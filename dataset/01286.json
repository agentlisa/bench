{
  "Title": "M-6: Invalid oracle version can cause the vault to open too large and risky position and get liquidated due to using unadjusted global current position",
  "Content": "# Issue M-6: Invalid oracle version can cause the vault to open too large and risky position and get liquidated due to using unadjusted global current position \n\nSource: https://github.com/sherlock-audit/2023-09-perennial-judging/issues/55 \n\n## Found by \npanprog\n\nThe fix to [issue 49 of the main contest](https://github.com/sherlock-audit/2023-07-perennial-judging/issues/49) introduced new invalidation system, which stores invalidation accumulator for all positions. This means that `market.pendingPosition()` returns unadjusted global position which might be completely wrong.\n\nThe problem is that `Vault` (`StrategyLib`) uses `market.pendingPosition(global.currentId)` without adjusting it, which leads to incorrect current global position right after invalid oracle version (which creates different invalidation values for latest and current positions). This incorrect global position can lead to inflated position limits enforced in the market and vault opening too large risky position with very high leverage, which might liquidate the vault leading to loss of funds for vault users.\n\n## Vulnerability Detail\n\n`StrategyLib._loadContext` for the market loads `currentPosition` as:\n```solidity\ncontext.currentPosition = registration.market.pendingPosition(global.currentId);\n```\n\nHowever, this is unadjusted position, so its value is incorrect if invalid oracle version happens while this position is pending.\n\nLater on, when calculating minimum and maxmium positions enforced by the vault in the market, they're calculated in `_positionLimit`:\n```solidity\nfunction _positionLimit(MarketContext memory context) private pure returns (UFixed6, UFixed6) {\n    return (\n        // minimum position size before crossing the net position\n        context.currentAccountPosition.maker.sub(\n            context.currentPosition.maker\n                .sub(context.currentPosition.net().min(context.currentPosition.maker))\n                .min(context.currentAccountPosition.maker)\n                .min(context.closable)\n        ),\n        // maximum position size before crossing the maker limit\n        context.currentAccountPosition.maker.add(\n            context.riskParameter.makerLimit\n                .sub(context.currentPosition.maker.min(context.riskParameter.makerLimit))\n        )\n    );\n}\n```\n\nAnd the target maker size for the market is set in `allocate`:\n```solidity\n(targets[marketId].collateral, targets[marketId].position) = (\n    Fixed6Lib.from(_locals.marketCollateral).sub(contexts[marketId].local.collateral),\n    _locals.marketAssets\n        .muldiv(registrations[marketId].leverage, contexts[marketId].latestPrice.abs())\n        .min(_locals.maxPosition)\n        .max(_locals.minPosition)\n);\n```\n\nSince `context.currentPosition` is incorrect, it can happen that both `_locals.minPosition` and `_locals.maxPosition` are too high, the vault will open too large and risky position, breaking its risk limit and possibly getting liquidated, especially if it happens during high volatility.\n\n## Impact\n\nIf invalid oracle version happens, the vault might open too large and risky position in such market, potentially getting liquidated and vault users losing funds due to this liquidation.\n\n## Code Snippet\n\n`StrategyLib._loadContext` loads current global position without adjusting it, meaning `context.currentPosition` is incorrect if invalid oracle version happens:\nhttps://github.com/sherlock-audit/2023-09-perennial/blob/main/perennial-v2/packages/perennial-vault/contracts/lib/StrategyLib.sol#L131\n\nThis leads to incorrect position limit calculations:\nhttps://github.com/sherlock-audit/2023-09-perennial/blob/main/perennial-v2/packages/perennial-vault/contracts/lib/StrategyLib.sol#L172-L187\n\nThis, in turn, leads to incorrect target vault's position calculation for the market:\nhttps://github.com/sherlock-audit/2023-09-perennial/blob/main/perennial-v2/packages/perennial-vault/contracts/lib/StrategyLib.sol#L93-L99\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdjust global current position after loading it:\n```solidity\n    context.currentPosition = registration.market.pendingPosition(global.currentId);\n+   context.currentPosition.adjust(registration.market.position());\n```\n\n\n\n## Discussion\n\n**kbrizzle**\n\nFixed in: https://github.com/equilibria-xyz/perennial-v2/pull/109.\n\nPlease note there were additional pending positions that required adjustment.\n\n**panprog**\n\nFixed\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/112",
  "Code": [
    {
      "filename": "perennial-v2/packages/perennial-vault/contracts/lib/StrategyLib.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../types/Registration.sol\";\n\n/// @title Strategy\n/// @notice Logic for vault capital allocation\n/// @dev - Deploys collateral first to satisfy the margin of each market, then deploys the rest by weight.\n///      - Positions are then targeted based on the amount of collateral that ends up deployed to each market.\nlibrary StrategyLib {\n    /// @dev The maximum multiplier that is allowed for leverage\n    UFixed6 public constant LEVERAGE_BUFFER = UFixed6.wrap(1.2e6);\n\n    /// @dev The context of an underlying market\n    struct MarketContext {\n        /// @dev The market parameter set\n        MarketParameter marketParameter;\n\n        /// @dev The risk parameter set\n        RiskParameter riskParameter;\n\n        /// @dev The local state of the vault\n        Local local;\n\n        /// @dev The vault's current account position\n        Position currentAccountPosition;\n\n        /// @dev The vault's latest account position\n        Position latestAccountPosition;\n\n        /// @dev The current global position\n        Position currentPosition;\n\n        /// @dev The latest valid price\n        Fixed6 latestPrice;\n\n        /// @dev The margin requirement of the vault\n        UFixed6 margin;\n\n        /// @dev The current closable amount of the vault\n        UFixed6 closable;\n    }\n\n    /// @dev The target allocation for a market\n    struct MarketTarget {\n        /// @dev The amount of change in collateral\n        Fixed6 collateral;\n\n        /// @dev The new position\n        UFixed6 position;\n    }\n\n    /// @dev Internal struct to avoid stack to deep error\n    struct _AllocateLocals {\n        UFixed6 marketCollateral;\n        UFixed6 marketAssets;\n        UFixed6 minPosition;\n        UFixed6 maxPosition;\n    }\n\n    /// @notice Compute the target allocation for each market\n    /// @param registrations The registrations of the markets\n    /// @param collateral The amount of collateral to allocate\n    /// @param assets The amount of collateral that is eligible for positions\n    function allocate(\n        Registration[] memory registrations,\n        UFixed6 collateral,\n        UFixed6 assets\n    ) internal view returns (MarketTarget[] memory targets) {\n        MarketContext[] memory contexts = new MarketContext[](registrations.length);\n        for (uint256 marketId; marketId < registrations.length; marketId++)\n            contexts[marketId] = _loadContext(registrations[marketId]);\n\n        (uint256 totalWeight, UFixed6 totalMargin) = _aggregate(registrations, contexts);\n\n        targets = new MarketTarget[](registrations.length);\n        for (uint256 marketId; marketId < registrations.length; marketId++) {\n            _AllocateLocals memory _locals;\n            _locals.marketCollateral = contexts[marketId].margin\n                .add(collateral.sub(totalMargin).muldiv(registrations[marketId].weight, totalWeight));\n\n            _locals.marketAssets = assets\n                .muldiv(registrations[marketId].weight, totalWeight)\n                .min(_locals.marketCollateral.mul(LEVERAGE_BUFFER));\n\n            UFixed6 minAssets = contexts[marketId].riskParameter.minMargin\n                .unsafeDiv(registrations[marketId].leverage.mul(contexts[marketId].riskParameter.maintenance));\n            if (contexts[marketId].marketParameter.closed || _locals.marketAssets.lt(minAssets))\n                _locals.marketAssets = UFixed6Lib.ZERO;\n\n            (_locals.minPosition, _locals.maxPosition) = _positionLimit(contexts[marketId]);\n\n            (targets[marketId].collateral, targets[marketId].position) = (\n                Fixed6Lib.from(_locals.marketCollateral).sub(contexts[marketId].local.collateral),\n                _locals.marketAssets\n                    .muldiv(registrations[marketId].leverage, contexts[marketId].latestPrice.abs())\n                    .min(_locals.maxPosition)\n                    .max(_locals.minPosition)\n            );\n        }\n    }\n\n    /// @notice Load the context of a market\n    /// @param registration The registration of the market\n    /// @return context The context of the market\n    function _loadContext(Registration memory registration) private view returns (MarketContext memory context) {\n        context.marketParameter = registration.market.parameter();\n        context.riskParameter = registration.market.riskParameter();\n        context.local = registration.market.locals(address(this));\n        Global memory global = registration.market.global();\n        context.latestPrice = global.latestPrice;\n\n        // latest position\n        UFixed6 previousClosable;\n        previousClosable = _loadPosition(\n            context,\n            context.latestAccountPosition = registration.market.positions(address(this)),\n            previousClosable\n        );\n        context.closable = context.latestAccountPosition.maker;\n\n        // pending positions\n        for (uint256 id = context.local.latestId + 1; id <= context.local.currentId; id++)\n            previousClosable = _loadPosition(\n                context,\n                context.currentAccountPosition = registration.market.pendingPositions(address(this), id),\n                previousClosable\n            );\n\n        // current position\n        context.currentPosition = registration.market.pendingPosition(global.currentId);\n    }\n\n    /// @notice Loads one position for the context calculation\n    /// @param context The context of the market\n    /// @param position The position to load\n    /// @param previousMaker The previous maker position\n    /// @return nextMaker The next maker position\n    function _loadPosition(\n        MarketContext memory context,\n        Position memory position,\n        UFixed6 previousMaker\n    ) private pure returns (UFixed6 nextMaker) {\n        position.adjust(context.latestAccountPosition);\n\n        context.margin = position\n            .margin(OracleVersion(0, context.latestPrice, true), context.riskParameter)\n            .max(context.margin);\n        context.closable = context.closable.sub(previousMaker.sub(position.maker.min(previousMaker)));\n        nextMaker = position.maker;\n    }\n\n    /// @notice Aggregate the context of all markets\n    /// @param registrations The registrations of the markets\n    /// @param contexts The contexts of the markets\n    /// @return totalWeight The total weight of all markets\n    /// @return totalMargin The total margin of all markets\n    function _aggregate(\n        Registration[] memory registrations,\n        MarketContext[] memory contexts\n    ) private pure returns (uint256 totalWeight, UFixed6 totalMargin) {\n        for (uint256 marketId; marketId < registrations.length; marketId++) {\n            totalWeight += registrations[marketId].weight;\n            totalMargin = totalMargin.add(contexts[marketId].margin);\n        }\n    }\n\n    /// @notice Compute the position limit of a market\n    /// @param context The context of the market\n    /// @return The minimum position size before crossing the net position\n    /// @return The maximum position size before crossing the maker limit\n    function _positionLimit(MarketContext memory context) private pure returns (UFixed6, UFixed6) {\n        return (\n            // minimum position size before crossing the net position\n            context.currentAccountPosition.maker.sub(\n                context.currentPosition.maker\n                    .sub(context.currentPosition.net().min(context.currentPosition.maker))\n                    .min(context.currentAccountPosition.maker)\n                    .min(context.closable)\n            ),\n            // maximum position size before crossing the maker limit\n            context.currentAccountPosition.maker.add(\n                context.riskParameter.makerLimit\n                    .sub(context.currentPosition.maker.min(context.riskParameter.makerLimit))\n            )\n        );\n    }\n}"
    },
    {
      "filename": "perennial-v2/packages/perennial-vault/contracts/lib/StrategyLib.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../types/Registration.sol\";\n\n/// @title Strategy\n/// @notice Logic for vault capital allocation\n/// @dev - Deploys collateral first to satisfy the margin of each market, then deploys the rest by weight.\n///      - Positions are then targeted based on the amount of collateral that ends up deployed to each market.\nlibrary StrategyLib {\n    /// @dev The maximum multiplier that is allowed for leverage\n    UFixed6 public constant LEVERAGE_BUFFER = UFixed6.wrap(1.2e6);\n\n    /// @dev The context of an underlying market\n    struct MarketContext {\n        /// @dev The market parameter set\n        MarketParameter marketParameter;\n\n        /// @dev The risk parameter set\n        RiskParameter riskParameter;\n\n        /// @dev The local state of the vault\n        Local local;\n\n        /// @dev The vault's current account position\n        Position currentAccountPosition;\n\n        /// @dev The vault's latest account position\n        Position latestAccountPosition;\n\n        /// @dev The current global position\n        Position currentPosition;\n\n        /// @dev The latest valid price\n        Fixed6 latestPrice;\n\n        /// @dev The margin requirement of the vault\n        UFixed6 margin;\n\n        /// @dev The current closable amount of the vault\n        UFixed6 closable;\n    }\n\n    /// @dev The target allocation for a market\n    struct MarketTarget {\n        /// @dev The amount of change in collateral\n        Fixed6 collateral;\n\n        /// @dev The new position\n        UFixed6 position;\n    }\n\n    /// @dev Internal struct to avoid stack to deep error\n    struct _AllocateLocals {\n        UFixed6 marketCollateral;\n        UFixed6 marketAssets;\n        UFixed6 minPosition;\n        UFixed6 maxPosition;\n    }\n\n    /// @notice Compute the target allocation for each market\n    /// @param registrations The registrations of the markets\n    /// @param collateral The amount of collateral to allocate\n    /// @param assets The amount of collateral that is eligible for positions\n    function allocate(\n        Registration[] memory registrations,\n        UFixed6 collateral,\n        UFixed6 assets\n    ) internal view returns (MarketTarget[] memory targets) {\n        MarketContext[] memory contexts = new MarketContext[](registrations.length);\n        for (uint256 marketId; marketId < registrations.length; marketId++)\n            contexts[marketId] = _loadContext(registrations[marketId]);\n\n        (uint256 totalWeight, UFixed6 totalMargin) = _aggregate(registrations, contexts);\n\n        targets = new MarketTarget[](registrations.length);\n        for (uint256 marketId; marketId < registrations.length; marketId++) {\n            _AllocateLocals memory _locals;\n            _locals.marketCollateral = contexts[marketId].margin\n                .add(collateral.sub(totalMargin).muldiv(registrations[marketId].weight, totalWeight));\n\n            _locals.marketAssets = assets\n                .muldiv(registrations[marketId].weight, totalWeight)\n                .min(_locals.marketCollateral.mul(LEVERAGE_BUFFER));\n\n            UFixed6 minAssets = contexts[marketId].riskParameter.minMargin\n                .unsafeDiv(registrations[marketId].leverage.mul(contexts[marketId].riskParameter.maintenance));\n            if (contexts[marketId].marketParameter.closed || _locals.marketAssets.lt(minAssets))\n                _locals.marketAssets = UFixed6Lib.ZERO;\n\n            (_locals.minPosition, _locals.maxPosition) = _positionLimit(contexts[marketId]);\n\n            (targets[marketId].collateral, targets[marketId].position) = (\n                Fixed6Lib.from(_locals.marketCollateral).sub(contexts[marketId].local.collateral),\n                _locals.marketAssets\n                    .muldiv(registrations[marketId].leverage, contexts[marketId].latestPrice.abs())\n                    .min(_locals.maxPosition)\n                    .max(_locals.minPosition)\n            );\n        }\n    }\n\n    /// @notice Load the context of a market\n    /// @param registration The registration of the market\n    /// @return context The context of the market\n    function _loadContext(Registration memory registration) private view returns (MarketContext memory context) {\n        context.marketParameter = registration.market.parameter();\n        context.riskParameter = registration.market.riskParameter();\n        context.local = registration.market.locals(address(this));\n        Global memory global = registration.market.global();\n        context.latestPrice = global.latestPrice;\n\n        // latest position\n        UFixed6 previousClosable;\n        previousClosable = _loadPosition(\n            context,\n            context.latestAccountPosition = registration.market.positions(address(this)),\n            previousClosable\n        );\n        context.closable = context.latestAccountPosition.maker;\n\n        // pending positions\n        for (uint256 id = context.local.latestId + 1; id <= context.local.currentId; id++)\n            previousClosable = _loadPosition(\n                context,\n                context.currentAccountPosition = registration.market.pendingPositions(address(this), id),\n                previousClosable\n            );\n\n        // current position\n        context.currentPosition = registration.market.pendingPosition(global.currentId);\n    }\n\n    /// @notice Loads one position for the context calculation\n    /// @param context The context of the market\n    /// @param position The position to load\n    /// @param previousMaker The previous maker position\n    /// @return nextMaker The next maker position\n    function _loadPosition(\n        MarketContext memory context,\n        Position memory position,\n        UFixed6 previousMaker\n    ) private pure returns (UFixed6 nextMaker) {\n        position.adjust(context.latestAccountPosition);\n\n        context.margin = position\n            .margin(OracleVersion(0, context.latestPrice, true), context.riskParameter)\n            .max(context.margin);\n        context.closable = context.closable.sub(previousMaker.sub(position.maker.min(previousMaker)));\n        nextMaker = position.maker;\n    }\n\n    /// @notice Aggregate the context of all markets\n    /// @param registrations The registrations of the markets\n    /// @param contexts The contexts of the markets\n    /// @return totalWeight The total weight of all markets\n    /// @return totalMargin The total margin of all markets\n    function _aggregate(\n        Registration[] memory registrations,\n        MarketContext[] memory contexts\n    ) private pure returns (uint256 totalWeight, UFixed6 totalMargin) {\n        for (uint256 marketId; marketId < registrations.length; marketId++) {\n            totalWeight += registrations[marketId].weight;\n            totalMargin = totalMargin.add(contexts[marketId].margin);\n        }\n    }\n\n    /// @notice Compute the position limit of a market\n    /// @param context The context of the market\n    /// @return The minimum position size before crossing the net position\n    /// @return The maximum position size before crossing the maker limit\n    function _positionLimit(MarketContext memory context) private pure returns (UFixed6, UFixed6) {\n        return (\n            // minimum position size before crossing the net position\n            context.currentAccountPosition.maker.sub(\n                context.currentPosition.maker\n                    .sub(context.currentPosition.net().min(context.currentPosition.maker))\n                    .min(context.currentAccountPosition.maker)\n                    .min(context.closable)\n            ),\n            // maximum position size before crossing the maker limit\n            context.currentAccountPosition.maker.add(\n                context.riskParameter.makerLimit\n                    .sub(context.currentPosition.maker.min(context.riskParameter.makerLimit))\n            )\n        );\n    }\n}"
    },
    {
      "filename": "perennial-v2/packages/perennial-vault/contracts/lib/StrategyLib.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../types/Registration.sol\";\n\n/// @title Strategy\n/// @notice Logic for vault capital allocation\n/// @dev - Deploys collateral first to satisfy the margin of each market, then deploys the rest by weight.\n///      - Positions are then targeted based on the amount of collateral that ends up deployed to each market.\nlibrary StrategyLib {\n    /// @dev The maximum multiplier that is allowed for leverage\n    UFixed6 public constant LEVERAGE_BUFFER = UFixed6.wrap(1.2e6);\n\n    /// @dev The context of an underlying market\n    struct MarketContext {\n        /// @dev The market parameter set\n        MarketParameter marketParameter;\n\n        /// @dev The risk parameter set\n        RiskParameter riskParameter;\n\n        /// @dev The local state of the vault\n        Local local;\n\n        /// @dev The vault's current account position\n        Position currentAccountPosition;\n\n        /// @dev The vault's latest account position\n        Position latestAccountPosition;\n\n        /// @dev The current global position\n        Position currentPosition;\n\n        /// @dev The latest valid price\n        Fixed6 latestPrice;\n\n        /// @dev The margin requirement of the vault\n        UFixed6 margin;\n\n        /// @dev The current closable amount of the vault\n        UFixed6 closable;\n    }\n\n    /// @dev The target allocation for a market\n    struct MarketTarget {\n        /// @dev The amount of change in collateral\n        Fixed6 collateral;\n\n        /// @dev The new position\n        UFixed6 position;\n    }\n\n    /// @dev Internal struct to avoid stack to deep error\n    struct _AllocateLocals {\n        UFixed6 marketCollateral;\n        UFixed6 marketAssets;\n        UFixed6 minPosition;\n        UFixed6 maxPosition;\n    }\n\n    /// @notice Compute the target allocation for each market\n    /// @param registrations The registrations of the markets\n    /// @param collateral The amount of collateral to allocate\n    /// @param assets The amount of collateral that is eligible for positions\n    function allocate(\n        Registration[] memory registrations,\n        UFixed6 collateral,\n        UFixed6 assets\n    ) internal view returns (MarketTarget[] memory targets) {\n        MarketContext[] memory contexts = new MarketContext[](registrations.length);\n        for (uint256 marketId; marketId < registrations.length; marketId++)\n            contexts[marketId] = _loadContext(registrations[marketId]);\n\n        (uint256 totalWeight, UFixed6 totalMargin) = _aggregate(registrations, contexts);\n\n        targets = new MarketTarget[](registrations.length);\n        for (uint256 marketId; marketId < registrations.length; marketId++) {\n            _AllocateLocals memory _locals;\n            _locals.marketCollateral = contexts[marketId].margin\n                .add(collateral.sub(totalMargin).muldiv(registrations[marketId].weight, totalWeight));\n\n            _locals.marketAssets = assets\n                .muldiv(registrations[marketId].weight, totalWeight)\n                .min(_locals.marketCollateral.mul(LEVERAGE_BUFFER));\n\n            UFixed6 minAssets = contexts[marketId].riskParameter.minMargin\n                .unsafeDiv(registrations[marketId].leverage.mul(contexts[marketId].riskParameter.maintenance));\n            if (contexts[marketId].marketParameter.closed || _locals.marketAssets.lt(minAssets))\n                _locals.marketAssets = UFixed6Lib.ZERO;\n\n            (_locals.minPosition, _locals.maxPosition) = _positionLimit(contexts[marketId]);\n\n            (targets[marketId].collateral, targets[marketId].position) = (\n                Fixed6Lib.from(_locals.marketCollateral).sub(contexts[marketId].local.collateral),\n                _locals.marketAssets\n                    .muldiv(registrations[marketId].leverage, contexts[marketId].latestPrice.abs())\n                    .min(_locals.maxPosition)\n                    .max(_locals.minPosition)\n            );\n        }\n    }\n\n    /// @notice Load the context of a market\n    /// @param registration The registration of the market\n    /// @return context The context of the market\n    function _loadContext(Registration memory registration) private view returns (MarketContext memory context) {\n        context.marketParameter = registration.market.parameter();\n        context.riskParameter = registration.market.riskParameter();\n        context.local = registration.market.locals(address(this));\n        Global memory global = registration.market.global();\n        context.latestPrice = global.latestPrice;\n\n        // latest position\n        UFixed6 previousClosable;\n        previousClosable = _loadPosition(\n            context,\n            context.latestAccountPosition = registration.market.positions(address(this)),\n            previousClosable\n        );\n        context.closable = context.latestAccountPosition.maker;\n\n        // pending positions\n        for (uint256 id = context.local.latestId + 1; id <= context.local.currentId; id++)\n            previousClosable = _loadPosition(\n                context,\n                context.currentAccountPosition = registration.market.pendingPositions(address(this), id),\n                previousClosable\n            );\n\n        // current position\n        context.currentPosition = registration.market.pendingPosition(global.currentId);\n    }\n\n    /// @notice Loads one position for the context calculation\n    /// @param context The context of the market\n    /// @param position The position to load\n    /// @param previousMaker The previous maker position\n    /// @return nextMaker The next maker position\n    function _loadPosition(\n        MarketContext memory context,\n        Position memory position,\n        UFixed6 previousMaker\n    ) private pure returns (UFixed6 nextMaker) {\n        position.adjust(context.latestAccountPosition);\n\n        context.margin = position\n            .margin(OracleVersion(0, context.latestPrice, true), context.riskParameter)\n            .max(context.margin);\n        context.closable = context.closable.sub(previousMaker.sub(position.maker.min(previousMaker)));\n        nextMaker = position.maker;\n    }\n\n    /// @notice Aggregate the context of all markets\n    /// @param registrations The registrations of the markets\n    /// @param contexts The contexts of the markets\n    /// @return totalWeight The total weight of all markets\n    /// @return totalMargin The total margin of all markets\n    function _aggregate(\n        Registration[] memory registrations,\n        MarketContext[] memory contexts\n    ) private pure returns (uint256 totalWeight, UFixed6 totalMargin) {\n        for (uint256 marketId; marketId < registrations.length; marketId++) {\n            totalWeight += registrations[marketId].weight;\n            totalMargin = totalMargin.add(contexts[marketId].margin);\n        }\n    }\n\n    /// @notice Compute the position limit of a market\n    /// @param context The context of the market\n    /// @return The minimum position size before crossing the net position\n    /// @return The maximum position size before crossing the maker limit\n    function _positionLimit(MarketContext memory context) private pure returns (UFixed6, UFixed6) {\n        return (\n            // minimum position size before crossing the net position\n            context.currentAccountPosition.maker.sub(\n                context.currentPosition.maker\n                    .sub(context.currentPosition.net().min(context.currentPosition.maker))\n                    .min(context.currentAccountPosition.maker)\n                    .min(context.closable)\n            ),\n            // maximum position size before crossing the maker limit\n            context.currentAccountPosition.maker.add(\n                context.riskParameter.makerLimit\n                    .sub(context.currentPosition.maker.min(context.riskParameter.makerLimit))\n            )\n        );\n    }\n}"
    }
  ]
}