{
  "Title": "[M-02] Violation of ERC-721 Standard in VerbsToken:tokenURI Implementation",
  "Content": "\nThe VerbsToken contract deviates from the ERC-721 standard, specifically in the `tokenURI` implementation. According to the standard, the `tokenURI` method must revert if a non-existent `tokenId` is passed. In the VerbsToken contract, this requirement was overlooked, leading to a violation of the EIP-721 specification and breaking the invariants declared in the protocol's README.\n\n### Proof of Concept\n\nThe responsibility for checking whether a token exists may be argued to be placed on the `descriptor`. However, the core VerbsToken contract, which is expected to adhere to the invariant stated in the Protocol's README, does not follow the specification.\n\n```markdown\n// File: README.md\n414:## EIP conformity\n415:\n416:- [VerbsToken](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/VerbsToken.sol): Should comply with `ERC721`\n```\n\nNote: the original [NounsToken](https://github.com/nounsDAO/nouns-monorepo/blob/61d2b50ce82bb060cf4281a55adddf47c5085881/packages/nouns-contracts/contracts/NounsToken.sol#L169) contract, which VerbsToken was forked from, did implement the `tokenURI` function properly.\n\n### Recommended Mitigation Steps\n\nIt is recommended to strictly adopt the implementation from the original NounsToken contract to ensure compliance with the ERC-721 standard.\n\n```patch\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n+        require(_exists(tokenId));\n        return descriptor.tokenURI(tokenId, artPieces[tokenId].metadata);\n    }\n```\n\n### References\n\n1.  [EIP-721 Standard](https://eips.ethereum.org/EIPS/eip-721)\n2.  [Code 423n4 Finding - Caviar](https://github.com/code-423n4/2023-04-caviar-findings/issues/44)\n3.  [Code 423n4 Finding - OpenDollar](https://github.com/code-423n4/2023-10-opendollar-findings/issues/243)\n4.  [NounsToken Contract Implementation](https://github.com/nounsDAO/nouns-monorepo/blob/61d2b50ce82bb060cf4281a55adddf47c5085881/packages/nouns-contracts/contracts/NounsToken.sol#L169)\n\n**[0xTheC0der (Judge) commented](https://github.com/code-423n4/2023-12-revolutionprotocol-findings/issues/471#issuecomment-1887506249):**\n >I felt obliged to award with Medium severity due to precedent EIP-721 tokenUri cases (see https://github.com/code-423n4/2023-12-revolutionprotocol-findings/issues/511#issuecomment-1883512625, one judged by Alex).\n> \n> This should be discussed during the next SC round.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-12-revolutionprotocol",
  "Code": [
    {
      "filename": "packages/nouns-contracts/contracts/NounsToken.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/// @title The Nouns ERC-721 token\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\npragma solidity ^0.8.6;\n\nimport { Ownable } from '@openzeppelin/contracts/access/Ownable.sol';\nimport { ERC721Checkpointable } from './base/ERC721Checkpointable.sol';\nimport { INounsDescriptorMinimal } from './interfaces/INounsDescriptorMinimal.sol';\nimport { INounsSeeder } from './interfaces/INounsSeeder.sol';\nimport { INounsToken } from './interfaces/INounsToken.sol';\nimport { ERC721 } from './base/ERC721.sol';\nimport { IERC721 } from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport { IProxyRegistry } from './external/opensea/IProxyRegistry.sol';\n\ncontract NounsToken is INounsToken, Ownable, ERC721Checkpointable {\n    // The nounders DAO address (creators org)\n    address public noundersDAO;\n\n    // An address who has permissions to mint Nouns\n    address public minter;\n\n    // The Nouns token URI descriptor\n    INounsDescriptorMinimal public descriptor;\n\n    // The Nouns token seeder\n    INounsSeeder public seeder;\n\n    // Whether the minter can be updated\n    bool public isMinterLocked;\n\n    // Whether the descriptor can be updated\n    bool public isDescriptorLocked;\n\n    // Whether the seeder can be updated\n    bool public isSeederLocked;\n\n    // The noun seeds\n    mapping(uint256 => INounsSeeder.Seed) public seeds;\n\n    // The internal noun ID tracker\n    uint256 private _currentNounId;\n\n    // IPFS content hash of contract-level metadata\n    string private _contractURIHash = 'QmZi1n79FqWt2tTLwCqiy6nLM6xLGRsEPQ5JmReJQKNNzX';\n\n    // OpenSea's Proxy Registry\n    IProxyRegistry public immutable proxyRegistry;\n\n    /**\n     * @notice Require that the minter has not been locked.\n     */\n    modifier whenMinterNotLocked() {\n        require(!isMinterLocked, 'Minter is locked');\n        _;\n    }\n\n    /**\n     * @notice Require that the descriptor has not been locked.\n     */\n    modifier whenDescriptorNotLocked() {\n        require(!isDescriptorLocked, 'Descriptor is locked');\n        _;\n    }\n\n    /**\n     * @notice Require that the seeder has not been locked.\n     */\n    modifier whenSeederNotLocked() {\n        require(!isSeederLocked, 'Seeder is locked');\n        _;\n    }\n\n    /**\n     * @notice Require that the sender is the nounders DAO.\n     */\n    modifier onlyNoundersDAO() {\n        require(msg.sender == noundersDAO, 'Sender is not the nounders DAO');\n        _;\n    }\n\n    /**\n     * @notice Require that the sender is the minter.\n     */\n    modifier onlyMinter() {\n        require(msg.sender == minter, 'Sender is not the minter');\n        _;\n    }\n\n    constructor(\n        address _noundersDAO,\n        address _minter,\n        INounsDescriptorMinimal _descriptor,\n        INounsSeeder _seeder,\n        IProxyRegistry _proxyRegistry\n    ) ERC721('Nouns', 'NOUN') {\n        noundersDAO = _noundersDAO;\n        minter = _minter;\n        descriptor = _descriptor;\n        seeder = _seeder;\n        proxyRegistry = _proxyRegistry;\n    }\n\n    /**\n     * @notice The IPFS URI of contract-level metadata.\n     */\n    function contractURI() public view returns (string memory) {\n        return string(abi.encodePacked('ipfs://', _contractURIHash));\n    }\n\n    /**\n     * @notice Set the _contractURIHash.\n     * @dev Only callable by the owner.\n     */\n    function setContractURIHash(string memory newContractURIHash) external onlyOwner {\n        _contractURIHash = newContractURIHash;\n    }\n\n    /**\n     * @notice Override isApprovedForAll to whitelist user's OpenSea proxy accounts to enable gas-less listings.\n     */\n    function isApprovedForAll(address owner, address operator) public view override(IERC721, ERC721) returns (bool) {\n        // Whitelist OpenSea proxy contract for easy trading.\n        if (proxyRegistry.proxies(owner) == operator) {\n            return true;\n        }\n        return super.isApprovedForAll(owner, operator);\n    }\n\n    /**\n     * @notice Mint a Noun to the minter, along with a possible nounders reward\n     * Noun. Nounders reward Nouns are minted every 10 Nouns, starting at 0,\n     * until 183 nounder Nouns have been minted (5 years w/ 24 hour auctions).\n     * @dev Call _mintTo with the to address(es).\n     */\n    function mint() public override onlyMinter returns (uint256) {\n        if (_currentNounId <= 1820 && _currentNounId % 10 == 0) {\n            _mintTo(noundersDAO, _currentNounId++);\n        }\n        return _mintTo(minter, _currentNounId++);\n    }\n\n    /**\n     * @notice Burn a noun.\n     */\n    function burn(uint256 nounId) public override onlyMinter {\n        _burn(nounId);\n        emit NounBurned(nounId);\n    }\n\n    /**\n     * @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        require(_exists(tokenId), 'NounsToken: URI query for nonexistent token');\n        return descriptor.tokenURI(tokenId, seeds[tokenId]);\n    }\n\n    /**\n     * @notice Similar to `tokenURI`, but always serves a base64 encoded data URI\n     * with the JSON contents directly inlined.\n     */\n    function dataURI(uint256 tokenId) public view override returns (string memory) {\n        require(_exists(tokenId), 'NounsToken: URI query for nonexistent token');\n        return descriptor.dataURI(tokenId, seeds[tokenId]);\n    }\n\n    /**\n     * @notice Set the nounders DAO.\n     * @dev Only callable by the nounders DAO when not locked.\n     */\n    function setNoundersDAO(address _noundersDAO) external onlyNoundersDAO {\n        noundersDAO = _noundersDAO;\n\n        emit NoundersDAOUpdated(_noundersDAO);\n    }\n\n    /**\n     * @notice Set the token minter.\n     * @dev Only callable by the owner when not locked.\n     */\n    function setMinter(address _minter) external override onlyOwner whenMinterNotLocked {\n        minter = _minter;\n\n        emit MinterUpdated(_minter);\n    }\n\n    /**\n     * @notice Lock the minter.\n     * @dev This cannot be reversed and is only callable by the owner when not locked.\n     */\n    function lockMinter() external override onlyOwner whenMinterNotLocked {\n        isMinterLocked = true;\n\n        emit MinterLocked();\n    }\n\n    /**\n     * @notice Set the token URI descriptor.\n     * @dev Only callable by the owner when not locked.\n     */\n    function setDescriptor(INounsDescriptorMinimal _descriptor) external override onlyOwner whenDescriptorNotLocked {\n        descriptor = _descriptor;\n\n        emit DescriptorUpdated(_descriptor);\n    }\n\n    /**\n     * @notice Lock the descriptor.\n     * @dev This cannot be reversed and is only callable by the owner when not locked.\n     */\n    function lockDescriptor() external override onlyOwner whenDescriptorNotLocked {\n        isDescriptorLocked = true;\n\n        emit DescriptorLocked();\n    }\n\n    /**\n     * @notice Set the token seeder.\n     * @dev Only callable by the owner when not locked.\n     */\n    function setSeeder(INounsSeeder _seeder) external override onlyOwner whenSeederNotLocked {\n        seeder = _seeder;\n\n        emit SeederUpdated(_seeder);\n    }\n\n    /**\n     * @notice Lock the seeder.\n     * @dev This cannot be reversed and is only callable by the owner when not locked.\n     */\n    function lockSeeder() external override onlyOwner whenSeederNotLocked {\n        isSeederLocked = true;\n\n        emit SeederLocked();\n    }\n\n    /**\n     * @notice Mint a Noun with `nounId` to the provided `to` address.\n     */\n    function _mintTo(address to, uint256 nounId) internal returns (uint256) {\n        INounsSeeder.Seed memory seed = seeds[nounId] = seeder.generateSeed(nounId, descriptor);\n\n        _mint(owner(), to, nounId);\n        emit NounCreated(nounId, seed);\n\n        return nounId;\n    }\n}"
    },
    {
      "filename": "packages/nouns-contracts/contracts/NounsToken.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/// @title The Nouns ERC-721 token\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\npragma solidity ^0.8.6;\n\nimport { Ownable } from '@openzeppelin/contracts/access/Ownable.sol';\nimport { ERC721Checkpointable } from './base/ERC721Checkpointable.sol';\nimport { INounsDescriptorMinimal } from './interfaces/INounsDescriptorMinimal.sol';\nimport { INounsSeeder } from './interfaces/INounsSeeder.sol';\nimport { INounsToken } from './interfaces/INounsToken.sol';\nimport { ERC721 } from './base/ERC721.sol';\nimport { IERC721 } from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport { IProxyRegistry } from './external/opensea/IProxyRegistry.sol';\n\ncontract NounsToken is INounsToken, Ownable, ERC721Checkpointable {\n    // The nounders DAO address (creators org)\n    address public noundersDAO;\n\n    // An address who has permissions to mint Nouns\n    address public minter;\n\n    // The Nouns token URI descriptor\n    INounsDescriptorMinimal public descriptor;\n\n    // The Nouns token seeder\n    INounsSeeder public seeder;\n\n    // Whether the minter can be updated\n    bool public isMinterLocked;\n\n    // Whether the descriptor can be updated\n    bool public isDescriptorLocked;\n\n    // Whether the seeder can be updated\n    bool public isSeederLocked;\n\n    // The noun seeds\n    mapping(uint256 => INounsSeeder.Seed) public seeds;\n\n    // The internal noun ID tracker\n    uint256 private _currentNounId;\n\n    // IPFS content hash of contract-level metadata\n    string private _contractURIHash = 'QmZi1n79FqWt2tTLwCqiy6nLM6xLGRsEPQ5JmReJQKNNzX';\n\n    // OpenSea's Proxy Registry\n    IProxyRegistry public immutable proxyRegistry;\n\n    /**\n     * @notice Require that the minter has not been locked.\n     */\n    modifier whenMinterNotLocked() {\n        require(!isMinterLocked, 'Minter is locked');\n        _;\n    }\n\n    /**\n     * @notice Require that the descriptor has not been locked.\n     */\n    modifier whenDescriptorNotLocked() {\n        require(!isDescriptorLocked, 'Descriptor is locked');\n        _;\n    }\n\n    /**\n     * @notice Require that the seeder has not been locked.\n     */\n    modifier whenSeederNotLocked() {\n        require(!isSeederLocked, 'Seeder is locked');\n        _;\n    }\n\n    /**\n     * @notice Require that the sender is the nounders DAO.\n     */\n    modifier onlyNoundersDAO() {\n        require(msg.sender == noundersDAO, 'Sender is not the nounders DAO');\n        _;\n    }\n\n    /**\n     * @notice Require that the sender is the minter.\n     */\n    modifier onlyMinter() {\n        require(msg.sender == minter, 'Sender is not the minter');\n        _;\n    }\n\n    constructor(\n        address _noundersDAO,\n        address _minter,\n        INounsDescriptorMinimal _descriptor,\n        INounsSeeder _seeder,\n        IProxyRegistry _proxyRegistry\n    ) ERC721('Nouns', 'NOUN') {\n        noundersDAO = _noundersDAO;\n        minter = _minter;\n        descriptor = _descriptor;\n        seeder = _seeder;\n        proxyRegistry = _proxyRegistry;\n    }\n\n    /**\n     * @notice The IPFS URI of contract-level metadata.\n     */\n    function contractURI() public view returns (string memory) {\n        return string(abi.encodePacked('ipfs://', _contractURIHash));\n    }\n\n    /**\n     * @notice Set the _contractURIHash.\n     * @dev Only callable by the owner.\n     */\n    function setContractURIHash(string memory newContractURIHash) external onlyOwner {\n        _contractURIHash = newContractURIHash;\n    }\n\n    /**\n     * @notice Override isApprovedForAll to whitelist user's OpenSea proxy accounts to enable gas-less listings.\n     */\n    function isApprovedForAll(address owner, address operator) public view override(IERC721, ERC721) returns (bool) {\n        // Whitelist OpenSea proxy contract for easy trading.\n        if (proxyRegistry.proxies(owner) == operator) {\n            return true;\n        }\n        return super.isApprovedForAll(owner, operator);\n    }\n\n    /**\n     * @notice Mint a Noun to the minter, along with a possible nounders reward\n     * Noun. Nounders reward Nouns are minted every 10 Nouns, starting at 0,\n     * until 183 nounder Nouns have been minted (5 years w/ 24 hour auctions).\n     * @dev Call _mintTo with the to address(es).\n     */\n    function mint() public override onlyMinter returns (uint256) {\n        if (_currentNounId <= 1820 && _currentNounId % 10 == 0) {\n            _mintTo(noundersDAO, _currentNounId++);\n        }\n        return _mintTo(minter, _currentNounId++);\n    }\n\n    /**\n     * @notice Burn a noun.\n     */\n    function burn(uint256 nounId) public override onlyMinter {\n        _burn(nounId);\n        emit NounBurned(nounId);\n    }\n\n    /**\n     * @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        require(_exists(tokenId), 'NounsToken: URI query for nonexistent token');\n        return descriptor.tokenURI(tokenId, seeds[tokenId]);\n    }\n\n    /**\n     * @notice Similar to `tokenURI`, but always serves a base64 encoded data URI\n     * with the JSON contents directly inlined.\n     */\n    function dataURI(uint256 tokenId) public view override returns (string memory) {\n        require(_exists(tokenId), 'NounsToken: URI query for nonexistent token');\n        return descriptor.dataURI(tokenId, seeds[tokenId]);\n    }\n\n    /**\n     * @notice Set the nounders DAO.\n     * @dev Only callable by the nounders DAO when not locked.\n     */\n    function setNoundersDAO(address _noundersDAO) external onlyNoundersDAO {\n        noundersDAO = _noundersDAO;\n\n        emit NoundersDAOUpdated(_noundersDAO);\n    }\n\n    /**\n     * @notice Set the token minter.\n     * @dev Only callable by the owner when not locked.\n     */\n    function setMinter(address _minter) external override onlyOwner whenMinterNotLocked {\n        minter = _minter;\n\n        emit MinterUpdated(_minter);\n    }\n\n    /**\n     * @notice Lock the minter.\n     * @dev This cannot be reversed and is only callable by the owner when not locked.\n     */\n    function lockMinter() external override onlyOwner whenMinterNotLocked {\n        isMinterLocked = true;\n\n        emit MinterLocked();\n    }\n\n    /**\n     * @notice Set the token URI descriptor.\n     * @dev Only callable by the owner when not locked.\n     */\n    function setDescriptor(INounsDescriptorMinimal _descriptor) external override onlyOwner whenDescriptorNotLocked {\n        descriptor = _descriptor;\n\n        emit DescriptorUpdated(_descriptor);\n    }\n\n    /**\n     * @notice Lock the descriptor.\n     * @dev This cannot be reversed and is only callable by the owner when not locked.\n     */\n    function lockDescriptor() external override onlyOwner whenDescriptorNotLocked {\n        isDescriptorLocked = true;\n\n        emit DescriptorLocked();\n    }\n\n    /**\n     * @notice Set the token seeder.\n     * @dev Only callable by the owner when not locked.\n     */\n    function setSeeder(INounsSeeder _seeder) external override onlyOwner whenSeederNotLocked {\n        seeder = _seeder;\n\n        emit SeederUpdated(_seeder);\n    }\n\n    /**\n     * @notice Lock the seeder.\n     * @dev This cannot be reversed and is only callable by the owner when not locked.\n     */\n    function lockSeeder() external override onlyOwner whenSeederNotLocked {\n        isSeederLocked = true;\n\n        emit SeederLocked();\n    }\n\n    /**\n     * @notice Mint a Noun with `nounId` to the provided `to` address.\n     */\n    function _mintTo(address to, uint256 nounId) internal returns (uint256) {\n        INounsSeeder.Seed memory seed = seeds[nounId] = seeder.generateSeed(nounId, descriptor);\n\n        _mint(owner(), to, nounId);\n        emit NounCreated(nounId, seed);\n\n        return nounId;\n    }\n}"
    }
  ]
}