{
  "Title": "[L09] Lack of input validation",
  "Content": "There are several places in the code base where input parameters are passed in function calls without any kind of validation of their values. Examples are:\n\n\n* The `amount` variable of the [`stake`](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/incentivizer/Incentivizer.sol#L284) and [`withdraw`](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/incentivizer/Incentivizer.sol#L302) functions from the `Incentivizer` contract is not validated to be non zero.\n* The [`propose`](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/governance/GovernerAlpha.sol#L168) function from the `GovernorAlpha` contract is not checking whether the `description` is empty or not.\n* The [`approve`](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/governance/Stake.sol#L159) function from the `Stake` contract is not validating the `spender` input parameter.\n\n\nEven though this issue does not pose a security risk, the lack of validation on user-controlled parameters may result in erroneous transactions or useless use of gas.\n\n\nConsider adding proper checks on the values passed in function calls.\n\n\n***Update**: Partially fixed on [pull request 9](https://github.com/emptysetsquad/emptyset/pull/9/commits/badf2f5dc430a75e04aa794c82c452eb1b15609c). The `GovernorAlpha` and `Stake` contracts have not been changed. The EmptySetSquad team statement for this issue:*\n\n\n\n> \n> *Leaves GovernorAlpha and Stake as-is to not modify forked code unnecessarily.*\n> \n> \n> \n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/src/incentivizer/Incentivizer.sol",
      "content": "/*\n    Copyright 2021 Empty Set Squad <emptysetsquad@protonmail.com>\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"../lib/Decimal.sol\";\n\n/**\n * @title Incentivizer\n * @notice Generic incentivization contract that allows one ERC20 to be staked while earning\n *         either the same ERC20 or a different ERC20 as a reward\n * @dev Reward program can be adjusted or ended at any time through governance as long as there\n *      is sufficient balance. Architecture based off the Synthetix StakingRewards contract:\n *      https://github.com/Synthetixio/synthetix/blob/master/contracts/StakingRewards.sol\n */\ncontract Incentivizer is Ownable, ReentrancyGuard {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using Decimal for Decimal.D256;\n\n    /**\n     * @notice Emitted when the reward program is updated with a rate `rate` completing `complete`\n     */\n    event RewardProgramUpdate(uint256 rate, uint256 complete);\n\n    /**\n     * @notice Emitted when the owner rescues `amount` of `token`\n     */\n    event Rescue(address token, uint256 amount);\n\n    /**\n     * @notice Emitted on reward accrual when `newReward` reward tokens are dispersed at\n     *         timestamp `updated`, updating the rewards per unit to `rewardPerUnit`\n     */\n    event Settle(uint256 rewardPerUnit, uint256 newReward, uint256 updated);\n\n    /**\n     * @notice Emitted on when `account` stakes `amount` of the underlying token\n     */\n    event Stake(address account, uint256 amount);\n\n    /**\n     * @notice Emitted on when `account` withdraws `amount` of the underlying token\n     */\n    event Withdrawal(address account, uint256 amount);\n\n    /**\n     * @notice Emitted on when `account` claims `amount` of the reward token\n     */\n    event Claim(address account, uint256 amount);\n\n    /**\n     * @notice Address to receive rescued and refunded funds\n     */\n    address public reserve;\n\n    /**\n     * @notice ERC20 token that will be used as underlying for staking\n     */\n    IERC20 public underlyingToken;\n\n    /**\n     * @notice ERC20 token that will be dispersed as rewards\n     */\n    IERC20 public rewardToken;\n\n    /**\n     * @notice Quantity of  rewardToken` dispersed to the entire staking pool per second\n     */\n    uint256 public rewardRate;\n\n    /**\n     * @notice Timestamp the current reward program ends\n     */\n    uint256 public rewardComplete;\n\n    /**\n     * @notice Timestamp that reward accrual was last settled\n     */\n    uint256 public rewardUpdated;\n\n    /**\n     * @notice Mapping of underlying token balance per account\n     */\n    mapping(address => uint256) public balanceOfUnderlying;\n\n    /**\n     * @notice Total underlying token balance staked in this contract\n     */\n    uint256 public totalUnderlying;\n\n    /**\n     * @notice Total outstanding unclaimed rewards that have accrued so far\n     */\n    uint256 public totalReward;\n\n    /**\n     * @notice Mapping of settled reward balance per account\n     */\n    mapping(address => uint256) internal _reward;\n\n    /**\n     * @notice Mapping of rewards already paid out per account\n     */\n    mapping(address => Decimal.D256) internal _paid;\n\n    /**\n     * @notice Monotonically increasing accumulator to track the reward amount per unit of staked underlying\n     */\n    Decimal.D256 internal _rewardPerUnit;\n\n\n    /**\n     * @notice Constructs the Incentivizer\n     * @param underlying_ Underlying ERC20 token for staking\n     * @param reward_ Reward ERC20 token for rewards\n     * @notice reserve_ Address to receive rescued and refunded ERC20 tokens\n     */\n    constructor(IERC20 underlying_, IERC20 reward_, address reserve_) public {\n        reserve = reserve_;\n        underlyingToken = underlying_;\n        rewardToken = reward_;\n    }\n\n    // ADMIN\n\n    /**\n     * @notice Updates the rate and completion time for this contract's reward program\n     * @dev Owner only - governance hook\n     *      Insufficient funds will revert - excess funds will be refunded to {reserve}\n     * @param rate Reward token amount to disperse to enter staking pool per second\n     * @param complete Timestamp the reward program ends\n     */\n    function updateRewardProgram(uint256 rate, uint256 complete) external onlyOwner {\n        require(complete > block.timestamp, \"Incentivizer: already ended\");\n\n        settle();\n\n        // Set new reward rate\n        (rewardRate, rewardComplete, rewardUpdated) = (rate, complete, block.timestamp);\n\n        // Return rewards in excess of the required amount\n        rewardToken.safeTransfer(reserve, verifyRewardBalance());\n\n        emit RewardProgramUpdate(rate, complete);\n    }\n\n    /**\n     * @notice Allows the owner to withdraw stuck ERC20 tokens to {reserve}\n     * @dev Owner only - governance hook\n     *      Non-reentrant\n     *      Cannot withdraw the underlying token\n     *      Cannot withdraw more of the reward token than is needed for the current reward program\n     * @param token ERC20 token to withdraw\n     * @param amount Amount to withdraw\n     */\n    function rescue(address token, uint256 amount) external nonReentrant onlyOwner {\n        require(token != address(underlyingToken), \"Incentivizer: underlying token\");\n\n        IERC20(token).safeTransfer(reserve, amount);\n\n        verifyRewardBalance();\n\n        emit Rescue(token, amount);\n    }\n\n    /**\n     * @notice Verifies that there is sufficient reward tokens for the current reward program\n     * @dev Internal only - helper\n     *      Reverts if there is insufficient reward token funds\n     */\n    function verifyRewardBalance() private view returns (uint256) {\n        return _totalRewardBalance()\n            .sub(totalReward, \"Incentivizer: insufficient rewards\")\n            .sub(totalProvisionedReward(), \"Incentivizer: insufficient rewards\");\n    }\n\n    // FLYWHEEL\n\n    /**\n     * @notice Total rewards that have been provisioned for the current reward program,\n     *         but not yet settled or paid out\n     * @return Total provisioned rewards\n     */\n    function totalProvisionedReward() public view returns (uint256) {\n        uint256 complete = rewardComplete;\n        uint256 updated = rewardUpdated;\n\n        return complete > updated ? complete.sub(updated).mul(rewardRate) : 0;\n    }\n\n    /**\n     * @notice Returns either the current timestamp or the last applicable timestamp of the reward program\n     * @return Most recent reward-applicable timestamp\n     */\n    function nowOrComplete() public view returns (uint256) {\n        uint256 complete = rewardComplete;\n        uint256 latest = block.timestamp;\n\n        return latest > complete ? complete : latest;\n    }\n\n    /**\n     * @notice Monotonically increasing accumulator to track the reward amount per unit of staked underlying\n     * @dev Computes the current effective rewardPerUnit value as if there was a settlement now\n     * @return Effective rewards per unit\n     */\n    function rewardPerUnit() public view returns (Decimal.D256 memory) {\n        if (totalUnderlying == 0) {\n            return _rewardPerUnit;\n        } else {\n            return _rewardPerUnit\n                .add(Decimal.from(nowOrComplete().sub(rewardUpdated).mul(rewardRate)).div(totalUnderlying));\n        }\n    }\n\n    /**\n     * @notice Accrues and updates rewards since last settlement\n     * @dev Internal only\n     */\n    function settle() internal {\n        uint256 nowOrComplete = nowOrComplete();\n        Decimal.D256 memory newRewardPerUnit = rewardPerUnit();\n        uint256 newReward = newRewardPerUnit.sub(_rewardPerUnit).mul(totalUnderlying).asUint256();\n        uint256 newTotalReward = totalReward.add(newReward);\n\n        _rewardPerUnit = newRewardPerUnit;\n        totalReward = newTotalReward;\n        rewardUpdated = nowOrComplete;\n\n        emit Settle(newRewardPerUnit.value, newReward, nowOrComplete);\n    }\n\n    /**\n     * @notice Accrues and records rewards for `account` to simplify accounting math\n     * @dev Internal only\n     * @param account Account to settle rewards for\n     */\n    function settleAccount(address account) internal {\n        settle();\n\n        _reward[account] = balanceOfReward(account);\n        _paid[account] = _rewardPerUnit;\n    }\n\n    // EXTERNAL\n\n    /**\n     * @notice Balance of all accrued rewards (including unsettled) for `account`\n     * @param account Account to retrieve balance for\n     */\n    function balanceOfReward(address account) public view returns (uint256) {\n        return _reward[account].add(\n            rewardPerUnit().sub(_paid[account])      // Since last checkpoint\n                .mul(balanceOfUnderlying[account])   // Multiply per unit\n                .asUint256()                         // Convert and truncate\n        );\n    }\n\n    /**\n     * @notice Deposit `amount` underlying tokens to start accruing rewards\n     * @dev Non-reentrant\n     * @param amount Amount of underlying tokens for the caller to deposit\n     */\n    function stake(uint256 amount) external nonReentrant {\n        settleAccount(msg.sender);\n\n        // Increment account balance\n        balanceOfUnderlying[msg.sender] = balanceOfUnderlying[msg.sender].add(amount);\n        totalUnderlying = totalUnderlying.add(amount);\n\n        // Transfer in token amount\n        underlyingToken.safeTransferFrom(msg.sender, address(this), amount);\n\n        emit Stake(msg.sender, amount);\n    }\n\n    /**\n     * @notice Withdraw `amount` underlying tokens\n     * @dev Non-reentrant\n     * @param amount Amount of underlying tokens for the caller to withdraw\n     */\n    function withdraw(uint256 amount) public nonReentrant {\n        settleAccount(msg.sender);\n\n        // Decrement account balance\n        balanceOfUnderlying[msg.sender] = balanceOfUnderlying[msg.sender].sub(amount, \"Incentivizer: insufficient balance\");\n        totalUnderlying = totalUnderlying.sub(amount, \"Incentivizer: insufficient balance\");\n\n        // Transfer out token amount\n        underlyingToken.safeTransfer(msg.sender, amount);\n\n        emit Withdrawal(msg.sender, amount);\n    }\n\n    /**\n     * @notice Claim all accrued reward tokens for caller\n     * @dev Non-reentrant\n     */\n    function claim() public nonReentrant {\n        settleAccount(msg.sender);\n\n        uint256 rewardBalance = _reward[msg.sender];\n        rewardToken.safeTransfer(msg.sender, rewardBalance);\n\n        _reward[msg.sender] = 0;\n        totalReward = totalReward.sub(rewardBalance);\n\n        emit Claim(msg.sender, rewardBalance);\n    }\n\n    /**\n     * @notice Claim all accrued reward tokens withdraw all underlying tokens for caller\n     */\n    function exit() external {\n        withdraw(balanceOfUnderlying[msg.sender]);\n        claim();\n    }\n\n    // INTERNAL\n\n    /**\n     * @notice Total reward token holdings of this contract\n     * @dev If reward token == underlying token, this will subtract the total underlying amount from the balance\n     * @dev Internal only - helper\n     */\n    function _totalRewardBalance() private view returns (uint256) {\n        if (underlyingToken == rewardToken) {\n            uint256 totalBalance = rewardToken.balanceOf(address(this));\n            return totalBalance > totalUnderlying ? totalBalance - totalUnderlying : 0;\n        }\n\n        return rewardToken.balanceOf(address(this));\n    }\n}"
    },
    {
      "filename": "protocol/contracts/src/governance/GovernerAlpha.sol",
      "content": "/*\n    Copyright 2021 Empty Set Squad <emptysetsquad@protonmail.com>\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\n/*\n * audit-info: Forked from Compound's GovernorAlpha contract:\n *             https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/GovernorAlpha.sol\n *\n *             Sections that have been changed from the original have been denoted with audit notes\n *             Additionally \"Comp\" has been renamed to \"Stake\" throughout\n */\ncontract GovernorAlpha {\n    /*\n     * audit-info: Beginning of modified code section\n     */\n\n    /// @notice The name of this contract\n    string public constant name = \"Empty Set Dollar Governor Alpha\";\n\n    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n    /// @dev Initial ESDS supply will be approximately 1.6b - 2.0b depending on initial incentive programs\n    function quorumVotes() public pure returns (uint) { return 100000000e18; } // 100,000,000 = ~5% of Stake\n\n    /// @notice The number of votes required in order for a voter to become a proposer\n    function proposalThreshold() public pure returns (uint) { return 10000000e18; } // 10,000,000 = ~0.5% of Stake\n\n    /*\n     * audit-info: End of modified code section\n     */\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    function proposalMaxOperations() public pure returns (uint) { return 10; } // 10 actions\n\n    /// @notice The delay before voting on a proposal may take place, once proposed\n    function votingDelay() public pure returns (uint) { return 1; } // 1 block\n\n    /// @notice The duration of voting on a proposal, in blocks\n    function votingPeriod() public pure returns (uint) { return 17280; } // ~3 days in blocks (assuming 15s blocks)\n\n    /// @notice The address of the Empty Set Dollar Protocol Timelock\n    TimelockInterface public timelock;\n\n    /// @notice The address of the Empty Set Dollar governance token\n    StakeInterface public stake;\n\n    /// @notice The address of the Governor Guardian\n    address public guardian;\n\n    /// @notice The total number of proposals\n    uint public proposalCount;\n\n    struct Proposal {\n        /// @notice Unique id for looking up a proposal\n        uint id;\n\n        /// @notice Creator of the proposal\n        address proposer;\n\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint eta;\n\n        /// @notice the ordered list of target addresses for calls to be made\n        address[] targets;\n\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n        uint[] values;\n\n        /// @notice The ordered list of function signatures to be called\n        string[] signatures;\n\n        /// @notice The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n        uint startBlock;\n\n        /// @notice The block at which voting ends: votes must be cast prior to this block\n        uint endBlock;\n\n        /// @notice Current number of votes in favor of this proposal\n        uint forVotes;\n\n        /// @notice Current number of votes in opposition to this proposal\n        uint againstVotes;\n\n        /// @notice Flag marking whether the proposal has been canceled\n        bool canceled;\n\n        /// @notice Flag marking whether the proposal has been executed\n        bool executed;\n\n        /// @notice Receipts of ballots for the entire set of voters\n        mapping (address => Receipt) receipts;\n    }\n\n    /// @notice Ballot receipt record for a voter\n    struct Receipt {\n        /// @notice Whether or not a vote has been cast\n        bool hasVoted;\n\n        /// @notice Whether or not the voter supports the proposal\n        bool support;\n\n        /// @notice The number of votes the voter had, which were cast\n        uint96 votes;\n    }\n\n    /// @notice Possible states that a proposal may be in\n    enum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    }\n\n    /// @notice The official record of all proposals ever proposed\n    mapping (uint => Proposal) public proposals;\n\n    /// @notice The latest proposal for each proposer\n    mapping (address => uint) public latestProposalIds;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,bool support)\");\n\n    /// @notice An event emitted when a new proposal is created\n    event ProposalCreated(uint id, address proposer, address[] targets, uint[] values, string[] signatures, bytes[] calldatas, uint startBlock, uint endBlock, string description);\n\n    /// @notice An event emitted when a vote has been cast on a proposal\n    event VoteCast(address voter, uint proposalId, bool support, uint votes);\n\n    /// @notice An event emitted when a proposal has been canceled\n    event ProposalCanceled(uint id);\n\n    /// @notice An event emitted when a proposal has been queued in the Timelock\n    event ProposalQueued(uint id, uint eta);\n\n    /// @notice An event emitted when a proposal has been executed in the Timelock\n    event ProposalExecuted(uint id);\n\n    constructor(address timelock_, address stake_, address guardian_) public {\n        timelock = TimelockInterface(timelock_);\n        stake = StakeInterface(stake_);\n        guardian = guardian_;\n    }\n\n    function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) public returns (uint) {\n        require(stake.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold(), \"GovernorAlpha::propose: proposer votes below proposal threshold\");\n        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \"GovernorAlpha::propose: proposal function information arity mismatch\");\n        require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n        require(targets.length <= proposalMaxOperations(), \"GovernorAlpha::propose: too many actions\");\n\n        uint latestProposalId = latestProposalIds[msg.sender];\n        if (latestProposalId != 0) {\n            ProposalState proposersLatestProposalState = state(latestProposalId);\n            require(proposersLatestProposalState != ProposalState.Active, \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\");\n            require(proposersLatestProposalState != ProposalState.Pending, \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\");\n        }\n\n        uint startBlock = add256(block.number, votingDelay());\n        uint endBlock = add256(startBlock, votingPeriod());\n\n        proposalCount++;\n        Proposal memory newProposal = Proposal({\n        id: proposalCount,\n        proposer: msg.sender,\n        eta: 0,\n        targets: targets,\n        values: values,\n        signatures: signatures,\n        calldatas: calldatas,\n        startBlock: startBlock,\n        endBlock: endBlock,\n        forVotes: 0,\n        againstVotes: 0,\n        canceled: false,\n        executed: false\n        });\n\n        proposals[newProposal.id] = newProposal;\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\n        return newProposal.id;\n    }\n\n    function queue(uint proposalId) public {\n        require(state(proposalId) == ProposalState.Succeeded, \"GovernorAlpha::queue: proposal can only be queued if it is succeeded\");\n        Proposal storage proposal = proposals[proposalId];\n        uint eta = add256(block.timestamp, timelock.delay());\n        for (uint i = 0; i < proposal.targets.length; i++) {\n            _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\n        }\n        proposal.eta = eta;\n        emit ProposalQueued(proposalId, eta);\n    }\n\n    function _queueOrRevert(address target, uint value, string memory signature, bytes memory data, uint eta) internal {\n        require(!timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))), \"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\");\n        timelock.queueTransaction(target, value, signature, data, eta);\n    }\n\n    function execute(uint proposalId) public payable {\n        require(state(proposalId) == ProposalState.Queued, \"GovernorAlpha::execute: proposal can only be executed if it is queued\");\n        Proposal storage proposal = proposals[proposalId];\n        proposal.executed = true;\n        for (uint i = 0; i < proposal.targets.length; i++) {\n            timelock.executeTransaction.value(proposal.values[i])(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n        }\n        emit ProposalExecuted(proposalId);\n    }\n\n    function cancel(uint proposalId) public {\n        ProposalState state = state(proposalId);\n        require(state != ProposalState.Executed, \"GovernorAlpha::cancel: cannot cancel executed proposal\");\n\n        Proposal storage proposal = proposals[proposalId];\n        require(msg.sender == guardian || stake.getPriorVotes(proposal.proposer, sub256(block.number, 1)) < proposalThreshold(), \"GovernorAlpha::cancel: proposer above threshold\");\n\n        proposal.canceled = true;\n        for (uint i = 0; i < proposal.targets.length; i++) {\n            timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n        }\n\n        emit ProposalCanceled(proposalId);\n    }\n\n    function getActions(uint proposalId) public view returns (address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas) {\n        Proposal storage p = proposals[proposalId];\n        return (p.targets, p.values, p.signatures, p.calldatas);\n    }\n\n    function getReceipt(uint proposalId, address voter) public view returns (Receipt memory) {\n        return proposals[proposalId].receipts[voter];\n    }\n\n    function state(uint proposalId) public view returns (ProposalState) {\n        require(proposalCount >= proposalId && proposalId > 0, \"GovernorAlpha::state: invalid proposal id\");\n        Proposal storage proposal = proposals[proposalId];\n        if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (block.number <= proposal.startBlock) {\n            return ProposalState.Pending;\n        } else if (block.number <= proposal.endBlock) {\n            return ProposalState.Active;\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes()) {\n            return ProposalState.Defeated;\n        } else if (proposal.eta == 0) {\n            return ProposalState.Succeeded;\n        } else if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    function castVote(uint proposalId, bool support) public {\n        return _castVote(msg.sender, proposalId, support);\n    }\n\n    function castVoteBySig(uint proposalId, bool support, uint8 v, bytes32 r, bytes32 s) public {\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"GovernorAlpha::castVoteBySig: invalid signature\");\n        return _castVote(signatory, proposalId, support);\n    }\n\n    function _castVote(address voter, uint proposalId, bool support) internal {\n        require(state(proposalId) == ProposalState.Active, \"GovernorAlpha::_castVote: voting is closed\");\n        Proposal storage proposal = proposals[proposalId];\n        Receipt storage receipt = proposal.receipts[voter];\n        require(receipt.hasVoted == false, \"GovernorAlpha::_castVote: voter already voted\");\n        uint96 votes = stake.getPriorVotes(voter, proposal.startBlock);\n\n        if (support) {\n            proposal.forVotes = add256(proposal.forVotes, votes);\n        } else {\n            proposal.againstVotes = add256(proposal.againstVotes, votes);\n        }\n\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = votes;\n\n        emit VoteCast(voter, proposalId, support, votes);\n    }\n\n    function __acceptAdmin() public {\n        require(msg.sender == guardian, \"GovernorAlpha::__acceptAdmin: sender must be gov guardian\");\n        timelock.acceptAdmin();\n    }\n\n    function __abdicate() public {\n        require(msg.sender == guardian, \"GovernorAlpha::__abdicate: sender must be gov guardian\");\n        guardian = address(0);\n    }\n\n    function __queueSetTimelockPendingAdmin(address newPendingAdmin, uint eta) public {\n        require(msg.sender == guardian, \"GovernorAlpha::__queueSetTimelockPendingAdmin: sender must be gov guardian\");\n        timelock.queueTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin), eta);\n    }\n\n    function __executeSetTimelockPendingAdmin(address newPendingAdmin, uint eta) public {\n        require(msg.sender == guardian, \"GovernorAlpha::__executeSetTimelockPendingAdmin: sender must be gov guardian\");\n        timelock.executeTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin), eta);\n    }\n\n    function add256(uint256 a, uint256 b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, \"addition overflow\");\n        return c;\n    }\n\n    function sub256(uint256 a, uint256 b) internal pure returns (uint) {\n        require(b <= a, \"subtraction underflow\");\n        return a - b;\n    }\n\n    function getChainId() internal pure returns (uint) {\n        uint chainId;\n        assembly { chainId := chainid() }\n        return chainId;\n    }\n}\n\ninterface TimelockInterface {\n    function delay() external view returns (uint);\n    function GRACE_PERIOD() external view returns (uint);\n    function acceptAdmin() external;\n    function queuedTransactions(bytes32 hash) external view returns (bool);\n    function queueTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external returns (bytes32);\n    function cancelTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external;\n    function executeTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external payable returns (bytes memory);\n}\n\ninterface StakeInterface {\n    function getPriorVotes(address account, uint blockNumber) external view returns (uint96);\n}"
    },
    {
      "filename": "protocol/contracts/src/governance/Stake.sol",
      "content": "/*\n    Copyright 2021 Empty Set Squad <emptysetsquad@protonmail.com>\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../Interfaces.sol\";\n\n/*\n * audit-info: Forked from Compound's Comp contract:\n *             https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/Comp.sol\n *\n *             Sections that have been changed from the original have been denoted with audit notes\n *             Additionally \"Comp\" has been renamed to \"Stake\" throughout\n */\n\n/*\n * audit-info: Beginning of modified code section\n */\n\ncontract Stake is IManagedToken, Ownable {\n\n    /// @notice EIP-20 token name for this token\n    string public constant name = \"Empty Set Dollar Stake\";\n\n    /// @notice EIP-20 token symbol for this token\n    string public constant symbol = \"ESDS\";\n\n    /// @notice EIP-20 token decimals for this token\n    uint8 public constant decimals = 18;\n\n    /// @notice Total number of tokens in circulation\n    /// @dev Initialized at 0, use mint() for initial distribution to migrator & incentivizer(s)\n    uint public totalSupply;\n\n    /*\n     * audit-info: End of modified code section\n     */\n\n    /// @notice Allowance amounts on behalf of others\n    mapping (address => mapping (address => uint96)) internal allowances;\n\n    /// @notice Official record of token balances for each account\n    mapping (address => uint96) internal balances;\n\n    /// @notice A record of each accounts delegate\n    mapping (address => address) public delegates;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint96 votes;\n    }\n\n    /// @notice A record of votes checkpoints for each account, by index\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each account\n    mapping (address => uint32) public numCheckpoints;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @notice A record of states for signing / validating signatures\n    mapping (address => uint) public nonces;\n\n    /// @notice An event thats emitted when an account changes its delegate\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /// @notice An event thats emitted when a delegate account's vote balance changes\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\n\n    /// @notice The standard EIP-20 transfer event\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    /// @notice The standard EIP-20 approval event\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*\n     * audit-info: Beginning of modified code section\n     */\n\n    /**\n     * @notice Mint new tokens\n     * @param rawAmount The number of tokens to be minted\n     */\n    function mint(uint rawAmount) public onlyOwner {\n        // mint the amount\n        uint96 amount = safe96(rawAmount, \"Stake::mint: amount exceeds 96 bits\");\n        totalSupply = safe96(SafeMath.add(totalSupply, amount), \"Stake::mint: totalSupply exceeds 96 bits\");\n\n        // transfer the amount to the recipient\n        balances[owner()] = add96(balances[owner()], amount, \"Stake::mint: transfer amount overflows\");\n        emit Transfer(address(0), owner("
    }
  ]
}