{
  "Title": "[M-02] Its possible to lose total governance control by mistake",
  "Content": "_Submitted by hubble, also found by antonttc, csanuragjain, gs8nrv, rayn, reassor, and TrungOre_\n\n[RoleManager.sol#L43-L46](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/access/RoleManager.sol#L43-L46)<br>\n[RoleManager.sol#L115-L128](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/access/RoleManager.sol#L115-L128)<br>\n\nThe impact of this vulnerability, i.e.,  losing all governance control is very High.<br>\nThere is a possibility, due to a corner case as described below.<br>\n\n### Proof of Concept\nContract : RoleManager.sol<br>\nFunction : renounceGovernance()<br>\n```\n   Step 0:\n     Let current governance role given to = CURRENT_GOV_ADDRESS\n     so, getRoleMemberCount() for \"governance\" role will return = 1 \n\n   Step 1: Add a new address say ALICE to governance role, by addGovernor(ALICE)\n     now, ALICE also has governace role, and getRoleMemberCount() for \"governance\" role will return = 2 \n   \n   Step 2: Assume that ALICE renounces governance role, by renounceGovernance()\n     now, ALICE does not have governance role, but getRoleMemberCount() for \"governance\" role will return = 2, due to a BUG\n\n   Step 3: In some distant future, if there is a compromise of CURRENT_GOV_ADDRESS keys or due to some other reason, \n     its decided to revoke governance role for CURRENT_GOV_ADDRESS via renounceGovernance(), and the command succeeds\n     It can be assumed that since getRoleMemberCount() for \"governance\" role returns = 2, at least there is one other active governor address. \n     But now, CURRENT_GOV_ADDRESS does not have governance role, and the total governance control on the protocol is lost my mistake.\n```\n### Recommended Mitigation Steps\ngetRoleMemberCount() currently returns _roleMembers[role].length();<br>\n  It should return the count only for _roles[role].members[account] = true;<br>\n\nIts recommended to add a new function to know who are the active members for any role,<br>\n  like getRoleMembers(bytes32 role) returning address account.\n\n**[chase-manning (Backd) confirmed](https://github.com/code-423n4/2022-04-backd-findings/issues/83)**\n\n**[gzeon (judge) decreased severity to Medium](https://github.com/code-423n4/2022-04-backd-findings/issues/83)**\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-04-backd-contest",
  "Code": [
    {
      "filename": "backd/contracts/access/RoleManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport \"../../interfaces/IAddressProvider.sol\";\nimport \"../../interfaces/IRoleManager.sol\";\n\nimport \"../../libraries/Roles.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/AddressProviderKeys.sol\";\n\ncontract RoleManager is IRoleManager {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n    mapping(bytes32 => RoleData) private _roles;\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    IAddressProvider public immutable addressProvider;\n\n    modifier onlyGovernance() {\n        require(hasRole(Roles.GOVERNANCE, msg.sender), Error.UNAUTHORIZED_ACCESS);\n        _;\n    }\n\n    constructor(IAddressProvider _addressProvider) {\n        addressProvider = _addressProvider;\n        _grantRole(Roles.GOVERNANCE, msg.sender);\n    }\n\n    function grantRole(bytes32 role, address account) external onlyGovernance {\n        _grantRole(role, account);\n    }\n\n    function addGovernor(address newGovernor) external onlyGovernance {\n        _grantRole(Roles.GOVERNANCE, newGovernor);\n    }\n\n    function renounceGovernance() external onlyGovernance {\n        require(getRoleMemberCount(Roles.GOVERNANCE) > 1, Error.CANNOT_REVOKE_ROLE);\n        _revokeRole(Roles.GOVERNANCE, msg.sender);\n    }\n\n    function addGaugeZap(address zap) external onlyGovernance {\n        _grantRole(Roles.GAUGE_ZAP, zap);\n    }\n\n    function removeGaugeZap(address zap) external {\n        revokeRole(Roles.GAUGE_ZAP, zap);\n    }\n\n    function hasAnyRole(\n        bytes32 role1,\n        bytes32 role2,\n        address account\n    ) external view returns (bool) {\n        return hasRole(role1, account) || hasRole(role2, account);\n    }\n\n    function hasAnyRole(\n        bytes32 role1,\n        bytes32 role2,\n        bytes32 role3,\n        address account\n    ) external view returns (bool) {\n        return hasRole(role1, account) || hasRole(role2, account) || hasRole(role3, account);\n    }\n\n    function hasAnyRole(bytes32[] memory roles, address account)\n        external\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        for (uint256 i = 0; i < roles.length; i++) {\n            if (hasRole(roles[i], account)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function getRoleMember(bytes32 role, uint256 index)\n        external\n        view\n        virtual\n        override\n        returns (address)\n    {\n        if (role == Roles.ADDRESS_PROVIDER && index == 0) {\n            return address(addressProvider);\n        } else if (role == Roles.POOL_FACTORY && index == 0) {\n            return addressProvider.getAddress(AddressProviderKeys._POOL_FACTORY_KEY);\n        } else if (role == Roles.CONTROLLER && index == 0) {\n            return addressProvider.getAddress(AddressProviderKeys._CONTROLLER_KEY);\n        } else if (role == Roles.POOL) {\n            return addressProvider.getPoolAtIndex(index);\n        } else if (role == Roles.VAULT) {\n            return addressProvider.getVaultAtIndex(index);\n        }\n        return _roleMembers[role].at(index);\n    }\n\n    function revokeRole(bytes32 role, address account) public onlyGovernance {\n        require(role != Roles.GOVERNANCE, Error.CANNOT_REVOKE_ROLE);\n        require(hasRole(role, account), Error.INVALID_ARGUMENT);\n        _revokeRole(role, account);\n    }\n\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        if (\n            role == Roles.ADDRESS_PROVIDER || role == Roles.POOL_FACTORY || role == Roles.CONTROLLER\n        ) {\n            return 1;\n        }\n        if (role == Roles.POOL) {\n            return addressProvider.poolsCount();\n        }\n        if (role == Roles.VAULT) {\n            return addressProvider.vaultsCount();\n        }\n        return _roleMembers[role].length();\n    }\n\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        if (role == Roles.ADDRESS_PROVIDER) {\n            return account == address(addressProvider);\n        } else if (role == Roles.POOL_FACTORY) {\n            return\n                account == addressProvider.getAddress(AddressProviderKeys._POOL_FACTORY_KEY, false);\n        } else if (role == Roles.CONTROLLER) {\n            return\n                account == addressProvider.getAddress(AddressProviderKeys._CONTROLLER_KEY, false);\n        } else if (role == Roles.MAINTENANCE) {\n            return _roles[role].members[account] || _roles[Roles.GOVERNANCE].members[account];\n        } else if (role == Roles.POOL) {\n            return addressProvider.isPool(account);\n        } else if (role == Roles.VAULT) {\n            return addressProvider.isVault(account);\n        }\n        return _roles[role].members[account];\n    }\n\n    function _grantRole(bytes32 role, address account) internal {\n        _roles[role].members[account] = true;\n        _roleMembers[role].add(account);\n        emit RoleGranted(role, account, msg.sender);\n    }\n\n    function _revokeRole(bytes32 role, address account) internal {\n        _roles[role].members[account] = false;\n        emit RoleRevoked(role, account, msg.sender);\n    }\n}"
    },
    {
      "filename": "backd/contracts/access/RoleManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport \"../../interfaces/IAddressProvider.sol\";\nimport \"../../interfaces/IRoleManager.sol\";\n\nimport \"../../libraries/Roles.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/AddressProviderKeys.sol\";\n\ncontract RoleManager is IRoleManager {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n    mapping(bytes32 => RoleData) private _roles;\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    IAddressProvider public immutable addressProvider;\n\n    modifier onlyGovernance() {\n        require(hasRole(Roles.GOVERNANCE, msg.sender), Error.UNAUTHORIZED_ACCESS);\n        _;\n    }\n\n    constructor(IAddressProvider _addressProvider) {\n        addressProvider = _addressProvider;\n        _grantRole(Roles.GOVERNANCE, msg.sender);\n    }\n\n    function grantRole(bytes32 role, address account) external onlyGovernance {\n        _grantRole(role, account);\n    }\n\n    function addGovernor(address newGovernor) external onlyGovernance {\n        _grantRole(Roles.GOVERNANCE, newGovernor);\n    }\n\n    function renounceGovernance() external onlyGovernance {\n        require(getRoleMemberCount(Roles.GOVERNANCE) > 1, Error.CANNOT_REVOKE_ROLE);\n        _revokeRole(Roles.GOVERNANCE, msg.sender);\n    }\n\n    function addGaugeZap(address zap) external onlyGovernance {\n        _grantRole(Roles.GAUGE_ZAP, zap);\n    }\n\n    function removeGaugeZap(address zap) external {\n        revokeRole(Roles.GAUGE_ZAP, zap);\n    }\n\n    function hasAnyRole(\n        bytes32 role1,\n        bytes32 role2,\n        address account\n    ) external view returns (bool) {\n        return hasRole(role1, account) || hasRole(role2, account);\n    }\n\n    function hasAnyRole(\n        bytes32 role1,\n        bytes32 role2,\n        bytes32 role3,\n        address account\n    ) external view returns (bool) {\n        return hasRole(role1, account) || hasRole(role2, account) || hasRole(role3, account);\n    }\n\n    function hasAnyRole(bytes32[] memory roles, address account)\n        external\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        for (uint256 i = 0; i < roles.length; i++) {\n            if (hasRole(roles[i], account)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function getRoleMember(bytes32 role, uint256 index)\n        external\n        view\n        virtual\n        override\n        returns (address)\n    {\n        if (role == Roles.ADDRESS_PROVIDER && index == 0) {\n            return address(addressProvider);\n        } else if (role == Roles.POOL_FACTORY && index == 0) {\n            return addressProvider.getAddress(AddressProviderKeys._POOL_FACTORY_KEY);\n        } else if (role == Roles.CONTROLLER && index == 0) {\n            return addressProvider.getAddress(AddressProviderKeys._CONTROLLER_KEY);\n        } else if (role == Roles.POOL) {\n            return addressProvider.getPoolAtIndex(index);\n        } else if (role == Roles.VAULT) {\n            return addressProvider.getVaultAtIndex(index);\n        }\n        return _roleMembers[role].at(index);\n    }\n\n    function revokeRole(bytes32 role, address account) public onlyGovernance {\n        require(role != Roles.GOVERNANCE, Error.CANNOT_REVOKE_ROLE);\n        require(hasRole(role, account), Error.INVALID_ARGUMENT);\n        _revokeRole(role, account);\n    }\n\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        if (\n            role == Roles.ADDRESS_PROVIDER || role == Roles.POOL_FACTORY || role == Roles.CONTROLLER\n        ) {\n            return 1;\n        }\n        if (role == Roles.POOL) {\n            return addressProvider.poolsCount();\n        }\n        if (role == Roles.VAULT) {\n            return addressProvider.vaultsCount();\n        }\n        return _roleMembers[role].length();\n    }\n\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        if (role == Roles.ADDRESS_PROVIDER) {\n            return account == address(addressProvider);\n        } else if (role == Roles.POOL_FACTORY) {\n            return\n                account == addressProvider.getAddress(AddressProviderKeys._POOL_FACTORY_KEY, false);\n        } else if (role == Roles.CONTROLLER) {\n            return\n                account == addressProvider.getAddress(AddressProviderKeys._CONTROLLER_KEY, false);\n        } else if (role == Roles.MAINTENANCE) {\n            return _roles[role].members[account] || _roles[Roles.GOVERNANCE].members[account];\n        } else if (role == Roles.POOL) {\n            return addressProvider.isPool(account);\n        } else if (role == Roles.VAULT) {\n            return addressProvider.isVault(account);\n        }\n        return _roles[role].members[account];\n    }\n\n    function _grantRole(bytes32 role, address account) internal {\n        _roles[role].members[account] = true;\n        _roleMembers[role].add(account);\n        emit RoleGranted(role, account, msg.sender);\n    }\n\n    function _revokeRole(bytes32 role, address account) internal {\n        _roles[role].members[account] = false;\n        emit RoleRevoked(role, account, msg.sender);\n    }\n}"
    }
  ]
}