{
  "Title": "[M-14] Incorrect initialization of smart contracts with Access Control issue",
  "Content": "_Submitted by Haipls, also found by byndooa, cryptphi, and TrungOre_\n\n[HomeFiProxy.sol#L216-L230](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/HomeFiProxy.sol#L216-L230)<br>\n[Community.sol#L102-L119](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Community.sol#L102-L119)<br>\n[DebtToken.sol#L43-L58](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/DebtToken.sol#L43-L58)<br>\n[Disputes.sol#L74-L81](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Disputes.sol#L74-L81)<br>\n[HomeFi.sol#L92-L120](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/HomeFi.sol#L92-L120)<br>\n[Project.sol#L94-L105](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L94-L105)<br>\n[ProjectFactory.sol#L45-L55](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/ProjectFactory.sol#L45-L55)<br>\n\nAll next Impact depends on actions and attention from developers when deployed\n\n*   Loss of funds\n*   Failure of the protocol, with the need for redeploy\n*   Loss of control over protocol elements (some smart contracts)\n*   The possibility of replacing contracts and settings with harmful ones\n\nAnd other things that come out of it...\n\n### Proof of Concept\n\nFor a proper understanding of Proof of Concept, you need to understand the following things:\n\n1.  Hardhat does not stop the process with a deploy and does not show failed transactions if they have occurred in some cases\n2.  Malicious agents can trace the protocol deployment transactions and insert their own transaction between them\n\nReason:\n\n*   [During deploy TransparentUpgradeableProxy's](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/HomeFiProxy.sol#L216-L230) initialize method for initializing contracts not called. The third parameter responsible for this is an empty string. This causes the initialization process itself to be **delayed**\n\n*   Contract initialization methods have no check over who calls them\n\nExample [ProjectFactory.sol#L45-L55](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/ProjectFactory.sol#L45-L55)\n\n**Also suitable for other contracts, strings are attached in Links to affected code**\n\n### Examples of exploiting the vulnerability\n\n**Failure of the protocol, with the need for redeploy** && **Loss of control over protocol elements (some smart contracts)**:\n\n1.  User listen transaction in mempool, etherscan, transaction in block etc\n2.  Finds the moment of deployment and sends the transaction for setup his HomeFi address in Disputes contract: Just he call initialize method and put his \\_homeFi parameter\n3.  In the event that hardhat tracked a failed transaction, the deployment will stop and you will need to start over. If the hardhead misses it and the developers do not check the result and the setting, access to this part will be lost and fix is needed\n\n**Loss of funds**:\n\n1.  User listen transaction in mempool, etherscan, transaction in block for listne when HomeFi will deployed\n2.  Send transaction for initialize [HomeFi](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/HomeFi.sol#L92-L120) with his \\_treasury address\n3.  Transfer the admin ownership the right to the real address to divert the eyes\n4.  The address of the treasury remains with the attacker\n5.  The protocol fees (fee) will be [transfered](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Community.sol#L443) to the attacker's address until it is detected\n\n### Recommended Mitigation Steps\n\nCarry out checks at the initialization stage or redesign the deployment process with the initialization of contracts during deployment\n\n**[zgorizzo69 (Rigor) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2022-08-rigor-findings/issues/6#issuecomment-1208155944):**\n >  About the reasons\n> * TransparentUpgradeableProxy third parameter is optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}\n> *  incorrect modifiers check that addresses are not address(0)<br>\n> about the possible exploit<br>\n> Interesting take on how the dark forest's creatures can harm the deployment process :+1: <br>\n> however if a tx fails the whole deployment script stops but I think it is a good practice to indeed verify after each initialization\n\n**[Jack the Pug (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-08-rigor-findings/issues/6#issuecomment-1229122338):**\n > Valid, but gonna downgrade it to Medium as the impact is not that severe in practice.\n> \n> Btw, in response to the response about the 2nd reason:\n> \n> > Contract initialization methods have no check over who calls them.<br>\n> > incorrect modifiers check that addresses are not address(0)\n> \n> \"no check over who calls them\" means no access control. It can be called by anyone. It's not about the input validation.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-08-rigor-protocol-contest",
  "Code": [
    {
      "filename": "contracts/HomeFiProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {TransparentUpgradeableProxy} from \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport {ProxyAdmin} from \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/**\n * @title HomeFiProxy Contract for HomeFi v2.5.0\n\n * @dev This contract provided functionality to update the core HomeFi contracts.\n */\ncontract HomeFiProxy is OwnableUpgradeable {\n    /*******************************************************************************\n     * -------------------------PUBLIC STORED PROPERTIES-------------------------- *\n     *******************************************************************************/\n\n    /// @notice Address of proxy admin\n    ProxyAdmin public proxyAdmin;\n\n    /// @notice bytes2 array of upgradable contracts initials\n    bytes2[] public allContractNames;\n\n    /*******************************************************************************\n     * ------------------------INTERNAL STORED PROPERTIES------------------------- *\n     *******************************************************************************/\n\n    /// @dev mapping that tell if a particular address is active(latest version of contract)\n    mapping(address => bool) internal contractsActive;\n\n    /// @dev mapping that maps contract initials with there implementation address\n    mapping(bytes2 => address payable) internal contractAddress;\n\n    /*******************************************************************************\n     * ---------------------------------MODIFIERS--------------------------------- *\n     *******************************************************************************/\n\n    /// @dev check _address should not be zero address\n    modifier nonZero(address _address) {\n        require(_address != address(0), \"Proxy::0 address\");\n        _;\n    }\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @notice Initialize all the homeFi contract in the correct sequential order and generate upgradable proxy for them.\n\n     * @dev Can only be called by HomeFiProxy owner.\n     * @dev modifier initializer\n     * @dev if more contract are added in homeFi, then their entry can be done here. \n\n     * @param _implementations the implementation address of homeFi smart contract in correct sequence.\n     */\n    function initiateHomeFi(address[] calldata _implementations)\n        external\n        initializer\n    {\n        // Initialize ownable\n        __Ownable_init();\n\n        // Create new proxy admin contract\n        proxyAdmin = new ProxyAdmin();\n\n        // Initial contract names\n        allContractNames.push(\"HF\"); // HomeFi\n        allContractNames.push(\"CN\"); // Community\n        allContractNames.push(\"DP\"); // Disputes\n        allContractNames.push(\"PF\"); // Project Factory\n        allContractNames.push(\"DA\"); // rDAI\n        allContractNames.push(\"US\"); // rUSDC\n        allContractNames.push(\"NT\"); // native token rETH - rXDAI\n\n        // Local instance of variable. For saving gas.\n        uint256 _length = allContractNames.length;\n\n        // Revert if _implementations length is wrong. Indicating wrong set of _implementations.\n        require(_length == _implementations.length, \"Proxy::Lengths !match\");\n\n        // Mark this contract as active\n        contractsActive[address(this)] = true;\n\n        // Generate proxy for all implementation\n        for (uint256 i = 0; i < _length; i++) {\n            _generateProxy(allContractNames[i], _implementations[i]);\n        }\n    }\n\n    /**\n     * @notice Adds a new contract type/implementation to HomeFi\n\n     * @dev modifier onlyOwner\n\n     * @param _contractName initial of contract to be added\n     * @param _contractAddress address of contract implementation to be added.\n     */\n    function addNewContract(bytes2 _contractName, address _contractAddress)\n        external\n        onlyOwner\n    {\n        // Revert if _contractName is already in use.\n        require(\n            contractAddress[_contractName] == address(0),\n            \"Proxy::Name !OK\"\n        );\n\n        // Add to allContractNames\n        allContractNames.push(_contractName);\n\n        // Generate proxy\n        _generateProxy(_contractName, _contractAddress);\n    }\n\n    /**\n     * @notice Upgrades a multiple contract implementations. Replaces old implementation with new.\n\n     * @dev modifier onlyOwner\n\n     * @param _contractNames bytes2 array of contract initials that needs to be upgraded\n     * @param _contractAddresses address array of contract implementation address that needs to be upgraded\n     */\n    function upgradeMultipleImplementations(\n        bytes2[] calldata _contractNames,\n        address[] calldata _contractAddresses\n    ) external onlyOwner {\n        // Local instance of variable. For saving gas.\n        uint256 _length = _contractNames.length;\n\n        // Revert if _contractNames and _contractAddresses length mismatch\n        require(_length == _contractAddresses.length, \"Proxy::Lengths !match\");\n\n        // Replace implementations\n        for (uint256 i = 0; i < _length; i++) {\n            _replaceImplementation(_contractNames[i], _contractAddresses[i]);\n        }\n    }\n\n    /**\n     * @notice Allows HomeFiProxy owner to change the owner of proxyAdmin contract.\n     * This can be useful when trying to deploy new version of HomeFiProxy\n\n     * @dev modifier onlyOwner\n     * @dev modifier nonZero with _newAdmin\n\n     * @param _newAdmin address of new proxyAdmin owner / new version of HomeFiProxy\n     */\n    function changeProxyAdminOwner(address _newAdmin)\n        external\n        onlyOwner\n        nonZero(_newAdmin)\n    {\n        // Transfer ownership to new admin.\n        proxyAdmin.transferOwnership(_newAdmin);\n    }\n\n    /*******************************************************************************\n     * ------------------------------EXTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @notice To check if we use the particular contract.\n     * @param _address The contract address to check if it is active or not.\n     * @return true if _address is active else false\n     */\n    function isActive(address _address) external view returns (bool) {\n        return contractsActive[_address];\n    }\n\n    /**\n     * @notice Gets latest contract address\n     * @param _contractName Contract name to fetch\n     * @return current implementation address corresponding to _contractName\n     */\n    function getLatestAddress(bytes2 _contractName)\n        external\n        view\n        returns (address)\n    {\n        return contractAddress[_contractName];\n    }\n\n    /*******************************************************************************\n     * ---------------------------INTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @dev Replaces the implementations of the contract.\n     * @dev modifier nonZero with _contractAddress\n\n     * @param _contractName The name of the contract.\n\n     * @param _contractAddress The address of the contract to replace the implementations for.\n     */\n    function _replaceImplementation(\n        bytes2 _contractName,\n        address _contractAddress\n    ) internal nonZero(_contractAddress) {\n        // Upgrade proxy\n        proxyAdmin.upgrade(\n            TransparentUpgradeableProxy(contractAddress[_contractName]),\n            _contractAddress\n        );\n    }\n\n    /**\n     * @dev generates upgradable proxy\n     * @dev modifier nonZero with _contractAddress\n\n     * @param _contractName initial of the contract\n\n     * @param _contractAddress of the proxy\n     */\n    function _generateProxy(bytes2 _contractName, address _contractAddress)\n        internal\n        nonZero(_contractAddress)\n    {\n        // Deploys new TransparentUpgradeableProxy for implementation\n        TransparentUpgradeableProxy tempInstance = new TransparentUpgradeableProxy(\n                _contractAddress,\n                address(proxyAdmin),\n                bytes(\"\")\n            );\n\n        // Store details\n        contractAddress[_contractName] = payable(address(tempInstance));\n        contractsActive[address(tempInstance)] = true;\n    }\n}"
    },
    {
      "filename": "contracts/Community.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {IHomeFi} from \"./interfaces/IHomeFi.sol\";\nimport {IProject} from \"./interfaces/IProject.sol\";\nimport {ICommunity, IDebtToken} from \"./interfaces/ICommunity.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ContextUpgradeable, ERC2771ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SignatureDecoder} from \"./libraries/SignatureDecoder.sol\";\n\n/* solhint-disable not-rely-on-time */\n\n/**\n * @title Community Contract for HomeFi v2.5.0\n \n * @notice Module for coordinating lending groups on HomeFi protocol\n */\ncontract Community is\n    ICommunity,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    ERC2771ContextUpgradeable\n{\n    // Using SafeERC20Upgradeable library for IDebtToken\n    using SafeERC20Upgradeable for IDebtToken;\n\n    /*******************************************************************************\n     * ---------------------FIXED INTERNAL STORED PROPERTIES---------------------- *\n     *******************************************************************************/\n    address internal tokenCurrency1;\n    address internal tokenCurrency2;\n    address internal tokenCurrency3;\n\n    /*******************************************************************************\n     * --------------------VARIABLE INTERNAL STORED PROPERTIES-------------------- *\n     *******************************************************************************/\n\n    mapping(uint256 => CommunityStruct) internal _communities;\n\n    /*******************************************************************************\n     * ----------------------FIXED PUBLIC STORED PROPERTIES----------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    IHomeFi public override homeFi;\n\n    /*******************************************************************************\n     * ---------------------VARIABLE PUBLIC STORED PROPERTIES--------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    bool public override restrictedToAdmin;\n    /// @inheritdoc ICommunity\n    uint256 public override communityCount;\n    /// @inheritdoc ICommunity\n    mapping(address => uint256) public override projectPublished;\n    /// @inheritdoc ICommunity\n    mapping(address => mapping(bytes32 => bool)) public override approvedHashes;\n\n    /*******************************************************************************\n     * ---------------------------------MODIFIERS--------------------------------- *\n     *******************************************************************************/\n\n    modifier nonZero(address _address) {\n        // Revert if _address zero address (0x00) (invalid)\n        require(_address != address(0), \"Community::0 address\");\n        _;\n    }\n\n    modifier onlyHomeFiAdmin() {\n        // Revert if sender is not homeFi admin\n        require(_msgSender() == homeFi.admin(), \"Community::!admin\");\n        _;\n    }\n\n    modifier isPublishedToCommunity(uint256 _communityID, address _project) {\n        // Revert if _project is not published to _communityID\n        require(\n            projectPublished[_project] == _communityID,\n            \"Community::!published\"\n        );\n        _;\n    }\n\n    modifier onlyProjectBuilder(address _project) {\n        // Revert if sender is not _project builder\n        require(\n            _msgSender() == IProject(_project).builder(),\n            \"Community::!Builder\"\n        );\n        _;\n    }\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    function initialize(address _homeFi)\n        external\n        override\n        initializer\n        nonZero(_homeFi)\n    {\n        // Initialize pausable. Set pause to false;\n        __Pausable_init();\n\n        // Initialize variables\n        homeFi = IHomeFi(_homeFi);\n        tokenCurrency1 = homeFi.tokenCurrency1();\n        tokenCurrency2 = homeFi.tokenCurrency2();\n        tokenCurrency3 = homeFi.tokenCurrency3();\n\n        // Community creation is paused for non admin by default paused\n        restrictedToAdmin = true;\n    }\n\n    /// @inheritdoc ICommunity\n    function createCommunity(bytes calldata _hash, address _currency)\n        external\n        override\n        whenNotPaused\n    {\n        // Local variable for sender. For gas saving.\n        address _sender = _msgSender();\n\n        // Revert if community creation is paused or sender is not HomeFi admin\n        require(\n            !restrictedToAdmin || _sender == homeFi.admin(),\n            \"Community::!admin\"\n        );\n\n        // Revert if currency is not supported by HomeFi\n        homeFi.validCurrency(_currency);\n\n        // Increment community counter\n        communityCount++;\n\n        // Store community details\n        CommunityStruct storage _community = _communities[communityCount];\n        _community.owner = _sender;\n        _community.currency = IDebtToken(_currency);\n        _community.memberCount = 1;\n        _community.members[0] = _sender;\n        _community.isMember[_sender] = true;\n\n        emit CommunityAdded(communityCount, _sender, _currency, _hash);\n    }\n\n    /// @inheritdoc ICommunity\n    function updateCommunityHash(uint256 _communityID, bytes calldata _hash)\n        external\n        override\n    {\n        // Revert if sender is not _communityID owner\n        require(\n            _communities[_communityID].owner == _msgSender(),\n            \"Community::!owner\"\n        );\n\n        // Emit event if _hash. This way this hash needs not be stored in memory.\n        emit UpdateCommunityHash(_communityID, _hash);\n    }\n\n    /// @inheritdoc ICommunity\n    function addMember(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual\n        override\n    {\n        // Compute hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Decode params from _data\n        (\n            uint256 _communityID,\n            address _newMemberAddr,\n            bytes memory _messageHash\n        ) = abi.decode(_data, (uint256, address, bytes));\n\n        CommunityStruct storage _community = _communities[_communityID];\n\n        // check signatures\n        checkSignatureValidity(_community.owner, _hash, _signature, 0); // must be community owner\n        checkSignatureValidity(_newMemberAddr, _hash, _signature, 1); // must be new member\n\n        // Revert if new member already exists\n        require(\n            !_community.isMember[_newMemberAddr],\n            \"Community::Member Exists\"\n        );\n\n        // Store updated community details\n        uint256 _memberCount = _community.memberCount;\n        _community.memberCount = _memberCount + 1;\n        _community.members[_memberCount] = _newMemberAddr;\n        _community.isMember[_newMemberAddr] = true;\n\n        emit MemberAdded(_communityID, _newMemberAddr, _messageHash);\n    }\n\n    /// @inheritdoc ICommunity\n    function publishProject(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual\n        override\n        whenNotPaused\n    {\n        // Compute hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Decode params from _data\n        (\n            uint256 _communityID,\n            address _project,\n            uint256 _apr,\n            uint256 _publishFee,\n            uint256 _publishNonce,\n            bytes memory _messageHash\n        ) = abi.decode(\n                _data,\n                (uint256, address, uint256, uint256, uint256, bytes)\n            );\n\n        // Local instance of community and community  project details. For saving gas.\n        CommunityStruct storage _community = _communities[_communityID];\n        ProjectDetails storage _communityProject = _community.projectDetails[\n            _project\n        ];\n\n        // Revert if decoded nonce is incorrect. This indicates wrong _data.\n        require(\n            _publishNonce == _community.publishNonce,\n            \"Community::invalid publishNonce\"\n        );\n\n        // Reverts if _project not originated from HomeFi\n        require(homeFi.isProjectExist(_project), \"Community::Project !Exists\");\n\n        // Local instance of variables. For saving gas.\n        IProject _projectInstance = IProject(_project);\n        address _builder = _projectInstance.builder();\n\n        // Revert if project builder is not community member\n        require(_community.isMember[_builder], \"Community::!Member\");\n\n        // Revert if project currency does not match community currency\n        require(\n            _projectInstance.currency() == _community.currency,\n            \"Community::!Currency\"\n        );\n\n        // check signatures\n        checkSignatureValidity(_community.owner, _hash, _signature, 0); // must be community owner\n        checkSignatureValidity(_builder, _hash, _signature, 1); // must be project builder\n\n        // If already published then unpublish first\n        if (projectPublished[_project] > 0) {\n            _unpublishProject(_project);\n        }\n\n        // Store updated details\n        _community.publishNonce = ++_community.publishNonce;\n        _communityProject.apr = _apr;\n        _communityProject.publishFee = _publishFee;\n        projectPublished[_project] = _communityID;\n\n        // If _publishFee is zero than mark publish fee as paid\n        if (_publishFee == 0) _communityProject.publishFeePaid = true;\n\n        emit ProjectPublished(\n            _communityID,\n            _project,\n            _apr,\n            _publishFee,\n            _communityProject.publishFeePaid,\n            _messageHash\n        );\n    }\n\n    /// @inheritdoc ICommunity\n    function unpublishProject(uint256 _communityID, address _project)\n        external\n        override\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n        onlyProjectBuilder(_project)\n    {\n        // Call internal function to unpublish project\n        _unpublishProject(_project);\n    }\n\n    /// @inheritdoc ICommunity\n    function payPublishFee(uint256 _communityID, address _project)\n        external\n        override\n        nonReentrant\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n        onlyProjectBuilder(_project)\n    {\n        // Local instance of variables. For saving gas.\n        CommunityStruct storage _community = _communities[_communityID];\n        ProjectDetails storage _communityProject = _community.projectDetails[\n            _project\n        ];\n\n        // Revert if publish fee already paid\n        require(\n            !_communityProject.publishFeePaid,\n            \"Community::publish fee paid\"\n        );\n\n        // Store updated detail\n        _communityProject.publishFeePaid = true;\n\n        // Transfer publishFee to community owner (lender)\n        _community.currency.safeTransferFrom(\n            _msgSender(),\n            _community.owner,\n            _communityProject.publishFee\n        );\n\n        emit PublishFeePaid(_communityID, _project);\n    }\n\n    /// @inheritdoc ICommunity\n    function toggleLendingNeeded(\n        uint256 _communityID,\n        address _project,\n        uint256 _lendingNeeded\n    )\n        external\n        override\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n        onlyProjectBuilder(_project)\n    {\n        // Local instance of variable. For saving gas.\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n\n        // Revert if publish fee not paid\n        require(\n            _communityProject.publishFeePaid,\n            \"Community::publish fee !paid\"\n        );\n\n        // Revert if _lendingNeeded is more than projectCost or less than what is already lent\n        require(\n            _lendingNeeded >= _communityProject.totalLent &&\n                _lendingNeeded <= IProject(_project).projectCost(),\n            \"Community::invalid lending\"\n        );\n\n        // Store updated detail\n        _communityProject.lendingNeeded = _lendingNeeded;\n\n        emit ToggleLendingNeeded(_communityID, _project, _lendingNeeded);\n    }\n\n    /// @inheritdoc ICommunity\n    function lendToProject(\n        uint256 _communityID,\n        address _project,\n        uint256 _lendingAmount,\n        bytes calldata _hash\n    )\n        external\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n    {\n        // Local instance of variable. For saving gas.\n        address _sender = _msgSender();\n\n        // Revert if sender is not community owner.\n        // Only community owner can lend.\n        require(\n            _sender == _communities[_communityID].owner,\n            \"Community::!owner\"\n        );\n\n        // Local instance of variable. For saving gas.\n        IProject _projectInstance = IProject(_project);\n\n        // Calculate lenderFee\n        uint256 _lenderFee = (_lendingAmount * _projectInstance.lenderFee()) /\n            (_projectInstance.lenderFee() + 1000);\n\n        // Calculate amount going to project. Lending amount - lending fee.\n        uint256 _amountToProject = _lendingAmount - _lenderFee;\n\n        // Revert if _amountToProject is not within further investment needed.\n        require(\n            _amountToProject <=\n                _communities[_communityID]\n                    .projectDetails[_project]\n                    .lendingNeeded -\n                    _communities[_communityID]\n                        .projectDetails[_project]\n                        .totalLent,\n            \"Community::lending>needed\"\n        );\n\n        // Local instance of variable. For saving gas.\n        IDebtToken _currency = _communities[_communityID].currency;\n        IDebtToken _wrappedToken = IDebtToken(\n            homeFi.wrappedToken(address(_currency))\n        );\n\n        // Update investment in Project\n        _projectInstance.lendToProject(_amountToProject);\n\n        // Update total lent by lender\n        _communities[_communityID]\n            .projectDetails[_project]\n            .totalLent += _amountToProject;\n\n        // First claim interest if principal lent > 0\n        if (\n            _communities[_communityID].projectDetails[_project].lentAmount > 0\n        ) {\n            claimInterest(_communityID, _project, _wrappedToken);\n        }\n\n        // Increment lent principal\n        _communities[_communityID]\n            .projectDetails[_project]\n            .lentAmount += _lendingAmount;\n\n        // Update lastTimestamp\n        _communities[_communityID]\n            .projectDetails[_project]\n            .lastTimestamp = block.timestamp;\n\n        // Transfer _lenderFee to HomeFi treasury from lender account\n        _currency.safeTransferFrom(_msgSender(), homeFi.treasury(), _lenderFee);\n\n        // Transfer _amountToProject to _project from lender account\n        _currency.safeTransferFrom(_msgSender(), _project, _amountToProject);\n\n        // Mint new _lendingAmount amount wrapped token to lender\n        _wrappedToken.mint(_sender, _lendingAmount);\n\n        emit LenderLent(_communityID, _project, _sender, _lendingAmount, _hash);\n    }\n\n    /// @inheritdoc ICommunity\n    function repayLender(\n        uint256 _communityID,\n        address _project,\n        uint256 _repayAmount\n    )\n        external\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        onlyProjectBuilder(_project)\n    {\n        // Internally call reduce debt\n        _reduceDebt(_communityID, _project, _repayAmount, \"0x\");\n\n        // Local instance of variable. For saving gas.\n        address _lender = _communities[_communityID].owner;\n\n        // Transfer repayment to lender\n        _communities[_communityID].currency.safeTransferFrom(\n            _msgSender(),\n            _lender,\n            _repayAmount\n        );\n\n        emit RepayLender(_communityID, _project, _lender, _repayAmount);\n    }\n\n    /// @inheritdoc ICommunity\n    function reduceDebt(\n        uint256 _communityID,\n        address _project,\n        uint256 _repayAmount,\n        bytes memory _details\n    ) external virtual override whenNotPaused {\n        // Revert if sender is not _communityID owner (lender)\n        require(\n            _msgSender() == _communities[_communityID].owner,\n            \"Community::!Owner\"\n        );\n\n        // Internal call to reduce debt\n        _reduceDebt(_communityID, _project, _repayAmount, _details);\n    }\n\n    /// @inheritdoc ICommunity\n    function approveHash(bytes32 _hash) external virtual override {\n        // allowing anyone to sign, as its hard to add restrictions here\n        approvedHashes[_msgSender()][_hash] = true;\n\n        emit ApproveHash(_hash, _msgSender());\n    }\n\n    /// @inheritdoc ICommunity\n    function escrow(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual\n        override\n        whenNotPaused\n    {\n        // Decode params from _data\n        (\n            uint256 _communityID,\n            address _builder,\n            address _lender,\n            address _agent,\n            address _project,\n            uint256 _repayAmount,\n            bytes memory _details\n        ) = abi.decode(\n                _data,\n                (uint256, address, address, address, address, uint256, bytes)\n            );\n\n        // Compute hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Local instance of variable. For saving gas.\n        IProject _projectInstance = IProject(_project);\n\n        // Revert if decoded builder is not decoded project's builder\n        require(_builder == _projectInstance.builder(), \"Community::!Builder\");\n\n        // Revert if decoded _communityID's owner is not decoded _lender\n        require(\n            _lender == _communities[_communityID].owner,\n            \"Community::!Owner\"\n        );\n\n        // check signatures\n        checkSignatureValidity(_lender, _hash, _signature, 0); // must be lender\n        checkSignatureValidity(_builder, _hash, _signature, 1); // must be builder\n        checkSignatureValidity(_agent, _hash, _signature, 2); // must be agent or escrow\n\n        // Internal call to reduce debt\n        _reduceDebt(_communityID, _project, _repayAmount, _details);\n        emit DebtReducedByEscrow(_agent);\n    }\n\n    /// @inheritdoc ICommunity\n    function restrictToAdmin() external override onlyHomeFiAdmin {\n        // Revert if already restricted to admin\n        require(!restrictedToAdmin, \"Community::restricted\");\n\n        // Disable community creation for non admins\n        restrictedToAdmin = true;\n\n        emit RestrictedToAdmin(_msgSender());\n    }\n\n    /// @inheritdoc ICommunity\n    function unrestrictToAdmin() external override onlyHomeFiAdmin {\n        // Revert if already unrestricted to admin\n        require(restrictedToAdmin, \"Community::!restricted\");\n\n        // Allow community creation for all\n        restrictedToAdmin = false;\n\n        emit UnrestrictedToAdmin(_msgSender());\n    }\n\n    /// @inheritdoc ICommunity\n    function pause() external override onlyHomeFiAdmin {\n        _pause();\n    }\n\n    /// @inheritdoc ICommunity\n    function unpause() external override onlyHomeFiAdmin {\n        _unpause();\n    }\n\n    /*******************************************************************************\n     * ------------------------------EXTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    function communities(uint256 _communityID)\n        external\n        view\n        override\n        returns (\n            address owner,\n            address currency,\n            uint256 memberCount,\n            uint256 publishNonce\n        )\n    {\n        CommunityStruct storage _community = _communities[_communityID];\n\n        owner = _community.owner;\n        currency = address(_community.currency);\n        memberCount = _community.memberCount;\n        publishNonce = _community.publishNonce;\n    }\n\n    /// @inheritdoc ICommunity\n    function members(uint256 _communityID)\n        external\n        view\n        virtual\n        override\n        returns (address[] memory)\n    {\n        // Initiate empty equal equal to member count length\n        address[] memory _members = new address[](\n            _communities[_communityID].memberCount\n        );\n\n        // Append member addresses in _members array\n        for (uint256 i = 0; i < _communities[_communityID].memberCount; i++) {\n            _members[i] = _communities[_communityID].members[i];\n        }\n\n        return _members;\n    }\n\n    /// @inheritdoc ICommunity\n    function projectDetails(uint256 _communityID, address _project)\n        external\n        view\n        virtual\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n\n        return (\n            _communityProject.apr,\n            _communityProject.lendingNeeded,\n            _communityProject.totalLent,\n            _communityProject.publishFee,\n            _communityProject.publishFeePaid,\n            _communityProject.lentAmount,\n            _communityProject.interest,\n            _communityProject.lastTimestamp\n        );\n    }\n\n    /*******************************************************************************\n     * -------------------------------PUBLIC VIEWS-------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    function returnToLender(uint256 _communityID, address _project)\n        public\n        view\n        override\n        returns (\n            uint256, // principal + interest\n            uint256, // principal\n            uint256, // total interest\n            uint256 // unclaimedInterest\n        )\n    {\n        // Local instance of variables. For saving gas.\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n        uint256 _lentAmount = _communityProject.lentAmount;\n\n        // Calculate number of days difference current and last timestamp\n        uint256 _noOfDays = (block.timestamp -\n            _communityProject.lastTimestamp) / 86400; // 24*60*60\n\n        /// Interest formula = (principal * APR * days) / (365 * 1000)\n        // prettier-ignore\n        uint256 _unclaimedInterest = \n                _lentAmount *\n                _communities[_communityID].projectDetails[_project].apr *\n                _noOfDays /\n                365000;\n\n        // Old (already rTokens claimed) + new interest\n        uint256 _totalInterest = _unclaimedInterest +\n            _communityProject.interest;\n\n        return (\n            _lentAmount + _totalInterest,\n            _lentAmount,\n            _totalInterest,\n            _unclaimedInterest\n        );\n    }\n\n    /// @inheritdoc ICommunity\n    function isTrustedForwarder(address _forwarder)\n        public\n        view\n        override(ERC2771ContextUpgradeable, ICommunity)\n        returns (bool)\n    {\n        return homeFi.isTrustedForwarder(_forwarder);\n    }\n\n    /*******************************************************************************\n     * ---------------------------INTERNAL TRANSACTIONS--------------------------- *\n     ****"
    }
  ]
}