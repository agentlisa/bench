{
  "Title": "[G-09] Use a more recent version of solidity",
  "Content": "\n- Use a solidity version of at least 0.8.0 to get overflow protection without SafeMath\n- Use a solidity version of at least 0.8.2 to get simple compiler automatic inlining\n- Use a solidity version of at least 0.8.3 to get better struct packing and cheaper multiple storage reads\n- Use a solidity version of at least 0.8.4 to get custom errors, which are cheaper at deployment than revert()/require() strings\n- Use a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value\n- In 0.8.15 the conditions necessary for inlining are relaxed. Benchmarks show that the change significantly decreases the bytecode size (which impacts the deployment cost) while the effect on the runtime gas usage is smaller.\n- In 0.8.17 prevent the incorrect removal of storage writes before calls to Yul functions that conditionally terminate the external EVM call; Simplify the starting offset of zero-length operations to zero. More efficient overflow checks for multiplication.\n\n 5 results - 5 files:\n```solidity\ncanto-bio-protocol/src/Bio.sol:\n\n  2: pragma solidity >=0.8.0;\n\n```\nhttps://github.com/code-423n4/2023-03-canto-identity/blob/main/canto-bio-protocol/src/Bio.sol#L2\n\n\n```solidity\ncanto-namespace-protocol/src/Namespace.sol:\n  \n  2: pragma solidity >=0.8.0;\n\n```\nhttps://github.com/code-423n4/2023-03-canto-identity/blob/main/canto-namespace-protocol/src/Namespace.sol#L2\n\n\n```solidity\ncanto-namespace-protocol/src/Tray.sol:\n\n  2: pragma solidity >=0.8.0;\n\n```\nhttps://github.com/code-423n4/2023-03-canto-identity/blob/main/canto-namespace-protocol/src/Tray.sol#L2\n\n\n```solidity\ncanto-namespace-protocol/src/Utils.sol:\n  \n  2: pragma solidity >=0.8.0;\n\n```\nhttps://github.com/code-423n4/2023-03-canto-identity/blob/main/canto-namespace-protocol/src/Utils.sol#L2  \n\n\n```solidity\ncanto-pfp-protocol/src/ProfilePicture.sol:\n  \n  2: pragma solidity >=0.8.0;\n  \n``` \nhttps://github.com/code-423n4/2023-03-canto-identity/blob/main/canto-pfp-protocol/src/ProfilePicture.sol#L2\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2023-03-canto-identity-subprotocols-contest",
  "Code": [
    {
      "filename": "canto-bio-protocol/src/Bio.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport {LibString} from \"solmate/utils/LibString.sol\";\nimport {Base64} from \"solady/utils/Base64.sol\";\nimport \"../interface/Turnstile.sol\";\n\ncontract Bio is ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Number of tokens minted\n    uint256 public numMinted;\n\n    /// @notice Stores the bio value per NFT\n    mapping(uint256 => string) public bio;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event BioAdded(address indexed minter, uint256 indexed nftID, string indexed bio);\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error TokenNotMinted(uint256 tokenID);\n    error InvalidBioLength(uint256 length);\n\n    /// @notice Initiates CSR on mainnet\n    constructor() ERC721(\"Biography\", \"Bio\") {\n        if (block.chainid == 7700) {\n            // Register CSR on Canto mainnnet\n            Turnstile turnstile = Turnstile(0xEcf044C5B4b867CFda001101c617eCd347095B44);\n            turnstile.register(tx.origin);\n        }\n    }\n\n    /// @notice Get the token URI for the specified _id\n    /// @dev Generates an on-chain SVG with a new line after 40 bytes. Line splitting generally supports UTF-8 multibyte characters and emojis, but is not tested for arbitrary UTF-8 characters\n    /// @param _id ID to query for\n    function tokenURI(uint256 _id) public view override returns (string memory) {\n        if (_ownerOf[_id] == address(0)) revert TokenNotMinted(_id);\n        string memory bioText = bio[_id];\n        bytes memory bioTextBytes = bytes(bioText);\n        uint lengthInBytes = bioTextBytes.length;\n        // Insert a new line after 40 characters, taking into account unicode character\n        uint lines = (lengthInBytes - 1) / 40 + 1;\n        string[] memory strLines = new string[](lines);\n        bool prevByteWasContinuation;\n        uint256 insertedLines;\n        // Because we do not split on zero-width joiners, line in bytes can technically be much longer. Will be shortened to the needed length afterwards\n        bytes memory bytesLines = new bytes(80);\n        uint bytesOffset;\n        for (uint i; i < lengthInBytes; ++i) {\n            bytes1 character = bioTextBytes[i];\n            bytesLines[bytesOffset] = character;\n            bytesOffset++;\n            if ((i > 0 && (i + 1) % 40 == 0) || prevByteWasContinuation || i == lengthInBytes - 1) {\n                bytes1 nextCharacter;\n                if (i != lengthInBytes - 1) {\n                    nextCharacter = bioTextBytes[i + 1];\n                }\n                if (nextCharacter & 0xC0 == 0x80) {\n                    // Unicode continuation byte, top two bits are 10\n                    prevByteWasContinuation = true;\n                } else {\n                    // Do not split when the prev. or next character is a zero width joiner. Otherwise, üë®‚Äçüëß‚Äçüë¶ could become üë®>‚Äçüëß‚Äçüë¶\n                    // Furthermore, do not split when next character is skin tone modifier to avoid ü§¶‚Äç‚ôÇÔ∏è\\nüèª\n                    if (\n                        // Note that we do not need to check i < lengthInBytes - 4, because we assume that it's a valid UTF8 string and these prefixes imply that another byte follows\n                        (nextCharacter == 0xE2 && bioTextBytes[i + 2] == 0x80 && bioTextBytes[i + 3] == 0x8D) ||\n                        (nextCharacter == 0xF0 &&\n                            bioTextBytes[i + 2] == 0x9F &&\n                            bioTextBytes[i + 3] == 0x8F &&\n                            uint8(bioTextBytes[i + 4]) >= 187 &&\n                            uint8(bioTextBytes[i + 4]) <= 191) ||\n                        (i >= 2 &&\n                            bioTextBytes[i - 2] == 0xE2 &&\n                            bioTextBytes[i - 1] == 0x80 &&\n                            bioTextBytes[i] == 0x8D)\n                    ) {\n                        prevByteWasContinuation = true;\n                        continue;\n                    }\n                    assembly {\n                        mstore(bytesLines, bytesOffset)\n                    }\n                    strLines[insertedLines++] = string(bytesLines);\n                    bytesLines = new bytes(80);\n                    prevByteWasContinuation = false;\n                    bytesOffset = 0;\n                }\n            }\n        }\n        string\n            memory svg = '<svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"xMinYMin meet\" viewBox=\"0 0 400 100\"><style>text { font-family: sans-serif; font-size: 12px; }</style>';\n        string memory text = '<text x=\"50%\" y=\"50%\" dominant-baseline=\"middle\" text-anchor=\"middle\">';\n        for (uint i; i < lines; ++i) {\n            text = string.concat(text, '<tspan x=\"50%\" dy=\"20\">', strLines[i], \"</tspan>\");\n        }\n        string memory json = Base64.encode(\n            bytes(\n                string.concat(\n                    '{\"name\": \"Bio #',\n                    LibString.toString(_id),\n                    '\", \"description\": \"',\n                    bioText,\n                    '\", \"image\": \"data:image/svg+xml;base64,',\n                    Base64.encode(bytes(string.concat(svg, text, \"</text></svg>\"))),\n                    '\"}'\n                )\n            )\n        );\n        return string(abi.encodePacked(\"data:application/json;base64,\", json));\n    }\n\n    /// @notice Mint a new Bio NFT\n    /// @param _bio The text to add\n    function mint(string calldata _bio) external {\n        // We check the length in bytes, so will be higher for UTF-8 characters. But sufficient for this check\n        if (bytes(_bio).length == 0 || bytes(_bio).length > 200) revert InvalidBioLength(bytes(_bio).length);\n        uint256 tokenId = ++numMinted;\n        bio[tokenId] = _bio;\n        _mint(msg.sender, tokenId);\n        emit BioAdded(msg.sender, tokenId, _bio);\n    }\n}"
    },
    {
      "filename": "canto-namespace-protocol/src/Namespace.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {Base64} from \"solady/utils/Base64.sol\";\nimport \"./Tray.sol\";\nimport \"./Utils.sol\";\nimport \"../interface/Turnstile.sol\";\n\ncontract Namespace is ERC721, Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Reference to the Tray NFT\n    Tray public immutable tray;\n\n    /// @notice Reference to the $NOTE TOKEN\n    ERC20 public note;\n\n    /// @notice Wallet that receives the revenue\n    address private revenueAddress;\n\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice References the tile for fusing by specifying the tray ID and the index within the tray\n    struct CharacterData {\n        /// @notice ID of the Tray NFT\n        uint256 trayID;\n        /// @notice Offset of the tile within the tray. Valid values 0..TILES_PER_TRAY - 1\n        uint8 tileOffset;\n        /// @notice Emoji modifier for the skin tone. Can have values of 0 (yellow) and 1 - 5 (light to dark). Only supported by some emojis\n        uint8 skinToneModifier;\n    }\n\n    /// @notice Next Namespace ID to mint. We start with minting at ID 1\n    uint256 public nextNamespaceIDToMint;\n\n    /// @notice Maps names to NFT IDs\n    mapping(string => uint256) public nameToToken;\n\n    /// @notice Maps NFT IDs to (ASCII) names\n    mapping(uint256 => string) public tokenToName;\n\n    /// @notice Stores the character data of an NFT\n    mapping(uint256 => Tray.TileData[]) private nftCharacters;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event NamespaceFused(address indexed fuser, uint256 indexed namespaceId, string indexed name);\n    event RevenueAddressUpdated(address indexed oldRevenueAddress, address indexed newRevenueAddress);\n    event NoteAddressUpdate(address indexed oldNoteAddress, address indexed newNoteAddress);\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error CallerNotAllowedToFuse();\n    error CallerNotAllowedToBurn();\n    error InvalidNumberOfCharacters(uint256 numCharacters);\n    error FusingDuplicateCharactersNotAllowed();\n    error NameAlreadyRegistered(uint256 nftID);\n    error TokenNotMinted(uint256 tokenID);\n    error CannotFuseCharacterWithSkinTone();\n\n    /// @notice Sets the reference to the tray\n    /// @param _tray Address of the tray contract\n    /// @param _note Address of the $NOTE token\n    /// @param _revenueAddress Adress to send the revenue to\n    constructor(\n        address _tray,\n        address _note,\n        address _revenueAddress\n    ) ERC721(\"Namespace\", \"NS\") Owned(msg.sender) {\n        tray = Tray(_tray);\n        note = ERC20(_note);\n        revenueAddress = _revenueAddress;\n        if (block.chainid == 7700) {\n            // Register CSR on Canto mainnnet\n            Turnstile turnstile = Turnstile(0xEcf044C5B4b867CFda001101c617eCd347095B44);\n            turnstile.register(tx.origin);\n        }\n    }\n\n    /// @notice Get the token URI for the specified _id\n    /// @param _id ID to query for\n    function tokenURI(uint256 _id) public view override returns (string memory) {\n        if (_ownerOf[_id] == address(0)) revert TokenNotMinted(_id);\n        string memory json = Base64.encode(\n            bytes(\n                string(\n                    abi.encodePacked(\n                        '{\"name\": \"',\n                        tokenToName[_id],\n                        '\", \"image\": \"data:image/svg+xml;base64,',\n                        Base64.encode(bytes(Utils.generateSVG(nftCharacters[_id], false))),\n                        '\"}'\n                    )\n                )\n            )\n        );\n        return string(abi.encodePacked(\"data:application/json;base64,\", json));\n    }\n\n    /// @notice Fuse a new Namespace NFT with the referenced tiles\n    /// @param _characterList The tiles to use for the fusing\n    function fuse(CharacterData[] calldata _characterList) external {\n        uint256 numCharacters = _characterList.length;\n        if (numCharacters > 13 || numCharacters == 0) revert InvalidNumberOfCharacters(numCharacters);\n        uint256 fusingCosts = 2**(13 - numCharacters) * 1e18;\n        SafeTransferLib.safeTransferFrom(note, msg.sender, revenueAddress, fusingCosts);\n        uint256 namespaceIDToMint = ++nextNamespaceIDToMint;\n        Tray.TileData[] storage nftToMintCharacters = nftCharacters[namespaceIDToMint];\n        bytes memory bName = new bytes(numCharacters * 33); // Used to convert into a string. Can be 33 times longer than the string at most (longest zalgo characters is 33 bytes)\n        uint256 numBytes;\n        // Extract unique trays for burning them later on\n        uint256 numUniqueTrays;\n        uint256[] memory uniqueTrays = new uint256[](_characterList.length);\n        for (uint256 i; i < numCharacters; ++i) {\n            bool isLastTrayEntry = true;\n            uint256 trayID = _characterList[i].trayID;\n            uint8 tileOffset = _characterList[i].tileOffset;\n            // Check for duplicate characters in the provided list. 1/2 * n^2 loop iterations, but n is bounded to 13 and we do not perform any storage operations\n            for (uint256 j = i + 1; j < numCharacters; ++j) {\n                if (_characterList[j].trayID == trayID) {\n                    isLastTrayEntry = false;\n                    if (_characterList[j].tileOffset == tileOffset) revert FusingDuplicateCharactersNotAllowed();\n                }\n            }\n            Tray.TileData memory tileData = tray.getTile(trayID, tileOffset); // Will revert if tileOffset is too high\n            uint8 characterModifier = tileData.characterModifier;\n\n            if (tileData.fontClass != 0 && _characterList[i].skinToneModifier != 0) {\n                revert CannotFuseCharacterWithSkinTone();\n            }\n            \n            if (tileData.fontClass == 0) {\n                // Emoji\n                characterModifier = _characterList[i].skinToneModifier;\n            }\n            bytes memory charAsBytes = Utils.characterToUnicodeBytes(0, tileData.characterIndex, characterModifier);\n            tileData.characterModifier = characterModifier;\n            uint256 numBytesChar = charAsBytes.length;\n            for (uint256 j; j < numBytesChar; ++j) {\n                bName[numBytes + j] = charAsBytes[j];\n            }\n            numBytes += numBytesChar;\n            nftToMintCharacters.push(tileData);\n            // We keep track of the unique trays NFTs (for burning them) and only check the owner once for the last occurence of the tray\n            if (isLastTrayEntry) {\n                uniqueTrays[numUniqueTrays++] = trayID;\n                // Verify address is allowed to fuse\n                address trayOwner = tray.ownerOf(trayID);\n                if (\n                    trayOwner != msg.sender &&\n                    tray.getApproved(trayID) != msg.sender &&\n                    !tray.isApprovedForAll(trayOwner, msg.sender)\n                ) revert CallerNotAllowedToFuse();\n            }\n        }\n        // Set array to the real length (in bytes) to avoid zero bytes in the end when doing the string conversion\n        assembly {\n            mstore(bName, numBytes)\n        }\n        string memory nameToRegister = string(bName);\n        uint256 currentRegisteredID = nameToToken[nameToRegister];\n        if (currentRegisteredID != 0) revert NameAlreadyRegistered(currentRegisteredID);\n        nameToToken[nameToRegister] = namespaceIDToMint;\n        tokenToName[namespaceIDToMint] = nameToRegister;\n\n        for (uint256 i; i < numUniqueTrays; ++i) {\n            tray.burn(uniqueTrays[i]);\n        }\n        _mint(msg.sender, namespaceIDToMint);\n        // Although _mint already emits an event, we additionally emit one because of the name\n        emit NamespaceFused(msg.sender, namespaceIDToMint, nameToRegister);\n    }\n\n    /// @notice Burn a specified Namespace NFT\n    /// @param _id Namespace NFT ID\n    function burn(uint256 _id) external {\n        address nftOwner = ownerOf(_id);\n        if (nftOwner != msg.sender && getApproved[_id] != msg.sender && !isApprovedForAll[nftOwner][msg.sender])\n            revert CallerNotAllowedToBurn();\n        string memory associatedName = tokenToName[_id];\n        delete tokenToName[_id];\n        delete nameToToken[associatedName];\n        _burn(_id);\n    }\n\n    /// @notice Change the address of the $NOTE token\n    /// @param _newNoteAddress New address to use\n    function changeNoteAddress(address _newNoteAddress) external onlyOwner {\n        address currentNoteAddress = address(note);\n        note = ERC20(_newNoteAddress);\n        emit NoteAddressUpdate(currentNoteAddress, _newNoteAddress);\n    }\n\n    /// @notice Change the revenue address\n    /// @param _newRevenueAddress New address to use\n    function changeRevenueAddress(address _newRevenueAddress) external onlyOwner {\n        address currentRevenueAddress = revenueAddress;\n        revenueAddress = _newRevenueAddress;\n        emit RevenueAddressUpdated(currentRevenueAddress, _newRevenueAddress);\n    }\n}"
    },
    {
      "filename": "canto-namespace-protocol/src/Tray.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC721A} from \"erc721a/ERC721A.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {LibString} from \"solmate/utils/LibString.sol\";\nimport {Base64} from \"solady/utils/Base64.sol\";\nimport \"./Utils.sol\";\nimport \"../interface/Turnstile.sol\";\n\ncontract Tray is ERC721A, Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Number of tiles that are in one tray\n    uint256 private constant TILES_PER_TRAY = 7;\n\n    /// @notice Sum of the odds for all fonts\n    uint256 private constant SUM_ODDS = 109;\n\n    /// @notice Number of characters for emojis\n    uint256 private constant NUM_CHARS_EMOJIS = 420;\n\n    /// @notice Number of characters for letters\n    uint256 private constant NUM_CHARS_LETTERS = 26;\n\n    /// @notice Number of characters for letters and numbers\n    uint256 private constant NUM_CHARS_LETTERS_NUMBERS = 36;\n\n    /// @notice Maximum number of trays that can be minted pre-launch (by the owner)\n    uint256 private constant PRE_LAUNCH_MINT_CAP = 1_000;\n\n    /// @notice Price of one tray in $NOTE\n    uint256 public immutable trayPrice;\n\n    /*//////////////////////////////////////////////////////////////\n                                 ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Wallet that receives the revenue\n    address private revenueAddress;\n\n    /// @notice Reference to the $NOTE TOKEN\n    ERC20 public note;\n\n    /// @notice Reference to the Namespace NFT contract\n    address public immutable namespaceNFT;\n\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Font and character index of a tile\n    struct TileData {\n        /// @notice Allowed values between 0 (emoji) and 9 (font5 rare)\n        uint8 fontClass;\n        /// @notice For Emojis (font class 0) between 0..NUM_CHARS_EMOJIS - 1, otherwise between 0..NUM_CHARS_LETTERS - 1\n        uint16 characterIndex;\n        /// @notice For generative fonts with randomness (Zalgo), we generate and fix this on minting. For some emojis, it can be set by the user to influence the skin color\n        uint8 characterModifier;\n    }\n\n    /// @notice Stores the content of a tray, i.e. all tiles\n    mapping(uint256 => TileData[TILES_PER_TRAY]) private tiles;\n\n    ///¬†@notice Last hash that was used to generate a tray\n    bytes32 public lastHash;\n\n    /// @notice Set to the number of minted NFTs after the prelaunch has ended\n    uint256 private prelaunchMinted = type(uint256).max;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event RevenueAddressUpdated(address indexed oldRevenueAddress, address indexed newRevenueAddress);\n    event NoteAddressUpdate(address indexed oldNoteAddress, address indexed newNoteAddress);\n    event PrelaunchEnded();\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error CallerNotAllowedToBurn();\n    error TrayNotMinted(uint256 tokenID);\n    error OnlyOwnerCanMintPreLaunch();\n    error MintExceedsPreLaunchAmount();\n    error PrelaunchTrayCannotBeUsedAfterPrelaunch(uint256 startTokenId);\n    error PrelaunchAlreadyEnded();\n\n    /// @notice Sets the initial hash, tray price, and the revenue address\n    /// @param _initHash Hash to initialize the system with. Will determine the generation sequence of the trays\n    /// @param _trayPrice Price of one tray in $NOTE\n    /// @param _revenueAddress Adress to send the revenue to\n    /// @param _note Address of the $NOTE token\n    /// @param _namespaceNFT Address of the Namespace NFT\n    constructor(\n        bytes32 _initHash,\n        uint256 _trayPrice,\n        address _revenueAddress,\n        address _note,\n        address _namespaceNFT\n    ) ERC721A(\"Namespace Tray\", \"NSTRAY\") Owned(msg.sender) {\n        lastHash = _initHash;\n        trayPrice = _trayPrice;\n        revenueAddress = _revenueAddress;\n        note = ERC20(_note);\n        namespaceNFT = _namespaceNFT;\n        if (block.chainid == 7700) {\n            // Register CSR on Canto mainnnet\n            Turnstile turnstile = Turnstile(0xEcf044C5B4b867CFda001101c617eCd347095B44);\n            turnstile.register(tx.origin);\n        }\n    }\n\n    /// @notice Get the token URI for the specified _id\n    /// @param _id ID to query for\n    function tokenURI(uint256 _id) public view override returns (string memory) {\n        if (!_exists(_id)) revert TrayNotMinted(_id);\n        uint256 numPrelaunchMinted = prelaunchMinted;\n        if (numPrelaunchMinted != type(uint256).max) {\n            // Prelaunch trays become invalid after the phase has ended\n            if (_id <= numPrelaunchMinted) revert PrelaunchTrayCannotBeUsedAfterPrelaunch(_id);\n        }\n        // Need to do an explicit copy here, implicit one not supported\n        TileData[TILES_PER_TRAY] storage storedNftTiles = tiles[_id];\n        TileData[] memory nftTiles = new TileData[](TILES_PER_TRAY);\n        for (uint256 i; i < TILES_PER_TRAY; ++i) {\n            nftTiles[i] = storedNftTiles[i];\n        }\n        string memory json = Base64.encode(\n            bytes(\n                string(\n                    abi.encodePacked(\n                        '{\"name\": \"Tray #',\n                        LibString.toString(_id),\n                        '\", \"image\": \"data:image/svg+xml;base64,',\n                        Base64.encode(bytes(Utils.generateSVG(nftTiles, true))),\n                        '\"}'\n                    )\n                )\n            )\n        );\n        return string(abi.encodePacked(\"data:application/json;base64,\", json));\n    }\n\n    /// @notice Buy a specifiable amount of trays\n    /// @param _amount Amount of trays to buy\n    function buy(uint256 _amount) external {\n        uint256 startingTrayId = _nextTokenId();\n        if (prelaunchMinted == type(uint256).max) {\n            // Still in prelaunch phase\n            if (msg.sender != owner) revert OnlyOwnerCanMintPreLaunch();\n            if (startingTrayId + _amount - 1 > PRE_LAUNCH_MINT_CAP) revert MintExceedsPreLaunchAmount();\n        } else {\n            SafeTransferLib.safeTransferFrom(note, msg.sender, revenueAddress, _amount * trayPrice);\n        }\n        for (uint256 i; i < _amount; ++i) {\n            TileData[TILES_PER_TRAY] memory trayTiledata;\n            for (uint256 j; j < TILES_PER_TRAY; ++j) {\n                lastHash = keccak256(abi.encode(lastHash));\n                trayTiledata[j] = _drawing(uint256(lastHash));\n            }\n            tiles[startingTrayId + i] = trayTiledata;\n        }\n        _mint(msg.sender, _amount); // We do not use _safeMint on purpose here to disallow callbacks and save gas\n    }\n\n    /// @notice Burn a specified tray\n    /// @dev Callable by the owner, an authorized address, or the Namespace NFT (when fusing)\n    /// @param _id Tray ID\n    function burn(uint256 _id) external {\n        address trayOwner = ownerOf(_id);\n        if (\n            namespaceNFT != msg.sender &&\n            trayOwner != msg.sender &&\n            getApproved(_id) != msg.sender &&\n            !isApprovedForAll(trayOwner, msg.sender)\n        ) revert CallerNotAllowedToBurn();\n        if (msg.sender == namespaceNFT) {\n            // Disallow fusing for prelaunch trays after phase has ended\n            uint256 numPrelaunchMinted = prelaunchMinted;\n            if (numPrelaunchMinted != type(uint256).max && _id <= numPrelaunchMinted)\n                revert PrelaunchTrayCannotBeUsedAfterPrelaunch(_id);\n        }\n        delete tiles[_id];\n        _burn(_id);\n    }\n\n    /// @notice Get the information about one tile\n    /// @dev Reverts for non-existing tray ID\n    /// @param _trayId Tray to query\n    /// @param _tileOffset Offset of the tile within the query, needs to be between 0 .. TILES_PER_TRAY - 1\n    function getTile(uint256 _trayId, uint8 _tileOffset) external view returns (TileData memory tileData) {\n        if (!_exists(_trayId)) revert TrayNotMinted(_trayId);\n        tileData = tiles[_trayId][_tileOffset];\n    }\n\n    /// @notice Query all tiles of a tray\n    /// @dev Reverts for non-existing tray ID\n    /// @param _trayId Tray to query\n    function getTiles(uint256 _trayId) external view returns (TileData[TILES_PER_TRAY] memory tileData) {\n        if (!_exists(_trayId)) revert TrayNotMinted(_trayId);\n        tileData = tiles[_trayId];\n    }\n\n    /// @notice Change the address of the $NOTE token\n    /// @param _newNoteAddress New address to use\n    function changeNoteAddress(address _newNoteAddress) external onlyOwner {\n        address currentNoteAddress = address(note);\n        note = ERC20(_newNoteAddress);\n        emit NoteAddressUpdate(currentNoteAddress, _newNoteAddress);\n    }\n\n    /// @notice Change the revenue address\n    /// @param _newRevenueAddress New address to use\n    function changeRevenueAddress(address _newRevenueAddress) external onlyOwner {\n        address currentRevenueAddress = revenueAddress;\n        revenueAddress = _newRevenueAddress;\n        emit RevenueAddressUpdated(currentRevenueAddress, _newRevenueAddress);\n    }\n\n    /// @notice End the prelaunch phase and start the public mint\n    function endPrelaunchPhase() external onlyOwner {\n        if (prelaunchMinted != type(uint256).max) revert PrelaunchAlreadyEnded();\n        prelaunchMinted = _nextTokenId() - 1;\n        emit PrelaunchEnded();\n    }\n\n    function _beforeTokenTransfers(\n        address, /* from*/\n        address to,\n        uint256 startTokenId,\n        uint256 /* quantity*/\n    ) internal view override {\n        uint256 numPrelaunchMinted = prelaunchMinted;\n        if (numPrelaunchMinted != type(uint256).max) {\n            // We do not allow any transfers of the prelaunch trays after the phase has ended\n            if (startTokenId <= numPrelaunchMinted && to != address(0))\n                revert PrelaunchTrayCannotBeUsedAfterPrelaunch(startTokenId);\n        }\n    }\n\n    function _drawing(uint256 _seed) private pure returns (TileData memory tileData) {\n        uint256 res = _seed % SUM_ODDS;\n        uint256 charRandValue = Utils.iteratePRNG(_seed); // Iterate PRNG to not have any biasedness / correlation between random numbers\n        if (res < 32) {\n            // Class is 0 in that case\n            tileData.characterIndex = uint16(charRandValue % NUM_CHARS_EMOJIS);\n        } else {\n            tileData.characterIndex = uint16(charRandValue % NUM_CHARS_LETTERS);\n            if (res < 64) {\n                tileData.fontClass = 1;\n                tileData.characterIndex = uint16(charRandValue % NUM_CHARS_LETTERS_NUMBERS);\n            } else if (res < 80) {\n                tileData.fontClass = 2;\n            } else if (res < 96) {\n                tileData.fontClass = 3 + uint8((res - 80) / 8);\n            } else if (res < 104) {\n                tileData.fontClass = 5 + uint8((res - 96) / 4);\n            } else if (res < 108) {\n                tileData.fontClass = 7 + uint8((res - 104) / 2);\n                if (tileData.fontClass == 7) {\n                    // Set seed for Zalgo to ensure same characters will be always generated for this tile\n                    uint256 zalgoSeed = Utils.iteratePRNG(_seed);\n                    tileData.characterModifier = uint8(zalgoSeed % 256);\n                }\n            } else {\n                tileData.fontClass = 9;\n            }\n        }\n    }\n\n    /// @dev Overridden function of ERC721A to start minting at 1\n    function _startTokenId() internal pure override returns (uint256) {\n        return 1;\n    }\n}"
    },
    {
      "filename": "canto-namespace-protocol/src/Utils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport \"./Tray.sol\";\nimport {LibString} from \"solmate/utils/LibString.sol\";\n\n/// @notice Utiltities for the on-chain SVG generation of the text data and pseudo randomness\nlibrary Utils {\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error EmojiDoesNotSupportSkinToneModifier(uint16 emojiIndex);\n    error InvalidSkinToneModifierProvided(uint256 characterModifier);\n\n    /// @notice UTF-8 encoding of the squiggle characters. The characters have a different length (1 to 3 bytes)\n    bytes private constant FONT_SQUIGGLE =\n        hex\"CEB1E182A6C688D483D2BDCF9DC9A0D48BCEB9CA9DC699CA85C9B1C9B3CF83CF81CF99C9BECA82C69ACF85CA8BC9AF78E183A7C8A5\";\n\n    /// @notice UTF-8 encoding of possible characters that can be above a letter for Zalgo. All characters have a length of 2 bytes\n    bytes private constant ZALGO_ABOVE_LETTER =\n        hex\"CC80CC81CC82CC83CC84CC85CC86CC87CC88CC89CC8ACC8BCC8CCC8DCC8ECC8FCC90CC91CC92CC93CC94CC95CC9ACC9BCCBDCCBECCBFCD80CD81CD82CD83CD84CD86CD8ACD8BCD8CCD90CD91CD92CD97CD98CD9BCD9DCD9ECDA0CDA1\";\n\n    /// @notice Number of characters that can be above a letter for Zalgo\n    uint256 private constant ZALGO_NUM_ABOVE = 46;\n\n    /// @notice UTF-8 encoding of possible characters that can be below a letter for Zalgo. All characters have a length of 2 bytes\n    bytes private constant ZALGO_BELOW_LETTER =\n        hex\"CC96CC97CC98CC99CC9CCC9DCC9ECC9FCCA0CCA1CCA2CCA3CCA4CCA5CCA6CCA7CCA8CCA9CCAACCABCCACCCADCCAECCAFCCB0CCB1CCB2CCB3CCB9CCBACCBBCCBCCD85CD87CD88CD89CD8DCD8ECD93CD94CD95CD96CD99CD9ACD9CCD9FCDA2\";\n\n    /// @notice Number of characters that can be below a letter for Zalgo\n    uint256 private constant ZALGO_NUM_BELOW = 47;\n\n    /// @notice UTF-8 encoding of possible characters that can be over a letter (i.e., in the middle) for Zalgo. All characters have a length of 2 bytes\n    bytes private constant ZALGO_OVER_LETTER = hex\"CCB4CCB5CCB6CCB7CCB8\";\n\n    /// @notice Number of characters that can be over a letter for Zalgo\n    uint256 private constant ZALGO_NUM_OVER = 5;\n\n    /// @notice UTF-8 encoding of all supported emojis. They are sorted by their length in bytes (all with 3 bytes first, then all with four bytes, ...)\n    /// For emojis with the same length, the emojis that do not support skin tone modifier come first.\n    /// @dev This string is generated by the script utils/gen_emoji_string.py\n    bytes private constant EMOJIS =\n        hex\"E29CA8E29C85E29D97E29AA1E29895E2AD90E29D8CE29ABDE29D93E28FB0E2AD95E29AABE29ABEE29894E29AAAE29C8BE29C8AF09F9882F09FA4A3F09F98ADF09F9898F09FA5B0F09F988DF09F988AF09F8E89F09F9881F09F9295F09FA5BAF09F9885F09F94A5F09F9984F09F9886F09FA497F09F9889F09F8E82F09FA494F09F9982F09F98B3F09FA5B3F09F988EF09F929CF09F9894F09F9296F09F9180F09F988BF09F988FF09F98A2F09F9297F09F98A9F09F92AFF09F8CB9F09F929EF09F8E88F09F9299F09F9883F09F98A1F09F9290F09F989CF09F9988F09F9884F09FA4A4F09FA4AAF09F9880F09F928BF09F9280F09F9294F09F988CF09F9293F09FA4A9F09F9983F09F98ACF09F98B1F09F98B4F09FA4ADF09F9890F09F8C9EF09F9892F09F9887F09F8CB8F09F9888F09F8EB6F09F8E8AF09FA5B5F09F989EF09F929AF09F96A4F09F92B0F09F989AF09F9191F09F8E81F09F92A5F09F9891F09FA5B4F09F92A9F09FA4AEF09F98A4F09FA4A2F09F8C9FF09F98A5F09F8C88F09F929BF09F989DF09F98ABF09F98B2F09F94B4F09F8CBBF09FA4AFF09FA4ACF09F9895F09F8D80F09F92A6F09FA68BF09FA4A8F09F8CBAF09F98B9F09F8CB7F09F929DF09F92A4F09F90B0F09F9893F09F9298F09F8DBBF09F989FF09F98A3F09FA790F09F98A0F09FA4A0F09F98BBF09F8C99F09F989BF09F998AF09FA7A1F09FA4A1F09FA4ABF09F8CBCF09FA582F09F98B7F09FA493F09FA5B6F09F98B6F09F9896F09F8EB5F09F9899F09F8D86F09FA491F09F9897F09F90B6F09F8D93F09F9185F09F9184F09F8CBFF09F9AA8F09F93A3F09F8D91F09F8D83F09F98AEF09F928EF09F93A2F09F8CB1F09F9981F09F8DB7F09F98AAF09F8C9AF09F8F86F09F8D92F09F9289F09F92A2F09F9B92F09F98B8F09F90BEF09F9A80F09F8EAFF09F8DBAF09F938CF09F93B7F09F92A8F09F8D95F09F8FA0F09F93B8F09F9087F09F9AA9F09F98B0F09F8C8AF09F9095F09F92ABF09F98B5F09F8EA4F09F8FA1F09FA580F09FA4A7F09F8DBEF09F8DB0F09F8D81F09F98AFF09F928CF09F92B8F09FA781F09F98BAF09F92A7F09F92A3F09FA490F09F8D8EF09F90B7F09F90A5F09F938DF09F8E80F09FA587F09F8C9DF09F94ABF09F90B1F09F90A3F09F8EA7F09F929FF09F91B9F09F928DF09F8DBCF09F92A1F09F98BDF09F8D8AF09F98A8F09F8DABF09FA7A2F09FA495F09F9AABF09F8EBCF09F90BBF09F93B2F09F91BBF09F91BFF09F8CAEF09F8DADF09F909FF09F90B8F09F909DF09F9088F09F94B5F09F94AAF09F98A7F09F8C84F09F98BEF09F93B1F09F8D87F09F8CB4F09F90A2F09F8C83F09F91BDF09F8D8CF09F93BAF09F9494F09F8C85F09FA684F09F8EA5F09F8D8BF09FA59AF09F92B2F09F939AF09F9094F09F8EB8F09FA583F09F98BFF09F9A97F09F8C8EF09F948AF09FA685F09F9ABFF09FA686F09F8D89F09F8DA"
    }
  ]
}