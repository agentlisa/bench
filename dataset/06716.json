{
  "Title": "[G-12] Use a `do while` loop instead of a `for` loop",
  "Content": "A `do while` loop will cost less gas since the condition is not being checked for the first iteration.\n\n**Note: Other optimizations, such as caching length, precrementing, and using unchecked blocks are not included in the Diff since they are included in the automated findings report.**\n\nTotal Instances: `8`\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/DNSSECImpl.sol#L118-L126\n\n*Gas Savings for `DNSRegistrar.proveAndClaimWithResolver`, obtained via protocol's tests: Avg 60 gas* \n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  301464  |  339399  |  320432 |    2     |\n| After  |  301404  |  339339  |  320372 |    2     |\n\n```solidity\nFile: contracts/dnssec-oracle/DNSSECImpl.sol\n118:        for (uint256 i = 0; i < input.length; i++) {\n119:            RRUtils.SignedSet memory rrset = validateSignedSet(\n120:                input[i],\n121:                proof,\n122:                now\n123:            );\n124:            proof = rrset.data;\n125:            inception = rrset.inception;\n126:        }\n```\n```diff\ndiff --git a/contracts/dnssec-oracle/DNSSECImpl.sol b/contracts/dnssec-oracle/DNSSECImpl.sol\nindex a3e4e5f..c30d8ba 100644\n--- a/contracts/dnssec-oracle/DNSSECImpl.sol\n+++ b/contracts/dnssec-oracle/DNSSECImpl.sol\n@@ -115,7 +115,8 @@ contract DNSSECImpl is DNSSEC, Owned {\n         returns (bytes memory rrs, uint32 inception)\n     {\n         bytes memory proof = anchors;\n-        for (uint256 i = 0; i < input.length; i++) {\n+        uint256 i;\n+        do {\n             RRUtils.SignedSet memory rrset = validateSignedSet(\n                 input[i],\n                 proof,\n@@ -123,7 +124,8 @@ contract DNSSECImpl is DNSSEC, Owned {\n             );\n             proof = rrset.data;\n             inception = rrset.inception;\n-        }\n+            i++;\n+        } while (i < input.length);\n         return (proof, inception);\n     }\n```\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/DNSSECImpl.sol#L260-L274\n\n*Gas Savings for `DNSRegistrar.proveAndClaimWithResolver`, obtained via protocol's tests: Avg 62 gas* \n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  301464  |  339399  |  320432 |    2     |\n| After  |  301402  |  339337  |  320370 |    2     |\n\n```solidity\nFile: contracts/dnssec-oracle/DNSSECImpl.sol\n260:        for (; !proof.done(); proof.next()) {\n261:            bytes memory proofName = proof.name();\n262:            if (!proofName.equals(rrset.signerName)) {\n263:                revert ProofNameMismatch(rrset.signerName, proofName);\n264:            }\n265:\n266:            bytes memory keyrdata = proof.rdata();\n267:            RRUtils.DNSKEY memory dnskey = keyrdata.readDNSKEY(\n268:                0,\n269:                keyrdata.length\n270:            );\n271:            if (verifySignatureWithKey(dnskey, keyrdata, rrset, data)) {\n272:                return;\n273:            }\n274:        }\n```\n```diff\ndiff --git a/contracts/dnssec-oracle/DNSSECImpl.sol b/contracts/dnssec-oracle/DNSSECImpl.sol\nindex a3e4e5f..a357e70 100644\n--- a/contracts/dnssec-oracle/DNSSECImpl.sol\n+++ b/contracts/dnssec-oracle/DNSSECImpl.sol\n@@ -257,7 +257,7 @@ contract DNSSECImpl is DNSSEC, Owned {\n         RRUtils.RRIterator memory proof\n     ) internal view {\n         // Check the DNSKEY's owner name matches the signer name on the RRSIG\n-        for (; !proof.done(); proof.next()) {\n+        do {\n             bytes memory proofName = proof.name();\n             if (!proofName.equals(rrset.signerName)) {\n                 revert ProofNameMismatch(rrset.signerName, proofName);\n@@ -271,7 +271,9 @@ contract DNSSECImpl is DNSSEC, Owned {\n             if (verifySignatureWithKey(dnskey, keyrdata, rrset, data)) {\n                 return;\n             }\n-        }\n+            proof.next();\n+        } while (!proof.done());\n+\n         revert NoMatchingProof(rrset.signerName);\n     }\n```\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/DNSSECImpl.sol#L181-L213\n\n*Gas Savings for `DNSRegistrar.proveAndClaimWithResolver`, obtained via protocol's tests: Avg 140 gas* \n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  301464  |  339399  |  320432 |    2     |\n| After  |  301324  |  339259  |  320292 |    2     |\n\n```solidity\nFile: contracts/dnssec-oracle/DNSSECImpl.sol\n181:    function validateRRs(\n182:        RRUtils.SignedSet memory rrset,\n183:        uint16 typecovered\n184:    ) internal pure returns (bytes memory name) {\n185:        // Iterate over all the RRs\n186:        for (\n187:            RRUtils.RRIterator memory iter = rrset.rrs();\n188:            !iter.done();\n189:            iter.next()\n190:        ) {\n191:            // We only support class IN (Internet)\n192:            if (iter.class != DNSCLASS_IN) {\n193:                revert InvalidClass(iter.class);\n194:            }\n195:\n196:            if (name.length == 0) {\n197:                name = iter.name();\n198:            } else {\n199:                // Name must be the same on all RRs. We do things this way to avoid copying the name\n200:                // repeatedly.\n201:                if (\n202:                    name.length != iter.data.nameLength(iter.offset) ||\n203:                    !name.equals(0, iter.data, iter.offset, name.length)\n204:                ) {\n205:                    revert InvalidRRSet();\n206:                }\n207:            }\n208:\n209:            // o  The RRSIG RR's Type Covered field MUST equal the RRset's type.\n210:            if (iter.dnstype != typecovered) {\n211:                revert SignatureTypeMismatch(iter.dnstype, typecovered);\n212:            }\n213:        }\n```\n```diff\ndiff --git a/contracts/dnssec-oracle/DNSSECImpl.sol b/contracts/dnssec-oracle/DNSSECImpl.sol\nindex a3e4e5f..f09438a 100644\n--- a/contracts/dnssec-oracle/DNSSECImpl.sol\n+++ b/contracts/dnssec-oracle/DNSSECImpl.sol\n@@ -183,11 +183,8 @@ contract DNSSECImpl is DNSSEC, Owned {\n         uint16 typecovered\n     ) internal pure returns (bytes memory name) {\n         // Iterate over all the RRs\n-        for (\n-            RRUtils.RRIterator memory iter = rrset.rrs();\n-            !iter.done();\n-            iter.next()\n-        ) {\n+        RRUtils.RRIterator memory iter = rrset.rrs();\n+        do {\n             // We only support class IN (Internet)\n             if (iter.class != DNSCLASS_IN) {\n                 revert InvalidClass(iter.class);\n@@ -210,7 +207,8 @@ contract DNSSECImpl is DNSSEC, Owned {\n             if (iter.dnstype != typecovered) {\n                 revert SignatureTypeMismatch(iter.dnstype, typecovered);\n             }\n-        }\n+            iter.next();\n+        } while (!iter.done());\n     }\n```\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/DNSSECImpl.sol#L330-L361\n\n*Gas Savings for `DNSRegistrar.proveAndClaimWithResolver`, obtained via protocol's tests: Avg 68 gas* \n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  301464  |  339399  |  320432 |    2     |\n| After  |  301396  |  339331  |  320364 |    2     |\n\n```solidity\nFile: contracts/dnssec-oracle/DNSSECImpl.sol\n330:    function verifyWithDS(\n331:        RRUtils.SignedSet memory rrset,\n332:        RRSetWithSignature memory data,\n333:        RRUtils.RRIterator memory proof\n334:    ) internal view {\n335:        uint256 proofOffset = proof.offset;\n336:        for (\n337:            RRUtils.RRIterator memory iter = rrset.rrs();\n338:            !iter.done();\n339:            iter.next()\n340:        ) {\n341:            if (iter.dnstype != DNSTYPE_DNSKEY) {\n342:                revert InvalidProofType(iter.dnstype);\n343:            }\n344:\n345:            bytes memory keyrdata = iter.rdata();\n346:            RRUtils.DNSKEY memory dnskey = keyrdata.readDNSKEY(\n347:                0,\n348:                keyrdata.length\n349:            );\n350:            if (verifySignatureWithKey(dnskey, keyrdata, rrset, data)) {\n351:                // It's self-signed - look for a DS record to verify it.\n352:                if (\n353:                    verifyKeyWithDS(rrset.signerName, proof, dnskey, keyrdata)\n354:                ) {\n355:                    return;\n356:                }\n357:                // Rewind proof iterator to the start for the next loop iteration.\n358:                proof.nextOffset = proofOffset;\n359:                proof.next();\n360:            }\n361:        }\n```\n```diff\ndiff --git a/contracts/dnssec-oracle/DNSSECImpl.sol b/contracts/dnssec-oracle/DNSSECImpl.sol\nindex a3e4e5f..66cc74e 100644\n--- a/contracts/dnssec-oracle/DNSSECImpl.sol\n+++ b/contracts/dnssec-oracle/DNSSECImpl.sol\n@@ -333,11 +333,8 @@ contract DNSSECImpl is DNSSEC, Owned {\n         RRUtils.RRIterator memory proof\n     ) internal view {\n         uint256 proofOffset = proof.offset;\n-        for (\n-            RRUtils.RRIterator memory iter = rrset.rrs();\n-            !iter.done();\n-            iter.next()\n-        ) {\n+        RRUtils.RRIterator memory iter = rrset.rrs();\n+        do {\n             if (iter.dnstype != DNSTYPE_DNSKEY) {\n                 revert InvalidProofType(iter.dnstype);\n             }\n@@ -358,7 +355,8 @@ contract DNSSECImpl is DNSSEC, Owned {\n                 proof.nextOffset = proofOffset;\n                 proof.next();\n             }\n-        }\n+            iter.next();\n+        } while (!iter.done());\n         revert NoMatchingProof(rrset.signerName);\n     }\n```\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/DNSSECImpl.sol#L373-L404\n\n*Gas Savings for `DNSRegistrar.proveAndClaimWithResolver`, obtained via protocol's tests: Avg 68 gas* \n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  301464  |  339399  |  320432 |    2     |\n| After  |  301396  |  339331  |  320364 |    2     |\n\n```solidity\nFile: contracts/dnsssec-oracle/DNSSECImpl.sol\n373:    function verifyKeyWithDS(\n374:        bytes memory keyname,\n375:        RRUtils.RRIterator memory dsrrs,\n376:        RRUtils.DNSKEY memory dnskey,\n377:        bytes memory keyrdata\n378:    ) internal view returns (bool) {\n379:        uint16 keytag = keyrdata.computeKeytag();\n380:        for (; !dsrrs.done(); dsrrs.next()) {\n381:            bytes memory proofName = dsrrs.name();\n382:            if (!proofName.equals(keyname)) {\n383:                revert ProofNameMismatch(keyname, proofName);\n384:            }\n385:\n386:            RRUtils.DS memory ds = dsrrs.data.readDS(\n387:                dsrrs.rdataOffset,\n388:                dsrrs.nextOffset - dsrrs.rdataOffset\n389:            );\n390:            if (ds.keytag != keytag) {\n391:                continue;\n392:            }\n393:            if (ds.algorithm != dnskey.algorithm) {\n394:                continue;\n395:            }\n396:\n397:            Buffer.buffer memory buf;\n398:            buf.init(keyname.length + keyrdata.length);\n399:            buf.append(keyname);\n400:            buf.append(keyrdata);\n401:            if (verifyDSHash(ds.digestType, buf.buf, ds.digest)) {\n402:                return true;\n403:            }\n404:        }\n```\n```diff\ndiff --git a/contracts/dnssec-oracle/DNSSECImpl.sol b/contracts/dnssec-oracle/DNSSECImpl.sol\nindex a3e4e5f..ed1c137 100644\n--- a/contracts/dnssec-oracle/DNSSECImpl.sol\n+++ b/contracts/dnssec-oracle/DNSSECImpl.sol\n@@ -377,7 +377,7 @@ contract DNSSECImpl is DNSSEC, Owned {\n         bytes memory keyrdata\n     ) internal view returns (bool) {\n         uint16 keytag = keyrdata.computeKeytag();\n-        for (; !dsrrs.done(); dsrrs.next()) {\n+        do {\n             bytes memory proofName = dsrrs.name();\n             if (!proofName.equals(keyname)) {\n                 revert ProofNameMismatch(keyname, proofName);\n@@ -388,9 +388,11 @@ contract DNSSECImpl is DNSSEC, Owned {\n                 dsrrs.nextOffset - dsrrs.rdataOffset\n             );\n             if (ds.keytag != keytag) {\n+                dsrrs.next();\n                 continue;\n             }\n             if (ds.algorithm != dnskey.algorithm) {\n+                dsrrs.next();\n                 continue;\n             }\n\n@@ -401,7 +403,8 @@ contract DNSSECImpl is DNSSEC, Owned {\n             if (verifyDSHash(ds.digestType, buf.buf, ds.digest)) {\n                 return true;\n             }\n-        }\n+            dsrrs.next();\n+        } while (!dsrrs.done());\n         return false;\n     }\n```\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnsregistrar/DNSClaimChecker.sol#L29-L40\n\n*Gas Savings for `DNSRegistrar.proveAndClaimWithResolver`, obtained via protocol's tests: Avg 42 gas* \n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  301464  |  339399  |  320432 |    2     |\n| After  |  301422  |  339357  |  320390 |    2     |\n\n```solidity\nFile: contracts/dnsregistrar/DNSClaimChecker.sol\n29:        for (\n30:            RRUtils.RRIterator memory iter = data.iterateRRs(0);\n31:            !iter.done();\n32:            iter.next()\n33:        ) {\n34:            if (iter.name().compareNames(buf.buf) != 0) continue;\n35:            bool found;\n36:            address addr;\n37:            (addr, found) = parseRR(data, iter.rdataOffset, iter.nextOffset);\n38:            if (found) {\n39:                return (addr, true);\n40:            }\n```\n```diff\ndiff --git a/contracts/dnsregistrar/DNSClaimChecker.sol b/contracts/dnsregistrar/DNSClaimChecker.sol\nindex 54950d1..7848671 100644\n--- a/contracts/dnsregistrar/DNSClaimChecker.sol\n+++ b/contracts/dnsregistrar/DNSClaimChecker.sol\n@@ -26,19 +26,20 @@ library DNSClaimChecker {\n         buf.append(\"\\x04_ens\");\n         buf.append(name);\n\n-        for (\n-            RRUtils.RRIterator memory iter = data.iterateRRs(0);\n-            !iter.done();\n-            iter.next()\n-        ) {\n-            if (iter.name().compareNames(buf.buf) != 0) continue;\n+        RRUtils.RRIterator memory iter = data.iterateRRs(0);\n+        do {\n+            if (iter.name().compareNames(buf.buf) != 0) {\n+                iter.next();\n+                continue;\n+            }\n             bool found;\n             address addr;\n             (addr, found) = parseRR(data, iter.rdataOffset, iter.nextOffset);\n             if (found) {\n                 return (addr, true);\n             }\n-        }\n+            iter.next();\n+        } while (!iter.done());\n\n         return (address(0x0), false);\n     }\n```\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnsregistrar/DNSClaimChecker.sol#L46-L61\n\n*Gas Savings for `DNSRegistrar.proveAndClaimWithResolver`, obtained via protocol's tests: Avg 36 gas* \n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  301464  |  339399  |  320432 |    2     |\n| After  |  301428  |  339363  |  320396 |    2     |\n\n```solidity\nFile: contracts/dnsregistrar/DNSClaimChecker.sol\n46:    function parseRR(\n47:        bytes memory rdata,\n48:        uint256 idx,\n49:        uint256 endIdx\n50:    ) internal pure returns (address, bool) {\n51:        while (idx < endIdx) {\n52:            uint256 len = rdata.readUint8(idx);\n53:            idx += 1;\n54:\n55:            bool found;\n56:            address addr;\n57:            (addr, found) = parseString(rdata, idx, len);\n58:\n59:            if (found) return (addr, true);\n60:            idx += len;\n61:        }\n```\n```diff\ndiff --git a/contracts/dnsregistrar/DNSClaimChecker.sol b/contracts/dnsregistrar/DNSClaimChecker.sol\nindex 54950d1..55bb5d2 100644\n--- a/contracts/dnsregistrar/DNSClaimChecker.sol\n+++ b/contracts/dnsregistrar/DNSClaimChecker.sol\n@@ -48,9 +48,9 @@ library DNSClaimChecker {\n         uint256 idx,\n         uint256 endIdx\n     ) internal pure returns (address, bool) {\n-        while (idx < endIdx) {\n+        do {\n             uint256 len = rdata.readUint8(idx);\n-            idx += 1;\n+            ++idx;\n\n             bool found;\n             address addr;\n@@ -58,7 +58,7 @@ library DNSClaimChecker {\n\n             if (found) return (addr, true);\n             idx += len;\n-        }\n+        } while (idx < endIdx);\n\n         return (address(0x0), false);\n     }\n```\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnssec-oracle/RRUtils.sol#L384-L399\n\n*Gas Savings for `DNSRegistrar.proveAndClaimWithResolver`, obtained via protocol's tests: Avg 406 gas* \n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  301464  |  339399  |  320432 |    2     |\n| After  |  301072  |  339007  |  320026 |    2     |\n\n```solidity\nFile: contracts/dnssec-oracle/RRUtils.sol\n384:            for (uint256 i = 0; i < data.length + 31; i += 32) {\n385:                uint256 word;\n386:                assembly {\n387:                    word := mload(add(add(data, 32), i))\n388:                }\n389:                if (i + 32 > data.length) {\n390:                    uint256 unused = 256 - (data.length - i) * 8;\n391:                    word = (word >> unused) << unused;\n392:                }\n393:                ac1 +=\n394:                    (word &\n395:                        0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >>\n396:                    8;\n397:                ac2 += (word &\n398:                    0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF);\n399:            }\n```\n```diff\ndiff --git a/contracts/dnssec-oracle/RRUtils.sol b/contracts/dnssec-oracle/RRUtils.sol\nindex 20fbf15..e9309d6 100644\n--- a/contracts/dnssec-oracle/RRUtils.sol\n+++ b/contracts/dnssec-oracle/RRUtils.sol\n@@ -381,13 +381,15 @@ library RRUtils {\n             require(data.length <= 8192, \"Long keys not permitted\");\n             uint256 ac1;\n             uint256 ac2;\n-            for (uint256 i = 0; i < data.length + 31; i += 32) {\n+            uint256 length = data.length;\n+            uint256 i;\n+            do {\n                 uint256 word;\n                 assembly {\n                     word := mload(add(add(data, 32), i))\n                 }\n-                if (i + 32 > data.length) {\n-                    uint256 unused = 256 - (data.length - i) * 8;\n+                if (i + 32 > length) {\n+                    uint256 unused = 256 - (length - i) * 8;\n                     word = (word >> unused) << unused;\n                 }\n                 ac1 +=\n@@ -396,7 +398,8 @@ library RRUtils {\n                     8;\n                 ac2 += (word &\n                     0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF);\n-            }\n+                i += 32;\n+            } while (i < data.length + 31);\n             ac1 =\n                 (ac1 &\n                     0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) +\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-04-ens",
  "Code": [
    {
      "filename": "contracts/dnssec-oracle/DNSSECImpl.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\npragma experimental ABIEncoderV2;\n\nimport \"./Owned.sol\";\nimport \"./BytesUtils.sol\";\nimport \"./RRUtils.sol\";\nimport \"./DNSSEC.sol\";\nimport \"./algorithms/Algorithm.sol\";\nimport \"./digests/Digest.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/*\n * @dev An oracle contract that verifies and stores DNSSEC-validated DNS records.\n * @note This differs from the DNSSEC spec defined in RFC4034 and RFC4035 in some key regards:\n *       - NSEC & NSEC3 are not supported; only positive proofs are allowed.\n *       - Proofs involving wildcard names will not validate.\n *       - TTLs on records are ignored, as data is not stored persistently.\n *       - Canonical form of names is not checked; in ENS this is done on the frontend, so submitting\n *         proofs with non-canonical names will only result in registering unresolvable ENS names.\n */\ncontract DNSSECImpl is DNSSEC, Owned {\n    using Buffer for Buffer.buffer;\n    using BytesUtils for bytes;\n    using RRUtils for *;\n\n    uint16 constant DNSCLASS_IN = 1;\n\n    uint16 constant DNSTYPE_DS = 43;\n    uint16 constant DNSTYPE_DNSKEY = 48;\n\n    uint256 constant DNSKEY_FLAG_ZONEKEY = 0x100;\n\n    error InvalidLabelCount(bytes name, uint256 labelsExpected);\n    error SignatureNotValidYet(uint32 inception, uint32 now);\n    error SignatureExpired(uint32 expiration, uint32 now);\n    error InvalidClass(uint16 class);\n    error InvalidRRSet();\n    error SignatureTypeMismatch(uint16 rrsetType, uint16 sigType);\n    error InvalidSignerName(bytes rrsetName, bytes signerName);\n    error InvalidProofType(uint16 proofType);\n    error ProofNameMismatch(bytes signerName, bytes proofName);\n    error NoMatchingProof(bytes signerName);\n\n    mapping(uint8 => Algorithm) public algorithms;\n    mapping(uint8 => Digest) public digests;\n\n    /**\n     * @dev Constructor.\n     * @param _anchors The binary format RR entries for the root DS records.\n     */\n    constructor(bytes memory _anchors) {\n        // Insert the 'trust anchors' - the key hashes that start the chain\n        // of trust for all other records.\n        anchors = _anchors;\n    }\n\n    /**\n     * @dev Sets the contract address for a signature verification algorithm.\n     *      Callable only by the owner.\n     * @param id The algorithm ID\n     * @param algo The address of the algorithm contract.\n     */\n    function setAlgorithm(uint8 id, Algorithm algo) public owner_only {\n        algorithms[id] = algo;\n        emit AlgorithmUpdated(id, address(algo));\n    }\n\n    /**\n     * @dev Sets the contract address for a digest verification algorithm.\n     *      Callable only by the owner.\n     * @param id The digest ID\n     * @param digest The address of the digest contract.\n     */\n    function setDigest(uint8 id, Digest digest) public owner_only {\n        digests[id] = digest;\n        emit DigestUpdated(id, address(digest));\n    }\n\n    /**\n     * @dev Takes a chain of signed DNS records, verifies them, and returns the data from the last record set in the chain.\n     *      Reverts if the records do not form an unbroken chain of trust to the DNSSEC anchor records.\n     * @param input A list of signed RRSets.\n     * @return rrs The RRData from the last RRSet in the chain.\n     * @return inception The inception time of the signed record set.\n     */\n    function verifyRRSet(\n        RRSetWithSignature[] memory input\n    )\n        external\n        view\n        virtual\n        override\n        returns (bytes memory rrs, uint32 inception)\n    {\n        return verifyRRSet(input, block.timestamp);\n    }\n\n    /**\n     * @dev Takes a chain of signed DNS records, verifies them, and returns the data from the last record set in the chain.\n     *      Reverts if the records do not form an unbroken chain of trust to the DNSSEC anchor records.\n     * @param input A list of signed RRSets.\n     * @param now The Unix timestamp to validate the records at.\n     * @return rrs The RRData from the last RRSet in the chain.\n     * @return inception The inception time of the signed record set.\n     */\n    function verifyRRSet(\n        RRSetWithSignature[] memory input,\n        uint256 now\n    )\n        public\n        view\n        virtual\n        override\n        returns (bytes memory rrs, uint32 inception)\n    {\n        bytes memory proof = anchors;\n        for (uint256 i = 0; i < input.length; i++) {\n            RRUtils.SignedSet memory rrset = validateSignedSet(\n                input[i],\n                proof,\n                now\n            );\n            proof = rrset.data;\n            inception = rrset.inception;\n        }\n        return (proof, inception);\n    }\n\n    /**\n     * @dev Validates an RRSet against the already trusted RR provided in `proof`.\n     *\n     * @param input The signed RR set. This is in the format described in section\n     *        5.3.2 of RFC4035: The RRDATA section from the RRSIG without the signature\n     *        data, followed by a series of canonicalised RR records that the signature\n     *        applies to.\n     * @param proof The DNSKEY or DS to validate the signature against.\n     * @param now The current timestamp.\n     */\n    function validateSignedSet(\n        RRSetWithSignature memory input,\n        bytes memory proof,\n        uint256 now\n    ) internal view returns (RRUtils.SignedSet memory rrset) {\n        rrset = input.rrset.readSignedSet();\n\n        // Do some basic checks on the RRs and extract the name\n        bytes memory name = validateRRs(rrset, rrset.typeCovered);\n        if (name.labelCount(0) != rrset.labels) {\n            revert InvalidLabelCount(name, rrset.labels);\n        }\n        rrset.name = name;\n\n        // All comparisons involving the Signature Expiration and\n        // Inception fields MUST use \"serial number arithmetic\", as\n        // defined in RFC 1982\n\n        // o  The validator's notion of the current time MUST be less than or\n        //    equal to the time listed in the RRSIG RR's Expiration field.\n        if (!RRUtils.serialNumberGte(rrset.expiration, uint32(now))) {\n            revert SignatureExpired(rrset.expiration, uint32(now));\n        }\n\n        // o  The validator's notion of the current time MUST be greater than or\n        //    equal to the time listed in the RRSIG RR's Inception field.\n        if (!RRUtils.serialNumberGte(uint32(now), rrset.inception)) {\n            revert SignatureNotValidYet(rrset.inception, uint32(now));\n        }\n\n        // Validate the signature\n        verifySignature(name, rrset, input, proof);\n\n        return rrset;\n    }\n\n    /**\n     * @dev Validates a set of RRs.\n     * @param rrset The RR set.\n     * @param typecovered The type covered by the RRSIG record.\n     */\n    function validateRRs(\n        RRUtils.SignedSet memory rrset,\n        uint16 typecovered\n    ) internal pure returns (bytes memory name) {\n        // Iterate over all the RRs\n        for (\n            RRUtils.RRIterator memory iter = rrset.rrs();\n            !iter.done();\n            iter.next()\n        ) {\n            // We only support class IN (Internet)\n            if (iter.class != DNSCLASS_IN) {\n                revert InvalidClass(iter.class);\n            }\n\n            if (name.length == 0) {\n                name = iter.name();\n            } else {\n                // Name must be the same on all RRs. We do things this way to avoid copying the name\n                // repeatedly.\n                if (\n                    name.length != iter.data.nameLength(iter.offset) ||\n                    !name.equals(0, iter.data, iter.offset, name.length)\n                ) {\n                    revert InvalidRRSet();\n                }\n            }\n\n            // o  The RRSIG RR's Type Covered field MUST equal the RRset's type.\n            if (iter.dnstype != typecovered) {\n                revert SignatureTypeMismatch(iter.dnstype, typecovered);\n            }\n        }\n    }\n\n    /**\n     * @dev Performs signature verification.\n     *\n     * Throws or reverts if unable to verify the record.\n     *\n     * @param name The name of the RRSIG record, in DNS label-sequence format.\n     * @param data The original data to verify.\n     * @param proof A DS or DNSKEY record that's already verified by the oracle.\n     */\n    function verifySignature(\n        bytes memory name,\n        RRUtils.SignedSet memory rrset,\n        RRSetWithSignature memory data,\n        bytes memory proof\n    ) internal view {\n        // o  The RRSIG RR's Signer's Name field MUST be the name of the zone\n        //    that contains the RRset.\n        if (!name.isSubdomainOf(rrset.signerName)) {\n            revert InvalidSignerName(name, rrset.signerName);\n        }\n\n        RRUtils.RRIterator memory proofRR = proof.iterateRRs(0);\n        // Check the proof\n        if (proofRR.dnstype == DNSTYPE_DS) {\n            verifyWithDS(rrset, data, proofRR);\n        } else if (proofRR.dnstype == DNSTYPE_DNSKEY) {\n            verifyWithKnownKey(rrset, data, proofRR);\n        } else {\n            revert InvalidProofType(proofRR.dnstype);\n        }\n    }\n\n    /**\n     * @dev Attempts to verify a signed RRSET against an already known public key.\n     * @param rrset The signed set to verify.\n     * @param data The original data the signed set was read from.\n     * @param proof The serialized DS or DNSKEY record to use as proof.\n     */\n    function verifyWithKnownKey(\n        RRUtils.SignedSet memory rrset,\n        RRSetWithSignature memory data,\n        RRUtils.RRIterator memory proof\n    ) internal view {\n        // Check the DNSKEY's owner name matches the signer name on the RRSIG\n        for (; !proof.done(); proof.next()) {\n            bytes memory proofName = proof.name();\n            if (!proofName.equals(rrset.signerName)) {\n                revert ProofNameMismatch(rrset.signerName, proofName);\n            }\n\n            bytes memory keyrdata = proof.rdata();\n            RRUtils.DNSKEY memory dnskey = keyrdata.readDNSKEY(\n                0,\n                keyrdata.length\n            );\n            if (verifySignatureWithKey(dnskey, keyrdata, rrset, data)) {\n                return;\n            }\n        }\n        revert NoMatchingProof(rrset.signerName);\n    }\n\n    /**\n     * @dev Attempts to verify some data using a provided key and a signature.\n     * @param dnskey The dns key record to verify the signature with.\n     * @param rrset The signed RRSET being verified.\n     * @param data The original data `rrset` was decoded from.\n     * @return True iff the key verifies the signature.\n     */\n    function verifySignatureWithKey(\n        RRUtils.DNSKEY memory dnskey,\n        bytes memory keyrdata,\n        RRUtils.SignedSet memory rrset,\n        RRSetWithSignature memory data\n    ) internal view returns (bool) {\n        // TODO: Check key isn't expired, unless updating key itself\n\n        // The Protocol Field MUST have value 3 (RFC4034 2.1.2)\n        if (dnskey.protocol != 3) {\n            return false;\n        }\n\n        // o The RRSIG RR's Signer's Name, Algorithm, and Key Tag fields MUST\n        //   match the owner name, algorithm, and key tag for some DNSKEY RR in\n        //   the zone's apex DNSKEY RRset.\n        if (dnskey.algorithm != rrset.algorithm) {\n            return false;\n        }\n        uint16 computedkeytag = keyrdata.computeKeytag();\n        if (computedkeytag != rrset.keytag) {\n            return false;\n        }\n\n        // o The matching DNSKEY RR MUST be present in the zone's apex DNSKEY\n        //   RRset, and MUST have the Zone Flag bit (DNSKEY RDATA Flag bit 7)\n        //   set.\n        if (dnskey.flags & DNSKEY_FLAG_ZONEKEY == 0) {\n            return false;\n        }\n\n        Algorithm algorithm = algorithms[dnskey.algorithm];\n        if (address(algorithm) == address(0)) {\n            return false;\n        }\n        return algorithm.verify(keyrdata, data.rrset, data.sig);\n    }\n\n    /**\n     * @dev Attempts to verify a signed RRSET against an already known hash. This function assumes\n     *      that the record\n     * @param rrset The signed set to verify.\n     * @param data The original data the signed set was read from.\n     * @param proof The serialized DS or DNSKEY record to use as proof.\n     */\n    function verifyWithDS(\n        RRUtils.SignedSet memory rrset,\n        RRSetWithSignature memory data,\n        RRUtils.RRIterator memory proof\n    ) internal view {\n        uint256 proofOffset = proof.offset;\n        for (\n            RRUtils.RRIterator memory iter = rrset.rrs();\n            !iter.done();\n            iter.next()\n        ) {\n            if (iter.dnstype != DNSTYPE_DNSKEY) {\n                revert InvalidProofType(iter.dnstype);\n            }\n\n            bytes memory keyrdata = iter.rdata();\n            RRUtils.DNSKEY memory dnskey = keyrdata.readDNSKEY(\n                0,\n                keyrdata.length\n            );\n            if (verifySignatureWithKey(dnskey, keyrdata, rrset, data)) {\n                // It's self-signed - look for a DS record to verify it.\n                if (\n                    verifyKeyWithDS(rrset.signerName, proof, dnskey, keyrdata)\n                ) {\n                    return;\n                }\n                // Rewind proof iterator to the start for the next loop iteration.\n                proof.nextOffset = proofOffset;\n                proof.next();\n            }\n        }\n        revert NoMatchingProof(rrset.signerName);\n    }\n\n    /**\n     * @dev Attempts to verify a key using DS records.\n     * @param keyname The DNS name of the key, in DNS label-sequence format.\n     * @param dsrrs The DS records to use in verification.\n     * @param dnskey The dnskey to verify.\n     * @param keyrdata The RDATA section of the key.\n     * @return True if a DS record verifies this key.\n     */\n    function verifyKeyWithDS(\n        bytes memory keyname,\n        RRUtils.RRIterator memory dsrrs,\n        RRUtils.DNSKEY memory dnskey,\n        bytes memory keyrdata\n    ) internal view returns (bool) {\n        uint16 keytag = keyrdata.computeKeytag();\n        for (; !dsrrs.done(); dsrrs.next()) {\n            bytes memory proofName = dsrrs.name();\n            if (!proofName.equals(keyname)) {\n                revert ProofNameMismatch(keyname, proofName);\n            }\n\n            RRUtils.DS memory ds = dsrrs.data.readDS(\n                dsrrs.rdataOffset,\n                dsrrs.nextOffset - dsrrs.rdataOffset\n            );\n            if (ds.keytag != keytag) {\n                continue;\n            }\n            if (ds.algorithm != dnskey.algorithm) {\n                continue;\n            }\n\n            Buffer.buffer memory buf;\n            buf.init(keyname.length + keyrdata.length);\n            buf.append(keyname);\n            buf.append(keyrdata);\n            if (verifyDSHash(ds.digestType, buf.buf, ds.digest)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @dev Attempts to verify a DS record's hash value against some data.\n     * @param digesttype The digest ID from the DS record.\n     * @param data The data to digest.\n     * @param digest The digest data to check against.\n     * @return True iff the digest matches.\n     */\n    function verifyDSHash(\n        uint8 digesttype,\n        bytes memory data,\n        bytes memory digest\n    ) internal view returns (bool) {\n        if (address(digests[digesttype]) == address(0)) {\n            return false;\n        }\n        return digests[digesttype].verify(data, digest);\n    }\n}"
    },
    {
      "filename": "contracts/dnssec-oracle/DNSSECImpl.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\npragma experimental ABIEncoderV2;\n\nimport \"./Owned.sol\";\nimport \"./BytesUtils.sol\";\nimport \"./RRUtils.sol\";\nimport \"./DNSSEC.sol\";\nimport \"./algorithms/Algorithm.sol\";\nimport \"./digests/Digest.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/*\n * @dev An oracle contract that verifies and stores DNSSEC-validated DNS records.\n * @note This differs from the DNSSEC spec defined in RFC4034 and RFC4035 in some key regards:\n *       - NSEC & NSEC3 are not supported; only positive proofs are allowed.\n *       - Proofs involving wildcard names will not validate.\n *       - TTLs on records are ignored, as data is not stored persistently.\n *       - Canonical form of names is not checked; in ENS this is done on the frontend, so submitting\n *         proofs with non-canonical names will only result in registering unresolvable ENS names.\n */\ncontract DNSSECImpl is DNSSEC, Owned {\n    using Buffer for Buffer.buffer;\n    using BytesUtils for bytes;\n    using RRUtils for *;\n\n    uint16 constant DNSCLASS_IN = 1;\n\n    uint16 constant DNSTYPE_DS = 43;\n    uint16 constant DNSTYPE_DNSKEY = 48;\n\n    uint256 constant DNSKEY_FLAG_ZONEKEY = 0x100;\n\n    error InvalidLabelCount(bytes name, uint256 labelsExpected);\n    error SignatureNotValidYet(uint32 inception, uint32 now);\n    error SignatureExpired(uint32 expiration, uint32 now);\n    error InvalidClass(uint16 class);\n    error InvalidRRSet();\n    error SignatureTypeMismatch(uint16 rrsetType, uint16 sigType);\n    error InvalidSignerName(bytes rrsetName, bytes signerName);\n    error InvalidProofType(uint16 proofType);\n    error ProofNameMismatch(bytes signerName, bytes proofName);\n    error NoMatchingProof(bytes signerName);\n\n    mapping(uint8 => Algorithm) public algorithms;\n    mapping(uint8 => Digest) public digests;\n\n    /**\n     * @dev Constructor.\n     * @param _anchors The binary format RR entries for the root DS records.\n     */\n    constructor(bytes memory _anchors) {\n        // Insert the 'trust anchors' - the key hashes that start the chain\n        // of trust for all other records.\n        anchors = _anchors;\n    }\n\n    /**\n     * @dev Sets the contract address for a signature verification algorithm.\n     *      Callable only by the owner.\n     * @param id The algorithm ID\n     * @param algo The address of the algorithm contract.\n     */\n    function setAlgorithm(uint8 id, Algorithm algo) public owner_only {\n        algorithms[id] = algo;\n        emit AlgorithmUpdated(id, address(algo));\n    }\n\n    /**\n     * @dev Sets the contract address for a digest verification algorithm.\n     *      Callable only by the owner.\n     * @param id The digest ID\n     * @param digest The address of the digest contract.\n     */\n    function setDigest(uint8 id, Digest digest) public owner_only {\n        digests[id] = digest;\n        emit DigestUpdated(id, address(digest));\n    }\n\n    /**\n     * @dev Takes a chain of signed DNS records, verifies them, and returns the data from the last record set in the chain.\n     *      Reverts if the records do not form an unbroken chain of trust to the DNSSEC anchor records.\n     * @param input A list of signed RRSets.\n     * @return rrs The RRData from the last RRSet in the chain.\n     * @return inception The inception time of the signed record set.\n     */\n    function verifyRRSet(\n        RRSetWithSignature[] memory input\n    )\n        external\n        view\n        virtual\n        override\n        returns (bytes memory rrs, uint32 inception)\n    {\n        return verifyRRSet(input, block.timestamp);\n    }\n\n    /**\n     * @dev Takes a chain of signed DNS records, verifies them, and returns the data from the last record set in the chain.\n     *      Reverts if the records do not form an unbroken chain of trust to the DNSSEC anchor records.\n     * @param input A list of signed RRSets.\n     * @param now The Unix timestamp to validate the records at.\n     * @return rrs The RRData from the last RRSet in the chain.\n     * @return inception The inception time of the signed record set.\n     */\n    function verifyRRSet(\n        RRSetWithSignature[] memory input,\n        uint256 now\n    )\n        public\n        view\n        virtual\n        override\n        returns (bytes memory rrs, uint32 inception)\n    {\n        bytes memory proof = anchors;\n        for (uint256 i = 0; i < input.length; i++) {\n            RRUtils.SignedSet memory rrset = validateSignedSet(\n                input[i],\n                proof,\n                now\n            );\n            proof = rrset.data;\n            inception = rrset.inception;\n        }\n        return (proof, inception);\n    }\n\n    /**\n     * @dev Validates an RRSet against the already trusted RR provided in `proof`.\n     *\n     * @param input The signed RR set. This is in the format described in section\n     *        5.3.2 of RFC4035: The RRDATA section from the RRSIG without the signature\n     *        data, followed by a series of canonicalised RR records that the signature\n     *        applies to.\n     * @param proof The DNSKEY or DS to validate the signature against.\n     * @param now The current timestamp.\n     */\n    function validateSignedSet(\n        RRSetWithSignature memory input,\n        bytes memory proof,\n        uint256 now\n    ) internal view returns (RRUtils.SignedSet memory rrset) {\n        rrset = input.rrset.readSignedSet();\n\n        // Do some basic checks on the RRs and extract the name\n        bytes memory name = validateRRs(rrset, rrset.typeCovered);\n        if (name.labelCount(0) != rrset.labels) {\n            revert InvalidLabelCount(name, rrset.labels);\n        }\n        rrset.name = name;\n\n        // All comparisons involving the Signature Expiration and\n        // Inception fields MUST use \"serial number arithmetic\", as\n        // defined in RFC 1982\n\n        // o  The validator's notion of the current time MUST be less than or\n        //    equal to the time listed in the RRSIG RR's Expiration field.\n        if (!RRUtils.serialNumberGte(rrset.expiration, uint32(now))) {\n            revert SignatureExpired(rrset.expiration, uint32(now));\n        }\n\n        // o  The validator's notion of the current time MUST be greater than or\n        //    equal to the time listed in the RRSIG RR's Inception field.\n        if (!RRUtils.serialNumberGte(uint32(now), rrset.inception)) {\n            revert SignatureNotValidYet(rrset.inception, uint32(now));\n        }\n\n        // Validate the signature\n        verifySignature(name, rrset, input, proof);\n\n        return rrset;\n    }\n\n    /**\n     * @dev Validates a set of RRs.\n     * @param rrset The RR set.\n     * @param typecovered The type covered by the RRSIG record.\n     */\n    function validateRRs(\n        RRUtils.SignedSet memory rrset,\n        uint16 typecovered\n    ) internal pure returns (bytes memory name) {\n        // Iterate over all the RRs\n        for (\n            RRUtils.RRIterator memory iter = rrset.rrs();\n            !iter.done();\n            iter.next()\n        ) {\n            // We only support class IN (Internet)\n            if (iter.class != DNSCLASS_IN) {\n                revert InvalidClass(iter.class);\n            }\n\n            if (name.length == 0) {\n                name = iter.name();\n            } else {\n                // Name must be the same on all RRs. We do things this way to avoid copying the name\n                // repeatedly.\n                if (\n                    name.length != iter.data.nameLength(iter.offset) ||\n                    !name.equals(0, iter.data, iter.offset, name.length)\n                ) {\n                    revert InvalidRRSet();\n                }\n            }\n\n            // o  The RRSIG RR's Type Covered field MUST equal the RRset's type.\n            if (iter.dnstype != typecovered) {\n                revert SignatureTypeMismatch(iter.dnstype, typecovered);\n            }\n        }\n    }\n\n    /**\n     * @dev Performs signature verification.\n     *\n     * Throws or reverts if unable to verify the record.\n     *\n     * @param name The name of the RRSIG record, in DNS label-sequence format.\n     * @param data The original data to verify.\n     * @param proof A DS or DNSKEY record that's already verified by the oracle.\n     */\n    function verifySignature(\n        bytes memory name,\n        RRUtils.SignedSet memory rrset,\n        RRSetWithSignature memory data,\n        bytes memory proof\n    ) internal view {\n        // o  The RRSIG RR's Signer's Name field MUST be the name of the zone\n        //    that contains the RRset.\n        if (!name.isSubdomainOf(rrset.signerName)) {\n            revert InvalidSignerName(name, rrset.signerName);\n        }\n\n        RRUtils.RRIterator memory proofRR = proof.iterateRRs(0);\n        // Check the proof\n        if (proofRR.dnstype == DNSTYPE_DS) {\n            verifyWithDS(rrset, data, proofRR);\n        } else if (proofRR.dnstype == DNSTYPE_DNSKEY) {\n            verifyWithKnownKey(rrset, data, proofRR);\n        } else {\n            revert InvalidProofType(proofRR.dnstype);\n        }\n    }\n\n    /**\n     * @dev Attempts to verify a signed RRSET against an already known public key.\n     * @param rrset The signed set to verify.\n     * @param data The original data the signed set was read from.\n     * @param proof The serialized DS or DNSKEY record to use as proof.\n     */\n    function verifyWithKnownKey(\n        RRUtils.SignedSet memory rrset,\n        RRSetWithSignature memory data,\n        RRUtils.RRIterator memory proof\n    ) internal view {\n        // Check the DNSKEY's owner name matches the signer name on the RRSIG\n        for (; !proof.done(); proof.next()) {\n            bytes memory proofName = proof.name();\n            if (!proofName.equals(rrset.signerName)) {\n                revert ProofNameMismatch(rrset.signerName, proofName);\n            }\n\n            bytes memory keyrdata = proof.rdata();\n            RRUtils.DNSKEY memory dnskey = keyrdata.readDNSKEY(\n                0,\n                keyrdata.length\n            );\n            if (verifySignatureWithKey(dnskey, keyrdata, rrset, data)) {\n                return;\n            }\n        }\n        revert NoMatchingProof(rrset.signerName);\n    }\n\n    /**\n     * @dev Attempts to verify some data using a provided key and a signature.\n     * @param dnskey The dns key record to verify the signature with.\n     * @param rrset The signed RRSET being verified.\n     * @param data The original data `rrset` was decoded from.\n     * @return True iff the key verifies the signature.\n     */\n    function verifySignatureWithKey(\n        RRUtils.DNSKEY memory dnskey,\n        bytes memory keyrdata,\n        RRUtils.SignedSet memory rrset,\n        RRSetWithSignature memory data\n    ) internal view returns (bool) {\n        // TODO: Check key isn't expired, unless updating key itself\n\n        // The Protocol Field MUST have value 3 (RFC4034 2.1.2)\n        if (dnskey.protocol != 3) {\n            return false;\n        }\n\n        // o The RRSIG RR's Signer's Name, Algorithm, and Key Tag fields MUST\n        //   match the owner name, algorithm, and key tag for some DNSKEY RR in\n        //   the zone's apex DNSKEY RRset.\n        if (dnskey.algorithm != rrset.algorithm) {\n            return false;\n        }\n        uint16 computedkeytag = keyrdata.computeKeytag();\n        if (computedkeytag != rrset.keytag) {\n            return false;\n        }\n\n        // o The matching DNSKEY RR MUST be present in the zone's apex DNSKEY\n        //   RRset, and MUST have the Zone Flag bit (DNSKEY RDATA Flag bit 7)\n        //   set.\n        if (dnskey.flags & DNSKEY_FLAG_ZONEKEY == 0) {\n            return false;\n        }\n\n        Algorithm algorithm = algorithms[dnskey.algorithm];\n        if (address(algorithm) == address(0)) {\n            return false;\n        }\n        return algorithm.verify(keyrdata, data.rrset, data.sig);\n    }\n\n    /**\n     * @dev Attempts to verify a signed RRSET against an already known hash. This function assumes\n     *      that the record\n     * @param rrset The signed set to verify.\n     * @param data The original data the signed set was read from.\n     * @param proof The serialized DS or DNSKEY record to use as proof.\n     */\n    function verifyWithDS(\n        RRUtils.SignedSet memory rrset,\n        RRSetWithSignature memory data,\n        RRUtils.RRIterator memory proof\n    ) internal view {\n        uint256 proofOffset = proof.offset;\n        for (\n            RRUtils.RRIterator memory iter = rrset.rrs();\n            !iter.done();\n            iter.next()\n        ) {\n            if (iter.dnstype != DNSTYPE_DNSKEY) {\n                revert InvalidProofType(iter.dnstype);\n            }\n\n            bytes memory keyrdata = iter.rdata();\n            RRUtils.DNSKEY memory dnskey = keyrdata.readDNSKEY(\n                0,\n                keyrdata.length\n            );\n            if (verifySignatureWithKey(dnskey, keyrdata, rrset, data)) {\n                // It's self-signed - look for a DS record to verify it.\n                if (\n                    verifyKeyWithDS(rrset.signerName, proof, dnskey, keyrdata)\n                ) {\n                    return;\n                }\n                // Rewind proof iterator to the start for the next loop iteration.\n                proof.nextOffset = proofOffset;\n                proof.next();\n            }\n        }\n        revert NoMatchingProof(rrset.signerName);\n    }\n\n    /**\n     * @dev Attempts to verify a key using DS records.\n     * @param keyname The DNS name of the key, in DNS label-sequence format.\n     * @param dsrrs The DS records to use in verification.\n     * @param dnskey The dnskey to verify.\n     * @param keyrdata The RDATA section of the key.\n     * @return True if a DS record verifies this key.\n     */\n    function verifyKeyWithDS(\n        bytes memory keyname,\n        RRUtils.RRIterator memory dsrrs,\n        RRUtils.DNSKEY memory dnskey,\n        bytes memory keyrdata\n    ) internal view returns (bool) {\n        uint16 keytag = keyrdata.computeKeytag();\n        for (; !dsrrs.done(); dsrrs.next()) {\n            bytes memory proofName = dsrrs.name();\n            if (!proofName.equals(keyname)) {\n                revert ProofNameMismatch(keyname, proofName);\n            }\n\n            RRUtils.DS memory ds = dsrrs.data.readDS(\n                dsrrs.rdataOffset,\n                dsrrs.nextOffset - dsrrs.rdataOffset\n            );\n            if (ds.keytag != keytag) {\n                continue;\n            }\n            if (ds.algorithm != dnskey.algorithm) {\n                continue;\n            }\n\n            Buffer.buffer memory buf;\n            buf.init(keyname.length + keyrdata.length);\n            buf.append(keyname);\n            buf.append(keyrdata);\n            if (verifyDSHash(ds.digestType, buf.buf, ds.digest)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @dev Attempts to verify a DS record's hash value against some data.\n     * @param digesttype The digest ID from the DS record.\n     * @param data The data to digest.\n     * @param digest The digest data to check against.\n     * @return True iff the digest matches.\n     */\n    function verifyDSHash(\n        uint8 digesttype,\n        bytes memory data,\n        bytes memory digest\n    ) internal view returns (bool) {\n        if (address(digests[digesttype]) == address(0)) {\n            return false;\n        }\n        return digests[digesttype].verify(data, digest);\n    }\n}"
    },
    {
      "filename": "contracts/dnssec-oracle/DNSSECImpl.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\npragma experimental ABIEncoderV2;\n\nimport \"./Owned.sol\";\nimport \"./BytesUtils.sol\";\nimport \"./RRUtils.sol\";\nimport \"./DNSSEC.sol\";\nimport \"./algorithms/Algorithm.sol\";\nimport \"./digests/Digest.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/*\n * @dev An oracle contract that verifies and stores DNSSEC-validated DNS records.\n * @note This differs from the DNSSEC spec defined in RFC4034 and RFC4035 in some key regards:\n *       - NSEC & NSEC3 are not supported; only positive proofs are allowed.\n *       - Proofs involving wildcard names will not validate.\n *       - TTLs on records are ignored, as data is not stored persistently.\n *       - Canonical form of names is not checked; in ENS this is done on the frontend, so submitting\n *         proofs with non-canonical names will only result in registering unresolvable ENS names.\n */\ncontract DNSSECImpl is DNSSEC, Owned {\n    using Buffer for Buffer.buffer;\n    using BytesUtils for bytes;\n    using RRUtils for *;\n\n    uint16 constant DNSCLASS_IN = 1;\n\n    uint16 constant DNSTYPE_DS = 43;\n    uint16 constant DNSTYPE_DNSKEY = 48;\n\n    uint256 constant DNSKEY_FLAG_ZONEKEY = 0x100;\n\n    error InvalidLabelCount(bytes name, uint256 labelsExpected);\n    error SignatureNotValidYet(uint32 inception, uint32 now);\n    error SignatureExpired(uint32 expiration, uint32 now);\n    error InvalidClass(uint16 class);\n    error InvalidRRSet();\n    error SignatureTypeMismatch(uint16 rrsetType, uint16 sigType);\n    error InvalidSignerName(bytes rrsetName, bytes signerName);\n    error InvalidProofType(uint16 proofType);\n    error ProofNameMismatch(bytes signerName, bytes proofName);\n    error NoMat"
    }
  ]
}