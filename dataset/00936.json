{
  "Title": "Block of GMXVault by using GMX UI fee",
  "Content": "# Block of GMXVault by using GMX UI fee\n\n### Severity\nHigh Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/strategy/gmx/GMXWorker.sol#L94\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/strategy/gmx/GMXWorker.sol#L94</a>\n\n\n## Summary\nAttacker can block GMXVault by setting registering himself as ui fee receiver on GMX and causing slippage check to always revert, when `processDepositFailure` is called.\n## Vulnerability Details\nIn case if deposit [has decided to be failed](https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/strategy/gmx/GMXDeposit.sol#L183-L185), that means that `processDepositFailure` function will be called by keeper in order to withdraw already deposited LP tokens and send received tokens to the depositor.\n\n`processDepositFailure` function [calculates amount of tokenA and tokenB](https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/strategy/gmx/GMXDeposit.sol#L251-L265) that it can get in exchange of LP tokens and also consider slippage. So in case if smaller amount will be received when GMX will do swap, then GMX withdrawal will revert. In order to send request to GMX [`removeLiquidity` function is called](https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/strategy/gmx/GMXDeposit.sol#L271-L274), which will eventually call `GMXWorker.removeLiquidity`. This function sets [`self.refundee` as `uiFeeReceiver`](https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/strategy/gmx/GMXWorker.sol#L94) to the GMX withdraw request. In this case, `self.refundee` [will be previous depositor](https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/strategy/gmx/GMXDeposit.sol#L68), as this value is not changed by `processDepositFailure` function.\n\nNow let's check what is `uiFeeReceiver` on GMX. This is actually entity that will receive percentage of your swaps on GMX. For withdrawing it will receive fee for both [long](https://github.com/gmx-io/gmx-synthetics/blob/main/contracts/withdrawal/ExecuteWithdrawalUtils.sol#L168-L174) and [short](https://github.com/gmx-io/gmx-synthetics/blob/main/contracts/withdrawal/ExecuteWithdrawalUtils.sol#L195-L201) tokens. Amount of fee depends [on what ui fee receiver has provided to himself](https://github.com/gmx-io/gmx-synthetics/blob/main/contracts/pricing/SwapPricingUtils.sol#L258).\n\nSo attacker can register himself as ui fee recipient and set his percentage high enough, so when `processDepositFailure` is called on his deposit, then created withdrawal request will always revert with slippage error. As result system will stuck in `Deposit_Failed` status and will not be able work normally and emergency operations will be needed.\n## Impact\nGMXVault will be blocked.\n## Tools Used\nVsCode\n## Recommendations\nYou don't need to use `uiFeeReceiver` at all. Set it as 0 for both deposits and withdraws.",
  "Impact": "HIGH",
  "Source": "https://www.codehawks.com/contests/clo38mm260001la08daw5cbuf",
  "Code": [
    {
      "filename": "contracts/strategy/gmx/GMXWorker.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IExchangeRouter } from  \"../../interfaces/protocols/gmx/IExchangeRouter.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\n\nlibrary GMXWorker {\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @dev Add strategy's tokens for liquidity and receive LP tokens\n    * @param self Vault store data\n    * @param alp GMXTypes.AddLiquidityParams\n    * @return depositKey Hashed key of created deposit in bytes32\n  */\n  function addLiquidity(\n    GMXTypes.Store storage self,\n    GMXTypes.AddLiquidityParams memory alp\n  ) external returns (bytes32) {\n    // Send native token for execution fee\n    self.exchangeRouter.sendWnt{ value: alp.executionFee }(\n      self.depositVault,\n      alp.executionFee\n    );\n\n    // Send tokens\n    self.exchangeRouter.sendTokens(\n      address(self.tokenA),\n      self.depositVault,\n      alp.tokenAAmt\n    );\n\n    self.exchangeRouter.sendTokens(\n      address(self.tokenB),\n      self.depositVault,\n      alp.tokenBAmt\n    );\n\n    // Create deposit\n    IExchangeRouter.CreateDepositParams memory _cdp =\n      IExchangeRouter.CreateDepositParams({\n        receiver: address(this),\n        callbackContract: self.callback,\n        uiFeeReceiver: self.refundee,\n        market: address(self.lpToken),\n        initialLongToken: address(self.tokenA),\n        initialShortToken: address(self.tokenB),\n        longTokenSwapPath: new address[](0),\n        shortTokenSwapPath: new address[](0),\n        minMarketTokens: alp.minMarketTokenAmt,\n        shouldUnwrapNativeToken: false,\n        executionFee: alp.executionFee,\n        callbackGasLimit: 2000000\n      });\n\n    return self.exchangeRouter.createDeposit(_cdp);\n  }\n\n  /**\n    * @dev Remove liquidity of strategy's LP token and receive underlying tokens\n    * @param self Vault store data\n    * @param rlp GMXTypes.RemoveLiquidityParams\n    * @return withdrawKey Hashed key of created withdraw in bytes32\n  */\n  function removeLiquidity(\n    GMXTypes.Store storage self,\n    GMXTypes.RemoveLiquidityParams memory rlp\n  ) external returns (bytes32) {\n    // Send native token for execution fee\n    self.exchangeRouter.sendWnt{value: rlp.executionFee }(\n      self.withdrawalVault,\n      rlp.executionFee\n    );\n\n    // Send GM LP tokens\n    self.exchangeRouter.sendTokens(\n      address(self.lpToken),\n      self.withdrawalVault,\n      rlp.lpAmt\n    );\n\n    // Create withdrawal\n    IExchangeRouter.CreateWithdrawalParams memory _cwp =\n      IExchangeRouter.CreateWithdrawalParams({\n        receiver: address(this),\n        callbackContract: self.callback,\n        uiFeeReceiver: self.refundee,\n        market: address(self.lpToken),\n        longTokenSwapPath: rlp.tokenASwapPath,\n        shortTokenSwapPath: rlp.tokenBSwapPath,\n        minLongTokenAmount: rlp.minTokenAAmt,\n        minShortTokenAmount: rlp.minTokenBAmt,\n        shouldUnwrapNativeToken: false,\n        executionFee: rlp.executionFee,\n        callbackGasLimit: 2000000\n      });\n\n    return self.exchangeRouter.createWithdrawal(_cwp);\n  }\n\n  /**\n    * @dev Swap exact amount of tokenIn for as many amount of tokenOut\n    * @param self Vault store data\n    * @param sp ISwap.SwapParams\n    * @return amountOut Amount of tokens out in token decimals\n  */\n  function swapExactTokensForTokens(\n    GMXTypes.Store storage self,\n    ISwap.SwapParams memory sp\n  ) external returns (uint256) {\n    IERC20(sp.tokenIn).approve(address(self.swapRouter), sp.amountIn);\n\n    return self.swapRouter.swapExactTokensForTokens(sp);\n  }\n\n  /**\n    * @dev Swap as little tokenIn for exact amount of tokenOut\n    * @param self Vault store data\n    * @param sp ISwap.SwapParams\n    * @return amountIn Amount of tokens in in token decimals\n  */\n  function swapTokensForExactTokens(\n    GMXTypes.Store storage self,\n    ISwap.SwapParams memory sp\n  ) external returns (uint256) {\n    IERC20(sp.tokenIn).approve(address(self.swapRouter), sp.amountIn);\n\n    return self.swapRouter.swapTokensForExactTokens(sp);\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXDeposit.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IDeposit } from \"../../interfaces/protocols/gmx/IDeposit.sol\";\nimport { IWithdrawal } from \"../../interfaces/protocols/gmx/IWithdrawal.sol\";\nimport { IEvent } from \"../../interfaces/protocols/gmx/IEvent.sol\";\nimport { IOrder } from \"../../interfaces/protocols/gmx/IOrder.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\nimport { GMXProcessDeposit } from \"./GMXProcessDeposit.sol\";\n\n/**\n  * @title GMXDeposit\n  * @author Steadefi\n  * @notice Re-usable library functions for deposit operations for Steadefi leveraged vaults\n*/\nlibrary GMXDeposit {\n  using SafeERC20 for IERC20;\n\n  /* ======================= CONSTANTS ======================= */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ======================== EVENTS ========================= */\n\n  event DepositCreated(\n    address indexed user,\n    address asset,\n    uint256 assetAmt\n  );\n  event DepositCompleted(\n    address indexed user,\n    uint256 shareAmt,\n    uint256 equityBefore,\n    uint256 equityAfter\n  );\n  event DepositCancelled(\n    address indexed user\n  );\n  event DepositFailed(bytes reason);\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n    * @param isNative Boolean as to whether user is depositing native asset (e.g. ETH, AVAX, etc.)\n  */\n  function deposit(\n    GMXTypes.Store storage self,\n    GMXTypes.DepositParams memory dp,\n    bool isNative\n  ) external {\n    // Sweep any tokenA/B in vault to the temporary trove for future compouding and to prevent\n    // it from being considered as part of depositor's assets\n    if (self.tokenA.balanceOf(address(this)) > 0) {\n      self.tokenA.safeTransfer(self.trove, self.tokenA.balanceOf(address(this)));\n    }\n    if (self.tokenB.balanceOf(address(this)) > 0) {\n      self.tokenB.safeTransfer(self.trove, self.tokenB.balanceOf(address(this)));\n    }\n\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.HealthParams memory _hp;\n\n    _hp.equityBefore = GMXReader.equityValue(self);\n    _hp.lpAmtBefore = GMXReader.lpAmt(self);\n    _hp.debtRatioBefore = GMXReader.debtRatio(self);\n    _hp.deltaBefore = GMXReader.delta(self);\n\n    // Transfer assets from user to vault\n    if (isNative) {\n      GMXChecks.beforeNativeDepositChecks(self, dp);\n\n      self.WNT.deposit{ value: dp.amt }();\n    } else {\n      IERC20(dp.token).safeTransferFrom(msg.sender, address(this), dp.amt);\n    }\n\n    GMXTypes.DepositCache memory _dc;\n\n    _dc.user = payable(msg.sender);\n\n    if (dp.token == address(self.lpToken)) {\n      // If LP token deposited\n      _dc.depositValue = self.gmxOracle.getLpTokenValue(\n        address(self.lpToken),\n        address(self.tokenA),\n        address(self.tokenA),\n        address(self.tokenB),\n        false,\n        false\n      )\n      * dp.amt\n      / SAFE_MULTIPLIER;\n    } else {\n      // If tokenA or tokenB deposited\n      _dc.depositValue = GMXReader.convertToUsdValue(\n        self,\n        address(dp.token),\n        dp.amt\n      );\n    }\n    _dc.depositParams = dp;\n    _dc.healthParams = _hp;\n\n    self.depositCache = _dc;\n\n    GMXChecks.beforeDepositChecks(self, _dc.depositValue);\n\n    self.status = GMXTypes.Status.Deposit;\n\n    self.vault.mintFee();\n\n    // Borrow assets and create deposit in GMX\n    (\n      uint256 _borrowTokenAAmt,\n      uint256 _borrowTokenBAmt\n    ) = GMXManager.calcBorrow(self, _dc.depositValue);\n\n    _dc.borrowParams.borrowTokenAAmt = _borrowTokenAAmt;\n    _dc.borrowParams.borrowTokenBAmt = _borrowTokenBAmt;\n\n    GMXManager.borrow(self, _borrowTokenAAmt, _borrowTokenBAmt);\n\n    GMXTypes.AddLiquidityParams memory _alp;\n\n    _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n    _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n    _alp.minMarketTokenAmt = GMXManager.calcMinMarketSlippageAmt(\n      self,\n      _dc.depositValue,\n      dp.slippage\n    );\n    _alp.executionFee = dp.executionFee;\n\n    _dc.depositKey = GMXManager.addLiquidity(\n      self,\n      _alp\n    );\n\n    self.depositCache = _dc;\n\n    emit DepositCreated(\n      _dc.user,\n      _dc.depositParams.token,\n      _dc.depositParams.amt\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDeposit(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessDepositChecks(self);\n\n    // We transfer the core logic of this function to GMXProcessDeposit.processDeposit()\n    // to allow try/catch here to catch for any issues or any checks in afterDepositChecks() failing.\n    // If there are any issues, a DepositFailed event will be emitted and processDepositFailure()\n    // should be triggered to refund assets accordingly and reset the vault status to Open again.\n    try GMXProcessDeposit.processDeposit(self) {\n      // Mint shares to depositor\n      self.vault.mint(self.depositCache.user, self.depositCache.sharesToUser);\n\n      self.status = GMXTypes.Status.Open;\n\n      emit DepositCompleted(\n        self.depositCache.user,\n        self.depositCache.sharesToUser,\n        self.depositCache.healthParams.equityBefore,\n        self.depositCache.healthParams.equityAfter\n      );\n    } catch (bytes memory reason) {\n      self.status = GMXTypes.Status.Deposit_Failed;\n\n      emit DepositFailed(reason);\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDepositCancellation(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessDepositCancellationChecks(self);\n\n    // Repay borrowed assets\n    GMXManager.repay(\n      self,\n      self.depositCache.borrowParams.borrowTokenAAmt,\n      self.depositCache.borrowParams.borrowTokenBAmt\n    );\n\n    // Return user's deposited asset\n    // If native token is being withdrawn, we convert wrapped to native\n    if (self.depositCache.depositParams.token == address(self.WNT)) {\n      self.WNT.withdraw(self.WNT.balanceOf(address(this)));\n      (bool success, ) = self.depositCache.user.call{value: address(this).balance}(\"\");\n      require(success, \"Transfer failed.\");\n    } else {\n      // Transfer requested withdraw asset to user\n      IERC20(self.depositCache.depositParams.token).safeTransfer(\n        self.depositCache.user,\n        self.depositCache.depositParams.amt\n      );\n    }\n\n    self.status = GMXTypes.Status.Open;\n\n    emit DepositCancelled(self.depositCache.user);\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDepositFailure(\n    GMXTypes.Store storage self,\n    uint256 slippage,\n    uint256 executionFee\n  ) external {\n    GMXChecks.beforeProcessAfterDepositFailureChecks(self);\n\n    GMXTypes.RemoveLiquidityParams memory _rlp;\n\n    // If current LP amount is somehow less or equal to amount before, we do not remove any liquidity\n    if (GMXReader.lpAmt(self) <= self.depositCache.healthParams.lpAmtBefore) {\n      processDepositFailureLiquidityWithdrawal(self);\n    } else {\n      // Remove only the newly added LP amount\n      _rlp.lpAmt = GMXReader.lpAmt(self) - self.depositCache.healthParams.lpAmtBefore;\n\n      // If delta strategy is Long, remove all in tokenB to make it more\n      // efficent to repay tokenB debt as Long strategy only borrows tokenB\n      if (self.delta == GMXTypes.Delta.Long) {\n        address[] memory _tokenASwapPath = new address[](1);\n        _tokenASwapPath[0] = address(self.lpToken);\n        _rlp.tokenASwapPath = _tokenASwapPath;\n\n        (_rlp.minTokenAAmt, _rlp.minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n          self,\n          _rlp.lpAmt,\n          address(self.tokenB),\n          address(self.tokenB),\n          slippage\n        );\n      } else {\n        (_rlp.minTokenAAmt, _rlp.minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n          self,\n          _rlp.lpAmt,\n          address(self.tokenA),\n          address(self.tokenB),\n          slippage\n        );\n      }\n\n      _rlp.executionFee = executionFee;\n\n      // Remove liqudity\n      self.depositCache.withdrawKey = GMXManager.removeLiquidity(\n        self,\n        _rlp\n      );\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDepositFailureLiquidityWithdrawal(\n    GMXTypes.Store storage self\n  ) public {\n    GMXChecks.beforeProcessAfterDepositFailureLiquidityWithdrawal(self);\n\n    GMXTypes.RepayParams memory _rp;\n\n    _rp.repayTokenAAmt = self.depositCache.borrowParams.borrowTokenAAmt;\n    _rp.repayTokenBAmt = self.depositCache.borrowParams.borrowTokenBAmt;\n\n    // Check if swap between assets are needed for repayment based on previous borrow\n    (\n      bool _swapNeeded,\n      address _tokenFrom,\n      address _tokenTo,\n      uint256 _tokenToAmt\n    ) = GMXManager.calcSwapForRepay(self, _rp);\n\n    if (_swapNeeded) {\n      ISwap.SwapParams memory _sp;\n\n      _sp.tokenIn = _tokenFrom;\n      _sp.tokenOut = _tokenTo;\n      _sp.amountIn = IERC20(_tokenFrom).balanceOf(address(this));\n      _sp.amountOut = _tokenToAmt;\n      _sp.slippage = self.minSlippage;\n      _sp.deadline = block.timestamp;\n      // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n      // We allow deadline to be set as the current block timestamp whenever this function\n      // is called because this function is triggered as a follow up function (by a callback/keeper)\n      // and not directly by a user/keeper. If this follow on function flow reverts due to this tx\n      // being processed after a set deadline, this will cause the vault to be in a \"stuck\" state.\n      // To resolve this, this function will have to be called again with an updated deadline until it\n      // succeeds/a miner processes the tx.\n\n      GMXManager.swapTokensForExactTokens(self, _sp);\n    }\n\n    // Adjust amount to repay for both tokens due to slight differences\n    // from liqudiity withdrawal and swaps. If the amount to repay based on previous borrow\n    // is more than the available balance vault has, we simply repay what the vault has\n    uint256 _repayTokenAAmt;\n    uint256 _repayTokenBAmt;\n\n    if (self.depositCache.borrowParams.borrowTokenAAmt > self.tokenA.balanceOf(address(this))) {\n      _repayTokenAAmt = self.tokenA.balanceOf(address(this));\n    } else {\n      _repayTokenAAmt = self.depositCache.borrowParams.borrowTokenAAmt;\n    }\n\n    if (self.depositCache.borrowParams.borrowTokenBAmt > self.tokenB.balanceOf(address(this))) {\n      _repayTokenBAmt = self.tokenB.balanceOf(address(this));\n    } else {\n      _repayTokenBAmt = self.depositCache.borrowParams.borrowTokenBAmt;\n    }\n\n    // Repay borrowed assets\n    GMXManager.repay(\n      self,\n      _repayTokenAAmt,\n      _repayTokenBAmt\n    );\n\n    // Refund user the rest of the remaining withdrawn LP assets\n    // Will be in tokenA/tokenB only; so if user deposited LP tokens\n    // they will still be refunded in tokenA/tokenB\n    self.tokenA.safeTransfer(self.depositCache.user, self.tokenA.balanceOf(address(this)));\n    self.tokenB.safeTransfer(self.depositCache.user, self.tokenB.balanceOf(address(this)));\n\n    self.status = GMXTypes.Status.Open;\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXDeposit.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IDeposit } from \"../../interfaces/protocols/gmx/IDeposit.sol\";\nimport { IWithdrawal } from \"../../interfaces/protocols/gmx/IWithdrawal.sol\";\nimport { IEvent } from \"../../interfaces/protocols/gmx/IEvent.sol\";\nimport { IOrder } from \"../../interfaces/protocols/gmx/IOrder.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\nimport { GMXProcessDeposit } from \"./GMXProcessDeposit.sol\";\n\n/**\n  * @title GMXDeposit\n  * @author Steadefi\n  * @notice Re-usable library functions for deposit operations for Steadefi leveraged vaults\n*/\nlibrary GMXDeposit {\n  using SafeERC20 for IERC20;\n\n  /* ======================= CONSTANTS ======================= */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ======================== EVENTS ========================= */\n\n  event DepositCreated(\n    address indexed user,\n    address asset,\n    uint256 assetAmt\n  );\n  event DepositCompleted(\n    address indexed user,\n    uint256 shareAmt,\n    uint256 equityBefore,\n    uint256 equityAfter\n  );\n  event DepositCancelled(\n    address indexed user\n  );\n  event DepositFailed(bytes reason);\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n    * @param isNative Boolean as to whether user is depositing native asset (e.g. ETH, AVAX, etc.)\n  */\n  function deposit(\n    GMXTypes.Store storage self,\n    GMXTypes.DepositParams memory dp,\n    bool isNative\n  ) external {\n    // Sweep any tokenA/B in vault to the temporary trove for future compouding and to prevent\n    // it from being considered as part of depositor's assets\n    if (self.tokenA.balanceOf(address(this)) > 0) {\n      self.tokenA.safeTransfer(self.trove, self.tokenA.balanceOf(address(this)));\n    }\n    if (self.tokenB.balanceOf(address(this)) > 0) {\n      self.tokenB.safeTransfer(self.trove, self.tokenB.balanceOf(address(this)));\n    }\n\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.HealthParams memory _hp;\n\n    _hp.equityBefore = GMXReader.equityValue(self);\n    _hp.lpAmtBefore = GMXReader.lpAmt(self);\n    _hp.debtRatioBefore = GMXReader.debtRatio(self);\n    _hp.deltaBefore = GMXReader.delta(self);\n\n    // Transfer assets from user to vault\n    if (isNative) {\n      GMXChecks.beforeNativeDepositChecks(self, dp);\n\n      self.WNT.deposit{ value: dp.amt }();\n    } else {\n      IERC20(dp.token).safeTransferFrom(msg.sender, address(this), dp.amt);\n    }\n\n    GMXTypes.DepositCache memory _dc;\n\n    _dc.user = payable(msg.sender);\n\n    if (dp.token == address(self.lpToken)) {\n      // If LP token deposited\n      _dc.depositValue = self.gmxOracle.getLpTokenValue(\n        address(self.lpToken),\n        address(self.tokenA),\n        address(self.tokenA),\n        address(self.tokenB),\n        false,\n        false\n      )\n      * dp.amt\n      / SAFE_MULTIPLIER;\n    } else {\n      // If tokenA or tokenB deposited\n      _dc.depositValue = GMXReader.convertToUsdValue(\n        self,\n        address(dp.token),\n        dp.amt\n      );\n    }\n    _dc.depositParams = dp;\n    _dc.healthParams = _hp;\n\n    self.depositCache = _dc;\n\n    GMXChecks.beforeDepositChecks(self, _dc.depositValue);\n\n    self.status = GMXTypes.Status.Deposit;\n\n    self.vault.mintFee();\n\n    // Borrow assets and create deposit in GMX\n    (\n      uint256 _borrowTokenAAmt,\n      uint256 _borrowTokenBAmt\n    ) = GMXManager.calcBorrow(self, _dc.depositValue);\n\n    _dc.borrowParams.borrowTokenAAmt = _borrowTokenAAmt;\n    _dc.borrowParams.borrowTokenBAmt = _borrowTokenBAmt;\n\n    GMXManager.borrow(self, _borrowTokenAAmt, _borrowTokenBAmt);\n\n    GMXTypes.AddLiquidityParams memory _alp;\n\n    _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n    _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n    _alp.minMarketTokenAmt = GMXManager.calcMinMarketSlippageAmt(\n      self,\n      _dc.depositValue,\n      dp.slippage\n    );\n    _alp.executionFee = dp.executionFee;\n\n    _dc.depositKey = GMXManager.addLiquidity(\n      self,\n      _alp\n    );\n\n    self.depositCache = _dc;\n\n    emit DepositCreated(\n      _dc.user,\n      _dc.depositParams.token,\n      _dc.depositParams.amt\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDeposit(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessDepositChecks(self);\n\n    // We transfer the core logic of this function to GMXProcessDeposit.processDeposit()\n    // to allow try/catch here to catch for any issues or any checks in afterDepositChecks() failing.\n    // If there are any issues, a DepositFailed event will be emitted and processDepositFailure()\n    // should be triggered to refund assets accordingly and reset the vault status to Open again.\n    try GMXProcessDeposit.processDeposit(self) {\n      // Mint shares to depositor\n      self.vault.mint(self.depositCache.user, self.depositCache.sharesToUser);\n\n      self.status = GMXTypes.Status.Open;\n\n      emit DepositCompleted(\n        self.depositCache.user,\n        self.depositCache.sharesToUser,\n        self.depositCache.healthParams.equityBefore,\n        self.depositCache.healthParams.equityAfter\n      );\n    } catch (bytes memory reason) {\n      self.status = GMXTypes.Status.Deposit_Failed;\n\n      emit DepositFailed(reason);\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDepositCancellation(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessDepositCancellationChecks(self);\n\n    // Repay borrowed assets\n    GMXManager.repay(\n      self,\n      self.depositCache.borrowParams.borrowTokenAAmt,\n      self.depositCache.borrowParams.borrowTokenBAmt\n    );\n\n    // Return user's deposited asset\n    // If native token is being withdrawn, we convert wrapped to native\n    if (self.depositCache.depositParams.token == address(self.WNT)) {\n      self.WNT.withdraw(self.WNT.balanceOf(address(this)));\n      (bool success, ) = self.depositCache.user.call{value: address(this).balance}(\"\");\n      require(success, \"Transfer failed.\");\n    } else {\n      // Transfer requested withdraw asset to user\n      IERC20(self.depositCache.depositParams.token).safeTransfer(\n        self.depositCache.user,\n        self.depositCache.depositParams.amt\n      );\n    }\n\n    self.status = GMXTypes.Status.Open;\n\n    emit DepositCancelled(self.depositCache.user);\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDepositFailure(\n    GMXTypes.Store storage self,\n    uint256 slippage,\n    uint256 executionFee\n  ) external {\n    GMXChecks.beforeProcessAfterDepositFailureChecks(self);\n\n    GMXTypes.RemoveLiquidityParams memory _rlp;\n\n    // If current LP amount is somehow less or equal to amount before, we do not remove any liquidity\n    if (GMXReader.lpAmt(self) <= self.depositCache.healthParams.lpAmtBefore) {\n      processDepositFailureLiquidityWithdrawal(self);\n    } else {\n      // Remove only the newly added LP amount\n      _rlp.lpAmt = GMXReader.lpAmt(self) - self.depositCache.healthParams.lpAmtBefore;\n\n      // If delta strategy is Long, remove all in tokenB to make it more\n      // efficent to repay tokenB debt as Long strategy only borrows tokenB\n      if (self.delta == GMXTypes.Delta.Long) {\n        address[] memory _tokenASwapPath = new address[](1);\n        _tokenASwapPath[0] = address(self.lpToken);\n        _rlp.tokenASwapPath = _tokenASwapPath;\n\n        (_rlp.minTokenAAmt, _rlp.minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n          self,\n          _rlp.lpAmt,\n          address(self.tokenB),\n          address(self.tokenB),\n          slippage\n        );\n      } else {\n        (_rlp.minTokenAAmt, _rlp.minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n          self,\n          _rlp.lpAmt,\n          address(self.tokenA),\n          address(self.tokenB),\n          slippage\n        );\n      }\n\n      _rlp.executionFee = executionFee;\n\n      // Remove liqudity\n      self.depositCache.withdrawKey = GMXManager.removeLiquidity(\n        self,\n        _rlp\n      );\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDepositFailureLiquidityWithdrawal(\n    GMXTypes.Store storage self\n  ) public {\n    GMXChecks.beforeProcessAfterDepositFailureLiquidityWithdrawal(self);\n\n    GMXTypes.RepayParams memory _rp;\n\n    _rp.repayTokenAAmt = self.depositCache.borrowParams.borrowTokenAAmt;\n    _rp.repayTokenBAmt = self.depositCache.borrowParams.borrowTokenBAmt;\n\n    // Check if swap between assets are needed for repayment based on previous borrow\n    (\n      bool _swapNeeded,\n      address _tokenFrom,\n      address _tokenTo,\n      uint256 _tokenToAmt\n    ) = GMXManager.calcSwapForRepay(self, _rp);\n\n    if (_swapNeeded) {\n      ISwap.SwapParams memory _sp;\n\n      _sp.tokenIn = _tokenFrom;\n      _sp.tokenOut = _tokenTo;\n      _sp.amountIn = IERC20(_tokenFrom).balanceOf(address(this));\n      _sp.amountOut = _tokenToAmt;\n      _sp.slippage = self.minSlippage;\n      _sp.deadline = block.timestamp;\n      // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n      // We allow deadline to be set as the current block timestamp whenever this function\n      // is called because this function is triggered as a follow up function (by a callback/keeper)\n      // and not directly by a user/keeper. If this follow on function flow reverts due to this tx\n      // being processed after a set deadline, this will cause the vault to be in a \"stuck\" state.\n      // To resolve this, this function will have to be called again with an updated deadline until it\n      // succeeds/a miner processes the tx.\n\n      GMXManager.swapTokensForExactTokens(self, _sp);\n    }\n\n    // Adjust amount to repay for both tokens due to slight differences\n    // from liqudiity withdrawal and swaps. If the amount to repay based on previous borrow\n    // is more than the available balance vault has, we simply repay what the vault has\n    uint256 _repayTokenAAmt;\n    uint256 _repayTokenBAmt;\n\n    if (self.depositCache.borrowParams.borrowTokenAAmt > self.tokenA.balanceOf(address(this))) {\n      _repayTokenAAmt = self.tokenA.balanceOf(address(this));\n    } else {\n      _repayTokenAAmt = self.depositCache.borrowParams.borrowTokenAAmt;\n    }\n\n    if (self.depositCache.borrowParams.borrowTokenBAmt > self.tokenB.balanceOf(address(this))) {\n      _repayTokenBAmt = self.tokenB.balanceOf(address(this));\n    } else {\n      _repayTokenBAmt = self.depositCache.borrowParams.borrowTokenBAmt;\n    }\n\n    // Repay borrowed assets\n    GMXManager.repay(\n      self,\n      _repayTokenAAmt,\n      _repayTokenBAmt\n    );\n\n    // Refund user the rest of the remaining withdrawn LP assets\n    // Will be in tokenA/tokenB only; so if user deposited LP tokens\n    // they will still be refunded in tokenA/tokenB\n    self.tokenA.safeTransfer(self.depositCache.user, self.tokenA.balanceOf(address(this)));\n    self.tokenB.safeTransfer(self.depositCache.user, self.tokenB.balanceOf(address(this)));\n\n    self.status = GMXTypes.Status.Open;\n  }\n}"
    },
    {
      "filename": "contracts/withdrawal/ExecuteWithdrawalUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../adl/AdlUtils.sol\";\n\nimport \"../data/DataStore.sol\";\n\nimport \"./WithdrawalVault.sol\";\nimport \"./WithdrawalStoreUtils.sol\";\nimport \"./WithdrawalEventUtils.sol\";\n\nimport \"../nonce/NonceUtils.sol\";\nimport \"../pricing/SwapPricingUtils.sol\";\nimport \"../oracle/Oracle.sol\";\nimport \"../oracle/OracleUtils.sol\";\n\nimport \"../gas/GasUtils.sol\";\nimport \"../callback/CallbackUtils.sol\";\n\nimport \"../utils/Array.sol\";\nimport \"../utils/AccountUtils.sol\";\n\nlibrary ExecuteWithdrawalUtils {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using Array for uint256[];\n    using Price for Price.Props;\n    using Withdrawal for Withdrawal.Props;\n\n    using EventUtils for EventUtils.AddressItems;\n    using EventUtils for EventUtils.UintItems;\n    using EventUtils for EventUtils.IntItems;\n    using EventUtils for EventUtils.BoolItems;\n    using EventUtils for EventUtils.Bytes32Items;\n    using EventUtils for EventUtils.BytesItems;\n    using EventUtils for EventUtils.StringItems;\n\n    /**\n     * @param dataStore The data store where withdrawal data is stored.\n     * @param eventEmitter The event emitter that is used to emit events.\n     * @param withdrawalVault WithdrawalVault.\n     * @param oracle The oracle that provides market prices.\n     * @param key The unique identifier of the withdrawal to execute.\n     * @param minOracleBlockNumbers The min block numbers for the oracle prices.\n     * @param maxOracleBlockNumbers The max block numbers for the oracle prices.\n     * @param keeper The keeper that is executing the withdrawal.\n     * @param startingGas The starting gas limit for the withdrawal execution.\n     */\n    struct ExecuteWithdrawalParams {\n        DataStore dataStore;\n        EventEmitter eventEmitter;\n        WithdrawalVault withdrawalVault;\n        Oracle oracle;\n        bytes32 key;\n        uint256[] minOracleBlockNumbers;\n        uint256[] maxOracleBlockNumbers;\n        address keeper;\n        uint256 startingGas;\n    }\n\n    struct ExecuteWithdrawalCache {\n        uint256 longTokenOutputAmount;\n        uint256 shortTokenOutputAmount;\n        SwapPricingUtils.SwapFees longTokenFees;\n        SwapPricingUtils.SwapFees shortTokenFees;\n        uint256 longTokenPoolAmountDelta;\n        uint256 shortTokenPoolAmountDelta;\n    }\n\n    struct ExecuteWithdrawalResult {\n        address outputToken;\n        uint256 outputAmount;\n        address secondaryOutputToken;\n        uint256 secondaryOutputAmount;\n    }\n\n    struct SwapCache {\n        Market.Props[] swapPathMarkets;\n        SwapUtils.SwapParams swapParams;\n        address outputToken;\n        uint256 outputAmount;\n    }\n\n    /**\n     * Executes a withdrawal on the market.\n     *\n     * @param params The parameters for executing the withdrawal.\n     */\n    function executeWithdrawal(ExecuteWithdrawalParams memory params, Withdrawal.Props memory withdrawal) external {\n        // 63/64 gas is forwarded to external calls, reduce the startingGas to account for this\n        params.startingGas -= gasleft() / 63;\n\n        WithdrawalStoreUtils.remove(params.dataStore, params.key, withdrawal.account());\n\n        if (withdrawal.account() == address(0)) {\n            revert Errors.EmptyWithdrawal();\n        }\n        if (withdrawal.marketTokenAmount() == 0) {\n            revert Errors.EmptyWithdrawalAmount();\n        }\n\n        OracleUtils.validateBlockNumberWithinRange(\n            params.minOracleBlockNumbers,\n            params.maxOracleBlockNumbers,\n            withdrawal.updatedAtBlock()\n        );\n\n        MarketUtils.distributePositionImpactPool(\n            params.dataStore,\n            params.eventEmitter,\n            withdrawal.market()\n        );\n\n        uint256 marketTokensBalance = MarketToken(payable(withdrawal.market())).balanceOf(address(params.withdrawalVault));\n        if (marketTokensBalance < withdrawal.marketTokenAmount()) {\n            revert Errors.InsufficientMarketTokens(marketTokensBalance, withdrawal.marketTokenAmount());\n        }\n\n        ExecuteWithdrawalResult memory result = _executeWithdrawal(params, withdrawal);\n\n        WithdrawalEventUtils.emitWithdrawalExecuted(\n            params.eventEmitter,\n            params.key,\n            withdrawal.account()\n        );\n\n        EventUtils.EventLogData memory eventData;\n        eventData.addressItems.initItems(2);\n        eventData.addressItems.setItem(0, \"outputToken\", result.outputToken);\n        eventData.addressItems.setItem(1, \"secondaryOutputToken\", result.secondaryOutputToken);\n        eventData.uintItems.initItems(2);\n        eventData.uintItems.setItem(0, \"outputAmount\", result.outputAmount);\n        eventData.uintItems.setItem(1, \"secondaryOutputAmount\", result.secondaryOutputAmount);\n        CallbackUtils.afterWithdrawalExecution(params.key, withdrawal, eventData);\n\n        GasUtils.payExecutionFee(\n            params.dataStore,\n            params.eventEmitter,\n            params.withdrawalVault,\n            withdrawal.executionFee(),\n            params.startingGas,\n            params.keeper,\n            withdrawal.account()\n        );\n    }\n\n    /**\n     * @dev executes a withdrawal.\n     * @param params ExecuteWithdrawalParams.\n     * @param withdrawal The withdrawal to execute.\n     */\n    function _executeWithdrawal(\n        ExecuteWithdrawalParams memory params,\n        Withdrawal.Props memory withdrawal\n    ) int"
    }
  ]
}