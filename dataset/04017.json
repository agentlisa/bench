{
  "Title": "[L01] Duplicated transfer of ownership",
  "Content": "In the [`initialize` function](https://github.com/celo-org/celo-monorepo/blob/af49272ef57a077ee6e704aad76d506c039798d3/packages/protocol/contracts/common/MetaTransactionWallet.sol#L66) of the [`MetaTransactionWallet` contract](https://github.com/celo-org/celo-monorepo/blob/af49272ef57a077ee6e704aad76d506c039798d3/packages/protocol/contracts/common/MetaTransactionWallet.sol#L12) the internal `_transferOwnership` function is [first called with the `msg.sender` as its parameter](https://github.com/celo-org/celo-monorepo/blob/af49272ef57a077ee6e704aad76d506c039798d3/packages/protocol/contracts/common/MetaTransactionWallet.sol#L67) and then it is [called to assign the ownership to itself](https://github.com/celo-org/celo-monorepo/blob/af49272ef57a077ee6e704aad76d506c039798d3/packages/protocol/contracts/common/MetaTransactionWallet.sol#L74). This complexity makes the transaction less gas-efficient by writing two times to storage.\n\n\nConsider declaring a function with `internal` visibility that can modify the `signer` variable without using the `onlyOwner` modifier and using it in the `initialize` function to decrease the amount of gas used by this function.\n\n\n**Update**: *Fixed in [PR#5943](https://github.com/celo-org/celo-monorepo/pull/5943/files). The `initialize` function no longer transfers ownership twice.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/common/MetaTransactionWallet.sol",
      "content": "pragma solidity ^0.5.13;\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\nimport \"./interfaces/ICeloVersionedContract.sol\";\nimport \"./interfaces/IMetaTransactionWallet.sol\";\nimport \"./ExternalCall.sol\";\nimport \"./Initializable.sol\";\nimport \"./Signatures.sol\";\n\ncontract MetaTransactionWallet is\n  IMetaTransactionWallet,\n  ICeloVersionedContract,\n  Initializable,\n  Ownable\n{\n  using SafeMath for uint256;\n  using BytesLib for bytes;\n\n  bytes32 public eip712DomainSeparator;\n  // The EIP712 typehash for ExecuteMetaTransaction, i.e. keccak256(\n  // \"ExecuteMetaTransaction(address destination,uint256 value,bytes data,uint256 nonce)\");\n  bytes32 public constant EIP712_EXECUTE_META_TRANSACTION_TYPEHASH = (\n    0x509c6e92324b7214543573524d0bb493d654d3410fa4f4937b3d2f4a903edd33\n  );\n  uint256 public nonce;\n  address public signer;\n\n  event SignerSet(address indexed signer);\n  event EIP712DomainSeparatorSet(bytes32 eip712DomainSeparator);\n  event Deposit(address indexed sender, uint256 value);\n  event TransactionExecution(\n    address indexed destination,\n    uint256 value,\n    bytes data,\n    bytes returnData\n  );\n  event MetaTransactionExecution(\n    address indexed destination,\n    uint256 value,\n    bytes data,\n    uint256 indexed nonce,\n    bytes returnData\n  );\n\n  /**\n   * @dev Fallback function allows to deposit ether.\n   */\n  function() external payable {\n    if (msg.value > 0) emit Deposit(msg.sender, msg.value);\n  }\n\n  /**\n   * @notice Returns the storage, major, minor, and patch version of the contract.\n   * @return The storage, major, minor, and patch version of the contract.\n   */\n  function getVersionNumber() public pure returns (uint256, uint256, uint256, uint256) {\n    return (1, 1, 0, 1);\n  }\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param _signer The address authorized to execute transactions via this wallet.\n   */\n  function initialize(address _signer) external initializer {\n    _transferOwnership(msg.sender);\n    setSigner(_signer);\n    setEip712DomainSeparator();\n    // MetaTransactionWallet owns itself, which necessitates that all onlyOwner functions\n    // be called via executeTransaction or executeMetaTransaction.\n    // If the signer was the owner, onlyOwner functions would not be callable via\n    // meta-transactions.\n    _transferOwnership(address(this));\n  }\n\n  /**\n   * @notice Transfers control of the wallet to a new signer.\n   * @param _signer The address authorized to execute transactions via this wallet.\n   */\n  function setSigner(address _signer) public onlyOwner {\n    require(_signer != address(0), \"cannot assign zero address as signer\");\n    signer = _signer;\n    emit SignerSet(signer);\n  }\n\n  /**\n   * @notice Sets the EIP-712 domain separator.\n   * @dev Should be called every time the wallet is upgraded to a new version.\n   */\n  function setEip712DomainSeparator() public {\n    uint256 id;\n    assembly {\n      id := chainid\n    }\n    // Note: `version` is the storage.major part of this contract's version (an\n    // increase to either of these could mean backwards incompatibilities).\n    eip712DomainSeparator = keccak256(\n      abi.encode(\n        keccak256(\n          \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        ),\n        keccak256(bytes(\"MetaTransactionWallet\")),\n        keccak256(\"1.1\"),\n        id,\n        address(this)\n      )\n    );\n    emit EIP712DomainSeparatorSet(eip712DomainSeparator);\n  }\n\n  /**\n   * @notice Returns the struct hash of the MetaTransaction\n   * @param destination The address to which the meta-transaction is to be sent.\n   * @param value The CELO value to be sent with the meta-transaction.\n   * @param data The data to be sent with the meta-transaction.\n   * @param _nonce The nonce for this meta-transaction local to this wallet.\n   * @return The digest of the provided meta-transaction.\n   */\n  function _getMetaTransactionStructHash(\n    address destination,\n    uint256 value,\n    bytes memory data,\n    uint256 _nonce\n  ) internal view returns (bytes32) {\n    return\n      keccak256(\n        abi.encode(\n          EIP712_EXECUTE_META_TRANSACTION_TYPEHASH,\n          destination,\n          value,\n          keccak256(data),\n          _nonce\n        )\n      );\n  }\n\n  /**\n   * @notice Returns the digest of the provided meta-transaction, to be signed by `sender`.\n   * @param destination The address to which the meta-transaction is to be sent.\n   * @param value The CELO value to be sent with the meta-transaction.\n   * @param data The data to be sent with the meta-transaction.\n   * @param _nonce The nonce for this meta-transaction local to this wallet.\n   * @return The digest of the provided meta-transaction.\n   */\n  function getMetaTransactionDigest(\n    address destination,\n    uint256 value,\n    bytes memory data,\n    uint256 _nonce\n  ) public view returns (bytes32) {\n    bytes32 structHash = _getMetaTransactionStructHash(destination, value, data, _nonce);\n    return Signatures.toEthSignedTypedDataHash(eip712DomainSeparator, structHash);\n  }\n\n  /**\n   * @notice Returns the address that signed the provided meta-transaction.\n   * @param destination The address to which the meta-transaction is to be sent.\n   * @param value The CELO value to be sent with the meta-transaction.\n   * @param data The data to be sent with the meta-transaction.\n   * @param _nonce The nonce for this meta-transaction local to this wallet.\n   * @param v The recovery id of the ECDSA signature of the meta-transaction.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @return The address that signed the provided meta-transaction.\n   */\n  function getMetaTransactionSigner(\n    address destination,\n    uint256 value,\n    bytes memory data,\n    uint256 _nonce,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public view returns (address) {\n    bytes32 structHash = _getMetaTransactionStructHash(destination, value, data, _nonce);\n    return Signatures.getSignerOfTypedDataHash(eip712DomainSeparator, structHash, v, r, s);\n  }\n\n  /**\n   * @notice Executes a meta-transaction on behalf of the signer.\n   * @param destination The address to which the meta-transaction is to be sent.\n   * @param value The CELO value to be sent with the meta-transaction.\n   * @param data The data to be sent with the meta-transaction.\n   * @param v The recovery id of the ECDSA signature of the meta-transaction.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @return The return value of the meta-transaction execution.\n   */\n  function executeMetaTransaction(\n    address destination,\n    uint256 value,\n    bytes calldata data,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (bytes memory) {\n    address _signer = getMetaTransactionSigner(destination, value, data, nonce, v, r, s);\n    require(_signer == signer, \"Invalid meta-transaction signer\");\n    nonce = nonce.add(1);\n    bytes memory returnData = ExternalCall.execute(destination, value, data);\n    emit MetaTransactionExecution(destination, value, data, nonce.sub(1), returnData);\n    return returnData;\n  }\n\n  /**\n   * @notice Executes a transaction on behalf of the signer.`\n   * @param destination The address to which the transaction is to be sent.\n   * @param value The CELO value to be sent with the transaction.\n   * @param data The data to be sent with the transaction.\n   * @return The return value of the transaction execution.\n   */\n  function executeTransaction(address destination, uint256 value, bytes memory data)\n    public\n    returns (bytes memory)\n  {\n    // Allowing the owner to call execute transaction allows, when the contract is self-owned,\n    // for the signer to sign and execute a batch of transactions via a meta-transaction.\n    require(msg.sender == signer || msg.sender == owner(), \"Invalid transaction sender\");\n    bytes memory returnData = ExternalCall.execute(destination, value, data);\n    emit TransactionExecution(destination, value, data, returnData);\n    return returnData;\n  }\n\n  /**\n   * @notice Executes multiple transactions on behalf of the signer.`\n   * @param destinations The address to which each transaction is to be sent.\n   * @param values The CELO value to be sent with each transaction.\n   * @param data The concatenated data to be sent in each transaction.\n   * @param dataLengths The length of each transaction's data.\n   * @return The return values of all transactions appended as bytes and an array of the length\n   *         of each transaction output which will be 0 if a transaction had no output \n   */\n  function executeTransactions(\n    address[] calldata destinations,\n    uint256[] calldata values,\n    bytes calldata data,\n    uint256[] calldata dataLengths\n  ) external returns (bytes memory, uint256[] memory) {\n    require(\n      destinations.length == values.length && values.length == dataLengths.length,\n      \"Input arrays must be same length\"\n    );\n\n    bytes memory returnValues;\n    uint256[] memory returnLengths = new uint256[](destinations.length);\n    uint256 dataPosition = 0;\n    for (uint256 i = 0; i < destinations.length; i = i.add(1)) {\n      bytes memory returnVal = executeTransaction(\n        destinations[i],\n        values[i],\n        sliceData(data, dataPosition, dataLengths[i])\n      );\n      returnValues = abi.encodePacked(returnValues, returnVal);\n      returnLengths[i] = returnVal.length;\n      dataPosition = dataPosition.add(dataLengths[i]);\n    }\n\n    require(dataPosition == data.length, \"data cannot have extra bytes appended\");\n    return (returnValues, returnLengths);\n  }\n\n  /**\n   * @notice Returns a slice from a byte array.\n   * @param data The byte array.\n   * @param start The start index of the slice to take.\n   * @param length The length of the slice to take.\n   * @return A slice from a byte array.\n   */\n  function sliceData(bytes memory data, uint256 start, uint256 length)\n    internal\n    returns (bytes memory)\n  {\n    // When length == 0 bytes.slice does not seem to always return an empty byte array.\n    bytes memory sliced;\n    if (length > 0) {\n      sliced = data.slice(start, length);\n    }\n    return sliced;\n  }\n}"
    }
  ]
}