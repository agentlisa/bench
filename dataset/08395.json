{
  "Title": "[G-27] `require()`/`revert()` strings longer than 32 bytes cost extra gas",
  "Content": "Each extra chunk of byetes past the original 32 i[incurs an MSTORE](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#consider-having-short-revert-strings) which costs 3 gas.<br>\n*There are 8 instances of this issue:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/governance/GolomToken.sol#L24\n```solidity\nFile:\tcontracts/governance/GolomToken.sol\n24: require(msg.sender == minter, 'GolomToken: only reward distributor can enable');\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L181\n```solidity\nFile:\tcontracts/rewards/RewardDistributor.sol\n181:  require(tokenowner == ve.ownerOf(tokenids[tindex]), 'Can only claim for a single Address together');\n\n292: require(traderEnableDate <= block.timestamp, 'RewardDistributor: time not over yet');\n\n309: require(voteEscrowEnableDate <= block.timestamp, 'RewardDistributor: time not over yet');\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowDelegation.sol#L73\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowDelegation.sol\n73: require(this.balanceOfNFT(tokenId) >= MIN_VOTING_POWER_REQUIRED, 'VEDelegation: Need more voting power');\n\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L929\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n929: require(_locked.end > block.timestamp, 'Cannot add to expired lock. Withdraw');\n\n945: require(unlock_time > block.timestamp, 'Can only lock until time in the future');\n\n983: require(_locked.end > block.timestamp, 'Cannot add to expired lock. Withdraw');\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-07-golom-contest",
  "Code": [
    {
      "filename": "contracts/governance/GolomToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\n/// @title Golom ERC20 governance token\n/// @notice Explain to an end user what this does\n/// @dev Implements ERC20, ERC20Votes and ERC20Permits from OpenZepellin\n\n// Tokens are minted on the initial mint\n// Additionally mint function is called to mint the tokens, only the reward distributor contract will be able to mint the token\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol';\n\ncontract GolomToken is ERC20Votes, Ownable {\n    address public minter;\n\n    uint256 public minterEnableDate;\n    address public pendingMinter;\n\n    bool public isAirdropMinted;\n    bool public isGenesisRewardMinted;\n\n    modifier onlyMinter() {\n        require(msg.sender == minter, 'GolomToken: only reward distributor can enable');\n        _;\n    }\n\n    constructor(address _governance) ERC20('Golom', 'GOL') ERC20Permit('Golom') {\n        _transferOwnership(_governance); // set the new owner\n    }\n\n    /// @notice Mints the tokens\n    /// @dev only minter can mint the tokens, minter will be RewardDistributor.sol\n    /// @param _account Address where the tokens will be minted\n    /// @param _amount Number of tokens to be minted\n    function mint(address _account, uint256 _amount) external onlyMinter {\n        _mint(_account, _amount);\n    }\n\n    /// @notice Mints 150M for the airdrop\n    /// @param _airdrop Airdrop contract\n    function mintAirdrop(address _airdrop) external onlyOwner {\n        require(!isAirdropMinted, 'already minted');\n        _mint(_airdrop, 150_000_000 * 1e18);\n        isAirdropMinted = true;\n    }\n\n    /// @notice Mint Genesis Reward\n    /// @param _rewardDistributor Address of the rewardDistributor\n    function mintGenesisReward(address _rewardDistributor) external onlyOwner {\n        require(!isGenesisRewardMinted, 'already minted');\n        _mint(_rewardDistributor, 62_500_000 * 1e18);\n        isGenesisRewardMinted = true;\n    }\n\n    /// @notice sets the minter with timelock, once setup admin needs to call executeSetMinter()\n    /// @param _minter Address of the new minter\n    function setMinter(address _minter) external onlyOwner {\n        pendingMinter = _minter;\n        minterEnableDate = block.timestamp + 1 days;\n    }\n\n    /// @notice Executes the set minter function after the timelock\n    /// @dev If being called first time, there won't be any timelock\n    function executeSetMinter() external onlyOwner {\n        if (minter == address(0)) {\n            minter = pendingMinter;\n        } else {\n            require(minterEnableDate <= block.timestamp, 'GolomToken: wait for timelock');\n            minter = pendingMinter;\n        }\n    }\n}"
    },
    {
      "filename": "contracts/rewards/RewardDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\n// stores daily trades\n// is minter of token, first interaction mints tokens and distributes tokens\n// gives prorata tokens to traders and exchange daily\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport 'hardhat/console.sol';\n\ninterface ERC20 {\n    function totalSupply() external returns (uint256);\n\n    function balanceOf(address account) external returns (uint256);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external returns (bool);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function mint(address account, uint256 amount) external;\n\n    function balanceOfNFTAt(uint256 _tokenId, uint256 _t) external view returns (uint256);\n\n    function deposit() external payable;\n}\n\ninterface VE {\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    function totalSupplyAtT(uint256 t) external view returns (uint256);\n\n    function balanceOfNFTAt(uint256 _tokenId, uint256 _t) external view returns (uint256);\n\n    function totalSupplyAt(uint256 _block) external view returns (uint256);\n\n    function balanceOfAtNFT(uint256 _tokenId, uint256 _block) external view returns (uint256);\n}\n\ncontract RewardDistributor is Ownable {\n    address public trader;\n    uint256 public epoch = 0;\n    uint256 public startTime; // timestamp at which the contracts need to be activated\n\n    uint256 constant dailyEmission = 600000 * 10**18;\n\n    address public pendingTrader;\n    uint256 public traderEnableDate;\n\n    address public pendingVoteEscrow;\n    uint256 public voteEscrowEnableDate;\n    VE public ve;\n\n    uint256 constant secsInDay = 24 * 60 * 60;\n    mapping(address => mapping(uint256 => uint256)) public feesTrader; // fees accumulated by address of trader per epoch\n    mapping(address => mapping(uint256 => uint256)) public feesExchange; // fees accumulated by exchange of trader per epoch\n    mapping(uint256 => uint256) public epochTotalFee; // total fee of epoch\n    mapping(uint256 => uint256) public rewardTrader; // reward minted each epoc for trader\n    mapping(uint256 => uint256) public rewardExchange; // reward minted each epoc for exhange\n    mapping(uint256 => uint256) public rewardLP; // reward minted each epoc for LP\n    mapping(uint256 => uint256) public rewardStaker; // reward minted each epoc for stakers\n    mapping(uint256 => uint256) public epochBeginTime; // what time previous epoch ended\n    mapping(uint256 => uint256) public claimedUpto; // epoch upto which tokenid has claimed\n    mapping(uint256 => mapping(uint256 => uint256)) public claimed; // epoch upto which tokenid has claimed\n    ERC20 public rewardToken;\n    ERC20 public weth;\n    event NewEpoch(uint256 indexed epochNo, uint256 tokenMinted, uint256 rewardStaker, uint256 previousEpochFee);\n\n    // epochs,trader, token\n\n    constructor(\n        address _weth,\n        address _trader,\n        address _token,\n        address _governance\n    ) {\n        weth = ERC20(_weth);\n        trader = _trader;\n        rewardToken = ERC20(_token);\n        _transferOwnership(_governance); // set the new owner\n        startTime = 1659211200;\n    }\n\n    modifier onlyTrader() {\n        require(msg.sender == trader);\n        _;\n    }\n\n    // at starttime epoch 1 starts , first trade changes epoch from 0 to 1 , emits tokens stores the rewards for epoch 1 ,\n    // after 1 day , first trade changes epoch from 1 to 2, changes eth in contract to weth and stores rewardstakedeth , emits tokens stores the rewards for epoch 2\n\n    /// @dev Add fees contributed by the Seller of nft and the exchange/frontend that facilated the trade\n    /// @param addr the address that contributed in fees\n    /// @param fee the fee contributed by these addresses\n    function addFee(address[2] memory addr, uint256 fee) public onlyTrader {\n        //console.log(block.timestamp,epoch,fee);\n        if (rewardToken.totalSupply() > 1000000000 * 10**18) {\n            // if supply is greater then a billion dont mint anything, dont add trades\n            return;\n        }\n\n        // if 24 hours have passed since last epoch change\n        if (block.timestamp > startTime + (epoch) * secsInDay) {\n            // this assumes atleast 1 trade is done daily??????\n            // logic to decide how much token to emit\n            // emission = daily * (1 - (balance of locker/ total supply))  full if 0 locked and 0 if all locked\n            // uint256 tokenToEmit = dailyEmission * rewardToken.balanceOf()/\n            // emissions is decided by epoch begiining locked/circulating , and amount each nft gets also decided at epoch begining\n            uint256 tokenToEmit = (dailyEmission * (rewardToken.totalSupply() - rewardToken.balanceOf(address(ve)))) /\n                rewardToken.totalSupply();\n            uint256 stakerReward = (tokenToEmit * rewardToken.balanceOf(address(ve))) / rewardToken.totalSupply();\n            // deposit previous epoch fee to weth for distribution to stakers\n\n            uint256 previousEpochFee = epochTotalFee[epoch];\n            epoch = epoch + 1;\n            rewardStaker[epoch] = stakerReward;\n            rewardTrader[epoch] = ((tokenToEmit - stakerReward) * 67) / 100;\n            rewardExchange[epoch] = ((tokenToEmit - stakerReward) * 33) / 100;\n            rewardToken.mint(address(this), tokenToEmit);\n            epochBeginTime[epoch] = block.number;\n            if (previousEpochFee > 0) {\n                if (epoch == 1){\n                    epochTotalFee[0] =  address(this).balance; // staking and trading rewards start at epoch 1, for epoch 0 all contract ETH balance is converted to staker rewards rewards.\n                    weth.deposit{value: address(this).balance}();  \n                }else{\n                    weth.deposit{value: previousEpochFee}();\n                }\n            }\n            emit NewEpoch(epoch, tokenToEmit, stakerReward, previousEpochFee);\n        }\n        feesTrader[addr[0]][epoch] = feesTrader[addr[0]][epoch] + fee;\n        feesExchange[addr[1]][epoch] = feesExchange[addr[1]][epoch] + fee;\n        epochTotalFee[epoch] = epochTotalFee[epoch] + fee;\n        return;\n    }\n\n    // allows sellers of nft to claim there previous epoch rewards\n    function traderClaim(address addr, uint256[] memory epochs) public {\n        uint256 reward = 0;\n        for (uint256 index = 0; index < epochs.length; index++) {\n            require(epochs[index] < epoch);\n            reward =\n                reward +\n                (rewardTrader[epochs[index]] * feesTrader[addr][epochs[index]]) /\n                epochTotalFee[epochs[index]];\n            feesTrader[addr][epochs[index]] = 0;\n        }\n        rewardToken.transfer(addr, reward);\n    }\n\n    // allows exchange that facilated the nft trades to claim there previous epoch rewards\n    function exchangeClaim(address addr, uint256[] memory epochs) public {\n        uint256 reward = 0;\n        for (uint256 index = 0; index < epochs.length; index++) {\n            require(epochs[index] < epoch);\n            reward =\n                reward +\n                (rewardExchange[epochs[index]] * feesExchange[addr][epochs[index]]) /\n                epochTotalFee[epochs[index]];\n            feesExchange[addr][epochs[index]] = 0;\n        }\n        rewardToken.transfer(addr, reward);\n    }\n\n    /// @dev allows VeNFT holders to claim there token and eth rewards\n    ///      all tokenids must have a common owner\n    /// @param tokenids the nft ids to claim rewards for all ids in the list must belong to 1 address\n    /// @param epochs the list of epochs to claim rewards\n    function multiStakerClaim(uint256[] memory tokenids, uint256[] memory epochs) public {\n        require(address(ve) != address(0), ' VE not added yet');\n\n        uint256 reward = 0;\n        uint256 rewardEth = 0;\n        address tokenowner = ve.ownerOf(tokenids[0]);\n\n        // for each tokenid\n        for (uint256 tindex = 0; tindex < tokenids.length; tindex++) {\n            require(tokenowner == ve.ownerOf(tokenids[tindex]), 'Can only claim for a single Address together');\n            // for each epoch\n            for (uint256 index = 0; index < epochs.length; index++) {\n                require(epochs[index] < epoch, 'cant claim for future epochs');\n                require(claimed[tokenids[tindex]][epochs[index]] == 0, 'cant claim if already claimed');\n                claimed[tokenids[tindex]][epochs[index]] = 1;\n                if (epochs[index] == 0){\n                    rewardEth =\n                        rewardEth +\n                        (epochTotalFee[0] *\n                            ve.balanceOfAtNFT(tokenids[tindex], epochBeginTime[1])) /\n                        ve.totalSupplyAt(epochBeginTime[1]);\n\n                }else{\n                    reward =\n                        reward +\n                        (rewardStaker[epochs[index]] * ve.balanceOfAtNFT(tokenids[tindex], epochBeginTime[epochs[index]])) /\n                        ve.totalSupplyAt(epochBeginTime[epochs[index]]);\n                    rewardEth =\n                        rewardEth +\n                        (epochTotalFee[epochs[index]] *\n                            ve.balanceOfAtNFT(tokenids[tindex], epochBeginTime[epochs[index]])) /\n                        ve.totalSupplyAt(epochBeginTime[epochs[index]]);\n                }\n\n            }\n        }\n        rewardToken.transfer(tokenowner, reward);\n        weth.transfer(tokenowner, rewardEth);\n    }\n\n\n    /// @dev returns unclaimed rewards of an NFT, returns (unclaimed golom rewards, unclaimed eth rewards, unclaimed epochs)\n    /// @param tokenid the nft id to claim rewards for all ids in the list must belong to 1 address\n    function stakerRewards(uint256 tokenid) public view returns (\n            uint256,\n            uint256,\n            uint256[] memory\n        ){\n        require(address(ve) != address(0), ' VE not added yet');\n\n        uint256 reward = 0;\n        uint256 rewardEth = 0;\n        uint256[] memory unclaimedepochs = new uint256[](epoch);\n        // for each epoch\n        for (uint256 index = 0; index < epoch; index++) {\n            unclaimedepochs[index]=claimed[tokenid][index];\n            if (claimed[tokenid][index] == 0){\n                if (index == 0){\n                    rewardEth =\n                        rewardEth +\n                        (epochTotalFee[0] *\n                            ve.balanceOfAtNFT(tokenid, epochBeginTime[1])) /\n                        ve.totalSupplyAt(epochBeginTime[1]);\n\n                }else{\n                    reward =\n                        reward +\n                        (rewardStaker[index] * ve.balanceOfAtNFT(tokenid, epochBeginTime[index])) /\n                        ve.totalSupplyAt(epochBeginTime[index]);\n                    rewardEth =\n                        rewardEth +\n                        (epochTotalFee[index] *\n                            ve.balanceOfAtNFT(tokenid, epochBeginTime[index])) /\n                        ve.totalSupplyAt(epochBeginTime[index]);\n                }\n            }\n        }\n        return (reward, rewardEth, unclaimedepochs);\n    }\n\n    /// @dev returns unclaimed rewards of an NFT, returns (unclaimed golom rewards, unclaimed eth rewards, unclaimed epochs)\n    /// @param addr the nft id to claim rewards for all ids in the list must belong to 1 address\n    function traderRewards(address addr) public view returns (\n            uint256        \n            ){\n        uint256 reward = 0;\n        for (uint256 index = 0; index < epoch; index++) {\n            reward =\n                reward +\n                (rewardTrader[index] * feesTrader[addr][index]) /\n                epochTotalFee[index];\n        }\n        return (reward);\n    }\n\n    /// @dev returns unclaimed golom rewards of a trader\n    /// @param addr the nft id to claim rewards for all ids in the list must belong to 1 address\n    function exchangeRewards(address addr) public view returns (\n            uint256\n        ){\n        uint256 reward = 0;\n        for (uint256 index = 0; index < epoch; index++) {\n            reward =\n                reward +\n                (rewardExchange[index] * feesExchange[addr][index]) /\n                epochTotalFee[index];\n        }\n        return (reward);\n    }\n\n    /// @notice Changes the trader address with timelock\n    /// @dev executeChangeTrader needs to be called after 1 days\n    /// @param _trader New trader address\n    function changeTrader(address _trader) external onlyOwner {\n        traderEnableDate = block.timestamp + 1 days;\n        pendingTrader = _trader;\n    }\n\n    /// @notice Execute's the change trader function\n    function executeChangeTrader() external onlyOwner {\n        require(traderEnableDate <= block.timestamp, 'RewardDistributor: time not over yet');\n        trader = pendingTrader;\n    }\n\n    /// @notice Adds vote escrow contract for multi staker claim\n    /// @param _voteEscrow Address of the voteEscrow contract\n    function addVoteEscrow(address _voteEscrow) external onlyOwner {\n        if (address(ve) == address(0)) {\n            ve = VE(pendingVoteEscrow);\n        } else {\n            voteEscrowEnableDate = block.timestamp + 1 days;\n            pendingVoteEscrow = _voteEscrow;\n        }\n    }\n\n    /// @notice Adds vote escrow contract for multi staker claim\n    function executeAddVoteEscrow() external onlyOwner {\n        require(voteEscrowEnableDate <= block.timestamp, 'RewardDistributor: time not over yet');\n        ve = VE(pendingVoteEscrow);\n    }\n\n    fallback() external payable {}\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/vote-escrow/VoteEscrowDelegation.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\n/// votescrow extended with delegation\n\n// import {Math} from '@openzeppelin-contracts/utils/math/SafeCast.sol';\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\n\nimport {VoteEscrowCore} from './VoteEscrowCore.sol';\n\ninterface IVoteEscrow {\n    function balanceOf(uint256) external view returns (uint256);\n\n    function balanceOfAtNFT(uint256, uint256) external view returns (uint256);\n\n    function ownerOf(uint256) external view returns (address);\n}\n\ncontract VoteEscrow is VoteEscrowCore, Ownable {\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(uint256 indexed tokenId, uint256 indexed toTokenId, address indexed currentOwner);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of votes.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /// @notice Delegate of the specific token\n    mapping(uint256 => uint256) public delegates;\n\n    /// @notice Total delegated tokens to specific token\n    mapping(uint256 => uint256[]) public delegatedTokenIds;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint256 fromBlock;\n        uint256[] delegatedTokenIds;\n    }\n\n    /// @notice A record of votes checkpoints for each tokenId, by index\n    mapping(uint256 => mapping(uint256 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each delegated tokenId\n    mapping(uint256 => uint256) public numCheckpoints;\n\n    /// @notice minimum voting power required for delegation\n    uint256 public MIN_VOTING_POWER_REQUIRED = 0;\n\n    constructor(address _token) {\n        token = _token;\n        voter = msg.sender;\n        point_history[0].blk = block.number;\n        point_history[0].ts = block.timestamp;\n\n        supportedInterfaces[ERC165_INTERFACE_ID] = true;\n        supportedInterfaces[ERC721_INTERFACE_ID] = true;\n        supportedInterfaces[ERC721_METADATA_INTERFACE_ID] = true;\n\n        // mint-ish\n        emit Transfer(address(0), address(this), tokenId);\n        // burn-ish\n        emit Transfer(address(this), address(0), tokenId);\n    }\n\n    /// @notice Explain to an end user what this does\n    /// @param tokenId token ID which is being delegated\n    /// @param toTokenId token ID to which the {tokenId} is being delegated\n    function delegate(uint256 tokenId, uint256 toTokenId) external {\n        require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');\n        require(this.balanceOfNFT(tokenId) >= MIN_VOTING_POWER_REQUIRED, 'VEDelegation: Need more voting power');\n\n        delegates[tokenId] = toTokenId;\n        uint256 nCheckpoints = numCheckpoints[toTokenId];\n\n        if (nCheckpoints > 0) {\n            Checkpoint storage checkpoint = checkpoints[toTokenId][nCheckpoints - 1];\n            checkpoint.delegatedTokenIds.push(tokenId);\n            _writeCheckpoint(toTokenId, nCheckpoints, checkpoint.delegatedTokenIds);\n        } else {\n            uint256[] memory array = new uint256[](1);\n            array[0] = tokenId;\n            _writeCheckpoint(toTokenId, nCheckpoints, array);\n        }\n\n        emit DelegateChanged(tokenId, toTokenId, msg.sender);\n    }\n\n    /**\n     * @notice Writes the checkpoint to store current NFTs in the specific block\n     */\n    function _writeCheckpoint(\n        uint256 toTokenId,\n        uint256 nCheckpoints,\n        uint256[] memory _delegatedTokenIds\n    ) internal {\n        require(_delegatedTokenIds.length < 500, 'VVDelegation: Cannot stake more');\n\n        Checkpoint memory oldCheckpoint = checkpoints[toTokenId][nCheckpoints - 1];\n\n        if (nCheckpoints > 0 && oldCheckpoint.fromBlock == block.number) {\n            oldCheckpoint.delegatedTokenIds = _delegatedTokenIds;\n        } else {\n            checkpoints[toTokenId][nCheckpoints] = Checkpoint(block.number, _delegatedTokenIds);\n            numCheckpoints[toTokenId] = nCheckpoints + 1;\n        }\n    }\n\n    /**\n     * @notice Gets the current delegated nfts array for `nftid`\n     * @param tokenId The address to get votes balance\n     * @return The current delegated nfts array for `account`\n     */\n    function _getCurrentDelegated(uint256 tokenId) internal view returns (uint256[] memory) {\n        uint256 nCheckpoints = numCheckpoints[tokenId];\n        uint256[] memory myArray;\n        return nCheckpoints > 0 ? checkpoints[tokenId][nCheckpoints - 1].delegatedTokenIds : myArray;\n    }\n\n    /**\n     * @notice Determine the prior delegated nfts array for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param nftId The id of the nft to check\n     * @param blockNumber The block number to get the delegate nft array at\n     * @return The number of delegated nfts the account had as of the given block\n     */\n    function _getPriorDelegated(uint256 nftId, uint256 blockNumber) internal view returns (uint256[] memory) {\n        require(blockNumber < block.number, 'VEDelegation: not yet determined');\n        uint256[] memory myArray;\n        uint256 nCheckpoints = numCheckpoints[nftId];\n        if (nCheckpoints == 0) {\n            return myArray;\n        }\n\n        // First check most recent balance\n        if (checkpoints[nftId][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[nftId][nCheckpoints - 1].delegatedTokenIds;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[nftId][0].fromBlock > blockNumber) {\n            return myArray;\n        }\n\n        uint256 lower = 0;\n        uint256 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[nftId][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.delegatedTokenIds;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[nftId][lower].delegatedTokenIds;\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param tokenId The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getVotes(uint256 tokenId) external view returns (uint256) {\n        uint256[] memory delegated = _getCurrentDelegated(tokenId);\n        uint256 votes = 0;\n        for (uint256 index = 0; index < delegated.length; index++) {\n            votes = votes + this.balanceOfNFT(delegated[index]);\n        }\n        return votes;\n    }\n\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param tokenId The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(uint256 tokenId, uint256 blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, 'VEDelegation: not yet determined');\n        uint256[] memory delegatednft = _getPriorDelegated(tokenId, blockNumber);\n        uint256 votes = 0;\n        for (uint256 index = 0; index < delegatednft.length; index++) {\n            votes = votes + this.balanceOfAtNFT(delegatednft[index], blockNumber);\n        }\n        return votes;\n    }\n\n    /// @notice Removes specific element from the array\n    /// @param _array Whole array\n    /// @param _element The element which we need to remove\n    function removeElement(uint256[] storage _array, uint256 _element) internal {\n        for (uint256 i; i < _array.length; i++) {\n            if (_array[i] == _element) {\n                _array[i] = _array[_array.length - 1];\n                _array.pop();\n                break;\n            }\n        }\n    }\n\n    /// @notice Remove delegation\n    /// @param tokenId TokenId of which delegation needs to be removed\n    function removeDelegation(uint256 tokenId) external {\n        require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');\n        uint256 nCheckpoints = numCheckpoints[tokenId];\n        Checkpoint storage checkpoint = checkpoints[tokenId][nCheckpoints - 1];\n        removeElement(checkpoint.delegatedTokenIds, tokenId);\n        _writeCheckpoint(tokenId, nCheckpoints, checkpoint.delegatedTokenIds);\n    }\n\n    // /// @notice Remove delegation by user\n    // function removeDelegationByOwner(uint256 delegatedTokenId, uint256 ownerTokenId) external {\n    //     require(ownerOf(ownerTokenId) == msg.sender, 'VEDelegation: Not allowed');\n    //     uint256 nCheckpoints = numCheckpoints[delegatedTokenId];\n    //     Checkpoint storage checkpoint = checkpoints[delegatedTokenId][nCheckpoints - 1];\n    //     removeElement(checkpoint.delegatedTokenIds, delegatedTokenId);\n    //     _writeCheckpoint(ownerTokenId, nCheckpoints, checkpoint.delegatedTokenIds);\n    // }\n\n    /// @dev Exeute transfer of a NFT.\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n    ///      address for this NFT. (NOTE: `msg.sender` not allowed in internal function so pass `_sender`.)\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    function _transferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        address _sender\n    ) internal override {\n        require(attachments[_tokenId] == 0 && !voted[_tokenId], 'attached');\n\n        // remove the delegation\n        this.removeDelegation(_tokenId);\n\n        // Check requirements\n        require(_isApprovedOrOwner(_sender, _tokenId));\n        // Clear approval. Throws if `_from` is not the current owner\n        _clearApproval(_from, _tokenId);\n        // Remove NFT. Throws if `_tokenId` is not a valid NFT\n        _removeTokenFrom(_from, _tokenId);\n        // Add NFT\n        _addTokenTo(_to, _tokenId);\n        // Set the block of ownership transfer (for Flash NFT protection)\n        ownership_change[_tokenId] = block.number;\n        // Log the transfer\n        emit Transfer(_from, _to, _tokenId);\n    }\n\n    /// @notice Changes minimum voting power required for delegation\n    /// @param _newMinVotingPower New minimum voting power required\n    function changeMinVotingPower(uint256 _newMinVotingPower) external onlyOwner {\n        MIN_VOTING_POWER_REQUIRED = _newMinVotingPower;\n    }\n}"
    },
    {
      "filename": "contracts/vote-escrow/VoteEscrowCore.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport './TokenUriHelper.sol';\n\n/**\n@title Voting Escrow\n@author Curve Finance\n@license MIT\n@notice Votes have a weight depending on time, so that users are\ncommitted to the future of (whatever they are voting for)\n@dev Vote weight decays linearly over time. Lock time cannot be\nmore than `MAXTIME` (4 years).\n\n# Voting escrow to have time-weighted votes\n# Votes have a weight depending on time, so that users are committed\n# to the future of (whatever they are voting for).\n# The weight in this implementation is linear, and lock cannot be more than maxtime:\n# w ^\n# 1 +        /\n#   |      /\n#   |    /\n#   |  /\n#   |/\n# 0 +--------+------> time\n#       maxtime (4 years?)\n*/\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *"
    }
  ]
}