{
  "Title": "[M-06] `TemporalGovernor` can be bricked by `guardian`",
  "Content": "\n<https://github.com/code-423n4/2023-07-moonwell/blob/main/src/core/Governance/TemporalGovernor.sol#L27> \n\n<https://github.com/code-423n4/2023-07-moonwell/blob/main/src/core/Governance/TemporalGovernor.sol#L188-L198> \n\n<https://github.com/code-423n4/2023-07-moonwell/blob/main/src/core/Governance/TemporalGovernor.sol#L256>\n\nWhen a `guardian` pauses `TemporalGovernor` they [lose the ability to pause again](https://github.com/code-423n4/2023-07-moonwell/blob/main/src/core/Governance/TemporalGovernor.sol#L283). This can then be reinstated by governance using [`grantGuardiansPause`](https://github.com/code-423n4/2023-07-moonwell/blob/main/src/core/Governance/TemporalGovernor.sol#L188-L198).\n\nHowever `grantGuardiansPause` can be called when the contract is still paused. This would break the assertions in [`permissionlessUnpause`](\\(https://github.com/code-423n4/2023-07-moonwell/blob/main/src/core/Governance/TemporalGovernor.sol#L256\\)) and [`togglePause`](https://github.com/code-423n4/2023-07-moonwell/blob/main/src/core/Governance/TemporalGovernor.sol#L289): `assert(!guardianPauseAllowed)`.\n\nAlso, `TemporalGovernor` [inherits from OpenZeppelin `Ownable`](https://github.com/code-423n4/2023-07-moonwell/blob/main/src/core/Governance/TemporalGovernor.sol#L27). There the `owner` has the ability to [`renounceOwnership`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol#L73-L75).\n\nThis could cause `TemporalGovernor` to end up in a bad state, since [`revokeGuardian`](https://github.com/code-423n4/2023-07-moonwell/blob/main/src/core/Governance/TemporalGovernor.sol#L205-L221) call that has special logic for revoking the guardian.\n\nThere is the ability to combine these two issues to brick the contract:\n\n1.  `guardian` pauses the contract.\n2.  governance sends an instruction for `grantGuardiansPause` which the `guardian` executes (while still paused). This step disables both `permissionlessUnpause` and `togglePause`. Though the contract is still rescuable through `revokeGuardian`.\n3.  `guardian` calls `renounceOwnership` from `Ownable`. Which disables any possibility to execute commands on `TemporalGovernor`. Hence no more ability to call `revokeGuardian`.\n\n### Impact\n\nThe contract is bricked. Since `permissionlessUnpause` can't be called due to the `assert(!guardianPauseAllowed)`. No cross chain calls an be processed because `executeProposal` is `whenNotPaused` and there is no `guardian` to execute `fastTrackProposalExecution`. Thus the `TemporalGovernor` will be stuck in paused state.\n\nIt is also possible for the `guardian` to hold the contract hostage before step 3 (`renounceOwnership`) as they are the only ones who can execute calls on it (through `fastTrackProposalExecution`).\n\nThis is scenario relies on governance sending a cross chain `grantGuardiansPause` while the contract is still paused and a malicious `guardian` which together are unlikely. Though the [docs](https://github.com/code-423n4/2023-07-moonwell#overview) mention this as a concern:\n\n> Specific areas of concern include:\n> ...\n>\n> *   TemporalGovernor which is the cross chain governance contract. Specific areas of concern include delays, the pause guardian, and putting the contract into a state where it cannot be updated.\n\n### Proof of Concept\n\nTest in `TemporalGovernorExec.t.sol`:\n\n```solidity\n    function testBrickTemporalGovernor() public {\n        // 1. guardian pauses contract\n        governor.togglePause();\n        assertTrue(governor.paused());\n        assertFalse(governor.guardianPauseAllowed());\n\n        // 2. grantGuardianPause is called\n        address[] memory targets = new address[](1);\n        targets[0] = address(governor);\n        uint256[] memory values = new uint256[](1);\n        \n        bytes[] memory payloads = new bytes[](1);\n        payloads[0] = abi.encodeWithSelector(TemporalGovernor.grantGuardiansPause.selector);\n\n        bytes memory payload = abi.encode(address(governor), targets, values, payloads);\n        mockCore.setStorage(true, trustedChainid, governor.addressToBytes(admin), \"reeeeeee\", payload);\n\n        governor.fastTrackProposalExecution(\"\");\n        assertTrue(governor.guardianPauseAllowed());\n\n        // 3. guardian revokesOwnership\n        governor.renounceOwnership();\n\n        // TemporalGovernor is bricked\n\n        // contract is paused so no proposals can be sent\n        vm.expectRevert(\"Pausable: paused\");\n        governor.executeProposal(\"\");\n\n        // guardian renounced so no fast track execution or togglePause\n        assertEq(address(0),governor.owner());\n\n        // permissionlessUnpause impossible because of assert\n        vm.warp(block.timestamp + permissionlessUnpauseTime + 1);\n        vm.expectRevert();\n        governor.permissionlessUnpause();\n    }\n```\n\n### Recommended Mitigation Steps\n\nHowever unlikely this is to happen, there are some simple steps that can be taken to prevent if from being possible:\n\nConsider adding `whenNotPaused` to `grantGuardiansPause` to prevent mistakes (or possible abuse). And also overriding the calls `renounceOwnership` and `transferOwnership`. `transferOwnership` should be a governance call (`msg.sender == address(this)`) to move the `guardian` to a new trusted account.\n\nPerhaps also consider if the `assert(!guardianPauseAllowed)` is worth just for pleasing the SMT solver.\n\n**[ElliotFriedman (Moonwell) confirmed](https://github.com/code-423n4/2023-07-moonwell-findings/issues/314#issuecomment-1659400867)**\n \n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-07-moonwell",
  "Code": [
    {
      "filename": "src/core/Governance/TemporalGovernor.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {IWormhole} from \"@protocol/core/Governance/IWormhole.sol\";\n\nimport {ITemporalGovernor} from \"@protocol/core/Governance/ITemporalGovernor.sol\";\n\n/// @notice contract that governs the Base deployment of moonwell leveraging the wormhole bridge\n/// as the source of truth. Wormhole will be fed in actions from the moonbeam chain and this contract\n/// will execute them on base.\n/// There are a few assumptions that are made in this contract:\n/// 1. Wormhole is secure and will not send malicious messages or be deactivated.\n/// 2. Moonbeam is secure.\n/// 3. Governance on Moonbeam cannot be compromised.\n/// if 1. is untrue and wormhole is deactivated, then this contract will be unable to upgrade the base instance\n/// if 1. is untrue and wormhole sends malicious messages, then this contract will be paused, and the guardian\n/// will have to fast track a proposal to hand ownership to a new governor, and wormhole will have to revoke\n/// the permissions on the compromised validator set.\n/// if 2. is untrue, then this contract will be paused until moonbeam is restored\n/// if 3. is untrue, then this contract will be paused until moonbeam governance is restored, if gov control\n/// cannot be restored, then this governance will be compromised.\ncontract TemporalGovernor is ITemporalGovernor, Ownable, Pausable {\n    using SafeCast for *;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    /// ----------- IMMUTABLES -----------\n\n    /// @notice reference to the wormhole bridge\n    IWormhole public immutable wormholeBridge;\n\n    /// @notice returns the amount of time a proposal must wait before being processed.\n    uint256 public immutable proposalDelay;\n\n    /// @notice returns the amount of time until this contract can be unpaused permissionlessly\n    uint256 public immutable permissionlessUnpauseTime;\n\n    /// ----------- SINGLE STORAGE SLOT -----------\n\n    /// @notice last paused time\n    uint248 public lastPauseTime;\n\n    /// @notice returns whether or not the guardian can pause.\n    /// starts true and then is turned false when the guardian pauses\n    /// governance can then reactivate it.\n    bool public guardianPauseAllowed = true;\n\n    /// ----------- MAPPINGS -----------\n\n    /// @notice Map of chain id => trusted sender\n    mapping(uint16 => EnumerableSet.Bytes32Set) private trustedSenders;\n\n    /// @notice Record of processed messages to prevent replaying\n    /// and enforce time limits are respected\n    mapping(bytes32 => ProposalInfo) public queuedTransactions;\n\n    constructor(\n        address wormholeCore,\n        uint256 _proposalDelay,\n        uint256 _permissionlessUnpauseTime,\n        TrustedSender[] memory _trustedSenders\n    ) Ownable() {\n        wormholeBridge = IWormhole(wormholeCore);\n        proposalDelay = _proposalDelay;\n        permissionlessUnpauseTime = _permissionlessUnpauseTime;\n\n        // Using https://book.wormhole.com/reference/contracts.html#testnet chain ids and local contracts\n        // Mark 0xf16165f1046f1b3cdb37da25e835b986e696313a as trusted to emit from eth mainnet\n        // Establish a list of trusted emitters from eash chain\n        for (uint256 i = 0; i < _trustedSenders.length; i++) {\n            trustedSenders[_trustedSenders[i].chainId].add(\n                addressToBytes(_trustedSenders[i].addr)\n            );\n        }\n    }\n\n    /// ------------- VIEW ONLY API -------------\n\n    /// @notice returns whether or not the address is in the trusted senders list for a given chain\n    /// @param chainId The wormhole chain id to check\n    /// @param addr The address to check\n    function isTrustedSender(\n        uint16 chainId,\n        bytes32 addr\n    ) public view returns (bool) {\n        return trustedSenders[chainId].contains(addr);\n    }\n\n    /// @notice returns whether or not the address is in the trusted senders list for a given chain\n    /// @param chainId The wormhole chain id to check\n    /// @param addr The address to check\n    function isTrustedSender(\n        uint16 chainId,\n        address addr\n    ) external view returns (bool) {\n        return isTrustedSender(chainId, addressToBytes(addr));\n    }\n\n    /// @notice returns the list of trusted senders for a given chain\n    /// @param chainId The wormhole chain id to check\n    /// @return The list of trusted senders\n    function allTrustedSenders(uint16 chainId)\n        external\n        view\n        override\n        returns (bytes32[] memory)\n    {\n        bytes32[] memory trustedSendersList = new bytes32[](\n            trustedSenders[chainId].length()\n        );\n\n        unchecked {\n            for (uint256 i = 0; i < trustedSendersList.length; i++) {\n                trustedSendersList[i] = trustedSenders[chainId].at(i);\n            }\n        }\n\n        return trustedSendersList;\n    }\n\n    /// @notice Wormhole addresses are denominated in 32 byte chunks. Converting the address to a bytes20\n    /// then to a bytes32 *left* aligns it, so we right shift to get the proper data\n    /// @param addr The address to convert\n    /// @return The address as a bytes32\n    function addressToBytes(address addr) public pure returns (bytes32) {\n        return bytes32(bytes20(addr)) >> 96;\n    }\n\n    /// @notice only callable through a governance proposal\n    /// @dev Updates the list of trusted senders\n    /// @param _trustedSenders The list of trusted senders, allowing one\n    /// trusted sender per chain id\n    function setTrustedSenders(\n        TrustedSender[] calldata _trustedSenders\n    ) external {\n        require(\n            msg.sender == address(this),\n            \"TemporalGovernor: Only this contract can update trusted senders\"\n        );\n\n        unchecked {\n            for (uint256 i = 0; i < _trustedSenders.length; i++) {\n                trustedSenders[_trustedSenders[i].chainId].add(\n                    addressToBytes(_trustedSenders[i].addr)\n                );\n\n                emit TrustedSenderUpdated(\n                    _trustedSenders[i].chainId,\n                    _trustedSenders[i].addr,\n                    true /// added to list\n                );\n            }\n        }\n    }\n\n    /// @notice only callable through a governance proposal\n    /// @dev Removes trusted senders from the list\n    /// @param _trustedSenders The list of trusted senders, allowing multiple\n    /// trusted sender per chain id\n    function unSetTrustedSenders(\n        TrustedSender[] calldata _trustedSenders\n    ) external {\n        require(\n            msg.sender == address(this),\n            \"TemporalGovernor: Only this contract can update trusted senders\"\n        );\n\n        unchecked {\n            for (uint256 i = 0; i < _trustedSenders.length; i++) {\n                trustedSenders[_trustedSenders[i].chainId].remove(\n                    addressToBytes(_trustedSenders[i].addr)\n                );\n\n                emit TrustedSenderUpdated(\n                    _trustedSenders[i].chainId,\n                    _trustedSenders[i].addr,\n                    false /// removed from list\n                );\n            }\n        }\n    }\n\n    /// @notice grant the guardians the pause ability\n    function grantGuardiansPause() external {\n        require(\n            msg.sender == address(this),\n            \"TemporalGovernor: Only this contract can update grant guardian pause\"\n        );\n\n        guardianPauseAllowed = true;\n        lastPauseTime = 0;\n\n        emit GuardianPauseGranted(block.timestamp);\n    }\n\n    /// ------------- GUARDIAN / GOVERNOR ONLY API -------------\n\n    /// @notice callable only via a gov proposal (governance) or by the guardian\n    /// this revokes guardian's ability, no more pausing or fast tracking and\n    /// unpauses the contract if paused\n    function revokeGuardian() external {\n        address oldGuardian = owner();\n        require(\n            msg.sender == oldGuardian || msg.sender == address(this),\n            \"TemporalGovernor: cannot revoke guardian\"\n        );\n\n        _transferOwnership(address(0));\n        guardianPauseAllowed = false;\n        lastPauseTime = 0;\n\n        if (paused()) {\n            _unpause();\n        }\n\n        emit GuardianRevoked(oldGuardian);\n    }\n\n    /// ------------- PERMISSIONLESS APIs -------------\n\n    /// @notice We explicitly don't care who is relaying this, as long\n    /// as the VAA is only processed once AND, critically, intended for this contract.\n    /// @param VAA The signed Verified Action Approval to process\n    /// @dev callable only when unpaused\n    function queueProposal(bytes memory VAA) external whenNotPaused {\n        _queueProposal(VAA);\n    }\n\n    /// @notice Taken mostly from the best practices docs from wormhole.\n    /// We explicitly don't care who is relaying this, as long\n    /// as the VAA is only processed once AND, critically, intended for this contract.\n    /// @param VAA The signed Verified Action Approval to process\n    function executeProposal(bytes memory VAA) public whenNotPaused {\n        _executeProposal(VAA, false);\n    }\n\n    /// @notice unpauses the contract, and blocks the guardian from pausing again until governance reapproves them\n    function permissionlessUnpause() external whenPaused {\n        /// lastPauseTime cannot be equal to 0 at this point because\n        /// block.timstamp on a real chain will always be gt 0 and\n        /// toggle pause will set lastPauseTime to block.timestamp\n        /// which means if the contract is paused on a live network,\n        /// its lastPauseTime cannot be 0\n        require(\n            lastPauseTime + permissionlessUnpauseTime <= block.timestamp,\n            \"TemporalGovernor: not past pause window\"\n        );\n\n        lastPauseTime = 0;\n        _unpause();\n\n        assert(!guardianPauseAllowed); /// this should never revert, statement for SMT solving\n\n        emit PermissionlessUnpaused(block.timestamp);\n    }\n\n    /// @notice Allow the guardian to process a VAA when the\n    /// Temporal Governor is paused this is only for use during\n    /// periods of emergency when the governance on moonbeam is\n    /// compromised and we need to stop additional proposals from going through.\n    /// @param VAA The signed Verified Action Approval to process\n    function fastTrackProposalExecution(bytes memory VAA) external onlyOwner {\n        _executeProposal(VAA, true); /// override timestamp checks and execute\n    }\n\n    /// @notice Allow the guardian to pause the contract\n    /// removes the guardians ability to call pause again until governance reaaproves them\n    /// starts the timer for the permissionless unpause\n    /// cannot call this function if guardian is revoked\n    function togglePause() external onlyOwner {\n        if (paused()) {\n            _unpause();\n        } else {\n            require(\n                guardianPauseAllowed,\n                \"TemporalGovernor: guardian pause not allowed\"\n            );\n\n            guardianPauseAllowed = false;\n            lastPauseTime = block.timestamp.toUint248();\n            _pause();\n        }\n\n        /// statement for SMT solver\n        assert(!guardianPauseAllowed); /// this should be an unreachable state\n    }\n\n    /// ------------- HELPER FUNCTIONS -------------\n\n    /// queue a proposal\n    function _queueProposal(bytes memory VAA) private {\n        /// Checks\n\n        // This call accepts single VAAs and headless VAAs\n        (\n            IWormhole.VM memory vm,\n            bool valid,\n            string memory reason\n        ) = wormholeBridge.parseAndVerifyVM(VAA);\n\n        // Ensure VAA parsing verification succeeded.\n        require(valid, reason);\n\n        address intendedRecipient;\n        address[] memory targets; /// contracts to call\n        uint256[] memory values; /// native token amount to send\n        bytes[] memory calldatas; /// calldata to send\n\n        (intendedRecipient, targets, values, calldatas) = abi.decode(\n            vm.payload,\n            (address, address[], uint256[], bytes[])\n        );\n\n        _sanityCheckPayload(targets, values, calldatas);\n\n        // Very important to check to make sure that the VAA we're processing is specifically designed\n        // to be sent to this contract\n        require(intendedRecipient == address(this), \"TemporalGovernor: Incorrect destination\");\n\n        // Ensure the emitterAddress of this VAA is a trusted address\n        require(\n            trustedSenders[vm.emitterChainId].contains(vm.emitterAddress), /// allow multiple per chainid\n            \"TemporalGovernor: Invalid Emitter Address\"\n        );\n\n        /// Check that the VAA hasn't already been processed (replay protection)\n        require(\n            queuedTransactions[vm.hash].queueTime == 0,\n            \"TemporalGovernor: Message already queued\"\n        );\n\n        /// Effect\n\n        // Add the VAA to queued messages so that it can't be replayed\n        queuedTransactions[vm.hash].queueTime = block.timestamp.toUint248();\n\n        emit QueuedTransaction(intendedRecipient, targets, values, calldatas);\n    }\n\n    function _executeProposal(bytes memory VAA, bool overrideDelay) private {\n        // This call accepts single VAAs and headless VAAs\n        (\n            IWormhole.VM memory vm,\n            bool valid,\n            string memory reason\n        ) = wormholeBridge.parseAndVerifyVM(VAA);\n\n        require(valid, reason); /// ensure VAA parsing verification succeeded\n\n        if (!overrideDelay) {\n            require(\n                queuedTransactions[vm.hash].queueTime != 0,\n                \"TemporalGovernor: tx not queued\"\n            );\n            require(\n                queuedTransactions[vm.hash].queueTime + proposalDelay <=\n                    block.timestamp,\n                \"TemporalGovernor: timelock not finished\"\n            );\n        } else if (queuedTransactions[vm.hash].queueTime == 0) {\n            /// if queue time is 0 due to fast track execution, set it to current block timestamp\n            queuedTransactions[vm.hash].queueTime = block.timestamp.toUint248();\n        }\n\n        // Ensure the emitterAddress of this VAA is a trusted address\n        require(\n            trustedSenders[vm.emitterChainId].contains(vm.emitterAddress), /// allow multiple per chainid\n            \"TemporalGovernor: Invalid Emitter Address\"\n        );\n\n        require(\n            !queuedTransactions[vm.hash].executed,\n            \"TemporalGovernor: tx already executed\"\n        );\n\n        queuedTransactions[vm.hash].executed = true;\n\n        address[] memory targets; /// contracts to call\n        uint256[] memory values; /// native token amount to send\n        bytes[] memory calldatas; /// calldata to send\n        (, targets, values, calldatas) = abi.decode(\n            vm.payload,\n            (address, address[], uint256[], bytes[])\n        );\n\n        /// Interaction (s)\n\n        _sanityCheckPayload(targets, values, calldatas);\n\n        for (uint256 i = 0; i < targets.length; i++) {\n            address target = targets[i];\n            uint256 value = values[i];\n            bytes memory data = calldatas[i];\n\n            // Go make our call, and if it is not successful revert with the error bubbling up\n            (bool success, bytes memory returnData) = target.call{value: value}(\n                data\n            );\n\n            /// revert on failure with error message if any\n            require(success, string(returnData));\n\n            emit ExecutedTransaction(target, value, data);\n        }\n    }\n\n    /// @notice arity check for payload\n    function _sanityCheckPayload(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas\n    ) private pure {\n        require(targets.length != 0, \"TemporalGovernor: Empty proposal\");\n        require(\n            targets.length == values.length &&\n                targets.length == calldatas.length,\n            \"TemporalGovernor: Arity mismatch for payload\"\n        );\n    }\n}"
    },
    {
      "filename": "src/core/Governance/TemporalGovernor.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {IWormhole} from \"@protocol/core/Governance/IWormhole.sol\";\n\nimport {ITemporalGovernor} from \"@protocol/core/Governance/ITemporalGovernor.sol\";\n\n/// @notice contract that governs the Base deployment of moonwell leveraging the wormhole bridge\n/// as the source of truth. Wormhole will be fed in actions from the moonbeam chain and this contract\n/// will execute them on base.\n/// There are a few assumptions that are made in this contract:\n/// 1. Wormhole is secure and will not send malicious messages or be deactivated.\n/// 2. Moonbeam is secure.\n/// 3. Governance on Moonbeam cannot be compromised.\n/// if 1. is untrue and wormhole is deactivated, then this contract will be unable to upgrade the base instance\n/// if 1. is untrue and wormhole sends malicious messages, then this contract will be paused, and the guardian\n/// will have to fast track a proposal to hand ownership to a new governor, and wormhole will have to revoke\n/// the permissions on the compromised validator set.\n/// if 2. is untrue, then this contract will be paused until moonbeam is restored\n/// if 3. is untrue, then this contract will be paused until moonbeam governance is restored, if gov control\n/// cannot be restored, then this governance will be compromised.\ncontract TemporalGovernor is ITemporalGovernor, Ownable, Pausable {\n    using SafeCast for *;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    /// ----------- IMMUTABLES -----------\n\n    /// @notice reference to the wormhole bridge\n    IWormhole public immutable wormholeBridge;\n\n    /// @notice returns the amount of time a proposal must wait before being processed.\n    uint256 public immutable proposalDelay;\n\n    /// @notice returns the amount of time until this contract can be unpaused permissionlessly\n    uint256 public immutable permissionlessUnpauseTime;\n\n    /// ----------- SINGLE STORAGE SLOT -----------\n\n    /// @notice last paused time\n    uint248 public lastPauseTime;\n\n    /// @notice returns whether or not the guardian can pause.\n    /// starts true and then is turned false when the guardian pauses\n    /// governance can then reactivate it.\n    bool public guardianPauseAllowed = true;\n\n    /// ----------- MAPPINGS -----------\n\n    /// @notice Map of chain id => trusted sender\n    mapping(uint16 => EnumerableSet.Bytes32Set) private trustedSenders;\n\n    /// @notice Record of processed messages to prevent replaying\n    /// and enforce time limits are respected\n    mapping(bytes32 => ProposalInfo) public queuedTransactions;\n\n    constructor(\n        address wormholeCore,\n        uint256 _proposalDelay,\n        uint256 _permissionlessUnpauseTime,\n        TrustedSender[] memory _trustedSenders\n    ) Ownable() {\n        wormholeBridge = IWormhole(wormholeCore);\n        proposalDelay = _proposalDelay;\n        permissionlessUnpauseTime = _permissionlessUnpauseTime;\n\n        // Using https://book.wormhole.com/reference/contracts.html#testnet chain ids and local contracts\n        // Mark 0xf16165f1046f1b3cdb37da25e835b986e696313a as trusted to emit from eth mainnet\n        // Establish a list of trusted emitters from eash chain\n        for (uint256 i = 0; i < _trustedSenders.length; i++) {\n            trustedSenders[_trustedSenders[i].chainId].add(\n                addressToBytes(_trustedSenders[i].addr)\n            );\n        }\n    }\n\n    /// ------------- VIEW ONLY API -------------\n\n    /// @notice returns whether or not the address is in the trusted senders list for a given chain\n    /// @param chainId The wormhole chain id to check\n    /// @param addr The address to check\n    function isTrustedSender(\n        uint16 chainId,\n        bytes32 addr\n    ) public view returns (bool) {\n        return trustedSenders[chainId].contains(addr);\n    }\n\n    /// @notice returns whether or not the address is in the trusted senders list for a given chain\n    /// @param chainId The wormhole chain id to check\n    /// @param addr The address to check\n    function isTrustedSender(\n        uint16 chainId,\n        address addr\n    ) external view returns (bool) {\n        return isTrustedSender(chainId, addressToBytes(addr));\n    }\n\n    /// @notice returns the list of trusted senders for a given chain\n    /// @param chainId The wormhole chain id to check\n    /// @return The list of trusted senders\n    function allTrustedSenders(uint16 chainId)\n        external\n        view\n        override\n        returns (bytes32[] memory)\n    {\n        bytes32[] memory trustedSendersList = new bytes32[](\n            trustedSenders[chainId].length()\n        );\n\n        unchecked {\n            for (uint256 i = 0; i < trustedSendersList.length; i++) {\n                trustedSendersList[i] = trustedSenders[chainId].at(i);\n            }\n        }\n\n        return trustedSendersList;\n    }\n\n    /// @notice Wormhole addresses are denominated in 32 byte chunks. Converting the address to a bytes20\n    /// then to a bytes32 *left* aligns it, so we right shift to get the proper data\n    /// @param addr The address to convert\n    /// @return The address as a bytes32\n    function addressToBytes(address addr) public pure returns (bytes32) {\n        return bytes32(bytes20(addr)) >> 96;\n    }\n\n    /// @notice only callable through a governance proposal\n    /// @dev Updates the list of trusted senders\n    /// @param _trustedSenders The list of trusted senders, allowing one\n    /// trusted sender per chain id\n    function setTrustedSenders(\n        TrustedSender[] calldata _trustedSenders\n    ) external {\n        require(\n            msg.sender == address(this),\n            \"TemporalGovernor: Only this contract can update trusted senders\"\n        );\n\n        unchecked {\n            for (uint256 i = 0; i < _trustedSenders.length; i++) {\n                trustedSenders[_trustedSenders[i].chainId].add(\n                    addressToBytes(_trustedSenders[i].addr)\n                );\n\n                emit TrustedSenderUpdated(\n                    _trustedSenders[i].chainId,\n                    _trustedSenders[i].addr,\n                    true /// added to list\n                );\n            }\n        }\n    }\n\n    /// @notice only callable through a governance proposal\n    /// @dev Removes trusted senders from the list\n    /// @param _trustedSenders The list of trusted senders, allowing multiple\n    /// trusted sender per chain id\n    function unSetTrustedSenders(\n        TrustedSender[] calldata _trustedSenders\n    ) external {\n        require(\n            msg.sender == address(this),\n            \"TemporalGovernor: Only this contract can update trusted senders\"\n        );\n\n        unchecked {\n            for (uint256 i = 0; i < _trustedSenders.length; i++) {\n                trustedSenders[_trustedSenders[i].chainId].remove(\n                    addressToBytes(_trustedSenders[i].addr)\n                );\n\n                emit TrustedSenderUpdated(\n                    _trustedSenders[i].chainId,\n                    _trustedSenders[i].addr,\n                    false /// removed from list\n                );\n            }\n        }\n    }\n\n    /// @notice grant the guardians the pause ability\n    function grantGuardiansPause() external {\n        require(\n            msg.sender == address(this),\n            \"TemporalGovernor: Only this contract can update grant guardian pause\"\n        );\n\n        guardianPauseAllowed = true;\n        lastPauseTime = 0;\n\n        emit GuardianPauseGranted(block.timestamp);\n    }\n\n    /// ------------- GUARDIAN / GOVERNOR ONLY API -------------\n\n    /// @notice callable only via a gov proposal (governance) or by the guardian\n    /// this revokes guardian's ability, no more pausing or fast tracking and\n    /// unpauses the contract if paused\n    function revokeGuardian() external {\n        address oldGuardian = owner();\n        require(\n            msg.sender == oldGuardian || msg.sender == address(this),\n            \"TemporalGovernor: cannot revoke guardian\"\n        );\n\n        _transferOwnership(address(0));\n        guardianPauseAllowed = false;\n        lastPauseTime = 0;\n\n        if (paused()) {\n            _unpause();\n        }\n\n        emit GuardianRevoked(oldGuardian);\n    }\n\n    /// ------------- PERMISSIONLESS APIs -------------\n\n    /// @notice We explicitly don't care who is relaying this, as long\n    /// as the VAA is only processed once AND, critically, intended for this contract.\n    /// @param VAA The signed Verified Action Approval to process\n    /// @dev callable only when unpaused\n    function queueProposal(bytes memory VAA) external whenNotPaused {\n        _queueProposal(VAA);\n    }\n\n    /// @notice Taken mostly from the best practices docs from wormhole.\n    /// We explicitly don't care who is relaying this, as long\n    /// as the VAA is only processed once AND, critically, intended for this contract.\n    /// @param VAA The signed Verified Action Approval to process\n    function executeProposal(bytes memory VAA) public whenNotPaused {\n        _executeProposal(VAA, false);\n    }\n\n    /// @notice unpauses the contract, and blocks the guardian from pausing again until governance reapproves them\n    function permissionlessUnpause() external whenPaused {\n        /// lastPauseTime cannot be equal to 0 at this point because\n        /// block.timstamp on a real chain will always be gt 0 and\n        /// toggle pause will set lastPauseTime to block.timestamp\n        /// which means if the contract is paused on a live network,\n        /// its lastPauseTime cannot be 0\n        require(\n            lastPauseTime + permissionlessUnpauseTime <= block.timestamp,\n            \"TemporalGovernor: not past pause window\"\n        );\n\n        lastPauseTime = 0;\n        _unpause();\n\n        assert(!guardianPauseAllowed); /// this should never revert, statement for SMT solving\n\n        emit PermissionlessUnpaused(block.timestamp);\n    }\n\n    /// @notice Allow the guardian to process a VAA when the\n    /// Temporal Governor is paused this is only for use during\n    /// periods of emergency when the governance on moonbeam is\n    /// compromised and we need to stop additional proposals from going through.\n    /// @param VAA The signed Verified Action Approval to process\n    function fastTrackProposalExecution(bytes memory VAA) external onlyOwner {\n        _executeProposal(VAA, true); /// override timestamp checks and execute\n    }\n\n    /// @notice Allow the guardian to pause the contract\n    /// removes the guardians ability to call pause again until governance reaaproves them\n    /// starts the timer for the permissionless unpause\n    /// cannot call this function if guardian is revoked\n    function togglePause() external onlyOwner {\n        if (paused()) {\n            _unpause();\n        } else {\n            require(\n                guardianPauseAllowed,\n                \"TemporalGovernor: guardian pause not allowed\"\n            );\n\n            guardianPauseAllowed = false;\n            lastPauseTime = block.timestamp.toUint248();\n            _pause();\n        }\n\n        /// statement for SMT solver\n        assert(!guardianPauseAllowed); /// this should be an unreachable state\n    }\n\n    /// ------------- HELPER FUNCTIONS -------------\n\n    /// queue a proposal\n    function _queueProposal(bytes memory VAA) private {\n        /// Checks\n\n        // This call accepts single VAAs and headless VAAs\n        (\n            IWormhole.VM memory vm,\n            bool valid,\n            string memory reason\n        ) = wormholeBridge.parseAndVerifyVM(VAA);\n\n        // Ensure VAA parsing verification succeeded.\n        require(valid, reason);\n\n        address intendedRecipient;\n        address[] memory targets; /// contracts to call\n        uint256[] memory values; /// native token amount to send\n        bytes[] memory calldatas; /// calldata to send\n\n        (intendedRecipient, targets, values, calldatas) = abi.decode(\n            vm.payload,\n            (address, address[], uint256[], bytes[])\n        );\n\n        _sanityCheckPayload(targets, values, calldatas);\n\n        // Very important to check to make sure that the VAA we're processing is specifically designed\n        // to be sent to this contract\n        require(intendedRecipient == address(this), \"TemporalGovernor: Incorrect destination\");\n\n        // Ensure the emitterAddress of this VAA is a trusted address\n        require(\n            trustedSenders[vm.emitterChainId].contains(vm.emitterAddress), /// allow multiple per chainid\n            \"TemporalGovernor: Invalid Emitter Address\"\n        );\n\n        /// Check that the VAA hasn't already been processed (replay protection)\n        require(\n            queuedTransactions[vm.hash].queueTime == 0,\n            \"TemporalGovernor: Message already queued\"\n        );\n\n        /// Effect\n\n        // Add the VAA to queued messages so that it can't be replayed\n        queuedTransactions[vm.hash].queueTime = block.timestamp.toUint248();\n\n        emit QueuedTransaction(intendedRecipient, targets, values, calldatas);\n    }\n\n    function _executeProposal(bytes memory VAA, bool overrideDelay) private {\n        // This call accepts single VAAs and headless VAAs\n        (\n            IWormhole.VM memory vm,\n            bool valid,\n            string memory reason\n        ) = wormholeBridge.parseAndVerifyVM(VAA);\n\n        require(valid, reason); /// ensure VAA parsing verification succeeded\n\n        if (!overrideDelay) {\n            require(\n                queuedTransactions[vm.hash].queueTime != 0,\n                \"TemporalGovernor: tx not queued\"\n            );\n            require(\n                queuedTransactions[vm.hash].queueTime + proposalDelay <=\n                    block.timestamp,\n                \"TemporalGovernor: timelock not finished\"\n            );\n        } else if (queuedTransactions[vm.hash].queueTime == 0) {\n            /// if queue time is 0 due to fast track execution, set it to current block timestamp\n            queuedTransactions[vm.hash].queueTime = block.timestamp.toUint248();\n        }\n\n        // Ensure the emitterAddress of this VAA is a trusted address\n        require(\n            trustedSenders[vm.emitterChainId].contains(vm.emitterAddress), /// allow multiple per chainid\n            \"TemporalGovernor: Invalid Emitter Address\"\n        );\n\n        require(\n            !queuedTransactions[vm.hash].executed,\n            \"TemporalGovernor: tx already executed\"\n        );\n\n        queuedTransactions[vm.hash].executed = true;\n\n        address[] memory targets; /// contracts to call\n        uint256[] memory values; /// native token amount to send\n        bytes[] memory calldatas; /// calldata to send\n        (, targets, values, calldatas) = abi.decode(\n            vm.payload,\n            (address, address[], uint256[], bytes[])\n        );\n\n        /// Interaction (s)\n\n        _sanityCheckPayload(targets, values, calldatas);\n\n        for (uint256 i = 0; i < targets.length; i++) {\n            address target = targets[i];\n            uint256 value = values[i];\n            bytes memory data = calldatas[i];\n\n            // Go make our call, and if it is not successful revert with the error bubbling up\n            (bool success, bytes memory returnData) = target.call{value: value}(\n                data\n            );\n\n            /// revert on failure with error message if any\n            require(success, string(returnData));\n\n            emit ExecutedTransaction(target, value, data);\n        }\n    }\n\n    /// @notice arity check for payload\n    function _sanityCheckPayload(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas\n    ) private pure {\n        require(targets.length != 0, \"TemporalGovernor: Empty proposal\");\n        require(\n            targets.length == values.length &&\n                targets.length == calldatas.length,\n            \"TemporalGovernor: Arity mismatch for payload\"\n        );\n    }\n}"
    },
    {
      "filename": "src/core/Governance/TemporalGovernor.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {SafeCast} from \"@openzeppelin/cont"
    }
  ]
}