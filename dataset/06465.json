{
  "Title": "[M-12] When the `anyExecute` call is made to `RootBridgeAgent` with a `depositNonce` that has been recorded in `executionHistory`, `initialGas` and `userFeeInfo` will not be updated, which would affect the next caller of `retrySettlement`.",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L873-L890> <br><https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L922> <br><https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L246> <br><https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L571>\n\n### Impact\n\nThe wrong `userFeeInfo` will be used when `retrySettlement` is called directly.\n\n### Proof of Concept\n\nHere is `retrySettlement` function:\n\n```solidity\nfunction retrySettlement(\n    uint32 _settlementNonce,\n    uint128 _remoteExecutionGas\n) external payable {\n    //Update User Gas available.\n    if (initialGas == 0) {\n        userFeeInfo.depositedGas = uint128(msg.value);\n        userFeeInfo.gasToBridgeOut = _remoteExecutionGas;\n    }\n    //Clear Settlement with updated gas.\n    _retrySettlement(_settlementNonce);\n}\n```\n\nThe assumption here, is that if `initialGas` is not 0, then `retrySettlement` is being called by `RootBridgeAgent#anyExecute`, which has already set values for `initialGas` and `userFeeInfo` (which would later be deleted at the end of the `anycall` function). But if it is 0, then `retrySettlement` is being called directly by a user, so the user should specify `_remoteExecutionGas` and send some `msg.value` with the call, which would make up the `userFeeInfo`.\n\nBut this assumption is not completely correct because whenever `RootBridgeAgent#anyExecute` is called with a `depositNonce` that has been recorded in `executionHistory`, the function returns early, which prevents other parts of the `anyExecute` function from being executed.\n\nAt the beginning of `anyExecute`, `initialGas` and `userFeeInfo` values are set and at the end of `anyExecute` call, if `initialGas>0`, `_payExecutionGas` sets `initialGas` and `userFeeInfo` to 0. So when the function returns earlier, before `_payExecutionGas` is called, `initialGas` and `userFeeInfo` are not updated.\n\nIf a user calls `retrySettlement` immediately after that, the call will use the wrong `userFeeInfo` (i.e. `userFeeInfo` set when `anyExecute` was called with a `depositNonce` that has already been recorded), because `initialGas!=0`. Whereas, it was meant to use values sent by the caller of `retrySettlement`.\n\nLooking at a part of `_manageGasOut` logic which is called in `_retrySettlement`:\n\n```solidity\n\nif (_initialGas > 0) {\n    if (\n        userFeeInfo.gasToBridgeOut <= MIN_FALLBACK_RESERVE * tx.gasprice\n    ) revert InsufficientGasForFees();\n    (amountOut, gasToken) = _gasSwapOut(\n        userFeeInfo.gasToBridgeOut,\n        _toChain\n    );\n} else {\n    if (msg.value <= MIN_FALLBACK_RESERVE * tx.gasprice)\n        revert InsufficientGasForFees();\n    wrappedNativeToken.deposit{value: msg.value}();\n    (amountOut, gasToken) = _gasSwapOut(msg.value, _toChain);\n}\n```\n\nThis could cause one of these:\n\n- User's `retrySettlement` call would revert if `userFeeInfo.gasToBridgeOut` (which the user does not have control over) is less than `MIN_FALLBACK_RESERVE * tx.gasprice`.\n- User's call passes without them sending any funds, so they make a free `retrySettlement` transaction.\n\n### Recommended Mitigation Steps\n\nConsider implementing one of these:\n\n- Restrict `retrySettlement` to only be called by `AgentExecutor`.\n- Delete `initialGas` and `userFeeInfo` before a return is called if the `nonce` has been executed before:\n\n```solidity\n//Check if tx has already been executed\nif (executionHistory[fromChainId][nonce]) {\n    _forceRevert();\n    delete initialGas;\n    delete userFeeInfo;\n    //Return true to avoid triggering anyFallback in case of `_forceRevert()` failure\n    return (true, \"already executed tx\");\n}\n```\n\n### Assessed type\n\nError\n\n**[0xBugsy (Maia) confirmed and commented](https://github.com/code-423n4/2023-05-maia-findings/issues/676#issuecomment-1632840188):**\n > This would be the best route to amend this in our opinion:\n >> Delete `initialGas` and `userFeeInfo` before a return is called if the `nonce` has been executed before.\n\n**[0xBugsy (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/676#issuecomment-1655938535):**\n > We recognize the audit's findings on Anycall Gas Management. These will not be rectified due to the upcoming migration of this section to LayerZero.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/ulysses-omnichain/RootBridgeAgent.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {WETH9} from \"./interfaces/IWETH9.sol\";\nimport {IUniswapV3Pool} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\n\nimport {AnycallFlags} from \"./lib/AnycallFlags.sol\";\n\nimport {IAnycallProxy} from \"./interfaces/IAnycallProxy.sol\";\nimport {IAnycallConfig} from \"./interfaces/IAnycallConfig.sol\";\nimport {IAnycallExecutor} from \"./interfaces/IAnycallExecutor.sol\";\n\nimport {IApp, IRootBridgeAgent} from \"./interfaces/IRootBridgeAgent.sol\";\nimport {IBranchBridgeAgent} from \"./interfaces/IBranchBridgeAgent.sol\";\nimport {IERC20hTokenRoot} from \"./interfaces/IERC20hTokenRoot.sol\";\nimport {IRootPort as IPort} from \"./interfaces/IRootPort.sol\";\nimport {IRootRouter as IRouter} from \"./interfaces/IRootRouter.sol\";\n\nimport {VirtualAccount} from \"./VirtualAccount.sol\";\nimport {\n    IRootBridgeAgent,\n    DepositParams,\n    DepositMultipleParams,\n    Settlement,\n    SettlementStatus,\n    SettlementParams,\n    SettlementMultipleParams,\n    UserFeeInfo,\n    SwapCallbackData\n} from \"./interfaces/IRootBridgeAgent.sol\";\n\nimport {DeployRootBridgeAgentExecutor, RootBridgeAgentExecutor} from \"./RootBridgeAgentExecutor.sol\";\n\n/// @title Library for Cross Chain Deposit Parameters Validation.\nlibrary CheckParamsLib {\n    /**\n     * @notice Function to check cross-chain deposit parameters and verify deposits made on branch chain are valid.\n     * @param _localPortAddress Address of local Port.\n     * @param _dParams Cross Chain swap parameters.\n     * @param _fromChain Chain ID of the chain where the deposit was made.\n     * @dev Local hToken must be recognized and address must match underlying if exists otherwise only local hToken is checked.\n     *\n     */\n    function checkParams(address _localPortAddress, DepositParams memory _dParams, uint24 _fromChain)\n        internal\n        view\n        returns (bool)\n    {\n        if (\n            (_dParams.amount < _dParams.deposit) //Deposit can't be greater than amount.\n                || (_dParams.amount > 0 && !IPort(_localPortAddress).isLocalToken(_dParams.hToken, _fromChain)) //Check local exists.\n                || (_dParams.deposit > 0 && !IPort(_localPortAddress).isUnderlyingToken(_dParams.token, _fromChain)) //Check underlying exists.\n        ) {\n            return false;\n        }\n        return true;\n    }\n}\n\n/// @title Library for Root Bridge Agent Deployment.\nlibrary DeployRootBridgeAgent {\n    function deploy(\n        WETH9 _wrappedNativeToken,\n        uint24 _localChainId,\n        address _daoAddress,\n        address _localAnyCallAddress,\n        address _localAnyCallExecutorAddress,\n        address _localPortAddress,\n        address _localRouterAddress\n    ) external returns (RootBridgeAgent) {\n        return new RootBridgeAgent(\n            _wrappedNativeToken,\n            _localChainId,\n            _daoAddress,\n            _localAnyCallAddress,\n            _localAnyCallExecutorAddress,\n            _localPortAddress,\n            _localRouterAddress\n        );\n    }\n}\n\n/// @title  Root Bridge Agent Contract\ncontract RootBridgeAgent is IRootBridgeAgent {\n    using SafeTransferLib for address;\n    using SafeCastLib for uint256;\n\n    /*///////////////////////////////////////////////////////////////\n                            ENCODING CONSTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// AnyExec Consts\n\n    uint8 internal constant PARAMS_START = 1;\n\n    uint8 internal constant PARAMS_START_SIGNED = 21;\n\n    uint8 internal constant PARAMS_ADDRESS_SIZE = 20;\n\n    uint8 internal constant PARAMS_GAS_IN = 32;\n\n    uint8 internal constant PARAMS_GAS_OUT = 16;\n\n    /// BridgeIn Consts\n\n    uint8 internal constant PARAMS_TKN_START = 5;\n\n    uint8 internal constant PARAMS_AMT_OFFSET = 64;\n\n    uint8 internal constant PARAMS_DEPOSIT_OFFSET = 96;\n\n    /*///////////////////////////////////////////////////////////////\n                        ROOT BRIDGE AGENT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Local Chain Id\n    uint24 public immutable localChainId;\n\n    /// @notice Local Wrapped Native Token\n    WETH9 public immutable wrappedNativeToken;\n\n    /// @notice Bridge Agent Factory Address.\n    address public immutable factoryAddress;\n\n    /// @notice Address of DAO.\n    address public immutable daoAddress;\n\n    /// @notice Local Core Root Router Address\n    address public immutable localRouterAddress;\n\n    /// @notice Address for Local Port Address where funds deposited from this chain are stored.\n    address public immutable localPortAddress;\n\n    /// @notice Local Anycall Address\n    address public immutable localAnyCallAddress;\n\n    /// @notice Local Anyexec Address\n    address public immutable localAnyCallExecutorAddress;\n\n    /// @notice Address of Root Bridge Agent Executor.\n    address public immutable bridgeAgentExecutorAddress;\n\n    /*///////////////////////////////////////////////////////////////\n                    BRANCH BRIDGE AGENTS STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Chain -> Branch Bridge Agent Address. For N chains, each Root Bridge Agent Address has M =< N Branch Bridge Agent Address.\n    mapping(uint256 => address) public getBranchBridgeAgent;\n\n    /// @notice If true, bridge agent manager has allowed for a new given branch bridge agent to be synced/added.\n    mapping(uint256 => bool) public isBranchBridgeAgentAllowed;\n\n    /*///////////////////////////////////////////////////////////////\n                        SETTLEMENTS STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Deposit nonce used for identifying transaction.\n    uint32 public settlementNonce;\n\n    /// @notice Mapping from Settlement nonce to Deposit Struct.\n    mapping(uint32 => Settlement) public getSettlement;\n\n    /*///////////////////////////////////////////////////////////////\n                            EXECUTOR STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice If true, bridge agent has already served a request with this nonce from  a given chain. Chain -> Nonce -> Bool\n    mapping(uint256 => mapping(uint32 => bool)) public executionHistory;\n\n    /*///////////////////////////////////////////////////////////////\n                        GAS MANAGEMENT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant MIN_FALLBACK_RESERVE = 155_000; // 100_000 for anycall + 55_000 for fallback\n    uint256 internal constant MIN_EXECUTION_OVERHEAD = 155_000; // 100_000 for anycall + 30_000 Pre 1st Gas Checkpoint Execution + 25_000 Post last Gas Checkpoint Execution\n\n    uint256 public initialGas;\n    UserFeeInfo public userFeeInfo;\n\n    /*///////////////////////////////////////////////////////////////\n                        DAO STATE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public accumulatedFees;\n\n    /**\n     * @notice Constructor for Bridge Agent.\n     *     @param _wrappedNativeToken Local Wrapped Native Token.\n     *     @param _daoAddress Address of DAO.\n     *     @param _localChainId Local Chain Id.\n     *     @param _localAnyCallAddress Local Anycall Address.\n     *     @param _localPortAddress Local Port Address.\n     *     @param _localRouterAddress Local Port Address.\n     */\n    constructor(\n        WETH9 _wrappedNativeToken,\n        uint24 _localChainId,\n        address _daoAddress,\n        address _localAnyCallAddress,\n        address _localAnyCallExecutorAddress,\n        address _localPortAddress,\n        address _localRouterAddress\n    ) {\n        require(address(_wrappedNativeToken) != address(0), \"Wrapped native token cannot be zero address\");\n        require(_daoAddress != address(0), \"DAO cannot be zero address\");\n        require(_localAnyCallAddress != address(0), \"Anycall Address cannot be zero address\");\n        require(_localAnyCallExecutorAddress != address(0), \"Anycall Executor Address cannot be zero address\");\n        require(_localPortAddress != address(0), \"Port Address cannot be zero address\");\n        require(_localRouterAddress != address(0), \"Router Address cannot be zero address\");\n\n        wrappedNativeToken = _wrappedNativeToken;\n        factoryAddress = msg.sender;\n        daoAddress = _daoAddress;\n        localChainId = _localChainId;\n        localAnyCallAddress = _localAnyCallAddress;\n        localPortAddress = _localPortAddress;\n        localRouterAddress = _localRouterAddress;\n        bridgeAgentExecutorAddress = DeployRootBridgeAgentExecutor.deploy(address(this));\n        localAnyCallExecutorAddress = _localAnyCallExecutorAddress;\n        settlementNonce = 1;\n        accumulatedFees = 1; //Avoid paying 20k gas in first `payExecutionGas` making MIN_EXECUTION_OVERHEAD constant.\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        VIEW EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootBridgeAgent\n    function getSettlementEntry(uint32 _settlementNonce) external view returns (Settlement memory) {\n        return getSettlement[_settlementNonce];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        USER EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootBridgeAgent\n    function retrySettlement(uint32 _settlementNonce, uint128 _remoteExecutionGas) external payable {\n        //Update User Gas available.\n        if (initialGas == 0) {\n            userFeeInfo.depositedGas = uint128(msg.value);\n            userFeeInfo.gasToBridgeOut = _remoteExecutionGas;\n        }\n        //Clear Settlement with updated gas.\n        _retrySettlement(_settlementNonce);\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function redeemSettlement(uint32 _depositNonce) external lock {\n        //Get deposit owner.\n        address depositOwner = getSettlement[_depositNonce].owner;\n\n        //Update Deposit\n        if (getSettlement[_depositNonce].status != SettlementStatus.Failed || depositOwner == address(0)) {\n            revert SettlementRedeemUnavailable();\n        } else if (\n            msg.sender != depositOwner && msg.sender != address(IPort(localPortAddress).getUserAccount(depositOwner))\n        ) {\n            revert NotSettlementOwner();\n        }\n        _redeemSettlement(_depositNonce);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    ROOT ROUTER EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootBridgeAgent\n    function callOut(address _recipient, bytes memory _data, uint24 _toChain) external payable lock requiresRouter {\n        //Encode Data for call.\n        bytes memory data =\n            abi.encodePacked(bytes1(0x00), _recipient, settlementNonce++, _data, _manageGasOut(_toChain));\n\n        //Perform Call to clear hToken balance on destination branch chain.\n        _performCall(data, _toChain);\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function callOutAndBridge(\n        address _owner,\n        address _recipient,\n        bytes memory _data,\n        address _globalAddress,\n        uint256 _amount,\n        uint256 _deposit,\n        uint24 _toChain\n    ) external payable lock requiresRouter {\n        //Get destination Local Address from Global Address.\n        address localAddress = IPort(localPortAddress).getLocalTokenFromGlobal(_globalAddress, _toChain);\n\n        //Get destination Underlying Address from Local Address.\n        address underlyingAddress = IPort(localPortAddress).getUnderlyingTokenFromLocal(localAddress, _toChain);\n\n        //Check if valid assets\n        if (localAddress == address(0) || (underlyingAddress == address(0) && _deposit > 0)) {\n            revert InvalidInputParams();\n        }\n\n        //Prepare data for call\n        bytes memory data = abi.encodePacked(\n            bytes1(0x01),\n            _recipient,\n            settlementNonce,\n            localAddress,\n            underlyingAddress,\n            _amount,\n            _deposit,\n            _data,\n            _manageGasOut(_toChain)\n        );\n\n        //Update State to reflect bridgeOut\n        _updateStateOnBridgeOut(\n            msg.sender, _globalAddress, localAddress, underlyingAddress, _amount, _deposit, _toChain\n        );\n\n        //Create Settlement\n        _createSettlement(_owner, _recipient, localAddress, underlyingAddress, _amount, _deposit, data, _toChain);\n\n        //Perform Call to clear hToken balance on destination branch chain and perform call.\n        _performCall(data, _toChain);\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function callOutAndBridgeMultiple(\n        address _owner,\n        address _recipient,\n        bytes memory _data,\n        address[] memory _globalAddresses,\n        uint256[] memory _amounts,\n        uint256[] memory _deposits,\n        uint24 _toChain\n    ) external payable lock requiresRouter {\n        address[] memory hTokens = new address[](_globalAddresses.length);\n        address[] memory tokens = new address[](_globalAddresses.length);\n        for (uint256 i = 0; i < _globalAddresses.length;) {\n            //Populate Addresses for Settlement\n            hTokens[i] = IPort(localPortAddress).getLocalTokenFromGlobal(_globalAddresses[i], _toChain);\n            tokens[i] = IPort(localPortAddress).getUnderlyingTokenFromLocal(hTokens[i], _toChain);\n\n            if (hTokens[i] == address(0) || (tokens[i] == address(0) && _deposits[i] > 0)) revert InvalidInputParams();\n\n            _updateStateOnBridgeOut(\n                msg.sender, _globalAddresses[i], hTokens[i], tokens[i], _amounts[i], _deposits[i], _toChain\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        //Prepare data for call with settlement of multiple assets\n        bytes memory data = abi.encodePacked(\n            bytes1(0x02),\n            _recipient,\n            uint8(hTokens.length),\n            settlementNonce,\n            hTokens,\n            tokens,\n            _amounts,\n            _deposits,\n            _data,\n            _manageGasOut(_toChain)\n        );\n\n        //Create Settlement Balance\n        _createMultipleSettlement(_owner, _recipient, hTokens, tokens, _amounts, _deposits, data, _toChain);\n\n        //Perform Call to destination Branch Chain.\n        _performCall(data, _toChain);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    TOKEN MANAGEMENT EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootBridgeAgent\n    function bridgeIn(address _recipient, DepositParams memory _dParams, uint24 _fromChain)\n        public\n        requiresAgentExecutor\n    {\n        //Check Deposit info from Cross Chain Parameters.\n        if (!CheckParamsLib.checkParams(localPortAddress, _dParams, _fromChain)) {\n            revert InvalidInputParams();\n        }\n\n        //Get global address\n        address globalAddress = IPort(localPortAddress).getGlobalTokenFromLocal(_dParams.hToken, _fromChain);\n\n        //Check if valid asset\n        if (globalAddress == address(0)) revert InvalidInputParams();\n\n        //Move hTokens from Branch to Root + Mint Sufficient hTokens to match new port deposit\n        IPort(localPortAddress).bridgeToRoot(_recipient, globalAddress, _dParams.amount, _dParams.deposit, _fromChain);\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function bridgeInMultiple(address _recipient, DepositMultipleParams memory _dParams, uint24 _fromChain)\n        external\n        requiresAgentExecutor\n    {\n        for (uint256 i = 0; i < _dParams.hTokens.length;) {\n            bridgeIn(\n                _recipient,\n                DepositParams({\n                    hToken: _dParams.hTokens[i],\n                    token: _dParams.tokens[i],\n                    amount: _dParams.amounts[i],\n                    deposit: _dParams.deposits[i],\n                    toChain: _dParams.toChain,\n                    depositNonce: 0\n                }),\n                _fromChain\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    TOKEN MANAGEMENT INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Updates the token balance state by moving assets from root omnichain environment to branch chain, when a user wants to bridge out tokens from the root bridge agent chain.\n     *     @param _sender address of the sender.\n     *     @param _globalAddress address of the global token.\n     *     @param _localAddress address of the local token.\n     *     @param _underlyingAddress address of the underlying token.\n     *     @param _amount amount of hTokens to be bridged out.\n     *     @param _deposit amount of underlying tokens to be bridged out.\n     *     @param _toChain chain to bridge to.\n     */\n    function _updateStateOnBridgeOut(\n        address _sender,\n        address _globalAddress,\n        address _localAddress,\n        address _underlyingAddress,\n        uint256 _amount,\n        uint256 _deposit,\n        uint24 _toChain\n    ) internal {\n        if (_amount - _deposit > 0) {\n            //Move output hTokens from Root to Branch\n            if (_localAddress == address(0)) revert UnrecognizedLocalAddress();\n            _globalAddress.safeTransferFrom(_sender, localPortAddress, _amount - _deposit);\n        }\n\n        if (_deposit > 0) {\n            //Verify there is enough balance to clear native tokens if needed\n            if (_underlyingAddress == address(0)) revert UnrecognizedUnderlyingAddress();\n            if (IERC20hTokenRoot(_globalAddress).getTokenBalance(_toChain) < _deposit) {\n                revert InsufficientBalanceForSettlement();\n            }\n            IPort(localPortAddress).burn(_sender, _globalAddress, _deposit, _toChain);\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                SETTLEMENT INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function to store a Settlement instance. Settlement should be reopened if fallback occurs.\n     *    @param _owner settlement owner address.\n     *    @param _recipient destination chain reciever address.\n     *    @param _hToken deposited global token address.\n     *    @param _token deposited global token address.\n     *    @param _amount amounts of total hTokens + Tokens output.\n     *    @param _deposit amount of underlying / native token to output.\n     *    @param _callData calldata to execute on destination Router.\n     *    @param _toChain Destination chain identificator.\n     *\n     */\n    function _createSettlement(\n        address _owner,\n        address _recipient,\n        address _hToken,\n        address _token,\n        uint256 _amount,\n        uint256 _deposit,\n        bytes memory _callData,\n        uint24 _toChain\n    ) internal {\n        //Cast to Dynamic\n        address[] memory hTokens = new address[](1);\n        hTokens[0] = _hToken;\n        address[] memory tokens = new address[](1);\n        tokens[0] = _token;\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = _amount;\n        uint256[] memory deposits = new uint256[](1);\n        deposits[0] = _deposit;\n\n        //Call createSettlement\n        _createMultipleSettlement(_owner, _recipient, hTokens, tokens, amounts, deposits, _callData, _toChain);\n    }\n\n    /**\n     * @notice Function to create a settlemment. Settlement should be reopened if fallback occurs.\n     *    @param _owner settlement owner address.\n     *    @param _recipient destination chain reciever address.\n     *    @param _hTokens deposited global token addresses.\n     *    @param _tokens deposited global token addresses.\n     *    @param _amounts amounts of total hTokens + Tokens output.\n     *    @param _deposits amount of underlying / native tokens to output.\n     *    @param _callData calldata to execute on destination Router.\n     *    @param _toChain Destination chain identificator.\n     *\n     *\n     */\n    function _createMultipleSettlement(\n        address _owner,\n        address _recipient,\n        address[] memory _hTokens,\n        address[] memory _tokens,\n        uint256[] memory _amounts,\n        uint256[] memory _deposits,\n        bytes memory _callData,\n        uint24 _toChain\n    ) internal {\n        // Update State\n        getSettlement[_getAndIncrementSettlementNonce()] = Settlement({\n            owner: _owner,\n            recipient: _recipient,\n            hTokens: _hTokens,\n            tokens: _tokens,\n            amounts: _amounts,\n            deposits: _deposits,\n            callData: _callData,\n            toChain: _toChain,\n            status: SettlementStatus.Success,\n            gasToBridgeOut: userFeeInfo.gasToBridgeOut\n        });\n    }\n\n    /**\n     * @notice Function to retry a user's Settlement balance with a new amount of gas to bridge out of Root Bridge Agent's Omnichain Environment.\n     *    @param _settlementNonce Identifier for token settlement.\n     *\n     */\n    function _retrySettlement(uint32 _settlementNonce) internal returns (bool) {\n        //Get Settlement\n        Settlement memory settlement = getSettlement[_settlementNonce];\n\n        //Check if Settlement hasn't been redeemed.\n        if (settlement.owner == address(0)) return false;\n\n        //abi encodePacked\n        bytes memory newGas = abi.encodePacked(_manageGasOut(settlement.toChain));\n\n        //overwrite last 16bytes of callData\n        for (uint256 i = 0; i < newGas.length;) {\n            settlement.callData[settlement.callData.length - 16 + i] = newGas[i];\n            unchecked {\n                ++i;\n            }\n        }\n\n        Settlement storage settlementReference = getSettlement[_settlementNonce];\n\n        //Update Gas To Bridge Out\n        settlementReference.gasToBridgeOut = userFeeInfo.gasToBridgeOut;\n\n        //Set Settlement Calldata to send to Branch Chain\n        settlementReference.callData = settlement.callData;\n\n        //Update Settlement Staus\n        settlementReference.status = SettlementStatus.Success;\n\n        //Retry call with additional gas\n        _performCall(settlement.callData, settlement.toChain);\n\n        //Retry Success\n        return true;\n    }\n\n    /**\n     * @notice Function to retry a user's Settlement balance.\n     *     @param _settlementNonce Identifier for token settlement.\n     *\n     */\n    function _redeemSettlement(uint32 _settlementNonce) internal {\n        // Get storage reference\n        Settlement storage settlement = getSettlement[_settlementNonce];\n\n        //Clear Global hTokens To Recipient on Root Chain cancelling Settlement to Branch\n        for (uint256 i = 0; i < settlement.hTokens.length;) {\n            //Check if asset\n            if (settlement.hTokens[i] != address(0)) {\n                //Move hTokens from Branch to Root + Mint Sufficient hTokens to match new port deposit\n                IPort(localPortAddress).bridgeToRoot(\n                    msg.sender,\n                    IPort(localPortAddress).getGlobalTokenFromLocal(settlement.hTokens[i], settlement.toChain),\n                    settlement.amounts[i],\n                    settlement.deposits[i],\n                    settlement.toChain\n                );\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Delete Settlement\n        delete getSettlement[_settlementNonce];\n    }\n\n    /**\n     * @notice Function to reopen a user's Settlement balance as pending and thus retryable by users. Called upon anyFallback of triggered by Branch Bridge Agent.\n     *     @param _settlementNonce Identifier for token settlement.\n     *\n     */\n    function _reopenSettlemment(uint32 _settlementNonce) internal {\n        //Update Deposit\n        getSettlement[_settlementNonce].status = SettlementStatus.Failed;\n    }\n\n    /**\n     * @notice Function that returns Deposit nonce and increments nonce counter.\n     *\n     */\n    function _getAndIncrementSettlementNonce() internal returns (uint32) {\n        return settlementNonce++;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    GAS SWAP INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint24 private constant GLOBAL_DIVISIONER = 1e6; // for basis point (0.0001%)\n\n    //Local mapping of valid gas pools\n    mapping(address => bool) private approvedGasPool;\n\n    /// @inheritdoc IRootBridgeAgent\n    function uniswapV3SwapCallback(int256 amount0, int256 amount1, bytes calldata _data) external {\n        if (!approvedGasPool[msg.sender]) revert CallerIsNotPool();\n        if (amount0 == 0 && amount1 == 0) revert AmountsAreZero();\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n\n        address(data.tokenIn).safeTransfer(msg.sender, uint256(amount0 > 0 ? amount0 : amount1));\n    }\n\n    /**\n     * @notice Swaps gas tokens from the given branch chain to the root chain\n     * @param _amount amount of gas token to swap\n     * @param _fromChain chain to swap from\n     */\n    function _gasSwapIn(uint256 _amount, uint24 _fromChain) internal returns (uint256) {\n        //Get fromChain's Gas Pool Info\n        (bool zeroForOneOnInflow, uint24 priceImpactPercentage, address gasTokenGlobalAddress, address poolAddress) =\n            IPort(localPortAddress).getGasPoolInfo(_fromChain);\n\n        //Check if valid addresses\n        if (gasTokenGlobalAddress == address(0) || poolAddress == address(0)) revert InvalidGasPool();\n\n        //Move Gas hTokens from Branch to Root / Mint Sufficient hTokens to match new port deposit\n        IPort(localPortAddress).bridgeToRoot(address(this), gasTokenGlobalAddress, _amount, _amount, _fromChain);\n\n        //Save Gas Pool for future use\n        if (!approvedGasPool[poolAddress]) approvedGasPool[poolAddress] = true;\n\n        //Get sqrtPriceX96\n        (uint160 sqrtPriceX96,,,,,,) = IUniswapV3Pool(poolAddress).slot0();\n\n        // Calculate Price limit depending on pre-set price impact\n        uint160 exactSqrtPriceImpact = (sqrtPriceX96 * (priceImpactPercentage / 2)) / GLOBAL_DIVISIONER;\n\n        //Get limit\n        uint160 sqrtPriceLimitX96 =\n            zeroForOneOnInflow ? sqrtPriceX96 - exactSqrtPriceImpact : sqrtPriceX96 + exactSqrtPriceImpact;\n\n        //Swap imbalanced token as long as we haven't used the entire amountSpecified and haven't reached the price limit\n        try IUniswapV3Pool(poolAddress).swap(\n            address(this),\n            zeroForOneOnInflow,\n            int256(_amount),\n            sqrtPriceLimitX96,\n            abi.encode(SwapCallbackData({tokenIn: gasTokenGlobalAddress}))\n        ) returns (int256 amount0, int256 amount1) {\n            return uint256(zeroForOneOnInflow ? amount1 : amount0);\n        } catch (bytes memory) {\n            _forceRevert();\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Swaps gas tokens from the given root chain to the branch chain\n     * @param _amount amount of gas token to swap\n     * @param _toChain chain to swap to\n     */\n    function _gasSwapOut(uint256 _amount, uint24 _toChain) internal returns (uint256, address) {\n        //Get fromChain's Gas Pool Info\n        (bool zeroForOneOnInflow, uint24 priceImpactPercentage, address gasTokenGlobalAddress, address poolAddress) =\n            IPort(localPortAddress).getGasPoolInfo(_toChain);\n\n        //Check if valid addresses\n        if (gasTokenGlobalAddress == address(0) || poolAddress == address(0)) revert InvalidGasPool();\n\n        //Save Gas Pool for future use\n        if (!approvedGasPool[poolAddress]) approvedGasPool[poolAddress] = true;\n\n        uint160 sqrtPriceLimitX96;\n        {\n            //Get sqrtPriceX96\n            (uint160 sqrtPriceX96,,,,,,) = IUniswapV3Pool(poolAddress).slot0();\n\n            // Calculate Price limit depending on pre-set price impact\n            uint160 exactSqrtPriceImpact = (sqrtPriceX96 * (priceImpactPercentage / 2)) / GLOBAL_DIVISIONER;\n\n            //Get limit\n            sqrtPriceLimitX96 =\n                zeroForOneOnInflow ? sqrtPriceX96 + exactSqrtPriceImpact : sqrtPriceX96 - exactSqrtPriceImpact;\n        }\n\n        //Swap imbalanced token as long as we haven't used the entire amountSpecified and haven't reached the price limit\n        (int256 amount0, int256 amount1) = IUniswapV3Pool(poolAddress).swap(\n            address(this),\n            !zeroForOneOnInflow,\n            int256(_amount),\n            sqrtPriceLimitX96,\n            abi.encode(SwapCallbackData({tokenIn: address(wrappedNativeToken)}))\n        );\n\n        return (uint256(!zeroForOneOnInflow ? amount1 : amount0), gasTokenGlobalAddress);\n    }\n\n    /**\n     * @notice Manages gas costs of bridging from Root to a given Branch.\n     * @param _toChain destination chain.\n     */\n    function _manageGasOut(uint24 _toChain) internal returns (uint128) {\n        uint256 amountOut;\n        address gasToken;\n        uint256 _initialGas = initialGas;\n\n        if (_toChain == localChainId) {\n            //Transfer gasToBridgeOut Local Branch Bridge Agent if remote initiated call.\n            if (_initialGas > 0) {\n                address(wrappedNativeToken).safeTransfer(getBranchBridgeAgent[localChainId], userFeeInfo.gasToBridgeOut);\n            }\n\n            return uint128(userFeeInfo.gasToBridgeOut);\n        }\n\n        if (_initialGas > 0) {\n            if (userFeeInfo.gasToBridgeOut <= MIN_FALLBACK_RESERVE * tx.gasprice) revert InsufficientGasForFees();\n            (amountOut, gasToken) = _gasSwapOut(userFeeInfo.gasToBridgeOut, _toChain);\n        } else {\n            if (msg.value <= MIN_FALLBACK_RESERVE * tx.gasprice) revert InsufficientGasForFees();\n            wrappedNativeToken.deposit{value: msg.value}();\n            (amountOut, gasToken) = _gasSwapOut(msg.value, _toChain);\n        }\n\n        IPort(localPortAddress).burn(address(this), gasToken, amountOut, _toChain);\n        return amountOut.toUint128();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    ANYCALL INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Internal function performs call to AnycallProxy Contract for cross-chain messaging.\n    function _performCall(bytes memory _calldata, uint256 _toChain) internal {\n        address callee = getBranchBridgeAgent[_toChain];\n\n        if (callee == address(0)) revert UnrecognizedBridgeAgent();\n\n        if (_toChain != localChainId) {\n            //Sends message to AnycallProxy\n            IAnycallProxy(localAnyCallAddress).anyCall(\n                callee, _calldata, _toChain, AnycallFlags.FLAG_ALLOW_FALLBACK_DST, \"\"\n            );\n        } else {\n            //Execute locally\n            IBranchBridgeAgent(callee).anyExecute(_calldata);\n        }\n    }\n\n    /**\n     * @notice Pays for the remote call execution gas. Demands that the user has enough gas to replenish gas for the anycall config contract or forces reversion.\n     * @param _depositedGas available user gas to pay for execution.\n     * @param _gasToBridgeOut amount of gas needed to bridge out.\n     * @param _initialGas initial gas used by the transaction.\n     * @param _fromChain chain remote action initiated from.\n     */\n    function _payExecutionGas(uint128 _depositedGas, uint128 _gasToBridgeOut, uint256 _initialGas, uint24 _fromChain)\n        internal\n    {\n        //reset initial remote execution gas and remote execution fee information\n        delete(initialGas);\n        delete(userFeeInfo);\n\n        if (_fromChain == localChainId) return;\n\n        //Get Available Gas\n        uint256 availableGas = _depositedGas - _gasToBridgeOut;\n\n        //Get Root Environment Execution Cost\n        uint256 minExecCost = tx.gasprice * (MIN_EXECUTION_OVERHEAD + _initialGas - gasleft());\n\n        //Check if sufficient balance\n        if (minExecCost > availableGas) {\n            _forceRevert();\n            return;\n        }\n\n        //Replenish Gas\n        _replenishGas(minExecCost);\n\n        //Account for excess gas\n        accumulatedFees += availableGas - minExecCost;\n    }\n\n    /**\n     * @notice Updates the user de"
    }
  ]
}