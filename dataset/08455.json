{
  "Title": "[M-03] `transfer()` depends on gas consts",
  "Content": "\n[ETHRegistrarController.sol#L183-L185](https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/ethregistrar/ETHRegistrarController.sol#L183-L185)<br>\n[ETHRegistrarController.sol#L204](https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/ethregistrar/ETHRegistrarController.sol#L204)<br>\n\n`transfer()` forwards 2300 gas only, which may not be enough in future if the recipient is a contract and gas costs change. it could break existing contracts functionality.\n\n### Proof of Concept\n\n`.transfer` or `.send` method, only 2300 gas will be “forwarded” to fallback function. Specifically, the SLOAD instruction, will go from costing 200 gas to 800 gas.\n\nIf any smart contract has a functionality of register ens and it has fallback function which is making some state change in contract on ether receive, it could use more than 2300 gas and revert every transaction.\n\nFor reference, check out:\n* <https://docs.soliditylang.org/en/v0.8.15/security-considerations.html?highlight=transfer#sending-and-receiving-ether>\n* <https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/>\n\n### Recommended Mitigation Steps\n\nUse `.call` insted `.transfer`\n\n     (bool success, ) = msg.sender.call.value(amount)(\"\");\n     require(success, \"Transfer failed.\");\n\n**[jefflau (ENS) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2022-07-ens-findings/issues/133#issuecomment-1196371402):**\n > Recommend reducing severity to QA\n\n**[LSDan (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-07-ens-findings/issues/133#issuecomment-1203817454):**\n > I'm downgrading this to Medium. There are external factors required to make this problem occur, but if it does the functionality of the protocol as a whole could be severely impacted.\n\n**[Arachnid (ENS) commented](https://github.com/code-423n4/2022-07-ens-findings/issues/133#issuecomment-1206025827):**\n > It's unclear to me how this could be a significant issue. Anyone writing code to register names knows that any excess funds will be returned, and therefore that they need a fallback that consumes minimal gas. Any EVM change that increases the gas of fallback functions would be breaking for a great number of contracts beyond ENS.\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-07-ens-findings/issues/133#issuecomment-1208062192):**\n > > It's unclear to me how this could be a significant issue.\n> \n> The register functions will fail, consuming a good bit of gas along the way if this occurs. If this were not such a critical piece of functionality I would have considered it QA, but a failure here breaks the protocol.\n> \n> > Anyone writing code to register names knows that any excess funds will be returned, and therefore that they need a fallback that consumes minimal gas. Any EVM change that increases the gas of fallback functions would be breaking for a great number of contracts beyond ENS.\n> \n> The fact that other contracts will break along with ENS does not invalidate the issue. This is a clearly documented problem that has been known for years (see ref links). There is no reason to introduce more critical contracts to the ecosystem that will fail in this scenario, particularly when it is so easy to avoid.\n\n**[Arachnid (ENS) commented](https://github.com/code-423n4/2022-07-ens-findings/issues/133#issuecomment-1214550653):**\n > > The register functions will fail, consuming a good bit of gas along the way if this occurs. If this were not such a critical piece of functionality I would have considered it QA, but a failure here breaks the protocol.\n> \n> I think the implied API here is that any contract registering names with the controller must either send the right amount of ether, or have a fallback function that can accept ether. Changes to the consensus layer that invalidate that assumption for a given contract are out-of-scope for ENS.\n> \n> Sending all remaining gas with the refund increases the threat surface by allowing possible reentrancy etc, which we haven't examined as a threat model here.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-07-ens-contest",
  "Code": [
    {
      "filename": "contracts/ethregistrar/ETHRegistrarController.sol",
      "content": "pragma solidity >=0.8.4;\n\nimport \"./BaseRegistrarImplementation.sol\";\nimport \"./StringUtils.sol\";\nimport \"../resolvers/Resolver.sol\";\nimport \"../registry/ReverseRegistrar.sol\";\nimport \"./IETHRegistrarController.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../wrapper/INameWrapper.sol\";\n\n/**\n * @dev A registrar controller for registering and renewing names at fixed cost.\n */\ncontract ETHRegistrarController is Ownable, IETHRegistrarController {\n    using StringUtils for *;\n    using Address for address;\n\n    uint256 public constant MIN_REGISTRATION_DURATION = 28 days;\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n\n    BaseRegistrarImplementation immutable base;\n    IPriceOracle public immutable prices;\n    uint256 public immutable minCommitmentAge;\n    uint256 public immutable maxCommitmentAge;\n    ReverseRegistrar public immutable reverseRegistrar;\n    INameWrapper public immutable nameWrapper;\n\n    mapping(bytes32 => uint256) public commitments;\n\n    event NameRegistered(\n        string name,\n        bytes32 indexed label,\n        address indexed owner,\n        uint256 baseCost,\n        uint256 premium,\n        uint256 expires\n    );\n    event NameRenewed(\n        string name,\n        bytes32 indexed label,\n        uint256 cost,\n        uint256 expires\n    );\n\n    constructor(\n        BaseRegistrarImplementation _base,\n        IPriceOracle _prices,\n        uint256 _minCommitmentAge,\n        uint256 _maxCommitmentAge,\n        ReverseRegistrar _reverseRegistrar,\n        INameWrapper _nameWrapper\n    ) {\n        require(_maxCommitmentAge > _minCommitmentAge);\n\n        base = _base;\n        prices = _prices;\n        minCommitmentAge = _minCommitmentAge;\n        maxCommitmentAge = _maxCommitmentAge;\n        reverseRegistrar = _reverseRegistrar;\n        nameWrapper = _nameWrapper;\n    }\n\n    function rentPrice(string memory name, uint256 duration)\n        public\n        view\n        override\n        returns (IPriceOracle.Price memory price)\n    {\n        bytes32 label = keccak256(bytes(name));\n        price = prices.price(name, base.nameExpires(uint256(label)), duration);\n    }\n\n    function valid(string memory name) public pure returns (bool) {\n        return name.strlen() >= 3;\n    }\n\n    function available(string memory name) public view override returns (bool) {\n        bytes32 label = keccak256(bytes(name));\n        return valid(name) && base.available(uint256(label));\n    }\n\n    function makeCommitment(\n        string memory name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint32 fuses,\n        uint64 wrapperExpiry\n    ) public pure override returns (bytes32) {\n        bytes32 label = keccak256(bytes(name));\n        if (data.length > 0) {\n            require(\n                resolver != address(0),\n                \"ETHRegistrarController: resolver is required when data is supplied\"\n            );\n        }\n        return\n            keccak256(\n                abi.encode(\n                    label,\n                    owner,\n                    duration,\n                    resolver,\n                    data,\n                    secret,\n                    reverseRecord,\n                    fuses,\n                    wrapperExpiry\n                )\n            );\n    }\n\n    function commit(bytes32 commitment) public override {\n        require(commitments[commitment] + maxCommitmentAge < block.timestamp);\n        commitments[commitment] = block.timestamp;\n    }\n\n    function register(\n        string calldata name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint32 fuses,\n        uint64 wrapperExpiry\n    ) public payable override {\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        require(\n            msg.value >= (price.base + price.premium),\n            \"ETHRegistrarController: Not enough ether provided\"\n        );\n\n        _consumeCommitment(\n            name,\n            duration,\n            makeCommitment(\n                name,\n                owner,\n                duration,\n                secret,\n                resolver,\n                data,\n                reverseRecord,\n                fuses,\n                wrapperExpiry\n            )\n        );\n\n        uint256 expires = nameWrapper.registerAndWrapETH2LD(\n            name,\n            owner,\n            duration,\n            resolver,\n            fuses,\n            wrapperExpiry\n        );\n\n        _setRecords(resolver, keccak256(bytes(name)), data);\n\n        if (reverseRecord) {\n            _setReverseRecord(name, resolver, msg.sender);\n        }\n\n        emit NameRegistered(\n            name,\n            keccak256(bytes(name)),\n            owner,\n            price.base,\n            price.premium,\n            expires\n        );\n\n        if (msg.value > (price.base + price.premium)) {\n            payable(msg.sender).transfer(\n                msg.value - (price.base + price.premium)\n            );\n        }\n    }\n\n    function renew(string calldata name, uint256 duration)\n        external\n        payable\n        override\n    {\n        bytes32 label = keccak256(bytes(name));\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        require(\n            msg.value >= price.base,\n            \"ETHController: Not enough Ether provided for renewal\"\n        );\n\n        uint256 expires = base.renew(uint256(label), duration);\n\n        if (msg.value > price.base) {\n            payable(msg.sender).transfer(msg.value - price.base);\n        }\n\n        emit NameRenewed(name, label, msg.value, expires);\n    }\n\n    function withdraw() public {\n        payable(owner()).transfer(address(this).balance);\n    }\n\n    function supportsInterface(bytes4 interfaceID)\n        external\n        pure\n        returns (bool)\n    {\n        return\n            interfaceID == type(IERC165).interfaceId ||\n            interfaceID == type(IETHRegistrarController).interfaceId;\n    }\n\n    /* Internal functions */\n\n    function _consumeCommitment(\n        string memory name,\n        uint256 duration,\n        bytes32 commitment\n    ) internal {\n        // Require a valid commitment (is old enough and is committed)\n        require(\n            commitments[commitment] + minCommitmentAge <= block.timestamp,\n            \"ETHRegistrarController: Commitment is not valid\"\n        );\n\n        // If the commitment is too old, or the name is registered, stop\n        require(\n            commitments[commitment] + maxCommitmentAge > block.timestamp,\n            \"ETHRegistrarController: Commitment has expired\"\n        );\n        require(available(name), \"ETHRegistrarController: Name is unavailable\");\n\n        delete (commitments[commitment]);\n\n        require(duration >= MIN_REGISTRATION_DURATION);\n    }\n\n    function _setRecords(\n        address resolver,\n        bytes32 label,\n        bytes[] calldata data\n    ) internal {\n        // use hardcoded .eth namehash\n        bytes32 nodehash = keccak256(abi.encodePacked(ETH_NODE, label));\n        for (uint256 i = 0; i < data.length; i++) {\n            // check first few bytes are namehash\n            bytes32 txNamehash = bytes32(data[i][4:36]);\n            require(\n                txNamehash == nodehash,\n                \"ETHRegistrarController: Namehash on record do not match the name being registered\"\n            );\n            resolver.functionCall(\n                data[i],\n                \"ETHRegistrarController: Failed to set Record\"\n            );\n        }\n    }\n\n    function _setReverseRecord(\n        string memory name,\n        address resolver,\n        address owner\n    ) internal {\n        reverseRegistrar.setNameForAddr(\n            msg.sender,\n            owner,\n            resolver,\n            string.concat(name, \".eth\")\n        );\n    }\n}"
    },
    {
      "filename": "contracts/ethregistrar/ETHRegistrarController.sol",
      "content": "pragma solidity >=0.8.4;\n\nimport \"./BaseRegistrarImplementation.sol\";\nimport \"./StringUtils.sol\";\nimport \"../resolvers/Resolver.sol\";\nimport \"../registry/ReverseRegistrar.sol\";\nimport \"./IETHRegistrarController.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../wrapper/INameWrapper.sol\";\n\n/**\n * @dev A registrar controller for registering and renewing names at fixed cost.\n */\ncontract ETHRegistrarController is Ownable, IETHRegistrarController {\n    using StringUtils for *;\n    using Address for address;\n\n    uint256 public constant MIN_REGISTRATION_DURATION = 28 days;\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n\n    BaseRegistrarImplementation immutable base;\n    IPriceOracle public immutable prices;\n    uint256 public immutable minCommitmentAge;\n    uint256 public immutable maxCommitmentAge;\n    ReverseRegistrar public immutable reverseRegistrar;\n    INameWrapper public immutable nameWrapper;\n\n    mapping(bytes32 => uint256) public commitments;\n\n    event NameRegistered(\n        string name,\n        bytes32 indexed label,\n        address indexed owner,\n        uint256 baseCost,\n        uint256 premium,\n        uint256 expires\n    );\n    event NameRenewed(\n        string name,\n        bytes32 indexed label,\n        uint256 cost,\n        uint256 expires\n    );\n\n    constructor(\n        BaseRegistrarImplementation _base,\n        IPriceOracle _prices,\n        uint256 _minCommitmentAge,\n        uint256 _maxCommitmentAge,\n        ReverseRegistrar _reverseRegistrar,\n        INameWrapper _nameWrapper\n    ) {\n        require(_maxCommitmentAge > _minCommitmentAge);\n\n        base = _base;\n        prices = _prices;\n        minCommitmentAge = _minCommitmentAge;\n        maxCommitmentAge = _maxCommitmentAge;\n        reverseRegistrar = _reverseRegistrar;\n        nameWrapper = _nameWrapper;\n    }\n\n    function rentPrice(string memory name, uint256 duration)\n        public\n        view\n        override\n        returns (IPriceOracle.Price memory price)\n    {\n        bytes32 label = keccak256(bytes(name));\n        price = prices.price(name, base.nameExpires(uint256(label)), duration);\n    }\n\n    function valid(string memory name) public pure returns (bool) {\n        return name.strlen() >= 3;\n    }\n\n    function available(string memory name) public view override returns (bool) {\n        bytes32 label = keccak256(bytes(name));\n        return valid(name) && base.available(uint256(label));\n    }\n\n    function makeCommitment(\n        string memory name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint32 fuses,\n        uint64 wrapperExpiry\n    ) public pure override returns (bytes32) {\n        bytes32 label = keccak256(bytes(name));\n        if (data.length > 0) {\n            require(\n                resolver != address(0),\n                \"ETHRegistrarController: resolver is required when data is supplied\"\n            );\n        }\n        return\n            keccak256(\n                abi.encode(\n                    label,\n                    owner,\n                    duration,\n                    resolver,\n                    data,\n                    secret,\n                    reverseRecord,\n                    fuses,\n                    wrapperExpiry\n                )\n            );\n    }\n\n    function commit(bytes32 commitment) public override {\n        require(commitments[commitment] + maxCommitmentAge < block.timestamp);\n        commitments[commitment] = block.timestamp;\n    }\n\n    function register(\n        string calldata name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint32 fuses,\n        uint64 wrapperExpiry\n    ) public payable override {\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        require(\n            msg.value >= (price.base + price.premium),\n            \"ETHRegistrarController: Not enough ether provided\"\n        );\n\n        _consumeCommitment(\n            name,\n            duration,\n            makeCommitment(\n                name,\n                owner,\n                duration,\n                secret,\n                resolver,\n                data,\n                reverseRecord,\n                fuses,\n                wrapperExpiry\n            )\n        );\n\n        uint256 expires = nameWrapper.registerAndWrapETH2LD(\n            name,\n            owner,\n            duration,\n            resolver,\n            fuses,\n            wrapperExpiry\n        );\n\n        _setRecords(resolver, keccak256(bytes(name)), data);\n\n        if (reverseRecord) {\n            _setReverseRecord(name, resolver, msg.sender);\n        }\n\n        emit NameRegistered(\n            name,\n            keccak256(bytes(name)),\n            owner,\n            price.base,\n            price.premium,\n            expires\n        );\n\n        if (msg.value > (price.base + price.premium)) {\n            payable(msg.sender).transfer(\n                msg.value - (price.base + price.premium)\n            );\n        }\n    }\n\n    function renew(string calldata name, uint256 duration)\n        external\n        payable\n        override\n    {\n        bytes32 label = keccak256(bytes(name));\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        require(\n            msg.value >= price.base,\n            \"ETHController: Not enough Ether provided for renewal\"\n        );\n\n        uint256 expires = base.renew(uint256(label), duration);\n\n        if (msg.value > price.base) {\n            payable(msg.sender).transfer(msg.value - price.base);\n        }\n\n        emit NameRenewed(name, label, msg.value, expires);\n    }\n\n    function withdraw() public {\n        payable(owner()).transfer(address(this).balance);\n    }\n\n    function supportsInterface(bytes4 interfaceID)\n        external\n        pure\n        returns (bool)\n    {\n        return\n            interfaceID == type(IERC165).interfaceId ||\n            interfaceID == type(IETHRegistrarController).interfaceId;\n    }\n\n    /* Internal functions */\n\n    function _consumeCommitment(\n        string memory name,\n        uint256 duration,\n        bytes32 commitment\n    ) internal {\n        // Require a valid commitment (is old enough and is committed)\n        require(\n            commitments[commitment] + minCommitmentAge <= block.timestamp,\n            \"ETHRegistrarController: Commitment is not valid\"\n        );\n\n        // If the commitment is too old, or the name is registered, stop\n        require(\n            commitments[commitment] + maxCommitmentAge > block.timestamp,\n            \"ETHRegistrarController: Commitment has expired\"\n        );\n        require(available(name), \"ETHRegistrarController: Name is unavailable\");\n\n        delete (commitments[commitment]);\n\n        require(duration >= MIN_REGISTRATION_DURATION);\n    }\n\n    function _setRecords(\n        address resolver,\n        bytes32 label,\n        bytes[] calldata data\n    ) internal {\n        // use hardcoded .eth namehash\n        bytes32 nodehash = keccak256(abi.encodePacked(ETH_NODE, label));\n        for (uint256 i = 0; i < data.length; i++) {\n            // check first few bytes are namehash\n            bytes32 txNamehash = bytes32(data[i][4:36]);\n            require(\n                txNamehash == nodehash,\n                \"ETHRegistrarController: Namehash on record do not match the name being registered\"\n            );\n            resolver.functionCall(\n                data[i],\n                \"ETHRegistrarController: Failed to set Record\"\n            );\n        }\n    }\n\n    function _setReverseRecord(\n        string memory name,\n        address resolver,\n        address owner\n    ) internal {\n        reverseRegistrar.setNameForAddr(\n            msg.sender,\n            owner,\n            resolver,\n            string.concat(name, \".eth\")\n        );\n    }\n}"
    }
  ]
}