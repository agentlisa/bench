{
  "Title": "[M-12] Denial of service in globalPause by wrong logic",
  "Content": "_Submitted by 0x1f8b_\n\nThe method `globalPause` is not tested and it doesn't work as expected.\n\n### Proof of Concept\n\nBecause the method returns an array (`_updatedAddresses`) and has never been initialized, when you want to set its value, it fails.\n\nRecipe:\n\n*   Call `globalPause` with any valid address.\n*   The transaction will FAULT.\n\n#### Affected source code\n\n*   [FraxlendPairDeployer.sol#L405](https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairDeployer.sol#L405)\n\n### Recommended Mitigation Steps\n\nInitialize the `_updatedAddresses` array like shown below:\n\n```diff\n    function globalPause(address[] memory _addresses) external returns (address[] memory _updatedAddresses) {\n        require(msg.sender == CIRCUIT_BREAKER_ADDRESS, \"Circuit Breaker only\");\n        address _pairAddress;\n        uint256 _lengthOfArray = _addresses.length;\n+       _updatedAddresses = new address[](_lengthOfArray);\n        for (uint256 i = 0; i < _lengthOfArray; ) {\n            _pairAddress = _addresses[i];\n            try IFraxlendPair(_pairAddress).pause() {\n                _updatedAddresses[i] = _addresses[i];\n            } catch {}\n            unchecked {\n                i = i + 1;\n            }\n        }\n    }\n```\n\n**[DrakeEvans (Frax) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2022-08-frax-findings/issues/76#issuecomment-1238100769):**\n > Valid, disagree with severity.  This is a convenience function.  Pause can still be called on the pairs themselves individually.  No user funds at risk, and no users can even touch this function, additionally no loss of functionality in the pairs themselves.  Only result is admin having to revert and spin up tx individually.\n\n**[gititGoro (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-08-frax-findings/issues/76#issuecomment-1266162395):**\n > Well caught! But definitely a Medium severity, given the existence of per pair pausing.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-08-frax",
  "Code": [
    {
      "filename": "src/contracts/FraxlendPairDeployer.sol",
      "content": "// SPDX-License-Identifier: ISC\npragma solidity ^0.8.15;\n\n// ====================================================================\n// |     ______                   _______                             |\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\n// |                                                                  |\n// ====================================================================\n// ====================== FraxlendPairDeployer ========================\n// ====================================================================\n// Frax Finance: https://github.com/FraxFinance\n\n// Primary Author\n// Drake Evans: https://github.com/DrakeEvans\n\n// Reviewers\n// Dennis: https://github.com/denett\n// Sam Kazemian: https://github.com/samkazemian\n// Travis Moore: https://github.com/FortisFortuna\n// Jack Corddry: https://github.com/corddry\n// Rich Gee: https://github.com/zer0blockchain\n\n// ====================================================================\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@rari-capital/solmate/src/utils/SSTORE2.sol\";\nimport \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport \"./interfaces/IRateCalculator.sol\";\nimport \"./interfaces/IFraxlendWhitelist.sol\";\nimport \"./interfaces/IFraxlendPair.sol\";\nimport \"./libraries/SafeERC20.sol\";\n\n// solhint-disable no-inline-assembly\n\n/// @title FraxlendPairDeployer\n/// @author Drake Evans (Frax Finance) https://github.com/drakeevans\n/// @notice Deploys and initializes new FraxlendPairs\n/// @dev Uses create2 to deploy the pairs, logs an event, and records a list of all deployed pairs\ncontract FraxlendPairDeployer is Ownable {\n    using SafeERC20 for IERC20;\n    using Strings for uint256;\n\n    // Constants\n    uint256 public DEFAULT_MAX_LTV = 75000; // 75% with 1e5 precision\n    uint256 public GLOBAL_MAX_LTV = 1e8; // 1000x (100,000%) with 1e5 precision, protects from rounding errors in LTV calc\n    uint256 public DEFAULT_LIQ_FEE = 10000; // 10% with 1e5 precision\n\n    address private contractAddress1;\n    address private contractAddress2;\n\n    // Admin contracts\n    address public CIRCUIT_BREAKER_ADDRESS;\n    address public COMPTROLLER_ADDRESS;\n    address public TIME_LOCK_ADDRESS;\n\n    // Dependencies\n    address private immutable FRAXLEND_WHITELIST_ADDRESS;\n\n    /// @notice Emits when a new pair is deployed\n    /// @notice The ```LogDeploy``` event is emitted when a new Pair is deployed\n    /// @param _name The name of the Pair\n    /// @param _address The address of the pair\n    /// @param _asset The address of the Asset Token contract\n    /// @param _collateral The address of the Collateral Token contract\n    /// @param _oracleMultiply The address of the numerator price Oracle\n    /// @param _oracleDivide The address of the denominator price Oracle\n    /// @param _rateContract The address of the Rate Calculator contract\n    /// @param _maxLTV The Maximum Loan-To-Value for a borrower to be considered solvent (1e5 precision)\n    /// @param _liquidationFee The fee paid to liquidators given as a % of the repayment (1e5 precision)\n    /// @param _maturityDate The maturityDate of the Pair\n    event LogDeploy(\n        string indexed _name,\n        address _address,\n        address indexed _asset,\n        address indexed _collateral,\n        address _oracleMultiply,\n        address _oracleDivide,\n        address _rateContract,\n        uint256 _maxLTV,\n        uint256 _liquidationFee,\n        uint256 _maturityDate\n    );\n\n    /// @notice CREATE2 salt => deployed address\n    mapping(bytes32 => address) public deployedPairsBySalt;\n    /// @notice hash of name => deployed address\n    mapping(string => address) public deployedPairsByName;\n    /// @notice address => isCustom boolean\n    mapping(address => bool) public deployedPairCustomStatusByAddress;\n    /// @notice List of the names of all deployed Pairs\n    string[] public deployedPairsArray;\n\n    constructor(\n        address _circuitBreaker,\n        address _comptroller,\n        address _timelock,\n        address _fraxlendWhitelist\n    ) Ownable() {\n        CIRCUIT_BREAKER_ADDRESS = _circuitBreaker;\n        COMPTROLLER_ADDRESS = _comptroller;\n        TIME_LOCK_ADDRESS = _timelock;\n        FRAXLEND_WHITELIST_ADDRESS = _fraxlendWhitelist;\n    }\n\n    // ============================================================================================\n    // Functions: View Functions\n    // ============================================================================================\n\n    /// @notice The ```deployedPairsLength``` function returns the length of the deployedPairsArray\n    /// @return length of array\n    function deployedPairsLength() external view returns (uint256) {\n        return deployedPairsArray.length;\n    }\n\n    /// @notice The ```getAllPairAddresses``` function returns all pair addresses in deployedPairsArray\n    /// @return memory All deployed pair addresses\n    function getAllPairAddresses() external view returns (address[] memory) {\n        string[] memory _deployedPairsArray = deployedPairsArray;\n        uint256 _lengthOfArray = _deployedPairsArray.length;\n        address[] memory _addresses = new address[](_lengthOfArray);\n        uint256 i;\n        for (i = 0; i < _lengthOfArray; ) {\n            _addresses[i] = deployedPairsByName[_deployedPairsArray[i]];\n            unchecked {\n                i++;\n            }\n        }\n        return _addresses;\n    }\n\n    struct PairCustomStatus {\n        address _address;\n        bool _isCustom;\n    }\n\n    /// @notice The ```getCustomStatuses``` function returns an array of structs which contain the address and custom status\n    /// @param _addresses Addresses to check for custom status\n    /// @return _pairCustomStatuses memory Array of structs containing information\n    function getCustomStatuses(address[] calldata _addresses)\n        external\n        view\n        returns (PairCustomStatus[] memory _pairCustomStatuses)\n    {\n        uint256 _lengthOfArray = _addresses.length;\n        uint256 i;\n        _pairCustomStatuses = new PairCustomStatus[](_lengthOfArray);\n        for (i = 0; i < _lengthOfArray; ) {\n            _pairCustomStatuses[i] = PairCustomStatus({\n                _address: _addresses[i],\n                _isCustom: deployedPairCustomStatusByAddress[_addresses[i]]\n            });\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    // ============================================================================================\n    // Functions: Setters\n    // ============================================================================================\n\n    /// @notice The ```setCreationCode``` function sets the bytecode for the fraxlendPair\n    /// @dev splits the data if necessary to accomodate creation code that is slightly larger than 24kb\n    /// @param _creationCode The creationCode for the Fraxlend Pair\n    function setCreationCode(bytes calldata _creationCode) external onlyOwner {\n        bytes memory _firstHalf = BytesLib.slice(_creationCode, 0, 13000);\n        contractAddress1 = SSTORE2.write(_firstHalf);\n        if (_creationCode.length > 13000) {\n            bytes memory _secondHalf = BytesLib.slice(_creationCode, 13000, _creationCode.length - 13000);\n            contractAddress2 = SSTORE2.write(_secondHalf);\n        }\n    }\n\n    // ============================================================================================\n    // Functions: Internal Methods\n    // ============================================================================================\n\n    /// @notice The ```_deployFirst``` function is an internal function with deploys the pair\n    /// @param _configData abi.encode(address _asset, address _collateral, address _oracleMultiply, address _oracleDivide, uint256 _oracleNormalization, address _rateContract, bytes memory _rateInitData)\n    /// @param _maxLTV The Maximum Loan-To-Value for a borrower to be considered solvent (1e5 precision)\n    /// @param _liquidationFee The fee paid to liquidators given as a % of the repayment (1e5 precision)\n    /// @param _maturityDate The maturityDate of the Pair\n    /// @param _isBorrowerWhitelistActive Enables borrower whitelist\n    /// @param _isLenderWhitelistActive Enables lender whitelist\n    /// @return _pairAddress The address to which the Pair was deployed\n    function _deployFirst(\n        bytes32 _saltSeed,\n        bytes memory _configData,\n        bytes memory _immutables,\n        uint256 _maxLTV,\n        uint256 _liquidationFee,\n        uint256 _maturityDate,\n        uint256 _penaltyRate,\n        bool _isBorrowerWhitelistActive,\n        bool _isLenderWhitelistActive\n    ) private returns (address _pairAddress) {\n        {\n            // _saltSeed is the same for all public pairs so duplicates cannot be created\n            bytes32 salt = keccak256(abi.encodePacked(_saltSeed, _configData));\n            require(deployedPairsBySalt[salt] == address(0), \"FraxlendPairDeployer: Pair already deployed\");\n\n            bytes memory _creationCode = BytesLib.concat(\n                SSTORE2.read(contractAddress1),\n                SSTORE2.read(contractAddress2)\n            );\n            bytes memory bytecode = abi.encodePacked(\n                _creationCode,\n                abi.encode(\n                    _configData,\n                    _immutables,\n                    _maxLTV,\n                    _liquidationFee,\n                    _maturityDate,\n                    _penaltyRate,\n                    _isBorrowerWhitelistActive,\n                    _isLenderWhitelistActive\n                )\n            );\n\n            assembly {\n                _pairAddress := create2(0, add(bytecode, 32), mload(bytecode), salt)\n            }\n            require(_pairAddress != address(0), \"FraxlendPairDeployer: create2 failed\");\n\n            deployedPairsBySalt[salt] = _pairAddress;\n        }\n\n        return _pairAddress;\n    }\n\n    /// @notice The ```_deploySecond``` function is the second part of deployment, it invoked the initialize() on the Pair\n    /// @param _name The name of the Pair\n    /// @param _pairAddress The address of the Pair\n    /// @param _configData abi.encode(address _asset, address _collateral, address _oracleMultiply, address _oracleDivide, uint256 _oracleNormalization, address _rateContract, bytes memory _rateInitData)\n    /// @param _approvedBorrowers An array of approved borrower addresses\n    /// @param _approvedLenders An array of approved lender addresses\n    function _deploySecond(\n        string memory _name,\n        address _pairAddress,\n        bytes memory _configData,\n        address[] memory _approvedBorrowers,\n        address[] memory _approvedLenders\n    ) private {\n        (, , , , , , bytes memory _rateInitData) = abi.decode(\n            _configData,\n            (address, address, address, address, uint256, address, bytes)\n        );\n        require(deployedPairsByName[_name] == address(0), \"FraxlendPairDeployer: Pair name must be unique\");\n        deployedPairsByName[_name] = _pairAddress;\n        deployedPairsArray.push(_name);\n\n        // Set additional values for FraxlendPair\n        IFraxlendPair _fraxlendPair = IFraxlendPair(_pairAddress);\n        _fraxlendPair.initialize(_name, _approvedBorrowers, _approvedLenders, _rateInitData);\n\n        // Transfer Ownership of FraxlendPair\n        _fraxlendPair.transferOwnership(COMPTROLLER_ADDRESS);\n    }\n\n    /// @notice The ```_logDeploy``` function emits a LogDeploy event\n    /// @param _name The name of the Pair\n    /// @param _pairAddress The address of the Pair\n    /// @param _configData abi.encode(address _asset, address _collateral, address _oracleMultiply, address _oracleDivide, uint256 _oracleNormalization, address _rateContract, bytes memory _rateInitData)\n    /// @param _maxLTV The Maximum Loan-To-Value for a borrower to be considered solvent (1e5 precision)\n    /// @param _liquidationFee The fee paid to liquidators given as a % of the repayment (1e5 precision)\n    /// @param _maturityDate The maturityDate of the Pair\n    function _logDeploy(\n        string memory _name,\n        address _pairAddress,\n        bytes memory _configData,\n        uint256 _maxLTV,\n        uint256 _liquidationFee,\n        uint256 _maturityDate\n    ) private {\n        (\n            address _asset,\n            address _collateral,\n            address _oracleMultiply,\n            address _oracleDivide,\n            ,\n            address _rateContract,\n\n        ) = abi.decode(_configData, (address, address, address, address, uint256, address, bytes));\n        emit LogDeploy(\n            _name,\n            _pairAddress,\n            _asset,\n            _collateral,\n            _oracleMultiply,\n            _oracleDivide,\n            _rateContract,\n            _maxLTV,\n            _liquidationFee,\n            _maturityDate\n        );\n    }\n\n    // ============================================================================================\n    // Functions: External Deploy Methods\n    // ============================================================================================\n\n    /// @notice The ```deploy``` function allows anyone to create a custom lending market between an Asset and Collateral Token\n    /// @param _configData abi.encode(address _asset, address _collateral, address _oracleMultiply, address _oracleDivide, uint256 _oracleNormalization, address _rateContract, bytes memory _rateInitData)\n    /// @return _pairAddress The address to which the Pair was deployed\n    function deploy(bytes memory _configData) external returns (address _pairAddress) {\n        (address _asset, address _collateral, , , , address _rateContract, ) = abi.decode(\n            _configData,\n            (address, address, address, address, uint256, address, bytes)\n        );\n        string memory _name = string(\n            abi.encodePacked(\n                \"FraxlendV1 - \",\n                IERC20(_collateral).safeName(),\n                \"/\",\n                IERC20(_asset).safeName(),\n                \" - \",\n                IRateCalculator(_rateContract).name(),\n                \" - \",\n                (deployedPairsArray.length + 1).toString()\n            )\n        );\n\n        _pairAddress = _deployFirst(\n            keccak256(abi.encodePacked(\"public\")),\n            _configData,\n            abi.encode(CIRCUIT_BREAKER_ADDRESS, COMPTROLLER_ADDRESS, TIME_LOCK_ADDRESS, FRAXLEND_WHITELIST_ADDRESS),\n            DEFAULT_MAX_LTV,\n            DEFAULT_LIQ_FEE,\n            0,\n            0,\n            false,\n            false\n        );\n\n        _deploySecond(_name, _pairAddress, _configData, new address[](0), new address[](0));\n\n        _logDeploy(_name, _pairAddress, _configData, DEFAULT_MAX_LTV, DEFAULT_LIQ_FEE, 0);\n    }\n\n    /// @notice The ```deployCustom``` function allows whitelisted users to deploy custom Term Sheets for OTC debt structuring\n    /// @dev Caller must be added to FraxLedWhitelist\n    /// @param _name The name of the Pair\n    /// @param _configData abi.encode(address _asset, address _collateral, address _oracleMultiply, address _oracleDivide, uint256 _oracleNormalization, address _rateContract, bytes memory _rateInitData)\n    /// @param _maxLTV The Maximum Loan-To-Value for a borrower to be considered solvent (1e5 precision)\n    /// @param _liquidationFee The fee paid to liquidators given as a % of the repayment (1e5 precision)\n    /// @param _maturityDate The maturityDate of the Pair\n    /// @param _approvedBorrowers An array of approved borrower addresses\n    /// @param _approvedLenders An array of approved lender addresses\n    /// @return _pairAddress The address to which the Pair was deployed\n    function deployCustom(\n        string memory _name,\n        bytes memory _configData,\n        uint256 _maxLTV,\n        uint256 _liquidationFee,\n        uint256 _maturityDate,\n        uint256 _penaltyRate,\n        address[] memory _approvedBorrowers,\n        address[] memory _approvedLenders\n    ) external returns (address _pairAddress) {\n        require(_maxLTV <= GLOBAL_MAX_LTV, \"FraxlendPairDeployer: _maxLTV is too large\");\n        require(\n            IFraxlendWhitelist(FRAXLEND_WHITELIST_ADDRESS).fraxlendDeployerWhitelist(msg.sender),\n            \"FraxlendPairDeployer: Only whitelisted addresses\"\n        );\n\n        _pairAddress = _deployFirst(\n            keccak256(abi.encodePacked(_name)),\n            _configData,\n            abi.encode(CIRCUIT_BREAKER_ADDRESS, COMPTROLLER_ADDRESS, TIME_LOCK_ADDRESS, FRAXLEND_WHITELIST_ADDRESS),\n            _maxLTV,\n            _liquidationFee,\n            _maturityDate,\n            _penaltyRate,\n            _approvedBorrowers.length > 0,\n            _approvedLenders.length > 0\n        );\n\n        _deploySecond(_name, _pairAddress, _configData, _approvedBorrowers, _approvedLenders);\n\n        deployedPairCustomStatusByAddress[_pairAddress] = true;\n\n        _logDeploy(_name, _pairAddress, _configData, _maxLTV, _liquidationFee, _maturityDate);\n    }\n\n    // ============================================================================================\n    // Functions: Admin\n    // ============================================================================================\n\n    /// @notice The ```globalPause``` function calls the pause() function on a given set of pair addresses\n    /// @dev Ignores reverts when calling pause()\n    /// @param _addresses Addresses to attempt to pause()\n    /// @return _updatedAddresses Addresses for which pause() was successful\n    function globalPause(address[] memory _addresses) external returns (address[] memory _updatedAddresses) {\n        require(msg.sender == CIRCUIT_BREAKER_ADDRESS, \"Circuit Breaker only\");\n        address _pairAddress;\n        uint256 _lengthOfArray = _addresses.length;\n        for (uint256 i = 0; i < _lengthOfArray; ) {\n            _pairAddress = _addresses[i];\n            try IFraxlendPair(_pairAddress).pause() {\n                _updatedAddresses[i] = _addresses[i];\n            } catch {}\n            unchecked {\n                i = i + 1;\n            }\n        }\n    }\n}"
    }
  ]
}