{
  "Title": "[N-01] Typo",
  "Content": "`_accumuatedRewards` => `_accumulatedRewards`\n\n- https://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/erc20/RewardableERC20.sol#L57\n\n```solidity\nuint256 _accumuatedRewards = accumulatedRewards[account];\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-07-reserve",
  "Code": [
    {
      "filename": "contracts/plugins/assets/erc20/RewardableERC20.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity ^0.8.19;\n\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../../interfaces/IRewardable.sol\";\n\n/**\n * @title RewardableERC20\n * @notice An abstract class that can be extended to create rewardable wrapper.\n * @notice `_claimAssetRewards` keeps tracks of rewards by snapshotting the balance\n * and calculating the difference between the current balance and the previous balance.\n * @dev To inherit:\n *   - override _claimAssetRewards()\n *   - call ERC20 constructor elsewhere during construction\n */\nabstract contract RewardableERC20 is IRewardable, ERC20, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    uint256 public immutable one; // {qShare/share}\n    IERC20 public immutable rewardToken;\n\n    uint256 public rewardsPerShare; // {qRewards/share}\n    mapping(address => uint256) public lastRewardsPerShare; // {qRewards/share}\n    mapping(address => uint256) public accumulatedRewards; // {qRewards}\n    mapping(address => uint256) public claimedRewards; // {qRewards}\n\n    // Used to keep track of how many reward the Vault has accumulated\n    // Whenever _claimAndSyncRewards() is called we will calculate the difference\n    // between the current balance and `lastRewardBalance` to figure out how much to distribute\n    uint256 internal lastRewardBalance = 0;\n\n    /// @dev Extending class must ensure ERC20 constructor is called\n    constructor(IERC20 _rewardToken, uint8 _decimals) {\n        rewardToken = _rewardToken;\n        one = 10**_decimals; // set via pass-in to prevent inheritance issues\n    }\n\n    function claimRewards() external nonReentrant {\n        _claimAndSyncRewards();\n        _syncAccount(msg.sender);\n        _claimAccountRewards(msg.sender);\n    }\n\n    function _syncAccount(address account) internal {\n        if (account == address(0)) return;\n\n        // {qRewards/share}\n        uint256 accountRewardsPerShare = lastRewardsPerShare[account];\n\n        // {qShare}\n        uint256 shares = balanceOf(account);\n\n        // {qRewards}\n        uint256 _accumuatedRewards = accumulatedRewards[account];\n\n        // {qRewards/share}\n        uint256 _rewardsPerShare = rewardsPerShare;\n        if (accountRewardsPerShare < _rewardsPerShare) {\n            // {qRewards/share}\n            uint256 delta = _rewardsPerShare - accountRewardsPerShare;\n\n            // {qRewards} = {qRewards/share} * {qShare}\n            _accumuatedRewards += (delta * shares) / one;\n        }\n        lastRewardsPerShare[account] = _rewardsPerShare;\n        accumulatedRewards[account] = _accumuatedRewards;\n    }\n\n    function _claimAndSyncRewards() internal virtual {\n        uint256 _totalSupply = totalSupply();\n        if (_totalSupply == 0) {\n            return;\n        }\n        _claimAssetRewards();\n        uint256 balanceAfterClaimingRewards = rewardToken.balanceOf(address(this));\n\n        uint256 _rewardsPerShare = rewardsPerShare;\n        uint256 _previousBalance = lastRewardBalance;\n\n        if (balanceAfterClaimingRewards > _previousBalance) {\n            uint256 delta = balanceAfterClaimingRewards - _previousBalance;\n            // {qRewards/share} += {qRewards} * {qShare/share} / {qShare}\n            _rewardsPerShare += (delta * one) / _totalSupply;\n        }\n        lastRewardBalance = balanceAfterClaimingRewards;\n        rewardsPerShare = _rewardsPerShare;\n    }\n\n    function _claimAccountRewards(address account) internal {\n        uint256 claimableRewards = accumulatedRewards[account] - claimedRewards[account];\n\n        emit RewardsClaimed(IERC20(address(rewardToken)), claimableRewards);\n\n        if (claimableRewards == 0) {\n            return;\n        }\n\n        claimedRewards[account] = accumulatedRewards[account];\n\n        uint256 currentRewardTokenBalance = rewardToken.balanceOf(address(this));\n\n        // This is just to handle the edge case where totalSupply() == 0 and there\n        // are still reward tokens in the contract.\n        uint256 nonDistributed = currentRewardTokenBalance > lastRewardBalance\n            ? currentRewardTokenBalance - lastRewardBalance\n            : 0;\n\n        rewardToken.safeTransfer(account, claimableRewards);\n\n        currentRewardTokenBalance = rewardToken.balanceOf(address(this));\n        lastRewardBalance = currentRewardTokenBalance > nonDistributed\n            ? currentRewardTokenBalance - nonDistributed\n            : 0;\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256\n    ) internal virtual override {\n        _claimAndSyncRewards();\n        _syncAccount(from);\n        _syncAccount(to);\n    }\n\n    /// === Must override ===\n\n    function _claimAssetRewards() internal virtual;\n}"
    }
  ]
}