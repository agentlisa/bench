{
  "Title": "Spelling mistakes",
  "Content": "##### Description\nSome texts have spelling mistakes:\n1) `balanceAdderess` -> `balanceAddress`\n   https://github.com/EnsoFinance/shortcuts-contracts/blob/4902e55608f975f73772310955444110b1cfc4fc/contracts/helpers/EnsoShortcutsHelpers.sol#L14\n2) `renounes` -> `renouns`\n   https://github.com/EnsoFinance/shortcuts-contracts/blob/4902e55608f975f73772310955444110b1cfc4fc/contracts/EnsoBeacon.sol#L147\n3) `alway` -> `always`\n   https://github.com/EnsoFinance/shortcuts-contracts/blob/4902e55608f975f73772310955444110b1cfc4fc/contracts/EnsoBeacon.sol#L179\n4) `indetify` -> `identify`\n   https://github.com/EnsoFinance/shortcuts-contracts/blob/4902e55608f975f73772310955444110b1cfc4fc/contracts/EnsoWalletFactory.sol#L43\n   https://github.com/EnsoFinance/shortcuts-contracts/blob/4902e55608f975f73772310955444110b1cfc4fc/contracts/EnsoWalletFactory.sol#L79\n5) `implemenation` -> `implementation`\n   https://github.com/EnsoFinance/shortcuts-contracts/blob/4902e55608f975f73772310955444110b1cfc4fc/contracts/EnsoBeacon.sol#L67\n##### Recommendation\nWe recommend correcting the mistakes.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/helpers/EnsoShortcutsHelpers.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n/**\n * @dev SignedMathHelpers contract is recommended to use only in Shortcuts passed to EnsoWallet.\n *\n * This contract functions allow to dynamically get the data during Shortcut transaction execution\n * that usually would be read between transactions\n */\ncontract EnsoShortcutsHelpers {\n    uint256 public constant VERSION = 2;\n\n    /**\n     * @dev Returns the ether balance of given `balanceAdderess`.\n     */\n    function getBalance(address balanceAddress) external view returns (uint256 balance) {\n        return address(balanceAddress).balance;\n    }\n\n    /**\n     * @dev Returns the current block timestamp.\n     */\n    function getBlockTimestamp() external view returns (uint256 timestamp) {\n        return block.timestamp;\n    }\n\n    /**\n     * @dev Returns a value depending on a truth condition\n     */\n    function toggle(bool condition, uint256 a, uint256 b) external pure returns (uint256) {\n        if (condition) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n\n    /**\n     * @dev Returns the inverse bool\n     */\n    function not(bool condition) external pure returns (bool) {\n        return !condition;\n    }\n\n    /**\n     * @dev Returns bool for a == b\n     */\n    function isEqual(uint256 a, uint256 b) external pure returns (bool) {\n        return a == b;\n    }\n\n    /**\n     * @dev Returns bool for a < b\n     */\n    function isLessThan(uint256 a, uint256 b) external pure returns (bool) {\n        return a < b;\n    }\n\n    /**\n     * @dev Returns bool for a <= b\n     */\n    function isEqualOrLessThan(uint256 a, uint256 b) external pure returns (bool) {\n        return a <= b;\n    }\n\n    /**\n     * @dev Returns bool for a > b\n     */\n    function isGreaterThan(uint256 a, uint256 b) external pure returns (bool) {\n        return a > b;\n    }\n\n    /**\n     * @dev Returns bool for a >= b\n     */\n    function isEqualOrGreaterThan(uint256 a, uint256 b) external pure returns (bool) {\n        return a >= b;\n    }\n\n    /**\n     * @dev Returns bool for a == b\n     */\n    function isAddressEqual(address a, address b) external pure returns (bool) {\n        return a == b;\n    }\n\n    /**\n     * @dev Returns `input` bytes as string.\n     */\n    function bytesToString(bytes calldata input) external pure returns (string memory) {\n        return string(abi.encodePacked(input));\n    }\n\n    /**\n     * @dev Returns `input` bytes32 as uint256.\n     */\n    function bytes32ToUint256(bytes32 input) external pure returns (uint256) {\n        return uint256(input);\n    }\n\n    /**\n     * @dev Returns `input` bytes32 as address.\n     */\n    function bytes32ToAddress(bytes32 input) external pure returns (address) {\n        return address(uint160(uint256(input)));\n    }\n\n    /**\n     * @dev Returns uint256 `value` as int256.\n     */\n    function uint256ToInt256(uint256 value) public pure returns (int256) {\n        require(value <= uint256(type(int256).max), \"Value does not fit in an int256\");\n        return int256(value);\n    }\n\n    /**\n     * @dev Returns int256 `value` as uint256.\n     */\n    function int256ToUint256(int256 value) public pure returns (uint256) {\n        require(value >= 0, \"Value must be positive\");\n        return uint256(value);\n    }\n}"
    },
    {
      "filename": "contracts/EnsoBeacon.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\nimport \"./interfaces/IBeacon.sol\";\nimport \"./interfaces/IOwnable.sol\";\nimport \"./interfaces/IUUPS.sol\";\n\ncontract EnsoBeacon is IBeacon {\n    address public admin;\n    address public delegate;\n    address public factory;\n    address public coreImplementation;\n    address public fallbackImplementation;\n\n    address public pendingAdmin;\n    address public pendingDelegate;\n    address public pendingCoreImplementation;\n    address public pendingFactoryImplementation;\n    bytes public pendingFactoryUpgradeData;\n\n    uint256 public delay;\n    uint256 public upgradeTimestamp;\n\n    event CoreUpgraded(address previousImplementation, address newImplementation);\n    event FallbackUpgraded(address previousImplementation, address newImplementation);\n    event EmergencyUpgrade();\n    event AdministrationTransferred(address previousAdmin, address newAdmin);\n    event AdministrationTransferStarted(address previousAdmin, address newAdmin);\n    event DelegationTransferred(address previousDelegate, address newDelegate);\n    event DelegationTransferStarted(address previousDelegate, address newDelegate);\n    event Factory(address newFactory);\n    event Delay(uint256 newDelay);\n\n    error InvalidImplementation();\n    error InvalidAccount();\n    error NotPermitted();\n    error NoPendingUpgrade();\n    error Wait();\n\n    modifier onlyAdmin {\n        if (msg.sender != admin) revert NotPermitted();\n        _;\n    }\n\n    modifier onlyDelegate {\n        if (msg.sender != delegate) revert NotPermitted();\n        _;\n    }\n\n    constructor(\n        address coreImplementation_,\n        address fallbackImplementation_\n    ) {\n        admin = msg.sender;\n        delegate = msg.sender;\n        coreImplementation = coreImplementation_;\n        fallbackImplementation = fallbackImplementation_;\n    }\n\n    // @notice The current core implementation\n    // @dev Called by proxy contracts to get the implementation address\n    function implementation() external view override returns (address) {\n        return coreImplementation;\n    }\n\n    // @notice Switch from the core implementation to the fallback implemenation\n    function emergencyUpgrade() external onlyDelegate {\n        _upgradeCore(fallbackImplementation);\n        emit EmergencyUpgrade();\n    }\n\n    // @notice Finalize the new core implementation\n    function finalizeUpgrade() external {\n        // Load timestamp and check\n        uint256 timestamp = upgradeTimestamp;\n        if (timestamp == 0) revert NoPendingUpgrade();\n        if (timestamp + delay > block.timestamp) revert Wait();\n        delete upgradeTimestamp;\n        // Load implementation data and check\n        address newImplementation = pendingCoreImplementation;\n        address factoryImplementation = pendingFactoryImplementation;\n        bytes memory data = pendingFactoryUpgradeData;\n        if (newImplementation == address(0)) revert InvalidImplementation(); // sanity check\n        delete pendingCoreImplementation;\n        delete pendingFactoryImplementation;\n        delete pendingFactoryUpgradeData;\n        // Upgrade\n        _upgradeCore(newImplementation);\n        if (factoryImplementation != address(0)) _upgradeFactory(factoryImplementation, data);\n    }\n\n    // @notice Initialize an upgrade to a new core implementation\n    // @param newImplementation The address of the new core implementation\n    // @param factoryImplementation Optionally include a new factory implementation to upgrade the factory simultaneously. Pass zero address if no upgrade is needed\n    // @param data Calldata for upgrading the new factory. Pass zero bytes if factory is not being upgraded or no additional call needs to be made\n    function upgradeCore(\n        address newImplementation,\n        address factoryImplementation,\n        bytes memory data\n    ) external onlyAdmin {\n        if (newImplementation == address(0)) revert InvalidImplementation();\n        upgradeTimestamp = block.timestamp;\n        pendingCoreImplementation = newImplementation;\n        // If the following is null data, at least we ensure that any old pending values are overwritten\n        pendingFactoryImplementation = factoryImplementation;\n        pendingFactoryUpgradeData = data;\n    }\n\n    // @notice Upgrade the fallback implementation\n    // @param newImplementation The address of the new fallback implementation\n    function upgradeFallback(address newImplementation) external onlyAdmin {\n        if (newImplementation == address(0)) revert InvalidImplementation();\n        if (newImplementation == fallbackImplementation) revert InvalidImplementation();\n        address previousImplementation = fallbackImplementation;\n        fallbackImplementation = newImplementation;\n        emit FallbackUpgraded(previousImplementation, newImplementation);\n    }\n\n    // @notice Upgrade the factory implementation\n    // @param newImplementation The address of the new factory implementation\n    // @param data Calldata for upgrading the new factory. Pass zero bytes if no additional call needs to be made\n    function upgradeFactory(address newImplementation, bytes memory data) external onlyAdmin {\n        _upgradeFactory(newImplementation, data);\n    }\n\n    // @notice Initiate transfer of the admin role\n    // @notice newAdmin The address of the new admin\n    function transferAdministration(address newAdmin) external onlyAdmin {\n        if (newAdmin == address(0)) revert InvalidAccount();\n        if (newAdmin == admin) revert InvalidAccount();\n        pendingAdmin = newAdmin;\n        emit AdministrationTransferStarted(admin, newAdmin);\n    }\n\n    // @notice Accept new admin role\n    // @dev Only the pending admin can call this function\n    function acceptAdministration() external {\n        if (msg.sender != pendingAdmin) revert NotPermitted();\n        delete pendingAdmin;\n        address previousAdmin = admin;\n        admin = msg.sender;\n        emit AdministrationTransferred(previousAdmin, msg.sender);\n    }\n\n    // @notice Renounce admin role. No upgrades can be done if this function is called.\n    // @dev This function renounes both the admin and the delegate roles.\n    function renounceAdministration() external onlyAdmin {\n        address previousAdmin = admin;\n        address previousDelegate = delegate;\n        delete admin;\n        delete delegate;\n        delete pendingAdmin;\n        delete pendingDelegate;\n        emit AdministrationTransferred(previousAdmin, address(0));\n        emit DelegationTransferred(previousDelegate, address(0));\n    }\n\n    // @notice Initiate transfer of the delegate role\n    // @notice newDelegate The address of the new delegate\n    function transferDelegation(address newDelegate) external onlyAdmin {\n        if (newDelegate == address(0)) revert InvalidAccount();\n        if (newDelegate == delegate) revert InvalidAccount();\n        pendingDelegate = newDelegate;\n        emit DelegationTransferStarted(delegate, newDelegate);\n    }\n\n    // @notice Accept new delegate role\n    // @dev Only the pending delegate can call this function\n    function acceptDelegation() external {\n        if (msg.sender != pendingDelegate) revert NotPermitted();\n        delete pendingDelegate;\n        address previousDelegate = delegate;\n        delegate = msg.sender;\n        emit DelegationTransferred(previousDelegate, msg.sender);\n    }\n\n    // @notice Renounce delegate role. Emergency upgrades cannot happen while this role remain unfilled.\n    // @dev The admin can alway give this role to another address with the transferDelegation function\n    function renounceDelegation() external onlyDelegate {\n        address previousDelegate = delegate;\n        delete delegate;\n        emit DelegationTransferred(previousDelegate, address(0));\n    }\n\n    // @notice Transfer ownership of a contract that is owned by this contract\n    // @param ownable The address of the contract that is getting it's ownership transferred\n    // @param newOwner The address of the new owner\n    function transferOwnership(address ownable, address newOwner) external onlyAdmin {\n        IOwnable(ownable).transferOwnership(newOwner);\n    }\n\n    // @notice Accept ownership of another contract by this contract\n    // @param ownable The address of the contract that is getting it's ownership transferred\n    function acceptOwnership(address ownable) external onlyAdmin {\n        IOwnable(ownable).acceptOwnership();\n    }\n\n    // @notice Set the current factory address in state\n    // @param newFactory The address of the new factory\n    function setFactory(address newFactory) external onlyAdmin {\n        factory = newFactory;\n        emit Factory(newFactory);\n    }\n\n    // @notice Update the delay between in initiating an upgrade and finalizing the upgrade\n    // @param newDelay The new delay in seconds\n    function setDelay(uint256 newDelay) external onlyAdmin {\n        delay = newDelay;\n        emit Delay(newDelay);\n    }\n\n    // @notice Internal function for setting the new core implementation\n    // @param newImplementation The address of the new implementation\n    function _upgradeCore(address newImplementation) internal {\n        if (newImplementation == address(0)) revert InvalidImplementation();\n        //if (newImplementation == coreImplementation) revert InvalidImplementation();\n        address previousImplementation = coreImplementation;\n        coreImplementation = newImplementation;\n        emit CoreUpgraded(previousImplementation, newImplementation);\n    }\n\n    // @notice Internal function for upgrading the factory implementation\n    // @param newImplementation The address of the new factory implementation\n    // @param data Calldata for upgrading the new factory. Pass zero bytes if no additional call needs to be made\n    function _upgradeFactory(address newImplementation, bytes memory data) internal {\n        if (data.length > 0) {\n            IUUPS(factory).upgradeToAndCall(newImplementation, data);\n        } else {\n            IUUPS(factory).upgradeTo(newImplementation);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/EnsoBeacon.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\nimport \"./interfaces/IBeacon.sol\";\nimport \"./interfaces/IOwnable.sol\";\nimport \"./interfaces/IUUPS.sol\";\n\ncontract EnsoBeacon is IBeacon {\n    address public admin;\n    address public delegate;\n    address public factory;\n    address public coreImplementation;\n    address public fallbackImplementation;\n\n    address public pendingAdmin;\n    address public pendingDelegate;\n    address public pendingCoreImplementation;\n    address public pendingFactoryImplementation;\n    bytes public pendingFactoryUpgradeData;\n\n    uint256 public delay;\n    uint256 public upgradeTimestamp;\n\n    event CoreUpgraded(address previousImplementation, address newImplementation);\n    event FallbackUpgraded(address previousImplementation, address newImplementation);\n    event EmergencyUpgrade();\n    event AdministrationTransferred(address previousAdmin, address newAdmin);\n    event AdministrationTransferStarted(address previousAdmin, address newAdmin);\n    event DelegationTransferred(address previousDelegate, address newDelegate);\n    event DelegationTransferStarted(address previousDelegate, address newDelegate);\n    event Factory(address newFactory);\n    event Delay(uint256 newDelay);\n\n    error InvalidImplementation();\n    error InvalidAccount();\n    error NotPermitted();\n    error NoPendingUpgrade();\n    error Wait();\n\n    modifier onlyAdmin {\n        if (msg.sender != admin) revert NotPermitted();\n        _;\n    }\n\n    modifier onlyDelegate {\n        if (msg.sender != delegate) revert NotPermitted();\n        _;\n    }\n\n    constructor(\n        address coreImplementation_,\n        address fallbackImplementation_\n    ) {\n        admin = msg.sender;\n        delegate = msg.sender;\n        coreImplementation = coreImplementation_;\n        fallbackImplementation = fallbackImplementation_;\n    }\n\n    // @notice The current core implementation\n    // @dev Called by proxy contracts to get the implementation address\n    function implementation() external view override returns (address) {\n        return coreImplementation;\n    }\n\n    // @notice Switch from the core implementation to the fallback implemenation\n    function emergencyUpgrade() external onlyDelegate {\n        _upgradeCore(fallbackImplementation);\n        emit EmergencyUpgrade();\n    }\n\n    // @notice Finalize the new core implementation\n    function finalizeUpgrade() external {\n        // Load timestamp and check\n        uint256 timestamp = upgradeTimestamp;\n        if (timestamp == 0) revert NoPendingUpgrade();\n        if (timestamp + delay > block.timestamp) revert Wait();\n        delete upgradeTimestamp;\n        // Load implementation data and check\n        address newImplementation = pendingCoreImplementation;\n        address factoryImplementation = pendingFactoryImplementation;\n        bytes memory data = pendingFactoryUpgradeData;\n        if (newImplementation == address(0)) revert InvalidImplementation(); // sanity check\n        delete pendingCoreImplementation;\n        delete pendingFactoryImplementation;\n        delete pendingFactoryUpgradeData;\n        // Upgrade\n        _upgradeCore(newImplementation);\n        if (factoryImplementation != address(0)) _upgradeFactory(factoryImplementation, data);\n    }\n\n    // @notice Initialize an upgrade to a new core implementation\n    // @param newImplementation The address of the new core implementation\n    // @param factoryImplementation Optionally include a new factory implementation to upgrade the factory simultaneously. Pass zero address if no upgrade is needed\n    // @param data Calldata for upgrading the new factory. Pass zero bytes if factory is not being upgraded or no additional call needs to be made\n    function upgradeCore(\n        address newImplementation,\n        address factoryImplementation,\n        bytes memory data\n    ) external onlyAdmin {\n        if (newImplementation == address(0)) revert InvalidImplementation();\n        upgradeTimestamp = block.timestamp;\n        pendingCoreImplementation = newImplementation;\n        // If the following is null data, at least we ensure that any old pending values are overwritten\n        pendingFactoryImplementation = factoryImplementation;\n        pendingFactoryUpgradeData = data;\n    }\n\n    // @notice Upgrade the fallback implementation\n    // @param newImplementation The address of the new fallback implementation\n    function upgradeFallback(address newImplementation) external onlyAdmin {\n        if (newImplementation == address(0)) revert InvalidImplementation();\n        if (newImplementation == fallbackImplementation) revert InvalidImplementation();\n        address previousImplementation = fallbackImplementation;\n        fallbackImplementation = newImplementation;\n        emit FallbackUpgraded(previousImplementation, newImplementation);\n    }\n\n    // @notice Upgrade the factory implementation\n    // @param newImplementation The address of the new factory implementation\n    // @param data Calldata for upgrading the new factory. Pass zero bytes if no additional call needs to be made\n    function upgradeFactory(address newImplementation, bytes memory data) external onlyAdmin {\n        _upgradeFactory(newImplementation, data);\n    }\n\n    // @notice Initiate transfer of the admin role\n    // @notice newAdmin The address of the new admin\n    function transferAdministration(address newAdmin) external onlyAdmin {\n        if (newAdmin == address(0)) revert InvalidAccount();\n        if (newAdmin == admin) revert InvalidAccount();\n        pendingAdmin = newAdmin;\n        emit AdministrationTransferStarted(admin, newAdmin);\n    }\n\n    // @notice Accept new admin role\n    // @dev Only the pending admin can call this function\n    function acceptAdministration() external {\n        if (msg.sender != pendingAdmin) revert NotPermitted();\n        delete pendingAdmin;\n        address previousAdmin = admin;\n        admin = msg.sender;\n        emit AdministrationTransferred(previousAdmin, msg.sender);\n    }\n\n    // @notice Renounce admin role. No upgrades can be done if this function is called.\n    // @dev This function renounes both the admin and the delegate roles.\n    function renounceAdministration() external onlyAdmin {\n        address previousAdmin = admin;\n        address previousDelegate = delegate;\n        delete admin;\n        delete delegate;\n        delete pendingAdmin;\n        delete pendingDelegate;\n        emit AdministrationTransferred(previousAdmin, address(0));\n        emit DelegationTransferred(previousDelegate, address(0));\n    }\n\n    // @notice Initiate transfer of the delegate role\n    // @notice newDelegate The address of the new delegate\n    function transferDelegation(address newDelegate) external onlyAdmin {\n        if (newDelegate == address(0)) revert InvalidAccount();\n        if (newDelegate == delegate) revert InvalidAccount();\n        pendingDelegate = newDelegate;\n        emit DelegationTransferStarted(delegate, newDelegate);\n    }\n\n    // @notice Accept new delegate role\n    // @dev Only the pending delegate can call this function\n    function acceptDelegation() external {\n        if (msg.sender != pendingDelegate) revert NotPermitted();\n        delete pendingDelegate;\n        address previousDelegate = delegate;\n        delegate = msg.sender;\n        emit DelegationTransferred(previousDelegate, msg.sender);\n    }\n\n    // @notice Renounce delegate role. Emergency upgrades cannot happen while this role remain unfilled.\n    // @dev The admin can alway give this role to another address with the transferDelegation function\n    function renounceDelegation() external onlyDelegate {\n        address previousDelegate = delegate;\n        delete delegate;\n        emit DelegationTransferred(previousDelegate, address(0));\n    }\n\n    // @notice Transfer ownership of a contract that is owned by this contract\n    // @param ownable The address of the contract that is getting it's ownership transferred\n    // @param newOwner The address of the new owner\n    function transferOwnership(address ownable, address newOwner) external onlyAdmin {\n        IOwnable(ownable).transferOwnership(newOwner);\n    }\n\n    // @notice Accept ownership of another contract by this contract\n    // @param ownable The address of the contract that is getting it's ownership transferred\n    function acceptOwnership(address ownable) external onlyAdmin {\n        IOwnable(ownable).acceptOwnership();\n    }\n\n    // @notice Set the current factory address in state\n    // @param newFactory The address of the new factory\n    function setFactory(address newFactory) external onlyAdmin {\n        factory = newFactory;\n        emit Factory(newFactory);\n    }\n\n    // @notice Update the delay between in initiating an upgrade and finalizing the upgrade\n    // @param newDelay The new delay in seconds\n    function setDelay(uint256 newDelay) external onlyAdmin {\n        delay = newDelay;\n        emit Delay(newDelay);\n    }\n\n    // @notice Internal function for setting the new core implementation\n    // @param newImplementation The address of the new implementation\n    function _upgradeCore(address newImplementation) internal {\n        if (newImplementation == address(0)) revert InvalidImplementation();\n        //if (newImplementation == coreImplementation) revert InvalidImplementation();\n        address previousImplementation = coreImplementation;\n        coreImplementation = newImplementation;\n        emit CoreUpgraded(previousImplementation, newImplementation);\n    }\n\n    // @notice Internal function for upgrading the factory implementation\n    // @param newImplementation The address of the new factory implementation\n    // @param data Calldata for upgrading the new factory. Pass zero bytes if no additional call needs to be made\n    function _upgradeFactory(address newImplementation, bytes memory data) internal {\n        if (data.length > 0) {\n            IUUPS(factory).upgradeToAndCall(newImplementation, data);\n        } else {\n            IUUPS(factory).upgradeTo(newImplementation);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/EnsoWalletFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\nimport \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\nimport \"./libraries/BeaconClones.sol\";\nimport \"./access/Ownable.sol\";\nimport \"./interfaces/IEnsoWallet.sol\";\n\ncontract EnsoWalletFactory is Ownable, UUPSUpgradeable {\n    using StorageAPI for bytes32;\n    using BeaconClones for address;\n\n    address public immutable ensoBeacon;\n\n    event Deployed(IEnsoWallet instance, string label);\n\n    error AlreadyInit();\n    error NoLabel();\n\n    constructor(address ensoBeacon_) {\n        ensoBeacon = ensoBeacon_;\n    }\n\n    // @notice A function to initialize state on the proxy the delegates to this contract\n    function initialize() external {\n        if (OWNER.getAddress() != address(0)) revert AlreadyInit();\n        OWNER.setAddress(msg.sender);\n    }\n\n    // @notice Deploy a wallet using the msg.sender as the salt\n    // @param commands The optional commands for executing a shortcut after deployment\n    // @param state The optional state for executing a shortcut after deployment\n    function deploy(\n        bytes32[] calldata commands,\n        bytes[] calldata state\n    ) public payable returns (IEnsoWallet) {\n        bytes32 salt = bytes32(uint256(uint160(msg.sender)));\n        return _deploy(salt, \"\", commands, state);\n    }\n\n    // @notice Deploy a wallet using a hash of the msg.sender and a label as the salt\n    // @param label The label to indentify deployment\n    // @param commands The optional commands for executing a shortcut after deployment\n    // @param state The optional state for executing a shortcut after deployment\n    function deployCustom(\n        string memory label,\n        bytes32[] calldata commands,\n        bytes[] calldata state\n    ) public payable returns (IEnsoWallet) {\n        if (bytes(label).length == 0) revert NoLabel();\n        bytes32 salt = _customSalt(msg.sender, label);\n        return _deploy(salt, label, commands, state);\n    }\n\n    // @notice Get the deployment address for the msg.sender\n    function getAddress() public view returns (address payable) {\n        return getUserAddress(msg.sender);\n    }\n\n    // @notice Get the deployment address for the user\n    // @param user The address of the user that is used to determine the deployment address\n    function getUserAddress(address user) public view returns (address payable) {\n        bytes32 salt = bytes32(uint256(uint160(user)));\n        return _predictDeterministicAddress(salt);\n    }\n\n    // @notice Get the deployment address for a user and label\n    // @param user The address of the user that is used to determine the deployment address\n    // @param label The label that is used to determine the deployment address\n    function getCustomAddress(address user, string memory label) external view returns (address payable) {\n        if (bytes(label).length == 0) revert NoLabel();\n        bytes32 salt = _customSalt(user, label);\n        return _predictDeterministicAddress(salt);\n    }\n\n    // @notice The internal function for deploying a new wallet\n    // @param salt The salt for deploy the address deterministically\n    // @param label The label to indentify deployment in the emitted event\n    // @param commands The optional commands for executing a shortcut after deployment\n    // @param state The optional state for executing a shortcut after deployment\n    function _deploy(\n        bytes32 salt,\n        string memory label,\n        bytes32[] calldata commands,\n        bytes[] calldata state\n    ) internal returns (IEnsoWallet instance) {\n        instance = IEnsoWallet(payable(ensoBeacon.cloneDeterministic(salt)));\n        instance.initialize{ value: msg.value }(msg.sender, salt, commands, state);\n        emit Deployed(instance, label);\n    }\n\n    // @notice Internal function to generate a custom salt using a user address and label\n    // @param user The address of the user\n    // @param label The label to identify the deployment\n    function _customSalt(address user, string memory label) internal pure returns (bytes32) {\n        return keccak256(abi.encode(user, label));\n    }\n\n    // @notice Internal function to derive the deployment address from a salt\n    // @param salt The bytes32 salt to generate the deployment address\n    function _predictDeterministicAddress(bytes32 salt) internal view returns (address payable) {\n        return payable(ensoBeacon.predictDeterministicAddress(\n            salt,\n            address(this)\n        ));\n    }\n\n    // @notice Internal function to support UUPS upgrades of the implementing proxy\n    // @notice newImplementation Address of the new implementation\n    function _authorizeUpgrade(address newImplementation) internal view override {\n        (newImplementation);\n        if (msg.sender != OWNER.getAddress()) revert NotOwner();\n    }\n}"
    },
    {
      "filename": "contracts/EnsoWalletFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\nimport \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\nimport \"./libraries/BeaconClones.sol\";\nimport \"./access/Ownable.sol\";\nimport \"./interfaces/IEnsoWallet.sol\";\n\ncontract EnsoWalletFactory is Ownable, UUPSUpgradeable {\n    using StorageAPI for bytes32;\n    using BeaconClones for address;\n\n    address public immutable ensoBeacon;\n\n    event Deployed(IEnsoWallet instance, string label);\n\n    error AlreadyInit();\n    error NoLabel();\n\n    constructor(address ensoBeacon_) {\n        ensoBeacon = ensoBeacon_;\n    }\n\n    // @notice A function to initialize state on the proxy the delegates to this contract\n    function initialize() external {\n        if (OWNER.getAddress() != address(0)) revert AlreadyInit();\n        OWNER.setAddress(msg.sender);\n    }\n\n    // @notice Deploy a wallet using the msg.sender as the salt\n    // @param commands The optional commands for executing a shortcut after deployment\n    // @param state The optional state for executing a shortcut after deployment\n    function deploy(\n        bytes32[] calldata commands,\n        bytes[] calldata state\n    ) public payable returns (IEnsoWallet) {\n        bytes32 salt = bytes32(uint256(uint160(msg.sender)));\n        return _deploy(salt, \"\", commands, state);\n    }\n\n    // @notice Deploy a wallet using a hash of the msg.sender and a label as the salt\n    // @param label The label to indentify deployment\n    // @param commands The optional commands for executing a shortcut after deployment\n    // @param state The optional state for executing a shortcut after deployment\n    function deployCustom(\n        string memory label,\n        bytes32[] calldata commands,\n        bytes[] calldata state\n    ) public payable returns (IEnsoWallet) {\n        if (bytes(label).length == 0) revert NoLabel();\n        bytes32 salt = _customSalt(msg.sender, label);\n        return _deploy(salt, label, commands, state);\n    }\n\n    // @notice Get the deployment address for the msg.sender\n    function getAddress() public view returns (address payable) {\n        return getUserAddress(msg.sender);\n    }\n\n    // @notice Get the deployment address for the user\n    // @param user The address of the user that is used to determine the deployment address\n    function getUserAddress(address user) public view returns (address payable) {\n        bytes32 salt = bytes32(uint256(uint160(user)));\n        return _predictDeterministicAddress(salt);\n    }\n\n    // @notice Get the deployment address for a user and label\n    // @param user The address of the user that is used to determine the deployment address\n    // @param label The label that is used to determine the deployment address\n    function getCustomAddress(address user, string memory label) external view returns (address payable) {\n        if (bytes(label).length == 0) revert NoLabel();\n        bytes32 salt = _customSalt(user, label);\n        return _predictDeterministicAddress(salt);\n    }\n\n    // @notice The internal function for deploying a new wallet\n    // @param salt The salt for deploy the address deterministically\n    // @param label The label to indentify deployment in the emitted event\n    // @param commands The optional commands for executing a shortcut after deployment\n    // @param state The optional state for executing a shortcut after deployment\n    function _deploy(\n        bytes32 salt,\n        string memory label,\n        bytes32[] calldata commands,\n        bytes[] calldata state\n    ) internal returns (IEnsoWallet instance) {\n        instance = IEnsoWallet(payable(ensoBeacon.cloneDeterministic(salt)));\n        instance.initialize{ value: msg.value }(msg.sender, salt, commands, state);\n        emit Deployed(instance, label);\n    }\n\n    // @notice Internal function to generate a custom salt using a user address and label\n    // @param user The address of the user\n    // @param label The label to identify the deployment\n    function _customSalt(address user, string memory label) internal pure returns (bytes32) {\n        return keccak256(abi.encode(user, label));\n    }\n\n    // @notice Internal function to derive the deployment address from a salt\n    // @param salt The bytes32 salt to generate the deployment address\n    function _predictDeterministicAddress(bytes32 salt) internal view returns (address payable) {\n        return payable(ensoBeacon.predictDeterministicAddress("
    }
  ]
}