{
  "Title": "[M05] Unnecessary input parameters",
  "Content": "In some functions, input parameters have only one acceptable value. If the input parameter does not have this value, the function call will revert.\n\n\nFor example, in [`SuplusAuctionHouse.increaseBidSize`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/SurplusAuctionHouse.sol#L379), the input parameter [`amountToBuy`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/SurplusAuctionHouse.sol#L379) is needed. However, a [strict equality to `bids[id].amountToSell` is required](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/SurplusAuctionHouse.sol#L384).\n\n\nAdditionally, in [`StabilityFeeTreasury.pullFunds`](https://github.com/reflexer-labs/geb/blob/072f00ebd61a6704d7de66fea688479ed97628c3/src/StabilityFeeTreasury.sol#L287), the `token` parameter is [required to be equal to `systemCoin`](https://github.com/reflexer-labs/geb/blob/072f00ebd61a6704d7de66fea688479ed97628c3/src/StabilityFeeTreasury.sol#L293).\n\n\n[`SurplusAuctionHouse.startAuction`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/SurplusAuctionHouse.sol#L154) has the input parameter `initialBid`, but this is always `0` when the function is called from other parts of the code.\n\n\nConsider removing these unnecessary input parameters, and instead enforcing these strict equalities within the function’s logic. This will improve user experience for publicly callable functions by lowering the likelihood of a transaction to revert, and simplifying the user interface. This will also assist auditors and future developers in understanding the intent of the code. If these input parameters are desired to be kept, consider explaining why in the docstrings for the function.\n\n\n***Update:** Acknowledged, and will not fix. Reflexer Labs’ statement for this issue:*\n\n\n\n> \n>  Maker wanted a general interface for `increaseBidSize` and `startAuction` because they’re probably thinking about the future where the implementation may evolve so we’d like to keep them as they are right now. As for `StabilityFeeTreasury.pullFunds` we want to keep token because the `pullFunds(address dstAccount, address token, uint256 wad)` signature will be used in a second iteration of a treasury that can handle any type of token. This way we keep a shared interface.\n> \n> \n> \n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/SurplusAuctionHouse.sol",
      "content": "/// SurplusAuctionHouse.sol\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.7;\n\nabstract contract SAFEEngineLike {\n    function transferInternalCoins(address,address,uint) virtual external;\n    function coinBalance(address) virtual external view returns (uint);\n    function approveSAFEModification(address) virtual external;\n    function denySAFEModification(address) virtual external;\n}\nabstract contract TokenLike {\n    function approve(address, uint) virtual public returns (bool);\n    function balanceOf(address) virtual public view returns (uint);\n    function move(address,address,uint) virtual external;\n    function burn(address,uint) virtual external;\n}\n\n/*\n   This thing lets you auction some coins in return for protocol tokens\n*/\n\ncontract PreSettlementSurplusAuctionHouse {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"PreSettlementSurplusAuctionHouse/account-not-authorized\");\n        _;\n    }\n\n    // --- Data ---\n    struct Bid {\n        // Bid size (how many protocol tokens are offered per system coins sold)\n        uint256 bidAmount;                                                            // [rad]\n        // How many system coins are sold in an auction\n        uint256 amountToSell;                                                         // [wad]\n        // Who the high bidder is\n        address highBidder;\n        // When the latest bid expires and the auction can be settled\n        uint48  bidExpiry;                                                            // [unix epoch time]\n        // Hard deadline for the auction after which no more bids can be placed\n        uint48  auctionDeadline;                                                      // [unix epoch time]\n    }\n\n    // Bid data for each separate auction\n    mapping (uint => Bid) public bids;\n\n    // SAFE database\n    SAFEEngineLike       public safeEngine;\n    // Protocol token address\n    TokenLike            public protocolToken;\n\n    uint256  constant ONE = 1.00E18;                                                  // [wad]\n    // Minimum bid increase compared to the last bid in order to take the new one in consideration\n    uint256  public   bidIncrease = 1.05E18;                                          // [wad]\n    // How long the auction lasts after a new bid is submitted\n    uint48   public   bidDuration = 3 hours;                                          // [seconds]\n    // Total length of the auction\n    uint48   public   totalAuctionLength = 2 days;                                    // [seconds]\n    // Number of auctions started up until now\n    uint256  public   auctionsStarted = 0;\n    // Whether the contract is settled or not\n    uint256  public   contractEnabled;\n\n    bytes32 public constant AUCTION_HOUSE_TYPE = bytes32(\"SURPLUS\");\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event ModifyParameters(bytes32 parameter, uint data);\n    event RestartAuction(uint id, uint auctionDeadline);\n    event IncreaseBidSize(uint id, address highBidder, uint amountToBuy, uint bid, uint bidExpiry);\n    event StartAuction(\n        uint256 id,\n        uint256 auctionsStarted,\n        uint256 amountToSell,\n        uint256 initialBid,\n        uint256 auctionDeadline\n    );\n    event SettleAuction(uint id);\n    event DisableContract();\n    event TerminateAuctionPrematurely(uint id, address sender, address highBidder, uint bidAmount);\n\n    // --- Init ---\n    constructor(address safeEngine_, address protocolToken_) public {\n        authorizedAccounts[msg.sender] = 1;\n        safeEngine = SAFEEngineLike(safeEngine_);\n        protocolToken = TokenLike(protocolToken_);\n        contractEnabled = 1;\n        emit AddAuthorization(msg.sender);\n    }\n\n    // --- Math ---\n    function addUint48(uint48 x, uint48 y) internal pure returns (uint48 z) {\n        require((z = x + y) >= x);\n    }\n    function multiply(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n\n    // --- Admin ---\n    /**\n     * @notice Modify auction parameters\n     * @param parameter The name of the parameter modified\n     * @param data New value for the parameter\n     */\n    function modifyParameters(bytes32 parameter, uint data) external isAuthorized {\n        if (parameter == \"bidIncrease\") bidIncrease = data;\n        else if (parameter == \"bidDuration\") bidDuration = uint48(data);\n        else if (parameter == \"totalAuctionLength\") totalAuctionLength = uint48(data);\n        else revert(\"PreSettlementSurplusAuctionHouse/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, data);\n    }\n\n    // --- Auction ---\n    /**\n     * @notice Start a new surplus auction\n     * @param amountToSell Total amount of system coins to sell (wad)\n     * @param initialBid Initial protocol token bid (rad)\n     */\n    function startAuction(uint amountToSell, uint initialBid) external isAuthorized returns (uint id) {\n        require(contractEnabled == 1, \"PreSettlementSurplusAuctionHouse/contract-not-enabled\");\n        require(auctionsStarted < uint(-1), \"PreSettlementSurplusAuctionHouse/overflow\");\n        id = ++auctionsStarted;\n\n        bids[id].bidAmount = initialBid;\n        bids[id].amountToSell = amountToSell;\n        bids[id].highBidder = msg.sender;\n        bids[id].auctionDeadline = addUint48(uint48(now), totalAuctionLength);\n\n        safeEngine.transferInternalCoins(msg.sender, address(this), amountToSell);\n\n        emit StartAuction(id, auctionsStarted, amountToSell, initialBid, bids[id].auctionDeadline);\n    }\n    /**\n     * @notice Restart an auction if no bids were submitted for it\n     * @param id ID of the auction to restart\n     */\n    function restartAuction(uint id) external {\n        require(bids[id].auctionDeadline < now, \"PreSettlementSurplusAuctionHouse/not-finished\");\n        require(bids[id].bidExpiry == 0, \"PreSettlementSurplusAuctionHouse/bid-already-placed\");\n        bids[id].auctionDeadline = addUint48(uint48(now), totalAuctionLength);\n        emit RestartAuction(id, bids[id].auctionDeadline);\n    }\n    /**\n     * @notice Submit a higher protocol token bid for the same amount of system coins\n     * @param id ID of the auction you want to submit the bid for\n     * @param amountToBuy Amount of system coins to buy (wad)\n     * @param bid New bid submitted (rad)\n     */\n    function increaseBidSize(uint id, uint amountToBuy, uint bid) external {\n        require(contractEnabled == 1, \"PreSettlementSurplusAuctionHouse/contract-not-enabled\");\n        require(bids[id].highBidder != address(0), \"PreSettlementSurplusAuctionHouse/high-bidder-not-set\");\n        require(bids[id].bidExpiry > now || bids[id].bidExpiry == 0, \"PreSettlementSurplusAuctionHouse/bid-already-expired\");\n        require(bids[id].auctionDeadline > now, \"PreSettlementSurplusAuctionHouse/auction-already-expired\");\n\n        require(amountToBuy == bids[id].amountToSell, \"PreSettlementSurplusAuctionHouse/amounts-not-matching\");\n        require(bid > bids[id].bidAmount, \"PreSettlementSurplusAuctionHouse/bid-not-higher\");\n        require(multiply(bid, ONE) >= multiply(bidIncrease, bids[id].bidAmount), \"PreSettlementSurplusAuctionHouse/insufficient-increase\");\n\n        if (msg.sender != bids[id].highBidder) {\n            protocolToken.move(msg.sender, bids[id].highBidder, bids[id].bidAmount);\n            bids[id].highBidder = msg.sender;\n        }\n        protocolToken.move(msg.sender, address(this), bid - bids[id].bidAmount);\n\n        bids[id].bidAmount = bid;\n        bids[id].bidExpiry = addUint48(uint48(now), bidDuration);\n\n        emit IncreaseBidSize(id, msg.sender, amountToBuy, bid, bids[id].bidExpiry);\n    }\n    /**\n     * @notice Settle/finish an auction\n     * @param id ID of the auction to settle\n     */\n    function settleAuction(uint id) external {\n        require(contractEnabled == 1, \"PreSettlementSurplusAuctionHouse/contract-not-enabled\");\n        require(bids[id].bidExpiry != 0 && (bids[id].bidExpiry < now || bids[id].auctionDeadline < now), \"PreSettlementSurplusAuctionHouse/not-finished\");\n        safeEngine.transferInternalCoins(address(this), bids[id].highBidder, bids[id].amountToSell);\n        protocolToken.burn(address(this), bids[id].bidAmount);\n        delete bids[id];\n        emit SettleAuction(id);\n    }\n    /**\n    * @notice Disable the auction house (usually called by AccountingEngine)\n    **/\n    function disableContract() external isAuthorized {\n        contractEnabled = 0;\n        safeEngine.transferInternalCoins(address(this), msg.sender, safeEngine.coinBalance(address(this)));\n        emit DisableContract();\n    }\n    /**\n     * @notice Terminate an auction prematurely.\n     * @param id ID of the auction to settle/terminate\n     */\n    function terminateAuctionPrematurely(uint id) external {\n        require(contractEnabled == 0, \"PreSettlementSurplusAuctionHouse/contract-still-enabled\");\n        require(bids[id].highBidder != address(0), \"PreSettlementSurplusAuctionHouse/high-bidder-not-set\");\n        protocolToken.move(address(this), bids[id].highBidder, bids[id].bidAmount);\n        emit TerminateAuctionPrematurely(id, msg.sender, bids[id].highBidder, bids[id].bidAmount);\n        delete bids[id];\n    }\n}\n\ncontract PostSettlementSurplusAuctionHouse {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"PostSettlementSurplusAuctionHouse/account-not-authorized\");\n        _;\n    }\n\n    // --- Data ---\n    struct Bid {\n        // Bid size (how many protocol tokens are offered per system coins sold)\n        uint256 bidAmount;                                                        // [rad]\n        // How many system coins are sold in an auction\n        uint256 amountToSell;                                                     // [wad]\n        // Who the high bidder is\n        address highBidder;\n        // When the latest bid expires and the auction can be settled\n        uint48  bidExpiry;                                                        // [unix epoch time]\n        // Hard deadline for the auction after which no more bids can be placed\n        uint48  auctionDeadline;                                                  // [unix epoch time]\n    }\n\n    // Bid data for each separate auction\n    mapping (uint => Bid) public bids;\n\n    // SAFE database\n    SAFEEngineLike        public safeEngine;\n    // Protocol token address\n    TokenLike            public protocolToken;\n\n    uint256  constant ONE = 1.00E18;                                              // [wad]\n    // Minimum bid increase compared to the last bid in order to take the new one in consideration\n    uint256  public   bidIncrease = 1.05E18;                                      // [wad]\n    // How long the auction lasts after a new bid is submitted\n    uint48   public   bidDuration = 3 hours;                                      // [seconds]\n    // Total length of the auction\n    uint48   public   totalAuctionLength = 2 days;                                // [seconds]\n    // Number of auctions started up until now\n    uint256  public   auctionsStarted = 0;\n\n    bytes32 public constant AUCTION_HOUSE_TYPE = bytes32(\"SURPLUS\");\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event ModifyParameters(bytes32 parameter, uint data);\n    event RestartAuction(uint id, uint auctionDeadline);\n    event IncreaseBidSize(uint id, address highBidder, uint amountToBuy, uint bid, uint bidExpiry);\n    event StartAuction(\n        uint256 id,\n        uint256 auctionsStarted,\n        uint256 amountToSell,\n        uint256 initialBid,\n        uint256 auctionDeadline\n    );\n    event SettleAuction(uint id);\n\n    // --- Init ---\n    constructor(address safeEngine_, address protocolToken_) public {\n        authorizedAccounts[msg.sender] = 1;\n        safeEngine = SAFEEngineLike(safeEngine_);\n        protocolToken = TokenLike(protocolToken_);\n        emit AddAuthorization(msg.sender);\n    }\n\n    // --- Math ---\n    function addUint48(uint48 x, uint48 y) internal pure returns (uint48 z) {\n        require((z = x + y) >= x);\n    }\n    function multiply(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n\n    // --- Admin ---\n    /**\n     * @notice Modify auction parameters\n     * @param parameter The name of the parameter modified\n     * @param data New value for the parameter\n     */\n    function modifyParameters(bytes32 parameter, uint data) external isAuthorized {\n        if (parameter == \"bidIncrease\") bidIncrease = data;\n        else if (parameter == \"bidDuration\") bidDuration = uint48(data);\n        else if (parameter == \"totalAuctionLength\") totalAuctionLength = uint48(data);\n        else revert(\"PostSettlementSurplusAuctionHouse/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, data);\n    }\n\n    // --- Auction ---\n    /**\n     * @notice Start a new surplus auction\n     * @param amountToSell Total amount of system coins to sell (wad)\n     * @param initialBid Initial protocol token bid (rad)\n     */\n    function startAuction(uint amountToSell, uint initialBid) external isAuthorized returns (uint id) {\n        require(auctionsStarted < uint(-1), \"PostSettlementSurplusAuctionHouse/overflow\");\n        id = ++auctionsStarted;\n\n        bids[id].bidAmount = initialBid;\n        bids[id].amountToSell = amountToSell;\n        bids[id].highBidder = msg.sender;\n        bids[id].auctionDeadline = addUint48(uint48(now), totalAuctionLength);\n\n        safeEngine.transferInternalCoins(msg.sender, address(this), amountToSell);\n\n        emit StartAuction(id, auctionsStarted, amountToSell, initialBid, bids[id].auctionDeadline);\n    }\n    /**\n     * @notice Restart an auction if no bids were submitted for it\n     * @param id ID of the auction to restart\n     */\n    function restartAuction(uint id) external {\n        require(bids[id].auctionDeadline < now, \"PostSettlementSurplusAuctionHouse/not-finished\");\n        require(bids[id].bidExpiry == 0, \"PostSettlementSurplusAuctionHouse/bid-already-placed\");\n        bids[id].auctionDeadline = addUint48(uint48(now), totalAuctionLength);\n        emit RestartAuction(id, bids[id].auctionDeadline);\n    }\n    /**\n     * @notice Submit a higher protocol token bid for the same amount of system coins\n     * @param id ID of the auction you want to submit the bid for\n     * @param amountToBuy Amount of system coins to buy (wad)\n     * @param bid New bid submitted (rad)\n     */\n    function increaseBidSize(uint id, uint amountToBuy, uint bid) external {\n        require(bids[id].highBidder != address(0), \"PostSettlementSurplusAuctionHouse/high-bidder-not-set\");\n        require(bids[id].bidExpiry > now || bids[id].bidExpiry == 0, \"PostSettlementSurplusAuctionHouse/bid-already-expired\");\n        require(bids[id].auctionDeadline > now, \"PostSettlementSurplusAuctionHouse/auction-already-expired\");\n\n        require(amountToBuy == bids[id].amountToSell, \"PostSettlementSurplusAuctionHouse/amounts-not-matching\");\n        require(bid > bids[id].bidAmount, \"PostSettlementSurplusAuctionHouse/bid-not-higher\");\n        require(multiply(bid, ONE) >= multiply(bidIncrease, bids[id].bidAmount), \"PostSettlementSurplusAuctionHouse/insufficient-increase\");\n\n        if (msg.sender != bids[id].highBidder) {\n            protocolToken.move(msg.sender, bids[id].highBidder, bids[id].bidAmount);\n            bids[id].highBidder = msg.sender;\n        }\n        protocolToken.move(msg.sender, address(this), bid - bids[id].bidAmount);\n\n        bids[id].bidAmount = bid;\n        bids[id].bidExpiry = addUint48(uint48(now), bidDuration);\n\n        emit IncreaseBidSize(id, msg.sender, amountToBuy, bid, bids[id].bidExpiry);\n    }\n    /**\n     * @notice Settle/finish an auction\n     * @param id ID of the auction to settle\n     */\n    function settleAuction(uint id) external {\n        require(bids[id].bidExpiry != 0 && (bids[id].bidExpiry < now || bids[id].auctionDeadline < now), \"PostSettlementSurplusAuctionHouse/not-finished\");\n        safeEngine.transferInternalCoins(address(this), bids[id].highBidder, bids[id].amountToSell);\n        protocolToken.burn(address(this), bids[id].bidAmount);\n        delete bids[id];\n        emit SettleAuction(id);\n    }\n}"
    },
    {
      "filename": "src/StabilityFeeTreasury.sol",
      "content": "/// StabilityFeeTreasury.sol\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>, 2020 Reflexer Labs, INC\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.7;\n\nabstract contract SAFEEngineLike {\n    function approveSAFEModification(address) virtual external;\n    function denySAFEModification(address) virtual external;\n    function transferInternalCoins(address,address,uint) virtual external;\n    function coinBalance(address) virtual public view returns (uint);\n}\nabstract contract SystemCoinLike {\n    function balanceOf(address) virtual public view returns (uint);\n    function approve(address, uint) virtual public returns (uint);\n    function transfer(address,uint) virtual public returns (bool);\n    function transferFrom(address,address,uint) virtual public returns (bool);\n}\nabstract contract CoinJoinLike {\n    function systemCoin() virtual public view returns (address);\n    function join(address, uint) virtual external;\n    function exit(address, uint) virtual external;\n}\n\ncontract StabilityFeeTreasury {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"StabilityFeeTreasury/account-not-authorized\");\n        _;\n    }\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event ModifyParameters(bytes32 parameter, address addr);\n    event ModifyParameters(bytes32 parameter, uint val);\n    event DisableContract();\n    event SetTotalAllowance(address account, uint rad);\n    event SetPerBlockAllowance(address account, uint rad);\n    event GiveFunds(address account, uint rad, uint expensesAccumulator);\n    event TakeFunds(address account, uint rad);\n    event PullFunds(address sender, address dstAccount, address token, uint rad, uint expensesAccumulator);\n    event TransferSurplusFunds(address accountingEngine, uint fundsToTransfer);\n\n    // --- Structs ---\n    struct Allowance {\n        uint total;\n        uint perBlock;\n    }\n\n    mapping(address => Allowance) private allowance;\n    mapping(address => mapping(uint => uint)) public pulledPerBlock;\n\n    SAFEEngineLike  public safeEngine;\n    SystemCoinLike  public systemCoin;\n    CoinJoinLike    public coinJoin;\n\n    address public accountingEngine;\n\n    uint256 public treasuryCapacity;           // max amount of SF that can be kept in treasury                        [rad]\n    uint256 public minimumFundsRequired;       // minimum amount of SF that must be kept in the treasury at all times  [rad]\n    uint256 public expensesMultiplier;         // multiplier for expenses                                              [hundred]\n    uint256 public surplusTransferDelay;       // minimum time between transferSurplusFunds calls                      [seconds]\n    uint256 public expensesAccumulator;        // expenses accumulator                                                 [rad]\n    uint256 public accumulatorTag;             // latest tagged accumulator price                                      [rad]\n    uint256 public latestSurplusTransferTime;  // latest timestamp when transferSurplusFunds was called                [seconds]\n    uint256 public contractEnabled;\n\n    modifier accountNotTreasury(address account) {\n        require(account != address(this), \"StabilityFeeTreasury/account-cannot-be-treasury\");\n        _;\n    }\n\n    constructor(\n        address safeEngine_,\n        address accountingEngine_,\n        address coinJoin_\n    ) public {\n        require(address(CoinJoinLike(coinJoin_).systemCoin()) != address(0), \"StabilityFeeTreasury/null-system-coin\");\n        require(accountingEngine_ != address(this), \"StabilityFeeTreasury/accounting-engine-cannot-be-treasury\");\n        authorizedAccounts[msg.sender] = 1;\n        safeEngine                = SAFEEngineLike(safeEngine_);\n        accountingEngine          = accountingEngine_;\n        coinJoin                  = CoinJoinLike(coinJoin_);\n        systemCoin                = SystemCoinLike(coinJoin.systemCoin());\n        latestSurplusTransferTime = now;\n        expensesMultiplier        = HUNDRED;\n        contractEnabled           = 1;\n        systemCoin.approve(address(coinJoin), uint(-1));\n        safeEngine.approveSAFEModification(address(coinJoin));\n        emit AddAuthorization(msg.sender);\n    }\n\n    // --- Math ---\n    uint256 constant HUNDRED = 10 ** 2;\n    uint256 constant RAY     = 10 ** 27;\n\n    function addition(uint x, uint y) internal pure returns (uint z) {\n        z = x + y;\n        require(z >= x);\n    }\n    function addition(int x, int y) internal pure returns (int z) {\n        z = x + y;\n        if (y <= 0) require(z <= x);\n        if (y  > 0) require(z > x);\n    }\n    function subtract(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n    function subtract(int x, int y) internal pure returns (int z) {\n        z = x - y;\n        require(y <= 0 || z <= x);\n        require(y >= 0 || z >= x);\n    }\n    function multiply(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n    function divide(uint x, uint y) internal pure returns (uint z) {\n        require(y > 0);\n        z = x / y;\n        require(z <= x);\n    }\n\n    // --- Administration ---\n    /**\n     * @notice Modify contract addresses\n     * @param parameter The name of the contract whose address will be changed\n     * @param addr New address for the contract\n     */\n    function modifyParameters(bytes32 parameter, address addr) external isAuthorized {\n        require(contractEnabled == 1, \"StabilityFeeTreasury/contract-not-enabled\");\n        require(addr != address(0), \"StabilityFeeTreasury/null-addr\");\n        if (parameter == \"accountingEngine\") {\n          require(addr != address(this), \"StabilityFeeTreasury/accounting-engine-cannot-be-treasury\");\n          accountingEngine = addr;\n        }\n        else revert(\"StabilityFeeTreasury/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, addr);\n    }\n    /**\n     * @notice Modify uint256 parameters\n     * @param parameter The name of the parameter to modify\n     * @param val New parameter value\n     */\n    function modifyParameters(bytes32 parameter, uint val) external isAuthorized {\n        require(contractEnabled == 1, \"StabilityFeeTreasury/not-live\");\n        if (parameter == \"expensesMultiplier\") expensesMultiplier = val;\n        else if (parameter == \"treasuryCapacity\") {\n          require(val >= minimumFundsRequired, \"StabilityFeeTreasury/capacity-lower-than-min-funds\");\n          treasuryCapacity = val;\n        }\n        else if (parameter == \"minimumFundsRequired\") {\n          require(val <= treasuryCapacity, \"StabilityFeeTreasury/min-funds-higher-than-capacity\");\n          minimumFundsRequired = val;\n        }\n        else if (parameter == \"surplusTransferDelay\") surplusTransferDelay = val;\n        else revert(\"StabilityFeeTreasury/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, val);\n    }\n    /**\n     * @notice Disable this contract (normally called by GlobalSettlement)\n     */\n    function disableContract() external isAuthorized {\n        require(contractEnabled == 1, \"StabilityFeeTreasury/already-disabled\");\n        contractEnabled = 0;\n        if (systemCoin.balanceOf(address(this)) > 0) {\n          coinJoin.join(address(this), systemCoin.balanceOf(address(this)));\n        }\n        safeEngine.transferInternalCoins(address(this), accountingEngine, safeEngine.coinBalance(address(this)));\n        emit DisableContract();\n    }\n\n    // --- Utils ---\n    function either(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := or(x, y)}\n    }\n    function both(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := and(x, y)}\n    }\n    /**\n     * @notice Join all ERC20 system coins that the treasury has inside SAFEEngine\n     */\n    function joinAllCoins() internal {\n        if (systemCoin.balanceOf(address(this)) > 0) {\n          coinJoin.join(address(this), systemCoin.balanceOf(address(this)));\n        }\n    }\n\n    // --- Getters ---\n    function getAllowance(address account) public view returns (uint256, uint256) {\n        return (allowance[account].total, allowance[account].perBlock);\n    }\n\n    // --- SF Transfer Allowance ---\n    /**\n     * @notice Modify an address' total allowance in order to withdraw SF from the treasury\n     * @param account The approved address\n     * @param rad The total approved amount of SF to withdraw (number with 45 decimals)\n     */\n    function setTotalAllowance(address account, uint rad) external isAuthorized accountNotTreasury(account) {\n        require(account != address(0), \"StabilityFeeTreasury/null-account\");\n        allowance[account].total = rad;\n        emit SetTotalAllowance(account, rad);\n    }\n    /**\n     * @notice Modify an address' per block allowance in order to withdraw SF from the treasury\n     * @param account The approved address\n     * @param rad The per block approved amount of SF to withdraw (number with 45 decimals)\n     */\n    function setPerBlockAllowance(address account, uint rad) external isAuthorized accountNotTreasury(account) {\n        require(account != address(0), \"StabilityFeeTreasury/null-account\");\n        allowance[account].perBlock = rad;\n        emit SetPerBlockAllowance(account, rad);\n    }\n\n    // --- Stability Fee Transfer (Governance) ---\n    /**\n     * @notice Governance transfers SF to an address\n     * @param account Address to transfer SF to\n     * @param rad Amount of internal system coins to transfer (a number with 45 decimals)\n     */\n    function giveFunds(address account, uint rad) external isAuthorized accountNotTreasury(account) {\n        require(account != address(0), \"StabilityFeeTreasury/null-account\");\n\n        joinAllCoins();\n        require(safeEngine.coinBalance(address(this)) >= rad, \"StabilityFeeTreasury/not-enough-funds\");\n\n        if (account != accountingEngine) {\n          expensesAccumulator = addition(expensesAccumulator, rad);\n        }\n\n        safeEngine.transferInternalCoins(address(this), account, rad);\n        emit GiveFunds(account, rad, expensesAccumulator);\n    }\n    /**\n     * @notice Governance takes funds from an address\n     * @param account Address to take system coins from\n     * @param rad Amount of internal system coins to take from the account (a number with 45 decimals)\n     */\n    function takeFunds(address account, uint rad) external isAuthorized accountNotTreasury(account) {\n        safeEngine.transferInternalCoins(account, address(this), rad);\n        emit TakeFunds(account, rad);\n    }\n\n    // --- Stability Fee Transfer (Approved Accounts) ---\n    /**\n     * @notice Pull stability fees from the treasury (if your allowance permits)\n     * @param dstAccount Address to transfer funds to\n     * @param token Address of the token to transfer (in this case it must be the address of the ERC20 system coin).\n     *              Used only to adhere to a standard for automated, on-chain treasuries\n     * @param wad Amount of system coins (SF) to transfer (expressed as an 18 decimal number but the contract will transfer\n              internal system coins that have 45 decimals)\n     */\n    function pullFunds(address dstAccount, address token, uint wad) external {\n        if (dstAccount == address(this)) return;\n\t      require(allowance[msg.sender].total >= wad, \"StabilityFeeTreasury/not-allowed\");\n        require(dstAccount != address(0), \"StabilityFeeTreasury/null-dst\");\n        require(dstAccount != accountingEngine, \"StabilityFeeTreasury/dst-cannot-be-accounting\");\n        require(wad > 0, \"StabilityFeeTreasury/null-transfer-amount\");\n        require(token == address(systemCoin), \"StabilityFeeTreasury/token-unavailable\");\n        if (allowance[msg.sender].perBlock > 0) {\n          require(addition(pulledPerBlock[msg.sender][block.number], multiply(wad, RAY)) <= allowance[msg.sender].perBlock, \"StabilityFeeTreasury/per-block-limit-exceeded\");\n        }\n\n        pulledPerBlock[msg.sender][block.number] = addition(pulledPerBlock[msg.sender][block.number], multiply(wad, RAY));\n\n        joinAllCoins();\n        require(safeEngine.coinBalance(address(this)) >= multiply(wad, RAY), \"StabilityFeeTreasury/not-enough-funds\");\n\n        // Update allowance and accumulator\n        allowance[msg.sender].total = subtract(allowance[msg.sender].total, multiply(wad, RAY));\n        expensesAccumulator         = addition(expensesAccumulator, multiply(wad, RAY));\n\n        // Transfer money\n        safeEngine.transferInternalCoins(address(this), dstAccount, multiply(wad, RAY));\n\n        emit PullFunds(msg.sender, dstAccount, token, multiply(wad, RAY), expensesAccumulator);\n    }\n\n    // --- Treasury Maintenance ---\n    /**\n     * @notice Transfer surplus stability fees to the AccountingEngine. This is here to make sure that the treasury\n               doesn't accumulate too many fees that it doesn't even need in order to pay for allowances. It ensures\n               t"
    }
  ]
}