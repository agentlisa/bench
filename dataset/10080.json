{
  "Title": "[M-01] Missing cap on `LicenseFee`",
  "Content": "_Submitted by gzeon, also found by 0x0x0x and TomFrenchBlockchain_\n\nThere is no cap on `LicenseFee`. While change of `LicenseFee` is under 1 day timelock, introducing a\\\n`maxLicenseFee` can improve credibility by removing the \"rug\" vector. There is a `minLicenseFee` in the contracts, while imo make little sense to have `minLicenseFee` but not `maxLicenseFee`.\n\nAn incorrectly set `LicenseFee` can potentially lead to over/underflow in [Basket.sol#L140-141](https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Basket.sol#L140-141) which is used in most of the function.\n\n### Proof of Concept\n\n[Basket.sol#L177](https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Basket.sol#L177)<br>\n[Factory.sol#L77](https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Factory.sol#L77)<br>\n[Basket.sol#L49](https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Basket.sol#L49)\n\n### Recommended Mitigation Steps\n\nDefine a `maxLicenseFee`\n\n**[frank-beard (Kuiper) acknowledged, but disagreed with High severity and commented](https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/154#issuecomment-1048121652):**\n> Generally it is intended for the publishers to act correctly and the timelock is intended to prevent incorrect values from making it all the way through, however there is validity in reducing how the fee can be modified, such as reducing how much any one fee change can change the fee. I would consider this a low risk issue.\n\n**[0xleastwood (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/154#issuecomment-1079621078):**\n> It seems like changes to `licenseFee` could potentially brick the contract as `handleFees()` underflows, preventing users from minting/burning tokens. I'd deem this as `medium` severity due to compromised protocol availability.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2021-12-defiProtocol",
  "Code": [
    {
      "filename": "contracts/contracts/Basket.sol",
      "content": "pragma solidity =0.8.7;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport './interfaces/IAuction.sol';\nimport \"./interfaces/IBasket.sol\";\nimport \"./interfaces/IFactory.sol\";\nimport \"hardhat/console.sol\";\n\n//TODO: add revert reasons or v8 custom errors back in\ncontract Basket is IBasket, ERC20Upgradeable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    //TODO: recommend using block timestamp instead of block numbers here\n    uint256 public constant TIMELOCK_DURATION = 1 days; // 1 day\n    uint256 public constant ONE_YEAR = 365.25 days;\n    uint256 private constant BASE = 1e18;\n\n    uint256 public maxSupply;\n\n    address public publisher;\n    uint256 public licenseFee;\n\n    IFactory public override factory;\n    IAuction public override auction;\n\n    uint256 public override ibRatio;\n\n    PendingPublisher public pendingPublisher;\n    PendingLicenseFee public pendingLicenseFee;\n    PendingWeights public pendingWeights;\n    PendingMaxSupply public pendingMaxSupply;\n\n    address[] public tokens;\n    uint256[] public weights;\n\n    uint256 public override lastFee;\n\n    bool public override initialized;\n\n    function initialize(IFactory.Proposal memory proposal, IAuction auction_) external override {\n        require(address(factory) == address(0));\n        require(!initialized);\n\n        publisher = proposal.proposer;\n        licenseFee = proposal.licenseFee;\n        factory = IFactory(msg.sender);\n        auction = auction_;\n        ibRatio = BASE;\n        tokens = proposal.tokens;\n        weights = proposal.weights;\n        maxSupply = proposal.maxSupply;\n        approveUnderlying(address(auction));\n\n        __ERC20_init(proposal.tokenName, proposal.tokenSymbol);\n\n        initialized = true;\n    }\n\n    function getPendingWeights() external override view returns (address[] memory, uint256[] memory, uint256) {\n        return (pendingWeights.tokens, pendingWeights.weights, pendingWeights.minIbRatio);\n    }\n\n    function validateWeights(address[] memory _tokens, uint256[] memory _weights) public override pure {\n        require(_tokens.length > 0);\n        require(_tokens.length == _weights.length);\n        uint256 length = _tokens.length;\n        address[] memory tokenList = new address[](length);\n\n        // check uniqueness of tokens and not token(0)\n\n        for (uint i = 0; i < length; i++) {\n            require(_tokens[i] != address(0));\n            require(_weights[i] > 0);\n\n            for (uint256 x = 0; x < tokenList.length; x++) {\n                require(_tokens[i] != tokenList[x]);\n            }\n\n            tokenList[i] = _tokens[i];\n        }\n    }\n\n    function mint(uint256 amount) public override {\n        mintTo(amount, msg.sender);\n    }\n\n    function mintTo(uint256 amount, address to) public nonReentrant override {\n        require(auction.auctionOngoing() == false);\n        require(amount > 0);\n        uint256 startSupply = totalSupply();\n        require(startSupply + amount <= maxSupply);\n\n        handleFees(startSupply);\n\n        pullUnderlying(amount, msg.sender);\n\n        _mint(to, amount);\n\n        require(totalSupply() <= maxSupply);\n\n        emit Minted(to, amount);\n    }\n\n    function burn(uint256 amount) public nonReentrant override {\n        require(auction.auctionOngoing() == false);\n        require(amount > 0);\n\n        uint256 startSupply = totalSupply();\n        handleFees(startSupply);\n\n        pushUnderlying(amount, msg.sender);\n        _burn(msg.sender, amount);\n        \n        emit Burned(msg.sender, amount);\n    }\n\n    function auctionBurn(uint256 amount) onlyAuction nonReentrant external override {\n        uint256 startSupply = totalSupply();\n        handleFees(startSupply);\n        _burn(msg.sender, amount);\n\n        uint256 newIbRatio = ibRatio * startSupply / (startSupply - amount);\n        ibRatio = newIbRatio;\n\n        emit NewIBRatio(newIbRatio);\n        emit Burned(msg.sender, amount);\n    }\n\n    function handleFees(uint256 startSupply) private {\n        if (lastFee == 0) {\n            lastFee = block.timestamp;\n        } else if (startSupply == 0) {\n            return;\n        } else {\n            uint256 timeDiff = (block.timestamp - lastFee);\n            uint256 feePct = timeDiff * licenseFee / ONE_YEAR;\n            uint256 fee = startSupply * feePct / (BASE - feePct);\n\n\n            _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);\n            _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);\n            lastFee = block.timestamp;\n\n            uint256 newIbRatio = ibRatio * startSupply / totalSupply();\n            ibRatio = newIbRatio;\n\n            emit NewIBRatio(ibRatio);\n        }\n    }\n\n    // changes publisher\n    // timelocked\n    function changePublisher(address newPublisher) onlyPublisher public override {\n        require(newPublisher != address(0));\n\n        if (pendingPublisher.publisher != address(0) && pendingPublisher.publisher == newPublisher) {\n            require(block.timestamp >= pendingPublisher.timestamp + TIMELOCK_DURATION);\n            publisher = newPublisher;\n\n            pendingPublisher.publisher = address(0);\n\n            emit ChangedPublisher(publisher);\n        } else {\n            pendingPublisher.publisher = newPublisher;\n            pendingPublisher.timestamp = block.timestamp;\n\n            emit NewPublisherSubmitted(newPublisher);\n        }\n    }\n\n    //changes licenseFee\n    // timelocked\n    function changeLicenseFee(uint256 newLicenseFee) onlyPublisher public override {\n        require(newLicenseFee >= factory.minLicenseFee() && newLicenseFee != licenseFee);\n        if (pendingLicenseFee.licenseFee != 0 && pendingLicenseFee.licenseFee == newLicenseFee) {\n            require(block.timestamp >= pendingLicenseFee.timestamp + TIMELOCK_DURATION);\n            licenseFee = newLicenseFee;\n\n            pendingLicenseFee.licenseFee = 0;\n\n            emit ChangedLicenseFee(licenseFee);\n        } else {\n            pendingLicenseFee.licenseFee = newLicenseFee;\n            pendingLicenseFee.timestamp = block.timestamp;\n\n            emit NewLicenseFeeSubmitted(newLicenseFee);\n        }\n    }\n\n    //changes maxSupply\n    // timelocked\n    function setNewMaxSupply(uint256 newMaxSupply) onlyPublisher public override {\n        require(newMaxSupply > totalSupply());\n\n        if (pendingMaxSupply.maxSupply != 0 && pendingMaxSupply.maxSupply == newMaxSupply) {\n            require(block.timestamp >= pendingMaxSupply.timestamp + TIMELOCK_DURATION);\n            maxSupply = newMaxSupply;\n\n            pendingMaxSupply.maxSupply = 0;\n\n            emit ChangedMaxSupply(newMaxSupply);\n        } else {\n            pendingMaxSupply.maxSupply = newMaxSupply;\n            pendingMaxSupply.timestamp = block.timestamp;\n\n            emit NewMaxSupplySubmitted(newMaxSupply);\n        }\n    }\n\n    // publish new index\n    // timelocked\n    function publishNewIndex(address[] memory _tokens, uint256[] memory _weights, uint256 _minIbRatio) onlyPublisher public override {\n        validateWeights(_tokens, _weights);\n\n        if (pendingWeights.pending) {\n            require(block.timestamp >= pendingWeights.timestamp + TIMELOCK_DURATION);\n            if (auction.auctionOngoing() == false) {\n                auction.startAuction();\n\n                emit PublishedNewIndex(publisher);\n            } else if (auction.hasBonded()) {\n\n            } else {\n                auction.killAuction();\n\n                pendingWeights.tokens = _tokens;\n                pendingWeights.weights = _weights;\n                pendingWeights.timestamp = block.timestamp;\n                pendingWeights.minIbRatio = _minIbRatio;\n            }\n        } else {\n            pendingWeights.pending = true;\n            pendingWeights.tokens = _tokens;\n            pendingWeights.weights = _weights;\n            pendingWeights.timestamp = block.timestamp;\n            pendingWeights.minIbRatio = _minIbRatio;\n\n            emit NewIndexSubmitted();\n        }\n    }\n\n    function setNewWeights() onlyAuction external override {\n        tokens = pendingWeights.tokens;\n        weights = pendingWeights.weights;\n        pendingWeights.pending = false;\n\n        approveUnderlying(address(auction));\n\n        emit WeightsSet();\n    }\n\n    // delete pending index\n    function deleteNewIndex() public override {\n        require(msg.sender == publisher || msg.sender == address(auction));\n        require(auction.auctionOngoing() == false);\n\n        pendingWeights.pending = false;\n\n        emit DeletedNewIndex(msg.sender);\n    }\n\n    function updateIBRatio(uint256 newRatio) onlyAuction external override returns (uint256) {\n        ibRatio = newRatio;\n\n        emit NewIBRatio(ibRatio);\n\n        return ibRatio;\n    }\n\n    function approveUnderlying(address spender) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            IERC20(tokens[i]).safeApprove(spender, 0);\n            IERC20(tokens[i]).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    function pushUnderlying(uint256 amount, address to) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;\n            IERC20(tokens[i]).safeTransfer(to, tokenAmount);\n        }\n    }\n\n    function pullUnderlying(uint256 amount, address from) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;\n            require(tokenAmount > 0);\n            IERC20(tokens[i]).safeTransferFrom(from, address(this), tokenAmount);\n        }\n    }\n\n    modifier onlyAuction() {\n        require(msg.sender == address(auction));\n        _;\n    }\n\n    modifier onlyPublisher() {\n        require(msg.sender == address(publisher));\n        _;\n    }\n}"
    },
    {
      "filename": "contracts/contracts/Basket.sol",
      "content": "pragma solidity =0.8.7;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport './interfaces/IAuction.sol';\nimport \"./interfaces/IBasket.sol\";\nimport \"./interfaces/IFactory.sol\";\nimport \"hardhat/console.sol\";\n\n//TODO: add revert reasons or v8 custom errors back in\ncontract Basket is IBasket, ERC20Upgradeable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    //TODO: recommend using block timestamp instead of block numbers here\n    uint256 public constant TIMELOCK_DURATION = 1 days; // 1 day\n    uint256 public constant ONE_YEAR = 365.25 days;\n    uint256 private constant BASE = 1e18;\n\n    uint256 public maxSupply;\n\n    address public publisher;\n    uint256 public licenseFee;\n\n    IFactory public override factory;\n    IAuction public override auction;\n\n    uint256 public override ibRatio;\n\n    PendingPublisher public pendingPublisher;\n    PendingLicenseFee public pendingLicenseFee;\n    PendingWeights public pendingWeights;\n    PendingMaxSupply public pendingMaxSupply;\n\n    address[] public tokens;\n    uint256[] public weights;\n\n    uint256 public override lastFee;\n\n    bool public override initialized;\n\n    function initialize(IFactory.Proposal memory proposal, IAuction auction_) external override {\n        require(address(factory) == address(0));\n        require(!initialized);\n\n        publisher = proposal.proposer;\n        licenseFee = proposal.licenseFee;\n        factory = IFactory(msg.sender);\n        auction = auction_;\n        ibRatio = BASE;\n        tokens = proposal.tokens;\n        weights = proposal.weights;\n        maxSupply = proposal.maxSupply;\n        approveUnderlying(address(auction));\n\n        __ERC20_init(proposal.tokenName, proposal.tokenSymbol);\n\n        initialized = true;\n    }\n\n    function getPendingWeights() external override view returns (address[] memory, uint256[] memory, uint256) {\n        return (pendingWeights.tokens, pendingWeights.weights, pendingWeights.minIbRatio);\n    }\n\n    function validateWeights(address[] memory _tokens, uint256[] memory _weights) public override pure {\n        require(_tokens.length > 0);\n        require(_tokens.length == _weights.length);\n        uint256 length = _tokens.length;\n        address[] memory tokenList = new address[](length);\n\n        // check uniqueness of tokens and not token(0)\n\n        for (uint i = 0; i < length; i++) {\n            require(_tokens[i] != address(0));\n            require(_weights[i] > 0);\n\n            for (uint256 x = 0; x < tokenList.length; x++) {\n                require(_tokens[i] != tokenList[x]);\n            }\n\n            tokenList[i] = _tokens[i];\n        }\n    }\n\n    function mint(uint256 amount) public override {\n        mintTo(amount, msg.sender);\n    }\n\n    function mintTo(uint256 amount, address to) public nonReentrant override {\n        require(auction.auctionOngoing() == false);\n        require(amount > 0);\n        uint256 startSupply = totalSupply();\n        require(startSupply + amount <= maxSupply);\n\n        handleFees(startSupply);\n\n        pullUnderlying(amount, msg.sender);\n\n        _mint(to, amount);\n\n        require(totalSupply() <= maxSupply);\n\n        emit Minted(to, amount);\n    }\n\n    function burn(uint256 amount) public nonReentrant override {\n        require(auction.auctionOngoing() == false);\n        require(amount > 0);\n\n        uint256 startSupply = totalSupply();\n        handleFees(startSupply);\n\n        pushUnderlying(amount, msg.sender);\n        _burn(msg.sender, amount);\n        \n        emit Burned(msg.sender, amount);\n    }\n\n    function auctionBurn(uint256 amount) onlyAuction nonReentrant external override {\n        uint256 startSupply = totalSupply();\n        handleFees(startSupply);\n        _burn(msg.sender, amount);\n\n        uint256 newIbRatio = ibRatio * startSupply / (startSupply - amount);\n        ibRatio = newIbRatio;\n\n        emit NewIBRatio(newIbRatio);\n        emit Burned(msg.sender, amount);\n    }\n\n    function handleFees(uint256 startSupply) private {\n        if (lastFee == 0) {\n            lastFee = block.timestamp;\n        } else if (startSupply == 0) {\n            return;\n        } else {\n            uint256 timeDiff = (block.timestamp - lastFee);\n            uint256 feePct = timeDiff * licenseFee / ONE_YEAR;\n            uint256 fee = startSupply * feePct / (BASE - feePct);\n\n\n            _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);\n            _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);\n            lastFee = block.timestamp;\n\n            uint256 newIbRatio = ibRatio * startSupply / totalSupply();\n            ibRatio = newIbRatio;\n\n            emit NewIBRatio(ibRatio);\n        }\n    }\n\n    // changes publisher\n    // timelocked\n    function changePublisher(address newPublisher) onlyPublisher public override {\n        require(newPublisher != address(0));\n\n        if (pendingPublisher.publisher != address(0) && pendingPublisher.publisher == newPublisher) {\n            require(block.timestamp >= pendingPublisher.timestamp + TIMELOCK_DURATION);\n            publisher = newPublisher;\n\n            pendingPublisher.publisher = address(0);\n\n            emit ChangedPublisher(publisher);\n        } else {\n            pendingPublisher.publisher = newPublisher;\n            pendingPublisher.timestamp = block.timestamp;\n\n            emit NewPublisherSubmitted(newPublisher);\n        }\n    }\n\n    //changes licenseFee\n    // timelocked\n    function changeLicenseFee(uint256 newLicenseFee) onlyPublisher public override {\n        require(newLicenseFee >= factory.minLicenseFee() && newLicenseFee != licenseFee);\n        if (pendingLicenseFee.licenseFee != 0 && pendingLicenseFee.licenseFee == newLicenseFee) {\n            require(block.timestamp >= pendingLicenseFee.timestamp + TIMELOCK_DURATION);\n            licenseFee = newLicenseFee;\n\n            pendingLicenseFee.licenseFee = 0;\n\n            emit ChangedLicenseFee(licenseFee);\n        } else {\n            pendingLicenseFee.licenseFee = newLicenseFee;\n            pendingLicenseFee.timestamp = block.timestamp;\n\n            emit NewLicenseFeeSubmitted(newLicenseFee);\n        }\n    }\n\n    //changes maxSupply\n    // timelocked\n    function setNewMaxSupply(uint256 newMaxSupply) onlyPublisher public override {\n        require(newMaxSupply > totalSupply());\n\n        if (pendingMaxSupply.maxSupply != 0 && pendingMaxSupply.maxSupply == newMaxSupply) {\n            require(block.timestamp >= pendingMaxSupply.timestamp + TIMELOCK_DURATION);\n            maxSupply = newMaxSupply;\n\n            pendingMaxSupply.maxSupply = 0;\n\n            emit ChangedMaxSupply(newMaxSupply);\n        } else {\n            pendingMaxSupply.maxSupply = newMaxSupply;\n            pendingMaxSupply.timestamp = block.timestamp;\n\n            emit NewMaxSupplySubmitted(newMaxSupply);\n        }\n    }\n\n    // publish new index\n    // timelocked\n    function publishNewIndex(address[] memory _tokens, uint256[] memory _weights, uint256 _minIbRatio) onlyPublisher public override {\n        validateWeights(_tokens, _weights);\n\n        if (pendingWeights.pending) {\n            require(block.timestamp >= pendingWeights.timestamp + TIMELOCK_DURATION);\n            if (auction.auctionOngoing() == false) {\n                auction.startAuction();\n\n                emit PublishedNewIndex(publisher);\n            } else if (auction.hasBonded()) {\n\n            } else {\n                auction.killAuction();\n\n                pendingWeights.tokens = _tokens;\n                pendingWeights.weights = _weights;\n                pendingWeights.timestamp = block.timestamp;\n                pendingWeights.minIbRatio = _minIbRatio;\n            }\n        } else {\n            pendingWeights.pending = true;\n            pendingWeights.tokens = _tokens;\n            pendingWeights.weights = _weights;\n            pendingWeights.timestamp = block.timestamp;\n            pendingWeights.minIbRatio = _minIbRatio;\n\n            emit NewIndexSubmitted();\n        }\n    }\n\n    function setNewWeights() onlyAuction external override {\n        tokens = pendingWeights.tokens;\n        weights = pendingWeights.weights;\n        pendingWeights.pending = false;\n\n        approveUnderlying(address(auction));\n\n        emit WeightsSet();\n    }\n\n    // delete pending index\n    function deleteNewIndex() public override {\n        require(msg.sender == publisher || msg.sender == address(auction));\n        require(auction.auctionOngoing() == false);\n\n        pendingWeights.pending = false;\n\n        emit DeletedNewIndex(msg.sender);\n    }\n\n    function updateIBRatio(uint256 newRatio) onlyAuction external override returns (uint256) {\n        ibRatio = newRatio;\n\n        emit NewIBRatio(ibRatio);\n\n        return ibRatio;\n    }\n\n    function approveUnderlying(address spender) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            IERC20(tokens[i]).safeApprove(spender, 0);\n            IERC20(tokens[i]).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    function pushUnderlying(uint256 amount, address to) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;\n            IERC20(tokens[i]).safeTransfer(to, tokenAmount);\n        }\n    }\n\n    function pullUnderlying(uint256 amount, address from) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;\n            require(tokenAmount > 0);\n            IERC20(tokens[i]).safeTransferFrom(from, address(this), tokenAmount);\n        }\n    }\n\n    modifier onlyAuction() {\n        require(msg.sender == address(auction));\n        _;\n    }\n\n    modifier onlyPublisher() {\n        require(msg.sender == address(publisher));\n        _;\n    }\n}"
    },
    {
      "filename": "contracts/contracts/Factory.sol",
      "content": "pragma solidity =0.8.7;\n\nimport \"hardhat/console.sol\";\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Clones } from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./interfaces/IAuction.sol\";\nimport \"./interfaces/IBasket.sol\";\nimport \"./interfaces/IFactory.sol\";\n\ncontract Factory is IFactory, Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    uint256 private constant BASE = 1e18;\n\n    constructor (IAuction _auctionImpl, IBasket _basketImpl) {\n        auctionImpl = _auctionImpl;\n        basketImpl = _basketImpl;\n        ownerSplit = 0; //TODO: needed?\n    }\n\n    Proposal[] private _proposals;\n\n    IAuction public override auctionImpl;\n    IBasket public override basketImpl;\n\n    uint256 public override minLicenseFee = 1e15; // 1e15 0.1%\n    uint256 public override auctionDecrement = 10000;\n    uint256 public override auctionMultiplier = 2;\n    uint256 public override bondPercentDiv = 400;\n    uint256 public override ownerSplit;\n\n    function proposal(uint256 proposalId) external override view returns (Proposal memory) {\n        return _proposals[proposalId];\n    }\n\n    function setMinLicenseFee(uint256 newMinLicenseFee) public override onlyOwner {\n        minLicenseFee = newMinLicenseFee;\n    }\n\n    function setAuctionDecrement(uint256 newAuctionDecrement) public override onlyOwner {\n        auctionDecrement = newAuctionDecrement;\n    }\n\n    function setAuctionMultiplier(uint256 newAuctionMultiplier) public override onlyOwner {\n        auctionMultiplier = newAuctionMultiplier;\n    }\n\n    function setBondPercentDiv(uint256 newBondPercentDiv) public override onlyOwner {\n        require(newBondPercentDiv > 0);\n        bondPercentDiv = newBondPercentDiv;\n    }\n\n    function setOwnerSplit(uint256 newOwnerSplit) public override onlyOwner {\n        require(newOwnerSplit <= 2e17); // 20%\n\n        ownerSplit = newOwnerSplit;\n    }\n\n    function getProposalWeights(uint256 id) external override view returns (address[] memory, uint256[] memory) {\n        return (_proposals[id].tokens, _proposals[id].weights);\n    }\n\n    function proposeBasketLicense(\n        uint256 licenseFee, \n        string memory tokenName, \n        string memory tokenSymbol, \n        address[] memory tokens,\n        uint256[] memory weights,\n        uint256 maxSupply\n    ) public override returns (uint256 id) {\n        basketImpl.validateWeights(tokens, weights);\n\n        require(licenseFee >= minLicenseFee);\n\n        // create proposal object\n        Proposal memory proposal = Proposal({\n            licenseFee: licenseFee,\n            tokenName: tokenName,\n            tokenSymbol: tokenSymbol,\n            proposer: address(msg.sender),\n            tokens: tokens,\n            weights: weights,\n            basket: address(0),\n            maxSupply: maxSupply\n        });\n\n        emit BasketLicenseProposed(msg.sender, tokenName);\n        _proposals.push(proposal);\n\n        return _proposals.length - 1;\n    }\n\n    function createBasket(uint256 idNumber) external override nonReentrant returns (IBasket) {\n        Proposal memory bProposal = _proposals[idNumber];\n        require(bProposal.basket == address(0));\n\n        IAuction newAuction = IAuction(Clones.clone(address(auctionImpl)));\n        IBasket newBasket = IBasket(Clones.clone(address(basketImpl)));\n\n        _proposals[idNumber].basket = address(newBasket);\n\n        newAuction.initialize(address(newBasket), address(this));\n        newBasket.initialize(bProposal, newAuction);\n\n        for (uint256 i = 0; i < bProposal.weights.length; i++) {\n            IERC20 token = IERC20(bProposal.tokens[i]);\n            token.safeTransferFrom(msg.sender, address(this), bProposal.weights[i]);\n            token.safeApprove(address(newBasket), bProposal.weights[i]);\n        }\n\n        newBasket.mintTo(BASE, msg.sender);\n\n        emit BasketCreated(address(newBasket));\n\n        return newBasket;\n    }\n}"
    },
    {
      "filename": "contracts/contracts/Basket.sol",
      "content": "pragma solidity =0.8.7;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport './interfaces/IAuction.sol';\nimport \"./interfaces/IBasket.sol\";\nimport \"./interfaces/IFactory.sol\";\nimport \"hardhat/console.sol\";\n\n//TODO: add revert reasons or v8 custom errors back in\ncontract Basket is IBasket, ERC20Upgradeable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    //TODO: recommend using block timestamp instead of block numbers here\n    uint256 public constant TIMELOCK_DURATION = 1 days; // 1 day\n    uint256 public constant ONE_YEAR = 365.25 days;\n    uint256 private constant BASE = 1e18;\n\n    uint256 public maxSupply;\n\n    address public publisher;\n    uint256 public licenseFee;\n\n    IFactory public override factory;\n    IAuction public override auction;\n\n    uint256 public override ibRatio;\n\n    PendingPublisher public pendingPublisher;\n    PendingLicenseFee public pendingLicenseFee;\n    PendingWeights public pendingWeights;\n    PendingMaxSupply public pendingMaxSupply;\n\n    address[] public tokens;\n    uint256[] public weights;\n\n    uint256 public override lastFee;\n\n    bool public override initialized;\n\n    function initialize(IFactory.Proposal memory proposal, IAuction auction_) external override {\n        require(address(factory) == address(0));\n        require(!initialized);\n\n        publisher = proposal.proposer;\n        licenseFee = proposal.licenseFee;\n        factory = IFactory(msg.sender);\n        auction = auction_;\n        ibRatio = BASE;\n        tokens = proposal.tokens;\n        weights = proposal.weights;\n        maxSupply = proposal.maxSupply;\n        approveUnderlying(address(auction));\n\n        __ERC20_init(proposal.tokenName, proposal.tokenSymbol);\n\n        initialized = true;\n    }\n\n    function getPendingWeights() external override view returns (address[] memory, uint256[] memory, uint256) {\n        return (pendingWeights.tokens, pendingWeights.weights, pendingWeights.minIbRatio);\n    }\n\n    function validateWeights(address[] memory _tokens, uint256[] memory _weights) public override pure {\n        require(_tokens.length > 0);\n        require(_tokens.length == _weights.length);\n        uint256 length = _tokens.length;\n        address[] memory tokenList = new address[](length);\n\n        // check uniqueness of tokens and not token(0)\n\n        for (uint i = 0; i < length; i++) {\n            require(_tokens[i] != address(0));\n            require(_weights[i] > 0);\n\n            for (uint256 x = 0; x < tokenList.length; x++) {\n                require(_tokens[i] != tokenList[x]);\n            }\n\n            tokenList[i] = _tokens[i];\n        }\n    }\n\n    function mint(uint256 amount) public override {\n        mintTo(amount, msg.sender);\n    }\n\n    function mintTo(uint256 amount, address to) public nonReentrant override {\n        require(auction.auctionOngoing() == false);\n        require(amount > 0);\n        uint256 startSupply = totalSupply();\n        require(startSupply + amount <= maxSupply);\n\n        handleFees(startSupply);\n\n        pullUnderlying(amount, msg.sender);\n\n        _mint(to, amount);\n\n        require(totalSupply() <= maxSupply);\n\n        emit Minted(to, amount);\n    }\n\n    function burn(uint256 amount) public nonReentrant override {\n        require(auction.auctionOngoing() == false);\n        require(amount > 0);\n\n        uint256 startSupply = totalSupply();\n        handleFees(startSupply);\n\n        pushUnderlying(amount, msg.sender);\n        _burn(msg.sender, amount);\n        \n        emit Burned(msg.sender, amount);\n    }\n\n    function auctionBurn(uint256 amount) onlyAuction nonReentrant external override {\n        uint256 startSupply = totalSupply();\n        handleFees(startSupply);\n        _burn(msg.sender, amount);\n\n        uint256 newIbRatio = ibRatio * startSupply / (startSupply - amount);\n        ibRatio = newIbRatio;\n\n        emit NewIBRatio(newIbRatio);\n        emit Burned(msg.sender, amount);\n    }\n\n    function handleFees(uint256 startSupply) private {\n        if (lastFee == 0) {\n            lastFee = block.timestamp;\n        } else if (startSupply == 0) {\n            return;\n        } else {\n            uint256 timeDiff = (block.timestamp - lastFee);\n            uint256 feePct = timeDiff * licenseFee / ONE_YEAR;\n            uint256 fee = startSupply * feePct / (BASE - feePct);\n\n\n            _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);\n            _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);\n            lastFee = block.timestamp;\n\n            uint256 newIbRatio = ibRatio * startSupply / totalSupply();\n            ibRatio = newIbRatio;\n\n            emit NewIBRatio(ibRatio);\n        }\n    }\n\n    // changes publisher\n    // timelocked\n    function changePublisher(address newPublisher) onlyPublisher public override {\n        require(newPublisher != address(0));\n\n        if (pendingPublisher.publisher != address(0) && pendingPublisher.publisher == newPublisher) {\n            require(block.timestamp >= pendingPublisher.timestamp + TIMELOCK_DURATION);\n            publisher = newPublisher;\n\n            pendingPublisher.publisher = address(0);\n\n            emit ChangedPublisher(publisher);\n        } else {\n            pendingPublisher.publisher = newPublisher;\n            pendingPublisher.timestamp = block.timestamp;\n\n            emit NewPublisherSubmitted(newPublisher);\n        }\n    }\n\n    //changes licenseFee\n    // timelocked\n    function changeLicenseFee(uint256 newLicenseFee) onlyPublisher public override {\n        require(newLicenseFee >= factory.minLicenseFee() && newLicenseFee != licenseFee);\n        if (pendingLicenseFee.licenseFee != 0 && pendingLicenseFee.licenseFee == newLicenseFee) {\n            require(block.timestamp >= pendingLicenseFee.timestamp + TIMELOCK_DURATION);\n            licenseFee = newLicenseFee;\n\n            pendingLicenseFee.licenseFee = 0;\n\n            emit ChangedLicenseFee(licenseFee);\n        } else {\n            pendingLicenseFee.licenseFee = newLicenseFee;\n            pendingLicenseFee.timestamp = block.timestamp;\n\n            emit NewLicenseFeeSubmitted(newLicenseFee);\n        }\n    }\n\n    //changes maxSupply\n    // timelocked\n    function setNewMaxSupply(uint256 newMaxSupply) onlyPublisher public override {\n        require(newMaxSupply > totalSupply());\n\n        if (pendingMaxSupply.maxSupply != 0 && pendingMaxSupply.maxSupply == newMaxSupply) {\n            require(block.timestamp >= pendingMaxSupply.timestamp + TIMELOCK_DURATION);\n            maxSupply = newMaxSupply;\n\n            pendingMaxSupply.maxSupply = 0;\n\n            emit ChangedMaxSupply(newMaxSupply);\n        } else {\n            pendingMaxSupply.maxSupply = newMaxSupply;\n            pendingMaxSupply.timestamp = block.timestamp;\n\n            emit NewMaxSupplySubmitted(newMaxSupply);\n        }\n    }\n\n    // publish new index\n    // timelocked\n    function publishNewIndex(address[] memory _tokens, uint256[] memory _weights, uint256 _minIbRatio) onlyPublisher public override {\n        validateWeights(_tokens, _weights);\n\n        if (pendingWeights.pending) {\n            require(block.timestamp >= pendingWeights.timestamp + TIMELOCK_DURATION);\n            if (auction.auctionOngoing() == false) {\n                auction.startAuction();\n\n                emit PublishedNewIndex(publisher);\n            } else if (auction.hasBonded()) {\n\n            } else {\n                auction.killAuction();\n\n                pendingWeights.tokens = _tokens;\n                pendingWeights.weights = _weights;\n                pendingWeights.timestamp = block.timestamp;\n                pendingWeights.minIbRatio = _minIbRatio;\n            }\n        } else {\n            pendingWeights.pending = true;\n            pendingWeights.tokens = _tokens;\n            pendingWeights.weights = _w"
    }
  ]
}