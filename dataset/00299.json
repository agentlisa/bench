{
  "Title": "Redemptions are blocked when L2 sequencers are down",
  "Content": "**Description:** Given that rollups such as [Optimism](https://docs.optimism.io/chain/differences#address-aliasing) and [Arbitrum](https://docs.arbitrum.io/arbos/l1-to-l2-messaging#address-aliasing) offer methods for forced transaction inclusion, it is important that the aliased sender address is also [checked](https://solodit.xyz/issues/m-8-operator-is-blocked-when-sequencer-is-down-on-arbitrum-sherlock-none-index-git) within [`Logic::redeemTokensWithPayload`](https://github.com/wormhole-foundation/wormhole-circle-integration/blob/f7df33b159a71b163b8b5c7e7381c0d8f193da99/evm/src/contracts/CircleIntegration/Logic.sol#L88-L91) when verifying the sender is the specified `mintRecipient` to allow for maximum uptime in the event of sequencer downtime.\n\n```solidity\n// Confirm that the caller is the `mintRecipient` to ensure atomic execution.\nrequire(\n    msg.sender.toUniversalAddress() == deposit.mintRecipient, \"caller must be mintRecipient\"\n);\n```\n\n**Impact:** Failure to consider the aliased `mintRecipient` address prevents the execution of valid VAAs on a target CCTP domain where transactions are batched by a centralized L2 sequencer. Since this VAA could carry a time-sensitive payload, such as the urgent cross-chain liquidity infusion to a protocol, this issue has the potential to have a high impact with reasonable likelihood.\n\n**Proof of Concept:**\n1. Protocol X attempts to transfer 10,000 USDC from CCTP Domain A to CCTP Domain B.\n2. CCTP Domain B is an L2 rollup that batches transactions for publishing onto the L1 chain via a centralized sequencer.\n3. The L2 sequencer goes down; however, transactions can still be executed via forced inclusion on the L1 chain.\n4. Protocol X implements the relevant functionality and attempts to redeem 10,000 USDC via forced inclusion.\n5. The Wormhole CCTP integration does not consider the contract's aliased address when validating the `mintRecipient`, so the redemption fails.\n6. Cross-chain transfer of this liquidity will remain blocked so long as the sequencer is down.\n\n**Recommended Mitigation:** Validation of the sender address against the `mintRecipient` should also consider the aliased `mintRecipient` address to allow for maximum uptime when [`Logic::redeemTokensWithPayload`](https://github.com/wormhole-foundation/wormhole-circle-integration/blob/f7df33b159a71b163b8b5c7e7381c0d8f193da99/evm/src/contracts/CircleIntegration/Logic.sol#L88-L91) is called via forced inclusion.\n\n**Wormhole Foundation:** Since CCTP [doesn’t deal with this aliasing](https://github.com/circlefin/evm-cctp-contracts/blob/adb2a382b09ea574f4d18d8af5b6706e8ed9b8f2/src/MessageTransmitter.sol#L270-L277), we don’t feel strongly that we should either.\n\n**Cyfrin:** Acknowledged.",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "evm/src/contracts/CircleIntegration/Logic.sol",
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.19;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {IWormhole} from \"src/interfaces/IWormhole.sol\";\nimport {IMessageTransmitter} from \"src/interfaces/IMessageTransmitter.sol\";\nimport {ITokenMessenger} from \"src/interfaces/ITokenMessenger.sol\";\nimport {ITokenMinter} from \"src/interfaces/ITokenMinter.sol\";\nimport {ICircleIntegration} from \"src/interfaces/ICircleIntegration.sol\";\n\nimport {Utils} from \"src/libraries/Utils.sol\";\nimport {WormholeCctpMessages} from \"src/libraries/WormholeCctpMessages.sol\";\n\nimport {Governance} from \"./Governance.sol\";\nimport {\n    getChainToDomain,\n    getConsumedVaas,\n    getDomainToChain,\n    getInitializedImplementations,\n    getRegisteredEmitters\n} from \"./Storage.sol\";\n\nabstract contract Logic is ICircleIntegration, Governance {\n    using Utils for address;\n    using SafeERC20 for IERC20;\n    using WormholeCctpMessages for *;\n\n    /// @inheritdoc ICircleIntegration\n    function transferTokensWithPayload(\n        TransferParameters calldata transferParams,\n        uint32 wormholeNonce,\n        bytes calldata payload\n    ) public payable returns (uint64 wormholeSequence) {\n        // Is the foreign Wormhole Circle Integration registered?\n        bytes32 destinationCaller = getRegisteredEmitters()[transferParams.targetChain];\n        require(destinationCaller != 0, \"target contract not registered\");\n\n        // Deposit tokens into this contract to prepare for burning.\n        IERC20(transferParams.token).safeTransferFrom(\n            msg.sender, address(this), transferParams.amount\n        );\n\n        // Approve the Token Messenger to spend tokens.\n        setTokenMessengerApproval(transferParams.token, transferParams.amount);\n\n        // Invoke Token Messenger to burn tokens and emit a CCTP token burn message.\n        (wormholeSequence,) = burnAndPublish(\n            destinationCaller,\n            getChainToDomain()[transferParams.targetChain],\n            transferParams.token,\n            transferParams.amount,\n            transferParams.mintRecipient,\n            wormholeNonce,\n            payload,\n            msg.value\n        );\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function redeemTokensWithPayload(RedeemParameters calldata params)\n        public\n        returns (DepositWithPayload memory deposit)\n    {\n        // This check prevents this contract existing on this network's potential fork, where it was\n        // not freshly deployed. This is a safety measure to prevent replay attacks on the forked\n        // network.\n        require(evmChain() == block.chainid, \"invalid evm chain\");\n\n        // Verify the VAA and mint tokens. Set the deposit struct with WormholeCctpTokenMessenger's\n        // return values.\n        IWormhole.VM memory vaa;\n        (\n            vaa,\n            deposit.token,\n            deposit.amount,\n            deposit.sourceDomain,\n            deposit.targetDomain,\n            deposit.nonce,\n            deposit.fromAddress,\n            deposit.mintRecipient,\n            deposit.payload\n        ) = verifyVaaAndMintLegacy(\n            params.encodedCctpMessage, params.cctpAttestation, params.encodedVaa\n        );\n\n        // Confirm that the caller is the `mintRecipient` to ensure atomic execution.\n        require(\n            msg.sender.toUniversalAddress() == deposit.mintRecipient, \"caller must be mintRecipient\"\n        );\n\n        // If this VAA does not come from a registered Wormhole Circle Integration contract, revert.\n        requireEmitterLegacy(vaa, getRegisteredEmitters()[vaa.emitterChainId]);\n\n        mapping(bytes32 => bool) storage consumedVaas = getConsumedVaas();\n\n        // Revert if this message has been consumed already. This check is meant to prevent replay\n        // attacks, but it may not be necessary because the CCTP Message Transmitter already keeps\n        // track of used nonces.\n        require(!consumedVaas[vaa.hash], \"message already consumed\");\n\n        // Mark as consumed.\n        consumedVaas[vaa.hash] = true;\n\n        // Emit Redeemed event.\n        emit Redeemed(vaa.emitterChainId, vaa.emitterAddress, vaa.sequence);\n    }\n\n    // getters\n\n    /// @inheritdoc ICircleIntegration\n    function fetchLocalTokenAddress(uint32 remoteDomain, bytes32 remoteToken)\n        public\n        view\n        returns (bytes32)\n    {\n        return fetchLocalToken(remoteDomain, remoteToken);\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function addressToBytes32(address evmAddr) public pure returns (bytes32 converted) {\n        converted = evmAddr.toUniversalAddress();\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function decodeDepositWithPayload(bytes memory encoded)\n        public\n        pure\n        returns (DepositWithPayload memory deposit)\n    {\n        // This is a hack to get around using the decodeDeposit method. This is not a real VM\n        // obviously.\n        //\n        // Plus, this getter should never be used in practice.\n        IWormhole.VM memory fakeVaa;\n        fakeVaa.payload = encoded;\n        (\n            deposit.token,\n            deposit.amount,\n            deposit.sourceDomain,\n            deposit.targetDomain,\n            deposit.nonce,\n            deposit.fromAddress,\n            deposit.mintRecipient,\n            deposit.payload\n        ) = fakeVaa.decodeDeposit();\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function encodeDepositWithPayload(DepositWithPayload memory message)\n        public\n        pure\n        returns (bytes memory encoded)\n    {\n        encoded = message.token.encodeDeposit(\n            message.amount,\n            message.sourceDomain,\n            message.targetDomain,\n            message.nonce,\n            message.fromAddress,\n            message.mintRecipient,\n            message.payload\n        );\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function isInitialized(address impl) public view returns (bool) {\n        return getInitializedImplementations()[impl];\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function wormhole() public view returns (IWormhole) {\n        return _wormhole;\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function chainId() public view returns (uint16) {\n        return _chainId;\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function wormholeFinality() public pure returns (uint8) {\n        return _MESSAGE_FINALITY;\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function circleBridge() public view returns (ITokenMessenger) {\n        return _tokenMessenger;\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function circleTokenMinter() public view returns (ITokenMinter) {\n        return _tokenMinter;\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function circleTransmitter() public view returns (IMessageTransmitter) {\n        return _messageTransmitter;\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function getRegisteredEmitter(uint16 chain) public view returns (bytes32) {\n        return getRegisteredEmitters()[chain];\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function isAcceptedToken(address token) public view returns (bool) {\n        return _tokenMinter.burnLimitsPerMessage(token) > 0;\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function getDomainFromChainId(uint16 chain) public view returns (uint32) {\n        return getChainToDomain()[chain];\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function getChainIdFromDomain(uint32 cctpDomain) public view returns (uint16) {\n        return getDomainToChain()[cctpDomain];\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function isMessageConsumed(bytes32 vaaHash) public view returns (bool) {\n        return getConsumedVaas()[vaaHash];\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function localDomain() public view returns (uint32) {\n        return _localCctpDomain;\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function evmChain() public view returns (uint256) {\n        return _evmChain;\n    }\n}"
    },
    {
      "filename": "evm/src/contracts/CircleIntegration/Logic.sol",
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.19;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {IWormhole} from \"src/interfaces/IWormhole.sol\";\nimport {IMessageTransmitter} from \"src/interfaces/IMessageTransmitter.sol\";\nimport {ITokenMessenger} from \"src/interfaces/ITokenMessenger.sol\";\nimport {ITokenMinter} from \"src/interfaces/ITokenMinter.sol\";\nimport {ICircleIntegration} from \"src/interfaces/ICircleIntegration.sol\";\n\nimport {Utils} from \"src/libraries/Utils.sol\";\nimport {WormholeCctpMessages} from \"src/libraries/WormholeCctpMessages.sol\";\n\nimport {Governance} from \"./Governance.sol\";\nimport {\n    getChainToDomain,\n    getConsumedVaas,\n    getDomainToChain,\n    getInitializedImplementations,\n    getRegisteredEmitters\n} from \"./Storage.sol\";\n\nabstract contract Logic is ICircleIntegration, Governance {\n    using Utils for address;\n    using SafeERC20 for IERC20;\n    using WormholeCctpMessages for *;\n\n    /// @inheritdoc ICircleIntegration\n    function transferTokensWithPayload(\n        TransferParameters calldata transferParams,\n        uint32 wormholeNonce,\n        bytes calldata payload\n    ) public payable returns (uint64 wormholeSequence) {\n        // Is the foreign Wormhole Circle Integration registered?\n        bytes32 destinationCaller = getRegisteredEmitters()[transferParams.targetChain];\n        require(destinationCaller != 0, \"target contract not registered\");\n\n        // Deposit tokens into this contract to prepare for burning.\n        IERC20(transferParams.token).safeTransferFrom(\n            msg.sender, address(this), transferParams.amount\n        );\n\n        // Approve the Token Messenger to spend tokens.\n        setTokenMessengerApproval(transferParams.token, transferParams.amount);\n\n        // Invoke Token Messenger to burn tokens and emit a CCTP token burn message.\n        (wormholeSequence,) = burnAndPublish(\n            destinationCaller,\n            getChainToDomain()[transferParams.targetChain],\n            transferParams.token,\n            transferParams.amount,\n            transferParams.mintRecipient,\n            wormholeNonce,\n            payload,\n            msg.value\n        );\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function redeemTokensWithPayload(RedeemParameters calldata params)\n        public\n        returns (DepositWithPayload memory deposit)\n    {\n        // This check prevents this contract existing on this network's potential fork, where it was\n        // not freshly deployed. This is a safety measure to prevent replay attacks on the forked\n        // network.\n        require(evmChain() == block.chainid, \"invalid evm chain\");\n\n        // Verify the VAA and mint tokens. Set the deposit struct with WormholeCctpTokenMessenger's\n        // return values.\n        IWormhole.VM memory vaa;\n        (\n            vaa,\n            deposit.token,\n            deposit.amount,\n            deposit.sourceDomain,\n            deposit.targetDomain,\n            deposit.nonce,\n            deposit.fromAddress,\n            deposit.mintRecipient,\n            deposit.payload\n        ) = verifyVaaAndMintLegacy(\n            params.encodedCctpMessage, params.cctpAttestation, params.encodedVaa\n        );\n\n        // Confirm that the caller is the `mintRecipient` to ensure atomic execution.\n        require(\n            msg.sender.toUniversalAddress() == deposit.mintRecipient, \"caller must be mintRecipient\"\n        );\n\n        // If this VAA does not come from a registered Wormhole Circle Integration contract, revert.\n        requireEmitterLegacy(vaa, getRegisteredEmitters()[vaa.emitterChainId]);\n\n        mapping(bytes32 => bool) storage consumedVaas = getConsumedVaas();\n\n        // Revert if this message has been consumed already. This check is meant to prevent replay\n        // attacks, but it may not be necessary because the CCTP Message Transmitter already keeps\n        // track of used nonces.\n        require(!consumedVaas[vaa.hash], \"message already consumed\");\n\n        // Mark as consumed.\n        consumedVaas[vaa.hash] = true;\n\n        // Emit Redeemed event.\n        emit Redeemed(vaa.emitterChainId, vaa.emitterAddress, vaa.sequence);\n    }\n\n    // getters\n\n    /// @inheritdoc ICircleIntegration\n    function fetchLocalTokenAddress(uint32 remoteDomain, bytes32 remoteToken)\n        public\n        view\n        returns (bytes32)\n    {\n        return fetchLocalToken(remoteDomain, remoteToken);\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function addressToBytes32(address evmAddr) public pure returns (bytes32 converted) {\n        converted = evmAddr.toUniversalAddress();\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function decodeDepositWithPayload(bytes memory encoded)\n        public\n        pure\n        returns (DepositWithPayload memory deposit)\n    {\n        // This is a hack to get around using the decodeDeposit method. This is not a real VM\n        // obviously.\n        //\n        // Plus, this getter should never be used in practice.\n        IWormhole.VM memory fakeVaa;\n        fakeVaa.payload = encoded;\n        (\n            deposit.token,\n            deposit.amount,\n            deposit.sourceDomain,\n            deposit.targetDomain,\n            deposit.nonce,\n            deposit.fromAddress,\n            deposit.mintRecipient,\n            deposit.payload\n        ) = fakeVaa.decodeDeposit();\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function encodeDepositWithPayload(DepositWithPayload memory message)\n        public\n        pure\n        returns (bytes memory encoded)\n    {\n        encoded = message.token.encodeDeposit(\n            message.amount,\n            message.sourceDomain,\n            message.targetDomain,\n            message.nonce,\n            message.fromAddress,\n            message.mintRecipient,\n            message.payload\n        );\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function isInitialized(address impl) public view returns (bool) {\n        return getInitializedImplementations()[impl];\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function wormhole() public view returns (IWormhole) {\n        return _wormhole;\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function chainId() public view returns (uint16) {\n        return _chainId;\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function wormholeFinality() public pure returns (uint8) {\n        return _MESSAGE_FINALITY;\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function circleBridge() public view returns (ITokenMessenger) {\n        return _tokenMessenger;\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function circleTokenMinter() public view returns (ITokenMinter) {\n        return _tokenMinter;\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function circleTransmitter() public view returns (IMessageTransmitter) {\n        return _messageTransmitter;\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function getRegisteredEmitter(uint16 chain) public view returns (bytes32) {\n        return getRegisteredEmitters()[chain];\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function isAcceptedToken(address token) public view returns (bool) {\n        return _tokenMinter.burnLimitsPerMessage(token) > 0;\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function getDomainFromChainId(uint16 chain) public view returns (uint32) {\n        return getChainToDomain()[chain];\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function getChainIdFromDomain(uint32 cctpDomain) public view returns (uint16) {\n        return getDomainToChain()[cctpDomain];\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function isMessageConsumed(bytes32 vaaHash) public view returns (bool) {\n        return getConsumedVaas()[vaaHash];\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function localDomain() public view returns (uint32) {\n        return _localCctpDomain;\n    }\n\n    /// @inheritdoc ICircleIntegration\n    function evmChain() public view returns (uint256) {\n        return _evmChain;\n    }\n}"
    },
    {
      "filename": "src/MessageTransmitter.sol",
      "content": "/*\n * Copyright (c) 2022, Circle Internet Financial Limited.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npragma solidity 0.7.6;\n\nimport \"@memview-sol/contracts/TypedMemView.sol\";\nimport \"./interfaces/IMessageTransmitter.sol\";\nimport \"./interfaces/IMessageHandler.sol\";\nimport \"./messages/Message.sol\";\nimport \"./roles/Pausable.sol\";\nimport \"./roles/Rescuable.sol\";\nimport \"./roles/Attestable.sol\";\n\n/**\n * @title MessageTransmitter\n * @notice Contract responsible for sending and receiving messages across chains.\n */\ncontract MessageTransmitter is\n    IMessageTransmitter,\n    Pausable,\n    Rescuable,\n    Attestable\n{\n    // ============ Events ============\n    /**\n     * @notice Emitted when a new message is dispatched\n     * @param message Raw bytes of message\n     */\n    event MessageSent(bytes message);\n\n    /**\n     * @notice Emitted when a new message is received\n     * @param caller Caller (msg.sender) on destination domain\n     * @param sourceDomain The source domain this message originated from\n     * @param nonce The nonce unique to this message\n     * @param sender The sender of this message\n     * @param messageBody message body bytes\n     */\n    event MessageReceived(\n        address indexed caller,\n        uint32 sourceDomain,\n        uint64 indexed nonce,\n        bytes32 sender,\n        bytes messageBody\n    );\n\n    /**\n     * @notice Emitted when max message body size is updated\n     * @param newMaxMessageBodySize new maximum message body size, in bytes\n     */\n    event MaxMessageBodySizeUpdated(uint256 newMaxMessageBodySize);\n\n    // ============ Libraries ============\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n    using Message for bytes29;\n\n    // ============ State Variables ============\n    // Domain of chain on which the contract is deployed\n    uint32 public immutable localDomain;\n\n    // Message Format version\n    uint32 public immutable version;\n\n    // Maximum size of message body, in bytes.\n    // This value is set by owner.\n    uint256 public maxMessageBodySize;\n\n    // Next available nonce from this source domain\n    uint64 public nextAvailableNonce;\n\n    // Maps a bytes32 hash of (sourceDomain, nonce) -> uint256 (0 if unused, 1 if used)\n    mapping(bytes32 => uint256) public usedNonces;\n\n    // ============ Constructor ============\n    constructor(\n        uint32 _localDomain,\n        address _attester,\n        uint32 _maxMessageBodySize,\n        uint32 _version\n    ) Attestable(_attester) {\n        localDomain = _localDomain;\n        maxMessageBodySize = _maxMessageBodySize;\n        version = _version;\n    }\n\n    // ============ External Functions  ============\n    /**\n     * @notice Send the message to the destination domain and recipient\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination chain as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessage(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes calldata messageBody\n    ) external override whenNotPaused returns (uint64) {\n        bytes32 _emptyDestinationCaller = bytes32(0);\n        uint64 _nonce = _reserveAndIncrementNonce();\n        bytes32 _messageSender = Message.addressToBytes32(msg.sender);\n\n        _sendMessage(\n            destinationDomain,\n            recipient,\n            _emptyDestinationCaller,\n            _messageSender,\n            _nonce,\n            messageBody\n        );\n\n        return _nonce;\n    }\n\n    /**\n     * @notice Replace a message with a new message body and/or destination caller.\n     * @dev The `originalAttestation` must be a valid attestation of `originalMessage`.\n     * Reverts if msg.sender does not match sender of original message, or if the source domain of the original message\n     * does not match this MessageTransmitter's local domain.\n     * @param originalMessage original message to replace\n     * @param originalAttestation attestation of `originalMessage`\n     * @param newMessageBody new message body of replaced message\n     * @param newDestinationCaller the new destination caller, which may be the\n     * same as the original destination caller, a new destination caller, or an empty\n     * destination caller (bytes32(0), indicating that any destination caller is valid.)\n     */\n    function replaceMessage(\n        bytes calldata originalMessage,\n        bytes calldata originalAttestation,\n        bytes calldata newMessageBody,\n        bytes32 newDestinationCaller\n    ) external override whenNotPaused {\n        // Validate each signature in the attestation\n        _verifyAttestationSignatures(originalMessage, originalAttestation);\n\n        bytes29 _originalMsg = originalMessage.ref(0);\n\n        // Validate message format\n        _originalMsg._validateMessageFormat();\n\n        // Validate message sender\n        bytes32 _sender = _originalMsg._sender();\n        require(\n            msg.sender == Message.bytes32ToAddress(_sender),\n            \"Sender not permitted to use nonce\"\n        );\n\n        // Validate source domain\n        uint32 _sourceDomain = _originalMsg._sourceDomain();\n        require(\n            _sourceDomain == localDomain,\n            \"Message not originally sent from this domain\"\n        );\n\n        uint32 _destinationDomain = _originalMsg._destinationDomain();\n        bytes32 _recipient = _originalMsg._recipient();\n        uint64 _nonce = _originalMsg._nonce();\n\n        _sendMessage(\n            _destinationDomain,\n            _recipient,\n            newDestinationCaller,\n            _sender,\n            _nonce,\n            newMessageBody\n        );\n    }\n\n    /**\n     * @notice Send the message to the destination domain and recipient, for a specified `destinationCaller` on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external override whenNotPaused returns (uint64) {\n        require(\n            destinationCaller != bytes32(0),\n            \"Destination caller must be nonzero\"\n        );\n\n        uint64 _nonce = _reserveAndIncrementNonce();\n        bytes32 _messageSender = Message.addressToBytes32(msg.sender);\n\n        _sendMessage(\n            destinationDomain,\n            recipient,\n            destinationCaller,\n            _messageSender,\n            _nonce,\n            messageBody\n        );\n\n        return _nonce;\n    }\n\n    /**\n     * @notice Receive a message. Messages with a given nonce\n     * can only be broadcast once for a (sourceDomain, destinationDomain)\n     * pair. The message body of a valid message is passed to the\n     * specified recipient for further processing.\n     *\n     * @dev Attestation format:\n     * A valid attestation is the concatenated 65-byte signature(s) of exactly\n     * `thresholdSignature` signatures, in increasing order of attester address.\n     * ***If the attester addresses recovered from signatures are not in\n     * increasing order, signature verification will fail.***\n     * If incorrect number of signatures or duplicate signatures are supplied,\n     * signature verification will fail.\n     *\n     * Message format:\n     * Field                 Bytes      Type       Index\n     * version               4          uint32     0\n     * sourceDomain          4          uint32     4\n     * destinationDomain     4          uint32     8\n     * nonce                 8          uint64     12\n     * sender                32         bytes32    20\n     * recipient             32         bytes32    52\n     * messageBody           dynamic    bytes      84\n     * @param message Message bytes\n     * @param attestation Concatenated 65-byte signature(s) of `message`, in increasing order\n     * of the attester address recovered from signatures.\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata attestation)\n        external\n        override\n        whenNotPaused\n        returns (bool success)\n    {\n        // Validate each signature in the attestation\n        _verifyAttestationSignatures(message, attestation);\n\n        bytes29 _msg = message.ref(0);\n\n        // Validate message format\n        _msg._validateMessageFormat();\n\n        // Validate domain\n        require(\n            _msg._destinationDomain() == localDomain,\n            \"Invalid destination domain\"\n        );\n\n        // Validate destination caller\n        if (_msg._destinationCaller() != bytes32(0)) {\n            require(\n                _msg._destinationCaller() ==\n                    Message.addressToBytes32(msg.sender),\n                \"Invalid caller for message\"\n            );\n        }\n\n        // Validate version\n        require(_msg._version() == version, \"Invalid message version\");\n\n        // Validate nonce is available\n        uint32 _sourceDomain = _msg._sourceDomain();\n        uint64 _nonce = _msg._nonce();\n        bytes32 _sourceAndNonce = _hashSourceAndNonce(_sourceDomain, _nonce);\n        require(usedNonces[_sourceAndNonce] == 0, \"Nonce already used\");\n        // Mark nonce used\n        usedNonces[_sourceAndNonce] = 1;\n\n        // Handle receive message\n        bytes32 _sender = _msg._sender();\n        bytes memory _messageBody = _msg._messageBody().clone();\n        require(\n            IMessageHandler(Message.bytes32ToAddress(_msg._recipient()))\n                .handleReceiveMessage(_sourceDomain, _sender, _messageBody),\n            \"handleReceiveMessage() failed\"\n        );\n\n        // Emit MessageReceived event\n        emit MessageReceived(\n            msg.sender,\n            _sourceDomain,\n            _nonce,\n            _sender,\n            _messageBody\n        );\n        return true;\n    }\n\n    /**\n     * @notice Sets the max message body size\n     * @dev This value should not be reduced without good reason,\n     * to avoid impacting users who rely on large messages.\n     * @param newMaxMessageBodySize new max message body size, in bytes\n     */\n    function setMaxMessageBodySize(uint256 newMaxMessageBodySize)\n        external\n        onlyOwner\n    {\n        maxMessageBodySize = newMaxMessageBodySize;\n        emit MaxMessageBodySizeUpdated(maxMessageBodySize);\n    }\n\n    // ============ Internal Utils ============\n    /**\n     * @notice Send the message to the destination domain and recipient. If `_destinationCaller` is not equal to bytes32(0),\n     * the message can only be received on the destination chain when called by `_destinationCaller`.\n     * @dev Format the message and emit `MessageSent` event with message information.\n     * @param _destinationDomain Domain of destination chain\n     * @param _recipient Address of message recipient on destination domain as bytes32\n     * @param _destinationCaller caller on the destination domain, as bytes32\n     * @param _sender message sender, as bytes32\n     * @param _nonce nonce reserved for message\n     * @param _messageBody Raw bytes content of message\n     */\n    function _sendMessage(\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        bytes32 _destinationCaller,\n        bytes32 _sender,\n        uint64 _nonce,\n        bytes calldata _messageBody\n    ) internal {\n        // Validate message body length\n        require(\n            _messageBody.length <= maxMessageBodySize,\n            \"Message body exceeds max size\"\n        );\n\n        require(_recipient != bytes32(0), \"Recipient must be nonzero\");\n\n        // serialize message\n        bytes memory _message = Message._formatMessage(\n            version,\n            localDomain,\n            _destinationDomain,\n            _nonce,\n            _sender,\n            _recipient,\n            _destinationCaller,\n            _messageBody\n        );\n\n        // Emit MessageSent event\n        emit MessageSent(_message);\n    }\n\n    /**\n     * @notice hashes `_source` and `_nonce`.\n     * @param _source Domain of chain where the transfer originated\n     * @param _nonce The unique identifier for the message from source to\n              destination\n     * @return hash of source and nonce\n     */\n    function _hashSourceAndNonce(uint32 _source, uint64 _nonce)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(_source, _nonce));\n    }\n\n    /**\n     * Reserve and increment next available nonce\n     * @return nonce reserved\n     */\n    function _reserveAndIncrementNonce() internal returns (uint64) {\n        uint64 _nonceReserved = nextAvailableNonce;\n        nextAvailableNonce = nextAvailableNonce + 1;\n        return _nonceReserved;\n    }\n}"
    }
  ]
}