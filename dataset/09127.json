{
  "Title": "[M-11] Users may lose rewards to other users if rewards are given as fee-on-transfer tokens",
  "Content": "_Submitted by IllIllI, also found by Aits, BowTiedWardens, and MaratCerby_\n\nIf rewards are given in fee-on-transfer tokens, users may get no rewards, breaking functionality.\n\n`Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or :::leak value with a hypothetical attack path with stated assumptions:::, but external requirements.`\n(emphasis mine)\n\nThe underlying BAL protocol support fee-on-transfer tokens, so should Aura.\n\n### Proof of Concept\n\n```solidity\nFile: contracts/ExtraRewardsDistributor.sol   #1\n\n87       function _addReward(\n88           address _token,\n89           uint256 _amount,\n90           uint256 _epoch\n91       ) internal nonReentrant {\n92           // Pull before reward accrual\n93           IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n94   \n95           //convert to reward per token\n96           uint256 supply = auraLocker.totalSupplyAtEpoch(_epoch);\n97           uint256 rPerT = (_amount * 1e20) / supply;\n98           rewardData[_token][_epoch] += rPerT;\n```\n\n[ExtraRewardsDistributor.sol#L87-L98](https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/ExtraRewardsDistributor.sol#L87-L98)<br>\n\nIf a fee is charged the total amount available to be transferred later will be less than the `_amount` passed in.\n\nConsider the following scenario:<br>\nUser A holds 98% of the total supply of vlBAL (the system is being bootstrapped)<br>\nUser B holds 1%<br>\nUser C holds 1%\n\n1.  `_token` is given out as a reward. It is a fee-on-transfer token with a fee of 2%\n2.  Nobody claims the reward until it's fully available (to save gas on transaction fees)\n3.  User A is the first to claim his/her reward and gets 98% of the reward, leaving 0 wei of the token left (since the other 2% was already taken as a fee by the token itself)\n4.  User B tries to claim and the call reverts since there's no balance left\n5.  User C tries to claim and the call reverts for them too\n6.  Users B and C are angry and stop using Aura\n\n```solidity\nFile: contracts/ExtraRewardsDistributor.sol   #2\n\n87       function _addReward(\n88           address _token,\n89           uint256 _amount,\n90           uint256 _epoch\n91       ) internal nonReentrant {\n92           // Pull before reward accrual\n93           IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n94   \n95           //convert to reward per token\n96           uint256 supply = auraLocker.totalSupplyAtEpoch(_epoch);\n97           uint256 rPerT = (_amount * 1e20) / supply;\n98           rewardData[_token][_epoch] += rPerT;\n```\n\n[ExtraRewardsDistributor.sol#L87-L98](https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/ExtraRewardsDistributor.sol#L87-L98)\n\n### Recommended Mitigation Steps\n\nMeasure the contract balance before and after the transfer, and use the difference as the amount, rather than the stated amount.\n\n**[0xMaharishi (Aura Finance) disputed and commented](https://github.com/code-423n4/2022-05-aura-findings/issues/176#issuecomment-1138718030):**\n > This contract is optional to use - it is not supposed to support fee bearing tokens.\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-05-aura-findings/issues/176#issuecomment-1179232751):**\n > See my comment on issue [#18](https://github.com/code-423n4/2022-05-aura-findings/issues/18): \"There are several cases in the code reported where the token in question comes from an external (non-admin, non-protocol) source. One of these is the addReward functionality (ExtraRewards). This would indeed cause an accounting issue and allow a potential malicious actor to send rewards which cause distribution to fail due to lack of funds. Just because you don't plan to use fee on transfer tokens, does not mean they will not be used. This should be protected against in the scenarios where it could cause an issue.\n\n > That said, this clearly requires external factors and relies on hypothetical attack motivation that seems unlikely to me. I think it should be included as a medium risk.\"\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-05-aura",
  "Code": [
    {
      "filename": "contracts/ExtraRewardsDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport { IExtraRewardsDistributor, IAuraLocker } from \"./Interfaces.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol\";\n\n/**\n * @title   ExtraRewardsDistributor\n * @author  adapted from ConvexFinance\n * @notice  Allows anyone to distribute rewards to the AuraLocker at a given epoch.\n */\ncontract ExtraRewardsDistributor is ReentrancyGuard, IExtraRewardsDistributor {\n    using SafeERC20 for IERC20;\n\n    IAuraLocker public immutable auraLocker;\n\n    // token -> epoch -> amount\n    mapping(address => mapping(uint256 => uint256)) public rewardData;\n    // token -> epochList\n    mapping(address => uint256[]) public rewardEpochs;\n    // token -> account -> last claimed epoch index\n    mapping(address => mapping(address => uint256)) public userClaims;\n\n    /* ========== EVENTS ========== */\n\n    event RewardAdded(address indexed token, uint256 indexed epoch, uint256 reward);\n    event RewardPaid(address indexed user, address indexed token, uint256 reward, uint256 index);\n    event RewardForfeited(address indexed user, address indexed token, uint256 index);\n\n    /**\n     * @dev Simple constructoor\n     * @param _auraLocker Aura Locker address\n     */\n    constructor(address _auraLocker) {\n        auraLocker = IAuraLocker(_auraLocker);\n    }\n\n    /* ========== ADD REWARDS ========== */\n\n    /**\n     * @notice Add a reward to the current epoch. can be called multiple times for the same reward token\n     * @param _token    Reward token address\n     * @param _amount   Amount of reward tokenπ\n     */\n    function addReward(address _token, uint256 _amount) external {\n        auraLocker.checkpointEpoch();\n\n        uint256 latestEpoch = auraLocker.epochCount() - 1;\n        _addReward(_token, _amount, latestEpoch);\n    }\n\n    /**\n     * @notice Add reward token to a specific epoch\n     * @param _token    Reward token address\n     * @param _amount   Amount of reward tokens to add\n     * @param _epoch    Which epoch to add to (must be less than the previous epoch)\n     */\n    function addRewardToEpoch(\n        address _token,\n        uint256 _amount,\n        uint256 _epoch\n    ) external {\n        auraLocker.checkpointEpoch();\n\n        uint256 latestEpoch = auraLocker.epochCount() - 1;\n        require(_epoch <= latestEpoch, \"Cannot assign to the future\");\n\n        if (_epoch == latestEpoch) {\n            _addReward(_token, _amount, latestEpoch);\n        } else {\n            uint256 len = rewardEpochs[_token].length;\n            require(len == 0 || rewardEpochs[_token][len - 1] < _epoch, \"Cannot backdate to this epoch\");\n\n            _addReward(_token, _amount, _epoch);\n        }\n    }\n\n    /**\n     * @notice  Transfer reward tokens from sender to contract for vlCVX holders\n     * @dev     Add reward token for specific epoch\n     * @param _token    Reward token address\n     * @param _amount   Amount of reward tokens\n     * @param _epoch    Epoch to add tokens to\n     */\n    function _addReward(\n        address _token,\n        uint256 _amount,\n        uint256 _epoch\n    ) internal nonReentrant {\n        // Pull before reward accrual\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n\n        //convert to reward per token\n        uint256 supply = auraLocker.totalSupplyAtEpoch(_epoch);\n        uint256 rPerT = (_amount * 1e20) / supply;\n        rewardData[_token][_epoch] += rPerT;\n\n        //add epoch to list\n        uint256 len = rewardEpochs[_token].length;\n        if (len == 0 || rewardEpochs[_token][len - 1] < _epoch) {\n            rewardEpochs[_token].push(_epoch);\n        }\n\n        //event\n        emit RewardAdded(_token, _epoch, _amount);\n    }\n\n    /* ========== GET REWARDS ========== */\n\n    /**\n     * @notice Claim rewards for a specific token since the first epoch.\n     * @param _account  Address of vlCVX holder\n     * @param _token    Reward token address\n     */\n    function getReward(address _account, address _token) public {\n        _getReward(_account, _token, 0);\n    }\n\n    /**\n     * @notice Claim rewards for a specific token at a specific epoch\n     * @param _account      Address of vlCVX holder\n     * @param _token        Reward token address\n     * @param _startIndex   Index of rewardEpochs[_token] to start checking for rewards from\n     */\n    function getReward(\n        address _account,\n        address _token,\n        uint256 _startIndex\n    ) public {\n        _getReward(_account, _token, _startIndex);\n    }\n\n    /**\n     * @notice Claim rewards for a specific token at a specific epoch\n     * @param _account     Address of vlCVX holder\n     * @param _token       Reward token address\n     * @param _startIndex  Index of rewardEpochs[_token] to start checking for rewards from\n     */\n    function _getReward(\n        address _account,\n        address _token,\n        uint256 _startIndex\n    ) public {\n        //get claimable tokens\n        (uint256 claimableTokens, uint256 index) = _allClaimableRewards(_account, _token, _startIndex);\n\n        if (claimableTokens > 0) {\n            //set claim checkpoint\n            userClaims[_token][_account] = index;\n\n            //send\n            IERC20(_token).safeTransfer(_account, claimableTokens);\n\n            //event\n            emit RewardPaid(_account, _token, claimableTokens, index);\n        }\n    }\n\n    /**\n     * @notice  Allow a user to set their claimed index forward without claiming rewards\n     *          Because claims cycle through all periods that a specific reward was given\n     *          there becomes a situation where, for example, a new user could lock\n     *          2 years from now and try to claim a token that was given out every week prior.\n     *          This would result in a 2mil gas checkpoint.(about 20k gas * 52 weeks * 2 years)\n     * @param _token  Reward token to forfeit\n     * @param _index  Epoch index to forfeit from\n     */\n    function forfeitRewards(address _token, uint256 _index) external {\n        require(_index > 0 && _index < rewardEpochs[_token].length - 1, \"!past\");\n        require(_index >= userClaims[_token][msg.sender], \"already claimed\");\n\n        //set claim checkpoint. next claim starts from index+1\n        userClaims[_token][msg.sender] = _index + 1;\n\n        emit RewardForfeited(msg.sender, _token, _index);\n    }\n\n    /* ========== VIEW REWARDS ========== */\n\n    /**\n     * @notice Get claimable rewards (rewardToken) for vlCVX holder\n     * @param _account  Address of vlCVX holder\n     * @param _token    Reward token address\n     */\n    function claimableRewards(address _account, address _token) external view returns (uint256) {\n        (uint256 rewards, ) = _allClaimableRewards(_account, _token, 0);\n        return rewards;\n    }\n\n    /**\n     * @notice Get claimable rewards for a token at a specific epoch\n     * @param _account     Address of vlCVX holder\n     * @param _token       Reward token address\n     * @param _epoch       The epoch to check for rewards\n     */\n    function claimableRewardsAtEpoch(\n        address _account,\n        address _token,\n        uint256 _epoch\n    ) external view returns (uint256) {\n        return _claimableRewards(_account, _token, _epoch);\n    }\n\n    /**\n     * @notice  Get all claimable rewards by looping through each epoch starting with the latest\n     *          saved epoch the user last claimed from\n     * @param _account  Address of vlCVX holder\n     * @param _token    Reward token\n     * @param _startIndex  Index of rewardEpochs[_token] to start checking for rewards from\n     */\n    function _allClaimableRewards(\n        address _account,\n        address _token,\n        uint256 _startIndex\n    ) internal view returns (uint256, uint256) {\n        uint256 latestEpoch = auraLocker.epochCount() - 1;\n        // e.g. tokenEpochs = 31, 21\n        uint256 tokenEpochs = rewardEpochs[_token].length;\n\n        // e.g. epochIndex = 0\n        uint256 epochIndex = userClaims[_token][_account];\n        // e.g. epochIndex = 27 > 0 ? 27 : 0 = 27\n        epochIndex = _startIndex > epochIndex ? _startIndex : epochIndex;\n\n        if (epochIndex >= tokenEpochs) {\n            return (0, tokenEpochs);\n        }\n\n        uint256 claimableTokens = 0;\n\n        for (uint256 i = epochIndex; i < tokenEpochs; i++) {\n            //only claimable after rewards are \"locked in\"\n            if (rewardEpochs[_token][i] < latestEpoch) {\n                claimableTokens += _claimableRewards(_account, _token, rewardEpochs[_token][i]);\n                //return index user claims should be set to\n                epochIndex = i + 1;\n            }\n        }\n        return (claimableTokens, epochIndex);\n    }\n\n    /**\n     * @notice Get claimable rewards for a token at a specific epoch\n     * @param _account     Address of vlCVX holder\n     * @param _token       Reward token address\n     * @param _epoch       The epoch to check for rewards\n     */\n    function _claimableRewards(\n        address _account,\n        address _token,\n        uint256 _epoch\n    ) internal view returns (uint256) {\n        //get balance and calc share\n        uint256 balance = auraLocker.balanceAtEpochOf(_epoch, _account);\n        return (balance * rewardData[_token][_epoch]) / 1e20;\n    }\n\n    /**\n     * @notice Simply gets the current epoch count for a given reward token\n     * @param _token    Reward token address\n     * @return _epochs  Number of epochs\n     */\n    function rewardEpochsCount(address _token) external view returns (uint256) {\n        return rewardEpochs[_token].length;\n    }\n}"
    },
    {
      "filename": "contracts/ExtraRewardsDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport { IExtraRewardsDistributor, IAuraLocker } from \"./Interfaces.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol\";\n\n/**\n * @title   ExtraRewardsDistributor\n * @author  adapted from ConvexFinance\n * @notice  Allows anyone to distribute rewards to the AuraLocker at a given epoch.\n */\ncontract ExtraRewardsDistributor is ReentrancyGuard, IExtraRewardsDistributor {\n    using SafeERC20 for IERC20;\n\n    IAuraLocker public immutable auraLocker;\n\n    // token -> epoch -> amount\n    mapping(address => mapping(uint256 => uint256)) public rewardData;\n    // token -> epochList\n    mapping(address => uint256[]) public rewardEpochs;\n    // token -> account -> last claimed epoch index\n    mapping(address => mapping(address => uint256)) public userClaims;\n\n    /* ========== EVENTS ========== */\n\n    event RewardAdded(address indexed token, uint256 indexed epoch, uint256 reward);\n    event RewardPaid(address indexed user, address indexed token, uint256 reward, uint256 index);\n    event RewardForfeited(address indexed user, address indexed token, uint256 index);\n\n    /**\n     * @dev Simple constructoor\n     * @param _auraLocker Aura Locker address\n     */\n    constructor(address _auraLocker) {\n        auraLocker = IAuraLocker(_auraLocker);\n    }\n\n    /* ========== ADD REWARDS ========== */\n\n    /**\n     * @notice Add a reward to the current epoch. can be called multiple times for the same reward token\n     * @param _token    Reward token address\n     * @param _amount   Amount of reward tokenπ\n     */\n    function addReward(address _token, uint256 _amount) external {\n        auraLocker.checkpointEpoch();\n\n        uint256 latestEpoch = auraLocker.epochCount() - 1;\n        _addReward(_token, _amount, latestEpoch);\n    }\n\n    /**\n     * @notice Add reward token to a specific epoch\n     * @param _token    Reward token address\n     * @param _amount   Amount of reward tokens to add\n     * @param _epoch    Which epoch to add to (must be less than the previous epoch)\n     */\n    function addRewardToEpoch(\n        address _token,\n        uint256 _amount,\n        uint256 _epoch\n    ) external {\n        auraLocker.checkpointEpoch();\n\n        uint256 latestEpoch = auraLocker.epochCount() - 1;\n        require(_epoch <= latestEpoch, \"Cannot assign to the future\");\n\n        if (_epoch == latestEpoch) {\n            _addReward(_token, _amount, latestEpoch);\n        } else {\n            uint256 len = rewardEpochs[_token].length;\n            require(len == 0 || rewardEpochs[_token][len - 1] < _epoch, \"Cannot backdate to this epoch\");\n\n            _addReward(_token, _amount, _epoch);\n        }\n    }\n\n    /**\n     * @notice  Transfer reward tokens from sender to contract for vlCVX holders\n     * @dev     Add reward token for specific epoch\n     * @param _token    Reward token address\n     * @param _amount   Amount of reward tokens\n     * @param _epoch    Epoch to add tokens to\n     */\n    function _addReward(\n        address _token,\n        uint256 _amount,\n        uint256 _epoch\n    ) internal nonReentrant {\n        // Pull before reward accrual\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n\n        //convert to reward per token\n        uint256 supply = auraLocker.totalSupplyAtEpoch(_epoch);\n        uint256 rPerT = (_amount * 1e20) / supply;\n        rewardData[_token][_epoch] += rPerT;\n\n        //add epoch to list\n        uint256 len = rewardEpochs[_token].length;\n        if (len == 0 || rewardEpochs[_token][len - 1] < _epoch) {\n            rewardEpochs[_token].push(_epoch);\n        }\n\n        //event\n        emit RewardAdded(_token, _epoch, _amount);\n    }\n\n    /* ========== GET REWARDS ========== */\n\n    /**\n     * @notice Claim rewards for a specific token since the first epoch.\n     * @param _account  Address of vlCVX holder\n     * @param _token    Reward token address\n     */\n    function getReward(address _account, address _token) public {\n        _getReward(_account, _token, 0);\n    }\n\n    /**\n     * @notice Claim rewards for a specific token at a specific epoch\n     * @param _account      Address of vlCVX holder\n     * @param _token        Reward token address\n     * @param _startIndex   Index of rewardEpochs[_token] to start checking for rewards from\n     */\n    function getReward(\n        address _account,\n        address _token,\n        uint256 _startIndex\n    ) public {\n        _getReward(_account, _token, _startIndex);\n    }\n\n    /**\n     * @notice Claim rewards for a specific token at a specific epoch\n     * @param _account     Address of vlCVX holder\n     * @param _token       Reward token address\n     * @param _startIndex  Index of rewardEpochs[_token] to start checking for rewards from\n     */\n    function _getReward(\n        address _account,\n        address _token,\n        uint256 _startIndex\n    ) public {\n        //get claimable tokens\n        (uint256 claimableTokens, uint256 index) = _allClaimableRewards(_account, _token, _startIndex);\n\n        if (claimableTokens > 0) {\n            //set claim checkpoint\n            userClaims[_token][_account] = index;\n\n            //send\n            IERC20(_token).safeTransfer(_account, claimableTokens);\n\n            //event\n            emit RewardPaid(_account, _token, claimableTokens, index);\n        }\n    }\n\n    /**\n     * @notice  Allow a user to set their claimed index forward without claiming rewards\n     *          Because claims cycle through all periods that a specific reward was given\n     *          there becomes a situation where, for example, a new user could lock\n     *          2 years from now and try to claim a token that was given out every week prior.\n     *          This would result in a 2mil gas checkpoint.(about 20k gas * 52 weeks * 2 years)\n     * @param _token  Reward token to forfeit\n     * @param _index  Epoch index to forfeit from\n     */\n    function forfeitRewards(address _token, uint256 _index) external {\n        require(_index > 0 && _index < rewardEpochs[_token].length - 1, \"!past\");\n        require(_index >= userClaims[_token][msg.sender], \"already claimed\");\n\n        //set claim checkpoint. next claim starts from index+1\n        userClaims[_token][msg.sender] = _index + 1;\n\n        emit RewardForfeited(msg.sender, _token, _index);\n    }\n\n    /* ========== VIEW REWARDS ========== */\n\n    /**\n     * @notice Get claimable rewards (rewardToken) for vlCVX holder\n     * @param _account  Address of vlCVX holder\n     * @param _token    Reward token address\n     */\n    function claimableRewards(address _account, address _token) external view returns (uint256) {\n        (uint256 rewards, ) = _allClaimableRewards(_account, _token, 0);\n        return rewards;\n    }\n\n    /**\n     * @notice Get claimable rewards for a token at a specific epoch\n     * @param _account     Address of vlCVX holder\n     * @param _token       Reward token address\n     * @param _epoch       The epoch to check for rewards\n     */\n    function claimableRewardsAtEpoch(\n        address _account,\n        address _token,\n        uint256 _epoch\n    ) external view returns (uint256) {\n        return _claimableRewards(_account, _token, _epoch);\n    }\n\n    /**\n     * @notice  Get all claimable rewards by looping through each epoch starting with the latest\n     *          saved epoch the user last claimed from\n     * @param _account  Address of vlCVX holder\n     * @param _token    Reward token\n     * @param _startIndex  Index of rewardEpochs[_token] to start checking for rewards from\n     */\n    function _allClaimableRewards(\n        address _account,\n        address _token,\n        uint256 _startIndex\n    ) internal view returns (uint256, uint256) {\n        uint256 latestEpoch = auraLocker.epochCount() - 1;\n        // e.g. tokenEpochs = 31, 21\n        uint256 tokenEpochs = rewardEpochs[_token].length;\n\n        // e.g. epochIndex = 0\n        uint256 epochIndex = userClaims[_token][_account];\n        // e.g. epochIndex = 27 > 0 ? 27 : 0 = 27\n        epochIndex = _startIndex > epochIndex ? _startIndex : epochIndex;\n\n        if (epochIndex >= tokenEpochs) {\n            return (0, tokenEpochs);\n        }\n\n        uint256 claimableTokens = 0;\n\n        for (uint256 i = epochIndex; i < tokenEpochs; i++) {\n            //only claimable after rewards are \"locked in\"\n            if (rewardEpochs[_token][i] < latestEpoch) {\n                claimableTokens += _claimableRewards(_account, _token, rewardEpochs[_token][i]);\n                //return index user claims should be set to\n                epochIndex = i + 1;\n            }\n        }\n        return (claimableTokens, epochIndex);\n    }\n\n    /**\n     * @notice Get claimable rewards for a token at a specific epoch\n     * @param _account     Address of vlCVX holder\n     * @param _token       Reward token address\n     * @param _epoch       The epoch to check for rewards\n     */\n    function _claimableRewards(\n        address _account,\n        address _token,\n        uint256 _epoch\n    ) internal view returns (uint256) {\n        //get balance and calc share\n        uint256 balance = auraLocker.balanceAtEpochOf(_epoch, _account);\n        return (balance * rewardData[_token][_epoch]) / 1e20;\n    }\n\n    /**\n     * @notice Simply gets the current epoch count for a given reward token\n     * @param _token    Reward token address\n     * @return _epochs  Number of epochs\n     */\n    function rewardEpochsCount(address _token) external view returns (uint256) {\n        return rewardEpochs[_token].length;\n    }\n}"
    }
  ]
}