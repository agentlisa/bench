{
  "Title": "Misleading comments",
  "Content": "Comments are meant to be helpful and describe the intent of the code block. However, in multiple parts of the codebase, comments are not consistent with the code that is written or do not add any value to the reader. These are some examples:\n\n\n* The function `_deposit` in both the [`STETHVault`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/vaults/STETHVault.sol#L112) and [`BaseVault`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/vaults/BaseVault.sol#L405) contracts does not create any shares even though the comments say so.\n* The description of each parameter on [`setParameter`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/configuration/ConfigurationManager.sol#L19-L24), [`getParameter`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/configuration/ConfigurationManager.sol#L34-L37) and [`getGlobalParameter`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/configuration/ConfigurationManager.sol#L42-L45) does not add any value to the reader.\n* The [`target`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/configuration/ConfigurationManager.sol#L21) parameter on `setParameter` has a wrong description.\n* The function `_spendCap` has the [same description](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/mixins/Capped.sol#L26) as `availableCap`.\n\n\nConsider correcting the comments to not mislead users or developers and write comments that add value to the reader. This will improve code clarity and consistency between docstrings and contract implementations.\n\n\n**Update:** *Fixed in commit [`3ad59d0`](https://github.com/pods-finance/yield-contracts/pull/55/commits/3ad59d05cf55e5e009dc7d1ed3d77372f3e4a882).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/vaults/STETHVault.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.9;\n\nimport \"./BaseVault.sol\";\n\n/**\n * @title A Vault that use variable weekly yields to buy calls\n * @author Pods Finance\n */\ncontract STETHVault is BaseVault {\n    using SafeERC20 for IERC20Metadata;\n    using AuxMath for uint256;\n    using AuxMath for AuxMath.Fractional;\n    using DepositQueueLib for DepositQueueLib.DepositQueue;\n\n    uint8 public immutable sharePriceDecimals;\n    uint256 public lastRoundAssets;\n    AuxMath.Fractional public lastSharePrice;\n\n    /*\n     @dev investorRatio is the proportion that the weekly yield will be splitted\n     The precision of this number is set by the variable DENOMINATOR. 5000 is equivalent to 50%\n    */\n    uint256 public constant investorRatio = 5000;\n    address public immutable investor;\n\n    event StartRoundData(uint256 indexed roundId, uint256 lastRoundAssets, uint256 sharePrice);\n    event EndRoundData(\n        uint256 indexed roundId,\n        uint256 roundAccruedInterest,\n        uint256 investmentYield,\n        uint256 idleAssets\n    );\n    event SharePrice(uint256 indexed roundId, uint256 startSharePrice, uint256 endSharePrice);\n\n    constructor(\n        IConfigurationManager _configuration,\n        IERC20Metadata _asset,\n        address _investor\n    ) BaseVault(_configuration, _asset) {\n        investor = _investor;\n        sharePriceDecimals = _asset.decimals();\n    }\n\n    /**\n     * @inheritdoc ERC20\n     */\n    function name() public view override returns (string memory) {\n        return string(abi.encodePacked(_asset.symbol(), \" Volatility Vault\"));\n    }\n\n    /**\n     * @inheritdoc ERC20\n     */\n    function symbol() public view override returns (string memory) {\n        return string(abi.encodePacked(_asset.symbol(), \"vv\"));\n    }\n\n    function _afterRoundStart(uint256) internal override {\n        uint256 supply = totalSupply();\n\n        lastRoundAssets = totalAssets();\n        lastSharePrice = AuxMath.Fractional({ numerator: supply == 0 ? 0 : lastRoundAssets, denominator: supply });\n\n        uint256 sharePrice = lastSharePrice.denominator == 0 ? 0 : lastSharePrice.mulDivDown(10**sharePriceDecimals);\n        emit StartRoundData(currentRoundId, lastRoundAssets, sharePrice);\n    }\n\n    function _afterRoundEnd() internal override {\n        uint256 roundAccruedInterest = 0;\n        uint256 endSharePrice = 0;\n        uint256 investmentYield = _asset.balanceOf(investor);\n        uint256 supply = totalSupply();\n\n        if (supply != 0) {\n            roundAccruedInterest = totalAssets() - lastRoundAssets;\n            uint256 investmentAmount = (roundAccruedInterest * investorRatio) / DENOMINATOR;\n\n            // Pulls the yields from investor\n            if (investmentYield > 0) {\n                _asset.safeTransferFrom(investor, address(this), investmentYield);\n            }\n\n            if (investmentAmount > 0) {\n                _asset.safeTransfer(investor, investmentAmount);\n            }\n\n            // End Share price needs to be calculated after the transfers between investor and vault\n            endSharePrice = (totalAssets()).mulDivDown(10**sharePriceDecimals, supply);\n        }\n        uint256 startSharePrice = lastSharePrice.denominator == 0\n            ? 0\n            : lastSharePrice.mulDivDown(10**sharePriceDecimals);\n\n        emit EndRoundData(currentRoundId, roundAccruedInterest, investmentYield, totalIdleAssets());\n        emit SharePrice(currentRoundId, startSharePrice, endSharePrice);\n    }\n\n    function _beforeWithdraw(uint256 shares, uint256) internal override {\n        lastRoundAssets -= shares.mulDivDown(lastSharePrice);\n    }\n\n    /**\n     * @dev See {BaseVault-totalAssets}.\n     */\n    function totalAssets() public view override returns (uint256) {\n        return _asset.balanceOf(address(this)) - totalIdleAssets();\n    }\n\n    /**\n     * @dev Pull assets from the caller and create shares to the receiver\n     */\n    function _deposit(\n        uint256 assets,\n        uint256 shares,\n        address receiver\n    ) internal override returns (uint256 depositedAssets) {\n        _spendCap(shares);\n\n        assets = _stETHTransferFrom(msg.sender, address(this), assets);\n        depositQueue.push(DepositQueueLib.DepositEntry(receiver, assets));\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        return assets;\n    }\n\n    function _withdraw(\n        uint256 assets,\n        uint256 shares,\n        address receiver,\n        address owner\n    ) internal virtual override returns (uint256 receiverAssets, uint256 receiverShares) {\n        if (msg.sender != owner) {\n            _spendAllowance(owner, msg.sender, shares);\n        }\n\n        _burn(owner, shares);\n        _restoreCap(shares);\n\n        // Apply custom withdraw logic\n        _beforeWithdraw(shares, assets);\n\n        uint256 fee = _getFee(assets);\n        receiverAssets = assets - fee;\n        receiverShares = shares;\n\n        emit Withdraw(msg.sender, receiver, owner, receiverAssets, shares);\n\n        _asset.safeTransfer(receiver, receiverAssets);\n\n        if (fee > 0) {\n            emit FeeCollected(fee);\n            _asset.safeTransfer(controller(), fee);\n        }\n    }\n\n    /**\n     * @dev Moves `amount` of stETH from `from` to `to` using the\n     * allowance mechanism.\n     *\n     * Note that due to division rounding, not always is not possible to move\n     * the entire amount, hence transfer is attempted, returning the\n     * `effectiveAmount` transferred.\n     *\n     * For more information refer to: https://docs.lido.fi/guides/steth-integration-guide#1-wei-corner-case\n     */\n    function _stETHTransferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) internal returns (uint256 effectiveAmount) {\n        uint256 balanceBefore = _asset.balanceOf(to);\n        if (from == address(this)) {\n            _asset.safeTransfer(to, amount);\n        } else {\n            _asset.safeTransferFrom(from, to, amount);\n        }\n        return _asset.balanceOf(to) - balanceBefore;\n    }\n}"
    },
    {
      "filename": "contracts/configuration/ConfigurationManager.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/IConfigurationManager.sol\";\n\n/**\n * @title ConfigurationManager\n * @author Pods Finance\n * @notice Allows contracts to read protocol-wide settings\n */\ncontract ConfigurationManager is IConfigurationManager, Ownable {\n    mapping(address => mapping(bytes32 => uint256)) private _parameters;\n    mapping(address => bool) private _allowedVault;\n    address private immutable _global = address(0);\n    bytes32 constant CAP = \"CAP\";\n\n    /**\n     * @dev Define a parameter\n     * @param target The parameter name\n     * @param name The parameter name\n     * @param value The parameter value\n     */\n    function setParameter(\n        address target,\n        bytes32 name,\n        uint256 value\n    ) public override onlyOwner {\n        _parameters[target][name] = value;\n        emit ParameterSet(target, name, value);\n    }\n\n    /**\n     * @dev Get the value of a defined parameter\n     * @param name The parameter name\n     */\n    function getParameter(address target, bytes32 name) external view override returns (uint256) {\n        return _parameters[target][name];\n    }\n\n    /**\n     * @dev Get the value of a defined parameter\n     * @param name The parameter name\n     */\n    function getGlobalParameter(bytes32 name) external view override returns (uint256) {\n        return _parameters[_global][name];\n    }\n\n    /**\n     * @dev Defines a cap value to a contract\n     * @param target The contract address\n     * @param value Cap amount\n     */\n    function setCap(address target, uint256 value) external override onlyOwner {\n        if (target == address(0)) revert ConfigurationManager__InvalidCapTarget();\n        setParameter(target, CAP, value);\n        emit SetCap(target, value);\n    }\n\n    /**\n     * @dev Get the value of a defined cap\n     * Note that 0 cap means that the contract is not capped\n     * @param target The contract address\n     */\n    function getCap(address target) external view override returns (uint256) {\n        return this.getParameter(target, CAP);\n    }\n\n    /**\n     * @dev Sets the allowance to migrate to a `vault` address\n     * @param vault The contract address\n     * @param allowed Allowance status\n     */\n    function setAllowedVault(address vault, bool allowed) external override onlyOwner {\n        _allowedVault[vault] = allowed;\n        emit VaultAllowanceSet(vault, allowed);\n    }\n\n    /**\n     * @dev Returns if a vault is allowed\n     * @param vault The contract address\n     */\n    function isVaultAllowed(address vault) external view override returns (bool) {\n        return _allowedVault[vault];\n    }\n}"
    },
    {
      "filename": "contracts/configuration/ConfigurationManager.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/IConfigurationManager.sol\";\n\n/**\n * @title ConfigurationManager\n * @author Pods Finance\n * @notice Allows contracts to read protocol-wide settings\n */\ncontract ConfigurationManager is IConfigurationManager, Ownable {\n    mapping(address => mapping(bytes32 => uint256)) private _parameters;\n    mapping(address => bool) private _allowedVault;\n    address private immutable _global = address(0);\n    bytes32 constant CAP = \"CAP\";\n\n    /**\n     * @dev Define a parameter\n     * @param target The parameter name\n     * @param name The parameter name\n     * @param value The parameter value\n     */\n    function setParameter(\n        address target,\n        bytes32 name,\n        uint256 value\n    ) public override onlyOwner {\n        _parameters[target][name] = value;\n        emit ParameterSet(target, name, value);\n    }\n\n    /**\n     * @dev Get the value of a defined parameter\n     * @param name The parameter name\n     */\n    function getParameter(address target, bytes32 name) external view override returns (uint256) {\n        return _parameters[target][name];\n    }\n\n    /**\n     * @dev Get the value of a defined parameter\n     * @param name The parameter name\n     */\n    function getGlobalParameter(bytes32 name) external view override returns (uint256) {\n        return _parameters[_global][name];\n    }\n\n    /**\n     * @dev Defines a cap value to a contract\n     * @param target The contract address\n     * @param value Cap amount\n     */\n    function setCap(address target, uint256 value) external override onlyOwner {\n        if (target == address(0)) revert ConfigurationManager__InvalidCapTarget();\n        setParameter(target, CAP, value);\n        emit SetCap(target, value);\n    }\n\n    /**\n     * @dev Get the value of a defined cap\n     * Note that 0 cap means that the contract is not capped\n     * @param target The contract address\n     */\n    function getCap(address target) external view override returns (uint256) {\n        return this.getParameter(target, CAP);\n    }\n\n    /**\n     * @dev Sets the allowance to migrate to a `vault` address\n     * @param vault The contract address\n     * @param allowed Allowance status\n     */\n    function setAllowedVault(address vault, bool allowed) external override onlyOwner {\n        _allowedVault[vault] = allowed;\n        emit VaultAllowanceSet(vault, allowed);\n    }\n\n    /**\n     * @dev Returns if a vault is allowed\n     * @param vault The contract address\n     */\n    function isVaultAllowed(address vault) external view override returns (bool) {\n        return _allowedVault[vault];\n    }\n}"
    },
    {
      "filename": "contracts/mixins/Capped.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.9;\n\nimport \"../interfaces/IConfigurationManager.sol\";\n\nabstract contract Capped {\n    IConfigurationManager private immutable _configuration;\n    uint256 public spentCap;\n\n    error Capped__AmountExceedsCap(uint256 amount, uint256 available);\n\n    constructor(IConfigurationManager _configuration_) {\n        _configuration = _configuration_;\n    }\n\n    /**\n     * @dev Returns the amount that could be used.\n     */\n    function availableCap() public view returns (uint256) {\n        uint256 cap = _configuration.getCap(address(this));\n        return cap == 0 ? type(uint256).max : cap - spentCap;\n    }\n\n    /**\n     * @dev Returns the amount that could be used.\n     * @param amount The amount to be spent\n     */\n    function _spendCap(uint256 amount) internal {\n        uint256 available = availableCap();\n        if (amount > available) revert Capped__AmountExceedsCap(amount, available);\n        spentCap += amount;\n    }\n\n    /**\n     * @dev Restores the cap.\n     * @param amount The amount to be restored\n     */\n    function _restoreCap(uint256 amount) internal {\n        if (availableCap() != type(uint256).max) {\n            spentCap -= amount;\n        }\n    }\n}"
    }
  ]
}