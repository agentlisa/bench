{
  "Title": "[L-03] Precision loss in `withdraw(...)` can lead to all `asdUDSC` being burned while not all `USDC` is withdrawn",
  "Content": "\nSee [`withdraw`(...)](https://github.com/code-423n4/2024-03-canto/blob/1516028017a34ccfb4b0b19f5c5f17f5fa4cad42/contracts/asd/asdUSDC.sol#L52-L66) method:  \n\n```solidity\nfunction withdraw(address _usdcVersion, uint256 _amount) external returns (uint256) {\n    // check whitelist\n    require(whitelistedUSDCVersions[_usdcVersion], \"ASDUSDC: USDC version not whitelisted\");\n    // burn tokens\n    _burn(msg.sender, _amount);\n    // calculate amount to withdraw\n    uint256 amountToWithdraw = _amount / (10 ** (this.decimals() - ERC20(_usdcVersion).decimals()));   // @audit precision loss\n    // check balance\n    require(usdcBalances[_usdcVersion] >= amountToWithdraw, \"ASDUSDC: Not enough USDC balance\");\n    // transfer USDC\n    usdcBalances[_usdcVersion] -= amountToWithdraw;\n    SafeERC20.safeTransfer(ERC20(_usdcVersion), msg.sender, amountToWithdraw);\n    emit Withdrawal(_usdcVersion, amountToWithdraw);\n    return amountToWithdraw;\n}\n```\n\nThe `asdUDSC` token has 18 decimals. For example, if the `USDC` token has 6 decimals (see [ERC20 token behaviors in scope](https://github.com/code-423n4/2024-03-canto?tab=readme-ov-file#erc20-token-behaviors-in-scope)), the burned `_amount` gets divided by `10**12` leading to a precision loss in the resulting `amountToWithdraw`.\n\n### Proof of Concept\n\nThe following test case, which should deposit and withdraw with differing decimals, demonstrates how all `asdUDSC` is burned while not all `USDC4` (with 6 decimals) is withdrawn:\n\n```diff\ndiff --git a/contracts/test-contracts/TestERC20.sol b/contracts/test-contracts/TestERC20.sol\nindex dccc64d..229d8c6 100644\n--- a/contracts/test-contracts/TestERC20.sol\n+++ b/contracts/test-contracts/TestERC20.sol\n@@ -3,7 +3,19 @@ pragma solidity ^0.8.22;\n import {IERC20, ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n \n contract TestERC20 is ERC20 {\n+\n+    uint8 private _decimals;\n+\n     constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) {\n+        _decimals = 18;\n         _mint(msg.sender, 1000 ether);\n     }\n+\n+    function decimals() public view override returns (uint8) {\n+        return _decimals;\n+    }\n+\n+    function setDecimals(uint8 _val) public {\n+        _decimals = _val;\n+    }\n }\ndiff --git a/test/ASDUSDC.js b/test/ASDUSDC.js\nindex 62e66b8..5a100b0 100644\n--- a/test/ASDUSDC.js\n+++ b/test/ASDUSDC.js\n@@ -6,6 +6,7 @@ describe(\"ASDUSDC\", function () {\n     let usdc1;\n     let usdc2;\n     let usdc3;\n+    let usdc4;\n     this.beforeEach(async () => {\n         // deploy ASDUSDC contract\n         asdUSDC = await ethers.deployContract(\"ASDUSDC\");\n@@ -13,9 +14,13 @@ describe(\"ASDUSDC\", function () {\n         usdc1 = await ethers.deployContract(\"TestERC20\", [\"USDC1\", \"USDC1\"]);\n         usdc2 = await ethers.deployContract(\"TestERC20\", [\"USDC2\", \"USDC2\"]);\n         usdc3 = await ethers.deployContract(\"TestERC20\", [\"USDC3\", \"USDC3\"]);\n-        // set whitelist for 2 of the tokens\n+        usdc4 = await ethers.deployContract(\"TestERC20\", [\"USDC4\", \"USDC4\"]);\n+        await usdc4.setDecimals(6);\n+\n+        // set whitelist for 3 of the tokens\n         await asdUSDC.updateWhitelist(usdc1.target, true);\n         await asdUSDC.updateWhitelist(usdc2.target, true);\n+        await asdUSDC.updateWhitelist(usdc4.target, true);\n     });\n \n     it(\"should set whitelist for correct contract addresses\", async () => {\n@@ -43,6 +48,26 @@ describe(\"ASDUSDC\", function () {\n         await expect(asdUSDC.deposit(usdc3.target, 1000)).to.be.revertedWith(\"ASDUSDC: USDC version not whitelisted\");\n     });\n \n+    it(\"should deposit & withdraw with differing decimals\", async () => {\n+        const [signer] = await ethers.getSigners();\n+        const usdc4Deposit = 1000e6;\n+        await usdc4.approve(asdUSDC.target, usdc4Deposit);\n+        await asdUSDC.deposit(usdc4.target, usdc4Deposit);\n+\n+        const usdc4Withdraw = BigInt(1000e18);\n+        expect(await asdUSDC.balanceOf(signer)).to.equal(usdc4Withdraw);\n+\n+        //split withdrawal in 2 transactions to provoke rounding error\n+        await asdUSDC.withdraw(usdc4.target, usdc4Withdraw / BigInt(2) - BigInt(1));\n+        await asdUSDC.withdraw(usdc4.target, usdc4Withdraw / BigInt(2) + BigInt(1));\n+\n+        // check that all of user's asdUDSC is burned\n+        expect(await asdUSDC.balanceOf(signer)).to.equal(0);\n+\n+        expect(await usdc4.balanceOf(asdUSDC.target), \"asdUSDC contract still has USDC4\").to.equal(0);\n+\n+    });\n+\n     it(\"should withdraw whitelisted usdc versions for asdUSDC\", async () => {\n         const [signer] = await ethers.getSigners();\n         const usdc1Deposit = 1000;\n```\n\n### Recommendation\n\nRe-calculate the actual `_amount` to burn by upscaling from `amountToWithdraw` to avoid burning more than what is actually withdrawn.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-canto",
  "Code": [
    {
      "filename": "contracts/asd/asdUSDC.sol",
      "content": "pragma solidity ^0.8.22;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title ASDUSDC\n * @notice This contract wraps multiple versions of USDC into one token\n */\ncontract ASDUSDC is ERC20, Ownable {\n    mapping(address => bool) public whitelistedUSDCVersions;\n    mapping(address => uint256) public usdcBalances;\n\n    event Deposit(address _version, uint _amount);\n    event Withdrawal(address _version, uint _amount);\n\n    constructor() ERC20(\"ASD USDC\", \"asdUSDC\") {}\n\n    /**\n     * @notice Add a USDC version to the whitelist\n     * @param _usdcVersion Address of the USDC version to add\n     */\n    function updateWhitelist(address _usdcVersion, bool _isWhitelisted) external onlyOwner {\n        whitelistedUSDCVersions[_usdcVersion] = _isWhitelisted;\n    }\n\n    /**\n     * @notice Deposit USDC and mint asdUSDC tokens\n     * @param _usdcVersion Address of the USDC version to deposit\n     * @param _amount Amount of USDC to deposit\n     * @return Amount of asdUSDC tokens minted\n     */\n    function deposit(address _usdcVersion, uint256 _amount) external returns (uint256) {\n        // check whitelist\n        require(whitelistedUSDCVersions[_usdcVersion], \"ASDUSDC: USDC version not whitelisted\");\n        SafeERC20.safeTransferFrom(ERC20(_usdcVersion), msg.sender, address(this), _amount);\n        usdcBalances[_usdcVersion] += _amount;\n        // Mint the same amount of asdUSDC tokens but take decimals into account\n        uint256 amountToMint = _amount * (10 ** (this.decimals() - ERC20(_usdcVersion).decimals()));\n        _mint(msg.sender, amountToMint);\n        emit Deposit(_usdcVersion, _amount);\n        return amountToMint;\n    }\n\n    /**\n     * @notice Withdraw USDC and burn asdUSDC tokens\n     * @param _usdcVersion Address of the USDC version to withdraw\n     * @param _amount Amount of asdUSDC tokens to burn\n     * @return Amount of USDC withdrawn\n     */\n    function withdraw(address _usdcVersion, uint256 _amount) external returns (uint256) {\n        // check whitelist\n        require(whitelistedUSDCVersions[_usdcVersion], \"ASDUSDC: USDC version not whitelisted\");\n        // burn tokens\n        _burn(msg.sender, _amount);\n        // calculate amount to withdraw\n        uint256 amountToWithdraw = _amount / (10 ** (this.decimals() - ERC20(_usdcVersion).decimals()));\n        // check balance\n        require(usdcBalances[_usdcVersion] >= amountToWithdraw, \"ASDUSDC: Not enough USDC balance\");\n        // transfer USDC\n        usdcBalances[_usdcVersion] -= amountToWithdraw;\n        SafeERC20.safeTransfer(ERC20(_usdcVersion), msg.sender, amountToWithdraw);\n        emit Withdrawal(_usdcVersion, amountToWithdraw);\n        return amountToWithdraw;\n    }\n\n    /**\n     * @notice Recover any USDC that was sent to the contract by mistake\n     * @param _usdcVersion Address of the USDC version to recover\n     * @return Amount of USDC minted\n     */\n    function recover(address _usdcVersion) external onlyOwner returns (uint256) {\n        // recover amount\n        uint amountToRecover = ERC20(_usdcVersion).balanceOf(address(this)) - usdcBalances[_usdcVersion];\n        usdcBalances[_usdcVersion] += amountToRecover;\n        // mint tokens\n        uint256 amountToMint = amountToRecover * (10 ** (this.decimals() - ERC20(_usdcVersion).decimals()));\n        _mint(msg.sender, amountToMint);\n        return amountToMint;\n    }\n}"
    }
  ]
}