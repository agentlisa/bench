{
  "Title": "M-6: RioLRTIssuer::issueLRT reverts if deposit asset's approve method doesn't return a bool",
  "Content": "# Issue M-6: RioLRTIssuer::issueLRT reverts if deposit asset's approve method doesn't return a bool \n\nSource: https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/189 \n\n## Found by \nfibonacci, fugazzi\n## Summary\n\nUsing `ERC20::approve` will not work with ERC20 tokens that do not return a bool.\n\n## Vulnerability Detail\n\nThe contest's README states that tokens that may not return a bool on ERC20 methods (e.g., USDT) are supposed to be used.\n\nThe `RioLRTIssuer::issueLRT` function makes a sacrificial deposit to prevent inflation attacks. To process the deposit, it calls the `ERC20::approve` method, which is expected to return a bool value.\n\nSolidity has return data length checks, and if the token implementation does not return a bool value, the transaction will revert.\n\n## Impact\n\nIssuing LRT tokens with an initial deposit in an asset that does not return a bool on an `approve` call will fail.\n\n## POC\n\nAdd this file to the `test` folder. Run test with `forge test --mc POC --rpc-url=<mainnet-rpc-url> -vv`.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {Test, console2} from 'forge-std/Test.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\ncontract POC is Test {\n    address constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n    address immutable owner = makeAddr(\"owner\");\n    address immutable spender = makeAddr(\"spender\");\n\n    function setUp() external {\n       deal(USDT, owner, 1e6);\n    }\n\n    function testApproveRevert() external {\n        vm.prank(owner);\n        IERC20(USDT).approve(spender, 1e6);\n    }\n\n    function testApproveSuccess() external {\n        vm.prank(owner);\n        SafeERC20.forceApprove(IERC20(USDT), spender, 1e6);\n\n        uint256 allowance = IERC20(USDT).allowance(owner, spender);\n        assertEq(allowance, 1e6);\n    }\n}\n```\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/main/rio-sherlock-audit/contracts/restaking/RioLRTIssuer.sol#L172\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse `forceApprove` from OpenZeppelin's `SafeERC20` library.\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/rio-org/rio-sherlock-audit/pull/5.\n\n**mstpr**\n\nEscalate\nI think this issue is low/informational for the following reasons:\n\n1- There are no loss of funds here. If the USDT is picked then the underlying asset will not be possible to be added to LRT. \n\n2- Current code is specifically for assets that has an EigenLayer strategy which there are no tokens like USDT. \n\n3- Issuer contract is upgradable proxy, if the adding a new asset fails, then the new implementation can be used to add the asset to LRT.\n\n**sherlock-admin2**\n\n> Escalate\n> I think this issue is low/informational for the following reasons:\n> \n> 1- There are no loss of funds here. If the USDT is picked then the underlying asset will not be possible to be added to LRT. \n> \n> 2- Current code is specifically for assets that has an EigenLayer strategy which there are no tokens like USDT. \n> \n> 3- Issuer contract is upgradable proxy, if the adding a new asset fails, then the new implementation can be used to add the asset to LRT.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**nevillehuang**\n\nDisagree with escalation, the argument is moot given it is explicitly stated in contest details that such tokens could be supported\n\n> Do you expect to use any of the following tokens with non-standard behaviour with the smart contracts?\n\n> - We plan to support tokens with no less than 6 decimals and no more than 18 decimals.\n> - Tokens may not return a bool on ERC20 methods (e.g. USDT)\n> - Tokens may have approval race protections (e.g. USDT)\n\n**realfugazzi**\n\n> Escalate I think this issue is low/informational for the following reasons:\n> \n> 1- There are no loss of funds here. If the USDT is picked then the underlying asset will not be possible to be added to LRT.\n> \n> 2- Current code is specifically for assets that has an EigenLayer strategy which there are no tokens like USDT.\n> \n> 3- Issuer contract is upgradable proxy, if the adding a new asset fails, then the new implementation can be used to add the asset to LRT.\n\nUSDT is mentioned as a supported asset in the documentation, also double checked by the sponsor, see #232 \n\nThe issue will prevent the initial deposit, enabling inflation attack vectors. \n\n**solimander**\n\n> The issue will prevent the initial deposit, enabling inflation attack vectors.\n\nIt will not allow USDT to be added, rather than enable inflation attack vectors.\n\n**Czar102**\n\nI disagree with the escalation, the codebase will not be able to support planned functionality without loss of funds, so Medium is appropriate.\n\n**mstpr**\n\n> I disagree with the escalation, the codebase will not be able to support planned functionality without loss of funds, so Medium is appropriate.\n\nthere won't be any loss of funds tho. It is just simply USDT will not be added, tx will fail. \n\n**solimander**\n\nIn which case, the issuer would be upgraded to support USDT.\n\n**realfugazzi**\n\n> > I disagree with the escalation, the codebase will not be able to support planned functionality without loss of funds, so Medium is appropriate.\n> \n> there won't be any loss of funds tho. It is just simply USDT will not be added, tx will fail.\n\nright even setting 0 will break the tx, but it falls in the med severity according to the docs as core func is broken \n\n**Czar102**\n\nResult:\nMedium\nHas duplicates\n\nAs noted above, breaks core functionality, hence Medium is appropriate.\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [mstpr](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/189/#issuecomment-2022687170): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/176",
  "Code": [
    {
      "filename": "rio-sherlock-audit/contracts/restaking/RioLRTIssuer.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.23;\n\nimport {CREATE3} from '@solady/utils/CREATE3.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {ERC1967Proxy} from '@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol';\nimport {OwnableUpgradeable} from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport {UUPSUpgradeable} from '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport {ContractType, ETH_ADDRESS, MIN_SACRIFICIAL_DEPOSIT} from 'contracts/utils/Constants.sol';\nimport {IRioLRTRewardDistributor} from 'contracts/interfaces/IRioLRTRewardDistributor.sol';\nimport {IRioLRTOperatorRegistry} from 'contracts/interfaces/IRioLRTOperatorRegistry.sol';\nimport {IRioLRTWithdrawalQueue} from 'contracts/interfaces/IRioLRTWithdrawalQueue.sol';\nimport {IRioLRTAssetRegistry} from 'contracts/interfaces/IRioLRTAssetRegistry.sol';\nimport {IRioLRTCoordinator} from 'contracts/interfaces/IRioLRTCoordinator.sol';\nimport {IRioLRTAVSRegistry} from 'contracts/interfaces/IRioLRTAVSRegistry.sol';\nimport {IRioLRTDepositPool} from 'contracts/interfaces/IRioLRTDepositPool.sol';\nimport {LRTAddressCalculator} from 'contracts/utils/LRTAddressCalculator.sol';\nimport {IRioLRTIssuer} from 'contracts/interfaces/IRioLRTIssuer.sol';\nimport {IRioLRT} from 'contracts/interfaces/IRioLRT.sol';\n\ncontract RioLRTIssuer is IRioLRTIssuer, OwnableUpgradeable, UUPSUpgradeable {\n    using LRTAddressCalculator for address;\n    using SafeERC20 for IERC20;\n\n    /// @notice The liquid restaking token (LRT) implementation.\n    address public immutable tokenImpl;\n\n    /// @notice The LRT coordinator implementation.\n    address public immutable coordinatorImpl;\n\n    /// @notice The LRT asset registry implementation.\n    address public immutable assetRegistryImpl;\n\n    /// @notice The LRT operator registry implementation.\n    address public immutable operatorRegistryImpl;\n\n    /// @notice The LRT AVS registry implementation.\n    address public immutable avsRegistryImpl;\n\n    /// @notice The LRT deposit pool implementation.\n    address public immutable depositPoolImpl;\n\n    /// @notice The LRT withdrawal queue implementation.\n    address public immutable withdrawalQueueImpl;\n\n    /// @notice The LRT reward distributor implementation.\n    address public immutable rewardDistributorImpl;\n\n    /// @notice Returns whether the provided token was issued by this factory.\n    mapping(address => bool) public isTokenFromFactory;\n\n    /// @param tokenImpl_ The liquid restaking token (LRT) implementation.\n    /// @param coordinatorImpl_ The LRT coordinator implementation.\n    /// @param assetRegistryImpl_ The LRT asset registry implementation.\n    /// @param operatorRegistryImpl_ The LRT operator registry implementation.\n    /// @param avsRegistryImpl_ The LRT AVS registry implementation.\n    /// @param depositPoolImpl_ The LRT deposit pool implementation.\n    /// @param withdrawalQueueImpl_ The LRT withdrawal queue implementation.\n    /// @param rewardDistributorImpl_ The LRT reward distributor implementation.\n    constructor(\n        address tokenImpl_,\n        address coordinatorImpl_,\n        address assetRegistryImpl_,\n        address operatorRegistryImpl_,\n        address avsRegistryImpl_,\n        address depositPoolImpl_,\n        address withdrawalQueueImpl_,\n        address rewardDistributorImpl_\n    ) {\n        _disableInitializers();\n\n        tokenImpl = tokenImpl_;\n        coordinatorImpl = coordinatorImpl_;\n        assetRegistryImpl = assetRegistryImpl_;\n        operatorRegistryImpl = operatorRegistryImpl_;\n        avsRegistryImpl = avsRegistryImpl_;\n        depositPoolImpl = depositPoolImpl_;\n        withdrawalQueueImpl = withdrawalQueueImpl_;\n        rewardDistributorImpl = rewardDistributorImpl_;\n    }\n\n    /// @notice Initializes the contract.\n    /// @param initialOwner The initial owner of the contract.\n    function initialize(address initialOwner) external initializer {\n        __Ownable_init(initialOwner);\n        __UUPSUpgradeable_init();\n    }\n\n    // forgefmt: disable-next-item\n    /// @notice Issues a new liquid restaking token (LRT).\n    /// @param name The name of the token.\n    /// @param symbol The symbol of the token.\n    /// @param config The token configuration.\n    function issueLRT(string calldata name, string calldata symbol, LRTConfig calldata config) external payable onlyOwner returns (LRTDeployment memory d) {\n        // Deploy the liquid restaking token (LRT).\n        d.token = address(new ERC1967Proxy(tokenImpl, ''));\n\n        // Deploy the supporting contracts using the LRT address as the salt.\n        d.coordinator = CREATE3.deploy(\n            d.token.computeSalt(ContractType.Coordinator),\n            abi.encodePacked(type(ERC1967Proxy).creationCode, abi.encode(coordinatorImpl, '')),\n            0\n        );\n        d.assetRegistry = CREATE3.deploy(\n            d.token.computeSalt(ContractType.AssetRegistry),\n            abi.encodePacked(type(ERC1967Proxy).creationCode, abi.encode(assetRegistryImpl, '')),\n            0\n        );\n        d.operatorRegistry = CREATE3.deploy(\n            d.token.computeSalt(ContractType.OperatorRegistry),\n            abi.encodePacked(type(ERC1967Proxy).creationCode, abi.encode(operatorRegistryImpl, '')),\n            0\n        );\n        d.avsRegistry = CREATE3.deploy(\n            d.token.computeSalt(ContractType.AVSRegistry),\n            abi.encodePacked(type(ERC1967Proxy).creationCode, abi.encode(avsRegistryImpl, '')),\n            0\n        );\n        d.depositPool = CREATE3.deploy(\n            d.token.computeSalt(ContractType.DepositPool),\n            abi.encodePacked(type(ERC1967Proxy).creationCode, abi.encode(depositPoolImpl, '')),\n            0\n        );\n        d.withdrawalQueue = CREATE3.deploy(\n            d.token.computeSalt(ContractType.WithdrawalQueue),\n            abi.encodePacked(type(ERC1967Proxy).creationCode, abi.encode(withdrawalQueueImpl, '')),\n            0\n        );\n        d.rewardDistributor = CREATE3.deploy(\n            d.token.computeSalt(ContractType.RewardDistributor),\n            abi.encodePacked(type(ERC1967Proxy).creationCode, abi.encode(rewardDistributorImpl, '')),\n            0\n        );\n\n        address initialOwner = msg.sender;\n\n        // Initialize all supporting contracts.\n        IRioLRT(d.token).initialize(initialOwner, name, symbol);\n        IRioLRTCoordinator(d.coordinator).initialize(initialOwner, d.token);\n        IRioLRTAssetRegistry(d.assetRegistry).initialize(initialOwner, d.token, config.priceFeedDecimals, config.assets);\n        IRioLRTOperatorRegistry(d.operatorRegistry).initialize(initialOwner, d.token);\n        IRioLRTAVSRegistry(d.avsRegistry).initialize(initialOwner, d.token);\n        IRioLRTDepositPool(d.depositPool).initialize(initialOwner, d.token);\n        IRioLRTWithdrawalQueue(d.withdrawalQueue).initialize(initialOwner, d.token);\n        IRioLRTRewardDistributor(d.rewardDistributor).initialize(initialOwner, d.token, config.treasury, config.operatorRewardPool);\n\n        isTokenFromFactory[d.token] = true;\n        emit LiquidRestakingTokenIssued(name, symbol, config, d);\n\n        // Make a sacrificial deposit to prevent inflation attacks.\n        _deposit(\n            IRioLRTCoordinator(d.coordinator),\n            config.deposit.asset,\n            config.deposit.amount\n        );\n    }\n\n    /// @dev Makes a sacrificial deposit to prevent inflation attacks.\n    /// @param coordinator The LRT coordinator.\n    /// @param asset The asset to deposit.\n    /// @param amount The amount to deposit.\n    function _deposit(IRioLRTCoordinator coordinator, address asset, uint256 amount) internal {\n        if (amount < MIN_SACRIFICIAL_DEPOSIT) revert INSUFFICIENT_SACRIFICIAL_DEPOSIT();\n        if (asset == ETH_ADDRESS) {\n            if (amount != msg.value) revert INVALID_ETH_PROVIDED();\n            coordinator.depositETH{value: amount}();\n            return;\n        }\n\n        IERC20(asset).safeTransferFrom(msg.sender, address(this), amount);\n        IERC20(asset).approve(address(coordinator), amount);\n\n        coordinator.deposit(asset, amount);\n    }\n\n    /// @dev Allows the owner to upgrade the LRT issuer implementation.\n    /// @param newImplementation The implementation to upgrade to.\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n}"
    }
  ]
}