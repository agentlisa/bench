{
  "Title": "M-1: Batcher frames are incorrectly decoded leading to consensus split",
  "Content": "# Issue M-1: Batcher frames are incorrectly decoded leading to consensus split \n\nSource: https://github.com/sherlock-audit/2023-01-optimism-judging/issues/279 \n\n## Found by \nobront\n\n## Summary\n\nThere is an error in the implementation of how frames are decoded, which will allow invalid frames to be accepted. This can allow a malicious sequencer to cause a consensus split between op-node implementations and the (correct) reference implementation. \n\n## Vulnerability Detail\n\nOptimism implements a highly efficient derivation scheme based on compression of L2 data that is sent to an L1 address. The [spec](https://github.com/ethereum-optimism/optimism/blob/develop/specs/derivation.md#l2-chain-derivation-specification) clearly defines how this works. Channels are split into frames, each one encoded as defined [here](https://github.com/ethereum-optimism/optimism/blob/develop/specs/derivation.md#frame-format). Frames will be aggregated by the derivation driver.\n\nDocs state that:\n> `All data in a frame is fixed-size, except the frame_data. The fixed overhead is 16 + 2 + 4 + 1 = 23 bytes. Fixed-size frame metadata avoids a circular dependency with the target total data length, to simplify packing of frames with varying content length.`\n\nSpecifically:\n> `is_last is a single byte with a value of 1 if the frame is the last in the channel, 0 if there are frames in the channel. Any other value makes the frame invalid (it must be ignored by the rollup node).`\n\nClearly, `is_last` is mandatory as per the specs. However, if we look at the code it will accept a frame even if `is_last` is not supplied.\n\nDecoding of the frame is done in `frame.go`, in the `UnmarshalBinary` function. After reading the frame data, only the last byte remains.\n```go\nif isLastByte, err := r.ReadByte(); err != nil && err != io.EOF {\n\treturn fmt.Errorf(\"error reading final byte: %w\", err)\n} else if isLastByte == 0 {\n\tf.IsLast = false\n\treturn err\n} else if isLastByte == 1 {\n\tf.IsLast = true\n\treturn err\n} else {\n\treturn errors.New(\"invalid byte as is_last\")\n}\n```\nIf the `ByteReader` object is empty, reading the next byte will return an `EOF` and the error clause is skipped. The result of `ReadByte` when an error occurs is `undefined`, however in all Go setups we've tested `isLastByte` is zero. This means it sets `f.IsLast = false` and returns the `EOF`.\n\nBack in `ParseFrames` which calls `UnmarshalBinary`, the `EOF` is ignored and the frame is accepted:\n```go\nfor buf.Len() > 0 {\n\tvar f Frame\n\tif err := (&f).UnmarshalBinary(buf); err != io.EOF && err != nil {\n\t\treturn nil, err\n\t}\n\tframes = append(frames, f)\n}\n```\nSo, it is demonstrated that an invalid frame is accepted by the Optimism implementation, provided the frame is the last one in the frames buffer. The impact is that a malicious sequencer can cause a consensus split between correct implementations and the reference implementation. It has been defined by the rules as Medium severity:\n```go\n- Causing a consensus failure\n- Explanation: There is one sequencer op-node submitting transaction batches to L1, but many verifier op-nodes will read these batches and check the results of its execution. The sequencer and verifiers must remain in consensus, even in the event of an L1 reorg.\n```\nAll that is needed is to send in different frame packages two frames of a channel, omit the `is_last` byte in the first frame and make sure it is the last frame in the package.\n\n## Impact\n\nMalicious sequencer can easily cause a consensus split by taking advantage of the incorrect frame reading logic in op-node.\n\n## Code Snippet\n\nhttps://github.com/ethereum-optimism/optimism/blob/407f97b9d13448b766624995ec824d3059d4d4f6/op-node/rollup/derive/frame.go#L93\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIn `UnmarshalBinary`, return a non-EOF error when `is_last` byte does not exist.\n\n\n## Discussion\n\n**rcstanciu**\n\nComment from Optimism\n\n---\n\n **Description:** A malicious or buggy batcher could submit a frame that the op-node would accept that a spec compliant node would not due to a bug in our parsing code.\n\n\n **Reason:** This would cause a consensus failure between different clients.\n\n\n **Action:** We need to fix this code.\n\n\n\n**zobront**\n\nEscalate for 250 USDC\n\nThis submission concerns a specific consensus failure due to parsing of batcher frames. \n\nIt has been wrongly duped to #53, which concerns a contract level issue with posted output roots for withdrawals. \n\nOptimism has acknowledged the validity of the issue and this is certainly just a misclick, as the issues are entirely unrelated.\n\n**sherlock-admin**\n\n > Escalate for 250 USDC\n> \n> This submission concerns a specific consensus failure due to parsing of batcher frames. \n> \n> It has been wrongly duped to #53, which concerns a contract level issue with posted output roots for withdrawals. \n> \n> Optimism has acknowledged the validity of the issue and this is certainly just a misclick, as the issues are entirely unrelated.\n\nYou've created a valid escalation for 250 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation accepted and resolving incorrect duplication state\n\n**sherlock-admin**\n\n> Escalation accepted and resolving incorrect duplication state\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/38",
  "Code": [
    {
      "filename": "op-node/rollup/derive/frame.go",
      "content": "package derive\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n)\n\n// Frames cannot be larger than 1 MB.\n// Data transactions that carry frames are generally not larger than 128 KB due to L1 network conditions,\n// but we leave space to grow larger anyway (gas limit allows for more data).\nconst MaxFrameLen = 1_000_000\n\n// Data Format\n//\n// frame = channel_id ++ frame_number ++ frame_data_length ++ frame_data ++ is_last\n//\n// channel_id        = bytes16\n// frame_number      = uint16\n// frame_data_length = uint32\n// frame_data        = bytes\n// is_last           = bool\n\ntype Frame struct {\n\tID          ChannelID\n\tFrameNumber uint16\n\tData        []byte\n\tIsLast      bool\n}\n\n// MarshalBinary writes the frame to `w`.\n// It returns any errors encountered while writing, but\n// generally expects the writer very rarely fail.\nfunc (f *Frame) MarshalBinary(w io.Writer) error {\n\t_, err := w.Write(f.ID[:])\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := binary.Write(w, binary.BigEndian, f.FrameNumber); err != nil {\n\t\treturn err\n\t}\n\tif err := binary.Write(w, binary.BigEndian, uint32(len(f.Data))); err != nil {\n\t\treturn err\n\t}\n\t_, err = w.Write(f.Data)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif f.IsLast {\n\t\tif _, err = w.Write([]byte{1}); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tif _, err = w.Write([]byte{0}); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\ntype ByteReader interface {\n\tio.Reader\n\tio.ByteReader\n}\n\n// UnmarshalBinary consumes a full frame from the reader.\n// If `r` fails a read, it returns the error from the reader\n// The reader will be left in a partially read state.\nfunc (f *Frame) UnmarshalBinary(r ByteReader) error {\n\tif _, err := io.ReadFull(r, f.ID[:]); err != nil {\n\t\treturn fmt.Errorf(\"error reading ID: %w\", err)\n\t}\n\tif err := binary.Read(r, binary.BigEndian, &f.FrameNumber); err != nil {\n\t\treturn fmt.Errorf(\"error reading frame number: %w\", err)\n\t}\n\n\tvar frameLength uint32\n\tif err := binary.Read(r, binary.BigEndian, &frameLength); err != nil {\n\t\treturn fmt.Errorf(\"error reading frame length: %w\", err)\n\t}\n\n\t// Cap frame length to MaxFrameLen (currently 1MB)\n\tif frameLength > MaxFrameLen {\n\t\treturn fmt.Errorf(\"frameLength is too large: %d\", frameLength)\n\t}\n\tf.Data = make([]byte, int(frameLength))\n\tif _, err := io.ReadFull(r, f.Data); err != nil {\n\t\treturn fmt.Errorf(\"error reading frame data: %w\", err)\n\t}\n\n\tif isLastByte, err := r.ReadByte(); err != nil && err != io.EOF {\n\t\treturn fmt.Errorf(\"error reading final byte: %w\", err)\n\t} else if isLastByte == 0 {\n\t\tf.IsLast = false\n\t\treturn err\n\t} else if isLastByte == 1 {\n\t\tf.IsLast = true\n\t\treturn err\n\t} else {\n\t\treturn errors.New(\"invalid byte as is_last\")\n\t}\n}\n\n// Frames on stored in L1 transactions with the following format:\n// data = DerivationVersion0 ++ Frame(s)\n// Where there is one or more frames concatenated together.\n\n// ParseFrames parse the on chain serialization of frame(s) in\n// an L1 transaction. Currently only version 0 of the serialization\n// format is supported.\n// All frames must be parsed without error and there must not be\n// any left over data and there must be at least one frame.\nfunc ParseFrames(data []byte) ([]Frame, error) {\n\tif len(data) == 0 {\n\t\treturn nil, errors.New(\"data array must not be empty\")\n\t}\n\tif data[0] != DerivationVersion0 {\n\t\treturn nil, fmt.Errorf(\"invalid derivation format byte: got %d\", data[0])\n\t}\n\tbuf := bytes.NewBuffer(data[1:])\n\tvar frames []Frame\n\tfor buf.Len() > 0 {\n\t\tvar f Frame\n\t\tif err := (&f).UnmarshalBinary(buf); err != io.EOF && err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tframes = append(frames, f)\n\t}\n\tif buf.Len() != 0 {\n\t\treturn nil, fmt.Errorf(\"did not fully consume data: have %d frames and %d bytes left\", len(frames), buf.Len())\n\t}\n\tif len(frames) == 0 {\n\t\treturn nil, errors.New(\"was not able to find any frames\")\n\t}\n\treturn frames, nil\n}"
    }
  ]
}