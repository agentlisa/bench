{
  "Title": "[L02] Lack of indexed parameters in events",
  "Content": "None of the parameters in the events defined in the [`DelFiPrice` contract](https://github.com/compound-finance/open-oracle/blob/e7a928334e5e454a88eec38e4ee1be5ee3b13f08/contracts/DelFiPrice.sol#L12-L16) are indexed. Consider [indexing event parameters](https://solidity.readthedocs.io/en/v0.5.12/contracts.html#events) to avoid hindering the task of off-chain services searching and filtering for specific events.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/DelFiPrice.sol",
      "content": "pragma solidity ^0.5.12;\npragma experimental ABIEncoderV2;\n\nimport \"./OpenOraclePriceData.sol\";\nimport \"./OpenOracleView.sol\";\n\n/**\n * @notice The DelFi Price Feed View\n * @author Compound Labs, Inc.\n */\ncontract DelFiPrice is OpenOracleView {\n    /// @notice The event emitted when the median price is updated\n    event PriceUpdated(string symbol, uint64 price);\n\n    /// @notice The event emitted when new prices are posted but the median price is not updated due to the anchor\n    event PriceGuarded(string symbol, uint64 median, uint64 anchor);\n\n    /// @notice The reporter address whose prices checked against the median for safety\n    address anchor;\n\n    /// @notice The highest ratio of the new median price to the anchor price that will still trigger the median price to be updated\n    uint256 upperBoundAnchorRatio;\n\n    /// @notice The lowest ratio of the new median price to the anchor price that will still trigger the median price to be updated\n    uint256 lowerBoundAnchorRatio;\n\n    /// @notice The mapping of medianized prices per symbol\n    mapping(string => uint64) public prices;\n\n    /**\n     * @param data_ Address of the Oracle Data contract\n     * @param sources_ The reporter addresses whose prices will be used to calculate the median\n     * @param anchor_ The reporter address whose prices checked against the median for safety\n     * @param anchorToleranceMantissa_ The tolerance allowed between the anchor and median. A tolerance of 10e16 means a new median that is 10% off from the anchor will still be saved\n     */\n    constructor(OpenOraclePriceData data_, address[] memory sources_, address anchor_, uint anchorToleranceMantissa_) public OpenOracleView(data_, sources_) {\n        anchor = anchor_;\n        require(anchorToleranceMantissa_ < 100e16, \"Anchor Tolerance is too high\");\n        upperBoundAnchorRatio = 100e16 + anchorToleranceMantissa_;\n        lowerBoundAnchorRatio = 100e16 - anchorToleranceMantissa_;\n    }\n\n    /**\n     * @notice Primary entry point to post and recalculate prices\n     * @dev We let anyone pay to post anything, but only sources count for prices\n     * @param messages The messages to post to the oracle\n     * @param signatures The signatures for the corresponding messages\n     */\n    function postPrices(bytes[] calldata messages, bytes[] calldata signatures, string[] calldata symbols) external {\n        require(messages.length == signatures.length, \"messages and signatures must be 1:1\");\n\n        // Save the prices\n        for (uint i = 0; i < messages.length; i++) {\n            OpenOraclePriceData(address(data)).put(messages[i], signatures[i]);\n        }\n\n        // Try to update the median\n        for (uint i = 0; i < symbols.length; i++) {\n            string memory symbol = symbols[i];\n            uint64 medianPrice = medianPrice(symbol, sources);\n            uint64 anchorPrice = OpenOraclePriceData(address(data)).getPrice(anchor, symbol);\n            if (anchorPrice == 0) {\n                emit PriceGuarded(symbol, medianPrice, anchorPrice);\n            } else {\n                uint256 anchorRatioMantissa = uint256(medianPrice) * 100e16 / anchorPrice;\n                // Only update the view's price if the median of the sources is within a bound, and it is a new median\n                if (anchorRatioMantissa <= upperBoundAnchorRatio && anchorRatioMantissa >= lowerBoundAnchorRatio) {\n                    // only update and emit event if the median price is new, otherwise do nothing\n                    if (prices[symbol] != medianPrice) {\n                        prices[symbol] = medianPrice;\n                        emit PriceUpdated(symbol, medianPrice);\n                    }\n                } else {\n                    emit PriceGuarded(symbol, medianPrice, anchorPrice);\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Calculates the median price over any set of sources\n     * @param symbol The symbol to calculate the median price of\n     * @param sources_ The sources to use when calculating the median price\n     * @return median The median price over the set of sources\n     */\n    function medianPrice(string memory symbol, address[] memory sources_) public view returns (uint64 median) {\n        require(sources_.length > 0, \"sources list must not be empty\");\n\n        uint N = sources_.length;\n        uint64[] memory postedPrices = new uint64[](N);\n        for (uint i = 0; i < N; i++) {\n            postedPrices[i] = OpenOraclePriceData(address(data)).getPrice(sources_[i], symbol);\n        }\n\n        uint64[] memory sortedPrices = sort(postedPrices);\n        // if N is even, get the left and right medians and average them\n        if (N % 2 == 0) {\n            uint64 left = sortedPrices[(N / 2) - 1];\n            uint64 right = sortedPrices[N / 2];\n            uint128 sum = uint128(left) + uint128(right);\n            return uint64(sum / 2);\n        } else {\n            // if N is odd, just return the median\n            return sortedPrices[N / 2];\n        }\n    }\n\n    /**\n     * @notice Helper to sort an array of uints\n     * @param array Array of integers to sort\n     * @return The sorted array of integers\n     */\n    function sort(uint64[] memory array) private pure returns (uint64[] memory) {\n        uint N = array.length;\n        for (uint i = 0; i < N; i++) {\n            for (uint j = i + 1; j < N; j++) {\n                if (array[i] > array[j]) {\n                    uint64 tmp = array[i];\n                    array[i] = array[j];\n                    array[j] = tmp;\n                }\n            }\n        }\n        return array;\n    }\n}"
    }
  ]
}