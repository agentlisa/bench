{
  "Title": "M-10: WAuraPools doesn't correctly account for AuraStash causing all deposits to be permanently lost",
  "Content": "# Issue M-10: WAuraPools doesn't correctly account for AuraStash causing all deposits to be permanently lost \n\nSource: https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/108 \n\n## Found by \n0x52\n\nSome Aura pools have two sources of AURA. First from the booster but also as a secondary reward. This secondary reward is stash AURA that doesn't behave like regular AURA. Although properly accounted for in AuraSpell, it is not properly accounted for in WAuraPools, resulting in all deposits being unrecoverable. \n\n## Vulnerability Detail\n\n[WAuraPools.sol#L413-L418](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/wrapper/WAuraPools.sol#L413-L418)\n\n        uint256 rewardTokensLength = rewardTokens.length;\n        for (uint256 i; i != rewardTokensLength; ) {\n            IERC20Upgradeable(rewardTokens[i]).safeTransfer(\n                msg.sender,\n                rewards[i]\n            );\n\nWhen burning the wrapped LP token, it attempts to transfer each token to msg.sender. The problem is that stash AURA cannot be transferred like an regular ERC20 token and any transfers will revert. Since this will be called on every attempted withdraw, all deposits will be permanently unrecoverable.\n\n## Impact\n\nAll deposits will be permanently unrecoverable\n\n## Code Snippet\n\n[WAuraPools.sol#L360-L424](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/wrapper/WAuraPools.sol#L360-L424)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCheck if reward is stash AURA and send regular AURA instead similar to what is done in AuraSpell.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**Kral01** commented:\n> Needs PoC\n\n\n\n**IAm0x52**\n\nEscalate\n\nThis was incorrectly excluded. \n\nhttps://github.com/sherlock-audit/2023-07-blueberry/blob/7c7e1c4a8f3012d1afd2e598b656010bb9127836/blueberry-core/contracts/spell/AuraSpell.sol#L243-L257\n\n        for (uint256 i; i != rewardTokensLength; ) {\n            address sellToken = rewardTokens[i];\n            if (sellToken == STASH_AURA) sellToken = AURA;\n\n            _doCutRewardsFee(sellToken);\n            if (\n                expectedRewards[i] != 0 &&\n                !PSwapLib.swap(\n                    augustusSwapper,\n                    tokenTransferProxy,\n                    sellToken,\n                    expectedRewards[i],\n                    swapDatas[i]\n                )\n            ) revert Errors.SWAP_FAILED(sellToken);\n\n            /// Refund rest (dust) amount to owner\n            _doRefund(sellToken);\n\n            unchecked {\n                ++i;\n            }\n\nAuraSpell requires the above code to prevent this. WAuraPools uses the exact same reward list and needs the same protections. The result is that funds will be permanently trapped, because the transfer will always fail.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This was incorrectly excluded. \n> \n> https://github.com/sherlock-audit/2023-07-blueberry/blob/7c7e1c4a8f3012d1afd2e598b656010bb9127836/blueberry-core/contracts/spell/AuraSpell.sol#L243-L257\n> \n>         for (uint256 i; i != rewardTokensLength; ) {\n>             address sellToken = rewardTokens[i];\n>             if (sellToken == STASH_AURA) sellToken = AURA;\n> \n>             _doCutRewardsFee(sellToken);\n>             if (\n>                 expectedRewards[i] != 0 &&\n>                 !PSwapLib.swap(\n>                     augustusSwapper,\n>                     tokenTransferProxy,\n>                     sellToken,\n>                     expectedRewards[i],\n>                     swapDatas[i]\n>                 )\n>             ) revert Errors.SWAP_FAILED(sellToken);\n> \n>             /// Refund rest (dust) amount to owner\n>             _doRefund(sellToken);\n> \n>             unchecked {\n>                 ++i;\n>             }\n> \n> AuraSpell requires the above code to prevent this. WAuraPools uses the exact same reward list and needs the same protections. The result is that funds will be permanently trapped, because the transfer will always fail.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Shogoki**\n\nSeems valid\nSTASH AURA seems to be a valid `extraRewardToken` but transfer can only be called from the pool, which will actually transfer AURA instead. \nSo if the WAURAPool tries to call transfer it will revert.\n\n**hrishibhat**\n\nResult:\nMedium\nUnique \nConsidering this issue a valid medium\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [IAm0x52](https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/108/#issuecomment-1694744574): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/104",
  "Code": [
    {
      "filename": "blueberry-core/contracts/wrapper/WAuraPools.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"../utils/BlueBerryErrors.sol\" as Errors;\nimport \"../utils/EnsureApprove.sol\";\nimport \"../interfaces/IWAuraPools.sol\";\nimport \"../interfaces/IERC20Wrapper.sol\";\nimport \"../interfaces/aura/IAuraRewarder.sol\";\nimport \"../interfaces/aura/IAuraExtraRewarder.sol\";\nimport \"../interfaces/aura/IAura.sol\";\n\n/**\n * @title WAuraPools\n * @author BlueberryProtocol\n * @notice Wrapped Aura Pools is the wrapper of LP positions\n * @dev Leveraged LP Tokens will be wrapped here and be held in BlueberryBank\n *      and do not generate yields. LP Tokens are identified by tokenIds\n *      encoded from lp token address.\n */\ncontract WAuraPools is\n    ERC1155Upgradeable,\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable,\n    EnsureApprove,\n    IERC20Wrapper,\n    IWAuraPools\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                   PUBLIC STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Address to Aura Pools contract\n    IAuraPools public auraPools;\n    /// @dev Address to AURA token\n    IAura public AURA;\n    /// @dev Address to STASH_AURA token\n    address public STASH_AURA;\n    /// @dev Mapping from token id to accExtPerShare\n    mapping(uint256 => mapping(address => uint256)) public accExtPerShare;\n    /// @dev Aura extra rewards addresses\n    address[] public extraRewards;\n    /// @dev The index of extra rewards\n    mapping(address => uint256) public extraRewardsIdx;\n\n    uint public REWARD_MULTIPLIER_DENOMINATOR;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Initializes contract with dependencies\n    /// @param aura_ The AURA token address\n    /// @param auraPools_ The auraPools contract address\n    /// @param stash_aura_ The stash for AURA\n    function initialize(\n        address aura_,\n        address auraPools_,\n        address stash_aura_\n    ) external initializer {\n        __ReentrancyGuard_init();\n        __ERC1155_init(\"WAuraPools\");\n        AURA = IAura(aura_);\n        STASH_AURA = stash_aura_;\n        auraPools = IAuraPools(auraPools_);\n        REWARD_MULTIPLIER_DENOMINATOR = auraPools\n            .REWARD_MULTIPLIER_DENOMINATOR();\n    }\n\n    /// @notice Encodes pool id and AURA per share into an ERC1155 token id\n    /// @param pid The pool id (The first 16-bits)\n    /// @param auraPerShare Amount of AURA per share, multiplied by 1e18 (The last 240-bits)\n    /// @return id The resulting ERC1155 token id\n\n    function encodeId(\n        uint256 pid,\n        uint256 auraPerShare\n    ) public pure returns (uint256 id) {\n        // Ensure the pool id and auraPerShare are within expected bounds\n        if (pid >= (1 << 16)) revert Errors.BAD_PID(pid);\n        if (auraPerShare >= (1 << 240))\n            revert Errors.BAD_REWARD_PER_SHARE(auraPerShare);\n        return (pid << 240) | auraPerShare;\n    }\n\n    /// @notice Decodes ERC1155 token id to pool id and AURA per share\n    /// @param id The ERC1155 token id\n    /// @return gid The decoded pool id\n    /// @return auraPerShare The decoded amount of AURA per share\n    function decodeId(\n        uint256 id\n    ) public pure returns (uint256 gid, uint256 auraPerShare) {\n        gid = id >> 240; // Extracting the first 16 bits\n        auraPerShare = id & ((1 << 240) - 1); // Extracting the last 240 bits\n    }\n\n    /// @notice Retrieves the underlying ERC20 token of the specified ERC1155 token id\n    /// @param id The ERC1155 token id\n    /// @return uToken Address of the underlying ERC20 token\n    function getUnderlyingToken(\n        uint256 id\n    ) external view override returns (address uToken) {\n        (uint256 pid, ) = decodeId(id);\n        (uToken, , , , , ) = getPoolInfoFromPoolId(pid);\n    }\n\n    /// @notice Gets the Balancer vault for a given BPT token\n    /// @param bpt Address of the BPT token\n    /// @return Vault associated with the provided BPT token\n    function getVault(address bpt) public view returns (IBalancerVault) {\n        return IBalancerVault(IBalancerPool(bpt).getVault());\n    }\n\n    /// @notice Retrieves pool tokens from a given BPT address\n    /// @param bpt Address of the BPT token\n    /// @return tokens Array of token addresses in the pool\n    /// @return balances Corresponding balances of the tokens in the pool\n    /// @return lastChangedBlock The last block when the pool composition changed\n    function getPoolTokens(\n        address bpt\n    )\n        external\n        view\n        returns (\n            address[] memory tokens,\n            uint256[] memory balances,\n            uint256 lastChangedBlock\n        )\n    {\n        return getVault(bpt).getPoolTokens(IBalancerPool(bpt).getPoolId());\n    }\n\n    /// @notice Retrieves pool id from a BPT token\n    /// @param bpt Address of the BPT token\n    /// @return Pool id associated with the BPT token\n    function getBPTPoolId(address bpt) public view returns (bytes32) {\n        return IBalancerPool(bpt).getPoolId();\n    }\n\n    /// @notice Fetches pool information using a provided aura finance pool id\n    /// @param pid The aura finance pool id\n    /// @return lptoken Address of the LP token\n    /// @return token Address of the associated token\n    /// @return gauge Address of the gauge\n    /// @return auraRewards Address for AURA rewards\n    /// @return stash Address of the stash\n    /// @return shutdown Boolean indicating if the pool is shut down\n    function getPoolInfoFromPoolId(\n        uint256 pid\n    )\n        public\n        view\n        returns (\n            address lptoken,\n            address token,\n            address gauge,\n            address auraRewards,\n            address stash,\n            bool shutdown\n        )\n    {\n        return auraPools.poolInfo(pid);\n    }\n\n    /// @notice Calculate the amount of pending reward for a given LP amount.\n    /// @param stRewardPerShare The stored reward per share value.\n    /// @param rewarder The address of the rewarder contract.\n    /// @param amount The amount of LP for which reward is being calculated.\n    /// @param lpDecimals The number of decimals of the LP token.\n    /// @return rewards The calculated reward amount.\n    function _getPendingReward(\n        uint256 stRewardPerShare,\n        address rewarder,\n        uint256 amount,\n        uint256 lpDecimals\n    ) internal view returns (uint256 rewards) {\n        /// Retrieve current reward per token from rewarder\n        uint256 enRewardPerShare = IAuraRewarder(rewarder).rewardPerToken();\n        /// Calculatethe difference in reward per share\n        uint256 share = enRewardPerShare > stRewardPerShare\n            ? enRewardPerShare - stRewardPerShare\n            : 0;\n        /// Calculate the total rewards base on share and amount.\n        rewards = (share * amount) / (10 ** lpDecimals);\n    }\n\n    /// @notice  Calculate the pending AURA reward amount.\n    /// @dev AuraMinter can mint additional tokens after `inflationProtectionTime` has passed\n    /// And its value is `1749120350`  ==> Thursday 5 June 2025 12:32:30 PM GMT+07:00\n    /// @param auraRewarder Address of Aura rewarder contract\n    /// @param balAmount The amount of BAL reward for AURA calculation.\n    /// @dev AURA token is minted in booster contract following the mint logic in the below\n    function _getAuraPendingReward(\n        address auraRewarder,\n        uint256 balAmount\n    ) internal view returns (uint256 mintAmount) {\n        /// AURA mint request amount = amount * reward_multiplier / reward_multiplier_denominator\n        uint256 mintRequestAmount = (balAmount *\n            auraPools.getRewardMultipliers(auraRewarder)) /\n            REWARD_MULTIPLIER_DENOMINATOR;\n\n        /// AURA token mint logic\n        /// e.g. emissionsMinted = 6e25 - 5e25 - 0 = 1e25;\n        uint256 totalSupply = AURA.totalSupply();\n        uint256 initAmount = AURA.INIT_MINT_AMOUNT();\n        uint256 minterMinted;\n        uint256 reductionPerCliff = AURA.reductionPerCliff();\n        uint256 totalCliffs = AURA.totalCliffs();\n        uint256 emissionMaxSupply = AURA.EMISSIONS_MAX_SUPPLY();\n\n        uint256 emissionsMinted = totalSupply - initAmount - minterMinted;\n        /// e.g. reductionPerCliff = 5e25 / 500 = 1e23\n        /// e.g. cliff = 1e25 / 1e23 = 100\n        uint256 cliff = emissionsMinted / reductionPerCliff;\n\n        /// e.g. 100 < 500\n        if (cliff < totalCliffs) {\n            /// e.g. (new) reduction = (500 - 100) * 2.5 + 700 = 1700;\n            /// e.g. (new) reduction = (500 - 250) * 2.5 + 700 = 1325;\n            /// e.g. (new) reduction = (500 - 400) * 2.5 + 700 = 950;\n            uint256 reduction = ((totalCliffs - cliff) * 5) / 2 + 700;\n            /// e.g. (new) amount = 1e19 * 1700 / 500 =  34e18;\n            /// e.g. (new) amount = 1e19 * 1325 / 500 =  26.5e18;\n            /// e.g. (new) amount = 1e19 * 950 / 500  =  19e17;\n            mintAmount = (mintRequestAmount * reduction) / totalCliffs;\n\n            /// e.g. amtTillMax = 5e25 - 1e25 = 4e25\n            uint256 amtTillMax = emissionMaxSupply - emissionsMinted;\n            if (mintAmount > amtTillMax) {\n                mintAmount = amtTillMax;\n            }\n        }\n    }\n\n    /// @notice Retrieve pending rewards for a given tokenId and amount.\n    /// @dev The rewards can be split among multiple tokens.\n    /// @param tokenId The ID of the token.\n    /// @param amount The amount of the token.\n    /// @return tokens Array of token addresses.\n    /// @return rewards Array of corresponding reward amounts.\n    function pendingRewards(\n        uint256 tokenId,\n        uint256 amount\n    )\n        public\n        view\n        override\n        returns (address[] memory tokens, uint256[] memory rewards)\n    {\n        (uint256 pid, uint256 stAuraPerShare) = decodeId(tokenId);\n        (address lpToken, , , address auraRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n        uint256 lpDecimals = IERC20MetadataUpgradeable(lpToken).decimals();\n        uint256 extraRewardsCount = extraRewards.length;\n        tokens = new address[](extraRewardsCount + 2);\n        rewards = new uint256[](extraRewardsCount + 2);\n\n        /// BAL reward\n        tokens[0] = IAuraRewarder(auraRewarder).rewardToken();\n        rewards[0] = _getPendingReward(\n            stAuraPerShare,\n            auraRewarder,\n            amount,\n            lpDecimals\n        );\n\n        /// AURA reward\n        tokens[1] = address(AURA);\n        rewards[1] = _getAuraPendingReward(auraRewarder, rewards[0]);\n\n        /// Additional rewards\n        for (uint256 i; i != extraRewardsCount; ) {\n            address rewarder = extraRewards[i];\n            uint256 stRewardPerShare = accExtPerShare[tokenId][rewarder];\n            tokens[i + 2] = IAuraRewarder(rewarder).rewardToken();\n            if (stRewardPerShare == 0) {\n                rewards[i + 2] = 0;\n            } else {\n                rewards[i + 2] = _getPendingReward(\n                    stRewardPerShare == type(uint).max ? 0 : stRewardPerShare,\n                    rewarder,\n                    amount,\n                    lpDecimals\n                );\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Mint an ERC1155 token corresponding to the provided LP token amount.\n    /// @param pid The ID of the AURA pool.\n    /// @param amount The amount of the LP token to be wrapped.\n    /// @return id The minted ERC1155 token's ID.\n    function mint(\n        uint256 pid,\n        uint256 amount\n    ) external nonReentrant returns (uint256 id) {\n        (address lpToken, , , address auraRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n        IERC20Upgradeable(lpToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        _ensureApprove(lpToken, address(auraPools), amount);\n        auraPools.deposit(pid, amount, true);\n\n        /// BAL reward handle logic\n        uint256 balRewardPerToken = IAuraRewarder(auraRewarder)\n            .rewardPerToken();\n        id = encodeId(pid, balRewardPerToken);\n        _mint(msg.sender, id, amount, \"\");\n\n        /// Store extra rewards info\n        uint256 extraRewardsCount = IAuraRewarder(auraRewarder)\n            .extraRewardsLength();\n        for (uint256 i; i != extraRewardsCount; ) {\n            address extraRewarder = IAuraRewarder(auraRewarder).extraRewards(i);\n            uint256 rewardPerToken = IAuraRewarder(extraRewarder)\n                .rewardPerToken();\n            accExtPerShare[id][extraRewarder] = rewardPerToken == 0\n                ? type(uint).max\n                : rewardPerToken;\n\n            _syncExtraReward(extraRewarder);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Burn the provided ERC1155 token and redeem its underlying ERC20 token.\n    /// @param id The ID of the ERC1155 token to burn.\n    /// @param amount The amount of the ERC1155 token to burn.\n    /// @return rewardTokens An array of reward tokens that the user is eligible to receive.\n    /// @return rewards The corresponding amounts of reward tokens.\n    function burn(\n        uint256 id,\n        uint256 amount\n    )\n        external\n        nonReentrant\n        returns (address[] memory rewardTokens, uint256[] memory rewards)\n    {\n        if (amount == type(uint256).max) {\n            amount = balanceOf(msg.sender, id);\n        }\n        (uint256 pid, ) = decodeId(id);\n        _burn(msg.sender, id, amount);\n\n        (address lpToken, , , address auraRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n\n        /// Claim Rewards\n        IAuraRewarder(auraRewarder).withdraw(amount, true);\n        /// Withdraw LP\n        auraPools.withdraw(pid, amount);\n\n        /// Transfer LP Tokens\n        IERC20Upgradeable(lpToken).safeTransfer(msg.sender, amount);\n\n        uint256 extraRewardsCount = IAuraRewarder(auraRewarder)\n            .extraRewardsLength();\n\n        for (uint256 i; i != extraRewardsCount; ) {\n            _syncExtraReward(IAuraRewarder(auraRewarder).extraRewards(i));\n\n            unchecked {\n                ++i;\n            }\n        }\n        uint256 storedExtraRewardLength = extraRewards.length;\n        bool hasDiffExtraRewards = extraRewardsCount != storedExtraRewardLength;\n\n        /// Transfer Reward Tokens\n        (rewardTokens, rewards) = pendingRewards(id, amount);\n\n        /// Withdraw manually\n        if (hasDiffExtraRewards) {\n            for (uint256 i; i != storedExtraRewardLength; ) {\n                IAuraExtraRewarder(extraRewards[i]).getReward();\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        uint256 rewardTokensLength = rewardTokens.length;\n        for (uint256 i; i != rewardTokensLength; ) {\n            IERC20Upgradeable(rewardTokens[i]).safeTransfer(\n                msg.sender,\n                rewards[i]\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Get the full set of extra rewards.\n    /// @return An array containing the addresses of extra reward tokens.\n    function extraRewardsLength() external view returns (uint256) {\n        return extraRewards.length;\n    }\n\n    /// @notice Internal function to sync any extra rewards with the contract.\n    /// @param extraReward The address of the extra reward token.\n    /// @dev Adds the extra reward to the internal list if not already present.\n    function _syncExtraReward(address extraReward) private {\n        if (extraRewardsIdx[extraReward] == 0) {\n            extraRewards.push(extraReward);\n            extraRewardsIdx[extraReward] = extraRewards.length;\n        }\n    }\n}"
    },
    {
      "filename": "blueberry-core/contracts/wrapper/WAuraPools.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"../utils/BlueBerryErrors.sol\" as Errors;\nimport \"../utils/EnsureApprove.sol\";\nimport \"../interfaces/IWAuraPools.sol\";\nimport \"../interfaces/IERC20Wrapper.sol\";\nimport \"../interfaces/aura/IAuraRewarder.sol\";\nimport \"../interfaces/aura/IAuraExtraRewarder.sol\";\nimport \"../interfaces/aura/IAura.sol\";\n\n/**\n * @title WAuraPools\n * @author BlueberryProtocol\n * @notice Wrapped Aura Pools is the wrapper of LP positions\n * @dev Leveraged LP Tokens will be wrapped here and be held in BlueberryBank\n *      and do not generate yields. LP Tokens are identified by tokenIds\n *      encoded from lp token address.\n */\ncontract WAuraPools is\n    ERC1155Upgradeable,\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable,\n    EnsureApprove,\n    IERC20Wrapper,\n    IWAuraPools\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                   PUBLIC STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Address to Aura Pools contract\n    IAuraPools public auraPools;\n    /// @dev Address to AURA token\n    IAura public AURA;\n    /// @dev Address to STASH_AURA token\n    address public STASH_AURA;\n    /// @dev Mapping from token id to accExtPerShare\n    mapping(uint256 => mapping(address => uint256)) public accExtPerShare;\n    /// @dev Aura extra rewards addresses\n    address[] public extraRewards;\n    /// @dev The index of extra rewards\n    mapping(address => uint256) public extraRewardsIdx;\n\n    uint public REWARD_MULTIPLIER_DENOMINATOR;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Initializes contract with dependencies\n    /// @param aura_ The AURA token address\n    /// @param auraPools_ The auraPools contract address\n    /// @param stash_aura_ The stash for AURA\n    function initialize(\n        address aura_,\n        address auraPools_,\n        address stash_aura_\n    ) external initializer {\n        __ReentrancyGuard_init();\n        __ERC1155_init(\"WAuraPools\");\n        AURA = IAura(aura_);\n        STASH_AURA = stash_aura_;\n        auraPools = IAuraPools(auraPools_);\n        REWARD_MULTIPLIER_DENOMINATOR = auraPools\n            .REWARD_MULTIPLIER_DENOMINATOR();\n    }\n\n    /// @notice Encodes pool id and AURA per share into an ERC1155 token id\n    /// @param pid The pool id (The first 16-bits)\n    /// @param auraPerShare Amount of AURA per share, multiplied by 1e18 (The last 240-bits)\n    /// @return id The resulting ERC1155 token id\n\n    function encodeId(\n        uint256 pid,\n        uint256 auraPerShare\n    ) public pure returns (uint256 id) {\n        // Ensure the pool id and auraPerShare are within expected bounds\n        if (pid >= (1 << 16)) revert Errors.BAD_PID(pid);\n        if (auraPerShare >= (1 << 240))\n            revert Errors.BAD_REWARD_PER_SHARE(auraPerShare);\n        return (pid << 240) | auraPerShare;\n    }\n\n    /// @notice Decodes ERC1155 token id to pool id and AURA per share\n    /// @param id The ERC1155 token id\n    /// @return gid The decoded pool id\n    /// @return auraPerShare The decoded amount of AURA per share\n    function decodeId(\n        uint256 id\n    ) public pure returns (uint256 gid, uint256 auraPerShare) {\n        gid = id >> 240; // Extracting the first 16 bits\n        auraPerShare = id & ((1 << 240) - 1); // Extracting the last 240 bits\n    }\n\n    /// @notice Retrieves the underlying ERC20 token of the specified ERC1155 token id\n    /// @param id The ERC1155 token id\n    /// @return uToken Address of the underlying ERC20 token\n    function getUnderlyingToken(\n        uint256 id\n    ) external view override returns (address uToken) {\n        (uint256 pid, ) = decodeId(id);\n        (uToken, , , , , ) = getPoolInfoFromPoolId(pid);\n    }\n\n    /// @notice Gets the Balancer vault for a given BPT token\n    /// @param bpt Address of the BPT token\n    /// @return Vault associated with the provided BPT token\n    function getVault(address bpt) public view returns (IBalancerVault) {\n        return IBalancerVault(IBalancerPool(bpt).getVault());\n    }\n\n    /// @notice Retrieves pool tokens from a given BPT address\n    /// @param bpt Address of the BPT token\n    /// @return tokens Array of token addresses in the pool\n    /// @return balances Corresponding balances of the tokens in the pool\n    /// @return lastChangedBlock The last block when the pool composition changed\n    function getPoolTokens(\n        address bpt\n    )\n        external\n        view\n        returns (\n            address[] memory tokens,\n            uint256[] memory balances,\n            uint256 lastChangedBlock\n        )\n    {\n        return getVault(bpt).getPoolTokens(IBalancerPool(bpt).getPoolId());\n    }\n\n    /// @notice Retrieves pool id from a BPT token\n    /// @param bpt Address of the BPT token\n    /// @return Pool id associated with the BPT token\n    function getBPTPoolId(address bpt) public view returns (bytes32) {\n        return IBalancerPool(bpt).getPoolId();\n    }\n\n    /// @notice Fetches pool information using a provided aura finance pool id\n    /// @param pid The aura finance pool id\n    /// @return lptoken Address of the LP token\n    /// @return token Address of the associated token\n    /// @return gauge Address of the gauge\n    /// @return auraRewards Address for AURA rewards\n    /// @return stash Address of the stash\n    /// @return shutdown Boolean indicating if the pool is shut down\n    function getPoolInfoFromPoolId(\n        uint256 pid\n    )\n        public\n        view\n        returns (\n            address lptoken,\n            address token,\n            address gauge,\n            address auraRewards,\n            address stash,\n            bool shutdown\n        )\n    {\n        return auraPools.poolInfo(pid);\n    }\n\n    /// @notice Calculate the amount of pending reward for a given LP amount.\n    /// @param stRewardPerShare The stored reward per share value.\n    /// @param rewarder The address of the rewarder contract.\n    /// @param amount The amount of LP for which reward is being calculated.\n    /// @param lpDecimals The number of decimals of the LP token.\n    /// @return rewards The calculated reward amount.\n    function _getPendingReward(\n        uint256 stRewardPerShare,\n        address rewarder,\n        uint256 amount,\n        uint256 lpDecimals\n    ) internal view returns (uint256 rewards) {\n        /// Retrieve current reward per token from rewarder\n        uint256 enRewardPerShare = IAuraRewarder(rewarder).rewardPerToken();\n        /// Calculatethe difference in reward per share\n        uint256 share = enRewardPerShare > stRewardPerShare\n            ? enRewardPerShare - stRewardPerShare\n            : 0;\n        /// Calculate the total rewards base on share and amount.\n        rewards = (share * amount) / (10 ** lpDecimals);\n    }\n\n    /// @notice  Calculate the pending AURA reward amount.\n    /// @dev AuraMinter can mint additional tokens after `inflationProtectionTime` has passed\n    /// And its value is `1749120350`  ==> Thursday 5 June 2025 12:32:30 PM GMT+07:00\n    /// @param auraRewarder Address of Aura rewarder contract\n    /// @param balAmount The amount of BAL reward for AURA calculation.\n    /// @dev AURA token is minted in booster contract following the mint logic in the below\n    function _getAuraPendingReward(\n        address auraRewarder,\n        uint256 balAmount\n    ) internal view returns (uint256 mintAmount) {\n        /// AURA mint request amount = amount * reward_multiplier / reward_multiplier_denominator\n        uint256 mintRequestAmount = (balAmount *\n            auraPools.getRewardMultipliers(auraRewarder)) /\n            REWARD_MULTIPLIER_DENOMINATOR;\n\n        /// AURA token mint logic\n        /// e.g. emissionsMinted = 6e25 - 5e25 - 0 = 1e25;\n        uint256 totalSupply = AURA.totalSupply();\n        uint256 initAmount = AURA.INIT_MINT_AMOUNT();\n        uint256 minterMinted;\n        uint256 reductionPerCliff = AURA.reductionPerCliff();\n        uint256 totalCliffs = AURA.totalCliffs();\n        uint256 emissionMaxSupply = AURA.EMISSIONS_MAX_SUPPLY();\n\n        uint256 emissionsMinted = totalSupply - initAmount - minterMinted;\n        /// e.g. reductionPerCliff = 5e25 / 500 = 1e23\n        /// e.g. cliff = 1e25 / 1e23 = 100\n        uint256 cliff = emissionsMinted / reductionPerCliff;\n\n        /// e.g. 100 < 500\n        if (cliff < totalCliffs) {\n            /// e.g. (new) reduction = (500 - 100) * 2.5 + 700 = 1700;\n            /// e.g. (new) reduction = (500 - 250) * 2.5 + 700 = 1325;\n            /// e.g. (new) reduction = (500 - 400) * 2.5 + 700 = 950;\n            uint256 reduction = ((totalCliffs - cliff) * 5) / 2 + 700;\n            /// e.g. (new) amount = 1e19 * 1700 / 500 =  34e18;\n            /// e.g. (new) amount = 1e19 * 1325 / 500 =  26.5e18;\n            /// e.g. (new) amount = 1e19 * 950 / 500  =  19e17;\n            mintAmount = (mintRequestAmount * reduction) / totalCliffs;\n\n            /// e.g. amtTillMax = 5e25 - 1e25 = 4e25\n            uint256 amtTillMax = emissionMaxSupply - emissionsMinted;\n            if (mintAmount > amtTillMax) {\n                mintAmount = amtTillMax;\n            }\n        }\n    }\n\n    /// @notice Retrieve pending rewards for a given tokenId and amount.\n    /// @dev The rewards can be split among multiple tokens.\n    /// @param tokenId The ID of the token.\n    /// @param amount The amount of the token.\n    /// @return tokens Array of token addresses.\n    /// @return rewards Array of corresponding reward amounts.\n    function pendingRewards(\n        uint256 tokenId,\n        uint256 amount\n    )\n        public\n        view\n        override\n        returns (address[] memory tokens, uint256[] memory rewards)\n    {\n        (uint256 pid, uint256 stAuraPerShare) = decodeId(tokenId);\n        (address lpToken, , , address auraRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n        uint256 lpDecimals = IERC20MetadataUpgradeable(lpToken).decimals();\n        uint256 extraRewardsCount = extraRewards.length;\n        tokens = new address[](extraRewardsCount + 2);\n        rewards = new uint256[](extraRewardsCount + 2);\n\n        /// BAL reward\n        tokens[0] = IAuraRewarder(auraRewarder).rewardToken();\n        rewards[0] = _getPendingReward(\n            stAuraPerShare,\n            auraRewarder,\n            amount,\n            lpDecimals\n        );\n\n        /// AURA reward\n        tokens[1] = address(AURA);\n        rewards[1] = _getAuraPendingReward(auraRewarder, rewards[0]);\n\n        /// Additional rewards\n        for (uint256 i; i != extraRewardsCount; ) {\n            address rewarder = extraRewards[i];\n            uint256 stRewardPerShare = accExtPerShare[tokenId][rewarder];\n            tokens[i + 2] = IAuraRewarder(rewarder).rewardToken();\n            if (stRewardPerShare == 0) {\n                rewards[i + 2] = 0;\n            } else {\n                rewards[i + 2] = _getPendingReward(\n                    stRewardPerShare == type(uint).max ? 0 : stRewardPerShare,\n                    rewarder,\n                    amount,\n                    lpDecimals\n                );\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Mint an ERC1155 token corresponding to the provided LP token amount.\n    /// @param pid The ID of the AURA pool.\n    /// @param amount The amount of the LP token to be wrapped.\n    /// @return id The minted ERC1155 token's ID.\n    function mint(\n        uint256 pid,\n        uint256 amount\n    ) external nonReentrant returns (uint256 id) {\n        (address lpToken, , , address auraRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n        IERC20Upgradeable(lpToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        _ensureApprove(lpToken, address(auraPools), amount);\n        auraPools.deposit(pid, amount, true);\n\n        /// BAL reward handle logic\n        uint256 balRewardPerToken = IAuraRewarder(auraRewarder)\n            .rewardPerToken();\n        id = encodeId(pid, balRewardPerToken);\n        _mint(msg.sender, id, amount, \"\");\n\n        /// Store extra rewards info\n        uint256 extraRewardsCount = IAuraRewarder(auraRewarder)\n            .extraRewardsLength();\n        for (uint256 i; i != extraRewardsCount; ) {\n            address extraRewarder = IAuraRewarder(auraRewarder).extraRewards(i);\n            uint256 rewardPerToken = IAuraRewarder(extraRewarder)\n                .rewardPerToken();\n            accExtPerShare[id][extraRewarder] = rewardPerToken == 0\n                ? type(uint).max\n                : rewardPerToken;\n\n            _syncExtraReward(extraRewarder);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Burn the provided ERC1155 token and redeem its underlying ERC20 token.\n    /// @param id The ID of the ERC1155 token to burn.\n    /// @param amount The amount of the ERC1155 token to burn.\n    /// @return rewardTokens An array of reward tokens that the user is eligible to receive.\n    /// @return rewards The corresponding amounts of reward tokens.\n    function burn(\n        uint256 id,\n        uint256 amount\n    )\n        external\n        nonReentrant\n        returns (address[] memory rewardTokens, uint256[] memory rewards)\n    {\n        if (amount == type(uint256).max) {\n            amount = balanceOf(msg.sender, id);\n        }\n        (uint256 pid, ) = decodeId(id);\n        _burn(msg.sender, id, amount);\n\n        (address lpToken, , , address auraRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n\n        /// Claim Rewards\n        IAuraRewarder(auraRewarder).withdraw(amount, true);\n        /// Withdraw LP\n        auraPools.withdraw(pid, amount);\n\n        /// Transfer LP Tokens\n        IERC20Upgradeable(lpToken).safeTransfer(msg.sender, amount);\n\n        uint256 extraRewardsCount = IAuraRewarder(auraRewarder)\n            .extraRewardsLength();\n\n        for (uint256 i; i != extraRewardsCount; ) {\n            _syncExtraReward(IAuraRewarder(auraRewarder).extraRewards(i));\n\n            unchecked {\n                ++i;\n            }\n        }\n        uint256 storedExtraRewardLength = extraRewards.length;\n        bool hasDiffExtraRewards = extraRewardsCount != storedExtraRewardLength;\n\n        /// Transfer Reward Tokens\n        (rewardTokens, rewards) = pendingRewards(id, amount);\n\n        /// Withdraw manually\n        if (hasDiffExtraRewards) {\n            for (uint256 i; i != storedExtraRewardLength; ) {\n                IAuraExtraRewarder(extraRewards[i]).getReward();\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        uint256 rewardTokensLength = rewardTokens.l"
    }
  ]
}