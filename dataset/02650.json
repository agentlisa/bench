{
  "Title": "M-7: `latestRoundData()` has no check for round completeness",
  "Content": "# Issue M-7: `latestRoundData()` has no check for round completeness \n\nSource: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/200 \n\n## Found by \n\\_\\_141345\\_\\_, 8olidity, yixxas, caventa, HonorLt\n\n## Summary\n\nNo check for round completeness could lead to stale prices and wrong price return value, or outdated price. The functions rely on accurate price feed might not work as expected, sometimes can lead to fund loss. \n\n\n## Vulnerability Detail\n\nThe oracle wrapper `getOraclePrice()` call out to an oracle with `latestRoundData()` to get the price of some token. Although the returned timestamp is checked, there is no check for round completeness.\n\nAccording to Chainlink's documentation, this function does not error if no answer has been reached but returns 0 or outdated round data. The external Chainlink oracle, which provides index price information to the system, introduces risk inherent to any dependency on third-party data sources. For example, the oracle could fall behind or otherwise fail to be maintained, resulting in outdated data being fed to the index price calculations. Oracle reliance has historically resulted in crippled on-chain systems, and complications that lead to these outcomes can arise from things as simple as network congestion.\n\n## Reference\nChainlink documentation:\nhttps://docs.chain.link/docs/historical-price-data/#historical-rounds\n\n## Impact\n\nIf there is a problem with chainlink starting a new round and finding consensus on the new value for the oracle (e.g. chainlink nodes abandon the oracle, chain congestion, vulnerability/attacks on the chainlink system) consumers of this contract may continue using outdated stale data (if oracles are unable to submit no new round is started).\n\nThis could lead to stale prices and wrong price return value, or outdated price.\n\nAs a result, the functions rely on accurate price feed might not work as expected, sometimes can lead to fund loss. The impacts vary and depends on the specific situation like the following:\n- incorrect liquidation\n    - some users could be liquidated when they should not\n    - no liquidation is performed when there should be\n- wrong price feed \n    - causing inappropriate loan being taken, beyond the current collateral factor\n    - too low price feed affect normal bor\n\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_Base.sol#L164-L181\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nValidate data feed for round completeness:\n```solidity\n    function getOraclePrice(IAggregatorV3 _priceFeed, int192 _maxPrice, int192 _minPrice) public view returns (uint256 ) {\n        (\n            uint80 roundID,\n            int signedPrice,\n            /*uint startedAt*/,\n            uint timeStamp,\n            uint80 answeredInRound\n        ) = _priceFeed.latestRoundData();\n        //check for Chainlink oracle deviancies, force a revert if any are present. Helps prevent a LUNA like issue\n        require(signedPrice > 0, \"Negative Oracle Price\");\n        require(timeStamp >= block.timestamp - HEARTBEAT_TIME , \"Stale pricefeed\");\n        require(signedPrice < _maxPrice, \"Upper price bound breached\");\n        require(signedPrice > _minPrice, \"Lower price bound breached\");\n        require(answeredInRound >= roundID, \"round not complete\");\n\n        uint256 price = uint256(signedPrice);\n        return price;\n    }\n```\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor confirmed, will fix. \n\n**kree-dotcom**\n\nFixed https://github.com/kree-dotcom/Velo-Deposit-Tokens/commit/5c656e791e70ecdfe26f9807438498384d7f6108\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/22",
  "Code": [
    {
      "filename": "contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_Base.sol",
      "content": "pragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n//chainlink aggregator interface extended \nimport \"./Interfaces/IAggregatorV3.sol\";\nimport \"./Interfaces/IAccessControlledOffchainAggregator.sol\";\n\nimport \"./Interfaces/IRouter.sol\";\n\n\nabstract contract DepositReceipt_Base is  ERC721Enumerable, AccessControl {\n    \n    // Role based access control, minters can mint or burn moUSD\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");  \n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");  \n\n    \n    uint256 private constant HEARTBEAT_TIME = 24 hours; //Check heartbeat frequency when adding new feeds\n    uint256 constant BASE = 1 ether; //division base\n    uint256 constant HUNDRED_TOKENS = 1e20; //due to constructor restrictions we know the non-USDC token has 18d.p.\n    uint256 constant HUNDRED = 100; //used to scale 100 token price to 1 token price\n    \n    //Mapping from NFTid to number of associated poolTokens\n    mapping(uint256 => uint256) public pooledTokens;\n    //Mapping from NFTid to original depositor contract(where tokens can be redeemed by anyone)\n    mapping(uint256 => address) public relatedDepositor;\n\n    //last NFT id, used as key\n    uint256 public currentLastId;\n\n    //router used for underlying asset quotes\n    IRouter public router;\n\n    //hardcoded price bounds used by chainlink for ETH feed\n    int192 ETHMaxPrice;\n    int192 ETHMinPrice;\n    //hardcoded price bounds used by chainlink for Token in USD feed\n    int192 tokenMaxPrice;\n    int192 tokenMinPrice;\n\n    //underlying gauge token details\n    address public token0; \n    address public token1;\n    bool public stable;\n\n    \n    \n    \n\n    event AddNewMinter(address indexed account, address indexed addedBy);\n    event NFTSplit(uint256 oldNFTId, uint256 newNFTId);\n    event NFTDataModified(uint256 NFTId, uint256 pastPooledTokens, uint256 newPooledTokens);\n\n\n    modifier onlyMinter{\n        require(hasRole(MINTER_ROLE, msg.sender), \"Caller is not a minter\");\n        _;\n    }\n\n    modifier onlyAdmin{\n        require(hasRole(ADMIN_ROLE, msg.sender), \"Caller is not an admin\");\n        _;\n    }\n    \n    function addMinter(address _account) external onlyAdmin{\n        _setupRole(MINTER_ROLE, _account);\n        emit AddNewMinter(_account,  msg.sender);\n    }\n\n    /**\n   * @notice as supportsInterface is present in both ERC721 and AccessControl we must specify the override here to dictate the order\n   */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721Enumerable, AccessControl) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n    /**\n   * @notice Splits a deposit Receipt  into two NFTs. Assigns `percentageSplit` of the original\n   * pooled tokens to the new certificate.\n   * @notice only the owner of an NFTId or approved approved addresses can split an NFT\n   * @param _NFTId The id of the DepositReceipt NFT.\n   * @param _percentageSplit The percentage of pooled tokens assigned to the new NFT.\n   */\n\n   //Borrowed from original Lyra.finance ERC721 design.\n  function split(uint256 _NFTId, uint256 _percentageSplit) external returns (uint256) {\n    require(_percentageSplit < BASE, \"split must be less than 100%\");\n    require(_isApprovedOrOwner(msg.sender, _NFTId), \"ERC721: caller is not token owner or approved\");\n\n    uint256 existingPooledTokens = pooledTokens[_NFTId];\n    uint256 newPooledTokens = (existingPooledTokens * _percentageSplit)/ BASE;\n    pooledTokens[_NFTId] = existingPooledTokens - newPooledTokens;\n    uint256 newNFTId = _mintNewNFT(newPooledTokens, relatedDepositor[_NFTId]);\n    \n\n    emit NFTSplit(_NFTId, newNFTId);\n    emit NFTDataModified(_NFTId, existingPooledTokens, existingPooledTokens - newPooledTokens);\n    emit NFTDataModified(newNFTId, 0, newPooledTokens);\n    return newNFTId;\n    }\n    \n     /**\n      * @notice Only minter roles can burn Deposit receipts\n      * @dev burns 'amount' of tokens to address 'account', and emits Transfer event to \n      * to zero address.\n      * @param _NFTId The NFT id of the token to be burned, sender must be holder or approved by holder\n     **/\n    function burn(uint256 _NFTId) external onlyMinter{\n        require(_isApprovedOrOwner(msg.sender, _NFTId), \"ERC721: caller is not token owner or approved\");\n        delete pooledTokens[_NFTId];\n        delete relatedDepositor[_NFTId];\n        _burn(_NFTId);\n    }\n    /**\n      * @notice Only minter roles can mint Deposit receipts for new Pooled Tokens\n      * @dev Mints new NFT with '_pooledTokenAmount' of pooledTokens associated with it\n      * @param _pooledTokenAmount amount of pooled tokens to be associated with NFT\n     **/\n    function safeMint( uint _pooledTokenAmount) external onlyMinter returns(uint256){\n        return (_mintNewNFT(_pooledTokenAmount, msg.sender));\n    }\n\n    /**\n      * @notice Only callable by Minters via safeMint or  by split()\n      * @dev Mints new NFT with '_pooledTokenAmount' of pooledTokens associated with it and emits Transfer event\n      * @param _pooledTokenAmount amount of pooled tokens to be associated with NFT\n      * @param _depositor the address to be recorded as the related depositor where the pooledTokens can be withdrawn from\n     **/\n    function _mintNewNFT( uint _pooledTokenAmount, address _depositor) internal returns(uint256){\n        uint256 NFTId = currentLastId;\n        currentLastId += 1;\n        pooledTokens[NFTId] = _pooledTokenAmount;\n        relatedDepositor[NFTId] = _depositor; \n        _safeMint( msg.sender, NFTId);\n        return(NFTId);\n\n    }\n    /**\n     * @notice Pass through function that converts pooledTokens to underlying asset amounts. \n     * @dev for pricing THIS MUST NOT be used in isolation, use priceLiquidity instead\n     * @param _liquidity amount of pooledTokens you want to find the underlying liquidity for.\n     */\n    function viewQuoteRemoveLiquidity(uint256 _liquidity) public view returns( uint256, uint256 ){\n        uint256 token0Amount;\n        uint256 token1Amount;\n        (token0Amount, token1Amount) = router.quoteRemoveLiquidity(\n                                    token0, \n                                    token1,\n                                    stable,\n                                    _liquidity );\n        return (token0Amount, token1Amount);\n\n    }\n\n    /** \n     * @dev This function is view but uses block.timestamp which will only return a non-zero value in a tx call.\n     * @param _priceFeed the Chainlink aggregator for the price you want to retrieve, ETH or Token.\n     * @param _maxPrice the immutable maximum price this aggregator has\n     * @param _minPrice the immutable minimum price this aggregator has\n     * @return Oracle price converted to a uint256 for ease of use elsewhere\n     */\n    function getOraclePrice(IAggregatorV3 _priceFeed, int192 _maxPrice, int192 _minPrice) public view returns (uint256 ) {\n        (\n            /*uint80 roundID*/,\n            int signedPrice,\n            /*uint startedAt*/,\n            uint timeStamp,\n            /*uint80 answeredInRound*/\n        ) = _priceFeed.latestRoundData();\n        //check for Chainlink oracle deviancies, force a revert if any are present. Helps prevent a LUNA like issue\n        require(signedPrice > 0, \"Negative Oracle Price\");\n        require(timeStamp >= block.timestamp - HEARTBEAT_TIME , \"Stale pricefeed\");\n        require(signedPrice < _maxPrice, \"Upper price bound breached\");\n        require(signedPrice > _minPrice, \"Lower price bound breached\");\n        uint256 price = uint256(signedPrice);\n        return price;\n\n\n    }\n\n   /**\n    *  @notice this is used to price pooled Tokens by determining their underlying assets and then pricing these\n    *  @notice the two ways to do this are to price to USDC as  a dollar equivalent or to ETH then use Chainlink price feeds\n    *  @dev each DepositReceipt has a bespoke valuation method, make sure it fits the tokens\n    *  @dev each DepositReceipt's valuation method is sensitive to available liquidity keep this in mind as liquidating a pooled token by using the same pool will reduce overall liquidity\n\n    */\n    function priceLiquidity(uint256 _liquidity) external virtual view returns(uint256);\n}"
    }
  ]
}