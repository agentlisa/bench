{
  "Title": "Outdated Seed Gauge System documentation in PR and inline comments",
  "Content": "There are multiple instances in both the PR and inline comments where documentation of the Seed Gauge System is outdated. For example:\n- `LibWhitelist::updateGaugeForToken` does not allow the gauge points to be changed. This is contrary to the comment in [`WhitelistFacet::updateGaugeForToken`](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/beanstalk/silo/WhitelistFacet.sol#L172).\n- The behavior of [`LibGauge::getBeanToMaxLpGpPerBdvRatioScaled`](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/libraries/LibGauge.sol#L316-L329) is incorrectly documented as the reverse of its actual behavior, which is `f(0) = MIN_BEAN_MAX_LPGP_RATIO` and `f(100e18) = MAX_BEAN_MAX_LPGP_RATIO`.\n- Gauge Points are not normalized to `100e18`, as stated in the PR.\n- The [`MIN_BEAN_MAX_LP_GP_PER_BDV_RATIO`](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/libraries/LibGauge.sol#L32) constant is actually `50e18`, not `25e18` as stated in the PR.\n- `gpPerBdv` and `beanToMaxLpGpPerBdvRatio` both have 18 decimal precision, but there are [multiple](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/libraries/LibGauge.sol#L153) [comments](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/libraries/LibGauge.sol#L210) which [incorrectly](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/libraries/LibGauge.sol#L215) state that these variables have 6 decimal precision.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/beanstalk/silo/WhitelistFacet.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {LibDiamond} from \"contracts/libraries/LibDiamond.sol\";\nimport {LibWhitelist} from \"contracts/libraries/Silo/LibWhitelist.sol\";\nimport {AppStorage} from \"../AppStorage.sol\";\n\n/**\n * @author Publius\n * @title Whitelist Facet \n * @notice Manages the Silo Whitelist including Adding to, Updating \n * and Removing from the Silo Whitelist\n **/\ncontract WhitelistFacet {\n\n    /**\n     * @notice Emitted when a token is added to the Silo Whitelist.\n     * @param token ERC-20 token being added to the Silo Whitelist.\n     * @param selector The function selector that returns the BDV of a given\n     * amount of `token`. Must have signature:\n     * \n     * ```\n     * function bdv(uint256 amount) public view returns (uint256);\n     * ```\n     * \n     * @param stalkEarnedPerSeason The Stalk per BDV per Season received from depositing `token`.\n     * @param stalkIssuedPerBdv The Stalk per BDV given from depositing `token`.\n     * @param gpSelector The function selector that returns the gauge points of a given token.\n     * Must have signature:\n     * \n     * ```\n     * function gpFunction(uint256,uint256,uint256) public view returns (uint256);\n     * ```\n     * \n     * @param gaugePoints The gauge points of the token.\n     * @param optimalPercentDepositedBdv The target percentage \n     * of the total LP deposited BDV for this token.\n     * \n     */\n    event WhitelistToken(\n        address indexed token,\n        bytes4 selector,\n        uint32 stalkEarnedPerSeason,\n        uint256 stalkIssuedPerBdv,\n        bytes4 gpSelector,\n        uint128 gaugePoints,\n        uint96 optimalPercentDepositedBdv\n    );\n\n    /**\n     * @notice Emitted whenever the `stalkEarnedPerSeason` changes for a token.\n     * @param token Address of the token that the `stalkEarnedPerSeason` is updated for.\n     * @param stalkEarnedPerSeason The new amount of Stalk earned per Season for each Deposited BDV.\n     * @param season The Season that the new `stalkEarnedPerSeason` comes into effect. \n     */\n    event UpdatedStalkPerBdvPerSeason(\n        address indexed token,\n        uint32 stalkEarnedPerSeason,\n        uint32 season\n    );\n\n    /**\n     * @notice Emitted when a token is removed from the Silo Whitelist.\n     * @param token Address of the token that was removed from the Silo Whitelist.\n     */\n    event DewhitelistToken(address indexed token);\n\n    /**\n     * @notice Removes a token from the Silo Whitelist.\n     * @dev Can only be called by Beanstalk or Beanstalk owner.\n     */\n    function dewhitelistToken(address token) external payable {\n        LibDiamond.enforceIsOwnerOrContract();\n        LibWhitelist.dewhitelistToken(token);\n    }\n\n    /**\n     * @notice Adds a token to the Silo Whitelist.\n     * @param token Address of the token that is being Whitelisted.\n     * @param selector The function selector that is used to calculate the BDV of the token.\n     * @param stalkIssuedPerBdv The amount of Stalk issued per BDV on Deposit.\n     * @param stalkEarnedPerSeason The amount of Stalk earned per Season for each Deposited BDV.\n     * @param gaugePointSelector The function selector that is used to calculate the Gauge Points of the token.\n     * @param gaugePoints The inital gauge points allocated to the token.\n     * @param optimalPercentDepositedBdv The target percentage \n     * of the total LP deposited BDV for this token. Only used if the token is an LP token.\n     * @dev \n     * Can only be called by Beanstalk or Beanstalk owner.\n     * Assumes an `encodeType` of 0.\n     */\n    function whitelistToken(\n        address token,\n        bytes4 selector,\n        uint16 stalkIssuedPerBdv,\n        uint32 stalkEarnedPerSeason,\n        bytes4 gaugePointSelector,\n        uint128 gaugePoints,\n        uint96 optimalPercentDepositedBdv\n    ) external payable {\n        LibDiamond.enforceIsOwnerOrContract();\n        LibWhitelist.whitelistToken(\n            token,\n            selector,\n            stalkIssuedPerBdv,\n            stalkEarnedPerSeason,\n            0x00,\n            gaugePointSelector,\n            gaugePoints,\n            optimalPercentDepositedBdv\n        );\n    }\n\n    /**\n     * @notice Adds a token to the Silo Whitelist with an `encodeType`\n     * @param token Address of the token that is being Whitelisted.\n     * @param selector The function selector that is used to calculate the BDV of the token.\n     * @param stalkIssuedPerBdv The amount of Stalk issued per BDV on Deposit.\n     * @param stalkEarnedPerSeason The amount of Stalk earned per Season for each Deposited BDV.\n     * @param encodeType The encode type that should be used to encode the BDV function call. See {LibTokenSilo.beanDenominatedValue}.\n     * @param gaugePointSelector The function selector that is used to calculate the Gauge Points of the token.\n     * @param gaugePoints The inital gauge points allocated to the token.\n     * @param optimalPercentDepositedBdv The target percentage \n     * of the total LP deposited BDV for this token. Only used if the token is an LP token.\n     * \n     * @dev Can only be called by Beanstalk or Beanstalk owner.\n     */\n    function whitelistTokenWithEncodeType(\n        address token,\n        bytes4 selector,\n        uint32 stalkIssuedPerBdv,\n        uint32 stalkEarnedPerSeason,\n        bytes1 encodeType,\n        bytes4 gaugePointSelector,\n        uint128 gaugePoints,\n        uint96 optimalPercentDepositedBdv\n    ) external payable {\n        LibDiamond.enforceIsOwnerOrContract();\n        LibWhitelist.whitelistToken(\n            token,\n            selector,\n            stalkIssuedPerBdv,\n            stalkEarnedPerSeason,\n            encodeType,\n            gaugePointSelector,\n            gaugePoints,\n            optimalPercentDepositedBdv\n        );\n    }\n\n    /**\n     * @notice Updates the Stalk Per BDV Per Season for a given Token\n     * @param token Address of the token that is being Whitelisted.\n     * @param stalkEarnedPerSeason The new amount of Stalk earned per Season for each Deposited BDV.\n     * @dev Can only be called by Beanstalk or Beanstalk owner.\n     */\n    function updateStalkPerBdvPerSeasonForToken(\n        address token,\n        uint32 stalkEarnedPerSeason\n    ) external payable {\n        LibDiamond.enforceIsOwnerOrContract();\n        LibWhitelist.updateStalkPerBdvPerSeasonForToken(\n            token,\n            stalkEarnedPerSeason\n        );\n    }\n\n    /**\n     * @notice updates the Gauge point selctor, the gauge points themselves, or the optimal \n     */\n    function updateGaugeForToken(\n        address token, \n        bytes4 gaugePointSelector,\n        uint96 optimalPercentDepositedBdv\n    ) external payable {\n        LibDiamond.enforceIsOwnerOrContract();\n        LibWhitelist.updateGaugeForToken(\n            token,\n            gaugePointSelector,\n            optimalPercentDepositedBdv\n        );\n    }\n}"
    },
    {
      "filename": "protocol/contracts/libraries/LibGauge.sol",
      "content": "/*\n SPDX-License-Identifier: MIT\n*/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {LibAppStorage, AppStorage, Storage} from \"./LibAppStorage.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport {LibWhitelistedTokens} from \"contracts/libraries/Silo/LibWhitelistedTokens.sol\";\nimport {LibWhitelist} from \"contracts/libraries/Silo/LibWhitelist.sol\";\nimport {LibSafeMath32} from \"contracts/libraries/LibSafeMath32.sol\";\nimport {C} from \"../C.sol\";\nimport {LibWell} from \"contracts/libraries/Well/LibWell.sol\";\n\n/**\n * @title LibGauge\n * @author Brean, Brendan\n * @notice LibGauge handles functionality related to the seed gauge system.\n */\nlibrary LibGauge {\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n    using LibSafeMath32 for uint32;\n\n    uint256 internal constant BDV_PRECISION = 1e6;\n    uint256 internal constant GP_PRECISION = 1e18;\n\n    // max and min are the ranges that the beanToMaxLpGpPerBdvRatioScaled can output.\n    uint256 internal constant MAX_BEAN_MAX_LP_GP_PER_BDV_RATIO = 100e18;\n    uint256 internal constant MIN_BEAN_MAX_LP_GP_PER_BDV_RATIO = 50e18;\n    uint256 internal constant BEAN_MAX_LP_GP_RATIO_RANGE =\n        MAX_BEAN_MAX_LP_GP_PER_BDV_RATIO - MIN_BEAN_MAX_LP_GP_PER_BDV_RATIO;\n\n    // the maximum value of beanToMaxLpGpPerBdvRatio.\n    uint256 internal constant ONE_HUNDRED_PERCENT = 100e18;\n\n    // 24 * 30 * 6\n    uint256 internal constant TARGET_SEASONS_TO_CATCHUP = 4320;\n    uint256 internal constant STALK_BDV_PRECISION = 1e4;\n\n    /**\n     * @notice Emitted when the AverageGrownStalkPerBdvPerSeason Updates.\n     */\n    event UpdateStalkPerBdvPerSeason(uint256 newStalkPerBdvPerSeason);\n\n    struct LpGaugePointData {\n        address lpToken;\n        uint256 gpPerBdv;\n    }\n    /**\n     * @notice Emitted when the gaugePoints for an LP silo token changes.\n     * @param season The current Season\n     * @param token The LP silo token whose gaugePoints was updated.\n     * @param gaugePoints The new gaugePoints for the LP silo token.\n     */\n    event GaugePointChange(uint256 indexed season, address indexed token, uint256 gaugePoints);\n\n    /**\n     * @notice Updates the seed gauge system.\n     * @dev updates the GaugePoints for LP assets (if applicable)\n     * and the distribution of grown Stalk to silo assets.\n     *\n     * If any of the LP price oracle failed, \n     * then the gauge system should be skipped, as a valid \n     * usd liquidity value cannot be computed.\n     */\n    function stepGauge() external {\n        (\n            uint256 maxLpGpPerBdv,\n            LpGaugePointData[] memory lpGpData,\n            uint256 totalGaugePoints,\n            uint256 totalLpBdv\n        ) = updateGaugePoints();\n        if (totalLpBdv == type(uint256).max) return;\n        updateGrownStalkEarnedPerSeason(maxLpGpPerBdv, lpGpData, totalGaugePoints, totalLpBdv);\n    }\n\n    /**\n     * @notice evaluate the gauge points of each LP asset.\n     * @dev `totalLpBdv` is returned as type(uint256).max when an Oracle failure occurs.\n     */\n    function updateGaugePoints()\n        internal\n        returns (\n            uint256 maxLpGpPerBdv,\n            LpGaugePointData[] memory lpGpData,\n            uint256 totalGaugePoints,\n            uint256 totalLpBdv\n        )\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        address[] memory whitelistedLpTokens = LibWhitelistedTokens.getWhitelistedLpTokens();\n        lpGpData = new LpGaugePointData[](whitelistedLpTokens.length);\n\n        // if there is only one pool, there is no need to update the gauge points.\n        if (whitelistedLpTokens.length == 1) {\n            // Assumes that only Wells use USD price oracles.\n            if (LibWell.isWell(whitelistedLpTokens[0]) && s.usdTokenPrice[whitelistedLpTokens[0]] == 0) {\n                return (maxLpGpPerBdv, lpGpData, totalGaugePoints, type(uint256).max);\n            }\n            uint256 gaugePoints = s.ss[whitelistedLpTokens[0]].gaugePoints;\n            lpGpData[0].gpPerBdv = gaugePoints.mul(BDV_PRECISION).div(\n                s.siloBalances[whitelistedLpTokens[0]].depositedBdv\n            );\n            return (\n                lpGpData[0].gpPerBdv,\n                lpGpData,\n                gaugePoints,\n                s.siloBalances[whitelistedLpTokens[0]].depositedBdv\n            );\n        }\n\n        // summate total deposited BDV across all whitelisted LP tokens.\n        for (uint256 i; i < whitelistedLpTokens.length; ++i) {\n            // Assumes that only Wells use USD price oracles.\n            if (LibWell.isWell(whitelistedLpTokens[i]) && s.usdTokenPrice[whitelistedLpTokens[i]] == 0) {\n                return (maxLpGpPerBdv, lpGpData, totalGaugePoints, type(uint256).max);\n            }\n            totalLpBdv = totalLpBdv.add(s.siloBalances[whitelistedLpTokens[i]].depositedBdv);\n        }\n\n        // if nothing has been deposited, skip gauge point update.\n        if (totalLpBdv == 0) return (maxLpGpPerBdv, lpGpData, totalGaugePoints, totalLpBdv);\n\n        // calculate and update the gauge points for each LP.\n        for (uint256 i; i < whitelistedLpTokens.length; ++i) {\n            Storage.SiloSettings storage ss = s.ss[whitelistedLpTokens[i]];\n\n            uint256 depositedBdv = s.siloBalances[whitelistedLpTokens[i]].depositedBdv;\n\n            // 1e6 = 1%\n            uint256 percentDepositedBdv = depositedBdv.mul(100e6).div(totalLpBdv);\n\n            // gets the gauge points of token from GaugePointFacet.\n            uint256 newGaugePoints = calcGaugePoints(\n                ss.gpSelector,\n                ss.gaugePoints,\n                ss.optimalPercentDepositedBdv,\n                percentDepositedBdv\n            );\n\n            // increment totalGaugePoints and calculate the gaugePoints per BDV:\n            totalGaugePoints = totalGaugePoints.add(newGaugePoints);\n            LpGaugePointData memory _lpGpData;\n            _lpGpData.lpToken = whitelistedLpTokens[i];\n\n            // gauge points has 18 decimal precision (GP_PRECISION = 1%)\n            // deposited BDV has 6 decimal precision (1e6 = 1 unit of BDV)\n            uint256 gpPerBdv = newGaugePoints.mul(BDV_PRECISION).div(depositedBdv);\n\n            // gpPerBdv has 6 decimal precision.\n            if (gpPerBdv > maxLpGpPerBdv) maxLpGpPerBdv = gpPerBdv;\n            _lpGpData.gpPerBdv = gpPerBdv;\n            lpGpData[i] = _lpGpData;\n\n            ss.gaugePoints = newGaugePoints.toUint128();\n            emit GaugePointChange(s.season.current, whitelistedLpTokens[i], ss.gaugePoints);\n        }\n    }\n\n    /**\n     * @notice calculates the new gauge points for the given token.\n     * @dev function calls the selector of the token's gauge point function.\n     * See {GaugePointFacet.defaultGaugePointFunction()}\n     */\n    function calcGaugePoints(\n        bytes4 gpSelector,\n        uint256 gaugePoints,\n        uint256 optimalPercentDepositedBdv,\n        uint256 percentDepositedBdv\n    ) internal view returns (uint256 newGaugePoints) {\n        bytes memory callData = abi.encodeWithSelector(\n            gpSelector,\n            gaugePoints,\n            optimalPercentDepositedBdv,\n            percentDepositedBdv\n        );\n        (bool success, bytes memory data) = address(this).staticcall(callData);\n        if (!success) {\n            if (data.length == 0) revert();\n            assembly {\n                revert(add(32, data), mload(data))\n            }\n        }\n        assembly {\n            newGaugePoints := mload(add(data, add(0x20, 0)))\n        }\n    }\n\n    /**\n     * @notice Updates the average grown stalk per BDV per Season for whitelisted Beanstalk assets.\n     * @dev Called at the end of each Season.\n     */\n    function updateGrownStalkEarnedPerSeason(\n        uint256 maxLpGpPerBdv,\n        LpGaugePointData[] memory lpGpData,\n        uint256 totalGaugePoints,\n        uint256 totalLpBdv\n    ) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 beanDepositedBdv = s.siloBalances[C.BEAN].depositedBdv;\n        uint256 totalBdv = totalLpBdv.add(beanDepositedBdv);\n\n        // if nothing has been deposited, skip grown stalk update.\n        if (totalBdv == 0) return;\n\n        // calculate the ratio between the bean and the max LP gauge points per BDV.\n        // 6 decimal precision\n        uint256 beanToMaxLpGpPerBdvRatio = getBeanToMaxLpGpPerBdvRatioScaled(\n            s.seedGauge.beanToMaxLpGpPerBdvRatio\n        );\n        // get the GaugePoints and GPperBDV for bean\n        // beanGpPerBdv has 6 decimal precision, beanToMaxLpGpPerBdvRatio has 18.\n        uint256 beanGpPerBdv = maxLpGpPerBdv.mul(beanToMaxLpGpPerBdvRatio).div(100e18);\n\n        totalGaugePoints = totalGaugePoints.add(\n            beanGpPerBdv.mul(beanDepositedBdv).div(BDV_PRECISION)\n        );\n\n        // check if one week elapsed since the last seedGauge update.\n        // if so, update the average grown stalk per BDV per Season.\n        // safemath not needed\n        if (s.season.current - s.seedGauge.lastSeedGaugeUpdate >= 168) {\n            updateStalkPerBdvPerSeason();\n        }\n        // calculate grown stalk issued this season and GrownStalk Per GaugePoint.\n        uint256 newGrownStalk = uint256(s.seedGauge.averageGrownStalkPerBdvPerSeason)\n            .mul(totalBdv)\n            .div(BDV_PRECISION);\n\n        // gauge points has 18 decimal precision.\n        uint256 newGrownStalkPerGp = newGrownStalk.mul(GP_PRECISION).div(totalGaugePoints);\n\n        // update stalkPerBdvPerSeason for bean.\n        issueGrownStalkPerBdv(C.BEAN, newGrownStalkPerGp, beanGpPerBdv);\n\n        // update stalkPerBdvPerSeason for LP\n        // if there is only one pool, then no need to read gauge points.\n        if (lpGpData.length == 1) {\n            issueGrownStalkPerBdv(lpGpData[0].lpToken, newGrownStalkPerGp, lpGpData[0].gpPerBdv);\n        } else {\n            for (uint256 i; i < lpGpData.length; i++) {\n                issueGrownStalkPerBdv(\n                    lpGpData[i].lpToken,\n                    newGrownStalkPerGp,\n                    lpGpData[i].gpPerBdv\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice issues the grown stalk per BDV for the given token.\n     * @param token the token to issue the grown stalk for.\n     * @param grownStalkPerGp the number of GrownStalk Per Gauge Point.\n     * @param gpPerBdv the amount of GaugePoints per BDV the token has.\n     */\n    function issueGrownStalkPerBdv(\n        address token,\n        uint256 grownStalkPerGp,\n        uint256 gpPerBdv\n    ) internal {\n        LibWhitelist.updateStalkPerBdvPerSeasonForToken(\n            token,\n            grownStalkPerGp.mul(gpPerBdv).div(GP_PRECISION).toUint32()\n        );\n    }\n\n    /**\n     * @notice updates the updateStalkPerBdvPerSeason in the seed gauge.\n     * @dev anyone can call this function to update. Currently, the function\n     * updates the targetGrownStalkPerBdvPerSeason such that it will take 6 months\n     * for the average new depositer to catch up to the average grown stalk per BDV.\n     *\n     * The expectation is that actors will call this function on their own as it benefits them.\n     * Newer depositers will call it if the value increases to catch up to the average faster,\n     * Older depositers will call it if the value decreases to slow down their rate of dilution.\n     */\n    function updateStalkPerBdvPerSeason() public {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        // will overflow if the average grown stalk per BDV exceeds 1.4e36,\n        // which is highly improbable assuming consistent new deposits.\n        // thus, safeCast was determined is to be unnecessary.\n        s.seedGauge.averageGrownStalkPerBdvPerSeason = uint128(\n            getAverageGrownStalkPerBdv().mul(BDV_PRECISION).div(TARGET_SEASONS_TO_CATCHUP)\n        );\n        s.seedGauge.lastSeedGaugeUpdate = s.season.current;\n        emit UpdateStalkPerBdvPerSeason(s.seedGauge.averageGrownStalkPerBdvPerSeason);\n    }\n\n    /**\n     * @notice returns the total BDV in beanstalk.\n     * @dev the total BDV may differ from the instaneous BDV,\n     * as BDV is asyncronous.\n     */\n    function getTotalBdv() internal view returns (uint256 totalBdv) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        address[] memory whitelistedSiloTokens = LibWhitelistedTokens.getWhitelistedTokens();\n        for (uint256 i; i < whitelistedSiloTokens.length; ++i) {\n            totalBdv = totalBdv.add(s.siloBalances[whitelistedSiloTokens[i]].depositedBdv);\n        }\n    }\n\n    /**\n     * @notice returns the average grown stalk per BDV .\n     */\n    function getAverageGrownStalkPerBdv() internal view returns (uint256) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 totalBdv = getTotalBdv();\n        if (totalBdv == 0) return 0;\n        return s.s.stalk.div(totalBdv).sub(STALK_BDV_PRECISION);\n    }\n\n    /**\n     * @notice returns the ratio between the bean and\n     * the max LP gauge points per BDV.\n     * @dev s.seedGauge.beanToMaxLpGpPerBdvRatio is a number between 0 and 100e18,\n     * where f(100e18) = MIN_BEAN_MAX_LPGP_RATIO and f(0) = MAX_BEAN_MAX_LPGP_RATIO.\n     */\n    function getBeanToMaxLpGpPerBdvRatioScaled(\n        uint256 beanToMaxLpGpPerBdvRatio\n    ) internal pure returns (uint256) {\n        return\n            beanToMaxLpGpPerBdvRatio.mul(BEAN_MAX_LP_GP_RATIO_RANGE).div(ONE_HUNDRED_PERCENT).add(\n                MIN_BEAN_MAX_LP_GP_PER_BDV_RATIO\n            );\n    }\n}"
    },
    {
      "filename": "protocol/contracts/libraries/LibGauge.sol",
      "content": "/*\n SPDX-License-Identifier: MIT\n*/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {LibAppStorage, AppStorage, Storage} from \"./LibAppStorage.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport {LibWhitelistedTokens} from \"contracts/libraries/Silo/LibWhitelistedTokens.sol\";\nimport {LibWhitelist} from \"contracts/libraries/Silo/LibWhitelist.sol\";\nimport {LibSafeMath32} from \"contracts/libraries/LibSafeMath32.sol\";\nimport {C} from \"../C.sol\";\nimport {LibWell} from \"contracts/libraries/Well/LibWell.sol\";\n\n/**\n * @title LibGauge\n * @author Brean, Brendan\n * @notice LibGauge handles functionality related to the seed gauge system.\n */\nlibrary LibGauge {\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n    using LibSafeMath32 for uint32;\n\n    uint256 internal constant BDV_PRECISION = 1e6;\n    uint256 internal constant GP_PRECISION = 1e18;\n\n    // max and min are the ranges that the beanToMaxLpGpPerBdvRatioScaled can output.\n    uint256 internal constant MAX_BEAN_MAX_LP_GP_PER_BDV_RATIO = 100e18;\n    uint256 internal constant MIN_BEAN_MAX_LP_GP_PER_BDV_RATIO = 50e18;\n    uint256 internal constant BEAN_MAX_LP_GP_RATIO_RANGE =\n        MAX_BEAN_MAX_LP_GP_PER_BDV_RATIO - MIN_BEAN_MAX_LP_GP_PER_BDV_RATIO;\n\n    // the maximum value of beanToMaxLpGpPerBdvRatio.\n    uint256 internal constant ONE_HUNDRED_PERCENT = 100e18;\n\n    // 24 * 30 * 6\n    uint256 internal constant TARGET_SEASONS_TO_CATCHUP = 4320;\n    uint256 internal constant STALK_BDV_PRECISION = 1e4;\n\n    /**\n     * @notice Emitted when the AverageGrownStalkPerBdvPerSeason Updates.\n     */\n    event UpdateStalkPerBdvPerSeason(uint256 newStalkPerBdvPerSeason);\n\n    struct LpGaugePointData {\n        address lpToken;\n        uint256 gpPerBdv;\n    }\n    /**\n     * @notice Emitted when the gaugePoints for an LP silo token changes.\n     * @param season The current Season\n     * @param token The LP silo token whose gaugePoints was updated.\n     * @param gaugePoints The new gaugePoints for the LP silo token.\n     */\n    event GaugePointChange(uint256 indexed season, address indexed token, uint256 gaugePoints);\n\n    /**\n     * @notice Updates the seed gauge system.\n     * @dev updates the GaugePoints for LP assets (if applicable)\n     * and the distribution of grown Stalk to silo assets.\n     *\n     * If any of the LP price oracle failed, \n     * then the gauge system should be skipped, as a valid \n     * usd liquidity value cannot be computed.\n     */\n    function stepGauge() external {\n        (\n            uint256 maxLpGpPerBdv,\n            LpGaugePointData[] memory lpGpData,\n            uint256 totalGaugePoints,\n            uint256 totalLpBdv\n        ) = updateGaugePoints();\n        if (totalLpBdv == type(uint256).max) return;\n        updateGrownStalkEarnedPerSeason(maxLpGpPerBdv, lpGpData, totalGaugePoints, totalLpBdv);\n    }\n\n    /**\n     * @notice evaluate the gauge points of each LP asset.\n     * @dev `totalLpBdv` is returned as type(uint256).max when an Oracle failure occurs.\n     */\n    function updateGaugePoints()\n        internal\n        returns (\n            uint256 maxLpGpPerBdv,\n            LpGaugePointData[] memory lpGpData,\n            uint256 totalGaugePoints,\n            uint256 totalLpBdv\n        )\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        address[] memory whitelistedLpTokens = LibWhitelistedTokens.getWhitelistedLpTokens();\n        lpGpData = new LpGaugePointData[](whitelistedLpTokens.length);\n\n        // if there is only one pool, there is no need to update the gauge points.\n        if (whitelistedLpTokens.length == 1) {\n            // Assumes that only Wells use USD price oracles.\n            if (LibWell.isWell(whitelistedLpTokens[0]) && s.usdTokenPrice[whitelistedLpTokens[0]] == 0) {\n                return (maxLpGpPerBdv, lpGpData, totalGaugePoints, type(uint256).max);\n            }\n            uint256 gaugePoints = s.ss[whitelistedLpTokens[0]].gaugePoints;\n            lpGpData[0].gpPerBdv = gaugePoints.mul(BDV_PRECISION).div(\n                s.siloBalances[whitelistedLpTokens[0]].depositedBdv\n            );\n            return (\n                lpGpData[0].gpPerBdv,\n                lpGpData,\n                gaugePoints,\n                s.siloBalances[whitelistedLpTokens[0]].depositedBdv\n            );\n        }\n\n        // summate total deposited BDV across all whitelisted LP tokens.\n        for (uint256 i; i < whitelistedLpTokens.length; ++i) {\n            // Assumes that only Wells use USD price oracles.\n            if (LibWell.isWell(whitelistedLpTokens[i]) && s.usdTokenPrice[whitelistedLpTokens[i]] == 0) {\n                return (maxLpGpPerBdv, lpGpData, totalGaugePoints, type(uint256).max);\n            }\n            totalLpBdv = totalLpBdv.add(s.siloBalances[whitelistedLpTokens[i]].depositedBdv);\n        }\n\n        // if nothing has been deposited, skip gauge point update.\n        if (totalLpBdv == 0) return (maxLpGpPerBdv, lpGpData, totalGaugePoints, totalLpBdv);\n\n        // calculate and update the gauge points for each LP.\n        for (uint256 i; i < whitelistedLpTokens.length; ++i) {\n            Storage.SiloSettings storage ss = s.ss[whitelistedLpTokens[i]];\n\n            uint256 depositedBdv = s.siloBalances[whitelistedLpTokens[i]].depositedBdv;\n\n            // 1e6 = 1%\n            uint256 percentDepositedBdv = depositedBdv.mul(100e6).div(totalLpBdv);\n\n            // gets the gauge points of token from GaugePointFacet.\n            uint256 newGaugePoints = calcGaugePoints(\n                ss.gpSelector,\n                ss.gaugePoints,\n                ss.optimalPercentDepositedBdv,\n                percentDepositedBdv\n            );\n\n            // increment totalGaugePoints and calculate the gaugePoints per BDV:\n            totalGaugePoints = totalGaugePoints.add(newGaugePoints);\n            LpGaugePointData memory _lpGpData;\n            _lpGpData.lpToken = whitelistedLpTokens[i];\n\n            // gauge points has 18 decimal precision (GP_PRECISION = 1%)\n            // deposited BDV has 6 decimal precision (1e6 = 1 unit of BDV)\n            uint256 gpPerBdv = newGaugePoints.mul(BDV_PRECISION).div(depositedBdv);\n\n            // gpPerBdv has 6 decimal precision.\n            if (gpPerBdv > maxLpGpPerBdv) maxLpGpPerBdv = gpPerBdv;\n            _lpGpData.gpPerBdv = gpPerBdv;\n            lpGpData[i] = _lpGpData;\n\n            ss.gaugePoints = newGaugePoints.toUint128();\n            emit GaugePointChange(s.season.current, whitelistedLpTokens[i], ss.gaugePoints);\n        }\n    }\n\n    /**\n     * @notice calculates the new gauge points for the given token.\n     * @dev function calls the selector of the token's gauge point function.\n     * See {GaugePointFacet.defaultGaugePointFunction()}\n     */\n    function calcGaugePoints(\n        bytes4 gpSelector,\n        uint256 gaugePoints,\n        uint256 optimalPercentDepositedBdv,\n        uint256 percentDepositedBdv\n    ) internal view returns (uint256 newGaugePoints) {\n        bytes memory callData = abi.encodeWithSelector(\n            gpSelector,\n            gaugePoints,\n            optimalPercentDepositedBdv,\n            percentDepositedBdv\n        );\n        (bool success, bytes memory data) = address(this).staticcall(callData);\n        if (!success) {\n            if (data.length == 0) revert();\n            assembly {\n                revert(add(32, data), mload(data))\n            }\n        }\n        assembly {\n            newGaugePoints := mload(add(data, add(0x20, 0)))\n        }\n    }\n\n    /**\n     * @notice Updates the average grown stalk per BDV per Season for whitelisted Beanstalk assets.\n     * @dev Called at the end of each Season.\n     */\n    function updateGrownStalkEarnedPerSeason(\n        uint256 maxLpGpPerBdv,\n        LpGaugePointData[] memory lpGpData,\n        uint256 totalGaugePoints,\n        uint256 totalLpBdv\n    ) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 beanDepositedBdv = s.siloBalances[C.BEAN].depositedBdv;\n        uint256 totalBdv = totalLpBdv.add(beanDepositedBdv);\n\n        // if nothing has been deposited, skip grown stalk update.\n        if (totalBdv == 0) return;\n\n        // calculate the ratio between the bean and the max LP gauge points per BDV.\n        // 6 decimal precision\n        uint256 beanToMaxLpGpPerBdvRatio = getBeanToMaxLpGpPerBdvRatioScaled(\n            s.seedGauge.beanToMaxLpGpPerBdvRatio\n        );\n        // get the GaugePoints and GPperBDV for bean\n        // beanGpPerBdv has 6 decimal precision, beanToMaxLpGpPerBdvRatio has 18.\n        uint256 beanGpPerBdv = maxLpGpPerBdv.mul(beanToMaxLpGpPerBdvRatio).div(100e18);\n\n        totalGaugePoints = totalGaugePoints.add(\n            beanGpPerBdv.mul(beanDepositedBdv).div(BDV_PRECISION)\n        );\n\n        // check if one week elapsed since the last seedGauge update.\n        // if so, update the average grown stalk per BDV per Season.\n        // safemath not needed\n        if (s.season.current - s.seedGauge.lastSeedGaugeUpdate >= 168) {\n            updateStalkPerBdvPerSeason();\n        }\n        // calculate grown stalk issued this season and GrownStalk Per GaugePoint.\n        uint256 newGrownStalk = uint256(s.seedGauge.averageGrownStalkPerBdvPerSeason)\n            .mul(totalBdv)\n            .div(BDV_PRECISION);\n\n        // gauge points has 18 decimal precision.\n        uint256 newGrownStalkPerGp = newGrownStalk.mul(GP_PRECISION).div(totalGaugePoints);\n\n        // update stalkPerBdvPerSeason for bean.\n        issueGrownStalkPerBdv(C.BEAN, newGrownStalkPerGp, beanGpPerBdv);\n\n        // update stalkPerBdvPerSeason for LP\n        // if there is only one pool, then no need to read gauge points.\n        if (lpGpData.length == 1) {\n            issueGrownStalkPerBdv(lpGpData[0].lpToken, newGrownStalkPerGp, lpGpData[0].gpPerBdv);\n        } else {\n            for (uint256 i; i < lpGpData.length; i++) {\n                issueGrownStalkPerBdv(\n                    lpGpData[i].lpToken,\n                    newGrownStalkPerGp,\n                    lpGpData[i].gpPerBdv\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice issues the grown stalk per BDV for the given token.\n     * @param token the token to issue the grown stalk for.\n     * @param grownStalkPerGp the number of GrownStalk Per Gauge Point.\n     * @param gpPerBdv the amount of GaugePoints per BDV the token has.\n     */\n    function issueGrownStalkPerBdv(\n        address token,\n        uint256 grownStalkPerGp,\n        uint256 gpPerBdv\n    ) internal {\n        LibWhitelist.updateStalkPerBdvPerSeasonForToken(\n            token,\n            grownStalkPerGp.mul(gpPerBdv).div(GP_PRECISION).toUint32()\n        );\n    }\n\n    /**\n     * @notice updates the updateStalkPerBdvPerSeason in the seed gauge.\n     * @dev anyone can call this function to update. Currently, the function\n     * updates the targetGrownStalkPerBdvPerSeason such that it will take 6 months\n     * for the average new depositer to catch up to the average grown stalk per BDV.\n     *\n     * The expectation is that actors will call this function on their own as it benefits them.\n     * Newer depositers will call it if the value increases to catch up to the average faster,\n     * Older depositers will call it if the value decreases to slow down their rate of dilution.\n     */\n    function updateStalkPerBdvPerSeason() public {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        // will overflow if the average grown stalk per BDV exceeds 1.4e36,\n        // which is highly improbable assuming consistent new deposits.\n        // thus, safeCast was determined is to be unnecessary.\n        s.seedGauge.averageGrownStalkPerBdvPerSeason = uint128(\n            getAverageGrownStalkPerBdv().mul(BDV_PRECISION).div(TARGET_SEASONS_TO_CATCHUP)\n        );\n        s.seedGauge.lastSeedGaugeUpdate = s.season.current;\n        emit UpdateStalkPerBdvPerSeason(s.seedGauge.averageGrownStalkPerBdvPerSeason);\n    }\n\n    /**\n     * @notice returns the total BDV in beanstalk.\n     * @dev the"
    }
  ]
}