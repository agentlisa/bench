{
  "Title": "Ether stuck in the `FeeDistributor`",
  "Content": "##### Description\nIf one of the fee receivers can't accept ether (i.e the transaction will revert or consume too much gas), no ether can be [withdrawn](https://github.com/p2p-org/eth-staking-fee-distributor-contracts/blob/4bac8f636d7ba14244612bcfb9e85f338feba6e3/contracts/feeDistributor/FeeDistributor.sol#L231).\nAlthough a new instance can be redeployed, some ether may stuck in the recent instance.\n##### Recommendation\nWe recommend implementing the functionality to migrate from a stuck `FeeDistributor` instance to a new one.",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/feeDistributor/FeeDistributor.sol",
      "content": "// SPDX-FileCopyrightText: 2022 P2P Validator <info@p2p.org>\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport \"../@openzeppelin/contracts/utils/Address.sol\";\nimport \"../@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"../@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"../@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport \"../feeDistributorFactory/IFeeDistributorFactory.sol\";\nimport \"../assetRecovering/OwnableTokenRecoverer.sol\";\nimport \"./IFeeDistributor.sol\";\n\n/**\n* @notice Should be a FeeDistributorFactory contract\n* @param _passedAddress passed address that does not support IFeeDistributorFactory interface\n*/\nerror FeeDistributor__NotFactory(address _passedAddress);\n\n/**\n* @notice Service address should be a secure P2P address, not zero.\n*/\nerror FeeDistributor__ZeroAddressService();\n\n/**\n* @notice Client address should be different from service address.\n* @param _passedAddress passed client address that equals to the service address\n*/\nerror FeeDistributor__ClientAddressEqualsService(address _passedAddress);\n\n/**\n* @notice Client address should be an actual client address, not zero.\n*/\nerror FeeDistributor__ZeroAddressClient();\n\n/**\n* @notice Client basis points should be >= 0 and <= 10000\n* @param _clientBasisPoints passed incorrect client basis points\n*/\nerror FeeDistributor__InvalidClientBasisPoints(uint96 _clientBasisPoints);\n\n/**\n* @notice The sum of (Client basis points + Referral basis points) should be >= 0 and <= 10000\n* @param _clientBasisPoints passed client basis points\n* @param _referralBasisPoints passed referral basis points\n*/\nerror FeeDistributor__ClientPlusReferralBasisPointsExceed10000(uint96 _clientBasisPoints, uint96 _referralBasisPoints);\n\n/**\n* @notice Referrer address should be different from service address.\n* @param _passedAddress passed referrer address that equals to the service address\n*/\nerror FeeDistributor__ReferrerAddressEqualsService(address _passedAddress);\n\n/**\n* @notice Referrer address should be different from client address.\n* @param _passedAddress passed referrer address that equals to the client address\n*/\nerror FeeDistributor__ReferrerAddressEqualsClient(address _passedAddress);\n\n/**\n* @notice Only factory can call `initialize`.\n* @param _msgSender sender address.\n* @param _actualFactory the actual factory address that can call `initialize`.\n*/\nerror FeeDistributor__NotFactoryCalled(address _msgSender, IFeeDistributorFactory _actualFactory);\n\n/**\n* @notice `initialize` should only be called once.\n* @param _existingClient address of the client with which the contact has already been initialized.\n*/\nerror FeeDistributor__ClientAlreadySet(address _existingClient);\n\n/**\n* @notice Cannot call `withdraw` if the client address is not set yet.\n* @dev The client address is supposed to be set by the factory.\n*/\nerror FeeDistributor__ClientNotSet();\n\n/**\n* @notice basisPoints of the referrer must be zero if referrer address is empty.\n* @param _referrerBasisPoints basisPoints of the referrer.\n*/\nerror FeeDistributor__ReferrerBasisPointsMustBeZeroIfAddressIsZero(uint96 _referrerBasisPoints);\n\n/**\n* @notice service should be able to receive ether.\n* @param _service address of the service.\n*/\nerror FeeDistributor__ServiceCannotReceiveEther(address _service);\n\n/**\n* @notice client should be able to receive ether.\n* @param _client address of the client.\n*/\nerror FeeDistributor__ClientCannotReceiveEther(address _client);\n\n/**\n* @notice referrer should be able to receive ether.\n* @param _referrer address of the referrer.\n*/\nerror FeeDistributor__ReferrerCannotReceiveEther(address _referrer);\n\n/**\n* @title Contract receiving MEV and priority fees\n* and distributing them to the service and the client.\n*/\ncontract FeeDistributor is OwnableTokenRecoverer, ReentrancyGuard, ERC165, IFeeDistributor {\n    // Type Declarations\n\n    using Address for address payable;\n\n    // State variables\n\n    /**\n    * @notice address of FeeDistributorFactory\n    */\n    IFeeDistributorFactory private immutable i_factory;\n\n    /**\n    * @notice address of the service (P2P) fee recipient\n    */\n    address payable private immutable i_service;\n\n    /**\n    * @notice client config (address of the client, client basis points)\n    */\n    FeeRecipient private s_clientConfig;\n\n    /**\n    * @notice referrer config (address of the referrer, referrer basis points)\n    */\n    FeeRecipient private s_referrerConfig;\n\n    /**\n    * @dev Set values that are constant, common for all the clients, known at the initial deploy time.\n    * @param _factory address of FeeDistributorFactory\n    * @param _service address of the service (P2P) fee recipient\n    */\n    constructor(\n        address _factory,\n        address _service\n    ) {\n        if (!ERC165Checker.supportsInterface(_factory, type(IFeeDistributorFactory).interfaceId)) {\n            revert FeeDistributor__NotFactory(_factory);\n        }\n        if (_service == address(0)) {\n            revert FeeDistributor__ZeroAddressService();\n        }\n\n        i_factory = IFeeDistributorFactory(_factory);\n        i_service = payable(_service);\n\n        (bool serviceCanReceiveEther,) = payable(_service).call{value : 0}(\"\");\n        if (!serviceCanReceiveEther) {\n            revert FeeDistributor__ServiceCannotReceiveEther(_service);\n        }\n    }\n\n    // Functions\n\n    /**\n    * @notice Set client address.\n    * @dev Could not be in the constructor since it is different for different clients.\n    * @dev _referrerConfig can be zero if there is no referrer.\n    * @param _clientConfig address and basis points (percent * 100) of the client\n    * @param _referrerConfig address and basis points (percent * 100) of the referrer.\n    */\n    function initialize(FeeRecipient calldata _clientConfig, FeeRecipient calldata _referrerConfig) external {\n        if (msg.sender != address(i_factory)) {\n            revert FeeDistributor__NotFactoryCalled(msg.sender, i_factory);\n        }\n        if (_clientConfig.recipient == address(0)) {\n            revert FeeDistributor__ZeroAddressClient();\n        }\n        if (_clientConfig.recipient == i_service) {\n            revert FeeDistributor__ClientAddressEqualsService(_clientConfig.recipient);\n        }\n        if (s_clientConfig.recipient != address(0)) {\n            revert FeeDistributor__ClientAlreadySet(s_clientConfig.recipient);\n        }\n        if (_clientConfig.basisPoints > 10000) {\n            revert FeeDistributor__InvalidClientBasisPoints(_clientConfig.basisPoints);\n        }\n\n        if (_referrerConfig.recipient != address(0)) {// if there is a referrer\n            if (_referrerConfig.recipient == i_service) {\n                revert FeeDistributor__ReferrerAddressEqualsService(_referrerConfig.recipient);\n            }\n            if (_referrerConfig.recipient == _clientConfig.recipient) {\n                revert FeeDistributor__ReferrerAddressEqualsClient(_referrerConfig.recipient);\n            }\n            if (_clientConfig.basisPoints + _referrerConfig.basisPoints > 10000) {\n                revert FeeDistributor__ClientPlusReferralBasisPointsExceed10000(_clientConfig.basisPoints, _referrerConfig.basisPoints);\n            }\n\n            // set referrer config\n            s_referrerConfig = _referrerConfig;\n\n        } else {// if there is no referrer\n            if (_referrerConfig.basisPoints != 0) {\n                revert FeeDistributor__ReferrerBasisPointsMustBeZeroIfAddressIsZero(_referrerConfig.basisPoints);\n            }\n        }\n\n        // set client config\n        s_clientConfig = _clientConfig;\n\n        emit Initialized(\n            _clientConfig.recipient,\n            _clientConfig.basisPoints,\n            _referrerConfig.recipient,\n            _referrerConfig.basisPoints\n        );\n\n        (bool clientCanReceiveEther,) = payable(_clientConfig.recipient).call{value : 0}(\"\");\n        if (!clientCanReceiveEther) {\n            revert FeeDistributor__ClientCannotReceiveEther(_clientConfig.recipient);\n        }\n        if (_referrerConfig.recipient != address(0)) {// if there is a referrer\n            (bool referrerCanReceiveEther,) = payable(_referrerConfig.recipient).call{value : 0}(\"\");\n            if (!referrerCanReceiveEther) {\n                revert FeeDistributor__ReferrerCannotReceiveEther(_referrerConfig.recipient);\n            }\n        }\n    }\n\n    /**\n    * @notice Withdraw the whole balance of the contract according to the pre-defined basis points.\n    */\n    function withdraw() external nonReentrant {\n        if (s_clientConfig.recipient == address(0)) {\n            revert FeeDistributor__ClientNotSet();\n        }\n\n        // get the contract's balance\n        uint256 balance = address(this).balance;\n\n        // how much should client get\n        uint256 clientAmount = (balance * s_clientConfig.basisPoints) / 10000;\n\n        // how much should referrer get\n        // if s_referrerConfig is not set, s_referrerConfig.basisPoints and referrerAmount will be 0\n        uint256 referrerAmount = (balance * s_referrerConfig.basisPoints) / 10000;\n\n        // how much should service get\n        uint256 serviceAmount = balance - clientAmount - referrerAmount;\n\n        // send ETH to service\n        i_service.sendValue(serviceAmount);\n\n        // send ETH to client\n        s_clientConfig.recipient.sendValue(clientAmount);\n\n        // send ETH to referrer\n        s_referrerConfig.recipient.sendValue(referrerAmount);\n\n        emit Withdrawn(serviceAmount, clientAmount, referrerAmount);\n    }\n\n    /**\n     * @dev Returns the factory address\n     */\n    function getFactory() external view returns (address) {\n        return address(i_factory);\n    }\n\n    /**\n     * @dev Returns the service address\n     */\n    function getService() external view returns (address) {\n        return i_service;\n    }\n\n    /**\n     * @dev Returns the client address\n     */\n    function getClient() external view returns (address) {\n        return s_clientConfig.recipient;\n    }\n\n    /**\n     * @dev Returns the service basis points\n     */\n    function getServiceBasisPoints() external view returns (uint256) {\n        return s_clientConfig.basisPoints;\n    }\n\n    /**\n    * @dev See {IERC165-supportsInterface}.\n    */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IFeeDistributor).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view override returns (address) {\n        return i_factory.owner();\n    }\n}"
    }
  ]
}