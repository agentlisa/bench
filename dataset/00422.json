{
  "Title": "M-3: Underflow Vulnerability in `Market::_allowedBorrow` Function: Oversight with Pearlmit Allowance Handling",
  "Content": "# Issue M-3: Underflow Vulnerability in `Market::_allowedBorrow` Function: Oversight with Pearlmit Allowance Handling \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/29 \n\n## Found by \nTendency\n## Summary\nThe protocol permits users to authorize spenders using the [MarketERC20::approveBorrow](https://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/Tapioca-bar/contracts/markets/MarketERC20.sol#L147-L150) function, and also includes support for allowances granted through the `Pearlmit` contract. However, an oversight in the [_allowedBorrow](https://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/Tapioca-bar/contracts/markets/Market.sol#L416-L425) function leads to an underflow issue when spenders utilize `Pearlmit` allowances, rendering them unable to execute borrowing actions despite having the necessary permission.\n\n## Vulnerability Detail\nProtocol users can approve a spender via [MarketERC20::approveBorrow](https://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/Tapioca-bar/contracts/markets/MarketERC20.sol#L147-L150) function, to perform certain actions like `borrow`, `repay` or adding of collateral on their behalf.\nWhenever the spender calls any of these functionalities, down the execution [_allowedBorrow](https://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/Tapioca-bar/contracts/markets/Market.sol#L416-L425) is invoked to check if the caller is allowed to borrow `share` from `from`, and then decrease the spender's allowance by the share amount.\n```solidity\n    function _allowedBorrow(address from, uint256 share) internal virtual override {\n        if (from != msg.sender) {\n            // TODO review risk of using this\n            (uint256 pearlmitAllowed,) = penrose.pearlmit().allowance(from, msg.sender, address(yieldBox), collateralId);\n            require(allowanceBorrow[from][msg.sender] >= share || pearlmitAllowed >= share, \"Market: not approved\");\n            if (allowanceBorrow[from][msg.sender] != type(uint256).max) {\n                allowanceBorrow[from][msg.sender] -= share;\n            }\n        }\n    }\n```\nThe problem here is, [_allowedBorrow](https://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/Tapioca-bar/contracts/markets/Market.sol#L416-L425) will always revert due to an underflow whenever the spender is given an allowance in the `Pearlmit` contract.\n\n+ To Illustrate\n\nAssuming we have two users, Bob and Alice, since `Pearlmit` allowance is also accepted, Alice grants Bob a borrowing allowance of `100` tokens for the collateral id using `Pearlmit`.\nNote that Bob's allowance in the Market contract for Alice will be `zero(0)` and `100` in `Pearlmit`.\n\nWhen Bob tries to borrow an amount equal to his `Pearlmit` allowance, down the borrow logic `_allowedBorrow` is called, in [_allowedBorrow](https://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/Tapioca-bar/contracts/markets/Market.sol#L416-L425) function, the below requirement passes, since the returned `pearlmitAllowed` for Bob will equal `100` shares\n```solidity\n require(allowanceBorrow[from][msg.sender] >= share || pearlmitAllowed >= share, \"Market: not approved\");\n```\nRemember Bob's allowance in the Market contract for Alice is `0`, but `100` in `Pearlmit`, but [_allowedBorrow](https://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/Tapioca-bar/contracts/markets/Market.sol#L416-L425) function erroneously attempts to deduct the share from Bob's Market allowance, which will thus result in an underflow revert(0 - 100).\n```solidity\n            if (allowanceBorrow[from][msg.sender] != type(uint256).max) {\n                allowanceBorrow[from][msg.sender] -= share;\n            }\n```\n\n## Impact\nAlthough giving a spender allowance via `Pearlmit` will appear to be supported, the spender cannot carry out any borrowing action in the Market.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/Tapioca-bar/contracts/markets/Market.sol#L416-L425\n## Tool used\n\nManual Review\n\n## Recommendation\nAfter ensuring that the user has got the approval, return when permission from `Pearlmit` is used:\n```solidity\n    function _allowedBorrow(address from, uint256 share) internal virtual override {\n        if (from != msg.sender) {\n            // TODO review risk of using this\n            (uint256 pearlmitAllowed,) = penrose.pearlmit().allowance(from, msg.sender, address(yieldBox), collateralId);\n            require(allowanceBorrow[from][msg.sender] >= share || pearlmitAllowed >= share, \"Market: not approved\");\n+            if (pearlmitAllowed != 0) return;\n            if (allowanceBorrow[from][msg.sender] != type(uint256).max) {\n                allowanceBorrow[from][msg.sender] -= share;\n            }\n        }\n    }\n```\nOr remove support for `Pearlmit` allowance\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  this seem valid, the pearlmit allowance should be deducted instead of the market one; medium(7)\n\n\n\n**cryptotechmaker**\n\nFixed in https://github.com/Tapioca-DAO/Tapioca-bar/pull/349\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Tapioca-DAO/Tapioca-bar/pull/349.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "Tapioca-bar/contracts/markets/MarketERC20.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {IERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport {IERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport {EIP712, ECDSA} from \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\nimport {IERC20} from \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract MarketERC20 is IERC20, IERC20Permit, IERC1155Receiver, EIP712 {\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 private constant _PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    // keccak256(\"PermitBorrow(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\n    bytes32 private constant _PERMIT_TYPEHASH_BORROW =\n        0xe9685ff6d48c617fe4f692c50e602cce27cbad0290beb93cfa77eac43968d58c;\n\n    /// @notice owner > balance mapping.\n    mapping(address => uint256) public override balanceOf;\n    /// @notice owner > spender > allowance mapping.\n    mapping(address => mapping(address => uint256)) public override allowance;\n    /// @notice owner > spender > allowance mapping.\n    mapping(address => mapping(address => uint256)) public allowanceBorrow;\n    /// @notice owner > nonce mapping. Used in `permit`.\n    mapping(address => uint256) private _nonces;\n\n    // ************** //\n    // *** EVENTS *** //\n    // ************** //\n    /// @notice event emitted when borrow approval is performed\n    event ApprovalBorrow(address indexed owner, address indexed spender, uint256 indexed value);\n\n    // ***************** //\n    // *** MODIFIERS *** //\n    // ***************** //\n\n    /// Check if msg.sender has right to execute Lend operations\n    modifier allowedLend(address from, uint256 share) virtual {\n        _allowedLend(from, share);\n        _;\n    }\n    /// Check if msg.sender has right to execute borrow operations\n\n    modifier allowedBorrow(address from, uint256 share) virtual {\n        _allowedBorrow(from, share);\n        _;\n    }\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    function totalSupply() external view virtual override returns (uint256) {}\n\n    function nonces(address owner) external view returns (uint256) {\n        return _nonces[owner];\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    /// @notice Transfers `amount` tokens from `msg.sender` to `to`.\n    /// @param to The address to move the tokens.\n    /// @param amount of the tokens to move.\n    /// @return (bool) Returns True if succeeded.\n    function transfer(address to, uint256 amount) external virtual returns (bool) {\n        // If `amount` is 0, or `msg.sender` is `to` nothing happens\n        if (amount != 0 || msg.sender == to) {\n            uint256 srcBalance = balanceOf[msg.sender];\n            require(srcBalance >= amount, \"ERC20: balance too low\");\n            if (msg.sender != to) {\n                require(to != address(0), \"ERC20: no zero address\"); // Moved down so low balance calls safe some gas\n\n                balanceOf[msg.sender] = srcBalance - amount; // Underflow is checked\n                balanceOf[to] += amount;\n            }\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /// @notice Transfers `amount` tokens from `from` to `to`. Caller needs approval for `from`.\n    /// @param from Address to draw tokens from.\n    /// @param to The address to move the tokens.\n    /// @param amount The token amount to move.\n    /// @return (bool) Returns True if succeeded.\n    function transferFrom(address from, address to, uint256 amount) external virtual returns (bool) {\n        // If `amount` is 0, or `from` is `to` nothing happens\n        if (amount != 0) {\n            uint256 srcBalance = balanceOf[from];\n            require(srcBalance >= amount, \"ERC20: balance too low\");\n\n            if (from != to) {\n                uint256 spenderAllowance = allowance[from][msg.sender];\n                // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).\n                if (spenderAllowance != type(uint256).max) {\n                    require(spenderAllowance >= amount, \"ERC20: allowance too low\");\n                    allowance[from][msg.sender] = spenderAllowance - amount; // Underflow is checked\n                }\n                require(to != address(0), \"ERC20: no zero address\"); // Moved down so other failed calls safe some gas\n\n                balanceOf[from] = srcBalance - amount; // Underflow is checked\n                balanceOf[to] += amount;\n            }\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    /// @notice Approves `amount` from sender to be spend by `spender`.\n    /// @param spender Address of the party that can draw from msg.sender's account.\n    /// @param amount The maximum collective amount that `spender` can draw.\n    /// @return (bool) Returns True if approved.\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function approveBorrow(address spender, uint256 amount) external returns (bool) {\n        _approveBorrow(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        external\n        virtual\n        override(IERC20, IERC20Permit)\n    {\n        _permit(true, owner, spender, value, deadline, v, r, s);\n    }\n\n    function permitBorrow(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external virtual {\n        _permit(false, owner, spender, value, deadline, v, r, s);\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n\n    /**\n     * @notice Checks if the caller is allowed to lend `share` from `from`.\n     */\n    function _allowedLend(address from, uint256 share) internal virtual {}\n\n    /**\n     * @notice Checks if the caller is allowed to borrow `share` from `from`.\n     */\n    function _allowedBorrow(address from, uint256 share) internal virtual {}\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        current = _nonces[owner]++;\n    }\n\n    function _permit(\n        bool asset, // true = asset, false = collateral\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash;\n\n        structHash = keccak256(\n            abi.encode(\n                asset ? _PERMIT_TYPEHASH : _PERMIT_TYPEHASH_BORROW, owner, spender, value, _useNonce(owner), deadline\n            )\n        );\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        if (asset) {\n            _approve(owner, spender, value);\n        } else {\n            _approveBorrow(owner, spender, value);\n        }\n    }\n\n    function _approveBorrow(address owner, address spender, uint256 amount) internal {\n        allowanceBorrow[owner][spender] = amount;\n        emit ApprovalBorrow(owner, spender, amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal {\n        allowance[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n        return interfaceId == type(IERC20).interfaceId || interfaceId == type(IERC20Permit).interfaceId\n            || interfaceId == type(IERC1155Receiver).interfaceId;\n    }\n\n    function onERC1155Received(address operator, address from, uint256 id, uint256 value, bytes calldata data)\n        external\n        returns (bytes4)\n    {\n        // bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))\n        return 0xf23a6e61;\n    }\n\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4) {\n        return bytes4(0);\n    }\n}"
    },
    {
      "filename": "Tapioca-bar/contracts/markets/MarketERC20.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {IERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport {IERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport {EIP712, ECDSA} from \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\nimport {IERC20} from \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract MarketERC20 is IERC20, IERC20Permit, IERC1155Receiver, EIP712 {\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 private constant _PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    // keccak256(\"PermitBorrow(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\n    bytes32 private constant _PERMIT_TYPEHASH_BORROW =\n        0xe9685ff6d48c617fe4f692c50e602cce27cbad0290beb93cfa77eac43968d58c;\n\n    /// @notice owner > balance mapping.\n    mapping(address => uint256) public override balanceOf;\n    /// @notice owner > spender > allowance mapping.\n    mapping(address => mapping(address => uint256)) public override allowance;\n    /// @notice owner > spender > allowance mapping.\n    mapping(address => mapping(address => uint256)) public allowanceBorrow;\n    /// @notice owner > nonce mapping. Used in `permit`.\n    mapping(address => uint256) private _nonces;\n\n    // ************** //\n    // *** EVENTS *** //\n    // ************** //\n    /// @notice event emitted when borrow approval is performed\n    event ApprovalBorrow(address indexed owner, address indexed spender, uint256 indexed value);\n\n    // ***************** //\n    // *** MODIFIERS *** //\n    // ***************** //\n\n    /// Check if msg.sender has right to execute Lend operations\n    modifier allowedLend(address from, uint256 share) virtual {\n        _allowedLend(from, share);\n        _;\n    }\n    /// Check if msg.sender has right to execute borrow operations\n\n    modifier allowedBorrow(address from, uint256 share) virtual {\n        _allowedBorrow(from, share);\n        _;\n    }\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    function totalSupply() external view virtual override returns (uint256) {}\n\n    function nonces(address owner) external view returns (uint256) {\n        return _nonces[owner];\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    /// @notice Transfers `amount` tokens from `msg.sender` to `to`.\n    /// @param to The address to move the tokens.\n    /// @param amount of the tokens to move.\n    /// @return (bool) Returns True if succeeded.\n    function transfer(address to, uint256 amount) external virtual returns (bool) {\n        // If `amount` is 0, or `msg.sender` is `to` nothing happens\n        if (amount != 0 || msg.sender == to) {\n            uint256 srcBalance = balanceOf[msg.sender];\n            require(srcBalance >= amount, \"ERC20: balance too low\");\n            if (msg.sender != to) {\n                require(to != address(0), \"ERC20: no zero address\"); // Moved down so low balance calls safe some gas\n\n                balanceOf[msg.sender] = srcBalance - amount; // Underflow is checked\n                balanceOf[to] += amount;\n            }\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /// @notice Transfers `amount` tokens from `from` to `to`. Caller needs approval for `from`.\n    /// @param from Address to draw tokens from.\n    /// @param to The address to move the tokens.\n    /// @param amount The token amount to move.\n    /// @return (bool) Returns True if succeeded.\n    function transferFrom(address from, address to, uint256 amount) external virtual returns (bool) {\n        // If `amount` is 0, or `from` is `to` nothing happens\n        if (amount != 0) {\n            uint256 srcBalance = balanceOf[from];\n            require(srcBalance >= amount, \"ERC20: balance too low\");\n\n            if (from != to) {\n                uint256 spenderAllowance = allowance[from][msg.sender];\n                // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).\n                if (spenderAllowance != type(uint256).max) {\n                    require(spenderAllowance >= amount, \"ERC20: allowance too low\");\n                    allowance[from][msg.sender] = spenderAllowance - amount; // Underflow is checked\n                }\n                require(to != address(0), \"ERC20: no zero address\"); // Moved down so other failed calls safe some gas\n\n                balanceOf[from] = srcBalance - amount; // Underflow is checked\n                balanceOf[to] += amount;\n            }\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    /// @notice Approves `amount` from sender to be spend by `spender`.\n    /// @param spender Address of the party that can draw from msg.sender's account.\n    /// @param amount The maximum collective amount that `spender` can draw.\n    /// @return (bool) Returns True if approved.\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function approveBorrow(address spender, uint256 amount) external returns (bool) {\n        _approveBorrow(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        external\n        virtual\n        override(IERC20, IERC20Permit)\n    {\n        _permit(true, owner, spender, value, deadline, v, r, s);\n    }\n\n    function permitBorrow(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external virtual {\n        _permit(false, owner, spender, value, deadline, v, r, s);\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n\n    /**\n     * @notice Checks if the caller is allowed to lend `share` from `from`.\n     */\n    function _allowedLend(address from, uint256 share) internal virtual {}\n\n    /**\n     * @notice Checks if the caller is allowed to borrow `share` from `from`.\n     */\n    function _allowedBorrow(address from, uint256 share) internal virtual {}\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        current = _nonces[owner]++;\n    }\n\n    function _permit(\n        bool asset, // true = asset, false = collateral\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash;\n\n        structHash = keccak256(\n            abi.encode(\n                asset ? _PERMIT_TYPEHASH : _PERMIT_TYPEHASH_BORROW, owner, spender, value, _useNonce(owner), deadline\n            )\n        );\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        if (asset) {\n            _approve(owner, spender, value);\n        } else {\n            _approveBorrow(owner, spender, value);\n        }\n    }\n\n    function _approveBorrow(address owner, address spender, uint256 amount) internal {\n        allowanceBorrow[owner][spender] = amount;\n        emit ApprovalBorrow(owner, spender, amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal {\n        allowance[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n        return interfaceId == type(IERC20).interfaceId || interfaceId == type(IERC20Permit).interfaceId\n            || interfaceId == type(IERC1155Receiver).interfaceId;\n    }\n\n    function onERC1155Received(address operator, address from, uint256 id, uint256 value, bytes calldata data)\n        external\n        returns (bytes4)\n    {\n        // bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))\n        return 0xf23a6e61;\n    }\n\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4) {\n        return bytes4(0);\n    }\n}"
    },
    {
      "filename": "Tapioca-bar/contracts/markets/Market.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {IERC20} from \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {ILeverageExecutor} from \"tapioca-periph/interfaces/bar/ILeverageExecutor.sol\";\nimport {ITapiocaOracle} from \"tapioca-periph/interfaces/periph/ITapiocaOracle.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IPearlmit} from \"tapioca-periph/interfaces/periph/IPearlmit.sol\";\nimport {IPenrose} from \"tapioca-periph/interfaces/bar/IPenrose.sol\";\nimport {MarketERC20} from \"./MarketERC20.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\nabstract contract Market is MarketERC20, Ownable {\n    using RebaseLibrary for Rebase;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    enum PauseType {\n        Borrow,\n        Repay,\n        AddCollateral,\n        RemoveCollateral,\n        Liquidation,\n        LeverageBuy,\n        LeverageSell,\n        AddAsset,\n        RemoveAsset\n    }\n\n    /// @notice pause options\n    mapping(PauseType pauseProp => bool pauseStatus) public pauseOptions;\n    /// @notice conservator's addresss\n    /// @dev conservator can pause/unpause the contract\n    address public conservator;\n\n    /// @notice returns YieldBox address\n    IYieldBox public yieldBox;\n    /// @notice returns Penrose address\n    IPenrose public penrose;\n\n    IPearlmit public pearlmit;\n\n    /// @notice collateral token address\n    IERC20 public collateral;\n    /// @notice collateral token YieldBox id\n    uint256 public collateralId;\n    /// @notice asset token address\n    IERC20 public asset;\n    /// @notice asset token YieldBox id\n    uint256 public assetId;\n    /// @notice oracle address\n    ITapiocaOracle public oracle;\n    /// @notice oracleData\n    bytes public oracleData;\n    /// @notice Exchange and interest rate tracking.\n    /// This is 'cached' here because calls to Oracles can be very expensive.\n    /// Asset -> collateral = assetAmount * exchangeRate.\n    uint256 public exchangeRate;\n    /// @notice cached rate is valid only for the `rateValidDuration` time\n    uint256 public rateValidDuration;\n    /// @notice latest timestamp when `exchangeRate` was updated\n    uint256 public rateTimestamp;\n\n    /// @notice total amount borrowed\n    /// @dev elastic = Total token amount to be repayed by borrowers, base = Total parts of the debt held by borrowers\n    Rebase public totalBorrow;\n    /// @notice total collateral supplied\n    uint256 public totalCollateralShare;\n    /// @notice max borrow cap\n    uint256 public totalBorrowCap;\n    /// @notice borrow amount per user\n    mapping(address => uint256) public userBorrowPart;\n    /// @notice collateral share per user\n    mapping(address => uint256) public userCollateralShare;\n\n    /// @notice accrual protocol rewards\n    uint256 public protocolFee; // 10%\n    /// @notice min % a liquidator can receive in rewards\n    uint256 public minLiquidatorReward = 8e4; //80%\n    /// @notice max % a liquidator can receive in rewards\n    uint256 public maxLiquidatorReward = 9e4; //90%\n    /// @notice max liquidatable bonus amount\n    /// @dev max % added to the amount that can be liquidated\n    uint256 public liquidationBonusAmount = 1e4; //10%\n    /// @notice collateralization rate\n    uint256 public collateralizationRate; // 75%\n    /// @notice liquidation collateralization rate\n    uint256 public liquidationCollateralizationRate; //80%\n    /// @notice liquidation multiplier used to compute liquidator rewards\n    uint256 public liquidationMultiplier = 12000; //12%\n    /// @notice returns the leverage executor\n    ILeverageExecutor public leverageExecutor;\n\n    // ***************** //\n    // *** CONSTANTS *** //\n    // ***************** //\n    uint256 internal EXCHANGE_RATE_PRECISION; //not costant, but can only be set in the 'init' method\n    uint256 internal constant FEE_PRECISION = 1e5;\n    uint256 internal constant FEE_PRECISION_DECIMALS = 5;\n\n    error ExchangeRateNotValid();\n\n    // ************** //\n    // *** EVENTS *** //\n    // ************** //\n    /// @notice event emitted when `leverageExecutor` is updated\n    event LeverageExecutorSet(address indexed oldVal, address indexed newVal);\n    /// @notice event emitted when `exchangeRate` validation duration is updated\n    event ExchangeRateDurationUpdated(uint256 _oldVal, uint256 _newVal);\n    /// @notice event emitted when conservator is updated\n    event ConservatorUpdated(address indexed old, address indexed _new);\n    /// @notice event emitted when pause state is changed\n    event PausedUpdated(PauseType indexed _type, bool indexed oldState, bool indexed newState);\n    /// @notice event emitted when cached exchange rate is updated\n    event LogExchangeRate(uint256 indexed rate);\n    /// @notice event emitted when borrow cap is updated\n    event LogBorrowCapUpdated(uint256 indexed _oldVal, uint256 indexed _newVal);\n    /// @notice event emitted when oracle data is updated\n    event OracleDataUpdated();\n    /// @notice event emitted when oracle is updated\n    event OracleUpdated(address newAddr);\n    /// @notice event emitted when a position is liquidated\n    event Liquidated(\n        address indexed liquidator,\n        address[] indexed users,\n        uint256 indexed liquidatorReward,\n        uint256 protocolReward,\n        uint256 repayedAmount,\n        uint256 collateralShareRemoved\n    );\n    /// @notice event emitted when the liquidation multiplier rate is updated\n    event LiquidationMultiplierUpdated(uint256 indexed oldVal, uint256 indexed newVal);\n    /// @notice event emitted on setMarketConfig updates\n    event ValueUpdated(uint256 indexed valType, uint256 indexed _newVal);\n\n    modifier optionNotPaused(PauseType _type) {\n        require(!pauseOptions[_type], \"Market: paused\");\n        _;\n    }\n\n    modifier notSelf(address destination) {\n        require(destination != address(this), \"Market: cannot execute on itself\");\n        _;\n    }\n\n    /// @dev Checks if the user is solvent in the closed liquidation case at the end of the function body.\n    modifier solvent(address from, bool liquidation) {\n        updateExchangeRate();\n        _accrue();\n\n        _;\n\n        require(_isSolvent(from, exchangeRate, liquidation), \"Market: insolvent\");\n    }\n\n    bool internal initialized;\n\n    modifier onlyOnce() {\n        require(!initialized, \"Market: initialized\");\n        _;\n        initialized = true;\n    }\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n    /// @notice updates `leverageExecutor`\n    /// @param _executor the new ILeverageExecutor\n    function setLeverageExecutor(ILeverageExecutor _executor) external onlyOwner {\n        emit LeverageExecutorSet(address(leverageExecutor), address(_executor));\n        leverageExecutor = _executor;\n    }\n\n    /// @notice sets common market configuration\n    /// @dev values are updated only if > 0 or not address(0)\n    /// @param _oracle oracle address\n    /// @param _oracleData oracle data\n    /// @param _conservator conservator address; conservator is allowed to pause/unpause the contract\n    /// @param _protocolFee protocol fee percentage\n    /// @param _liquidationBonusAmount extra amount factored in the closing factor computation\n    /// @param _minLiquidatorReward minimum reward percentage a liquidator can receive\n    /// @param _maxLiquidatorReward maximum reward percentage a liquidator can receive\n    /// @param _totalBorrowCap max amount that can be borrowed from the contract\n    /// @param _collateralizationRate the new collateralization rate value (75000 is 75%)\n    /// @param _liquidationCollateralizationRate the new liquidation collateralization rate value (75000 is 75%)\n    function setMarketConfig(\n        ITapiocaOracle _oracle,\n        bytes calldata _oracleData,\n        address _conservator,\n        uint256 _protocolFee,\n        uint256 _liquidationBonusAmount,\n        uint256 _minLiquidatorReward,\n        uint256 _maxLiquidatorReward,\n        uint256 _totalBorrowCap,\n        uint256 _collateralizationRate,\n        uint256 _liquidationCollateralizationRate\n    ) external onlyOwner {\n        if (address(_oracle) != address(0)) {\n            oracle = _oracle;\n            emit OracleUpdated(address(_oracle));\n        }\n\n        if (_oracleData.length > 0) {\n            oracleData = _oracleData;\n            emit OracleDataUpdated();\n        }\n\n        if (_conservator != address(0)) {\n            emit ConservatorUpdated(conservator, _conservator);\n            conservator = _conservator;\n        }\n\n        if (_protocolFee > 0) {\n            require(_protocolFee <= FEE_PRECISION, \"Market: not valid\");\n            protocolFee = _protocolFee;\n            emit ValueUpdated(2, _protocolFee);\n        }\n\n        if (_liquidationBonusAmount > 0) {\n            require(_liquidationBonusAmount < FEE_PRECISION, \"Market: not valid\");\n            liquidationBonusAmount = _liquidationBonusAmount;\n            emit ValueUpdated(3, _liquidationBonusAmount);\n        }\n\n        if (_minLiquidatorReward > 0) {\n            require(_minLiquidatorReward < FEE_PRECISION, \"Market: not valid\");\n            require(_minLiquidatorReward < maxLiquidatorReward, \"Market: not valid\");\n            minLiquidatorReward = _minLiquidatorReward;\n            emit ValueUpdated(4, _minLiquidatorReward);\n        }\n\n        if (_maxLiquidatorReward > 0) {\n            require(_maxLiquidatorReward < FEE_PRECISION, \"Market: not valid\");\n            require(_maxLiquidatorReward > minLiquidatorReward, \"Market: not valid\");\n            maxLiquidatorReward = _maxLiquidatorReward;\n            emit ValueUpdated(5, _maxLiquidatorReward);\n        }\n\n        if (_totalBorrowCap > 0) {\n            emit LogBorrowCapUpdated(totalBorrowCap, _totalBorrowCap);\n            totalBorrowCap = _totalBorrowCap;\n            emit ValueUpdated(6, _totalBorrowCap);\n        }\n\n        if (_collateralizationRate > 0) {\n            require(_collateralizationRate <= FEE_PRECISION, \"Market: not valid\");\n            require(_collateralizationRate <= liquidationCollateralizationRate, \"Market: collateralizationRate too big\");\n            require(\n                _collateralizationRate * (FEE_PRECISION + liquidationMultiplier) < FEE_PRECISION * FEE_PRECISION,\n                \"Market: CR * (1 + LM) >= 1\"\n            );\n            collateralizationRate = _collateralizationRate;\n            emit ValueUpdated(7, _collateralizationRate);\n        }\n\n        if (_liquidationCollateralizationRate > 0) {\n            require(\n                _liquidationCollateralizationRate >= collateralizationRate,\n                \"Market: liquidationCollateralizationRate too small\"\n            );\n            require(_liquidationCollateralizationRate <= FEE_PRECISION, \"Market: not valid\");\n            liquidationCollateralizationRate = _liquidationCollateralizationRate;\n            emit ValueUpdated(8, _liquidationCollateralizationRate);\n        }\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice returns the maximum liquidatable amount for user\n    /// @param borrowPart amount borrowed\n    /// @param collateralPartInAsset collateral's value in borrowed asset\n    /// @param ratesPrecision collateralizationRate and liquidationCollateralizationRate precision\n    function computeClosingFactor(uint256 borrowPart, uint256 collateralPartInAsset, uint256 ratesPrecision)\n        public\n        view\n        returns (uint256)\n    {\n        return _computeClosingFactor(\n            borrowPart,\n            collateralPartInAsset,\n            ratesPrecision,\n            liquidationCollateralizationRate,\n            liquidationMultiplier,\n            totalBorrow\n        );\n    }\n\n    function _computeClosingFactor(\n        uint256 borrowPart,\n        uint256 collateralPartInAsset,\n        uint256 ratesPrecision,\n        uint256 _liquidationCollateralizationRate,\n        uint256 _liquidationMultiplier,\n        Rebase memory _totalBorrow\n    ) internal view returns (uint256) {\n        // Obviously it's not `borrowPart` anymore but `borrowAmount`\n        borrowPart = (borrowPart * _totalBorrow.elastic) / _totalBorrow.base;\n\n        //borrowPart and collateralPartInAsset should already be scaled due to the exchange rate computation\n        uint256 liquidationStartsAt =\n            (collateralPartInAsset * _liquidationCollateralizationRate) / (10 ** ratesPrecision);\n\n        if (borrowPart < liquidationStartsAt) return 0;\n\n        //compute numerator\n        uint256 numerator = borrowPart - liquidationStartsAt;\n        //compute denominator\n        uint256 diff =\n            (collateral"
    }
  ]
}