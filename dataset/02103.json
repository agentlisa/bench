{
  "Title": "M-18: Global position-fee-related state not updated until _after_ liquidation checks are done",
  "Content": "# Issue M-18: Global position-fee-related state not updated until _after_ liquidation checks are done \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/158 \n\n## Found by \nIllIllI\n\n## Summary\n\nGlobal position-fee-related state not updated until _after_ liquidation checks are done\n\n\n## Vulnerability Detail\n\nChecking whether a position is liquidatable occurs before the global state is updated.\n\n\n## Impact\n\nA position that should be liquidated in the current block, won't be liquidated until the next block, when the correct fee multipliers/factors are applied. A delayed liquidation means that a position that should have been liquidated will not be, likely causing a larger loss than should have been incurred.\n\n\n## Code Snippet\n\nState is updated _after_ the liquidation checks:\n\n```solidity\n// File: gmx-synthetics/contracts/position/DecreasePositionUtils.sol : DecreasePositionUtils.decreasePosition()   #1\n\n162 @>         if (BaseOrderUtils.isLiquidationOrder(params.order.orderType()) && !PositionUtils.isPositionLiquidatable(\n163                params.contracts.dataStore,\n164                params.contracts.referralStorage,\n165                params.position,\n166                params.market,\n167                cache.prices,\n168                true\n169            )) {\n170                revert PositionShouldNotBeLiquidated();\n171            }\n172    \n173:@>         PositionUtils.updateFundingAndBorrowingState(params, cache.prices);\n```\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/position/DecreasePositionUtils.sol#L152-L179\n\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nCall `PositionUtils.updateFundingAndBorrowingState()` before all checks\n\n\n\n\n## Discussion\n\n**xvi10**\n\nFix in https://github.com/gmx-io/gmx-synthetics/commit/0821228d2333b5a689d9361bafa806f51c56fbc1\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/position/DecreasePositionUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Precision.sol\";\n\nimport \"../data/DataStore.sol\";\nimport \"../event/EventEmitter.sol\";\n\nimport \"../oracle/Oracle.sol\";\nimport \"../pricing/PositionPricingUtils.sol\";\n\nimport \"./Position.sol\";\nimport \"./PositionStoreUtils.sol\";\nimport \"./PositionUtils.sol\";\nimport \"./PositionEventUtils.sol\";\nimport \"../order/BaseOrderUtils.sol\";\nimport \"../order/OrderEventUtils.sol\";\n\nimport \"./DecreasePositionCollateralUtils.sol\";\n\n// @title DecreasePositionUtils\n// @dev Library for functions to help with decreasing a position\nlibrary DecreasePositionUtils {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    using Position for Position.Props;\n    using Order for Order.Props;\n    using Price for Price.Props;\n\n    // @dev DecreasePositionResult struct for the results of decreasePosition\n    // @param outputToken the output token\n    // @param outputAmount the output amount\n    // @param secondaryOutputToken the secondary output token\n    // @param secondaryOutputAmount the secondary output amount\n    struct DecreasePositionResult {\n        address outputToken;\n        uint256 outputAmount;\n        address secondaryOutputToken;\n        uint256 secondaryOutputAmount;\n    }\n\n    error InvalidDecreaseOrderSize(uint256 sizeDeltaUsd, uint256 positionSizeInUsd);\n    error UnableToWithdrawCollateralDueToLeverage(int256 estimatedRemainingCollateralUsd);\n    error InvalidDecreasePositionSwapType(Order.DecreasePositionSwapType decreasePositionSwapType);\n    error PositionShouldNotBeLiquidated();\n\n    // @dev decreases a position\n    // The decreasePosition function decreases the size of an existing position\n    // in a market. It takes a PositionUtils.UpdatePositionParams object as an input, which\n    // includes information about the position to be decreased, the market in\n    // which the position exists, and the order that is being used to decrease the position.\n    //\n    // The function first calculates the prices of the tokens in the market, and then\n    // checks whether the position is liquidatable based on the current market prices.\n    // If the order is a liquidation order and the position is not liquidatable, the function reverts.\n    //\n    // If there is not enough collateral in the position to complete the decrease,\n    // the function reverts. Otherwise, the function updates the position's size and\n    // collateral amount, and increments the claimable funding amount for\n    // the market if necessary.\n    //\n    // Finally, the function returns a DecreasePositionResult object containing\n    // information about the outcome of the decrease operation, including the amount\n    // of collateral removed from the position and any fees that were paid.\n    // @param params PositionUtils.UpdatePositionParams\n    function decreasePosition(\n        PositionUtils.UpdatePositionParams memory params\n    ) external returns (DecreasePositionResult memory) {\n        PositionUtils.DecreasePositionCache memory cache;\n\n        cache.prices = MarketUtils.getMarketPricesForPosition(\n            params.contracts.oracle,\n            params.market\n        );\n\n        // cap the order size to the position size\n        if (params.order.sizeDeltaUsd() > params.position.sizeInUsd()) {\n            if (params.order.orderType() == Order.OrderType.LimitDecrease ||\n                params.order.orderType() == Order.OrderType.StopLossDecrease) {\n\n                OrderEventUtils.emitOrderSizeDeltaAutoUpdated(\n                    params.contracts.eventEmitter,\n                    params.orderKey,\n                    params.order.sizeDeltaUsd(),\n                    params.position.sizeInUsd()\n                );\n\n                params.order.setSizeDeltaUsd(params.position.sizeInUsd());\n            } else {\n                revert InvalidDecreaseOrderSize(params.order.sizeDeltaUsd(), params.position.sizeInUsd());\n            }\n        }\n\n        if (params.order.sizeDeltaUsd() < params.position.sizeInUsd() && params.order.initialCollateralDeltaAmount() > 0) {\n            // estimate pnl based on indexTokenPrice\n            (cache.estimatedPositionPnlUsd, /* uint256 sizeDeltaInTokens */) = PositionUtils.getPositionPnlUsd(\n                params.contracts.dataStore,\n                params.market,\n                cache.prices,\n                params.position,\n                cache.prices.indexTokenPrice.midPrice(),\n                params.position.sizeInUsd()\n            );\n\n            cache.estimatedRealizedPnlUsd = cache.estimatedPositionPnlUsd * params.order.sizeDeltaUsd().toInt256() / params.position.sizeInUsd().toInt256();\n            cache.estimatedRemainingPnlUsd = cache.estimatedPositionPnlUsd - cache.estimatedRealizedPnlUsd;\n\n            PositionUtils.WillPositionCollateralBeSufficientValues memory positionValues = PositionUtils.WillPositionCollateralBeSufficientValues(\n                params.position.sizeInUsd() - params.order.sizeDeltaUsd(), // positionSizeInUsd\n                params.position.collateralAmount() - params.order.initialCollateralDeltaAmount(), // positionCollateralAmount\n                cache.estimatedRemainingPnlUsd, // positionPnlUsd\n                cache.estimatedRealizedPnlUsd,  // realizedPnlUsd\n                -params.order.sizeDeltaUsd().toInt256() // openInterestDelta\n            );\n\n            (bool willBeSufficient, int256 estimatedRemainingCollateralUsd) = PositionUtils.willPositionCollateralBeSufficient(\n                params.contracts.dataStore,\n                params.market,\n                cache.prices,\n                params.position.collateralToken(),\n                params.position.isLong(),\n                positionValues\n            );\n\n            if (!willBeSufficient) {\n                if (params.order.sizeDeltaUsd() == 0) {\n                    revert UnableToWithdrawCollateralDueToLeverage(estimatedRemainingCollateralUsd);\n                }\n\n                OrderEventUtils.emitOrderCollateralDeltaAmountAutoUpdated(\n                    params.contracts.eventEmitter,\n                    params.orderKey,\n                    params.order.initialCollateralDeltaAmount(),\n                    0\n                );\n\n                params.order.setInitialCollateralDeltaAmount(0);\n            }\n\n            // if the remaining collateral will be below the min collateral usd value, then close the position\n            if (estimatedRemainingCollateralUsd < params.contracts.dataStore.getUint(Keys.MIN_COLLATERAL_USD).toInt256()) {\n                params.order.setSizeDeltaUsd(params.position.sizeInUsd());\n            }\n        }\n\n        // if the position will be closed, set the initial collateral delta amount\n        // to zero to help ensure that the order can be executed\n        if (params.order.sizeDeltaUsd() == params.position.sizeInUsd() && params.order.initialCollateralDeltaAmount() > 0) {\n            params.order.setInitialCollateralDeltaAmount(0);\n        }\n\n        cache.pnlToken = params.position.isLong() ? params.market.longToken : params.market.shortToken;\n        cache.pnlTokenPrice = params.position.isLong() ? cache.prices.longTokenPrice : cache.prices.shortTokenPrice;\n\n        if (params.order.decreasePositionSwapType() != Order.DecreasePositionSwapType.NoSwap &&\n            cache.pnlToken == params.position.collateralToken()) {\n            revert InvalidDecreasePositionSwapType(params.order.decreasePositionSwapType());\n        }\n\n        if (BaseOrderUtils.isLiquidationOrder(params.order.orderType()) && !PositionUtils.isPositionLiquidatable(\n            params.contracts.dataStore,\n            params.contracts.referralStorage,\n            params.position,\n            params.market,\n            cache.prices,\n            true\n        )) {\n            revert PositionShouldNotBeLiquidated();\n        }\n\n        PositionUtils.updateFundingAndBorrowingState(params, cache.prices);\n\n        cache.initialCollateralAmount = params.position.collateralAmount();\n        (\n            PositionUtils.DecreasePositionCollateralValues memory values,\n            PositionPricingUtils.PositionFees memory fees\n        ) = DecreasePositionCollateralUtils.processCollateral(\n            params,\n            cache\n        );\n\n        cache.nextPositionSizeInUsd = params.position.sizeInUsd() - params.order.sizeDeltaUsd();\n        cache.nextPositionBorrowingFactor = MarketUtils.getCumulativeBorrowingFactor(params.contracts.dataStore, params.market.marketToken, params.position.isLong());\n\n        PositionUtils.updateTotalBorrowing(\n            params,\n            cache.nextPositionSizeInUsd,\n            cache.nextPositionBorrowingFactor\n        );\n\n        params.position.setSizeInUsd(cache.nextPositionSizeInUsd);\n        params.position.setSizeInTokens(params.position.sizeInTokens() - values.sizeDeltaInTokens);\n        params.position.setCollateralAmount(values.remainingCollateralAmount.toUint256());\n        params.position.setDecreasedAtBlock(Chain.currentBlockNumber());\n\n        PositionUtils.incrementClaimableFundingAmount(params, fees);\n\n        if (params.position.sizeInUsd() == 0 || params.position.sizeInTokens() == 0) {\n            // withdraw all collateral if the position will be closed\n            values.output.outputAmount += params.position.collateralAmount();\n\n            params.position.setSizeInUsd(0);\n            params.position.setSizeInTokens(0);\n            params.position.setCollateralAmount(0);\n\n            PositionStoreUtils.remove(params.contracts.dataStore, params.positionKey, params.order.account());\n        } else {\n            if (!fees.funding.hasPendingLongTokenFundingFee) {\n                params.position.setLongTokenFundingAmountPerSize(fees.funding.latestLongTokenFundingAmountPerSize);\n            }\n            if (!fees.funding.hasPendingShortTokenFundingFee) {\n                params.position.setShortTokenFundingAmountPerSize(fees.funding.latestShortTokenFundingAmountPerSize);\n            }\n            params.position.setBorrowingFactor(cache.nextPositionBorrowingFactor);\n\n            PositionUtils.validatePosition(\n                params.contracts.dataStore,\n                params.contracts.referralStorage,\n                params.position,\n                params.market,\n                cache.prices,\n                false\n            );\n\n            PositionStoreUtils.set(params.contracts.dataStore, params.positionKey, params.position);\n        }\n\n        MarketUtils.applyDeltaToCollateralSum(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.position.market(),\n            params.position.collateralToken(),\n            params.position.isLong(),\n            -(cache.initialCollateralAmount - params.position.collateralAmount()).toInt256()\n        );\n\n        PositionUtils.updateOpenInterest(\n            params,\n            -params.order.sizeDeltaUsd().toInt256(),\n            -values.sizeDeltaInTokens.toInt256()\n        );\n\n        MarketUtils.applyDeltaToPoolAmount(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.market.marketToken,\n            values.pnlTokenForPool,\n            values.pnlAmountForPool\n        );\n\n        MarketUtils.applyDeltaToPoolAmount(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.market.marketToken,\n            params.position.collateralToken(),\n            fees.feeAmountForPool.toInt256()\n        );\n\n        PositionUtils.handleReferral(params, fees);\n\n        PositionPricingUtils.emitPositionFeesCollected(\n            params.contracts.eventEmitter,\n            params.market.marketToken,\n            params.position.collateralToken(),\n            false,\n            fees\n        );\n\n        PositionEventUtils.emitPositionDecrease(\n            params.contracts.eventEmitter,\n            params.positionKey,\n            params.position,\n            params.order.sizeDeltaUsd(),\n            cache.initialCollateralAmount - params.position.collateralAmount(),\n            params.order.orderType(),\n            values\n        );\n\n        values = DecreasePositionCollateralUtils.swapWithdrawnCollateralToPnlToken(params, values);\n\n        return DecreasePositionResult(\n            values.output.outputToken,\n            values.output.outputAmount,\n            values.output.secondaryOutputToken,\n            values.output.secondaryOutputAmount\n        );\n    }\n}"
    }
  ]
}