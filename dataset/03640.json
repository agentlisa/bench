{
  "Title": "Immutable variable in access modifier",
  "Content": "##### Description\nAt the line https://github.com/aave/governance-crosschain-bridges/blob/9fd0609a2e14d546885f76211961f251d2e15cb9/contracts/BridgeExecutorBase.sol#L22 used the `_guardian` variable in the access modifier. But it is initialized only once in the constructor and there is no other functionality to change. This can lead to unavailability to use `cancel()` method.\n\n##### Recommendation\nIt is recommended to add tool to change `_guardian` variable.\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/BridgeExecutorBase.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.7.5;\npragma abicoder v2;\n\nimport './dependencies/utilities/SafeMath.sol';\nimport './interfaces/IBridgeExecutor.sol';\n\nabstract contract BridgeExecutorBase is IBridgeExecutor {\n  using SafeMath for uint256;\n\n  uint256 private _delay;\n  uint256 private _gracePeriod;\n  uint256 private _minimumDelay;\n  uint256 private _maximumDelay;\n  address private _guardian;\n  uint256 private _actionsSetCounter;\n\n  mapping(uint256 => ActionsSet) private _actionsSets;\n  mapping(bytes32 => bool) private _queuedActions;\n\n  modifier onlyGuardian() {\n    require(msg.sender == _guardian, 'ONLY_BY_GUARDIAN');\n    _;\n  }\n\n  modifier onlyThis() {\n    require(msg.sender == address(this), 'UNAUTHORIZED_ORIGIN_ONLY_THIS');\n    _;\n  }\n\n  constructor(\n    uint256 delay,\n    uint256 gracePeriod,\n    uint256 minimumDelay,\n    uint256 maximumDelay,\n    address guardian\n  ) {\n    require(delay >= minimumDelay, 'DELAY_SHORTER_THAN_MINIMUM');\n    require(delay <= maximumDelay, 'DELAY_LONGER_THAN_MAXIMUM');\n    _delay = delay;\n    _gracePeriod = gracePeriod;\n    _minimumDelay = minimumDelay;\n    _maximumDelay = maximumDelay;\n    _guardian = guardian;\n  }\n\n  /// @inheritdoc IBridgeExecutor\n  function execute(uint256 actionsSetId) external payable override {\n    require(getCurrentState(actionsSetId) == ActionsSetState.Queued, 'ONLY_QUEUED_ACTIONS');\n\n    ActionsSet storage actionsSet = _actionsSets[actionsSetId];\n    require(block.timestamp >= actionsSet.executionTime, 'TIMELOCK_NOT_FINISHED');\n\n    actionsSet.executed = true;\n    uint256 actionCount = actionsSet.targets.length;\n\n    bytes[] memory returnedData = new bytes[](actionCount);\n    for (uint256 i = 0; i < actionCount; i++) {\n      returnedData[i] = _executeTransaction(\n        actionsSet.targets[i],\n        actionsSet.values[i],\n        actionsSet.signatures[i],\n        actionsSet.calldatas[i],\n        actionsSet.executionTime,\n        actionsSet.withDelegatecalls[i]\n      );\n    }\n    emit ActionsSetExecuted(actionsSetId, msg.sender, returnedData);\n  }\n\n  /// @inheritdoc IBridgeExecutor\n  function cancel(uint256 actionsSetId) external override onlyGuardian {\n    ActionsSetState state = getCurrentState(actionsSetId);\n    require(state == ActionsSetState.Queued, 'ONLY_BEFORE_EXECUTED');\n\n    ActionsSet storage actionsSet = _actionsSets[actionsSetId];\n    actionsSet.canceled = true;\n    for (uint256 i = 0; i < actionsSet.targets.length; i++) {\n      _cancelTransaction(\n        actionsSet.targets[i],\n        actionsSet.values[i],\n        actionsSet.signatures[i],\n        actionsSet.calldatas[i],\n        actionsSet.executionTime,\n        actionsSet.withDelegatecalls[i]\n      );\n    }\n\n    emit ActionsSetCanceled(actionsSetId);\n  }\n\n  /// @inheritdoc IBridgeExecutor\n  function getActionsSetById(uint256 actionsSetId)\n    external\n    view\n    override\n    returns (ActionsSet memory)\n  {\n    return _actionsSets[actionsSetId];\n  }\n\n  /// @inheritdoc IBridgeExecutor\n  function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {\n    require(_actionsSetCounter >= actionsSetId, 'INVALID_ACTION_ID');\n    ActionsSet storage actionsSet = _actionsSets[actionsSetId];\n    if (actionsSet.canceled) {\n      return ActionsSetState.Canceled;\n    } else if (actionsSet.executed) {\n      return ActionsSetState.Executed;\n    } else if (block.timestamp > actionsSet.executionTime.add(_gracePeriod)) {\n      return ActionsSetState.Expired;\n    } else {\n      return ActionsSetState.Queued;\n    }\n  }\n\n  /// @inheritdoc IBridgeExecutor\n  function isActionQueued(bytes32 actionHash) public view override returns (bool) {\n    return _queuedActions[actionHash];\n  }\n\n  /// @inheritdoc IBridgeExecutor\n  function receiveFunds() external payable {}\n\n  /// @inheritdoc IBridgeExecutor\n  function updateDelay(uint256 delay) external override onlyThis {\n    _validateDelay(delay);\n    emit DelayUpdate(_delay, delay);\n    _delay = delay;\n  }\n\n  /// @inheritdoc IBridgeExecutor\n  function updateGracePeriod(uint256 gracePeriod) external override onlyThis {\n    emit GracePeriodUpdate(_gracePeriod, gracePeriod);\n    _gracePeriod = gracePeriod;\n  }\n\n  /// @inheritdoc IBridgeExecutor\n  function updateMinimumDelay(uint256 minimumDelay) external override onlyThis {\n    uint256 previousMinimumDelay = _minimumDelay;\n    _minimumDelay = minimumDelay;\n    _validateDelay(_delay);\n    emit MinimumDelayUpdate(previousMinimumDelay, minimumDelay);\n  }\n\n  /// @inheritdoc IBridgeExecutor\n  function updateMaximumDelay(uint256 maximumDelay) external override onlyThis {\n    uint256 previousMaximumDelay = _maximumDelay;\n    _maximumDelay = maximumDelay;\n    _validateDelay(_delay);\n    emit MaximumDelayUpdate(previousMaximumDelay, maximumDelay);\n  }\n\n  /// @inheritdoc IBridgeExecutor\n  function getDelay() external view override returns (uint256) {\n    return _delay;\n  }\n\n  /// @inheritdoc IBridgeExecutor\n  function getGracePeriod() external view override returns (uint256) {\n    return _gracePeriod;\n  }\n\n  /// @inheritdoc IBridgeExecutor\n  function getMinimumDelay() external view override returns (uint256) {\n    return _minimumDelay;\n  }\n\n  /// @inheritdoc IBridgeExecutor\n  function getMaximumDelay() external view override returns (uint256) {\n    return _maximumDelay;\n  }\n\n  /**\n   * @dev target.delegatecall cannot be provided a value directly and is sent\n   * with the entire available msg.value. In this instance, we only want each proposed action\n   * to execute with exactly the value defined in the proposal. By splitting executeDelegateCall\n   * into a seperate function, it can be called from this contract with a defined amout of value,\n   * reducing the risk that a delegatecall is executed with more value than intended\n   * @return success - boolean indicating it the delegate call was successfull\n   * @return resultdata - bytes returned by the delegate call\n   **/\n  function executeDelegateCall(address target, bytes calldata data)\n    external\n    payable\n    onlyThis\n    returns (bool, bytes memory)\n  {\n    bool success;\n    bytes memory resultData;\n    // solium-disable-next-line security/no-call-value\n    (success, resultData) = target.delegatecall(data);\n    return (success, resultData);\n  }\n\n  /**\n   * @dev Queue the ActionsSet - only callable by the BridgeMessageProvessor\n   * @param targets list of contracts called by each action's associated transaction\n   * @param values list of value in wei for each action's  associated transaction\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget, else calls the target\n   **/\n  function _queue(\n    address[] memory targets,\n    uint256[] memory values,\n    string[] memory signatures,\n    bytes[] memory calldatas,\n    bool[] memory withDelegatecalls\n  ) internal {\n    require(targets.length != 0, 'INVALID_EMPTY_TARGETS');\n    require(\n      targets.length == values.length &&\n        targets.length == signatures.length &&\n        targets.length == calldatas.length &&\n        targets.length == withDelegatecalls.length,\n      'INCONSISTENT_PARAMS_LENGTH'\n    );\n\n    uint256 actionsSetId = _actionsSetCounter;\n    uint256 executionTime = block.timestamp.add(_delay);\n    _actionsSetCounter++;\n\n    for (uint256 i = 0; i < targets.length; i++) {\n      bytes32 actionHash =\n        keccak256(\n          abi.encode(\n            targets[i],\n            values[i],\n            signatures[i],\n            calldatas[i],\n            executionTime,\n            withDelegatecalls[i]\n          )\n        );\n      require(!isActionQueued(actionHash), 'DUPLICATED_ACTION');\n      _queuedActions[actionHash] = true;\n    }\n\n    ActionsSet storage actionsSet = _actionsSets[actionsSetId];\n    actionsSet.targets = targets;\n    actionsSet.values = values;\n    actionsSet.signatures = signatures;\n    actionsSet.calldatas = calldatas;\n    actionsSet.withDelegatecalls = withDelegatecalls;\n    actionsSet.executionTime = executionTime;\n\n    emit ActionsSetQueued(\n      actionsSetId,\n      targets,\n      values,\n      signatures,\n      calldatas,\n      withDelegatecalls,\n      executionTime\n    );\n  }\n\n  function _executeTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 executionTime,\n    bool withDelegatecall\n  ) internal returns (bytes memory) {\n    require(address(this).balance >= value, 'NOT_ENOUGH_CONTRACT_BALANCE');\n\n    bytes32 actionHash =\n      keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall));\n    _queuedActions[actionHash] = false;\n\n    bytes memory callData;\n    if (bytes(signature).length == 0) {\n      callData = data;\n    } else {\n      callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n    }\n\n    bool success;\n    bytes memory resultData;\n    if (withDelegatecall) {\n      (success, resultData) = this.executeDelegateCall{value: value}(target, callData);\n    } else {\n      // solium-disable-next-line security/no-call-value\n      (success, resultData) = target.call{value: value}(callData);\n    }\n    return _verifyCallResult(success, resultData);\n  }\n\n  function _cancelTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 executionTime,\n    bool withDelegatecall\n  ) internal {\n    bytes32 actionHash =\n      keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall));\n    _queuedActions[actionHash] = false;\n  }\n\n  function _validateDelay(uint256 delay) internal view {\n    require(delay >= _minimumDelay, 'DELAY_SHORTER_THAN_MINIMUM');\n    require(delay <= _maximumDelay, 'DELAY_LONGER_THAN_MAXIMUM');\n  }\n\n  function _verifyCallResult(bool success, bytes memory returndata)\n    private\n    pure\n    returns (bytes memory)\n  {\n    if (success) {\n      return returndata;\n    } else {\n      // Look for revert reason and bubble it up if present\n      if (returndata.length > 0) {\n        // The easiest way to bubble the revert reason is using memory via assembly\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert('FAILED_ACTION_EXECUTION');\n      }\n    }\n  }\n}"
    }
  ]
}