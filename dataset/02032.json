{
  "Title": "Potential clash between proxy and implementation function selectors",
  "Content": "ink! allows developers to set custom selectors for the functions defined on a contract as mentioned in [**Custom Selectors could facilitate proxy selector clashing attack**](#h01). When this feature is not used, the [`compute` function](https://github.com/paritytech/ink/blob/33b04bc13d3c77d676e375090eb7b6cebb9d6bd6/crates/ink/ir/src/ir/selector.rs#L68) from the `ink` crate is used to calculate the function selector instead. This function calculates the selector by hashing the function name and taking its first 4 bytes (similar to how it is done in Solidity).\n\n\nThe issue lies in the fact that the function selector is calculated using only the function’s name, without taking into account any other value. This may cause a function selector collision since it is likely to use the same function name in both the proxy and implementation.\n\n\nHere are some potential mitigations strategies for this issue:\n\n\n* Develop an `upgrade` command, as mentioned in the suggestions section, to check that there are no repeated function selectors between the proxy and the implementation to which the system is being upgraded.\n* Develop a new macro attribute named `proxy`, that could overwrite the implementation of the [`compute` function](https://github.com/paritytech/ink/blob/33b04bc13d3c77d676e375090eb7b6cebb9d6bd6/crates/ink/ir/src/ir/selector.rs#L68) so that it not only uses the name of the function, but also appends to it the name of the proxy contract, a hash of the name of the proxy contract, or any other item that will make the selector different, and properly document it. Additionally, the `proxy` macro will improve the readability of the contract itself, since developers and auditors will know the contract will behave like a proxy.\n\n\n***Update:** Acknowledged, will resolve. The progress can be tracked on [issue 981](https://github.com/paritytech/cargo-contract/issues/981) of the “cargo-contract” repository.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "crates/ink/ir/src/ir/selector.rs",
      "content": "// Copyright 2018-2022 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::blake2::blake2b_256;\nuse crate::literal::HexLiteral;\nuse proc_macro2::TokenStream as TokenStream2;\nuse std::marker::PhantomData;\nuse syn::spanned::Spanned as _;\n\n/// The selector of an ink! dispatchable.\n///\n/// # Note\n///\n/// This is equal to the first four bytes of the SHA-3 hash of a function's name.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\npub struct Selector {\n    bytes: [u8; 4],\n}\n\n/// The trait prefix to compute a composed selector for trait implementation blocks.\n#[derive(Debug, Copy, Clone)]\npub struct TraitPrefix<'a> {\n    /// The namespace of the ink! trait definition.\n    ///\n    /// By default this is equal to the `module_path!` at the ink! trait definition site.\n    /// It can be customized by the ink! trait definition author using `#[ink(namespace = N)]`\n    /// ink! attribute.\n    namespace: Option<&'a syn::LitStr>,\n    /// The Rust identifier of the ink! trait definition.\n    trait_ident: &'a syn::Ident,\n}\n\nimpl<'a> TraitPrefix<'a> {\n    /// Creates a new trait prefix.\n    pub fn new(trait_ident: &'a syn::Ident, namespace: Option<&'a syn::LitStr>) -> Self {\n        Self {\n            namespace,\n            trait_ident,\n        }\n    }\n\n    /// Returns a vector over the bytes of the namespace.\n    pub fn namespace_bytes(&self) -> Vec<u8> {\n        self.namespace\n            .map(|namespace| namespace.value().into_bytes())\n            .unwrap_or_default()\n    }\n\n    /// Returns a shared reference to the Rust identifier of the trait.\n    pub fn trait_ident(&self) -> &'a syn::Ident {\n        self.trait_ident\n    }\n}\n\nimpl Selector {\n    /// Computes the BLAKE-2 256-bit based selector from the given input bytes.\n    pub fn compute(input: &[u8]) -> Self {\n        let mut output = [0; 32];\n        blake2b_256(input, &mut output);\n        Self::from([output[0], output[1], output[2], output[3]])\n    }\n\n    /// # Note\n    ///\n    /// - `trait_prefix` is `None` when computing the selector of ink! constructors\n    ///   and messages in inherent implementation blocks.\n    /// - `trait_prefix` is `Some` when computing the selector of ink! constructors\n    ///   and messages in trait implementation blocks. In this case the `namespace`\n    ///   is either the full path of the trait definition gained by Rust's\n    ///   `module_path!` macro by default or it is customized by manual application\n    ///   of the `#[ink(namespace = \"my_namespace\")]` ink! attribute. In the\n    ///   example `my_namespace` concatenated with `::` and the identifier of the\n    ///   trait definition would then be part of the provided `trait_prefix` parameter.\n    /// - `fn_ident` refers to the ink! constructor or message identifier.\n    ///\n    /// # Inherent Implementation Blocks\n    ///\n    /// For inherent implementation blocks, when `trait_prefix` is `None` the composed\n    /// selector is computed as follows:\n    ///\n    /// 1. Apply `BLAKE2` 256-bit hash `H` on the bytes of the ASCII representation of\n    ///   the `fn_ident` identifier.\n    /// 1. The first 4 bytes of `H` make up the selector.\n    ///\n    /// # Trait Implementation Blocks\n    ///\n    /// For trait implementation blocks, when `trait_prefix` is\n    /// `Some((namespace, trait_ident))` the composed selector is computed as follows:\n    ///\n    /// 1. Compute the ASCII byte representation of `fn_ident` and call it `F`.\n    /// 1. Compute the ASCII byte representation of `namespace` and call it `N`.\n    /// 1. Compute the ASCII byte representation of `trait_ident` and call it `T`.\n    /// 1. Concatenate `N`, `T` and `F` using `::` as separator and call it `C`.\n    /// 1. Apply the `BLAKE2` 256-bit hash `H` of `C`.\n    /// 1. The first 4 bytes of `H` make up the selector.\n    pub fn compose<'a, T>(trait_prefix: T, fn_ident: &syn::Ident) -> Self\n    where\n        T: Into<Option<TraitPrefix<'a>>>,\n    {\n        let fn_ident = fn_ident.to_string().into_bytes();\n        let input_bytes: Vec<u8> = match trait_prefix.into() {\n            Some(trait_prefix) => {\n                let namespace = trait_prefix.namespace_bytes();\n                let trait_ident = trait_prefix.trait_ident().to_string().into_bytes();\n                let separator = &b\"::\"[..];\n                if namespace.is_empty() {\n                    [&trait_ident[..], &fn_ident[..]].join(separator)\n                } else {\n                    [&namespace[..], &trait_ident[..], &fn_ident[..]].join(separator)\n                }\n            }\n            None => fn_ident.to_vec(),\n        };\n        Self::compute(&input_bytes)\n    }\n\n    /// Returns the underlying four bytes.\n    pub fn to_bytes(&self) -> [u8; 4] {\n        self.bytes\n    }\n\n    /// Returns the big-endian `u32` representation of the selector bytes.\n    pub fn into_be_u32(self) -> u32 {\n        u32::from_be_bytes(self.bytes)\n    }\n\n    /// Returns the 4 bytes that make up the selector as hex encoded bytes.\n    pub fn hex_lits(self) -> [syn::LitInt; 4] {\n        self.bytes.map(<u8 as HexLiteral>::hex_padded_suffixed)\n    }\n}\n\nimpl From<[u8; 4]> for Selector {\n    fn from(bytes: [u8; 4]) -> Self {\n        Self { bytes }\n    }\n}\n\n/// Used as generic parameter for the `selector_id!` macro.\npub enum SelectorId {}\n\n/// Used as generic parameter for the `selector_bytes!` macro.\npub enum SelectorBytes {}\n\n/// The selector ID of an ink! dispatchable.\n///\n/// # Note\n///\n/// This is mainly used for analysis and codegen of the `selector_id!` macro.\n#[derive(Debug)]\npub struct SelectorMacro<T> {\n    selector: Selector,\n    input: syn::Lit,\n    _marker: PhantomData<fn() -> T>,\n}\n\nimpl<T> SelectorMacro<T> {\n    /// Returns the underlying selector.\n    pub fn selector(&self) -> Selector {\n        self.selector\n    }\n\n    /// Returns the literal input of the selector ID.\n    pub fn input(&self) -> &syn::Lit {\n        &self.input\n    }\n}\n\nimpl<T> TryFrom<TokenStream2> for SelectorMacro<T> {\n    type Error = syn::Error;\n\n    fn try_from(input: TokenStream2) -> Result<Self, Self::Error> {\n        let input_span = input.span();\n        let lit = syn::parse2::<syn::Lit>(input).map_err(|error| {\n            format_err!(\n                input_span,\n                \"expected string or byte string literal as input: {}\",\n                error\n            )\n        })?;\n        let input_bytes = match lit {\n            syn::Lit::Str(ref lit_str) => lit_str.value().into_bytes(),\n            syn::Lit::ByteStr(ref byte_str) => byte_str.value(),\n            invalid => {\n                return Err(format_err!(\n                    invalid.span(),\n                    \"expected string or byte string literal as input. found {:?}\",\n                    invalid,\n                ))\n            }\n        };\n        let selector = Selector::compute(&input_bytes);\n        Ok(Self {\n            selector,\n            input: lit,\n            _marker: PhantomData,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn hex_lits_works() {\n        let hex_lits = Selector::from([0xC0, 0xDE, 0xCA, 0xFE]).hex_lits();\n        assert_eq!(\n            hex_lits,\n            [\n                syn::parse_quote! { 0xC0_u8 },\n                syn::parse_quote! { 0xDE_u8 },\n                syn::parse_quote! { 0xCA_u8 },\n                syn::parse_quote! { 0xFE_u8 },\n            ]\n        )\n    }\n}"
    },
    {
      "filename": "crates/ink/ir/src/ir/selector.rs",
      "content": "// Copyright 2018-2022 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse super::blake2::blake2b_256;\nuse crate::literal::HexLiteral;\nuse proc_macro2::TokenStream as TokenStream2;\nuse std::marker::PhantomData;\nuse syn::spanned::Spanned as _;\n\n/// The selector of an ink! dispatchable.\n///\n/// # Note\n///\n/// This is equal to the first four bytes of the SHA-3 hash of a function's name.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\npub struct Selector {\n    bytes: [u8; 4],\n}\n\n/// The trait prefix to compute a composed selector for trait implementation blocks.\n#[derive(Debug, Copy, Clone)]\npub struct TraitPrefix<'a> {\n    /// The namespace of the ink! trait definition.\n    ///\n    /// By default this is equal to the `module_path!` at the ink! trait definition site.\n    /// It can be customized by the ink! trait definition author using `#[ink(namespace = N)]`\n    /// ink! attribute.\n    namespace: Option<&'a syn::LitStr>,\n    /// The Rust identifier of the ink! trait definition.\n    trait_ident: &'a syn::Ident,\n}\n\nimpl<'a> TraitPrefix<'a> {\n    /// Creates a new trait prefix.\n    pub fn new(trait_ident: &'a syn::Ident, namespace: Option<&'a syn::LitStr>) -> Self {\n        Self {\n            namespace,\n            trait_ident,\n        }\n    }\n\n    /// Returns a vector over the bytes of the namespace.\n    pub fn namespace_bytes(&self) -> Vec<u8> {\n        self.namespace\n            .map(|namespace| namespace.value().into_bytes())\n            .unwrap_or_default()\n    }\n\n    /// Returns a shared reference to the Rust identifier of the trait.\n    pub fn trait_ident(&self) -> &'a syn::Ident {\n        self.trait_ident\n    }\n}\n\nimpl Selector {\n    /// Computes the BLAKE-2 256-bit based selector from the given input bytes.\n    pub fn compute(input: &[u8]) -> Self {\n        let mut output = [0; 32];\n        blake2b_256(input, &mut output);\n        Self::from([output[0], output[1], output[2], output[3]])\n    }\n\n    /// # Note\n    ///\n    /// - `trait_prefix` is `None` when computing the selector of ink! constructors\n    ///   and messages in inherent implementation blocks.\n    /// - `trait_prefix` is `Some` when computing the selector of ink! constructors\n    ///   and messages in trait implementation blocks. In this case the `namespace`\n    ///   is either the full path of the trait definition gained by Rust's\n    ///   `module_path!` macro by default or it is customized by manual application\n    ///   of the `#[ink(namespace = \"my_namespace\")]` ink! attribute. In the\n    ///   example `my_namespace` concatenated with `::` and the identifier of the\n    ///   trait definition would then be part of the provided `trait_prefix` parameter.\n    /// - `fn_ident` refers to the ink! constructor or message identifier.\n    ///\n    /// # Inherent Implementation Blocks\n    ///\n    /// For inherent implementation blocks, when `trait_prefix` is `None` the composed\n    /// selector is computed as follows:\n    ///\n    /// 1. Apply `BLAKE2` 256-bit hash `H` on the bytes of the ASCII representation of\n    ///   the `fn_ident` identifier.\n    /// 1. The first 4 bytes of `H` make up the selector.\n    ///\n    /// # Trait Implementation Blocks\n    ///\n    /// For trait implementation blocks, when `trait_prefix` is\n    /// `Some((namespace, trait_ident))` the composed selector is computed as follows:\n    ///\n    /// 1. Compute the ASCII byte representation of `fn_ident` and call it `F`.\n    /// 1. Compute the ASCII byte representation of `namespace` and call it `N`.\n    /// 1. Compute the ASCII byte representation of `trait_ident` and call it `T`.\n    /// 1. Concatenate `N`, `T` and `F` using `::` as separator and call it `C`.\n    /// 1. Apply the `BLAKE2` 256-bit hash `H` of `C`.\n    /// 1. The first 4 bytes of `H` make up the selector.\n    pub fn compose<'a, T>(trait_prefix: T, fn_ident: &syn::Ident) -> Self\n    where\n        T: Into<Option<TraitPrefix<'a>>>,\n    {\n        let fn_ident = fn_ident.to_string().into_bytes();\n        let input_bytes: Vec<u8> = match trait_prefix.into() {\n            Some(trait_prefix) => {\n                let namespace = trait_prefix.namespace_bytes();\n                let trait_ident = trait_prefix.trait_ident().to_string().into_bytes();\n                let separator = &b\"::\"[..];\n                if namespace.is_empty() {\n                    [&trait_ident[..], &fn_ident[..]].join(separator)\n                } else {\n                    [&namespace[..], &trait_ident[..], &fn_ident[..]].join(separator)\n                }\n            }\n            None => fn_ident.to_vec(),\n        };\n        Self::compute(&input_bytes)\n    }\n\n    /// Returns the underlying four bytes.\n    pub fn to_bytes(&self) -> [u8; 4] {\n        self.bytes\n    }\n\n    /// Returns the big-endian `u32` representation of the selector bytes.\n    pub fn into_be_u32(self) -> u32 {\n        u32::from_be_bytes(self.bytes)\n    }\n\n    /// Returns the 4 bytes that make up the selector as hex encoded bytes.\n    pub fn hex_lits(self) -> [syn::LitInt; 4] {\n        self.bytes.map(<u8 as HexLiteral>::hex_padded_suffixed)\n    }\n}\n\nimpl From<[u8; 4]> for Selector {\n    fn from(bytes: [u8; 4]) -> Self {\n        Self { bytes }\n    }\n}\n\n/// Used as generic parameter for the `selector_id!` macro.\npub enum SelectorId {}\n\n/// Used as generic parameter for the `selector_bytes!` macro.\npub enum SelectorBytes {}\n\n/// The selector ID of an ink! dispatchable.\n///\n/// # Note\n///\n/// This is mainly used for analysis and codegen of the `selector_id!` macro.\n#[derive(Debug)]\npub struct SelectorMacro<T> {\n    selector: Selector,\n    input: syn::Lit,\n    _marker: PhantomData<fn() -> T>,\n}\n\nimpl<T> SelectorMacro<T> {\n    /// Returns the underlying selector.\n    pub fn selector(&self) -> Selector {\n        self.selector\n    }\n\n    /// Returns the literal input of the selector ID.\n    pub fn input(&self) -> &syn::Lit {\n        &self.input\n    }\n}\n\nimpl<T> TryFrom<TokenStream2> for SelectorMacro<T> {\n    type Error = syn::Error;\n\n    fn try_from(input: TokenStream2) -> Result<Self, Self::Error> {\n        let input_span = input.span();\n        let lit = syn::parse2::<syn::Lit>(input).map_err(|error| {\n            format_err!(\n                input_span,\n                \"expected string or byte string literal as input: {}\",\n                error\n            )\n        })?;\n        let input_bytes = match lit {\n            syn::Lit::Str(ref lit_str) => lit_str.value().into_bytes(),\n            syn::Lit::ByteStr(ref byte_str) => byte_str.value(),\n            invalid => {\n                return Err(format_err!(\n                    invalid.span(),\n                    \"expected string or byte string literal as input. found {:?}\",\n                    invalid,\n                ))\n            }\n        };\n        let selector = Selector::compute(&input_bytes);\n        Ok(Self {\n            selector,\n            input: lit,\n            _marker: PhantomData,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn hex_lits_works() {\n        let hex_lits = Selector::from([0xC0, 0xDE, 0xCA, 0xFE]).hex_lits();\n        assert_eq!(\n            hex_lits,\n            [\n                syn::parse_quote! { 0xC0_u8 },\n                syn::parse_quote! { 0xDE_u8 },\n                syn::parse_quote! { 0xCA_u8 },\n                syn::parse_quote! { 0xFE_u8 },\n            ]\n        )\n    }\n}"
    }
  ]
}