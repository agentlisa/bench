{
  "Title": "[M-04] KUMASwap incorrectly reverts when when `_maxCoupons` has been reached",
  "Content": "\nSelling bonds with coupons that are already accounted will fail unexpectedly.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2023-02-kuma/blob/3f3d2269fcb3437a9f00ffdd67b5029487435b95/src/kuma-protocol/KUMASwap.sol#L116-L118>\n\n        if (_coupons.length() == _maxCoupons) {\n            revert Errors.MAX_COUPONS_REACHED();\n        }\n\nThe above lines will cause ALL bonds sales to revert when `_coupons.length` has reached `_maxCoupons`. Since bonds may share the same `coupon`, the swap should continue to accept bonds with a `coupon` that already exist in the `_coupons` set.\n\n### Recommended Mitigation Steps\n\nsellBond should only revert if the max length has been reached and bond.coupon doesn't already exist:\n\n    -   if (_coupons.length() == _maxCoupons) {\n    +   if (_coupons.length() == _maxCoupons && !_coupons.contains(bond.coupon)) {\n            revert Errors.MAX_COUPONS_REACHED();\n        }\n\n**[m19 (KUMA) confirmed and commented](https://github.com/code-423n4/2023-02-kuma-findings/issues/10#issuecomment-1447491243):**\n > Even though this scenario is unlikely to ever happen we have confirmed this issue in a test:\n> \n> ```\n>     function test_sellBond_WithExistingCouponWhenMaxCouponsReached() external {\n>         _KUMASwap.sellBond(1);\n>         IKUMABondToken.Bond memory bond_ = _bond;\n> \n>         for (uint256 i; i < 364; i++) {\n>             bond_.coupon = bond_.coupon + 1;\n>             _KUMABondToken.issueBond(address(this), bond_);\n>             _KUMASwap.sellBond(i + 2);\n>         }\n> \n>         _KUMABondToken.issueBond(address(this), _bond);\n> \n>         _KUMASwap.sellBond(365);\n>     }\n> ```\n> \n> We intend to fix this.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-02-kuma-findings/issues/10#issuecomment-1449844072):**\n > The warden has shown a way in which the system could stop selling coupons due to the handling of duplicate coupons, this relies on a specific condition which may not always happen, for this reason, in lack of an attack that can be used to break the functionality, I agree with Medium Severity.\n> \n**[m19 (KUMA) mitigated](https://github.com/code-423n4/2023-02-kuma-findings/issues/3#issuecomment-1447507612):**\n > https://github.com/code-423n4/2023-02-kuma/pull/7 \n>\n **Status:** Mitigation confirmed by [0xsomeone](https://github.com/code-423n4/2023-03-kuma-mitigation-contest-findings/issues/22), [0x52](https://github.com/code-423n4/2023-03-kuma-mitigation-contest-findings/issues/15), and [hihen](https://github.com/code-423n4/2023-03-kuma-mitigation-contest-findings/issues/5).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-02-kuma",
  "Code": [
    {
      "filename": "src/kuma-protocol/KUMASwap.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {Errors} from \"./libraries/Errors.sol\";\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {IKUMABondToken} from \"@mcag/interfaces/IKUMABondToken.sol\";\nimport {IKUMAAddressProvider} from \"./interfaces/IKUMAAddressProvider.sol\";\nimport {IKBCToken} from \"./interfaces/IKBCToken.sol\";\nimport {IKIBToken} from \"./interfaces/IKIBToken.sol\";\nimport {IKUMASwap} from \"./interfaces/IKUMASwap.sol\";\nimport {IMCAGRateFeed} from \"./interfaces/IMCAGRateFeed.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin-upgradeable/contracts/security/PausableUpgradeable.sol\";\nimport {PercentageMath} from \"./libraries/PercentageMath.sol\";\nimport {Roles} from \"./libraries/Roles.sol\";\nimport {WadRayMath} from \"./libraries/WadRayMath.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\n\ncontract KUMASwap is IKUMASwap, PausableUpgradeable, UUPSUpgradeable {\n    using EnumerableSet for EnumerableSet.UintSet;\n    using PercentageMath for uint256;\n    using Roles for bytes32;\n    using SafeERC20 for IERC20;\n    using WadRayMath for uint256;\n\n    uint256 public constant MIN_ALLOWED_COUPON = WadRayMath.RAY;\n    uint256 public constant DEPRECATION_MODE_TIMELOCK = 2 days;\n\n    bytes32 private _riskCategory;\n    uint16 private _maxCoupons;\n    IKUMAAddressProvider private _KUMAAddressProvider;\n    bool private _isDeprecated;\n    uint56 private _deprecationInitializedAt;\n    uint16 private _variableFee;\n    uint96 private _expirationDelay;\n    IERC20 private _deprecationStableCoin;\n    uint256 private _fixedFee;\n    uint256 private _minCoupon;\n\n    // @notice Set of unique coupons in reserve\n    EnumerableSet.UintSet private _coupons;\n    // @notice Set of all token ids in reserve\n    EnumerableSet.UintSet private _bondReserve;\n    // @notice Set of all expired token ids in the reserve;\n    EnumerableSet.UintSet private _expiredBonds;\n\n    // @notice KUMABondToken id to KBCToken id\n    mapping(uint256 => uint256) private _cloneBonds;\n    // @notice Quantity of each coupon in reserve\n    mapping(uint256 => uint256) private _couponInventory;\n    // @notive Bond id to Bond sale price discounted by KIBToken cumulative yield\n    mapping(uint256 => uint256) private _bondBaseValue;\n\n    modifier onlyRole(bytes32 role) {\n        if (!IAccessControl(_KUMAAddressProvider.getAccessController()).hasRole(role, msg.sender)) {\n            revert Errors.ACCESS_CONTROL_ACCOUNT_IS_MISSING_ROLE(msg.sender, role);\n        }\n        _;\n    }\n\n    modifier whenNotDeprecated() {\n        if (_isDeprecated) {\n            revert Errors.DEPRECATION_MODE_ENABLED();\n        }\n        _;\n    }\n\n    modifier whenDeprecated() {\n        if (!_isDeprecated) {\n            revert Errors.DEPRECATION_MODE_NOT_ENABLED();\n        }\n        _;\n    }\n\n    constructor() initializer {}\n\n    /**\n     * @param KUMAAddressProvider KUMAAddressProvider.\n     * @param currency Underlying bonds currency.\n     * @param country Underlying bonds treasury issuer.\n     * @param term Underling bonds term.\n     */\n    function initialize(\n        IKUMAAddressProvider KUMAAddressProvider,\n        IERC20 deprecationStableCoin,\n        bytes4 currency,\n        bytes4 country,\n        uint64 term\n    ) external override initializer {\n        if (address(KUMAAddressProvider) == address(0) || address(deprecationStableCoin) == address(0)) {\n            revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\n        }\n        if (currency == bytes4(0) || country == bytes4(0) || term == 0) {\n            revert Errors.WRONG_RISK_CATEGORY();\n        }\n        _KUMAAddressProvider = KUMAAddressProvider;\n        _maxCoupons = uint16(term / 30 days);\n        _riskCategory = keccak256(abi.encode(currency, country, term));\n        _minCoupon = MIN_ALLOWED_COUPON;\n        _deprecationStableCoin = deprecationStableCoin;\n        __Pausable_init();\n\n        emit DeprecationStableCoinSet(address(0), address(deprecationStableCoin));\n        emit KUMAAddressProviderSet(address(KUMAAddressProvider));\n        emit RiskCategorySet(_riskCategory);\n    }\n\n    /**\n     * @notice Sells a bond against KIBToken.\n     * @param tokenId Sold bond tokenId.\n     */\n    function sellBond(uint256 tokenId) external override whenNotPaused whenNotDeprecated {\n        if (_coupons.length() == _maxCoupons) {\n            revert Errors.MAX_COUPONS_REACHED();\n        }\n        IKUMAAddressProvider KUMAAddressProvider = _KUMAAddressProvider;\n        IKUMABondToken KUMABondToken = IKUMABondToken(KUMAAddressProvider.getKUMABondToken());\n        IKUMABondToken.Bond memory bond = KUMABondToken.getBond(tokenId);\n\n        if (bond.riskCategory != _riskCategory) {\n            revert Errors.WRONG_RISK_CATEGORY();\n        }\n\n        if (bond.maturity <= block.timestamp) {\n            revert Errors.CANNOT_SELL_MATURED_BOND();\n        }\n\n        IKIBToken KIBToken = IKIBToken(KUMAAddressProvider.getKIBToken(_riskCategory));\n        uint256 referenceRate = IMCAGRateFeed(KUMAAddressProvider.getRateFeed()).getRate(_riskCategory);\n\n        if (bond.coupon < referenceRate) {\n            revert Errors.COUPON_TOO_LOW();\n        }\n\n        if (_coupons.length() == 0) {\n            _minCoupon = bond.coupon;\n            _coupons.add(bond.coupon);\n        } else {\n            if (bond.coupon < _minCoupon) {\n                _minCoupon = bond.coupon;\n            }\n            if (!_coupons.contains(bond.coupon)) {\n                _coupons.add(bond.coupon);\n            }\n        }\n\n        _couponInventory[bond.coupon]++;\n        _bondReserve.add(tokenId);\n\n        uint256 bondValue = _getBondValue(bond.issuance, bond.term, bond.coupon, bond.principal);\n\n        _bondBaseValue[tokenId] = bondValue.wadToRay().rayDiv(KIBToken.getUpdatedCumulativeYield());\n\n        uint256 fee = _calculateFees(bondValue);\n\n        uint256 mintAmount = bondValue;\n\n        if (fee > 0) {\n            mintAmount = bondValue - fee;\n            KIBToken.mint(KUMAAddressProvider.getKUMAFeeCollector(_riskCategory), fee);\n        }\n\n        KIBToken.mint(msg.sender, mintAmount);\n        KUMABondToken.safeTransferFrom(msg.sender, address(this), tokenId);\n\n        emit FeeCharged(fee);\n        emit BondSold(tokenId, mintAmount, msg.sender);\n    }\n\n    /**\n     * @notice Buys a bond against KIBToken.\n     * @param tokenId Bought bond tokenId.\n     */\n    function buyBond(uint256 tokenId) external override whenNotPaused whenNotDeprecated {\n        IKUMAAddressProvider KUMAAddressProvider = _KUMAAddressProvider;\n        IKUMABondToken KUMABondToken = IKUMABondToken(KUMAAddressProvider.getKUMABondToken());\n        IKUMABondToken.Bond memory bond = KUMABondToken.getBond(tokenId);\n\n        if (!_bondReserve.contains(tokenId)) {\n            revert Errors.INVALID_TOKEN_ID();\n        }\n\n        bool isBondExpired = _expiredBonds.contains(tokenId);\n\n        if (_expiredBonds.length() > 0 && !isBondExpired) {\n            revert Errors.EXPIRED_BONDS_MUST_BE_BOUGHT_FIRST();\n        }\n\n        if (_couponInventory[bond.coupon] == 1) {\n            _coupons.remove(bond.coupon);\n        }\n\n        _couponInventory[bond.coupon]--;\n        _bondReserve.remove(tokenId);\n\n        if (isBondExpired) {\n            _expiredBonds.remove(tokenId);\n        }\n\n        IKIBToken KIBToken = IKIBToken(KUMAAddressProvider.getKIBToken(_riskCategory));\n\n        uint256 bondFaceValue = _getBondValue(bond.issuance, bond.term, bond.coupon, bond.principal);\n        uint256 realizedBondValue = _bondBaseValue[tokenId].rayMul(KIBToken.getUpdatedCumulativeYield()).rayToWad();\n\n        bool requireClone = bondFaceValue > realizedBondValue;\n\n        if (requireClone) {\n            _cloneBonds[tokenId] = IKBCToken(KUMAAddressProvider.getKBCToken()).issueBond(\n                msg.sender,\n                IKBCToken.CloneBond({\n                    parentId: tokenId,\n                    issuance: KIBToken.getPreviousEpochTimestamp(),\n                    coupon: KIBToken.getYield(),\n                    principal: realizedBondValue\n                })\n            );\n        }\n\n        _updateMinCoupon();\n\n        KIBToken.burn(msg.sender, realizedBondValue);\n\n        if (!requireClone) {\n            KUMABondToken.safeTransferFrom(address(this), msg.sender, tokenId);\n        }\n\n        emit BondBought(tokenId, realizedBondValue, msg.sender);\n    }\n\n    /**\n     * @notice Buys a bond against _deprecationStableCoin.\n     * @dev Requires an approval on amount from buyer. This will also result in some stale state for the contract on _coupons\n     * and _minCoupon but this is acceptable as deprecation mode is irreversible. This function also ignores any existing clone bond\n     * which is the intended bahaviour as bonds will be valued per their market rate offchain.\n     * @param tokenId Bought bond tokenId.\n     * @param buyer Bought bond buyer.\n     * @param amount Stable coin price paid by the buyer.\n     */\n    function buyBondForStableCoin(uint256 tokenId, address buyer, uint256 amount)\n        external\n        override\n        onlyRole(Roles.KUMA_MANAGER_ROLE)\n        whenDeprecated\n    {\n        if (!_bondReserve.contains(tokenId)) {\n            revert Errors.INVALID_TOKEN_ID();\n        }\n        if (buyer == address(0)) {\n            revert Errors.BUYER_CANNOT_BE_ADDRESS_ZERO();\n        }\n        if (amount == 0) {\n            revert Errors.AMOUNT_CANNOT_BE_ZERO();\n        }\n\n        _bondReserve.remove(tokenId);\n\n        _deprecationStableCoin.safeTransferFrom(buyer, address(this), amount);\n        IKUMABondToken(_KUMAAddressProvider.getKUMABondToken()).safeTransferFrom(address(this), buyer, tokenId);\n\n        emit BondBought(tokenId, amount, buyer);\n    }\n\n    /**\n     * @notice Claims a bond against a CloneBond.\n     * @dev Can only by called by a KUMA_SWAP_CLAIM_ROLE address.\n     * @param tokenId Claimed bond tokenId.\n     */\n    function claimBond(uint256 tokenId)\n        external\n        override\n        onlyRole(Roles.KUMA_SWAP_CLAIM_ROLE.toGranularRole(_riskCategory))\n    {\n        IKUMAAddressProvider KUMAAddressProvider = _KUMAAddressProvider;\n\n        if (_cloneBonds[tokenId] == 0) {\n            revert Errors.BOND_NOT_AVAILABLE_FOR_CLAIM();\n        }\n\n        uint256 gBondId = _cloneBonds[tokenId];\n        delete _cloneBonds[tokenId];\n\n        IKBCToken(KUMAAddressProvider.getKBCToken()).redeem(gBondId);\n        IKUMABondToken(KUMAAddressProvider.getKUMABondToken()).safeTransferFrom(address(this), msg.sender, tokenId);\n\n        emit BondClaimed(tokenId, gBondId);\n    }\n\n    /**\n     * @notice Redeems KIBToken against deprecation mode stable coin. Redeem stable coin amount is calculated as follow :\n     *                          KIBTokenAmount\n     *      redeemAmount = ------------------------ * KUMASwapStableCoinBalance\n     *                        KIBTokenTotalSupply\n     * @dev Can only be called if deprecation mode is enabled.\n     * @param amount Amount of KIBToken to redeem.\n     */\n    function redeemKIBT(uint256 amount) external override whenDeprecated {\n        if (amount == 0) {\n            revert Errors.AMOUNT_CANNOT_BE_ZERO();\n        }\n        if (_bondReserve.length() != 0) {\n            revert Errors.BOND_RESERVE_NOT_EMPTY();\n        }\n        IKIBToken KIBToken = IKIBToken(_KUMAAddressProvider.getKIBToken(_riskCategory));\n        IERC20 deprecationStableCoin = _deprecationStableCoin;\n\n        uint256 redeemAmount =\n            amount.wadMul(_deprecationStableCoin.balanceOf(address(this))).wadDiv(KIBToken.totalSupply());\n        KIBToken.burn(msg.sender, amount);\n        deprecationStableCoin.safeTransfer(msg.sender, redeemAmount);\n\n        emit KIBTRedeemed(msg.sender, redeemAmount);\n    }\n\n    /**\n     * @notice Expires a bond if it has reached maturity by setting _minCoupon to MIN_ALLOWED_COUPON.\n     * @param tokenId Claimed bond tokenId.\n     */\n    function expireBond(uint256 tokenId) external override whenNotDeprecated {\n        if (!_bondReserve.contains(tokenId)) {\n            revert Errors.INVALID_TOKEN_ID();\n        }\n\n        IKUMAAddressProvider KUMAAddressProvider = _KUMAAddressProvider;\n\n        if (IKUMABondToken(KUMAAddressProvider.getKUMABondToken()).getBond(tokenId).maturity > block.timestamp) {\n            revert Errors.BOND_NOT_MATURED();\n        }\n\n        _expiredBonds.add(tokenId);\n\n        IKIBToken(KUMAAddressProvider.getKIBToken(_riskCategory)).refreshYield();\n\n        emit BondExpired(tokenId);\n    }\n\n    /**\n     * @dev See {Pausable-_pause}.\n     */\n    function pause() external override onlyRole(Roles.KUMA_SWAP_PAUSE_ROLE.toGranularRole(_riskCategory)) {\n        _pause();\n    }\n\n    /**\n     * @dev See {Pausable-_unpause}.\n     */\n    function unpause() external override onlyRole(Roles.KUMA_SWAP_UNPAUSE_ROLE.toGranularRole(_riskCategory)) {\n        _unpause();\n    }\n\n    /**\n     * @notice Set fees that will be charges upon bond sale per the following formula :\n     * totalFee = bondValue * variableFee + fixedFee.\n     * @param variableFee in basis points.\n     * @param fixedFee in KIBToken decimals.\n     */\n    function setFees(uint16 variableFee, uint256 fixedFee) external override onlyRole(Roles.KUMA_MANAGER_ROLE) {\n        _variableFee = variableFee;\n        _fixedFee = fixedFee;\n        emit FeeSet(variableFee, fixedFee);\n    }\n\n    /**\n     * @notice Sets a new stable coin to be accepted during deprecation mode.\n     * @param newDeprecationStableCoin New stable coin.\n     */\n    function setDeprecationStableCoin(IERC20 newDeprecationStableCoin)\n        external\n        override\n        onlyRole(Roles.KUMA_MANAGER_ROLE)\n        whenNotDeprecated\n    {\n        if (address(newDeprecationStableCoin) == address(0)) {\n            revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\n        }\n        emit DeprecationStableCoinSet(address(_deprecationStableCoin), address(newDeprecationStableCoin));\n        _deprecationStableCoin = newDeprecationStableCoin;\n    }\n\n    /**\n     * @notice Initializes deprecation mode.\n     */\n    function initializeDeprecationMode() external override onlyRole(Roles.KUMA_MANAGER_ROLE) whenNotDeprecated {\n        if (_deprecationInitializedAt != 0) {\n            revert Errors.DEPRECATION_MODE_ALREADY_INITIALIZED();\n        }\n\n        _deprecationInitializedAt = uint56(block.timestamp);\n\n        emit DeprecationModeInitialized();\n    }\n\n    /**\n     * @notice Cancel the initialization of the deprecation mode.\n     */\n    function uninitializeDeprecationMode() external onlyRole(Roles.KUMA_MANAGER_ROLE) whenNotDeprecated {\n        if (_deprecationInitializedAt == 0) {\n            revert Errors.DEPRECATION_MODE_NOT_INITIALIZED();\n        }\n\n        _deprecationInitializedAt = 0;\n\n        emit DeprecationModeUninitialized();\n    }\n\n    /**\n     * @notice Enables deprecation.\n     * @dev Deprecation mode must have been initialized at least 2 days before through the initializeDeprecationMode function.\n     */\n    function enableDeprecationMode() external override onlyRole(Roles.KUMA_MANAGER_ROLE) whenNotDeprecated {\n        if (_deprecationInitializedAt == 0) {\n            revert Errors.DEPRECATION_MODE_NOT_INITIALIZED();\n        }\n\n        uint256 elapsedTime = block.timestamp - _deprecationInitializedAt;\n\n        if (elapsedTime < DEPRECATION_MODE_TIMELOCK) {\n            revert Errors.ELAPSED_TIME_SINCE_DEPRECATION_MODE_INITIALIZATION_TOO_SHORT(\n                elapsedTime, DEPRECATION_MODE_TIMELOCK\n            );\n        }\n\n        _isDeprecated = true;\n\n        IKIBToken(_KUMAAddressProvider.getKIBToken(_riskCategory)).refreshYield();\n\n        emit DeprecationModeEnabled();\n    }\n\n    /**\n     * @return _riskCategory risk category of the bonds accepted by the contract.\n     */\n    function getRiskCategory() external view returns (bytes32) {\n        return _riskCategory;\n    }\n\n    /**\n     * @return _maxCoupons Maximum amount of unique coupons accepted by the contract.\n     */\n    function getMaxCoupons() external view returns (uint16) {\n        return _maxCoupons;\n    }\n\n    /**\n     * @return _KUMAAddressProvider.\n     */\n    function getKUMAAddressProvider() external view returns (IKUMAAddressProvider) {\n        return _KUMAAddressProvider;\n    }\n\n    /**\n     * @return True if deprecation mode has been initialized false if not.\n     */\n    function isDeprecationInitialized() external view override returns (bool) {\n        return _deprecationInitializedAt != 0;\n    }\n\n    /**\n     * @return Timestamp of deprecation mode initialization.\n     */\n    function getDeprecationInitializedAt() external view override returns (uint56) {\n        return _deprecationInitializedAt;\n    }\n\n    /**\n     * @return True if deprecation mode has been enabled false if not.\n     */\n    function isDeprecated() external view override returns (bool) {\n        return _isDeprecated;\n    }\n\n    /**\n     * @return _varibaleFee Variable fee in basis points.\n     */\n    function getVariableFee() external view override returns (uint16) {\n        return _variableFee;\n    }\n\n    /**\n     * @return _deprecationStableCoin Accepted stable coin during deprecation mode.\n     */\n    function getDeprecationStableCoin() external view override returns (IERC20) {\n        return _deprecationStableCoin;\n    }\n\n    /**\n     * @return _fixedFee Fixed fee in KIBToken decimals.\n     */\n    function getFixedFee() external view override returns (uint256) {\n        return _fixedFee;\n    }\n\n    /**\n     * @return Lowest coupon of bonds in reserve.\n     */\n    function getMinCoupon() external view override returns (uint256) {\n        return _minCoupon;\n    }\n\n    /**\n     * @return Array of all coupons in reserve.\n     */\n    function getCoupons() external view override returns (uint256[] memory) {\n        return _coupons.values();\n    }\n\n    /**\n     * @return Array of all tokenIds in reserve.\n     */\n    function getBondReserve() external view override returns (uint256[] memory) {\n        return _bondReserve.values();\n    }\n\n    /**\n     * @return Array of all tokenIds in reserve.\n     */\n    function getExpiredBonds() external view override returns (uint256[] memory) {\n        return _expiredBonds.values();\n    }\n\n    /**\n     * @return CloneBond Id of parent tokenId.\n     */\n    function getCloneBond(uint256 tokenId) external view override returns (uint256) {\n        return _cloneBonds[tokenId];\n    }\n\n    /**\n     * @return Amount of bonds with coupon value in inventory.\n     */\n    function getCouponInventory(uint256 coupon) external view override returns (uint256) {\n        return _couponInventory[coupon];\n    }\n\n    /**\n     * @return True if bond is in reserve false if not.\n     */\n    function isInReserve(uint256 tokenId) external view override returns (bool) {\n        return _bondReserve.contains(tokenId);\n    }\n\n    /**\n     * @return True if reserve has an expired bond false if not.\n     */\n    function isExpired() external view override returns (bool) {\n        return _expiredBonds.length() > 0;\n    }\n\n    /**\n     * @return Bond base value.\n     */\n    function getBondBaseValue(uint256 tokenId) external view override returns (uint256) {\n        return _bondBaseValue[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data)\n        external\n        pure\n        override\n        returns (bytes4)\n    {\n        return IERC721Receiver.onERC721Received.selector;\n    }\n\n    function _authorizeUpgrade(address newImplementation) internal view override onlyRole(Roles.KUMA_MANAGER_ROLE) {}\n\n    /**\n     * @return bondValue Bond principal value + accrued interests.\n     */\n    function _getBondValue(uint256 issuance, uint256 term, uint256 coupon, uint256 principal)\n        private\n        view\n        returns (uint256)\n    {\n        uint256 previousEpochTimestamp =\n            IKIBToken(_KUMAAddressProvider.getKIBToken(_riskCategory)).getPreviousEpochTimestamp();\n\n        if (previousEpochTimestamp <= issuance) {\n            return principal;\n        }\n\n        uint256 elapsedTime = previousEpochTimestamp - issuance;\n\n        if (elapsedTime > term) {\n            elapsedTime = term;\n        }\n\n        return coupon.rayPow(elapsedTime).rayMul(principal);\n    }\n\n    /**\n     * @return minCoupon Lowest coupon of bonds in reserve.\n     */\n    function _updateMinCoupon() private returns (uint256) {\n        uint256 currentMinCoupon = _minCoupon;\n\n        if (_coupons.length() == 0) {\n            _minCoupon = MIN_ALLOWED_COUPON;\n            emit MinCouponUpdated(currentMinCoupon, MIN_ALLOWED_COUPON);\n            return MIN_ALLOWED_COUPON;\n        }\n\n        if (_couponInventory[currentMinCoupon] != 0) {\n            return currentMinCoupon;\n        }\n\n        uint256 minCoupon = _coupons.at(0);\n\n        for (uint256 i = 1; i < _coupons.length();) {\n            uint256 coupon = _coupons.at(i);\n\n            if (coupon < minCoupon) {\n                minCoupon = coupon;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        _minCoupon = minCoupon;\n\n        emit MinCouponUpdated(currentMinCoupon, minCoupon);\n\n        return minCoupon;\n    }\n\n    /**\n     * @return fee Based on a specific amount.\n     */\n    function _calculateFees(uint256 amount) private view returns (uint256 fee) {\n        if (_variableFee > 0) {\n            fee = amount.percentMul(_variableFee);\n        }\n        if (_fixedFee > 0) {\n            fee += _fixedFee;\n        }\n    }\n}"
    }
  ]
}