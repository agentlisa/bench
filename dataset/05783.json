{
  "Title": "[M-10] Incorrect flag results to `_hasFallbackToggled` always set to false on `createMultipleSettlement`.",
  "Content": "\nFunction `_hasFallbackToggled` would be set to false on `createMultipleSettlement` regardless of user intentions.\n\n### Proof of Concept\n\nUsers can specify if they want a fallback on their transaction, which prevents the transaction from reverting in case of failure. But due to an incorrect flag, this would always be set to false.\n\n<https://github.com/code-423n4/2023-09-maia/blob/main/src/RootBridgeAgent.sol#L1090>\n\n```solidity\nfunction _createSettlementMultiple(\n        uint32 _settlementNonce,\n        address payable _refundee,\n        address _recipient,\n        uint16 _dstChainId,\n        address[] memory _globalAddresses,\n        uint256[] memory _amounts,\n        uint256[] memory _deposits,\n        bytes memory _params,\n        bool _hasFallbackToggled\n    ) internal returns (bytes memory _payload) {\n        ...SNIP\n        // Prepare data for call with settlement of multiple assets\n        _payload = abi.encodePacked(\n@>          _hasFallbackToggled ? bytes1(0x02) & 0x0F : bytes1(0x02),\n            _recipient,\n            uint8(hTokens.length),\n            _settlementNonce,\n            hTokens,\n            tokens,\n            _amounts,\n            _deposits,\n            _params\n        );\n       ...SNIP\n    }\n```\n\nThe variable `_hasFallbackToggled` can be set to true or false depending whether the user wants a fallback or not.\n\nIf true, the value at the payload index 0 (`payload [0]`) would be set to `bytes1(0x02) & 0x0F` but this would still results to `bytes1(0x02)`; otherwise, false this would also results to `bytes1(0x02)`.\n\nOn the destination chain, to check for the fallback status of a transaction: \n\n<https://github.com/code-423n4/2023-09-maia/blob/main/src/BranchBridgeAgent.sol#L651>\n\n```solidity\nfunction lzReceiveNonBlocking(address _endpoint, bytes calldata _srcAddress, bytes calldata _payload)\n        public\n        override\n        requiresEndpoint(_endpoint, _srcAddress)\n    {\n\t...SNIP\n    // DEPOSIT FLAG: 2 (Multiple Settlement)\n        } else if (flag == 0x02) {\n            // Parse recipient\n            address payable recipient = payable(address(uint160(bytes20(_payload[PARAMS_START:PARAMS_START_SIGNED]))));\n\n            // Parse deposit nonce\n            nonce = uint32(bytes4(_payload[22:26]));\n\n            //Check if tx has already been executed\n            if (executionState[nonce] != STATUS_READY) revert AlreadyExecutedTransaction();\n\n            //Try to execute remote request\n            // Flag 2 - BranchBridgeAgentExecutor(bridgeAgentExecutorAddress).executeWithSettlementMultiple(recipient, localRouterAddress, _payload)\n            _execute(\n@>             _payload[0] == 0x82,\n                nonce,\n                recipient,\n                abi.encodeWithSelector(\n                    BranchBridgeAgentExecutor.executeWithSettlementMultiple.selector,\n                    recipient,\n                    localRouterAddress,\n                    _payload\n                )\n           );\n\t...SNIP\n}\n```\n\n`_payload[0] == 0x82` would always be false; irrespective of the fallback status chosen by the user.\n\nA simple test with chisel:\n\n```solidity\n➜ function checkToggle(bool hastoggle) public returns(bytes memory _payload) {\n_payload = abi.encodePacked(hastoggle ? bytes1(0x02) & 0x0F : bytes1(0x02));\n}\n➜ function test() public returns(bool) {\nbytes memory payload = checkToggle(true);\nreturn payload[0] == 0x82;\n}\n➜ bool check = test()\n➜ check\nType: bool\n└ Value: false//<@ should be true\n➜ function test2() public returns(bool) {\nbytes memory payload = checkToggle(false);\nreturn payload[0] == 0x82;\n}\n➜ check = test2()\nType: bool\n└ Value: false//<@ always false\n```\n\nThis would result to unexpected behaviors and issues with integrations.\n\n### Recommended Mitigation Steps\n\nChange the following line to:\n\n```diff\nfunction _createSettlementMultiple(\n        uint32 _settlementNonce,\n        address payable _refundee,\n        address _recipient,\n        uint16 _dstChainId,\n        address[] memory _globalAddresses,\n        uint256[] memory _amounts,\n        uint256[] memory _deposits,\n        bytes memory _params,\n        bool _hasFallbackToggled\n    ) internal returns (bytes memory _payload) {\n        // Check if valid length\n        if (_globalAddresses.length > MAX_TOKENS_LENGTH) revert InvalidInputParamsLength();\n\n        // Check if valid length\n        if (_globalAddresses.length != _amounts.length) revert InvalidInputParamsLength();\n        if (_amounts.length != _deposits.length) revert InvalidInputParamsLength();\n\n        //Update Settlement Nonce\n        settlementNonce = _settlementNonce + 1;\n\n        // Create Arrays\n        address[] memory hTokens = new address[](_globalAddresses.length);\n        address[] memory tokens = new address[](_globalAddresses.length);\n\n        for (uint256 i = 0; i < hTokens.length;) {\n            // Populate Addresses for Settlement\n            hTokens[i] = IPort(localPortAddress).getLocalTokenFromGlobal(_globalAddresses[i], _dstChainId);\n            tokens[i] = IPort(localPortAddress).getUnderlyingTokenFromLocal(hTokens[i], _dstChainId);\n\n            // Avoid stack too deep\n            uint16 destChainId = _dstChainId;\n\n            // Update State to reflect bridgeOut\n            _updateStateOnBridgeOut(\n                msg.sender, _globalAddresses[i], hTokens[i], tokens[i], _amounts[i], _deposits[i], destChainId\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Prepare data for call with settlement of multiple assets\n        _payload = abi.encodePacked(\n-           _hasFallbackToggled ? bytes1(0x02) & 0x0F : bytes1(0x02),\n+           _hasFallbackToggled ? bytes1(0x82) : bytes1(0x02),\n            _recipient,\n            uint8(hTokens.length),\n            _settlementNonce,\n            hTokens,\n            tokens,\n            _amounts,\n            _deposits,\n            _params\n        );\n\n        // Create and Save Settlement\n        // Get storage reference\n        Settlement storage settlement = getSettlement[_settlementNonce];\n\n        // Update Settlement\n        settlement.owner = _refundee;\n        settlement.recipient = _recipient;\n        settlement.hTokens = hTokens;\n        settlement.tokens = tokens;\n        settlement.amounts = _amounts;\n        settlement.deposits = _deposits;\n        settlement.dstChainId = _dstChainId;\n        settlement.status = STATUS_SUCCESS;\n    }\n```\n\n### Assessed type\n\nError\n\n**[0xLightt (Maia) confirmed](https://github.com/code-423n4/2023-09-maia-findings/issues/397#issuecomment-1787992354)**\n\n**[0xBugsy (Maia) commented](https://github.com/code-423n4/2023-09-maia-findings/issues/397#issuecomment-1807198522):**\n > Addressed [here](https://github.com/Maia-DAO/2023-09-maia-remediations/commit/4d2825cd4e73a69ad33bccaf2ceb07443f127beb).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-09-maia",
  "Code": [
    {
      "filename": "src/RootBridgeAgent.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ExcessivelySafeCall} from \"lib/ExcessivelySafeCall.sol\";\n\nimport {ILayerZeroEndpoint} from \"./interfaces/ILayerZeroEndpoint.sol\";\n\nimport {IBranchBridgeAgent} from \"./interfaces/IBranchBridgeAgent.sol\";\nimport {IERC20hTokenRoot} from \"./interfaces/IERC20hTokenRoot.sol\";\n\nimport {BridgeAgentConstants} from \"./interfaces/BridgeAgentConstants.sol\";\nimport {\n    GasParams,\n    DepositParams,\n    DepositMultipleParams,\n    ILayerZeroReceiver,\n    IRootBridgeAgent,\n    Settlement,\n    SettlementInput,\n    SettlementMultipleInput\n} from \"./interfaces/IRootBridgeAgent.sol\";\n\nimport {IRootPort as IPort} from \"./interfaces/IRootPort.sol\";\n\nimport {VirtualAccount} from \"./VirtualAccount.sol\";\nimport {DeployRootBridgeAgentExecutor, RootBridgeAgentExecutor} from \"./RootBridgeAgentExecutor.sol\";\n\n/// @title Root Bridge Agent Contract\n/// @author MaiaDAO\ncontract RootBridgeAgent is IRootBridgeAgent, BridgeAgentConstants {\n    using SafeTransferLib for address;\n    using ExcessivelySafeCall for address;\n    /*///////////////////////////////////////////////////////////////\n                        ROOT BRIDGE AGENT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Local Chain Id\n    uint16 public immutable localChainId;\n\n    /// @notice Bridge Agent Factory Address.\n    address public immutable factoryAddress;\n\n    /// @notice Local Core Root Router Address\n    address public immutable localRouterAddress;\n\n    /// @notice Local Port Address where funds deposited from this chain are stored.\n    address public immutable localPortAddress;\n\n    /// @notice Local Layer Zero Endpoint Address for cross-chain communication.\n    address public immutable lzEndpointAddress;\n\n    /// @notice Address of Root Bridge Agent Executor.\n    address public immutable bridgeAgentExecutorAddress;\n\n    /*///////////////////////////////////////////////////////////////\n                        BRANCH BRIDGE AGENTS STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Chain -> Branch Bridge Agent Address. For N chains, each Root Bridge Agent Address has M =< N Branch Bridge Agent Address.\n    mapping(uint256 chainId => address branchBridgeAgent) public getBranchBridgeAgent;\n\n    /// @notice Message Path for each connected Branch Bridge Agent as bytes for Layzer Zero interaction = localAddress + destinationAddress abi.encodePacked()\n    mapping(uint256 chainId => bytes branchBridgeAgentPath) public getBranchBridgeAgentPath;\n\n    /// @notice If true, bridge agent manager has allowed for a new given branch bridge agent to be synced/added.\n    mapping(uint256 chainId => bool allowed) public isBranchBridgeAgentAllowed;\n\n    /*///////////////////////////////////////////////////////////////\n                            SETTLEMENTS STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Deposit nonce used for identifying transaction.\n    uint32 public settlementNonce;\n\n    /// @notice Mapping from Settlement nonce to Settlement Struct.\n    mapping(uint256 nonce => Settlement settlementInfo) public getSettlement;\n\n    /*///////////////////////////////////////////////////////////////\n                            EXECUTOR STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice If true, bridge agent has already served a request with this nonce from  a given chain. Chain -> Nonce -> Bool\n    mapping(uint256 chainId => mapping(uint256 nonce => uint256 state)) public executionState;\n\n    /*///////////////////////////////////////////////////////////////\n                            REENTRANCY STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Re-entrancy lock modifier state.\n    uint256 internal _unlocked = 1;\n\n    /*///////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Constructor for Bridge Agent.\n     *     @param _localChainId Local Chain Id.\n     *     @param _lzEndpointAddress Local Layerzero Endpoint Address.\n     *     @param _localPortAddress Local Port Address.\n     *     @param _localRouterAddress Local Port Address.\n     */\n    constructor(\n        uint16 _localChainId,\n        address _lzEndpointAddress,\n        address _localPortAddress,\n        address _localRouterAddress\n    ) {\n        require(_lzEndpointAddress != address(0), \"Layerzero Enpoint Address cannot be zero address\");\n        require(_localPortAddress != address(0), \"Port Address cannot be zero address\");\n        require(_localRouterAddress != address(0), \"Router Address cannot be zero address\");\n\n        factoryAddress = msg.sender;\n        localChainId = _localChainId;\n        lzEndpointAddress = _lzEndpointAddress;\n        localPortAddress = _localPortAddress;\n        localRouterAddress = _localRouterAddress;\n        bridgeAgentExecutorAddress = DeployRootBridgeAgentExecutor.deploy(address(this));\n        settlementNonce = 1;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        FALLBACK FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    receive() external payable {}\n\n    /*///////////////////////////////////////////////////////////////\n                        VIEW EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootBridgeAgent\n    function getSettlementEntry(uint32 _settlementNonce) external view override returns (Settlement memory) {\n        return getSettlement[_settlementNonce];\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function getFeeEstimate(\n        uint256 _gasLimit,\n        uint256 _remoteBranchExecutionGas,\n        bytes calldata _payload,\n        uint16 _dstChainId\n    ) external view returns (uint256 _fee) {\n        (_fee,) = ILayerZeroEndpoint(lzEndpointAddress).estimateFees(\n            _dstChainId,\n            address(this),\n            _payload,\n            false,\n            abi.encodePacked(uint16(2), _gasLimit, _remoteBranchExecutionGas, getBranchBridgeAgent[_dstChainId])\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    ROOT ROUTER EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootBridgeAgent\n    function callOut(\n        address payable _refundee,\n        address _recipient,\n        uint16 _dstChainId,\n        bytes calldata _params,\n        GasParams calldata _gParams\n    ) external payable override lock requiresRouter {\n        //Encode Data for call.\n        bytes memory payload = abi.encodePacked(bytes1(0x00), _recipient, settlementNonce++, _params);\n\n        //Perform Call to clear hToken balance on destination branch chain.\n        _performCall(_dstChainId, _refundee, payload, _gParams);\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function callOutAndBridge(\n        address payable _refundee,\n        address _recipient,\n        uint16 _dstChainId,\n        bytes calldata _params,\n        SettlementInput calldata _sParams,\n        GasParams calldata _gParams,\n        bool _hasFallbackToggled\n    ) external payable override lock requiresRouter {\n        // Create Settlement and Perform call\n        bytes memory payload = _createSettlement(\n            settlementNonce,\n            _refundee,\n            _recipient,\n            _dstChainId,\n            _params,\n            _sParams.globalAddress,\n            _sParams.amount,\n            _sParams.deposit,\n            _hasFallbackToggled\n        );\n\n        //Perform Call.\n        _performCall(_dstChainId, _refundee, payload, _gParams);\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function callOutAndBridgeMultiple(\n        address payable _refundee,\n        address _recipient,\n        uint16 _dstChainId,\n        bytes calldata _params,\n        SettlementMultipleInput calldata _sParams,\n        GasParams calldata _gParams,\n        bool _hasFallbackToggled\n    ) external payable override lock requiresRouter {\n        // Create Settlement and Perform call\n        bytes memory payload = _createSettlementMultiple(\n            settlementNonce,\n            _refundee,\n            _recipient,\n            _dstChainId,\n            _sParams.globalAddresses,\n            _sParams.amounts,\n            _sParams.deposits,\n            _params,\n            _hasFallbackToggled\n        );\n\n        // Perform Call to destination Branch Chain.\n        _performCall(_dstChainId, _refundee, payload, _gParams);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    SETTLEMENT EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootBridgeAgent\n    function retrySettlement(\n        uint32 _settlementNonce,\n        address _recipient,\n        bytes calldata _params,\n        GasParams calldata _gParams,\n        bool _hasFallbackToggled\n    ) external payable override lock {\n        // Get storage reference\n        Settlement storage settlementReference = getSettlement[_settlementNonce];\n\n        // Check if Settlement hasn't been redeemed.\n        if (settlementReference.owner == address(0)) revert SettlementRetryUnavailable();\n\n        // Check if caller is Settlement owner\n        if (msg.sender != settlementReference.owner) {\n            if (msg.sender != address(IPort(localPortAddress).getUserAccount(settlementReference.owner))) {\n                revert NotSettlementOwner();\n            }\n        }\n\n        // Update Settlement Status\n        settlementReference.status = STATUS_SUCCESS;\n\n        // Perform Settlement Retry\n        _performRetrySettlementCall(\n            _hasFallbackToggled,\n            settlementReference.hTokens,\n            settlementReference.tokens,\n            settlementReference.amounts,\n            settlementReference.deposits,\n            _params,\n            _settlementNonce,\n            payable(settlementReference.owner),\n            _recipient,\n            settlementReference.dstChainId,\n            _gParams,\n            msg.value\n        );\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function retrieveSettlement(uint32 _settlementNonce, GasParams calldata _gParams) external payable lock {\n        //Get settlement storage reference\n        Settlement storage settlementReference = getSettlement[_settlementNonce];\n\n        // Get Settlement owner.\n        address settlementOwner = settlementReference.owner;\n\n        // Check if Settlement is Retrieve.\n        if (settlementOwner == address(0)) revert SettlementRetrieveUnavailable();\n\n        // Check Settlement Owner\n        if (msg.sender != settlementOwner) {\n            if (msg.sender != address(IPort(localPortAddress).getUserAccount(settlementOwner))) {\n                revert NotSettlementOwner();\n            }\n        }\n\n        //Encode Data for cross-chain call.\n        bytes memory payload = abi.encodePacked(bytes1(0x03), settlementOwner, _settlementNonce);\n\n        //Retrieve Deposit\n        _performCall(settlementReference.dstChainId, payable(settlementOwner), payload, _gParams);\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function redeemSettlement(uint32 _settlementNonce) external override lock {\n        // Get setttlement storage reference\n        Settlement storage settlement = getSettlement[_settlementNonce];\n\n        // Get deposit owner.\n        address settlementOwner = settlement.owner;\n\n        // Check if Settlement is redeemable.\n        if (settlement.status == STATUS_SUCCESS) revert SettlementRedeemUnavailable();\n        if (settlementOwner == address(0)) revert SettlementRedeemUnavailable();\n\n        // Check if Settlement Owner is msg.sender or msg.sender is the virtual account of the settlement owner.\n        if (msg.sender != settlementOwner) {\n            if (msg.sender != address(IPort(localPortAddress).getUserAccount(settlementOwner))) {\n                revert NotSettlementOwner();\n            }\n        }\n\n        // Clear Global hTokens To Recipient on Root Chain cancelling Settlement to Branch\n        for (uint256 i = 0; i < settlement.hTokens.length;) {\n            // Save to memory\n            address _hToken = settlement.hTokens[i];\n\n            // Check if asset\n            if (_hToken != address(0)) {\n                // Save to memory\n                uint24 _dstChainId = settlement.dstChainId;\n\n                // Move hTokens from Branch to Root + Mint Sufficient hTokens to match new port deposit\n                IPort(localPortAddress).bridgeToRoot(\n                    msg.sender,\n                    IPort(localPortAddress).getGlobalTokenFromLocal(_hToken, _dstChainId),\n                    settlement.amounts[i],\n                    settlement.deposits[i],\n                    _dstChainId\n                );\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Delete Settlement\n        delete getSettlement[_settlementNonce];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    TOKEN MANAGEMENT EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootBridgeAgent\n    function bridgeIn(address _recipient, DepositParams memory _dParams, uint256 _srcChainId)\n        public\n        override\n        requiresAgentExecutor\n    {\n        // Deposit can't be greater than amount.\n        if (_dParams.amount < _dParams.deposit) revert InvalidInputParams();\n\n        // Cache local port address\n        address _localPortAddress = localPortAddress;\n\n        // Check local exists.\n        if (_dParams.amount > 0) {\n            if (!IPort(_localPortAddress).isLocalToken(_dParams.hToken, _srcChainId)) {\n                revert InvalidInputParams();\n            }\n        }\n\n        // Check underlying exists.\n        if (_dParams.deposit > 0) {\n            if (IPort(_localPortAddress).getLocalTokenFromUnderlying(_dParams.token, _srcChainId) != _dParams.hToken) {\n                revert InvalidInputParams();\n            }\n        }\n\n        // Move hTokens from Branch to Root + Mint Sufficient hTokens to match new port deposit\n        IPort(_localPortAddress).bridgeToRoot(\n            _recipient,\n            IPort(_localPortAddress).getGlobalTokenFromLocal(_dParams.hToken, _srcChainId),\n            _dParams.amount,\n            _dParams.deposit,\n            _srcChainId\n        );\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function bridgeInMultiple(address _recipient, DepositMultipleParams calldata _dParams, uint256 _srcChainId)\n        external\n        override\n        requiresAgentExecutor\n    {\n        // Cache length\n        uint256 length = _dParams.hTokens.length;\n\n        // Check MAX_LENGTH\n        if (length > MAX_TOKENS_LENGTH) revert InvalidInputParams();\n\n        // Bridge in assets\n        for (uint256 i = 0; i < length;) {\n            bridgeIn(\n                _recipient,\n                DepositParams({\n                    hToken: _dParams.hTokens[i],\n                    token: _dParams.tokens[i],\n                    amount: _dParams.amounts[i],\n                    deposit: _dParams.deposits[i],\n                    depositNonce: 0\n                }),\n                _srcChainId\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    LAYER ZERO EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ILayerZeroReceiver\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64, bytes calldata _payload) public {\n        (bool success,) = address(this).excessivelySafeCall(\n            gasleft(),\n            150,\n            abi.encodeWithSelector(this.lzReceiveNonBlocking.selector, msg.sender, _srcChainId, _srcAddress, _payload)\n        );\n\n        if (!success) if (msg.sender == getBranchBridgeAgent[localChainId]) revert ExecutionFailure();\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function lzReceiveNonBlocking(\n        address _endpoint,\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        bytes calldata _payload\n    ) public override requiresEndpoint(_endpoint, _srcChainId, _srcAddress) {\n        // Deposit Nonce\n        uint32 nonce;\n\n        // DEPOSIT FLAG: 0 (System request / response)\n        if (_payload[0] == 0x00) {\n            // Parse deposit nonce\n            nonce = uint32(bytes4(_payload[PARAMS_START:PARAMS_TKN_START]));\n\n            // Check if tx has already been executed\n            if (executionState[_srcChainId][nonce] != STATUS_READY) {\n                revert AlreadyExecutedTransaction();\n            }\n\n            // Avoid stack too deep\n            uint16 srcChainId = _srcChainId;\n\n            // Try to execute remote request\n            // Flag 0 - RootBridgeAgentExecutor(bridgeAgentExecutorAddress).executeSystemRequest(_localRouterAddress, _payload, _srcChainId)\n            _execute(\n                nonce,\n                abi.encodeWithSelector(\n                    RootBridgeAgentExecutor.executeSystemRequest.selector, localRouterAddress, _payload, srcChainId\n                ),\n                srcChainId\n            );\n\n            // DEPOSIT FLAG: 1 (Call without Deposit)\n        } else if (_payload[0] == 0x01) {\n            // Parse Deposit Nonce\n            nonce = uint32(bytes4(_payload[PARAMS_START:PARAMS_TKN_START]));\n\n            // Check if tx has already been executed\n            if (executionState[_srcChainId][nonce] != STATUS_READY) {\n                revert AlreadyExecutedTransaction();\n            }\n\n            // Avoid stack too deep\n            uint16 srcChainId = _srcChainId;\n\n            // Try to execute remote request\n            // Flag 1 - RootBridgeAgentExecutor(bridgeAgentExecutorAddress).executeNoDeposit(localRouterAddress, payload, _srcChainId)\n            _execute(\n                nonce,\n                abi.encodeWithSelector(\n                    RootBridgeAgentExecutor.executeNoDeposit.selector, localRouterAddress, _payload, srcChainId\n                ),\n                srcChainId\n            );\n\n            // DEPOSIT FLAG: 2 (Call with Deposit)\n        } else if (_payload[0] == 0x02) {\n            //Parse Deposit Nonce\n            nonce = uint32(bytes4(_payload[PARAMS_START:PARAMS_TKN_START]));\n\n            //Check if tx has already been executed\n            if (executionState[_srcChainId][nonce] != STATUS_READY) {\n                revert AlreadyExecutedTransaction();\n            }\n\n            // Avoid stack too deep\n            uint16 srcChainId = _srcChainId;\n\n            // Try to execute remote request\n            // Flag 2 - RootBridgeAgentExecutor(bridgeAgentExecutorAddress).executeWithDeposit(localRouterAddress, _payload, _srcChainId)\n            _execute(\n                nonce,\n                abi.encodeWithSelector(\n                    RootBridgeAgentExecutor.executeWithDeposit.selector, localRouterAddress, _payload, srcChainId\n                ),\n                srcChainId\n            );\n\n            // DEPOSIT FLAG: 3 (Call with multiple asset Deposit)\n        } else if (_payload[0] == 0x03) {\n            // Parse deposit nonce\n            nonce = uint32(bytes4(_payload[2:6]));\n\n            // Check if tx has already been executed\n            if (executionState[_srcChainId][nonce] != STATUS_READY) {\n                revert AlreadyExecutedTransaction();\n            }\n\n            // Avoid stack too deep\n            uint16 srcChainId = _srcChainId;\n\n            // Try to execute remote request\n            // Flag 3 - RootBridgeAgentExecutor(bridgeAgentExecutorAddress).executeWithDepositMultiple(localRouterAddress, _payload, _srcChainId)\n            _execute(\n                nonce,\n                abi.encodeWithSelector(\n                    RootBridgeAgentExecutor.executeWithDepositMultiple.selector,\n                    localRouterAddress,\n                    _payload,\n                    srcChainId\n                ),\n                srcChainId\n            );\n\n            // DEPOSIT FLAG: 4 (Call without Deposit + msg.sender)\n        } else if (_payload[0] == 0x04) {\n            // Parse deposit nonce\n            nonce = uint32(bytes4(_payload[PARAMS_START_SIGNED:PARAMS_TKN_START_SIGNED]));\n\n            //Check if tx has already been executed\n            if (executionState[_srcChainId][nonce] != STATUS_READY) {\n                revert AlreadyExecutedTransaction();\n            }\n\n            // Get User Virtual Account\n            VirtualAccount userAccount = IPort(localPortAddress).fetchVirtualAccount(\n                address(uint160(bytes20(_payload[PARAMS_START:PARAMS_START_SIGNED])))\n            );\n\n            // Toggle Router Virtual Account use for tx execution\n            IPort(localPortAddress).toggleVirtualAccountApproved(userAccount, localRouterAddress);\n\n            // Avoid stack too deep\n            uint16 srcChainId = _srcChainId;\n\n            // Try to execute remote request\n            // Flag 4 - RootBridgeAgentExecutor(bridgeAgentExecutorAddress).executeSignedNoDeposit(address(userAccount), localRouterAddress, data, _srcChainId\n            _execute(\n                nonce,\n                abi.encodeWithSelector(\n                    RootBridgeAgentExecutor.executeSignedNoDeposit.selector,\n                    address(userAccount),\n                    localRouterAddress,\n                    _payload,\n                    srcChainId\n                ),\n                srcChainId\n            );\n\n            // Toggle Router Virtual Account use for tx execution\n            IPort(localPortAddress).toggleVirtualAccountApproved(userAccount, localRouterAddress);\n\n            //DEPOSIT FLAG: 5 (Call with Deposit + msg.sender)\n        } else if (_payload[0] & 0x7F == 0x05) {\n            // Parse deposit nonce\n            nonce = uint32(bytes4(_payload[PARAMS_START_SIGNED:PARAMS_TKN_START_SIGNED]));\n\n            //Check if tx has already been executed\n            if (executionState[_srcChainId][nonce] != STATUS_READY) {\n                revert AlreadyExecutedTransaction();\n            }\n\n            // Get User Virtual Account\n            VirtualAccount userAccount = IPort(localPortAddress).fetchVirtualAccount(\n                address(uint160(bytes20(_payload[PARAMS_START:PARAMS_START_SIGNED])))\n            );\n\n            // Toggle Router Virtual Account use for tx execution\n            IPort(localPortAddress).toggleVirtualAccountApproved(userAccount, localRouterAddress);\n\n            // Avoid stack too deep\n            uint16 srcChainId = _srcChainId;\n\n            // Try to execute remote request\n            // Flag 5 - RootBridgeAgentExecutor(bridgeAgentExecutorAddress).executeSignedWithDeposit(address(userAccount), localRouterAddress, data, _srcChainId)\n            _execute(\n                _payload[0] == 0x85,\n                nonce,\n                address(uint160(bytes20(_payload[PARAMS_START:PARAMS_START_SIGNED]))),\n                abi.encodeWithSelector(\n                    RootBridgeAgentExecutor.executeSignedWithDeposit.selector,\n                    address(userAccount),\n                    localRouterAddress,\n                    _payload,\n                    srcChainId\n                ),\n                srcChainId\n            );\n\n            // Toggle Router Virtual Account use for tx execution\n            IPort(localPortAddress).toggleVirtualAccountApproved(userAccount, localRouterAddress);\n\n            // DEPOSIT FLAG: 6 (Call with multiple asset Deposit + msg.sender)\n        } else if (_payload[0] & 0x7F == 0x06) {\n            // Parse deposit nonce\n            nonce = uint32(bytes4(_payload[PARAMS_START_SIGNED + PARAMS_START:PARAMS_START_SIGNED + PARAMS_TKN_START]));\n\n            // Check if tx has already been executed\n            if (executionState[_srcChainId][nonce] != STATUS_READY) {\n                revert AlreadyExecutedTransaction();\n            }\n\n            // Get User Virtual Account\n            VirtualAccount userAccount = IPort(localPortAddress).fetchVirtualAccount(\n                address(uint160(bytes20(_payload[PARAMS_START:PARAMS_START_SIGNED])))\n            );\n\n            // Toggle Router Virtual Account use for tx execution\n            IPort(localPortAddress).toggleVirtualAccountApproved(userAccount, localRouterAddress);\n\n            // Avoid stack too deep\n            uint16 srcChainId = _srcChainId;\n\n            // Try to execute remote request\n            // Flag 6 - RootBridgeAgentExecutor(bridgeAgentExecutorAddress).executeSignedWithDepositMultiple(address(userAccount), localRouterAddress, data, _srcChainId)\n            _execute(\n                _payload[0] == 0x86,\n                nonce,\n                address(uint160(bytes20(_payload[PARAMS_START:PARAMS_START_SIGNED]))),\n                abi.encodeWithSelector(\n                    RootBridgeAgentExecutor.executeSignedWithDepositMultiple.selector,\n                    address(userAccount),\n                    localRouterAddress,\n                    _payload,\n                    srcChainId\n                ),\n                srcChainId\n            );\n\n            // Toggle Router Virtual Account use for tx execution\n            IPort(localPortAddress).toggleVirtualAccountApproved(userAccount, localRouterAddress);\n\n            /// DEPOSIT FLAG: 7 (retrySettlement)\n        } else if (_payload[0] & 0x7F == 0x07) {\n            // Prepare Variables for decoding\n            address owner;\n            bytes memory params;\n            GasParams memory gParams;\n\n            // Decode Input\n            (nonce, owner, params, gParams) = abi.decode(_payload[PARAMS_START:], (uint32, address, bytes, GasParams));\n\n            // Get storage reference\n            Settlement storage settlementReference = getSettlement[nonce];\n\n            // Check if Settlement hasn't been redeemed.\n            if (settlementReference.owner == address(0)) revert SettlementRetryUnavailable();\n\n            // Check settlement owner\n            if (owner != settlementReference.owner) {\n                if (owner != address(IPort(localPortAddress).getUserAccount(settlementReference.owner))) {\n                    revert NotSettlementOwner();\n                }\n            }\n\n            //Update Settlement Staus\n            settlementReference.status = STATUS_SUCCESS;\n\n            //Retry settlement call with new params and gas\n            _performRetrySettlementCall(\n                _payload[0] == 0x87,\n                settlementReference.hTokens,\n                settlementReference.tokens,\n                settlementReference.amounts,\n                settlementReference.deposits,\n                params,\n                nonce,\n                payable(settlementReference.owner),\n                settlementReference.recipient,\n                settlementReference.dstChainId,\n                gParams,\n                address(this).balance\n            );\n\n            /// DEPOSIT FLAG: 8 (retrieveDeposit)\n        } else if (_payload[0] == 0x08) {\n            //Parse deposit nonce\n            nonce = uint32(bytes4(_payload[PARAMS_START_SIGNED:PARAMS_TKN_START_SIGNED]));\n\n            //Check if deposit is in retrieve mode\n            if (executionState[_srcChainId][nonce] == STATUS_DONE) {\n                revert AlreadyExecutedTransaction();\n            } else {\n                //Set settlement to retrieve mode, if not already set.\n                if (executionState[_srcChainId][nonce] == STATUS_READY) {\n                    executionState[_srcChainId][nonce] = STATUS_RETRIEVE;\n                }\n                //Trigger fallback/Retry failed fallback\n                _performFallbackCall(\n                    payable(address(uint160(bytes20(_payload[PARAMS_START:PARAMS_START_SIGNED])))), nonce, _srcChainId\n                );\n            }\n\n            //DEPOSIT FLAG: 9 (Fallback)\n        } else if (_payload[0] == 0x09) {\n            // Parse nonce\n            nonce = uint32(bytes4(_payload[PARAMS_START:PARAMS_TKN_START]));\n\n            // Reopen Settlement for redemption\n            getSettlement[nonce].status = STATUS_FAILED;\n\n            // Emit LogFallback\n            emit LogFallback(nonce, _srcChainId);\n\n            // return to prevent unnecessary emits/logic\n            return;\n\n            // Unrecognized Function Selector\n        } else {\n            revert UnknownFlag();\n        }\n\n        emit LogExecute(nonce, _srcChainId);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                DEPOSIT EXECUTION INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Internal function requests execution from Root Bridge Agent Executor Contract.\n     *   @param _depositNonce Identifier for nonce being executed.\n     *   @param _calldata Payload of message to be executed by the Root Bridge Agent Executor Contract.\n     *   @param _srcChainId Chain ID of source chain where request originates from.\n     */\n    function _execute(uint256 _depositNonce, bytes memory _calldata, uint16 _srcChainId) private {\n        //Update tx state as executed\n        executionState[_srcChainId][_depositNonce] = STATUS_DONE;\n\n        //Try to execute the remote request\n        (bool success,) = bridgeAgentExecutorAddress.call{value: address(this).balance}(_calldata);\n\n        // No fallback is requested revert allowing for retry.\n        if (!success) revert ExecutionFailure();\n    }\n\n    /**\n     * @notice Internal function requests execution from Root Bridge Agent Executor Contract.\n     *   @param _hasFallbackToggled if true, fallback on execution failure is toggled on.\n     *   @param _depositNonce Identifier for nonce being executed.\n     *   @param _refundee address to refund gas to in case of fallback being triggered.\n     *   @param _calldata Calldata to be executed by the Root Bridge Agent Executor Contract.\n     *   @param _srcChainId Chain ID of source chain where request originates from.\n     */\n    function _execute(\n        bool _hasFallbackToggled,\n        uint32 _depositNonce,\n        address _refundee,\n        bytes memory _calldata,\n        uint16 _srcChainId\n    ) private {\n        //Update tx state as executed\n        executionState[_srcChainId][_depositNonce] = STATUS_DONE;\n\n        //Try to execute the remote request\n        (bool success,) = bridgeAgentExecutorAddress.call{value: address(this).balance}(_calldata);\n\n        //Update tx state if execution failed\n        if (!success) {\n            //Read the fallback flag.\n            if (_hasFallbackToggled) {\n                // Update tx state as retrieve only\n                executionState[_srcChainId][_depositNonce] = STATUS_RETRIEVE;\n                // Perform the fallback call\n                _performFallbackCall(payable(_refundee), _depositNonce, _srcChainId);\n            } else {\n                // No fallback is requested revert allowing for retry.\n                revert ExecutionFailure();\n            }\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    LAYER ZERO INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Internal function performs call to Layer Zero Endpoint Contract for cross-chain messaging.\n     *   @param _refundee address to refund excess gas to.\n     *   @param _dstChainId Layer Zero Chain ID of destination chain.\n     *   @param _payload Payload of message to be sent to Layer Zero Endpoint Contract.\n     *   @param _gParams Gas parameters for cross-chain message execution.\n     */\n\n    function _performCall(\n        uint16 _dstChainId,\n        address payable _refundee,\n        bytes memory _payload,\n        GasParams calldata _gParams\n    ) internal {\n        // Get destination Branch Bridge Agent\n        address callee = getBranchBridgeAgent[_dstChainId];\n\n        // Check if valid destination\n        if (callee == address(0)) revert UnrecognizedBridgeAgent();\n\n        // Check if call to remote chain\n        if (_dstChainId != localChainId) {\n            //Sends message to Layerzero Enpoint\n            ILayerZeroEndpoint(lzEndpointAddress).send{value: msg.value}(\n                _dstChainId,\n                getBranchBridgeAgentPath[_dstChainId],\n                _payload,\n                _refundee,\n                address(0),\n                abi.encodePacked(uint16(2), _gP"
    }
  ]
}