{
  "Title": "[L-05] `initialize` functions can be front-run",
  "Content": "\nSee [this](https://github.com/code-423n4/2021-10-badgerdao-findings/issues/40) finding from a prior badger-dao contest for details\n\n1.  File: src/CitadelMinter.sol (line [109](https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/CitadelMinter.sol#L109))\n\n```solidity\n    function initialize(\n```\n\n2.  File: src/KnightingRound.sol (line [119](https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/KnightingRound.sol#L119))\n\n```solidity\n    ) external initializer {\n```\n\n3.  File: src/Funding.sol (line [112](https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/Funding.sol#L112))\n\n```solidity\n    ) external initializer {\n```\n\n4.  File: src/StakedCitadel.sol (line [179](https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/StakedCitadel.sol#L179))\n\n```solidity\n    ) public initializer whenNotPaused {\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-04-badger-citadel-contest",
  "Code": [
    {
      "filename": "src/CitadelMinter.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\nimport {IERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {AddressUpgradeable} from \"openzeppelin-contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {EnumerableSetUpgradeable} from \"openzeppelin-contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\n\nimport \"./lib/GlobalAccessControlManaged.sol\";\n\nimport \"./interfaces/citadel/ISupplySchedule.sol\";\nimport \"./interfaces/citadel/ICitadelToken.sol\";\nimport \"./interfaces/badger/IVault.sol\";\nimport \"./interfaces/citadel/IStakedCitadelLocker.sol\";\n\n/**\nSupply schedules are defined in terms of Epochs\n*/\ncontract CitadelMinter is\n    GlobalAccessControlManaged,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    bytes32 public constant CONTRACT_GOVERNANCE_ROLE =\n        keccak256(\"CONTRACT_GOVERNANCE_ROLE\");\n    bytes32 public constant POLICY_OPERATIONS_ROLE =\n        keccak256(\"POLICY_OPERATIONS_ROLE\");\n\n    ICitadelToken public citadelToken;\n    IVault public xCitadel;\n    IStakedCitadelLocker public xCitadelLocker;\n    ISupplySchedule public supplySchedule;\n\n    uint256 public lastMintTimestamp;\n\n    uint256 constant MAX_BPS = 10000;\n\n    EnumerableSetUpgradeable.AddressSet internal fundingPools;\n    mapping(address => uint256) public fundingPoolWeights;\n    uint256 public totalFundingPoolWeight;\n\n    uint256 public fundingBps;\n    uint256 public stakingBps;\n    uint256 public lockingBps;\n\n    /// ==================\n    /// ===== Events =====\n    /// ==================\n\n    event FundingPoolWeightSet(\n        address pool,\n        uint256 weight,\n        uint256 totalFundingPoolWeight\n    );\n    event CitadelDistributionSplitSet(\n        uint256 fundingBps,\n        uint256 stakingBps,\n        uint256 lockingBps\n    );\n    event CitadelDistribution(\n        uint256 fundingAmount,\n        uint256 stakingAmount,\n        uint256 lockingAmount\n    );\n\n    event CitadelDistributionToFunding(\n        uint256 startTime,\n        uint256 endTime,\n        uint256 citadelAmount\n    );\n    event CitadelDistributionToFundingPool(\n        uint256 startTime,\n        uint256 endTime,\n        address pool,\n        uint256 citadelAmount\n    );\n    event CitadelDistributionToStaking(\n        uint256 startTime,\n        uint256 endTime,\n        uint256 citadelAmount\n    );\n    event CitadelDistributionToLocking(\n        uint256 startTime,\n        uint256 endTime,\n        uint256 citadelAmount,\n        uint256 xCitadelAmount\n    );\n\n    /// =======================\n    /// ===== Initializer =====\n    /// =======================\n\n    /**\n     * @notice Initializer\n     * @dev this contract must have the rights to mint the citadel token to function correctly\n     * @dev this contract is intended to be the only way citadel is minted, with the expection of the initial minting event\n     * @param _gac global access control which is pinged to allow / deny access to permissioned calls by role\n     * @param _citadelToken citadel token\n     * @param _xCitadel staked citadel\n     * @param _xCitadelLocker staked citadel locker\n     * @param _supplySchedule contract that determines how much citadel to mint at a given time\n     */\n    function initialize(\n        address _gac,\n        address _citadelToken,\n        address _xCitadel,\n        address _xCitadelLocker,\n        address _supplySchedule\n    ) external initializer {\n        require(_gac != address(0), \"address 0 invalid\");\n        require(_citadelToken != address(0), \"address 0 invalid\");\n        require(_xCitadel != address(0), \"address 0 invalid\");\n        require(_xCitadelLocker != address(0), \"address 0 invalid\");\n        require(_supplySchedule != address(0), \"address 0 invalid\");\n\n        __GlobalAccessControlManaged_init(_gac);\n        __ReentrancyGuard_init();\n\n        citadelToken = ICitadelToken(_citadelToken);\n        xCitadel = IVault(_xCitadel);\n        xCitadelLocker = IStakedCitadelLocker(_xCitadelLocker);\n\n        supplySchedule = ISupplySchedule(_supplySchedule);\n\n        // Approve xCitadel vault for use of citadel tokens\n        // NOTE: Using input params as those cost 3 to read vs 100 from storage\n        IERC20Upgradeable(_citadelToken).safeApprove(_xCitadel, type(uint256).max);\n\n        // Approve xCitadel for locker to use\n        IERC20Upgradeable(_xCitadel).safeApprove(_xCitadelLocker, type(uint256).max);\n    }\n\n    /// =======================\n    /// ===== Public view =====\n    /// =======================\n\n    function getFundingPoolWeights()\n        external\n        view\n        returns (address[] memory pools, uint256[] memory weights)\n    {\n        uint256 numPools = fundingPools.length();\n        pools = new address[](numPools);\n        weights = new uint256[](numPools);\n\n        for (uint256 i = 0; i < numPools; i++) {\n            address pool = fundingPools.at(i);\n            uint256 weight = fundingPoolWeights[pool];\n\n            pools[i] = pool;\n            weights[i] = weight;\n        }\n    }\n\n    /// ==============================\n    /// ===== Policy Ops actions =====\n    /// ==============================\n\n    /**\n     * @notice Update the state of citadel emissions by minting and distributing citadel tokens according to the emission schedule and proportional splits between destinations (e.g. funding pools, stakers, lockers)\n     * @dev In theory this call should be permissionless, and after sufficient security analysis this may be changed to be the case\n     */\n    function mintAndDistribute()\n        external\n        onlyRole(POLICY_OPERATIONS_ROLE)\n        gacPausable\n        nonReentrant\n    {\n        uint256 cachedLastMintTimestamp = lastMintTimestamp;\n\n        uint256 mintable = supplySchedule.getMintable(cachedLastMintTimestamp);\n        citadelToken.mint(address(this), mintable);\n\n        uint256 lockingAmount = 0;\n        uint256 stakingAmount = 0;\n        uint256 fundingAmount = 0;\n\n        // 3 gas to store + 3 to read\n        // Saves 100 gas for each time we xCitadel\n        IVault cachedXCitadel = xCitadel;\n\n        // Saves gas below if true\n        uint256 cachedLockingBps = lockingBps;\n        if (cachedLockingBps != 0) {\n            lockingAmount = (mintable * cachedLockingBps) / MAX_BPS;\n\n            uint256 beforeAmount = cachedXCitadel.balanceOf(address(this));\n\n            IVault(cachedXCitadel).deposit(lockingAmount);\n\n            uint256 afterAmount = cachedXCitadel.balanceOf(address(this));\n\n            uint256 xCitadelToLockers = afterAmount - beforeAmount;\n\n            xCitadelLocker.notifyRewardAmount(\n                address(cachedXCitadel),\n                xCitadelToLockers\n            );\n            emit CitadelDistributionToLocking(\n                cachedLastMintTimestamp,\n                block.timestamp,\n                lockingAmount,\n                xCitadelToLockers\n            );\n        }\n\n        uint256 cachedStakingBps = stakingBps;\n        if (cachedStakingBps != 0) {\n            stakingAmount = (mintable * cachedStakingBps) / MAX_BPS;\n\n            IERC20Upgradeable(address(citadelToken)).safeTransfer(address(cachedXCitadel), stakingAmount);\n            emit CitadelDistributionToStaking(\n                cachedLastMintTimestamp,\n                block.timestamp,\n                stakingAmount\n            );\n        }\n\n        /// Saves gas if the if is true, if it's not costs 6 extra gas\n        uint256 cachedFundingBps = fundingBps;\n        if (cachedFundingBps != 0) {\n            fundingAmount = (mintable * cachedFundingBps) / MAX_BPS;\n\n            _transferToFundingPools(fundingAmount);\n            emit CitadelDistributionToFunding(\n                cachedLastMintTimestamp,\n                block.timestamp,\n                fundingAmount\n            );\n        }\n\n        emit CitadelDistribution(fundingAmount, stakingAmount, lockingAmount);\n\n        lastMintTimestamp = block.timestamp;\n    }\n\n    /**\n     * @notice Set the funding weight for a given address.\n     * @dev If the pool does not exist and is assigned a weight\n     * @dev Setting the funding pool weight to 0 for an existing pool will delete it from the set\n     * @param _pool Address of funding pool contract to add\n     * @param _weight Weight to give to pool. Must be between 0 and 10000, inclusive\n     */\n    function setFundingPoolWeight(address _pool, uint256 _weight)\n        external\n        onlyRole(POLICY_OPERATIONS_ROLE)\n        gacPausable\n        nonReentrant\n    {\n        require(\n            address(_pool) != address(0),\n            \"CitadelMinter: address(0) check\"\n        );\n\n        bool poolExists = fundingPools.contains(_pool);\n\n        // NOTE: Could cachedTotalFundingPoolWeight but honestly logic is already messy enough\n\n        // Remove existing pool on 0 weight\n        if (_weight == 0 && poolExists) {\n            _removeFundingPool(_pool);\n\n            emit FundingPoolWeightSet(_pool, _weight, totalFundingPoolWeight);\n        } else if (_weight > 0) {\n            // Add new pool or modify existing pool\n            require(_weight <= 10000, \"exceed max funding pool weight\");\n            if (!poolExists) {\n                _addFundingPool(_pool);\n            }\n            uint256 _newTotalWeight = totalFundingPoolWeight;\n            _newTotalWeight = _newTotalWeight - fundingPoolWeights[_pool];\n            fundingPoolWeights[_pool] = _weight;\n            _newTotalWeight = _newTotalWeight + _weight;\n            totalFundingPoolWeight = _newTotalWeight;\n\n            emit FundingPoolWeightSet(_pool, _weight, _newTotalWeight);\n        }\n    }\n\n    /**\n     * @notice Set the proportions of newly minted citadel to go to funding pools, stakers, and lockers on mintAndDistribute() calls\n     * @dev This is decided according to the treasury / marketcap logic outlined in the tokenomics, and is intended to be automated on-chain when safe\n     * @dev Sum of basis point values supplied must exactly equal 10000 (100%)\n     * @param _fundingBps Percentage of newly minted citadel to be allocated to funding pools, in basis points\n     * @param _stakingBps Percentage of newly minted citadel to be allocated to stakers as auto-compounding xCitadel rewards, in basis points\n     * @param _lockingBps Percentage of newly minted citadel to be allocated to lockers as emitted xCitadel rewards, in basis points\n     */\n    function setCitadelDistributionSplit(\n        uint256 _fundingBps,\n        uint256 _stakingBps,\n        uint256 _lockingBps\n    ) external onlyRole(POLICY_OPERATIONS_ROLE) gacPausable nonReentrant {\n        require(\n            _fundingBps + _stakingBps + _lockingBps == MAX_BPS,\n            \"CitadelMinter: Sum of propvalues must be 10000 bps\"\n        );\n        fundingBps = _fundingBps;\n        stakingBps = _stakingBps;\n        lockingBps = _lockingBps;\n\n        emit CitadelDistributionSplitSet(_fundingBps, _stakingBps, _lockingBps);\n    }\n\n    /// ==============================\n    /// ===== Governance actions =====\n    /// ==============================\n\n    function initializeLastMintTimestamp()\n        external\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n        gacPausable\n    {\n        require(\n            lastMintTimestamp == 0,\n            \"CitadelMinter: last mint timestamp already initialized\"\n        );\n        uint256 globalStartTimestamp = ISupplySchedule(supplySchedule)\n            .globalStartTimestamp();\n\n        require(\n            globalStartTimestamp != 0,\n            \"CitadelMinter: supply schedule start not initialized\"\n        );\n        lastMintTimestamp = globalStartTimestamp;\n    }\n\n    /// ==============================\n    /// ===== Internal Functions =====\n    /// ==============================\n\n    // === Funding Pool Management ===\n    function _transferToFundingPools(uint256 _citadelAmount) internal {\n        uint256 length = fundingPools.length();\n        // Use cached to save 96 gas per loop read\n        uint256 cachedTotalFundingPoolWeight = totalFundingPoolWeight;\n\n        require(length > 0, \"CitadelMinter: no funding pools\");\n        for (uint256 i; i < length; ++i) {\n            address pool = fundingPools.at(i);\n            uint256 weight = fundingPoolWeights[pool];\n\n            uint256 amount = (_citadelAmount * weight) /\n                cachedTotalFundingPoolWeight;\n\n            IERC20Upgradeable(address(citadelToken)).safeTransfer(pool, amount);\n\n            emit CitadelDistributionToFundingPool(\n                lastMintTimestamp,\n                block.timestamp,\n                pool,\n                amount\n            );\n        }\n    }\n\n    function _removeFundingPool(address _pool) internal {\n        uint256 currentPoolWeight = fundingPoolWeights[_pool];\n        totalFundingPoolWeight = totalFundingPoolWeight - currentPoolWeight;\n\n        fundingPoolWeights[_pool] = 0;\n\n        require(\n            fundingPools.remove(_pool),\n            \"CitadelMinter: funding pool does not exist for removal\"\n        );\n    }\n\n    function _addFundingPool(address _pool) internal {\n        require(\n            fundingPools.add(_pool),\n            \"CitadelMinter: funding pool already exists\"\n        );\n    }\n}"
    },
    {
      "filename": "src/KnightingRound.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {ERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./interfaces/badger/IBadgerVipGuestlist.sol\";\nimport \"./lib/GlobalAccessControlManaged.sol\";\n\n/**\n * @title Citadel Knighting Round\n * @notice Sells citadel at a predetermined price to whitelisted buyers. Citadel tokens are not distributed until the finalize event.\n * TODO: Better revert strings\n */\ncontract KnightingRound is GlobalAccessControlManaged, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for ERC20Upgradeable;\n\n    bytes32 public constant CONTRACT_GOVERNANCE_ROLE =\n        keccak256(\"CONTRACT_GOVERNANCE_ROLE\");\n    bytes32 public constant TREASURY_GOVERNANCE_ROLE =\n        keccak256(\"TREASURY_GOVERNANCE_ROLE\");\n\n    bytes32 public constant TECH_OPERATIONS_ROLE =\n        keccak256(\"TECH_OPERATIONS_ROLE\");\n    bytes32 public constant TREASURY_OPERATIONS_ROLE =\n        keccak256(\"TREASURY_OPERATIONS_ROLE\");\n\n    /// token to give out (CTDL)\n    ERC20Upgradeable public tokenOut;\n    /// token to take in WBTC / bibbtc LP / CVX / bveCVX\n    ERC20Upgradeable public tokenIn;\n    /// time when tokens can be first purchased\n    uint256 public saleStart;\n    /// duration of the token sale, cannot purchase afterwards\n    uint256 public saleDuration;\n    /// address receiving the proceeds of the sale - will be citadel multisig\n    address public saleRecipient;\n    /// whether the sale has been finalized\n    bool public finalized;\n\n    /// tokenIn per tokenOut price\n    /// eg. 1 WBTC (8 decimals) = 40,000 CTDL ==> price = 10^8 / 40,000\n    uint256 public tokenOutPrice;\n\n    /// Amounts bought by accounts\n    mapping(address => uint256) public boughtAmounts;\n    /// Whether an account has claimed tokens\n    /// NOTE: can reset boughtAmounts after a claim to optimize gas\n    ///       but we need to persist boughtAmounts\n    mapping(address => bool) public hasClaimed;\n\n    /// Amount of `tokenIn` taken in\n    uint256 public totalTokenIn;\n    /// Amount of `tokenOut` sold\n    uint256 public totalTokenOutBought;\n    /// Amount of `tokenOut` claimed\n    uint256 public totalTokenOutClaimed;\n\n    /// Max tokenIn that can be taken by the contract (defines the cap for tokenOut sold)\n    uint256 public tokenInLimit;\n\n    uint256 public tokenInNormalizationValue;\n\n    /// Whitelist\n    IBadgerVipGuestlist public guestlist;\n\n    /// Amount vote for each DAO\n    mapping(uint8 => uint256) public daoCommitments;\n    mapping(address => uint8) public daoVotedFor;\n\n    /// ==================\n    /// ===== Events =====\n    /// ==================\n\n    event Sale(\n        address indexed buyer,\n        uint8 indexed daoId,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n    event Claim(address indexed claimer, uint256 amount);\n    event Finalized();\n\n    event SaleStartUpdated(uint256 saleStart);\n    event SaleDurationUpdated(uint256 saleDuration);\n    event TokenOutPriceUpdated(uint256 tokenOutPrice);\n    event SaleRecipientUpdated(address indexed recipient);\n    event GuestlistUpdated(address indexed guestlist);\n    event TokenInLimitUpdated(uint256 tokenInLimit);\n\n    event Sweep(address indexed token, uint256 amount);\n\n    /// =======================\n    /// ===== Initializer =====\n    /// =======================\n\n    /**\n     * @notice Initializer.\n     * @param _tokenOut The token this contract will return in a trade (citadel)\n     * @param _tokenIn The token this contract will receive in a trade\n     * @param _saleStart The time when tokens can be first purchased\n     * @param _saleDuration The duration of the token sale\n     * @param _tokenOutPrice The tokenOut per tokenIn price\n     * @param _saleRecipient The address receiving the proceeds of the sale - will be citadel multisig\n     * @param _guestlist Address that will manage auction approvals\n     * @param _tokenInLimit The max tokenIn that the contract can take\n     */\n    function initialize(\n        address _globalAccessControl,\n        address _tokenOut,\n        address _tokenIn,\n        uint256 _saleStart,\n        uint256 _saleDuration,\n        uint256 _tokenOutPrice,\n        address _saleRecipient,\n        address _guestlist,\n        uint256 _tokenInLimit\n    ) external initializer {\n        require(\n            _saleStart >= block.timestamp,\n            \"KnightingRound: start date may not be in the past\"\n        );\n        require(\n            _saleDuration > 0,\n            \"KnightingRound: the sale duration must not be zero\"\n        );\n        require(\n            _tokenOutPrice > 0,\n            \"KnightingRound: the price must not be zero\"\n        );\n        require(\n            _saleRecipient != address(0),\n            \"KnightingRound: sale recipient should not be zero\"\n        );\n\n        __GlobalAccessControlManaged_init(_globalAccessControl);\n\n        tokenOut = ERC20Upgradeable(_tokenOut);\n        tokenIn = ERC20Upgradeable(_tokenIn);\n        saleStart = _saleStart;\n        saleDuration = _saleDuration;\n        tokenOutPrice = _tokenOutPrice;\n        saleRecipient = _saleRecipient;\n        guestlist = IBadgerVipGuestlist(_guestlist);\n        tokenInLimit = _tokenInLimit;\n\n        tokenInNormalizationValue = 10**tokenIn.decimals();\n    }\n\n    /// ==========================\n    /// ===== Public actions =====\n    /// ==========================\n\n    /**\n     * @notice Exchange `_tokenInAmount` of `tokenIn` for `tokenOut`\n     * @param _tokenInAmount Amount of `tokenIn` to give\n     * @param _daoId ID of DAO to vote for\n     * @param _proof Merkle proof for the guestlist. Use `new bytes32[](0)` if there's no guestlist\n     * @return tokenOutAmount_ Amount of `tokenOut` bought\n     */\n    function buy(\n        uint256 _tokenInAmount,\n        uint8 _daoId,\n        bytes32[] calldata _proof\n    ) external gacPausable returns (uint256 tokenOutAmount_) {\n        require(saleStart <= block.timestamp, \"KnightingRound: not started\");\n        require(\n            block.timestamp < saleStart + saleDuration,\n            \"KnightingRound: already ended\"\n        );\n        require(_tokenInAmount > 0, \"_tokenInAmount should be > 0\");\n        require(\n            totalTokenIn + _tokenInAmount <= tokenInLimit,\n            \"total amount exceeded\"\n        );\n\n        if (address(guestlist) != address(0)) {\n            require(guestlist.authorized(msg.sender, _proof), \"not authorized\");\n        }\n\n        uint256 boughtAmountTillNow = boughtAmounts[msg.sender];\n\n        if (boughtAmountTillNow > 0) {\n            require(\n                _daoId == daoVotedFor[msg.sender],\n                \"can't vote for multiple daos\"\n            );\n        } else {\n            daoVotedFor[msg.sender] = _daoId;\n        }\n\n        tokenOutAmount_ = getAmountOut(_tokenInAmount);\n\n        boughtAmounts[msg.sender] = boughtAmountTillNow + tokenOutAmount_;\n        daoCommitments[_daoId] = daoCommitments[_daoId] + tokenOutAmount_;\n\n        totalTokenIn = totalTokenIn + _tokenInAmount;\n        totalTokenOutBought = totalTokenOutBought + tokenOutAmount_;\n\n        tokenIn.safeTransferFrom(msg.sender, saleRecipient, _tokenInAmount);\n\n        emit Sale(msg.sender, _daoId, _tokenInAmount, tokenOutAmount_);\n    }\n\n    /**\n     * @notice Claim bought tokens after sale has been finalized\n     */\n    function claim() external gacPausable returns (uint256 tokenOutAmount_) {\n        require(finalized, \"sale not finalized\");\n        require(!hasClaimed[msg.sender], \"already claimed\");\n\n        tokenOutAmount_ = boughtAmounts[msg.sender];\n\n        require(tokenOutAmount_ > 0, \"nothing to claim\");\n\n        hasClaimed[msg.sender] = true;\n        totalTokenOutClaimed = totalTokenOutClaimed + tokenOutAmount_;\n\n        tokenOut.safeTransfer(msg.sender, tokenOutAmount_);\n\n        emit Claim(msg.sender, tokenOutAmount_);\n    }\n\n    /// =======================\n    /// ===== Public view =====\n    /// =======================\n\n    /**\n     * @notice Get the amount received when exchanging `tokenIn`\n     * @param _tokenInAmount Amount of `tokenIn` to exchange\n     * @return tokenOutAmount_ Amount of `tokenOut` received\n     */\n    function getAmountOut(uint256 _tokenInAmount)\n        public\n        view\n        returns (uint256 tokenOutAmount_)\n    {\n        tokenOutAmount_ =\n            (_tokenInAmount * tokenOutPrice) /\n            tokenInNormalizationValue;\n    }\n\n    /**\n     * @notice Check how much `tokenIn` can still be taken in\n     * @return limitLeft_ Amount of `tokenIn` that can still be exchanged\n     */\n    function getTokenInLimitLeft() external view returns (uint256 limitLeft_) {\n        if (totalTokenIn < tokenInLimit) {\n            limitLeft_ = tokenInLimit - totalTokenIn;\n        }\n    }\n\n    /**\n     * @notice Check if the sale has ended\n     * @return hasEnded_ True if the sale has ended\n     */\n    function saleEnded() public view returns (bool hasEnded_) {\n        hasEnded_ =\n            (block.timestamp >= saleStart + saleDuration) ||\n            (totalTokenIn >= tokenInLimit);\n    }\n\n    /// ====================================\n    /// ===== Permissioned: governance =====\n    /// ====================================\n\n    /**\n     * @notice Finalize the sale after sale duration. Can only be called by owner\n       @dev Ensure contract has enough `tokenOut` before calling\n     */\n    function finalize() external onlyRole(CONTRACT_GOVERNANCE_ROLE) {\n        require(!finalized, \"KnightingRound: already finalized\");\n        require(saleEnded(), \"KnightingRound: not finished\");\n        require(\n            tokenOut.balanceOf(address(this)) >= totalTokenOutBought,\n            \"KnightingRound: not enough balance\"\n        );\n\n        finalized = true;\n\n        emit Finalized();\n    }\n\n    /**\n     * @notice Update the sale start time. Can only be called by owner\n     * @param _saleStart New start time\n     */\n    function setSaleStart(uint256 _saleStart)\n        external\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        require(\n            _saleStart >= block.timestamp,\n            \"KnightingRound: start date may not be in the past\"\n        );\n        require(!finalized, \"KnightingRound: already finalized\");\n\n        saleStart = _saleStart;\n\n        emit SaleStartUpdated(_saleStart);\n    }\n\n    /**\n     * @notice Update sale duration. Can only be called by owner\n     * @param _saleDuration New duration\n     */\n    function setSaleDuration(uint256 _saleDuration)\n        external\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        require(\n            _saleDuration > 0,\n            \"KnightingRound: the sale duration must not be zero\"\n        );\n        require(!finalized, \"KnightingRound: already finalized\");\n\n        saleDuration = _saleDuration;\n\n        emit SaleDurationUpdated(_saleDuration);\n    }\n\n    /**\n     * @notice Modify the tokenOut price in. Can only be called by owner\n     * @param _tokenOutPrice New tokenOut price\n     */\n    function setTokenOutPrice(uint256 _tokenOutPrice)\n        external\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        require(\n            _tokenOutPrice > 0,\n            \"KnightingRound: the price must not be zero\"\n        );\n\n        tokenOutPrice = _tokenOutPrice;\n\n        emit TokenOutPriceUpdated(_tokenOutPrice);\n    }\n\n    /**\n     * @notice Update the `tokenIn` receipient address. Can only be called by owner\n     * @param _saleRecipient New recipient address\n     */\n    function setSaleRecipient(address _saleRecipient)\n        external\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        require(\n            _saleRecipient != address(0),\n            \"KnightingRound: sale recipient should not be zero\"\n        );\n\n        saleRecipient = _saleRecipient;\n\n        emit SaleRecipientUpdated(_saleRecipient);\n    }\n\n    /// ============================\n    /// ===== Tech ops actions =====\n    /// ============================\n\n    /**\n     * @notice Update the guestlist address. Can only be called by owner\n     * @param _guestlist New guestlist address\n     */\n    function setGuestlist(address _guestlist)\n        external\n        onlyRole(TECH_OPERATIONS_ROLE)\n    {\n        guestlist = IBadgerVipGuestlist(_guestlist);\n\n        emit GuestlistUpdated(_guestlist);\n    }\n\n    /**\n     * @notice Modify the max tokenIn that this contract can take. Can only be called by owner\n     * @param _tokenInLimit New max amountIn\n     */\n    function setTokenInLimit(uint256 _tokenInLimit)\n        external\n        onlyRole(TECH_OPERATIONS_ROLE)\n    {\n        require(!finalized, \"KnightingRound: already finalized\");\n\n        tokenInLimit = _tokenInLimit;\n\n        emit TokenInLimitUpdated(_tokenInLimit);\n    }\n\n    /// ================================\n    /// ===== Treasury Ops actions =====\n    /// ================================\n\n    /**\n     * @notice Transfers out any tokens accidentally sent to the contract. Can only be called by owner\n     * @dev The contract transfers all `tokenIn` directly to `saleRecipient` during a sale so it's safe\n     *      to sweep `tokenIn`. For `tokenOut`, the function only sweeps the extra amount\n     *      (current contract balance - amount left to be claimed)\n     * @param _token The token to sweep\n     */\n    function sweep(address _token) external gacPausable nonReentrant onlyRole(TREASURY_OPERATIONS_ROLE) {\n        uint256 amount = ERC20Upgradeable(_token).balanceOf(address(this));\n\n        if (_token == address(tokenOut)) {\n            uint256 amountLeftToBeClaimed = totalTokenOutBought -\n                totalTokenOutClaimed;\n            amount = amount - amountLeftToBeClaimed;\n        }\n\n        require(amount > 0, \"nothing to sweep\");\n\n        emit Sweep(_token, amount);\n        ERC20Upgradeable(_token).safeTransfer(saleRecipient, amount);\n    }\n}"
    },
    {
      "filename": "src/Funding.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./interfaces/badger/IVault.sol\";\nimport \"./interfaces/erc20/IERC20.sol\";\nimport \"./lib/GlobalAccessControlManaged.sol\";\nimport \"./lib/SafeERC20.sol\";\nimport \"./interfaces/citadel/IMedianOracle.sol\";\n\n/**\n * @notice Sells a token at a predetermined price to whitelisted buyers.\n * TODO: Better revert strings\n */\ncontract Funding is GlobalAccessControlManaged, ReentrancyGuardUpgradeable {\n    using SafeERC20 for IERC20;\n\n    // Roles used from GAC\n    bytes32 public constant CONTRACT_GOVERNANCE_ROLE =\n        keccak256(\"CONTRACT_GOVERNANCE_ROLE\");\n    bytes32 public constant POLICY_OPERATIONS_ROLE =\n        keccak256(\"POLICY_OPERATIONS_ROLE\");\n    bytes32 public constant TREASURY_OPERATIONS_ROLE = keccak256(\"TREASURY_OPERATIONS_ROLE\");\n    bytes32 public constant TREASURY_VAULT_ROLE =\n        keccak256(\"TREASURY_VAULT_ROLE\");\n    bytes32 public constant KEEPER_ROLE = keccak256(\"KEEPER_ROLE\");\n\n    uint256 public constant MAX_BPS = 10000;\n\n    IERC20 public citadel; /// token to distribute (in vested xCitadel form)\n    IVault public xCitadel; /// wrapped citadel form that is actually distributed\n    IERC20 public asset; /// token to take in WBTC / bibbtc LP / CVX / bveCVX\n\n    uint256 public citadelPriceInAsset; /// asset per citadel price eg. 1 WBTC (8 decimals) = 40,000 CTDL ==> price = 10^8 / 40,000\n    uint256 public minCitadelPriceInAsset; /// Lower bound on expected citadel price in asset terms. Used as circuit breaker oracle.\n    uint256 public maxCitadelPriceInAsset; /// Upper bound on expected citadel price in asset terms. Used as circuit breaker oracle.\n    bool public citadelPriceFlag; /// Flag citadel price for review by guardian if it exceeds min and max bounds;\n\n    uint256 public assetDecimalsNormalizationValue;\n\n    address public citadelPriceInAssetOracle;\n    address public saleRecipient;\n\n    struct FundingParams {\n        uint256 discount;\n        uint256 minDiscount;\n        uint256 maxDiscount;\n        address discountManager;\n        uint256 assetCumulativeFunded; /// persistent sum of asset amount in over lifetime of contract.\n        uint256 assetCap; /// Max asset token that can be taken in by the contract (defines the cap for citadel sold)\n    }\n\n    FundingParams public funding;\n\n    /// ==================\n    /// ===== Events =====\n    /// ==================\n\n    // TODO: we should conform to some interface here\n    event Deposit(\n        address indexed buyer,\n        uint256 assetIn,\n        uint256 citadelOutValue\n    );\n\n    event CitadelPriceInAssetUpdated(uint256 citadelPrice);\n\n    event CitadelPriceBoundsSet(uint256 minPrice, uint256 maxPrice);\n    event CitadelPriceFlag(uint256 price, uint256 minPrice, uint256 maxPrice);\n\n    event SaleRecipientUpdated(address indexed recipient);\n    event AssetCapUpdated(uint256 assetCap);\n\n    event Sweep(address indexed token, uint256 amount);\n    event ClaimToTreasury(address indexed token, uint256 amount);\n\n    modifier onlyCitadelPriceInAssetOracle() {\n        require(\n            msg.sender == citadelPriceInAssetOracle,\n            \"onlyCitadelPriceInAssetOracle\"\n        );\n        _;\n    }\n\n    event DiscountLimitsSet(uint256 minDiscount, uint256 maxDiscount);\n    event DiscountSet(uint256 discount);\n    event DiscountManagerSet(address discountManager);\n\n    /// =======================\n    /// ===== Initializer =====\n    /// =======================\n\n    /**\n     * @notice Initializer.\n     * @param _gac Global access control\n     * @param _citadel The token this contract will return in a trade\n     * @param _asset The token this contract will receive in a trade\n     * @param _xCitadel Staked citadel, citadel will be granted to funders in this form\n     * @param _saleRecipient The address receiving the proceeds of the sale - will be citadel multisig\n     * @param _assetCap The max asset that the contract can take\n     */\n    function initialize(\n        address _gac,\n        address _citadel,\n        address _asset,\n        address _xCitadel,\n        address _saleRecipient,\n        address _citadelPriceInAssetOracle,\n        uint256 _assetCap\n    ) external initializer {\n        require(\n            _saleRecipient != address(0),\n            \"Funding: 0 sale\"\n        );\n        require(\n            _citadelPriceInAssetOracle != address(0),\n            \"Funding: 0 oracle\"\n        );\n\n        __GlobalAccessControlManaged_init(_gac);\n        __ReentrancyGuard_init();\n\n        citadel = IERC20(_citadel);\n        xCitadel = IVault(_xCitadel);\n        asset = IERC20(_asset);\n        saleRecipient = _saleRecipient;\n\n        citadelPriceInAssetOracle = _citadelPriceInAssetOracle;\n\n        funding = FundingParams(0, 0, 0, address(0), 0, _assetCap);\n\n        assetDecimalsNormalizationValue = 10**asse"
    }
  ]
}