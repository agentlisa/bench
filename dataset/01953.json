{
  "Title": "M-6: `changeMaxGenerationId` allows to mint tokens from older generations retroactively",
  "Content": "# Issue M-6: `changeMaxGenerationId` allows to mint tokens from older generations retroactively \n\nSource: https://github.com/sherlock-audit/2023-04-footium-judging/issues/319 \n\n## Found by \nBAHOZ, Dug, GalloDaSballo, juancito\n## Summary\n\n`changeMaxGenerationId` is meant to allow more minting for the current generation, however, because of the fact that merkleProofs do not validate for the current season, whenever the limit will be raised, the limit will allow to mint players from older seasons\n\nIt will unlock a lot more minting than it may be intended\n\n## Vulnerability Detail\n\nIf for any reason `maxGenerationId` is increased, because of the fact that `MerkleProofUpgradeable.verify` doesn't check for `generationIds` and `seasonId` then not only new players from the current season can be minted, but also players from older seasons.\n\n## Impact\n\nMinting of X tokens where X is the number of old seasons\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-footium/blob/main/footium-eth-shareable/contracts/FootiumAcademy.sol#L257-L269\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nEnforce minting exclusively for the current season or change validation to validate the generations and seasons being minted\n\n\n\n## Discussion\n\n**logiclogue**\n\nThis is an interesting one. A decision needs to be made whether this is the intended behaviour. Marking as 'Sponsor Confirmed'.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/71",
  "Code": [
    {
      "filename": "footium-eth-shareable/contracts/FootiumAcademy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport {MerkleProofUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/cryptography/MerkleProofUpgradeable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {IFootiumPlayer} from \"./interfaces/IFootiumPlayer.sol\";\nimport {IFootiumClub} from \"./interfaces/IFootiumClub.sol\";\nimport \"./common/Errors.sol\";\n\ntype SeasonID is uint256;\n\nerror GenerationIDTooHigh(uint256 generationId, uint256 maxGenerationId);\nerror PlayerAlreadyRedeemed(uint256 generationId);\nerror ClubNotInDivision(uint256 clubId, uint256 divisionTier);\nerror PlayerTooOld(uint256 currentSeasonId);\nerror PlayerTooYoung(SeasonID seasonId);\nerror InvalidSeasonId(SeasonID seasonId);\n\n/**\n * @title Footium Football Academy\n * @notice An NFT football academy.\n */\ncontract FootiumAcademy is\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable\n{\n    /* Storage */\n    IFootiumPlayer private _footiumPlayer;\n    IFootiumClub private _footiumClub;\n    address private _prizeDistributorAddress;\n    uint256 private _maxGenerationId;\n    uint256 public currentSeasonId;\n    uint256 public academyMinAge;\n    uint256 public academyMaxAge;\n\n    bytes32 private _clubDivsMerkleRoot;\n\n    mapping(SeasonID => mapping(uint256 => mapping(uint256 => bool)))\n        private redeemed;\n\n    mapping(uint256 => uint256) public divisionToFee; //Maps a divisionTier to a fee\n\n    /* Events */\n\n    event ChangedMaxGenerationId(uint256 indexed maxGenerationId);\n    event ChangedCurrentSeasonId(uint256 indexed currentSeasonId);\n    event AcademyPlayerMinted(\n        SeasonID indexed seasonId,\n        uint256 indexed clubId,\n        uint256 indexed generationId,\n        uint256 playerId\n    );\n    event ChangedClubDivsMerkleRoot(bytes32 merkleRoot);\n    event ChangedDivisionFees(uint256[] fees);\n\n    /**\n     * @dev Initializes the FootiumAcademy contract.\n     * @param footiumPlayer Footium Players contract address.\n     * @param footiumClub Footium Clubs contract address.\n     * @param prizeDistributorAddress FootiumPrizeDistributor contract address.\n     * @param maxGenerationId The maximum integer generationId can be.\n     * @param fees Division fees.\n     */\n    function initialize(\n        IFootiumPlayer footiumPlayer,\n        IFootiumClub footiumClub,\n        address prizeDistributorAddress,\n        uint256 maxGenerationId,\n        uint256[] memory fees\n    ) external initializer {\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n\n        _footiumPlayer = footiumPlayer;\n        _footiumClub = footiumClub;\n        _prizeDistributorAddress = prizeDistributorAddress;\n        currentSeasonId = 1;\n        academyMinAge = 18;\n        academyMaxAge = 20;\n\n        setDivisionFees(fees);\n        changeMaxGenerationId(maxGenerationId);\n    }\n\n    /**\n     * @notice Changes the `_maxGenerationId` storage variable.\n     * @param maxGenerationId The new value for the `maxGenerationId` storage variable.\n     * @dev Only owner address allowed.\n     */\n    function changeMaxGenerationId(uint256 maxGenerationId) public onlyOwner {\n        _maxGenerationId = maxGenerationId;\n        emit ChangedMaxGenerationId(_maxGenerationId);\n    }\n\n    /**\n     * @notice Changes the `_clubDivsMerkleRoot` variable.\n     * @param _merkleRoot is the value for the `_clubDivsMerkleRoot` variable.\n     * @dev Only owner address allowed.\n     */\n    function setClubDivsMerkleRoot(bytes32 _merkleRoot) external onlyOwner {\n        _clubDivsMerkleRoot = _merkleRoot;\n\n        emit ChangedClubDivsMerkleRoot(_clubDivsMerkleRoot);\n    }\n\n    /**\n     * @notice Updates division fees.\n     * @param _fees an array of division fees to be set.\n     * @dev Only owner address allowed.\n     */\n    function setDivisionFees(uint256[] memory _fees) public onlyOwner {\n        uint256 max = _fees.length;\n\n        for (uint256 i = 0; i < max; ) {\n            uint256 fee = _fees[i];\n            divisionToFee[i + 1] = fee;\n\n            unchecked {\n                i++;\n            }\n        }\n\n        emit ChangedDivisionFees(_fees);\n    }\n\n    /**\n     * @notice Changes the `currentSeasonId` storage variable.\n     * @param _newSeasonId The new value for the `currentSeasonId` storage variable.\n     * @dev Only owner address allowed\n     */\n    function changeCurrentSeasonId(uint256 _newSeasonId) external onlyOwner {\n        currentSeasonId = _newSeasonId;\n\n        emit ChangedCurrentSeasonId(currentSeasonId);\n    }\n\n    /**\n     * @notice Unpause the contract\n     * @dev Only owner address allowed.\n     */\n    function activateContract() external onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @notice Pause the contract\n     * @dev Only owner address allowed.\n     */\n    function pauseContract() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice Mint players corresponding to `generationIds` from the `seasonId` cohort.\n     * @param seasonId The season cohort to mint players from.\n     * @param clubId The ID of the club to receive the players.\n     * @param divisionTier The tier of the division.\n     * @param generationIds The unique identifier of each player within the season cohort.\n     * @param divisionProof Sibling hashes on the branch from the leaf to the division root of the merkel tree.\n     * @dev Only the owner can mint players to their club.\n     */\n    function mintPlayers(\n        SeasonID seasonId,\n        uint256 clubId,\n        uint256 divisionTier,\n        uint256[] calldata generationIds,\n        bytes32[] calldata divisionProof\n    ) external payable whenNotPaused nonReentrant {\n        uint256 totalFee = _validateMintingParams(\n            seasonId,\n            clubId,\n            divisionTier,\n            generationIds,\n            divisionProof\n        );\n\n        uint256 generationId;\n\n        for (uint256 i = 0; i < generationIds.length; ) {\n            generationId = generationIds[i];\n\n            if (generationId > _maxGenerationId) {\n                revert GenerationIDTooHigh(generationId, _maxGenerationId);\n            }\n\n            if (redeemed[seasonId][clubId][generationId]) {\n                revert PlayerAlreadyRedeemed(generationId);\n            }\n\n            redeemed[seasonId][clubId][generationId] = true;\n\n            uint256 playerId = _footiumPlayer.safeMint(\n                _footiumClub.clubToEscrow(clubId)\n            );\n\n            emit AcademyPlayerMinted(seasonId, clubId, generationId, playerId);\n\n            unchecked {\n                i++;\n            }\n        }\n\n        // forward total fee to the prize distributor contract\n        (bool sent, ) = _prizeDistributorAddress.call{value: totalFee}(\"\");\n        if (!sent) {\n            revert FailedToSendETH(totalFee);\n        }\n    }\n\n    /**\n     * @notice Transfers contract available ether balance to the contact owner address\n     * @dev Only owner address allowed\n     */\n    function withdraw() external onlyOwner {\n        uint256 balance = address(this).balance;\n        if (balance > 0) {\n            (bool sent, ) = payable(owner()).call{value: balance}(\"\");\n            if (!sent) {\n                revert FailedToSendETH(balance);\n            }\n        }\n    }\n\n    function _validateMintingParams(\n        SeasonID seasonId,\n        uint256 clubId,\n        uint256 divisionTier,\n        uint256[] calldata generationIds,\n        bytes32[] calldata divisionProof\n    ) private returns (uint256) {\n        if (\n            !MerkleProofUpgradeable.verify(\n                divisionProof,\n                _clubDivsMerkleRoot,\n                keccak256(abi.encodePacked(clubId, divisionTier))\n            )\n        ) {\n            revert ClubNotInDivision(clubId, divisionTier);\n        }\n\n        if (msg.sender != _footiumClub.ownerOf(clubId)) {\n            revert NotClubOwner(clubId, msg.sender);\n        }\n\n        if (SeasonID.unwrap(seasonId) <= 0) {\n            revert InvalidSeasonId(seasonId);\n        }\n\n        if (SeasonID.unwrap(seasonId) > currentSeasonId) {\n            revert PlayerTooYoung(seasonId);\n        }\n\n        uint256 playerCount = generationIds.length;\n        uint256 totalFee = playerCount * divisionToFee[divisionTier];\n        if (msg.value < totalFee) {\n            revert IncorrectETHAmount(msg.value);\n        }\n\n        uint256 maxSeasonId = SeasonID.unwrap(seasonId) +\n            academyMaxAge -\n            academyMinAge;\n\n        if (maxSeasonId < currentSeasonId) {\n            revert PlayerTooOld(currentSeasonId);\n        }\n\n        return totalFee;\n    }\n}"
    }
  ]
}