{
  "Title": "[L05] Contracts have artifacts leftover from earlier test versions",
  "Content": "The whitepaper defines the native token’s symbol as “AUDS” and its name as “Audius”. However, the symbol used in [the `AudiusToken` contract](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/erc20/AudiusToken.sol#L21) is “TAUDS” and its name is “TestAudius”.\n\n\nIn [the `ServiceTypeManager` contract](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ServiceTypeManager.sol#L34-L35) there are two events called `Test` and `TestAddr` that are not used in the code.\n\n\nConsider changing the name and symbol to the ones defined in the whitepaper, and consider removing the unused test events.\n\n\n***Update:** Partially fixed. The test events were deleted in [pull request #583](https://github.com/AudiusProject/audius-protocol/pull/583/files#diff-97eaf3b56cab95094247b87ff242d988L35-L36). Audius’ statement for the token issue:*\n\n\n\n> This was done on purpose so we wouldn’t accidentally deploy test contracts to mainnet with the token symbol AUDS. The plan was to change the name and symbol before the final deploy of the contracts as to not pollute the ERC-20 landscape with the token name and symbol.\n> \n> \n\n\n***Update:** Fixed in [pull request #657](https://github.com/AudiusProject/audius-protocol/pull/657).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "eth-contracts/contracts/erc20/AudiusToken.sol",
      "content": "pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Detailed.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Mintable.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Pausable.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Burnable.sol\";\nimport \"../InitializableV2.sol\";\n\n\n/** Upgradeable ERC20 token that is Detailed, Mintable, Pausable, Burnable. */\ncontract AudiusToken is InitializableV2,\n    ERC20,\n    ERC20Detailed,\n    ERC20Mintable,\n    ERC20Pausable,\n    ERC20Burnable\n{\n    string constant NAME = \"TestAudius\";\n\n    string constant SYMBOL = \"TAUDS\";\n\n    // Defines number of Wei in 1 token\n    // 18 decimals is standard - imitates relationship between Ether and Wei\n    uint8 constant DECIMALS = 18;\n\n    // 10^27 = 1 billion (10^9) tokens, 18 decimal places\n    // 1 TAUD = 1 * 10^18 wei\n    uint256 constant INITIAL_SUPPLY = 1000000000 * 10**uint256(DECIMALS);\n\n    function initialize(address _owner, address governance) public initializer {\n        // ERC20 has no initialize function\n\n        // ERC20Detailed provides setters/getters for name, symbol, decimals properties\n        ERC20Detailed.initialize(NAME, SYMBOL, DECIMALS);\n\n        // ERC20Burnable has no initialize function. Makes token burnable\n\n        // Initialize call makes token pausable & gives pauserRole to governance\n        ERC20Pausable.initialize(governance);\n\n        // Initialize call makes token mintable & gives minterRole to msg.sender\n        ERC20Mintable.initialize(msg.sender);\n\n        // Mints initial token supply & transfers to _owner account\n        _mint(_owner, INITIAL_SUPPLY);\n\n        // Transfers minterRole to governance\n        addMinter(governance);\n        renounceMinter();\n\n        InitializableV2.initialize();\n    }\n}"
    },
    {
      "filename": "eth-contracts/contracts/ServiceTypeManager.sol",
      "content": "pragma solidity ^0.5.0;\n\nimport \"./InitializableV2.sol\";\n\n\ncontract ServiceTypeManager is InitializableV2 {\n    address governanceAddress;\n\n    /**\n     * @dev - mapping of serviceType - serviceTypeVersion\n     * Example - \"discovery-provider\" - [\"0.0.1\", \"0.0.2\", ..., \"currentVersion\"]\n     */\n    mapping(bytes32 => bytes32[]) public serviceTypeVersions;\n\n    /**\n     * @dev - mapping of serviceType - < serviceTypeVersion, isValid >\n     * Example - \"discovery-provider\" - <\"0.0.1\", true>\n     */\n    mapping(bytes32 => mapping(bytes32 => bool)) public serviceTypeVersionInfo;\n\n    /// @dev List of valid service types\n    bytes32[] private validServiceTypes;\n\n    /// @dev Struct representing service type stake requirements\n    struct ServiceTypeStakeRequirements {\n        uint minStake;\n        uint maxStake;\n    }\n\n    /// @dev mapping of service type to registered requirements\n    mapping(bytes32 => ServiceTypeStakeRequirements) serviceTypeStakeRequirements;\n\n    event SetServiceVersion(bytes32 _serviceType, bytes32 _serviceVersion);\n    event Test(string msg, bool value);\n    event TestAddr(string msg, address addr);\n\n    /**\n     * @notice Function to initialize the contract\n     * @param _governanceAddress - Governance proxy address\n     */\n    function initialize(address _governanceAddress) public initializer\n    {\n        governanceAddress = _governanceAddress;\n        InitializableV2.initialize();\n    }\n\n    /// @notice Get the Governance address\n    function getGovernanceAddress() external view returns (address addr) {\n        return governanceAddress;\n    }\n\n    /**\n     * @notice Set the Governance address\n     * @dev Only callable by Governance address\n     * @param _governanceAddress - address for new Governance contract\n     */\n    function setGovernanceAddress(address _governanceAddress) external {\n        require(msg.sender == governanceAddress, \"Only governance\");\n        governanceAddress = _governanceAddress;\n    }\n\n    // ========================================= Service Type Logic =========================================\n\n    /// @notice Add a new service type\n    /**\n     * @notice Add a new service type\n     * @param _serviceType - type of service to add\n     * @param _serviceTypeMin - minimum stake for service type\n     * @param _serviceTypeMax - maximum stake for service type\n     */\n    function addServiceType(\n        bytes32 _serviceType,\n        uint _serviceTypeMin,\n        uint _serviceTypeMax\n    ) external\n    {\n        _requireIsInitialized();\n\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n        require(!this.serviceTypeIsValid(_serviceType), \"Already known service type\");\n\n        validServiceTypes.push(_serviceType);\n        serviceTypeStakeRequirements[_serviceType] = ServiceTypeStakeRequirements({\n            minStake: _serviceTypeMin,\n            maxStake: _serviceTypeMax\n        });\n    }\n\n    /**\n     * @notice Remove an existing service type\n     * @param _serviceType - name of service type to remove\n     */\n    function removeServiceType(bytes32 _serviceType) external {\n        _requireIsInitialized();\n\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n\n        uint serviceIndex = 0;\n        bool foundService = false;\n        for (uint i = 0; i < validServiceTypes.length; i ++) {\n            if (validServiceTypes[i] == _serviceType) {\n                serviceIndex = i;\n                foundService = true;\n                break;\n            }\n        }\n        require(foundService == true, \"Invalid service type, not found\");\n        // Overwrite service index\n        uint lastIndex = validServiceTypes.length - 1;\n        validServiceTypes[serviceIndex] = validServiceTypes[lastIndex];\n        validServiceTypes.length--;\n        // Overwrite values\n        serviceTypeStakeRequirements[_serviceType].minStake = 0;\n        serviceTypeStakeRequirements[_serviceType].maxStake = 0;\n    }\n\n    /**\n     * @notice Update a service type\n     * @param _serviceType - type of service\n     * @param _serviceTypeMin - minimum stake for service type\n     * @param _serviceTypeMax - maximum stake for service type\n     */\n    function updateServiceType(\n        bytes32 _serviceType,\n        uint _serviceTypeMin,\n        uint _serviceTypeMax\n    ) external\n    {\n        _requireIsInitialized();\n        require(\n            msg.sender == governanceAddress,\n            \"Only callable by Governance contract\"\n        );\n\n        require(this.serviceTypeIsValid(_serviceType), \"Invalid service type\");\n\n        serviceTypeStakeRequirements[_serviceType].minStake = _serviceTypeMin;\n        serviceTypeStakeRequirements[_serviceType].maxStake = _serviceTypeMax;\n    }\n\n    /**\n     * @notice Get min and max stake for a given service type\n     * @param _serviceType - type of service\n     * @return min and max stake for type\n     */\n    function getServiceTypeStakeInfo(bytes32 _serviceType)\n    external view returns (uint min, uint max)\n    {\n        return (\n            serviceTypeStakeRequirements[_serviceType].minStake,\n            serviceTypeStakeRequirements[_serviceType].maxStake\n        );\n    }\n\n    /**\n     * @notice Get list of valid service types\n     */\n    function getValidServiceTypes()\n    external view returns (bytes32[] memory types)\n    {\n        return validServiceTypes;\n    }\n\n    /**\n     * @notice Return indicating whether this is a valid service type\n     */\n    function serviceTypeIsValid(bytes32 _serviceType)\n    external view returns (bool isValid)\n    {\n        return serviceTypeStakeRequirements[_serviceType].maxStake > 0;\n    }\n\n    // ========================================= Service Version Logic =========================================\n\n    /**\n     * @notice Add new version for a serviceType\n     * @param _serviceType - type of service\n     * @param _serviceVersion - new version of service to add\n     */\n    function setServiceVersion(\n        bytes32 _serviceType,\n        bytes32 _serviceVersion\n    ) external\n    {\n        _requireIsInitialized();\n\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n\n        require(\n            serviceTypeVersionInfo[_serviceType][_serviceVersion] == false,\n            \"Already registered\"\n        );\n\n         // Update array of known types\n        serviceTypeVersions[_serviceType].push(_serviceVersion);\n\n        // Update status for this specific service version\n        serviceTypeVersionInfo[_serviceType][_serviceVersion] = true;\n\n        emit SetServiceVersion(_serviceType, _serviceVersion);\n    }\n\n    /**\n     * @notice Get a version for a service type given it's index\n     * @param _serviceType - type of service\n     * @param _versionIndex - index in list of service versions\n     */\n    function getVersion(bytes32 _serviceType, uint _versionIndex)\n    external view returns (bytes32 version)\n    {\n        require(\n            serviceTypeVersions[_serviceType].length > _versionIndex,\n            \"No registered version of serviceType\"\n        );\n        return (serviceTypeVersions[_serviceType][_versionIndex]);\n    }\n\n    /**\n     * @notice Get curent version for a service type\n     * @param _serviceType - type of service\n     * @return Returns current version of service\n     */\n    function getCurrentVersion(bytes32 _serviceType)\n    external view returns (bytes32 currentVersion)\n    {\n        require(\n            serviceTypeVersions[_serviceType].length >= 1,\n            \"No registered version of serviceType\"\n        );\n        uint latestVersionIndex = serviceTypeVersions[_serviceType].length - 1;\n        return (serviceTypeVersions[_serviceType][latestVersionIndex]);\n    }\n\n    /**\n     * @notice Get total number of versions for a service type\n     * @param _serviceType - type of service\n     */\n    function getNumberOfVersions(bytes32 _serviceType)\n    external view returns (uint)\n    {\n        return serviceTypeVersions[_serviceType].length;\n    }\n\n    /**\n     * @notice Return boolean indicating whether given version is valid for given type\n     * @param _serviceType - type of service\n     * @param _serviceVersion - version of service to check\n     */\n    function serviceVersionIsValid(bytes32 _serviceType, bytes32 _serviceVersion)\n    external view returns (bool isValidServiceVersion)\n    {\n        return serviceTypeVersionInfo[_serviceType][_serviceVersion];\n    }\n}"
    }
  ]
}