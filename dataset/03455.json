{
  "Title": "[H01] ETH can be locked inside the Timelock contract",
  "Content": "The `Tally` team originally based their implementations on the ground of the [`GovernorBravoDelegate`](https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/GovernorBravoDelegate.sol) Compound contract.\n\n\nDuring the course of this audit, the `Tally` team discovered [a limitation](https://github.com/compound-finance/compound-protocol/issues/150) in Compoundâ€™s governor where ETH sent directly to the `Timelock` is not available for use by governance proposals, and although it is not permanently stuck, requires an elaborate workaround to be retrieved.\n\n\nThis is because the governor implementation requires all the value of a proposal to be attached as `msg.value` by the account that triggers the execution, not using in any way the `Timelock` ETH funds.\n\n\nThe [same issue was later identified in the `SafeGuard` implementation](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuard.sol#L80) and the team is aware of the issue and it is in the process of fixing it.\n\n\nWhile fixing the issue, consider using the approach [adopted by the OpenZeppelin library for the same issue](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2849).\n\n\n**Update:** *Fixed in commit [`7337db227edda83533be586135d96ddac4f5bf29`](https://github.com/withtally/safeguard/commit/7337db227edda83533be586135d96ddac4f5bf29).*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/SafeGuard.sol",
      "content": "pragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"./ITimelock.sol\";\nimport \"hardhat/console.sol\";\n\ncontract SafeGuard is AccessControlEnumerable {\n\n    // Request info event\n    event QueueTransactionWithDescription(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta, string description);\n\n    bytes32 public constant SAFEGUARD_ADMIN_ROLE = keccak256(\"SAFEGUARD_ADMIN_ROLE\");\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    bytes32 public constant CANCELER_ROLE = keccak256(\"CANCELER_ROLE\");\n    bytes32 public constant CREATOR_ROLE = keccak256(\"CREATOR_ROLE\");\n\n    ///@dev The address of the Timelock\n    ITimelock public timelock;\n\n    /**\n     * @dev Initializes the contract with a given Timelock address and administrator address.\n     */\n    constructor (address _admin, bytes32[] memory roles, address[] memory rolesAssignees) {\n        require(roles.length == rolesAssignees.length, \"SafeGuard::constructor: roles assignment arity mismatch\");\n        // set roles administrator\n        _setRoleAdmin(SAFEGUARD_ADMIN_ROLE, SAFEGUARD_ADMIN_ROLE);\n        _setRoleAdmin(PROPOSER_ROLE, SAFEGUARD_ADMIN_ROLE);\n        _setRoleAdmin(EXECUTOR_ROLE, SAFEGUARD_ADMIN_ROLE);\n        _setRoleAdmin(CANCELER_ROLE, SAFEGUARD_ADMIN_ROLE);\n        _setRoleAdmin(CREATOR_ROLE, SAFEGUARD_ADMIN_ROLE);\n\n        // assign roles \n        for (uint i = 0; i < roles.length; i++) {\n            _setupRole(roles[i], rolesAssignees[i]);\n        }\n\n        // set admin rol to an address\n        _setupRole(SAFEGUARD_ADMIN_ROLE, _admin);\n        _setupRole(CREATOR_ROLE, msg.sender);\n    }\n\n    /**\n     * @dev Modifier to make a function callable just by a certain role.\n     */\n    modifier justByRole(bytes32 role) {\n        require(hasRole(role, _msgSender()), \"SafeGuard: sender requires permission\");\n        _;\n    }\n\n    /**\n     * @notice Sets the timelock address this safeGuard contract is gonna use\n     * @param _timelock The address of the timelock contract\n     */\n    function setTimelock(address _timelock) public justByRole(CREATOR_ROLE) {\n        require(address(timelock) == address(0), \"SafeGuard::setTimelock: Timelock address already defined\");\n        // set timelock address\n        timelock = ITimelock(_timelock);\n    }\n\n    function queueTransaction(address target, uint256 value, string memory signature, bytes memory data, uint256 eta) public justByRole(PROPOSER_ROLE) {\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        _queueTimelockTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function queueTransactionWithDescription(address target, uint256 value, string memory signature, bytes memory data, uint256 eta, string memory description) public justByRole(PROPOSER_ROLE) {\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        _queueTimelockTransaction(txHash, target, value, signature, data, eta);\n        emit QueueTransactionWithDescription(txHash, target, value, signature, data, eta, description);\n    }\n\n    function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public justByRole(CANCELER_ROLE) {\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        _cancelTimelockTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function executeTransaction(address target, uint256 _value, string memory signature, bytes memory data, uint256 eta) public payable justByRole(EXECUTOR_ROLE) {\n        bytes32 txHash = keccak256(abi.encode(target, _value, signature, data, eta));\n        require(timelock.queuedTransactions(txHash), \"SafeGuard::executeTransaction: transaction should be queued\");\n        timelock.executeTransaction{value: _value, gas: gasleft()}(target, _value, signature, data, eta);\n    }\n\n    function _queueTimelockTransaction(bytes32 txHash, address target, uint256 value, string memory signature, bytes memory data, uint256 eta) private {\n        require(!timelock.queuedTransactions(txHash), \"SafeGuard::queueTransaction: transaction already queued at eta\");\n        timelock.queueTransaction(target, value, signature, data, eta);\n    }\n\n    function _cancelTimelockTransaction(bytes32 txHash, address target, uint256 value, string memory signature, bytes memory data, uint256 eta) private {\n        require(timelock.queuedTransactions(txHash), \"SafeGuard::cancelTransaction: transaction should be queued\");\n        timelock.cancelTransaction(target, value, signature, data, eta);\n    }\n}"
    }
  ]
}