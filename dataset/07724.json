{
  "Title": "[M-05] `call` opcode's return value not checked.",
  "Content": "\n<https://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/lowLevelCallers/LowLevelETH.sol#L35>\n\n<https://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/lowLevelCallers/LowLevelETH.sol#L46>\n\n<https://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/lowLevelCallers/LowLevelETH.sol#L57>\n\n### Impact\n\nThe `call` opcode's return value not checked, which could lead to the `originator` losing funds.\n\n### Proof of Concept\n\nThe caller of `LooksRareAggregator.sol::execute` could be a contract who may not implement the `fallback` or `receive` function, when a call to it with value sent, it will revert, thus failed to receive the ETH.\n\nLet's imagine the contract calls the `execute` function to buy multiple NFTs with ETH as the payout currency and make the `isAtomic` parameter being false. Since the batch buy of NFTs is not atomic, the failed transactions in LooksRare or Seaport marketplace will return the passed ETH. The contract doesn't implement the `fallback/receive` function and the call opcode's return value not checked, thus the ETH value will be trapped in the `LooksRareAggregator` contract until the next user call the `execute` function and the trapped ETH is returned to him. The `originator` lose funds.\n\n```solidity\n    function _returnETHIfAny(address recipient) internal {\n        assembly {\n            if gt(selfbalance(), 0) {\n                let status := call(gas(), recipient, selfbalance(), 0, 0, 0, 0) // @audit-issue status not checked.\n            }\n        }\n    }\n```\n\n### Recommended Mitigation Steps\n\nCheck the return value on the `call` opcode.\n\n```solidity\n    function _returnETHIfAny() internal {\n        bool status;\n        assembly {\n            if gt(selfbalance(), 0) {\n                status := call(gas(), caller(), selfbalance(), 0, 0, 0, 0) // @audit-issue [MED] status not checked\n            }\n        }\n        if (!status) revert ETHTransferFail();\n    }\n\n    function _returnETHIfAny(address recipient) internal {\n        bool status;\n        assembly {\n            if gt(selfbalance(), 0) {\n                status := call(gas(), recipient, selfbalance(), 0, 0, 0, 0) // @audit-issue status not checked.\n            }\n        }\n        if (!status) revert ETHTransferFail();\n    }\nfunction _returnETHIfAnyWithOneWeiLeft() internal {\n        bool status;\n        assembly {\n            if gt(selfbalance(), 1) {\n                status := call(gas(), caller(), sub(selfbalance(), 1), 0, 0, 0, 0)\n            }\n        }\n        if (!status) revert ETHTransferFail();\n    }\n```\n\n**[0xhiroshi (LooksRare) confirmed](https://github.com/code-423n4/2022-11-looksrare-findings/issues/241#issuecomment-1326716597)**\n\n**[Picodes (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-11-looksrare-findings/issues/241#issuecomment-1345539234):**\n > Medium severity as only the dust is impacted.\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-11-looksrare",
  "Code": [
    {
      "filename": "contracts/lowLevelCallers/LowLevelETH.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.14;\n\nimport {IWETH} from \"../interfaces/IWETH.sol\";\n\n/**\n * @title LowLevelETH\n * @notice This contract contains low-level calls to transfer ETH.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract LowLevelETH {\n    error ETHTransferFail();\n\n    /**\n     * @notice Transfer ETH to a recipient address\n     * @param _to Recipient address\n     * @param _amount Amount to transfer\n     */\n    function _transferETH(address _to, uint256 _amount) internal {\n        bool status;\n\n        assembly {\n            status := call(gas(), _to, _amount, 0, 0, 0, 0)\n        }\n\n        if (!status) revert ETHTransferFail();\n    }\n\n    /**\n     * @notice Return ETH back to the original sender if any ETH is left in the payable call.\n     */\n    function _returnETHIfAny() internal {\n        assembly {\n            if gt(selfbalance(), 0) {\n                let status := call(gas(), caller(), selfbalance(), 0, 0, 0, 0)\n            }\n        }\n    }\n\n    /**\n     * @notice Return ETH back to the designated sender if any ETH is left in the payable call.\n     */\n    function _returnETHIfAny(address recipient) internal {\n        assembly {\n            if gt(selfbalance(), 0) {\n                let status := call(gas(), recipient, selfbalance(), 0, 0, 0, 0)\n            }\n        }\n    }\n\n    /**\n     * @notice Return ETH to the original sender if any is left in the payable call but leave 1 wei of ETH in the contract.\n     */\n    function _returnETHIfAnyWithOneWeiLeft() internal {\n        assembly {\n            if gt(selfbalance(), 1) {\n                let status := call(gas(), caller(), sub(selfbalance(), 1), 0, 0, 0, 0)\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/lowLevelCallers/LowLevelETH.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.14;\n\nimport {IWETH} from \"../interfaces/IWETH.sol\";\n\n/**\n * @title LowLevelETH\n * @notice This contract contains low-level calls to transfer ETH.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract LowLevelETH {\n    error ETHTransferFail();\n\n    /**\n     * @notice Transfer ETH to a recipient address\n     * @param _to Recipient address\n     * @param _amount Amount to transfer\n     */\n    function _transferETH(address _to, uint256 _amount) internal {\n        bool status;\n\n        assembly {\n            status := call(gas(), _to, _amount, 0, 0, 0, 0)\n        }\n\n        if (!status) revert ETHTransferFail();\n    }\n\n    /**\n     * @notice Return ETH back to the original sender if any ETH is left in the payable call.\n     */\n    function _returnETHIfAny() internal {\n        assembly {\n            if gt(selfbalance(), 0) {\n                let status := call(gas(), caller(), selfbalance(), 0, 0, 0, 0)\n            }\n        }\n    }\n\n    /**\n     * @notice Return ETH back to the designated sender if any ETH is left in the payable call.\n     */\n    function _returnETHIfAny(address recipient) internal {\n        assembly {\n            if gt(selfbalance(), 0) {\n                let status := call(gas(), recipient, selfbalance(), 0, 0, 0, 0)\n            }\n        }\n    }\n\n    /**\n     * @notice Return ETH to the original sender if any is left in the payable call but leave 1 wei of ETH in the contract.\n     */\n    function _returnETHIfAnyWithOneWeiLeft() internal {\n        assembly {\n            if gt(selfbalance(), 1) {\n                let status := call(gas(), caller(), sub(selfbalance(), 1), 0, 0, 0, 0)\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/lowLevelCallers/LowLevelETH.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.14;\n\nimport {IWETH} from \"../interfaces/IWETH.sol\";\n\n/**\n * @title LowLevelETH\n * @notice This contract contains low-level calls to transfer ETH.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract LowLevelETH {\n    error ETHTransferFail();\n\n    /**\n     * @notice Transfer ETH to a recipient address\n     * @param _to Recipient address\n     * @param _amount Amount to transfer\n     */\n    function _transferETH(address _to, uint256 _amount) internal {\n        bool status;\n\n        assembly {\n            status := call(gas(), _to, _amount, 0, 0, 0, 0)\n        }\n\n        if (!status) revert ETHTransferFail();\n    }\n\n    /**\n     * @notice Return ETH back to the original sender if any ETH is left in the payable call.\n     */\n    function _returnETHIfAny() internal {\n        assembly {\n            if gt(selfbalance(), 0) {\n                let status := call(gas(), caller(), selfbalance(), 0, 0, 0, 0)\n            }\n        }\n    }\n\n    /**\n     * @notice Return ETH back to the designated sender if any ETH is left in the payable call.\n     */\n    function _returnETHIfAny(address recipient) internal {\n        assembly {\n            if gt(selfbalance(), 0) {\n                let status := call(gas(), recipient, selfbalance(), 0, 0, 0, 0)\n            }\n        }\n    }\n\n    /**\n     * @notice Return ETH to the original sender if any is left in the payable call but leave 1 wei of ETH in the contract.\n     */\n    function _returnETHIfAnyWithOneWeiLeft() internal {\n        assembly {\n            if gt(selfbalance(), 1) {\n                let status := call(gas(), caller(), sub(selfbalance(), 1), 0, 0, 0, 0)\n            }\n        }\n    }\n}"
    }
  ]
}