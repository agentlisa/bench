{
  "Title": "Native Ink! Transfers Are Not Traceable in PaymentSplitter Contract",
  "Content": "The `PaymentSplitter` contract implements a [`receive` function](https://github.com/Brushfam/openbrush-contracts/blob/553347354de6d0ead6a335ba4c197bdd01fb2d12/contracts/src/finance/payment_splitter/mod.rs#L71) used to add funds to the contract. When calling this function, an [event is emitted](https://github.com/Brushfam/openbrush-contracts/blob/553347354de6d0ead6a335ba4c197bdd01fb2d12/contracts/src/finance/payment_splitter/mod.rs#L72) to keep track of all funds received in the contract and the sender's identity.\n\n\nHowever, there is no way to keep track of deposits made through the ink! [`transfer` function](https://paritytech.github.io/ink/ink_env/fn.transfer.html). Consequently, other contracts will need to be aware of the `PaymentSplitter`'s implementation and its functions, as they must know about the aforementioned `receive` function. In general, transfers between protocols should occur in a standardized manner (for instance, using the `transfer` function mentioned above), which enhances interoperability between systems.\n\n\nFor instance, if one of the beneficiaries of the `PaymentSplitter` contract is another `PaymentSplitter` contract when releasing funds to this beneficiary, the funds sent will not be tracked since the contract is [using the aforementioned `transfer` function](https://github.com/Brushfam/openbrush-contracts/blob/553347354de6d0ead6a335ba4c197bdd01fb2d12/contracts/src/finance/payment_splitter/mod.rs#L177) instead of the `receive` function.\n\n\nCurrently, there appears to be no direct solution for initiating an action within a contract when funds are sent to it. This limitation stems from ink!, not OpenBrush. Consider encouraging the ink! team to incorporate a standard `receive` function, which could then be triggered upon someone executing a native `transfer` to a contract.\n\n\n***Update:** Acknowledged, not resolved. The Brushfam team stated:*\n\n\n\n> *We will communicate with ink! team to fix the issue, for now will just update the documentation about this issue.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/finance/payment_splitter/mod.rs",
      "content": "// Copyright (c) 2012-2022 Supercolony\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\"Software\"),\n// to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\npub use crate::{\n    payment_splitter,\n    traits::payment_splitter::*,\n};\nuse ink::prelude::vec::Vec;\nuse openbrush::{\n    storage::Mapping,\n    traits::{\n        AccountId,\n        Balance,\n        Storage,\n    },\n};\npub use payment_splitter::Internal as _;\n\n#[derive(Default, Debug)]\n#[openbrush::storage_item]\npub struct Data {\n    #[lazy]\n    pub total_shares: Balance,\n    #[lazy]\n    pub total_released: Balance,\n    pub shares: Mapping<AccountId, Balance>,\n    pub released: Mapping<AccountId, Balance>,\n    #[lazy]\n    pub payees: Vec<AccountId>,\n}\n\npub trait PaymentSplitterImpl: Storage<Data> + Internal {\n    fn total_shares(&self) -> Balance {\n        self.data().total_shares.get_or_default()\n    }\n\n    fn total_released(&self) -> Balance {\n        self.data().total_released.get_or_default()\n    }\n\n    fn shares(&self, account: AccountId) -> Balance {\n        self.data().shares.get(&account).unwrap_or(0)\n    }\n\n    fn released(&self, account: AccountId) -> Balance {\n        self.data().released.get(&account).unwrap_or(0)\n    }\n\n    fn payee(&self, index: u32) -> Option<AccountId> {\n        self.data().payees.get_or_default().get(index as usize).cloned()\n    }\n\n    fn receive(&mut self) {\n        self._emit_payee_added_event(Self::env().caller(), Self::env().transferred_value())\n    }\n\n    fn release(&mut self, account: AccountId) -> Result<(), PaymentSplitterError> {\n        self._release(account)\n    }\n}\n\npub trait Internal {\n    /// User must override those methods in their contract.\n    fn _emit_payee_added_event(&self, account: AccountId, shares: Balance);\n\n    fn _emit_payment_received_event(&self, from: AccountId, amount: Balance);\n\n    fn _emit_payment_released_event(&self, to: AccountId, amount: Balance);\n\n    /// Inits an instance of `PaymentSplitter` where each account in `payees` is assigned the number of shares at\n    /// the matching position in the `shares` array.\n    ///\n    /// All addresses in `payees` must be non-zero. Both arrays must have the same non-zero length, and there must be no\n    /// duplicates in `payees`.\n    ///\n    /// Emits `PayeeAdded` on each account.\n    fn _init(&mut self, payees_and_shares: Vec<(AccountId, Balance)>) -> Result<(), PaymentSplitterError>;\n\n    fn _add_payee(&mut self, payee: AccountId, share: Balance) -> Result<(), PaymentSplitterError>;\n\n    /// Calls the `release` method for each `AccountId` in the `payees` vec.\n    fn _release_all(&mut self) -> Result<(), PaymentSplitterError>;\n\n    fn _release(&mut self, account: AccountId) -> Result<(), PaymentSplitterError>;\n}\n\npub trait InternalImpl: Storage<Data> + Internal {\n    fn _emit_payee_added_event(&self, _account: AccountId, _shares: Balance) {}\n\n    fn _emit_payment_received_event(&self, _from: AccountId, _amount: Balance) {}\n\n    fn _emit_payment_released_event(&self, _to: AccountId, _amount: Balance) {}\n\n    fn _init(&mut self, payees_and_shares: Vec<(AccountId, Balance)>) -> Result<(), PaymentSplitterError> {\n        if payees_and_shares.is_empty() {\n            return Err(PaymentSplitterError::NoPayees)\n        }\n\n        for (payee, share) in payees_and_shares.into_iter() {\n            Internal::_add_payee(self, payee, share)?;\n        }\n        Ok(())\n    }\n\n    fn _add_payee(&mut self, payee: AccountId, share: Balance) -> Result<(), PaymentSplitterError> {\n        if share == 0 {\n            return Err(PaymentSplitterError::SharesAreZero)\n        }\n        if self.data().shares.get(&payee).is_some() {\n            return Err(PaymentSplitterError::AlreadyHasShares)\n        }\n\n        let mut payees = self.data().payees.get_or_default();\n        payees.push(payee);\n        self.data().payees.set(&payees);\n\n        self.data().shares.insert(&payee, &share);\n\n        let new_shares = self.data().total_shares.get_or_default() + share;\n        self.data().total_shares.set(&new_shares);\n\n        Internal::_emit_payee_added_event(self, payee, share);\n        Ok(())\n    }\n\n    fn _release_all(&mut self) -> Result<(), PaymentSplitterError> {\n        let payees = self.data().payees.get_or_default();\n        let len = payees.len();\n\n        for account in payees.iter().take(len) {\n            Internal::_release(self, *account)?;\n        }\n\n        Ok(())\n    }\n\n    fn _release(&mut self, account: AccountId) -> Result<(), PaymentSplitterError> {\n        if self.data().shares.get(&account).is_none() {\n            return Err(PaymentSplitterError::AccountHasNoShares)\n        }\n\n        let balance = Self::env().balance();\n        let current_balance = balance.checked_sub(Self::env().minimum_balance()).unwrap_or_default();\n        let total_released = self.data().total_released.get_or_default();\n        let total_received = current_balance + total_released;\n        let shares = self.data().shares.get(&account).unwrap();\n        let total_shares = self.data().total_shares.get_or_default();\n        let released = self.data().released.get(&account).unwrap_or_default();\n        let payment = total_received * shares / total_shares - released;\n\n        if payment == 0 {\n            return Err(PaymentSplitterError::AccountIsNotDuePayment)\n        }\n\n        self.data().released.insert(&account, &(released + payment));\n        self.data().total_released.set(&(total_released + payment));\n\n        let transfer_result = Self::env().transfer(account, payment);\n        if transfer_result.is_err() {\n            return Err(PaymentSplitterError::TransferFailed)\n        }\n        Internal::_emit_payment_released_event(self, account, payment);\n        Ok(())\n    }\n}"
    },
    {
      "filename": "contracts/src/finance/payment_splitter/mod.rs",
      "content": "// Copyright (c) 2012-2022 Supercolony\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\"Software\"),\n// to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\npub use crate::{\n    payment_splitter,\n    traits::payment_splitter::*,\n};\nuse ink::prelude::vec::Vec;\nuse openbrush::{\n    storage::Mapping,\n    traits::{\n        AccountId,\n        Balance,\n        Storage,\n    },\n};\npub use payment_splitter::Internal as _;\n\n#[derive(Default, Debug)]\n#[openbrush::storage_item]\npub struct Data {\n    #[lazy]\n    pub total_shares: Balance,\n    #[lazy]\n    pub total_released: Balance,\n    pub shares: Mapping<AccountId, Balance>,\n    pub released: Mapping<AccountId, Balance>,\n    #[lazy]\n    pub payees: Vec<AccountId>,\n}\n\npub trait PaymentSplitterImpl: Storage<Data> + Internal {\n    fn total_shares(&self) -> Balance {\n        self.data().total_shares.get_or_default()\n    }\n\n    fn total_released(&self) -> Balance {\n        self.data().total_released.get_or_default()\n    }\n\n    fn shares(&self, account: AccountId) -> Balance {\n        self.data().shares.get(&account).unwrap_or(0)\n    }\n\n    fn released(&self, account: AccountId) -> Balance {\n        self.data().released.get(&account).unwrap_or(0)\n    }\n\n    fn payee(&self, index: u32) -> Option<AccountId> {\n        self.data().payees.get_or_default().get(index as usize).cloned()\n    }\n\n    fn receive(&mut self) {\n        self._emit_payee_added_event(Self::env().caller(), Self::env().transferred_value())\n    }\n\n    fn release(&mut self, account: AccountId) -> Result<(), PaymentSplitterError> {\n        self._release(account)\n    }\n}\n\npub trait Internal {\n    /// User must override those methods in their contract.\n    fn _emit_payee_added_event(&self, account: AccountId, shares: Balance);\n\n    fn _emit_payment_received_event(&self, from: AccountId, amount: Balance);\n\n    fn _emit_payment_released_event(&self, to: AccountId, amount: Balance);\n\n    /// Inits an instance of `PaymentSplitter` where each account in `payees` is assigned the number of shares at\n    /// the matching position in the `shares` array.\n    ///\n    /// All addresses in `payees` must be non-zero. Both arrays must have the same non-zero length, and there must be no\n    /// duplicates in `payees`.\n    ///\n    /// Emits `PayeeAdded` on each account.\n    fn _init(&mut self, payees_and_shares: Vec<(AccountId, Balance)>) -> Result<(), PaymentSplitterError>;\n\n    fn _add_payee(&mut self, payee: AccountId, share: Balance) -> Result<(), PaymentSplitterError>;\n\n    /// Calls the `release` method for each `AccountId` in the `payees` vec.\n    fn _release_all(&mut self) -> Result<(), PaymentSplitterError>;\n\n    fn _release(&mut self, account: AccountId) -> Result<(), PaymentSplitterError>;\n}\n\npub trait InternalImpl: Storage<Data> + Internal {\n    fn _emit_payee_added_event(&self, _account: AccountId, _shares: Balance) {}\n\n    fn _emit_payment_received_event(&self, _from: AccountId, _amount: Balance) {}\n\n    fn _emit_payment_released_event(&self, _to: AccountId, _amount: Balance) {}\n\n    fn _init(&mut self, payees_and_shares: Vec<(AccountId, Balance)>) -> Result<(), PaymentSplitterError> {\n        if payees_and_shares.is_empty() {\n            return Err(PaymentSplitterError::NoPayees)\n        }\n\n        for (payee, share) in payees_and_shares.into_iter() {\n            Internal::_add_payee(self, payee, share)?;\n        }\n        Ok(())\n    }\n\n    fn _add_payee(&mut self, payee: AccountId, share: Balance) -> Result<(), PaymentSplitterError> {\n        if share == 0 {\n            return Err(PaymentSplitterError::SharesAreZero)\n        }\n        if self.data().shares.get(&payee).is_some() {\n            return Err(PaymentSplitterError::AlreadyHasShares)\n        }\n\n        let mut payees = self.data().payees.get_or_default();\n        payees.push(payee);\n        self.data().payees.set(&payees);\n\n        self.data().shares.insert(&payee, &share);\n\n        let new_shares = self.data().total_shares.get_or_default() + share;\n        self.data().total_shares.set(&new_shares);\n\n        Internal::_emit_payee_added_event(self, payee, share);\n        Ok(())\n    }\n\n    fn _release_all(&mut self) -> Result<(), PaymentSplitterError> {\n        let payees = self.data().payees.get_or_default();\n        let len = payees.len();\n\n        for account in payees.iter().take(len) {\n            Internal::_release(self, *account)?;\n        }\n\n        Ok(())\n    }\n\n    fn _release(&mut self, account: AccountId) -> Result<(), PaymentSplitterError> {\n        if self.data().shares.get(&account).is_none() {\n            return Err(PaymentSplitterError::AccountHasNoShares)\n        }\n\n        let balance = Self::env().balance();\n        let current_balance = balance.checked_sub(Self::env().minimum_balance()).unwrap_or_default();\n        let total_released = self.data().total_released.get_or_default();\n        let total_received = current_balance + total_released;\n        let shares = self.data().shares.get(&account).unwrap();\n        let total_shares = self.data().total_shares.get_or_default();\n        let released = self.data().released.get(&account).unwrap_or_default();\n        let payment = total_received * shares / total_shares - released;\n\n        if payment == 0 {\n            return Err(PaymentSplitterError::AccountIsNotDuePayment)\n        }\n\n        self.data().released.insert(&account, &(released + payment));\n        self.data().total_released.set(&(total_released + payment));\n\n        let transfer_result = Self::env().transfer(account, payment);\n        if transfer_result.is_err() {\n            return Err(PaymentSplitterError::TransferFailed)\n        }\n        Internal::_emit_payment_released_event(self, account, payment);\n        Ok(())\n    }\n}"
    }
  ]
}