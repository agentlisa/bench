{
  "Title": "M-8: Permissioned rebalancing functions leading to loss of assets",
  "Content": "# Issue M-8: Permissioned rebalancing functions leading to loss of assets \n\nSource: https://github.com/sherlock-audit/2024-01-napier-judging/issues/99 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nArabadzhiev, ZanyBonzy, cawfree, thisvishalsingh, xiaoming90\n## Summary\n\nPermissioned rebalancing functions that could only be accessed by admin could lead to a loss of assets.\n\n## Vulnerability Detail\n\nPer the contest's README page, it stated that the admin/owner is \"RESTRICTED\". Thus, any finding showing that the owner/admin can steal a user's funds, cause loss of funds or harm to the users, or cause the user's fund to be struck is valid in this audit contest.\n\n> Q: Is the admin/owner of the protocol/contracts TRUSTED or RESTRICTED?\n>\n> RESTRICTED\n\nThe following describes a way where the admin can block users from withdrawing their assets from the protocol\n\n1. The admin calls the `setRebalancer` function to set the rebalance to a wallet address owned by them.\n\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/napier-v1/src/adapters/BaseLSTAdapter.sol#L245\n\n```solidity\nFile: BaseLSTAdapter.sol\n245:     function setRebalancer(address _rebalancer) external onlyOwner {\n246:         rebalancer = _rebalancer;\n247:     }\n```\n\n2. The admin calls the `setTargetBufferPercentage` the set the `targetBufferPercentage` to the smallest possible value of 1%. This will cause only 1% of the total ETH deposited by all the users to reside on the adaptor contract. This will cause the ETH buffer to deplete quickly and cause all the redemption and withdrawal to revert.\n\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/napier-v1/src/adapters/BaseLSTAdapter.sol#L251\n\n```solidity\nFile: BaseLSTAdapter.sol\n251:     function setTargetBufferPercentage(uint256 _targetBufferPercentage) external onlyRebalancer {\n252:         if (_targetBufferPercentage < MIN_BUFFER_PERCENTAGE || _targetBufferPercentage > BUFFER_PERCENTAGE_PRECISION) {\n253:             revert InvalidBufferPercentage();\n254:         }\n255:         targetBufferPercentage = _targetBufferPercentage;\n256:     }\n```\n\n3. The owner calls the `setRebalancer` function again and sets the rebalancer address to `address(0)`. As such, no one has the ability to call functions that are only accessible by rebalancer. The `requestWithdrawal` and `requestWithdrawalAll` functions are only accessible by rebalancer. Thus, no one can call these two functions to replenish the ETH buffer in the adaptor contract.\n4. When this state is reached, users can no longer withdraw their assets from the protocol, and their assets are stuck in the contract. This effectively causes them to lose their assets.\n\n## Impact\n\nLoss of assets for the victim.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/napier-v1/src/adapters/BaseLSTAdapter.sol#L245\n\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/napier-v1/src/adapters/BaseLSTAdapter.sol#L251\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nTo prevent the above scenario, the minimum `targetBufferPercentage` should be set to a higher percentage such as 5 or 10%, and the `requestWithdrawal` function should be made permissionless, so that even if the rebalancer does not do its job, anyone else can still initiate the rebalancing process to replenish the adaptor's ETH buffer for user's withdrawal.\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  invalid\n\n\n\n**massun-onibakuchi**\n\nWe are aware of such issues. The owner account is set to governance or multisig. To prevent the target buffer from becoming too low, it is set to 10% by default. This value can be changed even after deployment. Additionally, executing rebalancing functions may reduce the scale of the adapter. Making such functions callable by anyone would, conversely, become a vulnerability. Considering this trade-off, we chose to make it a permissioned function.\n\n**nevillehuang**\n\nEscalate\n\nUnsure why this issue was excluded. The issue is highlighting how a potentially malicious protocol admin can cause a permanent DoS on users for core functionalities such as redemptions and withdrawals. Given protocol admins are explicitly mentioned as restricted in the contest details, I believe this issue should be valid medium severity.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> Unsure why this issue was excluded. The issue is highlighting how a potentially malicious protocol admin can cause a permanent DoS on users for core functionalities such as redemptions and withdrawals. Given protocol admins are explicitly mentioned as restricted in the contest details, I believe this issue should be valid medium severity.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**xiaoming9090**\n\nAgree with Nevi. This report and its duplicates highlighted that it is possible for a malicious admin to negatively impact the users. Thus, it should be valid as per Sherlock's contest rules as admin is \"restricted\" in the contest's README.\n\n**ABDuullahi**\n\nThis should stay invalid i believe, the README says `Rebalancer: An account can manage adapter and request withdrawal for liquid staking tokens. It can't steal funds.` and this issue does not describe a situation where the role can steal funds.\n\n**xiaoming9090**\n\n> 4\\. users can no longer withdraw their assets from the protocol, and their assets are stuck in the contract\n\nThe ability for the malicious admin (with rebalancer role) to cause users to be unable to withdraw their assets from the protocol, and in turn lead to their assets being stuck, is sufficient for this issue to be valid.\n\n**cvetanovv**\n\nI disagree with the escalation. \nThe reason the report is not valid is the first comment from the sponsor. As we can see this is a design decision. \nOther than that, one of the recommendations is that `targetBufferPercentage` should be higher. But this is a configuration value that can be changed. So I think the report should remain Low/Invalid.\n\n**xiaoming9090**\n\n> I disagree with the escalation. The reason the report is not valid is the first comment from the sponsor. As we can see this is a design decision. Other than that, one of the recommendations is that `targetBufferPercentage` should be higher. But this is a configuration value that can be changed. So I think the report should remain Low/Invalid.\n\nA malicious admin can set the `targetBufferPercentage` is configured to the lowest possible value, and then calls the `setRebalancer` function again and sets the rebalancer address to address(0). As such, no one has the ability to call functions that are only accessible by rebalancer. The `requestWithdrawal` and `requestWithdrawalAll` functions are only accessible by rebalancer. Thus, no one can call these two functions to replenish the ETH buffer in the adaptor contract.\n\nWhen the ETH buffer is not replenished, no one can withdraw from the protocol. This is sufficient to show that it is possible for malicious admins to harm users by preventing them from withdrawing. Note that the admin is restricted in this contest.\n\n**ABDuullahi**\n\nI think sherlock rules stated that the restriction must be explicitly mentioned, and for this role, its that `it cant steal funds`, not to disrupt the claiming/withdrawal process\n\n**nevillehuang**\n\n@ABDuullahi This issue is initiated by the admin (owner of contracts), not the rebalancer.\n\n**Czar102**\n\n> This issue is initiated by the admin (owner of contracts), not the rebalancer.\n\n@nevillehuang is the rebalancer relevant to this issue at all?\n\nIf not, I am planning to consider this a Medium severity issue and accept the escalation, with similar reasons to the ones listed here: https://github.com/sherlock-audit/2024-01-napier-judging/issues/97#issuecomment-1997410230.\n\n**nevillehuang**\n\n@Czar102 Not relevant, the admin can set the rebalancer to an address they control and/or themselves and execute the DoS\n\n**Czar102**\n\n@nevillehuang @cvetanovv is this a correct and full list of duplicates?\n#11, #21, #26, #119\n\n**Czar102**\n\nResult:\nMedium\nHas duplicates\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [nevillehuang](https://github.com/sherlock-audit/2024-01-napier-judging/issues/99/#issuecomment-1984813068): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/171",
  "Code": [
    {
      "filename": "napier-v1/src/adapters/BaseLSTAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport {IWETH9} from \"../interfaces/IWETH9.sol\";\nimport {IERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/IERC20.sol\";\n\nimport {BaseAdapter} from \"../BaseAdapter.sol\";\nimport {ERC4626} from \"@openzeppelin/contracts@4.9.3/token/ERC20/extensions/ERC4626.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts@4.9.3/security/ReentrancyGuard.sol\";\n\nimport {SafeCast} from \"@openzeppelin/contracts@4.9.3/utils/math/SafeCast.sol\";\nimport {WETH} from \"../Constants.sol\";\n\n/// @notice Adapter for Liquid Staking Token (LST)\n/// @dev This adapter facilitates immediate ETH withdrawals without a waiting period.\n/// It maintains an ETH buffer to enable these withdrawals. The size of this buffer is determined\n/// by a specified desired buffer percentage. The maintenance of the buffer\n/// are handled by a designated account.\n/// @dev LST Adapter is NOT compatible with EIP4626 standard. We don't expect it to be used by other contracts other than Tranche.\nabstract contract BaseLSTAdapter is BaseAdapter, ERC4626, ReentrancyGuard {\n    using SafeCast for uint256;\n\n    uint256 constant BUFFER_PERCENTAGE_PRECISION = 1e18; // 1e18 = 100%\n    uint256 constant MIN_BUFFER_PERCENTAGE = 0.01 * 1e18; // 1%\n\n    /// @notice Rebalancer of the ETH buffer, can be set by the owner\n    /// @notice The account can request a withdrawal\n    address public rebalancer;\n\n    /// @notice Desired buffer percentage in WAD\n    uint256 public targetBufferPercentage = 0.1 * 1e18; // 10% desired buffer percentage\n\n    /// @notice Amount of ETH pending withdrawal\n    uint128 public withdrawalQueueEth;\n\n    /// @notice Amount of ETH available (Buffer), does not include pending withdrawal. Internal accounting of ETH\n    uint128 public bufferEth;\n\n    /// @notice Request ID of the withdrawal request\n    /// @dev 0 if there is no pending withdrawal request\n    uint256 public requestId;\n\n    error ZeroAssets();\n    error ZeroShares();\n    error InsufficientBuffer();\n    error BufferTooLarge();\n    error InvalidBufferPercentage();\n    error WithdrawalPending();\n    error NoPendingWithdrawal();\n    error NotRebalancer();\n    error NotImplemented();\n\n    /// @notice Reverts if the caller is not the rebalancer\n    modifier onlyRebalancer() {\n        if (rebalancer != msg.sender) revert NotRebalancer();\n        _;\n    }\n\n    /// @dev Adapter itself is the target token\n    constructor(address _rebalancer) BaseAdapter(WETH, address(this)) ERC4626((IWETH9(WETH))) {\n        rebalancer = _rebalancer;\n    }\n\n    ////////////////////////////////////////////////////////\n    /// ADAPTER METHOD\n    ////////////////////////////////////////////////////////\n\n    /// @notice Handles prefunded deposits\n    /// @return The amount of staked ETH\n    /// @return The amount of shares minted\n    function prefundedDeposit() external nonReentrant returns (uint256, uint256) {\n        uint256 bufferEthCache = bufferEth; // cache storage reads\n        uint256 queueEthCache = withdrawalQueueEth; // cache storage reads\n        uint256 assets = IWETH9(WETH).balanceOf(address(this)) - bufferEthCache; // amount of WETH deposited at this time\n        uint256 shares = previewDeposit(assets);\n\n        if (assets == 0) return (0, 0);\n        if (shares == 0) revert ZeroShares();\n\n        // Calculate the target buffer amount considering the user's deposit.\n        // bufferRatio is defined as the ratio of ETH balance to the total assets in the adapter in ETH.\n        // Formula:\n        // desiredBufferRatio = (withdrawalQueueEth + bufferEth + assets - s) / (withdrawalQueueEth + bufferEth + stakedEth + assets)\n        // Where:\n        // assets := Amount of ETH the user is depositing\n        // s := Amount of ETH to stake at this time, s <= bufferEth + assets.\n        //\n        // Thus, the formula can be simplified to:\n        // s = (withdrawalQueueEth + bufferEth + assets) - (withdrawalQueueEth + bufferEth + stakedEth + assets) * desiredBufferRatio\n        //   = (withdrawalQueueEth + bufferEth + assets) - targetBufferEth\n        //\n        // Flow:\n        // If `s` <= 0, don't stake any ETH.\n        // If `s` < bufferEth + assets, stake `s` amount of ETH.\n        // If `s` >= bufferEth + assets, all available ETH can be staked in theory.\n        // However, we cap the stake amount. This is to prevent the buffer from being completely drained.\n        //\n        // Let `a` be the available amount of ETH in the buffer after the deposit. `a` is calculated as:\n        // a = (bufferEth + assets) - s\n        uint256 targetBufferEth = ((totalAssets() + assets) * targetBufferPercentage) / BUFFER_PERCENTAGE_PRECISION;\n\n        /// WRITE ///\n        _mint(msg.sender, shares);\n\n        uint256 availableEth = bufferEthCache + assets; // non-zero\n\n        // If the buffer is insufficient: Doesn't stake any of the deposit\n        if (targetBufferEth >= availableEth + queueEthCache) {\n            bufferEth = availableEth.toUint128();\n            return (assets, shares);\n        }\n\n        uint256 stakeAmount;\n        unchecked {\n            stakeAmount = availableEth + queueEthCache - targetBufferEth; // non-zero, no underflow\n        }\n        // If the stake amount exceeds 95% of the available ETH, cap the stake amount.\n        // This is to prevent the buffer from being completely drained. This is not a complete solution.\n        //\n        // The condition: stakeAmount > availableEth, is equivalent to: queueEthCache > targetBufferEth\n        // Possible scenarios:\n        // - Target buffer percentage was changed to a lower value and there is a large withdrawal request pending.\n        // - There is a pending withdrawal request and the available ETH are not left in the buffer.\n        // - There is no pending withdrawal request and the available ETH are not left in the buffer.\n        uint256 maxStakeAmount = (availableEth * 95) / 100;\n        if (stakeAmount > maxStakeAmount) {\n            stakeAmount = maxStakeAmount; // max 95% of the available ETH\n        }\n\n        /// INTERACT ///\n        // Deposit into the yield source\n        // Actual amount of ETH spent may be less than the requested amount.\n        stakeAmount = _stake(stakeAmount); // stake amount can be 0\n\n        /// WRITE ///\n        bufferEth = (availableEth - stakeAmount).toUint128(); // no underflow theoretically\n\n        return (assets, shares);\n    }\n\n    /// @notice Handles prefunded redemptions\n    /// @dev Withdraw from the buffer. If the buffer is insufficient, revert with an error\n    /// @param recipient The address to receive the redeemed WETH\n    /// @return The amount of redeemed WETH\n    /// @return The amount of shares burned\n    function prefundedRedeem(address recipient) external virtual returns (uint256, uint256) {\n        uint256 shares = balanceOf(address(this));\n        uint256 assets = previewRedeem(shares);\n\n        if (shares == 0) return (0, 0);\n        if (assets == 0) revert ZeroAssets();\n\n        uint256 bufferEthCache = bufferEth;\n        // If the buffer is insufficient, shares cannot be redeemed immediately\n        // Need to wait for the withdrawal to be completed and the buffer to be refilled.\n        if (assets > bufferEthCache) revert InsufficientBuffer();\n\n        unchecked {\n            /// WRITE ///\n            // Reduce the buffer and burn the shares\n            bufferEth = (bufferEthCache - assets).toUint128(); // no underflow\n            _burn(address(this), shares);\n        }\n\n        /// INTERACT ///\n        IWETH9(WETH).transfer(recipient, assets);\n\n        return (assets, shares);\n    }\n\n    ////////////////////////////////////////////////////////\n    /// VIRTUAL METHOD\n    ////////////////////////////////////////////////////////\n\n    /// @notice Request a withdrawal of ETH\n    /// @dev This function is called by only the rebalancer\n    /// @dev Reverts if there is a pending withdrawal request\n    /// @dev Reverts if the buffer is sufficient to cover the desired buffer percentage of the total assets\n    function requestWithdrawal() external virtual nonReentrant onlyRebalancer {\n        if (requestId != 0) revert WithdrawalPending();\n\n        uint256 targetBufferEth = (totalAssets() * targetBufferPercentage) / BUFFER_PERCENTAGE_PRECISION;\n\n        // If the buffer exceeds the target buffer, revert.\n        // If the buffer is insufficient, request a withdrawal to refill the buffer.\n        // note: use `>=` instead of `>` to prevent amount of ETH to withdraw to be 0\n        // note: At this point, `withdrawalQueueEth` is 0 because there is no pending withdrawal request.\n        // `nonStakedEth` = `bufferEth` + 0 = `bufferEth`\n        uint256 bufferEthCache = bufferEth;\n        if (bufferEthCache >= targetBufferEth) revert BufferTooLarge();\n\n        unchecked {\n            // Ensure that `withdrawAmount` is non-zero and withdrawalQueueEth is zero.\n            uint256 withdrawAmount = targetBufferEth - bufferEthCache; // no underflow\n\n            /// WRITE & INTERACT ///\n            // Record the pending withdrawal request\n            // Request a withdrawal\n            (uint256 queueAmount, uint256 _requestId) = _requestWithdrawal(withdrawAmount);\n            withdrawalQueueEth = queueAmount.toUint128();\n            requestId = _requestId;\n        }\n    }\n\n    /// @notice Request a withdrawal of all staked ETH\n    /// @dev This function is called by only the rebalancer\n    /// @dev Reverts if there is a pending withdrawal request\n    function requestWithdrawalAll() external virtual;\n\n    /// @notice Claim the finized withdrawal request\n    /// @dev This function is called by anyone\n    /// @dev Reverts if there is no pending withdrawal request\n    function claimWithdrawal() external virtual;\n\n    /// @notice Stake the given amount of ETH into the yield source\n    /// @param stakeAmount The amount of ETH to stake\n    /// @return The actual amount of ETH spent\n    function _stake(uint256 stakeAmount) internal virtual returns (uint256);\n\n    /// @notice Request a withdrawal of the given amount of ETH from the yield source\n    /// @param withdrawAmount The amount of ETH to withdraw\n    /// @return queueAmount The amount of ETH withdrawn\n    /// @return requestId The request Id of the withdrawal request\n    function _requestWithdrawal(\n        uint256 withdrawAmount\n    ) internal virtual returns (uint256 queueAmount, uint256 requestId);\n\n    /// @dev Must be overridden by inheriting contracts\n    /// @inheritdoc ERC4626\n    function totalAssets() public view virtual override returns (uint256) {}\n\n    function scale() external view override returns (uint256) {\n        return convertToAssets(1e18);\n    }\n\n    /// @notice Returns the present buffer percentage in WAD. e.g) 10% => 0.1 * 1e18\n    function bufferPresentPercentage() external view returns (uint256) {\n        return ((bufferEth + withdrawalQueueEth) * BUFFER_PERCENTAGE_PRECISION) / totalAssets();\n    }\n\n    ////////////////////////////////////////////////////////\n    /// ADMIN METHOD\n    ////////////////////////////////////////////////////////\n\n    function setRebalancer(address _rebalancer) external onlyOwner {\n        rebalancer = _rebalancer;\n    }\n\n    /// @notice Set the maximum buffer percentage\n    /// @param _targetBufferPercentage The maximum buffer percentage in WAD\n    function setTargetBufferPercentage(uint256 _targetBufferPercentage) external onlyRebalancer {\n        if (_targetBufferPercentage < MIN_BUFFER_PERCENTAGE || _targetBufferPercentage > BUFFER_PERCENTAGE_PRECISION) {\n            revert InvalidBufferPercentage();\n        }\n        targetBufferPercentage = _targetBufferPercentage;\n    }\n\n    /////////////////////////////////////////////////////////\n    /// NOT IMPLEMENTED METHOD\n    /////////////////////////////////////////////////////////\n\n    /// @notice direct deposit,mint,redeem,withdraw should be reverted.\n    function deposit(uint256, address) public pure override returns (uint256) {\n        revert NotImplemented();\n    }\n\n    function mint(uint256, address) public pure override returns (uint256) {\n        revert NotImplemented();\n    }\n\n    function withdraw(uint256, address, address) public pure override returns (uint256) {\n        revert NotImplemented();\n    }\n\n    function redeem(uint256, address, address) public pure override returns (uint256) {\n        revert NotImplemented();\n    }\n}"
    },
    {
      "filename": "napier-v1/src/adapters/BaseLSTAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport {IWETH9} from \"../interfaces/IWETH9.sol\";\nimport {IERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/IERC20.sol\";\n\nimport {BaseAdapter} from \"../BaseAdapter.sol\";\nimport {ERC4626} from \"@openzeppelin/contracts@4.9.3/token/ERC20/extensions/ERC4626.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts@4.9.3/security/ReentrancyGuard.sol\";\n\nimport {SafeCast} from \"@openzeppelin/contracts@4.9.3/utils/math/SafeCast.sol\";\nimport {WETH} from \"../Constants.sol\";\n\n/// @notice Adapter for Liquid Staking Token (LST)\n/// @dev This adapter facilitates immediate ETH withdrawals without a waiting period.\n/// It maintains an ETH buffer to enable these withdrawals. The size of this buffer is determined\n/// by a specified desired buffer percentage. The maintenance of the buffer\n/// are handled by a designated account.\n/// @dev LST Adapter is NOT compatible with EIP4626 standard. We don't expect it to be used by other contracts other than Tranche.\nabstract contract BaseLSTAdapter is BaseAdapter, ERC4626, ReentrancyGuard {\n    using SafeCast for uint256;\n\n    uint256 constant BUFFER_PERCENTAGE_PRECISION = 1e18; // 1e18 = 100%\n    uint256 constant MIN_BUFFER_PERCENTAGE = 0.01 * 1e18; // 1%\n\n    /// @notice Rebalancer of the ETH buffer, can be set by the owner\n    /// @notice The account can request a withdrawal\n    address public rebalancer;\n\n    /// @notice Desired buffer percentage in WAD\n    uint256 public targetBufferPercentage = 0.1 * 1e18; // 10% desired buffer percentage\n\n    /// @notice Amount of ETH pending withdrawal\n    uint128 public withdrawalQueueEth;\n\n    /// @notice Amount of ETH available (Buffer), does not include pending withdrawal. Internal accounting of ETH\n    uint128 public bufferEth;\n\n    /// @notice Request ID of the withdrawal request\n    /// @dev 0 if there is no pending withdrawal request\n    uint256 public requestId;\n\n    error ZeroAssets();\n    error ZeroShares();\n    error InsufficientBuffer();\n    error BufferTooLarge();\n    error InvalidBufferPercentage();\n    error WithdrawalPending();\n    error NoPendingWithdrawal();\n    error NotRebalancer();\n    error NotImplemented();\n\n    /// @notice Reverts if the caller is not the rebalancer\n    modifier onlyRebalancer() {\n        if (rebalancer != msg.sender) revert NotRebalancer();\n        _;\n    }\n\n    /// @dev Adapter itself is the target token\n    constructor(address _rebalancer) BaseAdapter(WETH, address(this)) ERC4626((IWETH9(WETH))) {\n        rebalancer = _rebalancer;\n    }\n\n    ////////////////////////////////////////////////////////\n    /// ADAPTER METHOD\n    ////////////////////////////////////////////////////////\n\n    /// @notice Handles prefunded deposits\n    /// @return The amount of staked ETH\n    /// @return The amount of shares minted\n    function prefundedDeposit() external nonReentrant returns (uint256, uint256) {\n        uint256 bufferEthCache = bufferEth; // cache storage reads\n        uint256 queueEthCache = withdrawalQueueEth; // cache storage reads\n        uint256 assets = IWETH9(WETH).balanceOf(address(this)) - bufferEthCache; // amount of WETH deposited at this time\n        uint256 shares = previewDeposit(assets);\n\n        if (assets == 0) return (0, 0);\n        if (shares == 0) revert ZeroShares();\n\n        // Calculate the target buffer amount considering the user's deposit.\n        // bufferRatio is defined as the ratio of ETH balance to the total assets in the adapter in ETH.\n        // Formula:\n        // desiredBufferRatio = (withdrawalQueueEth + bufferEth + assets - s) / (withdrawalQueueEth + bufferEth + stakedEth + assets)\n        // Where:\n        // assets := Amount of ETH the user is depositing\n        // s := Amount of ETH to stake at this time, s <= bufferEth + assets.\n        //\n        // Thus, the formula can be simplified to:\n        // s = (withdrawalQueueEth + bufferEth + assets) - (withdrawalQueueEth + bufferEth + stakedEth + assets) * desiredBufferRatio\n        //   = (withdrawalQueueEth + bufferEth + assets) - targetBufferEth\n        //\n        // Flow:\n        // If `s` <= 0, don't stake any ETH.\n        // If `s` < bufferEth + assets, stake `s` amount of ETH.\n        // If `s` >= bufferEth + assets, all available ETH can be staked in theory.\n        // However, we cap the stake amount. This is to prevent the buffer from being completely drained.\n        //\n        // Let `a` be the available amount of ETH in the buffer after the deposit. `a` is calculated as:\n        // a = (bufferEth + assets) - s\n        uint256 targetBufferEth = ((totalAssets() + assets) * targetBufferPercentage) / BUFFER_PERCENTAGE_PRECISION;\n\n        /// WRITE ///\n        _mint(msg.sender, shares);\n\n        uint256 availableEth = bufferEthCache + assets; // non-zero\n\n        // If the buffer is insufficient: Doesn't stake any of the deposit\n        if (targetBufferEth >= availableEth + queueEthCache) {\n            bufferEth = availableEth.toUint128();\n            return (assets, shares);\n        }\n\n        uint256 stakeAmount;\n        unchecked {\n            stakeAmount = availableEth + queueEthCache - targetBufferEth; // non-zero, no underflow\n        }\n        // If the stake amount exceeds 95% of the available ETH, cap the stake amount.\n        // This is to prevent the buffer from being completely drained. This is not a complete solution.\n        //\n        // The condition: stakeAmount > availableEth, is equivalent to: queueEthCache > targetBufferEth\n        // Possible scenarios:\n        // - Target buffer percentage was changed to a lower value and there is a large withdrawal request pending.\n        // - There is a pending withdrawal request and the available ETH are not left in the buffer.\n        // - There is no pending withdrawal request and the available ETH are not left in the buffer.\n        uint256 maxStakeAmount = (availableEth * 95) / 100;\n        if (stakeAmount > maxStakeAmount) {\n            stakeAmount = maxStakeAmount; // max 95% of the available ETH\n        }\n\n        /// INTERACT ///\n        // Deposit into the yield source\n        // Actual amount of ETH spent may be less than the requested amount.\n        stakeAmount = _stake(stakeAmount); // stake amount can be 0\n\n        /// WRITE ///\n        bufferEth = (availableEth - stakeAmount).toUint128(); // no underflow theoretically\n\n        return (assets, shares);\n    }\n\n    /// @notice Handles prefunded redemptions\n    /// @dev Withdraw from the buffer. If the buffer is insufficient, revert with an error\n    /// @param recipient The address to receive the redeemed WETH\n    /// @return The amount of redeemed WETH\n    /// @return The amount of shares burned\n    function prefundedRedeem(address recipient) external virtual returns (uint256, uint256) {\n        uint256 shares = balanceOf(address(this));\n        uint256 assets = previewRedeem(shares);\n\n        if (shares == 0) return (0, 0);\n        if (assets == 0) revert ZeroAssets();\n\n        uint256 bufferEthCache = bufferEth;\n        // If the buffer is insufficient, shares cannot be redeemed immediately\n        // Need to wait for the withdrawal to be completed and the buffer to be refilled.\n        if (assets > bufferEthCache) revert InsufficientBuffer();\n\n        unchecked {\n            /// WRITE ///\n            // Reduce the buffer and burn the shares\n            bufferEth = (bufferEthCache - assets).toUint128(); // no underflow\n            _burn(address(this), shares);\n        }\n\n        /// INTERACT ///\n        IWETH9(WETH).transfer(recipient, assets);\n\n        return (assets, shares);\n    }\n\n    ////////////////////////////////////////////////////////\n    /// VIRTUAL METHOD\n    ////////////////////////////////////////////////////////\n\n    /// @notice Request a withdrawal of ETH\n    /// @dev This function is called by only the rebalancer\n    /// @dev Reverts if there is a pending withdrawal request\n    /// @dev Reverts if the buffer is sufficient to cover the desired buffer percentage of the total assets\n    function requestWithdrawal() external virtual nonReentrant onlyRebalancer {\n        if (requestId != 0) revert WithdrawalPending();\n\n        uint256 targetBufferEth = (totalAssets() * targetBufferPercentage) / BUFFER_PERCENTAGE_PRECISION;\n\n        // If the buffer exceeds the target buffer, revert.\n        // If the buffer is insufficient, request a withdrawal to refill the buffer.\n        // note: use `>=` instead of `>` to prevent amount of ETH to withdraw to be 0\n        // note: At this point, `withdrawalQueueEth` is 0 because there is no pending withdrawal request.\n        // `nonStakedEth` = `bufferEth` + 0 = `bufferEth`\n        uint256 bufferEthCache = bufferEth;\n        if (bufferEthCache >= targetBufferEth) revert BufferTooLarge();\n\n        unchecked {\n            // Ensure that `withdrawAmount` is non-zero and withdrawalQueueEth is zero.\n            uint256 withdrawAmount = targetBufferEth - bufferEthCache; // no underflow\n\n            /// WRITE & INTERACT ///\n            // Record the pending withdrawal request\n            // Request a withdrawal\n            (uint256 queueAmount, uint256 _requestId) = _requestWithdrawal(withdrawAmount);\n            withdrawalQueueEth = queueAmount.toUint128();\n            requestId = _requestId;\n        }\n    }\n\n    /// @notice Request a withdrawal of all staked ETH\n    /// @dev This function is called by only the rebalancer\n    /// @dev Reverts if there is a pending withdrawal request\n    function requestWithdrawalAll() external virtual;\n\n    /// @notice Claim the finized withdrawal request\n    /// @dev This function is called by anyone\n    /// @dev Reverts if there is no pending withdrawal request\n    function claimWithdrawal() external virtual;\n\n    /// @notice Stake the given amount of ETH into the yield source\n    /// @param stakeAmount The amount of ETH to stake\n    /// @return The actual amount of ETH spent\n    function _stake(uint256 stakeAmount) internal virtual returns (uint256);\n\n    /// @notice Request a withdrawal of the given amount of ETH from the yield source\n    /// @param withdrawAmount The amount of ETH to withdraw\n    /// @return queueAmount The amount of ETH withdrawn\n    /// @return requestId The request Id of the withdrawal request\n    function _requestWithdrawal(\n        uint256 withdrawAmount\n    ) internal virtual returns (uint256 queueAmount, uint256 requestId);\n\n    /// @dev Must be overridden by inheriting contracts\n    /// @inheritdoc ERC4626\n    function totalAssets() public view virtual override returns (uint256) {}\n\n    function scale() external view override returns (uint256) {\n        return convertToAssets(1e18);\n    }\n\n    /// @notice Returns the present buffer percentage in WAD. e.g) 10% => 0.1 * 1e18\n    function bufferPresentPercentage() external view returns (uint256) {\n        return ((bufferEth + withdrawalQueueEth) * BUFFER_PERCENTAGE_PRECISION) / totalAssets();\n    }\n\n    ////////////////////////////////////////////////////////\n    /// ADMIN METHOD\n    ////////////////////////////////////////////////////////\n\n    function setRebalancer(address _rebalancer) external onlyOwner {\n        rebalancer = _rebalancer;\n    }\n\n    /// @notice Set the maximum buffer percentage\n    /// @param _targetBufferPercentage The maximum buffer percentage in WAD\n    function setTargetBufferPercentage(uint256 _targetBufferPercentage) external onlyRebalancer {\n        if (_targetBufferPercentage < MIN_BUFFER_PERCENTAGE || _targetBufferPercentage > BUFFER_PERCENTAGE_PRECISION) {\n            revert InvalidBufferPercentage();\n        }\n        targetBufferPercentage = _targetBufferPercentage;\n    }\n\n    /////////////////////////////////////////////////////////\n    /// NOT IMPLEMENTED METHOD\n    /////////////////////////////////////////////////////////\n\n    /// @notice direct deposit,mint,redeem,withdraw should be reverted.\n    function deposit(uint256, address) public pure override returns (uint256) {\n        revert NotImplemented();\n    }\n\n    function mint(uint256, address) public pure override returns (uint256) {\n        revert NotImplemented();\n    }\n\n    function withdraw(uint256, address, address) public pure override returns (uint256) {\n        revert NotImplemented();\n    }\n\n    function redeem(uint256, address, address) public pure override returns (uint256) {\n        revert NotImplemented();\n    }\n}"
    },
    {
      "filename": "napier-v1/src/adapters/BaseLSTAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport {IWETH9} from \"../interfaces/IWETH9.sol\";\nimport {IERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/IERC20.sol\";\n\nimport {BaseAdapter} from \"../BaseAdapter.sol\";\nimport {ERC4626} from \"@openzeppelin/contracts@4.9.3/token/ERC20/extensions/ERC4626.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts@4.9.3/security/ReentrancyGuard.sol\";\n\nimport {SafeCast} from \"@openzeppelin/contracts@4.9.3/utils/math/SafeCast.sol\";\nimport {WETH} from \"../Constants.sol\";\n\n/// @notice Adapter for Liquid Staking Token (LST)\n/// @dev This adapter facilitates immediate ETH withdrawals without a waiting period.\n/// It maintains an ETH buffer to enable these withdrawals. The size of this buffer is determined\n/// by a specified desired buffer percentage. The maintenance of the buffer\n/// are handled by a designated account.\n/// @dev LST Adapter is NOT compatible with EIP4626 standard. We don't expect it to be used by other contracts other than Tranche.\nabstract contract BaseLSTAdapter is BaseAdapter, ERC4626, ReentrancyGuard {\n    using SafeCast for uint256;\n\n    uint256 constant BUFFER_PERCENTAGE_PRECISION = 1e18; // 1e18 = 100%\n    uint256 constant MIN_BUFFER_PERCENTAGE = 0.01 * 1e18; // 1%\n\n    /// @notice Rebalancer of the ETH buffer, can be set by the owner\n    /// @notice The account can request a withdrawal\n    address public rebalancer;\n\n    /// @notice Desired buffer percentage in WAD\n    uint256 public targetBufferPercentage = 0.1 * 1e18; // 10% desired buffer percentage\n\n    /// @notice Amount of ETH pending withdrawal\n    uint128 public withdrawalQueueEth;\n\n    /// @notice Amount of ETH available (Buffer), does not include pending withdrawal. Internal accounting of ETH\n    uint128 public bufferEth;\n\n    /// @notice Request ID of the withdrawal request\n    /// @dev 0 if there is no pending withdrawal request\n    uint256 public requestId;\n\n    error ZeroAssets();\n    error ZeroShares();\n    error InsufficientBuffer();\n    error BufferTooLarge();\n    error InvalidBufferPercentage();\n    error WithdrawalPending();\n    error NoPendingWithdrawal();\n    error NotRebalancer();\n    error NotImplemented();\n\n    /// @notice Reverts if the caller is not the rebalancer\n    modifier onlyRebalancer() {\n        if (rebalancer != msg.sender) revert NotRebalancer();\n        _;\n    }\n\n    /// @dev Adapter itself is the target token\n    constructor(address _rebalancer) BaseAdapter(WETH, address(this)) ERC4626((IWETH9(WETH))) {\n        rebalancer = _rebalancer;\n    }\n\n    ////////////////////////////////////////////////////////\n    /// ADAPTER METHOD\n    ////////////////////////////////////////////////////////\n\n    /// @notice Handles prefunded deposits\n    /// @return The amount of staked ETH\n    /// @return The amount of shares minted\n    function prefundedDeposit() external nonReentrant returns (uint256, uint256) {\n        uint256 bufferEthCache = bufferEth; // cache storage reads\n        uint256 queueEthCache = withdrawalQueueEth; // cache storage reads\n        uint256 assets = IWETH9(WETH).balanceOf(address(this)) - bufferEthCache; // amount of WETH deposited at this time\n        uint256 shares = previewDeposit(assets);\n\n        if (assets == 0) return (0, 0);\n        if (shares == 0) revert ZeroShares();\n\n        // Calculate the target buffer amount considering the user's deposit.\n        // bufferRatio is defined as the ratio of ETH balance to the total assets in the adapter in ETH.\n        // Formula:\n        // desiredBufferRatio = (withdrawalQueueEth + bufferEth + assets - s) / (withdrawalQueueEth + bufferEth + stakedEth + assets)\n        // Where:\n        // assets := Amount of ETH the user is depositing\n        // s := Amount of ETH to stake at this time, s <= bufferEth + assets.\n        //\n        // Thus, the formula can be simplified to:\n        // s = (withdrawalQueueEth + bufferEth + assets) - (withdrawalQueueEth + bufferEth + stakedEth + assets) * desiredBufferRatio\n        //   = (withdrawalQueueEth + bufferEth + assets) - targetBufferEth\n        //\n        // Flow:\n        // If `s` <= 0, don't stake any ETH.\n        // If `s` < bufferEth + assets, stake `s` amount of ETH.\n        // If `s` >= bufferEth + assets, all available ETH can be staked in theory.\n        // However, we cap the stake amount. This is to prevent the buffer from being completely drained.\n        //\n        // Let `a` be the available amount of ETH in the buffer after the deposit. `a` is calculated as:\n        // a = (bufferEth + assets) - s\n        uint256 targetBufferEth = ((totalAssets() + assets) * targetBufferPercentage) / BUFFER_PERCENTAGE_PRECISION;\n\n        /// WRITE ///\n        _mint(msg.sender, shares);\n\n        uint256 availableEth = bufferEthCache + assets; // non-zero\n\n        // If the buffer is insufficient: Doesn't stake any of the deposit\n        if (targetBufferEth >= availableEth + queueEthCache) {\n            bufferEth = availableEth.toUint128();\n            return (assets, shares);\n        }\n\n        uint256 stakeAmount;\n        unchecked {\n            stakeAmount = availableEth + queueEthCache - targetBufferEth; // non-zero, no underflow\n        }\n        // If the stake amount exceeds 95% of the available ETH, cap the stake amount.\n        // This is to prevent the buffer from being completely drained. This is not a complete solution.\n        //\n        // The condition: stakeAmount > availableEth, is equivalent to: queueEthCache > targetBufferEth\n        // Possible scenarios:\n        // - Target buffer percentage was changed to a lower value and there is a large withdrawal request pending.\n        // - There is a pending withdrawal request and the available ETH are not left in the buffer.\n        // - There is no pending withdrawal request and the available ETH are not left in the buffer.\n        uint256 maxStakeAmount = (availableEth * 95) / 100;\n        if (stakeAmount > maxStakeAmount) {\n            stakeAmount = maxStakeAmount; // max 95% of the available ETH\n        }\n\n        /// INTERACT ///\n        // Deposit into the yield source\n        // Actual amount of ETH spent may be less than the requested amount.\n        stakeAmount = _stake(stakeAmount); // stake amount can be 0\n\n        /// WRITE ///\n        bufferEth = (availableEth - stakeAmount).toUint128(); // no underflow theoretically\n\n        return (assets, shares);\n    }\n\n    /// @notice Handles prefunded redemptions\n    /// @dev Withdraw from the buffer. If the buffer is insufficient, revert with an error\n    /// @param recipient The address to receive the redeemed WETH\n    /// @return The amount of redeemed WETH\n    /// @return The amount of shares burned\n    function prefundedRedeem(address recipient) external virtual returns (uint256, uint256) {\n        uint256 shares = balanceOf(address(this));\n        uint256 assets = previewRedeem(shares);\n\n        if (shares == 0) return (0, 0);\n        if (assets == 0) revert ZeroAssets();\n\n        uint256 bufferEthCache = bufferEth;\n        // If the buffer is insufficient, shares cannot be redeemed immediately\n        // Need to wait for the withdrawal to be completed and the buffer to be refilled.\n        if (assets > bufferEthCache) revert InsufficientBuffer();\n\n        unchecked {\n            /// WRITE ///\n            // Reduce the buffer and burn the shares\n            bufferEth = (bufferEthCache - assets).toUint128(); // no underflow\n            _burn(address(this), shares);\n        }\n\n        /// INTERACT ///\n        IWETH9(WETH).transfer(recipient, assets);\n\n        return (assets, shares);\n    }\n\n    ////////////////////////////////////////////////////////\n    /// VIRTUAL METHOD\n    ////////////////////////////////////////////////////////\n\n    /// @notice Request a withdrawal of"
    }
  ]
}