{
  "Title": "[M-14] Incorrect rebase percentage calculation",
  "Content": "_Submitted by csanuragjain_\n\n**Note: this issue had originally been grouped with M-15. Approximately 1 week after judging and awarding were finalized, the judging team re-assessed that this issue should have been classified as a unique issue. It has been broken out here accordingly.**\n\n<https://github.com/code-423n4/2022-06-yieldy/blob/main/src/contracts/Yieldy.sol#L91>\n\nIt was observed that if updatedTotalSupply > MAX_SUPPLY then updatedTotalSupply becomes MAX_SUPPLY. This means _profit amount is not fully used. But _storeRebase function is still called with _profit amount.\n\nThis becomes a problem since _storeRebase function caluclates rebasePercent using this incorrect _profit amount.\n\n### Proof of Concept\n\n1. REBASE_ROLE calls rebase function with say profit 10. Assume currentTotalSupply is 90\n2. updatedTotalSupply is calculated as updatedTotalSupply = currentTotalSupply + _profit. Thus updatedTotalSupply becomes 90+10=100\n\n3. Assume MAX_SUPPLY is 91. Since updatedTotalSupply>MAX_SUPPLY so updatedTotalSupply is updated to be 91\n\n4. Now _storeRebase function is called with updatedTotalSupply (91), _profit(10)\n\n5. This is incorrect since 10 amount from _profit is not utilized and only 1 amount is utilized. This becomes a problem in rebasePercent calculation where it is calculated on full 10 amount instead of 1\n\n### Recommended Mitigation Steps\n\nUse below:\n\n```\nif (updatedTotalSupply > MAX_SUPPLY) {\n_profit=_profit - (updatedTotalSupply-MAX_SUPPLY);\n                updatedTotalSupply = MAX_SUPPLY;\n\t\t\t\t\n            }\n```\n\n**[toshiSat (Yieldy) acknowledged and commented](https://github.com/code-423n4/2022-06-yieldy-findings/issues/52#issuecomment-1168079367):** \n > Max Supply is nearly the max amount in uint256. The protection is there, but will most likely never hit.\n\n**[JasoonS (judge) commented](https://github.com/code-423n4/2022-06-yieldy-findings/issues/52#issuecomment-1200224474):**\n > Potentially, this should be a medium issue.\n\n**[JasoonS (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-06-yieldy-findings/issues/52#issuecomment-1230560266):**\n > Downgrading to medium\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-06-yieldy-contest",
  "Code": [
    {
      "filename": "src/contracts/Yieldy.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./YieldyStorage.sol\";\nimport \"../libraries/ERC20PermitUpgradeable.sol\";\n\ncontract Yieldy is\n    YieldyStorage,\n    ERC20PermitUpgradeable,\n    AccessControlUpgradeable\n{\n    event LogSupply(\n        uint256 indexed epoch,\n        uint256 timestamp,\n        uint256 totalSupply\n    );\n\n    event LogRebase(uint256 indexed epoch, uint256 rebase, uint256 index);\n\n    /**\n        @notice initialize function\n        @param _tokenName erc20 token name\n        @param _tokenSymbol erc20 token symbol\n        @param _decimal decimal amount\n     */\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        uint8 _decimal\n    ) external initializer {\n        ERC20Upgradeable.__ERC20_init(_tokenName, _tokenSymbol);\n        ERC20PermitUpgradeable.__ERC20Permit_init(_tokenName);\n        AccessControlUpgradeable.__AccessControl_init();\n\n        _setupRole(ADMIN_ROLE, msg.sender);\n        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n        _setRoleAdmin(MINTER_BURNER_ROLE, ADMIN_ROLE);\n        _setRoleAdmin(REBASE_ROLE, ADMIN_ROLE);\n\n        decimal = _decimal;\n        WAD = 10**decimal;\n        rebasingCreditsPerToken = WAD;\n        _setIndex(WAD);\n    }\n\n    /**\n        @notice called by the admin role address to set the staking contract. Can only be called\n        once. \n        @param _stakingContract address of the staking contract\n     */\n    function initializeStakingContract(address _stakingContract)\n        external\n        onlyRole(ADMIN_ROLE)\n    {\n        require(stakingContract == address(0), \"Already Initialized\");\n        require(_stakingContract != address(0), \"Invalid address\");\n        stakingContract = _stakingContract;\n        _setupRole(MINTER_BURNER_ROLE, _stakingContract);\n        _setupRole(REBASE_ROLE, _stakingContract);\n    }\n\n    /**\n        @notice sets index to get the value of rebases from the beginning of the contract\n        @param _index uint - initial index\n     */\n    function _setIndex(uint256 _index) internal {\n        index = creditsForTokenBalance(_index);\n    }\n\n    /**\n        @notice increases Yieldy supply to increase staking balances relative to profit_\n        @param _profit uint256 - amount of rewards to distribute\n        @param _epoch uint256 - epoch number\n     */\n    function rebase(uint256 _profit, uint256 _epoch)\n        external\n        onlyRole(REBASE_ROLE)\n    {\n        uint256 currentTotalSupply = _totalSupply;\n        require(_totalSupply > 0, \"Can't rebase if not circulating\");\n\n        if (_profit == 0) {\n            emit LogSupply(_epoch, block.timestamp, currentTotalSupply);\n            emit LogRebase(_epoch, 0, getIndex());\n        } else {\n            uint256 updatedTotalSupply = currentTotalSupply + _profit;\n\n            if (updatedTotalSupply > MAX_SUPPLY) {\n                updatedTotalSupply = MAX_SUPPLY;\n            }\n\n            rebasingCreditsPerToken = rebasingCredits / updatedTotalSupply;\n            require(rebasingCreditsPerToken > 0, \"Invalid change in supply\");\n\n            _totalSupply = updatedTotalSupply;\n\n            _storeRebase(updatedTotalSupply, _profit, _epoch);\n        }\n    }\n\n    /**\n        @notice emits event with data about rebase\n        @param _previousCirculating uint\n        @param _profit uint\n        @param _epoch uint\n     */\n    function _storeRebase(\n        uint256 _previousCirculating,\n        uint256 _profit,\n        uint256 _epoch\n    ) internal {\n        uint256 rebasePercent = (_profit * WAD) / _previousCirculating;\n\n        rebases.push(\n            Rebase({\n                epoch: _epoch,\n                rebase: rebasePercent,\n                totalStakedBefore: _previousCirculating,\n                totalStakedAfter: _totalSupply,\n                amountRebased: _profit,\n                index: getIndex(),\n                blockNumberOccurred: block.number\n            })\n        );\n\n        emit LogSupply(_epoch, block.timestamp, _totalSupply);\n        emit LogRebase(_epoch, rebasePercent, getIndex());\n    }\n\n    /**\n        @notice gets balanceOf Yieldy\n        @param _wallet address\n        @return uint\n     */\n    function balanceOf(address _wallet) public view override returns (uint256) {\n        return creditBalances[_wallet] / rebasingCreditsPerToken;\n    }\n\n    /**\n        @notice calculate credits based on balance amount\n        @param _amount uint\n        @return uint\n     */\n    function creditsForTokenBalance(uint256 _amount)\n        public\n        view\n        returns (uint256)\n    {\n        return _amount * rebasingCreditsPerToken;\n    }\n\n    /**\n        @notice calculate balance based on _credits amount\n        @param _credits uint\n        @return uint\n     */\n    function tokenBalanceForCredits(uint256 _credits)\n        public\n        view\n        returns (uint256)\n    {\n        return _credits / rebasingCreditsPerToken;\n    }\n\n    /**\n        @notice get current index to show what how much Yieldy the user would have gained if staked from the beginning\n        @return uint - current index\n     */\n    function getIndex() public view returns (uint256) {\n        return tokenBalanceForCredits(index);\n    }\n\n    /**\n        @notice transfers to _to address with an amount of _value\n        @param _to address\n        @param _value uint\n        @return bool - transfer succeeded\n     */\n    function transfer(address _to, uint256 _value)\n        public\n        override\n        returns (bool)\n    {\n        require(_to != address(0), \"Invalid address\");\n\n        uint256 creditAmount = _value * rebasingCreditsPerToken;\n        require(creditAmount <= creditBalances[msg.sender], \"Not enough funds\");\n\n        creditBalances[msg.sender] = creditBalances[msg.sender] - creditAmount;\n        creditBalances[_to] = creditBalances[_to] + creditAmount;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n        @notice transfer from address to address with amount\n        @param _from address\n        @param _to address\n        @param _value uint\n        @return bool\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) public override returns (bool) {\n        require(_allowances[_from][msg.sender] >= _value, \"Allowance too low\");\n\n        uint256 newValue = _allowances[_from][msg.sender] - _value;\n        _allowances[_from][msg.sender] = newValue;\n        emit Approval(_from, msg.sender, newValue);\n\n        uint256 creditAmount = creditsForTokenBalance(_value);\n        creditBalances[_from] = creditBalances[_from] - creditAmount;\n        creditBalances[_to] = creditBalances[_to] + creditAmount;\n        emit Transfer(_from, _to, _value);\n\n        return true;\n    }\n\n    /**\n        @notice should be same as yield decimal\n     */\n    function decimals() public view override returns (uint8) {\n        return decimal;\n    }\n\n    /**\n        @notice called from the staking contract co create Yieldy tokens\n        @param _address to receive tokens\n        @param _amount to mint to _address\n     */\n    function mint(address _address, uint256 _amount)\n        external\n        onlyRole(MINTER_BURNER_ROLE)\n    {\n        _mint(_address, _amount);\n    }\n\n    /**\n        @notice internal override for stock erc20 mint functionality\n        @param _address to receive tokens\n        @param _amount to mint to _address\n     */\n    function _mint(address _address, uint256 _amount) internal override {\n        require(_address != address(0), \"Mint to the zero address\");\n\n        uint256 creditAmount = _amount * rebasingCreditsPerToken;\n        creditBalances[_address] = creditBalances[_address] + creditAmount;\n        rebasingCredits = rebasingCredits + creditAmount;\n\n        _totalSupply = _totalSupply + _amount;\n\n        require(_totalSupply < MAX_SUPPLY, \"Max supply\");\n        emit Transfer(address(0), _address, _amount);\n    }\n\n    /**\n        @notice called from the staking contract co burn Yieldy tokens\n        @param _address to burns tokens from\n        @param _amount to burn from _address\n     */\n    function burn(address _address, uint256 _amount)\n        external\n        onlyRole(MINTER_BURNER_ROLE)\n    {\n        _burn(_address, _amount);\n    }\n\n    /**\n        @notice internal override for stock erc20 burn functionality\n        @param _address to burns tokens from\n        @param _amount to burn from _address\n     */\n    function _burn(address _address, uint256 _amount) internal override {\n        require(_address != address(0), \"Burn from the zero address\");\n        if (_amount == 0) {\n            return;\n        }\n\n        uint256 creditAmount = _amount * rebasingCreditsPerToken;\n        uint256 currentCredits = creditBalances[_address];\n        require(currentCredits >= creditAmount, \"Not enough balance\");\n\n        creditBalances[_address] = creditBalances[_address] - creditAmount;\n        rebasingCredits = rebasingCredits - creditAmount;\n        _totalSupply = _totalSupply - _amount;\n\n        emit Transfer(_address, address(0), _amount);\n    }\n}"
    }
  ]
}