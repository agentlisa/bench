{
  "Title": "[M-08] DOS set token through erc777 hook",
  "Content": "_Submitted by jonah1005_\n\n<https://github.com/code-423n4/2022-06-notional-coop/blob/main/index-coop-notional-trade-module/contracts/protocol/modules/v1/DebtIssuanceModule.sol#L131-L141>\n\n<https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC777/ERC777.sol#L376-L380>\n\n### Impact\n\nThe `wfCash` is an `erc777` token. [ERC777.sol#L376-L380](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC777/ERC777.sol#L376-L380) Users can get the control flow before sending token and after receiving tokens. This creates attack vectors that require extra caution in designing modules. Any combination of modules may lead to a possible exploit. To elaborate on the dangerousness of the re-entrancy attack, a possible scenario is presented.\n\nBefore the exploit, we first elaborate on three attack vectors:\n\n1.  [DebtIssuanceModule.sol#L131-L141](https://github.com/code-423n4/2022-06-notional-coop/blob/main/index-coop-notional-trade-module/contracts/protocol/modules/v1/DebtIssuanceModule.sol#L131-L141) The issuance module would pull tokens from the sender before minting setToken.\n\nAssume there are three compoenents in this set. 1. CDai. 2. wfCash  In the `_callTokensToSend`, the setToken has received `cdai` and the `totalSupply` is still the same.\n\n2.  `nonReentrant` does not protect cross-contract re-entrancy. This means, that during the `issue` of issuance module, users can trigger other modules' functions.\n\n3.  Restricted functions with `onlyManagerAndValidSet` modifier may be triggered by the exploiter as well. Manager of a setToken is usually a manager contract. Assume it's a multisig-wallet, the exploiter can front-run the execute transaction and replay the payload during his exploit. Note, a private transaction from flash-bot can still be front-run. Please refer to the [uncle bandit risk](https://docs.flashbots.net/flashbots-protect/rpc/uncle-bandits)\n\nGiven the above attack vectors, the exploiter have enough weapons to exploit the `setToken` at a propriate time. Note that different combination of modules may have different exploit paths. As long as the above attack vectors remain, the setToken is vulnerable.\n\nAssume a setToken with `CompoundLeverageModule`, `NotionalTradeModule` and `BasicIssuanceModule` with the following positions: 1. CDAI: 100  2. wfCash-DAI 100  and totalSupply = 100. The community decides to remove the `compoundLeverageModule` from the set token. Since `notionalTradeModule` can handle cDAI, the community vote to just call `removeModule` to remove `compoundLeverageModule`. The exploiter has the time to build an exploit and wait the right timing to come.\n\n0.  The exploiter listen the manager multisig wallet.\n1.  Exploiter issue 10 setToken.\n2.  During the `_callTokensToSend` of `wfcash`, the totalSupply = 100, CDAI = 110, wfCash-DAI = 110.\n3.  Call `sync` of `CompoundLeverageModule`. `_getCollateralPosition` get  `_cToken.balanceOf(address(_setToken)) = 110` and `totalSupply = 100` and update the `DefaultUnit` of `CETH` 1,1X.\n4.  Replay multisig wallet's payload and remove `compoundLeverageModule`.\n5.  The `setToken` can no longer issue / redeem as it would raise `undercollateralized` error. Further, `setValuer` would give a pumped valuation that may cause harm to other protocols.\n\n### Proof of Concept\n\n[POC](https://gist.github.com/Jonah246/13e58b59765c0334189c99a9f29c6dab)\nThe exploit is quite lengthy. Please check the `Attack.sol` for the main exploit logic.\n\n```solidity\n    function register() public {\n        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), _TOKENS_SENDER_INTERFACE_HASH, address(this));\n        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), _TOKENS_SENDER_INTERFACE_HASH, address(this));\n    }\n\n    function attack(uint256 _amount) external {\n        cToken.approve(address(issueModule), uint256(-1));\n        wfCash.approve(address(issueModule), uint256(-1));\n        issueModule.issue(setToken, _amount, address(this));\n    }\n\n    function tokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external {\n        compoundModule.sync(setToken, false);\n        manager.removeModule(address(setToken));\n    }\n```\n\n### Recommended Mitigation Steps\n\nThe design choice of wfcash being an `ERC777` seems unnecessary to me. Over the past two years, ERC777 leads to so many exploits. [IMBTC-UNISWAP](https://defirate.com/imbtc-uniswap-hack/) [CREAM-AMP](https://twitter.com/CreamdotFinance/status/1432249771750686721?s=20) I recommend the team use ERC20 instead.\n\nIf the SetToken team considers supporting ERC777 necessary, I recommend implementing protocol-wide cross-contract reentrancy prevention. Please refer to Rari-Capital. [Comptroller.sol#L1978-L2002](https://github.com/Rari-Capital/fuse-v1/blob/development/src/core/Comptroller.sol#L1978-L2002)\n\nNote that, `Rari` was [exploited](https://www.coindesk.com/business/2022/04/30/defi-lender-rari-capitalfei-loses-80m-in-hack/) given this reentrancy prevention. Simply making `nonReentrant` cross-contact prevention may not be enough. I recommend to setToken protocol going through every module and re-consider whether it's re-entrancy safe.\n\n**[ckoopmann (Index Coop) commented](https://github.com/code-423n4/2022-06-notional-coop-findings/issues/168#issuecomment-1156059002):**\n > @jeffywu : What do you think ? Can we drop the ERC777 interface from wfCash (it's not used by the NotionalTradeModule afaik). \n> If not, I'll have to review this issue in more details and see if we need a mitigation on our side.\n> \n> Note that the issue mostly references the DebtIssuanceModule which we probably wont / cant change unless there is a major vulnerability.\n\n**[jeffywu (Notional) confirmed and commented](https://github.com/code-423n4/2022-06-notional-coop-findings/issues/168#issuecomment-1156580278):**\n > @ckoopmann I think we can just drop ERC777\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-06-notional-coop",
  "Code": [
    {
      "filename": "index-coop-notional-trade-module/contracts/protocol/modules/v1/DebtIssuanceModule.sol",
      "content": "/*\n    Copyright 2021 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.6.10;\npragma experimental \"ABIEncoderV2\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport { SignedSafeMath } from \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\n\nimport { AddressArrayUtils } from \"../../../lib/AddressArrayUtils.sol\";\nimport { IController } from \"../../../interfaces/IController.sol\";\nimport { IManagerIssuanceHook } from \"../../../interfaces/IManagerIssuanceHook.sol\";\nimport { IModuleIssuanceHook } from \"../../../interfaces/IModuleIssuanceHook.sol\";\nimport { Invoke } from \"../../lib/Invoke.sol\";\nimport { ISetToken } from \"../../../interfaces/ISetToken.sol\";\nimport { ModuleBase } from \"../../lib/ModuleBase.sol\";\nimport { Position } from \"../../lib/Position.sol\";\nimport { PreciseUnitMath } from \"../../../lib/PreciseUnitMath.sol\";\n\n\n/**\n * @title DebtIssuanceModule\n * @author Set Protocol\n *\n * The DebtIssuanceModule is a module that enables users to issue and redeem SetTokens that contain default and all\n * external positions, including debt positions. Module hooks are added to allow for syncing of positions, and component\n * level hooks are added to ensure positions are replicated correctly. The manager can define arbitrary issuance logic\n * in the manager hook, as well as specify issue and redeem fees.\n */\ncontract DebtIssuanceModule is ModuleBase, ReentrancyGuard {\n\n    /* ============ Structs ============ */\n\n    // NOTE: moduleIssuanceHooks uses address[] for compatibility with AddressArrayUtils library\n    struct IssuanceSettings {\n        uint256 maxManagerFee;                          // Max issue/redeem fee defined on instantiation\n        uint256 managerIssueFee;                        // Current manager issuance fees in precise units (10^16 = 1%)\n        uint256 managerRedeemFee;                       // Current manager redeem fees in precise units (10^16 = 1%)\n        address feeRecipient;                           // Address that receives all manager issue and redeem fees\n        IManagerIssuanceHook managerIssuanceHook;       // Instance of manager defined hook, can hold arbitrary logic\n        address[] moduleIssuanceHooks;                  // Array of modules that are registered with this module\n        mapping(address => bool) isModuleHook;          // Mapping of modules to if they've registered a hook\n    }\n\n    /* ============ Events ============ */\n\n    event SetTokenIssued(\n        ISetToken indexed _setToken,\n        address indexed _issuer,\n        address indexed _to,\n        address _hookContract,\n        uint256 _quantity,\n        uint256 _managerFee,\n        uint256 _protocolFee\n    );\n    event SetTokenRedeemed(\n        ISetToken indexed _setToken,\n        address indexed _redeemer,\n        address indexed _to,\n        uint256 _quantity,\n        uint256 _managerFee,\n        uint256 _protocolFee\n    );\n    event FeeRecipientUpdated(ISetToken indexed _setToken, address _newFeeRecipient);\n    event IssueFeeUpdated(ISetToken indexed _setToken, uint256 _newIssueFee);\n    event RedeemFeeUpdated(ISetToken indexed _setToken, uint256 _newRedeemFee);\n\n    /* ============ Constants ============ */\n\n    uint256 private constant ISSUANCE_MODULE_PROTOCOL_FEE_SPLIT_INDEX = 0;\n\n    /* ============ State ============ */\n\n    mapping(ISetToken => IssuanceSettings) public issuanceSettings;\n\n    /* ============ Constructor ============ */\n\n    constructor(IController _controller) public ModuleBase(_controller) {}\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Deposits components to the SetToken, replicates any external module component positions and mints\n     * the SetToken. If the token has a debt position all collateral will be transferred in first then debt\n     * will be returned to the minting address. If specified, a fee will be charged on issuance.\n     *\n     * @param _setToken         Instance of the SetToken to issue\n     * @param _quantity         Quantity of SetToken to issue\n     * @param _to               Address to mint SetToken to\n     */\n    function issue(\n        ISetToken _setToken,\n        uint256 _quantity,\n        address _to\n    )\n        external\n        virtual\n        nonReentrant\n        onlyValidAndInitializedSet(_setToken)\n    {\n        require(_quantity > 0, \"Issue quantity must be > 0\");\n\n        address hookContract = _callManagerPreIssueHooks(_setToken, _quantity, msg.sender, _to);\n\n        _callModulePreIssueHooks(_setToken, _quantity);\n\n        (\n            uint256 quantityWithFees,\n            uint256 managerFee,\n            uint256 protocolFee\n        ) = calculateTotalFees(_setToken, _quantity, true);\n\n        (\n            address[] memory components,\n            uint256[] memory equityUnits,\n            uint256[] memory debtUnits\n        ) = _calculateRequiredComponentIssuanceUnits(_setToken, quantityWithFees, true);\n\n        _resolveEquityPositions(_setToken, quantityWithFees, _to, true, components, equityUnits);\n        _resolveDebtPositions(_setToken, quantityWithFees, true, components, debtUnits);\n        _resolveFees(_setToken, managerFee, protocolFee);\n\n        _setToken.mint(_to, _quantity);\n\n        emit SetTokenIssued(\n            _setToken,\n            msg.sender,\n            _to,\n            hookContract,\n            _quantity,\n            managerFee,\n            protocolFee\n        );\n    }\n\n    /**\n     * Returns components from the SetToken, unwinds any external module component positions and burns the SetToken.\n     * If the token has debt positions, the module transfers in the required debt amounts from the caller and uses\n     * those funds to repay the debts on behalf of the SetToken. All debt will be paid down first then equity positions\n     * will be returned to the minting address. If specified, a fee will be charged on redeem.\n     *\n     * @param _setToken         Instance of the SetToken to redeem\n     * @param _quantity         Quantity of SetToken to redeem\n     * @param _to               Address to send collateral to\n     */\n    function redeem(\n        ISetToken _setToken,\n        uint256 _quantity,\n        address _to\n    )\n        external\n        virtual\n        nonReentrant\n        onlyValidAndInitializedSet(_setToken)\n    {\n        require(_quantity > 0, \"Redeem quantity must be > 0\");\n\n        _callModulePreRedeemHooks(_setToken, _quantity);\n\n        // Place burn after pre-redeem hooks because burning tokens may lead to false accounting of synced positions\n        _setToken.burn(msg.sender, _quantity);\n\n        (\n            uint256 quantityNetFees,\n            uint256 managerFee,\n            uint256 protocolFee\n        ) = calculateTotalFees(_setToken, _quantity, false);\n\n        (\n            address[] memory components,\n            uint256[] memory equityUnits,\n            uint256[] memory debtUnits\n        ) = _calculateRequiredComponentIssuanceUnits(_setToken, quantityNetFees, false);\n\n        _resolveDebtPositions(_setToken, quantityNetFees, false, components, debtUnits);\n        _resolveEquityPositions(_setToken, quantityNetFees, _to, false, components, equityUnits);\n        _resolveFees(_setToken, managerFee, protocolFee);\n\n        emit SetTokenRedeemed(\n            _setToken,\n            msg.sender,\n            _to,\n            _quantity,\n            managerFee,\n            protocolFee\n        );\n    }\n\n    /**\n     * MANAGER ONLY: Updates address receiving issue/redeem fees for a given SetToken.\n     *\n     * @param _setToken             Instance of the SetToken to update fee recipient\n     * @param _newFeeRecipient      New fee recipient address\n     */\n    function updateFeeRecipient(\n        ISetToken _setToken,\n        address _newFeeRecipient\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        require(_newFeeRecipient != address(0), \"Fee Recipient must be non-zero address.\");\n        require(_newFeeRecipient != issuanceSettings[_setToken].feeRecipient, \"Same fee recipient passed\");\n\n        issuanceSettings[_setToken].feeRecipient = _newFeeRecipient;\n\n        emit FeeRecipientUpdated(_setToken, _newFeeRecipient);\n    }\n\n    /**\n     * MANAGER ONLY: Updates issue fee for passed SetToken\n     *\n     * @param _setToken             Instance of the SetToken to update issue fee\n     * @param _newIssueFee          New fee amount in preciseUnits (1% = 10^16)\n     */\n    function updateIssueFee(\n        ISetToken _setToken,\n        uint256 _newIssueFee\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        require(_newIssueFee <= issuanceSettings[_setToken].maxManagerFee, \"Issue fee can't exceed maximum\");\n        require(_newIssueFee != issuanceSettings[_setToken].managerIssueFee, \"Same issue fee passed\");\n\n        issuanceSettings[_setToken].managerIssueFee = _newIssueFee;\n\n        emit IssueFeeUpdated(_setToken, _newIssueFee);\n    }\n\n    /**\n     * MANAGER ONLY: Updates redeem fee for passed SetToken\n     *\n     * @param _setToken             Instance of the SetToken to update redeem fee\n     * @param _newRedeemFee         New fee amount in preciseUnits (1% = 10^16)\n     */\n    function updateRedeemFee(\n        ISetToken _setToken,\n        uint256 _newRedeemFee\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        require(_newRedeemFee <= issuanceSettings[_setToken].maxManagerFee, \"Redeem fee can't exceed maximum\");\n        require(_newRedeemFee != issuanceSettings[_setToken].managerRedeemFee, \"Same redeem fee passed\");\n\n        issuanceSettings[_setToken].managerRedeemFee = _newRedeemFee;\n\n        emit RedeemFeeUpdated(_setToken, _newRedeemFee);\n    }\n\n    /**\n     * MODULE ONLY: Adds calling module to array of modules that require they be called before component hooks are\n     * called. Can be used to sync debt positions before issuance.\n     *\n     * @param _setToken             Instance of the SetToken to issue\n     */\n    function registerToIssuanceModule(ISetToken _setToken) external onlyModule(_setToken) onlyValidAndInitializedSet(_setToken) {\n        require(!issuanceSettings[_setToken].isModuleHook[msg.sender], \"Module already registered.\");\n        issuanceSettings[_setToken].moduleIssuanceHooks.push(msg.sender);\n        issuanceSettings[_setToken].isModuleHook[msg.sender] = true;\n    }\n\n    /**\n     * MODULE ONLY: Removes calling module from array of modules that require they be called before component hooks are\n     * called.\n     *\n     * @param _setToken             Instance of the SetToken to issue\n     */\n    function unregisterFromIssuanceModule(ISetToken _setToken) external onlyModule(_setToken) onlyValidAndInitializedSet(_setToken) {\n        require(issuanceSettings[_setToken].isModuleHook[msg.sender], \"Module not registered.\");\n        issuanceSettings[_setToken].moduleIssuanceHooks.removeStorage(msg.sender);\n        issuanceSettings[_setToken].isModuleHook[msg.sender] = false;\n    }\n\n    /**\n     * MANAGER ONLY: Initializes this module to the SetToken with issuance-related hooks and fee information. Only callable\n     * by the SetToken's manager. Hook addresses are optional. Address(0) means that no hook will be called\n     *\n     * @param _setToken                     Instance of the SetToken to issue\n     * @param _maxManagerFee                Maximum fee that can be charged on issue and redeem\n     * @param _managerIssueFee              Fee to charge on issuance\n     * @param _managerRedeemFee             Fee to charge on redemption\n     * @param _feeRecipient                 Address to send fees to\n     * @param _managerIssuanceHook          Instance of the Manager Contract with the Pre-Issuance Hook function\n     */\n    function initialize(\n        ISetToken _setToken,\n        uint256 _maxManagerFee,\n        uint256 _managerIssueFee,\n        uint256 _managerRedeemFee,\n        address _feeRecipient,\n        IManagerIssuanceHook _managerIssuanceHook\n    )\n        external\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n    {\n        require(_managerIssueFee <= _maxManagerFee, \"Issue fee can't exceed maximum fee\");\n        require(_managerRedeemFee <= _maxManagerFee, \"Redeem fee can't exceed maximum fee\");\n\n        issuanceSettings[_setToken] = IssuanceSettings({\n            maxManagerFee: _maxManagerFee,\n            managerIssueFee: _managerIssueFee,\n            managerRedeemFee: _managerRedeemFee,\n            feeRecipient: _feeRecipient,\n            managerIssuanceHook: _managerIssuanceHook,\n            moduleIssuanceHooks: new address[](0)\n        });\n\n        _setToken.initializeModule();\n    }\n\n    /**\n     * SET TOKEN ONLY: Allows removal of module (and deletion of state) if no other modules are registered.\n     */\n    function removeModule() external override {\n        require(issuanceSettings[ISetToken(msg.sender)].moduleIssuanceHooks.length == 0, \"Registered modules must be removed.\");\n        delete issuanceSettings[ISetToken(msg.sender)];\n    }\n\n    /* ============ External View Functions ============ */\n\n    /**\n     * Calculates the manager fee, protocol fee and resulting totalQuantity to use when calculating unit amounts. If fees are charged they\n     * are added to the total issue quantity, for example 1% fee on 100 Sets means 101 Sets are minted by caller, the _to address receives\n     * 100 and the feeRecipient receives 1. Conversely, on redemption the redeemer will only receive the collateral that collateralizes 99\n     * Sets, while the additional Set is given to the feeRecipient.\n     *\n     * @param _setToken                 Instance of the SetToken to issue\n     * @param _quantity                 Amount of SetToken issuer wants to receive/redeem\n     * @param _isIssue                  If issuing or redeeming\n     *\n     * @return totalQuantity           Total amount of Sets to be issued/redeemed with fee adjustment\n     * @return managerFee              Sets minted to the manager\n     * @return protocolFee             Sets minted to the protocol\n     */\n    function calculateTotalFees(\n        ISetToken _setToken,\n        uint256 _quantity,\n        bool _isIssue\n    )\n        public\n        view\n        returns (uint256 totalQuantity, uint256 managerFee, uint256 protocolFee)\n    {\n        IssuanceSettings memory setIssuanceSettings = issuanceSettings[_setToken];\n        uint256 protocolFeeSplit = controller.getModuleFee(address(this), ISSUANCE_MODULE_PROTOCOL_FEE_SPLIT_INDEX);\n        uint256 totalFeeRate = _isIssue ? setIssuanceSettings.managerIssueFee : setIssuanceSettings.managerRedeemFee;\n\n        uint256 totalFee = totalFeeRate.preciseMul(_quantity);\n        protocolFee = totalFee.preciseMul(protocolFeeSplit);\n        managerFee = totalFee.sub(protocolFee);\n\n        totalQuantity = _isIssue ? _quantity.add(totalFee) : _quantity.sub(totalFee);\n    }\n\n    /**\n     * Calculates the amount of each component needed to collateralize passed issue quantity plus fees of Sets as well as amount of debt\n     * that will be returned to caller. Values DO NOT take into account any updates from pre action manager or module hooks.\n     *\n     * @param _setToken         Instance of the SetToken to issue\n     * @param _quantity         Amount of Sets to be issued\n     *\n     * @return address[]        Array of component addresses making up the Set\n     * @return uint256[]        Array of equity notional amounts of each component, respectively, represented as uint256\n     * @return uint256[]        Array of debt notional amounts of each component, respectively, represented as uint256\n     */\n    function getRequiredComponentIssuanceUnits(\n        ISetToken _setToken,\n        uint256 _quantity\n    )\n        external\n        view\n        virtual\n        returns (address[] memory, uint256[] memory, uint256[] memory)\n    {\n        (\n            uint256 totalQuantity,,\n        ) = calculateTotalFees(_setToken, _quantity, true);\n\n        return _calculateRequiredComponentIssuanceUnits(_setToken, totalQuantity, true);\n    }\n\n    /**\n     * Calculates the amount of each component will be returned on redemption net of fees as well as how much debt needs to be paid down to.\n     * redeem. Values DO NOT take into account any updates from pre action manager or module hooks.\n     *\n     * @param _setToken         Instance of the SetToken to issue\n     * @param _quantity         Amount of Sets to be redeemed\n     *\n     * @return address[]        Array of component addresses making up the Set\n     * @return uint256[]        Array of equity notional amounts of each component, respectively, represented as uint256\n     * @return uint256[]        Array of debt notional amounts of each component, respectively, represented as uint256\n     */\n    function getRequiredComponentRedemptionUnits(\n        ISetToken _setToken,\n        uint256 _quantity\n    )\n        external\n        view\n        virtual\n        returns (address[] memory, uint256[] memory, uint256[] memory)\n    {\n        (\n            uint256 totalQuantity,,\n        ) = calculateTotalFees(_setToken, _quantity, false);\n\n        return _calculateRequiredComponentIssuanceUnits(_setToken, totalQuantity, false);\n    }\n\n    function getModuleIssuanceHooks(ISetToken _setToken) external view returns(address[] memory) {\n        return issuanceSettings[_setToken].moduleIssuanceHooks;\n    }\n\n    function isModuleIssuanceHook(ISetToken _setToken, address _hook) external view returns(bool) {\n        return issuanceSettings[_setToken].isModuleHook[_hook];\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Calculates the amount of each component needed to collateralize passed issue quantity of Sets as well as amount of debt that will\n     * be returned to caller. Can also be used to determine how much collateral will be returned on redemption as well as how much debt\n     * needs to be paid down to redeem.\n     *\n     * @param _setToken         Instance of the SetToken to issue\n     * @param _quantity         Amount of Sets to be issued/redeemed\n     * @param _isIssue          Whether Sets are being issued or redeemed\n     *\n     * @return address[]        Array of component addresses making up the Set\n     * @return uint256[]        Array of equity notional amounts of each component, respectively, represented as uint256\n     * @return uint256[]        Array of debt notional amounts of each component, respectively, represented as uint256\n     */\n    function _calculateRequiredComponentIssuanceUnits(\n        ISetToken _setToken,\n        uint256 _quantity,\n        bool _isIssue\n    )\n        internal\n        view\n        returns (address[] memory, uint256[] memory, uint256[] memory)\n    {\n        (\n            address[] memory components,\n            uint256[] memory equityUnits,\n            uint256[] memory debtUnits\n        ) = _getTotalIssuanceUnits(_setToken);\n\n        uint256 componentsLength = components.length;\n        uint256[] memory totalEquityUnits = new uint256[](componentsLength);\n        uint256[] memory totalDebtUnits = new uint256[](componentsLength);\n        for (uint256 i = 0; i < components.length; i++) {\n            // Use preciseMulCeil to round up to ensure overcollateration when small issue quantities are provided\n            // and preciseMul to round down to ensure overcollateration when small redeem quantities are provided\n            totalEquityUnits[i] = _isIssue ?\n                equityUnits[i].preciseMulCeil(_quantity) :\n                equityUnits[i].preciseMul(_quantity);\n\n            totalDebtUnits[i] = _isIssue ?\n                debtUnits[i].preciseMul(_quantity) :\n                debtUnits[i].preciseMulCeil(_quantity);\n        }\n\n        return (components, totalEquityUnits, totalDebtUnits);\n    }\n\n    /**\n     * Sums total debt and equity units for each component, taking into account default and external positions.\n     *\n     * @param _setToken         Instance of the SetToken to issue\n     *\n     * @return address[]        Array of component addresses making up the Set\n     * @return uint256[]        Array of equity unit amounts of each component, respectively, represented as uint256\n     * @return uint256[]        Array of debt unit amounts of each component, respectively, represented as uint256\n     */\n    function _getTotalIssuanceUnits(\n        ISetToken _setToken\n    )\n        internal\n        view\n        returns (address[] memory, uint256[] memory, uint256[] memory)\n    {\n        address[] memory components = _setToken.getComponents();\n        uint256 componentsLength = components.length;\n\n        uint256[] memory equityUnits = new uint256[](componentsLength);\n        uint256[] memory debtUnits = new uint256[](componentsLength);\n\n        for (uint256 i = 0; i < components.length; i++) {\n            address component = components[i];\n            int256 cumulativeEquity = _setToken.getDefaultPositionRealUnit(component);\n            int256 cumulativeDebt = 0;\n            address[] memory externalPositions = _setToken.getExternalPositionModules(component);\n\n            if (externalPositions.length > 0) {\n                for (uint256 j = 0; j < externalPositions.length; j++) {\n                    int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(component, externalPositions[j]);\n\n                    // If positionUnit <= 0 it will be \"added\" to debt position\n                    if (externalPositionUnit > 0) {\n                        cumulativeEquity = cumulativeEquity.add(externalPositionUnit);\n                    } else {\n                        cumulativeDebt = cumulativeDebt.add(externalPositionUnit);\n                    }\n                }\n            }\n\n            equityUnits[i] = cumulativeEquity.toUint256();\n            debtUnits[i] = cumulativeDebt.mul(-1).toUint256();\n        }\n\n        return (components, equityUnits, debtUnits);\n    }\n\n    /**\n     * Resolve equity positions associated with SetToken. On issuance, the total equity position for an asset (including default and external\n     * positions) is transferred in. Then any external position hooks are called to transfer the external positions to their necessary place.\n     * On redemption all external positions are recalled by the external position hook, then those position plus any default position are\n     * transferred back to the _to address.\n     */\n    function _resolveEquityPositions(\n        ISetToken _setToken,\n        uint256 _quantity,\n        address _to,\n        bool _isIssue,\n        address[] memory _components,\n        uint256[] memory _componentEquityQuantities\n    )\n        internal\n    {\n        for (uint256 i = 0; i < _components.length; i++) {\n            address component = _components[i];\n            uint256 componentQuantity = _componentEquityQuantities[i];\n            if (componentQuantity > 0) {\n                if (_isIssue) {\n                    transferFrom(\n                        IERC20(component),\n                        msg.sender,\n                        address(_setToken),\n                        componentQuantity\n                    );\n\n                    _executeExternalPositionHooks(_setToken, _quantity, IERC20(component), true, true);\n                } else {\n                    _executeExternalPositionHooks(_setToken, _quantity, IERC20(component), false, true);\n\n                    _setToken.strictInvokeTransfer(\n                        component,\n                        _to,\n                        componentQuantity\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Resolve debt positions associated with SetToken. On issuance, debt positions are entered into by calling the external position hook. The\n     * resulting debt is then returned to the calling address. On redemption, the module transfers in the required debt amount from the caller\n     * and uses those funds to repay the debt on behalf of the SetToken.\n     */\n    function _resolveDebtPositions(\n        ISetToken _setToken,\n        uint256 _quantity,\n        bool _isIssue,\n        address[] memory _components,\n        uint256[] memory _componentDebtQuantities\n    )\n        internal\n    {\n        for (uint256 i = 0; i < _components.length; i++) {\n            address component = _components[i];\n            uint256 componentQuantity = _componentDebtQuantities[i];\n            if (componentQuantity > 0) {\n                if (_isIssue) {\n                    _executeExternalPositionHooks(_setToken, _quantity, IERC20(component), true, false);\n                    _setToken.strictInvokeTransfer(\n                        component,\n                        msg.sender,\n                        componentQuantity\n                    );\n                } else {\n                    transferFrom(\n                        IERC20(component),\n                        msg.sender,\n                        address(_setToken),\n                        componentQuantity\n                    );\n                    _executeExternalPositionHooks(_setToken, _quantity, IERC20(component), false, false);\n                }\n            }\n        }\n    }\n\n    /**\n     * If any manager fees mints Sets to the defined feeRecipient. If protocol fee is enabled mints Sets to protocol\n     * feeRecipient.\n     */\n    function _resolveFees(ISetToken _setToken, uint256 managerFee, uint256 protocolFee) internal {\n        if (managerFee > 0) {\n            _setToken.mint(issuanceSettings[_setToken].feeRecipient, managerFee);\n\n            // Protocol fee check is inside manager fee check because protocol fees are only collected on manager fees\n            if (protocolFee > 0) {\n                _setToken.mint(controller.feeRecipient(), protocolFee);\n            }\n        }\n    }\n\n    /**\n     * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic\n     * can contain arbitrary logic including validations, external function calls, etc.\n     */\n    function _callManagerPreIssueHooks(\n        ISetToken _setToken,\n        uint256 _quantity,\n        address _caller,\n        address _to\n    )\n        internal\n        returns(address)\n    {\n        IManagerIssuanceHook preIssueHook = issuanceSettings[_setToken].managerIssuanceHook;\n        if (address(preIssueHook) != address(0)) {\n            preIssueHook.invokePreIssueHook(_setToken, _quantity, _caller, _to);\n            return address(preIssueHook);\n        }\n\n        return address(0);\n    }\n\n    /**\n     * Calls all modules that have registered with the DebtIssuanceModule that have a moduleIssueHook.\n     */\n    function _callModulePreIssueHooks(ISetToken _setToken, uint256 _quantity) internal {\n        address[] memory issuanceHooks = issuanceSettings[_setToken].moduleIssuanceHooks;\n        for (uint256 i = 0; i < issuanceHooks.length; i++) {\n            IModuleIssuanceHook(issuanceHooks[i]).moduleIssueHook(_setToken, _quantity);\n        }\n    }\n\n    /**\n     * Calls all modules that have registered with the DebtIssuanceModule that have a moduleRedeemHook.\n     */\n    function _callModulePreRedeemHooks(ISetToken _setToken, uint256 _quantity) internal {\n        address[] memory issuanceHooks = issuanceSettings[_setToken].moduleIssuanceHooks;\n        for (uint256 i = 0; i < issuanceHooks.length; i++) {\n            IModuleIssuanceHook(issuanceHooks[i]).moduleRedeemHook(_setToken, _quantity);\n        }\n    }\n\n    /**\n     * For each component's external module positions, calculate the total notional quantity, and\n     * call the module's issue hook or redeem hook.\n     * Note: It is possible that these hooks can cause the states of other modules to change.\n     * It can be problematic if the hook called an external function that called back into a module, resulting in state inconsistencies.\n     */\n    function _executeExternalPositionHooks(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        IERC20 _component,\n        bool _isIssue,\n        bool _isEquity\n    )\n        internal\n    {\n        address[] memory externalPositionModules = _setToken.getExternalPositionModules(address(_component));\n        uint256 modulesLength = externalPositionModules.length;\n        if (_isIssue) {\n            for (uint256 i = 0; i < modulesLength; i++) {\n                IModuleIssuanceHook(externalPositionModules[i]).componentIssueHook(_setToken, _setTokenQuantity, _component, _isEquity);\n            }\n        } else {\n            for (uint256 i = 0; i < modulesLength; i++) {\n                IModuleIssuanceHook(externalPositionModules[i]).componentRedeemHook(_setToken, _setTokenQuantity, _component, _isEquity);\n            }\n        }\n    }\n}"
    },
    {
      "filename": "index-coop-notional-trade-module/contracts/protocol/modules/v1/DebtIssuanceModule.sol",
      "content": "/*\n    Copyright 2021 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.6.10;\npragma experimental \"ABIEncoderV2\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport { SignedSafeMath } from \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\n\nimport { AddressArrayUtils } from \"../../../lib/AddressArrayUtils.sol\";\nimport { IController } from \"../../../interfaces/IController.sol\";\nimport { IManagerIssuanceHook } from \"../../../interfaces/IManagerIssuanceHook.sol\";\nimport { IModuleIssuanceHook } from \"../../../interfaces/IModuleIssuanceHook.sol\";\nimport { Invoke } from \"../../lib/Invoke.sol\";\nimport { ISetToken } from \"../../../interfaces/ISetToken.sol\";\nimport { ModuleBase } from \"../../lib/ModuleBase.sol\";\nimport { Position } from \"../../lib/Position.sol\";\nimport { PreciseUnitMath } from \"../../../lib/PreciseUnitMath.sol\";\n\n\n/**\n * @title DebtIssuanceModule\n * @author Set Protocol\n *\n * The DebtIssuanceModule is a module that enables users to issue and redeem SetTokens that contain default and all\n * external positions, including debt positions. Module hooks are added to allow for syncing of positions, and component\n * level hooks are added to ensure positions are replicated correctly. The manager can define arbitrary issuance logic\n * in the manager hook, as well as specify issue and redeem fees.\n */\ncontract DebtIssuanceModule is ModuleBase, ReentrancyGuard {\n\n    /* ============ Structs ============ */\n\n    // NOTE: moduleIssuanceHooks uses address[] for compatibility with AddressArrayUtils library\n    struct IssuanceSettings {\n        uint256 maxManagerFee;                          // Max issue/redeem fee defined on instantiation\n        uint256 managerIssueFee;                        // Current manager issuance fees in precise units (10^16 = 1%)\n        uint256 managerRedeemFee;                       // Current manager redeem fees in precise units (10^16 = 1%)\n        address feeRecipient;                           // Address that receives all manager issue and redeem fees\n        IManagerIssuanceHook managerIssuanceHook;       // Instance of manager defined hook, can hold arbitrary logic\n        address[] moduleIssuanceHooks;                  // Array of modules that are registered with this module\n        mapping(address => bool) is"
    }
  ]
}