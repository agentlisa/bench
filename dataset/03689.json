{
  "Title": "[L05] Incorrect interface definition",
  "Content": "In the [`CurveOracle`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/oracle/CurveOracle.sol#L39) and [`CurveSpellV1`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/spell/CurveSpellV1.sol#L45) contracts, external calls are made to [Curve’s on-chain registry](https://etherscan.io/address/0x7D86446dDb609eD0F5f8684AcF30380a356b2B4c#code). The registry function [`get_n_coins`](https://github.com/curvefi/curve-pool-registry/blob/ed52ad5ddfdeb87d42c2eb78e2fc62af8230a868/contracts/Registry.vy#L319) is used to obtain the number of underlying tokens, which various functions use to properly iterate relevant token arrays. However, the interface being used deviates from the implementation. Specifically, the interface has the return value of this call as a single `uint`, when in reality it is an array consisting of two `uint` values – the first representing the number of “wrapped tokens” and the second representing “*all* underlying tokens”. In the case of metapools, these values may be different.\n\n\nConsider updating the interface to accurately reflect the implementation in order to avoid potential confusion, avoid unexpected behavior, and clarify the intention of the code.\n\n\n***Update:** Fixed in [PR#100](https://github.com/AlphaFinanceLab/homora-v2/pull/100).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/oracle/CurveOracle.sol",
      "content": "pragma solidity 0.6.12;\n\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/math/SafeMath.sol';\n\nimport './UsingBaseOracle.sol';\nimport '../../interfaces/IBaseOracle.sol';\nimport '../../interfaces/ICurvePool.sol';\nimport '../../interfaces/ICurveRegistry.sol';\n\ninterface IERC20Decimal {\n  function decimals() external view returns (uint8);\n}\n\ncontract CurveOracle is UsingBaseOracle, IBaseOracle {\n  using SafeMath for uint;\n\n  ICurveRegistry public immutable registry; // Curve registry\n\n  struct UnderlyingToken {\n    uint8 decimals; // token decimals\n    address token; // token address\n  }\n\n  mapping(address => UnderlyingToken[]) public ulTokens; // Mapping from LP token to underlying tokens\n  mapping(address => address) public poolOf; // Mapping from LP token to pool\n\n  constructor(IBaseOracle _base, ICurveRegistry _registry) public UsingBaseOracle(_base) {\n    registry = _registry;\n  }\n\n  /// @dev Register the pool given LP token address and set the pool info.\n  /// @param lp LP token to find the corresponding pool.\n  function registerPool(address lp) external {\n    address pool = poolOf[lp];\n    require(pool == address(0), 'lp is already registered');\n    pool = registry.get_pool_from_lp_token(lp);\n    require(pool != address(0), 'no corresponding pool for lp token');\n    poolOf[lp] = pool;\n    uint n = registry.get_n_coins(pool);\n    address[8] memory tokens = registry.get_coins(pool);\n    for (uint i = 0; i < n; i++) {\n      ulTokens[lp].push(\n        UnderlyingToken({token: tokens[i], decimals: IERC20Decimal(tokens[i]).decimals()})\n      );\n    }\n  }\n\n  /// @dev Return the value of the given input as ETH per unit, multiplied by 2**112.\n  /// @param lp The ERC-20 LP token to check the value.\n  function getETHPx(address lp) external view override returns (uint) {\n    address pool = poolOf[lp];\n    require(pool != address(0), 'lp is not registered');\n    UnderlyingToken[] memory tokens = ulTokens[lp];\n    uint minPx = uint(-1);\n    uint n = tokens.length;\n    for (uint idx = 0; idx < n; idx++) {\n      UnderlyingToken memory ulToken = tokens[idx];\n      uint tokenPx = base.getETHPx(ulToken.token);\n      if (ulToken.decimals < 18) tokenPx = tokenPx.div(10**(18 - uint(ulToken.decimals)));\n      if (ulToken.decimals > 18) tokenPx = tokenPx.mul(10**(uint(ulToken.decimals) - 18));\n      if (tokenPx < minPx) minPx = tokenPx;\n    }\n    require(minPx != uint(-1), 'no min px');\n    // use min underlying token prices\n    return minPx.mul(ICurvePool(pool).get_virtual_price()).div(1e18);\n  }\n}"
    }
  ]
}