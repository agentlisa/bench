{
  "Title": "M-2: CREATE opcode works differently in the zkSync chain",
  "Content": "# Issue M-2: CREATE opcode works differently in the zkSync chain \n\nSource: https://github.com/sherlock-audit/2024-04-titles-judging/issues/91 \n\n## Found by \nArsenLupin, Kalogerone, me\\_na0mi\n## Summary\n\n`zkSync Era` chain has differences in the usage of the `create` opcode compared to the EVM.\n\n## Vulnerability Detail\n\nAccording to the contest README, the protocol can be deployed in zkSync Era ([README](https://github.com/sherlock-audit/2024-04-titles/blob/d7f60952df22da00b772db5d3a8272a988546089/README.md?plain=1#L11))\n\nThe zkSync Era docs explain how it differs from Ethereum.\n\nThe description of CREATE and CREATE2 ([zkSynce Era Docs](https://era.zksync.io/docs/reference/architecture/differences-with-ethereum.html#create-create2)) states that Create cannot be used for arbitrary code unknown to the compiler.\n\n`TitlesCore::createEdition` function uses Solady's `LibClone::clone` function:\n\n```javascript\n    function createEdition(bytes calldata payload_, address referrer_) external payable returns (Edition edition) {\n\n        EditionPayload memory payload = abi.decode(payload_.cdDecompress(), (EditionPayload));\n\n@>      edition = Edition(editionImplementation.clone()); \n\n        // wake-disable-next-line reentrancy\n        edition.initialize(\n            feeManager, graph, payload.work.creator.target, address(this), payload.metadata\n        );\n\n        // wake-disable-next-line unchecked-return-value\n        _publish(edition, payload.work, referrer_);\n\n        emit EditionCreated(\n            address(edition),\n            payload.work.creator.target,\n            payload.work.maxSupply,\n            payload.work.strategy,\n            abi.encode(payload.metadata)\n        );\n    }\n```\n```javascript\n    function clone(uint256 value, address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n            mstore(0x14, implementation)\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n@>          instance := create(value, 0x0c, 0x35)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n```\n\nAs mentioned by the zkSync docs: \"The code will not function correctly because the compiler is not aware of the bytecode beforehand\". \n\nThis will result in **loss of funds**, since there is a fee to create a new edition, hence the `TitlesCore::createEdition` function is payable.\n\n## Impact\n\nNo editions can be created in the zkSync Era chain.\n\n## Code Snippet\n\n[https://github.com/sherlock-audit/2024-04-titles/blob/d7f60952df22da00b772db5d3a8272a988546089/wallflower-contract-v2/src/TitlesCore.sol#L79](https://github.com/sherlock-audit/2024-04-titles/blob/d7f60952df22da00b772db5d3a8272a988546089/wallflower-contract-v2/src/TitlesCore.sol#L79)\n[https://github.com/Vectorized/solady/blob/91d5f64b39a4d20a3ce1b5e985103b8ea4dc1cfc/src/utils/LibClone.sol#L137](https://github.com/Vectorized/solady/blob/91d5f64b39a4d20a3ce1b5e985103b8ea4dc1cfc/src/utils/LibClone.sol#L137l)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThis can be solved by implementing CREATE2 directly and using `type(Edition).creationCode` as mentioned in the zkSync Era docs.\n\n\n\n## Discussion\n\n**midori-fuse**\n\nEscalate\n\nThis escalation raises two points:\n\nThe first point is that #353 and #440 are duplicates of this issue.\n\nThe second point is that this issue has been excluded without reasoning (nor do I see any signs of someone reviewing this issue), even though evidence has been provided, and the impacts have been shown:\n- The relevant part of the zkEVM docs has been linked within the report.\n- The contract is bricked for this issue, which fits into the \"rendering the contract useless\" in the medium severity criteria.\n- The contest README includes zkSync as a deployment chain.\n\nFor this reason I believe this issue (and the mentioned duplicates) to be a valid medium.\n\n\n**sherlock-admin3**\n\n> Escalate\n> \n> This escalation raises two points:\n> \n> The first point is that #353 and #440 are duplicates of this issue.\n> \n> The second point is that this issue has been excluded without reasoning (nor do I see any signs of someone reviewing this issue), even though evidence has been provided, and the impacts have been shown:\n> - The relevant part of the zkEVM docs has been linked within the report.\n> - The contract is bricked for this issue, which fits into the \"rendering the contract useless\" in the medium severity criteria.\n> - The contest README includes zkSync as a deployment chain.\n> \n> For this reason I believe this issue (and the mentioned duplicates) to be a valid medium.\n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**cvetanovv**\n\nI disagree with the escalation. This issue is invalid. \n\nYou can see Sherlock [documentation](https://docs.sherlock.xyz/audits/judging/judging#vii.-list-of-issue-categories-that-are-not-considered-valid) subclause 24. EVM opcodes type of issue is not valid.\n\n**midori-fuse**\n\nThe clause states:\n\n> Using Solidity versions that support EVM opcodes that don't work on networks on which the protocol is deployed is not a valid issue because one can manage compilation flags to compile for past EVM versions on newer Solidity versions.\n\nThis is not an issue of \"Using solidity versions\", because all solidity versions support the CREATE opcode, and this issue will manifest no matter what Solidity version you use, or what EVM you compile it on. The clause clearly states that the rule only applies to using Solidity versions such that it is mitigatable by managing compilation flags, it does not apply to all \"EVM opcodes type\" in general. \n\nAny issue also boils down to just \"EVM opcode\", because when you compile any Solidity source files, you always get EVM opcodes, the majority (if not, most of the time, all) of which you cannot manage compilation flags to the behavior you desire.\n\n**Kalogerone**\n\nI agree with @midori-fuse. Subclause 24 doesn't refer to these kind of issues. This issue is not about the solidity version used. Subclause 24 clearly covers the solution which cannot be applied here:\n\n>because one can manage compilation flags to compile for past EVM versions on newer Solidity versions.\n\n**cvetanovv**\n\n@midori-fuse and @Kalogerone, I agree with the comments and will consult with @WangSecurity about whether it is a valid issue.\n\n**Hash01011122**\n\nAgreed with @midori-fuse on \n>The clause clearly states that the rule only applies to using Solidity versions such that it is mitigatable by managing compilation flags, it does not apply to all \"EVM opcodes type\" in general.\n\nBut still this appears to be low. I will let head of judge decide severity of this issue.\n\n\n**Kalogerone**\n\nI would argue it is not a low because as I mentioned in my report, the function used to create a new contract is payable and the user has to pay a fee to do that. Zksync docs never mention that the function will fail/revert, meaning that the user’s funds are not safe and there is possible loss of funds.\n\n> The following code will not function correctly because the compiler is not aware of the bytecode beforehand\n\n\n> Unfortunately, it's impossible to differentiate between the above cases during compile-time. As a result, we strongly recommend including tests for any factory that deploys child contracts using type(T).creationCode.\n\n**WangSecurity**\n\nI agree with the escalation and that it should be a valid medium, rather than the high. Planning to accept the escalation and validate as medium with duplicates #353 and #440.\n\n**Evert0x**\n\nResult:\nMedium\nHas Duplicates\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [midori-fuse](https://github.com/sherlock-audit/2024-04-titles-judging/issues/91/#issuecomment-2108304828): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/326",
  "Code": [
    {
      "filename": "README.md?plain=1",
      "content": "# TITLES contest details\n\n- Join [Sherlock Discord](https://discord.gg/MABEWyASkp)\n- Submit findings using the issue page in your private contest repo (label issues as med or high)\n- [Read for more details](https://docs.sherlock.xyz/audits/watsons)\n\n# Q&A\n\n### Q: On what chains are the smart contracts going to be deployed?\nEthereum, Base, OP, Zora, Blast, Arbitrum, zkSync, Degen\n___\n\n### Q: If you are integrating tokens, are you allowing only whitelisted tokens to work with the codebase or any complying with the standard? Are they assumed to have certain properties, e.g. be non-reentrant? Are there any types of <a href=\"https://github.com/d-xo/weird-erc20\" target=\"_blank\" rel=\"noopener noreferrer\">weird tokens</a> you want to integrate?\nThe current version supports native ETH.\n___\n\n### Q: Are the admins of the protocols your contracts integrate with (if any) TRUSTED or RESTRICTED? If these integrations are trusted, should auditors also assume they are always responsive, for example, are oracles trusted to provide non-stale information, or VRF providers to respond within a designated timeframe?\nThe only third-party integration we utilize at this time is 0xSplits, and there are no critical roles involved.  Any issues directly related to 0xSplits own implementation is NOT in scope, consider the protocol to be trusted for the purpose of this audit.\n___\n\n### Q: Are there any protocol roles? Please list them and provide whether they are TRUSTED or RESTRICTED, or provide a more comprehensive description of what a role can and can't do/impact.\nThere are a few roles in the system with varying levels of power. \n\nADMIN_ROLE (Trusted) => Granted by the deployer to internal, trusted addresses only.\n  On TitlesCore, this role can:\n    1) Change the ERC-1155 Edition implementation contract to an arbitrary address (`setEditionImplementation`). No post-auth validation is performed.\n    2) Upgrade the contract to an arbitrary new implementation (via `_authorizeUpgrade`, inherited and overridden with auth check from Solady's `UUPSUpgradeable`)\n\n  On TitlesGraph, this role can:\n    1) Create new Edges at will (`createEdges`). No post-auth validation is applied, except the typical uniqueness checks.\n    2) Upgrade the contract to an arbitrary new implementation (via `_authorizeUpgrade`, inherited and overridden with auth check from Solady's `UUPSUpgradeable`)\n    3) Grant or revoke any role to/from any address (`grantRole`, `revokeRole`).\n\n  On FeeManager, this role can:\n    1) Set the protocol fees (`setProtocolFees`). All fees are constrained to a constant range.\n    2) Create or change a fee route for any work within any Edition (`createRoute`). This is the only way to change the fee route for a work after publication.\n    3) Withdraw any funds locked in the contract (`withdraw`). This is the only way to withdraw funds from the contract.\n    3) Grant or revoke any role to/from any address (`grantRole`, `revokeRole`).\n\nEDITION_MANAGER_ROLE (Restricted) =>\n  On an Edition, this role can:\n    1) Publish a new work with any desired configuration (`publish`). This is the only way to create new works after the Edition is created.\n    2) Mint promotional copies of any work (`promoMint`). There are no limitations on this action aside from the work's supply cap and minting period.\n    3) Set the Edition's ERC2981 royalty receiver (`setRoyaltyTarget`). This is the only way to change the royalty receiver for the Edition.\n    4) Grant or revoke any role to/from any address (`grantRole`, `revokeRole`).\n\nEDITION_PUBLISHER_ROLE (Restricted) =>\n  On TitlesCore, this role can:\n    1) Publish a new work under any Edition for which they have been granted the role (i.e. `edition.hasAnyRole(msg.sender, EDITION_PUBLISHER_ROLE)` is true) (`publish`). After auth, the request is passed to the Edition contract for further handling.\n\nEDITION_MINTER_ROLE (Restricted) =>\n  On an Edition, this role can:\n    1) Mint promotional copies of any work (`promoMint`). There are no limitations on this action aside from the work's supply cap and minting period.\n\nOther roles which don't have specific role IDs:\n  - Editions have an Ownable `owner` who can:\n    1) Mint promotional copies of any work (`promoMint`). There are no limitations on this action aside from the work's supply cap and minting period.\n    2) Grant or revoke EDITION_PUBLISHER_ROLE to/from any address (`grantPublisherRole`, `revokePublisherRole`).\n    3) Manage the ERC1155 contract in typical ways (e.g. transfer ownership). Notably, the owner CANNOT manage roles other than EDITION_PUBLISHER_ROLE.\n\n  - Works within an Edition have a `creator` who can:\n    1) Update the minting period for the work (`setTimeframe`). This is the only way to change the minting period for a work after publication.\n    2) Set the fee strategy for any work within the Edition (`setFeeStrategy`). This is the only way to change the fee strategy for a work after publication. The fee strategy is validated by the Fee Manager, and the final strategy (which may have been modified during validation) is applied immediately.\n    3) Set the metadata for their own works. This is the only way to change the metadata for a work after publication.\n    4) Transfer full ownership of the work to a new address (`transferWork`). This is the only way to change the creator for a work.\n\n  - FeeManager has an Ownable `owner` (essentially synonymous with `ADMIN_ROLE`, held by TitlesCore) who can:\n    1) Set the protocol fees (`setProtocolFees`). All fees are constrained to a constant range. This role is granted to the TitlesCore contract whose currently scoped version does not have a mechanism for leveraging this permission directly.\n    2) Create or change a fee route for any work within any Edition (`createRoute`). This is the only way to change the fee route for a work after publication.\n___\n\n### Q: For permissioned functions, please list all checks and requirements that will be made before calling the function.\nTitlesCore:\n  - `initialize` => initializer, cannot be run twice\n  - `publish` => checks that the caller has the EDITION_PUBLISHER_ROLE on the given Edition. \n  - `setEditionImplementation` => checks that the caller is the owner or has the ADMIN_ROLE\n\nFeeManager:\n  - `createRoute` => checks that the caller is the owner or has the ADMIN_ROLE\n  - `setProtocolFees` => checks that the caller is the owner or has the ADMIN_ROLE\n  - `withdraw` => checks that the caller is the owner or has the ADMIN_ROLE\n\nTitlesGraph:\n  - `createEdge` => checks that the caller is the contract identified by the `from` node (the `node.entity.target`).\n  - `createEdges` => checks that the caller is the owner or has the ADMIN_ROLE\n  - `acknowledgeEdge` (standard flow) => checks that the caller is either the creator of the contract identified by the `to` node, or that contract itself.\n  - `unacknowledgeEdge` (standard flow) => checks that the caller is either the creator of the contract identified by the `to` node, or that contract itself.\n  - `acknowledgeEdge` (signature flow) => checks that the given signature is valid for the `to` node's creator (supports both ECDSA and ERC1271 signers), that the signed hash matches (based on the edge ID and data provided), and that the signature has not been previously used.\n  - `unacknowledgeEdge` (signature flow) => checks that the given signature is valid for the `to` node's creator (supports both ECDSA and ERC1271 signers), that the signed hash matches (based on the edge ID and data provided), and that the signature has not been previously used.\n\nEdition:\n  - `initialize` => initializer, cannot be run twice\n  - `publish` => checks that the caller has the EDITION_MANAGER_ROLE\n  - `promoMint` => checks that the caller is the owner of the Edition or holds the EDITION_MANAGER_ROLE or EDITION_MINTER_ROLE\n  - `setFeeStrategy` => checks that the caller is the creator of the work for which the strategy is being set.\n  - `setMetadata` => checks that the caller is the owner if ID is 0 (representing the Edition itself), or the creator of the specified work otherwise.\n  - `setTimeframe` => checks that the caller is the creator of the work for which the timeframe is being set.\n  - `transferWork` => checks that the caller is the creator of the work being transferred.\n  - `grantRoles`/`revokeRoles` => checks that the caller has the EDITION_MANAGER_ROLE\n  - `grantPublisherRole`/`revokePublisherRole` => checks that the caller is the owner of the Edition or has the EDITION_MANAGER_ROLE\n___\n\n### Q: Is the codebase expected to comply with any EIPs? Can there be/are there any deviations from the specification?\nstrict implementation of EIPs\n1271 (Graph), 712 (Graph, Edition), 2981 (Edition), 1155 (Edition)\n___\n\n### Q: Are there any off-chain mechanisms or off-chain procedures for the protocol (keeper bots, arbitrage bots, etc.)?\nN/A\n___\n\n### Q: Are there any hardcoded values that you intend to change before (some) deployments?\nThe exact amounts of the fees controlled by FeeManager may change before deployment, but only within the bounds of the current fee constants.\n___\n\n### Q: If the codebase is to be deployed on an L2, what should be the behavior of the protocol in case of sequencer issues (if applicable)? Should Sherlock assume that the Sequencer won't misbehave, including going offline?\nOut of scope\n___\n\n### Q: Should potential issues, like broken assumptions about function behavior, be reported if they could pose risks in future integrations, even if they might not be an issue in the context of the scope? If yes, can you elaborate on properties/invariants that should hold?\nYes.\n___\n\n### Q: Please discuss any design choices you made.\nFund Management: We chose to delegate fee payouts to 0xSplits v2. The protocol aims to avoid any direct TVL in this release.\n\nGraph: This is a new concept with a vast future design space, so we've erred on the side of a minimal implementation with low complexity. We intend to further standardize the OpenGraph model in the future.\n___\n\n### Q: Please list any known issues/acceptable risks that should not result in a valid finding.\nN/A\n___\n\n### Q: We will report issues where the core protocol functionality is inaccessible for at least 7 days. Would you like to override this value?\nNo\n___\n\n### Q: Please provide links to previous audits (if any).\nN/A\n___\n\n### Q: Please list any relevant protocol resources.\nRun `forge doc` or check out the /docs directory in the repo for pretty comprehensive auto-generated docs from the natspec. \n___\n\n### Q: Additional audit information.\nIn addition to the security of funds, we would also like there to be focus on the sanctity of the data in the TitlesGraph and the permissioning around it (only the appropriate people/contracts can signal reference and acknowledgement of reference). \n___\n\n\n\n# Audit scope\n\n\n[wallflower-contract-v2 @ d23c44def46ce4fd74f3daae36df0135acae7505](https://github.com/titlesnyc/wallflower-contract-v2/tree/d23c44def46ce4fd74f3daae36df0135acae7505)\n- [wallflower-contract-v2/src/TitlesCore.sol](wallflower-contract-v2/src/TitlesCore.sol)\n- [wallflower-contract-v2/src/editions/Edition.sol](wallflower-contract-v2/src/editions/Edition.sol)\n- [wallflower-contract-v2/src/fees/FeeManager.sol](wallflower-contract-v2/src/fees/FeeManager.sol)\n- [wallflower-contract-v2/src/graph/TitlesGraph.sol](wallflower-contract-v2/src/graph/TitlesGraph.sol)\n- [wallflower-contract-v2/src/shared/Common.sol](wallflower-contract-v2/src/shared/Common.sol)"
    },
    {
      "filename": "wallflower-contract-v2/src/TitlesCore.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {LibClone} from \"lib/solady/src/utils/LibClone.sol\";\nimport {LibZip} from \"lib/solady/src/utils/LibZip.sol\";\nimport {OwnableRoles} from \"lib/solady/src/auth/OwnableRoles.sol\";\nimport {Receiver} from \"lib/solady/src/accounts/Receiver.sol\";\nimport {Initializable} from \"lib/solady/src/utils/Initializable.sol\";\nimport {SafeTransferLib} from \"lib/solady/src/utils/SafeTransferLib.sol\";\nimport {UUPSUpgradeable} from \"lib/solady/src/utils/UUPSUpgradeable.sol\";\n\nimport {EnumerableMap} from \"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableMap.sol\";\nimport {EnumerableSet} from \"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\";\n\nimport {Edition} from \"src/editions/Edition.sol\";\nimport {FeeManager} from \"src/fees/FeeManager.sol\";\n\nimport {\n    ADMIN_ROLE,\n    EDITION_PUBLISHER_ROLE,\n    EditionCreated,\n    FeeStrategyUpdated,\n    Metadata,\n    Node,\n    Strategy,\n    Target\n} from \"src/shared/Common.sol\";\nimport {TitlesGraph} from \"src/graph/TitlesGraph.sol\";\n\n/// @title Titles Core\n/// @notice Core contract for the Titles Protocol\ncontract TitlesCore is OwnableRoles, Initializable, UUPSUpgradeable, Receiver {\n    using LibClone for address;\n    using LibZip for bytes;\n    using SafeTransferLib for address;\n\n    address public editionImplementation = address(new Edition());\n    FeeManager public feeManager;\n    TitlesGraph public graph;\n\n    /// @notice Initializes the protocol.\n    /// @param feeReceiver_ The address to receive fees.\n    /// @param splitFactory_ The address of the split factory.\n    function initialize(address feeReceiver_, address splitFactory_) external initializer {\n        _initializeOwner(msg.sender);\n\n        feeManager = new FeeManager(msg.sender, feeReceiver_, splitFactory_);\n        graph = new TitlesGraph(address(this), msg.sender);\n    }\n\n    /// @notice The payload for creating a Work within an {Edition}.\n    struct WorkPayload {\n        Target creator;\n        Node[] attributions;\n        uint256 maxSupply;\n        uint64 opensAt;\n        uint64 closesAt;\n        Strategy strategy;\n        Metadata metadata;\n    }\n\n    /// @notice The payload for creating an {Edition}.\n    struct EditionPayload {\n        WorkPayload work;\n        Metadata metadata;\n    }\n\n    /// @notice Creates an {Edition} with the given payload.\n    /// @param payload_ The compressed payload for creating the {Edition}. See {EditionPayload}.\n    /// @param referrer_ The address of the referrer.\n    /// @return edition The new {Edition}.\n    function createEdition(bytes calldata payload_, address referrer_)\n        external\n        payable\n        returns (Edition edition)\n    {\n        EditionPayload memory payload = abi.decode(payload_.cdDecompress(), (EditionPayload));\n\n        edition = Edition(editionImplementation.clone());\n\n        // wake-disable-next-line reentrancy\n        edition.initialize(\n            feeManager, graph, payload.work.creator.target, address(this), payload.metadata\n        );\n\n        // wake-disable-next-line unchecked-return-value\n        _publish(edition, payload.work, referrer_);\n\n        emit EditionCreated(\n            address(edition),\n            payload.work.creator.target,\n            payload.work.maxSupply,\n            payload.work.strategy,\n            abi.encode(payload.metadata)\n        );\n    }\n\n    /// @notice Publishes a new Work in the given {Edition} using the given payload.\n    /// @param edition_ The {Edition} to publish the Work in.\n    /// @param payload_ The compressed payload for publishing the Work. See {WorkPayload}.\n    /// @param referrer_ The address of the referrer.\n    /// @return tokenId The token ID of the new Work.\n    function publish(Edition edition_, bytes calldata payload_, address referrer_)\n        external\n        payable\n        returns (uint256 tokenId)\n    {\n        if (!edition_.hasAnyRole(msg.sender, EDITION_PUBLISHER_ROLE)) {\n            revert Unauthorized();\n        }\n        WorkPayload memory payload = abi.decode(payload_.cdDecompress(), (WorkPayload));\n        return _publish(edition_, payload, referrer_);\n    }\n\n    /// @notice Publishes a new Work in the given {Edition} using the given payload.\n    /// @param edition_ The {Edition} to publish the Work in.\n    /// @param work_ The payload for publishing the Work. See {EditionPayload}.\n    /// @param referrer_ The address of the referrer.\n    /// @return tokenId The token ID of the new Work.\n    function _publish(Edition edition_, WorkPayload memory work_, address referrer_)\n        internal\n        returns (uint256 tokenId)\n    {\n        // Publish the new Work in the Edition\n        // wake-disable-next-line reentrancy\n        tokenId = edition_.publish(\n            work_.creator.target,\n            work_.maxSupply,\n            work_.opensAt,\n            work_.closesAt,\n            work_.attributions,\n            work_.strategy,\n            work_.metadata\n        );\n\n        // Collect the creation fee\n        // wake-disable-next-line reentrancy\n        feeManager.collectCreationFee{value: msg.value}(edition_, tokenId, msg.sender);\n\n        // Create the fee route for the new Work\n        // wake-disable-next-line reentrancy\n        Target memory feeReceiver = feeManager.createRoute(\n            edition_, tokenId, _attributionTargets(work_.attributions), referrer_\n        );\n\n        // Set the royalty target for the new Work\n        // wake-disable-next-line reentrancy\n        edition_.setRoyaltyTarget(tokenId, feeReceiver.target);\n    }\n\n    /// @notice Sets the implementation address to be cloned for each new {Edition}.\n    /// @param implementation_ The new implementation address.\n    /// @dev Only the owner can call this function.\n    function setEditionImplementation(address implementation_)\n        external\n        onlyOwnerOrRoles(ADMIN_ROLE)\n    {\n        editionImplementation = implementation_;\n    }\n\n    /// @inheritdoc UUPSUpgradeable\n    /// @dev This function is overridden to restrict access to the owner/admin. No other logic required.\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyOwnerOrRoles(ADMIN_ROLE)\n    {}\n\n    /// @notice Returns the targets of the given attributions.\n    function _attributionTargets(Node[] memory attributions_)\n        internal\n        pure\n        returns (Target[] memory targets)\n    {\n        targets = new Target[](attributions_.length);\n        for (uint256 i = 0; i < attributions_.length; i++) {\n            targets[i] = attributions_[i].creator;\n        }\n    }\n}"
    },
    {
      "filename": "src/utils/LibClone.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Minimal proxy library.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibClone.sol)\n/// @author Minimal proxy by 0age (https://github.com/0age)\n/// @author Clones with immutable args by wighawag, zefram.eth, Saw-mon & Natalie\n/// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)\n/// @author Minimal ERC1967 proxy by jtriley-eth (https://github.com/jtriley-eth/minimum-viable-proxy)\n///\n/// @dev Minimal proxy:\n/// Although the sw0nt pattern saves 5 gas over the erc-1167 pattern during runtime,\n/// it is not supported out-of-the-box on Etherscan. Hence, we choose to use the 0age pattern,\n/// which saves 4 gas over the erc-1167 pattern during runtime, and has the smallest bytecode.\n///\n/// @dev Minimal proxy (PUSH0 variant):\n/// This is a new minimal proxy that uses the PUSH0 opcode introduced during Shanghai.\n/// It is optimized first for minimal runtime gas, then for minimal bytecode.\n/// The PUSH0 clone functions are intentionally postfixed with a jarring \"_PUSH0\" as\n/// many EVM chains may not support the PUSH0 opcode in the early months after Shanghai.\n/// Please use with caution.\n///\n/// @dev Clones with immutable args (CWIA):\n/// The implementation of CWIA here implements a `receive()` method that emits the\n/// `ReceiveETH(uint256)` event. This skips the `DELEGATECALL` when there is no calldata,\n/// enabling us to accept hard gas-capped `sends` & `transfers` for maximum backwards\n/// composability. The minimal proxy implementation does not offer this feature.\n///\n/// @dev Minimal ERC1967 proxy:\n/// An minimal ERC1967 proxy, intended to be upgraded with UUPS.\n/// This is NOT the same as ERC1967Factory's transparent proxy, which includes admin logic.\n///\n/// @dev ERC1967I proxy:\n/// An variant of the minimal ERC1967 proxy, with a special code path that activates\n/// if `calldatasize() == 1`. This code path skips the delegatecall and directly returns the\n/// `implementation` address. The returned implementation is guaranteed to be valid if the\n/// keccak256 of the proxy's code is equal to `ERC1967I_CODE_HASH`.\nlibrary LibClone {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The keccak256 of the deployed code for the ERC1967 proxy.\n    bytes32 internal constant ERC1967_CODE_HASH =\n        0xaaa52c8cc8a0e3fd27ce756cc6b4e70c51423e9b597b11f32d3e49f8b1fc890d;\n\n    /// @dev The keccak256 of the deployed code for the ERC1967I proxy.\n    bytes32 internal constant ERC1967I_CODE_HASH =\n        0xce700223c0d4cea4583409accfc45adac4a093b3519998a9cbbe1504dadba6f7;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Unable to deploy the clone.\n    error DeploymentFailed();\n\n    /// @dev The salt must start with either the zero address or `by`.\n    error SaltDoesNotStartWith();\n\n    /// @dev The ETH transfer has failed.\n    error ETHTransferFailed();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  MINIMAL PROXY OPERATIONS                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Deploys a clone of `implementation`.\n    function clone(address implementation) internal returns (address instance) {\n        instance = clone(0, implementation);\n    }\n\n    /// @dev Deploys a clone of `implementation`.\n    /// Deposits `value` ETH during deployment.\n    function clone(uint256 value, address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * --------------------------------------------------------------------------+\n             * CREATION (9 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\n             * --------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize     | r         |                              |\n             * 3d         | RETURNDATASIZE    | 0 r       |                              |\n             * 81         | DUP2              | r 0 r     |                              |\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                              |\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\n             * --------------------------------------------------------------------------|\n             * RUNTIME (44 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\n             * --------------------------------------------------------------------------|\n             *                                                                           |\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | 0                      |                       |\n             * 3d      | RETURNDATASIZE | 0 0                    |                       |\n             * 3d      | RETURNDATASIZE | 0 0 0                  |                       |\n             * 3d      | RETURNDATASIZE | 0 0 0 0                |                       |\n             *                                                                           |\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            |                       |\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          |                       |\n             * 3d      | RETURNDATASIZE | 0 0 cds 0 0 0 0        |                       |\n             * 37      | CALLDATACOPY   | 0 0 0 0                | [0..cds): calldata    |\n             *                                                                           |\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            | [0..cds): calldata    |\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          | [0..cds): calldata    |\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0 0 0     | [0..cds): calldata    |\n             * 5a      | GAS            | gas addr 0 cds 0 0 0 0 | [0..cds): calldata    |\n             * f4      | DELEGATECALL   | success 0 0            | [0..cds): calldata    |\n             *                                                                           |\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | rds success 0 0        | [0..cds): calldata    |\n             * 3d      | RETURNDATASIZE | rds rds success 0 0    | [0..cds): calldata    |\n             * 93      | SWAP4          | 0 rds success 0 rds    | [0..cds): calldata    |\n             * 80      | DUP1           | 0 0 rds success 0 rds  | [0..cds): calldata    |\n             * 3e      | RETURNDATACOPY | success 0 rds          | [0..rds): returndata  |\n             *                                                                           |\n             * 60 0x2a | PUSH1 0x2a     | 0x2a success 0 rds     | [0..rds): returndata  |\n             * 57      | JUMPI          | 0 rds                  | [0..rds): returndata  |\n             *                                                                           |\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * fd      | REVERT         |                        | [0..rds): returndata  |\n             *                                                                           |\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b      | JUMPDEST       | 0 rds                  | [0..rds): returndata  |\n             * f3      | RETURN         |                        | [0..rds): returndata  |\n             * --------------------------------------------------------------------------+\n             */\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n            mstore(0x14, implementation)\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            instance := create(value, 0x0c, 0x35)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Deploys a deterministic clone of `implementation` with `salt`.\n    function cloneDeterministic(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = cloneDeterministic(0, implementation, salt);\n    }\n\n    /// @dev Deploys a deterministic clone of `implementation` with `salt`.\n    /// Deposits `value` ETH during deployment.\n    function cloneDeterministic(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n            mstore(0x14, implementation)\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            instance := create2(value, 0x0c, 0x35, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the initialization code of the clone of `implementation`.\n    function initCode(address implementation) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(add(result, 0x40), 0x5af43d3d93803e602a57fd5bf30000000000000000000000)\n            mstore(add(result, 0x28), implementation)\n            mstore(add(result, 0x14), 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            mstore(result, 0x35) // Store the length.\n            mstore(0x40, add(result, 0x60)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the clone of `implementation`.\n    /// Used for mining vanity addresses with create2crunch.\n    function initCodeHash(address implementation) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n            mstore(0x14, implementation)\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            hash := keccak256(0x0c, 0x35)\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the address of the deterministic clone of `implementation`,\n    /// with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddress(address implementation, bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address predicted)\n    {\n        bytes32 hash = initCodeHash(implementation);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*          MINIMAL PROXY OPERATIONS (PUSH0 VARIANT)          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Deploys a PUSH0 clone of `implementation`.\n    function clone_PUSH0(address implementation) internal returns (address instance) {\n        instance = clone_PUSH0(0, implementation);\n    }\n\n    /// @dev Deploys a PUSH0 clone of `implementation`.\n    /// Deposits `value` ETH during deployment.\n    function clone_PUSH0(uint256 value, address implementation)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * --------------------------------------------------------------------------+\n             * CREATION (9 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\n             * --------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize     | r         |                              |\n             * 5f         | PUSH0             | 0 r       |                              |\n             * 81         | DUP2              | r 0 r     |                              |\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\n             * 5f         | PUSH0             | 0 o r 0 r |                              |\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\n             * --------------------------------------------------------------------------|\n             * RUNTIME (45 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\n             * --------------------------------------------------------------------------|\n             *                                                                           |\n             * ::: keep some values in stack :::::::::::::::::::::::::::::::::::::"
    }
  ]
}