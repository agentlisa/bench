{
  "Title": "[M-18] A lack of slippage protection can lead to a significant loss of user funds",
  "Content": "\nTalos strategy contracts interact with Uniswap V3 in multiple areas of the code. However, none of these interactions contain any [slippage control](https://dacian.me/defi-slippage-attacks#heading-no-slippage-parameter). This means, the contract, and by extension, all users who hold shares, can lose a significant value due to liquid pools or MEV sandwich attacks every time any of the relevant functions are called.\n\n### Impact\n\n[`TalosBaseStrategy#deposit`](https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/base/TalosBaseStrategy.sol#L201-L210) is the entry point for any Talos vault and it transfers tokens from the caller to the vault to be deposited into Uniswap V3. Since it lacks a slippage control, every user who interacts with any Talos vault will risk having their funds stolen by MEV bots. [`PoolActions#rerange`](https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/libraries/PoolActions.sol#L73-L87) is also vulnerable (which is called whenever the strategy manager wishes to rebalance pool allocation of the vault), which may lead to vault funds being at risk to the detriment of shareholders. The \"vault initialize\" function [`TalosBaseStrategy#init`](https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/base/TalosBaseStrategy.sol#L135-L149) is vulnerable as well; however, only the vault owners funds would be at risk here.\n\n### Proof of Concept\n\nIn each of the below instances, a call to Uniswap V3 is made. Calls `amount0Min` and `amount1Min` are each set to `0`, which allows for a **100% slippage tolerance**. This means, that the action could lead to the caller losing up to 100% of their tokens due to slippage.\n\n[`TalosBaseStrategy#deposit`](https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/base/TalosBaseStrategy.sol#L201-L210):\n\n```solidity\n        (liquidityDifference, amount0, amount1) = nonfungiblePositionManager.increaseLiquidity(\n            INonfungiblePositionManager.IncreaseLiquidityParams({\n                tokenId: _tokenId,\n                amount0Desired: amount0Desired,\n                amount1Desired: amount1Desired,\n                amount0Min: 0, // @audit should be non-zero\n                amount1Min: 0, // @audit should be non-zero\n                deadline: block.timestamp\n            })\n        );\n```\n\n[`PoolActions#rerange`](https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/libraries/PoolActions.sol#L73-L87):\n\n```solidity\n        (tokenId, liquidity, amount0, amount1) = nonfungiblePositionManager.mint(\n            INonfungiblePositionManager.MintParams({\n                token0: address(actionParams.token0),\n                token1: address(actionParams.token1),\n                fee: poolFee,\n                tickLower: tickLower,\n                tickUpper: tickUpper,\n                amount0Desired: balance0,\n                amount1Desired: balance1,\n                amount0Min: 0, // @audit should be non-zero\n                amount1Min: 0, // @audit should be non-zero\n                recipient: address(this),\n                deadline: block.timestamp\n            })\n```\n\n[`TalosBaseStrategy#init`](https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/base/TalosBaseStrategy.sol#L135-L149):\n\n```solidity\n        (_tokenId, _liquidity, amount0, amount1) = _nonfungiblePositionManager.mint(\n            INonfungiblePositionManager.MintParams({\n                token0: address(_token0),\n                token1: address(_token1),\n                fee: poolFee,\n                tickLower: tickLower,\n                tickUpper: tickUpper,\n                amount0Desired: amount0Desired,\n                amount1Desired: amount1Desired,\n                amount0Min: 0, // @audit should be non-zero\n                amount1Min: 0, // @audit should be non-zero\n                recipient: address(this),\n                deadline: block.timestamp\n            })\n        );\n```\n\n[`TalosBaseStrategy#_withdrawAll`](https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/base/TalosBaseStrategy.sol#L353-L361):\n\n```solidity\n        _nonfungiblePositionManager.decreaseLiquidity(\n            INonfungiblePositionManager.DecreaseLiquidityParams({\n                tokenId: _tokenId,\n                liquidity: _liquidity,\n                amount0Min: 0, // @audit should be non-zero\n                amount1Min: 0, // @audit should be non-zero\n                deadline: block.timestamp\n            })\n        );\n```\n\n### Recommended Mitigation Steps\n\nFor each vulnerable function, allow the caller to specify values for `amount0Min` and `amount1Min` instead of setting them to `0`.\n\n### Assessed type\n\nUniswap\n\n**[Trust (judge) decreased severity to Medium](https://github.com/code-423n4/2023-05-maia-findings/issues/577#issuecomment-1649408047)**\n\n**[0xLightt (Maia) confirmed and commented](https://github.com/code-423n4/2023-05-maia-findings/issues/577#issuecomment-1651930410):**\n > > none of these interactions contain any [slippage control](https://dacian.me/defi-slippage-attacks#heading-no-slippage-parameter).\n> \n> Just want to add that this is not accurate. These functions, except `init`, already have the `checkDeviation` [modifier](https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/base/TalosBaseStrategy.sol#L421-L427) that offers some level of protection.\n> \n> But this issue is still valid, since the pool's slippage protection offered by the modifier may not be the same as the desired by the user. This way, the user can define their own settings.\n\n**[0xLightt (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/577#issuecomment-1709163274):**\n > Addressed [here](https://github.com/Maia-DAO/eco-c4-contest/tree/577-57-504-658-583-730).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/talos/base/TalosBaseStrategy.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Logic inspired by Popsicle Finance Contracts (PopsicleV3Optimizer/contracts/popsicle-v3-optimizer/PopsicleV3Optimizer.sol)\npragma solidity >=0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\nimport {IUniswapV3Pool} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {INonfungiblePositionManager} from \"@uniswap/v3-periphery/contracts/interfaces/INonfungiblePositionManager.sol\";\n\nimport {PoolVariables} from \"../libraries/PoolVariables.sol\";\n\nimport {ITalosBaseStrategy} from \"../interfaces/ITalosBaseStrategy.sol\";\nimport {ITalosOptimizer} from \"../interfaces/ITalosOptimizer.sol\";\n\n/// @title Tokenized Vault implementation for Uniswap V3 Non Fungible Positions.\nabstract contract TalosBaseStrategy is Ownable, ERC20, ReentrancyGuard, ITalosBaseStrategy {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n    using FixedPointMathLib for uint128;\n    using SafeCastLib for uint256;\n    using SafeCastLib for uint128;\n    using PoolVariables for IUniswapV3Pool;\n\n    /*//////////////////////////////////////////////////////////////\n                        TALOS BASE STRATEGY STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    uint256 public override tokenId;\n    /// @inheritdoc ITalosBaseStrategy\n    uint128 public override liquidity;\n\n    /// @inheritdoc ITalosBaseStrategy\n    uint256 public protocolFees0;\n    /// @inheritdoc ITalosBaseStrategy\n    uint256 public protocolFees1;\n\n    /// @notice Current tick lower of Optimizer pool position\n    /// @inheritdoc ITalosBaseStrategy\n    int24 public override tickLower;\n    /// @notice Current tick higher of Optimizer pool position\n    /// @inheritdoc ITalosBaseStrategy\n    int24 public override tickUpper;\n\n    /// @inheritdoc ITalosBaseStrategy\n    bool public initialized;\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    ERC20 public immutable override token0;\n    /// @inheritdoc ITalosBaseStrategy\n    ERC20 public immutable override token1;\n    /// @inheritdoc ITalosBaseStrategy\n    int24 public immutable override tickSpacing;\n    /// @inheritdoc ITalosBaseStrategy\n    uint24 public immutable override poolFee;\n    /// @inheritdoc ITalosBaseStrategy\n    IUniswapV3Pool public immutable override pool;\n    /// @inheritdoc ITalosBaseStrategy\n    ITalosOptimizer public immutable override optimizer;\n    /// @inheritdoc ITalosBaseStrategy\n    address public immutable strategyManager;\n    /// @inheritdoc ITalosBaseStrategy\n    INonfungiblePositionManager public immutable override nonfungiblePositionManager;\n\n    uint24 internal constant MULTIPLIER = 1e6;\n\n    constructor(\n        IUniswapV3Pool _pool,\n        ITalosOptimizer _optimizer,\n        INonfungiblePositionManager _nonfungiblePositionManager,\n        address _strategyManager,\n        address _owner\n    ) ERC20(\"TALOS LP\", \"TLP\", 18) {\n        _initializeOwner(_owner);\n        optimizer = _optimizer;\n        nonfungiblePositionManager = _nonfungiblePositionManager;\n        strategyManager = _strategyManager;\n        pool = _pool;\n        token0 = ERC20(_pool.token0());\n        token1 = ERC20(_pool.token1());\n        tickSpacing = _pool.tickSpacing();\n        poolFee = _pool.fee();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            INITIALIZATION\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    function init(uint256 amount0Desired, uint256 amount1Desired, address receiver)\n        external\n        virtual\n        nonReentrant\n        returns (uint256 shares, uint256 amount0, uint256 amount1)\n    {\n        if (initialized) revert AlreadyInitialized();\n\n        {\n            // Own Scope to avoid stack to deep\n            int24 _tickSpacing = tickSpacing; // Saves an extra SLOAD\n            int24 baseThreshold = _tickSpacing * optimizer.tickRangeMultiplier();\n            (, int24 currentTick,,,,,) = pool.slot0();\n            int24 tickFloor = PoolVariables.floor(currentTick, _tickSpacing);\n\n            int24 _tickLower = tickFloor - baseThreshold; // Saves an extra SLOAD\n            int24 _tickUpper = tickFloor + baseThreshold; // Saves an extra SLOAD\n            PoolVariables.checkRange(_tickLower, _tickUpper); // Check ticks also for overflow/underflow\n            tickLower = _tickLower;\n            tickUpper = _tickUpper;\n        }\n\n        (ERC20 _token0, ERC20 _token1) = (token0, token1);\n        address(_token0).safeTransferFrom(msg.sender, address(this), amount0Desired);\n        address(_token1).safeTransferFrom(msg.sender, address(this), amount1Desired);\n\n        INonfungiblePositionManager _nonfungiblePositionManager = nonfungiblePositionManager; // Saves an extra SLOAD\n\n        address(_token0).safeApprove(address(_nonfungiblePositionManager), type(uint256).max);\n        address(_token1).safeApprove(address(_nonfungiblePositionManager), type(uint256).max);\n\n        uint128 _liquidity;\n        uint256 _tokenId;\n        (_tokenId, _liquidity, amount0, amount1) = _nonfungiblePositionManager.mint(\n            INonfungiblePositionManager.MintParams({\n                token0: address(_token0),\n                token1: address(_token1),\n                fee: poolFee,\n                tickLower: tickLower,\n                tickUpper: tickUpper,\n                amount0Desired: amount0Desired,\n                amount1Desired: amount1Desired,\n                amount0Min: 0,\n                amount1Min: 0,\n                recipient: address(this),\n                deadline: block.timestamp\n            })\n        );\n\n        if (amount0 == 0 && amount1 == 0) revert AmountsAreZero();\n\n        shares = _liquidity * MULTIPLIER;\n        liquidity = _liquidity;\n        tokenId = _tokenId;\n\n        _mint(receiver, shares);\n        if (totalSupply > optimizer.maxTotalSupply()) revert ExceedingMaxTotalSupply();\n\n        emit Initialize(tokenId, msg.sender, receiver, amount0, amount1, shares);\n\n        afterDeposit(_tokenId);\n        initialized = true;\n\n        // Refund in both assets.\n        if (amount0 < amount0Desired) {\n            uint256 refund0 = amount0Desired - amount0;\n            address(_token0).safeTransfer(msg.sender, refund0);\n        }\n\n        if (amount1 < amount1Desired) {\n            uint256 refund1 = amount1Desired - amount1;\n            address(_token1).safeTransfer(msg.sender, refund1);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    function deposit(uint256 amount0Desired, uint256 amount1Desired, address receiver)\n        public\n        virtual\n        override\n        nonReentrant\n        checkDeviation\n        returns (uint256 shares, uint256 amount0, uint256 amount1)\n    {\n        uint256 _tokenId = tokenId;\n\n        beforeDeposit(_tokenId, receiver);\n\n        (ERC20 _token0, ERC20 _token1) = (token0, token1);\n\n        address(_token0).safeTransferFrom(msg.sender, address(this), amount0Desired);\n        address(_token1).safeTransferFrom(msg.sender, address(this), amount1Desired);\n\n        uint128 liquidityDifference;\n\n        (liquidityDifference, amount0, amount1) = nonfungiblePositionManager.increaseLiquidity(\n            INonfungiblePositionManager.IncreaseLiquidityParams({\n                tokenId: _tokenId,\n                amount0Desired: amount0Desired,\n                amount1Desired: amount1Desired,\n                amount0Min: 0,\n                amount1Min: 0,\n                deadline: block.timestamp\n            })\n        );\n\n        if (amount0 == 0 && amount1 == 0) revert AmountsAreZero();\n\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n        shares = supply == 0 ? liquidityDifference * MULTIPLIER : (liquidityDifference * supply) / liquidity;\n        liquidity += liquidityDifference;\n\n        _mint(receiver, shares);\n        if (totalSupply > optimizer.maxTotalSupply()) revert ExceedingMaxTotalSupply();\n\n        emit Deposit(msg.sender, receiver, amount0, amount1, shares);\n\n        afterDeposit(_tokenId);\n\n        // Refund in both assets.\n        if (amount0 < amount0Desired) {\n            uint256 refund0 = amount0Desired - amount0;\n            address(_token0).safeTransfer(msg.sender, refund0);\n        }\n\n        if (amount1 < amount1Desired) {\n            uint256 refund1 = amount1Desired - amount1;\n            address(_token1).safeTransfer(msg.sender, refund1);\n        }\n    }\n\n    /// @inheritdoc ITalosBaseStrategy\n    function redeem(uint256 shares, uint256 amount0Min, uint256 amount1Min, address receiver, address _owner)\n        public\n        virtual\n        override\n        nonReentrant\n        checkDeviation\n        returns (uint256 amount0, uint256 amount1)\n    {\n        if (msg.sender != _owner) {\n            uint256 allowed = allowance[_owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[_owner][msg.sender] = allowed - shares;\n        }\n\n        if (shares == 0) revert RedeemingZeroShares();\n        if (receiver == address(0)) revert ReceiverIsZeroAddress();\n\n        uint256 _tokenId = tokenId;\n\n        beforeRedeem(_tokenId, receiver);\n\n        INonfungiblePositionManager _nonfungiblePositionManager = nonfungiblePositionManager; // Saves an extra SLOAD\n        {\n            uint128 liquidityToDecrease = uint128((liquidity * shares) / totalSupply);\n\n            (amount0, amount1) = _nonfungiblePositionManager.decreaseLiquidity(\n                INonfungiblePositionManager.DecreaseLiquidityParams({\n                    tokenId: _tokenId,\n                    liquidity: liquidityToDecrease,\n                    amount0Min: amount0Min,\n                    amount1Min: amount1Min,\n                    deadline: block.timestamp\n                })\n            );\n\n            if (amount0 == 0 && amount1 == 0) revert AmountsAreZero();\n\n            _burn(_owner, shares);\n\n            liquidity -= liquidityToDecrease;\n        }\n        emit Redeem(msg.sender, receiver, _owner, amount0, amount1, shares);\n\n        (amount0, amount1) = _nonfungiblePositionManager.collect(\n            INonfungiblePositionManager.CollectParams({\n                tokenId: _tokenId,\n                recipient: receiver,\n                amount0Max: type(uint128).max,\n                amount1Max: type(uint128).max\n            })\n        );\n\n        afterRedeem(_tokenId);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        RERANGE/REBALANCE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    function rerange() external virtual override nonReentrant checkDeviation onlyStrategyManager {\n        uint256 _tokenId = tokenId;\n        beforeRerange(_tokenId);\n        // Redeem all liquidity from pool to rerange for Optimizer's balances.\n        _withdrawAll(_tokenId);\n\n        (uint256 amount0, uint256 amount1) = doRerange();\n        emit Rerange(tokenId, tickLower, tickUpper, amount0, amount1);\n\n        afterRerange(tokenId); // tokenId changed in doRerange\n    }\n\n    /// @inheritdoc ITalosBaseStrategy\n    function rebalance() external virtual override nonReentrant checkDeviation onlyStrategyManager {\n        uint256 _tokenId = tokenId;\n        beforeRerange(_tokenId);\n        // Redeem all liquidity from pool to rerange for Optimizer's balances.\n        _withdrawAll(_tokenId);\n\n        (uint256 amount0, uint256 amount1) = doRebalance();\n        emit Rerange(tokenId, tickLower, tickUpper, amount0, amount1);\n\n        afterRerange(tokenId); // tokenId changed in doRerange\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL HOOKS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC721Receiver\n    function onERC721Received(address, address, uint256, bytes calldata) external pure override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /// @inheritdoc ITalosBaseStrategy\n    function uniswapV3SwapCallback(int256 amount0, int256 amount1, bytes calldata _data) external {\n        if (msg.sender != address(pool)) revert CallerIsNotPool();\n        if (amount0 == 0 && amount1 == 0) revert AmountsAreZero();\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        bool zeroForOne = data.zeroForOne;\n\n        if (zeroForOne) address(token0).safeTransfer(msg.sender, uint256(amount0));\n        else address(token1).safeTransfer(msg.sender, uint256(amount1));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Redeems all liquidity for a specific tokenId\n    /// @param _tokenId position to withdraw liquidity from\n    function _withdrawAll(uint256 _tokenId) internal {\n        uint128 _liquidity = liquidity; // Saves an extra SLOAD if totalSupply is non-zero.\n        if (_liquidity == 0) return;\n        INonfungiblePositionManager _nonfungiblePositionManager = nonfungiblePositionManager;\n        _nonfungiblePositionManager.decreaseLiquidity(\n            INonfungiblePositionManager.DecreaseLiquidityParams({\n                tokenId: _tokenId,\n                liquidity: _liquidity,\n                amount0Min: 0,\n                amount1Min: 0,\n                deadline: block.timestamp\n            })\n        );\n        liquidity = 0;\n        _nonfungiblePositionManager.collect(\n            INonfungiblePositionManager.CollectParams({\n                tokenId: _tokenId,\n                recipient: address(this),\n                amount0Max: type(uint128).max,\n                amount1Max: type(uint128).max\n            })\n        );\n    }\n\n    function beforeDeposit(uint256 _tokenId, address _receiver) internal virtual;\n\n    function afterDeposit(uint256 _tokenId) internal virtual;\n\n    function beforeRedeem(uint256 _tokenId, address _owner) internal virtual;\n\n    function afterRedeem(uint256 _tokenId) internal virtual;\n\n    function beforeRerange(uint256 _tokenId) internal virtual;\n\n    function afterRerange(uint256 _tokenId) internal virtual;\n\n    function doRerange() internal virtual returns (uint256 amount0, uint256 amount1);\n\n    function doRebalance() internal virtual returns (uint256 amount0, uint256 amount1);\n\n    /*//////////////////////////////////////////////////////////////\n                            ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    function collectProtocolFees(uint256 amount0, uint256 amount1) external nonReentrant onlyOwner {\n        uint256 _protocolFees0 = protocolFees0;\n        uint256 _protocolFees1 = protocolFees1;\n\n        if (amount0 > _protocolFees0) {\n            revert Token0AmountIsBiggerThanProtocolFees();\n        }\n        if (amount1 > _protocolFees1) {\n            revert Token1AmountIsBiggerThanProtocolFees();\n        }\n        ERC20 _token0 = token0;\n        ERC20 _token1 = token1;\n        uint256 balance0 = _token0.balanceOf(address(this));\n        uint256 balance1 = _token1.balanceOf(address(this));\n        require(balance0 >= amount0 && balance1 >= amount1);\n        if (amount0 > 0) _token0.transfer(msg.sender, amount0);\n        if (amount1 > 0) _token1.transfer(msg.sender, amount1);\n\n        protocolFees0 = _protocolFees0 - amount0;\n        protocolFees1 = _protocolFees1 - amount1;\n        emit RewardPaid(msg.sender, amount0, amount1);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Function modifier that checks if price has not moved a lot recently.\n    /// This mitigates price manipulation during rebalance and also prevents placing orders when it's too volatile.\n    modifier checkDeviation() {\n        ITalosOptimizer _optimizer = optimizer;\n        pool.checkDeviation(_optimizer.maxTwapDeviation(), _optimizer.twapDuration());\n        _;\n    }\n\n    /// @notice Function modifier that checks if msg.sender is the strategy manager.\n    modifier onlyStrategyManager() {\n        if (msg.sender != strategyManager) revert NotStrategyManager();\n        _;\n    }\n}"
    },
    {
      "filename": "src/talos/base/TalosBaseStrategy.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Logic inspired by Popsicle Finance Contracts (PopsicleV3Optimizer/contracts/popsicle-v3-optimizer/PopsicleV3Optimizer.sol)\npragma solidity >=0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\nimport {IUniswapV3Pool} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {INonfungiblePositionManager} from \"@uniswap/v3-periphery/contracts/interfaces/INonfungiblePositionManager.sol\";\n\nimport {PoolVariables} from \"../libraries/PoolVariables.sol\";\n\nimport {ITalosBaseStrategy} from \"../interfaces/ITalosBaseStrategy.sol\";\nimport {ITalosOptimizer} from \"../interfaces/ITalosOptimizer.sol\";\n\n/// @title Tokenized Vault implementation for Uniswap V3 Non Fungible Positions.\nabstract contract TalosBaseStrategy is Ownable, ERC20, ReentrancyGuard, ITalosBaseStrategy {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n    using FixedPointMathLib for uint128;\n    using SafeCastLib for uint256;\n    using SafeCastLib for uint128;\n    using PoolVariables for IUniswapV3Pool;\n\n    /*//////////////////////////////////////////////////////////////\n                        TALOS BASE STRATEGY STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    uint256 public override tokenId;\n    /// @inheritdoc ITalosBaseStrategy\n    uint128 public override liquidity;\n\n    /// @inheritdoc ITalosBaseStrategy\n    uint256 public protocolFees0;\n    /// @inheritdoc ITalosBaseStrategy\n    uint256 public protocolFees1;\n\n    /// @notice Current tick lower of Optimizer pool position\n    /// @inheritdoc ITalosBaseStrategy\n    int24 public override tickLower;\n    /// @notice Current tick higher of Optimizer pool position\n    /// @inheritdoc ITalosBaseStrategy\n    int24 public override tickUpper;\n\n    /// @inheritdoc ITalosBaseStrategy\n    bool public initialized;\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    ERC20 public immutable override token0;\n    /// @inheritdoc ITalosBaseStrategy\n    ERC20 public immutable override token1;\n    /// @inheritdoc ITalosBaseStrategy\n    int24 public immutable override tickSpacing;\n    /// @inheritdoc ITalosBaseStrategy\n    uint24 public immutable override poolFee;\n    /// @inheritdoc ITalosBaseStrategy\n    IUniswapV3Pool public immutable override pool;\n    /// @inheritdoc ITalosBaseStrategy\n    ITalosOptimizer public immutable override optimizer;\n    /// @inheritdoc ITalosBaseStrategy\n    address public immutable strategyManager;\n    /// @inheritdoc ITalosBaseStrategy\n    INonfungiblePositionManager public immutable override nonfungiblePositionManager;\n\n    uint24 internal constant MULTIPLIER = 1e6;\n\n    constructor(\n        IUniswapV3Pool _pool,\n        ITalosOptimizer _optimizer,\n        INonfungiblePositionManager _nonfungiblePositionManager,\n        address _strategyManager,\n        address _owner\n    ) ERC20(\"TALOS LP\", \"TLP\", 18) {\n        _initializeOwner(_owner);\n        optimizer = _optimizer;\n        nonfungiblePositionManager = _nonfungiblePositionManager;\n        strategyManager = _strategyManager;\n        pool = _pool;\n        token0 = ERC20(_pool.token0());\n        token1 = ERC20(_pool.token1());\n        tickSpacing = _pool.tickSpacing();\n        poolFee = _pool.fee();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            INITIALIZATION\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    function init(uint256 amount0Desired, uint256 amount1Desired, address receiver)\n        external\n        virtual\n        nonReentrant\n        returns (uint256 shares, uint256 amount0, uint256 amount1)\n    {\n        if (initialized) revert AlreadyInitialized();\n\n        {\n            // Own Scope to avoid stack to deep\n            int24 _tickSpacing = tickSpacing; // Saves an extra SLOAD\n            int24 baseThreshold = _tickSpacing * optimizer.tickRangeMultiplier();\n            (, int24 currentTick,,,,,) = pool.slot0();\n            int24 tickFloor = PoolVariables.floor(currentTick, _tickSpacing);\n\n            int24 _tickLower = tickFloor - baseThreshold; // Saves an extra SLOAD\n            int24 _tickUpper = tickFloor + baseThreshold; // Saves an extra SLOAD\n            PoolVariables.checkRange(_tickLower, _tickUpper); // Check ticks also for overflow/underflow\n            tickLower = _tickLower;\n            tickUpper = _tickUpper;\n        }\n\n        (ERC20 _token0, ERC20 _token1) = (token0, token1);\n        address(_token0).safeTransferFrom(msg.sender, address(this), amount0Desired);\n        address(_token1).safeTransferFrom(msg.sender, address(this), amount1Desired);\n\n        INonfungiblePositionManager _nonfungiblePositionManager = nonfungiblePositionManager; // Saves an extra SLOAD\n\n        address(_token0).safeApprove(address(_nonfungiblePositionManager), type(uint256).max);\n        address(_token1).safeApprove(address(_nonfungiblePositionManager), type(uint256).max);\n\n        uint128 _liquidity;\n        uint256 _tokenId;\n        (_tokenId, _liquidity, amount0, amount1) = _nonfungiblePositionManager.mint(\n            INonfungiblePositionManager.MintParams({\n                token0: address(_token0),\n                token1: address(_token1),\n                fee: poolFee,\n                tickLower: tickLower,\n                tickUpper: tickUpper,\n                amount0Desired: amount0Desired,\n                amount1Desired: amount1Desired,\n                amount0Min: 0,\n                amount1Min: 0,\n                recipient: address(this),\n                deadline: block.timestamp\n            })\n        );\n\n        if (amount0 == 0 && amount1 == 0) revert AmountsAreZero();\n\n        shares = _liquidity * MULTIPLIER;\n        liquidity = _liquidity;\n        tokenId = _tokenId;\n\n        _mint(receiver, shares);\n        if (totalSupply > optimizer.maxTotalSupply()) revert ExceedingMaxTotalSupply();\n\n        emit Initialize(tokenId, msg.sender, receiver, amount0, amount1, shares);\n\n        afterDeposit(_tokenId);\n        initialized = true;\n\n        // Refund in both assets.\n        if (amount0 < amount0Desired) {\n            uint256 refund0 = amount0Desired - amount0;\n            address(_token0).safeTransfer(msg.sender, refund0);\n        }\n\n        if (amount1 < amount1Desired) {\n            uint256 refund1 = amount1Desired - amount1;\n            address(_token1).safeTransfer(msg.sender, refund1);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    function deposit(uint256 amount0Desired, uint256 amount1Desired, address receiver)\n        public\n        virtual\n        override\n        nonReentrant\n        checkDeviation\n        returns (uint256 shares, uint256 amount0, uint256 amount1)\n    {\n        uint256 _tokenId = tokenId;\n\n        beforeDeposit(_tokenId, receiver);\n\n        (ERC20 _token0, ERC20 _token1) = (token0, token1);\n\n        address(_token0).safeTransferFrom(msg.sender, address(this), amount0Desired);\n        address(_token1).safeTransferFrom(msg.sender, address(this), amount1Desired);\n\n        uint128 liquidityDifference;\n\n        (liquidityDifference, amount0, amount1) = nonfungiblePositionManager.increaseLiquidity(\n            INonfungiblePositionManager.IncreaseLiquidityParams({\n                tokenId: _tokenId,\n                amount0Desired: amount0Desired,\n                amount1Desired: amount1Desired,\n                amount0Min: 0,\n                amount1Min: 0,\n                deadline: block.timestamp\n            })\n        );\n\n        if (amount0 == 0 && amount1 == 0) revert AmountsAreZero();\n\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n        shares = supply == 0 ? liquidityDifference * MULTIPLIER : (liquidityDifference * supply) / liquidity;\n        liquidity += liquidityDifference;\n\n        _mint(receiver, shares);\n        if (totalSupply > optimizer.maxTotalSupply()) revert ExceedingMaxTotalSupply();\n\n        emit Deposit(msg.sender, receiver, amount0, amount1, shares);\n\n        afterDeposit(_tokenId);\n\n        // Refund in both assets.\n        if (amount0 < amount0Desired) {\n            uint256 refund0 = amount0Desired - amount0;\n            address(_token0).safeTransfer(msg.sender, refund0);\n        }\n\n        if (amount1 < amount1Desired) {\n            uint256 refund1 = amount1Desired - amount1;\n            address(_token1).safeTransfer(msg.sender, refund1);\n        }\n    }\n\n    /// @inheritdoc ITalosBaseStrategy\n    function redeem(uint256 shares, uint256 amount0Min, uint256 amount1Min, address receiver, address _owner)\n        public\n        virtual\n        override\n        nonReentrant\n        checkDeviation\n        returns (uint256 amount0, uint256 amount1)\n    {\n        if (msg.sender != _owner) {\n            uint256 allowed = allowance[_owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[_owner][msg.sender] = allowed - shares;\n        }\n\n        if (shares == 0) revert RedeemingZeroShares();\n        if (receiver == address(0)) revert ReceiverIsZeroAddress();\n\n        uint256 _tokenId = tokenId;\n\n        beforeRedeem(_tokenId, receiver);\n\n        INonfungiblePositionManager _nonfungiblePositionManager = nonfungiblePositionManager; // Saves an extra SLOAD\n        {\n            uint128 liquidityToDecrease = uint128((liquidity * shares) / totalSupply);\n\n            (amount0, amount1) = _nonfungiblePositionManager.decreaseLiquidity(\n                INonfungiblePositionManager.DecreaseLiquidityParams({\n                    tokenId: _tokenId,\n                    liquidity: liquidityToDecrease,\n                    amount0Min: amount0Min,\n                    amount1Min: amount1Min,\n                    deadline: block.timestamp\n                })\n            );\n\n            if (amount0 == 0 && amount1 == 0) revert AmountsAreZero();\n\n            _burn(_owner, shares);\n\n            liquidity -= liquidityToDecrease;\n        }\n        emit Redeem(msg.sender, receiver, _owner, amount0, amount1, shares);\n\n        (amount0, amount1) = _nonfungiblePositionManager.collect(\n            INonfungiblePositionManager.CollectParams({\n                tokenId: _tokenId,\n                recipient: receiver,\n                amount0Max: type(uint128).max,\n                amount1Max: type(uint128).max\n            })\n        );\n\n        afterRedeem(_tokenId);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        RERANGE/REBALANCE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    function rerange() external virtual override nonReentrant checkDeviation onlyStrategyManager {\n        uint256 _tokenId = tokenId;\n        beforeRerange(_tokenId);\n        // Redeem all liquidity from pool to rerange for Optimizer's balances.\n        _withdrawAll(_tokenId);\n\n        (uint256 amount0, uint256 amount1) = doRerange();\n        emit Rerange(tokenId, tickLower, tickUpper, amount0, amount1);\n\n        afterRerange(tokenId); // tokenId changed in doRerange\n    }\n\n    /// @inheritdoc ITalosBaseStrategy\n    function rebalance() external virtual override nonReentrant checkDeviation onlyStrategyManager {\n        uint256 _tokenId = tokenId;\n        beforeRerange(_tokenId);\n        // Redeem all liquidity from pool to rerange for Optimizer's balances.\n        _withdrawAll(_tokenId);\n\n        (uint256 amount0, uint256 amount1) = doRebalance();\n        emit Rerange(tokenId, tickLower, tickUpper, amount0, amount1);\n\n        afterRerange(tokenId); // tokenId changed in doRerange\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL HOOKS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC721Receiver\n    function onERC721Received(address, address, uint256, bytes calldata) external pure override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /// @inheritdoc ITalosBaseStrategy\n    function uniswapV3SwapCallback(int256 amount0, int256 amount1, bytes calldata _data) external {\n        if (msg.sender != address(pool)) revert CallerIsNotPool();\n        if (amount0 == 0 && amount1 == 0) revert AmountsAreZero();\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        bool zeroForOne = data.zeroForOne;\n\n        if (zeroForOne) address(token0).safeTransfer(msg.sender, uint256(amount0));\n        else address(token1).safeTransfer(msg.sender, uint256(amount1));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Redeems all liquidity for a specific tokenId\n    /// @param _tokenId position to withdraw liquidity from\n    function _withdrawAll(uint256 _tokenId) internal {\n        uint128 _liquidity = liquidity; // Saves an extra SLOAD if totalSupply is non-zero.\n        if (_liquidity == 0) return;\n        INonfungiblePositionManager _nonfungiblePositionManager = nonfungiblePositionManager;\n        _nonfungiblePositionManager.decreaseLiquidity(\n            INonfungiblePositionManager.DecreaseLiquidityParams({\n                tokenId: _tokenId,\n                liquidity: _liquidity,\n                amount0Min: 0,\n                amount1Min: 0,\n                deadline: block.timestamp\n            })\n        );\n        liquidity = 0;\n        _nonfungiblePositionManager.collect(\n            INonfungiblePositionManager.CollectParams({\n                tokenId: _tokenId,\n                recipient: address(this),\n                amount0Max: type(uint128).max,\n                amount1Max: type(uint128).max\n            })\n        );\n    }\n\n    function beforeDeposit(uint256 _tokenId, address _receiver) internal virtual;\n\n    function afterDeposit(uint256 _tokenId) internal virtual;\n\n    function beforeRedeem(uint256 _tokenId, address _owner) internal virtual;\n\n    function afterRedeem(uint256 _tokenId) internal virtual;\n\n    function beforeRerange(uint256 _tokenId) internal virtual;\n\n    function afterRerange(uint256 _tokenId) internal virtual;\n\n    function doRerange() internal virtual returns (uint256 amount0, uint256 amount1);\n\n    function doRebalance() internal virtual returns (uint256 amount0, uint256 amount1);\n\n    /*//////////////////////////////////////////////////////////////\n                            ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    function collectProtocolFees(uint256 amount0, uint256 amount1) external nonReentrant onlyOwner {"
    }
  ]
}