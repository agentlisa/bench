{
  "Title": "Make `LSSVMPair::call` payable to allow value to be sent with external calls",
  "Content": "**Description:**\nCurrently, [`LSSVMPair::call`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/LSSVMPair.sol#L640) simply passes a [value of zero](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/LSSVMPair.sol#L661); however, there may be instances in which non-zero `msg.value` is required/desired and so the function should be marked as payable to allow the owner to supply ETH for the external call.\n\n**Impact:**\nIf the owner wishes to send ETH with the external call, they cannot do so, which may impact the external call's functionality.\n\n**Recommended Mitigation:**\nConsider allowing value to be passed to external calls by making `LSSVMPair::call` payable.\n\n**Sudoswap:**\nAcknowledged.\n\n**Cyfrin:**\nAcknowledged.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/LSSVMPair.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IRoyaltyEngineV1} from \"manifoldxyz/IRoyaltyEngineV1.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport {ERC721Holder} from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport {ERC1155Holder} from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\n\nimport {LSSVMRouter} from \"./LSSVMRouter.sol\";\nimport {ICurve} from \"./bonding-curves/ICurve.sol\";\nimport {ILSSVMPairFactoryLike} from \"./ILSSVMPairFactoryLike.sol\";\nimport {CurveErrorCodes} from \"./bonding-curves/CurveErrorCodes.sol\";\nimport {IOwnershipTransferReceiver} from \"./lib/IOwnershipTransferReceiver.sol\";\nimport {OwnableWithTransferCallback} from \"./lib/OwnableWithTransferCallback.sol\";\n\n/// @title The base contract for an NFT/TOKEN AMM pair\n/// @author boredGenius and 0xmons\n/// @notice This implements the core swap logic from NFT to TOKEN\nabstract contract LSSVMPair is OwnableWithTransferCallback, ERC721Holder, ERC1155Holder {\n    /**\n     * Library usage\n     */\n\n    using Address for address;\n\n    /**\n     *  Enums\n     */\n\n    enum PoolType {\n        TOKEN,\n        NFT,\n        TRADE\n    }\n\n    /**\n     * Constants\n     */\n\n    /// @dev 50%, must <= 1 - MAX_PROTOCOL_FEE (set in LSSVMPairFactory)\n    uint256 internal constant MAX_TRADE_FEE = 0.5e18;\n\n    /**\n     *  Immutable params\n     */\n\n    // Sudoswap Royalty Engine\n    IRoyaltyEngineV1 public immutable ROYALTY_ENGINE;\n\n    /**\n     *  Storage variables\n     */\n\n    // @dev This is generally used to mean the immediate sell price for the next marginal NFT.\n    // However, this should NOT be assumed, as bonding curves may use spotPrice in different ways.\n    // Use getBuyNFTQuote and getSellNFTQuote for accurate pricing info.\n    uint128 public spotPrice;\n\n    // The parameter for the pair's bonding curve.\n    // Units and meaning are bonding curve dependent.\n    uint128 public delta;\n\n    // The spread between buy and sell prices, set to be a multiplier we apply to the buy price\n    // Fee is only relevant for TRADE pools\n    // Units are in base 1e18\n    uint96 public fee;\n\n    // The address that swapped assets are sent to\n    // For TRADE pools, assets are always sent to the pool, so this is used to track trade fee\n    // If set to address(0), will default to owner() for NFT and TOKEN pools\n    address payable internal assetRecipient;\n\n    /**\n     *  Events\n     */\n\n    event SwapNFTInPair(uint256 amountIn, uint256[] ids);\n    event SwapNFTInPair(uint256 amountIn, uint256 numNFTs);\n    event SwapNFTOutPair(uint256 amountOut, uint256[] ids);\n    event SwapNFTOutPair(uint256 amountOut, uint256 numNFTs);\n    event SpotPriceUpdate(uint128 newSpotPrice);\n    event TokenDeposit(uint256 amount);\n    event TokenWithdrawal(uint256 amount);\n    event NFTWithdrawal(uint256[] ids);\n    event NFTWithdrawal(uint256 numNFTs);\n    event DeltaUpdate(uint128 newDelta);\n    event FeeUpdate(uint96 newFee);\n    event AssetRecipientChange(address indexed a);\n\n    /**\n     *  Errors\n     */\n\n    error LSSVMPair__NotRouter();\n    error LSSVMPair__CallFailed();\n    error LSSVMPair__InvalidDelta();\n    error LSSVMPair__WrongPoolType();\n    error LSSVMPair__OutputTooSmall();\n    error LSSVMPair__ZeroSwapAmount();\n    error LSSVMPair__RoyaltyTooLarge();\n    error LSSVMPair__TradeFeeTooLarge();\n    error LSSVMPair__InvalidSpotPrice();\n    error LSSVMPair__TargetNotAllowed();\n    error LSSVMPair__NftNotTransferred();\n    error LSSVMPair__AlreadyInitialized();\n    error LSSVMPair__FunctionNotAllowed();\n    error LSSVMPair__DemandedInputTooLarge();\n    error LSSVMPair__NonTradePoolWithTradeFee();\n    error LSSVMPair__BondingCurveError(CurveErrorCodes.Error error);\n\n    constructor(IRoyaltyEngineV1 royaltyEngine) {\n        ROYALTY_ENGINE = royaltyEngine;\n    }\n\n    /**\n     * @notice Called during pair creation to set initial parameters\n     *   @dev Only called once by factory to initialize.\n     *   We verify this by making sure that the current owner is address(0).\n     *   The Ownable library we use disallows setting the owner to be address(0), so this condition\n     *   should only be valid before the first initialize call.\n     *   @param _owner The owner of the pair\n     *   @param _assetRecipient The address that will receive the TOKEN or NFT sent to this pair during swaps. NOTE: If set to address(0), they will go to the pair itself.\n     *   @param _delta The initial delta of the bonding curve\n     *   @param _fee The initial % fee taken, if this is a trade pair\n     *   @param _spotPrice The initial price to sell an asset into the pair\n     */\n    function initialize(\n        address _owner,\n        address payable _assetRecipient,\n        uint128 _delta,\n        uint96 _fee,\n        uint128 _spotPrice\n    ) external {\n        if (owner() != address(0)) revert LSSVMPair__AlreadyInitialized();\n        __Ownable_init(_owner);\n\n        ICurve _bondingCurve = bondingCurve();\n        PoolType _poolType = poolType();\n        if (_poolType != PoolType.TRADE) {\n            if (_fee != 0) revert LSSVMPair__NonTradePoolWithTradeFee();\n        } else {\n            if (_fee > MAX_TRADE_FEE) revert LSSVMPair__TradeFeeTooLarge();\n            fee = _fee;\n        }\n\n        // Set asset recipient if it's not address(0)\n        if (_assetRecipient != address(0)) {\n            assetRecipient = _assetRecipient;\n        }\n\n        if (!_bondingCurve.validateDelta(_delta)) revert LSSVMPair__InvalidDelta();\n        if (!_bondingCurve.validateSpotPrice(_spotPrice)) revert LSSVMPair__InvalidSpotPrice();\n        delta = _delta;\n        spotPrice = _spotPrice;\n    }\n\n    /**\n     * External state-changing functions\n     */\n\n    /**\n     * @notice Sends token to the pair in exchange for a specific set of NFTs\n     *     @dev To compute the amount of token to send, call bondingCurve.getBuyInfo\n     *     This swap is meant for users who want specific IDs. Also higher chance of\n     *     reverting if some of the specified IDs leave the pool before the swap goes through.\n     *     @param nftIds The list of IDs of the NFTs to purchase\n     *     @param maxExpectedTokenInput The maximum acceptable cost from the sender. If the actual\n     *     amount is greater than this value, the transaction will be reverted.\n     *     @param nftRecipient The recipient of the NFTs\n     *     @param isRouter True if calling from LSSVMRouter, false otherwise. Not used for\n     *     ETH pairs.\n     *     @param routerCaller If isRouter is true, ERC20 tokens will be transferred from this address. Not used for\n     *     ETH pairs.\n     *     @return - The amount of token used for purchase\n     */\n    function swapTokenForSpecificNFTs(\n        uint256[] calldata nftIds,\n        uint256 maxExpectedTokenInput,\n        address nftRecipient,\n        bool isRouter,\n        address routerCaller\n    ) external payable virtual returns (uint256);\n\n    /**\n     * @notice Sends a set of NFTs to the pair in exchange for token\n     *     @dev To compute the amount of token to that will be received, call bondingCurve.getSellInfo.\n     *     @param nftIds The list of IDs of the NFTs to sell to the pair\n     *     @param minExpectedTokenOutput The minimum acceptable token received by the sender. If the actual\n     *     amount is less than this value, the transaction will be reverted.\n     *     @param tokenRecipient The recipient of the token output\n     *     @param isRouter True if calling from LSSVMRouter, false otherwise. Not used for\n     *     ETH pairs.\n     *     @param routerCaller If isRouter is true, ERC20 tokens will be transferred from this address. Not used for\n     *     ETH pairs.\n     *     @return outputAmount The amount of token received\n     */\n    function swapNFTsForToken(\n        uint256[] calldata nftIds,\n        uint256 minExpectedTokenOutput,\n        address payable tokenRecipient,\n        bool isRouter,\n        address routerCaller\n    ) external virtual returns (uint256 outputAmount);\n\n    /**\n     * View functions\n     */\n\n    /**\n     * @dev Used as read function to query the bonding curve for buy pricing info\n     *     @param numNFTs The number of NFTs to buy from the pair\n     */\n    function getBuyNFTQuote(uint256 assetId, uint256 numNFTs)\n        external\n        view\n        returns (\n            CurveErrorCodes.Error error,\n            uint256 newSpotPrice,\n            uint256 newDelta,\n            uint256 inputAmount,\n            uint256 protocolFee,\n            uint256 royaltyAmount\n        )\n    {\n        uint256 tradeFee;\n        (error, newSpotPrice, newDelta, inputAmount, tradeFee, protocolFee) =\n            bondingCurve().getBuyInfo(spotPrice, delta, numNFTs, fee, factory().protocolFeeMultiplier());\n\n        if (numNFTs != 0) {\n            // Calculate the inputAmount minus tradeFee and protocolFee\n            uint256 inputAmountMinusFees = inputAmount - tradeFee - protocolFee;\n\n            // Compute royalties\n            (,, royaltyAmount) = calculateRoyaltiesView(assetId, inputAmountMinusFees);\n\n            inputAmount += royaltyAmount;\n        }\n    }\n\n    /**\n     * @dev Used as read function to query the bonding curve for sell pricing info including royalties\n     *     @param numNFTs The number of NFTs to sell to the pair\n     */\n    function getSellNFTQuote(uint256 assetId, uint256 numNFTs)\n        external\n        view\n        returns (\n            CurveErrorCodes.Error error,\n            uint256 newSpotPrice,\n            uint256 newDelta,\n            uint256 outputAmount,\n            uint256 protocolFee,\n            uint256 royaltyAmount\n        )\n    {\n        (error, newSpotPrice, newDelta, outputAmount, /* tradeFee */, protocolFee) =\n            bondingCurve().getSellInfo(spotPrice, delta, numNFTs, fee, factory().protocolFeeMultiplier());\n\n        if (numNFTs != 0) {\n            // Compute royalties\n            (,, royaltyAmount) = calculateRoyaltiesView(assetId, outputAmount);\n\n            // Deduct royalties from outputAmount\n            unchecked {\n                // Safe because we already require outputAmount >= royaltyAmount in _calculateRoyalties()\n                outputAmount -= royaltyAmount;\n            }\n        }\n    }\n\n    /**\n     * @notice Returns the pair's variant (Pair uses ETH or ERC20)\n     */\n    function pairVariant() public pure virtual returns (ILSSVMPairFactoryLike.PairVariant);\n\n    function factory() public pure returns (ILSSVMPairFactoryLike _factory) {\n        uint256 paramsLength = _immutableParamsLength();\n        assembly {\n            _factory := shr(0x60, calldataload(sub(calldatasize(), paramsLength)))\n        }\n    }\n\n    /**\n     * @notice Returns the type of bonding curve that parameterizes the pair\n     */\n    function bondingCurve() public pure returns (ICurve _bondingCurve) {\n        uint256 paramsLength = _immutableParamsLength();\n        assembly {\n            _bondingCurve := shr(0x60, calldataload(add(sub(calldatasize(), paramsLength), 20)))\n        }\n    }\n\n    /**\n     * @notice Returns the address of NFT collection that parameterizes the pair\n     */\n    function nft() public pure returns (address _nft) {\n        uint256 paramsLength = _immutableParamsLength();\n        assembly {\n            _nft := shr(0x60, calldataload(add(sub(calldatasize(), paramsLength), 40)))\n        }\n    }\n\n    /**\n     * @notice Returns the pair's type (TOKEN/NFT/TRADE)\n     */\n    function poolType() public pure returns (PoolType _poolType) {\n        uint256 paramsLength = _immutableParamsLength();\n        assembly {\n            _poolType := shr(0xf8, calldataload(add(sub(calldatasize(), paramsLength), 60)))\n        }\n    }\n\n    /**\n     * @notice Returns the address that assets that receives assets when a swap is done with this pair\n     *     Can be set to another address by the owner, but has no effect on TRADE pools\n     *     If set to address(0), defaults to owner() for NFT/TOKEN pools\n     */\n    function getAssetRecipient() public view returns (address payable) {\n        // TRADE pools will always receive the asset themselves\n        if (poolType() == PoolType.TRADE) {\n            return payable(address(this));\n        }\n\n        address payable _assetRecipient = assetRecipient;\n\n        // Otherwise, we return the recipient if it's been set\n        // Or, we replace it with owner() if it's address(0)\n        if (_assetRecipient == address(0)) {\n            return payable(owner());\n        }\n        return _assetRecipient;\n    }\n\n    /**\n     * @notice Returns the address that receives trade fees when a swap is done with this pair\n     *      Only relevant for TRADE pools\n     *      If set to address(0), defaults to the pair itself\n     */\n    function getFeeRecipient() public view returns (address payable _feeRecipient) {\n        _feeRecipient = assetRecipient;\n        if (_feeRecipient == address(0)) {\n            _feeRecipient = payable(address(this));\n        }\n    }\n\n    /**\n     * Internal functions\n     */\n\n    /**\n     * @notice Calculates the amount needed to be sent into the pair for a buy and adjusts spot price or delta if necessary\n     *     @param numNFTs The amount of NFTs to purchase from the pair\n     *     @param _bondingCurve The bonding curve to use for price calculation\n     *     @param _factory The factory to use for protocol fee lookup\n     *     @return tradeFee The amount of tokens to send as trade fee\n     *     @return protocolFee The amount of tokens to send as protocol fee\n     *     @return inputAmount The amount of tokens total tokens receive\n     */\n    function _calculateBuyInfoAndUpdatePoolParams(uint256 numNFTs, ICurve _bondingCurve, ILSSVMPairFactoryLike _factory)\n        internal\n        returns (uint256 tradeFee, uint256 protocolFee, uint256 inputAmount)\n    {\n        CurveErrorCodes.Error error;\n        // Save on 2 SLOADs by caching\n        uint128 currentSpotPrice = spotPrice;\n        uint128 currentDelta = delta;\n        uint128 newDelta;\n        uint128 newSpotPrice;\n        (error, newSpotPrice, newDelta, inputAmount, tradeFee, protocolFee) =\n            _bondingCurve.getBuyInfo(currentSpotPrice, currentDelta, numNFTs, fee, _factory.protocolFeeMultiplier());\n\n        // Revert if bonding curve had an error\n        if (error != CurveErrorCodes.Error.OK) {\n            revert LSSVMPair__BondingCurveError(error);\n        }\n\n        // Consolidate writes to save gas\n        if (currentSpotPrice != newSpotPrice || currentDelta != newDelta) {\n            spotPrice = newSpotPrice;\n            delta = newDelta;\n        }\n\n        // Emit spot price update if it has been updated\n        if (currentSpotPrice != newSpotPrice) {\n            emit SpotPriceUpdate(newSpotPrice);\n        }\n\n        // Emit delta update if it has been updated\n        if (currentDelta != newDelta) {\n            emit DeltaUpdate(newDelta);\n        }\n    }\n\n    /**\n     * @notice Calculates the amount needed to be sent by the pair for a sell and adjusts spot price or delta if necessary\n     *     @param numNFTs The amount of NFTs to send to the the pair\n     *     @param _bondingCurve The bonding curve to use for price calculation\n     *     @param _factory The factory to use for protocol fee lookup\n     *     @return protocolFee The amount of tokens to send as protocol fee\n     *     @return outputAmount The amount of tokens total tokens receive\n     */\n    function _calculateSellInfoAndUpdatePoolParams(\n        uint256 numNFTs,\n        ICurve _bondingCurve,\n        ILSSVMPairFactoryLike _factory\n    ) internal returns (uint256 protocolFee, uint256 outputAmount) {\n        CurveErrorCodes.Error error;\n        // Save on 2 SLOADs by caching\n        uint128 currentSpotPrice = spotPrice;\n        uint128 currentDelta = delta;\n        uint128 newSpotPrice;\n        uint128 newDelta;\n        (error, newSpotPrice, newDelta, outputAmount, /*tradeFee*/, protocolFee) =\n            _bondingCurve.getSellInfo(currentSpotPrice, currentDelta, numNFTs, fee, _factory.protocolFeeMultiplier());\n\n        // Revert if bonding curve had an error\n        if (error != CurveErrorCodes.Error.OK) {\n            revert LSSVMPair__BondingCurveError(error);\n        }\n\n        // Consolidate writes to save gas\n        if (currentSpotPrice != newSpotPrice || currentDelta != newDelta) {\n            spotPrice = newSpotPrice;\n            delta = newDelta;\n        }\n\n        // Emit spot price update if it has been updated\n        if (currentSpotPrice != newSpotPrice) {\n            emit SpotPriceUpdate(newSpotPrice);\n        }\n\n        // Emit delta update if it has been updated\n        if (currentDelta != newDelta) {\n            emit DeltaUpdate(newDelta);\n        }\n    }\n\n    /**\n     * @notice Pulls the token input of a trade from the trader (including all royalties and fees)\n     *     @param inputAmountExcludingRoyalty The amount of tokens to be sent, excluding the royalty (includes protocol fee)\n     *     @param royaltyAmounts The amounts of tokens to be sent as royalties\n     *     @param royaltyRecipients The recipients of the royalties\n     *     @param royaltyTotal The sum of all royaltyAmounts\n     *     @param tradeFeeAmount The amount of tokens to be sent as trade fee (if applicable)\n     *     @param isRouter Whether or not the caller is LSSVMRouter\n     *     @param routerCaller If called from LSSVMRouter, store the original caller\n     *     @param protocolFee The protocol fee to be paid\n     */\n    function _pullTokenInputs(\n        uint256 inputAmountExcludingRoyalty,\n        uint256[] memory royaltyAmounts,\n        address payable[] memory royaltyRecipients,\n        uint256 royaltyTotal,\n        uint256 tradeFeeAmount,\n        bool isRouter,\n        address routerCaller,\n        uint256 protocolFee\n    ) internal virtual;\n\n    /**\n     * @notice Sends excess tokens back to the caller (if applicable)\n     * @dev Swap callers interacting with an ETH pair must be able to receive ETH (e.g. if the caller sends too much ETH)\n     */\n    function _refundTokenToSender(uint256 inputAmount) internal virtual;\n\n    /**\n     * @notice Sends tokens to a recipient\n     *     @param tokenRecipient The address receiving the tokens\n     *     @param outputAmount The amount of tokens to send\n     */\n    function _sendTokenOutput(address payable tokenRecipient, uint256 outputAmount) internal virtual;\n\n    /**\n     * @dev Used internally to grab pair parameters from calldata, see LSSVMPairCloner for technical details\n     */\n    function _immutableParamsLength() internal pure virtual returns (uint256);\n\n    /**\n     * Royalty support functions\n     */\n\n    function _calculateRoyalties(uint256 assetId, uint256 saleAmount)\n        internal\n        returns (address payable[] memory royaltyRecipients, uint256[] memory royaltyAmounts, uint256 royaltyTotal)\n    {\n        (address payable[] memory recipients, uint256[] memory amounts) =\n            ROYALTY_ENGINE.getRoyalty(nft(), assetId, saleAmount);\n        return _calculateRoyaltiesLogic(recipients, amounts, saleAmount);\n    }\n\n    /**\n     * @dev Same as _calculateRoyalties, but uses getRoyaltyView to avoid state mutations and is public for external callers\n     */\n    function calculateRoyaltiesView(uint256 assetId, uint256 saleAmount)\n        public\n        view\n        returns (address payable[] memory royaltyRecipients, uint256[] memory royaltyAmounts, uint256 royaltyTotal)\n    {\n        (address payable[] memory recipients, uint256[] memory amounts) =\n            ROYALTY_ENGINE.getRoyaltyView(nft(), assetId, saleAmount);\n        return _calculateRoyaltiesLogic(recipients, amounts, saleAmount);\n    }\n\n    /**\n     * @dev Common logic used by _calculateRoyalties() and calculateRoyaltiesView()\n     */\n    function _calculateRoyaltiesLogic(address payable[] memory recipients, uint256[] memory amounts, uint256 saleAmount)\n        internal\n        view\n        returns (address payable[] memory royaltyRecipients, uint256[] memory royaltyAmounts, uint256 royaltyTotal)\n    {\n        // cache to save gas\n        uint256 numRecipients = recipients.length;\n\n        if (numRecipients != 0) {\n            // If a pair has custom Settings, use the overridden royalty amount and only use the first receiver\n            (bool settingsEnabled, uint96 bps) = factory().getSettingsForPair(address(this));\n            if (settingsEnabled) {\n                royaltyRecipients = new address payable[](1);\n                royaltyRecipients[0] = recipients[0];\n                royaltyAmounts = new uint256[](1);\n                royaltyAmounts[0] = (saleAmount * bps) / 10000;\n\n                // update numRecipients to match new recipients list\n                numRecipients = 1;\n            } else {\n                royaltyRecipients = recipients;\n                royaltyAmounts = amounts;\n            }\n        }\n\n        for (uint256 i; i < numRecipients;) {\n            royaltyTotal += royaltyAmounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Ensure royalty total is at most 25% of the sale amount\n        // This defends against a rogue Manifold registry that charges extremely\n        // high royalties\n        if (royaltyTotal > saleAmount >> 2) {\n            revert LSSVMPair__RoyaltyTooLarge();\n        }\n    }\n\n    /**\n     * Owner functions\n     */\n\n    /**\n     * @notice Rescues a specified set of NFTs owned by the pair to the owner address. (onlyOwnable modifier is in the implemented function)\n     *     @param a The NFT to transfer\n     *     @param nftIds The list of IDs of the NFTs to send to the owner\n     */\n    function withdrawERC721(IERC721 a, uint256[] calldata nftIds) external virtual;\n\n    /**\n     * @notice Rescues ERC20 tokens from the pair to the owner. Only callable by the owner (onlyOwnable modifier is in the implemented function).\n     *     @param a The token to transfer\n     *     @param amount The amount of tokens to send to the owner\n     */\n    function withdrawERC20(ERC20 a, uint256 amount) external virtual;\n\n    /**\n     * @notice Rescues ERC1155 tokens from the pair to the owner. Only callable by the owner.\n     *     @param a The NFT to transfer\n     *     @param ids The NFT ids to transfer\n     *     @param amounts The amounts of each id to transfer\n     */\n    function withdrawERC1155(IERC1155 a, uint256[] calldata ids, uint256[] calldata amounts) external virtual;\n\n    /**\n     * @notice Updates the selling spot price. Only callable by the owner.\n     *     @param newSpotPrice The new selling spot price value, in Token\n     */\n    function changeSpotPrice(uint128 newSpotPrice) external onlyOwner {\n        ICurve _bondingCurve = bondingCurve();\n        if (!_bondingCurve.validateSpotPrice(newSpotPrice)) revert LSSVMPair__InvalidSpotPrice();\n        if (spotPrice != newSpotPrice) {\n            spotPrice = newSpotPrice;\n            emit SpotPriceUpdate(newSpotPrice);\n        }\n    }\n\n    /**\n     * @notice Updates the delta parameter. Only callable by the owner.\n     *     @param newDelta The new delta parameter\n     */\n    function changeDelta(uint128 newDelta) external onlyOwner {\n        ICurve _bondingCurve = bondingCurve();\n        if (!_bondingCurve.validateDelta(newDelta)) revert LSSVMPair__InvalidDelta();\n        if (delta != newDelta) {\n            delta = newDelta;\n            emit DeltaUpdate(newDelta);\n        }\n    }\n\n    /**\n     * @notice Updates the fee taken by the LP. Only callable by the owner.\n     *     Only callable if the pool is a Trade pool. Reverts if the fee is >=\n     *     MAX_FEE.\n     *     @param newFee The new LP fee percentage, 18 decimals\n     */\n    function changeFee(uint96 newFee) external onlyOwner {\n        PoolType _poolType = poolType();\n        if (_poolType != PoolType.TRADE) revert LSSVMPair__NonTradePoolWithTradeFee();\n        if (newFee > MAX_TRADE_FEE) revert LSSVMPair__TradeFeeTooLarge();\n        if (fee != newFee) {\n            fee = newFee;\n            emit FeeUpdate(newFee);\n        }\n    }\n\n    /**\n     * @notice Changes the address that will receive assets received from\n     *     trades. Only callable by the owner.\n     *     @param newRecipient The new asset recipient\n     */\n    function changeAssetRecipient(address payable newRecipient) external onlyOwner {\n        if (assetRecipient != newRecipient) {\n            assetRecipient = newRecipient;\n            emit AssetRecipientChange(newRecipient);\n        }\n    }\n\n    function _preCallCheck(address target) internal virtual;\n\n    /**\n     * @notice Allows the pair to make arbitrary external calls to contracts\n     *     whitelisted by the protocol. Only callable by the owner.\n     *     @param target The contract to call\n     *     @param data The calldata to pass to the contract\n     */\n    function call(address payable target, bytes calldata data) external onlyOwner {\n        ILSSVMPairFactoryLike _factory = factory();\n        if (!_factory.callAllowed(target)) revert LSSVMPair__TargetNotAllowed();\n\n        // Ensure the call isn't calling a banned function\n        bytes4 sig = bytes4(data[:4]);\n        if (\n            sig == IOwnershipTransferReceiver.onOwnershipTransferred.selector\n                || sig == LSSVMRouter.pairTransferERC20From.selector || sig == LSSVMRouter.pairTransferNFTFrom.selector\n                || sig == LSSVMRouter.pairTransferERC1155From.selector || sig == ILSSVMPairFactoryLike.openLock.selector\n                || sig == ILSSVMPairFactoryLike.closeLock.selector\n        ) {\n            revert LSSVMPair__FunctionNotAllowed();\n        }\n\n        // Prevent calling the pair's underlying nft\n        // (We ban calling the underlying NFT/ERC20 to avoid maliciously transferring assets approved for the pair to spend)\n        if (target == nft()) revert LSSVMPair__TargetNotAllowed();\n\n        _preCallCheck(target);\n\n        (bool success,) = target.call{value: 0}(data);\n        if (!success) revert LSSVMPair__CallFailed();\n    }\n\n    /**\n     * @notice Allows owner to batch multiple calls, forked from: https://github.com/boringcrypto/BoringSolidity/blob/master/contracts/BoringBatchable.sol\n     *     @notice The revert handling is forked from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/c239e1af8d1a1296577108dd6989a17b57434f8e/contracts/utils/Address.sol#L201\n     *     @dev Intended for withdrawing/altering pool pricing in one tx, only callable by owner, cannot change owner\n     *     @param calls The calldata for each call to make\n     *     @param revertOnFail Whether or not to revert the entire tx if any of the calls fail. Calls to transferOwnership will revert regardless.\n     */\n    function multicall(bytes[] calldata calls, bool revertOnFail) external onlyOwner {\n        for (uint256 i; i < calls.length;) {\n            bytes4 sig = bytes4(calls[i][:4]);\n            // We ban calling transferOwnership when ownership\n            if (sig == transferOwnership.selector) revert LSSVMPair__FunctionNotAllowed();\n\n            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);\n            if (!success && revertOnFail) {\n                assembly {\n                    revert(add(0x20, result), mload(result))\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    }
  ]
}