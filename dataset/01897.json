{
  "Title": "M-9: Using the collateral assets' oracle price at 100% of its value to mint USSD without a fee can be used for arbitrage.",
  "Content": "# Issue M-9: Using the collateral assets' oracle price at 100% of its value to mint USSD without a fee can be used for arbitrage. \n\nSource: https://github.com/sherlock-audit/2023-05-USSD-judging/issues/836 \n\n## Found by \nWATCHPUG\n## Summary\n\nAllowing the users to mint USSD using the collateral assets, at 100% of its value based on the oracle price without a fee can easily be exploited by the arbitragers.\n\n## Vulnerability Detail\n\nThe Oracle price can not be trusted as the real-time price.\n\nFor example, the BTC/USD and ETH/USD price feeds on miannet have a \"Deviation threshold\" of 0.5%, meaning that the price will only be updated once the price movement exceeds 0.5% within the heartbeat period.\n\nSay if the previous price point for WETH is 1000 USD, the price will only be updated once the price goes up to more than 1005 USD or down to less than 995 USD.\n\n## Impact\n\nWhen the market price of WETH is lower than the oracle price, it is possible to mint 1000 USSD by using 1 WETH and selling it to DAI, causing the quality of the collateral for USSD to continuously decrease and the value to be leaked to the arbitragers.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSD.sol#L150-L173\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adding a minting fee of 0.5% to 1% (should be higher than the deviation).\n\n\n\n## Discussion\n\n**0xRobocop**\n\nEscalate for 10 USDC\n\nThis is not an issue, it assumes that a \"real-time\" price exists which is theoretically impossible. In reality there is no way to value a collateral precisely to a \"real-time\" price because this \"price\" does not exists and the markets are aligned thanks to arbitrageurs. \n\nWe cannot say that the chainlink price (if chainlink is behaving properly and contract consumes the prices safely) is below or above the \"market-price\", because there is no such \"market-price\", what we can say is that some market has a different price than chainlink's oracle. For example the ETH / DAI uniswap pool may have the price of 1 ETH for 996 DAI and chainlink's price may be 1 ETH for 1000 DAI. Watson argues that this scenario will:\n\n`cause the quality of the collateral for USSD to continuously decrease and the value to be leaked to the arbitragers.`\n\nWhich is not true, what will happen is the next:\n\n- 1. User will send 1 ETH to the USSD protocol and receive 1000 USSD.\n- 2. User will change 1000 USSD for 1000 DAI.\n- 3. User will buy ETH in uniswap with the 1000 DAI and receive 1.004 ETH, driving up the price of ETH in uniswap.\n- 4. User will repeat the process until the uniswap price is equal to the chainlink price and the arbitrage is no longer possible.\n- 5. ETH price increased in the \"below-price\" market, making the ETH collateral of the USSD protocol more valuable across different markets.\n\n\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> This is not an issue, it assumes that a \"real-time\" price exists which is theoretically impossible. In reality there is no way to value a collateral precisely to a \"real-time\" price because this \"price\" does not exists and the markets are aligned thanks to arbitrageurs. \n> \n> We cannot say that the chainlink price (if chainlink is behaving properly and contract consumes the prices safely) is below or above the \"market-price\", because there is no such \"market-price\", what we can say is that some market has a different price than chainlink's oracle. For example the ETH / DAI uniswap pool may have the price of 1 ETH for 996 DAI and chainlink's price may be 1 ETH for 1000 DAI. Watson argues that this scenario will:\n> \n> `cause the quality of the collateral for USSD to continuously decrease and the value to be leaked to the arbitragers.`\n> \n> Which is not true, what will happen is the next:\n> \n> - 1. User will send 1 ETH to the USSD protocol and receive 1000 USSD.\n> - 2. User will change 1000 USSD for 1000 DAI.\n> - 3. User will buy ETH in uniswap with the 1000 DAI and receive 1.004 ETH, driving up the price of ETH in uniswap.\n> - 4. User will repeat the process until the uniswap price is equal to the chainlink price and the arbitrage is no longer possible.\n> - 5. ETH price increased in the \"below-price\" market, making the ETH collateral of the USSD protocol more valuable across different markets.\n> \n> \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**twicek**\n\nEscalate for 10 USDC\n\nI agree with the comments made by 0xRobocop, this report describe a common scenario that lead to an arbitrage opportunity, which is not an issue.\nHitting the deviation threshold will lead for the price to be updated earlier than usual which will naturally lead to the arbitrage opportunity described by 0xRobocop. Adding a minting fee could actually be more detrimental since it would prevent arbitrager from getting the USSD / DAI Pool to equilibrium.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> I agree with the comments made by 0xRobocop, this report describe a common scenario that lead to an arbitrage opportunity, which is not an issue.\n> Hitting the deviation threshold will lead for the price to be updated earlier than usual which will naturally lead to the arbitrage opportunity described by 0xRobocop. Adding a minting fee could actually be more detrimental since it would prevent arbitrager from getting the USSD / DAI Pool to equilibrium.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\nAgree with the escalation.\n\n**hrishibhat**\n\nResult:\nMedium\nUnique\nConsidering this a valid medium. \nLead Watson comment:\n>  comment is basically describing the arbitrage CAN happen, the missing part there is ETH/DAI is a much deeper pool than USSD/DAI, the USSD/DAI pool will suffer a much bigger damage before the arbitrage opportunity disappears. This is not a common/natural scenario\n\n\n**sherlock-admin**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0xRobocop](https://github.com/sherlock-audit/2023-05-USSD-judging/issues/836/#issuecomment-1605228222): rejected\n- [twicek](https://github.com/sherlock-audit/2023-05-USSD-judging/issues/836/#issuecomment-1605860157): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/82",
  "Code": [
    {
      "filename": "ussd-contracts/contracts/USSD.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\nimport \"./interfaces/IStableOracle.sol\";\nimport \"./interfaces/IUSSDRebalancer.sol\";\n\nimport \"@uniswap/swap-router-contracts/contracts/interfaces/IV3SwapRouter.sol\";\n\n/**\n    @notice USSD: Autonomous on-chain stablecoin\n */\ncontract USSD is\n    IUSSD,\n    ERC20Upgradeable,\n    AccessControlUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address payable;\n\n    IUSSDRebalancer public rebalancer;\n\n    // allowed to manage collateral, set tresholds and perform management tasks\n    bytes32 public constant STABLE_CONTROL_ROLE = keccak256(\"STABLECONTROL\");\n\n    function initialize(\n        string memory name,\n        string memory symbol\n    ) public initializer {\n        __Context_init_unchained();\n        __AccessControl_init_unchained();\n        __ERC20_init_unchained(name, symbol);\n\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        // mint 10k USSD to create initial pool\n        _mint(msg.sender, 10_000 * 1e6);\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 6;\n    }\n\n    /**\n        @dev restrict calls only by STABLE_CONTROL_ROLE role\n     */\n    modifier onlyControl() {\n        require(hasRole(STABLE_CONTROL_ROLE, msg.sender), \"control only\");\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                Events\n    //////////////////////////////////////////////////////////////*/\n\n    event Mint(\n        address indexed from,\n        address indexed to,\n        address token,\n        uint256 amountToken,\n        uint256 amountStable\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                          COLLATERAL MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    CollateralInfo[] private collateral;\n\n    function collateralList()\n        public\n        view\n        override\n        returns (CollateralInfo[] memory)\n    {\n        return collateral;\n    }\n\n    function addCollateral(\n        address _address,\n        address _oracle,\n        bool _mint,\n        bool _redeem,\n        uint256[] calldata _ratios,\n        bytes memory _pathbuy,\n        bytes memory _pathsell,\n        uint256 index\n    ) public onlyControl {\n        CollateralInfo memory newCollateral = CollateralInfo({\n            token: _address,\n            mint: _mint,\n            redeem: _redeem,\n            oracle: IStableOracle(_oracle),\n            pathbuy: _pathbuy,\n            pathsell: _pathsell,\n            ratios: _ratios\n        });\n        if (index < collateral.length) {\n            collateral[index] = newCollateral; // for editing\n        } else {\n            collateral.push(newCollateral); // for adding new collateral\n        }\n    }\n\n    function swapCollateralIndexes(\n        uint256 _index1,\n        uint256 _index2\n    ) public onlyControl {\n        // cannot use (a, b) = (b, a) for storage variables\n        CollateralInfo memory tmp = collateral[_index1];\n        collateral[_index1] = collateral[_index2];\n        collateral[_index2] = tmp;\n    }\n\n    function removeCollateral(uint256 _index) public onlyControl {\n        collateral[_index] = collateral[collateral.length - 1];\n        collateral.pop();\n    }\n\n    function getCollateralIndex(\n        address _token\n    ) public view returns (uint256 index) {\n        for (index = 0; index < collateral.length; index++) {\n            if (collateral[index].token == _token) {\n                return index;\n            }\n        }\n    }\n\n    function hasCollateralMint(\n        address _token\n    ) public view returns (bool present) {\n        for (uint256 i = 0; i < collateral.length; i++) {\n            if (collateral[i].token == _token && collateral[i].mint) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// Mint specific AMOUNT OF STABLE by giving token\n    function mintForToken(\n        address token,\n        uint256 tokenAmount,\n        address to\n    ) public returns (uint256 stableCoinAmount) {\n        require(hasCollateralMint(token), \"unsupported token\");\n\n        IERC20Upgradeable(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            tokenAmount\n        );\n        stableCoinAmount = calculateMint(token, tokenAmount);\n        _mint(to, stableCoinAmount);\n\n        emit Mint(msg.sender, to, token, tokenAmount, stableCoinAmount);\n    }\n\n    /// @dev Return how much STABLECOIN does user receive for AMOUNT of asset\n    function calculateMint(address _token, uint256 _amount) public view returns (uint256 stableCoinAmount) {\n        uint256 assetPrice = collateral[getCollateralIndex(_token)].oracle.getPriceUSD();\n        return (((assetPrice * _amount) / 1e18) * (10 ** decimals())) / (10 ** IERC20MetadataUpgradeable(_token).decimals());\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function collateralFactor() public view override returns (uint256) {\n        uint256 totalAssetsUSD = 0;\n        for (uint256 i = 0; i < collateral.length; i++) {\n            totalAssetsUSD +=\n                (((IERC20Upgradeable(collateral[i].token).balanceOf(\n                    address(this)\n                ) * 1e18) /\n                    (10 **\n                        IERC20MetadataUpgradeable(collateral[i].token)\n                            .decimals())) *\n                    collateral[i].oracle.getPriceUSD()) /\n                1e18;\n        }\n\n        return (totalAssetsUSD * 1e6) / totalSupply();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               REBALANCER\n    //////////////////////////////////////////////////////////////*/\n\n    function setRebalancer(address _rebalancer) public onlyControl {\n        rebalancer = IUSSDRebalancer(_rebalancer);\n    }\n\n    function mintRebalancer(uint256 amount) public override {\n        _mint(address(this), amount);\n    }\n\n    function burnRebalancer(uint256 amount) public override {\n        _burn(address(this), amount);\n    }\n\n    modifier onlyBalancer() {\n        require(msg.sender == address(rebalancer), \"bal\");\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               UNISWAP\n    //////////////////////////////////////////////////////////////*/\n\n    IV3SwapRouter public uniRouter; // uniswap router to handle operations\n\n    function setUniswapRouter(address _router) public onlyControl {\n        uniRouter = IV3SwapRouter(_router);\n    }\n\n    function UniV3SwapInput(\n        bytes memory _path,\n        uint256 _sellAmount\n    ) public override onlyBalancer {\n        IV3SwapRouter.ExactInputParams memory params = IV3SwapRouter\n            .ExactInputParams({\n                path: _path,\n                recipient: address(this),\n                //deadline: block.timestamp,\n                amountIn: _sellAmount,\n                amountOutMinimum: 0\n            });\n        uniRouter.exactInput(params);\n    }\n\n    function approveToRouter(address _token) public {\n        IERC20Upgradeable(_token).approve(\n            address(uniRouter),\n            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n        );\n    }\n}"
    }
  ]
}