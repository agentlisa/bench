{
  "Title": "[M-01] Multiples initializations of `JBTiered721Delegate`",
  "Content": "\nThe `initialize` method of the `JBTiered721Delegate` contract has as a flag that the `_store` argument is different from `address(0)`, however, it can be initialized by anyone with this value to allow the project to continue with its usual initialization, the attacker could have interfered and modified the corresponding values to carry out an attack.\n\n### Proof of Concept\n\nLooking at the method below, we highlight in green the parts that need to be initialized to prevent a call to `store=address(0)` from failing.\n\n```diff\n  function initialize(\n    uint256 _projectId,\n    IJBDirectory _directory,\n    string memory _name,\n    string memory _symbol,\n    IJBFundingCycleStore _fundingCycleStore,\n    string memory _baseUri,\n    IJBTokenUriResolver _tokenUriResolver,\n    string memory _contractUri,\n    JB721PricingParams memory _pricing,\n    IJBTiered721DelegateStore _store,\n    JBTiered721Flags memory _flags\n  ) public override {\n    // Make the original un-initializable.\n    require(address(this) != codeOrigin);\n    // Stop re-initialization.\n    require(address(store) == address(0));\n\n    // Initialize the sub class.\n    JB721Delegate._initialize(_projectId, _directory, _name, _symbol);\n\n    fundingCycleStore = _fundingCycleStore;\n    store = _store;\n    pricingCurrency = _pricing.currency;\n    pricingDecimals = _pricing.decimals;\n    prices = _pricing.prices;\n\n    // Store the base URI if provided.\n+   if (bytes(_baseUri).length != 0) _store.recordSetBaseUri(_baseUri);\n\n    // Set the contract URI if provided.\n+   if (bytes(_contractUri).length != 0) _store.recordSetContractUri(_contractUri);\n\n    // Set the token URI resolver if provided.\n+   if (_tokenUriResolver != IJBTokenUriResolver(address(0)))\n      _store.recordSetTokenUriResolver(_tokenUriResolver);\n\n    // Record adding the provided tiers.\n+   if (_pricing.tiers.length > 0) _store.recordAddTiers(_pricing.tiers);\n\n    // Set the flags if needed.\n    if (\n+     _flags.lockReservedTokenChanges ||\n+     _flags.lockVotingUnitChanges ||\n+     _flags.lockManualMintingChanges ||\n+     _flags.pausable\n    ) _store.recordFlags(_flags);\n\n    // Transfer ownership to the initializer.\n    _transferOwnership(msg.sender);\n  }\n```\n\nSo if the attacker initializes the contract as follows:\n\n*   `_baseUri` = \"\"\n*   `_contractUri` = \"\"\n*   `_tokenUriResolver` = `address(0)`\n*   `_pricing.tiers` = \\[]\n*   `_flags` = all `false`\n\nThe contract will be initialized and transfered the ownership to `msg.sender`.\n\nAfter that, the owner can call `didPay` with the the fake data provided in [JBTiered721Delegate.sol:221](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721Delegate.sol#L221) and increase `creditsOf` of anyone [JBTiered721Delegate.sol:587](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721Delegate.sol#L587) without touching any `store` call.\n\n*   The attacker can transfer the ownership to the contract, and the project will be able to initialize the contract again without notice.\n\n### Recommended Mitigation Steps\n\nEnsure that the `store` address is not empty.\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2022-10-juicebox-findings/issues/24#issuecomment-1304542277):**\n > I believe the finding to be valid if:\n> \n> - the attacker initialize the contract with `_store == address(0)` and the parameters as above so it does not revert in the normal process\n> - the attacker calls initialize to transfer the ownership to himself and modify the storage so he can then call `didPay`\n> - the attacker calls `didPay` to manipulate `creditsOf`\n> - finally the attacker calls `initialize` to set `_store` to non zero and at this point it is like if nothing happened although `creditsOf` has been manipulated\n\n**[drgorillamd (Juicebox DAO) commented](https://github.com/code-423n4/2022-10-juicebox-findings/issues/24#issuecomment-1304544699):**\n > Hmm, this would require a spoof directory too (to bypass the isTerminalOf check) -> I'd mitigate with a `check msg.value==data.value` in the abstract delegate contract, ie if someone wants to do this, actually paying the credit is needed\n\n> Def nice finding, ggwp!\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2022-10-juicebox-findings/issues/24#issuecomment-1304552713):**\n > I do agree that Med is more appropriate as it falls within centralization risks as ultimately only the deployer could exploit this.\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-10-juicebox-contest",
  "Code": [
    {
      "filename": "contracts/JBTiered721Delegate.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport '@jbx-protocol/juice-contracts-v3/contracts/libraries/JBFundingCycleMetadataResolver.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport './abstract/JB721Delegate.sol';\nimport './interfaces/IJBTiered721Delegate.sol';\nimport './libraries/JBIpfsDecoder.sol';\nimport './libraries/JBTiered721FundingCycleMetadataResolver.sol';\nimport './structs/JBTiered721Flags.sol';\n\n/**\n  @title\n  JBTiered721Delegate\n\n  @notice\n  Delegate that offers project contributors NFTs with tiered price floors upon payment and the ability to redeem NFTs for treasury assets based based on price floor.\n\n  @dev\n  Adheres to -\n  IJBTiered721Delegate: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.\n\n  @dev\n  Inherits from -\n  JB721Delegate: A generic NFT delegate.\n  Votes: A helper for voting balance snapshots.\n  Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.\n*/\ncontract JBTiered721Delegate is IJBTiered721Delegate, JB721Delegate, Ownable {\n  //*********************************************************************//\n  // --------------------------- custom errors ------------------------- //\n  //*********************************************************************//\n\n  error NOT_AVAILABLE();\n  error OVERSPENDING();\n  error PRICING_RESOLVER_CHANGES_PAUSED();\n  error RESERVED_TOKEN_MINTING_PAUSED();\n  error TRANSFERS_PAUSED();\n\n  //*********************************************************************//\n  // --------------------- public stored properties -------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    The address of the origin 'JBTiered721Delegate', used to check in the init if the contract is the original or not\n  */\n  address public override codeOrigin;\n\n  /**\n    @notice\n    The contract that stores and manages the NFT's data.\n  */\n  IJBTiered721DelegateStore public override store;\n\n  /**\n    @notice\n    The contract storing all funding cycle configurations.\n  */\n  IJBFundingCycleStore public override fundingCycleStore;\n\n  /**\n    @notice\n    The contract that exposes price feeds.\n  */\n  IJBPrices public override prices;\n\n  /** \n    @notice\n    The currency that is accepted when minting tier NFTs. \n  */\n  uint256 public override pricingCurrency;\n\n  /** \n    @notice\n    The currency that is accepted when minting tier NFTs. \n  */\n  uint256 public override pricingDecimals;\n\n  /** \n    @notice\n    The amount that each address has paid that has not yet contribute to the minting of an NFT. \n\n    _address The address to which the credits belong.\n  */\n  mapping(address => uint256) public override creditsOf;\n\n  //*********************************************************************//\n  // ------------------------- external views -------------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    The first owner of each token ID, which corresponds to the address that originally contributed to the project to receive the NFT.\n\n    @param _tokenId The ID of the token to get the first owner of.\n\n    @return The first owner of the token.\n  */\n  function firstOwnerOf(uint256 _tokenId) external view override returns (address) {\n    // Get a reference to the first owner.\n    address _storedFirstOwner = store.firstOwnerOf(address(this), _tokenId);\n\n    // If the stored first owner is set, return it.\n    if (_storedFirstOwner != address(0)) return _storedFirstOwner;\n\n    // Otherwise, the first owner must be the current owner.\n    return _owners[_tokenId];\n  }\n\n  //*********************************************************************//\n  // -------------------------- public views --------------------------- //\n  //*********************************************************************//\n\n  /** \n    @notice \n    The total number of tokens owned by the given owner across all tiers. \n\n    @param _owner The address to check the balance of.\n\n    @return balance The number of tokens owners by the owner accross all tiers.\n  */\n  function balanceOf(address _owner) public view override returns (uint256 balance) {\n    return store.balanceOf(address(this), _owner);\n  }\n\n  /** \n    @notice\n    The metadata URI of the provided token ID.\n\n    @dev\n    Defer to the tokenUriResolver if set, otherwise, use the tokenUri set with the token's tier.\n\n    @param _tokenId The ID of the token to get the tier URI for. \n\n    @return The token URI corresponding with the tier or the tokenUriResolver URI.\n  */\n  function tokenURI(uint256 _tokenId) public view override returns (string memory) {\n    // A token without an owner doesn't have a URI.\n    if (_owners[_tokenId] == address(0)) return '';\n\n    // Get a reference to the URI resolver.\n    IJBTokenUriResolver _resolver = store.tokenUriResolverOf(address(this));\n\n    // If a token URI resolver is provided, use it to resolve the token URI.\n    if (address(_resolver) != address(0)) return _resolver.getUri(_tokenId);\n\n    // Return the token URI for the token's tier.\n    return\n      JBIpfsDecoder.decode(\n        store.baseUriOf(address(this)),\n        store.encodedTierIPFSUriOf(address(this), _tokenId)\n      );\n  }\n\n  /** \n    @notice\n    Returns the URI where contract metadata can be found. \n\n    @return The contract's metadata URI.\n  */\n  function contractURI() external view override returns (string memory) {\n    return store.contractUriOf(address(this));\n  }\n\n  /**\n    @notice\n    Indicates if this contract adheres to the specified interface.\n\n    @dev\n    See {IERC165-supportsInterface}.\n\n    @param _interfaceId The ID of the interface to check for adherance to.\n  */\n  function supportsInterface(bytes4 _interfaceId) public view override returns (bool) {\n    return\n      _interfaceId == type(IJBTiered721Delegate).interfaceId ||\n      super.supportsInterface(_interfaceId);\n  }\n\n  //*********************************************************************//\n  // -------------------------- constructor ---------------------------- //\n  //*********************************************************************//\n\n  constructor() {\n    codeOrigin = address(this);\n  }\n\n  /**\n    @param _projectId The ID of the project this contract's functionality applies to.\n    @param _directory The directory of terminals and controllers for projects.\n    @param _name The name of the token.\n    @param _symbol The symbol that the token should be represented by.\n    @param _fundingCycleStore A contract storing all funding cycle configurations.\n    @param _baseUri A URI to use as a base for full token URIs.\n    @param _tokenUriResolver A contract responsible for resolving the token URI for each token ID.\n    @param _contractUri A URI where contract metadata can be found. \n    @param _pricing The tier pricing according to which token distribution will be made. Must be passed in order of contribution floor, with implied increasing value.\n    @param _store A contract that stores the NFT's data.\n    @param _flags A set of flags that help define how this contract works.\n  */\n  function initialize(\n    uint256 _projectId,\n    IJBDirectory _directory,\n    string memory _name,\n    string memory _symbol,\n    IJBFundingCycleStore _fundingCycleStore,\n    string memory _baseUri,\n    IJBTokenUriResolver _tokenUriResolver,\n    string memory _contractUri,\n    JB721PricingParams memory _pricing,\n    IJBTiered721DelegateStore _store,\n    JBTiered721Flags memory _flags\n  ) public override {\n    // Make the original un-initializable.\n    require(address(this) != codeOrigin);\n    // Stop re-initialization.\n    require(address(store) == address(0));\n\n    // Initialize the sub class.\n    JB721Delegate._initialize(_projectId, _directory, _name, _symbol);\n\n    fundingCycleStore = _fundingCycleStore;\n    store = _store;\n    pricingCurrency = _pricing.currency;\n    pricingDecimals = _pricing.decimals;\n    prices = _pricing.prices;\n\n    // Store the base URI if provided.\n    if (bytes(_baseUri).length != 0) _store.recordSetBaseUri(_baseUri);\n\n    // Set the contract URI if provided.\n    if (bytes(_contractUri).length != 0) _store.recordSetContractUri(_contractUri);\n\n    // Set the token URI resolver if provided.\n    if (_tokenUriResolver != IJBTokenUriResolver(address(0)))\n      _store.recordSetTokenUriResolver(_tokenUriResolver);\n\n    // Record adding the provided tiers.\n    if (_pricing.tiers.length > 0) _store.recordAddTiers(_pricing.tiers);\n\n    // Set the flags if needed.\n    if (\n      _flags.lockReservedTokenChanges ||\n      _flags.lockVotingUnitChanges ||\n      _flags.lockManualMintingChanges ||\n      _flags.pausable\n    ) _store.recordFlags(_flags);\n\n    // Transfer ownership to the initializer.\n    _transferOwnership(msg.sender);\n  }\n\n  //*********************************************************************//\n  // ---------------------- external transactions ---------------------- //\n  //*********************************************************************//\n\n  /** \n    @notice\n    Mint reserved tokens within the tier for the provided value.\n\n    @param _mintReservesForTiersData Contains information about how many reserved tokens to mint for each tier.\n  */\n  function mintReservesFor(JBTiered721MintReservesForTiersData[] memory _mintReservesForTiersData)\n    external\n    override\n  {\n    // Keep a reference to the number of tiers there are to mint reserved for.\n    uint256 _numberOfTiers = _mintReservesForTiersData.length;\n\n    for (uint256 _i; _i < _numberOfTiers; ) {\n      // Get a reference to the data being iterated on.\n      JBTiered721MintReservesForTiersData memory _data = _mintReservesForTiersData[_i];\n\n      // Mint for the tier.\n      mintReservesFor(_data.tierId, _data.count);\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /** \n    @notice\n    Mint tokens within the tier for the provided beneficiaries.\n\n    @param _mintForTiersData Contains information about how who to mint tokens for from each tier.\n  */\n  function mintFor(JBTiered721MintForTiersData[] memory _mintForTiersData)\n    external\n    override\n    onlyOwner\n  {\n    // Keep a reference to the number of beneficiaries there are to mint for.\n    uint256 _numberOfBeneficiaries = _mintForTiersData.length;\n\n    for (uint256 _i; _i < _numberOfBeneficiaries; ) {\n      // Get a reference to the data being iterated on.\n      JBTiered721MintForTiersData memory _data = _mintForTiersData[_i];\n\n      // Mint for the tier.\n      mintFor(_data.tierIds, _data.beneficiary);\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /** \n    @notice\n    Adjust the tiers mintable through this contract, adhering to any locked tier constraints. \n\n    @dev\n    Only the contract's owner can adjust the tiers.\n\n    @param _tiersToAdd An array of tier data to add.\n    @param _tierIdsToRemove An array of tier IDs to remove.\n  */\n  function adjustTiers(JB721TierParams[] calldata _tiersToAdd, uint256[] calldata _tierIdsToRemove)\n    external\n    override\n    onlyOwner\n  {\n    // Get a reference to the number of tiers being added.\n    uint256 _numberOfTiersToAdd = _tiersToAdd.length;\n\n    // Get a reference to the number of tiers being removed.\n    uint256 _numberOfTiersToRemove = _tierIdsToRemove.length;\n\n    // Remove the tiers.\n    if (_numberOfTiersToRemove != 0) {\n      // Record the removed tiers.\n      store.recordRemoveTierIds(_tierIdsToRemove);\n\n      // Emit events for each removed tier.\n      for (uint256 _i; _i < _numberOfTiersToRemove; ) {\n        emit RemoveTier(_tierIdsToRemove[_i], msg.sender);\n        unchecked {\n          ++_i;\n        }\n      }\n    }\n\n    // Add the tiers.\n    if (_numberOfTiersToAdd != 0) {\n      // Record the added tiers in the store.\n      uint256[] memory _tierIdsAdded = store.recordAddTiers(_tiersToAdd);\n\n      // Emit events for each added tier.\n      for (uint256 _i; _i < _numberOfTiersToAdd; ) {\n        emit AddTier(_tierIdsAdded[_i], _tiersToAdd[_i], msg.sender);\n        unchecked {\n          ++_i;\n        }\n      }\n    }\n  }\n\n  /** \n    @notice\n    Sets the beneificiary of the reserved tokens for tiers where a specific beneficiary isn't set. \n\n    @dev\n    Only the contract's owner can set the default reserved token beneficiary.\n\n    @param _beneficiary The default beneificiary of the reserved tokens.\n  */\n  function setDefaultReservedTokenBeneficiary(address _beneficiary) external override onlyOwner {\n    // Set the beneficiary.\n    store.recordSetDefaultReservedTokenBeneficiary(_beneficiary);\n\n    emit SetDefaultReservedTokenBeneficiary(_beneficiary, msg.sender);\n  }\n\n  /**\n    @notice\n    Set a base token URI.\n\n    @dev\n    Only the contract's owner can set the base URI.\n\n    @param _baseUri The new base URI.\n  */\n  function setBaseUri(string memory _baseUri) external override onlyOwner {\n    // Store the new value.\n    store.recordSetBaseUri(_baseUri);\n\n    emit SetBaseUri(_baseUri, msg.sender);\n  }\n\n  /**\n    @notice\n    Set a contract metadata URI to contain opensea-style metadata.\n\n    @dev\n    Only the contract's owner can set the contract URI.\n\n    @param _contractUri The new contract URI.\n  */\n  function setContractUri(string calldata _contractUri) external override onlyOwner {\n    // Store the new value.\n    store.recordSetContractUri(_contractUri);\n\n    emit SetContractUri(_contractUri, msg.sender);\n  }\n\n  /**\n    @notice\n    Set a token URI resolver.\n\n    @dev\n    Only the contract's owner can set the token URI resolver.\n\n    @param _tokenUriResolver The new URI resolver.\n  */\n  function setTokenUriResolver(IJBTokenUriResolver _tokenUriResolver) external override onlyOwner {\n    // Store the new value.\n    store.recordSetTokenUriResolver(_tokenUriResolver);\n\n    emit SetTokenUriResolver(_tokenUriResolver, msg.sender);\n  }\n\n  //*********************************************************************//\n  // ----------------------- public transactions ----------------------- //\n  //*********************************************************************//\n\n  /** \n    @notice\n    Mint reserved tokens within the tier for the provided value.\n\n    @param _tierId The ID of the tier to mint within.\n    @param _count The number of reserved tokens to mint. \n  */\n  function mintReservesFor(uint256 _tierId, uint256 _count) public override {\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(projectId);\n\n    // Minting reserves must not be paused.\n    if (\n      JBTiered721FundingCycleMetadataResolver.mintingReservesPaused(\n        (JBFundingCycleMetadataResolver.metadata(_fundingCycle))\n      )\n    ) revert RESERVED_TOKEN_MINTING_PAUSED();\n\n    // Record the minted reserves for the tier.\n    uint256[] memory _tokenIds = store.recordMintReservesFor(_tierId, _count);\n\n    // Keep a reference to the reserved token beneficiary.\n    address _reservedTokenBeneficiary = store.reservedTokenBeneficiaryOf(address(this), _tierId);\n\n    // Keep a reference to the token ID being iterated on.\n    uint256 _tokenId;\n\n    for (uint256 _i; _i < _count; ) {\n      // Set the token ID.\n      _tokenId = _tokenIds[_i];\n\n      // Mint the token.\n      _mint(_reservedTokenBeneficiary, _tokenId);\n\n      emit MintReservedToken(_tokenId, _tierId, _reservedTokenBeneficiary, msg.sender);\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /** \n    @notice\n    Manually mint NFTs from tiers.\n\n    @param _tierIds The IDs of the tiers to mint from.\n    @param _beneficiary The address to mint to. \n\n    @return tokenIds The IDs of the newly minted tokens.\n  */\n  function mintFor(uint16[] memory _tierIds, address _beneficiary)\n    public\n    override\n    onlyOwner\n    returns (uint256[] memory tokenIds)\n  {\n    // Record the mint. The returned token IDs correspond to the tiers passed in.\n    (tokenIds, ) = store.recordMint(\n      type(uint256).max, // force the mint.\n      _tierIds,\n      true // manual mint\n    );\n\n    // Keep a reference to the number of tokens being minted.\n    uint256 _numberOfTokens = _tierIds.length;\n\n    // Keep a reference to the token ID being iterated on.\n    uint256 _tokenId;\n\n    for (uint256 _i; _i < _numberOfTokens; ) {\n      // Set the token ID.\n      _tokenId = tokenIds[_i];\n\n      // Mint the token.\n      _mint(_beneficiary, _tokenId);\n\n      emit Mint(_tokenId, _tierIds[_i], _beneficiary, 0, msg.sender);\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  //*********************************************************************//\n  // ------------------------ internal functions ----------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    Mints for a given contribution to the beneficiary.\n\n    @param _data The Juicebox standard project contribution data.\n  */\n  function _processPayment(JBDidPayData calldata _data) internal override {\n    // Normalize the currency.\n    uint256 _value;\n    if (_data.amount.currency == pricingCurrency) _value = _data.amount.value;\n    else if (prices != IJBPrices(address(0)))\n      _value = PRBMath.mulDiv(\n        _data.amount.value,\n        10**pricingDecimals,\n        prices.priceFor(_data.amount.currency, pricingCurrency, _data.amount.decimals)\n      );\n    else return;\n\n    // Keep a reference to the amount of credits the beneficiary already has.\n    uint256 _credits = creditsOf[_data.beneficiary];\n\n    // Set the leftover amount as the initial value, including any credits the beneficiary might already have.\n    uint256 _leftoverAmount = _value + _credits;\n\n    // Keep a reference to a flag indicating if a mint is expected from discretionary funds. Defaults to false, meaning to mint is not expected.\n    bool _expectMintFromExtraFunds;\n\n    // Keep a reference to the flag indicating if the transaction should revert if all provded funds aren't spent. Defaults to false, meaning only a minimum payment is enforced.\n    bool _dontOverspend;\n\n    // Skip the first 32 bytes which are used by the JB protocol to pass the paying project's ID when paying from a JBSplit.\n    // Check the 4 bytes interfaceId to verify the metadata is intended for this contract.\n    if (\n      _data.metadata.length > 36 &&\n      bytes4(_data.metadata[32:36]) == type(IJB721Delegate).interfaceId\n    ) {\n      // Keep a reference to the flag indicating if the transaction should not mint anything.\n      bool _dontMint;\n\n      // Keep a reference to the the specific tier IDs to mint.\n      uint16[] memory _tierIdsToMint;\n\n      // Decode the metadata.\n      (, , _dontMint, _expectMintFromExtraFunds, _dontOverspend, _tierIdsToMint) = abi.decode(\n        _data.metadata,\n        (bytes32, bytes4, bool, bool, bool, uint16[])\n      );\n\n      // Don't mint if not desired.\n      if (_dontMint) return;\n\n      // Mint rewards if they were specified.\n      if (_tierIdsToMint.length != 0)\n        _leftoverAmount = _mintAll(_leftoverAmount, _tierIdsToMint, _data.beneficiary);\n    }\n\n    // If there are funds leftover, mint the best available with it.\n    if (_leftoverAmount != 0) {\n      _leftoverAmount = _mintBestAvailableTier(\n        _leftoverAmount,\n        _data.beneficiary,\n        _expectMintFromExtraFunds\n      );\n\n      if (_leftoverAmount != 0) {\n        // Make sure there are no leftover funds after minting if not expected.\n        if (_dontOverspend) revert OVERSPENDING();\n\n        // Increment the leftover amount.\n        creditsOf[_data.beneficiary] = _leftoverAmount;\n      } else if (_credits != 0) creditsOf[_data.beneficiary] = 0;\n    } else if (_credits != 0) creditsOf[_data.beneficiary] = 0;\n  }\n\n  /** \n    @notice\n    A function that will run when a tokens are burned via redemption.\n\n    @param _tokenIds The IDs of the tokens that were burned.\n  */\n  function _didBurn(uint256[] memory _tokenIds) internal override {\n    // Add to burned counter.\n    store.recordBurn(_tokenIds);\n  }\n\n  /** \n    @notice\n    Mints a token in the best available tier.\n\n    @param _amount The amount to base the mint on.\n    @param _beneficiary The address to mint for.\n    @param _expectMint A flag indicating if a mint was expected.\n\n    @return  leftoverAmount The amount leftover after the mint.\n  */\n  function _mintBestAvailableTier(\n    uint256 _amount,\n    address _beneficiary,\n    bool _expectMint\n  ) internal returns (uint256 leftoverAmount) {\n    // Keep a reference to the token ID.\n    uint256 _tokenId;\n\n    // Keep a reference to the tier ID.\n    uint256 _tierId;\n\n    // Record the mint.\n    (_tokenId, _tierId, leftoverAmount) = store.recordMintBestAvailableTier(_amount);\n\n    // If there's no best tier, return or revert.\n    if (_tokenId == 0) {\n      // Make sure a mint was not expected.\n      if (_expectMint) revert NOT_AVAILABLE();\n      return leftoverAmount;\n    }\n\n    // Mint the tokens.\n    _mint(_beneficiary, _tokenId);\n\n    emit Mint(_tokenId, _tierId, _beneficiary, _amount - leftoverAmount, msg.sender);\n  }\n\n  /** \n    @notice\n    Mints a token in all provided tiers.\n\n    @param _amount The amount to base the mints on. All mints' price floors must fit in this amount.\n    @param _mintTierIds An array of tier IDs that are intended to be minted.\n    @param _beneficiary The address to mint for.\n\n    @return leftoverAmount The amount leftover after the mint.\n  */\n  function _mintAll(\n    uint256 _amount,\n    uint16[] memory _mintTierIds,\n    address _beneficiary\n  ) internal returns (uint256 leftoverAmount) {\n    // Keep a reference to the token ID.\n    uint256[] memory _tokenIds;\n\n    // Record the mint. The returned token IDs correspond to the tiers passed in.\n    (_tokenIds, leftoverAmount) = store.recordMint(\n      _amount,\n      _mintTierIds,\n      false // Not a manual mint\n    );\n\n    // Get a reference to the number of mints.\n    uint256 _mintsLength = _tokenIds.length;\n\n    // Keep a reference to the token ID being iterated on.\n    uint256 _tokenId;\n\n    // Loop through each token ID and mint.\n    for (uint256 _i; _i < _mintsLength; ) {\n      // Get a reference to the tier being iterated on.\n      _tokenId = _tokenIds[_i];\n\n      // Mint the tokens.\n      _mint(_beneficiary, _tokenId);\n\n      emit Mint(_tokenId, _mintTierIds[_i], _beneficiary, _amount, msg.sender);\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /** \n    @notice\n    The cumulative weight the given token IDs have in redemptions compared to the `_totalRedemptionWeight`. \n\n    @param _tokenIds The IDs of the tokens to get the cumulative redemption weight of.\n\n    @return The weight.\n  */\n  function _redemptionWeightOf(uint256[] memory _tokenIds)\n    internal\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return store.redemptionWeightOf(address(this), _tokenIds);\n  }\n\n  /** \n    @notice\n    The cumulative weight that all token IDs have in redemptions. \n\n    @return The total weight.\n  */\n  function _totalRedemptionWeight() internal view virtual override returns (uint256) {\n    return store.totalRedemptionWeight(address(this));\n  }\n\n  /**\n    @notice\n    User the hook to register the first owner if it's not yet regitered.\n\n    @param _from The address where the transfer is originating.\n    @param _to The address to which the transfer is being made.\n    @param _tokenId The ID of the token being transfered.\n  */\n  function _beforeTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  ) internal virtual override {\n    // Transfered must not be paused when not minting or burning.\n    if (_from != address(0)) {\n      // Transfers must not be paused.\n      if (store.flagsOf(address(this)).pausable) {\n        // Get a reference to the project's current funding cycle.\n        JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(projectId);\n\n        if (\n          _to != address(0) &&\n          JBTiered721FundingCycleMetadataResolver.transfersPaused(\n            (JBFundingCycleMetadataResolver.metadata(_fundingCycle))\n          )\n        ) revert TRANSFERS_PAUSED();\n      }\n\n      // If there's no stored first owner, and the transfer isn't originating from the zero address as expected for mints, store the first owner.\n      if (store.firstOwnerOf(address(this), _tokenId) == address(0))\n        store.recordSetFirstOwnerOf(_tokenId, _from);\n    }\n\n    super._beforeTokenTransfer(_from, _to, _tokenId);\n  }\n\n  /**\n    @notice\n    Transfer voting units after the transfer of a token.\n\n    @param _from The address where the transfer is originating.\n    @param _to The address to which the transfer is being made.\n    @param _tokenId The ID of the token being transfered.\n   */\n  function _afterTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  ) internal virtual override {\n    // Get a reference to the tier.\n    JB721Tier memory _tier = store.tierOfTokenId(address(this), _tokenId);\n\n    // Record the transfer.\n    store.recordTransferForTier(_tier.id, _from, _to);\n\n    // Handle any other accounting (ex. account for governance voting units)\n    _afterTokenTransferAccounting(_from, _to, _tokenId, _tier);\n\n    super._afterTokenTransfer(_from, _to, _tokenId);\n  }\n\n  /**\n    @notice \n    Custom hook to handle token/tier accounting, this way we can reuse the '_tier' instead of fetching it again.\n\n    @param _from The account to transfer voting units from.\n    @param _to The account to transfer voting units to.\n    @param _tokenId The ID of the token for which voting units are being transfered.\n    @param _tier The tier the token ID is part of.\n  */\n  function _afterTokenTransferAccounting(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    JB721Tier memory _tier\n  ) internal virtual {\n    _from; // Prevents unused var compiler and natspec complaints.\n    _to;\n    _tokenId;\n    _tier;\n  }\n}"
    }
  ]
}