{
  "Title": "[G-07] Multiple address mappings can be combined into a single mapping of an address to a struct, where appropriate",
  "Content": "We can combine multiple mappings below into structs. We can then pack the structs by modifying the `uint type` for the values. This will result in cheaper storage reads since multiple mappings are accessed in functions and those values are now occupying the same storage slot, meaning the slot will become warm after the first SLOAD. In addition, when writing to and reading from the struct values we will avoid a `Gsset (20000 gas)` and `Gcoldsload (2100 gas)` since multiple struct values are now occupying the same slot.\n\n**Note: These are instances missed by the automated report**\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/StandardFunding.sol#L106-L112\n\n*Gas Savings for `GrantFund.claimDelegateReward`, obtained via protocol's tests: Avg 22146 gas*\n\n|        |    Max   |\n| ------ | -------- |\n| Before |   65340  |  \n| After  |   43194  | \n\n```solidity\nFile: ajna-grants/src/grants/base/StandardFunding.sol\n106:    mapping(uint256 => mapping(address => bool)) public hasClaimedReward;\n107:\n108:    /**\n109:     * @notice Mapping of distributionId to user address to total votes cast on screening stage proposals.\n110:     * @dev distributionId => address => uint256\n111:    */\n112:    mapping(uint256 => mapping(address => uint256)) public screeningVotesCast;\n```\n```diff\ndiff --git a/src/grants/base/StandardFunding.sol b/src/grants/base/StandardFunding.sol\nindex 928b337..9985766 100644\n--- a/src/grants/base/StandardFunding.sol\n+++ b/src/grants/base/StandardFunding.sol\n@@ -99,17 +99,12 @@ abstract contract StandardFunding is Funding, IStandardFunding {\n     */\n     mapping(uint256 => bool) internal _isSurplusFundsUpdated;\n\n-    /**\n-     * @notice Mapping of distributionId to user address to whether user has claimed his delegate reward\n-     * @dev distributionId => address => bool\n-    */\n-    mapping(uint256 => mapping(address => bool)) public hasClaimedReward;\n+    struct UserInfo {\n+        uint248 screeningVotesCast;\n+        bool hasClaimedReward;\n+    }\n\n-    /**\n-     * @notice Mapping of distributionId to user address to total votes cast on screening stage proposals.\n-     * @dev distributionId => address => uint256\n-    */\n-    mapping(uint256 => mapping(address => uint256)) public screeningVotesCast;\n+    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n\n     /**************************************************/\n     /*** Distribution Management Functions External ***/\n@@ -237,7 +232,8 @@ abstract contract StandardFunding is Funding, IStandardFunding {\n         uint24 distributionId_\n     ) external override returns(uint256 rewardClaimed_) {\n         // Revert if delegatee didn't vote in screening stage\n-        if(screeningVotesCast[distributionId_][msg.sender] == 0) revert DelegateRewardInvalid();\n+        UserInfo storage _userInfo = userInfo[distributionId_][msg.sender];\n+        if(_userInfo.screeningVotesCast == 0) revert DelegateRewardInvalid();\n\n         QuarterlyDistribution memory currentDistribution = _distributions[distributionId_];\n\n@@ -245,14 +241,14 @@ abstract contract StandardFunding is Funding, IStandardFunding {\n         if(block.number < _getChallengeStageEndBlock(currentDistribution.endBlock)) revert ChallengePeriodNotEnded();\n\n         // check rewards haven't already been claimed\n-        if(hasClaimedReward[distributionId_][msg.sender]) revert RewardAlreadyClaimed();\n+        if(_userInfo.hasClaimedReward) revert RewardAlreadyClaimed();\n\n         QuadraticVoter memory voter = _quadraticVoters[distributionId_][msg.sender];\n\n         // calculate rewards earned for voting\n         rewardClaimed_ = _getDelegateReward(currentDistribution, voter);\n\n-        hasClaimedReward[distributionId_][msg.sender] = true;\n+        _userInfo.hasClaimedReward = true;\n\n         emit DelegateRewardClaimed(\n             msg.sender,\n@@ -703,7 +699,8 @@ abstract contract StandardFunding is Funding, IStandardFunding {\n         uint24 distributionId = proposal_.distributionId;\n\n         // check that the voter has enough voting power to cast the vote\n-        if (screeningVotesCast[distributionId][account_] + votes_ > _getVotesScreening(distributionId, account_)) revert InsufficientVotingPower();\n+        UserInfo storage _userInfo = userInfo[distributionId][account_];\n+        if (_userInfo.screeningVotesCast + votes_ > _getVotesScreening(distributionId, account_)) revert InsufficientVotingPower();\n\n         uint256[] storage currentTopTenProposals = _topTenProposals[distributionId];\n         uint256 proposalId = proposal_.proposalId;\n@@ -740,7 +737,7 @@ abstract contract StandardFunding is Funding, IStandardFunding {\n         }\n\n         // record voters vote\n-        screeningVotesCast[proposal_.distributionId][account_] += votes_;\n+        _userInfo.screeningVotesCast += uint248(votes_);\n\n         // emit VoteCast instead of VoteCastWithParams to maintain compatibility with Tally\n         emit VoteCast(\n```\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-core/src/PositionManager.sol#L52-L57\n\n**Please note that in the [automated report](https://gist.github.com/CloudEllie/a4655b833548ed9a86a63eb7292bcc0f#g01-multiple-addressid-mappings-can-be-combined-into-a-single-mapping-of-an-addressid-to-a-struct-where-appropriate) the `poolKey` mapping was not included in the findings**.\n\n*Gas Savings for `PositionManager.permit`, obtained via protocol's tests: Avg 21833 gas*\n\n|        |    Max   |\n| ------ | -------- |\n| Before |   54387  |  \n| After  |   32554  | \n\n*Gas Savings for `PositionManager.burn`, obtained via protocol's tests: Avg 1927 gas*\n\n|        |    Max   |\n| ------ | -------- |\n| Before |   10451  |  \n| After  |   8524   | \n\n```solidity\nFile: ajna-core/src/PositionManager.sol\n52:    mapping(uint256 => address) public override poolKey;\n53:\n54:    /// @dev Mapping of `token id => ajna pool address` for which token was minted.\n55:    mapping(uint256 => mapping(uint256 => Position)) internal positions;\n56:    /// @dev Mapping of `token id => nonce` value used for permit.\n57:    mapping(uint256 => uint96)                       internal nonces;\n```\n```diff\ndiff --git a/src/PositionManager.sol b/src/PositionManager.sol\nindex 261fbc1..ca903f4 100644\n--- a/src/PositionManager.sol\n+++ b/src/PositionManager.sol\n@@ -48,13 +48,15 @@ contract PositionManager is ERC721, PermitERC721, IPositionManager, Multicall, R\n     /*** State Variables ***/\n     /***********************/\n\n-    /// @dev Mapping of `token id => ajna pool address` for which token was minted.\n-    mapping(uint256 => address) public override poolKey;\n+    struct TokenInfo {\n+        address poolKey;\n+        uint96 nonces;\n+    }\n+\n+    mapping(uint256 => TokenInfo) tokenInfo;\n\n     /// @dev Mapping of `token id => ajna pool address` for which token was minted.\n     mapping(uint256 => mapping(uint256 => Position)) internal positions;\n-    /// @dev Mapping of `token id => nonce` value used for permit.\n-    mapping(uint256 => uint96)                       internal nonces;\n     /// @dev Mapping of `token id => bucket indexes` associated with position.\n     mapping(uint256 => EnumerableSet.UintSet)        internal positionIndexes;\n\n@@ -104,7 +106,7 @@ contract PositionManager is ERC721, PermitERC721, IPositionManager, Multicall, R\n         if (!_isApprovedOrOwner(msg.sender, tokenId_)) revert NoAuth();\n\n         // revert if the token id is not minted for given pool address\n-        if (pool_ != poolKey[tokenId_]) revert WrongPool();\n+        if (pool_ != tokenInfo[tokenId_].poolKey) revert WrongPool();\n\n         _;\n     }\n@@ -121,6 +123,10 @@ contract PositionManager is ERC721, PermitERC721, IPositionManager, Multicall, R\n         erc721PoolFactory = erc721Factory_;\n     }\n\n+    function poolKey(uint256 tokenId_) external view returns (address) {\n+        return tokenInfo[tokenId_].poolKey;\n+    }\n+\n     /********************************/\n     /*** Owner External Functions ***/\n     /********************************/\n@@ -146,8 +152,7 @@ contract PositionManager is ERC721, PermitERC721, IPositionManager, Multicall, R\n         if (positionIndexes[params_.tokenId].length() != 0) revert LiquidityNotRemoved();\n\n         // remove permit nonces and pool mapping for burned token\n-        delete nonces[params_.tokenId];\n-        delete poolKey[params_.tokenId];\n+        delete tokenInfo[params_.tokenId];\n\n         _burn(params_.tokenId);\n\n@@ -172,7 +177,7 @@ contract PositionManager is ERC721, PermitERC721, IPositionManager, Multicall, R\n     ) external override {\n         EnumerableSet.UintSet storage positionIndex = positionIndexes[params_.tokenId];\n\n-        IPool   pool  = IPool(poolKey[params_.tokenId]);\n+        IPool   pool  = IPool(tokenInfo[params_.tokenId].poolKey);\n         address owner = ownerOf(params_.tokenId);\n\n         uint256 indexesLength = params_.indexes.length;\n@@ -233,7 +238,7 @@ contract PositionManager is ERC721, PermitERC721, IPositionManager, Multicall, R\n         if (!_isAjnaPool(params_.pool, params_.poolSubsetHash)) revert NotAjnaPool();\n\n         // record which pool the tokenId was minted in\n-        poolKey[tokenId_] = params_.pool;\n+        tokenInfo[tokenId_].poolKey = params_.pool;\n\n         _mint(params_.recipient, tokenId_);\n\n@@ -404,7 +409,7 @@ contract PositionManager is ERC721, PermitERC721, IPositionManager, Multicall, R\n     function _getAndIncrementNonce(\n         uint256 tokenId_\n     ) internal override returns (uint256) {\n-        return uint256(nonces[tokenId_]++);\n+        return uint256(tokenInfo[tokenId_].nonces++);\n     }\n\n     /**\n@@ -452,7 +457,7 @@ contract PositionManager is ERC721, PermitERC721, IPositionManager, Multicall, R\n         uint256 index_\n     ) external override view returns (uint256) {\n         Position memory position = positions[tokenId_][index_];\n-        return _bucketBankruptAfterDeposit(IPool(poolKey[tokenId_]), index_, position.depositTime) ? 0 : position.lps;\n+        return _bucketBankruptAfterDeposit(IPool(tokenInfo[tokenId_].poolKey), index_, position.depositTime) ? 0 : position.lps;\n     }\n\n     /// @inheritdoc IPositionManagerDerivedState\n@@ -472,7 +477,7 @@ contract PositionManager is ERC721, PermitERC721, IPositionManager, Multicall, R\n         // filter out bankrupt buckets\n         filteredIndexes_ = new uint256[](indexesLength);\n         uint256 filteredIndexesLength = 0;\n-        IPool pool = IPool(poolKey[tokenId_]);\n+        IPool pool = IPool(tokenInfo[tokenId_].poolKey);\n         for (uint256 i = 0; i < indexesLength; ) {\n             if (!_bucketBankruptAfterDeposit(pool, indexes[i], positions[tokenId_][indexes[i]].depositTime)) {\n                 filteredIndexes_[filteredIndexesLength++] = indexes[i];\n@@ -500,7 +505,7 @@ contract PositionManager is ERC721, PermitERC721, IPositionManager, Multicall, R\n         uint256 tokenId_,\n         uint256 index_\n     ) external view override returns (bool) {\n-        return _bucketBankruptAfterDeposit(IPool(poolKey[tokenId_]), index_, positions[tokenId_][index_].depositTime);\n+        return _bucketBankruptAfterDeposit(IPool(tokenInfo[tokenId_].poolKey), index_, positions[tokenId_][index_].depositTime);\n     }\n\n     /// @inheritdoc IPositionManagerDerivedState\n@@ -519,14 +524,14 @@ contract PositionManager is ERC721, PermitERC721, IPositionManager, Multicall, R\n     ) public view override(ERC721) returns (string memory) {\n         require(_exists(tokenId_));\n\n-        address collateralTokenAddress = IPool(poolKey[tokenId_]).collateralAddress();\n-        address quoteTokenAddress      = IPool(poolKey[tokenId_]).quoteTokenAddress();\n+        address collateralTokenAddress = IPool(tokenInfo[tokenId_].poolKey).collateralAddress();\n+        address quoteTokenAddress      = IPool(tokenInfo[tokenId_].poolKey).quoteTokenAddress();\n\n         PositionNFTSVG.ConstructTokenURIParams memory params = PositionNFTSVG.ConstructTokenURIParams({\n             collateralTokenSymbol: tokenSymbol(collateralTokenAddress),\n             quoteTokenSymbol:      tokenSymbol(quoteTokenAddress),\n             tokenId:               tokenId_,\n-            pool:                  poolKey[tokenId_],\n+            pool:                  tokenInfo[tokenId_].poolKey,\n             owner:                 ownerOf(tokenId_),\n             indexes:               positionIndexes[tokenId_].values()\n         });\n```\n\nThe instance below requires modifications to `IRewardsManagerState.sol` (out of scope) and the tests, and therefore is not included in the final diffs. I will explain this optimization for completeness: The `isEpochClaimed` nested mapping and the `rewardsClaimed` mapping are both accessed when the `claimRewards` function is called (this function invokes other internal functions that write to and read from these mappings). The same `tokenId_` that is used in the `isEpochClaimed` nested mapping is available each time `rewardsClaimed` is read from or written to. Since rewards are claimed for specific tokens, it stands to reason that both these mappings can be combined into a single nested mapping that points to a struct. We can then pack `rewardsClaimed` and `isEpochClaimed` into a single slot by changing the uint of `rewardsClaimed` to `uint248`. Doing so will allow us to avoid a `Gsset (20_000 gas)` when both values are written to and one `Gcoldsload (2100 gas)` when both values are read.\n\n**The diff included below is only to showcase the necessary changes needed for `RewardsManager.sol`. Those changes will not work unless `IRewardsManagerState.sol` and the tests are changed as well**.\n\n**Please note that in the [automated report](https://gist.github.com/CloudEllie/a4655b833548ed9a86a63eb7292bcc0f#g01-multiple-addressid-mappings-can-be-combined-into-a-single-mapping-of-an-addressid-to-a-struct-where-appropriate) the `isEpochClaimed` mapping was not included in the findings**.\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-core/src/RewardsManager.sol#L70-L72\n\nEstimated Gas Savings: `~22100` (`Gsset (20_000 gas)` + `Gcoldsload (2100 gas)`)\n\n```solidity\nFile: ajna-core/src/RewardsManager.sol\n70:    mapping(uint256 => mapping(uint256 => bool)) public override isEpochClaimed;\n71:    /// @dev `epoch => rewards claimed` mapping.\n72:    mapping(uint256 => uint256) public override rewardsClaimed;\n```\n```diff\ndiff --git a/src/RewardsManager.sol b/src/RewardsManager.sol\nindex 314b476..e7b2252 100644\n--- a/src/RewardsManager.sol\n+++ b/src/RewardsManager.sol\n@@ -66,10 +66,13 @@ contract RewardsManager is IRewardsManager, ReentrancyGuard {\n     /*** State Variables ***/\n     /***********************/\n\n-    /// @dev `tokenID => epoch => bool has claimed` mapping.\n-    mapping(uint256 => mapping(uint256 => bool)) public override isEpochClaimed;\n-    /// @dev `epoch => rewards claimed` mapping.\n-    mapping(uint256 => uint256) public override rewardsClaimed;\n+    struct EpochInfo {\n+        uint248 rewardsClaimed;\n+        bool isEpochClaimed;\n+    }\n+\n+    mapping(uint256 => mapping(uint256 => EpochInfo)) epochInfo;\n+\n     /// @dev `epoch => update bucket rate rewards claimed` mapping.\n     mapping(uint256 => uint256) public override updateRewardsClaimed;\n\n@@ -99,6 +102,16 @@ contract RewardsManager is IRewardsManager, ReentrancyGuard {\n         positionManager = positionManager_;\n     }\n\n+    function isEpochClaimed(uint256 tokenId_, uint256 epoch_) external view returns (bool) {\n+        return epochInfo[tokenId_][epoch_].isEpochClaimed;\n+    }\n+\n+    function rewardsClaimed(uint256 tokenId_, uint256 epoch_) external view returns (uint256) {\n+        // need to modify out of scope interface file and tests for this to work.\n+        return uint256(epochInfo[tokenId_][epoch_].rewardsClaimed);\n+    }\n+\n+\n     /**************************/\n     /*** External Functions ***/\n     /**************************/\n@@ -119,7 +132,7 @@ contract RewardsManager is IRewardsManager, ReentrancyGuard {\n\n         if (msg.sender != stakeInfo.owner) revert NotOwnerOfDeposit();\n\n-        if (isEpochClaimed[tokenId_][epochToClaim_]) revert AlreadyClaimed();\n+        if (epochInfo[tokenId_][epochToClaim_].isEpochClaimed) revert AlreadyClaimed();\n\n         _claimRewards(stakeInfo, tokenId_, epochToClaim_, true, stakeInfo.ajnaPool);\n     }\n@@ -408,8 +421,8 @@ contract RewardsManager is IRewardsManager, ReentrancyGuard {\n             unchecked { ++epoch; }\n\n             // update epoch token claim trackers\n-            rewardsClaimed[epoch]           += nextEpochRewards;\n-            isEpochClaimed[tokenId_][epoch] = true;\n+            epochInfo[tokenId_][epoch].rewardsClaimed += uint248(nextEpochRewards);\n+            epochInfo[tokenId_][epoch].isEpochClaimed = true;\n         }\n     }\n\n@@ -432,7 +445,7 @@ contract RewardsManager is IRewardsManager, ReentrancyGuard {\n     ) internal view returns (uint256 epochRewards_) {\n\n         uint256 nextEpoch = epoch_ + 1;\n-        uint256 claimedRewardsInNextEpoch = rewardsClaimed[nextEpoch];\n+        uint256 claimedRewardsInNextEpoch = uint256(epochInfo[tokenId_][nextEpoch].rewardsClaimed);\n         uint256 bucketIndex;\n         uint256 interestEarned;\n\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-05-ajna",
  "Code": [
    {
      "filename": "ajna-grants/src/grants/base/StandardFunding.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport { IERC20 }    from \"@oz/token/ERC20/IERC20.sol\";\nimport { SafeCast }  from \"@oz/utils/math/SafeCast.sol\";\nimport { SafeERC20 } from \"@oz/token/ERC20/utils/SafeERC20.sol\";\n\nimport { Funding } from \"./Funding.sol\";\n\nimport { IStandardFunding } from \"../interfaces/IStandardFunding.sol\";\n\nimport { Maths } from \"../libraries/Maths.sol\";\n\nabstract contract StandardFunding is Funding, IStandardFunding {\n\n    using SafeERC20 for IERC20;\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    /**\n     * @notice Maximum percentage of tokens that can be distributed by the treasury in a quarter.\n     * @dev Stored as a Wad percentage.\n     */\n    uint256 internal constant GLOBAL_BUDGET_CONSTRAINT = 0.03 * 1e18;\n\n    /**\n     * @notice Length of the challengephase of the distribution period in blocks.\n     * @dev    Roughly equivalent to the number of blocks in 7 days.\n     * @dev    The period in which funded proposal slates can be checked in updateSlate.\n     */\n    uint256 internal constant CHALLENGE_PERIOD_LENGTH = 50400;\n\n    /**\n     * @notice Length of the distribution period in blocks.\n     * @dev    Roughly equivalent to the number of blocks in 90 days.\n     */\n    uint48 internal constant DISTRIBUTION_PERIOD_LENGTH = 648000;\n\n    /**\n     * @notice Length of the funding phase of the distribution period in blocks.\n     * @dev    Roughly equivalent to the number of blocks in 10 days.\n     */\n    uint256 internal constant FUNDING_PERIOD_LENGTH = 72000;\n\n    /**\n     * @notice Keccak hash of a prefix string for standard funding mechanism\n     */\n    bytes32 internal constant DESCRIPTION_PREFIX_HASH_STANDARD = keccak256(bytes(\"Standard Funding: \"));\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    /**\n     * @notice ID of the current distribution period.\n     * @dev Used to access information on the status of an ongoing distribution.\n     * @dev Updated at the start of each quarter.\n     * @dev Monotonically increases by one per period.\n     */\n    uint24 internal _currentDistributionId = 0;\n\n    /**\n     * @notice Mapping of quarterly distributions from the grant fund.\n     * @dev distributionId => QuarterlyDistribution\n     */\n    mapping(uint24 => QuarterlyDistribution) internal _distributions;\n\n    /**\n     * @dev Mapping of all proposals that have ever been submitted to the grant fund for screening.\n     * @dev proposalId => Proposal\n     */\n    mapping(uint256 => Proposal) internal _standardFundingProposals;\n\n    /**\n     * @dev Mapping of distributionId to a sorted array of 10 proposalIds with the most votes in the screening period.\n     * @dev distribution.id => proposalId[]\n     * @dev A new array is created for each distribution period\n     */\n    mapping(uint256 => uint256[]) internal _topTenProposals;\n\n    /**\n     * @notice Mapping of a hash of a proposal slate to a list of funded proposals.\n     * @dev slate hash => proposalId[]\n     */\n    mapping(bytes32 => uint256[]) internal _fundedProposalSlates;\n\n    /**\n     * @notice Mapping of quarterly distributions to voters to a Quadratic Voter info struct.\n     * @dev distributionId => voter address => QuadraticVoter \n     */\n    mapping(uint256 => mapping(address => QuadraticVoter)) internal _quadraticVoters;\n\n    /**\n     * @notice Mapping of distributionId to whether surplus funds from distribution updated into treasury\n     * @dev distributionId => bool\n    */\n    mapping(uint256 => bool) internal _isSurplusFundsUpdated;\n\n    /**\n     * @notice Mapping of distributionId to user address to whether user has claimed his delegate reward\n     * @dev distributionId => address => bool\n    */\n    mapping(uint256 => mapping(address => bool)) public hasClaimedReward;\n\n    /**\n     * @notice Mapping of distributionId to user address to total votes cast on screening stage proposals.\n     * @dev distributionId => address => uint256\n    */\n    mapping(uint256 => mapping(address => uint256)) public screeningVotesCast;\n\n    /**************************************************/\n    /*** Distribution Management Functions External ***/\n    /**************************************************/\n\n    /// @inheritdoc IStandardFunding\n    function startNewDistributionPeriod() external override returns (uint24 newDistributionId_) {\n        uint24  currentDistributionId       = _currentDistributionId;\n        uint256 currentDistributionEndBlock = _distributions[currentDistributionId].endBlock;\n\n        // check that there isn't currently an active distribution period\n        if (block.number <= currentDistributionEndBlock) revert DistributionPeriodStillActive();\n\n        // update Treasury with unused funds from last two distributions\n        {\n            // Check if any last distribution exists and its challenge stage is over\n            if (currentDistributionId > 0 && (block.number > _getChallengeStageEndBlock(currentDistributionEndBlock))) {\n                // Add unused funds from last distribution to treasury\n                _updateTreasury(currentDistributionId);\n            }\n\n            // checks if any second last distribution exist and its unused funds are not added into treasury\n            if (currentDistributionId > 1 && !_isSurplusFundsUpdated[currentDistributionId - 1]) {\n                // Add unused funds from second last distribution to treasury\n                _updateTreasury(currentDistributionId - 1);\n            }\n        }\n\n        // set the distribution period to start at the current block\n        uint48 startBlock = SafeCast.toUint48(block.number);\n        uint48 endBlock = startBlock + DISTRIBUTION_PERIOD_LENGTH;\n\n        // set new value for currentDistributionId\n        newDistributionId_ = _setNewDistributionId();\n\n        // create QuarterlyDistribution struct\n        QuarterlyDistribution storage newDistributionPeriod = _distributions[newDistributionId_];\n        newDistributionPeriod.id              = newDistributionId_;\n        newDistributionPeriod.startBlock      = startBlock;\n        newDistributionPeriod.endBlock        = endBlock;\n        uint256 gbc                           = Maths.wmul(treasury, GLOBAL_BUDGET_CONSTRAINT);\n        newDistributionPeriod.fundsAvailable  = SafeCast.toUint128(gbc);\n\n        // decrease the treasury by the amount that is held for allocation in the new distribution period\n        treasury -= gbc;\n\n        emit QuarterlyDistributionStarted(\n            newDistributionId_,\n            startBlock,\n            endBlock\n        );\n    }\n\n    /**************************************************/\n    /*** Distribution Management Functions Internal ***/\n    /**************************************************/\n\n    /**\n     * @notice Get the block number at which this distribution period's challenge stage ends.\n     * @param  endBlock_ The end block of quarterly distribution to get the challenge stage end block for.\n     * @return The block number at which this distribution period's challenge stage ends.\n    */\n    function _getChallengeStageEndBlock(\n        uint256 endBlock_\n    ) internal pure returns (uint256) {\n        return endBlock_ + CHALLENGE_PERIOD_LENGTH;\n    }\n\n    /**\n     * @notice Get the block number at which this distribution period's screening stage ends.\n     * @param  endBlock_ The end block of quarterly distribution to get the screening stage end block for.\n     * @return The block number at which this distribution period's screening stage ends.\n    */\n    function _getScreeningStageEndBlock(\n        uint256 endBlock_\n    ) internal pure returns (uint256) {\n        return endBlock_ - FUNDING_PERIOD_LENGTH;\n    }\n\n    /**\n     * @notice Updates Treasury with surplus funds from distribution.\n     * @dev    Counters incremented in an unchecked block due to being bounded by array length of at most 10.\n     * @param distributionId_ distribution Id of updating distribution \n     */\n    function _updateTreasury(\n        uint24 distributionId_\n    ) private {\n        bytes32 fundedSlateHash = _distributions[distributionId_].fundedSlateHash;\n        uint256 fundsAvailable  = _distributions[distributionId_].fundsAvailable;\n\n        uint256[] memory fundingProposalIds = _fundedProposalSlates[fundedSlateHash];\n\n        uint256 totalTokensRequested;\n        uint256 numFundedProposals = fundingProposalIds.length;\n\n        for (uint i = 0; i < numFundedProposals; ) {\n            Proposal memory proposal = _standardFundingProposals[fundingProposalIds[i]];\n\n            totalTokensRequested += proposal.tokensRequested;\n\n            unchecked { ++i; }\n        }\n\n        // readd non distributed tokens to the treasury\n        treasury += (fundsAvailable - totalTokensRequested);\n\n        _isSurplusFundsUpdated[distributionId_] = true;\n    }\n\n    /**\n     * @notice Set a new DistributionPeriod Id.\n     * @dev    Increments the previous Id nonce by 1.\n     * @return newId_ The new distribution period Id.\n     */\n    function _setNewDistributionId() private returns (uint24 newId_) {\n        newId_ = _currentDistributionId += 1;\n    }\n\n    /************************************/\n    /*** Delegation Rewards Functions ***/\n    /************************************/\n\n    /// @inheritdoc IStandardFunding\n    function claimDelegateReward(\n        uint24 distributionId_\n    ) external override returns(uint256 rewardClaimed_) {\n        // Revert if delegatee didn't vote in screening stage\n        if(screeningVotesCast[distributionId_][msg.sender] == 0) revert DelegateRewardInvalid();\n\n        QuarterlyDistribution memory currentDistribution = _distributions[distributionId_];\n\n        // Check if Challenge Period is still active\n        if(block.number < _getChallengeStageEndBlock(currentDistribution.endBlock)) revert ChallengePeriodNotEnded();\n\n        // check rewards haven't already been claimed\n        if(hasClaimedReward[distributionId_][msg.sender]) revert RewardAlreadyClaimed();\n\n        QuadraticVoter memory voter = _quadraticVoters[distributionId_][msg.sender];\n\n        // calculate rewards earned for voting\n        rewardClaimed_ = _getDelegateReward(currentDistribution, voter);\n\n        hasClaimedReward[distributionId_][msg.sender] = true;\n\n        emit DelegateRewardClaimed(\n            msg.sender,\n            distributionId_,\n            rewardClaimed_\n        );\n\n        // transfer rewards to delegatee\n        IERC20(ajnaTokenAddress).safeTransfer(msg.sender, rewardClaimed_);\n    }\n\n    /**\n     * @notice Calculate the delegate rewards that have accrued to a given voter, in a given distribution period.\n     * @dev    Voter must have voted in both the screening and funding stages, and is proportional to their share of votes across the stages.\n     * @param  currentDistribution_ Struct of the distribution period to calculat rewards for.\n     * @param  voter_               Struct of the funding stages voter.\n     * @return rewards_             The delegate rewards accrued to the voter.\n     */\n    function _getDelegateReward(\n        QuarterlyDistribution memory currentDistribution_,\n        QuadraticVoter memory voter_\n    ) internal pure returns (uint256 rewards_) {\n        // calculate the total voting power available to the voter that was allocated in the funding stage\n        uint256 votingPowerAllocatedByDelegatee = voter_.votingPower - voter_.remainingVotingPower;\n\n        // if none of the voter's voting power was allocated, they receive no rewards\n        if (votingPowerAllocatedByDelegatee == 0) return 0;\n\n        // calculate reward\n        // delegateeReward = 10 % of GBC distributed as per delegatee Voting power allocated\n        rewards_ = Maths.wdiv(\n            Maths.wmul(\n                currentDistribution_.fundsAvailable,\n                votingPowerAllocatedByDelegatee\n            ),\n            currentDistribution_.fundingVotePowerCast\n        ) / 10;\n    }\n\n    /***********************************/\n    /*** Proposal Functions External ***/\n    /***********************************/\n\n    /// @inheritdoc IStandardFunding\n    function updateSlate(\n        uint256[] calldata proposalIds_,\n        uint24 distributionId_\n    ) external override returns (bool newTopSlate_) {\n        QuarterlyDistribution storage currentDistribution = _distributions[distributionId_];\n\n        // store number of proposals for reduced gas cost of iterations\n        uint256 numProposalsInSlate = proposalIds_.length;\n\n        // check the each proposal in the slate is valid, and get the sum of the proposals fundingVotesReceived\n        uint256 sum = _validateSlate(distributionId_, currentDistribution.endBlock, currentDistribution.fundsAvailable, proposalIds_, numProposalsInSlate);\n\n        // get pointers for comparing proposal slates\n        bytes32 currentSlateHash = currentDistribution.fundedSlateHash;\n        bytes32 newSlateHash     = keccak256(abi.encode(proposalIds_));\n\n        // check if slate of proposals is better than the existing slate, and is thus the new top slate\n        newTopSlate_ = currentSlateHash == 0 ||\n            (currentSlateHash!= 0 && sum > _sumProposalFundingVotes(_fundedProposalSlates[currentSlateHash]));\n\n        // if slate of proposals is new top slate, update state\n        if (newTopSlate_) {\n            uint256[] storage existingSlate = _fundedProposalSlates[newSlateHash];\n\n            for (uint i = 0; i < numProposalsInSlate; ) {\n\n                // update list of proposals to fund\n                existingSlate.push(proposalIds_[i]);\n\n                unchecked { ++i; }\n            }\n\n            // update hash to point to the new leading slate of proposals\n            currentDistribution.fundedSlateHash = newSlateHash;\n\n            emit FundedSlateUpdated(\n                distributionId_,\n                newSlateHash\n            );\n        }\n    }\n\n    /// @inheritdoc IStandardFunding\n    function executeStandard(\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        bytes32 descriptionHash_\n    ) external nonReentrant override returns (uint256 proposalId_) {\n        proposalId_ = _hashProposal(targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_STANDARD, descriptionHash_)));\n        Proposal storage proposal = _standardFundingProposals[proposalId_];\n\n        uint24 distributionId = proposal.distributionId;\n\n        // check that the distribution period has ended, and one week has passed to enable competing slates to be checked\n        if (block.number <= _getChallengeStageEndBlock(_distributions[distributionId].endBlock)) revert ExecuteProposalInvalid();\n\n        // check proposal is succesful and hasn't already been executed\n        if (!_standardFundingVoteSucceeded(proposalId_) || proposal.executed) revert ProposalNotSuccessful();\n\n        proposal.executed = true;\n\n        _execute(proposalId_, targets_, values_, calldatas_);\n    }\n\n    /// @inheritdoc IStandardFunding\n    function proposeStandard(\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        string memory description_\n    ) external override returns (uint256 proposalId_) {\n        proposalId_ = _hashProposal(targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_STANDARD, keccak256(bytes(description_)))));\n\n        Proposal storage newProposal = _standardFundingProposals[proposalId_];\n\n        // check for duplicate proposals\n        if (newProposal.proposalId != 0) revert ProposalAlreadyExists();\n\n        QuarterlyDistribution memory currentDistribution = _distributions[_currentDistributionId];\n\n        // cannot add new proposal after end of screening period\n        // screening period ends 72000 blocks before end of distribution period, ~ 80 days.\n        if (block.number > _getScreeningStageEndBlock(currentDistribution.endBlock)) revert ScreeningPeriodEnded();\n\n        // store new proposal information\n        newProposal.proposalId      = proposalId_;\n        newProposal.distributionId  = currentDistribution.id;\n        newProposal.tokensRequested = _validateCallDatas(targets_, values_, calldatas_); // check proposal parameters are valid and update tokensRequested\n\n        // revert if proposal requested more tokens than are available in the distribution period\n        if (newProposal.tokensRequested > (currentDistribution.fundsAvailable * 9 / 10)) revert InvalidProposal();\n\n        emit ProposalCreated(\n            proposalId_,\n            msg.sender,\n            targets_,\n            values_,\n            new string[](targets_.length),\n            calldatas_,\n            block.number,\n            currentDistribution.endBlock,\n            description_\n        );\n    }\n\n    /***********************************/\n    /*** Proposal Functions Internal ***/\n    /***********************************/\n\n    /**\n     * @notice Check the validity of a potential slate of proposals to execute, and sum the slate's fundingVotesReceived.\n     * @dev    Only iterates through a maximum of 10 proposals that made it through both voting stages.\n     * @dev    Counters incremented in an unchecked block due to being bounded by array length.\n     * @param  distributionId_                   Id of the distribution period to check the slate for.\n     * @param  endBlock                          End block of the distribution period.\n     * @param  distributionPeriodFundsAvailable_ Funds available for distribution in the distribution period.\n     * @param  proposalIds_                      Array of proposal Ids to check.\n     * @param  numProposalsInSlate_              Number of proposals in the slate.\n     * @return sum_                              The total funding votes received by all proposals in the proposed slate.\n     */\n    function _validateSlate(uint24 distributionId_, uint256 endBlock, uint256 distributionPeriodFundsAvailable_, uint256[] calldata proposalIds_, uint256 numProposalsInSlate_) internal view returns (uint256 sum_) {\n        // check that the function is being called within the challenge period\n        if (block.number <= endBlock || block.number > _getChallengeStageEndBlock(endBlock)) {\n            revert InvalidProposalSlate();\n        }\n\n        // check that the slate has no duplicates\n        if (_hasDuplicates(proposalIds_)) revert InvalidProposalSlate();\n\n        uint256 gbc = distributionPeriodFundsAvailable_;\n        uint256 totalTokensRequested = 0;\n\n        // check each proposal in the slate is valid\n        for (uint i = 0; i < numProposalsInSlate_; ) {\n            Proposal memory proposal = _standardFundingProposals[proposalIds_[i]];\n\n            // check if Proposal is in the topTenProposals list\n            if (_findProposalIndex(proposalIds_[i], _topTenProposals[distributionId_]) == -1) revert InvalidProposalSlate();\n\n            // account for fundingVotesReceived possibly being negative\n            if (proposal.fundingVotesReceived < 0) revert InvalidProposalSlate();\n\n            // update counters\n            sum_ += uint128(proposal.fundingVotesReceived); // since we are converting from int128 to uint128, we can safely assume that the value will not overflow\n            totalTokensRequested += proposal.tokensRequested;\n\n            // check if slate of proposals exceeded budget constraint ( 90% of GBC )\n            if (totalTokensRequested > (gbc * 9 / 10)) {\n                revert InvalidProposalSlate();\n            }\n\n            unchecked { ++i; }\n        }\n    }\n\n    /**\n     * @notice Check an array of proposalIds for duplicate IDs.\n     * @dev    Only iterates through a maximum of 10 proposals that made it through the screening round.\n     * @dev    Counters incremented in an unchecked block due to being bounded by array length.\n     * @param  proposalIds_ Array of proposal Ids to check.\n     * @return Boolean indicating the presence of a duplicate. True if it has a duplicate; false if not.\n     */\n    function _hasDuplicates(\n        uint256[] calldata proposalIds_\n    ) internal pure returns (bool) {\n        uint256 numProposals = proposalIds_.length;\n\n        for (uint i = 0; i < numProposals; ) {\n            for (uint j = i + 1; j < numProposals; ) {\n                if (proposalIds_[i] == proposalIds_[j]) return true;\n\n                unchecked { ++j; }\n            }\n\n            unchecked { ++i; }\n\n        }\n        return false;\n    }\n\n    /**\n     * @notice Calculates the sum of funding votes allocated to a list of proposals.\n     * @dev    Only iterates through a maximum of 10 proposals that made it through the screening round.\n     * @dev    Counters incremented in an unchecked block due to being bounded by array length of at most 10.\n     * @param  proposalIdSubset_ Array of proposal Ids to sum.\n     * @return sum_ The sum of the funding votes across the given proposals.\n     */\n    function _sumProposalFundingVotes(\n        uint256[] memory proposalIdSubset_\n    ) internal view returns (uint128 sum_) {\n        for (uint i = 0; i < proposalIdSubset_.length;) {\n            // since we are converting from int128 to uint128, we can safely assume that the value will not overflow\n            sum_ += uint128(_standardFundingProposals[proposalIdSubset_[i]].fundingVotesReceived);\n\n            unchecked { ++i; }\n        }\n    }\n\n    /**\n     * @notice Get the current ProposalState of a given proposal.\n     * @dev    Used by GrantFund.state() for analytics compatability purposes.\n     * @param  proposalId_ The ID of the proposal being checked.\n     * @return The proposals status in the ProposalState enum.\n     */\n    function _standardProposalState(uint256 proposalId_) internal view returns (ProposalState) {\n        Proposal memory proposal = _standardFundingProposals[proposalId_];\n\n        if (proposal.executed)                                                     return ProposalState.Executed;\n        else if (_distributions[proposal.distributionId].endBlock >= block.number) return ProposalState.Active;\n        else if (_standardFundingVoteSucceeded(proposalId_))                      return ProposalState.Succeeded;\n        else                                                                       return ProposalState.Defeated;\n    }\n\n    /*********************************/\n    /*** Voting Functions External ***/\n    /*********************************/\n\n    /// @inheritdoc IStandardFunding\n    function fundingVote(\n        FundingVoteParams[] memory voteParams_\n    ) external override returns (uint256 votesCast_) {\n        uint24 currentDistributionId = _currentDistributionId;\n\n        QuarterlyDistribution storage currentDistribution = _distributions[currentDistributionId];\n        QuadraticVoter        storage voter               = _quadraticVoters[currentDistributionId][msg.sender];\n\n        uint256 endBlock = currentDistribution.endBlock;\n\n        uint256 screeningStageEndBlock = _getScreeningStageEndBlock(endBlock);\n\n        // check that the funding stage is active\n        if (block.number <= screeningStageEndBlock || block.number > endBlock) revert InvalidVote();\n\n        uint128 votingPower = voter.votingPower;\n\n        // if this is the first time a voter has attempted to vote this period,\n        // set initial voting power and remaining voting power\n        if (votingPower == 0) {\n\n            // calculate the voting power available to the voting power in this funding stage\n            uint128 newVotingPower = SafeCast.toUint128(_getVotesFunding(msg.sender, votingPower, voter.remainingVotingPower, screeningStageEndBlock));\n\n            voter.votingPower          = newVotingPower;\n            voter.remainingVotingPower = newVotingPower;\n        }\n\n        uint256 numVotesCast = voteParams_.length;\n\n        for (uint256 i = 0; i < numVotesCast; ) {\n            Proposal storage proposal = _standardFundingProposals[voteParams_[i].proposalId];\n\n            // check that the proposal is part of the current distribution period\n            if (proposal.distributionId != currentDistributionId) revert InvalidVote();\n\n            // check that the proposal being voted on is in the top ten screened proposals\n            if (_findProposalIndex(voteParams_[i].proposalId, _topTenProposals[currentDistributionId]) == -1) revert InvalidVote();\n\n            // cast each successive vote\n            votesCast_ += _fundingVote(\n                currentDistribution,\n                proposal,\n                msg.sender,\n                voter,\n                voteParams_[i]\n            );\n\n            unchecked { ++i; }\n        }\n    }\n\n    /// @inheritdoc IStandardFunding\n    function screeningVote(\n        ScreeningVoteParams[] memory voteParams_\n    ) external override returns (uint256 votesCast_) {\n        QuarterlyDistribution memory currentDistribution = _distributions[_currentDistributionId];\n\n        // check screening stage is active\n        if (block.number < currentDistribution.startBlock || block.number > _getScreeningStageEndBlock(currentDistribution.endBlock)) revert InvalidVote();\n\n        uint256 numVotesCast = voteParams_.length;\n\n        for (uint256 i = 0; i < numVotesCast; ) {\n            Proposal storage proposal = _standardFundingProposals[voteParams_[i].proposalId];\n\n            // check that the proposal is part of the current distribution period\n            if (proposal.distributionId != currentDistribution.id) revert InvalidVote();\n\n            uint256 votes = voteParams_[i].votes;\n\n            // cast each successive vote\n            votesCast_ += votes;\n            _screeningVote(msg.sender, proposal, votes);\n\n            unchecked { ++i; }\n        }\n    }\n\n    /*********************************/\n    /*** Voting Functions Internal ***/\n    /*********************************/\n\n    /**\n     * @notice Vote on a proposal in the funding stage of the Distribution Period.\n     * @dev    Votes can be allocated to multiple proposals, quadratically, for or against.\n     * @param  currentDistribution_  The current distribution period.\n     * @param  proposal_             The current proposal being voted upon.\n     * @param  account_              The voting account.\n     * @param  voter_                The voter data struct tracking available votes.\n     * @param  voteParams_           The amount of votes being allocated to the proposal. Not squared. If less than 0, vote is against.\n     * @return incrementalVotesUsed_ The amount of funding stage votes allocated to the proposal.\n     */\n    function _fundingVote(\n        QuarterlyDistribution storage currentDistribution_,\n        Proposal storage proposal_,\n        address account_,\n        QuadraticVoter storage voter_,\n        FundingVoteParams memory voteParams_\n    ) internal returns (uint256 incrementalVotesUsed_) {\n        uint8  support = 1;\n        uint256 proposalId = proposal_.proposalId;\n\n        // determine if voter is voting for or against the proposal\n        voteParams_.votesUsed < 0 ? support = 0 : support = 1;\n\n        uint128 votingPower = voter_.votingPower;\n\n        // the total amount of voting power used by the voter before this vote executes\n        uint128 voterPowerUsedPreVote = votingPower - voter_.remainingVotingPower;\n\n        FundingVoteParams[] storage votesCast = voter_.votesCast;\n\n        // check that the voter hasn't already voted on a proposal by seeing if it's already in the votesCast array \n        int256 voteCastIndex = _findProposalIndexOfVotesCast(proposalId, votesCast);\n\n        // voter had already cast a funding vote on this proposal\n        if (voteCastIndex != -1) {\n            // since we are converting from int256 to uint256, we can safely assume that the value will not overflow\n            FundingVoteParams storage existingVote = votesCast[uint256(voteCastIndex)];\n\n            // can't change the direction of a previous vote\n            if (support == 0 && existingVote.votesUsed > 0 || support == 1 && existingVote.votesUsed < 0) {\n                // if the vote is in the opposite direction of a previous vote,\n                // and the proposal is already in the votesCast array, revert can't change direction\n                revert FundingVoteWrongDirection();\n            }\n            else {\n                // update the votes cast for the proposal\n                existingVote.votesUsed += voteParams_.votesUsed;\n            }\n        }\n        // first time voting on this proposal, add the newly cast vote to the voter's votesCast array\n        else {\n            votesCast.push(voteParams_);\n        }\n\n        // calculate the cumulative cost of all votes made by the voter\n        // and check that attempted votes cast doesn't overflow uint128\n        uint256 sumOfTheSquareOfVotesCast = _sumSquareOfVotesCast(votesCast);\n        if (sumOfTheSquareOfVotesCast > type(uint128).max) revert InsufficientVotingPower();\n        uint128 cumulativeVotePowerUsed = SafeCast.toUint128(sumOfTheSquareOfVotesCast);\n\n        // check that the voter has enough voting power remaining to cast the vote\n        if (cumulativeVotePowerUsed > votingPower) revert InsufficientVotingPower();\n\n        // update voter voting power accumulator\n        voter_.remainingVotingPower = votingPower - cumulativeVotePowerUsed;\n\n        // calculate the change in voting power used by the voter in this vote in order to accurately track the total voting power used in the funding stage\n        // since we are moving from uint128 to uint256, we can safely assume that the value will not overflow\n        uint256 incrementalVotingPowerUsed = uint256(cumulativeVotePowerUsed - voterPowerUsedPreVote);\n\n        // update accumulator for total voting power used in the funding stage in order to calculate delegate rewards\n        currentDistribution_.fundingVotePowerCast += incrementalVotingPowerUsed;\n\n        // update proposal vote tracking\n        proposal_.fundingVotesReceived += SafeCast.toInt128(voteParams_.votesUsed);\n\n        // the incremental additional votes cast on the proposal to be used as a return value and emit value\n        incrementalVotesUsed_ = SafeCast.toUint256(Maths.abs(voteParams_.votesUsed));\n\n        // emit VoteCast instead of VoteCastWithParams to maintain compatibility with Tally\n        // emits the amount of incremental votes cast for the proposal, not the voting power cost or total votes on a proposal\n        emit VoteCast(\n            account_,\n            proposalId,\n            support,\n            incrementalVotesUsed_,\n            \"\"\n        );\n    }\n\n    /**\n     * @notice Vote on a proposal in the screening stage of the Distribution Period.\n     * @param account_  The voting account.\n     * @param proposal_ The current proposal being voted upon.\n     * @param votes_    The amount of votes being cast.\n     */\n    function _screeningVote(\n        address account_,\n        Proposal storage proposal_,\n        uint256 votes_\n    ) internal {\n        uint24 distributionId = proposal_.distributionId;\n\n        // check that the voter has enough voting power to cast the vote\n        if (screeningVotesCast[distributionId][account_] + votes_ > _getVotesScreening(distributionId, account_)) revert InsufficientVotingPower();\n\n        uint256[] storage currentTopTenProposals = _topTenProposals[distributionId];\n        uint256 proposalId = proposal_.proposalId;\n\n        // update proposal votes counter\n        proposal_.votesReceived += SafeCast.toUint128(votes_);\n\n        // check if proposal was already screened\n        int indexInArray = _findProposalIndex(proposalId, currentTopTenProposals);\n        uint256 screenedProposalsLength = currentTopTenProposals.length;\n\n        // check if the proposal should be added to the top ten list for the first time\n        if (screenedProposalsLength < 10 && indexInArray == -1) {\n            currentTopTenProposals.push(proposalId);\n\n            // sort top ten proposals\n            _insertionSortProposalsByVotes(currentTopTenProposals, screenedProposalsLength);\n        }\n        else {\n            // proposal is already in the array\n            if (indexInArray != -1) {\n                // re-sort top ten proposals to account for new vote totals\n                _insertionSortProposalsByVotes(currentTopTenProposals, uint256(indexInArray));\n            }\n            // proposal isn't already in the array\n            else if(_standardFundingProposals[currentTopTenProposals[screenedProposalsLength - 1]].votesReceived < proposal_.votesReceived) {\n                // replace the least supported proposal with the new proposal\n                currentTopTenProposals.pop();\n                currentTopTenProposals.push(proposalId);\n\n                // sort top ten proposals"
    }
  ]
}