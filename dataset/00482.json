{
  "Title": "M-9: `requestWithdrawal` doesn't estimate accurately the available shares for withdrawals",
  "Content": "# Issue M-9: `requestWithdrawal` doesn't estimate accurately the available shares for withdrawals \n\nSource: https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/361 \n\n## Found by \nAudinarey, Aymen0909, Bauer, Bony, Drynooo, cats, deepplus, hash, kennedy1030, monrel, sakshamguruji, zzykxx\n## Summary\n\nThe `requestWithdrawal` function inaccurately estimates the available shares for withdrawals by including funds stored in the deposit pool into the already deposited EigenLayer shares. This can potentially lead to blocking withdrawals or users receiving less funds for their shares.\n\n## Vulnerability Detail\n\nFor a user to withdraw funds from the protocol, they must first request a withdrawal using the `requestWithdrawal` function, which queues the withdrawal in the current epoch by calling `withdrawalQueue().queueWithdrawal`.\n\nTo evaluate the available shares for withdrawal, the function converts the protocol asset balance into shares:\n\n```solidity\nuint256 availableShares = assetRegistry().convertToSharesFromAsset(asset, assetRegistry().getTotalBalanceForAsset(asset));\n```\n\nThe issue arises from the `getTotalBalanceForAsset` function, which returns the sum of the protocol asset funds held, including assets already deposited into EigenLayer and assets still in the deposit pool:\n\n```solidity\nfunction getTotalBalanceForAsset(\n    address asset\n) public view returns (uint256) {\n    if (!isSupportedAsset(asset)) revert ASSET_NOT_SUPPORTED(asset);\n\n    address depositPool_ = address(depositPool());\n    if (asset == ETH_ADDRESS) {\n        return depositPool_.balance + getETHBalanceInEigenLayer();\n    }\n\n    uint256 sharesHeld = getAssetSharesHeld(asset);\n    uint256 tokensInRio = IERC20(asset).balanceOf(depositPool_);\n    uint256 tokensInEigenLayer = convertFromSharesToAsset(\n        getAssetStrategy(asset),\n        sharesHeld\n    );\n\n    return tokensInRio + tokensInEigenLayer;\n}\n```\n\nThis causes the calculated `availableShares` to differ from the actual shares held by the protocol because the assets still in the deposit pool shouldn't be converted to shares with the current share price (shares/asset) as they were not deposited into EigenLayer yet.\n\nDepending on the current shares price, the function might over or under-estimate the available shares in the protocol. This can potentially result in allowing more queued withdrawals than the available shares in the protocol, leading to blocking withdrawals later on or users receiving less funds for their shares.\n\n## Impact\n\nThe `requestWithdrawal` function inaccurately estimates the available shares for withdrawals, potentially resulting in blocking withdrawals or users receiving less funds for their shares.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/main/rio-sherlock-audit/contracts/restaking/RioLRTCoordinator.sol#L111-L114\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThere is no straightforward way to handle this issue as the asset held by the deposit pool can't be converted into shares while they were not deposited into EigenLayer. The code should be reviewed to address this issue.\n\n\n\n## Discussion\n\n**solimander**\n\nDuplicate of https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/109\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/176",
  "Code": [
    {
      "filename": "rio-sherlock-audit/contracts/restaking/RioLRTCoordinator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.23;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IRioLRTWithdrawalQueue} from 'contracts/interfaces/IRioLRTWithdrawalQueue.sol';\nimport {UUPSUpgradeable} from '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport {OwnableUpgradeable} from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport {IRioLRTAssetRegistry} from 'contracts/interfaces/IRioLRTAssetRegistry.sol';\nimport {ETH_ADDRESS, MAX_REBALANCE_DELAY} from 'contracts/utils/Constants.sol';\nimport {IRioLRTCoordinator} from 'contracts/interfaces/IRioLRTCoordinator.sol';\nimport {OperatorOperations} from 'contracts/utils/OperatorOperations.sol';\nimport {RioLRTCore} from 'contracts/restaking/base/RioLRTCore.sol';\nimport {ETH_ADDRESS} from 'contracts/utils/Constants.sol';\nimport {Asset} from 'contracts/utils/Asset.sol';\n\ncontract RioLRTCoordinator is IRioLRTCoordinator, OwnableUpgradeable, UUPSUpgradeable, RioLRTCore {\n    using SafeERC20 for *;\n    using Asset for *;\n\n    /// @notice The required delay between rebalances.\n    uint24 public rebalanceDelay;\n\n    /// @notice Tracks the timestamp from which each asset is eligible for rebalancing, inclusive of the defined timestamp.\n    mapping(address asset => uint256 timestamp) public assetNextRebalanceAfter;\n\n    /// @notice Require that the asset is supported, the deposit amount is non-zero, and the\n    /// deposit cap has not been reached.\n    /// @param asset The asset being deposited.\n    /// @param amountIn The amount of the asset being deposited.\n    modifier checkDeposit(address asset, uint256 amountIn) {\n        _checkAssetSupported(asset);\n        _checkAmountGreaterThanZero(amountIn);\n        _checkDepositCapReached(asset, amountIn);\n        _;\n    }\n\n    /// @notice Require that the asset is supported and the withdrawal amount is non-zero.\n    /// @param asset The asset being deposited.\n    /// @param amountIn The amount of the asset being deposited.\n    modifier checkWithdrawal(address asset, uint256 amountIn) {\n        _checkAssetSupported(asset);\n        _checkAmountGreaterThanZero(amountIn);\n        _;\n    }\n\n    /// @notice Require that the rebalance delay has been met.\n    /// @param asset The asset being rebalanced.\n    modifier checkRebalanceDelayMet(address asset) {\n        _checkRebalanceDelayMet(asset);\n        _;\n    }\n\n    /// @param issuer_ The LRT issuer that's authorized to deploy this contract.\n    constructor(address issuer_) RioLRTCore(issuer_) {}\n\n    /// @dev Initializes the contract.\n    /// @param initialOwner The owner of the contract.\n    /// @param token_ The address of the liquid restaking token.\n    function initialize(address initialOwner, address token_) external initializer {\n        __Ownable_init(initialOwner);\n        __UUPSUpgradeable_init();\n        __RioLRTCore_init(token_);\n\n        _setRebalanceDelay(24 hours);\n    }\n\n    /// @notice Returns the total value of all underlying assets in the unit of account.\n    function getTVL() public view returns (uint256 value) {\n        return assetRegistry().getTVL();\n    }\n\n    // forgefmt: disable-next-item\n    /// @notice Deposits ERC20 tokens and mints restaking token(s) to the caller.\n    /// @param asset The asset being deposited.\n    /// @param amountIn The amount of the asset being deposited.\n    function deposit(address asset, uint256 amountIn) external checkDeposit(asset, amountIn) returns (uint256 amountOut) {\n        // Convert deposited asset amount to restaking tokens.\n        amountOut = convertFromAssetToRestakingTokens(asset, amountIn);\n\n        // Pull tokens from the sender to the deposit pool.\n        IERC20(asset).safeTransferFrom(msg.sender, address(depositPool()), amountIn);\n\n        // Mint restaking tokens to the caller.\n        token.mint(msg.sender, amountOut);\n\n        emit Deposited(msg.sender, asset, amountIn, amountOut);\n    }\n\n    /// @notice Deposits ETH and mints restaking token(s) to the caller.\n    function depositETH() external payable returns (uint256) {\n        return _depositETH();\n    }\n\n    // forgefmt: disable-next-item\n    /// @notice Requests a withdrawal to `asset` for `amountIn` restaking tokens.\n    /// @param asset The asset being withdrawn.\n    /// @param amountIn The amount of restaking tokens being redeemed.\n    function requestWithdrawal(address asset, uint256 amountIn) external checkWithdrawal(asset, amountIn) returns (uint256 sharesOwed) {\n        // Determine the amount of shares owed to the withdrawer using the current exchange rate.\n        sharesOwed = convertToSharesFromRestakingTokens(asset, amountIn);\n\n        // If requesting ETH, reduce the precision of the shares owed to the nearest Gwei,\n        // which is the smallest unit of account supported by EigenLayer.\n        if (asset == ETH_ADDRESS) sharesOwed = sharesOwed.reducePrecisionToGwei();\n\n        // Pull restaking tokens from the sender to the withdrawal queue.\n        token.safeTransferFrom(msg.sender, address(withdrawalQueue()), amountIn);\n\n        // Ensure there are enough shares to cover the withdrawal request, and queue the withdrawal.\n        uint256 availableShares = assetRegistry().convertToSharesFromAsset(asset, assetRegistry().getTotalBalanceForAsset(asset));\n        if (sharesOwed > availableShares - withdrawalQueue().getSharesOwedInCurrentEpoch(asset)) {\n            revert INSUFFICIENT_SHARES_FOR_WITHDRAWAL();\n        }\n        withdrawalQueue().queueWithdrawal(msg.sender, asset, sharesOwed, amountIn);\n    }\n\n    /// @notice Rebalances the provided `asset` by processing outstanding withdrawals and\n    /// depositing remaining assets into EigenLayer.\n    /// @param asset The asset to rebalance.\n    function rebalance(address asset) external checkRebalanceDelayMet(asset) {\n        if (!assetRegistry().isSupportedAsset(asset)) revert ASSET_NOT_SUPPORTED(asset);\n        if (msg.sender != tx.origin) revert CALLER_MUST_BE_EOA();\n\n        // Process any outstanding withdrawals using funds from the deposit pool and EigenLayer.\n        uint256 sharesOwed = withdrawalQueue().getSharesOwedInCurrentEpoch(asset);\n        if (sharesOwed > 0) {\n            _processUserWithdrawalsForCurrentEpoch(asset, sharesOwed);\n        }\n\n        // Deposit remaining assets into EigenLayer.\n        (uint256 sharesReceived, bool isDepositCapped) = depositPool().depositBalanceIntoEigenLayer(asset);\n        if (sharesOwed == 0 && sharesReceived == 0) {\n            revert NO_REBALANCE_NEEDED();\n        }\n        if (sharesReceived > 0) {\n            if (asset == ETH_ADDRESS) {\n                assetRegistry().increaseUnverifiedValidatorETHBalance(sharesReceived);\n            } else {\n                assetRegistry().increaseSharesHeldForAsset(asset, sharesReceived);\n            }\n        }\n\n        // When the deposit is not capped, the rebalance is considered complete, and the asset rebalance\n        // timestamp is increased by the specified delay. If capped, the asset may be rebalanced again\n        // immediately as there are more assets to deposit.\n        if (!isDepositCapped) {\n            assetNextRebalanceAfter[asset] = uint40(block.timestamp) + rebalanceDelay;\n        }\n        emit Rebalanced(asset);\n    }\n\n    /// @notice Sets the rebalance delay.\n    /// @param newRebalanceDelay The new rebalance delay, in seconds.\n    function setRebalanceDelay(uint24 newRebalanceDelay) external onlyOwner {\n        _setRebalanceDelay(newRebalanceDelay);\n    }\n\n    /// @notice Converts the unit of account value to its equivalent in restaking tokens.\n    /// The unit of account is the price feed's quote asset.\n    /// @param value The restaking token's value in the unit of account.\n    function convertFromUnitOfAccountToRestakingTokens(uint256 value) public view returns (uint256) {\n        uint256 tvl = getTVL();\n        uint256 supply = token.totalSupply();\n\n        if (supply == 0) {\n            return value;\n        }\n        return value * supply / tvl;\n    }\n\n    /// @notice Converts an amount of restaking tokens to its equivalent value in the unit of account.\n    /// The unit of account is the price feed's quote asset.\n    /// @param amount The amount of restaking tokens to convert.\n    function convertToUnitOfAccountFromRestakingTokens(uint256 amount) public view returns (uint256) {\n        uint256 tvl = getTVL();\n        uint256 supply = token.totalSupply();\n\n        if (supply == 0) {\n            return amount;\n        }\n        return tvl * amount / supply;\n    }\n\n    /// @notice Converts an asset amount to its equivalent value in restaking tokens.\n    /// @param asset The address of the asset to convert.\n    /// @param amount The amount of the asset to convert.\n    function convertFromAssetToRestakingTokens(address asset, uint256 amount) public view returns (uint256) {\n        uint256 value = assetRegistry().convertToUnitOfAccountFromAsset(asset, amount);\n        return convertFromUnitOfAccountToRestakingTokens(value);\n    }\n\n    /// @notice Converts an amount of restaking tokens to the equivalent in the asset.\n    /// @param asset The address of the asset to convert to.\n    /// @param amount The amount of restaking tokens to convert.\n    function convertToAssetFromRestakingTokens(address asset, uint256 amount) public view returns (uint256) {\n        uint256 value = convertToUnitOfAccountFromRestakingTokens(amount);\n        return assetRegistry().convertFromUnitOfAccountToAsset(asset, value);\n    }\n\n    /// @notice Converts an amount of restaking tokens to the equivalent in the provided\n    /// asset's EigenLayer shares.\n    /// @param asset The address of the asset whose EigenLayer shares to convert to.\n    /// @param amount The amount of restaking tokens to convert.\n    function convertToSharesFromRestakingTokens(address asset, uint256 amount) public view returns (uint256 shares) {\n        uint256 assetAmount = convertToAssetFromRestakingTokens(asset, amount);\n        return assetRegistry().convertToSharesFromAsset(asset, assetAmount);\n    }\n\n    /// @notice Deposits ETH and mints restaking token(s) to the caller.\n    receive() external payable {\n        _depositETH();\n    }\n\n    /// @notice Deposits ETH and mints restaking token(s) to the caller.\n    /// @dev This function assumes that the quote asset is ETH.\n    function _depositETH() internal checkDeposit(ETH_ADDRESS, msg.value) returns (uint256 amountOut) {\n        // Convert deposited ETH to restaking tokens and mint to the caller.\n        amountOut = convertFromUnitOfAccountToRestakingTokens(msg.value);\n\n        // Forward ETH to the deposit pool.\n        address(depositPool()).transferETH(msg.value);\n\n        // Mint restaking tokens to the caller.\n        token.mint(msg.sender, amountOut);\n\n        emit Deposited(msg.sender, ETH_ADDRESS, msg.value, amountOut);\n    }\n\n    /// @dev Sets the rebalance delay.\n    /// @param newRebalanceDelay The new rebalance delay, in seconds.\n    function _setRebalanceDelay(uint24 newRebalanceDelay) internal {\n        if (newRebalanceDelay > MAX_REBALANCE_DELAY) revert REBALANCE_DELAY_TOO_LONG();\n        rebalanceDelay = newRebalanceDelay;\n\n        emit RebalanceDelaySet(newRebalanceDelay);\n    }\n\n    // forgefmt: disable-next-item\n    /// @dev Processes user withdrawals for the provided asset by transferring available\n    /// assets from the deposit pool and queueing any remaining amount for withdrawal from\n    /// EigenLayer.\n    /// @param asset The asset being withdrawn.\n    /// @param sharesOwed The amount of shares owed to users.\n    function _processUserWithdrawalsForCurrentEpoch(address asset, uint256 sharesOwed) internal {\n        IRioLRTWithdrawalQueue withdrawalQueue_ = withdrawalQueue();\n        (uint256 assetsSent, uint256 sharesSent) = depositPool().transferMaxAssetsForShares(\n            asset,\n            sharesOwed,\n            address(withdrawalQueue_)\n        );\n        uint256 sharesRemaining = sharesOwed - sharesSent;\n\n        // Exit early if all pending withdrawals were paid from the deposit pool.\n        if (sharesRemaining == 0) {\n            withdrawalQueue_.settleCurrentEpoch(asset, assetsSent, sharesSent);\n            return;\n        }\n\n        address strategy = assetRegistry().getAssetStrategy(asset);\n        bytes32 aggregateRoot = OperatorOperations.queueWithdrawalFromOperatorsForUserSettlement(\n            operatorRegistry(),\n            strategy,\n            sharesRemaining\n        );\n        withdrawalQueue_.queueCurrentEpochSettlement(asset, assetsSent, sharesSent, aggregateRoot);\n    }\n\n    /// @dev Checks if the provided asset is supported.\n    /// @param asset The address of the asset.\n    function _checkAssetSupported(address asset) internal view {\n        if (!assetRegistry().isSupportedAsset(asset)) revert ASSET_NOT_SUPPORTED(asset);\n    }\n\n    /// @dev Checks if the provided amount is greater than zero.\n    /// @param amount The amount being checked.\n    function _checkAmountGreaterThanZero(uint256 amount) internal pure {\n        if (amount == 0) revert AMOUNT_MUST_BE_GREATER_THAN_ZERO();\n    }\n\n    /// @dev Checks if the deposit cap for the asset has been reached.\n    /// @param asset The address of the asset.\n    /// @param amountIn The amount of the asset being deposited.\n    function _checkDepositCapReached(address asset, uint256 amountIn) internal view {\n        IRioLRTAssetRegistry assetRegistry_ = assetRegistry();\n\n        uint256 depositCap = assetRegistry_.getAssetDepositCap(asset);\n        if (depositCap > 0) {\n            uint256 existingBalance = assetRegistry_.getTotalBalanceForAsset(asset);\n            if (existingBalance + amountIn > depositCap) {\n                revert DEPOSIT_CAP_REACHED(asset, depositCap);\n            }\n        }\n    }\n\n    /// @dev Reverts if the rebalance delay has not been met.\n    /// @param asset The asset being rebalanced.\n    function _checkRebalanceDelayMet(address asset) internal view {\n        if (block.timestamp < assetNextRebalanceAfter[asset]) revert REBALANCE_DELAY_NOT_MET();\n    }\n\n    /// @dev Allows the owner to upgrade the gateway implementation.\n    /// @param newImplementation The implementation to upgrade to.\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n}"
    }
  ]
}