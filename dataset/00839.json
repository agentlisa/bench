{
  "Title": "M-6: Balancer LP valuation methodologies use the incorrect supply metric",
  "Content": "# Issue M-6: Balancer LP valuation methodologies use the incorrect supply metric \n\nSource: https://github.com/sherlock-audit/2023-11-olympus-judging/issues/155 \n\n## Found by \n0x52, 0xMR0, Arabadzhiev, AuditorPraise, Bauer, CL001, Drynooo, ZanyBonzy, ast3ros, bin2chen, coffiasd, cu5t0mPe0, ge6a, hash, jovi, shealtielanz, tvdung94\n## Summary\n\nIn various Balancer LP valuations, totalSupply() is used to determine the total LP supply. However this is not the appropriate method for determining the supply. Instead getActualSupply should be used instead. Depending on the which pool implementation and how much LP is deployed, the valuation can be much too high or too low. Since the RBS pricing is dependent on this metric. It could lead to RBS being deployed at incorrect prices.\n\n## Vulnerability Detail\n\n[AuraBalancerSupply.sol#L345-L362](https://github.com/sherlock-audit/2023-11-olympus/blob/main/bophades/src/modules/SPPLY/submodules/AuraBalancerSupply.sol#L345-L362)\n\n    uint256 balTotalSupply = pool.balancerPool.totalSupply();\n    uint256[] memory balances = new uint256[](_vaultTokens.length);\n    // Calculate the proportion of the pool balances owned by the polManager\n    if (balTotalSupply != 0) {\n        // Calculate the amount of OHM in the pool owned by the polManager\n        // We have to iterate through the tokens array to find the index of OHM\n        uint256 tokenLen = _vaultTokens.length;\n        for (uint256 i; i < tokenLen; ) {\n            uint256 balance = _vaultBalances[i];\n            uint256 polBalance = (balance * balBalance) / balTotalSupply;\n\n\n            balances[i] = polBalance;\n\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\nTo value each LP token the contract divides the valuation of the pool by the total supply of LP. This in itself is correct, however the totalSupply method for a variety of Balancer pools doesn't accurately reflect the true LP supply. If we take a look at a few Balancer pools we can quickly see the issue:\n\nThis [pool](https://etherscan.io/token/0x42ed016f826165c2e5976fe5bc3df540c5ad0af7) shows a max supply of 2,596,148,429,273,858 whereas the actual supply is 6454.48. In this case the LP token would be significantly undervalued. If a sizable portion of the reserves are deployed in an affected pool the backing per OHM would appear to the RBS system to be much lower than it really is. As a result it can cause the RBS to deploy its funding incorrectly, potentially selling/buying at a large loss to the protocol.\n\n## Impact\n\nPool LP can be grossly under/over valued\n\n## Code Snippet\n\n[AuraBalancerSupply.sol#L332-L369](https://github.com/sherlock-audit/2023-11-olympus/blob/main/bophades/src/modules/SPPLY/submodules/AuraBalancerSupply.sol#L332-L369)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse a try-catch block to always query getActualSupply on each pool to make sure supported pools use the correct metric.\n\n\n\n## Discussion\n\n**0xJem**\n\nThis is a valid issue and highlights problems with Balancer's documentation.\n\nWe are likely to drop both the Balancer submodules from the final version, since we no longer have any Balancer pools used for POL and don't have any assets that require price resolution via Balancer pools.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/128",
  "Code": [
    {
      "filename": "bophades/src/modules/SPPLY/submodules/AuraBalancerSupply.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\n// Balancer\nimport {IBalancerPool} from \"src/external/balancer/interfaces/IBalancerPool.sol\";\nimport {IVault} from \"src/libraries/Balancer/interfaces/IVault.sol\";\nimport {IAuraRewardPool} from \"src/external/aura/interfaces/IAuraRewardPool.sol\";\nimport {VaultReentrancyLib} from \"src/libraries/Balancer/contracts/VaultReentrancyLib.sol\";\n\n// Bophades Modules\nimport \"modules/SPPLY/SPPLY.v1.sol\";\n\n/// @title      AuraBalancerSupply\n/// @author     Oighty\n/// @notice     Calculates the amount of protocol-owned liquidity OHM in Balancer pools, including BPTs staked in Aura\ncontract AuraBalancerSupply is SupplySubmodule {\n    // Requirements\n    // [X] Determine the amount of protocol-owned liquidity OHM in Balancer pools, including BPTs staked in Aura\n    // Math:\n    // Protocol deposits OHM-TKN liquidity into a balancer pool.\n    // The protocol may stake the liquidity pool tokens in Aura.\n    // Let X be the amount of BPT tokens held by the POL manager.\n    // Let Y be the amount of Aura BPT tokens held by the POL manager.\n    // Aura BPT tokens are 1:1 with BPT token balances.\n    // Then, A = X + Y is the total amount of BPT tokens held by the POL manager.\n    // If there are B BPT tokens in circulation, then the protocol owns A/B of the pool.\n    // If there are C OHM tokens in the pool, then the protocol owns (A/B) * C of the OHM in the pool.\n    // Therefore,\n    // Protocol-owned Borrowable OHM = 0\n    // Collateralized OHM = 0\n    // Protocol-owned Liquidity OHM = (A/B) * C\n\n    // ========== ERRORS ========== //\n\n    /// @notice The Balancer pool and Aura pool have differing assets\n    error AuraBalSupply_PoolMismatch();\n\n    /// @notice The parameters provided are invalid. This is usually due to a zero address.\n    error AuraBalSupply_InvalidParams();\n\n    /// @notice                 The pool is already added\n    /// @param balancerPool     Address of the Balancer pool\n    /// @param auraPool         Address of the Aura pool\n    error AuraBalSupply_PoolAlreadyAdded(address balancerPool, address auraPool);\n\n    // ========== EVENTS ========== //\n\n    /// @notice             Emitted when a pool is added\n    /// @param balancerPool Address of the Balancer pool\n    /// @param auraPool     Address of the Aura pool\n    event PoolAdded(address balancerPool, address auraPool);\n\n    /// @notice             Emitted when a pool is removed\n    /// @param balancerPool Address of the Balancer pool\n    /// @param auraPool     Address of the Aura pool\n    event PoolRemoved(address balancerPool, address auraPool);\n\n    // ========== STATE VARIABLES ========== //\n\n    /// @notice         Struct that represents a Balancer/Aura pool pair\n    struct Pool {\n        /// @notice     Balancer pool\n        IBalancerPool balancerPool;\n        /// @notice     Aura pool. Optional.\n        IAuraRewardPool auraPool;\n    }\n\n    /// @notice     Address of the POL manager.\n    address public immutable polManager;\n\n    /// @notice     Address of the OHM token. Cached at contract creation.\n    address internal immutable ohm;\n\n    /// @notice     Address of the Balancer Vault. Cached at contract creation.\n    IVault public immutable balVault;\n\n    /// @notice     Array of Balancer/Aura pool pairs.\n    /// @dev        The pools can be added and removed using the `addPool()` and `removePool()` functions.\n    Pool[] public pools;\n\n    // ========== CONSTRUCTOR ========== //\n\n    /// @notice             Constructor for the AuraBalancerSupply submodule\n    /// @dev                Will revert if:\n    /// @dev                - The `polManager_` address is 0\n    /// @dev                - The `balVault_` address is 0\n    /// @dev                - There is an invalid entry in the `pools_` array (see `addPool()`)\n    /// @dev                - Calling the `Submodule` constructor fails\n    ///\n    /// @param parent_      Address of the parent contract, the SPPLY module\n    /// @param polManager_  Address of the POL manager\n    /// @param balVault_    Address of the Balancer vault\n    /// @param pools_       Array of Balancer/Aura pool pairs\n    constructor(\n        Module parent_,\n        address polManager_,\n        address balVault_,\n        Pool[] memory pools_\n    ) Submodule(parent_) {\n        // Check that the parameters are valid\n        if (polManager_ == address(0) || balVault_ == address(0))\n            revert AuraBalSupply_InvalidParams();\n\n        polManager = polManager_;\n        balVault = IVault(balVault_);\n        ohm = address(SPPLYv1(address(parent_)).ohm());\n\n        // Iterate through the pools and add them to the array\n        // Check that the aura pool is for the associated balancer pool unless it is blank\n        uint256 len = pools_.length;\n        for (uint256 i; i < len; i++) {\n            // Don't add address 0\n            if (address(pools_[i].balancerPool) == address(0)) revert AuraBalSupply_InvalidParams();\n\n            // Balancer pool must be the asset of the Aura pool\n            if (\n                address(pools_[i].auraPool) != address(0) &&\n                address(pools_[i].balancerPool) != pools_[i].auraPool.asset()\n            ) {\n                revert AuraBalSupply_PoolMismatch();\n            }\n\n            // Don't add twice\n            if (_inArray(address(pools_[i].balancerPool)))\n                revert AuraBalSupply_PoolAlreadyAdded(\n                    address(pools_[i].balancerPool),\n                    address(pools_[i].auraPool)\n                );\n\n            pools.push(pools_[i]);\n            emit PoolAdded(address(pools_[i].balancerPool), address(pools_[i].auraPool));\n        }\n    }\n\n    // ========== SUBMODULE SETUP ========== //\n\n    /// @inheritdoc Submodule\n    function SUBKEYCODE() public pure override returns (SubKeycode) {\n        return toSubKeycode(\"SPPLY.AURABALANCER\");\n    }\n\n    /// @inheritdoc Submodule\n    function VERSION() external pure override returns (uint8 major, uint8 minor) {\n        major = 1;\n        minor = 0;\n    }\n\n    /// @inheritdoc Submodule\n    function INIT() external override onlyParent {}\n\n    // ========== DATA FUNCTIONS ========== //\n\n    /// @inheritdoc SupplySubmodule\n    /// @dev        Collateralized OHM is always zero for liquidity pools\n    function getCollateralizedOhm() external pure override returns (uint256) {\n        // Collateralized OHM is zero for liquidity pools (except BLV, which is a different module)\n        return 0;\n    }\n\n    /// @inheritdoc SupplySubmodule\n    /// @dev        Protocol-owned borrowable OHM is always zero for liquidity pools\n    function getProtocolOwnedBorrowableOhm() external pure override returns (uint256) {\n        // POBO is zero for liquidity pools\n        return 0;\n    }\n\n    /// @inheritdoc SupplySubmodule\n    /// @dev        Protocol-owned liquidity OHM is calculated as the sum of the protocol-owned OHM in each pool\n    ///\n    /// @dev        This function accesses the reserves of the monitored pools.\n    /// @dev        In order to protect against re-entrancy attacks,\n    /// @dev        it utilises the Balancer VaultReentrancyLib.\n    function getProtocolOwnedLiquidityOhm() external view override returns (uint256) {\n        // Prevent re-entrancy attacks\n        VaultReentrancyLib.ensureNotInVaultContext(balVault);\n\n        // Iterate through the pools and get the POL supply from each\n        uint256 supply;\n        uint256 len = pools.length;\n        for (uint256 i; i < len; ) {\n            SPPLYv1.Reserves memory reserve = _getReserves(pools[i]);\n\n            // Iterate over the tokens and add the OHM balance to the total POL supply\n            uint256 tokenLen = reserve.tokens.length;\n            for (uint256 j; j < tokenLen; ) {\n                if (reserve.tokens[j] == ohm) {\n                    supply += reserve.balances[j];\n                    break;\n                }\n                unchecked {\n                    ++j;\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return supply;\n    }\n\n    /// @inheritdoc SupplySubmodule\n    function getProtocolOwnedTreasuryOhm() external pure override returns (uint256) {\n        // POTO is always zero for liquidity pools\n        return 0;\n    }\n\n    /// @inheritdoc SupplySubmodule\n    /// @dev        This function accesses the reserves of the monitored pools.\n    /// @dev        In order to protect against re-entrancy attacks,\n    /// @dev        it utilises the Balancer VaultReentrancyLib.\n    function getProtocolOwnedLiquidityReserves()\n        external\n        view\n        override\n        returns (SPPLYv1.Reserves[] memory)\n    {\n        // Prevent re-entrancy attacks\n        VaultReentrancyLib.ensureNotInVaultContext(balVault);\n\n        // Iterate through tokens and add the reserves of each pool\n        uint256 len = pools.length;\n        SPPLYv1.Reserves[] memory reserves = new SPPLYv1.Reserves[](len);\n        for (uint256 i; i < len; ) {\n            SPPLYv1.Reserves memory reserve = _getReserves(pools[i]);\n            reserves[i] = reserve;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return reserves;\n    }\n\n    /// @inheritdoc SupplySubmodule\n    function getSourceCount() external view override returns (uint256) {\n        return pools.length;\n    }\n\n    /// @notice Get the list of configured pools\n    /// @return Array of Balancer/Aura pool pairs\n    function getPools() external view returns (Pool[] memory) {\n        return pools;\n    }\n\n    // =========== ADMIN FUNCTIONS =========== //\n\n    /// @notice                 Add a Balancer/Aura Pool pair to the list of pools\n    /// @dev                    Will revert if:\n    /// @dev                    - The `balancerPool_` address is 0\n    /// @dev                    - The `balancerPool_` address is already added\n    /// @dev                    - The `balancerPool_` address is not the asset of the specified Aura pool\n    /// @dev                    - The caller is not the parent module\n    ///\n    /// @param balancerPool_    Address of the Balancer pool\n    /// @param auraPool_        Address of the Aura pool\n    function addPool(address balancerPool_, address auraPool_) external onlyParent {\n        // Don't add address 0\n        if (balancerPool_ == address(0)) revert AuraBalSupply_InvalidParams();\n\n        // Check that the pool isn't already added\n        if (_inArray(balancerPool_))\n            revert AuraBalSupply_PoolAlreadyAdded(balancerPool_, auraPool_);\n\n        // Check that the aura pool is for the associated balancer pool unless it is blank\n        if (address(auraPool_) != address(0) && balancerPool_ != IAuraRewardPool(auraPool_).asset())\n            revert AuraBalSupply_PoolMismatch();\n\n        // Add the pool to the array\n        pools.push(\n            Pool({balancerPool: IBalancerPool(balancerPool_), auraPool: IAuraRewardPool(auraPool_)})\n        );\n\n        emit PoolAdded(balancerPool_, auraPool_);\n    }\n\n    /// @notice                 Remove a Balancer/Aura Pool pair from the list of pools\n    /// @dev                    Will revert if:\n    /// @dev                    - The `balancerPool_` address is 0\n    /// @dev                    - The `balancerPool_` address is not already added\n    /// @dev                    - The caller is not the parent module\n    ///\n    /// @param balancerPool_    Address of the Balancer pool\n    function removePool(address balancerPool_) external onlyParent {\n        // Ignore address 0\n        if (balancerPool_ == address(0)) revert AuraBalSupply_InvalidParams();\n\n        // Check that the pool is present\n        if (!_inArray(balancerPool_)) revert AuraBalSupply_InvalidParams();\n\n        uint256 len = pools.length;\n        for (uint256 i; i < len; ) {\n            if (balancerPool_ == address(pools[i].balancerPool)) {\n                address auraPool = address(pools[i].auraPool);\n                pools[i] = pools[len - 1];\n                pools.pop();\n                emit PoolRemoved(balancerPool_, auraPool);\n                return;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    // =========== HELPER FUNCTIONS =========== //\n\n    /// @notice     Determines if `balancerPool_` is contained in the `pools` array\n    ///\n    /// @param      balancerPool_ Address of the Balancer pool\n    /// @return     True if the pool is present, false otherwise\n    function _inArray(address balancerPool_) internal view returns (bool) {\n        uint256 len = pools.length;\n        for (uint256 i; i < len; ) {\n            if (balancerPool_ == address(pools[i].balancerPool)) {\n                return true;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return false;\n    }\n\n    /// @notice         Get the reserves of a Balancer/Aura pool pair\n    /// @dev            The calling function is responsible for protecting against re-entrancy.\n    ///\n    /// @param pool     Balancer/Aura pool pair\n    /// @return         Reserves of the pool\n    function _getReserves(Pool storage pool) internal view returns (SPPLYv1.Reserves memory) {\n        // Get the balancer pool token balance of the manager\n        uint256 balBalance = pool.balancerPool.balanceOf(polManager);\n        // If an aura pool is defined, get the underlying balance and add to the balancer pool balance before adding to the total POL supply\n        // We don't have to do a ERC4626 shares to assets conversion because aura pools are all 1:1 with balancer pool balances\n        if (address(pool.auraPool) != address(0)) balBalance += pool.auraPool.balanceOf(polManager);\n\n        // Get the pool tokens and total balances of the pool\n        (address[] memory _vaultTokens, uint256[] memory _vaultBalances, ) = balVault.getPoolTokens(\n            pool.balancerPool.getPoolId()\n        );\n\n        // Get the total supply of the balancer pool\n        uint256 balTotalSupply = pool.balancerPool.totalSupply();\n        uint256[] memory balances = new uint256[](_vaultTokens.length);\n        // Calculate the proportion of the pool balances owned by the polManager\n        if (balTotalSupply != 0) {\n            // Calculate the amount of OHM in the pool owned by the polManager\n            // We have to iterate through the tokens array to find the index of OHM\n            uint256 tokenLen = _vaultTokens.length;\n            for (uint256 i; i < tokenLen; ) {\n                uint256 balance = _vaultBalances[i];\n                uint256 polBalance = (balance * balBalance) / balTotalSupply;\n\n                balances[i] = polBalance;\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        SPPLYv1.Reserves memory reserves;\n        reserves.source = address(pool.balancerPool);\n        reserves.tokens = _vaultTokens;\n        reserves.balances = balances;\n        return reserves;\n    }\n}"
    },
    {
      "filename": "bophades/src/modules/SPPLY/submodules/AuraBalancerSupply.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\n// Balancer\nimport {IBalancerPool} from \"src/external/balancer/interfaces/IBalancerPool.sol\";\nimport {IVault} from \"src/libraries/Balancer/interfaces/IVault.sol\";\nimport {IAuraRewardPool} from \"src/external/aura/interfaces/IAuraRewardPool.sol\";\nimport {VaultReentrancyLib} from \"src/libraries/Balancer/contracts/VaultReentrancyLib.sol\";\n\n// Bophades Modules\nimport \"modules/SPPLY/SPPLY.v1.sol\";\n\n/// @title      AuraBalancerSupply\n/// @author     Oighty\n/// @notice     Calculates the amount of protocol-owned liquidity OHM in Balancer pools, including BPTs staked in Aura\ncontract AuraBalancerSupply is SupplySubmodule {\n    // Requirements\n    // [X] Determine the amount of protocol-owned liquidity OHM in Balancer pools, including BPTs staked in Aura\n    // Math:\n    // Protocol deposits OHM-TKN liquidity into a balancer pool.\n    // The protocol may stake the liquidity pool tokens in Aura.\n    // Let X be the amount of BPT tokens held by the POL manager.\n    // Let Y be the amount of Aura BPT tokens held by the POL manager.\n    // Aura BPT tokens are 1:1 with BPT token balances.\n    // Then, A = X + Y is the total amount of BPT tokens held by the POL manager.\n    // If there are B BPT tokens in circulation, then the protocol owns A/B of the pool.\n    // If there are C OHM tokens in the pool, then the protocol owns (A/B) * C of the OHM in the pool.\n    // Therefore,\n    // Protocol-owned Borrowable OHM = 0\n    // Collateralized OHM = 0\n    // Protocol-owned Liquidity OHM = (A/B) * C\n\n    // ========== ERRORS ========== //\n\n    /// @notice The Balancer pool and Aura pool have differing assets\n    error AuraBalSupply_PoolMismatch();\n\n    /// @notice The parameters provided are invalid. This is usually due to a zero address.\n    error AuraBalSupply_InvalidParams();\n\n    /// @notice                 The pool is already added\n    /// @param balancerPool     Address of the Balancer pool\n    /// @param auraPool         Address of the Aura pool\n    error AuraBalSupply_PoolAlreadyAdded(address balancerPool, address auraPool);\n\n    // ========== EVENTS ========== //\n\n    /// @notice             Emitted when a pool is added\n    /// @param balancerPool Address of the Balancer pool\n    /// @param auraPool     Address of the Aura pool\n    event PoolAdded(address balancerPool, address auraPool);\n\n    /// @notice             Emitted when a pool is removed\n    /// @param balancerPool Address of the Balancer pool\n    /// @param auraPool     Address of the Aura pool\n    event PoolRemoved(address balancerPool, address auraPool);\n\n    // ========== STATE VARIABLES ========== //\n\n    /// @notice         Struct that represents a Balancer/Aura pool pair\n    struct Pool {\n        /// @notice     Balancer pool\n        IBalancerPool balancerPool;\n        /// @notice     Aura pool. Optional.\n        IAuraRewardPool auraPool;\n    }\n\n    /// @notice     Address of the POL manager.\n    address public immutable polManager;\n\n    /// @notice     Address of the OHM token. Cached at contract creation.\n    address internal immutable ohm;\n\n    /// @notice     Address of the Balancer Vault. Cached at contract creation.\n    IVault public immutable balVault;\n\n    /// @notice     Array of Balancer/Aura pool pairs.\n    /// @dev        The pools can be added and removed using the `addPool()` and `removePool()` functions.\n    Pool[] public pools;\n\n    // ========== CONSTRUCTOR ========== //\n\n    /// @notice             Constructor for the AuraBalancerSupply submodule\n    /// @dev                Will revert if:\n    /// @dev                - The `polManager_` address is 0\n    /// @dev                - The `balVault_` address is 0\n    /// @dev                - There is an invalid entry in the `pools_` array (see `addPool()`)\n    /// @dev                - Calling the `Submodule` constructor fails\n    ///\n    /// @param parent_      Address of the parent contract, the SPPLY module\n    /// @param polManager_  Address of the POL manager\n    /// @param balVault_    Address of the Balancer vault\n    /// @param pools_       Array of Balancer/Aura pool pairs\n    constructor(\n        Module parent_,\n        address polManager_,\n        address balVault_,\n        Pool[] memory pools_\n    ) Submodule(parent_) {\n        // Check that the parameters are valid\n        if (polManager_ == address(0) || balVault_ == address(0))\n            revert AuraBalSupply_InvalidParams();\n\n        polManager = polManager_;\n        balVault = IVault(balVault_);\n        ohm = address(SPPLYv1(address(parent_)).ohm());\n\n        // Iterate through the pools and add them to the array\n        // Check that the aura pool is for the associated balancer pool unless it is blank\n        uint256 len = pools_.length;\n        for (uint256 i; i < len; i++) {\n            // Don't add address 0\n            if (address(pools_[i].balancerPool) == address(0)) revert AuraBalSupply_InvalidParams();\n\n            // Balancer pool must be the asset of the Aura pool\n            if (\n                address(pools_[i].auraPool) != address(0) &&\n                address(pools_[i].balancerPool) != pools_[i].auraPool.asset()\n            ) {\n                revert AuraBalSupply_PoolMismatch();\n            }\n\n            // Don't add twice\n            if (_inArray(address(pools_[i].balancerPool)))\n                revert AuraBalSupply_PoolAlreadyAdded(\n                    address(pools_[i].balancerPool),\n                    address(pools_[i].auraPool)\n                );\n\n            pools.push(pools_[i]);\n            emit PoolAdded(address(pools_[i].balancerPool), address(pools_[i].auraPool));\n        }\n    }\n\n    // ========== SUBMODULE SETUP ========== //\n\n    /// @inheritdoc Submodule\n    function SUBKEYCODE() public pure override returns (SubKeycode) {\n        return toSubKeycode(\"SPPLY.AURABALANCER\");\n    }\n\n    /// @inheritdoc Submodule\n    function VERSION() external pure override returns (uint8 major, uint8 minor) {\n        major = 1;\n        minor = 0;\n    }\n\n    /// @inheritdoc Submodule\n    function INIT() external override onlyParent {}\n\n    // ========== DATA FUNCTIONS ========== //\n\n    /// @inheritdoc SupplySubmodule\n    /// @dev        Collateralized OHM is always zero for liquidity pools\n    function getCollateralizedOhm() external pure override returns (uint256) {\n        // Collateralized OHM is zero for liquidity pools (except BLV, which is a different module)\n        return 0;\n    }\n\n    /// @inheritdoc SupplySubmodule\n    /// @dev        Protocol-owned borrowable OHM is always zero for liquidity pools\n    function getProtocolOwnedBorrowableOhm() external pure override returns (uint256) {\n        // POBO is zero for liquidity pools\n        return 0;\n    }\n\n    /// @inheritdoc SupplySubmodule\n    /// @dev        Protocol-owned liquidity OHM is calculated as the sum of the protocol-owned OHM in each pool\n    ///\n    /// @dev        This function accesses the reserves of the monitored pools.\n    /// @dev        In order to protect against re-entrancy attacks,\n    /// @dev        it utilises the Balancer VaultReentrancyLib.\n    function getProtocolOwnedLiquidityOhm() external view override returns (uint256) {\n        // Prevent re-entrancy attacks\n        VaultReentrancyLib.ensureNotInVaultContext(balVault);\n\n        // Iterate through the pools and get the POL supply from each\n        uint256 supply;\n        uint256 len = pools.length;\n        for (uint256 i; i < len; ) {\n            SPPLYv1.Reserves memory reserve = _getReserves(pools[i]);\n\n            // Iterate over the tokens and add the OHM balance to the total POL supply\n            uint256 tokenLen = reserve.tokens.length;\n            for (uint256 j; j < tokenLen; ) {\n                if (reserve.tokens[j] == ohm) {\n                    supply += reserve.balances[j];\n                    break;\n                }\n                unchecked {\n                    ++j;\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return supply;\n    }\n\n    /// @inheritdoc SupplySubmodule\n    function getProtocolOwnedTreasuryOhm() external pure override returns (uint256) {\n        // POTO is always zero for liquidity pools\n        return 0;\n    }\n\n    /// @inheritdoc SupplySubmodule\n    /// @dev        This function accesses the reserves of the monitored pools.\n    /// @dev        In order to protect against re-entrancy attacks,\n    /// @dev        it utilises the Balancer VaultReentrancyLib.\n    function getProtocolOwnedLiquidityReserves()\n        external\n        view\n        override\n        returns (SPPLYv1.Reserves[] memory)\n    {\n        // Prevent re-entrancy attacks\n        VaultReentrancyLib.ensureNotInVaultContext(balVault);\n\n        // Iterate through tokens and add the reserves of each pool\n        uint256 len = pools.length;\n        SPPLYv1.Reserves[] memory reserves = new SPPLYv1.Reserves[](len);\n        for (uint256 i; i < len; ) {\n            SPPLYv1.Reserves memory reserve = _getReserves(pools[i]);\n            reserves[i] = reserve;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return reserves;\n    }\n\n    /// @inheritdoc SupplySubmodule\n    function getSourceCount() external view override returns (uint256) {\n        return pools.length;\n    }\n\n    /// @notice Get the list of configured pools\n    /// @return Array of Balancer/Aura pool pairs\n    function getPools() external view returns (Pool[] memory) {\n        return pools;\n    }\n\n    // =========== ADMIN FUNCTIONS =========== //\n\n    /// @notice                 Add a Balancer/Aura Pool pair to the list of pools\n    /// @dev                    Will revert if:\n    /// @dev                    - The `balancerPool_` address is 0\n    /// @dev                    - The `balancerPool_` address is already added\n    /// @dev                    - The `balancerPool_` address is not the asset of the specified Aura pool\n    /// @dev                    - The caller is not the parent module\n    ///\n    /// @param balancerPool_    Address of the Balancer pool\n    /// @param auraPool_        Address of the Aura pool\n    function addPool(address balancerPool_, address auraPool_) external onlyParent {\n        // Don't add address 0\n        if (balancerPool_ == address(0)) revert AuraBalSupply_InvalidParams();\n\n        // Check that the pool isn't already added\n        if (_inArray(balancerPool_))\n            revert AuraBalSupply_PoolAlreadyAdded(balancerPool_, auraPool_);\n\n        // Check that the aura pool is for the associated balancer pool unless it is blank\n        if (address(auraPool_) != address(0) && balancerPool_ != IAuraRewardPool(auraPool_).asset())\n            revert AuraBalSupply_PoolMismatch();\n\n        // Add the pool to the array\n        pools.push(\n            Pool({balancerPool: IBalancerPool(balancerPool_), auraPool: IAuraRewardPool(auraPool_)})\n        );\n\n        emit PoolAdded(balancerPool_, auraPool_);\n    }\n\n    /// @notice                 Remove a Balancer/Aura Pool pair from the list of pools\n    /// @dev                    Will revert if:\n    /// @dev                    - The `balancerPool_` address is 0\n    /// @dev                    - The `balancerPool_` address is not already added\n    /// @dev                    - The caller is not the parent module\n    ///\n    /// @param balancerPool_    Address of the Balancer pool\n    function removePool(address balancerPool_) external onlyParent {\n        // Ignore address 0\n        if (balancerPool_ == address(0)) revert AuraBalSupply_InvalidParams();\n\n        // Check that the pool is present\n        if (!_inArray(balancerPool_)) revert AuraBalSupply_InvalidParams();\n\n        uint256 len = pools.length;\n        for (uint256 i; i < len; ) {\n            if (balancerPool_ == address(pools[i].balancerPool)) {\n                address auraPool = address(pools[i].auraPool);\n                pools[i] = pools[len - 1];\n                pools.pop();\n                emit PoolRemoved(balancerPool_, auraPool);\n                return;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    // =========== HELPER FUNCTIONS =========== //\n\n    /// @notice     Determines if `balancerPool_` is contained in the `pools` array\n    ///\n    /// @param      balancerPool_ Address of the Balancer pool\n    /// @return     True if the pool is present, false otherwise\n    function _inArray(address balancerPool_) internal view returns (bool) {\n        uint256 len = pools.length;\n        for (uint256 i; i < len; ) {\n            if (balancerPool_ == address(pools[i].balancerPool)) {\n                return true;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return false;\n    }\n\n    /// @notice         Get the reserves of a Balancer/Aura pool pair\n    /// @dev            The calling function is responsible for protecting against re-entrancy.\n    ///\n    /// @param pool     Balancer/Aura pool pair\n    /// @return         Reserves of the pool\n    function _getReserves(Pool storage pool) internal view returns (SPPLYv1.Reserves memory) {\n        // Get the balancer pool token balance of the manager\n        uint256 balBalance = pool.balancerPool.balanceOf(polManager);\n        // If an aura pool is defined, get the underlying balance and add to the balancer pool balance before adding to the total POL supply\n        // We don't have to do a ERC4626 shares to assets conversion because aura pools are all 1:1 with balancer pool balances\n        if (address(pool.auraPool) != address(0)) balBalance += pool.auraPool.balanceOf(polManager);\n\n        // Get the pool tokens and total balances of the pool\n        (address[] memory _vaultTokens, uint256[] memory _vaultBalances, ) = balVault.getPoolTokens(\n            pool.balancerPool.getPoolId()\n        );\n\n        // Get the total supply of the balancer pool\n        uint256 balTotalSupply = pool.balancerPool.totalSupply();\n        uint256[] memory balances = new uint256[](_vaultTokens.length);\n        // Calculate the proportion of the pool balances owned by the polManager\n        if (balTotalSupply != 0) {\n            // Calculate the amount of OHM in the pool owned by the polManager\n            // We have to iterate through the tokens array to find the index of OHM\n            uint256 tokenLen = _vaultTokens.length;\n            for (uint256 i; i < tokenLen; ) {\n                uint256 balance = _vaultBalances[i];\n                uint256 polBalance = (balance * balBalance) / balTotalSupply;\n\n                balances[i] = polBalance;\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        SPPLYv1.Reserves memory reserves;\n        reserves.source = address(pool.balancerPool);\n        reserves.tokens = _vaultTokens;\n        reserves.balances = balances;\n        return reserves;\n    }\n}"
    }
  ]
}