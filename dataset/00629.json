{
  "Title": "H-6: Malicious keepers can manipulate the price when executing an order",
  "Content": "# Issue H-6: Malicious keepers can manipulate the price when executing an order \n\nSource: https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/194 \n\n## Found by \nLTDingZhen, nobody2018, xiaoming90\n## Summary\n\nMalicious keepers can manipulate the price when executing an order by selecting a price in favor of either the LPs or long traders, leading to a loss of assets to the victim's party.\n\n## Vulnerability Detail\n\nWhen the keeper executes an order, it was understood from the protocol team that the protocol expects that the keeper must also update the Pyth price to the latest one available off-chain. In addition, the [contest page](https://github.com/sherlock-audit/2023-12-flatmoney-xiaoming9090?tab=readme-ov-file#q-are-there-any-off-chain-mechanisms-or-off-chain-procedures-for-the-protocol-keeper-bots-input-validation-expectations-etc) mentioned that \"an offchain price that is pulled by the keeper and pushed onchain at time of any order execution\".\n\nThis requirement must be enforced to ensure that the latest price is always used.\n\nhttps://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/DelayedOrder.sol#L386\n\n```solidity\nFile: DelayedOrder.sol\n378:     function executeOrder(\n379:         address account,\n380:         bytes[] calldata priceUpdateData\n381:     )\n382:         external\n383:         payable\n384:         nonReentrant\n385:         whenNotPaused\n386:         updatePythPrice(vault, msg.sender, priceUpdateData)\n387:         orderInvariantChecks(vault)\n388:     {\n389:         // Settle funding fees before executing any order.\n390:         // This is to avoid error related to max caps or max skew reached when the market has been skewed to one side for a long time.\n391:         // This is more important in case the we allow for limit orders in the future.\n392:         vault.settleFundingFees();\n..SNIP..\n410:     }\n```\n\nHowever, this requirement can be bypassed by malicious keepers. A keeper could skip or avoid the updating of the Pyth price by passing in an empty `priceUpdateData` array, which will pass the empty array to the `OracleModule.updatePythPrice` function.\n\nhttps://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/abstracts/OracleModifiers.sol#L12\n\n```solidity\nFile: OracleModifiers.sol\n10:     /// @dev Important to use this modifier in functions which require the Pyth network price to be updated.\n11:     ///      Otherwise, the invariant checks or any other logic which depends on the Pyth network price may not be correct.\n12:     modifier updatePythPrice(\n13:         IFlatcoinVault vault,\n14:         address sender,\n15:         bytes[] calldata priceUpdateData\n16:     ) {\n17:         IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).updatePythPrice{value: msg.value}(\n18:             sender,\n19:             priceUpdateData\n20:         );\n21:         _;\n22:     }\n```\n\nWhen the Pyth's `Pyth.updatePriceFeeds` function is executed, the `updateData` parameter will be set to an empty array.\n\nhttps://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/OracleModule.sol#L64\n\n```solidity\nFile: OracleModule.sol\n64:     function updatePythPrice(address sender, bytes[] calldata priceUpdateData) external payable nonReentrant {\n65:         // Get fee amount to pay to Pyth\n66:         uint256 fee = offchainOracle.oracleContract.getUpdateFee(priceUpdateData);\n67: \n68:         // Update the price data (and pay the fee)\n69:         offchainOracle.oracleContract.updatePriceFeeds{value: fee}(priceUpdateData);\n70: \n71:         if (msg.value - fee > 0) {\n72:             // Need to refund caller. Try to return unused value, or revert if failed\n73:             (bool success, ) = sender.call{value: msg.value - fee}(\"\");\n74:             if (success == false) revert FlatcoinErrors.RefundFailed();\n75:         }\n76:     }\n```\n\nInspecting the source code of Pyth's on-chain contract, the [`Pyth.updatePriceFeeds`](https://goerli.basescan.org/address/0xf5bbe9558f4bf37f1eb82fb2cedb1c775fa56832#code#F24#L75) function will not perform any update since the `updateData.length` will be zero in this instance.\n\nhttps://goerli.basescan.org/address/0xf5bbe9558f4bf37f1eb82fb2cedb1c775fa56832#code#F24#L75\n\n```solidity\nfunction updatePriceFeeds(\n    bytes[] calldata updateData\n) public payable override {\n    uint totalNumUpdates = 0;\n    for (uint i = 0; i < updateData.length; ) {\n        if (\n            updateData[i].length > 4 &&\n            UnsafeCalldataBytesLib.toUint32(updateData[i], 0) ==\n            ACCUMULATOR_MAGIC\n        ) {\n            totalNumUpdates += updatePriceInfosFromAccumulatorUpdate(\n                updateData[i]\n            );\n        } else {\n            updatePriceBatchFromVm(updateData[i]);\n            totalNumUpdates += 1;\n        }\n\n        unchecked {\n            i++;\n        }\n    }\n    uint requiredFee = getTotalFee(totalNumUpdates);\n    if (msg.value < requiredFee) revert PythErrors.InsufficientFee();\n}\n```\n\nThe keeper is permissionless, thus anyone can be a keeper and execute order on the protocol. If this requirement is not enforced, keepers who might also be LPs (or collude with LPs) can choose whether to update the Pyth price to the latest price or not, depending on whether the updated price is in favor of the LPs. For instance, if the existing on-chain price (\\$1000 per ETH) is higher than the latest off-chain price (\\$950 per ETH), malicious keepers will use the higher price of \\$1000 to open the trader's long position so that its position's entry price will be set to a higher price of \\$1000. When the latest price of \\$950 gets updated, the longer position will immediately incur a loss of \\$50. Since this is a zero-sum game, long traders' loss is LPs' gain.\n\nNote that per the current design, when the open long position order is executed at $T2$, any price data with a timestamp between $T1$ and $T2$ is considered valid and can be used within the `executeOpen` function to execute an open order. Thus, when the malicious keeper uses an up-to-date price stored in Pyth's on-chain contract, it will not revert as long as its timestamp is on or after $T1$.\n\n![image](https://github.com/sherlock-audit/2023-12-flatmoney-xiaoming9090/assets/102820284/8ca41703-96c6-4cfe-bfc5-161f59ecaddf)\n\nAlternatively, it is also possible for the opposite scenario to happen where the keepers favor the long traders and choose to use a lower older price on-chain to execute the order instead of using the latest higher price. As such, the long trader's position will be immediately profitable after the price update. In this case, the LPs are on the losing end.\n\nSidenote: The oracle's `maxDiffPercent` check will not guard against this attack effectively. For instance, in the above example, if the Chainlink price is \\$975 and the `maxDiffPercent` is 5%, the Pyth price of \\$950 or \\$1000 still falls within the acceptable range. If the `maxDiffPercent` is reduced to a smaller margin, it will potentially lead to a more serious issue where all the transactions get reverted when fetching the price, breaking the entire protocol.\n\n## Impact\n\nLoss of assets as shown in the scenario above.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/DelayedOrder.sol#L386\n\nhttps://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/abstracts/OracleModifiers.sol#L12\n\nhttps://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/OracleModule.sol#L64\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nEnsure that the keepers must update the Pyth price when executing an order. Perform additional checks against the `priceUpdateData` submitted by the keepers to ensure that it is not empty and `priceId` within the `PriceInfo` matches the price ID of the collateral (rETH), so as to prevent malicious keeper from bypassing the price update by passing in an empty array or price update data that is not mapped to the collateral (rETH).\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  invalid\n\n\n\n**rashtrakoff**\n\nI don't believe this is an issue due to the check for price freshness [here](https://github.com/dhedge/flatcoin-v1/blob/ea561f48bd9eae11895fc5e4f476abe909d8a634/src/OracleModule.sol#L131). However we can probably implement the suggestion for more protection.\n\n**nevillehuang**\n\n@rashtrakoff If I understand correctly, as long as freshness of price does not exceed `maxAge`, it is an accepted updated price, if not it will revert, hence making this issue invalid.\n\n**nevillehuang**\n\nHi @rashtrakoff here is LSW comments, which seems valid to me.\n\n> The check at Line 111 basically checks for deviation between the on-chain and off-chain price deviation. If the two prices deviate by a certain percentage `maxDiffPercent` (I recall the test or deployment script set it as 5%), the TX will revert.\n\n> However, it is incorrect that this check will prevent this issue. I expected that the sponsor might assume that this check might prevent this issue during the audit. Thus, in the report (at the end of the \"Vulnerability Detail\"), I have documented the reasons why this oracle check would not help to prevent this issue, and the example and numbers in the report are specially selected to work within the 5% price deviation ðŸ™‚\n\n> Sidenote: The oracle's maxDiffPercent check will not guard against this attack effectively. For instance, in the above example, if the Chainlink price is $975 and the maxDiffPercent is 5%, the Pyth price of $950 or $1000 still falls within the acceptable range. If the maxDiffPercent is reduced to a smaller margin, it will potentially lead to a more serious issue where all the transactions get reverted when fetching the price, breaking the entire protocol.\n\n**sherlock-admin**\n\nThe protocol team fixed this issue in PR/commit https://github.com/dhedge/flatcoin-v1/pull/277.\n\n**0xLogos**\n\nEscalate\n\nLow (med at best)\n\nOracle's prices discrepancy should be within trader fee charged. \n\n**sherlock-admin2**\n\n> Escalate\n> \n> Low (med at best)\n> \n> Oracle's prices discrepancy should be within trader fee charged. \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**xiaoming9090**\n\n> Escalate\n> \n> Low (med at best)\n> \n> Oracle's prices discrepancy should be within trader fee charged.\n\nThe escalation is invalid.\n\nThe report's sidenote and my comment shared by the lead judge have explained why the existing price deviation control does not prevent this attack.\n\n**Czar102**\n\nI agree with @xiaoming9090, I don't see a valid point in the escalation.\n\nPlanning to reject the escalation and leave the issue as is.\n\n**nevillehuang**\n\nAgree with @xiaoming9090 and @Czar102 \n\n**Czar102**\n\nResult:\nHigh\nHas duplicates\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0xLogos](https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/194/#issuecomment-1956855342): rejected\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/132",
  "Code": [
    {
      "filename": "flatcoin-v1/src/DelayedOrder.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\n\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/contracts/interfaces/IERC20Upgradeable.sol\";\nimport {SignedMath} from \"openzeppelin-contracts/contracts/utils/math/SignedMath.sol\";\n\nimport {FlatcoinStructs} from \"./libraries/FlatcoinStructs.sol\";\nimport {FlatcoinErrors} from \"./libraries/FlatcoinErrors.sol\";\nimport {FlatcoinModuleKeys} from \"./libraries/FlatcoinModuleKeys.sol\";\nimport {FlatcoinEvents} from \"./libraries/FlatcoinEvents.sol\";\nimport {ModuleUpgradeable} from \"./abstracts/ModuleUpgradeable.sol\";\nimport {OracleModifiers} from \"./abstracts/OracleModifiers.sol\";\nimport {InvariantChecks} from \"./misc/InvariantChecks.sol\";\n\nimport {IDelayedOrder} from \"./interfaces/IDelayedOrder.sol\";\nimport {IFlatcoinVault} from \"./interfaces/IFlatcoinVault.sol\";\nimport {ILeverageModule} from \"./interfaces/ILeverageModule.sol\";\nimport {IStableModule} from \"./interfaces/IStableModule.sol\";\nimport {IOracleModule} from \"./interfaces/IOracleModule.sol\";\nimport {ILiquidationModule} from \"./interfaces/ILiquidationModule.sol\";\nimport {IKeeperFee} from \"./interfaces/IKeeperFee.sol\";\n\n/// @title DelayedOrder\n/// @author dHEDGE\n/// @notice Contains functions to announce and execute delayed orders.\ncontract DelayedOrder is\n    IDelayedOrder,\n    ModuleUpgradeable,\n    ReentrancyGuardUpgradeable,\n    InvariantChecks,\n    OracleModifiers\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeERC20Upgradeable for IStableModule;\n    using SignedMath for int256;\n\n    /// @notice Minimum deposit amount for stable LP collateral.\n    uint256 public constant MIN_DEPOSIT = 1e6;\n\n    /// @dev Mapping containing all the orders in an encoded format.\n    mapping(address account => FlatcoinStructs.Order order) private _announcedOrder;\n\n    /// @dev To prevent the implementation contract from being used, we invoke the _disableInitializers\n    /// function in the constructor to automatically lock it when it is deployed.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Function to initialize this contract.\n    function initialize(IFlatcoinVault _vault) external initializer {\n        __Module_init(FlatcoinModuleKeys._DELAYED_ORDER_KEY, _vault);\n        __ReentrancyGuard_init();\n    }\n\n    /////////////////////////////////////////////\n    //         Announcement Functions          //\n    /////////////////////////////////////////////\n\n    /// @notice Announces deposit intent for keepers to execute at offchain oracle price.\n    /// @dev The deposit amount is taken plus the keeper fee.\n    /// @param depositAmount The amount of collateral to deposit.\n    /// @param minAmountOut The minimum amount of tokens the user expects to receive back.\n    /// @param keeperFee The fee the user is paying for keeper transaction execution (in collateral tokens).\n    function announceStableDeposit(\n        uint256 depositAmount,\n        uint256 minAmountOut,\n        uint256 keeperFee\n    ) external whenNotPaused {\n        uint64 executableAtTime = _prepareAnnouncementOrder(keeperFee);\n\n        vault.checkCollateralCap(depositAmount);\n\n        if (depositAmount < MIN_DEPOSIT)\n            revert FlatcoinErrors.AmountTooSmall({amount: depositAmount, minAmount: MIN_DEPOSIT});\n\n        // Check that the requested minAmountOut is feasible\n        uint256 quotedAmount = IStableModule(vault.moduleAddress(FlatcoinModuleKeys._STABLE_MODULE_KEY))\n            .stableDepositQuote(depositAmount);\n\n        if (quotedAmount < minAmountOut) revert FlatcoinErrors.HighSlippage(quotedAmount, minAmountOut);\n\n        _announcedOrder[msg.sender] = FlatcoinStructs.Order({\n            orderType: FlatcoinStructs.OrderType.StableDeposit,\n            orderData: abi.encode(\n                FlatcoinStructs.AnnouncedStableDeposit({depositAmount: depositAmount, minAmountOut: minAmountOut})\n            ),\n            keeperFee: keeperFee,\n            executableAtTime: executableAtTime\n        });\n\n        // Sends collateral to the delayed order contract first before it is settled by keepers and sent to the vault\n        vault.collateral().safeTransferFrom(msg.sender, address(this), depositAmount + keeperFee);\n\n        emit FlatcoinEvents.OrderAnnounced({\n            account: msg.sender,\n            orderType: FlatcoinStructs.OrderType.StableDeposit,\n            keeperFee: keeperFee\n        });\n    }\n\n    /// @notice Announces withdrawal intent for keepers to execute at offchain oracle price.\n    /// @dev The deposit amount is taken plus the keeper fee, also in LP tokens.\n    /// @param withdrawAmount The amount to withdraw in stable LP tokens.\n    /// @param minAmountOut The minimum amount of underlying asset tokens the user expects to receive back.\n    /// @param keeperFee The fee the user is paying for keeper transaction execution (in stable LP tokens).\n    function announceStableWithdraw(\n        uint256 withdrawAmount,\n        uint256 minAmountOut,\n        uint256 keeperFee\n    ) external whenNotPaused {\n        uint64 executableAtTime = _prepareAnnouncementOrder(keeperFee);\n\n        IStableModule stableModule = IStableModule(vault.moduleAddress(FlatcoinModuleKeys._STABLE_MODULE_KEY));\n        uint256 lpBalance = IERC20Upgradeable(stableModule).balanceOf(msg.sender);\n\n        if (lpBalance < withdrawAmount)\n            revert FlatcoinErrors.NotEnoughBalanceForWithdraw(msg.sender, lpBalance, withdrawAmount);\n\n        // Check that the requested minAmountOut is feasible\n        {\n            uint256 expectedAmountOut = stableModule.stableWithdrawQuote(withdrawAmount);\n\n            if (keeperFee > expectedAmountOut) revert FlatcoinErrors.WithdrawalTooSmall(expectedAmountOut, keeperFee);\n\n            expectedAmountOut -= keeperFee;\n\n            if (expectedAmountOut < minAmountOut) revert FlatcoinErrors.HighSlippage(expectedAmountOut, minAmountOut);\n\n            vault.checkSkewMax({additionalSkew: expectedAmountOut});\n        }\n\n        _announcedOrder[msg.sender] = FlatcoinStructs.Order({\n            orderType: FlatcoinStructs.OrderType.StableWithdraw,\n            orderData: abi.encode(\n                FlatcoinStructs.AnnouncedStableWithdraw({withdrawAmount: withdrawAmount, minAmountOut: minAmountOut})\n            ),\n            keeperFee: keeperFee,\n            executableAtTime: executableAtTime\n        });\n\n        // Lock the LP tokens belonging to this position so that it can't be transferred to someone else.\n        // Locking doesn't require an approval from an account.\n        stableModule.lock({account: msg.sender, amount: withdrawAmount});\n\n        emit FlatcoinEvents.OrderAnnounced({\n            account: msg.sender,\n            orderType: FlatcoinStructs.OrderType.StableWithdraw,\n            keeperFee: keeperFee\n        });\n    }\n\n    /// @notice Announces leverage open intent for keepers to execute at offchain oracle price.\n    /// @param margin The amount of collateral to deposit.\n    /// @param additionalSize The amount of additional size to open.\n    /// @param maxFillPrice The maximum price at which the trade can be executed.\n    /// @param keeperFee The fee the user is paying for keeper transaction execution (in collateral tokens).\n    function announceLeverageOpen(\n        uint256 margin,\n        uint256 additionalSize,\n        uint256 maxFillPrice,\n        uint256 keeperFee\n    ) external whenNotPaused {\n        ILeverageModule leverageModule = ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY));\n\n        uint64 executableAtTime = _prepareAnnouncementOrder(keeperFee);\n\n        vault.checkSkewMax({additionalSkew: additionalSize});\n\n        leverageModule.checkLeverageCriteria(margin, additionalSize);\n\n        (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice();\n\n        if (maxFillPrice < currentPrice) revert FlatcoinErrors.MaxFillPriceTooLow(maxFillPrice, currentPrice);\n\n        uint256 tradeFee = leverageModule.getTradeFee(additionalSize);\n\n        if (\n            ILiquidationModule(vault.moduleAddress(FlatcoinModuleKeys._LIQUIDATION_MODULE_KEY)).getLiquidationMargin(\n                additionalSize,\n                maxFillPrice\n            ) >= margin\n        ) revert FlatcoinErrors.PositionCreatesBadDebt();\n\n        _announcedOrder[msg.sender] = FlatcoinStructs.Order({\n            orderType: FlatcoinStructs.OrderType.LeverageOpen,\n            orderData: abi.encode(\n                FlatcoinStructs.AnnouncedLeverageOpen({\n                    margin: margin,\n                    additionalSize: additionalSize,\n                    maxFillPrice: maxFillPrice,\n                    tradeFee: tradeFee\n                })\n            ),\n            keeperFee: keeperFee,\n            executableAtTime: executableAtTime\n        });\n\n        // Sends collateral to the delayed order contract first before it is settled by keepers and sent to the vault\n        vault.collateral().safeTransferFrom(msg.sender, address(this), margin + keeperFee + tradeFee);\n\n        emit FlatcoinEvents.OrderAnnounced({\n            account: msg.sender,\n            orderType: FlatcoinStructs.OrderType.LeverageOpen,\n            keeperFee: keeperFee\n        });\n    }\n\n    /// @notice Announces leverage adjust intent for keepers to execute at offchain oracle price.\n    /// @param tokenId The ERC721 token ID of the position.\n    /// @param marginAdjustment The amount of margin to deposit or withdraw.\n    /// @param additionalSizeAdjustment The amount of additional size to increase or decrease.\n    /// @param fillPrice The price at which the trade can be executed.\n    /// @param keeperFee The fee the user is paying for keeper transaction execution (in collateral tokens).\n    function announceLeverageAdjust(\n        uint256 tokenId,\n        int256 marginAdjustment,\n        int256 additionalSizeAdjustment,\n        uint256 fillPrice,\n        uint256 keeperFee\n    ) external whenNotPaused {\n        uint64 executableAtTime = _prepareAnnouncementOrder(keeperFee);\n\n        // If both adjustable parameters are zero, there is nothing to adjust\n        if (marginAdjustment == 0 && additionalSizeAdjustment == 0)\n            revert FlatcoinErrors.ZeroValue(\"marginAdjustment|additionalSizeAdjustment\");\n\n        ILeverageModule leverageModule = ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY));\n\n        // Check that the caller is the owner of the token\n        if (leverageModule.ownerOf(tokenId) != msg.sender) revert FlatcoinErrors.NotTokenOwner(tokenId, msg.sender);\n\n        // Trade fee is calculated based on additional size change\n        uint256 totalFee;\n        {\n            uint256 tradeFee;\n            (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY))\n                .getPrice();\n\n            // Means increasing or decreasing additional size\n            if (additionalSizeAdjustment >= 0) {\n                // If additionalSizeAdjustment equals zero, trade fee is zero as well\n                tradeFee = leverageModule.getTradeFee(uint256(additionalSizeAdjustment));\n                vault.checkSkewMax(uint256(additionalSizeAdjustment));\n\n                if (fillPrice < currentPrice) revert FlatcoinErrors.MaxFillPriceTooLow(fillPrice, currentPrice);\n            } else {\n                tradeFee = leverageModule.getTradeFee(uint256(additionalSizeAdjustment * -1));\n\n                if (fillPrice > currentPrice) revert FlatcoinErrors.MinFillPriceTooHigh(fillPrice, currentPrice);\n            }\n\n            totalFee = tradeFee + keeperFee;\n        }\n\n        {\n            // New additional size will be either bigger or smaller than current additional size\n            // depends on if additionalSizeAdjustment is positive or negative.\n            int256 newAdditionalSize = int256(vault.getPosition(tokenId).additionalSize) + additionalSizeAdjustment;\n\n            // If user withdraws margin or changes additional size with no changes to margin, fees are charged from their existing margin.\n            int256 newMarginAfterSettlement = leverageModule.getPositionSummary(tokenId).marginAfterSettlement +\n                ((marginAdjustment > 0) ? marginAdjustment : marginAdjustment - int256(totalFee));\n\n            // New margin or size can't be negative, which means that they want to withdraw more than they deposited or not enough to pay the fees\n            if (newMarginAfterSettlement < 0 || newAdditionalSize < 0)\n                revert FlatcoinErrors.ValueNotPositive(\"newMarginAfterSettlement|newAdditionalSize\");\n\n            if (\n                ILiquidationModule(vault.moduleAddress(FlatcoinModuleKeys._LIQUIDATION_MODULE_KEY))\n                    .getLiquidationMargin(uint256(newAdditionalSize), fillPrice) >= uint256(newMarginAfterSettlement)\n            ) revert FlatcoinErrors.PositionCreatesBadDebt();\n\n            // New values can't be less than min margin and min/max leverage requirements.\n            leverageModule.checkLeverageCriteria(uint256(newMarginAfterSettlement), uint256(newAdditionalSize));\n        }\n\n        _announcedOrder[msg.sender] = FlatcoinStructs.Order({\n            orderType: FlatcoinStructs.OrderType.LeverageAdjust,\n            orderData: abi.encode(\n                FlatcoinStructs.AnnouncedLeverageAdjust({\n                    tokenId: tokenId,\n                    marginAdjustment: marginAdjustment,\n                    additionalSizeAdjustment: additionalSizeAdjustment,\n                    fillPrice: fillPrice,\n                    tradeFee: totalFee - keeperFee,\n                    totalFee: totalFee\n                })\n            ),\n            keeperFee: keeperFee,\n            executableAtTime: executableAtTime\n        });\n\n        // Lock the NFT belonging to this position so that it can't be transferred to someone else.\n        // Locking doesn't require an approval from the leverage trader.\n        leverageModule.lock(tokenId);\n\n        // If user increases margin, fees are charged from their account.\n        if (marginAdjustment > 0) {\n            // Sending positive margin adjustment and both fees from the user to the delayed order contract.\n            vault.collateral().safeTransferFrom(msg.sender, address(this), uint256(marginAdjustment) + totalFee);\n        }\n\n        emit FlatcoinEvents.OrderAnnounced({\n            account: msg.sender,\n            orderType: FlatcoinStructs.OrderType.LeverageAdjust,\n            keeperFee: keeperFee\n        });\n    }\n\n    /// @notice Announces leverage close intent for keepers to execute at offchain oracle price.\n    /// @param tokenId The ERC721 token ID of the position.\n    /// @param minFillPrice The minimum price at which the trade can be executed.\n    /// @param keeperFee The fee the user is paying for keeper transaction execution (in collateral tokens).\n    function announceLeverageClose(uint256 tokenId, uint256 minFillPrice, uint256 keeperFee) external whenNotPaused {\n        uint64 executableAtTime = _prepareAnnouncementOrder(keeperFee);\n        uint256 tradeFee;\n\n        ILeverageModule leverageModule = ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY));\n\n        // Check that the caller of this function is actually the owner of the token ID.\n        // Since `lock` function in leverage module doesn't check for this, we need to do it here.\n        if (leverageModule.ownerOf(tokenId) != msg.sender) revert FlatcoinErrors.NotTokenOwner(tokenId, msg.sender);\n\n        {\n            uint256 size = vault.getPosition(tokenId).additionalSize;\n\n            // Position needs additional margin to cover the trading fee on closing the position\n            tradeFee = leverageModule.getTradeFee(size);\n\n            // Make sure there is enough margin in the position to pay the keeper fee and trading fee\n            // This should always pass because the position should get liquidated before the margin becomes too small\n            int256 settledMargin = leverageModule.getPositionSummary(tokenId).marginAfterSettlement;\n\n            uint256 totalFee = tradeFee + keeperFee;\n            if (settledMargin < int256(totalFee)) revert FlatcoinErrors.NotEnoughMarginForFees(settledMargin, totalFee);\n\n            (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY))\n                .getPrice();\n\n            if (minFillPrice > currentPrice) revert FlatcoinErrors.MinFillPriceTooHigh(minFillPrice, currentPrice);\n        }\n\n        _announcedOrder[msg.sender] = FlatcoinStructs.Order({\n            orderType: FlatcoinStructs.OrderType.LeverageClose,\n            orderData: abi.encode(\n                FlatcoinStructs.AnnouncedLeverageClose({\n                    tokenId: tokenId,\n                    minFillPrice: minFillPrice,\n                    tradeFee: tradeFee\n                })\n            ),\n            keeperFee: keeperFee,\n            executableAtTime: executableAtTime\n        });\n\n        // Lock the NFT belonging to this position so that it can't be transferred to someone else.\n        // Locking doesn't require an approval from the leverage trader.\n        leverageModule.lock(tokenId);\n\n        emit FlatcoinEvents.OrderAnnounced({\n            account: msg.sender,\n            orderType: FlatcoinStructs.OrderType.LeverageClose,\n            keeperFee: keeperFee\n        });\n    }\n\n    /////////////////////////////////////////////\n    //           Execution Functions           //\n    /////////////////////////////////////////////\n\n    /// @notice Executes any valid pending order for an account.\n    /// @dev Uses the Pyth network price to execute.\n    /// @param account The user account which has a pending deposit.\n    /// @param priceUpdateData The Pyth network offchain price oracle update data.\n    function executeOrder(\n        address account,\n        bytes[] calldata priceUpdateData\n    )\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n        updatePythPrice(vault, msg.sender, priceUpdateData)\n        orderInvariantChecks(vault)\n    {\n        // Settle funding fees before executing any order.\n        // This is to avoid error related to max caps or max skew reached when the market has been skewed to one side for a long time.\n        // This is more important in case the we allow for limit orders in the future.\n        vault.settleFundingFees();\n\n        FlatcoinStructs.OrderType orderType = _announcedOrder[account].orderType;\n\n        // If there is no order in store, just return.\n        if (orderType == FlatcoinStructs.OrderType.None) return;\n\n        if (orderType == FlatcoinStructs.OrderType.StableDeposit) {\n            _executeStableDeposit(account);\n        } else if (orderType == FlatcoinStructs.OrderType.StableWithdraw) {\n            _executeStableWithdraw(account);\n        } else if (orderType == FlatcoinStructs.OrderType.LeverageOpen) {\n            _executeLeverageOpen(account);\n        } else if (orderType == FlatcoinStructs.OrderType.LeverageClose) {\n            _executeLeverageClose(account);\n        } else if (orderType == FlatcoinStructs.OrderType.LeverageAdjust) {\n            _executeLeverageAdjust(account);\n        }\n    }\n\n    /// @notice Function to cancel an existing order after it has expired.\n    /// @dev This function can be called by anyone.\n    /// @param account The user account which has a pending order.\n    function cancelExistingOrder(address account) public {\n        FlatcoinStructs.Order memory order = _announcedOrder[account];\n\n        // If there is no order in store, just return.\n        if (order.orderType == FlatcoinStructs.OrderType.None) return;\n\n        if (block.timestamp <= order.executableAtTime + vault.maxExecutabilityAge())\n            revert FlatcoinErrors.OrderHasNotExpired();\n\n        // Delete the order tracker from storage.\n        // NOTE: This is done before the transfer of ERC721 NFT to prevent reentrancy attacks.\n        delete _announcedOrder[account];\n\n        if (order.orderType == FlatcoinStructs.OrderType.StableDeposit) {\n            FlatcoinStructs.AnnouncedStableDeposit memory stableDeposit = abi.decode(\n                order.orderData,\n                (FlatcoinStructs.AnnouncedStableDeposit)\n            );\n\n            // Send collateral back to trader\n            vault.collateral().safeTransfer({to: account, value: stableDeposit.depositAmount + order.keeperFee});\n        } else if (order.orderType == FlatcoinStructs.OrderType.StableWithdraw) {\n            FlatcoinStructs.AnnouncedStableWithdraw memory stableWithdraw = abi.decode(\n                order.orderData,\n                (FlatcoinStructs.AnnouncedStableWithdraw)\n            );\n\n            // Unlock the LP tokens belonging to this position which were locked during announcement.\n            IStableModule(vault.moduleAddress(FlatcoinModuleKeys._STABLE_MODULE_KEY)).unlock({\n                account: account,\n                amount: stableWithdraw.withdrawAmount\n            });\n        } else if (order.orderType == FlatcoinStructs.OrderType.LeverageOpen) {\n            FlatcoinStructs.AnnouncedLeverageOpen memory leverageOpen = abi.decode(\n                order.orderData,\n                (FlatcoinStructs.AnnouncedLeverageOpen)\n            );\n\n            // Send collateral back to trader\n            vault.collateral().safeTransfer({\n                to: account,\n                value: order.keeperFee + leverageOpen.margin + leverageOpen.tradeFee\n            });\n        } else if (order.orderType == FlatcoinStructs.OrderType.LeverageClose) {\n            FlatcoinStructs.AnnouncedLeverageClose memory leverageClose = abi.decode(\n                order.orderData,\n                (FlatcoinStructs.AnnouncedLeverageClose)\n            );\n\n            // Unlock the ERC721 position NFT to allow for transfers.\n            ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY)).unlock(leverageClose.tokenId);\n        } else if (order.orderType == FlatcoinStructs.OrderType.LeverageAdjust) {\n            FlatcoinStructs.AnnouncedLeverageAdjust memory leverageAdjust = abi.decode(\n                order.orderData,\n                (FlatcoinStructs.AnnouncedLeverageAdjust)\n            );\n\n            if (leverageAdjust.marginAdjustment > 0) {\n                vault.collateral().safeTransfer({\n                    to: account,\n                    value: uint256(leverageAdjust.marginAdjustment) + leverageAdjust.totalFee\n                });\n            }\n\n            // Unlock the ERC721 position NFT to allow for transfers.\n            ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY)).unlock(\n                leverageAdjust.tokenId\n            );\n        }\n\n        emit FlatcoinEvents.OrderCancelled({account: account, orderType: order.orderType});\n    }\n\n    /////////////////////////////////////////////\n    //       Internal Execution Functions      //\n    /////////////////////////////////////////////\n\n    /// @notice User delayed deposit into the stable LP. Mints ERC20 token receipt.\n    /// @dev Uses the Pyth network price to execute.\n    /// @param account The user account which has a pending deposit.\n    /// @return liquidityMinted The amount of stable LP tokens the user receives.\n    function _executeStableDeposit(address account) internal returns (uint256 liquidityMinted) {\n        FlatcoinStructs.Order memory order = _announcedOrder[account];\n\n        FlatcoinStructs.AnnouncedStableDeposit memory stableDeposit = abi.decode(\n            order.orderData,\n            (FlatcoinStructs.AnnouncedStableDeposit)\n        );\n\n        vault.checkCollateralCap(stableDeposit.depositAmount);\n\n        _prepareExecutionOrder(account, order.executableAtTime);\n\n        liquidityMinted = IStableModule(vault.moduleAddress(FlatcoinModuleKeys._STABLE_MODULE_KEY)).executeDeposit(\n            account,\n            order.executableAtTime,\n            stableDeposit\n        );\n\n        // Settle the collateral\n        vault.collateral().safeTransfer({to: msg.sender, value: order.keeperFee}); // pay the keeper their fee\n        vault.collateral().safeTransfer({to: address(vault), value: stableDeposit.depositAmount}); // transfer collateral to the vault\n\n        emit FlatcoinEvents.OrderExecuted({account: account, orderType: order.orderType, keeperFee: order.keeperFee});\n    }\n\n    /// @notice User delayed withdrawal from the stable LP.\n    /// @dev Uses the Pyth network price to execute.\n    /// @param account The user account which has a pending withdrawal.\n    /// @return amountOut The amount of collateral asset tokens the user receives.\n    function _executeStableWithdraw(address account) internal returns (uint256 amountOut) {\n        FlatcoinStructs.Order memory order = _announcedOrder[account];\n\n        _prepareExecutionOrder(account, order.executableAtTime);\n\n        FlatcoinStructs.AnnouncedStableWithdraw memory stableWithdraw = abi.decode(\n            order.orderData,\n            (FlatcoinStructs.AnnouncedStableWithdraw)\n        );\n\n        uint256 withdrawFee;\n\n        (amountOut, withdrawFee) = IStableModule(vault.moduleAddress(FlatcoinModuleKeys._STABLE_MODULE_KEY))\n            .executeWithdraw(account, order.executableAtTime, stableWithdraw);\n\n        uint256 totalFee = order.keeperFee + withdrawFee;\n\n        // Make sure there is enough margin in the position to pay the keeper fee and withdrawal fee\n        if (amountOut < totalFee) revert FlatcoinErrors.NotEnoughMarginForFees(int256(amountOut), totalFee);\n\n        // include the fees here to check for slippage\n        amountOut -= totalFee;\n\n        if (amountOut < stableWithdraw.minAmountOut)\n            revert FlatcoinErrors.HighSlippage(amountOut, stableWithdraw.minAmountOut);\n\n        // Settle the collateral\n        vault.updateStableCollateralTotal(int256(withdrawFee)); // pay the withdrawal fee to stable LPs\n        vault.sendCollateral({to: msg.sender, amount: order.keeperFee}); // pay the keeper their fee\n        vault.sendCollateral({to: account, amount: amountOut}); // transfer remaining amount to the trader\n\n        emit FlatcoinEvents.OrderExecuted({account: account, orderType: order.orderType, keeperFee: order.keeperFee});\n    }\n\n    /// @notice Execution of user delayed leverage open order. Mints ERC721 token receipt.\n    /// @dev Uses the Pyth network price to execute.\n    /// @param account The user account which has a pending order.\n    /// @return tokenId The ERC721 token ID of the position.\n    function _executeLeverageOpen(address account) internal returns (uint256 tokenId) {\n        FlatcoinStructs.Order memory order = _announcedOrder[account];\n        FlatcoinStructs.AnnouncedLeverageOpen memory announcedOpen = abi.decode(\n            order.orderData,\n            (FlatcoinStructs.AnnouncedLeverageOpen)\n        );\n\n        _prepareExecutionOrder(account, order.executableAtTime);\n\n        vault.collateral().safeTransfer({\n            to: address(vault),\n            value: announcedOpen.margin + announcedOpen.tradeFee + order.keeperFee\n        }); // transfer collateral + fees to the vault\n\n        tokenId = ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY)).executeOpen({\n            account: account,\n            keeper: msg.sender,\n            order: order\n        });\n\n        emit FlatcoinEvents.OrderExecuted({account: account, orderType: order.orderType, keeperFee: order.keeperFee});\n    }\n\n    /// @notice Execution of user delayed leverage adjust order.\n    /// @dev Uses the Pyth network price to execute.\n    /// @param account The user account which has a pending order.\n    function _executeLeverageAdjust(address account) internal {\n        FlatcoinStructs.Order memory order = _announcedOrder[account];\n        FlatcoinStructs.AnnouncedLeverageAdjust memory leverageAdjust = abi.decode(\n            order.orderData,\n            (FlatcoinStructs.AnnouncedLeverageAdjust)\n        );\n\n        _prepareExecutionOrder(account, order.executableAtTime);\n\n        ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY)).executeAdjust({\n            account: account,\n            keeper: msg.sender,\n            order: order\n        });\n\n        if (leverageAdjust.marginAdjustment > 0) {\n            // Sending positive margin adjustment and fees from delayed order contract to the vault\n            vault.collateral().safeTransfer({\n                to: address(vault),\n                value: uint256(leverageAdjust.marginAdjustment) + leverageAdjust.tradeFee + order.keeperFee\n            });\n        }\n\n        emit FlatcoinEvents.OrderExecuted({account: account, orderType: order.orderType, keeperFee: order.keeperFee});\n    }\n\n    /// @notice Execution of user delayed leverage close order. Burns ERC721 token receipt.\n    /// @dev Uses the Pyth network price to execute.\n    /// @param account The user account which has a pending order.\n    /// @return settledMargin The amount of margin settled from the position.\n    function _executeLeverageClose(address account) internal returns (int256 settledMargin) {\n        FlatcoinStructs.Order memory order = _announcedOrder[account];\n\n        _prepareExecutionOrder(account, order.executableAtTime);\n\n        settledMargin = ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY)).executeClose({\n            account: account,\n            keeper: msg.sender,\n            order: order\n        });\n\n        emit FlatcoinEvents.OrderExecuted({account: account, orderType: order.orderType, keeperFee: order.keeperFee});\n    }\n\n    /// @dev This function HAS to be called as soon as the transaction flow enters an announce function.\n    function _prepareAnnouncementOrder(uint256 keeperFee) internal returns (uint64 executableAtTime) {\n        // Settle funding fees to not encounter the `MaxSkewReached` error.\n        // This error could happen if the funding fees are not settled for a long time and the market is skewed long\n        // for a long time.\n        vault.settleFundingFees();\n\n        if (keeperFee < IKeeperFee(vault.moduleAddress(FlatcoinModuleKeys._KEEPER_FEE_MODULE_KEY)).getKeeperFee())\n            revert FlatcoinErrors.InvalidFee(keeperFee);\n\n        // If the user has an existing pending order that expired, then cancel it.\n        cancelExistingOrder(msg.sender);\n\n        executableAtTime = uint64(block.timestamp + vault.minExecutabilityAge());\n    }\n\n    /// @dev This function HAS to be called as soon as the transaction flow enters an execute function.\n    function _prepareExecutionOrder(address account, uint256 executableAtTime) internal {\n        if (block.timestamp > executableAtTime + vault.maxExecutabilityAge()) revert FlatcoinErrors.OrderHasExpired();\n\n        // Check that the minimum time delay is reached before execution\n        if (block.timestamp < executableAtTime) revert FlatcoinErrors.ExecutableTimeNotReached(executableAtTime);\n\n        // Delete the order tracker from storage.\n        delete _announcedOrder[account];\n    }\n\n    /////////////////////////////////////////////\n    //             View Functions              //\n    /////////////////////////////////////////////\n\n    /// @notice Getter for the announced order of an account\n    /// @param account The user account which has a pending order\n    /// @return order The order struct\n    function getAnnouncedOrder(address account) external view returns (FlatcoinStructs.Order memory order) {\n        return _announcedOrder[account];\n    }\n\n    /// @notice Checks whether a user announced order has expired executability time or not\n    /// @param account The user account which has a pending order\n    /// @return expired True if the order has expired, false otherwise\n    function hasOrderExpired(address account) public view returns (bool expired) {\n        uint256 executableAtTime = _announcedOrder[account].executableAtTime;\n\n        if (executableAtTime <= 0) revert FlatcoinErrors.ZeroValue(\"executableAtTime\");\n\n        expired = (executableAtTime + vault.maxExecutabilityAge() >= block.timestamp) ? false : true;\n    }\n}"
    },
    {
      "filename": "flatcoin-v1/src/abstracts/OracleModifiers.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\n\nimport {IFlatcoinVault} from \"../interfaces/IFlatcoinVault.sol\";\nimport {IOracleModule} from \"../interfaces/IOracleModule.sol\";\nimport {FlatcoinModuleKeys} from \"../libraries/FlatcoinModul"
    }
  ]
}