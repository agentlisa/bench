{
  "Title": "[G-03] Use `furnace` instead of `main.furnace()`",
  "Content": "Gas savings: ~2.6K\n\nCode: https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/RToken.sol#L184<br>\nhttps://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/RToken.sol#L257\n\nAt `RToken.redeemTo()` and `redeemCustom()` furnace is being called using `main.furnace()` instead of using the `furnace` variable.\n\nThe call to `main.furnace()` costs both the cold storage variable read at `main.furnace()` and an external call to a cold address while using the `furnace` variable of the current contract costs only the cold storage read.\n\nThe additional cold call would cost ~2.6K.\n\nTo my understanding both of the values should be equal at all times so there shouldn't be an issue with the replacement.\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-06-reserve",
  "Code": [
    {
      "filename": "contracts/p1/RToken.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.17;\n\n// solhint-disable-next-line max-line-length\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"../interfaces/IMain.sol\";\nimport \"../interfaces/IRToken.sol\";\nimport \"../libraries/Fixed.sol\";\nimport \"../libraries/Throttle.sol\";\nimport \"../vendor/ERC20PermitUpgradeable.sol\";\nimport \"./mixins/Component.sol\";\n\n/**\n * @title RTokenP1\n * An ERC20 with an elastic supply and governable exchange rate to basket units.\n */\ncontract RTokenP1 is ComponentP1, ERC20PermitUpgradeable, IRToken {\n    using FixLib for uint192;\n    using ThrottleLib for ThrottleLib.Throttle;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    uint256 public constant MIN_THROTTLE_RATE_AMT = 1e18; // {qRTok}\n    uint256 public constant MAX_THROTTLE_RATE_AMT = 1e48; // {qRTok}\n    uint192 public constant MAX_THROTTLE_PCT_AMT = 1e18; // {qRTok}\n    uint192 public constant MIN_EXCHANGE_RATE = 1e9; // D18{BU/rTok}\n    uint192 public constant MAX_EXCHANGE_RATE = 1e27; // D18{BU/rTok}\n\n    /// The mandate describes what goals its governors should try to achieve. By succinctly\n    /// explaining the RToken’s purpose and what the RToken is intended to do, it provides common\n    /// ground for the governors to decide upon priorities and how to weigh tradeoffs.\n    ///\n    /// Example Mandates:\n    ///\n    /// - Capital preservation first. Spending power preservation second. Permissionless\n    ///     access third.\n    /// - Capital preservation above all else. All revenues fund the over-collateralization pool.\n    /// - Risk-neutral pursuit of profit for token holders.\n    ///     Maximize (gross revenue - payments for over-collateralization and governance).\n    /// - This RToken holds only FooCoin, to provide a trade for hedging against its\n    ///     possible collapse.\n    ///\n    /// The mandate may also be a URI to a longer body of text, presumably on IPFS or some other\n    /// immutable data store.\n    string public mandate;\n\n    // ==== Peer components ====\n    IAssetRegistry private assetRegistry;\n    IBasketHandler private basketHandler;\n    IBackingManager private backingManager;\n    IFurnace private furnace;\n\n    // The number of baskets that backingManager must hold\n    // in order for this RToken to be fully collateralized.\n    // The exchange rate for issuance and redemption is totalSupply()/basketsNeeded {BU}/{qRTok}.\n    uint192 public basketsNeeded; // D18{BU}\n\n    // === Supply throttles ===\n    ThrottleLib.Throttle private issuanceThrottle;\n    ThrottleLib.Throttle private redemptionThrottle;\n\n    function init(\n        IMain main_,\n        string calldata name_,\n        string calldata symbol_,\n        string calldata mandate_,\n        ThrottleLib.Params calldata issuanceThrottleParams_,\n        ThrottleLib.Params calldata redemptionThrottleParams_\n    ) external initializer {\n        require(bytes(name_).length > 0, \"name empty\");\n        require(bytes(symbol_).length > 0, \"symbol empty\");\n        require(bytes(mandate_).length > 0, \"mandate empty\");\n        __Component_init(main_);\n        __ERC20_init(name_, symbol_);\n        __ERC20Permit_init(name_);\n\n        assetRegistry = main_.assetRegistry();\n        basketHandler = main_.basketHandler();\n        backingManager = main_.backingManager();\n        furnace = main_.furnace();\n\n        mandate = mandate_;\n        setIssuanceThrottleParams(issuanceThrottleParams_);\n        setRedemptionThrottleParams(redemptionThrottleParams_);\n\n        issuanceThrottle.lastTimestamp = uint48(block.timestamp);\n        redemptionThrottle.lastTimestamp = uint48(block.timestamp);\n    }\n\n    /// Issue an RToken on the current basket\n    /// @param amount {qTok} The quantity of RToken to issue\n    /// @custom:interaction nearly CEI, but see comments around handling of refunds\n    function issue(uint256 amount) public {\n        issueTo(_msgSender(), amount);\n    }\n\n    /// Issue an RToken on the current basket, to a particular recipient\n    /// @param recipient The address to receive the issued RTokens\n    /// @param amount {qRTok} The quantity of RToken to issue\n    /// @custom:interaction\n    // BU exchange rate cannot decrease, and it can only increase when < FIX_ONE.\n    function issueTo(address recipient, uint256 amount) public notIssuancePausedOrFrozen {\n        require(amount > 0, \"Cannot issue zero\");\n\n        // == Refresh ==\n\n        assetRegistry.refresh();\n\n        // == Checks-effects block ==\n\n        address issuer = _msgSender(); // OK to save: it can't be changed in reentrant runs\n\n        // Ensure basket is ready, SOUND and not in warmup period\n        require(basketHandler.isReady(), \"basket not ready\");\n\n        furnace.melt();\n        uint256 supply = totalSupply();\n\n        // Revert if issuance exceeds either supply throttle\n        issuanceThrottle.useAvailable(supply, int256(amount)); // reverts on over-issuance\n        redemptionThrottle.useAvailable(supply, -int256(amount)); // shouldn't revert\n\n        // AT THIS POINT:\n        //   all contract invariants hold\n        //   furnace melting is up-to-date\n        //   asset states are up-to-date\n        //   throttle is up-to-date\n\n        // amtBaskets: the BU change to be recorded by this issuance\n        // D18{BU} = D18{BU} * {qRTok} / {qRTok}\n        // revert-on-overflow provided by FixLib functions\n        uint192 amtBaskets = supply > 0\n            ? basketsNeeded.muluDivu(amount, supply, CEIL)\n            : _safeWrap(amount);\n        emit Issuance(issuer, recipient, amount, amtBaskets);\n\n        (address[] memory erc20s, uint256[] memory deposits) = basketHandler.quote(\n            amtBaskets,\n            CEIL\n        );\n\n        // == Interactions: Create RToken + transfer tokens to BackingManager ==\n        _scaleUp(recipient, amtBaskets, supply);\n\n        for (uint256 i = 0; i < erc20s.length; ++i) {\n            IERC20Upgradeable(erc20s[i]).safeTransferFrom(\n                issuer,\n                address(backingManager),\n                deposits[i]\n            );\n        }\n    }\n\n    /// Redeem RToken for basket collateral\n    /// @param amount {qTok} The quantity {qRToken} of RToken to redeem\n    /// @custom:interaction CEI\n    function redeem(uint256 amount) external {\n        redeemTo(_msgSender(), amount);\n    }\n\n    /// Redeem RToken for basket collateral to a particular recipient\n    // checks:\n    //   amount > 0\n    //   amount <= balanceOf(caller)\n    //\n    // effects:\n    //   (so totalSupply -= amount and balanceOf(caller) -= amount)\n    //   basketsNeeded' / totalSupply' >== basketsNeeded / totalSupply\n    //   burn(caller, amount)\n    //\n    // actions:\n    //   let erc20s = basketHandler.erc20s()\n    //   for each token in erc20s:\n    //     let tokenAmt = (amount * basketsNeeded / totalSupply) current baskets\n    //     do token.transferFrom(backingManager, caller, tokenAmt)\n    // BU exchange rate cannot decrease, and it can only increase when < FIX_ONE.\n    /// @param recipient The address to receive the backing collateral tokens\n    /// @param amount {qRTok} The quantity {qRToken} of RToken to redeem\n    /// @custom:interaction RCEI\n    function redeemTo(address recipient, uint256 amount) public notFrozen {\n        // == Refresh ==\n\n        assetRegistry.refresh();\n        // solhint-disable-next-line no-empty-blocks\n        try main.furnace().melt() {} catch {} // nice for the redeemer, but not necessary\n\n        // == Checks and Effects ==\n\n        require(amount > 0, \"Cannot redeem zero\");\n        require(amount <= balanceOf(_msgSender()), \"insufficient balance\");\n        require(basketHandler.fullyCollateralized(), \"partial redemption; use redeemCustom\");\n        // redemption while IFFY/DISABLED allowed\n\n        uint256 supply = totalSupply();\n\n        // Revert if redemption exceeds either supply throttle\n        issuanceThrottle.useAvailable(supply, -int256(amount));\n        redemptionThrottle.useAvailable(supply, int256(amount)); // reverts on over-redemption\n\n        // {BU}\n        uint192 baskets = _scaleDown(_msgSender(), amount);\n        emit Redemption(_msgSender(), recipient, amount, baskets);\n\n        (address[] memory erc20s, uint256[] memory amounts) = basketHandler.quote(baskets, FLOOR);\n\n        // === Interactions ===\n\n        for (uint256 i = 0; i < erc20s.length; ++i) {\n            if (amounts[i] == 0) continue;\n\n            // Send withdrawal\n            IERC20Upgradeable(erc20s[i]).safeTransferFrom(\n                address(backingManager),\n                recipient,\n                amounts[i]\n            );\n        }\n    }\n\n    /// Redeem RToken for a linear combination of historical baskets, to a particular recipient\n    // checks:\n    //   amount > 0\n    //   amount <= balanceOf(caller)\n    //   sum(portions) == FIX_ONE\n    //   nonce >= basketHandler.primeNonce() for nonce in basketNonces\n    //\n    // effects:\n    //   (so totalSupply -= amount and balanceOf(caller) -= amount)\n    //   basketsNeeded' / totalSupply' >== basketsNeeded / totalSupply\n    //   burn(caller, amount)\n    //\n    // actions:\n    //   for each token in erc20s:\n    //     let tokenAmt = (amount * basketsNeeded / totalSupply) custom baskets\n    //     let prorataAmt = (amount / totalSupply) * token.balanceOf(backingManager)\n    //     do token.transferFrom(backingManager, caller, min(tokenAmt, prorataAmt))\n    // BU exchange rate cannot decrease, and it can only increase when < FIX_ONE.\n    /// @dev Allows partial redemptions up to the minAmounts\n    /// @param recipient The address to receive the backing collateral tokens\n    /// @param amount {qRTok} The quantity {qRToken} of RToken to redeem\n    /// @param basketNonces An array of basket nonces to do redemption from\n    /// @param portions {1} An array of Fix quantities that must add up to FIX_ONE\n    /// @param expectedERC20sOut An array of ERC20s expected out\n    /// @param minAmounts {qTok} The minimum ERC20 quantities the caller should receive\n    /// @custom:interaction RCEI\n    function redeemCustom(\n        address recipient,\n        uint256 amount,\n        uint48[] memory basketNonces,\n        uint192[] memory portions,\n        address[] memory expectedERC20sOut,\n        uint256[] memory minAmounts\n    ) external notFrozen returns (address[] memory erc20sOut, uint256[] memory amountsOut) {\n        // == Refresh ==\n\n        assetRegistry.refresh();\n        // solhint-disable-next-line no-empty-blocks\n        try main.furnace().melt() {} catch {}\n\n        // == Checks and Effects ==\n\n        require(amount > 0, \"Cannot redeem zero\");\n        require(amount <= balanceOf(_msgSender()), \"insufficient balance\");\n        uint256 portionsSum;\n        for (uint256 i = 0; i < portions.length; ++i) {\n            portionsSum += portions[i];\n        }\n        require(portionsSum == FIX_ONE, \"portions do not add up to FIX_ONE\");\n\n        uint256 supply = totalSupply();\n\n        // Revert if redemption exceeds either supply throttle\n        issuanceThrottle.useAvailable(supply, -int256(amount));\n        redemptionThrottle.useAvailable(supply, int256(amount)); // reverts on over-redemption\n\n        // {BU}\n        uint192 baskets = _scaleDown(_msgSender(), amount);\n        emit Redemption(_msgSender(), recipient, amount, baskets);\n\n        // === Get basket redemption amounts ===\n\n        (erc20sOut, amountsOut) = basketHandler.quoteCustomRedemption(\n            basketNonces,\n            portions,\n            baskets\n        );\n\n        // ==== Prorate redemption ====\n        // i.e, set amounts = min(amounts, balances * amount / totalSupply)\n        //   where balances[i] = erc20sOut[i].balanceOf(backingManager)\n\n        // Bound each withdrawal by the prorata share, in case we're currently under-collateralized\n        for (uint256 i = 0; i < erc20sOut.length; ++i) {\n            // {qTok} = {qTok} * {qRTok} / {qRTok}\n            uint256 prorata = mulDiv256(\n                IERC20(erc20sOut[i]).balanceOf(address(backingManager)),\n                amount,\n                supply\n            ); // FLOOR\n\n            if (prorata < amountsOut[i]) amountsOut[i] = prorata;\n        }\n\n        // === Save initial recipient balances ===\n\n        uint256[] memory pastBals = new uint256[](expectedERC20sOut.length);\n        for (uint256 i = 0; i < expectedERC20sOut.length; ++i) {\n            pastBals[i] = IERC20(expectedERC20sOut[i]).balanceOf(recipient);\n            // we haven't verified this ERC20 is registered but this is always a staticcall\n        }\n\n        // === Interactions ===\n\n        // Distribute tokens; revert if empty redemption\n        {\n            bool allZero = true;\n            for (uint256 i = 0; i < erc20sOut.length; ++i) {\n                if (amountsOut[i] == 0) continue; // unregistered ERC20s will have 0 amount\n                if (allZero) allZero = false;\n\n                // Send withdrawal\n                IERC20Upgradeable(erc20sOut[i]).safeTransferFrom(\n                    address(backingManager),\n                    recipient,\n                    amountsOut[i]\n                );\n            }\n            if (allZero) revert(\"empty redemption\");\n        }\n\n        // === Post-checks ===\n\n        // Check post-balances\n        for (uint256 i = 0; i < expectedERC20sOut.length; ++i) {\n            uint256 bal = IERC20(expectedERC20sOut[i]).balanceOf(recipient);\n            // we haven't verified this ERC20 is registered but this is always a staticcall\n            require(bal - pastBals[i] >= minAmounts[i], \"redemption below minimum\");\n        }\n    }\n\n    /// Mint an amount of RToken equivalent to baskets BUs, scaling basketsNeeded up\n    /// Callable only by BackingManager\n    /// @param baskets {BU} The number of baskets to mint RToken for\n    /// @custom:protected\n    // checks: caller is backingManager\n    // effects:\n    //   bal'[recipient] = bal[recipient] + amtRToken\n    //   totalSupply' = totalSupply + amtRToken\n    //   basketsNeeded' = basketsNeeded + baskets\n    // BU exchange rate cannot decrease, and it can only increase when < FIX_ONE.\n    function mint(uint192 baskets) external {\n        require(_msgSender() == address(backingManager), \"not backing manager\");\n        _scaleUp(address(backingManager), baskets, totalSupply());\n    }\n\n    /// Melt a quantity of RToken from the caller's account, increasing the basket rate\n    /// @param amtRToken {qRTok} The amtRToken to be melted\n    /// @custom:protected\n    // checks: caller is furnace\n    // effects:\n    //   bal'[caller] = bal[caller] - amtRToken\n    //   totalSupply' = totalSupply - amtRToken\n    // BU exchange rate cannot decrease\n    // BU exchange rate CAN increase, but we already trust furnace to do this slowly\n    function melt(uint256 amtRToken) external {\n        require(_msgSender() == address(furnace), \"furnace only\");\n        _burn(_msgSender(), amtRToken);\n        emit Melted(amtRToken);\n    }\n\n    /// Burn an amount of RToken from caller's account and scale basketsNeeded down\n    /// Callable only by backingManager\n    /// @param amount {qRTok}\n    /// @custom:protected\n    // checks: caller is backingManager\n    // effects:\n    //   bal'[recipient] = bal[recipient] - amtRToken\n    //   totalSupply' = totalSupply - amtRToken\n    //   basketsNeeded' = basketsNeeded - baskets\n    // BU exchange rate cannot decrease, and it can only increase when < FIX_ONE.\n    function dissolve(uint256 amount) external {\n        require(_msgSender() == address(backingManager), \"not backing manager\");\n        _scaleDown(_msgSender(), amount);\n    }\n\n    /// An affordance of last resort for Main in order to ensure re-capitalization\n    /// @custom:protected\n    // checks: caller is backingManager\n    // effects: basketsNeeded' = basketsNeeded_\n    function setBasketsNeeded(uint192 basketsNeeded_) external notTradingPausedOrFrozen {\n        require(_msgSender() == address(backingManager), \"not backing manager\");\n        emit BasketsNeededChanged(basketsNeeded, basketsNeeded_);\n        basketsNeeded = basketsNeeded_;\n\n        // == P0 exchangeRateIsValidAfter modifier ==\n        uint256 supply = totalSupply();\n        require(supply > 0, \"0 supply\");\n\n        // Note: These are D18s, even though they are uint256s. This is because\n        // we cannot assume we stay inside our valid range here, as that is what\n        // we are checking in the first place\n        uint256 low = (FIX_ONE_256 * basketsNeeded) / supply; // D18{BU/rTok}\n        uint256 high = (FIX_ONE_256 * basketsNeeded + (supply - 1)) / supply; // D18{BU/rTok}\n\n        // here we take advantage of an implicit upcast from uint192 exchange rates\n        require(low >= MIN_EXCHANGE_RATE && high <= MAX_EXCHANGE_RATE, \"BU rate out of range\");\n    }\n\n    /// Sends all token balance of erc20 (if it is registered) to the BackingManager\n    /// @custom:interaction\n    function monetizeDonations(IERC20 erc20) external notTradingPausedOrFrozen {\n        require(assetRegistry.isRegistered(erc20), \"erc20 unregistered\");\n        IERC20Upgradeable(address(erc20)).safeTransfer(\n            address(backingManager),\n            erc20.balanceOf(address(this))\n        );\n    }\n\n    // ==== Throttle setters/getters ====\n\n    /// @return {qRTok} The maximum issuance that can be performed in the current block\n    function issuanceAvailable() external view returns (uint256) {\n        return issuanceThrottle.currentlyAvailable(issuanceThrottle.hourlyLimit(totalSupply()));\n    }\n\n    /// @return available {qRTok} The maximum redemption that can be performed in the current block\n    function redemptionAvailable() external view returns (uint256 available) {\n        uint256 supply = totalSupply();\n        uint256 hourlyLimit = redemptionThrottle.hourlyLimit(supply);\n        available = redemptionThrottle.currentlyAvailable(hourlyLimit);\n        if (supply < available) available = supply;\n    }\n\n    /// @return The issuance throttle parametrization\n    function issuanceThrottleParams() external view returns (ThrottleLib.Params memory) {\n        return issuanceThrottle.params;\n    }\n\n    /// @return The redemption throttle parametrization\n    function redemptionThrottleParams() external view returns (ThrottleLib.Params memory) {\n        return redemptionThrottle.params;\n    }\n\n    /// @custom:governance\n    function setIssuanceThrottleParams(ThrottleLib.Params calldata params) public governance {\n        require(params.amtRate >= MIN_THROTTLE_RATE_AMT, \"issuance amtRate too small\");\n        require(params.amtRate <= MAX_THROTTLE_RATE_AMT, \"issuance amtRate too big\");\n        require(params.pctRate <= MAX_THROTTLE_PCT_AMT, \"issuance pctRate too big\");\n        emit IssuanceThrottleSet(issuanceThrottle.params, params);\n        issuanceThrottle.params = params;\n    }\n\n    /// @custom:governance\n    function setRedemptionThrottleParams(ThrottleLib.Params calldata params) public governance {\n        require(params.amtRate >= MIN_THROTTLE_RATE_AMT, \"redemption amtRate too small\");\n        require(params.amtRate <= MAX_THROTTLE_RATE_AMT, \"redemption amtRate too big\");\n        require(params.pctRate <= MAX_THROTTLE_PCT_AMT, \"redemption pctRate too big\");\n        emit RedemptionThrottleSet(redemptionThrottle.params, params);\n        redemptionThrottle.params = params;\n    }\n\n    // ==== Private ====\n\n    /// Mint an amount of RToken equivalent to amtBaskets and scale basketsNeeded up\n    /// @param recipient The address to receive the RTokens\n    /// @param amtBaskets {BU} The number of amtBaskets to mint RToken for\n    /// @param totalSupply {qRTok} The current totalSupply\n    // effects:\n    //   bal'[recipient] = bal[recipient] + amtRToken\n    //   totalSupply' = totalSupply + amtRToken\n    //   basketsNeeded' = basketsNeeded + amtBaskets\n    // BU exchange rate cannot decrease, and it can only increase when < FIX_ONE.\n    function _scaleUp(\n        address recipient,\n        uint192 amtBaskets,\n        uint256 totalSupply\n    ) private {\n        // take advantage of 18 decimals during casting\n        uint256 amtRToken = totalSupply > 0\n            ? amtBaskets.muluDivu(totalSupply, basketsNeeded) // {rTok} = {BU} * {qRTok} * {qRTok}\n            : amtBaskets; // {rTok}\n        emit BasketsNeededChanged(basketsNeeded, basketsNeeded + amtBaskets);\n        basketsNeeded += amtBaskets;\n\n        // Mint RToken to recipient\n        _mint(recipient, amtRToken);\n    }\n\n    /// Burn an amount of RToken and scale basketsNeeded down\n    /// @param account The address to dissolve RTokens from\n    /// @param amtRToken {qRTok} The amount of RToken to be dissolved\n    /// @return amtBaskets {BU} The equivalent number of baskets dissolved\n    // effects:\n    //   bal'[recipient] = bal[recipient] - amtRToken\n    //   totalSupply' = totalSupply - amtRToken\n    //   basketsNeeded' = basketsNeeded - amtBaskets\n    // BU exchange rate cannot decrease, and it can only increase when < FIX_ONE.\n    function _scaleDown(address account, uint256 amtRToken) private returns (uint192 amtBaskets) {\n        // D18{BU} = D18{BU} * {qRTok} / {qRTok}\n        amtBaskets = basketsNeeded.muluDivu(amtRToken, totalSupply()); // FLOOR\n        emit BasketsNeededChanged(basketsNeeded, basketsNeeded - amtBaskets);\n        basketsNeeded -= amtBaskets;\n\n        // Burn RToken from account; reverts if not enough balance\n        _burn(account, amtRToken);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     */\n    function _beforeTokenTransfer(\n        address,\n        address to,\n        uint256\n    ) internal virtual override {\n        require(to != address(this), \"RToken transfer to self\");\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[42] private __gap;\n}"
    },
    {
      "filename": "contracts/p1/RToken.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.17;\n\n// solhint-disable-next-line max-line-length\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"../interfaces/IMain.sol\";\nimport \"../interfaces/IRToken.sol\";\nimport \"../libraries/Fixed.sol\";\nimport \"../libraries/Throttle.sol\";\nimport \"../vendor/ERC20PermitUpgradeable.sol\";\nimport \"./mixins/Component.sol\";\n\n/**\n * @title RTokenP1\n * An ERC20 with an elastic supply and governable exchange rate to basket units.\n */\ncontract RTokenP1 is ComponentP1, ERC20PermitUpgradeable, IRToken {\n    using FixLib for uint192;\n    using ThrottleLib for ThrottleLib.Throttle;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    uint256 public constant MIN_THROTTLE_RATE_AMT = 1e18; // {qRTok}\n    uint256 public constant MAX_THROTTLE_RATE_AMT = 1e48; // {qRTok}\n    uint192 public constant MAX_THROTTLE_PCT_AMT = 1e18; // {qRTok}\n    uint192 public constant MIN_EXCHANGE_RATE = 1e9; // D18{BU/rTok}\n    uint192 public constant MAX_EXCHANGE_RATE = 1e27; // D18{BU/rTok}\n\n    /// The mandate describes what goals its governors should try to achieve. By succinctly\n    /// explaining the RToken’s purpose and what the RToken is intended to do, it provides common\n    /// ground for the governors to decide upon priorities and how to weigh tradeoffs.\n    ///\n    /// Example Mandates:\n    ///\n    /// - Capital preservation first. Spending power preservation second. Permissionless\n    ///     access third.\n    /// - Capital preservation above all else. All revenues fund the over-collateralization pool.\n    /// - Risk-neutral pursuit of profit for token holders.\n    ///     Maximize (gross revenue - payments for over-collateralization and governance).\n    /// - This RToken holds only FooCoin, to provide a trade for hedging against its\n    ///     possible collapse.\n    ///\n    /// The mandate may also be a URI to a longer body of text, presumably on IPFS or some other\n    /// immutable data store.\n    string public mandate;\n\n    // ==== Peer components ====\n    IAssetRegistry private assetRegistry;\n    IBasketHandler private basketHandler;\n    IBackingManager private backingManager;\n    IFurnace private furnace;\n\n    // The number of baskets that backingManager must hold\n    // in order for this RToken to be fully collateralized.\n    // The exchange rate for issuance and redemption is totalSupply()/basketsNeeded {BU}/{qRTok}.\n    uint192 public basketsNeeded; // D18{BU}\n\n    // === Supply throttles ===\n    ThrottleLib.Throttle private issuanceThrottle;\n    ThrottleLib.Throttle private redemptionThrottle;\n\n    function init(\n        IMain main_,\n        string calldata name_,\n        string calldata symbol_,\n        string calldata mandate_,\n        ThrottleLib.Params calldata issuanceThrottleParams_,\n        ThrottleLib.Params calldata redemptionThrottleParams_\n    ) external initializer {\n        require(bytes(name_).length > 0, \"name empty\");\n        require(bytes(symbol_).length > 0, \"symbol empty\");\n        require(bytes(mandate_).length > 0, \"mandate empty\");\n        __Component_init(main_);\n        __ERC20_init(name_, symbol_);\n        __ERC20Permit_init(name_);\n\n        assetRegistry = main_.assetRegistry();\n        basketHandler = main_.basketHandler();\n        backingManager = main_.backingManager();\n        furnace = main_.furnace();\n\n        mandate = mandate_;\n        setIssuanceThrottleParams(issuanceThrottleParams_);\n        setRedemptionThrottleParams(redemptionThrottleParams_);\n\n        issuanceThrottle.lastTimestamp = uint48(block.timestamp);\n        redemptionThrottle.lastTimestamp = uint48(block.timestamp);\n    }\n\n    /// Issue an RToken on the current basket\n    /// @param amount {qTok} The quantity of RToken to issue\n    /// @custom:interaction nearly CEI, but see comments around handling of refunds\n    function issue(uint256 amount) public {\n        issueTo(_msgSender(), amount);\n    }\n\n    /// Issue an RToken on the current basket, to a particular recipient\n    /// @param recipient The address to receive the issued RTokens\n    /// @param amount {qRTok} The quantity of RToken to issue\n    /// @custom:interaction\n    // BU exchange rate cannot decrease, and it can only increase when < FIX_ONE.\n    function issueTo(address recipient, uint256 amount) public notIssuancePausedOrFrozen {\n        require(amount > 0, \"Cannot issue zero\");\n\n        // == Refresh ==\n\n        assetRegistry.refresh();\n\n        // == Checks-effects block ==\n\n        address issuer = _msgSender(); // OK to save: it can't be changed in reentrant runs\n\n        // Ensure basket is ready, SOUND and not in warmup period\n        require(basketHandler.isReady(), \"basket not ready\");\n\n        furnace.melt();\n        uint256 supply = totalSupply();\n\n        // Revert if issuance exceeds either supply throttle\n        issuanceThrottle.useAvailable(supply, int256(amount)); // reverts on over-issuance\n        redemptionThrottle.useAvailable(supply, -int256(amount)); // shouldn't revert\n\n        // AT THIS POINT:\n        //   all contract invariants hold\n        //   furnace melting is up-to-date\n        //   asset states are up-to-date\n        //   throttle is up-to-date\n\n        // amtBaskets: the BU change to be recorded by this issuance\n        // D18{BU} = D18{BU} * {qRTok} / {qRTok}\n        // revert-on-overflow provided by FixLib functions\n        uint192 amtBaskets = supply > 0\n            ? basketsNeeded.muluDivu(amount, supply, CEIL)\n            : _safeWrap(amount);\n        emit Issuance(issuer, recipient, amount, amtBaskets);\n\n        (address[] memory erc20s, uint256[] memory deposits) = basketHandler.quote(\n            amtBaskets,\n            CEIL\n        );\n\n        // == Interactions: Create RToken + transfer tokens to BackingManager ==\n        _scaleUp(recipient, amtBaskets, supply);\n\n        for (uint256 i = 0; i < erc20s.length; ++i) {\n            IERC20Upgradeable(erc20s[i]).safeTransferFrom(\n                issuer,\n                address(backingManager),\n                deposits[i]\n            );\n        }\n    }\n\n    /// Redeem RToken for basket collateral\n    /// @param amount {qTok} The quantity {qRToken} of RToken to redeem\n    /// @custom:interaction CEI\n    function redeem(uint256 amount) external {\n        redeemTo(_msgSender(), amount);\n    }\n\n    /// Redeem RToken for basket collateral to a particular recipient\n    // checks:\n    //   amount > 0\n    //   amount <= balanceOf(caller)\n    //\n    // effects:\n    //   (so totalSupply -= amount and balanceOf(caller) -= amount)\n    //   basketsNeeded' / totalSupply' >== basketsNeeded / totalSupply\n    //   burn(caller, amount)\n    //\n    // actions:\n    //   let erc20s = basketHandler.erc20s()\n    //   for each token in erc20s:\n    //     let tokenAmt = (amount * basketsNeeded / totalSupply) current baskets\n    //     do token.transferFrom(backingManager, caller, tokenAmt)\n    // BU exchange rate cannot decrease, and it can only increase when < FIX_ONE.\n    /// @param recipient The address to receive the backing collateral tokens\n    /// @param amount {qRTok} The quantity {qRToken} of RToken to redeem\n    /// @custom:interaction RCEI\n    function redeemTo(address recipient, uint256 amount) public notFrozen {\n        // == Refresh ==\n\n        assetRegistry.refresh();\n        // solhint-disable-next-line no-empty-blocks\n        try main.furnace().melt() {} catch {} // nice for the redeemer, but not necessary\n\n        // == Checks and Effects ==\n\n        require(amount > 0, \"Cannot redeem zero\");\n        require(amount <= balanceOf(_msgSender()), \"insufficient balance\");\n        require(basketHandler.fullyCollateralized(), \"partial redemption; use redeemCustom\");\n        // redemption while IFFY/DISABLED allowed\n\n        uint256 supply = totalSupply();\n\n        // Revert if redemption exceeds either supply throttle\n        issuanceThrottle.useAvailable(supply, -int256(amount));\n        redemptionThrottle.useAvailable(supply, int256(amount)); // reverts on over-redemption\n\n        // {BU}\n        uint192 baskets = _scaleDown(_msgSender(), amount);\n        emit Redemption(_msgSender(), recipient, amount, baskets);\n\n        (address[] memory erc20s, uint256[] memory amounts) = basketHandler.quote(baskets, FLOOR);\n\n        // === Interactions ===\n\n        for (uint256 i = 0; i < erc20s.length; ++i) {\n            if (amounts[i] == 0) continue;\n\n            // Send withdrawal\n            IERC20Upgradeable(erc20s[i]).safeTransferFrom(\n                address(backingManager),\n                recipient,\n                amounts[i]\n            );\n        }\n    }\n\n    /// Redeem RToken for a linear combination of historical baskets, to a particular recipient\n    // checks:\n    //   amount > 0\n    //   amount <= balanceOf(caller)\n    //   sum(portions) == FIX_ONE\n    //   nonce >= basketHandler.primeNonce() for nonce in basketNonces\n    //\n    // effects:\n    //   (so totalSupply -= amount and balanceOf(caller) -= amount)\n    //   basketsNeeded' / totalSupply' >== basketsNeeded / totalSupply\n    //   burn(caller, amount)\n    //\n    // actions:\n    //   for each token in erc20s:\n    //     let tokenAmt = (amount * basketsNeeded / totalSupply) custom baskets\n    //     let prorataAmt = (amount / totalSupply) * token.balanceOf(backingManager)\n    //     do token.transferFrom(backingManager, caller, min(tokenAmt, prorataAmt))\n    // BU exchange rate cannot decrease, and it can only increase when < FIX_ONE.\n    /// @dev Allows partial redemptions up to the minAmounts\n    /// @param recipient The address to receive the backing collateral tokens\n    /// @param amount {qRTok} The quantity {qRToken} of RToken to redeem\n    /// @param basketNonces An array of basket nonces to do redemption from\n    /// @param portions {1} An array of Fix quantities that must add up to FIX_ONE\n    /// @param expectedERC20sOut An array of ERC20s expected out\n    /// @param minAmounts {qTok} The minimum ERC20 quantities the caller should receive\n    /// @custom:interaction RCEI\n    function redeemCustom(\n        address recipient,\n        uint256 amount,\n        uint48[] memory basketNonces,\n        uint192[] memory portions,\n        address[] memory expectedERC20sOut,\n        uint256[] memory minAmounts\n    ) external notFrozen returns (address[] memory erc20sOut, uint25"
    }
  ]
}