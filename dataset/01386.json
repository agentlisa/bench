{
  "Title": "Using the `RESPONSE_TIMEOUT` constant for all oracles",
  "Content": "##### Description\n\n- https://github.com/prisma-fi/prisma-contracts/blob/d9a2b2ba4d26e01115731fffadd8306c5955a660/contracts/core/PriceFeed.sol#L58\n\nChainlink uses the heartbeat when checking if the data feed is fresh.\n\nCurrently, the `25 hours` constant is used for the definition of staling. However, there are feeds that update the data faster (for example, https://data.chain.link/ethereum/mainnet/crypto-usd/eth-usd).\n\nWithout this, data can be considered fresh for a long time.\n\n##### Recommendation\n\nIt is recommended not to use the `RESPONSE_TIMEOUT` constant. Each oracle can contain this variable.\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/core/PriceFeed.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\nimport \"../interfaces/IAggregatorV3Interface.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../dependencies/PrismaMath.sol\";\nimport \"../dependencies/PrismaOwnable.sol\";\n\n/**\n    @title Prisma Multi Token Price Feed\n    @notice Based on Gravita's PriceFeed:\n            https://github.com/Gravita-Protocol/Gravita-SmartContracts/blob/9b69d555f3567622b0f84df8c7f1bb5cd9323573/contracts/PriceFeed.sol\n\n            Prisma's implementation additionally caches price values within a block and incorporates exchange rate settings for derivative tokens (e.g. stETH -> wstETH).\n */\ncontract PriceFeed is PrismaOwnable {\n    struct OracleRecord {\n        IAggregatorV3Interface chainLinkOracle;\n        uint8 decimals;\n        bytes4 sharePriceSignature;\n        uint8 sharePriceDecimals;\n        bool isFeedWorking;\n        bool isEthIndexed;\n    }\n\n    struct PriceRecord {\n        uint96 scaledPrice;\n        uint32 timestamp;\n        uint32 lastUpdated;\n        uint80 roundId;\n    }\n\n    struct FeedResponse {\n        uint80 roundId;\n        int256 answer;\n        uint256 timestamp;\n        bool success;\n    }\n\n    // Custom Errors --------------------------------------------------------------------------------------------------\n\n    error PriceFeed__InvalidFeedResponseError(address token);\n    error PriceFeed__FeedFrozenError(address token);\n    error PriceFeed__UnknownFeedError(address token);\n\n    // Events ---------------------------------------------------------------------------------------------------------\n\n    event NewOracleRegistered(address token, address chainlinkAggregator, bool isEthIndexed);\n    event PriceFeedStatusUpdated(address token, address oracle, bool isWorking);\n    event PriceRecordUpdated(address indexed token, uint256 _price);\n\n    /** Constants ---------------------------------------------------------------------------------------------------- */\n\n    // Used to convert a chainlink price answer to an 18-digit precision uint\n    uint256 public constant TARGET_DIGITS = 18;\n\n    // After this timeout, responses will be considered stale and revert\n    uint256 public constant RESPONSE_TIMEOUT = 25 hours;\n\n    // Maximum deviation allowed between two consecutive Chainlink oracle prices. 18-digit precision.\n    uint256 public constant MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND = 5e17; // 50%\n\n    // State ------------------------------------------------------------------------------------------------------------\n\n    mapping(address => OracleRecord) public oracleRecords;\n    mapping(address => PriceRecord) public priceRecords;\n\n    constructor(address _prismaCore, address ethFeed) PrismaOwnable(_prismaCore) {\n        setOracle(address(0), ethFeed, 0, 0, false);\n    }\n\n    // Admin routines ---------------------------------------------------------------------------------------------------\n\n    /**\n        @notice Set the oracle for a specific token\n        @param _token Address of the LST to set the oracle for\n        @param _chainlinkOracle Address of the chainlink oracle for this LST\n        @param sharePriceSignature Four byte function selector to be used when calling `_collateral`, in order to obtain the share price\n        @param sharePriceDecimals Decimal precision used in the returned share price\n        @param _isEthIndexed True if the base currency is ETH\n     */\n    function setOracle(\n        address _token,\n        address _chainlinkOracle,\n        bytes4 sharePriceSignature,\n        uint8 sharePriceDecimals,\n        bool _isEthIndexed\n    ) public onlyOwner {\n        IAggregatorV3Interface newFeed = IAggregatorV3Interface(_chainlinkOracle);\n        (FeedResponse memory currResponse, FeedResponse memory prevResponse, ) = _fetchFeedResponses(newFeed, 0);\n\n        if (!_isFeedWorking(currResponse, prevResponse)) {\n            revert PriceFeed__InvalidFeedResponseError(_token);\n        }\n        if (_isPriceStale(currResponse.timestamp)) {\n            revert PriceFeed__FeedFrozenError(_token);\n        }\n\n        OracleRecord memory record = OracleRecord({\n            chainLinkOracle: newFeed,\n            decimals: newFeed.decimals(),\n            sharePriceSignature: sharePriceSignature,\n            sharePriceDecimals: sharePriceDecimals,\n            isFeedWorking: true,\n            isEthIndexed: _isEthIndexed\n        });\n\n        oracleRecords[_token] = record;\n\n        _processFeedResponses(_token, record, currResponse, prevResponse, priceRecords[_token]);\n        emit NewOracleRegistered(_token, _chainlinkOracle, _isEthIndexed);\n    }\n\n    // Public functions -------------------------------------------------------------------------------------------------\n\n    /**\n        @notice Get the latest price returned from the oracle\n        @dev You can obtain these values by calling `TroveManager.fetchPrice()`\n             rather than directly interacting with this contract.\n        @param _token Token to fetch the price for\n        @return The latest valid price for the requested token\n     */\n    function fetchPrice(address _token) public returns (uint256) {\n        PriceRecord memory priceRecord = priceRecords[_token];\n\n        if (priceRecord.lastUpdated == block.timestamp) {\n            // We short-circuit only if the price was already correct in the current block\n            return priceRecord.scaledPrice;\n        }\n        if (priceRecord.lastUpdated == 0) {\n            revert PriceFeed__UnknownFeedError(_token);\n        }\n\n        OracleRecord storage oracle = oracleRecords[_token];\n\n        (FeedResponse memory currResponse, FeedResponse memory prevResponse, bool updated) = _fetchFeedResponses(\n            oracle.chainLinkOracle,\n            priceRecord.roundId\n        );\n\n        if (!updated) {\n            if (_isPriceStale(priceRecord.timestamp)) {\n                revert PriceFeed__FeedFrozenError(_token);\n            }\n            return priceRecord.scaledPrice;\n        }\n\n        return _processFeedResponses(_token, oracle, currResponse, prevResponse, priceRecord);\n    }\n\n    // Internal functions -----------------------------------------------------------------------------------------------\n\n    function _processFeedResponses(\n        address _token,\n        OracleRecord memory oracle,\n        FeedResponse memory _currResponse,\n        FeedResponse memory _prevResponse,\n        PriceRecord memory priceRecord\n    ) internal returns (uint256) {\n        uint8 decimals = oracle.decimals;\n        bool isValidResponse = _isFeedWorking(_currResponse, _prevResponse) &&\n            !_isPriceStale(_currResponse.timestamp) &&\n            !_isPriceChangeAboveMaxDeviation(_currResponse, _prevResponse, decimals);\n        if (isValidResponse) {\n            uint256 scaledPrice = _scalePriceByDigits(uint256(_currResponse.answer), decimals);\n            if (oracle.sharePriceSignature != 0) {\n                (bool success, bytes memory returnData) = _token.staticcall(abi.encode(oracle.sharePriceSignature));\n                require(success, \"Share price not available\");\n                scaledPrice = (scaledPrice * abi.decode(returnData, (uint256))) / (10 ** oracle.sharePriceDecimals);\n            }\n            if (oracle.isEthIndexed) {\n                // Oracle returns ETH price, need to convert to USD\n                scaledPrice = _calcEthPrice(scaledPrice);\n            }\n            if (!oracle.isFeedWorking) {\n                _updateFeedStatus(_token, oracle, true);\n            }\n            _storePrice(_token, scaledPrice, _currResponse.timestamp, _currResponse.roundId);\n            return scaledPrice;\n        } else {\n            if (oracle.isFeedWorking) {\n                _updateFeedStatus(_token, oracle, false);\n            }\n            if (_isPriceStale(priceRecord.timestamp)) {\n                revert PriceFeed__FeedFrozenError(_token);\n            }\n            return priceRecord.scaledPrice;\n        }\n    }\n\n    function _calcEthPrice(uint256 ethAmount) internal returns (uint256) {\n        uint256 ethPrice = fetchPrice(address(0));\n        return (ethPrice * ethAmount) / 1 ether;\n    }\n\n    function _fetchFeedResponses(\n        IAggregatorV3Interface oracle,\n        uint80 lastRoundId\n    ) internal view returns (FeedResponse memory currResponse, FeedResponse memory prevResponse, bool updated) {\n        currResponse = _fetchCurrentFeedResponse(oracle);\n        if (lastRoundId == 0 || currResponse.roundId > lastRoundId) {\n            prevResponse = _fetchPrevFeedResponse(oracle, currResponse.roundId);\n            updated = true;\n        }\n    }\n\n    function _isPriceStale(uint256 _priceTimestamp) internal view returns (bool) {\n        return block.timestamp - _priceTimestamp > RESPONSE_TIMEOUT;\n    }\n\n    function _isFeedWorking(\n        FeedResponse memory _currentResponse,\n        FeedResponse memory _prevResponse\n    ) internal view returns (bool) {\n        return _isValidResponse(_currentResponse) && _isValidResponse(_prevResponse);\n    }\n\n    function _isValidResponse(FeedResponse memory _response) internal view returns (bool) {\n        return\n            (_response.success) &&\n            (_response.roundId != 0) &&\n            (_response.timestamp != 0) &&\n            (_response.timestamp <= block.timestamp) &&\n            (_response.answer != 0);\n    }\n\n    function _isPriceChangeAboveMaxDeviation(\n        FeedResponse memory _currResponse,\n        FeedResponse memory _prevResponse,\n        uint8 decimals\n    ) internal pure returns (bool) {\n        uint256 currentScaledPrice = _scalePriceByDigits(uint256(_currResponse.answer), decimals);\n        uint256 prevScaledPrice = _scalePriceByDigits(uint256(_prevResponse.answer), decimals);\n\n        uint256 minPrice = PrismaMath._min(currentScaledPrice, prevScaledPrice);\n        uint256 maxPrice = PrismaMath._max(currentScaledPrice, prevScaledPrice);\n\n        /*\n         * Use the larger price as the denominator:\n         * - If price decreased, the percentage deviation is in relation to the previous price.\n         * - If price increased, the percentage deviation is in relation to the current price.\n         */\n        uint256 percentDeviation = ((maxPrice - minPrice) * PrismaMath.DECIMAL_PRECISION) / maxPrice;\n\n        return percentDeviation > MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND;\n    }\n\n    function _scalePriceByDigits(uint256 _price, uint256 _answerDigits) internal pure returns (uint256) {\n        if (_answerDigits == TARGET_DIGITS) {\n            return _price;\n        } else if (_answerDigits < TARGET_DIGITS) {\n            // Scale the returned price value up to target precision\n            return _price * (10 ** (TARGET_DIGITS - _answerDigits));\n        } else {\n            // Scale the returned price value down to target precision\n            return _price / (10 ** (_answerDigits - TARGET_DIGITS));\n        }\n    }\n\n    function _updateFeedStatus(address _token, OracleRecord memory _oracle, bool _isWorking) internal {\n        oracleRecords[_token].isFeedWorking = _isWorking;\n        emit PriceFeedStatusUpdated(_token, address(_oracle.chainLinkOracle), _isWorking);\n    }\n\n    function _storePrice(address _token, uint256 _price, uint256 _timestamp, uint80 roundId) internal {\n        priceRecords[_token] = PriceRecord({\n            scaledPrice: uint96(_price),\n            timestamp: uint32(_timestamp),\n            lastUpdated: uint32(block.timestamp),\n            roundId: roundId\n        });\n        emit PriceRecordUpdated(_token, _price);\n    }\n\n    function _fetchCurrentFeedResponse(\n        IAggregatorV3Interface _priceAggregator\n    ) internal view returns (FeedResponse memory response) {\n        try _priceAggregator.latestRoundData() returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 /* startedAt */,\n            uint256 timestamp,\n            uint80 /* answeredInRound */\n        ) {\n            // If call to Chainlink succeeds, return the response and success = true\n            response.roundId = roundId;\n            response.answer = answer;\n            response.timestamp = timestamp;\n            response.success = true;\n        } catch {\n            // If call to Chainlink aggregator reverts, return a zero response with success = false\n            return response;\n        }\n    }\n\n    function _fetchPrevFeedResponse(\n        IAggregatorV3Interface _priceAggregator,\n        uint80 _currentRoundId\n    ) internal view returns (FeedResponse memory prevResponse) {\n        if (_currentRoundId == 0) {\n            return prevResponse;\n        }\n        unchecked {\n            try _priceAggregator.getRoundData(_currentRoundId - 1) returns (\n                uint80 roundId,\n                int256 answer,\n                uint256 /* startedAt */,\n                uint256 timestamp,\n                uint80 /* answeredInRound */\n            ) {\n                prevResponse.roundId = roundId;\n                prevResponse.answer = answer;\n                prevResponse.timestamp = timestamp;\n                prevResponse.success = true;\n            } catch {}\n        }\n    }\n}"
    }
  ]
}