{
  "Title": "M-11: `quoteAllAvailablePoolsWithTimePeriod` can be manipulated with low liquidity pools",
  "Content": "# Issue M-11: `quoteAllAvailablePoolsWithTimePeriod` can be manipulated with low liquidity pools \n\nSource: https://github.com/sherlock-audit/2023-04-jojo-judging/issues/438 \n\n## Found by \nArbitraryExecution, GalloDaSballo, deadrxsezzz\n## Summary\n\n`quoteAllAvailablePoolsWithTimePeriod` can be manipulated with low liquidity pools, and there exist Uniswap V3 pools on Arbitrum that JOJO may quote the price from that are low liquidity and therefore manipulatable.\n\n## Vulnerability Detail\n\nThe [`quoteAllAvailablePoolsWithTimePeriod` function](https://github.com/Mean-Finance/uniswap-v3-oracle/blob/9935263665c5a16f9c385e909bcc6edcc8d56970/solidity/contracts/StaticOracle.sol#L53) from the `StaticOracle` contract is used in the `getMarkPrice` function of `uniswapPriceAdaptor.sol` to retrieve the weighted arithmetic mean of the tick prices of all applicable Uniswap V3 pools for the given `period`. However, the returned price can potentially be manipulated if the liquidity of a queried pool is low enough. This is because the arithmetic mean is susceptible to outliers. The potential for Uniswap V3 pools to be manipulated is usually considered a theoretical vulnerability for high-liquidity pools. However, there are specific instances of low liquidity Uniswap V3 pools on Arbitrum that JOJO will attempt to quote a price from, therefore making manipulation a real attack vector.\n\nIn one such instance, the deployed [`StaticOracle`](https://arbiscan.io/address/0xb210ce856631eeeb767efa666ec7c1c57738d438) contract that JOJO intends to use on Arbitrum returns the following three Uniswap V3 pools for the WBTC/USDC pair: [`0xac70bD92F89e6739B3a08Db9B6081a923912f73D`](https://arbiscan.io/address/0xac70bD92F89e6739B3a08Db9B6081a923912f73D), [`0xA62aD78825E3a55A77823F00Fe0050F567c1e4EE`](https://arbiscan.io/address/0xA62aD78825E3a55A77823F00Fe0050F567c1e4EE), and [`0x83450968eC7606F98Df1C170f8C922d55A13f236`](https://arbiscan.io/address/0x83450968eC7606F98Df1C170f8C922d55A13f236). Two of the three pools have low liquidity, which makes the average arithmetic mean of the three pools manipulatable.\n\n## Impact\n\nManipulating the price of a token used in a perpetual opens up the opportunity for arbitrage on the JOJO protocol which in turn could increase counterparty risk. Additionally, if the price exceeds the allowed difference set by JOJO, this could cause a permanent DOS of the `uniswapPriceAdaptor` and `emergencyOracle` fallback oracle mechanism. Despite this oracle mechanism being the fallback to Chainlink, a permanent DOS of the backup price oracle system should be considered a critical failure.\n\n## Code Snippet\n\nhttps://github.com/Mean-Finance/uniswap-v3-oracle/blob/9935263665c5a16f9c385e909bcc6edcc8d56970/solidity/contracts/StaticOracle.sol#L158-L174\n\n```solidity\nfunction _quote(\n    uint128 _baseAmount,\n    address _baseToken,\n    address _quoteToken,\n    address[] memory _pools,\n    uint32 _period\n  ) internal view returns (uint256 _quoteAmount) {\n    require(_pools.length > 0, 'No defined pools');\n    OracleLibrary.WeightedTickData[] memory _tickData = new OracleLibrary.WeightedTickData[](_pools.length);\n    for (uint256 i; i < _pools.length; i++) {\n      (_tickData[i].tick, _tickData[i].weight) = _period > 0\n        ? OracleLibrary.consult(_pools[i], _period)\n        : OracleLibrary.getBlockStartingTickAndLiquidity(_pools[i]);\n    }\n    int24 _weightedTick = _tickData.length == 1 ? _tickData[0].tick : OracleLibrary.getWeightedArithmeticMeanTick(_tickData);\n    return OracleLibrary.getQuoteAtTick(_weightedTick, _baseAmount, _baseToken, _quoteToken);\n}\n```\n\n## Tool used\n\nManual review.\n\n## Recommendation\n\nJOJO should consider replacing `quoteAllAvailablePoolsWithTimePeriod` with [`quoteSpecificPoolsWithTimePeriod`](https://github.com/Mean-Finance/uniswap-v3-oracle/blob/main/solidity/contracts/StaticOracle.sol#L77) and selecting a subset of Uniswap V3 pools with sufficient liquidity to avoid price manipulation.\n\n\n\n\n\n## Discussion\n\n**JoscelynFarr**\n\nfix link:\nhttps://github.com/JOJOexchange/smart-contract-EVM/commit/1dbc9001be667af42952c110e9fdf04fd7826669\nhttps://github.com/JOJOexchange/JUSDV1/commit/eed86242c2be0cd70e6b412124eb05ed5e3c92dc\n\n**IAm0x52**\n\nFixes look good. Pools are now specified instead of being pulled dynamically \n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/70",
  "Code": [
    {
      "filename": "solidity/contracts/StaticOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/utils/Address.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\nimport '@uniswap/v3-periphery/contracts/libraries/PoolAddress.sol';\nimport '@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol';\nimport '../interfaces/IStaticOracle.sol';\n\n/// @title Uniswap V3 Static Oracle\n/// @notice Oracle contract for price quoting against Uniswap V3 pools\ncontract StaticOracle is IStaticOracle {\n  /// @inheritdoc IStaticOracle\n  IUniswapV3Factory public immutable override UNISWAP_V3_FACTORY;\n  /// @inheritdoc IStaticOracle\n  uint8 public immutable override CARDINALITY_PER_MINUTE;\n  uint24[] internal _knownFeeTiers;\n\n  constructor(IUniswapV3Factory _UNISWAP_V3_FACTORY, uint8 _CARDINALITY_PER_MINUTE) {\n    UNISWAP_V3_FACTORY = _UNISWAP_V3_FACTORY;\n    CARDINALITY_PER_MINUTE = _CARDINALITY_PER_MINUTE;\n\n    // Assign default fee tiers\n    _knownFeeTiers.push(500);\n    _knownFeeTiers.push(3000);\n    _knownFeeTiers.push(10000);\n  }\n\n  /// @inheritdoc IStaticOracle\n  function supportedFeeTiers() external view override returns (uint24[] memory) {\n    return _knownFeeTiers;\n  }\n\n  /// @inheritdoc IStaticOracle\n  function isPairSupported(address _tokenA, address _tokenB) external view override returns (bool) {\n    uint256 _length = _knownFeeTiers.length;\n    for (uint256 i; i < _length; ++i) {\n      address _pool = PoolAddress.computeAddress(address(UNISWAP_V3_FACTORY), PoolAddress.getPoolKey(_tokenA, _tokenB, _knownFeeTiers[i]));\n      if (Address.isContract(_pool)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /// @inheritdoc IStaticOracle\n  function getAllPoolsForPair(address _tokenA, address _tokenB) public view override returns (address[] memory) {\n    return _getPoolsForTiers(_tokenA, _tokenB, _knownFeeTiers);\n  }\n\n  /// @inheritdoc IStaticOracle\n  function quoteAllAvailablePoolsWithTimePeriod(\n    uint128 _baseAmount,\n    address _baseToken,\n    address _quoteToken,\n    uint32 _period\n  ) external view override returns (uint256 _quoteAmount, address[] memory _queriedPools) {\n    _queriedPools = _getQueryablePoolsForTiers(_baseToken, _quoteToken, _period);\n    _quoteAmount = _quote(_baseAmount, _baseToken, _quoteToken, _queriedPools, _period);\n  }\n\n  /// @inheritdoc IStaticOracle\n  function quoteSpecificFeeTiersWithTimePeriod(\n    uint128 _baseAmount,\n    address _baseToken,\n    address _quoteToken,\n    uint24[] calldata _feeTiers,\n    uint32 _period\n  ) external view override returns (uint256 _quoteAmount, address[] memory _queriedPools) {\n    _queriedPools = _getPoolsForTiers(_baseToken, _quoteToken, _feeTiers);\n    require(_queriedPools.length == _feeTiers.length, 'Given tier does not have pool');\n    _quoteAmount = _quote(_baseAmount, _baseToken, _quoteToken, _queriedPools, _period);\n  }\n\n  /// @inheritdoc IStaticOracle\n  function quoteSpecificPoolsWithTimePeriod(\n    uint128 _baseAmount,\n    address _baseToken,\n    address _quoteToken,\n    address[] calldata _pools,\n    uint32 _period\n  ) external view override returns (uint256 _quoteAmount) {\n    return _quote(_baseAmount, _baseToken, _quoteToken, _pools, _period);\n  }\n\n  /// @inheritdoc IStaticOracle\n  function prepareAllAvailablePoolsWithTimePeriod(\n    address _tokenA,\n    address _tokenB,\n    uint32 _period\n  ) external override returns (address[] memory _preparedPools) {\n    return prepareAllAvailablePoolsWithCardinality(_tokenA, _tokenB, _getCardinalityForTimePeriod(_period));\n  }\n\n  /// @inheritdoc IStaticOracle\n  function prepareSpecificFeeTiersWithTimePeriod(\n    address _tokenA,\n    address _tokenB,\n    uint24[] calldata _feeTiers,\n    uint32 _period\n  ) external override returns (address[] memory _preparedPools) {\n    return prepareSpecificFeeTiersWithCardinality(_tokenA, _tokenB, _feeTiers, _getCardinalityForTimePeriod(_period));\n  }\n\n  /// @inheritdoc IStaticOracle\n  function prepareSpecificPoolsWithTimePeriod(address[] calldata _pools, uint32 _period) external override {\n    prepareSpecificPoolsWithCardinality(_pools, _getCardinalityForTimePeriod(_period));\n  }\n\n  /// @inheritdoc IStaticOracle\n  function prepareAllAvailablePoolsWithCardinality(\n    address _tokenA,\n    address _tokenB,\n    uint16 _cardinality\n  ) public override returns (address[] memory _preparedPools) {\n    _preparedPools = getAllPoolsForPair(_tokenA, _tokenB);\n    _prepare(_preparedPools, _cardinality);\n  }\n\n  /// @inheritdoc IStaticOracle\n  function prepareSpecificFeeTiersWithCardinality(\n    address _tokenA,\n    address _tokenB,\n    uint24[] calldata _feeTiers,\n    uint16 _cardinality\n  ) public override returns (address[] memory _preparedPools) {\n    _preparedPools = _getPoolsForTiers(_tokenA, _tokenB, _feeTiers);\n    require(_preparedPools.length == _feeTiers.length, 'Given tier does not have pool');\n    _prepare(_preparedPools, _cardinality);\n  }\n\n  /// @inheritdoc IStaticOracle\n  function prepareSpecificPoolsWithCardinality(address[] calldata _pools, uint16 _cardinality) public override {\n    _prepare(_pools, _cardinality);\n  }\n\n  /// @inheritdoc IStaticOracle\n  function addNewFeeTier(uint24 _feeTier) external override {\n    require(UNISWAP_V3_FACTORY.feeAmountTickSpacing(_feeTier) != 0, 'Invalid fee tier');\n    for (uint256 i; i < _knownFeeTiers.length; i++) {\n      require(_knownFeeTiers[i] != _feeTier, 'Tier already supported');\n    }\n    _knownFeeTiers.push(_feeTier);\n  }\n\n  function _getCardinalityForTimePeriod(uint32 _period) internal view returns (uint16 _cardinality) {\n    // We add 1 just to be on the safe side\n    _cardinality = uint16((_period * CARDINALITY_PER_MINUTE) / 60) + 1;\n  }\n\n  function _prepare(address[] memory _pools, uint16 _cardinality) internal {\n    for (uint256 i; i < _pools.length; i++) {\n      IUniswapV3Pool(_pools[i]).increaseObservationCardinalityNext(_cardinality);\n    }\n  }\n\n  function _quote(\n    uint128 _baseAmount,\n    address _baseToken,\n    address _quoteToken,\n    address[] memory _pools,\n    uint32 _period\n  ) internal view returns (uint256 _quoteAmount) {\n    require(_pools.length > 0, 'No defined pools');\n    OracleLibrary.WeightedTickData[] memory _tickData = new OracleLibrary.WeightedTickData[](_pools.length);\n    for (uint256 i; i < _pools.length; i++) {\n      (_tickData[i].tick, _tickData[i].weight) = _period > 0\n        ? OracleLibrary.consult(_pools[i], _period)\n        : OracleLibrary.getBlockStartingTickAndLiquidity(_pools[i]);\n    }\n    int24 _weightedTick = _tickData.length == 1 ? _tickData[0].tick : OracleLibrary.getWeightedArithmeticMeanTick(_tickData);\n    return OracleLibrary.getQuoteAtTick(_weightedTick, _baseAmount, _baseToken, _quoteToken);\n  }\n\n  /// @notice Takes a pair and a time period, and returns all pools that could be queried for that period\n  /// @param _tokenA One of the pair's tokens\n  /// @param _tokenB The other of the pair's tokens\n  /// @param _period The period that we want to query for\n  /// @return _queryablePools All pools that can be queried\n  function _getQueryablePoolsForTiers(\n    address _tokenA,\n    address _tokenB,\n    uint32 _period\n  ) internal view virtual returns (address[] memory _queryablePools) {\n    address[] memory _existingPools = getAllPoolsForPair(_tokenA, _tokenB);\n    // If period is 0, then just return all existing pools\n    if (_period == 0) return _existingPools;\n\n    _queryablePools = new address[](_existingPools.length);\n    uint256 _validPools;\n    for (uint256 i; i < _existingPools.length; i++) {\n      if (OracleLibrary.getOldestObservationSecondsAgo(_existingPools[i]) >= _period) {\n        _queryablePools[_validPools++] = _existingPools[i];\n      }\n    }\n\n    _resizeArray(_queryablePools, _validPools);\n  }\n\n  /// @notice Takes a pair and some fee tiers, and returns all pools that match those tiers\n  /// @param _tokenA One of the pair's tokens\n  /// @param _tokenB The other of the pair's tokens\n  /// @param _feeTiers The fee tiers to consider when searching for the pair's pools\n  /// @return _pools The pools for the given pair and fee tiers\n  function _getPoolsForTiers(\n    address _tokenA,\n    address _tokenB,\n    uint24[] memory _feeTiers\n  ) internal view virtual returns (address[] memory _pools) {\n    _pools = new address[](_feeTiers.length);\n    uint256 _validPools;\n    for (uint256 i; i < _feeTiers.length; i++) {\n      address _pool = PoolAddress.computeAddress(address(UNISWAP_V3_FACTORY), PoolAddress.getPoolKey(_tokenA, _tokenB, _feeTiers[i]));\n      if (Address.isContract(_pool)) {\n        _pools[_validPools++] = _pool;\n      }\n    }\n\n    _resizeArray(_pools, _validPools);\n  }\n\n  function _resizeArray(address[] memory _array, uint256 _amountOfValidElements) internal pure {\n    // If all elements are valid, then nothing to do here\n    if (_array.length == _amountOfValidElements) return;\n\n    // If not, then resize the array\n    assembly {\n      mstore(_array, _amountOfValidElements)\n    }\n  }\n}"
    },
    {
      "filename": "solidity/contracts/StaticOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/utils/Address.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\nimport '@uniswap/v3-periphery/contracts/libraries/PoolAddress.sol';\nimport '@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol';\nimport '../interfaces/IStaticOracle.sol';\n\n/// @title Uniswap V3 Static Oracle\n/// @notice Oracle contract for price quoting against Uniswap V3 pools\ncontract StaticOracle is IStaticOracle {\n  /// @inheritdoc IStaticOracle\n  IUniswapV3Factory public immutable override UNISWAP_V3_FACTORY;\n  /// @inheritdoc IStaticOracle\n  uint8 public immutable override CARDINALITY_PER_MINUTE;\n  uint24[] internal _knownFeeTiers;\n\n  constructor(IUniswapV3Factory _UNISWAP_V3_FACTORY, uint8 _CARDINALITY_PER_MINUTE) {\n    UNISWAP_V3_FACTORY = _UNISWAP_V3_FACTORY;\n    CARDINALITY_PER_MINUTE = _CARDINALITY_PER_MINUTE;\n\n    // Assign default fee tiers\n    _knownFeeTiers.push(500);\n    _knownFeeTiers.push(3000);\n    _knownFeeTiers.push(10000);\n  }\n\n  /// @inheritdoc IStaticOracle\n  function supportedFeeTiers() external view override returns (uint24[] memory) {\n    return _knownFeeTiers;\n  }\n\n  /// @inheritdoc IStaticOracle\n  function isPairSupported(address _tokenA, address _tokenB) external view override returns (bool) {\n    uint256 _length = _knownFeeTiers.length;\n    for (uint256 i; i < _length; ++i) {\n      address _pool = PoolAddress.computeAddress(address(UNISWAP_V3_FACTORY), PoolAddress.getPoolKey(_tokenA, _tokenB, _knownFeeTiers[i]));\n      if (Address.isContract(_pool)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /// @inheritdoc IStaticOracle\n  function getAllPoolsForPair(address _tokenA, address _tokenB) public view override returns (address[] memory) {\n    return _getPoolsForTiers(_tokenA, _tokenB, _knownFeeTiers);\n  }\n\n  /// @inheritdoc IStaticOracle\n  function quoteAllAvailablePoolsWithTimePeriod(\n    uint128 _baseAmount,\n    address _baseToken,\n    address _quoteToken,\n    uint32 _period\n  ) external view override returns (uint256 _quoteAmount, address[] memory _queriedPools) {\n    _queriedPools = _getQueryablePoolsForTiers(_baseToken, _quoteToken, _period);\n    _quoteAmount = _quote(_baseAmount, _baseToken, _quoteToken, _queriedPools, _period);\n  }\n\n  /// @inheritdoc IStaticOracle\n  function quoteSpecificFeeTiersWithTimePeriod(\n    uint128 _baseAmount,\n    address _baseToken,\n    address _quoteToken,\n    uint24[] calldata _feeTiers,\n    uint32 _period\n  ) external view override returns (uint256 _quoteAmount, address[] memory _queriedPools) {\n    _queriedPools = _getPoolsForTiers(_baseToken, _quoteToken, _feeTiers);\n    require(_queriedPools.length == _feeTiers.length, 'Given tier does not have pool');\n    _quoteAmount = _quote(_baseAmount, _baseToken, _quoteToken, _queriedPools, _period);\n  }\n\n  /// @inheritdoc IStaticOracle\n  function quoteSpecificPoolsWithTimePeriod(\n    uint128 _baseAmount,\n    address _baseToken,\n    address _quoteToken,\n    address[] calldata _pools,\n    uint32 _period\n  ) external view override returns (uint256 _quoteAmount) {\n    return _quote(_baseAmount, _baseToken, _quoteToken, _pools, _period);\n  }\n\n  /// @inheritdoc IStaticOracle\n  function prepareAllAvailablePoolsWithTimePeriod(\n    address _tokenA,\n    address _tokenB,\n    uint32 _period\n  ) external override returns (address[] memory _preparedPools) {\n    return prepareAllAvailablePoolsWithCardinality(_tokenA, _tokenB, _getCardinalityForTimePeriod(_period));\n  }\n\n  /// @inheritdoc IStaticOracle\n  function prepareSpecificFeeTiersWithTimePeriod(\n    address _tokenA,\n    address _tokenB,\n    uint24[] calldata _feeTiers,\n    uint32 _period\n  ) external override returns (address[] memory _preparedPools) {\n    return prepareSpecificFeeTiersWithCardinality(_tokenA, _tokenB, _feeTiers, _getCardinalityForTimePeriod(_period));\n  }\n\n  /// @inheritdoc IStaticOracle\n  function prepareSpecificPoolsWithTimePeriod(address[] calldata _pools, uint32 _period) external override {\n    prepareSpecificPoolsWithCardinality(_pools, _getCardinalityForTimePeriod(_period));\n  }\n\n  /// @inheritdoc IStaticOracle\n  function prepareAllAvailablePoolsWithCardinality(\n    address _tokenA,\n    address _tokenB,\n    uint16 _cardinality\n  ) public override returns (address[] memory _preparedPools) {\n    _preparedPools = getAllPoolsForPair(_tokenA, _tokenB);\n    _prepare(_preparedPools, _cardinality);\n  }\n\n  /// @inheritdoc IStaticOracle\n  function prepareSpecificFeeTiersWithCardinality(\n    address _tokenA,\n    address _tokenB,\n    uint24[] calldata _feeTiers,\n    uint16 _cardinality\n  ) public override returns (address[] memory _preparedPools) {\n    _preparedPools = _getPoolsForTiers(_tokenA, _tokenB, _feeTiers);\n    require(_preparedPools.length == _feeTiers.length, 'Given tier does not have pool');\n    _prepare(_preparedPools, _cardinality);\n  }\n\n  /// @inheritdoc IStaticOracle\n  function prepareSpecificPoolsWithCardinality(address[] calldata _pools, uint16 _cardinality) public override {\n    _prepare(_pools, _cardinality);\n  }\n\n  /// @inheritdoc IStaticOracle\n  function addNewFeeTier(uint24 _feeTier) external override {\n    require(UNISWAP_V3_FACTORY.feeAmountTickSpacing(_feeTier) != 0, 'Invalid fee tier');\n    for (uint256 i; i < _knownFeeTiers.length; i++) {\n      require(_knownFeeTiers[i] != _feeTier, 'Tier already supported');\n    }\n    _knownFeeTiers.push(_feeTier);\n  }\n\n  function _getCardinalityForTimePeriod(uint32 _period) internal view returns (uint16 _cardinality) {\n    // We add 1 just to be on the safe side\n    _cardinality = uint16((_period * CARDINALITY_PER_MINUTE) / 60) + 1;\n  }\n\n  function _prepare(address[] memory _pools, uint16 _cardinality) internal {\n    for (uint256 i; i < _pools.length; i++) {\n      IUniswapV3Pool(_pools[i]).increaseObservationCardinalityNext(_cardinality);\n    }\n  }\n\n  function _quote(\n    uint128 _baseAmount,\n    address _baseToken,\n    address _quoteToken,\n    address[] memory _pools,\n    uint32 _period\n  ) internal view returns (uint256 _quoteAmount) {\n    require(_pools.length > 0, 'No defined pools');\n    OracleLibrary.WeightedTickData[] memory _tickData = new OracleLibrary.WeightedTickData[](_pools.length);\n    for (uint256 i; i < _pools.length; i++) {\n      (_tickData[i].tick, _tickData[i].weight) = _period > 0\n        ? OracleLibrary.consult(_pools[i], _period)\n        : OracleLibrary.getBlockStartingTickAndLiquidity(_pools[i]);\n    }\n    int24 _weightedTick = _tickData.length == 1 ? _tickData[0].tick : OracleLibrary.getWeightedArithmeticMeanTick(_tickData);\n    return OracleLibrary.getQuoteAtTick(_weightedTick, _baseAmount, _baseToken, _quoteToken);\n  }\n\n  /// @notice Takes a pair and a time period, and returns all pools that could be queried for that period\n  /// @param _tokenA One of the pair's tokens\n  /// @param _tokenB The other of the pair's tokens\n  /// @param _period The period that we want to query for\n  /// @return _queryablePools All pools that can be queried\n  function _getQueryablePoolsForTiers(\n    address _tokenA,\n    address _tokenB,\n    uint32 _period\n  ) internal view virtual returns (address[] memory _queryablePools) {\n    address[] memory _existingPools = getAllPoolsForPair(_tokenA, _tokenB);\n    // If period is 0, then just return all existing pools\n    if (_period == 0) return _existingPools;\n\n    _queryablePools = new address[](_existingPools.length);\n    uint256 _validPools;\n    for (uint256 i; i < _existingPools.length; i++) {\n      if (OracleLibrary.getOldestObservationSecondsAgo(_existingPools[i]) >= _period) {\n        _queryablePools[_validPools++] = _existingPools[i];\n      }\n    }\n\n    _resizeArray(_queryablePools, _validPools);\n  }\n\n  /// @notice Takes a pair and some fee tiers, and returns all pools that match those tiers\n  /// @param _tokenA One of the pair's tokens\n  /// @param _tokenB The other of the pair's tokens\n  /// @param _feeTiers The fee tiers to consider when searching for the pair's pools\n  /// @return _pools The pools for the given pair and fee tiers\n  function _getPoolsForTiers(\n    address _tokenA,\n    address _tokenB,\n    uint24[] memory _feeTiers\n  ) internal view virtual returns (address[] memory _pools) {\n    _pools = new address[](_feeTiers.length);\n    uint256 _validPools;\n    for (uint256 i; i < _feeTiers.length; i++) {\n      address _pool = PoolAddress.computeAddress(address(UNISWAP_V3_FACTORY), PoolAddress.getPoolKey(_tokenA, _tokenB, _feeTiers[i]));\n      if (Address.isContract(_pool)) {\n        _pools[_validPools++] = _pool;\n      }\n    }\n\n    _resizeArray(_pools, _validPools);\n  }\n\n  function _resizeArray(address[] memory _array, uint256 _amountOfValidElements) internal pure {\n    // If all elements are valid, then nothing to do here\n    if (_array.length == _amountOfValidElements) return;\n\n    // If not, then resize the array\n    assembly {\n      mstore(_array, _amountOfValidElements)\n    }\n  }\n}"
    },
    {
      "filename": "solidity/contracts/StaticOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/utils/Address.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\nimport '@uniswap/v3-periphery/contracts/libraries/PoolAddress.sol';\nimport '@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol';\nimport '../libraries/OracleLibraryPlus.sol';\nimport '../interfaces/IStaticOracle.sol';\n\n/// @title Uniswap V3 Static Oracle\n/// @notice Oracle contract for price quoting against Uniswap V3 pools\ncontract StaticOracle is IStaticOracle {\n  /// @inheritdoc IStaticOracle\n  IUniswapV3Factory public immutable override UNISWAP_V3_FACTORY;\n  /// @inheritdoc IStaticOracle\n  uint8 public immutable override CARDINALITY_PER_MINUTE;\n  uint24[] internal _knownFeeTiers;\n\n  constructor(IUniswapV3Factory _UNISWAP_V3_FACTORY, uint8 _CARDINALITY_PER_MINUTE) {\n    UNISWAP_V3_FACTORY = _UNISWAP_V3_FACTORY;\n    CARDINALITY_PER_MINUTE = _CARDINALITY_PER_MINUTE;\n\n    // Assign default fee tiers\n    _knownFeeTiers.push(500);\n    _knownFeeTiers.push(3000);\n    _knownFeeTiers.push(10000);\n  }\n\n  /// @inheritdoc IStaticOracle\n  function supportedFeeTiers() external view override returns (uint24[] memory) {\n    return _knownFeeTiers;\n  }\n\n  /// @inheritdoc IStaticOracle\n  function isPairSupported(address _tokenA, address _tokenB) external view override returns (bool) {\n    uint256 _length = _knownFeeTiers.length;\n    for (uint256 i; i < _length; ++i) {\n      address _pool = PoolAddress.computeAddress(address(UNISWAP_V3_FACTORY), PoolAddress.getPoolKey(_tokenA, _tokenB, _knownFeeTiers[i]));\n      if (Address.isContract(_pool)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /// @inheritdoc IStaticOracle\n  function getAllPoolsForPair(address _tokenA, address _tokenB) public view override returns (address[] memory) {\n    return _getPoolsForTiers(_tokenA, _tokenB, _knownFeeTiers);\n  }\n\n  /// @inheritdoc IStaticOracle\n  function quoteAllAvailablePoolsWithTimePeriod(\n    uint128 _baseAmount,\n    address _baseToken,\n    address _quoteToken,\n    uint32 _period\n  ) external view override returns (uint256 _quoteAmount, address[] memory _queriedPools) {\n    return quoteAllAvailablePoolsWithOffsettedTimePeriod(_baseAmount, _baseToken, _quoteToken, _period, 0);\n  }\n\n  /// @inheritdoc IStaticOracle\n  function quoteSpecificFeeTiersWithTimePeriod(\n    uint128 _baseAmount,\n    address _baseToken,\n    address _quoteToken,\n    uint24[] calldata _feeTiers,\n    uint32 _period\n  ) external view override returns (uint256 _quoteAmount, address[] memory _queriedPools) {\n    return quoteSpecificFeeTiersWithOffsettedTimePeriod(_baseAmount, _baseToken, _quoteToken, _feeTiers, _period, 0);\n  }\n\n  /// @inheritdoc IStaticOracle\n  function quoteSpecificPoolsWithTimePeriod(\n    uint128 _baseAmount,\n    address _baseToken,\n    address _quoteToken,\n    address[] calldata _pools,\n    uint32 _period\n  ) external view override returns (uint256 _quoteAmount) {\n    return quoteSpecificPoolsWithOffsettedTimePeriod(_baseAmount, _baseToken, _quoteToken, _pools, _period, 0);\n  }\n\n  /// @inheritdoc IStaticOracle\n  function quoteAllAvailablePoolsWithOffsettedTimePeriod(\n    uint128 _baseAmount,\n    address _baseToken,\n    address _quoteToken,\n    uint32 _period,\n    uint32 _offset\n  ) public view override returns (uint256 _quoteAmount, address[] memory _queriedPools) {\n    _queriedPools = _getQueryablePoolsForTiers(_baseToken, _quoteToken, _offset + _period);\n    _quoteAmount = _quote(_baseAmount, _baseToken, _quoteToken, _queriedPools, _period, _offset);\n  }\n\n  /// @inheritdoc IStaticOracle\n  function quoteSpecificFeeTiersWithOffsettedTimePeriod(\n    uint128 _baseAmount,\n    address _baseToken,\n    address _quoteToken,\n    uint24[] calldata _feeTiers,\n    uint32 _period,\n    uint32 _offset\n  ) public view override returns (uint256 _quoteAmount, address[] memory _queriedPools) {\n    _queriedPools = _getPoolsForTiers(_baseToken, _quoteToken, _feeTiers);\n    require(_queriedPools.length == _feeTiers.length, 'Given tier does not have pool');\n    _quoteAmount = _quote(_baseAmount, _baseToken, _quoteToken, _queriedPools, _period, _offset);\n  }\n\n  /// @inheritdoc IStaticOracle\n  function quoteSpecificPoolsWithOffsettedTimePeriod(\n    uint128 _baseAmount,\n    address _baseToken,\n    address _quoteToken,\n    address[] calldata _pools,\n    uint32 _period,\n    uint32 _offset\n  ) public view override returns (uint256 _quoteAmount) {\n    return _quote(_baseAmount, _baseToken, _quoteToken, _pools, _period, _offset);\n  }\n\n  /// @inheritdoc IStaticOracle\n  function prepareAllAvailablePoolsWithTimePeriod(\n    address _tokenA,\n    address _tokenB,\n    uint32 _period\n  ) external override returns (address[] memory _preparedPools) {\n    return prepareAllAvailablePoolsWithCardinality(_tokenA, _tokenB, _getCardinalityForTimePeriod(_period));\n  }\n\n  /// @inheritdoc IStaticOracle\n  function prepareSpecificFeeTiersWithTimePeriod(\n    address _tokenA,\n    address _tokenB,\n    uint24[] calldata _feeTiers,\n    uint32 _period\n  ) external override returns (address[] memory _preparedPools) {\n    return prepareSpecificFeeTiersWithCardinality(_tokenA, _tokenB, _feeTiers, _getCardinalityForTimePeriod(_period));\n  }\n\n  /// @inheritdoc IStaticOracle\n  function prepareSpecificPoolsWithTimePeriod(address[] calldata _pools, uint32 _period) external override {\n    prepareSpecificPoolsWithCardinality(_pools, _getCardinalityForTimePeriod(_period));\n  }\n\n  /// @inheritdoc IStaticOracle\n  function prepareAllAvailablePoolsWithCardinality(\n    address _tokenA,\n    address _tokenB,\n    uint16 _cardinality\n  ) public override returns (address[] memory _preparedPools) {\n    _preparedPools = getAllPoolsForPair(_tokenA, _tokenB);\n    _prepare(_preparedPools, _cardinality);\n  }\n\n  /// @inheritdoc IStaticOracle\n  function prepareSpecificFeeTiersWithCardinality(\n    address _tokenA,\n    address _tokenB,\n    uint24[] calldata _feeTiers,\n    uint16 _cardinality\n  ) public override returns (address[] memory _preparedPools) {\n    _preparedPools = _getPoolsForTiers(_tokenA, _tokenB, _feeTiers);\n    require(_preparedPools.length == _feeTiers.length, 'Given tier does not have pool');\n    _prepare(_preparedPools, _cardinality);\n  }\n\n  /// @inheritdoc IStaticOracle\n  function prepareSpecificPoolsWithCardinality(address[] calldata _pools, uint16 _cardinality) public override {\n    _prepare(_pools, _cardinality);\n  }\n\n  /// @inheritdoc IStaticOracle\n  function addNewFeeTier(uint24 _feeTier) external override {\n    require(UNISWAP_V3_FACTORY.feeAmountTickSpacing(_feeTier) != 0, 'Invalid fee tier');\n    for (uint256 i; i < _knownFeeTiers.length; i++) {\n      require(_knownFeeTiers[i] != _feeTier, 'Tier already supported');\n    }\n    _knownFeeTiers.push(_feeTier);\n  }\n\n  function _getCardinalityForTimePeriod(uint32 _period) internal view returns (uint16 _cardinality) {\n    // We add 1 just to be on the safe side\n    _cardinality = uint16((_period * CARDINALITY_PER_MINUTE) / 60) + 1;\n  }\n\n  function _prepare(address[] memory _pools, uint16 _cardinality) internal {\n    for (uint256 i; i < _pools.length; i++) {\n      IUniswapV3Pool(_pools[i]).increaseObservationCardinalityNext(_cardinality);\n    }\n  }\n\n  function _quote(\n    uint128 _baseAmount,\n    address _baseToken,\n    address _quoteToken,\n    address[] memory _pools,\n    uint32 _period,\n    uint32 _offset\n  ) internal view returns (uint256 _quoteAmount) {\n    require(_pools.length > 0, 'No defined pools');\n    require(_offset == 0 || _period > 0, 'Cannot query an offsetted spot quote');\n    OracleLibrary.WeightedTickData[] memory _tickData = new OracleLibrary.WeightedTickData[](_pools.length);\n\n    for (uint256 i; i < _pools.length; i++) {\n      (_tickData[i].tick, _tickData[i].weight) = _period > 0\n        ? OracleLibraryPlus.consultOffsetted(_pools[i], _period, _offset)\n        : OracleLibrary.getBlockStartingTickAndLiquidity(_pools[i]); // _offset is 0\n    }\n    int24 _weightedTick = _tickData.length == 1 ? _tickData[0].tick : OracleLibrary.getWeightedArithmeticMeanTick(_tickData);\n    return OracleLibrary.getQuoteAtTick(_weightedTick, _baseAmount, _baseToken, _quoteToken);\n  }\n\n  /// @notice Takes a pair and a time period, and returns all pools that could be queried for that period\n  /// @param _tokenA One of the pair's tokens\n  /// @param _tokenB The other of the pair's tokens\n  /// @param _period The period that we want to query for\n  /// @return _queryablePools All pools that can be queried\n  function _getQueryablePoolsForTiers(\n    address _tokenA,\n    address _tokenB,\n    uint32 _period\n  ) internal view virtual returns (address[] memory _queryablePools) {\n    address[] memory _existingPools = getAllPoolsForPair(_tokenA, _tokenB);\n    // If period is 0, then just return all existing pools\n    if (_period == 0) return _existingPools;\n\n    _queryablePools = new address[](_existingPools.length);\n    uint256 _validPools;\n    for (uint256 i; i < _existingPools.length; i++) {\n      if (OracleLibrary.getOldestObservationSecondsAgo(_existingPools[i]) >= _period) {\n        _queryablePools[_validPools++] = _existingPools[i];\n      }\n    }\n\n    _resizeArray(_queryablePools, _validPools);\n  }\n\n  /// @notice Takes a pair and some fee tiers, and returns all pools that match those tiers\n  /// @param _tokenA One of the pair's tokens\n  /// @param _tokenB The other of the pair's tokens\n  /// @param _feeTiers The fee tiers to consider when searching for the pair's pools\n  /// @return _pools The pools for the given pair and fee tiers\n  function _getPoolsForTiers(\n    address _tokenA,\n    address _tokenB,\n    uint24[] memory _feeTiers\n  ) internal view virtual returns (address[] memory _pools) {\n    _pools = new address[](_feeTiers.length);\n    uint256 _validPools;\n    for (uint256 i; i < _feeTiers.length; i++) {\n      address _pool = PoolAddress.computeAddress(address(UNISWAP_V3_FACTORY), PoolAddress.getPoolKey(_tokenA, _tokenB, _feeTiers[i]));\n      if (Address.isContract(_pool)) {\n        _pools[_validPools++] = _pool;\n      }\n    }\n\n    _resizeArray(_pools, _validPools);\n  }\n\n  function _resizeArray(address[] memory _array, uint256 _amountOfValidElements) internal pure {\n    // If all elements are valid, then nothing to do here\n    if (_array.length == _amountOfValidElements) return;\n\n    // If not, then resize the array\n    assembly {\n      mstore(_array, _amountOfValidElements)\n    }\n  }\n}"
    }
  ]
}