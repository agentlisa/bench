{
  "Title": "[N-07] Large multiples of ten should use scientific notation (e.g. `1e6`) rather than decimal literals (e.g. `1000000`), for readability",
  "Content": "\n```solidity\nFile: contracts/utils/CvxMintAmount.sol   #1\n\n7     uint256 private constant _CLIFF_SIZE = 100000 * 1e18; //new cliff every 100,000 tokens\n```\n\n<https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/utils/CvxMintAmount.sol#L7>\n\n```solidity\nFile: contracts/utils/CvxMintAmount.sol   #2\n\n9     uint256 private constant _MAX_SUPPLY = 100000000 * 1e18; //100 mil max supply\n```\n\n<https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/utils/CvxMintAmount.sol#L9>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-04-backd",
  "Code": [
    {
      "filename": "backd/contracts/utils/CvxMintAmount.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nabstract contract CvxMintAmount {\n    uint256 private constant _CLIFF_SIZE = 100000 * 1e18; //new cliff every 100,000 tokens\n    uint256 private constant _CLIFF_COUNT = 1000; // 1,000 cliffs\n    uint256 private constant _MAX_SUPPLY = 100000000 * 1e18; //100 mil max supply\n    IERC20 private constant _CVX_TOKEN =\n        IERC20(address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B)); // CVX Token\n\n    function getCvxMintAmount(uint256 crvEarned) public view returns (uint256) {\n        //first get total supply\n        uint256 cvxTotalSupply = _CVX_TOKEN.totalSupply();\n\n        //get current cliff\n        uint256 currentCliff = cvxTotalSupply / _CLIFF_SIZE;\n\n        //if current cliff is under the max\n        if (currentCliff >= _CLIFF_COUNT) return 0;\n\n        //get remaining cliffs\n        uint256 remaining = _CLIFF_COUNT - currentCliff;\n\n        //multiply ratio of remaining cliffs to total cliffs against amount CRV received\n        uint256 cvxEarned = (crvEarned * remaining) / _CLIFF_COUNT;\n\n        //double check we have not gone over the max supply\n        uint256 amountTillMax = _MAX_SUPPLY - cvxTotalSupply;\n        if (cvxEarned > amountTillMax) cvxEarned = amountTillMax;\n        return cvxEarned;\n    }\n}"
    },
    {
      "filename": "backd/contracts/utils/CvxMintAmount.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nabstract contract CvxMintAmount {\n    uint256 private constant _CLIFF_SIZE = 100000 * 1e18; //new cliff every 100,000 tokens\n    uint256 private constant _CLIFF_COUNT = 1000; // 1,000 cliffs\n    uint256 private constant _MAX_SUPPLY = 100000000 * 1e18; //100 mil max supply\n    IERC20 private constant _CVX_TOKEN =\n        IERC20(address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B)); // CVX Token\n\n    function getCvxMintAmount(uint256 crvEarned) public view returns (uint256) {\n        //first get total supply\n        uint256 cvxTotalSupply = _CVX_TOKEN.totalSupply();\n\n        //get current cliff\n        uint256 currentCliff = cvxTotalSupply / _CLIFF_SIZE;\n\n        //if current cliff is under the max\n        if (currentCliff >= _CLIFF_COUNT) return 0;\n\n        //get remaining cliffs\n        uint256 remaining = _CLIFF_COUNT - currentCliff;\n\n        //multiply ratio of remaining cliffs to total cliffs against amount CRV received\n        uint256 cvxEarned = (crvEarned * remaining) / _CLIFF_COUNT;\n\n        //double check we have not gone over the max supply\n        uint256 amountTillMax = _MAX_SUPPLY - cvxTotalSupply;\n        if (cvxEarned > amountTillMax) cvxEarned = amountTillMax;\n        return cvxEarned;\n    }\n}"
    }
  ]
}