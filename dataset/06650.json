{
  "Title": "[G-01] Use calldata instead of memory for function arguments that do not get mutated",
  "Content": "When you specify a data location as `memory`, that value will be copied into memory. When you specify the location as `calldata`, the value will stay static within calldata. If the value is a large, complex type, using `memory` may result in extra memory expansion costs.\n\n**Note: We are not able to change [`_hashProposals`](https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/Funding.sol#L152-L157) , [`_validateCallDatas`](https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/Funding.sol#L103-L107), and [`proposeExtraordinary`](https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/ExtraordinaryFunding.sol#L85-L90) to take `calldata` arguments due to `stack too deep` errors.**\n\nTotal Instances: `19`\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-core/src/RewardsManager.sol#L135-L140\n\n*Gas Savings for `RewardsManager.moveStakedLiquidity`, obtained via protocol's tests: Avg 1195 gas*\n\n|        |    Max   |\n| ------ | -------- |\n| Before |  2112272 |  \n| After  |  2111077 | \n\n```solidity\nFile: ajna-core/src/RewardsManager.sol\n135:    function moveStakedLiquidity(\n136:        uint256 tokenId_,\n137:        uint256[] memory fromBuckets_,\n138:        uint256[] memory toBuckets_,\n139:        uint256 expiry_\n140:    ) external nonReentrant override {\n```\n```diff\ndiff --git a/src/RewardsManager.sol b/src/RewardsManager.sol\nindex 314b476..2e263b4 100644\n--- a/src/RewardsManager.sol\n+++ b/src/RewardsManager.sol\n@@ -134,8 +134,8 @@ contract RewardsManager is IRewardsManager, ReentrancyGuard {\n      */\n     function moveStakedLiquidity(\n         uint256 tokenId_,\n-        uint256[] memory fromBuckets_,\n-        uint256[] memory toBuckets_,\n+        uint256[] calldata fromBuckets_,\n+        uint256[] calldata toBuckets_,\n         uint256 expiry_\n     ) external nonReentrant override {\n         StakeInfo storage stakeInfo = stakes[tokenId_];\n@@ -147,16 +147,18 @@ contract RewardsManager is IRewardsManager, ReentrancyGuard {\n         if (fromBucketLength != toBuckets_.length) revert MoveStakedLiquidityInvalid();\n\n         address ajnaPool = stakeInfo.ajnaPool;\n-        uint256 curBurnEpoch = IPool(ajnaPool).currentBurnEpoch();\n+        { // to fix `stack too deep` error\n+            uint256 curBurnEpoch = IPool(ajnaPool).currentBurnEpoch();\n\n-        // claim rewards before moving liquidity, if any\n-        _claimRewards(\n-            stakeInfo,\n-            tokenId_,\n-            curBurnEpoch,\n-            false,\n-            ajnaPool\n-        );\n+            // claim rewards before moving liquidity, if any\n+            _claimRewards(\n+                stakeInfo,\n+                tokenId_,\n+                curBurnEpoch,\n+                false,\n+                ajnaPool\n+            );\n+        }\n\n         uint256 fromIndex;\n         uint256 toIndex;\n```\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/StandardFunding.sol#L519-L521\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/StandardFunding.sol#L612-L618\n\n*Gas Savings for `GrantFund.fundingVote`, obtained via protocol's tests: Avg 1589 gas*\n\n|        |    Max   |\n| ------ | -------- |\n| Before |   409345 |  \n| After  |   407756 | \n\n```solidity\nFile: ajna-grants/src/grants/base/StandardFunding.sol\n519:    function fundingVote(\n520:        FundingVoteParams[] memory voteParams_\n521:    ) external override returns (uint256 votesCast_) {\n\n612:    function _fundingVote(\n613:        QuarterlyDistribution storage currentDistribution_,\n614:        Proposal storage proposal_,\n615:        address account_,\n616:        QuadraticVoter storage voter_,\n617:        FundingVoteParams memory voteParams_\n618:    ) internal returns (uint256 incrementalVotesUsed_) {\n```\n```diff\ndiff --git a/src/grants/base/StandardFunding.sol b/src/grants/base/StandardFunding.sol\nindex 928b337..88f37a0 100644\n--- a/src/grants/base/StandardFunding.sol\n+++ b/src/grants/base/StandardFunding.sol\n@@ -517,31 +517,33 @@ abstract contract StandardFunding is Funding, IStandardFunding {\n\n     /// @inheritdoc IStandardFunding\n     function fundingVote(\n-        FundingVoteParams[] memory voteParams_\n+        FundingVoteParams[] calldata voteParams_\n     ) external override returns (uint256 votesCast_) {\n         uint24 currentDistributionId = _currentDistributionId;\n\n         QuarterlyDistribution storage currentDistribution = _distributions[currentDistributionId];\n         QuadraticVoter        storage voter               = _quadraticVoters[currentDistributionId][msg.sender];\n\n-        uint256 endBlock = currentDistribution.endBlock;\n+        { // @audit: needed to fix `stack too deep` error\n+            uint256 endBlock = currentDistribution.endBlock;\n\n-        uint256 screeningStageEndBlock = _getScreeningStageEndBlock(endBlock);\n+            uint256 screeningStageEndBlock = _getScreeningStageEndBlock(endBlock);\n\n-        // check that the funding stage is active\n-        if (block.number <= screeningStageEndBlock || block.number > endBlock) revert InvalidVote();\n+            // check that the funding stage is active\n+            if (block.number <= screeningStageEndBlock || block.number > endBlock) revert InvalidVote();\n\n-        uint128 votingPower = voter.votingPower;\n+            uint128 votingPower = voter.votingPower;\n\n-        // if this is the first time a voter has attempted to vote this period,\n-        // set initial voting power and remaining voting power\n-        if (votingPower == 0) {\n+            // if this is the first time a voter has attempted to vote this period,\n+            // set initial voting power and remaining voting power\n+            if (votingPower == 0) {\n\n-            // calculate the voting power available to the voting power in this funding stage\n-            uint128 newVotingPower = SafeCast.toUint128(_getVotesFunding(msg.sender, votingPower, voter.remainingVotingPower, screeningStageEndBlock));\n+                // calculate the voting power available to the voting power in this funding stage\n+                uint128 newVotingPower = SafeCast.toUint128(_getVotesFunding(msg.sender, votingPower, voter.remainingVotingPower, screeningStageEndBlock));\n\n-            voter.votingPower          = newVotingPower;\n-            voter.remainingVotingPower = newVotingPower;\n+                voter.votingPower          = newVotingPower;\n+                voter.remainingVotingPower = newVotingPower;\n+            }\n         }\n\n         uint256 numVotesCast = voteParams_.length;\n@@ -614,7 +616,7 @@ abstract contract StandardFunding is Funding, IStandardFunding {\n         Proposal storage proposal_,\n         address account_,\n         QuadraticVoter storage voter_,\n-        FundingVoteParams memory voteParams_\n+        FundingVoteParams calldata voteParams_\n     ) internal returns (uint256 incrementalVotesUsed_) {\n         uint8  support = 1;\n         uint256 proposalId = proposal_.proposalId;\n```\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/StandardFunding.sol#L572-L574\n\n*Gas Savings for `GrantFund.screeningVote`, obtained via protocol's tests: Avg 2678 gas*\n\n|        |    Max   |\n| ------ | -------- |\n| Before |   399146 |  \n| After  |   396468 | \n\n```solidity\nFile: ajna-grants/src/grants/base/StandardFunding.sol\n572:    function screeningVote(\n573:        ScreeningVoteParams[] memory voteParams_\n574:    ) external override returns (uint256 votesCast_) {\n```\n```diff\ndiff --git a/src/grants/base/StandardFunding.sol b/src/grants/base/StandardFunding.sol\nindex 928b337..550cf53 100644\n--- a/src/grants/base/StandardFunding.sol\n+++ b/src/grants/base/StandardFunding.sol\n@@ -570,7 +570,7 @@ abstract contract StandardFunding is Funding, IStandardFunding {\n\n     /// @inheritdoc IStandardFunding\n     function screeningVote(\n-        ScreeningVoteParams[] memory voteParams_\n+        ScreeningVoteParams[] calldata voteParams_\n     ) external override returns (uint256 votesCast_) {\n         QuarterlyDistribution memory currentDistribution = _distributions[_currentDistributionId];\n\n```\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/GrantFund.sol#L22-L27\n\n*Gas Savings for `GrantFund.hashProposal`, obtained via protocol's tests: Avg 127 gas*\n\n|        |    Max   |\n| ------ | -------- |\n| Before |   3843   |  \n| After  |   3716   | \n\n```solidity\nFile: ajna-grants/src/grants/GrantFund.sol\n22:    function hashProposal(\n23:        address[] memory targets_,\n24:        uint256[] memory values_,\n25:        bytes[] memory calldatas_,\n26:        bytes32 descriptionHash_\n27:    ) external pure override returns (uint256 proposalId_) {\n```\n```diff\ndiff --git a/src/grants/GrantFund.sol b/src/grants/GrantFund.sol\nindex 3d568b0..4c21753 100644\n--- a/src/grants/GrantFund.sol\n+++ b/src/grants/GrantFund.sol\n@@ -20,9 +20,9 @@ contract GrantFund is IGrantFund, ExtraordinaryFunding, StandardFunding {\n\n     /// @inheritdoc IGrantFund\n     function hashProposal(\n-        address[] memory targets_,\n-        uint256[] memory values_,\n-        bytes[] memory calldatas_,\n+        address[] calldata targets_,\n+        uint256[] calldata values_,\n+        bytes[] calldata calldatas_,\n         bytes32 descriptionHash_\n     ) external pure override returns (uint256 proposalId_) {\n         proposalId_ = _hashProposal(targets_, values_, calldatas_, descriptionHash_);\n```\n\nThe instances below do not save a lot of gas because they each call `_hashProposal`, which loads all the calldata arrays into memory so even if all the parameters are set to `calldata` they will all eventually be loaded into memory in the `_hashProposal`. In addition, some parameters in `proposeStandard` must stay as `memory` due to `stack too deep` errors.\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/Funding.sol#L52-L57\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/ExtraordinaryFunding.sol#L56-L61\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/StandardFunding.sol#L343-L348\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/StandardFunding.sol#L366-L371\n\n*Gas Savings for `GrantFund.executeExtraordinary`, obtained via protocol's tests: Avg 64 gas*\n\n|        |    Max   |\n| ------ | -------- |\n| Before |   95823  |  \n| After  |   95759  | \n\n*Gas Savings for `GrantFund.executeStandard`, obtained via protocol's tests: Avg 64 gas*\n\n|        |    Max   |\n| ------ | -------- |\n| Before |   47894  |  \n| After  |   47830  | \n\n*Gas Savings for `GrantFund.proposeStandard`, obtained via protocol's tests: Avg 46 gas*\n\n|        |    Max   |\n| ------ | -------- |\n| Before |   82900  |  \n| After  |   82854  | \n\n```solidity\nFile: ajna-grants/src/grants/base/Funding.sol\n52:    function _execute(\n53:        uint256 proposalId_,\n54:        address[] memory targets_,\n55:        uint256[] memory values_,\n56:        bytes[] memory calldatas_\n57:    ) internal {\n\n56:    function executeExtraordinary(\n57:        address[] memory targets_,\n58:        uint256[] memory values_,\n59:        bytes[] memory calldatas_,\n60:        bytes32 descriptionHash_\n61:    ) external nonReentrant override returns (uint256 proposalId_) {\n\n343:    function executeStandard(\n344:        address[] memory targets_,\n345:        uint256[] memory values_,\n346:        bytes[] memory calldatas_,\n347:        bytes32 descriptionHash_\n348:    ) external nonReentrant override returns (uint256 proposalId_) {\n\n366:    function proposeStandard(\n367:        address[] memory targets_,\n368:        uint256[] memory values_,\n369:        bytes[] memory calldatas_,\n370:        string memory description_\n371:    ) external override returns (uint256 proposalId_) {\n```\n```diff\ndiff --git a/src/grants/base/Funding.sol b/src/grants/base/Funding.sol\nindex 72fafb9..d5c58d1 100644\n--- a/src/grants/base/Funding.sol\n+++ b/src/grants/base/Funding.sol\n@@ -51,9 +51,9 @@ abstract contract Funding is IFunding, ReentrancyGuard {\n      */\n     function _execute(\n         uint256 proposalId_,\n-        address[] memory targets_,\n-        uint256[] memory values_,\n-        bytes[] memory calldatas_\n+        address[] calldata targets_,\n+        uint256[] calldata values_,\n+        bytes[] calldata calldatas_\n     ) internal {\n         // use common event name to maintain consistency with tally\n         emit ProposalExecuted(proposalId_);\n```\n```diff\ndiff --git a/src/grants/base/ExtraordinaryFunding.sol b/src/grants/base/ExtraordinaryFunding.sol\nindex 4a70abb..43bba61 100644\n--- a/src/grants/base/ExtraordinaryFunding.sol\n+++ b/src/grants/base/ExtraordinaryFunding.sol\n@@ -54,9 +54,9 @@ abstract contract ExtraordinaryFunding is Funding, IExtraordinaryFunding {\n\n     /// @inheritdoc IExtraordinaryFunding\n     function executeExtraordinary(\n-        address[] memory targets_,\n-        uint256[] memory values_,\n-        bytes[] memory calldatas_,\n+        address[] calldata targets_,\n+        uint256[] calldata values_,\n+        bytes[] calldata calldatas_,\n         bytes32 descriptionHash_\n     ) external nonReentrant override returns (uint256 proposalId_) {\n         proposalId_ = _hashProposal(targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_EXTRAORDINARY, descriptionHash_)));\n```\n```diff\ndiff --git a/src/grants/base/StandardFunding.sol b/src/grants/base/StandardFunding.sol\nindex 928b337..ceef9f5 100644\n--- a/src/grants/base/StandardFunding.sol\n+++ b/src/grants/base/StandardFunding.sol\n@@ -341,9 +341,9 @@ abstract contract StandardFunding is Funding, IStandardFunding {\n\n     /// @inheritdoc IStandardFunding\n     function executeStandard(\n-        address[] memory targets_,\n-        uint256[] memory values_,\n-        bytes[] memory calldatas_,\n+        address[] calldata targets_,\n+        uint256[] calldata values_,\n+        bytes[] calldata calldatas_,\n         bytes32 descriptionHash_\n     ) external nonReentrant override returns (uint256 proposalId_) {\n         proposalId_ = _hashProposal(targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_STANDARD, descriptionHash_)));\n@@ -364,8 +364,8 @@ abstract contract StandardFunding is Funding, IStandardFunding {\n\n     /// @inheritdoc IStandardFunding\n     function proposeStandard(\n-        address[] memory targets_,\n-        uint256[] memory values_,\n+        address[] calldata targets_,\n+        uint256[] calldata values_,\n         bytes[] memory calldatas_,\n         string memory description_\n     ) external override returns (uint256 proposalId_) {\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-05-ajna",
  "Code": [
    {
      "filename": "ajna-grants/src/grants/base/Funding.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport { Address }         from \"@oz/utils/Address.sol\";\nimport { IVotes }          from \"@oz/governance/utils/IVotes.sol\";\nimport { ReentrancyGuard } from \"@oz/security/ReentrancyGuard.sol\";\nimport { SafeCast }        from \"@oz/utils/math/SafeCast.sol\";\n\nimport { Maths } from \"../libraries/Maths.sol\";\n\nimport { IFunding } from \"../interfaces/IFunding.sol\";\n\nabstract contract Funding is IFunding, ReentrancyGuard {\n\n    /******************/\n    /*** Immutables ***/\n    /******************/\n\n    // address of the ajna token used in grant coordination\n    address public immutable ajnaTokenAddress = 0x9a96ec9B57Fb64FbC60B423d1f4da7691Bd35079;\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    /**\n     * @notice Number of blocks prior to a given voting stage to check an accounts voting power.\n     * @dev    Prevents flashloan attacks or duplicate voting with multiple accounts.\n     */\n    uint256 internal constant VOTING_POWER_SNAPSHOT_DELAY = 33;\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    /**\n     * @notice Total funds available for Funding Mechanism\n    */\n    uint256 public treasury;\n\n    /**************************/\n    /*** Internal Functions ***/\n    /**************************/\n\n     /**\n     * @notice Execute the calldata of a passed proposal.\n     * @param targets_   The list of smart contract targets for the calldata execution. Should be the Ajna token address.\n     * @param values_    Unused. Should be 0 since all calldata is executed on the Ajna token's transfer method.\n     * @param calldatas_ The list of calldatas to execute.\n     */\n    function _execute(\n        uint256 proposalId_,\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_\n    ) internal {\n        // use common event name to maintain consistency with tally\n        emit ProposalExecuted(proposalId_);\n\n        string memory errorMessage = \"Governor: call reverted without message\";\n        for (uint256 i = 0; i < targets_.length; ++i) {\n            (bool success, bytes memory returndata) = targets_[i].call{value: values_[i]}(calldatas_[i]);\n            Address.verifyCallResult(success, returndata, errorMessage);\n        }\n    }\n\n     /**\n     * @notice Retrieve the voting power of an account.\n     * @dev    Voting power is the minimum of the amount of votes available at a snapshot block 33 blocks prior to voting start, and at the vote starting block.\n     * @param account_        The voting account.\n     * @param snapshot_       One of the block numbers to retrieve the voting power at. 33 blocks prior to the block at which a proposal is available for voting.\n     * @param voteStartBlock_ The block number the proposal became available for voting.\n     * @return                The voting power of the account.\n     */\n    function _getVotesAtSnapshotBlocks(\n        address account_,\n        uint256 snapshot_,\n        uint256 voteStartBlock_\n    ) internal view returns (uint256) {\n        IVotes token = IVotes(ajnaTokenAddress);\n\n        // calculate the number of votes available at the snapshot block\n        uint256 votes1 = token.getPastVotes(account_, snapshot_);\n\n        // enable voting weight to be calculated during the voting period's start block\n        voteStartBlock_ = voteStartBlock_ != block.number ? voteStartBlock_ : block.number - 1;\n\n        // calculate the number of votes available at the stage's start block\n        uint256 votes2 = token.getPastVotes(account_, voteStartBlock_);\n\n        return Maths.min(votes2, votes1);\n    }\n\n    /**\n     * @notice Verifies proposal's targets, values, and calldatas match specifications.\n     * @dev    Counters incremented in an unchecked block due to being bounded by array length.\n     * @param targets_         The addresses of the contracts to call.\n     * @param values_          The amounts of ETH to send to each target.\n     * @param calldatas_       The calldata to send to each target.\n     * @return tokensRequested_ The amount of tokens requested in the calldata.\n     */\n    function _validateCallDatas(\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_\n    ) internal view returns (uint128 tokensRequested_) {\n\n        // check params have matching lengths\n        if (targets_.length == 0 || targets_.length != values_.length || targets_.length != calldatas_.length) revert InvalidProposal();\n\n        for (uint256 i = 0; i < targets_.length;) {\n\n            // check targets and values params are valid\n            if (targets_[i] != ajnaTokenAddress || values_[i] != 0) revert InvalidProposal();\n\n            // check calldata function selector is transfer()\n            bytes memory selDataWithSig = calldatas_[i];\n\n            bytes4 selector;\n            //slither-disable-next-line assembly\n            assembly {\n                selector := mload(add(selDataWithSig, 0x20))\n            }\n            if (selector != bytes4(0xa9059cbb)) revert InvalidProposal();\n\n            // https://github.com/ethereum/solidity/issues/9439\n            // retrieve tokensRequested from incoming calldata, accounting for selector and recipient address\n            uint256 tokensRequested;\n            bytes memory tokenDataWithSig = calldatas_[i];\n            //slither-disable-next-line assembly\n            assembly {\n                tokensRequested := mload(add(tokenDataWithSig, 68))\n            }\n\n            // update tokens requested for additional calldata\n            tokensRequested_ += SafeCast.toUint128(tokensRequested);\n\n            unchecked { ++i; }\n        }\n    }\n\n    /**\n     * @notice Create a proposalId from a hash of proposal's targets, values, and calldatas arrays, and a description hash.\n     * @dev    Consistent with proposalId generation methods used in OpenZeppelin Governor.\n     * @param targets_         The addresses of the contracts to call.\n     * @param values_          The amounts of ETH to send to each target.\n     * @param calldatas_       The calldata to send to each target.\n     * @param descriptionHash_ The hash of the proposal's description string. Generated by keccak256(bytes(description))).\n     * @return proposalId_     The hashed proposalId created from the provided params.\n     */\n    function _hashProposal(\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        bytes32 descriptionHash_\n    ) internal pure returns (uint256 proposalId_) {\n        proposalId_ = uint256(keccak256(abi.encode(targets_, values_, calldatas_, descriptionHash_)));\n    }\n}"
    },
    {
      "filename": "ajna-core/src/RewardsManager.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport { IERC20 }          from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport { IERC721 }         from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport { ReentrancyGuard } from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport { SafeERC20 }       from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport { IPool }                        from './interfaces/pool/IPool.sol';\nimport { IPositionManager }             from './interfaces/position/IPositionManager.sol';\nimport { IPositionManagerOwnerActions } from './interfaces/position/IPositionManagerOwnerActions.sol';\nimport {\n    IRewardsManager,\n    IRewardsManagerOwnerActions,\n    IRewardsManagerState,\n    IRewardsManagerDerivedState\n} from './interfaces/rewards/IRewardsManager.sol';\nimport { StakeInfo, BucketState } from './interfaces/rewards/IRewardsManagerState.sol';\n\nimport { PositionManager } from './PositionManager.sol';\n\nimport { Maths } from './libraries/internal/Maths.sol';\n\n/**\n *  @title  Rewards (staking) Manager contract\n *  @notice Pool lenders can optionally mint `NFT` that represents their positions.\n *          The Rewards contract allows pool lenders with positions `NFT` to stake and earn `Ajna` tokens. \n *          Lenders with `NFT`s can:\n *          - `stake` token\n *          - `update bucket exchange rate` and earn rewards\n *          - `claim` rewards\n *          - `unstake` token\n */\ncontract RewardsManager is IRewardsManager, ReentrancyGuard {\n\n    using SafeERC20 for IERC20;\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    /**\n     * @notice Maximum percentage of tokens burned that can be claimed as `Ajna` token `LP` `NFT` rewards.\n     */\n    uint256 internal constant REWARD_CAP = 0.8 * 1e18;\n    /**\n     * @notice Maximum percentage of tokens burned that can be claimed as `Ajna` token update rewards.\n     */\n    uint256 internal constant UPDATE_CAP = 0.1 * 1e18;\n    /**\n     * @notice Reward factor by which to scale the total rewards earned.\n     * @dev ensures that rewards issued to staked lenders in a given pool are less than the `Ajna` tokens burned in that pool.\n     */\n    uint256 internal constant REWARD_FACTOR = 0.5 * 1e18;\n    /**\n     * @notice Reward factor by which to scale rewards earned for updating a buckets exchange rate.\n     */\n    uint256 internal constant UPDATE_CLAIM_REWARD = 0.05 * 1e18;\n    /**\n     * @notice Time period after a burn event in which buckets exchange rates can be updated.\n     */\n    uint256 internal constant UPDATE_PERIOD = 2 weeks;\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    /// @dev `tokenID => epoch => bool has claimed` mapping.\n    mapping(uint256 => mapping(uint256 => bool)) public override isEpochClaimed;\n    /// @dev `epoch => rewards claimed` mapping.\n    mapping(uint256 => uint256) public override rewardsClaimed;\n    /// @dev `epoch => update bucket rate rewards claimed` mapping.\n    mapping(uint256 => uint256) public override updateRewardsClaimed;\n\n    /// @dev Mapping of per pool bucket exchange rates at a given burn event `poolAddress => bucketIndex => epoch => bucket exchange rate`.\n    mapping(address => mapping(uint256 => mapping(uint256 => uint256))) internal bucketExchangeRates;\n\n    /// @dev Mapping `tokenID => Stake info`.\n    mapping(uint256 => StakeInfo) internal stakes;\n\n    /******************/\n    /*** Immutables ***/\n    /******************/\n\n    /// @dev Address of the `Ajna` token.\n    address public immutable ajnaToken;\n    /// @dev The `PositionManager` contract\n    IPositionManager public immutable positionManager;\n\n    /*******************/\n    /*** Constructor ***/\n    /*******************/\n\n    constructor(address ajnaToken_, IPositionManager positionManager_) {\n        if (ajnaToken_ == address(0)) revert DeployWithZeroAddress();\n\n        ajnaToken = ajnaToken_;\n        positionManager = positionManager_;\n    }\n\n    /**************************/\n    /*** External Functions ***/\n    /**************************/\n\n    /**\n     *  @inheritdoc IRewardsManagerOwnerActions\n     *  @dev    === Revert on ===\n     *  @dev    not owner `NotOwnerOfDeposit()`\n     *  @dev    already claimed `AlreadyClaimed()`\n     *  @dev    === Emit events ===\n     *  @dev    - `ClaimRewards`\n     */\n    function claimRewards(\n        uint256 tokenId_,\n        uint256 epochToClaim_\n    ) external override {\n        StakeInfo storage stakeInfo = stakes[tokenId_];\n\n        if (msg.sender != stakeInfo.owner) revert NotOwnerOfDeposit();\n\n        if (isEpochClaimed[tokenId_][epochToClaim_]) revert AlreadyClaimed();\n\n        _claimRewards(stakeInfo, tokenId_, epochToClaim_, true, stakeInfo.ajnaPool);\n    }\n\n    /**\n     *  @inheritdoc IRewardsManagerOwnerActions\n     *  @dev    === Revert on ===\n     *  @dev    not owner `NotOwnerOfDeposit()`\n     *  @dev    invalid index params `MoveStakedLiquidityInvalid()`\n     *  @dev    === Emit events ===\n     *  @dev    - `MoveStakedLiquidity`\n     */\n    function moveStakedLiquidity(\n        uint256 tokenId_,\n        uint256[] memory fromBuckets_,\n        uint256[] memory toBuckets_,\n        uint256 expiry_\n    ) external nonReentrant override {\n        StakeInfo storage stakeInfo = stakes[tokenId_];\n\n        if (msg.sender != stakeInfo.owner) revert NotOwnerOfDeposit();\n\n        // check move array sizes match to be able to match on index\n        uint256 fromBucketLength = fromBuckets_.length;\n        if (fromBucketLength != toBuckets_.length) revert MoveStakedLiquidityInvalid();\n\n        address ajnaPool = stakeInfo.ajnaPool;\n        uint256 curBurnEpoch = IPool(ajnaPool).currentBurnEpoch();\n\n        // claim rewards before moving liquidity, if any\n        _claimRewards(\n            stakeInfo,\n            tokenId_,\n            curBurnEpoch,\n            false,\n            ajnaPool\n        );\n\n        uint256 fromIndex;\n        uint256 toIndex;\n        for (uint256 i = 0; i < fromBucketLength; ) {\n            fromIndex = fromBuckets_[i];\n            toIndex = toBuckets_[i];\n\n            // call out to position manager to move liquidity between buckets\n            IPositionManagerOwnerActions.MoveLiquidityParams memory moveLiquidityParams = IPositionManagerOwnerActions.MoveLiquidityParams(\n                tokenId_,\n                ajnaPool,\n                fromIndex,\n                toIndex,\n                expiry_\n            );\n            positionManager.moveLiquidity(moveLiquidityParams);\n\n            // update to bucket state\n            BucketState storage toBucket = stakeInfo.snapshot[toIndex];\n            toBucket.lpsAtStakeTime  = uint128(positionManager.getLP(tokenId_, toIndex));\n            toBucket.rateAtStakeTime = uint128(IPool(ajnaPool).bucketExchangeRate(toIndex));\n            delete stakeInfo.snapshot[fromIndex];\n\n            // iterations are bounded by array length (which is itself bounded), preventing overflow / underflow\n            unchecked { ++i; }\n        }\n\n        emit MoveStakedLiquidity(tokenId_, fromBuckets_, toBuckets_);\n\n        // update to bucket list exchange rates, from buckets are aready updated on claim\n        // calculate rewards for updating exchange rates, if any\n        uint256 updateReward = _updateBucketExchangeRates(\n            ajnaPool,\n            toBuckets_\n        );\n\n        // transfer rewards to sender\n        _transferAjnaRewards(updateReward);\n    }\n\n    /**\n     *  @inheritdoc IRewardsManagerOwnerActions\n     *  @dev    === Revert on ===\n     *  @dev    not owner `NotOwnerOfDeposit()`\n     *  @dev    === Emit events ===\n     *  @dev    - `Stake`\n     */\n    function stake(\n        uint256 tokenId_\n    ) external override {\n        address ajnaPool = PositionManager(address(positionManager)).poolKey(tokenId_);\n\n        // check that msg.sender is owner of tokenId\n        if (IERC721(address(positionManager)).ownerOf(tokenId_) != msg.sender) revert NotOwnerOfDeposit();\n\n        StakeInfo storage stakeInfo = stakes[tokenId_];\n        stakeInfo.owner    = msg.sender;\n        stakeInfo.ajnaPool = ajnaPool;\n\n        uint256 curBurnEpoch = IPool(ajnaPool).currentBurnEpoch();\n\n        // record the staking epoch\n        stakeInfo.stakingEpoch = uint96(curBurnEpoch);\n\n        // initialize last time interaction at staking epoch\n        stakeInfo.lastClaimedEpoch = uint96(curBurnEpoch);\n\n        uint256[] memory positionIndexes = positionManager.getPositionIndexes(tokenId_);\n\n        for (uint256 i = 0; i < positionIndexes.length; ) {\n\n            uint256 bucketId = positionIndexes[i];\n\n            BucketState storage bucketState = stakeInfo.snapshot[bucketId];\n\n            // record the number of lps in bucket at the time of staking\n            bucketState.lpsAtStakeTime = uint128(positionManager.getLP(\n                tokenId_,\n                bucketId\n            ));\n            // record the bucket exchange rate at the time of staking\n            bucketState.rateAtStakeTime = uint128(IPool(ajnaPool).bucketExchangeRate(bucketId));\n\n            // iterations are bounded by array length (which is itself bounded), preventing overflow / underflow\n            unchecked { ++i; }\n        }\n\n        emit Stake(msg.sender, ajnaPool, tokenId_);\n\n        // transfer LP NFT to this contract\n        IERC721(address(positionManager)).transferFrom(msg.sender, address(this), tokenId_);\n\n        // calculate rewards for updating exchange rates, if any\n        uint256 updateReward = _updateBucketExchangeRates(\n            ajnaPool,\n            positionIndexes\n        );\n\n        // transfer rewards to sender\n        _transferAjnaRewards(updateReward);\n    }\n\n    /**\n     *  @inheritdoc IRewardsManagerOwnerActions\n     *  @dev    === Revert on ===\n     *  @dev    not owner `NotOwnerOfDeposit()`\n     *  @dev    === Emit events ===\n     *  @dev    - `ClaimRewards`\n     *  @dev    - `Unstake`\n     */\n    function unstake(\n        uint256 tokenId_\n    ) external override {\n        StakeInfo storage stakeInfo = stakes[tokenId_];\n\n        if (msg.sender != stakeInfo.owner) revert NotOwnerOfDeposit();\n\n        address ajnaPool = stakeInfo.ajnaPool;\n\n        // claim rewards, if any\n        _claimRewards(\n            stakeInfo,\n            tokenId_,\n            IPool(ajnaPool).currentBurnEpoch(),\n            false,\n            ajnaPool\n        );\n\n        // remove bucket snapshots recorded at the time of staking\n        uint256[] memory positionIndexes = positionManager.getPositionIndexes(tokenId_);\n        for (uint256 i = 0; i < positionIndexes.length; ) {\n            delete stakeInfo.snapshot[positionIndexes[i]]; // reset BucketState struct for current position\n\n            unchecked { ++i; }\n        }\n\n        // remove recorded stake info\n        delete stakes[tokenId_];\n\n        emit Unstake(msg.sender, ajnaPool, tokenId_);\n\n        // transfer LP NFT from contract to sender\n        IERC721(address(positionManager)).transferFrom(address(this), msg.sender, tokenId_);\n    }\n\n    /**\n     *  @inheritdoc IRewardsManagerOwnerActions\n     *  @dev    === Emit events ===\n     *  @dev    - `UpdateExchangeRates`\n     */\n    function updateBucketExchangeRatesAndClaim(\n        address pool_,\n        uint256[] calldata indexes_\n    ) external override returns (uint256 updateReward) {\n        updateReward = _updateBucketExchangeRates(pool_, indexes_);\n\n        // transfer rewards to sender\n        _transferAjnaRewards(updateReward);\n    }\n\n    /*******************************/\n    /*** External View Functions ***/\n    /*******************************/\n\n    /// @inheritdoc IRewardsManagerDerivedState\n    function calculateRewards(\n        uint256 tokenId_,\n        uint256 epochToClaim_\n    ) external view override returns (uint256 rewards_) {\n\n        address ajnaPool         = stakes[tokenId_].ajnaPool;\n        uint256 lastClaimedEpoch = stakes[tokenId_].lastClaimedEpoch;\n        uint256 stakingEpoch     = stakes[tokenId_].stakingEpoch;\n\n        uint256[] memory positionIndexes = positionManager.getPositionIndexesFiltered(tokenId_);\n\n        // iterate through all burn periods to calculate and claim rewards\n        for (uint256 epoch = lastClaimedEpoch; epoch < epochToClaim_; ) {\n\n            rewards_ += _calculateNextEpochRewards(\n                tokenId_,\n                epoch,\n                stakingEpoch,\n                ajnaPool,\n                positionIndexes\n            );\n\n            unchecked { ++epoch; }\n        }\n    }\n\n    /// @inheritdoc IRewardsManagerState\n    function getStakeInfo(\n        uint256 tokenId_\n    ) external view override returns (address, address, uint256) {\n        return (\n            stakes[tokenId_].owner,\n            stakes[tokenId_].ajnaPool,\n            stakes[tokenId_].lastClaimedEpoch\n        );\n    }\n\n    /// @inheritdoc IRewardsManagerState\n    function getBucketStateStakeInfo(\n        uint256 tokenId_,\n        uint256 bucketId_\n    ) external view override returns (uint256, uint256) {\n        return (\n            stakes[tokenId_].snapshot[bucketId_].lpsAtStakeTime,\n            stakes[tokenId_].snapshot[bucketId_].rateAtStakeTime\n        );\n    }\n\n    /**************************/\n    /*** Internal Functions ***/\n    /**************************/\n\n    /**\n     *  @notice Calculate the amount of rewards that have been accumulated by a staked `NFT`.\n     *  @dev    Rewards are calculated as the difference in exchange rates between the last interaction burn event and the current burn event.\n     *  @param  tokenId_      `ID` of the staked `LP` `NFT`.\n     *  @param  epochToClaim_ The burn epoch to claim rewards for (rewards calculation starts from the last claimed epoch).\n     *  @return rewards_      Amount of rewards earned by the `NFT`.\n     */\n    function _calculateAndClaimRewards(\n        uint256 tokenId_,\n        uint256 epochToClaim_\n    ) internal returns (uint256 rewards_) {\n\n        address ajnaPool         = stakes[tokenId_].ajnaPool;\n        uint256 lastClaimedEpoch = stakes[tokenId_].lastClaimedEpoch;\n        uint256 stakingEpoch     = stakes[tokenId_].stakingEpoch;\n\n        uint256[] memory positionIndexes = positionManager.getPositionIndexesFiltered(tokenId_);\n\n        // iterate through all burn periods to calculate and claim rewards\n        for (uint256 epoch = lastClaimedEpoch; epoch < epochToClaim_; ) {\n\n            uint256 nextEpochRewards = _calculateNextEpochRewards(\n                tokenId_,\n                epoch,\n                stakingEpoch,\n                ajnaPool,\n                positionIndexes\n            );\n\n            rewards_ += nextEpochRewards;\n\n            unchecked { ++epoch; }\n\n            // update epoch token claim trackers\n            rewardsClaimed[epoch]           += nextEpochRewards;\n            isEpochClaimed[tokenId_][epoch] = true;\n        }\n    }\n\n    /**\n     *  @notice Calculate the amount of rewards that have been accumulated by a staked `NFT` in next epoch.\n     *  @dev    Rewards are calculated as the difference in exchange rates between the last interaction burn event and the current burn event.\n     *  @param  tokenId_         `ID` of the staked `LP` `NFT`.\n     *  @param  epoch_           The current epoch.\n     *  @param  stakingEpoch_    The epoch in which token was staked.\n     *  @param  ajnaPool_        Address of the pool.\n     *  @param  positionIndexes_ Bucket ids associated with `NFT` staked.\n     *  @return epochRewards_    Calculated rewards in epoch.\n     */\n    function _calculateNextEpochRewards(\n        uint256 tokenId_,\n        uint256 epoch_,\n        uint256 stakingEpoch_,\n        address ajnaPool_,\n        uint256[] memory positionIndexes_\n    ) internal view returns (uint256 epochRewards_) {\n\n        uint256 nextEpoch = epoch_ + 1;\n        uint256 claimedRewardsInNextEpoch = rewardsClaimed[nextEpoch];\n        uint256 bucketIndex;\n        uint256 interestEarned;\n\n        // iterate through all buckets and calculate epoch rewards for\n        for (uint256 i = 0; i < positionIndexes_.length; ) {\n            bucketIndex = positionIndexes_[i];\n            BucketState memory bucketSnapshot = stakes[tokenId_].snapshot[bucketIndex];\n\n            uint256 bucketRate;\n            if (epoch_ != stakingEpoch_) {\n\n                // if staked in a previous epoch then use the initial exchange rate of epoch\n                bucketRate = bucketExchangeRates[ajnaPool_][bucketIndex][epoch_];\n            } else {\n\n                // if staked during the epoch then use the bucket rate at the time of staking\n                bucketRate = bucketSnapshot.rateAtStakeTime;\n            }\n\n            // calculate the amount of interest accrued in current epoch\n            interestEarned += _calculateExchangeRateInterestEarned(\n                ajnaPool_,\n                nextEpoch,\n                bucketIndex,\n                bucketSnapshot.lpsAtStakeTime,\n                bucketRate\n            ); \n            unchecked { ++i; }\n        }\n\n        // calculate and accumulate rewards if interest earned\n        if (interestEarned != 0) {\n            epochRewards_ = _calculateNewRewards(\n                ajnaPool_,\n                interestEarned,\n                nextEpoch,\n                epoch_,\n                claimedRewardsInNextEpoch\n            );\n        }\n    }\n\n    /**\n     *  @notice Calculate the amount of interest that has accrued to a lender in a bucket based upon their `LP`.\n     *  @param  pool_           Address of the pool whose exchange rates are being checked.\n     *  @param  nextEventEpoch_ The next event epoch to check the exchange rate for.\n     *  @param  bucketIndex_    Index of the bucket to check the exchange rate for.\n     *  @param  bucketLP_       Amount of `LP` in bucket.\n     *  @param  exchangeRate_   Exchange rate in current epoch.\n     *  @return interestEarned_ The amount of interest accrued.\n     */\n    function _calculateExchangeRateInterestEarned(\n        address pool_,\n        uint256 nextEventEpoch_,\n        uint256 bucketIndex_,\n        uint256 bucketLP_,\n        uint256 exchangeRate_\n    ) internal view returns (uint256 interestEarned_) {\n\n        if (exchangeRate_ != 0) {\n\n            uint256 nextExchangeRate = bucketExchangeRates[pool_][bucketIndex_][nextEventEpoch_];\n\n            // calculate interest earned only if next exchange rate is higher than current exchange rate\n            if (nextExchangeRate > exchangeRate_) {\n\n                // calculate the equivalent amount of quote tokens given the stakes lp balance,\n                // and the exchange rate at the next and current burn events\n                interestEarned_ = Maths.wmul(nextExchangeRate - exchangeRate_, bucketLP_);\n            }\n\n        }\n    }\n\n    /**\n     *  @notice Calculate new rewards between current and next epoch, based on earned interest.\n     *  @param  ajnaPool_              Address of the pool.\n     *  @param  interestEarned_        The amount of interest accrued to current epoch.\n     *  @param  nextEpoch_             The next burn event epoch to calculate new rewards.\n     *  @param  epoch_                 The current burn event epoch to calculate new rewards.\n     *  @param  rewardsClaimedInEpoch_ Rewards claimed in epoch.\n     *  @return newRewards_            New rewards between current and next burn event epoch.\n     */\n    function _calculateNewRewards(\n        address ajnaPool_,\n        uint256 interestEarned_,\n        uint256 nextEpoch_,\n        uint256 epoch_,\n        uint256 rewardsClaimedInEpoch_\n    ) internal view returns (uint256 newRewards_) {\n        (\n            ,\n            // total interest accumulated by the pool over the claim period\n            uint256 totalBurnedInPeriod,\n            // total tokens burned over the claim period\n            uint256 totalInterestEarnedInPeriod\n        ) = _getPoolAccumulators(ajnaPool_, nextEpoch_, epoch_);\n\n        // calculate rewards earned\n        newRewards_ = totalInterestEarnedInPeriod == 0 ? 0 : Maths.wmul(\n            REWARD_FACTOR,\n            Maths.wdiv(\n                Maths.wmul(interestEarned_, totalBurnedInPeriod),\n                totalInterestEarnedInPeriod\n            )\n        );\n\n        uint256 rewardsCapped = Maths.wmul(REWARD_CAP, totalBurnedInPeriod);\n\n        // Check rewards claimed - check that less than 80% of the tokens for a given burn event have been claimed.\n        if (rewardsClaimedInEpoch_ + newRewards_ > rewardsCapped) {\n\n            // set claim reward to difference between cap and reward\n            newRewards_ = rewardsCapped - rewardsClaimedInEpoch_;\n        }\n    }\n\n    /**\n     *  @notice Claim rewards that have been accumulated by a staked `NFT`.\n     *  @param  stakeInfo_     `StakeInfo` struct containing details of stake to claim rewards for.\n     *  @param  tokenId_       `ID` of the staked `LP` `NFT`.\n     *  @param  epochToClaim_  The burn epoch to claim rewards for (rewards calculation starts from the last claimed epoch)\n     *  @param  validateEpoch_ True if the epoch is received as a parameter and needs to be validated (lower or equal with latest epoch).\n     *  @param  ajnaPool_      Address of `Ajna` pool associated with the stake.\n     */\n    function _claimRewards(\n        StakeInfo storage stakeInfo_,\n        uint256 tokenId_,\n        uint256 epochToClaim_,\n        bool validateEpoch_,\n        address ajnaPool_\n    ) internal {\n\n        // revert if higher epoch to claim than current burn epoch\n        if (validateEpoch_ && epochToClaim_ > IPool(ajnaPool_).currentBurnEpoch()) revert EpochNotAvailable();\n\n        // update bucket exchange rates and claim associated rewards\n        uint256 rewardsEarned = _updateBucketExchangeRates(\n            ajnaPool_,\n            positionManager.getPositionIndexes(tokenId_)\n        );\n\n        rewardsEarned += _calculateAndClaimRewards(tokenId_, epochToClaim_);\n\n        uint256[] memory burnEpochsClaimed = _getBurnEpochsClaimed(\n            stakeInfo_.lastClaimedEpoch,\n            epochToClaim_\n        );\n\n        emit ClaimRewards(\n            msg.sender,\n            ajnaPool_,\n            tokenId_,\n            burnEpochsClaimed,\n            rewardsEarned\n        );\n\n        // update last interaction burn event\n        stakeInfo_.lastClaimedEpoch = uint96(epochToClaim_);\n\n        // transfer rewards to sender\n        _transferAjnaRewards(rewardsEarned);\n    }\n\n    /**\n     *  @notice Retrieve an array of burn epochs from which a depositor has claimed rewards.\n     *  @param  lastClaimedEpoch_      The last burn period in which a depositor claimed rewards.\n     *  @param  burnEpochToStartClaim_ The most recent burn period from a depositor earned rewards.\n     *  @return burnEpochsClaimed_     Array of burn epochs from which a depositor has claimed rewards.\n     */\n    function _getBurnEpochsClaimed(\n        uint256 lastClaimedEpoch_,\n        uint256 burnEpochToStartClaim_\n    ) internal pure returns (uint256[] memory burnEpochsClaimed_) {\n        uint256 numEpochsClaimed = burnEpochToStartClaim_ - lastClaimedEpoch_;\n\n        burnEpochsClaimed_ = new uint256[](numEpochsClaimed);\n\n        uint256 i;\n        uint256 claimEpoch = lastClaimedEpoch_ + 1;\n        while (claimEpoch <= burnEpochToStartClaim_) {\n            burnEpochsClaimed_[i] = claimEpoch;\n\n            // iterations are bounded by array length (which is itself bounded), preventing overflow / underflow\n            unchecked {\n                ++i;\n                ++claimEpoch;\n            }\n        }\n    }\n\n    /**\n     *  @notice Retrieve the total ajna tokens burned and total interest earned by a pool since a given block.\n     *  @param  pool_                  Address of the `Ajna` pool to retrieve accumulators of.\n     *  @param  currentBurnEventEpoch_ The latest burn event.\n     *  @param  lastBurnEventEpoch_    The burn event to use as checkpoint since which values have accumulated.\n     *  @return Timestamp of the latest burn event.\n     *  @return Total `Ajna` tokens burned by the pool since the last burn event.\n     *  @return Total interest earned by the pool since the last burn event.\n     */\n    function _getPoolAccumulators(\n        address pool_,\n        uint256 currentBurnEventEpoch_,\n        uint256 lastBurnEventEpoch_\n    ) internal view returns (uint256, uint256, uint256) {\n        (\n            uint256 currentBurnTime,\n            uint256 totalInterestLatest,\n            uint256 totalBurnedLatest\n        ) = IPool(pool_).burnInfo(currentBurnEventEpoch_);\n\n        (\n            ,\n            uint256 totalInterestAtBlock,\n            uint256 totalBurnedAtBlock\n        ) = IPool(pool_).burnInfo(lastBurnEventEpoch_);\n\n        uint256 totalBurned   = totalBurnedLatest   != 0 ? totalBurnedLatest   - totalBurnedAtBlock   : totalBurnedAtBlock;\n        uint256 totalInterest = totalInterestLatest != 0 ? totalInterestLatest - totalInterestAtBlock : totalInterestAtBlock;\n\n        return (\n            currentBurnTime,\n            totalBurned,\n            totalInterest\n        );\n    }\n\n    /**\n     *  @notice Update the exchange rate of a list of buckets.\n     *  @dev    Called as part of `stake`, `unstake`, and `claimRewards`, as well as `updateBucketExchangeRatesAndClaim`.\n     *  @dev    Caller can claim `5%` of the rewards that have accumulated to each bucket since the last burn event, if it hasn't already been updated.\n     *  @param  pool_           Address of the pool whose exchange rates are being updated.\n     *  @param  indexes_        List of bucket indexes to be updated.\n     *  @return updatedRewards_ Update exchange rate rewards.\n     */\n    function _updateBucketExchangeRates(\n        address pool_,\n        uint256[] memory indexes_\n    ) internal returns (uint256 updatedRewards_) {\n        // get the current burn epoch from the given pool\n        uint256 curBurnEpoch = IPool(pool_).currentBurnEpoch();\n\n        // update exchange rates only if the pool has not yet burned any tokens without calcula"
    }
  ]
}