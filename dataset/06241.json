{
  "Title": "[H-33] `BaseTOFTLeverageModule.sol`: `leverageDownInternal` tries to burn tokens from wrong address",
  "Content": "\n<https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/modules/BaseTOFTLeverageModule.sol#L212> \n\n<https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/modules/BaseTOFTLeverageModule.sol#L269-L277>\n\nThe function `sendForLeverage` is used to interact with the USDO token on a different chain. Lets assume the origin of the tx is chain A, and the destination is chain B. The BaseTOFT contract sends a message through the lz endpoints to make a call in the destination chain.\n\nThe flow of control is as follows:\n\nChain A : user -call-> BaseTOFT.sol:`sendForLeverage` -delegateCall-> BaseTOFTLeverageModule.sol:`sendForLeverage` -call-> lzEndpointA\n\nChain B : lzEndpointB -call-> BaseTOFT.sol:`_nonblockingLzReceive` -delegateCall-> BaseTOFTLeverageModule.sol:`leverageDown` -delegateCall-> `leverageDownInternal`\n\nFor the last call to `leverageDownInternal`, the `msg.sender` is the lzEndpointB. This is because all the calls since then have been delegate calls, and thus msg.sender has not been able to change. We analyze the `leverageDownInternal` function in this context.\n\n```solidity\nfunction leverageDownInternal(\n        uint256 amount,\n        IUSDOBase.ILeverageSwapData memory swapData,\n        IUSDOBase.ILeverageExternalContractsData memory externalData,\n        IUSDOBase.ILeverageLZData memory lzData,\n        address leverageFor\n    ) public payable {\n        _unwrap(address(this), amount);\n```\n\nThe very first operation is to do an unwrap of the mTapiocaOFT token. This is done by calling `_unwrap` defined in the **same** **contract** as shown.\n\n```solidity\nfunction _unwrap(address _toAddress, uint256 _amount) private {\n    _burn(msg.sender, _amount);\n\n    if (erc20 == address(0)) {\n        _safeTransferETH(_toAddress, _amount);\n    } else {\n        IERC20(erc20).safeTransfer(_toAddress, _amount);\n    }\n}\n```\n\nHere we see the contract is trying to burn tokens from the `msg.sender` address. But the issue is in this context, the `msg.sender` is the lzEndpoint on chain B who is doing the call, and they dont have any TOFT tokens there. Thus this call will revert.\n\nThe TOFT tokens are actually held within the same contract where the execution is happening. This is because in the `leverageDown` function, we see the contract credit itself with TOFT tokens.\n\n```solidity\n if (!credited) {\n    _creditTo(_srcChainId, address(this), amount);\n    creditedPackets[_srcChainId][_srcAddress][_nonce] = true;\n}\n```\n\nThus the tokens are actually present in `address(this)` and not in `msg.sender`. Thus the burn should be done from `address(this)` and not `msg.sender`. Thus all cross chain calls for this function will fail and revert.\n\nSince this leads to broken functionality, this is considered a high severity issue.\n\n### Proof of Concept\n\nSince no test exists for the `sendForLeverage` function, no POC is provided. However the flow of control and detailed explanation is provided above.\n\n### Recommended Mitigation Steps\n\nRun `_burn(address(this),amount)` to burn the tokens instead of unwrapping. Then do the eth/erc20 transfer from the contract.\n\n**[0xRektora (Tapioca) confirmed via duplicate issue 725](https://github.com/code-423n4/2023-07-tapioca-findings/issues/725)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-07-tapioca",
  "Code": [
    {
      "filename": "contracts/tOFT/modules/BaseTOFTLeverageModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\n//LZ\nimport \"tapioca-sdk/dist/contracts/libraries/LzLib.sol\";\n\n//TAPIOCA\nimport {IUSDOBase} from \"tapioca-periph/contracts/interfaces/IUSDO.sol\";\nimport \"tapioca-periph/contracts/interfaces/ISwapper.sol\";\nimport \"tapioca-periph/contracts/interfaces/IMagnetar.sol\";\nimport \"tapioca-periph/contracts/interfaces/ISingularity.sol\";\nimport \"tapioca-periph/contracts/interfaces/IPermitBorrow.sol\";\nimport \"tapioca-periph/contracts/interfaces/IPermitAll.sol\";\nimport \"tapioca-periph/contracts/interfaces/ITapiocaOptionsBroker.sol\";\nimport \"tapioca-periph/contracts/interfaces/ITapiocaOptionLiquidityProvision.sol\";\n\nimport \"../BaseTOFTStorage.sol\";\n\n/// @title tOFT leverage module\n/// @notice tOFT module for leverage type actions\ncontract BaseTOFTLeverageModule is BaseTOFTStorage {\n    using SafeERC20 for IERC20;\n    using BytesLib for bytes;\n\n    constructor(\n        address _lzEndpoint,\n        address _erc20,\n        IYieldBoxBase _yieldBox,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimal,\n        uint256 _hostChainID\n    )\n        BaseTOFTStorage(\n            _lzEndpoint,\n            _erc20,\n            _yieldBox,\n            _name,\n            _symbol,\n            _decimal,\n            _hostChainID\n        )\n    {}\n\n    function initMultiSell(\n        address from,\n        uint256 share,\n        IUSDOBase.ILeverageSwapData calldata swapData,\n        IUSDOBase.ILeverageLZData calldata lzData,\n        IUSDOBase.ILeverageExternalContractsData calldata externalData,\n        bytes calldata airdropAdapterParams,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        bytes32 senderBytes = LzLib.addressToBytes32(from);\n\n        bytes memory lzPayload = abi.encode(\n            PT_MARKET_MULTIHOP_SELL,\n            senderBytes,\n            from,\n            share,\n            swapData,\n            lzData,\n            externalData,\n            airdropAdapterParams,\n            approvals\n        );\n\n        _lzSend(\n            lzData.lzSrcChainId,\n            lzPayload,\n            payable(lzData.refundAddress),\n            lzData.zroPaymentAddress,\n            airdropAdapterParams,\n            msg.value\n        );\n        emit SendToChain(lzData.lzSrcChainId, msg.sender, senderBytes, 0);\n    }\n\n    function sendForLeverage(\n        uint256 amount,\n        address leverageFor,\n        IUSDOBase.ILeverageLZData calldata lzData,\n        IUSDOBase.ILeverageSwapData calldata swapData,\n        IUSDOBase.ILeverageExternalContractsData calldata externalData\n    ) external payable {\n        bytes32 senderBytes = LzLib.addressToBytes32(msg.sender);\n        _debitFrom(msg.sender, lzEndpoint.getChainId(), senderBytes, amount);\n\n        bytes memory lzPayload = abi.encode(\n            PT_LEVERAGE_MARKET_DOWN,\n            senderBytes,\n            amount,\n            swapData,\n            externalData,\n            lzData,\n            leverageFor\n        );\n\n        _lzSend(\n            lzData.lzDstChainId,\n            lzPayload,\n            payable(lzData.refundAddress),\n            lzData.zroPaymentAddress,\n            lzData.dstAirdropAdapterParam,\n            msg.value\n        );\n        emit SendToChain(lzData.lzDstChainId, msg.sender, senderBytes, amount);\n    }\n\n    //---Destination calls---\n    function multiHop(bytes memory _payload) public {\n        (\n            ,\n            ,\n            address from,\n            uint256 share,\n            IUSDOBase.ILeverageSwapData memory swapData,\n            IUSDOBase.ILeverageLZData memory lzData,\n            IUSDOBase.ILeverageExternalContractsData memory externalData,\n            ICommonData.IApproval[] memory approvals\n        ) = abi.decode(\n                _payload,\n                (\n                    uint16,\n                    bytes32,\n                    address,\n                    uint256,\n                    IUSDOBase.ILeverageSwapData,\n                    IUSDOBase.ILeverageLZData,\n                    IUSDOBase.ILeverageExternalContractsData,\n                    ICommonData.IApproval[]\n                )\n            );\n\n        if (approvals.length > 0) {\n            _callApproval(approvals);\n        }\n\n        ISingularity(externalData.srcMarket).multiHopSellCollateral(\n            from,\n            share,\n            swapData,\n            lzData,\n            externalData\n        );\n    }\n\n    function leverageDown(\n        address module,\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) public {\n        (\n            ,\n            ,\n            uint256 amount,\n            IUSDOBase.ILeverageSwapData memory swapData,\n            IUSDOBase.ILeverageExternalContractsData memory externalData,\n            IUSDOBase.ILeverageLZData memory lzData,\n            address leverageFor\n        ) = abi.decode(\n                _payload,\n                (\n                    uint16,\n                    bytes32,\n                    uint256,\n                    IUSDOBase.ILeverageSwapData,\n                    IUSDOBase.ILeverageExternalContractsData,\n                    IUSDOBase.ILeverageLZData,\n                    address\n                )\n            );\n\n        uint256 balanceBefore = balanceOf(address(this));\n        bool credited = creditedPackets[_srcChainId][_srcAddress][_nonce];\n        if (!credited) {\n            _creditTo(_srcChainId, address(this), amount);\n            creditedPackets[_srcChainId][_srcAddress][_nonce] = true;\n        }\n        uint256 balanceAfter = balanceOf(address(this));\n\n        (bool success, bytes memory reason) = module.delegatecall(\n            abi.encodeWithSelector(\n                this.leverageDownInternal.selector,\n                amount,\n                swapData,\n                externalData,\n                lzData,\n                leverageFor\n            )\n        );\n\n        if (!success) {\n            if (balanceAfter - balanceBefore >= amount) {\n                IERC20(address(this)).safeTransfer(leverageFor, amount);\n            }\n            revert(_getRevertMsg(reason)); //forward revert because it's handled by the main executor\n        }\n\n        emit ReceiveFromChain(_srcChainId, leverageFor, amount);\n    }\n\n    function leverageDownInternal(\n        uint256 amount,\n        IUSDOBase.ILeverageSwapData memory swapData,\n        IUSDOBase.ILeverageExternalContractsData memory externalData,\n        IUSDOBase.ILeverageLZData memory lzData,\n        address leverageFor\n    ) public payable {\n        _unwrap(address(this), amount);\n\n        //swap to USDO\n        IERC20(erc20).approve(externalData.swapper, amount);\n        ISwapper.SwapData memory _swapperData = ISwapper(externalData.swapper)\n            .buildSwapData(erc20, swapData.tokenOut, amount, 0, false, false);\n        (uint256 amountOut, ) = ISwapper(externalData.swapper).swap(\n            _swapperData,\n            swapData.amountOutMin,\n            address(this),\n            swapData.data\n        );\n\n        //repay\n        uint256 repayableAmount = IMagnetar(externalData.magnetar)\n            .getBorrowPartForAmount(externalData.srcMarket, amountOut);\n        ICommonData.IApproval[] memory approvals;\n        IUSDOBase(swapData.tokenOut).sendAndLendOrRepay{\n            value: address(this).balance\n        }(\n            address(this),\n            leverageFor,\n            lzData.lzSrcChainId,\n            lzData.zroPaymentAddress,\n            IUSDOBase.ILendOrRepayParams({\n                repay: true,\n                depositAmount: amountOut,\n                repayAmount: repayableAmount,\n                marketHelper: externalData.magnetar,\n                market: externalData.srcMarket,\n                removeCollateral: false,\n                removeCollateralShare: 0,\n                lockData: ITapiocaOptionLiquidityProvision.IOptionsLockData({\n                    lock: false,\n                    target: address(0),\n                    lockDuration: 0,\n                    amount: 0,\n                    fraction: 0\n                }),\n                participateData: ITapiocaOptionsBroker.IOptionsParticipateData({\n                    participate: false,\n                    target: address(0),\n                    tOLPTokenId: 0\n                })\n            }),\n            approvals,\n            ICommonData.IWithdrawParams({\n                withdraw: false,\n                withdrawLzFeeAmount: 0,\n                withdrawOnOtherChain: false,\n                withdrawLzChainId: 0,\n                withdrawAdapterParams: \"0x\"\n            }),\n            LzLib.buildDefaultAdapterParams(lzData.srcExtraGasLimit)\n        );\n    }\n\n    function _unwrap(address _toAddress, uint256 _amount) private {\n        _burn(msg.sender, _amount);\n\n        if (erc20 == address(0)) {\n            _safeTransferETH(_toAddress, _amount);\n        } else {\n            IERC20(erc20).safeTransfer(_toAddress, _amount);\n        }\n    }\n\n    function _safeTransferETH(address to, uint256 amount) private {\n        (bool sent, ) = to.call{value: amount}(\"\");\n        require(sent, \"TOFT_failed\");\n    }\n\n    function _callApproval(ICommonData.IApproval[] memory approvals) private {\n        for (uint256 i = 0; i < approvals.length; ) {\n            if (approvals[i].permitBorrow) {\n                try\n                    IPermitBorrow(approvals[i].target).permitBorrow(\n                        approvals[i].owner,\n                        approvals[i].spender,\n                        approvals[i].value,\n                        approvals[i].deadline,\n                        approvals[i].v,\n                        approvals[i].r,\n                        approvals[i].s\n                    )\n                {} catch Error(string memory reason) {\n                    if (!approvals[i].allowFailure) {\n                        revert(reason);\n                    }\n                }\n            } else if (approvals[i].permitAll) {\n                try\n                    IPermitAll(approvals[i].target).permitAll(\n                        approvals[i].owner,\n                        approvals[i].spender,\n                        approvals[i].deadline,\n                        approvals[i].v,\n                        approvals[i].r,\n                        approvals[i].s\n                    )\n                {} catch Error(string memory reason) {\n                    if (!approvals[i].allowFailure) {\n                        revert(reason);\n                    }\n                }\n            } else {\n                try\n                    IERC20Permit(approvals[i].target).permit(\n                        approvals[i].owner,\n                        approvals[i].spender,\n                        approvals[i].value,\n                        approvals[i].deadline,\n                        approvals[i].v,\n                        approvals[i].r,\n                        approvals[i].s\n                    )\n                {} catch Error(string memory reason) {\n                    if (!approvals[i].allowFailure) {\n                        revert(reason);\n                    }\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/tOFT/modules/BaseTOFTLeverageModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\n//LZ\nimport \"tapioca-sdk/dist/contracts/libraries/LzLib.sol\";\n\n//TAPIOCA\nimport {IUSDOBase} from \"tapioca-periph/contracts/interfaces/IUSDO.sol\";\nimport \"tapioca-periph/contracts/interfaces/ISwapper.sol\";\nimport \"tapioca-periph/contracts/interfaces/IMagnetar.sol\";\nimport \"tapioca-periph/contracts/interfaces/ISingularity.sol\";\nimport \"tapioca-periph/contracts/interfaces/IPermitBorrow.sol\";\nimport \"tapioca-periph/contracts/interfaces/IPermitAll.sol\";\nimport \"tapioca-periph/contracts/interfaces/ITapiocaOptionsBroker.sol\";\nimport \"tapioca-periph/contracts/interfaces/ITapiocaOptionLiquidityProvision.sol\";\n\nimport \"../BaseTOFTStorage.sol\";\n\n/// @title tOFT leverage module\n/// @notice tOFT module for leverage type actions\ncontract BaseTOFTLeverageModule is BaseTOFTStorage {\n    using SafeERC20 for IERC20;\n    using BytesLib for bytes;\n\n    constructor(\n        address _lzEndpoint,\n        address _erc20,\n        IYieldBoxBase _yieldBox,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimal,\n        uint256 _hostChainID\n    )\n        BaseTOFTStorage(\n            _lzEndpoint,\n            _erc20,\n            _yieldBox,\n            _name,\n            _symbol,\n            _decimal,\n            _hostChainID\n        )\n    {}\n\n    function initMultiSell(\n        address from,\n        uint256 share,\n        IUSDOBase.ILeverageSwapData calldata swapData,\n        IUSDOBase.ILeverageLZData calldata lzData,\n        IUSDOBase.ILeverageExternalContractsData calldata externalData,\n        bytes calldata airdropAdapterParams,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        bytes32 senderBytes = LzLib.addressToBytes32(from);\n\n        bytes memory lzPayload = abi.encode(\n            PT_MARKET_MULTIHOP_SELL,\n            senderBytes,\n            from,\n            share,\n            swapData,\n            lzData,\n            externalData,\n            airdropAdapterParams,\n            approvals\n        );\n\n        _lzSend(\n            lzData.lzSrcChainId,\n            lzPayload,\n            payable(lzData.refundAddress),\n            lzData.zroPaymentAddress,\n            airdropAdapterParams,\n            msg.value\n        );\n        emit SendToChain(lzData.lzSrcChainId, msg.sender, senderBytes, 0);\n    }\n\n    function sendForLeverage(\n        uint256 amount,\n        address leverageFor,\n        IUSDOBase.ILeverageLZData calldata lzData,\n        IUSDOBase.ILeverageSwapData calldata swapData,\n        IUSDOBase.ILeverageExternalContractsData calldata externalData\n    ) external payable {\n        bytes32 senderBytes = LzLib.addressToBytes32(msg.sender);\n        _debitFrom(msg.sender, lzEndpoint.getChainId(), senderBytes, amount);\n\n        bytes memory lzPayload = abi.encode(\n            PT_LEVERAGE_MARKET_DOWN,\n            senderBytes,\n            amount,\n            swapData,\n            externalData,\n            lzData,\n            leverageFor\n        );\n\n        _lzSend(\n            lzData.lzDstChainId,\n            lzPayload,\n            payable(lzData.refundAddress),\n            lzData.zroPaymentAddress,\n            lzData.dstAirdropAdapterParam,\n            msg.value\n        );\n        emit SendToChain(lzData.lzDstChainId, msg.sender, senderBytes, amount);\n    }\n\n    //---Destination calls---\n    function multiHop(bytes memory _payload) public {\n        (\n            ,\n            ,\n            address from,\n            uint256 share,\n            IUSDOBase.ILeverageSwapData memory swapData,\n            IUSDOBase.ILeverageLZData memory lzData,\n            IUSDOBase.ILeverageExternalContractsData memory externalData,\n            ICommonData.IApproval[] memory approvals\n        ) = abi.decode(\n                _payload,\n                (\n                    uint16,\n                    bytes32,\n                    address,\n                    uint256,\n                    IUSDOBase.ILeverageSwapData,\n                    IUSDOBase.ILeverageLZData,\n                    IUSDOBase.ILeverageExternalContractsData,\n                    ICommonData.IApproval[]\n                )\n            );\n\n        if (approvals.length > 0) {\n            _callApproval(approvals);\n        }\n\n        ISingularity(externalData.srcMarket).multiHopSellCollateral(\n            from,\n            share,\n            swapData,\n            lzData,\n            externalData\n        );\n    }\n\n    function leverageDown(\n        address module,\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) public {\n        (\n            ,\n            ,\n            uint256 amount,\n            IUSDOBase.ILeverageSwapData memory swapData,\n            IUSDOBase.ILeverageExternalContractsData memory externalData,\n            IUSDOBase.ILeverageLZData memory lzData,\n            address leverageFor\n        ) = abi.decode(\n                _payload,\n                (\n                    uint16,\n                    bytes32,\n                    uint256,\n                    IUSDOBase.ILeverageSwapData,\n                    IUSDOBase.ILeverageExternalContractsData,\n                    IUSDOBase.ILeverageLZData,\n                    address\n                )\n            );\n\n        uint256 balanceBefore = balanceOf(address(this));\n        bool credited = creditedPackets[_srcChainId][_srcAddress][_nonce];\n        if (!credited) {\n            _creditTo(_srcChainId, address(this), amount);\n            creditedPackets[_srcChainId][_srcAddress][_nonce] = true;\n        }\n        uint256 balanceAfter = balanceOf(address(this));\n\n        (bool success, bytes memory reason) = module.delegatecall(\n            abi.encodeWithSelector(\n                this.leverageDownInternal.selector,\n                amount,\n                swapData,\n                externalData,\n                lzData,\n                leverageFor\n            )\n        );\n\n        if (!success) {\n            if (balanceAfter - balanceBefore >= amount) {\n                IERC20(address(this)).safeTransfer(leverageFor, amount);\n            }\n            revert(_getRevertMsg(reason)); //forward revert because it's handled by the main executor\n        }\n\n        emit ReceiveFromChain(_srcChainId, leverageFor, amount);\n    }\n\n    function leverageDownInternal(\n        uint256 amount,\n        IUSDOBase.ILeverageSwapData memory swapData,\n        IUSDOBase.ILeverageExternalContractsData memory externalData,\n        IUSDOBase.ILeverageLZData memory lzData,\n        address leverageFor\n    ) public payable {\n        _unwrap(address(this), amount);\n\n        //swap to USDO\n        IERC20(erc20).approve(externalData.swapper, amount);\n        ISwapper.SwapData memory _swapperData = ISwapper(externalData.swapper)\n            .buildSwapData(erc20, swapData.tokenOut, amount, 0, false, false);\n        (uint256 amountOut, ) = ISwapper(externalData.swapper).swap(\n            _swapperData,\n            swapData.amountOutMin,\n            address(this),\n            swapData.data\n        );\n\n        //repay\n        uint256 repayableAmount = IMagnetar(externalData.magnetar)\n            .getBorrowPartForAmount(externalData.srcMarket, amountOut);\n        ICommonData.IApproval[] memory approvals;\n        IUSDOBase(swapData.tokenOut).sendAndLendOrRepay{\n            value: address(this).balance\n        }(\n            address(this),\n            leverageFor,\n            lzData.lzSrcChainId,\n            lzData.zroPaymentAddress,\n            IUSDOBase.ILendOrRepayParams({\n                repay: true,\n                depositAmount: amountOut,\n                repayAmount: repayableAmount,\n                marketHelper: externalData.magnetar,\n                market: externalData.srcMarket,\n                removeCollateral: false,\n                removeCollateralShare: 0,\n                lockData: ITapiocaOptionLiquidityProvision.IOptionsLockData({\n                    lock: false,\n                    target: address(0),\n                    lockDuration: 0,\n                    amount: 0,\n                    fraction: 0\n                }),\n                participateData: ITapiocaOptionsBroker.IOptionsParticipateData({\n                    participate: false,\n                    target: address(0),\n                    tOLPTokenId: 0\n                })\n            }),\n            approvals,\n            ICommonData.IWithdrawParams({\n                withdraw: false,\n                withdrawLzFeeAmount: 0,\n                withdrawOnOtherChain: false,\n                withdrawLzChainId: 0,\n                withdrawAdapterParams: \"0x\"\n            }),\n            LzLib.buildDefaultAdapterParams(lzData.srcExtraGasLimit)\n        );\n    }\n\n    function _unwrap(address _toAddress, uint256 _amount) private {\n        _burn(msg.sender, _amount);\n\n        if (erc20 == address(0)) {\n            _safeTransferETH(_toAddress, _amount);\n        } else {\n            IERC20(erc20).safeTransfer(_toAddress, _amount);\n        }\n    }\n\n    function _safeTransferETH(address to, uint256 amount) private {\n        (bool sent, ) = to.call{value: amount}(\"\");\n        require(sent, \"TOFT_failed\");\n    }\n\n    function _callApproval(ICommonData.IApproval[] memory approvals) private {\n        for (uint256 i = 0; i < approvals.length; ) {\n            if (approvals[i].permitBorrow) {\n                try\n                    IPermitBorrow(approvals[i].target).permitBorrow(\n                        approvals[i].owner,\n                        approvals[i].spender,\n                        approvals[i].value,\n                        approvals[i].deadline,\n                        approvals[i].v,\n                        approvals[i].r,\n                        approvals[i].s\n                    )\n                {} catch Error(string memory reason) {\n                    if (!approvals[i].allowFailure) {\n                        revert(reason);\n                    }\n                }\n            } else if (approvals[i].permitAll) {\n                try\n                    IPermitAll(approvals[i].target).permitAll(\n                        approvals[i].owner,\n                        approvals[i].spender,\n                        approvals[i].deadline,\n                        approvals[i].v,\n                        approvals[i].r,\n                        approvals[i].s\n                    )\n                {} catch Error(string memory reason) {\n                    if (!approvals[i].allowFailure) {\n                        revert(reason);\n                    }\n                }\n            } else {\n                try\n                    IERC20Permit(approvals[i].target).permit(\n                        approvals[i].owner,\n                        approvals[i].spender,\n                        approvals[i].value,\n                        approvals[i].deadline,\n                        approvals[i].v,\n                        approvals[i].r,\n                        approvals[i].s\n                    )\n                {} catch Error(string memory reason) {\n                    if (!approvals[i].allowFailure) {\n                        revert(reason);\n                    }\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    }
  ]
}