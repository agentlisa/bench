{
  "Title": "Duplicated code",
  "Content": "The internal logic of the `poolTokenAmountToBurn` functions in the [`BNTPool`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/pools/BNTPool.sol#L294-L308) and [`PoolCollection`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/pools/PoolCollection.sol#L431-L451) contracts are essentially duplicates.\n\n\nDuplicating code can lead to issues later in the development lifecycle and leaves the project more prone to the introduction of errors. Such errors can inadvertently be introduced when functionality changes are not replicated across all instances of code that should be identical.\n\n\nRather than duplicating code, consider having just one contract or library containing the duplicated code and using it whenever the duplicated functionality is required.\n\n\n**Update:** *Acknowledged. The flexibility of independent upgrades is prioritized over re-use in this case. Client’s response:*\n\n\n\n> *If the contracts are used for a while and the shared logic is kept in place without frequent changes, a shared logic component will be created, but for now flexibility is more important than code reusability, especially since these two contracts are very different conceptually.*\n> \n> \n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/pools/BNTPool.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { ITokenGovernance } from \"@bancor/token-governance/contracts/ITokenGovernance.sol\";\n\nimport { Token } from \"../token/Token.sol\";\n\nimport { IVersioned } from \"../utility/interfaces/IVersioned.sol\";\nimport { Upgradeable } from \"../utility/Upgradeable.sol\";\nimport { Utils, InvalidParam, InvalidStakedBalance } from \"../utility/Utils.sol\";\nimport { PPM_RESOLUTION } from \"../utility/Constants.sol\";\nimport { Fraction } from \"../utility/FractionLibrary.sol\";\nimport { MathEx } from \"../utility/MathEx.sol\";\n\nimport { IBancorNetwork } from \"../network/interfaces/IBancorNetwork.sol\";\nimport { INetworkSettings, NotWhitelisted } from \"../network/interfaces/INetworkSettings.sol\";\n\nimport { IMasterVault } from \"../vaults/interfaces/IMasterVault.sol\";\n\n// prettier-ignore\nimport {\n    IBNTPool,\n    ROLE_BNT_POOL_TOKEN_MANAGER,\n    ROLE_BNT_MANAGER,\n    ROLE_VAULT_MANAGER,\n    ROLE_FUNDING_MANAGER\n} from \"./interfaces/IBNTPool.sol\";\n\nimport { IPoolToken } from \"./interfaces/IPoolToken.sol\";\nimport { IPoolCollection, Pool } from \"./interfaces/IPoolCollection.sol\";\n\nimport { Token } from \"../token/Token.sol\";\nimport { TokenLibrary } from \"../token/TokenLibrary.sol\";\n\nimport { Vault } from \"../vaults/Vault.sol\";\nimport { IVault } from \"../vaults/interfaces/IVault.sol\";\n\nimport { PoolToken } from \"./PoolToken.sol\";\n\n/**\n * @dev BNT Pool contract\n */\ncontract BNTPool is IBNTPool, Vault {\n    using TokenLibrary for Token;\n\n    error FundingLimitExceeded();\n\n    struct InternalWithdrawalAmounts {\n        uint256 bntAmount;\n        uint256 withdrawalFeeAmount;\n    }\n\n    // the network contract\n    IBancorNetwork private immutable _network;\n\n    // the network settings contract\n    INetworkSettings private immutable _networkSettings;\n\n    // the master vault contract\n    IMasterVault private immutable _masterVault;\n\n    // the BNT pool token\n    IPoolToken internal immutable _poolToken;\n\n    // the total staked BNT balance in the network\n    uint256 private _stakedBalance;\n\n    // a mapping between pools and their current funding\n    mapping(Token => uint256) private _currentPoolFunding;\n\n    // upgrade forward-compatibility storage gap\n    uint256[MAX_GAP - 2] private __gap;\n\n    /**\n     * @dev triggered when liquidity is deposited\n     */\n    event TokensDeposited(\n        bytes32 indexed contextId,\n        address indexed provider,\n        uint256 bntAmount,\n        uint256 poolTokenAmount,\n        uint256 vbntAmount\n    );\n\n    /**\n     * @dev triggered when liquidity is withdrawn\n     */\n    event TokensWithdrawn(\n        bytes32 indexed contextId,\n        address indexed provider,\n        uint256 bntAmount,\n        uint256 poolTokenAmount,\n        uint256 vbntAmount,\n        uint256 withdrawalFeeAmount\n    );\n\n    /**\n     * @dev triggered when funding is requested\n     */\n    event FundingRequested(bytes32 indexed contextId, Token indexed pool, uint256 bntAmount, uint256 poolTokenAmount);\n\n    /**\n     * @dev triggered when funding is renounced\n     */\n    event FundingRenounced(bytes32 indexed contextId, Token indexed pool, uint256 bntAmount, uint256 poolTokenAmount);\n\n    /**\n     * @dev triggered when the total liquidity in the BNT pool is updated\n     */\n    event TotalLiquidityUpdated(\n        bytes32 indexed contextId,\n        uint256 liquidity,\n        uint256 stakedBalance,\n        uint256 poolTokenSupply\n    );\n\n    /**\n     * @dev a \"virtual\" constructor that is only used to set immutable state variables\n     */\n    constructor(\n        IBancorNetwork initNetwork,\n        ITokenGovernance initBNTGovernance,\n        ITokenGovernance initVBNTGovernance,\n        INetworkSettings initNetworkSettings,\n        IMasterVault initMasterVault,\n        IPoolToken initBNTPoolToken\n    )\n        Vault(initBNTGovernance, initVBNTGovernance)\n        validAddress(address(initNetwork))\n        validAddress(address(initNetworkSettings))\n        validAddress(address(initMasterVault))\n        validAddress(address(initBNTPoolToken))\n    {\n        _network = initNetwork;\n        _networkSettings = initNetworkSettings;\n        _masterVault = initMasterVault;\n        _poolToken = initBNTPoolToken;\n    }\n\n    /**\n     * @dev fully initializes the contract and its parents\n     */\n    function initialize() external initializer {\n        __BNTPool_init();\n    }\n\n    // solhint-disable func-name-mixedcase\n\n    /**\n     * @dev initializes the contract and its parents\n     */\n    function __BNTPool_init() internal onlyInitializing {\n        __Vault_init();\n\n        __BNTPool_init_unchained();\n    }\n\n    /**\n     * @dev performs contract-specific initialization\n     */\n    function __BNTPool_init_unchained() internal onlyInitializing {\n        _poolToken.acceptOwnership();\n\n        // set up administrative roles\n        _setRoleAdmin(ROLE_BNT_POOL_TOKEN_MANAGER, ROLE_ADMIN);\n        _setRoleAdmin(ROLE_BNT_MANAGER, ROLE_ADMIN);\n        _setRoleAdmin(ROLE_VAULT_MANAGER, ROLE_ADMIN);\n        _setRoleAdmin(ROLE_FUNDING_MANAGER, ROLE_ADMIN);\n    }\n\n    // solhint-enable func-name-mixedcase\n\n    modifier poolWhitelisted(Token pool) {\n        _poolWhitelisted(pool);\n\n        _;\n    }\n\n    /**\n     * @dev validates that the provided pool is whitelisted\n     */\n    function _poolWhitelisted(Token pool) internal view {\n        if (!_networkSettings.isTokenWhitelisted(pool)) {\n            revert NotWhitelisted();\n        }\n    }\n\n    /**\n     * @inheritdoc Upgradeable\n     */\n    function version() public pure override(IVersioned, Upgradeable) returns (uint16) {\n        return 2;\n    }\n\n    /**\n     * @inheritdoc Vault\n     */\n    function isPayable() public pure override(IVault, Vault) returns (bool) {\n        return false;\n    }\n\n    /**\n     * @dev returns the BNT pool token manager role\n     */\n    function roleBNTPoolTokenManager() external pure returns (bytes32) {\n        return ROLE_BNT_POOL_TOKEN_MANAGER;\n    }\n\n    /**\n     * @dev returns the BNT manager role\n     */\n    function roleBNTManager() external pure returns (bytes32) {\n        return ROLE_BNT_MANAGER;\n    }\n\n    /**\n     * @dev returns the vault manager role\n     */\n    function roleVaultManager() external pure returns (bytes32) {\n        return ROLE_VAULT_MANAGER;\n    }\n\n    /**\n     * @dev returns the funding manager role\n     */\n    function roleFundingManager() external pure returns (bytes32) {\n        return ROLE_FUNDING_MANAGER;\n    }\n\n    /**\n     * @dev returns whether the given caller is allowed access to the given token\n     *\n     * requirements:\n     *\n     * - the token must be the BNT pool token\n     * - the caller must have the ROLE_BNT_POOL_TOKEN_MANAGER role\n     */\n    function isAuthorizedWithdrawal(\n        address caller,\n        Token token,\n        address, /* target */\n        uint256 /* amount */\n    ) internal view override returns (bool) {\n        return token.isEqual(_poolToken) && hasRole(ROLE_BNT_POOL_TOKEN_MANAGER, caller);\n    }\n\n    /**\n     * @inheritdoc IBNTPool\n     */\n    function poolToken() external view returns (IPoolToken) {\n        return _poolToken;\n    }\n\n    /**\n     * @inheritdoc IBNTPool\n     */\n    function stakedBalance() external view returns (uint256) {\n        return _stakedBalance;\n    }\n\n    /**\n     * @inheritdoc IBNTPool\n     */\n    function currentPoolFunding(Token pool) external view returns (uint256) {\n        return _currentPoolFunding[pool];\n    }\n\n    /**\n     * @inheritdoc IBNTPool\n     */\n    function availableFunding(Token pool) external view returns (uint256) {\n        return MathEx.subMax0(_networkSettings.poolFundingLimit(pool), _currentPoolFunding[pool]);\n    }\n\n    /**\n     * @inheritdoc IBNTPool\n     */\n    function poolTokenToUnderlying(uint256 poolTokenAmount) external view returns (uint256) {\n        return _poolTokenToUnderlying(poolTokenAmount);\n    }\n\n    /**\n     * @inheritdoc IBNTPool\n     */\n    function underlyingToPoolToken(uint256 bntAmount) external view returns (uint256) {\n        return _underlyingToPoolToken(bntAmount);\n    }\n\n    /**\n     * @inheritdoc IBNTPool\n     */\n    function poolTokenAmountToBurn(uint256 bntAmountToDistribute) external view returns (uint256) {\n        if (bntAmountToDistribute == 0) {\n            return 0;\n        }\n\n        uint256 poolTokenSupply = _poolToken.totalSupply();\n        uint256 val = bntAmountToDistribute * poolTokenSupply;\n\n        return\n            MathEx.mulDivF(\n                val,\n                poolTokenSupply,\n                val + _stakedBalance * (poolTokenSupply - _poolToken.balanceOf(address(this)))\n            );\n    }\n\n    /**\n     * @inheritdoc IBNTPool\n     */\n    function mint(address recipient, uint256 bntAmount)\n        external\n        onlyRoleMember(ROLE_BNT_MANAGER)\n        validAddress(recipient)\n        greaterThanZero(bntAmount)\n    {\n        _bntGovernance.mint(recipient, bntAmount);\n    }\n\n    /**\n     * @inheritdoc IBNTPool\n     */\n    function burnFromVault(uint256 bntAmount) external onlyRoleMember(ROLE_VAULT_MANAGER) greaterThanZero(bntAmount) {\n        _masterVault.burn(Token(address(_bnt)), bntAmount);\n    }\n\n    /**\n     * @inheritdoc IBNTPool\n     */\n    function depositFor(\n        bytes32 contextId,\n        address provider,\n        uint256 bntAmount,\n        bool isMigrating,\n        uint256 originalVBNTAmount\n    ) external only(address(_network)) validAddress(provider) greaterThanZero(bntAmount) returns (uint256) {\n        // calculate the pool token amount to transfer\n        uint256 poolTokenAmount = _underlyingToPoolToken(bntAmount);\n\n        // transfer pool tokens from the protocol to the provider. Please note that it's not possible to deposit\n        // liquidity requiring the protocol to transfer the provider more protocol tokens than it holds\n        _poolToken.transfer(provider, poolTokenAmount);\n\n        // burn the previously received BNT\n        _bntGovernance.burn(bntAmount);\n\n        uint256 vbntAmount = poolTokenAmount;\n\n        // the provider should receive pool tokens and vBNT in equal amounts. since the provider might already have\n        // some vBNT during migration, the contract only mints the delta between the full amount and the amount the\n        // provider already has\n        if (isMigrating) {\n            vbntAmount = MathEx.subMax0(vbntAmount, originalVBNTAmount);\n        }\n\n        // mint vBNT to the provider\n        if (vbntAmount > 0) {\n            _vbntGovernance.mint(provider, vbntAmount);\n        }\n\n        emit TokensDeposited({\n            contextId: contextId,\n            provider: provider,\n            bntAmount: bntAmount,\n            poolTokenAmount: poolTokenAmount,\n            vbntAmount: vbntAmount\n        });\n\n        return poolTokenAmount;\n    }\n\n    /**\n     * @inheritdoc IBNTPool\n     */\n    function withdraw(\n        bytes32 contextId,\n        address provider,\n        uint256 poolTokenAmount,\n        uint256 bntAmount\n    )\n        external\n        only(address(_network))\n        validAddress(provider)\n        greaterThanZero(poolTokenAmount)\n        greaterThanZero(bntAmount)\n        returns (uint256)\n    {\n        // ensure that the provided amounts correspond to the state of the pool (please note the pool tokens should\n        // have been already deposited back from the network)\n        uint256 underlyingAmount = _poolTokenToUnderlying(poolTokenAmount);\n        if (bntAmount > underlyingAmount) {\n            revert InvalidParam();\n        }\n\n        InternalWithdrawalAmounts memory amounts = _withdrawalAmounts(bntAmount);\n\n        // burn the respective vBNT amount\n        _vbntGovernance.burn(poolTokenAmount);\n\n        // mint BNT to the provider\n        _bntGovernance.mint(provider, amounts.bntAmount);\n\n        emit TokensWithdrawn({\n            contextId: contextId,\n            provider: provider,\n            bntAmount: amounts.bntAmount,\n            poolTokenAmount: poolTokenAmount,\n            vbntAmount: poolTokenAmount,\n            withdrawalFeeAmount: amounts.withdrawalFeeAmount\n        });\n\n        return amounts.bntAmount;\n    }\n\n    /**\n     * @inheritdoc IBNTPool\n     */\n    function withdrawalAmount(uint256 poolTokenAmount)\n        external\n        view\n        greaterThanZero(poolTokenAmount)\n        returns (uint256)\n    {\n        return _withdrawalAmounts(_poolTokenToUnderlying(poolTokenAmount)).bntAmount;\n    }\n\n    /**\n     * @inheritdoc IBNTPool\n     */\n    function requestFunding(\n        bytes32 contextId,\n        Token pool,\n        uint256 bntAmount\n    ) external onlyRoleMember(ROLE_FUNDING_MANAGER) poolWhitelisted(pool) greaterThanZero(bntAmount) {\n        uint256 currentFunding = _currentPoolFunding[pool];\n        uint256 fundingLimit = _networkSettings.poolFundingLimit(pool);\n        uint256 newFunding = currentFunding + bntAmount;\n\n        // verify that the new funding amount doesn't exceed the limit\n        if (newFunding > fundingLimit) {\n            revert FundingLimitExceeded();\n        }\n\n        // calculate the pool token amount to mint\n        uint256 currentStakedBalance = _stakedBalance;\n        uint256 poolTokenAmount;\n        uint256 poolTokenTotalSupply = _poolToken.totalSupply();\n        if (poolTokenTotalSupply == 0) {\n            // if this is the initial liquidity provision - use a one-to-one pool token to BNT rate\n            if (currentStakedBalance > 0) {\n                revert InvalidStakedBalance();\n            }\n\n            poolTokenAmount = bntAmount;\n        } else {\n            poolTokenAmount = _underlyingToPoolToken(bntAmount, poolTokenTotalSupply, currentStakedBalance);\n        }\n\n        // update the staked balance\n        uint256 newStakedBalance = currentStakedBalance + bntAmount;\n        _stakedBalance = newStakedBalance;\n\n        // update the current funding amount\n        _currentPoolFunding[pool] = newFunding;\n\n        // mint pool tokens to the protocol\n        _poolToken.mint(address(this), poolTokenAmount);\n\n        // mint BNT to the vault\n        _bntGovernance.mint(address(_masterVault), bntAmount);\n\n        emit FundingRequested({\n            contextId: contextId,\n            pool: pool,\n            bntAmount: bntAmount,\n            poolTokenAmount: poolTokenAmount\n        });\n\n        emit TotalLiquidityUpdated({\n            contextId: contextId,\n            liquidity: _bnt.balanceOf(address(_masterVault)),\n            stakedBalance: newStakedBalance,\n            poolTokenSupply: poolTokenTotalSupply + poolTokenAmount\n        });\n    }\n\n    /**\n     * @inheritdoc IBNTPool\n     */\n    function renounceFunding(\n        bytes32 contextId,\n        Token pool,\n        uint256 bntAmount\n    ) external onlyRoleMember(ROLE_FUNDING_MANAGER) poolWhitelisted(pool) greaterThanZero(bntAmount) {\n        uint256 currentStakedBalance = _stakedBalance;\n\n        // calculate the renounced amount to deduct from both the staked balance and current pool funding\n        uint256 currentFunding = _currentPoolFunding[pool];\n        uint256 reduceFundingAmount = Math.min(currentFunding, bntAmount);\n\n        // calculate the pool token amount to burn\n        uint256 poolTokenTotalSupply = _poolToken.totalSupply();\n        uint256 poolTokenAmount = _underlyingToPoolToken(\n            reduceFundingAmount,\n            poolTokenTotalSupply,\n            currentStakedBalance\n        );\n\n        // update the current pool funding. Note that the given amount can be higher than the funding amount but the\n        // request shouldn't fail (and the funding amount cannot get negative)\n        _currentPoolFunding[pool] = currentFunding - reduceFundingAmount;\n\n        // update the staked balance\n        uint256 newStakedBalance = currentStakedBalance - reduceFundingAmount;\n        _stakedBalance = newStakedBalance;\n\n        // burn pool tokens from the protocol\n        _poolToken.burn(poolTokenAmount);\n\n        // burn all BNT from the master vault\n        _masterVault.burn(Token(address(_bnt)), bntAmount);\n\n        emit FundingRenounced({\n            contextId: contextId,\n            pool: pool,\n            bntAmount: bntAmount,\n            poolTokenAmount: poolTokenAmount\n        });\n\n        emit TotalLiquidityUpdated({\n            contextId: contextId,\n            liquidity: _bnt.balanceOf(address(_masterVault)),\n            stakedBalance: newStakedBalance,\n            poolTokenSupply: poolTokenTotalSupply - poolTokenAmount\n        });\n    }\n\n    /**\n     * @inheritdoc IBNTPool\n     */\n    function onFeesCollected(\n        Token pool,\n        uint256 feeAmount,\n        bool isTradeFee\n    ) external only(address(_network)) validAddress(address(pool)) {\n        if (feeAmount == 0) {\n            return;\n        }\n\n        // increase the staked balance by the given amount\n        _stakedBalance += feeAmount;\n\n        if (isTradeFee) {\n            // increase the current funding for the specified pool by the given amount\n            _currentPoolFunding[pool] += feeAmount;\n        }\n    }\n\n    /**\n     * @dev converts the specified pool token amount to the underlying BNT amount\n     */\n    function _poolTokenToUnderlying(uint256 poolTokenAmount) private view returns (uint256) {\n        return MathEx.mulDivF(poolTokenAmount, _stakedBalance, _poolToken.totalSupply());\n    }\n\n    /**\n     * @dev converts the specified underlying BNT amount to pool token amount\n     */\n    function _underlyingToPoolToken(uint256 bntAmount) private view returns (uint256) {\n        return _underlyingToPoolToken(bntAmount, _poolToken.totalSupply(), _stakedBalance);\n    }\n\n    /**\n     * @dev converts the specified underlying BNT amount to pool token amount\n     */\n    function _underlyingToPoolToken(\n        uint256 bntAmount,\n        uint256 poolTokenTotalSupply,\n        uint256 currentStakedBalance\n    ) private pure returns (uint256) {\n        return MathEx.mulDivC(bntAmount, poolTokenTotalSupply, currentStakedBalance);\n    }\n\n    /**\n     * @dev returns withdrawal amounts\n     */\n    function _withdrawalAmounts(uint256 bntAmount) internal view returns (InternalWithdrawalAmounts memory) {\n        // deduct the exit fee from BNT amount\n        uint256 withdrawalFeeAmount = MathEx.mulDivF(bntAmount, _networkSettings.withdrawalFeePPM(), PPM_RESOLUTION);\n\n        bntAmount -= withdrawalFeeAmount;\n\n        return InternalWithdrawalAmounts({ bntAmount: bntAmount, withdrawalFeeAmount: withdrawalFeeAmount });\n    }\n}"
    }
  ]
}