{
  "Title": "[G-07] Use simple comparison in trinary logic",
  "Content": "<h2 id=\"g-07-use-simple-comparison-in-trinary-logic\" style=\"position:relative;\"><a href=\"#g-07-use-simple-comparison-in-trinary-logic\" aria-label=\"g 07 use simple comparison in trinary logic permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[G-07] Use simple comparison in trinary logic</h2>\n<p>The comparison operators &gt;= and &lt;= use more gas than &gt;, &lt;, or ==. Replacing the  &gt;= and â‰¤ operators with a comparison operator that has an opcode in the EVM saves gas.</p>\n<p>The existing code is:<br>\n<a href=\"https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/rewards/FlywheelDynamicRewards.sol#L50\">FlywheelDynamicRewards.sol#L50</a><br></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"\" data-index=\"56\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">uint32 latest = timestamp &gt;= cycle.end ? cycle.end : timestamp;</span></span></code></pre>\n<p>A simple comparison can be used for gas savings by reversing the logic:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"\" data-index=\"57\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">uint32 latest = timestamp &lt; cycle.end ? timestamp : cycle.end;</span></span></code></pre>\n<h3 id=\"recommended-mitigation-steps-13\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-13\" aria-label=\"recommended mitigation steps 13 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h3>\n<p>Replace the comparison operator and reverse the logic to save gas using the suggestions above.</p>\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-04-xtribe-contest",
  "Code": [
    {
      "filename": "src/rewards/FlywheelDynamicRewards.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.10;\n\nimport \"./BaseFlywheelRewards.sol\";\nimport {SafeCastLib} from \"solmate/utils/SafeCastLib.sol\";\n\n/** \n @title Flywheel Dynamic Reward Stream\n @notice Determines rewards based on a dynamic reward stream.\n         Rewards are transferred linearly over a \"rewards cycle\" to prevent gaming the reward distribution. \n         The reward source can be arbitrary logic, but most common is to \"pass through\" rewards from some other source.\n         The getNextCycleRewards() hook should also transfer the next cycle's rewards to this contract to ensure proper accounting.\n*/\nabstract contract FlywheelDynamicRewards is BaseFlywheelRewards {\n    using SafeTransferLib for ERC20;\n    using SafeCastLib for uint256;\n\n    event NewRewardsCycle(uint32 indexed start, uint32 indexed end, uint192 reward);\n\n    /// @notice the length of a rewards cycle\n    uint32 public immutable rewardsCycleLength;\n\n    struct RewardsCycle {\n        uint32 start;\n        uint32 end;\n        uint192 reward;\n    }\n\n    mapping(ERC20 => RewardsCycle) public rewardsCycle;\n\n    constructor(FlywheelCore _flywheel, uint32 _rewardsCycleLength) BaseFlywheelRewards(_flywheel) {\n        rewardsCycleLength = _rewardsCycleLength;\n    }\n\n    /**\n     @notice calculate and transfer accrued rewards to flywheel core\n     @param strategy the strategy to accrue rewards for\n     @return amount the amount of tokens accrued and transferred\n     */\n    function getAccruedRewards(ERC20 strategy, uint32 lastUpdatedTimestamp)\n        external\n        override\n        onlyFlywheel\n        returns (uint256 amount)\n    {\n        RewardsCycle memory cycle = rewardsCycle[strategy];\n\n        uint32 timestamp = block.timestamp.safeCastTo32();\n\n        uint32 latest = timestamp >= cycle.end ? cycle.end : timestamp;\n        uint32 earliest = lastUpdatedTimestamp <= cycle.start ? cycle.start : lastUpdatedTimestamp;\n        if (cycle.end != 0) {\n            amount = (cycle.reward * (latest - earliest)) / (cycle.end - cycle.start);\n            assert(amount <= cycle.reward); // should never happen because latest <= cycle.end and earliest >= cycle.start\n        }\n        // if cycle has ended, reset cycle and transfer all available\n        if (timestamp >= cycle.end) {\n            uint32 end = ((timestamp + rewardsCycleLength) / rewardsCycleLength) * rewardsCycleLength;\n            uint192 rewards = getNextCycleRewards(strategy);\n\n            // reset for next cycle\n            rewardsCycle[strategy] = RewardsCycle({start: timestamp, end: end, reward: rewards});\n\n            emit NewRewardsCycle(timestamp, end, rewards);\n        }\n    }\n\n    function getNextCycleRewards(ERC20 strategy) internal virtual returns (uint192);\n}"
    }
  ]
}