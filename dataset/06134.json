{
  "Title": "[L-01] Avoid directly minting follow NFTs to the profile owner in `processBlock()`",
  "Content": "\nIn `FollowNFT.sol`, whenever a follower is blocked by a profile and his `followTokenId` is unwrapped, `processBlock()` will mint the follow NFT to the follower's address:\n\n[FollowNFT.sol#L198-L203](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/FollowNFT.sol#L198-L203)\n\n```solidity\n        uint256 followTokenId = _followTokenIdByFollowerProfileId[followerProfileId];\n        if (followTokenId != 0) {\n            if (!_isFollowTokenWrapped(followTokenId)) {\n                // Wrap it first, so the user stops following but does not lose the token when being blocked.\n                _mint(IERC721(HUB).ownerOf(followerProfileId), followTokenId);\n            }\n```\n\nHowever, if the profile owner's address isn't able to follow NFTs, such as profiles held in a secure wallet (e.g. hardware wallet or multisig), the minted follow NFT would become permanently stuck.\n\n### Recommendation\n\nConsider allowing the follower to recover the NFT by himself by assigning `profileIdAllowedToRecover` to `followerProfileId`: \n\n[FollowNFT.sol#L198-L203](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/FollowNFT.sol#L198-L203)\n\n```diff\n        uint256 followTokenId = _followTokenIdByFollowerProfileId[followerProfileId];\n        if (followTokenId != 0) {\n            if (!_isFollowTokenWrapped(followTokenId)) {\n                // Wrap it first, so the user stops following but does not lose the token when being blocked.\n-               _mint(IERC721(HUB).ownerOf(followerProfileId), followTokenId);\n+               _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover = followerProfileId;\n            }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-07-lens",
  "Code": [
    {
      "filename": "contracts/FollowNFT.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {Types} from 'contracts/libraries/constants/Types.sol';\nimport {ERC2981CollectionRoyalties} from 'contracts/base/ERC2981CollectionRoyalties.sol';\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\nimport {HubRestricted} from 'contracts/base/HubRestricted.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport {IERC721Timestamped} from 'contracts/interfaces/IERC721Timestamped.sol';\nimport {IFollowNFT} from 'contracts/interfaces/IFollowNFT.sol';\nimport {ILensHub} from 'contracts/interfaces/ILensHub.sol';\nimport {LensBaseERC721} from 'contracts/base/LensBaseERC721.sol';\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\nimport {StorageLib} from 'contracts/libraries/StorageLib.sol';\nimport {FollowTokenURILib} from 'contracts/libraries/token-uris/FollowTokenURILib.sol';\n\ncontract FollowNFT is HubRestricted, LensBaseERC721, ERC2981CollectionRoyalties, IFollowNFT {\n    using Strings for uint256;\n\n    string constant FOLLOW_NFT_NAME_SUFFIX = '-Follower';\n    string constant FOLLOW_NFT_SYMBOL_SUFFIX = '-Fl';\n\n    uint256[5] ___DEPRECATED_SLOTS; // Deprecated slots, previously used for delegations.\n    uint256 internal _followedProfileId;\n\n    // Old uint256 `_lastFollowTokenId` slot splitted into two uint128s to include `_followerCount`.\n    uint128 internal _lastFollowTokenId;\n    // `_followerCount` will not be decreased when a follower profile is burned, making the counter not fully accurate.\n    // New variable added in V2 in the same slot, lower-ordered to not conflict with previous storage layout.\n    uint128 internal _followerCount;\n\n    bool private _initialized;\n\n    // Introduced in v2\n    mapping(uint256 => Types.FollowData) internal _followDataByFollowTokenId;\n    mapping(uint256 => uint256) internal _followTokenIdByFollowerProfileId;\n    mapping(uint256 => uint256) internal _followApprovalByFollowTokenId;\n    uint256 internal _royaltiesInBasisPoints;\n\n    event FollowApproval(uint256 indexed followerProfileId, uint256 indexed followTokenId);\n\n    constructor(address hub) HubRestricted(hub) {\n        _initialized = true;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function initialize(uint256 profileId) external override {\n        // This is called right after deployment by the LensHub, so we can skip the onlyHub check.\n        if (_initialized) {\n            revert Errors.Initialized();\n        }\n        _initialized = true;\n        _followedProfileId = profileId;\n        _setRoyalty(1000); // 10% of royalties\n    }\n\n    /// @inheritdoc IFollowNFT\n    function follow(\n        uint256 followerProfileId,\n        address transactionExecutor,\n        uint256 followTokenId\n    ) external override onlyHub returns (uint256) {\n        if (_followTokenIdByFollowerProfileId[followerProfileId] != 0) {\n            revert AlreadyFollowing();\n        }\n\n        if (followTokenId == 0) {\n            // Fresh follow.\n            return _followMintingNewToken(followerProfileId);\n        }\n\n        address followTokenOwner = _unsafeOwnerOf(followTokenId);\n        if (followTokenOwner != address(0)) {\n            // Provided follow token is wrapped.\n            return\n                _followWithWrappedToken({\n                    followerProfileId: followerProfileId,\n                    transactionExecutor: transactionExecutor,\n                    followTokenId: followTokenId,\n                    followTokenOwner: followTokenOwner\n                });\n        }\n\n        uint256 currentFollowerProfileId = _followDataByFollowTokenId[followTokenId].followerProfileId;\n        if (currentFollowerProfileId != 0) {\n            // Provided follow token is unwrapped.\n            // It has a follower profile set already, it can only be used to follow if that profile was burnt.\n            return\n                _followWithUnwrappedTokenFromBurnedProfile({\n                    followerProfileId: followerProfileId,\n                    followTokenId: followTokenId,\n                    currentFollowerProfileId: currentFollowerProfileId\n                });\n        }\n\n        // Provided follow token does not exist anymore, it can only be used if the profile attempting to follow is\n        // allowed to recover it.\n        return _followByRecoveringToken({followerProfileId: followerProfileId, followTokenId: followTokenId});\n    }\n\n    /// @inheritdoc IFollowNFT\n    function unfollow(uint256 unfollowerProfileId, address transactionExecutor) external override onlyHub {\n        uint256 followTokenId = _followTokenIdByFollowerProfileId[unfollowerProfileId];\n        if (followTokenId == 0) {\n            revert NotFollowing();\n        }\n        address followTokenOwner = _unsafeOwnerOf(followTokenId);\n        if (followTokenOwner == address(0)) {\n            // Follow token is unwrapped.\n            // Unfollowing and allowing recovery.\n            _unfollow({unfollower: unfollowerProfileId, followTokenId: followTokenId});\n            _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover = unfollowerProfileId;\n        } else {\n            // Follow token is wrapped.\n            address unfollowerProfileOwner = IERC721(HUB).ownerOf(unfollowerProfileId);\n            // Follower profile owner or its approved delegated executor must hold the token or be approved-for-all.\n            if (\n                (followTokenOwner != unfollowerProfileOwner) &&\n                (followTokenOwner != transactionExecutor) &&\n                !isApprovedForAll(followTokenOwner, transactionExecutor) &&\n                !isApprovedForAll(followTokenOwner, unfollowerProfileOwner)\n            ) {\n                revert DoesNotHavePermissions();\n            }\n            _unfollow({unfollower: unfollowerProfileId, followTokenId: followTokenId});\n        }\n    }\n\n    /// @inheritdoc IFollowNFT\n    function removeFollower(uint256 followTokenId) external override {\n        address followTokenOwner = ownerOf(followTokenId);\n        if (followTokenOwner == msg.sender || isApprovedForAll(followTokenOwner, msg.sender)) {\n            _unfollowIfHasFollower(followTokenId);\n        } else {\n            revert DoesNotHavePermissions();\n        }\n    }\n\n    /// @inheritdoc IFollowNFT\n    function approveFollow(uint256 followerProfileId, uint256 followTokenId) external override {\n        if (!IERC721Timestamped(HUB).exists(followerProfileId)) {\n            revert Errors.TokenDoesNotExist();\n        }\n        address followTokenOwner = _unsafeOwnerOf(followTokenId);\n        if (followTokenOwner == address(0)) {\n            revert OnlyWrappedFollowTokens();\n        }\n        if (followTokenOwner != msg.sender && !isApprovedForAll(followTokenOwner, msg.sender)) {\n            revert DoesNotHavePermissions();\n        }\n        _approveFollow(followerProfileId, followTokenId);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function wrap(uint256 followTokenId, address wrappedTokenReceiver) external override {\n        if (wrappedTokenReceiver == address(0)) {\n            revert Errors.InvalidParameter();\n        }\n        _wrap(followTokenId, wrappedTokenReceiver);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function wrap(uint256 followTokenId) external override {\n        _wrap(followTokenId, address(0));\n    }\n\n    function _wrap(uint256 followTokenId, address wrappedTokenReceiver) internal {\n        if (_isFollowTokenWrapped(followTokenId)) {\n            revert AlreadyWrapped();\n        }\n        uint256 followerProfileId = _followDataByFollowTokenId[followTokenId].followerProfileId;\n        if (followerProfileId == 0) {\n            followerProfileId = _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover;\n            if (followerProfileId == 0) {\n                revert FollowTokenDoesNotExist();\n            }\n            delete _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover;\n        }\n        address followerProfileOwner = IERC721(HUB).ownerOf(followerProfileId);\n        if (msg.sender != followerProfileOwner) {\n            revert DoesNotHavePermissions();\n        }\n        _mint(wrappedTokenReceiver == address(0) ? followerProfileOwner : wrappedTokenReceiver, followTokenId);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function unwrap(uint256 followTokenId) external override {\n        if (_followDataByFollowTokenId[followTokenId].followerProfileId == 0) {\n            revert NotFollowing();\n        }\n        super.burn(followTokenId);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function processBlock(uint256 followerProfileId) external override onlyHub returns (bool) {\n        bool hasUnfollowed;\n        uint256 followTokenId = _followTokenIdByFollowerProfileId[followerProfileId];\n        if (followTokenId != 0) {\n            if (!_isFollowTokenWrapped(followTokenId)) {\n                // Wrap it first, so the user stops following but does not lose the token when being blocked.\n                _mint(IERC721(HUB).ownerOf(followerProfileId), followTokenId);\n            }\n            _unfollow(followerProfileId, followTokenId);\n            hasUnfollowed = true;\n        }\n        return hasUnfollowed;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowerProfileId(uint256 followTokenId) external view override returns (uint256) {\n        return _followDataByFollowTokenId[followTokenId].followerProfileId;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function isFollowing(uint256 followerProfileId) external view override returns (bool) {\n        return _followTokenIdByFollowerProfileId[followerProfileId] != 0;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowTokenId(uint256 followerProfileId) external view override returns (uint256) {\n        return _followTokenIdByFollowerProfileId[followerProfileId];\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getOriginalFollowTimestamp(uint256 followTokenId) external view override returns (uint256) {\n        return _followDataByFollowTokenId[followTokenId].originalFollowTimestamp;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowTimestamp(uint256 followTokenId) external view override returns (uint256) {\n        return _followDataByFollowTokenId[followTokenId].followTimestamp;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getProfileIdAllowedToRecover(uint256 followTokenId) external view override returns (uint256) {\n        return _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowData(uint256 followTokenId) external view override returns (Types.FollowData memory) {\n        return _followDataByFollowTokenId[followTokenId];\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowApproved(uint256 followTokenId) external view override returns (uint256) {\n        return _followApprovalByFollowTokenId[followTokenId];\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowerCount() external view override returns (uint256) {\n        return _followerCount;\n    }\n\n    function burn(uint256 followTokenId) public override {\n        _unfollowIfHasFollower(followTokenId);\n        super.burn(followTokenId);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(LensBaseERC721, ERC2981CollectionRoyalties)\n        returns (bool)\n    {\n        return\n            LensBaseERC721.supportsInterface(interfaceId) || ERC2981CollectionRoyalties.supportsInterface(interfaceId);\n    }\n\n    function name() public view override returns (string memory) {\n        return string(abi.encodePacked(_followedProfileId.toString(), FOLLOW_NFT_NAME_SUFFIX));\n    }\n\n    function symbol() public view override returns (string memory) {\n        return string(abi.encodePacked(_followedProfileId.toString(), FOLLOW_NFT_SYMBOL_SUFFIX));\n    }\n\n    /**\n     * @dev This returns the follow NFT URI fetched from the hub.\n     */\n    function tokenURI(uint256 followTokenId) public view override returns (string memory) {\n        if (!_exists(followTokenId)) {\n            revert Errors.TokenDoesNotExist();\n        }\n        return\n            FollowTokenURILib.getTokenURI(\n                followTokenId,\n                _followedProfileId,\n                _followDataByFollowTokenId[followTokenId].originalFollowTimestamp\n            );\n    }\n\n    function _followMintingNewToken(uint256 followerProfileId) internal returns (uint256) {\n        uint256 followTokenIdAssigned;\n        unchecked {\n            followTokenIdAssigned = ++_lastFollowTokenId;\n            _followerCount++;\n        }\n        _baseFollow({\n            followerProfileId: followerProfileId,\n            followTokenId: followTokenIdAssigned,\n            isOriginalFollow: true\n        });\n        return followTokenIdAssigned;\n    }\n\n    function _followWithWrappedToken(\n        uint256 followerProfileId,\n        address transactionExecutor,\n        uint256 followTokenId,\n        address followTokenOwner\n    ) internal returns (uint256) {\n        bool isFollowApproved = _followApprovalByFollowTokenId[followTokenId] == followerProfileId;\n        address followerProfileOwner = IERC721(HUB).ownerOf(followerProfileId);\n        if (\n            !isFollowApproved &&\n            followTokenOwner != followerProfileOwner &&\n            followTokenOwner != transactionExecutor &&\n            !isApprovedForAll(followTokenOwner, transactionExecutor) &&\n            !isApprovedForAll(followTokenOwner, followerProfileOwner)\n        ) {\n            revert DoesNotHavePermissions();\n        }\n        // The transactionExecutor is allowed to write the follower in that wrapped token.\n        if (isFollowApproved) {\n            // The `_followApprovalByFollowTokenId` was used, and now it needs to be cleared.\n            _approveFollow(0, followTokenId);\n        }\n        _replaceFollower({\n            currentFollowerProfileId: _followDataByFollowTokenId[followTokenId].followerProfileId,\n            newFollowerProfileId: followerProfileId,\n            followTokenId: followTokenId\n        });\n        return followTokenId;\n    }\n\n    function _followWithUnwrappedTokenFromBurnedProfile(\n        uint256 followerProfileId,\n        uint256 followTokenId,\n        uint256 currentFollowerProfileId\n    ) internal returns (uint256) {\n        if (IERC721Timestamped(HUB).exists(currentFollowerProfileId)) {\n            revert DoesNotHavePermissions();\n        }\n        _replaceFollower({\n            currentFollowerProfileId: currentFollowerProfileId,\n            newFollowerProfileId: followerProfileId,\n            followTokenId: followTokenId\n        });\n        return followTokenId;\n    }\n\n    function _followByRecoveringToken(uint256 followerProfileId, uint256 followTokenId) internal returns (uint256) {\n        if (_followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover != followerProfileId) {\n            revert FollowTokenDoesNotExist();\n        }\n        unchecked {\n            _followerCount++;\n        }\n        _baseFollow({followerProfileId: followerProfileId, followTokenId: followTokenId, isOriginalFollow: false});\n        return followTokenId;\n    }\n\n    function _replaceFollower(\n        uint256 currentFollowerProfileId,\n        uint256 newFollowerProfileId,\n        uint256 followTokenId\n    ) internal {\n        if (currentFollowerProfileId != 0) {\n            // As it has a follower, unfollow first, removing the current follower.\n            delete _followTokenIdByFollowerProfileId[currentFollowerProfileId];\n            ILensHub(HUB).emitUnfollowedEvent(currentFollowerProfileId, _followedProfileId);\n        } else {\n            unchecked {\n                _followerCount++;\n            }\n        }\n        // Perform the follow, setting a new follower.\n        _baseFollow({followerProfileId: newFollowerProfileId, followTokenId: followTokenId, isOriginalFollow: false});\n    }\n\n    function _baseFollow(\n        uint256 followerProfileId,\n        uint256 followTokenId,\n        bool isOriginalFollow\n    ) internal {\n        _followTokenIdByFollowerProfileId[followerProfileId] = followTokenId;\n        _followDataByFollowTokenId[followTokenId].followerProfileId = uint160(followerProfileId);\n        _followDataByFollowTokenId[followTokenId].followTimestamp = uint48(block.timestamp);\n        delete _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover;\n        if (isOriginalFollow) {\n            _followDataByFollowTokenId[followTokenId].originalFollowTimestamp = uint48(block.timestamp);\n        } else {\n            // Migration code.\n            // If the follow token was minted before the originalFollowTimestamp was introduced, it will be 0.\n            // In that case, we need to fetch the mint timestamp from the token data.\n            if (_followDataByFollowTokenId[followTokenId].originalFollowTimestamp == 0) {\n                uint48 mintTimestamp = uint48(StorageLib.getTokenData(followTokenId).mintTimestamp);\n                _followDataByFollowTokenId[followTokenId].originalFollowTimestamp = mintTimestamp;\n            }\n        }\n    }\n\n    function _unfollowIfHasFollower(uint256 followTokenId) internal {\n        uint256 followerProfileId = _followDataByFollowTokenId[followTokenId].followerProfileId;\n        if (followerProfileId != 0) {\n            _unfollow(followerProfileId, followTokenId);\n            ILensHub(HUB).emitUnfollowedEvent(followerProfileId, _followedProfileId);\n        }\n    }\n\n    function _unfollow(uint256 unfollower, uint256 followTokenId) internal {\n        unchecked {\n            // This is safe, as this line can only be reached if the unfollowed profile is being followed by the\n            // unfollower profile, so _followerCount is guaranteed to be greater than zero.\n            _followerCount--;\n        }\n        delete _followTokenIdByFollowerProfileId[unfollower];\n        delete _followDataByFollowTokenId[followTokenId].followerProfileId;\n        delete _followDataByFollowTokenId[followTokenId].followTimestamp;\n        delete _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover;\n    }\n\n    function _approveFollow(uint256 approvedProfileId, uint256 followTokenId) internal {\n        _followApprovalByFollowTokenId[followTokenId] = approvedProfileId;\n        emit FollowApproval(approvedProfileId, followTokenId);\n    }\n\n    /**\n     * @dev Upon transfers, we clear follow approvals and emit the transfer event in the hub.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 followTokenId\n    ) internal override {\n        if (from != address(0)) {\n            // It is cleared on unwrappings and transfers, and it can not be set on unwrapped tokens.\n            // As a consequence, there is no need to clear it on wrappings.\n            _approveFollow(0, followTokenId);\n        }\n        super._beforeTokenTransfer(from, to, followTokenId);\n    }\n\n    function _getReceiver(\n        uint256 /* followTokenId */\n    ) internal view override returns (address) {\n        return IERC721(HUB).ownerOf(_followedProfileId);\n    }\n\n    function _beforeRoyaltiesSet(\n        uint256 /* royaltiesInBasisPoints */\n    ) internal view override {\n        if (IERC721(HUB).ownerOf(_followedProfileId) != msg.sender) {\n            revert Errors.NotProfileOwner();\n        }\n    }\n\n    function _isFollowTokenWrapped(uint256 followTokenId) internal view returns (bool) {\n        return _exists(followTokenId);\n    }\n\n    function _getRoyaltiesInBasisPointsSlot() internal pure override returns (uint256) {\n        uint256 slot;\n        assembly {\n            slot := _royaltiesInBasisPoints.slot\n        }\n        return slot;\n    }\n\n    //////////////////\n    /// Migrations ///\n    //////////////////\n\n    // This function shouldn't fail under no circumstances, except if wrong parameters are passed.\n    function tryMigrate(\n        uint256 followerProfileId,\n        address followerProfileOwner,\n        uint256 idOfProfileFollowed,\n        uint256 followTokenId\n    ) external onlyHub returns (uint48) {\n        // Migrated FollowNFTs should have `originalFollowTimestamp` set\n        if (_followDataByFollowTokenId[followTokenId].originalFollowTimestamp != 0) {\n            return 0; // Already migrated\n        }\n\n        if (_followedProfileId != idOfProfileFollowed) {\n            revert Errors.InvalidParameter();\n        }\n\n        if (!_exists(followTokenId)) {\n            return 0; // Doesn't exist\n        }\n\n        address followTokenOwner = ownerOf(followTokenId);\n\n        // ProfileNFT and FollowNFT should be in the same account\n        if (followerProfileOwner != followTokenOwner) {\n            return 0; // Not holding both Profile & Follow NFTs together\n        }\n\n        unchecked {\n            ++_followerCount;\n        }\n\n        _followTokenIdByFollowerProfileId[followerProfileId] = followTokenId;\n\n        uint48 mintTimestamp = uint48(StorageLib.getTokenData(followTokenId).mintTimestamp);\n\n        _followDataByFollowTokenId[followTokenId].followerProfileId = uint160(followerProfileId);\n        _followDataByFollowTokenId[followTokenId].originalFollowTimestamp = mintTimestamp;\n        _followDataByFollowTokenId[followTokenId].followTimestamp = mintTimestamp;\n\n        super._burn(followTokenId);\n        return mintTimestamp;\n    }\n}"
    },
    {
      "filename": "contracts/FollowNFT.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {Types} from 'contracts/libraries/constants/Types.sol';\nimport {ERC2981CollectionRoyalties} from 'contracts/base/ERC2981CollectionRoyalties.sol';\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\nimport {HubRestricted} from 'contracts/base/HubRestricted.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport {IERC721Timestamped} from 'contracts/interfaces/IERC721Timestamped.sol';\nimport {IFollowNFT} from 'contracts/interfaces/IFollowNFT.sol';\nimport {ILensHub} from 'contracts/interfaces/ILensHub.sol';\nimport {LensBaseERC721} from 'contracts/base/LensBaseERC721.sol';\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\nimport {StorageLib} from 'contracts/libraries/StorageLib.sol';\nimport {FollowTokenURILib} from 'contracts/libraries/token-uris/FollowTokenURILib.sol';\n\ncontract FollowNFT is HubRestricted, LensBaseERC721, ERC2981CollectionRoyalties, IFollowNFT {\n    using Strings for uint256;\n\n    string constant FOLLOW_NFT_NAME_SUFFIX = '-Follower';\n    string constant FOLLOW_NFT_SYMBOL_SUFFIX = '-Fl';\n\n    uint256[5] ___DEPRECATED_SLOTS; // Deprecated slots, previously used for delegations.\n    uint256 internal _followedProfileId;\n\n    // Old uint256 `_lastFollowTokenId` slot splitted into two uint128s to include `_followerCount`.\n    uint128 internal _lastFollowTokenId;\n    // `_followerCount` will not be decreased when a follower profile is burned, making the counter not fully accurate.\n    // New variable added in V2 in the same slot, lower-ordered to not conflict with previous storage layout.\n    uint128 internal _followerCount;\n\n    bool private _initialized;\n\n    // Introduced in v2\n    mapping(uint256 => Types.FollowData) internal _followDataByFollowTokenId;\n    mapping(uint256 => uint256) internal _followTokenIdByFollowerProfileId;\n    mapping(uint256 => uint256) internal _followApprovalByFollowTokenId;\n    uint256 internal _royaltiesInBasisPoints;\n\n    event FollowApproval(uint256 indexed followerProfileId, uint256 indexed followTokenId);\n\n    constructor(address hub) HubRestricted(hub) {\n        _initialized = true;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function initialize(uint256 profileId) external override {\n        // This is called right after deployment by the LensHub, so we can skip the onlyHub check.\n        if (_initialized) {\n            revert Errors.Initialized();\n        }\n        _initialized = true;\n        _followedProfileId = profileId;\n        _setRoyalty(1000); // 10% of royalties\n    }\n\n    /// @inheritdoc IFollowNFT\n    function follow(\n        uint256 followerProfileId,\n        address transactionExecutor,\n        uint256 followTokenId\n    ) external override onlyHub returns (uint256) {\n        if (_followTokenIdByFollowerProfileId[followerProfileId] != 0) {\n            revert AlreadyFollowing();\n        }\n\n        if (followTokenId == 0) {\n            // Fresh follow.\n            return _followMintingNewToken(followerProfileId);\n        }\n\n        address followTokenOwner = _unsafeOwnerOf(followTokenId);\n        if (followTokenOwner != address(0)) {\n            // Provided follow token is wrapped.\n            return\n                _followWithWrappedToken({\n                    followerProfileId: followerProfileId,\n                    transactionExecutor: transactionExecutor,\n                    followTokenId: followTokenId,\n                    followTokenOwner: followTokenOwner\n                });\n        }\n\n        uint256 currentFollowerProfileId = _followDataByFollowTokenId[followTokenId].followerProfileId;\n        if (currentFollowerProfileId != 0) {\n            // Provided follow token is unwrapped.\n            // It has a follower profile set already, it can only be used to follow if that profile was burnt.\n            return\n                _followWithUnwrappedTokenFromBurnedProfile({\n                    followerProfileId: followerProfileId,\n                    followTokenId: followTokenId,\n                    currentFollowerProfileId: currentFollowerProfileId\n                });\n        }\n\n        // Provided follow token does not exist anymore, it can only be used if the profile attempting to follow is\n        // allowed to recover it.\n        return _followByRecoveringToken({followerProfileId: followerProfileId, followTokenId: followTokenId});\n    }\n\n    /// @inheritdoc IFollowNFT\n    function unfollow(uint256 unfollowerProfileId, address transactionExecutor) external override onlyHub {\n        uint256 followTokenId = _followTokenIdByFollowerProfileId[unfollowerProfileId];\n        if (followTokenId == 0) {\n            revert NotFollowing();\n        }\n        address followTokenOwner = _unsafeOwnerOf(followTokenId);\n        if (followTokenOwner == address(0)) {\n            // Follow token is unwrapped.\n            // Unfollowing and allowing recovery.\n            _unfollow({unfollower: unfollowerProfileId, followTokenId: followTokenId});\n            _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover = unfollowerProfileId;\n        } else {\n            // Follow token is wrapped.\n            address unfollowerProfileOwner = IERC721(HUB).ownerOf(unfollowerProfileId);\n            // Follower profile owner or its approved delegated executor must hold the token or be approved-for-all.\n            if (\n                (followTokenOwner != unfollowerProfileOwner) &&\n                (followTokenOwner != transactionExecutor) &&\n                !isApprovedForAll(followTokenOwner, transactionExecutor) &&\n                !isApprovedForAll(followTokenOwner, unfollowerProfileOwner)\n            ) {\n                revert DoesNotHavePermissions();\n            }\n            _unfollow({unfollower: unfollowerProfileId, followTokenId: followTokenId});\n        }\n    }\n\n    /// @inheritdoc IFollowNFT\n    function removeFollower(uint256 followTokenId) external override {\n        address followTokenOwner = ownerOf(followTokenId);\n        if (followTokenOwner == msg.sender || isApprovedForAll(followTokenOwner, msg.sender)) {\n            _unfollowIfHasFollower(followTokenId);\n        } else {\n            revert DoesNotHavePermissions();\n        }\n    }\n\n    /// @inheritdoc IFollowNFT\n    function approveFollow(uint256 followerProfileId, uint256 followTokenId) external override {\n        if (!IERC721Timestamped(HUB).exists(followerProfileId)) {\n            revert Errors.TokenDoesNotExist();\n        }\n        address followTokenOwner = _unsafeOwnerOf(followTokenId);\n        if (followTokenOwner == address(0)) {\n            revert OnlyWrappedFollowTokens();\n        }\n        if (followTokenOwner != msg.sender && !isApprovedForAll(followTokenOwner, msg.sender)) {\n            revert DoesNotHavePermissions();\n        }\n        _approveFollow(followerProfileId, followTokenId);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function wrap(uint256 followTokenId, address wrappedTokenReceiver) external override {\n        if (wrappedTokenReceiver == address(0)) {\n            revert Errors.InvalidParameter();\n        }\n        _wrap(followTokenId, wrappedTokenReceiver);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function wrap(uint256 followTokenId) external override {\n        _wrap(followTokenId, address(0));\n    }\n\n    function _wrap(uint256 followTokenId, address wrappedTokenReceiver) internal {\n        if (_isFollowTokenWrapped(followTokenId)) {\n            revert AlreadyWrapped();\n        }\n        uint256 followerProfileId = _followDataByFollowTokenId[followTokenId].followerProfileId;\n        if (followerProfileId == 0) {\n            followerProfileId = _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover;\n            if (followerProfileId == 0) {\n                revert FollowTokenDoesNotExist();\n            }\n            delete _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover;\n        }\n        address followerProfileOwner = IERC721(HUB).ownerOf(followerProfileId);\n        if (msg.sender != followerProfileOwner) {\n            revert DoesNotHavePermissions();\n        }\n        _mint(wrappedTokenReceiver == address(0) ? followerProfileOwner : wrappedTokenReceiver, followTokenId);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function unwrap(uint256 followTokenId) external override {\n        if (_followDataByFollowTokenId[followTokenId].followerProfileId == 0) {\n            revert NotFollowing();\n        }\n        super.burn(followTokenId);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function processBlock(uint256 followerProfileId) external override onlyHub returns (bool) {\n        bool hasUnfollowed;\n        uint256 followTokenId = _followTokenIdByFollowerProfileId[followerProfileId];\n        if (followTokenId != 0) {\n            if (!_isFollowTokenWrapped(followTokenId)) {\n                // Wrap it first, so the user stops following but does not lose the token when being blocked.\n                _mint(IERC721(HUB).ownerOf(followerProfileId), followTokenId);\n            }\n            _unfollow(followerProfileId, followTokenId);\n            hasUnfollowed = true;\n        }\n        return hasUnfollowed;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowerProfileId(uint256 followTokenId) external view override returns (uint256) {\n        return _followDataByFollowTokenId[followTokenId].followerProfileId;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function isFollowing(uint256 followerProfileId) external view override returns (bool) {\n        return _followTokenIdByFollowerProfileId[followerProfileId] != 0;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowTokenId(uint256 followerProfileId) external view override returns (uint256) {\n        return _followTokenIdByFollowerProfileId[followerProfileId];\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getOriginalFollowTimestamp(uint256 followTokenId) external view override returns (uint256) {\n        return _followDataByFollowTokenId[followTokenId].originalFollowTimestamp;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowTimestamp(uint256 followTokenId) external view override returns (uint256) {\n        return _followDataByFollowTokenId[followTokenId].followTimestamp;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getProfileIdAllowedToRecover(uint256 followTokenId) external view override returns (uint256) {\n        return _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowData(uint256 followTokenId) external view override returns (Types.FollowData memory) {\n        return _followDataByFollowTokenId[followTokenId];\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowApproved(uint256 followTokenId) external view override returns (uint256) {\n        return _followApprovalByFollowTokenId[followTokenId];\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowerCount() external view override returns (uint256) {\n        return _followerCount;\n    }\n\n    function burn(uint256 followTokenId) public override {\n        _unfollowIfHasFollower(followTokenId);\n        super.burn(followTokenId);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(LensBaseERC721, ERC2981CollectionRoyalties)"
    }
  ]
}