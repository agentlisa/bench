{
  "Title": "M-3: Holders of worthless external PTs can stick other Illuminate PT holders with bad debts",
  "Content": "# Issue M-3: Holders of worthless external PTs can stick other Illuminate PT holders with bad debts \n\nSource: https://github.com/sherlock-audit/2022-10-illuminate-judging/issues/119 \n\n## Found by \nIllIllI\n\n## Summary\n\nHolders of worthless external PTs can stick other Illuminate PT holders with bad debts\n\n\n## Vulnerability Detail\n\nSome of the supported external PTs can pause their activity. One such PT, Pendle, not only can pause activity, but can turn on [emergency mode](https://docs.pendle.finance/docs/information/others/pausing-mechanism#pausingmanager-contract) where the admin can transfer the underlying tokens to an [arbitrary contract](https://github.com/pendle-finance/pendle-core/blob/b34d265e4fe8e3a6f79bdec1ab88ab2fd49a882c/contracts/core/abstract/PendleForgeBase.sol#L98-L105) for safekeeping until they decide what to do with the funds. The Illuminate code does not handle such cases, and in fact, if the Pendle protocol is in emergency mode, will still allow users to convert their possibly worthless Pendle PTs to Illuminate ones.\n\nWhile there is a mechanism for the Illuminate admin to pause a market, there's no guarantee that the Illuminate admin will notice the Pendle pause before other users, and even if they do, it's possible that users have automation set up to front-run such pauses for Pendle markets, so that they never are stuck with worthless tokens.\n\n\n## Impact\n\n_Direct theft of any user funds, whether at-rest or in-motion, other than unclaimed yield_\n\nOther users that deposited principal in the form of external PTs (e.g. by minting Illuminate PTs in order to be pool liquidity providers) that have actual value, will have their shares of available underlying diluted by Pendle PTs that cannot be redeemed. Illuminate PTs are on a per-share basis rather than a one-for-one basis, so the less underlying there is at redemption time, the less underlying every Illuminate PT holder gets.\n\n\n## Code Snippet\n\nThere are no checks that the protocol of the external PT is paused or has any value:\n```solidity\n// File: src/Lender.sol : Lender.mint()   #1\n\n270        function mint(\n271            uint8 p,\n272            address u,\n273            uint256 m,\n274            uint256 a\n275        ) external unpaused(u, m, p) returns (bool) {\n276            // Fetch the desired principal token\n277            address principal = IMarketPlace(marketPlace).token(u, m, p);\n278    \n279            // Transfer the users principal tokens to the lender contract\n280            Safe.transferFrom(IERC20(principal), msg.sender, address(this), a);\n281    \n282            // Mint the tokens received from the user\n283            IERC5095(principalToken(u, m)).authMint(msg.sender, a);\n284    \n285            emit Mint(p, u, m, a);\n286    \n287            return true;\n288:       }\n```\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Lender.sol#L270-L288\n\n\nRedemptions of Illuminate PTs for underlyings is based on shares of each Illuminate PT's `totalSupply()` of the _available_ underlying, not the expect underlying total:\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Redeemer.sol#L422\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Redeemer.sol#L464\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Redeemer.sol#L517\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nEnsure that the protocol being used as principal is not paused before allowing minting\n\n\n\n\n## Discussion\n\n**sourabhmarathe**\n\nIn the event of insolvency, we expect the `admin` to pause any principal token using the `unpaused` modifier to block minting.\n\n**IllIllI000**\n\n@sourabhmarathe there is no guarantee that the admin will be aware of the insolvency and do the manual step of pausing, before automated tools notice and take advantage of the issue\n\n**JTraversa**\n\nThis is generally the case with most integrations across most protocols, there is the chance of an atomic attack on multiple protocols preventing the pausing of markets after detection.\n\nSo there arent immediately extremely easy solutions, that said specifically we have already implemented the recommended auditor remediation,\n> Ensure that the protocol being used as principal is not paused before allowing minting\n\nWe do ensure that the protocol being used as a principal does not flag the `unpaused` modifier before any minting.\n\n**IllIllI000**\n\nThe recommendation is to check whether the protocol itself is paused, not to check whether Illuminate has its own paused flag set\n\n**Evert0x**\n\nValid issue but downgrading to medium severity as the conditions are dependent on an external protocol their admin functions. \n\n**JTraversa**\n\nUnderstood although this presupposes the idea that all of them can even be paused.\n\nAgain, im unsure if this is a reasonable request, as you could submit the same exact report for every single sherlock audit and it would be equally valid for every single integration ever?\n\nFurther, if there is an attack, the attacker would simply just attack illuminate before the external protocol can be paused, completely bypassing any checks and just leaving normal users paying more gas.\n\nIt all just seems kind of unreasonable, especially as you add additional integrations to the stack (e.g. Illuminate -> Swivel -> Euler -> Lido, do we somehow check EACH of these before every transaction?)\n\n**0x00052**\n\nEscalate for 1 USDC\n\nReminder @Evert0x \n\n**sherlock-admin**\n\n > Escalate for 1 USDC\n> \n> Reminder @Evert0x \n\nYou've created a valid escalation for 1 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/12",
  "Code": [
    {
      "filename": "contracts/core/abstract/PendleForgeBase.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../../libraries/ExpiryUtilsLib.sol\";\nimport \"../../interfaces/IPendleBaseToken.sol\";\nimport \"../../interfaces/IPendleData.sol\";\nimport \"../../interfaces/IPendleForge.sol\";\nimport \"../../interfaces/IPendleRewardManager.sol\";\nimport \"../../interfaces/IPendleYieldContractDeployer.sol\";\nimport \"../../interfaces/IPendleYieldTokenHolder.sol\";\nimport \"../../periphery/WithdrawableV2.sol\";\nimport \"../../libraries/MathLib.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/// @notice Common contract base for a forge implementation.\n/// @dev Each specific forge implementation will need to implement the virtual functions\nabstract contract PendleForgeBase is IPendleForge, WithdrawableV2, ReentrancyGuard {\n    using ExpiryUtils for string;\n    using SafeMath for uint256;\n    using Math for uint256;\n    using SafeERC20 for IERC20;\n\n    struct PendleTokens {\n        IPendleYieldToken xyt;\n        IPendleYieldToken ot;\n    }\n\n    IPendleRouter public immutable override router;\n    IPendleData public immutable override data;\n    bytes32 public immutable override forgeId;\n    IERC20 public immutable override rewardToken; // COMP/StkAAVE\n    IPendleRewardManager public immutable override rewardManager;\n    IPendleYieldContractDeployer public immutable override yieldContractDeployer;\n    IPendlePausingManager public immutable pausingManager;\n\n    mapping(address => mapping(uint256 => mapping(address => uint256)))\n        public\n        override dueInterests;\n\n    mapping(address => mapping(uint256 => uint256)) public totalFee;\n    mapping(address => mapping(uint256 => address)) public override yieldTokenHolders; // yieldTokenHolders[underlyingAsset][expiry]\n\n    string private constant OT = \"OT\";\n    string private constant XYT = \"YT\";\n\n    modifier onlyXYT(address _underlyingAsset, uint256 _expiry) {\n        require(\n            msg.sender == address(data.xytTokens(forgeId, _underlyingAsset, _expiry)),\n            \"ONLY_YT\"\n        );\n        _;\n    }\n\n    modifier onlyOT(address _underlyingAsset, uint256 _expiry) {\n        require(\n            msg.sender == address(data.otTokens(forgeId, _underlyingAsset, _expiry)),\n            \"ONLY_OT\"\n        );\n        _;\n    }\n\n    modifier onlyRouter() {\n        require(msg.sender == address(router), \"ONLY_ROUTER\");\n        _;\n    }\n\n    constructor(\n        address _governanceManager,\n        IPendleRouter _router,\n        bytes32 _forgeId,\n        address _rewardToken,\n        address _rewardManager,\n        address _yieldContractDeployer\n    ) PermissionsV2(_governanceManager) {\n        require(address(_router) != address(0), \"ZERO_ADDRESS\");\n        require(_forgeId != 0x0, \"ZERO_BYTES\");\n\n        router = _router;\n        forgeId = _forgeId;\n        IPendleData _dataTemp = IPendleRouter(_router).data();\n        data = _dataTemp;\n        rewardToken = IERC20(_rewardToken);\n        rewardManager = IPendleRewardManager(_rewardManager);\n        yieldContractDeployer = IPendleYieldContractDeployer(_yieldContractDeployer);\n        pausingManager = _dataTemp.pausingManager();\n    }\n\n    // INVARIANT: All write functions must go through this check.\n    // All XYT/OT transfers must go through this check as well. As such, XYT/OT transfers are also paused\n    function checkNotPaused(address _underlyingAsset, uint256 _expiry) internal {\n        (bool paused, ) =\n            pausingManager.checkYieldContractStatus(forgeId, _underlyingAsset, _expiry);\n        require(!paused, \"YIELD_CONTRACT_PAUSED\");\n    }\n\n    // Only the forgeEmergencyHandler can call this function, when its in emergencyMode\n    // this will allow a spender to spend the whole balance of the specified tokens of the yieldTokenHolder contract\n    // the spender should ideally be a contract with logic for users to withdraw out their funds.\n    function setUpEmergencyMode(\n        address _underlyingAsset,\n        uint256 _expiry,\n        address spender\n    ) external override {\n        (, bool emergencyMode) =\n            pausingManager.checkYieldContractStatus(forgeId, _underlyingAsset, _expiry);\n        require(emergencyMode, \"NOT_EMERGENCY\");\n        (address forgeEmergencyHandler, , ) = pausingManager.forgeEmergencyHandler();\n        require(msg.sender == forgeEmergencyHandler, \"NOT_EMERGENCY_HANDLER\");\n        IPendleYieldTokenHolder(yieldTokenHolders[_underlyingAsset][_expiry]).setUpEmergencyMode(\n            spender\n        );\n    }\n\n    /**\n    Use:\n        To create a newYieldContract\n    Conditions:\n        * only call by Router\n        * the yield contract for this pair of _underlyingAsset & _expiry must not exist yet (checked on Router)\n    */\n    function newYieldContracts(address _underlyingAsset, uint256 _expiry)\n        external\n        override\n        onlyRouter\n        returns (address ot, address xyt)\n    {\n        checkNotPaused(_underlyingAsset, _expiry);\n        address yieldToken = _getYieldBearingToken(_underlyingAsset);\n        uint8 yieldTokenDecimals = IPendleYieldToken(yieldToken).decimals();\n\n        // require(yieldToken != address(0), \"INVALID_ASSET\"); Guaranteed by _getYieldBearingToken\n\n        // Deploy the OT contract -> XYT contract -> yieldTokenHolder\n        ot = yieldContractDeployer.forgeOwnershipToken(\n            _underlyingAsset,\n            OT.concat(IPendleBaseToken(yieldToken).name(), _expiry, \" \"),\n            OT.concat(IPendleBaseToken(yieldToken).symbol(), _expiry, \"-\"),\n            yieldTokenDecimals,\n            _expiry\n        );\n\n        xyt = yieldContractDeployer.forgeFutureYieldToken(\n            _underlyingAsset,\n            XYT.concat(IPendleBaseToken(yieldToken).name(), _expiry, \" \"),\n            XYT.concat(IPendleBaseToken(yieldToken).symbol(), _expiry, \"-\"),\n            yieldTokenDecimals,\n            _expiry\n        );\n\n        yieldTokenHolders[_underlyingAsset][_expiry] = yieldContractDeployer\n            .deployYieldTokenHolder(yieldToken, _expiry);\n\n        data.storeTokens(forgeId, ot, xyt, _underlyingAsset, _expiry);\n\n        emit NewYieldContracts(forgeId, _underlyingAsset, _expiry, ot, xyt, yieldToken);\n    }\n\n    /**\n    Use:\n        * To redeem the underlying asset & due interests after the XYT has expired\n    Conditions:\n        * only be called by Router\n        * only callable after XYT has expired (checked on Router)\n        * If _transferOutRate != RONE, there should be a forwardYieldToken call outside\n    Consideration:\n        * Why not use redeemUnderlying? Because redeemAfterExpiry doesn't require XYT (which has zero value now).\n            Users just need OT to redeem\n    */\n    function redeemAfterExpiry(\n        address _user,\n        address _underlyingAsset,\n        uint256 _expiry\n    ) external override onlyRouter returns (uint256 redeemedAmount) {\n        checkNotPaused(_underlyingAsset, _expiry);\n        IERC20 yieldToken = IERC20(_getYieldBearingToken(_underlyingAsset));\n        PendleTokens memory tokens = _getTokens(_underlyingAsset, _expiry);\n        uint256 expiredOTamount = tokens.ot.balanceOf(_user);\n        require(expiredOTamount > 0, \"NOTHING_TO_REDEEM\");\n\n        // burn ot only, since users don't need xyt to redeem this\n        tokens.ot.burn(_user, expiredOTamount);\n\n        // calc the value of the OT after since it expired (total of its underlying value + dueInterests since expiry)\n        // no forge fee is charged on redeeming OT. Forge fee is only charged on redeeming XYT\n        redeemedAmount = _calcTotalAfterExpiry(_underlyingAsset, _expiry, expiredOTamount);\n\n        // redeem the interest of any XYT (of the same underlyingAsset+expiry) that the user is having\n        redeemedAmount = redeemedAmount.add(\n            _beforeTransferDueInterests(tokens, _underlyingAsset, _expiry, _user, false)\n        );\n\n        // transfer back to the user\n        redeemedAmount = _safeTransfer(\n            yieldToken,\n            _underlyingAsset,\n            _expiry,\n            _user,\n            redeemedAmount\n        );\n\n        // Notice for anyone taking values from this event:\n        //   The redeemedAmount includes the interest due to any XYT held\n        //   to get the exact yieldToken redeemed from OT, we need to deduct the (amount +forgeFeeAmount) of interests\n        //   settled that was emitted in the DueInterestsSettled event emitted earlier in this same transaction\n        emit RedeemYieldToken(\n            forgeId,\n            _underlyingAsset,\n            _expiry,\n            expiredOTamount,\n            redeemedAmount,\n            _user\n        );\n    }\n\n    /**\n    Use:\n        * To redeem the underlying asset & due interests before the expiry of the XYT. In this case, for each OT used\n        to redeem, there must be an XYT (of the same yield contract)\n    Conditions:\n        * only be called by Router\n        * only callable if the XYT hasn't expired\n    */\n    function redeemUnderlying(\n        address _user,\n        address _underlyingAsset,\n        uint256 _expiry,\n        uint256 _amountToRedeem\n    ) external override onlyRouter returns (uint256 redeemedAmount) {\n        checkNotPaused(_underlyingAsset, _expiry);\n        PendleTokens memory tokens = _getTokens(_underlyingAsset, _expiry);\n\n        IERC20 yieldToken = IERC20(_getYieldBearingToken(_underlyingAsset));\n\n        tokens.ot.burn(_user, _amountToRedeem);\n        tokens.xyt.burn(_user, _amountToRedeem);\n\n        /*\n        * calc the amount of underlying asset for OT + the amount of dueInterests for XYT\n        * dueInterests for XYT has been updated during the process of burning XYT, so we skip updating dueInterests in\n            the _beforeTransferDueInterests function\n        */\n        redeemedAmount = _calcUnderlyingToRedeem(_underlyingAsset, _amountToRedeem).add(\n            _beforeTransferDueInterests(tokens, _underlyingAsset, _expiry, _user, true)\n        );\n\n        // transfer the amountTransferOut back to the user\n        redeemedAmount = _safeTransfer(\n            yieldToken,\n            _underlyingAsset,\n            _expiry,\n            _user,\n            redeemedAmount\n        );\n\n        // Notice for anyone taking values from this event:\n        //   The redeemedAmount includes the interest due to the XYT held\n        //   to get the exact yieldToken redeemed from OT+XYT, we need to deduct the (amount +forgeFeeAmount) of interests\n        //   settled that was emitted in the DueInterestsSettled event emitted earlier in this same transaction\n        emit RedeemYieldToken(\n            forgeId,\n            _underlyingAsset,\n            _expiry,\n            _amountToRedeem,\n            redeemedAmount,\n            _user\n        );\n\n        return redeemedAmount;\n    }\n\n    /**\n    Use:\n        * To redeem the due interests. This function can always be called regardless of whether the XYT has expired or not\n    Conditions:\n        * only be called by Router\n    */\n    function redeemDueInterests(\n        address _user,\n        address _underlyingAsset,\n        uint256 _expiry\n    ) external override onlyRouter returns (uint256 amountOut) {\n        checkNotPaused(_underlyingAsset, _expiry);\n        PendleTokens memory tokens = _getTokens(_underlyingAsset, _expiry);\n        IERC20 yieldToken = IERC20(_getYieldBearingToken(_underlyingAsset));\n\n        // update the dueInterests of the user before we transfer out\n        amountOut = _beforeTransferDueInterests(tokens, _underlyingAsset, _expiry, _user, false);\n\n        amountOut = _safeTransfer(yieldToken, _underlyingAsset, _expiry, _user, amountOut);\n    }\n\n    /**\n    Use:\n        * To update the dueInterests for users(before their balances of XYT changes)\n        * This must be called before any transfer / mint/ burn action of XYT\n        (and this has been implemented in the beforeTokenTransfer of the PendleFutureYieldToken)\n    Conditions:\n        * Can only be called by the respective XYT contract, before transferring XYTs\n    */\n    function updateDueInterests(\n        address _underlyingAsset,\n        uint256 _expiry,\n        address _user\n    ) external override onlyXYT(_underlyingAsset, _expiry) nonReentrant {\n        checkNotPaused(_underlyingAsset, _expiry);\n        PendleTokens memory tokens = _getTokens(_underlyingAsset, _expiry);\n        uint256 principal = tokens.xyt.balanceOf(_user);\n        _updateDueInterests(principal, _underlyingAsset, _expiry, _user);\n    }\n\n    /**\n    Use:\n        * To redeem the rewards (COMP and StkAAVE) for users(before their balances of OT changes)\n        * This must be called before any transfer / mint/ burn action of OT\n        (and this has been implemented in the beforeTokenTransfer of the PendleOwnershipToken)\n    Conditions:\n        * Can only be called by the respective OT contract, before transferring OTs\n    Note:\n        This function is just a proxy to call to rewardManager\n    */\n    function updatePendingRewards(\n        address _underlyingAsset,\n        uint256 _expiry,\n        address _user\n    ) external override onlyOT(_underlyingAsset, _expiry) nonReentrant {\n        checkNotPaused(_underlyingAsset, _expiry);\n        rewardManager.updatePendingRewards(_underlyingAsset, _expiry, _user);\n    }\n\n    /**\n    Use:\n        * To mint OT & XYT given that the user has transferred in _amountToTokenize of aToken/cToken\n        * The newly minted OT & XYT can be minted to somebody else different from the user who transfer the aToken/cToken in\n    Conditions:\n        * Should only be called by Router\n        * The yield contract (OT & XYT) must not be expired yet (checked at Router)\n    */\n    function mintOtAndXyt(\n        address _underlyingAsset,\n        uint256 _expiry,\n        uint256 _amountToTokenize,\n        address _to\n    )\n        external\n        override\n        onlyRouter\n        returns (\n            address ot,\n            address xyt,\n            uint256 amountTokenMinted\n        )\n    {\n        checkNotPaused(_underlyingAsset, _expiry);\n        PendleTokens memory tokens = _getTokens(_underlyingAsset, _expiry);\n\n        amountTokenMinted = _calcAmountToMint(_underlyingAsset, _amountToTokenize);\n\n        // updatePendingRewards will be called in mint\n        tokens.ot.mint(_to, amountTokenMinted);\n\n        // updateDueInterests will be called in mint\n        tokens.xyt.mint(_to, amountTokenMinted);\n\n        emit MintYieldTokens(\n            forgeId,\n            _underlyingAsset,\n            _expiry,\n            _amountToTokenize,\n            amountTokenMinted,\n            _to\n        );\n        return (address(tokens.ot), address(tokens.xyt), amountTokenMinted);\n    }\n\n    /**\n    Use:\n        * To withdraw the forgeFee\n    Conditions:\n        * Should only be called by Governance\n        * This function must be the only way to withdrawForgeFee\n    Consideration:\n        * Although this function can be called directly, it doesn't have ReentrancyGuard since it can only be called by governance\n    */\n    function withdrawForgeFee(address _underlyingAsset, uint256 _expiry)\n        external\n        override\n        onlyGovernance\n    {\n        checkNotPaused(_underlyingAsset, _expiry);\n        IERC20 yieldToken = IERC20(_getYieldBearingToken(_underlyingAsset));\n\n        //ping to update interest up to now\n        _updateForgeFee(_underlyingAsset, _expiry, 0);\n        uint256 _totalFee = totalFee[_underlyingAsset][_expiry];\n        totalFee[_underlyingAsset][_expiry] = 0;\n\n        address treasuryAddress = data.treasury();\n        _totalFee = _safeTransfer(\n            yieldToken,\n            _underlyingAsset,\n            _expiry,\n            treasuryAddress,\n            _totalFee\n        );\n        emit ForgeFeeWithdrawn(forgeId, _underlyingAsset, _expiry, _totalFee);\n    }\n\n    function getYieldBearingToken(address _underlyingAsset) external override returns (address) {\n        return _getYieldBearingToken(_underlyingAsset);\n    }\n\n    /**\n    @notice To be called before the dueInterest of any users is redeemed.\n    @param _skipUpdateDueInterests: this is set to true, if there was already a call to _updateDueInterests() in this transaction\n    INVARIANT: there must be a transfer of the interests (amountOut) to the user after this function is called\n    */\n    function _beforeTransferDueInterests(\n        PendleTokens memory _tokens,\n        address _underlyingAsset,\n        uint256 _expiry,\n        address _user,\n        bool _skipUpdateDueInterests\n    ) internal returns (uint256 amountOut) {\n        uint256 principal = _tokens.xyt.balanceOf(_user);\n\n        if (!_skipUpdateDueInterests) {\n            _updateDueInterests(principal, _underlyingAsset, _expiry, _user);\n        }\n\n        amountOut = dueInterests[_underlyingAsset][_expiry][_user];\n        dueInterests[_underlyingAsset][_expiry][_user] = 0;\n\n        uint256 forgeFee = data.forgeFee();\n        uint256 forgeFeeAmount;\n        /*\n         * Collect the forgeFee\n         * INVARIANT: all XYT interest payout must go through this line\n         */\n        if (forgeFee > 0) {\n            forgeFeeAmount = amountOut.rmul(forgeFee);\n            amountOut = amountOut.sub(forgeFeeAmount);\n            _updateForgeFee(_underlyingAsset, _expiry, forgeFeeAmount);\n        }\n\n        emit DueInterestsSettled(\n            forgeId,\n            _underlyingAsset,\n            _expiry,\n            amountOut,\n            forgeFeeAmount,\n            _user\n        );\n    }\n\n    /**\n    Use:\n        * Must be the only way to transfer aToken/cToken out\n    Consideration:\n        * Due to mathematical precision, in some extreme cases, the forge may lack a few wei of tokens to transfer back\n            That's why there is a call to minimize the amount to transfer out with the balance of the contract\n        * Nonetheless, because we are collecting some forge fee, so it's expected that all users will receive the full\n        amount of aToken/cToken (and we will receive a little less than the correct amount)\n    */\n    function _safeTransfer(\n        IERC20 _yieldToken,\n        address _underlyingAsset,\n        uint256 _expiry,\n        address _user,\n        uint256 _amount\n    ) internal returns (uint256) {\n        address yieldTokenHolder = yieldTokenHolders[_underlyingAsset][_expiry];\n        _amount = Math.min(_amount, _yieldToken.balanceOf(yieldTokenHolder));\n        if (_amount == 0) return 0;\n        _yieldToken.safeTransferFrom(yieldTokenHolder, _user, _amount);\n        return _amount;\n    }\n\n    function _getTokens(address _underlyingAsset, uint256 _expiry)\n        internal\n        view\n        returns (PendleTokens memory _tokens)\n    {\n        (_tokens.ot, _tokens.xyt) = data.getPendleYieldTokens(forgeId, _underlyingAsset, _expiry);\n    }\n\n    // There shouldn't be any fund in here\n    // hence governance is allowed to withdraw anything from here.\n    function _allowedToWithdraw(address) internal pure override returns (bool allowed) {\n        allowed = true;\n    }\n\n    /// INVARIANT: after _updateDueInterests is called, dueInterests[][][] must already be\n    /// updated with all the due interest for the user, until exactly the current timestamp (no caching whatsoever)\n    /// Refer to updateDueInterests function for more info\n    function _updateDueInterests(\n        uint256 _principal,\n        address _underlyingAsset,\n        uint256 _expiry,\n        address _user\n    ) internal virtual;\n\n    /**\n    Use:\n        * To update the amount of forgeFee (taking into account the compound interest effect)\n        * To be called whenever the forge collect fees, or before withdrawing the fee\n    * @param _feeAmount the new fee that this forge just collected\n    */\n    function _updateForgeFee(\n        address _underlyingAsset,\n        uint256 _expiry,\n        uint256 _feeAmount\n    ) internal virtual;\n\n    /// calculate the (principal + interest) from the last action before expiry to now.\n    function _calcTotalAfterExpiry(\n        address _underlyingAsset,\n        uint256 _expiry,\n        uint256 redeemedAmount\n    ) internal virtual returns (uint256 totalAfterExpiry);\n\n    /// Calc the amount of underlying asset to redeem. Default is 1 OT -> 1 yieldToken, except for Compound\n    function _calcUnderlyingToRedeem(address, uint256 _amountToRedeem)\n        internal\n        virtual\n        returns (uint256 underlyingToRedeem)\n    {\n        underlyingToRedeem = _amountToRedeem;\n    }\n\n    /// Calc the amount of OT & XYT to mint. Default is 1 yieldToken -> 1 OT & 1 XYT, except for Compound\n    function _calcAmountToMint(address, uint256 _amountToTokenize)\n        internal\n        virtual\n        returns (uint256 amountToMint)\n    {\n        amountToMint = _amountToTokenize;\n    }\n\n    /// Get the address of the yieldBearingToken from Aave/Compound\n    function _getYieldBearingToken(address _underlyingAsset) internal virtual returns (address);\n}"
    },
    {
      "filename": "src/Lender.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.16;\n\nimport 'src/MarketPlace.sol'; // library of MarketPlace specific constructs\nimport 'src/lib/Swivel.sol'; // library of Swivel specific constructs\nimport 'src/lib/Element.sol'; // library of Element specific constructs\nimport 'src/lib/Safe.sol';\nimport 'src/lib/Cast.sol';\nimport 'src/lib/RevertMsgExtractor.sol';\nimport 'src/errors/Exception.sol';\n\nimport 'src/interfaces/ITempus.sol';\nimport 'src/interfaces/ITempusAMM.sol';\nimport 'src/interfaces/ITempusPool.sol';\nimport 'src/interfaces/ITempusToken.sol';\nimport 'src/interfaces/IERC20.sol';\nimport 'src/interfaces/IERC5095.sol';\nimport 'src/interfaces/ISensePeriphery.sol';\nimport 'src/interfaces/ISenseAdapter.sol';\nimport 'src/interfaces/ISenseDivider.sol';\nimport 'src/interfaces/IERC20.sol';\nimport 'src/interfaces/IYield.sol';\nimport 'src/interfaces/IYieldToken.sol';\nimport 'src/interfaces/ISwivel.sol';\nimport 'src/interfaces/IElementToken.sol';\nimport 'src/interfaces/IElementVault.sol';\nimport 'src/interfaces/ISwivel.sol';\nimport 'src/interfaces/IAPWineAMMPool.sol';\nimport 'src/interfaces/IAPWineRouter.sol';\nimport 'src/interfaces/IAPWineToken.sol';\nimport 'src/interfaces/IAPWineFutureVault.sol';\nimport 'src/interfaces/IAPWineController.sol';\nimport 'src/interfaces/INotional.sol';\nimport 'src/interfaces/IPendle.sol';\nimport 'src/interfaces/IPendleToken.sol';\n\n/// @title Lender\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice The lender contract executes loans on behalf of users\n/// @notice The contract holds the principal tokens and mints an ERC-5095 tokens to users to represent their loans\ncontract Lender {\n    /// @notice minimum wait before the admin may withdraw funds or change the fee rate\n    uint256 public constant HOLD = 3 days;\n\n    /// @notice address that is allowed to set and withdraw fees, disable principals, etc. It is commonly used in the authorized modifier.\n    address public admin;\n    /// @notice address of the MarketPlace contract, used to access the markets mapping\n    address public marketPlace;\n    /// @notice mapping that determines if a principal token has been paused by the admin\n    mapping(address => mapping(uint256 => bool[9])) public paused;\n\n    /// @notice contract used to execute swaps on Swivel's exchange\n    address public immutable swivelAddr;\n    /// @notice a SushiSwap router used by Pendle to execute swaps\n    address public immutable pendleAddr;\n\n    /// @notice this value determines the amount of fees paid on loans\n    uint256 public feenominator;\n    /// @notice represents a point in time where the feenominator may change\n    uint256 public feeChange;\n    /// @notice represents a minimum that the feenominator must exceed\n    uint256 public constant MIN_FEENOMINATOR = 500;\n\n    /// @notice maps underlying tokens to the amount of fees accumulated for that token\n    mapping(address => uint256) public fees;\n    /// @notice maps a token address to a point in time, a hold, after which a withdrawal can be made\n    mapping(address => uint256) public withdrawals;\n\n    /// @notice emitted upon lending to a protocol\n    event Lend(\n        uint8 principal,\n        address indexed underlying,\n        uint256 indexed maturity,\n        uint256 returned,\n        uint256 spent,\n        address sender\n    );\n    /// @notice emitted upon minting Illuminate principal tokens\n    event Mint(\n        uint8 principal,\n        address indexed underlying,\n        uint256 indexed maturity,\n        uint256 amount\n    );\n    /// @notice emitted upon scheduling a withdrawal\n    event ScheduleWithdrawal(address indexed token, uint256 hold);\n    /// @notice emitted upon blocking a scheduled withdrawal\n    event BlockWithdrawal(address indexed token);\n    /// @notice emitted upon changing the admin\n    event SetAdmin(address indexed admin);\n    /// @notice emitted upon setting the fee rate\n    event SetFee(uint256 indexed fee);\n    /// @notice emitted upon scheduling a fee change\n    event ScheduleFeeChange(uint256 when);\n    /// @notice emitted upon blocking a scheduled fee change\n    event BlockFeeChange();\n    /// @notice emitted upon pausing or unpausing of a principal token\n    event PauseMarket(\n        uint8 principal,\n        address indexed underlying,\n        uint256 indexed maturity,\n        address token,\n        bool indexed state\n    );\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Exception(0, 0, 0, msg.sender, a);\n        }\n        _;\n    }\n\n    /// @notice reverts on all markets where the paused mapping returns true\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    modifier unpaused(\n        address u,\n        uint256 m,\n        uint8 p\n    ) {\n        if (paused[u][m][p]) {\n            revert Exception(1, p, 0, address(0), address(0));\n        }\n        _;\n    }\n\n    /// @notice initializes the Lender contract\n    /// @param s the Swivel contract\n    /// @param p the Pendle contract\n    constructor(address s, address p) {\n        admin = msg.sender;\n        swivelAddr = s;\n        pendleAddr = p;\n        feenominator = 1000;\n    }\n\n    /// @notice approves the redeemer contract to spend the principal tokens held by the lender contract.\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param r the address being approved, in this case the redeemer contract\n    /// @return bool true if the approval was successful\n    function approve(\n        address u,\n        uint256 m,\n        address r\n    ) external authorized(admin) returns (bool) {\n        // approve the underlying for max per given principal\n        for (uint8 i; i != 9; ) {\n            // get the principal token's address\n            address token = IMarketPlace(marketPlace).token(u, m, i);\n            // check that the token is defined for this particular market\n            if (token != address(0)) {\n                // max approve the token\n                Safe.approve(IERC20(token), r, type(uint256).max);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return true;\n    }\n\n    /// @notice bulk approves the usage of addresses at the given ERC20 addresses.\n    /// @dev the lengths of the inputs must match because the arrays are paired by index\n    /// @param u array of ERC20 token addresses that will be approved on\n    /// @param a array of addresses that will be approved\n    /// @return true if successful\n    function approve(address[] calldata u, address[] calldata a)\n        external\n        authorized(admin)\n        returns (bool)\n    {\n        for (uint256 i; i != u.length; ) {\n            IERC20 uToken = IERC20(u[i]);\n            if (address(0) != (address(uToken))) {\n                Safe.approve(uToken, a[i], type(uint256).max);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return true;\n    }\n\n    /// @notice approves market contracts that require lender approval\n    /// @param u address of an underlying asset\n    /// @param a APWine's router contract\n    /// @param e Element's vault contract\n    /// @param n Notional's token contract\n    function approve(\n        address u,\n        address a,\n        address e,\n        address n\n    ) external authorized(marketPlace) {\n        uint256 max = type(uint256).max;\n        IERC20 uToken = IERC20(u);\n        if (a != address(0)) {\n            Safe.approve(uToken, a, max);\n        }\n        if (e != address(0)) {\n            Safe.approve(uToken, e, max);\n        }\n        if (n != address(0)) {\n            Safe.approve(uToken, n, max);\n        }\n        if (IERC20(u).allowance(address(this), swivelAddr) == 0) {\n            Safe.approve(uToken, swivelAddr, max);\n        }\n    }\n\n    /// @notice sets the admin address\n    /// @param a address of a new admin\n    /// @return bool true if successful\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        emit SetAdmin(a);\n        return true;\n    }\n\n    /// @notice sets the feenominator to the given value\n    /// @param f the new value of the feenominator, fees are not collected when the feenominator is 0\n    /// @return bool true if successful\n    function setFee(uint256 f) external authorized(admin) returns (bool) {\n        uint256 feeTime = feeChange;\n        if (feeTime == 0) {\n            revert Exception(23, 0, 0, address(0), address(0));\n        } else if (block.timestamp < feeTime) {\n            revert Exception(\n                24,\n                block.timestamp,\n                feeTime,\n                address(0),\n                address(0)\n            );\n        } else if (f < MIN_FEENOMINATOR) {\n            revert Exception(25, 0, 0, address(0), address(0));\n        }\n        feenominator = f;\n        delete feeChange;\n        emit SetFee(f);\n        return true;\n    }\n\n    /// @notice sets the address of the marketplace contract which contains the addresses of all the fixed rate markets\n    /// @param m the address of the marketplace contract\n    /// @return bool true if the address was set\n    function setMarketPlace(address m)\n        external\n        authorized(admin)\n        returns (bool)\n    {\n        if (marketPlace != address(0)) {\n            revert Exception(5, 0, 0, marketPlace, address(0));\n        }\n        marketPlace = m;\n        return true;\n    }\n\n    /// @notice mint swaps the sender's principal tokens for Illuminate's ERC5095 tokens in effect, this opens a new fixed rate position for the sender on Illuminate\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount being minted\n    /// @return bool true if the mint was successful\n    function mint(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a\n    ) external unpaused(u, m, p) returns (bool) {\n        // Fetch the desired principal token\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Transfer the users principal tokens to the lender contract\n        Safe.transferFrom(IERC20(principal), msg.sender, address(this), a);\n\n        // Mint the tokens received from the user\n        IERC5095(principalToken(u, m)).authMint(msg.sender, a);\n\n        emit Mint(p, u, m, a);\n\n        return true;\n    }\n\n    /// @notice lend method for the Illuminate and Yield protocols\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param y Yield Space Pool for the principal token\n    /// @param minimum slippage limit, minimum amount to PTs to buy\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        address y,\n        uint256 minimum\n    ) external unpaused(u, m, p) returns (uint256) {\n        // Check that the principal is Illuminate or Yield\n        if (\n            p != uint8(MarketPlace.Principals.Illuminate) &&\n            p != uint8(MarketPlace.Principals.Yield)\n        ) {\n            revert Exception(6, 0, 0, address(0), address(0));\n        }\n\n        // Get principal token for this market\n        address principal = IMarketPlace(marketPlace)."
    }
  ]
}