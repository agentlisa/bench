{
  "Title": "M-7: changeTreasury() Lack of check and remove old",
  "Content": "# Issue M-7: changeTreasury() Lack of check and remove old \n\nSource: https://github.com/sherlock-audit/2023-03-Y2K-judging/issues/208 \n\n## Found by \nHonorLt, VAD37, bin2chen, nobody2018\n\n## Summary\nchangeTreasury() Lack of check and remove old\n## Vulnerability Detail\nchangeTreasury() used to set new treasury\nThe code is as followsï¼š\n```solidity\n    function changeTreasury(uint256 _marketId, address _treasury)\n        public\n        onlyTimeLocker\n    {\n        if (_treasury == address(0)) revert AddressZero();\n\n        address[2] memory vaults = marketIdToVaults[_marketId];\n\n        if (vaults[0] == address(0) || vaults[1] == address(0)) {\n            revert MarketDoesNotExist(_marketId);\n        }\n        IVaultV2(vaults[0]).whiteListAddress(_treasury);\n        IVaultV2(vaults[1]).whiteListAddress(_treasury);\n        IVaultV2(vaults[0]).setTreasury(treasury);\n        IVaultV2(vaults[1]).setTreasury(treasury);\n\n        emit AddressWhitelisted(_treasury, _marketId);\n    }\n```\nThe above code has the following problem:\n1. no check whether the new treasury same as the old. If it is the same, the whitelist will be canceled.\n2. Use setTreasury(VaultFactoryV2.treasury), it should be setTreasury(_treasury)\n3. not cancel old  treasury from the whitelist \n\n## Impact\nwhiteListAddress abnormal\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-03-Y2K/blob/main/Earthquake/src/v2/VaultFactoryV2.sol#L228\n## Tool used\n\nManual Review\n\n## Recommendation\n```solidity\n    function changeTreasury(uint256 _marketId, address _treasury)\n        public\n        onlyTimeLocker\n    {\n        if (_treasury == address(0)) revert AddressZero();\n\n        address[2] memory vaults = marketIdToVaults[_marketId];\n\n        if (vaults[0] == address(0) || vaults[1] == address(0)) {\n            revert MarketDoesNotExist(_marketId);\n        }\n\n+       require(vaults[0].treasury() !=_treasury,\"same\"); //check same\n+       IVaultV2(vaults[0]).whiteListAddress(vaults[0].treasury()); //cancel old whitelist\n+       IVaultV2(vaults[1]).whiteListAddress(vaults[1].treasury()); //cancel old whitelist\n\n        IVaultV2(vaults[0]).whiteListAddress(_treasury);\n        IVaultV2(vaults[1]).whiteListAddress(_treasury);\n+       IVaultV2(vaults[0]).setTreasury(_treasury);\n+       IVaultV2(vaults[1]).setTreasury(_treasury);\n-       IVaultV2(vaults[0]).setTreasury(treasury);\n-       IVaultV2(vaults[1]).setTreasury(treasury);\n\n        emit AddressWhitelisted(_treasury, _marketId);\n    }\n```\n\n\n\n## Discussion\n\n**dmitriia**\n\nKeeping it separate from 435 because of whitelist observation (1)\n\n**pauliax**\n\nEscalate for 10 USDC.\n\nI believe it is unfair to leave it as a solo medium.\n\n#410 also mentions the problem with whitelisting: \"Also, probably the old treasury should be removed from the whitelist to prevent accidental abuse of privileges.\" but was grouped together with other issues from #435.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC.\n> \n> I believe it is unfair to leave it as a solo medium.\n> \n> #410 also mentions the problem with whitelisting: \"Also, probably the old treasury should be removed from the whitelist to prevent accidental abuse of privileges.\" but was grouped together with other issues from #435.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**3xHarry**\n\nfix Pr: https://github.com/Y2K-Finance/Earthquake/pull/137\n\n**hrishibhat**\n\nEscalation accepted\n\nAdded relevant duplicates based on whitelist observation\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Added relevant duplicates based on whitelist observation\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n**IAm0x52**\n\nFixes look good. Carousel now directly uses the treasury address sent on factory\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/57",
  "Code": [
    {
      "filename": "Earthquake/src/v2/VaultFactoryV2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {IVaultV2} from \"./interfaces/IVaultV2.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {VaultV2Creator} from \"./libraries/VaultV2Creator.sol\";\n\n/// @author Y2K Finance Team\n\ncontract VaultFactoryV2 is Ownable {\n    address public immutable WETH;\n    bytes internal constant COLLAT = \"COLLATERAL\";\n    bytes internal constant PREMIUM = \"PREMIUM\";\n    bytes internal constant CSYMBOL = \"cY2K\";\n    bytes internal constant PSYMBOL = \"pY2K\";\n    /*//////////////////////////////////////////////////////////////\n                                Storage\n    //////////////////////////////////////////////////////////////*/\n    address public treasury;\n    bool internal adminSetController;\n    address public timelocker;\n\n    mapping(uint256 => address[2]) public marketIdToVaults; //[0] premium and [1] collateral vault\n    mapping(uint256 => uint256[]) public marketIdToEpochs; //all epochs in the market\n    mapping(uint256 => uint16) public epochFee; // epochId to fee\n    mapping(address => address) public tokenToOracle; //token address to respective oracle smart contract address\n    mapping(address => bool) public controllers;\n\n    /*//////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n    /** @notice Contract constructor\n     * @param _weth WETH address\n     * @param _treasury Treasury address\n     * @param _timelocker Timelocker address\n     */\n    constructor(\n        address _weth,\n        address _treasury,\n        address _timelocker\n    ) {\n        if (_weth == address(0)) revert AddressZero();\n        WETH = _weth;\n        timelocker = _timelocker;\n        treasury = _treasury;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n    /**\n    @notice Function to create two new vaults, premium and collateral, with the respective params, and storing the oracle for the token provided\n    @param  _marketCalldata MarketConfigurationCalldata struct with the market params\n    @return premium address of the premium vault\n    @return collateral address of the collateral vault\n    @return marketId uint256 of the marketId\n     */\n    function createNewMarket(MarketConfigurationCalldata memory _marketCalldata)\n        external\n        onlyOwner\n        returns (\n            address premium,\n            address collateral,\n            uint256 marketId\n        )\n    {\n        if (!controllers[_marketCalldata.controller]) revert ControllerNotSet();\n        if (_marketCalldata.token == address(0)) revert AddressZero();\n        if (_marketCalldata.oracle == address(0)) revert AddressZero();\n        if (_marketCalldata.underlyingAsset == address(0)) revert AddressZero();\n\n        if (tokenToOracle[_marketCalldata.token] == address(0)) {\n            tokenToOracle[_marketCalldata.token] = _marketCalldata.oracle;\n        }\n\n        marketId = getMarketId(_marketCalldata.token, _marketCalldata.strike);\n        if (marketIdToVaults[marketId][0] != address(0))\n            revert MarketAlreadyExists();\n\n        //y2kUSDC_99*PREMIUM\n        premium = VaultV2Creator.createVaultV2(\n            VaultV2Creator.MarketConfiguration(\n                _marketCalldata.underlyingAsset == WETH,\n                _marketCalldata.underlyingAsset,\n                string(abi.encodePacked(_marketCalldata.name, PREMIUM)),\n                string(PSYMBOL),\n                _marketCalldata.tokenURI,\n                _marketCalldata.token,\n                _marketCalldata.strike,\n                _marketCalldata.controller,\n                treasury\n            )\n        );\n\n        // y2kUSDC_99*COLLATERAL\n        collateral = VaultV2Creator.createVaultV2(\n            VaultV2Creator.MarketConfiguration(\n                _marketCalldata.underlyingAsset == WETH,\n                _marketCalldata.underlyingAsset,\n                string(abi.encodePacked(_marketCalldata.name, COLLAT)),\n                string(CSYMBOL),\n                _marketCalldata.tokenURI,\n                _marketCalldata.token,\n                _marketCalldata.strike,\n                _marketCalldata.controller,\n                treasury\n            )\n        );\n\n        //set counterparty vault\n        IVaultV2(premium).setCounterPartyVault(collateral);\n        IVaultV2(collateral).setCounterPartyVault(premium);\n\n        marketIdToVaults[marketId] = [premium, collateral];\n\n        emit MarketCreated(\n            marketId,\n            premium,\n            collateral,\n            _marketCalldata.underlyingAsset,\n            _marketCalldata.token,\n            _marketCalldata.name,\n            _marketCalldata.strike,\n            _marketCalldata.controller\n        );\n\n        return (premium, collateral, marketId);\n    }\n\n    /**    \n    @notice Function set epoch for market,\n    @param  _marketId uint256 of the market index to create more assets in\n    @param  _epochBegin uint40 in UNIX timestamp, representing the begin date of the epoch. Example: Epoch begins in 31/May/2022 at 00h 00min 00sec: 1654038000\n    @param  _epochEnd uint40 in UNIX timestamp, representing the end date of the epoch and also the ID for the minting functions. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1656630000\n    @param _withdrawalFee uint16 of the fee value, multiply your % value by 10, Example: if you want fee of 0.5% , insert 5\n     */\n    function createEpoch(\n        uint256 _marketId,\n        uint40 _epochBegin,\n        uint40 _epochEnd,\n        uint16 _withdrawalFee\n    ) public onlyOwner returns (uint256 epochId, address[2] memory vaults) {\n        vaults = marketIdToVaults[_marketId];\n\n        if (vaults[0] == address(0) || vaults[1] == address(0)) {\n            revert MarketDoesNotExist(_marketId);\n        }\n\n        if (_withdrawalFee == 0) revert FeeCannotBe0();\n\n        if (!controllers[IVaultV2(vaults[0]).controller()])\n            revert ControllerNotSet();\n        if (!controllers[IVaultV2(vaults[1]).controller()])\n            revert ControllerNotSet();\n\n        epochId = getEpochId(_marketId, _epochBegin, _epochEnd);\n\n        _setEpoch(\n            EpochConfiguration(\n                _epochBegin,\n                _epochEnd,\n                _withdrawalFee,\n                _marketId,\n                epochId,\n                IVaultV2(vaults[0]),\n                IVaultV2(vaults[1])\n            )\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function _setEpoch(EpochConfiguration memory _epochConfig) internal {\n        _epochConfig.premium.setEpoch(\n            _epochConfig.epochBegin,\n            _epochConfig.epochEnd,\n            _epochConfig.epochId\n        );\n        _epochConfig.collateral.setEpoch(\n            _epochConfig.epochBegin,\n            _epochConfig.epochEnd,\n            _epochConfig.epochId\n        );\n\n        epochFee[_epochConfig.epochId] = _epochConfig.withdrawalFee;\n        marketIdToEpochs[_epochConfig.marketId].push(_epochConfig.epochId);\n\n        emit EpochCreated(\n            _epochConfig.epochId,\n            _epochConfig.marketId,\n            _epochConfig.epochBegin,\n            _epochConfig.epochEnd,\n            address(_epochConfig.premium),\n            address(_epochConfig.collateral),\n            _epochConfig.premium.token(),\n            _epochConfig.premium.strike(),\n            _epochConfig.withdrawalFee\n        );\n    }\n\n    /**\n    @notice Function to whitelist controller smart contract, only owner or timelocker can add more controllers. \n    owner can set controller once, all future controllers must be set by timelocker.\n    @param  _controller Address of the controller smart contract\n     */\n    function whitelistController(address _controller) public {\n        if (_controller == address(0)) revert AddressZero();\n        if (msg.sender == owner() && !adminSetController) {\n            controllers[_controller] = true;\n            adminSetController = true;\n            emit ControllerWhitelisted(_controller);\n        } else if (msg.sender == timelocker) {\n            controllers[_controller] = !controllers[_controller];\n            if (!adminSetController) adminSetController = true;\n            emit ControllerWhitelisted(_controller);\n        } else {\n            revert NotAuthorized();\n        }\n    }\n\n    /**\n    @notice Admin function, whitelists an address on vault for sendTokens function\n    @param _treasury Treasury address\n    @param  _marketId Target market index\n     */\n    function changeTreasury(uint256 _marketId, address _treasury)\n        public\n        onlyTimeLocker\n    {\n        if (_treasury == address(0)) revert AddressZero();\n\n        address[2] memory vaults = marketIdToVaults[_marketId];\n\n        if (vaults[0] == address(0) || vaults[1] == address(0)) {\n            revert MarketDoesNotExist(_marketId);\n        }\n\n        IVaultV2(vaults[0]).whiteListAddress(_treasury);\n        IVaultV2(vaults[1]).whiteListAddress(_treasury);\n        IVaultV2(vaults[0]).setTreasury(treasury);\n        IVaultV2(vaults[1]).setTreasury(treasury);\n\n        emit AddressWhitelisted(_treasury, _marketId);\n    }\n\n    /**\n    @notice Admin function, whitelists an address on vault for sendTokens function\n    @param  _marketId Target market index\n    @param _wAddress Treasury address\n     */\n    function whitelistAddressOnMarket(uint256 _marketId, address _wAddress)\n        public\n        onlyTimeLocker\n    {\n        if (_wAddress == address(0)) revert AddressZero();\n\n        address[2] memory vaults = marketIdToVaults[_marketId];\n\n        if (vaults[0] == address(0) || vaults[1] == address(0)) {\n            revert MarketDoesNotExist(_marketId);\n        }\n\n        IVaultV2(vaults[0]).whiteListAddress(_wAddress);\n        IVaultV2(vaults[1]).whiteListAddress(_wAddress);\n\n        emit AddressWhitelisted(_wAddress, _marketId);\n    }\n\n    /**\n    @notice Admin function, sets treasury address\n    @param _treasury Treasury address\n     */\n    function setTreasury(address _treasury) public onlyTimeLocker {\n        if (_treasury == address(0)) revert AddressZero();\n        treasury = _treasury;\n        emit TreasurySet(_treasury);\n    }\n\n    /**\n    @notice Timelocker function, changes controller address on vaults\n    @param _marketId Target marketId\n    @param  _controller Address of the controller smart contract\n     */\n    function changeController(uint256 _marketId, address _controller)\n        public\n        onlyTimeLocker\n        controllerIsWhitelisted(_controller)\n    {\n        if (_controller == address(0)) revert AddressZero();\n\n        address[2] memory vaults = marketIdToVaults[_marketId];\n\n        if (vaults[0] == address(0) || vaults[1] == address(0)) {\n            revert MarketDoesNotExist(_marketId);\n        }\n\n        IVaultV2(vaults[0]).changeController(_controller);\n        IVaultV2(vaults[1]).changeController(_controller);\n\n        emit ControllerChanged(_marketId, _controller, vaults[0], vaults[1]);\n    }\n\n    /**\n    @notice Timelocker function, changes oracle address for a given token\n    @param _token Target token address\n    @param  _oracle Oracle address\n     */\n    function changeOracle(address _token, address _oracle)\n        public\n        onlyTimeLocker\n    {\n        if (_oracle == address(0)) revert AddressZero();\n        if (_token == address(0)) revert AddressZero();\n\n        tokenToOracle[_token] = _oracle;\n        emit OracleChanged(_token, _oracle);\n    }\n\n    /**\n    @notice Timelocker function, changes owner address\n    @param _owner Address of the new _owner\n     */\n    function changeOwner(address _owner) public onlyTimeLocker {\n        if (_owner == address(0)) revert AddressZero();\n        _transferOwnership(_owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                GETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n    @notice Function the retrieve the addresses of the premium and collateral vaults, in an array, in the respective order\n    @param index uint256 of the market index which to the vaults are associated to\n    @return vaults Address array of two vaults addresses, [0] being the premium vault, [1] being the collateral vault\n     */\n    function getVaults(uint256 index)\n        public\n        view\n        returns (address[2] memory vaults)\n    {\n        return marketIdToVaults[index];\n    }\n\n    /**\n    @notice Function to retrieve the epochId for a given marketId\n    @param marketId marketId\n    @return epochIds uint256 array of epochIds\n     */\n    function getEpochsByMarketId(uint256 marketId)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        return marketIdToEpochs[marketId];\n    }\n\n    /**\n    @notice Function to retrieve the fee for a given epoch\n    @param epochId uint256 of the epoch\n    @return fee uint16 of the fee\n     */\n    function getEpochFee(uint256 epochId) public view returns (uint16 fee) {\n        return epochFee[epochId];\n    }\n\n    /**\n    @notice Function to compute the marketId from a token and a strike price\n    @param token Address of the token\n    @param strikePrice uint256 of the strike price\n    @return marketId uint256 of the marketId\n     */\n    function getMarketId(address token, uint256 strikePrice)\n        public\n        pure\n        returns (uint256 marketId)\n    {\n        return uint256(keccak256(abi.encodePacked(token, strikePrice)));\n    }\n\n    /**\n    @notice Function to compute the epochId from a marketId, epochBegin and epochEnd\n    @param marketId uint256 of the marketId\n    @param epochBegin uint40 of the epoch begin\n    @param epochEnd uint40 of the epoch end\n    @return epochId uint256 of the epochId\n     */\n    function getEpochId(\n        uint256 marketId,\n        uint40 epochBegin,\n        uint40 epochEnd\n    ) public pure returns (uint256 epochId) {\n        return\n            uint256(\n                keccak256(abi.encodePacked(marketId, epochBegin, epochEnd))\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                STRUCTS\n    //////////////////////////////////////////////////////////////*/\n    struct MarketConfigurationCalldata {\n        address token;\n        uint256 strike;\n        address oracle;\n        address underlyingAsset;\n        string name;\n        string tokenURI;\n        address controller;\n    }\n\n    struct EpochConfiguration {\n        uint40 epochBegin;\n        uint40 epochEnd;\n        uint16 withdrawalFee;\n        uint256 marketId;\n        uint256 epochId;\n        IVaultV2 premium;\n        IVaultV2 collateral;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Modifier to check if the caller is the timelocker\n     */\n    modifier onlyTimeLocker() {\n        if (msg.sender != timelocker) revert NotTimeLocker();\n        _;\n    }\n\n    /** @notice Modifier to check if the controller is whitelisted on the factory\n     */\n    modifier controllerIsWhitelisted(address _controller) {\n        if (!controllers[_controller]) revert ControllerNotSet();\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error MarketDoesNotExist(uint256 marketId);\n    error MarketAlreadyExists();\n    error AddressZero();\n    error ControllerNotSet();\n    error NotTimeLocker();\n    error NotAuthorized();\n    error FeeCannotBe0();\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Market is created when event is emitted\n     * @param marketId market id\n     * @param premium premium vault address\n     * @param collateral collateral vault address\n     * @param underlyingAsset underlying asset address\n     * @param token Token address to monitor strike price\n     * @param name Market name\n     * @param strike Strike price\n     * @param controller Controller address\n     */\n    event MarketCreated(\n        uint256 indexed marketId,\n        address premium,\n        address collateral,\n        address underlyingAsset,\n        address token,\n        string name,\n        uint256 strike,\n        address controller\n    );\n\n    /** @notice event is emitted when epoch is created\n     * @param epochId epoch id derrived out of market id, start and end epoch\n     * @param marketId Current market index\n     * @param startEpoch Epoch start time\n     * @param endEpoch Epoch end time\n     * @param premium premium vault address\n     * @param collateral collateral vault address\n     * @param token Token address\n     * @param strike Strike price\n     * @param withdrawalFee Withdrawal fee\n     */\n    event EpochCreated(\n        uint256 indexed epochId,\n        uint256 indexed marketId,\n        uint40 startEpoch,\n        uint40 endEpoch,\n        address premium,\n        address collateral,\n        address token,\n        uint256 strike,\n        uint16 withdrawalFee\n    );\n\n    /** @notice Controller is changed when event is emitted\n     * @param marketId Target market index\n     * @param controller Target controller address\n     * @param premium Target premium vault address\n     * @param collateral Target collateral vault address\n     */\n    event ControllerChanged(\n        uint256 indexed marketId,\n        address indexed controller,\n        address premium,\n        address collateral\n    );\n\n    /** @notice Oracle is changed when event is emitted\n     * @param _token Target token address\n     * @param _oracle Target oracle address\n     */\n    event OracleChanged(address indexed _token, address _oracle);\n\n    /** @notice Address whitelisted is changed when event is emitted\n     * @param _wAddress whitelisted address\n     * @param _marketId Target market index\n     */\n    event AddressWhitelisted(address _wAddress, uint256 indexed _marketId);\n\n    /** @notice Treasury is changed when event is emitted\n     * @param _treasury Treasury address\n     */\n    event TreasurySet(address _treasury);\n\n    /** @notice New Controller is whitelisted when event is emitted\n     * @param _controller Controller address\n     */\n    event ControllerWhitelisted(address _controller);\n}"
    }
  ]
}