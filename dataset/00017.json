{
  "Title": "The overflow in the `_calculateStreamedAmount` function can lead to unexpected results.",
  "Content": "# The overflow in the `_calculateStreamedAmount` function can lead to unexpected results.\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-05-Sablier/blob/43d7e752a68bba2a1d73d3d6466c3059079ed0c6/v2-core/src/SablierV2LockupLinear.sol#L163-L171\">https://github.com/Cyfrin/2024-05-Sablier/blob/43d7e752a68bba2a1d73d3d6466c3059079ed0c6/v2-core/src/SablierV2LockupLinear.sol#L163-L171</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-05-Sablier/blob/43d7e752a68bba2a1d73d3d6466c3059079ed0c6/v2-core/src/abstracts/SablierV2Lockup.sol#L553\">https://github.com/Cyfrin/2024-05-Sablier/blob/43d7e752a68bba2a1d73d3d6466c3059079ed0c6/v2-core/src/abstracts/SablierV2Lockup.sol#L553</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-05-Sablier/blob/43d7e752a68bba2a1d73d3d6466c3059079ed0c6/v2-core/src/SablierV2LockupLinear.sol#L207-L212\">https://github.com/Cyfrin/2024-05-Sablier/blob/43d7e752a68bba2a1d73d3d6466c3059079ed0c6/v2-core/src/SablierV2LockupLinear.sol#L207-L212</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/PaulRBerg/prb-math/blob/cceb7f618c4d0c17cc834622ba8bd708a38951ad/src/ud60x18/Math.sol#L99-L101\">https://github.com/PaulRBerg/prb-math/blob/cceb7f618c4d0c17cc834622ba8bd708a38951ad/src/ud60x18/Math.sol#L99-L101</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/PaulRBerg/prb-math/blob/cceb7f618c4d0c17cc834622ba8bd708a38951ad/src/Common.sol#L407-L409\">https://github.com/PaulRBerg/prb-math/blob/cceb7f618c4d0c17cc834622ba8bd708a38951ad/src/Common.sol#L407-L409</a>\n\n\n## Summary\nIn the `_calculateStreamedAmount` function, the calculation is within an `unchecked` block. \nWhen the `start time` is later than the `current block's timestamp`, an `overflow` occurs during the calculation. \nThis can lead to several vulnerabilities:\n- The `sender` cannot `cancel` the `stream` before the `start time` because the `PRB math library` reverts due to the `overflowed`, extremely large values.\nThe `sender` should be able to `cancel` the `stream` anytime if it has not been `depleted` yet.\n- For specific values, the `overflow` can result in incorrect calculations (without triggering a `revert`), allowing some tokens to be `withdrawn` before the `start time`.\n## Vulnerability Details\nWe can create a `linear lockup` using the `createWithTimestamps` function in `SablierV2LockupLinear`.\n```\nfunction createWithTimestamps(LockupLinear.CreateWithTimestamps calldata params)\n    external\n    override\n    noDelegateCall\n    returns (uint256 streamId)\n{\n    // Checks, Effects and Interactions: create the stream.\n    streamId = _create(params);\n}\n```\nObviously, the `start time` can be later than the current `block.timestamp` because some `senders` may want to start `streaming` in the future.\n\nAfter some time, the `sender` wants to `cancel` their `stream` before the `start time` because they found issues with their plan. \nHowever, this `cancellation` will be reverted due to an `overflow`.\n\nLet's explain this step by step with a specific example.\nThe test for this example will be provided at the end.\n\nThe `current time` is `1714518000`, and the `start time` is `1714690800`, which is slightly later. \nThe `cliff time` is `0`, and the `duration` is `10,000`.\nThe `sender` wants to `cancel` this `stream`, so they call the `cancel` function.\nHere, we calculate the `streamed amount` so far by calling the `_calculateStreamedAmount` function\n```\nfunction _cancel(uint256 streamId) internal {\n    // Calculate the streamed amount.\n    uint128 streamedAmount = _calculateStreamedAmount(streamId);\n}\n```\nIn the `_calculateStreamedAmount` function, we don't check whether the `start time` is later than the `current time`. \nTherefore, in the `unchecked` block, an `overflow` occur. \nIn our case, the `elapsed time` becomes a large value due to `overflow` (almost `type(256).max`), and the `total duration` is `10,000`. \nWe call the `div` function in the `PRB math library`.\n```\nfunction _calculateStreamedAmount(uint256 streamId) internal view override returns (uint128) {\n    unchecked {\n            // Calculate how much time has passed since the stream started, and the stream's total duration.\n            uint256 startTime = uint256(_streams[streamId].startTime);\n            UD60x18 elapsedTime = ud(blockTimestamp - startTime);\n            UD60x18 totalDuration = ud(endTime - startTime);\n\n            // Divide the elapsed time by the stream's total duration.\n            UD60x18 elapsedTimePercentage = elapsedTime.div(totalDuration);\n    }\n}\n```\nIn the div function, we multiply by 1e18, and the revert occurs in the mulDiv function\n```\nfunction div(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    result = wrap(Common.mulDiv(x.unwrap(), uUNIT, y.unwrap()));\n}\n```\n```\nfunction mulDiv(uint256 x, uint256 y, uint256 denominator) pure returns (uint256 result) {\n    assembly (\"memory-safe\") {\n        let mm := mulmod(x, y, not(0))\n        prod0 := mul(x, y)\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n    if (prod1 >= denominator) {\n        revert PRBMath_MulDiv_Overflow(x, y, denominator);  // @audit, here\n    }\n}\n```\nIn our test, the revert message is as follows:\n```\n[FAIL. Reason: PRBMath_MulDiv_Overflow(115792089237316195423570985008687907853269984665640564039457584007913129467136 [1.157e77], 1000000000000000000 [1e18], 10000 [1e4])]\n```\nPlease add below test to the `test/integration/concrete/lockup-linear/create-with-timestamps/createWithTimestamps.t.sol`\n```\nfunction test_Cancel_Linear_Before_Start() external {\n        LockupLinear.CreateWithTimestamps memory params = defaults.createWithTimestampsLL();\n        \n        params.timestamps.cliff = 0;\n        uint256 streamId = lockupLinear.createWithTimestamps(params);\n        \n        assertGt(params.timestamps.start, block.timestamp); // params.timestamps.start = 1714690800, block.timestamp = 1714518000\n\n        uint256 duration = params.timestamps.end - params.timestamps.start;\n        assertEq(duration, 10000);\n\n        resetPrank({ msgSender: params.sender });\n        lockupLinear.cancel(streamId);\n}\n```\n## Impact\nThe `impact` is described in the `Summary` section.\n## Tools Used\nManual review\n## Recommendations\n```\nfunction _calculateStreamedAmount(uint256 streamId) internal view override returns (uint128) {\n    uint256 cliffTime = uint256(_cliffs[streamId]);\n    uint256 blockTimestamp = block.timestamp;\n    if (cliffTime > blockTimestamp) {\n        return 0;\n    }\n\n+    uint256 startTime = uint256(_streams[streamId].startTime);\n+    if (startTime > blockTimestamp) {\n+        return 0;\n+    }\n}\n```",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clvb9njmy00012dqjyaavpl44",
  "Code": [
    {
      "filename": "v2-core/src/SablierV2LockupLinear.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.22;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { UD60x18, ud } from \"@prb/math/src/UD60x18.sol\";\n\nimport { SablierV2Lockup } from \"./abstracts/SablierV2Lockup.sol\";\nimport { SablierV2Lockup } from \"./abstracts/SablierV2Lockup.sol\";\nimport { ISablierV2LockupLinear } from \"./interfaces/ISablierV2LockupLinear.sol\";\nimport { ISablierV2NFTDescriptor } from \"./interfaces/ISablierV2NFTDescriptor.sol\";\nimport { Helpers } from \"./libraries/Helpers.sol\";\nimport { Lockup, LockupLinear } from \"./types/DataTypes.sol\";\n\n/*\n\n███████╗ █████╗ ██████╗ ██╗     ██╗███████╗██████╗     ██╗   ██╗██████╗\n██╔════╝██╔══██╗██╔══██╗██║     ██║██╔════╝██╔══██╗    ██║   ██║╚════██╗\n███████╗███████║██████╔╝██║     ██║█████╗  ██████╔╝    ██║   ██║ █████╔╝\n╚════██║██╔══██║██╔══██╗██║     ██║██╔══╝  ██╔══██╗    ╚██╗ ██╔╝██╔═══╝\n███████║██║  ██║██████╔╝███████╗██║███████╗██║  ██║     ╚████╔╝ ███████╗\n╚══════╝╚═╝  ╚═╝╚═════╝ ╚══════╝╚═╝╚══════╝╚═╝  ╚═╝      ╚═══╝  ╚══════╝\n\n██╗      ██████╗  ██████╗██╗  ██╗██╗   ██╗██████╗     ██╗     ██╗███╗   ██╗███████╗ █████╗ ██████╗\n██║     ██╔═══██╗██╔════╝██║ ██╔╝██║   ██║██╔══██╗    ██║     ██║████╗  ██║██╔════╝██╔══██╗██╔══██╗\n██║     ██║   ██║██║     █████╔╝ ██║   ██║██████╔╝    ██║     ██║██╔██╗ ██║█████╗  ███████║██████╔╝\n██║     ██║   ██║██║     ██╔═██╗ ██║   ██║██╔═══╝     ██║     ██║██║╚██╗██║██╔══╝  ██╔══██║██╔══██╗\n███████╗╚██████╔╝╚██████╗██║  ██╗╚██████╔╝██║         ███████╗██║██║ ╚████║███████╗██║  ██║██║  ██║\n╚══════╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝ ╚═════╝ ╚═╝         ╚══════╝╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝\n\n*/\n\n/// @title SablierV2LockupLinear\n/// @notice See the documentation in {ISablierV2LockupLinear}.\ncontract SablierV2LockupLinear is\n    ISablierV2LockupLinear, // 5 inherited components\n    SablierV2Lockup // 14 inherited components\n{\n    using SafeERC20 for IERC20;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                  STATE VARIABLES\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Cliff times mapped by stream IDs. This complements the `_streams` mapping in {SablierV2Lockup}.\n    mapping(uint256 id => uint40 cliff) internal _cliffs;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Emits a {TransferAdmin} event.\n    /// @param initialAdmin The address of the initial contract admin.\n    /// @param initialNFTDescriptor The address of the initial NFT descriptor.\n    constructor(\n        address initialAdmin,\n        ISablierV2NFTDescriptor initialNFTDescriptor\n    )\n        ERC721(\"Sablier V2 Lockup Linear NFT\", \"SAB-V2-LOCKUP-LIN\")\n        SablierV2Lockup(initialAdmin, initialNFTDescriptor)\n    {\n        nextStreamId = 1;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                           USER-FACING CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ISablierV2LockupLinear\n    function getCliffTime(uint256 streamId) external view override notNull(streamId) returns (uint40 cliffTime) {\n        cliffTime = _cliffs[streamId];\n    }\n\n    /// @inheritdoc ISablierV2LockupLinear\n    function getStream(uint256 streamId)\n        external\n        view\n        override\n        notNull(streamId)\n        returns (LockupLinear.StreamLL memory stream)\n    {\n        // Retrieve the Lockup stream from storage.\n        Lockup.Stream memory lockupStream = _streams[streamId];\n\n        // Settled streams cannot be canceled.\n        if (_statusOf(streamId) == Lockup.Status.SETTLED) {\n            lockupStream.isCancelable = false;\n        }\n\n        stream = LockupLinear.StreamLL({\n            amounts: lockupStream.amounts,\n            asset: lockupStream.asset,\n            cliffTime: _cliffs[streamId],\n            endTime: lockupStream.endTime,\n            isCancelable: lockupStream.isCancelable,\n            isTransferable: lockupStream.isTransferable,\n            isDepleted: lockupStream.isDepleted,\n            isStream: lockupStream.isStream,\n            recipient: _ownerOf(streamId),\n            sender: lockupStream.sender,\n            startTime: lockupStream.startTime,\n            wasCanceled: lockupStream.wasCanceled\n        });\n    }\n\n    /// @inheritdoc ISablierV2LockupLinear\n    function getTimestamps(uint256 streamId)\n        external\n        view\n        override\n        notNull(streamId)\n        returns (LockupLinear.Timestamps memory timestamps)\n    {\n        timestamps = LockupLinear.Timestamps({\n            start: _streams[streamId].startTime,\n            cliff: _cliffs[streamId],\n            end: _streams[streamId].endTime\n        });\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                         USER-FACING NON-CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ISablierV2LockupLinear\n    function createWithDurations(LockupLinear.CreateWithDurations calldata params)\n        external\n        override\n        noDelegateCall\n        returns (uint256 streamId)\n    {\n        // Set the current block timestamp as the stream's start time.\n        LockupLinear.Timestamps memory timestamps;\n        timestamps.start = uint40(block.timestamp);\n\n        // Calculate the cliff time and the end time. It is safe to use unchecked arithmetic because {_create} will\n        // nonetheless check that the end time is greater than the cliff time, and also that the cliff time, if set,\n        // is greater than or equal to the start time.\n        unchecked {\n            if (params.durations.cliff > 0) {\n                timestamps.cliff = timestamps.start + params.durations.cliff;\n            }\n            timestamps.end = timestamps.start + params.durations.total;\n        }\n\n        // Checks, Effects and Interactions: create the stream.\n        streamId = _create(\n            LockupLinear.CreateWithTimestamps({\n                sender: params.sender,\n                recipient: params.recipient,\n                totalAmount: params.totalAmount,\n                asset: params.asset,\n                cancelable: params.cancelable,\n                transferable: params.transferable,\n                timestamps: timestamps,\n                broker: params.broker\n            })\n        );\n    }\n\n    /// @inheritdoc ISablierV2LockupLinear\n    function createWithTimestamps(LockupLinear.CreateWithTimestamps calldata params)\n        external\n        override\n        noDelegateCall\n        returns (uint256 streamId)\n    {\n        // Checks, Effects and Interactions: create the stream.\n        streamId = _create(params);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                           INTERNAL CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc SablierV2Lockup\n    /// @dev The distribution function is:\n    ///\n    /// $$\n    /// f(x) = x * d + c\n    /// $$\n    ///\n    /// Where:\n    ///\n    /// - $x$ is the elapsed time divided by the stream's total duration.\n    /// - $d$ is the deposited amount.\n    /// - $c$ is the cliff amount.\n    function _calculateStreamedAmount(uint256 streamId) internal view override returns (uint128) {\n        // If the cliff time is in the future, return zero.\n        uint256 cliffTime = uint256(_cliffs[streamId]);\n        uint256 blockTimestamp = block.timestamp;\n        if (cliffTime > blockTimestamp) {\n            return 0;\n        }\n\n        // If the end time is not in the future, return the deposited amount.\n        uint256 endTime = uint256(_streams[streamId].endTime);\n        if (blockTimestamp >= endTime) {\n            return _streams[streamId].amounts.deposited;\n        }\n\n        // In all other cases, calculate the amount streamed so far. Normalization to 18 decimals is not needed\n        // because there is no mix of amounts with different decimals.\n        unchecked {\n            // Calculate how much time has passed since the stream started, and the stream's total duration.\n            uint256 startTime = uint256(_streams[streamId].startTime);\n            UD60x18 elapsedTime = ud(blockTimestamp - startTime);\n            UD60x18 totalDuration = ud(endTime - startTime);\n\n            // Divide the elapsed time by the stream's total duration.\n            UD60x18 elapsedTimePercentage = elapsedTime.div(totalDuration);\n\n            // Cast the deposited amount to UD60x18.\n            UD60x18 depositedAmount = ud(_streams[streamId].amounts.deposited);\n\n            // Calculate the streamed amount by multiplying the elapsed time percentage by the deposited amount.\n            UD60x18 streamedAmount = elapsedTimePercentage.mul(depositedAmount);\n\n            // Although the streamed amount should never exceed the deposited amount, this condition is checked\n            // without asserting to avoid locking funds in case of a bug. If this situation occurs, the withdrawn\n            // amount is considered to be the streamed amount, and the stream is effectively frozen.\n            if (streamedAmount.gt(depositedAmount)) {\n                return _streams[streamId].amounts.withdrawn;\n            }\n\n            // Cast the streamed amount to uint128. This is safe due to the check above.\n            return uint128(streamedAmount.intoUint256());\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                           INTERNAL NON-CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev See the documentation for the user-facing functions that call this internal function.\n    function _create(LockupLinear.CreateWithTimestamps memory params) internal returns (uint256 streamId) {\n        // Check: verify the broker fee and calculate the amounts.\n        Lockup.CreateAmounts memory createAmounts =\n            Helpers.checkAndCalculateBrokerFee(params.totalAmount, params.broker.fee, MAX_BROKER_FEE);\n\n        // Check: validate the user-provided parameters.\n        Helpers.checkCreateLockupLinear(createAmounts.deposit, params.timestamps);\n\n        // Load the stream ID.\n        streamId = nextStreamId;\n\n        // Effect: create the stream.\n        _streams[streamId] = Lockup.Stream({\n            amounts: Lockup.Amounts({ deposited: createAmounts.deposit, refunded: 0, withdrawn: 0 }),\n            asset: params.asset,\n            endTime: params.timestamps.end,\n            isCancelable: params.cancelable,\n            isDepleted: false,\n            isStream: true,\n            isTransferable: params.transferable,\n            sender: params.sender,\n            startTime: params.timestamps.start,\n            wasCanceled: false\n        });\n\n        // Effect: set the cliff time if it is greater than zero.\n        if (params.timestamps.cliff > 0) {\n            _cliffs[streamId] = params.timestamps.cliff;\n        }\n\n        // Effect: bump the next stream ID.\n        // Using unchecked arithmetic because these calculations cannot realistically overflow, ever.\n        unchecked {\n            nextStreamId = streamId + 1;\n        }\n\n        // Effect: mint the NFT to the recipient.\n        _mint({ to: params.recipient, tokenId: streamId });\n\n        // Interaction: transfer the deposit amount.\n        params.asset.safeTransferFrom({ from: msg.sender, to: address(this), value: createAmounts.deposit });\n\n        // Interaction: pay the broker fee, if not zero.\n        if (createAmounts.brokerFee > 0) {\n            params.asset.safeTransferFrom({ from: msg.sender, to: params.broker.account, value: createAmounts.brokerFee });\n        }\n\n        // Log the newly created stream.\n        emit ISablierV2LockupLinear.CreateLockupLinearStream({\n            streamId: streamId,\n            funder: msg.sender,\n            sender: params.sender,\n            recipient: params.recipient,\n            amounts: createAmounts,\n            asset: params.asset,\n            cancelable: params.cancelable,\n            transferable: params.transferable,\n            timestamps: params.timestamps,\n            broker: params.broker.account\n        });\n    }\n}"
    },
    {
      "filename": "v2-core/src/abstracts/SablierV2Lockup.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.22;\n\nimport { IERC4906 } from \"@openzeppelin/contracts/interfaces/IERC4906.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { IERC721Metadata } from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport { UD60x18 } from \"@prb/math/src/UD60x18.sol\";\n\nimport { ISablierV2Recipient } from \"../interfaces/hooks/ISablierV2Recipient.sol\";\nimport { ISablierV2Sender } from \"../interfaces/hooks/ISablierV2Sender.sol\";\nimport { ISablierV2Lockup } from \"../interfaces/ISablierV2Lockup.sol\";\nimport { ISablierV2NFTDescriptor } from \"../interfaces/ISablierV2NFTDescriptor.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\nimport { Lockup } from \"../types/DataTypes.sol\";\nimport { Adminable } from \"./Adminable.sol\";\nimport { NoDelegateCall } from \"./NoDelegateCall.sol\";\n\n/// @title SablierV2Lockup\n/// @notice See the documentation in {ISablierV2Lockup}.\nabstract contract SablierV2Lockup is\n    NoDelegateCall, // 0 inherited components\n    Adminable, // 1 inherited components\n    IERC4906, // 2 inherited components\n    ISablierV2Lockup, // 4 inherited components\n    ERC721 // 6 inherited components\n{\n    using SafeERC20 for IERC20;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                  STATE VARIABLES\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ISablierV2Lockup\n    UD60x18 public constant override MAX_BROKER_FEE = UD60x18.wrap(0.1e18);\n\n    /// @inheritdoc ISablierV2Lockup\n    uint256 public override nextStreamId;\n\n    /// @inheritdoc ISablierV2Lockup\n    ISablierV2NFTDescriptor public override nftDescriptor;\n\n    /// @dev Sablier V2 Lockup streams mapped by unsigned integers.\n    mapping(uint256 id => Lockup.Stream stream) internal _streams;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Emits a {TransferAdmin} event.\n    /// @param initialAdmin The address of the initial contract admin.\n    /// @param initialNFTDescriptor The address of the initial NFT descriptor.\n    constructor(address initialAdmin, ISablierV2NFTDescriptor initialNFTDescriptor) {\n        admin = initialAdmin;\n        nftDescriptor = initialNFTDescriptor;\n        emit TransferAdmin({ oldAdmin: address(0), newAdmin: initialAdmin });\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      MODIFIERS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Checks that `streamId` does not reference a null stream.\n    modifier notNull(uint256 streamId) {\n        if (!_streams[streamId].isStream) {\n            revert Errors.SablierV2Lockup_Null(streamId);\n        }\n        _;\n    }\n\n    /// @dev Emits an ERC-4906 event to trigger an update of the NFT metadata.\n    modifier updateMetadata(uint256 streamId) {\n        _;\n        emit MetadataUpdate({ _tokenId: streamId });\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                           USER-FACING CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ISablierV2Lockup\n    function getAsset(uint256 streamId) external view override notNull(streamId) returns (IERC20 asset) {\n        asset = _streams[streamId].asset;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function getDepositedAmount(uint256 streamId)\n        external\n        view\n        override\n        notNull(streamId)\n        returns (uint128 depositedAmount)\n    {\n        depositedAmount = _streams[streamId].amounts.deposited;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function getEndTime(uint256 streamId) external view override notNull(streamId) returns (uint40 endTime) {\n        endTime = _streams[streamId].endTime;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function getRecipient(uint256 streamId) external view override returns (address recipient) {\n        // Check the stream NFT exists and return the owner, which is the stream's recipient.\n        recipient = _requireOwned({ tokenId: streamId });\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function getRefundedAmount(uint256 streamId)\n        external\n        view\n        override\n        notNull(streamId)\n        returns (uint128 refundedAmount)\n    {\n        refundedAmount = _streams[streamId].amounts.refunded;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function getSender(uint256 streamId) external view override notNull(streamId) returns (address sender) {\n        sender = _streams[streamId].sender;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function getStartTime(uint256 streamId) external view override notNull(streamId) returns (uint40 startTime) {\n        startTime = _streams[streamId].startTime;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function getWithdrawnAmount(uint256 streamId)\n        external\n        view\n        override\n        notNull(streamId)\n        returns (uint128 withdrawnAmount)\n    {\n        withdrawnAmount = _streams[streamId].amounts.withdrawn;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function isCancelable(uint256 streamId) external view override notNull(streamId) returns (bool result) {\n        if (_statusOf(streamId) != Lockup.Status.SETTLED) {\n            result = _streams[streamId].isCancelable;\n        }\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function isCold(uint256 streamId) external view override notNull(streamId) returns (bool result) {\n        Lockup.Status status = _statusOf(streamId);\n        result = status == Lockup.Status.SETTLED || status == Lockup.Status.CANCELED || status == Lockup.Status.DEPLETED;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function isDepleted(uint256 streamId) external view override notNull(streamId) returns (bool result) {\n        result = _streams[streamId].isDepleted;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function isStream(uint256 streamId) external view override returns (bool result) {\n        result = _streams[streamId].isStream;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function isTransferable(uint256 streamId) external view override notNull(streamId) returns (bool result) {\n        result = _streams[streamId].isTransferable;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function isWarm(uint256 streamId) external view override notNull(streamId) returns (bool result) {\n        Lockup.Status status = _statusOf(streamId);\n        result = status == Lockup.Status.PENDING || status == Lockup.Status.STREAMING;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function refundableAmountOf(uint256 streamId)\n        external\n        view\n        override\n        notNull(streamId)\n        returns (uint128 refundableAmount)\n    {\n        // These checks are needed because {_calculateStreamedAmount} does not look up the stream's status. Note that\n        // checking for `isCancelable` also checks if the stream `wasCanceled` thanks to the protocol invariant that\n        // canceled streams are not cancelable anymore.\n        if (_streams[streamId].isCancelable && !_streams[streamId].isDepleted) {\n            refundableAmount = _streams[streamId].amounts.deposited - _calculateStreamedAmount(streamId);\n        }\n        // Otherwise, the result is implicitly zero.\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function statusOf(uint256 streamId) external view override notNull(streamId) returns (Lockup.Status status) {\n        status = _statusOf(streamId);\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function streamedAmountOf(uint256 streamId)\n        public\n        view\n        override\n        notNull(streamId)\n        returns (uint128 streamedAmount)\n    {\n        streamedAmount = _streamedAmountOf(streamId);\n    }\n\n    /// @inheritdoc ERC721\n    function tokenURI(uint256 streamId) public view override(IERC721Metadata, ERC721) returns (string memory uri) {\n        // Check: the stream NFT exists.\n        _requireOwned({ tokenId: streamId });\n\n        // Generate the URI describing the stream NFT.\n        uri = nftDescriptor.tokenURI({ sablier: this, streamId: streamId });\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function wasCanceled(uint256 streamId) external view override notNull(streamId) returns (bool result) {\n        result = _streams[streamId].wasCanceled;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function withdrawableAmountOf(uint256 streamId)\n        external\n        view\n        override\n        notNull(streamId)\n        returns (uint128 withdrawableAmount)\n    {\n        withdrawableAmount = _withdrawableAmountOf(streamId);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                         USER-FACING NON-CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ISablierV2Lockup\n    function burn(uint256 streamId) external override noDelegateCall notNull(streamId) {\n        // Check: only depleted streams can be burned.\n        if (!_streams[streamId].isDepleted) {\n            revert Errors.SablierV2Lockup_StreamNotDepleted(streamId);\n        }\n\n        // Check:\n        // 1. NFT exists (see {IERC721.getApproved}).\n        // 2. `msg.sender` is either the owner of the NFT or an approved third party.\n        if (!_isCallerStreamRecipientOrApproved(streamId)) {\n            revert Errors.SablierV2Lockup_Unauthorized(streamId, msg.sender);\n        }\n\n        // Effect: burn the NFT.\n        _burn({ tokenId: streamId });\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function cancel(uint256 streamId) public override noDelegateCall notNull(streamId) {\n        // Check: the stream is neither depleted nor canceled.\n        if (_streams[streamId].isDepleted) {\n            revert Errors.SablierV2Lockup_StreamDepleted(streamId);\n        } else if (_streams[streamId].wasCanceled) {\n            revert Errors.SablierV2Lockup_StreamCanceled(streamId);\n        }\n\n        // Check: `msg.sender` is the stream's sender.\n        if (!_isCallerStreamSender(streamId)) {\n            revert Errors.SablierV2Lockup_Unauthorized(streamId, msg.sender);\n        }\n\n        // Checks, Effects and Interactions: cancel the stream.\n        _cancel(streamId);\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function cancelMultiple(uint256[] calldata streamIds) external override noDelegateCall {\n        // Iterate over the provided array of stream IDs and cancel each stream.\n        uint256 count = streamIds.length;\n        for (uint256 i = 0; i < count; ++i) {\n            // Effects and Interactions: cancel the stream.\n            cancel(streamIds[i]);\n        }\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function renounce(uint256 streamId) external override noDelegateCall notNull(streamId) updateMetadata(streamId) {\n        // Check: the stream is not cold.\n        Lockup.Status status = _statusOf(streamId);\n        if (status == Lockup.Status.DEPLETED) {\n            revert Errors.SablierV2Lockup_StreamDepleted(streamId);\n        } else if (status == Lockup.Status.CANCELED) {\n            revert Errors.SablierV2Lockup_StreamCanceled(streamId);\n        } else if (status == Lockup.Status.SETTLED) {\n            revert Errors.SablierV2Lockup_StreamSettled(streamId);\n        }\n\n        // Check: `msg.sender` is the stream's sender.\n        if (!_isCallerStreamSender(streamId)) {\n            revert Errors.SablierV2Lockup_Unauthorized(streamId, msg.sender);\n        }\n\n        // Checks and Effects: renounce the stream.\n        _renounce(streamId);\n\n        // Log the renouncement.\n        emit ISablierV2Lockup.RenounceLockupStream(streamId);\n\n        // Interaction: if the recipient is a contract, try to invoke the renounce hook on the recipient without\n        // reverting if the hook is not implemented, and also without bubbling up any potential revert.\n        address recipient = _ownerOf(streamId);\n        if (recipient.code.length > 0) {\n            try ISablierV2Recipient(recipient).onLockupStreamRenounced(streamId) { } catch { }\n        }\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function setNFTDescriptor(ISablierV2NFTDescriptor newNFTDescriptor) external override onlyAdmin {\n        // Effect: set the NFT descriptor.\n        ISablierV2NFTDescriptor oldNftDescriptor = nftDescriptor;\n        nftDescriptor = newNFTDescriptor;\n\n        // Log the change of the NFT descriptor.\n        emit ISablierV2Lockup.SetNFTDescriptor({\n            admin: msg.sender,\n            oldNFTDescriptor: oldNftDescriptor,\n            newNFTDescriptor: newNFTDescriptor\n        });\n\n        // Refresh the NFT metadata for all streams.\n        emit BatchMetadataUpdate({ _fromTokenId: 1, _toTokenId: nextStreamId - 1 });\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function withdraw(\n        uint256 streamId,\n        address to,\n        uint128 amount\n    )\n        public\n        override\n        noDelegateCall\n        notNull(streamId)\n        updateMetadata(streamId)\n    {\n        // Check: the stream is not depleted.\n        if (_streams[streamId].isDepleted) {\n            revert Errors.SablierV2Lockup_StreamDepleted(streamId);\n        }\n\n        // Check: the withdrawal address is not zero.\n        if (to == address(0)) {\n            revert Errors.SablierV2Lockup_WithdrawToZeroAddress(streamId);\n        }\n\n        // Check: the withdraw amount is not zero.\n        if (amount == 0) {\n            revert Errors.SablierV2Lockup_WithdrawAmountZero(streamId);\n        }\n\n        // Retrieve the recipient from storage.\n        address recipient = _ownerOf(streamId);\n\n        // Check: if `msg.sender` is neither the stream's recipient nor an approved third party, the withdrawal address\n        // must be the recipient.\n        if (to != recipient && !_isCallerStreamRecipientOrApproved(streamId)) {\n            revert Errors.SablierV2Lockup_WithdrawalAddressNotRecipient(streamId, msg.sender, to);\n        }\n\n        // Check: the withdraw amount is not greater than the withdrawable amount.\n        uint128 withdrawableAmount = _withdrawableAmountOf(streamId);\n        if (amount > withdrawableAmount) {\n            revert Errors.SablierV2Lockup_Overdraw(streamId, amount, withdrawableAmount);\n        }\n\n        // Retrieve the sender from storage.\n        address sender = _streams[streamId].sender;\n\n        // Effects and Interactions: make the withdrawal.\n        _withdraw(streamId, to, amount);\n\n        // Interaction: if `msg.sender` is not the recipient and the recipient is a contract, try to invoke the\n        // withdraw hook on it without reverting if the hook is not implemented, and also without bubbling up\n        // any potential revert.\n        if (msg.sender != recipient && recipient.code.length > 0) {\n            try ISablierV2Recipient(recipient).onLockupStreamWithdrawn({\n                streamId: streamId,\n                caller: msg.sender,\n                to: to,\n                amount: amount\n            }) { } catch { }\n        }\n\n        // Interaction: if `msg.sender` is not the sender, the sender is a contract and is different from the\n        // recipient, try to invoke the withdraw hook on it without reverting if the hook is not implemented, and also\n        // without bubbling up any potential revert.\n        if (msg.sender != sender && sender.code.length > 0 && sender != recipient) {\n            try ISablierV2Sender(sender).onLockupStreamWithdrawn({\n                streamId: streamId,\n                caller: msg.sender,\n                to: to,\n                amount: amount\n            }) { } catch { }\n        }\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function withdrawMax(uint256 streamId, address to) external override {\n        withdraw({ streamId: streamId, to: to, amount: _withdrawableAmountOf(streamId) });\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function withdrawMaxAndTransfer(\n        uint256 streamId,\n        address newRecipient\n    )\n        external\n        override\n        noDelegateCall\n        notNull(streamId)\n    {\n        // Check: the caller is the current recipient. This also checks that the NFT was not burned.\n        address currentRecipient = _ownerOf(streamId);\n        if (msg.sender != currentRecipient) {\n            revert Errors.SablierV2Lockup_Unauthorized(streamId, msg.sender);\n        }\n\n        // Skip the withdrawal if the withdrawable amount is zero.\n        uint128 withdrawableAmount = _withdrawableAmountOf(streamId);\n        if (withdrawableAmount > 0) {\n            withdraw({ streamId: streamId, to: currentRecipient, amount: withdrawableAmount });\n        }\n\n        // Checks and Effects: transfer the NFT.\n        _transfer({ from: currentRecipient, to: newRecipient, tokenId: streamId });\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function withdrawMultiple(\n        uint256[] calldata streamIds,\n        uint128[] calldata amounts\n    )\n        external\n        override\n        noDelegateCall\n    {\n        // Check: there is an equal number of `streamIds` and `amounts`.\n        uint256 streamIdsCount = streamIds.length;\n        uint256 amountsCount = amounts.length;\n        if (streamIdsCount != amountsCount) {\n            revert Errors.SablierV2Lockup_WithdrawArrayCountsNotEqual(streamIdsCount, amountsCount);\n        }\n\n        // Iterate over the provided array of stream IDs, and withdraw from each stream to the recipient.\n        for (uint256 i = 0; i < streamIdsCount; ++i) {\n            // Checks, Effects and Interactions: check the parameters and make the withdrawal.\n            withdraw({ streamId: streamIds[i], to: _ownerOf(streamIds[i]), amount: amounts[i] });\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                             INTERNAL CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Calculates the streamed amount of the stream without looking up the stream's status.\n    /// @dev This function is implemented by child contracts, so the logic varies depending on the model.\n    function _calculateStreamedAmount(uint256 streamId) internal view virtual returns (uint128);\n\n    /// @notice Checks whether `msg.sender` is the stream's recipient or an approved third party.\n    /// @param streamId The stream ID for the query.\n    function _isCallerStreamRecipientOrApproved(uint256 streamId) internal view returns (bool) {\n        address recipient = _ownerOf(streamId);\n        return msg.sender == recipient || isApprovedForAll({ owner: recipient, operator: msg.sender })\n            || getApproved(streamId) == msg.sender;\n    }\n\n    /// @notice Checks whether `msg.sender` is the stream's sender.\n    /// @param streamId The stream ID for the query.\n    function _isCallerStreamSender(uint256 streamId) internal view returns (bool) {\n        return msg.sender == _streams[streamId].sender;\n    }\n\n    /// @dev Retrieves the stream's status without performing a null check.\n    function _statusOf(uint256 streamId) internal view returns (Lockup.Status) {\n        if (_streams[streamId].isDepleted) {\n            return Lockup.Status.DEPLETED;\n        } else if (_streams[streamId].wasCanceled) {\n            return Lockup.Status.CANCELED;\n        }\n\n        if (block.timestamp < _streams[streamId].startTime) {\n            return Lockup.Status.PENDING;\n        }\n\n        if (_calculateStreamedAmount(streamId) < _streams[streamId].amounts.deposited) {\n            return Lockup.Status.STREAMING;\n        } else {\n            return Lockup.Status.SETTLED;\n        }\n    }\n\n    /// @"
    }
  ]
}