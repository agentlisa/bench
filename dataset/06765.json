{
  "Title": "[G-01] Cache calldata/memory pointers for complex types to avoid offset calculations",
  "Content": "The function parameters in the following instances are complex types (arrays of structs which contain arrays) and thus will result in more complex offset calculations to retrieve specific data from calldata/memory. We can avoid peforming some of these offset calculations by instantiating calldata/memory pointers.\n\nTotal Instances: `52`\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol#L106-L138\n\n### Cache calldata pointers for `buys[i]` and `buys[i].tokenIds`\n\n*Gas Savings for `EthRouter.buy`, obtained via protocol's tests: Avg 5987 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  187054  |  397581  |  199750 |    7     |\n| After  |  182524  |  381578  |  193763 |    7     |\n\n```solidity\nFile: src/EthRouter.sol\n106:        for (uint256 i = 0; i < buys.length; i++) {\n107:            if (buys[i].isPublicPool) {\n108:                // execute the buy against a public pool\n109:                uint256 inputAmount = Pair(buys[i].pool).nftBuy{value: buys[i].baseTokenAmount}(\n110:                    buys[i].tokenIds, buys[i].baseTokenAmount, 0\n111:                );\n112:\n113:                // pay the royalties if buyer has opted-in\n114:                if (payRoyalties) {\n115:                    uint256 salePrice = inputAmount / buys[i].tokenIds.length;\n116:                    for (uint256 j = 0; j < buys[i].tokenIds.length; j++) {\n117:                        // get the royalty fee and recipient\n118:                        (uint256 royaltyFee, address royaltyRecipient) =\n119:                            getRoyalty(buys[i].nft, buys[i].tokenIds[j], salePrice);\n120:\n121:                        if (royaltyFee > 0) {\n122:                            // transfer the royalty fee to the royalty recipient\n123:                            royaltyRecipient.safeTransferETH(royaltyFee);\n124:                        }\n125:                    }\n126:                }\n127:            } else {\n128:                // execute the buy against a private pool\n129:                PrivatePool(buys[i].pool).buy{value: buys[i].baseTokenAmount}(\n130:                    buys[i].tokenIds, buys[i].tokenWeights, buys[i].proof\n131:                );\n132:            }\n133:\n134:            for (uint256 j = 0; j < buys[i].tokenIds.length; j++) {\n135:                // transfer the NFT to the caller\n136:                ERC721(buys[i].nft).safeTransferFrom(address(this), msg.sender, buys[i].tokenIds[j]);\n137:            }\n138:        }\n```\n```diff\ndiff --git a/src/EthRouter.sol b/src/EthRouter.sol\nindex 125001d..1ed1c17 100644\n--- a/src/EthRouter.sol\n+++ b/src/EthRouter.sol\n@@ -104,19 +104,21 @@ contract EthRouter is ERC721TokenReceiver {\n\n         // loop through and execute the the buys\n         for (uint256 i = 0; i < buys.length; i++) {\n-            if (buys[i].isPublicPool) {\n+            Buy calldata _buy = buys[i];\n+            uint256[] calldata _tokenIds = _buy.tokenIds;\n+            if (_buy.isPublicPool) {\n                 // execute the buy against a public pool\n-                uint256 inputAmount = Pair(buys[i].pool).nftBuy{value: buys[i].baseTokenAmount}(\n-                    buys[i].tokenIds, buys[i].baseTokenAmount, 0\n+                uint256 inputAmount = Pair(_buy.pool).nftBuy{value: _buy.baseTokenAmount}(\n+                    _tokenIds, _buy.baseTokenAmount, 0\n                 );\n\n                 // pay the royalties if buyer has opted-in\n                 if (payRoyalties) {\n-                    uint256 salePrice = inputAmount / buys[i].tokenIds.length;\n-                    for (uint256 j = 0; j < buys[i].tokenIds.length; j++) {\n+                    uint256 salePrice = inputAmount / _tokenIds.length;\n+                    for (uint256 j = 0; j < _tokenIds.length; j++) {\n                         // get the royalty fee and recipient\n                         (uint256 royaltyFee, address royaltyRecipient) =\n-                            getRoyalty(buys[i].nft, buys[i].tokenIds[j], salePrice);\n+                            getRoyalty(_buy.nft, _tokenIds[j], salePrice);\n\n                         if (royaltyFee > 0) {\n                             // transfer the royalty fee to the royalty recipient\n@@ -126,14 +128,14 @@ contract EthRouter is ERC721TokenReceiver {\n                 }\n             } else {\n                 // execute the buy against a private pool\n-                PrivatePool(buys[i].pool).buy{value: buys[i].baseTokenAmount}(\n-                    buys[i].tokenIds, buys[i].tokenWeights, buys[i].proof\n+                PrivatePool(_buy.pool).buy{value: _buy.baseTokenAmount}(\n+                    _tokenIds, _buy.tokenWeights, _buy.proof\n                 );\n             }\n\n-            for (uint256 j = 0; j < buys[i].tokenIds.length; j++) {\n+            for (uint256 j = 0; j < _tokenIds.length; j++) {\n                 // transfer the NFT to the caller\n-                ERC721(buys[i].nft).safeTransferFrom(address(this), msg.sender, buys[i].tokenIds[j]);\n+                ERC721(_buy.nft).safeTransferFrom(address(this), msg.sender, _tokenIds[j]);\n             }\n         }\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol#L159-L200\n\n### Cache calldata pointers for `sells[i]` and `sells[i].tokenIds`\n\n*Gas Savings for `EthRouter.sell`, obtained via protocol's tests: Avg 5422 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  217300  |  402940  |  232102 |    7     |\n| After  |  212264  |  392556  |  226680 |    7     |\n\n```solidity\nFile: src/EthRouter.sol\n159:        for (uint256 i = 0; i < sells.length; i++) {\n160:            // transfer the NFTs into the router from the caller\n161:            for (uint256 j = 0; j < sells[i].tokenIds.length; j++) {\n162:                ERC721(sells[i].nft).safeTransferFrom(msg.sender, address(this), sells[i].tokenIds[j]);\n163:            }\n164:\n165:            // approve the pair to transfer NFTs from the router\n166:            ERC721(sells[i].nft).setApprovalForAll(sells[i].pool, true);\n167:\n168:            if (sells[i].isPublicPool) {\n169:                // exceute the sell against a public pool\n170:                uint256 outputAmount = Pair(sells[i].pool).nftSell(\n171:                    sells[i].tokenIds,\n172:                    0,\n173:                    0,\n174:                    sells[i].publicPoolProofs,\n175:                    // ReservoirOracle.Message[] is the exact same as IStolenNftOracle.Message[] and can be\n176:                    // decoded/encoded 1-to-1.\n177:                    abi.decode(abi.encode(sells[i].stolenNftProofs), (ReservoirOracle.Message[]))\n178:                );\n179:\n180:                // pay the royalties if seller has opted-in\n181:                if (payRoyalties) {\n182:                    uint256 salePrice = outputAmount / sells[i].tokenIds.length;\n183:                    for (uint256 j = 0; j < sells[i].tokenIds.length; j++) {\n184:                        // get the royalty fee and recipient\n185:                        (uint256 royaltyFee, address royaltyRecipient) =\n186:                            getRoyalty(sells[i].nft, sells[i].tokenIds[j], salePrice);\n187:\n188:                        if (royaltyFee > 0) {\n189:                            // transfer the royalty fee to the royalty recipient\n190:                            royaltyRecipient.safeTransferETH(royaltyFee);\n191:                        }\n192:                    }\n193:                }\n194:            } else {\n195:                // execute the sell against a private pool\n196:                PrivatePool(sells[i].pool).sell(\n197:                    sells[i].tokenIds, sells[i].tokenWeights, sells[i].proof, sells[i].stolenNftProofs\n198:                );\n199:            }\n200:        }\n```\n```diff\ndiff --git a/src/EthRouter.sol b/src/EthRouter.sol\nindex 125001d..12218d6 100644\n--- a/src/EthRouter.sol\n+++ b/src/EthRouter.sol\n@@ -157,33 +157,35 @@ contract EthRouter is ERC721TokenReceiver {\n\n         // loop through and execute the sells\n         for (uint256 i = 0; i < sells.length; i++) {\n+            Sell calldata _sell = sells[i];\n+            uint256[] calldata _tokenIds = _sell.tokenIds;\n             // transfer the NFTs into the router from the caller\n-            for (uint256 j = 0; j < sells[i].tokenIds.length; j++) {\n-                ERC721(sells[i].nft).safeTransferFrom(msg.sender, address(this), sells[i].tokenIds[j]);\n+            for (uint256 j = 0; j < _tokenIds.length; j++) {\n+                ERC721(_sell.nft).safeTransferFrom(msg.sender, address(this), _tokenIds[j]);\n             }\n\n             // approve the pair to transfer NFTs from the router\n-            ERC721(sells[i].nft).setApprovalForAll(sells[i].pool, true);\n+            ERC721(_sell.nft).setApprovalForAll(_sell.pool, true);\n\n-            if (sells[i].isPublicPool) {\n+            if (_sell.isPublicPool) {\n                 // exceute the sell against a public pool\n-                uint256 outputAmount = Pair(sells[i].pool).nftSell(\n-                    sells[i].tokenIds,\n+                uint256 outputAmount = Pair(_sell.pool).nftSell(\n+                    _tokenIds,\n                     0,\n                     0,\n-                    sells[i].publicPoolProofs,\n+                    _sell.publicPoolProofs,\n                     // ReservoirOracle.Message[] is the exact same as IStolenNftOracle.Message[] and can be\n                     // decoded/encoded 1-to-1.\n-                    abi.decode(abi.encode(sells[i].stolenNftProofs), (ReservoirOracle.Message[]))\n+                    abi.decode(abi.encode(_sell.stolenNftProofs), (ReservoirOracle.Message[]))\n                 );\n\n                 // pay the royalties if seller has opted-in\n                 if (payRoyalties) {\n-                    uint256 salePrice = outputAmount / sells[i].tokenIds.length;\n-                    for (uint256 j = 0; j < sells[i].tokenIds.length; j++) {\n+                    uint256 salePrice = outputAmount / _tokenIds.length;\n+                    for (uint256 j = 0; j < _tokenIds.length; j++) {\n                         // get the royalty fee and recipient\n                         (uint256 royaltyFee, address royaltyRecipient) =\n-                            getRoyalty(sells[i].nft, sells[i].tokenIds[j], salePrice);\n+                            getRoyalty(_sell.nft, _tokenIds[j], salePrice);\n\n                         if (royaltyFee > 0) {\n                             // transfer the royalty fee to the royalty recipient\n@@ -193,8 +195,8 @@ contract EthRouter is ERC721TokenReceiver {\n                 }\n             } else {\n                 // execute the sell against a private pool\n-                PrivatePool(sells[i].pool).sell(\n-                    sells[i].tokenIds, sells[i].tokenWeights, sells[i].proof, sells[i].stolenNftProofs\n+                PrivatePool(_sell.pool).sell(\n+                    _tokenIds, _sell.tokenWeights, _sell.proof, _sell.stolenNftProofs\n                 );\n             }\n         }\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol#L261-L287\n\n### Cache calldata pointer for `changes[i]` and memory pointers for `changes[i].inputTokenIds` & `changes[i].outputTokenIds`\n\n*Gas Savings for `EthRouter.change`, obtained via protocol's tests: Avg 4314 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  284857  |  298879  |  217295 |    4     |\n| After  |  279105  |  293127  |  212981 |    4     |\n\n```solidity\nFile: src/EthRouter.sol\n261:        for (uint256 i = 0; i < changes.length; i++) {\n262:            Change memory _change = changes[i];\n263:\n264:            // transfer NFTs from caller\n265:            for (uint256 j = 0; j < changes[i].inputTokenIds.length; j++) {\n266:                ERC721(_change.nft).safeTransferFrom(msg.sender, address(this), _change.inputTokenIds[j]);\n267:            }\n268:\n269:            // approve pair to transfer NFTs from router\n270:            ERC721(_change.nft).setApprovalForAll(_change.pool, true);\n271:\n272:            // execute change\n273:            PrivatePool(_change.pool).change{value: msg.value}(\n274:                _change.inputTokenIds,\n275:                _change.inputTokenWeights,\n276:                _change.inputProof,\n277:                _change.stolenNftProofs,\n278:                _change.outputTokenIds,\n279:                _change.outputTokenWeights,\n280:                _change.outputProof\n281:            );\n282:\n283:            // transfer NFTs to caller\n284:            for (uint256 j = 0; j < changes[i].outputTokenIds.length; j++) {\n285:                ERC721(_change.nft).safeTransferFrom(address(this), msg.sender, _change.outputTokenIds[j]);\n286:            }\n287:        }\n```\n```diff\ndiff --git a/src/EthRouter.sol b/src/EthRouter.sol\nindex 125001d..c63c2f8 100644\n--- a/src/EthRouter.sol\n+++ b/src/EthRouter.sol\n@@ -259,11 +259,13 @@ contract EthRouter is ERC721TokenReceiver {\n\n         // loop through and execute the changes\n         for (uint256 i = 0; i < changes.length; i++) {\n-            Change memory _change = changes[i];\n+            Change calldata _change = changes[i];\n+            uint256[] memory _inputTokenIds = _change.inputTokenIds;\n+            uint256[] memory _outputTokenIds = _change.outputTokenIds;\n\n             // transfer NFTs from caller\n-            for (uint256 j = 0; j < changes[i].inputTokenIds.length; j++) {\n-                ERC721(_change.nft).safeTransferFrom(msg.sender, address(this), _change.inputTokenIds[j]);\n+            for (uint256 j = 0; j < _inputTokenIds.length; j++) {\n+                ERC721(_change.nft).safeTransferFrom(msg.sender, address(this), _inputTokenIds[j]);\n             }\n\n             // approve pair to transfer NFTs from router\n@@ -271,18 +273,18 @@ contract EthRouter is ERC721TokenReceiver {\n\n             // execute change\n             PrivatePool(_change.pool).change{value: msg.value}(\n-                _change.inputTokenIds,\n+                _inputTokenIds,\n                 _change.inputTokenWeights,\n                 _change.inputProof,\n                 _change.stolenNftProofs,\n-                _change.outputTokenIds,\n+                _outputTokenIds,\n                 _change.outputTokenWeights,\n                 _change.outputProof\n             );\n\n             // transfer NFTs to caller\n-            for (uint256 j = 0; j < changes[i].outputTokenIds.length; j++) {\n-                ERC721(_change.nft).safeTransferFrom(address(this), msg.sender, _change.outputTokenIds[j]);\n+            for (uint256 j = 0; j < _outputTokenIds.length; j++) {\n+                ERC721(_change.nft).safeTransferFrom(address(this), msg.sender, _outputTokenIds[j]);\n             }\n         }\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2023-04-caviar-private-pools",
  "Code": [
    {
      "filename": "src/EthRouter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/*\n *                                     _H_\n *                                    /___\\\n *                                    \\888/\n * ~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~U~^~^~^~^~^~^~^\n *                       ~              |\n *       ~                        o     |        ~\n *                 ___        o         |\n *        _,.--,.'`   `~'-.._    O      |\n *       /_  .-\"      _   /_\\'.         |   ~\n *      .-';'       (( `  \\0/  `\\       #\n *     /__;          ((_  ,_     |  ,   #\n *     .-;                  \\_   /  #  _#,\n *    /  ;    .-' /  _.--\"\"-.\\`~`   `#(('\\\\        ~\n *    ;-';   /   / .'                  )) \\\\\n *        ; /.--'.'                   ((   ))\n *         \\     |        ~            \\\\ ((\n *          \\    |                      )) `\n *    ~      \\   |                      `\n *            \\  |\n *            .` `\"\"-.\n *          .'        \\         ~               ~\n *          |    |\\    |\n *          \\   /  '-._|\n *           \\.'\n */\n\nimport {ERC721, ERC721TokenReceiver} from \"solmate/tokens/ERC721.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {IERC2981} from \"openzeppelin/interfaces/IERC2981.sol\";\nimport {Pair, ReservoirOracle} from \"caviar/Pair.sol\";\nimport {IRoyaltyRegistry} from \"royalty-registry-solidity/IRoyaltyRegistry.sol\";\n\nimport {PrivatePool} from \"./PrivatePool.sol\";\nimport {IStolenNftOracle} from \"./interfaces/IStolenNftOracle.sol\";\n\n/// @title Eth Router\n/// @author out.eth (@outdoteth)\n/// @notice This contract is used to route buy, sell, and change orders to multiple pools in one transaction. It\n/// will route the orders to either a private pool or a public pool. If the order goes to a public pool, then users\n/// can choose whether or not they would like to pay royalties. The only base token which is supported is native ETH.\ncontract EthRouter is ERC721TokenReceiver {\n    using SafeTransferLib for address;\n\n    struct Buy {\n        address payable pool;\n        address nft;\n        uint256[] tokenIds;\n        uint256[] tokenWeights;\n        PrivatePool.MerkleMultiProof proof;\n        uint256 baseTokenAmount;\n        bool isPublicPool;\n    }\n\n    struct Sell {\n        address payable pool;\n        address nft;\n        uint256[] tokenIds;\n        uint256[] tokenWeights;\n        PrivatePool.MerkleMultiProof proof;\n        IStolenNftOracle.Message[] stolenNftProofs;\n        bool isPublicPool;\n        bytes32[][] publicPoolProofs;\n    }\n\n    struct Change {\n        address payable pool;\n        address nft;\n        uint256[] inputTokenIds;\n        uint256[] inputTokenWeights;\n        PrivatePool.MerkleMultiProof inputProof;\n        IStolenNftOracle.Message[] stolenNftProofs;\n        uint256[] outputTokenIds;\n        uint256[] outputTokenWeights;\n        PrivatePool.MerkleMultiProof outputProof;\n    }\n\n    error DeadlinePassed();\n    error OutputAmountTooSmall();\n    error PriceOutOfRange();\n    error InvalidRoyaltyFee();\n\n    address public immutable royaltyRegistry;\n\n    receive() external payable {}\n\n    constructor(address _royaltyRegistry) {\n        royaltyRegistry = _royaltyRegistry;\n    }\n\n    /// @notice Executes a series of buy operations against public or private pools.\n    /// @param buys The buy operations to execute.\n    /// @param deadline The deadline for the transaction to be mined. Will revert if timestamp is greater than deadline.\n    /// If it's set to 0 then there is no deadline.\n    /// @param payRoyalties Whether to pay royalties or not.\n    function buy(Buy[] calldata buys, uint256 deadline, bool payRoyalties) public payable {\n        // check that the deadline has not passed (if any)\n        if (block.timestamp > deadline && deadline != 0) {\n            revert DeadlinePassed();\n        }\n\n        // loop through and execute the the buys\n        for (uint256 i = 0; i < buys.length; i++) {\n            if (buys[i].isPublicPool) {\n                // execute the buy against a public pool\n                uint256 inputAmount = Pair(buys[i].pool).nftBuy{value: buys[i].baseTokenAmount}(\n                    buys[i].tokenIds, buys[i].baseTokenAmount, 0\n                );\n\n                // pay the royalties if buyer has opted-in\n                if (payRoyalties) {\n                    uint256 salePrice = inputAmount / buys[i].tokenIds.length;\n                    for (uint256 j = 0; j < buys[i].tokenIds.length; j++) {\n                        // get the royalty fee and recipient\n                        (uint256 royaltyFee, address royaltyRecipient) =\n                            getRoyalty(buys[i].nft, buys[i].tokenIds[j], salePrice);\n\n                        if (royaltyFee > 0) {\n                            // transfer the royalty fee to the royalty recipient\n                            royaltyRecipient.safeTransferETH(royaltyFee);\n                        }\n                    }\n                }\n            } else {\n                // execute the buy against a private pool\n                PrivatePool(buys[i].pool).buy{value: buys[i].baseTokenAmount}(\n                    buys[i].tokenIds, buys[i].tokenWeights, buys[i].proof\n                );\n            }\n\n            for (uint256 j = 0; j < buys[i].tokenIds.length; j++) {\n                // transfer the NFT to the caller\n                ERC721(buys[i].nft).safeTransferFrom(address(this), msg.sender, buys[i].tokenIds[j]);\n            }\n        }\n\n        // refund any surplus ETH to the caller\n        if (address(this).balance > 0) {\n            msg.sender.safeTransferETH(address(this).balance);\n        }\n    }\n\n    /// @notice Executes a series of sell operations against public or private pools.\n    /// @param sells The sell operations to execute.\n    /// @param minOutputAmount The minimum amount of output tokens that must be received for the transaction to succeed.\n    /// @param deadline The deadline for the transaction to be mined. Will revert if timestamp is greater than deadline.\n    /// Set to 0 for there to be no deadline.\n    /// @param payRoyalties Whether to pay royalties or not.\n    function sell(Sell[] calldata sells, uint256 minOutputAmount, uint256 deadline, bool payRoyalties) public {\n        // check that the deadline has not passed (if any)\n        if (block.timestamp > deadline && deadline != 0) {\n            revert DeadlinePassed();\n        }\n\n        // loop through and execute the sells\n        for (uint256 i = 0; i < sells.length; i++) {\n            // transfer the NFTs into the router from the caller\n            for (uint256 j = 0; j < sells[i].tokenIds.length; j++) {\n                ERC721(sells[i].nft).safeTransferFrom(msg.sender, address(this), sells[i].tokenIds[j]);\n            }\n\n            // approve the pair to transfer NFTs from the router\n            ERC721(sells[i].nft).setApprovalForAll(sells[i].pool, true);\n\n            if (sells[i].isPublicPool) {\n                // exceute the sell against a public pool\n                uint256 outputAmount = Pair(sells[i].pool).nftSell(\n                    sells[i].tokenIds,\n                    0,\n                    0,\n                    sells[i].publicPoolProofs,\n                    // ReservoirOracle.Message[] is the exact same as IStolenNftOracle.Message[] and can be\n                    // decoded/encoded 1-to-1.\n                    abi.decode(abi.encode(sells[i].stolenNftProofs), (ReservoirOracle.Message[]))\n                );\n\n                // pay the royalties if seller has opted-in\n                if (payRoyalties) {\n                    uint256 salePrice = outputAmount / sells[i].tokenIds.length;\n                    for (uint256 j = 0; j < sells[i].tokenIds.length; j++) {\n                        // get the royalty fee and recipient\n                        (uint256 royaltyFee, address royaltyRecipient) =\n                            getRoyalty(sells[i].nft, sells[i].tokenIds[j], salePrice);\n\n                        if (royaltyFee > 0) {\n                            // transfer the royalty fee to the royalty recipient\n                            royaltyRecipient.safeTransferETH(royaltyFee);\n                        }\n                    }\n                }\n            } else {\n                // execute the sell against a private pool\n                PrivatePool(sells[i].pool).sell(\n                    sells[i].tokenIds, sells[i].tokenWeights, sells[i].proof, sells[i].stolenNftProofs\n                );\n            }\n        }\n\n        // check that the output amount is greater than the minimum\n        if (address(this).balance < minOutputAmount) {\n            revert OutputAmountTooSmall();\n        }\n\n        // transfer the output amount to the caller\n        msg.sender.safeTransferETH(address(this).balance);\n    }\n\n    /// @notice Executes a deposit to a private pool (transfers NFTs and ETH to the pool).\n    /// @param privatePool The private pool to deposit to.\n    /// @param nft The NFT contract address.\n    /// @param tokenIds The token IDs of the NFTs to deposit.\n    /// @param minPrice The minimum price of the pool. Will revert if price is smaller than this.\n    /// @param maxPrice The maximum price of the pool. Will revert if price is greater than this.\n    /// @param deadline The deadline for the transaction to be mined. Will revert if timestamp is greater than deadline.\n    /// Set to 0 for deadline to be ignored.\n    function deposit(\n        address payable privatePool,\n        address nft,\n        uint256[] calldata tokenIds,\n        uint256 minPrice,\n        uint256 maxPrice,\n        uint256 deadline\n    ) public payable {\n        // check deadline has not passed (if any)\n        if (block.timestamp > deadline && deadline != 0) {\n            revert DeadlinePassed();\n        }\n\n        // check pool price is in between min and max\n        uint256 price = PrivatePool(privatePool).price();\n        if (price > maxPrice || price < minPrice) {\n            revert PriceOutOfRange();\n        }\n\n        // transfer NFTs from caller\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n        }\n\n        // approve pair to transfer NFTs from router\n        ERC721(nft).setApprovalForAll(privatePool, true);\n\n        // execute deposit\n        PrivatePool(privatePool).deposit{value: msg.value}(tokenIds, msg.value);\n    }\n\n    /// @notice Executes a series of change operations against a private pool.\n    /// @param changes The change operations to execute.\n    /// @param deadline The deadline for the transaction to be mined. Will revert if timestamp is greater than deadline.\n    /// Set to 0 for deadline to be ignored.\n    function change(Change[] calldata changes, uint256 deadline) public payable {\n        // check deadline has not passed (if any)\n        if (block.timestamp > deadline && deadline != 0) {\n            revert DeadlinePassed();\n        }\n\n        // loop through and execute the changes\n        for (uint256 i = 0; i < changes.length; i++) {\n            Change memory _change = changes[i];\n\n            // transfer NFTs from caller\n            for (uint256 j = 0; j < changes[i].inputTokenIds.length; j++) {\n                ERC721(_change.nft).safeTransferFrom(msg.sender, address(this), _change.inputTokenIds[j]);\n            }\n\n            // approve pair to transfer NFTs from router\n            ERC721(_change.nft).setApprovalForAll(_change.pool, true);\n\n            // execute change\n            PrivatePool(_change.pool).change{value: msg.value}(\n                _change.inputTokenIds,\n                _change.inputTokenWeights,\n                _change.inputProof,\n                _change.stolenNftProofs,\n                _change.outputTokenIds,\n                _change.outputTokenWeights,\n                _change.outputProof\n            );\n\n            // transfer NFTs to caller\n            for (uint256 j = 0; j < changes[i].outputTokenIds.length; j++) {\n                ERC721(_change.nft).safeTransferFrom(address(this), msg.sender, _change.outputTokenIds[j]);\n            }\n        }\n\n        // refund any surplus ETH to the caller\n        if (address(this).balance > 0) {\n            msg.sender.safeTransferETH(address(this).balance);\n        }\n    }\n\n    /// @notice Gets the royalty and recipient for a given NFT and sale price. Looks up the royalty info from the\n    /// manifold registry.\n    /// @param tokenId The token ID of the NFT.\n    /// @param salePrice The sale price of the NFT.\n    /// @return royaltyFee The royalty fee to pay.\n    /// @return recipient The address to pay the royalty fee to.\n    function getRoyalty(address nft, uint256 tokenId, uint256 salePrice)\n        public\n        view\n        returns (uint256 royaltyFee, address recipient)\n    {\n        // get the royalty lookup address\n        address lookupAddress = IRoyaltyRegistry(royaltyRegistry).getRoyaltyLookupAddress(nft);\n\n        if (IERC2981(lookupAddress).supportsInterface(type(IERC2981).interfaceId)) {\n            // get the royalty fee from the registry\n            (recipient, royaltyFee) = IERC2981(lookupAddress).royaltyInfo(tokenId, salePrice);\n\n            // revert if the royalty fee is greater than the sale price\n            if (royaltyFee > salePrice) revert InvalidRoyaltyFee();\n        }\n    }\n}"
    },
    {
      "filename": "src/EthRouter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/*\n *                                     _H_\n *                                    /___\\\n *                                    \\888/\n * ~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~U~^~^~^~^~^~^~^\n *                       ~              |\n *       ~                        o     |        ~\n *                 ___        o         |\n *        _,.--,.'`   `~'-.._    O      |\n *       /_  .-\"      _   /_\\'.         |   ~\n *      .-';'       (( `  \\0/  `\\       #\n *     /__;          ((_  ,_     |  ,   #\n *     .-;                  \\_   /  #  _#,\n *    /  ;    .-' /  _.--\"\"-.\\`~`   `#(('\\\\        ~\n *    ;-';   /   / .'                  )) \\\\\n *        ; /.--'.'                   ((   ))\n *         \\     |        ~            \\\\ ((\n *          \\    |                      )) `\n *    ~      \\   |                      `\n *            \\  |\n *            .` `\"\"-.\n *          .'        \\         ~               ~\n *          |    |\\    |\n *          \\   /  '-._|\n *           \\.'\n */\n\nimport {ERC721, ERC721TokenReceiver} from \"solmate/tokens/ERC721.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {IERC2981} from \"openzeppelin/interfaces/IERC2981.sol\";\nimport {Pair, ReservoirOracle} from \"caviar/Pair.sol\";\nimport {IRoyaltyRegistry} from \"royalty-registry-solidity/IRoyaltyRegistry.sol\";\n\nimport {PrivatePool} from \"./PrivatePool.sol\";\nimport {IStolenNftOracle} from \"./interfaces/IStolenNftOracle.sol\";\n\n/// @title Eth Router\n/// @author out.eth (@outdoteth)\n/// @notice This contract is used to route buy, sell, and change orders to multiple pools in one transaction. It\n/// will route the orders to either a private pool or a public pool. If the order goes to a public pool, then users\n/// can choose whether or not they would like to pay royalties. The only base token which is supported is native ETH.\ncontract EthRouter is ERC721TokenReceiver {\n    using SafeTransferLib for address;\n\n    struct Buy {\n        address payable pool;\n        address nft;\n        uint256[] tokenIds;\n        uint256[] tokenWeights;\n        PrivatePool.MerkleMultiProof proof;\n        uint256 baseTokenAmount;\n        bool isPublicPool;\n    }\n\n    struct Sell {\n        address payable pool;\n        address nft;\n        uint256[] tokenIds;\n        uint256[] tokenWeights;\n        PrivatePool.MerkleMultiProof proof;\n        IStolenNftOracle.Message[] stolenNftProofs;\n        bool isPublicPool;\n        bytes32[][] publicPoolProofs;\n    }\n\n    struct Change {\n        address payable pool;\n        address nft;\n        uint256[] inputTokenIds;\n        uint256[] inputTokenWeights;\n        PrivatePool.MerkleMultiProof inputProof;\n        IStolenNftOracle.Message[] stolenNftProofs;\n        uint256[] outputTokenIds;\n        uint256[] outputTokenWeights;\n        PrivatePool.MerkleMultiProof outputProof;\n    }\n\n    error DeadlinePassed();\n    error OutputAmountTooSmall();\n    error PriceOutOfRange();\n    error InvalidRoyaltyFee();\n\n    address public immutable royaltyRegistry;\n\n    receive() external payable {}\n\n    constructor(address _royaltyRegistry) {\n        royaltyRegistry = _royaltyRegistry;\n    }\n\n    /// @notice Executes a series of buy operations against public or private pools.\n    /// @param buys The buy operations to execute.\n    /// @param deadline The deadline for the transaction to be mined. Will revert if timestamp is greater than deadline.\n    /// If it's set to 0 then there is no deadline.\n    /// @param payRoyalties Whether to pay royalties or not.\n    function buy(Buy[] calldata buys, uint256 deadline, bool payRoyalties) public payable {\n        // check that the deadline has not passed (if any)\n        if (block.timestamp > deadline && deadline != 0) {\n            revert DeadlinePassed();\n        }\n\n        // loop through and execute the the buys\n        for (uint256 i = 0; i < buys.length; i++) {\n            if (buys[i].isPublicPool) {\n                // execute the buy against a public pool\n                uint256 inputAmount = Pair(buys[i].pool).nftBuy{value: buys[i].baseTokenAmount}(\n                    buys[i].tokenIds, buys[i].baseTokenAmount, 0\n                );\n\n                // pay the royalties if buyer has opted-in\n                if (payRoyalties) {\n                    uint256 salePrice = inputAmount / buys[i].tokenIds.length;\n                    for (uint256 j = 0; j < buys[i].tokenIds.length; j++) {\n                        // get the royalty fee and recipient\n                        (uint256 royaltyFee, address royaltyRecipient) =\n                            getRoyalty(buys[i].nft, buys[i].tokenIds[j], salePrice);\n\n                        if (royaltyFee > 0) {\n                            // transfer the royalty fee to the royalty recipient\n                            royaltyRecipient.safeTransferETH(royaltyFee);\n                        }\n                    }\n                }\n            } else {\n                // execute the buy against a private pool\n                PrivatePool(buys[i].pool).buy{value: buys[i].baseTokenAmount}(\n                    buys[i].tokenIds, buys[i].tokenWeights, buys[i].proof\n                );\n            }\n\n            for (uint256 j = 0; j < buys[i].tokenIds.length; j++) {\n                // transfer the NFT to the caller\n                ERC721(buys[i].nft).safeTransferFrom(address(this), msg.sender, buys[i].tokenIds[j]);\n            }\n        }\n\n        // refund any surplus ETH to the caller\n        if (address(this).balance > 0) {\n            msg.sender.safeTransferETH(address(this).balance);\n        }\n    }\n\n    /// @notice Executes a series of sell operations against public or private pools.\n    /// @param sells The sell operations to execute.\n    /// @param minOutputAmount The minimum amount of output tokens that must be received for the transaction to succeed.\n    /// @param deadline The deadline for the transaction to be mined. Will revert if timestamp is greater than deadline.\n    /// Set to 0 for there to be no deadline.\n    /// @param payRoyalties Whether to pay royalties or not.\n    function sell(Sell[] calldata sells, uint256 minOutputAmount, uint256 deadline, bool payRoyalties) public {\n        // check that the deadline has not passed (if any)\n        if (block.timestamp > deadline && deadline != 0) {\n            revert DeadlinePassed();\n        }\n\n        // loop through and execute the sells\n        for (uint256 i = 0; i < sells.length; i++) {\n            // transfer the NFTs into the router from the caller\n            for (uint256 j = 0; j < sells[i].tokenIds.length; j++) {\n                ERC721(sells[i].nft).safeTransferFrom(msg.sender, address(this), sells[i].tokenIds[j]);\n            }\n\n            // approve the pair to transfer NFTs from the router\n            ERC721(sells[i].nft).setApprovalForAll(sells[i].pool, true);\n\n            if (sells[i].isPublicPool) {\n                // exceute the sell against a public pool\n                uint256 outputAmount = Pair(sells[i].pool).nftSell(\n                    sells[i].tokenIds,\n                    0,\n                    0,\n                    sells[i].publicPoolProofs,\n                    // ReservoirOracle.Message[] is the exact same as IStolenNftOracle.Message[] and can be\n                    // decoded/encoded 1-to-1.\n                    abi.decode(abi.encode(sells[i].stolenNftProofs), (ReservoirOracle.Message[]))\n                );\n\n                // pay the royalties if seller has opted-in\n                if (payRoyalties) {\n                    uint256 salePrice = outputAmount / sells[i].tokenIds.length;\n                    for (uint256 j = 0; j < sells[i].tokenIds.length; j++) {\n                        // get the royalty fee and recipient\n                        (uint256 royaltyFee, address royaltyRecipient) =\n                            getRoyalty(sells[i].nft, sells[i].tokenIds[j], salePrice);\n\n                        if (royaltyFee > 0) {\n                            // transfer the royalty fee to the royalty recipient\n                            royaltyRecipient.safeTransferETH(royaltyFee);\n                        }\n                    }\n                }\n            } else {\n                // execute the sell against a private pool\n                PrivatePool(sells[i].pool).sell(\n                    sells[i].tokenIds, sells[i].tokenWeights, sells[i].proof, sells[i].stolenNftProofs\n                );\n            }\n        }\n\n        // check that the output amount is greater than the minimum\n        if (address(this).balance < minOutputAmount) {\n            revert OutputAmountTooSmall();\n        }\n\n        // transfer the output amount to the caller\n        msg.sender.safeTransferETH(address(this).balance);\n    }\n\n    /// @notice Executes a deposit to a private pool (transfers NFTs and ETH to the pool).\n    /// @param privatePool The private pool to deposit to.\n    /// @param nft The NFT contract address.\n    /// @param tokenIds The token IDs of the NFTs to deposit.\n    /// @param minPrice The minimum price of the pool. Will revert if price is smaller than this.\n    /// @param maxPrice The maximum price of the pool. Will revert if price is greater than this.\n    /// @param deadline The deadline for the transaction to be mined. Will revert if timestamp is greater than deadline.\n    /// Set to 0 for deadline to be ignored.\n    function deposit(\n        address payable privatePool,\n        address nft,\n        uint256[] calldata tokenIds,\n        uint256 minPrice,\n        uint256 maxPrice,\n        uint256 deadline\n    ) public payable {\n        // check deadline has not passed (if any)\n        if (block.timestamp > deadline && deadline != 0) {\n            revert DeadlinePassed();\n        }\n\n        // check pool price is in between min and max\n        uint256 price = PrivatePool(privatePool).price();\n        if (price > maxPrice || price < minPrice) {\n            revert PriceOutOfRange();\n        }\n\n        // transfer NFTs from caller\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n        }\n\n        // approve pair to transfer NFTs from router\n        ERC721(nft).setApprovalForAll(privatePool, true);\n\n        // execute deposit\n        PrivatePool(privatePool).deposit{value: msg.value}(tokenIds, msg.value);\n    }\n\n    /// @notice Executes a series of change operations against a private pool.\n    /// @param changes The change operations to execute.\n    /// @param deadline The deadline for the transaction to be mined. Will revert if timestamp is greater than deadline.\n    /// Set to 0 for deadline to be ignored.\n    function change(Change[] calldata changes, uint256 deadline) public payable {\n        // check deadline has not passed (if any)\n        if (block.timestamp > deadline && deadline != 0) {\n            revert DeadlinePassed();\n        }\n\n        // loop through and execute the changes\n        for (uint256 i = 0; i < changes.length; i++) {\n            Change memory _change = changes[i];\n\n            // transfer NFTs from caller\n            for (uint256 j = 0; j < changes[i].inputTokenIds.length; j++) {\n                ERC721(_change.nft).safeTransferFrom(msg.sender, address(this), _change.inputTokenIds[j]);\n            }\n\n            // approve pair to transfer NFTs from router\n            ERC721(_change.nft).setApprovalForAll(_change.pool, true);\n\n            // execute change\n            PrivatePool(_change.pool).change{value: msg.value}(\n                _change.inputTokenIds,\n                _change.inputTokenWeights,\n                _change.inputProof,\n                _change.stolenNftProofs,\n                _change.outputTokenIds,\n                _change.outputTokenWeights,\n                _change.outputProof\n            );\n\n            // transfer NFTs to caller\n            for (uint256 j = 0; j < changes[i].outputTokenIds.length; j++) {\n                ERC721(_change.nft).safeTransferFrom(address(this), msg.sender, _change.outputTokenIds[j]);\n            }\n        }\n\n        // refund any surplus ETH to the caller\n        if (address(this).balance > 0) {\n            msg.sender.safeTransferETH(address(this).balance);\n        }\n    }\n\n    /// @notice Gets the royalty and recipient for a given NFT and sale price. Looks up the royalty info from the\n    /// manifold registry.\n    /// @param tokenId The token ID of the NFT.\n    /// @param salePrice The sale price of the NFT.\n    /// @return royaltyFee The royalty fee to pay.\n    /// @return recipient The address to pay the royalty fee to.\n    function getRoyalty(address nft, uint256 tokenId, uint256 salePrice)\n        public\n        view\n        returns (uint256 royaltyFee, address recipient)\n    {\n        // get the royalty lookup address\n        address lookupAddress = IRoyaltyRegistry(royaltyRegistry).getRoyaltyLookupAddress(nft);\n\n        if (IERC2981(lookupAddress).supportsInterface(type(IERC2981).interfaceId)) {\n            // get the royalty fee from the registry\n            (recipient, royaltyFee) = IERC2981(lookupAddress).royaltyInfo(tokenId, salePrice);\n\n            // revert if the royalty fee is greater than the sale price\n            if (royaltyFee > salePrice) revert InvalidRoyaltyFee();\n        }\n    }\n}"
    },
    {
      "filename": "src/EthRouter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/*\n *                                     _H_\n *                                    /___\\\n *                                    \\888/\n * ~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~U~^~^~^~^~^~^~^\n *                       ~              |\n *       ~                        o     |        ~\n *                 ___        o         |\n *        _,.--,.'`   `~'-.._    O      |\n *       /_  .-\"      _   /_\\'.         |   ~\n *      .-';'       (( `  \\0/  `\\       #\n *     /__;          ((_  ,_     |  ,   #\n *     .-;                  \\_   /  #  _#,\n *    /  ;    .-' /  _.--\"\"-.\\`~`   `#(('\\\\        ~\n *    ;-';   /   / .'                  )) \\\\\n *        ; /.--'.'                   ((   ))\n *         \\     |        ~            \\\\ ((\n *          \\    |                      )) `\n *    ~      \\   |                      `\n *            \\  |\n *            .` `\"\"-.\n *          .'        \\         ~               ~\n *          |    |\\    |\n *          \\   /  '-._|\n *           \\.'\n */\n\nimport {ERC721, ERC721TokenReceiver} from \"solmate/tokens/ERC721.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {IERC2981} from \"openzeppelin/interfaces/IERC2981.sol\";\nimport {Pair, ReservoirOracle} from \"caviar/Pair.sol\";\nimport {IRoyaltyRegistry} from \"royalty-registry-solidity/IRoyaltyRegistry.sol\";\n\nimport {PrivatePool} from \"./PrivatePool.sol\";\nimport {IStolenNftOracle} from \"./interfaces/IStolenNftOracle.sol\";\n\n/// @title Eth Router\n/// @author out.eth (@outdoteth)\n/// @notice This contract is used to route buy, sell, and change orders to multiple pools in one transaction. It\n/// will route the orders to either a private pool or a public pool. If the order goes to a public pool, then users\n/// can choose whether or not they would like to pay royalties. The only base token which is supported is native ETH.\ncontract EthRouter is ERC721TokenReceiver {\n    using SafeTransferLib for address;\n\n    struct Buy {\n        address payable pool;\n        address nft;\n        uint256[] tokenIds;\n        uint256[] tokenWeights;\n        PrivatePool.MerkleMultiProof proof;\n        uint256 baseTokenAmount;\n        bool isPublicPool;\n    }\n\n    struct Sell {\n        address payable pool;\n        address nft;\n        uint256[] tokenIds;\n        uint256[] tokenWeights;\n        PrivatePool.MerkleMultiProof proof;\n        IStolenNftOracle.Message[] stolenNftProofs;\n        bool isPublicPool;\n        bytes32[][] publicPoolProofs;\n    }\n\n    struct Change {\n        address payable pool;\n        address nft;\n        uint256[] inputTokenIds;\n        uint256[] inputTokenWeights;\n        PrivatePool.MerkleMultiProof inputProof;\n        IStolenNftOracle.Message[] stolenNftProofs;\n        uint256[] outputTokenIds;\n        uint256[] outputTokenWeights;\n        PrivatePool.MerkleMultiProof outputProof;\n    }\n\n    error DeadlinePassed();\n    error OutputAmountTooSmall();\n    error PriceOutOfRange();\n    error InvalidRoyaltyFee();\n\n    address public immutable royaltyRegistry;\n\n    receive() external payable {}\n\n    constructor(address _royaltyRegistry) {\n        royaltyRegistry = _royaltyRegistry;\n    }\n\n    /// @notice Executes a series of buy operations against public or private pools.\n    /// @param buys The buy operations to execute.\n    /// @param deadline The deadline for the transaction to be mined. Will revert if timestamp is greater than deadline.\n    /// If it's set to 0 then there is no deadline.\n    /// @param payRoyalties Whether to pay royalties or not.\n    function buy(Buy[] calldata buys, uint256 deadline, bool payRoyalties) public payable {\n        // check that the deadline has not passed (if any)\n        if (block.timestamp > deadline && deadline != 0) {\n            revert DeadlinePassed();\n        }\n\n        // loop through and execute the the buys\n        for (uint256 i = 0; i < buys.length; i++) {\n            if (buys[i].isPublicPool) {\n                // execute the buy against a public pool\n                uint256 inputAmount = Pair(buys[i].pool).nftBuy{value: buys[i].baseTokenAmount}(\n                    buys[i].tokenIds, buys[i].baseTokenAmount, 0\n                );\n\n                // pay the royalties if buyer has opted-in\n                if (payRoyalties) {\n                    uint256 salePrice = inputAmount / buys[i].tokenIds.length;\n                    for (uint256 j = 0; j < buys[i].tokenIds.length; j++) {\n                        // get the royalty fee and recipient\n                        (uint256 royaltyFee, address royaltyRecipient) =\n                            getRoyalty(buys[i].nft, buys[i].tokenIds[j], salePrice);\n\n                        if (royaltyFee > 0) {\n                            // transfer the royalty fee to the royalty recipient\n                            royaltyRecipient.safeTransferETH(royaltyFee);\n                        }\n                    }\n                }\n            } else {\n                // execute the buy against a private pool\n                PrivatePool(buys[i].pool).buy{value: buys[i].baseTokenAmount}(\n                    buys[i].tokenIds, buys[i].tokenWeights, buys[i].proof\n                );\n            }\n\n            for (uint256 j = 0; j < buys[i].tokenIds.length; j++) {\n                // transfer the NFT to the caller\n                ERC721(buys[i].nft).safeTransferFrom(address(this), msg.sender, buys[i].tokenIds[j]);\n            }\n        }\n\n        // refund any surplus ETH to the caller\n        if (address(this).balance > 0) {\n            msg.sender.safeTransferETH(address(this).balance);\n        }\n    }\n\n    /// @notice Executes a series of sell operations against public or private pools.\n    /// @param sells The sell operations to execute.\n    /// @param minOutputAmount The minimum amount of output tokens that must be received for the transaction to succeed.\n    /// @param deadline The deadline for the transaction to be mined. Will revert if timestamp is greater than deadline.\n    /// Set to 0 for there to be no deadline.\n    /// @param payRoyalties Whether to pay royalties or not.\n    func"
    }
  ]
}