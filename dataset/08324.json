{
  "Title": "[M-02] `XC20Wrapper` may lose received token forever if `LocalAsset(xc20).mint` is reverted indefinitely",
  "Content": "_Submitted by Chom_\n\n[XC20Wrapper.sol#L124-L126](https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/xc20/contracts/XC20Wrapper.sol#L124-L126)<br>\n\nXC20Wrapper may lose received token forever if LocalAsset(xc20).mint is reverted indefinitely.\n\nSimilar to ERC20, the spec said that if mint returns false it means minting is failed. But it is commonly revert instead of returning false which is also a minting failure. XC20 may revert on minting as well and common sense also guiding programmers to use the revert pattern instead of returning false.\n\nThis case is not handled if SC20 minting is reverted indefinitely. No matter how hard you retry the GMP message execution, it always fail thus the token get locked forever.\n\n### Proof of Concept\n\n        function _executeWithToken(\n            string calldata,\n            string calldata,\n            bytes calldata payload,\n            string calldata tokenSymbol,\n            uint256 amount\n        ) internal override {\n            address receiver = abi.decode(payload, (address));\n            address tokenAddress = gateway().tokenAddresses(tokenSymbol);\n            address xc20 = wrapped[tokenAddress];\n            if (xc20 == address(0) || !LocalAsset(xc20).mint(receiver, amount)) {\n                _safeTransfer(tokenAddress, receiver, amount);\n            }\n        }\n\n*   Token is sent to gateway before executing the message on the destination chain.\n*   If `_executeWithToken` fail, the token remain inside gateway. The only way to use that token is to execute the `_executeWithToken` succesfully.\n*   Assume LocalAsset(xc20).mint(...) revert indefinitely, \\_executeWithToken also revert indefinitely.\n*   As a result, `_executeWithToken` never success thus the tokens remain inside gateway forever.\n\n### Recommended Mitigation Steps\n\nUse try catch\n\n        function _executeWithToken(\n            string calldata,\n            string calldata,\n            bytes calldata payload,\n            string calldata tokenSymbol,\n            uint256 amount\n        ) internal override {\n            address receiver = abi.decode(payload, (address));\n            address tokenAddress = gateway().tokenAddresses(tokenSymbol);\n            address xc20 = wrapped[tokenAddress];\n            if (xc20 == address(0)) {\n                _safeTransfer(tokenAddress, receiver, amount);\n            }\n\n            try LocalAsset(xc20).mint(receiver, amount) returns (bool success) {\n                if (!success) _safeTransfer(tokenAddress, receiver, amount);\n            } catch { _safeTransfer(tokenAddress, receiver, amount); }\n        }\n\n**[re1ro (Axelar) acknowledged and commented](https://github.com/code-423n4/2022-07-axelar-findings/issues/176#issuecomment-1206266860):**\n > **Mitigation**<br>\n> We addressed the issue with introducing `_safeMint` function<br>\n> https://github.com/axelarnetwork/axelar-xc20-wrapper/pull/4\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-07-axelar-findings/issues/176#issuecomment-1236396995):**\n > The warden states that `mint()` may fail and cause a revert instead of returning false.\n> \n> With the code in scope we can check the used ERC20 implementation and we find:\n> \n> [ERC20.sol#L187-L188](https://github.com/code-423n4/2022-07-axelar/blob/9c4c44b94cddbd48b9baae30051a4e13cbe39539/xc20/contracts/ERC20.sol#L187-L188)<br>\n> \n> ```solidity\n>         if (account == address(0)) revert InvalidAccount();\n> \n> ```\n> \n> Because a revert can happen, the scenario, which hypothetically would brick the functionality can actually happen.\n> \n> We may also have reverts due to overflow and underflow.\n> \n> Because the code is built to assume that no revert can happen, but the warden demonstrated how a revert could factually happen, I do agree with Medium Severity.\n> \n> The sponsor has mitigated by using `_safeMint`.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-07-axelar",
  "Code": [
    {
      "filename": "xc20/contracts/XC20Wrapper.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IERC20 } from './interfaces/IERC20.sol';\nimport { AxelarExecutable } from '@axelar-network/axelar-utils-solidity/contracts/executables/AxelarExecutable.sol';\nimport { IAxelarGateway } from '@axelar-network/axelar-utils-solidity/contracts/interfaces/IAxelarGateway.sol';\nimport './Upgradable.sol';\nimport { LocalAsset } from './interfaces/LocalAsset.sol';\n\ncontract XC20Wrapper is AxelarExecutable, Upgradable {\n    error TransferFailed();\n    error NotAxelarToken();\n    error NotXc20Token();\n    error InsufficientBalance();\n    error AlreadyWrappingAxelarToken();\n    error AlreadyWrappingXC20Token();\n    error NotOwnerOfXc20();\n\n    mapping(address => address) public wrapped;\n    mapping(address => address) public unwrapped;\n\n    bytes32 public xc20Codehash;\n    address public immutable gatewayAddress;\n\n    constructor(address gatewayAddress_) {\n        gatewayAddress = gatewayAddress_;\n    }\n\n    function gateway() public view override returns (IAxelarGateway) {\n        return IAxelarGateway(gatewayAddress);\n    }\n\n    function _setup(bytes calldata data) internal override {\n        (address owner_, bytes32 codehash_) = abi.decode(data, (address, bytes32));\n        _transferOwnership(owner_);\n        xc20Codehash = codehash_;\n    }\n\n    function contractId() public pure returns (bytes32) {\n        return keccak256('xc20-wrapper');\n    }\n\n    function setXc20Codehash(bytes32 newCodehash) external onlyOwner {\n        xc20Codehash = newCodehash;\n    }\n\n    function addWrapping(\n        string calldata symbol,\n        address xc20Token,\n        string memory newName,\n        string memory newSymbol\n    ) external payable onlyOwner {\n        address axelarToken = gateway().tokenAddresses(symbol);\n        if (axelarToken == address(0)) revert('NotAxelarToken()');\n        if (xc20Token.codehash != xc20Codehash) revert('NotXc20Token()');\n        if (wrapped[axelarToken] != address(0)) revert('AlreadyWrappingAxelarToken()');\n        if (unwrapped[xc20Token] != address(0)) revert('AlreadyWrappingXC20Token()');\n        wrapped[axelarToken] = xc20Token;\n        unwrapped[xc20Token] = axelarToken;\n        if (!LocalAsset(xc20Token).set_team(address(this), address(this), address(this))) revert('NotOwner()');\n        if (!LocalAsset(xc20Token).set_metadata(newName, newSymbol, IERC20(axelarToken).decimals())) revert('CannotSetMetadata()');\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    function removeWrapping(string calldata symbol) external onlyOwner {\n        address axelarToken = gateway().tokenAddresses(symbol);\n        if (axelarToken == address(0)) revert('NotAxelarToken()');\n        address xc20Token = wrapped[axelarToken];\n        if (xc20Token == address(0)) revert('NotWrappingToken()');\n        wrapped[axelarToken] = address(0);\n        unwrapped[xc20Token] = address(0);\n    }\n\n    function wrap(address axelarToken, uint256 amount) external {\n        _safeTransferFrom(axelarToken, msg.sender, amount);\n        address wrappedToken = wrapped[axelarToken];\n        if (wrappedToken == address(0)) revert('NotAxelarToken()');\n        if (!LocalAsset(wrappedToken).mint(msg.sender, amount)) revert('CannotMint()');\n    }\n\n    function unwrap(address wrappedToken, uint256 amount) external {\n        address axelarToken = unwrapped[wrappedToken];\n        if (axelarToken == address(0)) revert('NotXc20Token()');\n        if (IERC20(wrappedToken).balanceOf(msg.sender) < amount) revert('InsufficientBalance()');\n        if (!LocalAsset(wrappedToken).burn(msg.sender, amount)) revert('CannotBurn()');\n        _safeTransfer(axelarToken, msg.sender, amount);\n    }\n\n    function _safeTransfer(\n        address tokenAddress,\n        address receiver,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory returnData) = tokenAddress.call(abi.encodeWithSelector(IERC20.transfer.selector, receiver, amount));\n        bool transferred = success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\n\n        if (!transferred || tokenAddress.code.length == 0) revert('TransferFailed()');\n    }\n\n    function _safeTransferFrom(\n        address tokenAddress,\n        address from,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory returnData) = tokenAddress.call(\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, address(this), amount)\n        );\n        bool transferred = success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\n\n        if (!transferred || tokenAddress.code.length == 0) revert('TransferFailed()');\n    }\n\n    function _executeWithToken(\n        string calldata,\n        string calldata,\n        bytes calldata payload,\n        string calldata tokenSymbol,\n        uint256 amount\n    ) internal override {\n        address receiver = abi.decode(payload, (address));\n        address tokenAddress = gateway().tokenAddresses(tokenSymbol);\n        address xc20 = wrapped[tokenAddress];\n        if (xc20 == address(0) || !LocalAsset(xc20).mint(receiver, amount)) {\n            _safeTransfer(tokenAddress, receiver, amount);\n        }\n    }\n}"
    },
    {
      "filename": "xc20/contracts/ERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IERC20 } from './interfaces/IERC20.sol';\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is IERC20 {\n    mapping(address => uint256) public override balanceOf;\n\n    mapping(address => mapping(address => uint256)) public override allowance;\n\n    uint256 public override totalSupply;\n\n    string public name;\n    string public symbol;\n\n    uint8 public decimals;\n\n    /**\n     * @dev Sets the values for {name}, {symbol}, and {decimals}.\n     */\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) {\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) external virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) external virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external virtual override returns (bool) {\n        uint256 _allowance = allowance[sender][msg.sender];\n\n        if (_allowance != type(uint256).max) {\n            _approve(sender, msg.sender, _allowance - amount);\n        }\n\n        _transfer(sender, recipient, amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {\n        _approve(msg.sender, spender, allowance[msg.sender][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {\n        _approve(msg.sender, spender, allowance[msg.sender][spender] - subtractedValue);\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        if (sender == address(0) || recipient == address(0)) revert InvalidAccount();\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        balanceOf[sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        if (account == address(0)) revert InvalidAccount();\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        totalSupply += amount;\n        balanceOf[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        if (account == address(0)) revert InvalidAccount();\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        balanceOf[account] -= amount;\n        totalSupply -= amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        if (owner == address(0) || spender == address(0)) revert InvalidAccount();\n\n        allowance[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}"
    }
  ]
}