{
  "Title": "M-6: Sense PT redemptions do not allow for known loss scenarios",
  "Content": "# Issue M-6: Sense PT redemptions do not allow for known loss scenarios \n\nSource: https://github.com/sherlock-audit/2022-10-illuminate-judging/issues/111 \n\n## Found by \nIllIllI\n\n## Summary\n\nSense PT redemptions do not allow for known loss scenarios, which will lead to principal losses\n\n\n## Vulnerability Detail\n\nThe Sense PT redemption code in the `Redeemer` expects any losses during redemption to be due to a malicious adapter, and requires that there be no losses. However, there are legitimate reasons for there to be losses which aren't accounted for, which will cause the PTs to be unredeemable. The Lido FAQ page lists two such reasons:\n\n```markdown\n- Slashing risk\n\nETH 2.0 validators risk staking penalties, with up to 100% of staked funds at risk if validators fail. To minimise this risk, Lido stakes across multiple professional and reputable node operators with heterogeneous setups, with additional mitigation in the form of insurance that is paid from Lido fees.\n\n- stETH price risk\n\nUsers risk an exchange price of stETH which is lower than inherent value due to withdrawal restrictions on Lido, making arbitrage and risk-free market-making impossible. \n\nThe Lido DAO is driven to mitigate above risks and eliminate them entirely to the extent possible. Despite this, they may still exist and, as such, it is our duty to communicate them.\n```\nhttps://help.lido.fi/en/articles/5230603-what-are-the-risks-of-staking-with-lido\n\nIf Lido is slashed, or there are withdrawal restrictions, the Sense series sponsor will be forced to settle the series, regardless of the exchange rate (or miss out on their [rewards](https://github.com/sense-finance/sense-v1/blob/b71a728e7ce968220860d8bffcaad1c24830fdd0/pkg/core/src/Divider.sol#L181)). The Sense `Divider` contract anticipates and [properly handles](https://github.com/sense-finance/sense-v1/blob/b71a728e7ce968220860d8bffcaad1c24830fdd0/pkg/core/src/Divider.sol#L322-L328) these losses, but the Illuminate code does not.\n\nLido is just one example of a Sense token that exists in the Illuminate code base - there may be others added in the future which also require there to be allowances for losses.\n\n\n## Impact\n\n_Permanent freezing of funds_\n\nThere may be a malicious series sponsor that purposely triggers a loss, either by DOSing Lido validators, or by withdrawing enough to trigger withdrawal restrictions. In such a case, the exchange rate stored by Sense during the settlement will lead to losses, and users that hold Illumimate PTs (not just the users that minted Illuminate PTs with Sense PTs), will lose their principal, because Illuminate PT redemptions are an a share-of-underlying basis, not on the basis of the originally-provided token.\n\nWhile the Illuminate project does have an emergency `withdraw()` function that would allow an admin to rescue the funds and manually distribute them, this would not be trustless and defeats the purpose of having a smart contract.\n\n\n## Code Snippet\n\nThe Sense adapter specifically used in the Illuminate tests is the one that corresponds to wstETH:\n```solidity\n// File: test/fork/Contracts.sol    #1\n36    // (sense adapter)\n37    // NOTE for sense, we have to use the adapter contract to verify the underlying/maturity\n38    // NOTE also we had to use the wsteth pools.... (maturity: 1659312000)\n39:    address constant SENSE_ADAPTER = 0x880E5caBB22D24F3E278C4C760e763f239AccA95;\n```\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/test/fork/Contracts.sol#L36-L39\n\n\nThe code for the redemption of the Sense PTs assumes that one PT equals at least one underlying, which may not be the case:\n```solidity\n// File: src/Redeemer.sol : Redeemer.redeem()   #2\n360            // Get the balance of tokens to be redeemed by the user\n361            uint256 amount = token.balanceOf(cachedLender);\n...\n379            IConverter(converter).convert(\n380                compounding,\n381                u,\n382                IERC20(compounding).balanceOf(address(this))\n383            );\n384    \n385            // Get the amount received\n386            uint256 redeemed = IERC20(u).balanceOf(address(this)) - starting;\n387    \n388 @>         // Verify that underlying are received 1:1 - cannot trust the adapter\n389 @>         if (redeemed < amount) {\n390 @>             revert Exception(13, 0, 0, address(0), address(0));\n391            }\n392    \n393            // Update the holdings for this market\n394            holdings[u][m] = holdings[u][m] + redeemed;\n395    \n396            emit Redeem(p, u, m, redeemed, msg.sender);\n397            return true;\n398:       }\n```\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Redeemer.sol#L360-L398\n\nRedemptions of Illuminate PTs for underlyings is based on shares of each Illuminate PT's `totalSupply()` of the _available_ underlying, not the expect underlying total:\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Redeemer.sol#L422\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Redeemer.sol#L464\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Redeemer.sol#L517\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\nAllow losses during redemption if Sense's [`Periphery.verified()`](https://github.com/sense-finance/sense-v1/blob/b71a728e7ce968220860d8bffcaad1c24830fdd0/pkg/core/src/Periphery.sol#L60-L61) returns `true`\n\n\n\n## Discussion\n\n**sourabhmarathe**\n\nI agree with the stated problem from this report, the only thing I would change about the Recommendation is that we can check is if the Lender contract has approved the periphery.\n\n**JTraversa**\n\nHah i find this one kinda funny since another of your tickets recommended doing the opposite and ensuring yield can never be negative.\n\nBuuut i would clarify here that were are not discussing the stETH <-> ETH conversion rates but strictly the actual stETH yields.\n\nSo yes, they can be negative should slashing exceed yields, but Lido has historically been nowhere close to this outside of tiny (~1 minutes?) periods. (Even then i am unsure if lido has been slashed yet / I might be confusing them with another staking service) \n\nGiven we have terms of 3+ months, it is extremely unrealistic for this to ever have any impact.\n\nSo I would vaguely accept the issue (to align with my report on the other negative yield ticket), and then definitely downgrade this to medium at most, perhaps low.\n\n**0x00052**\n\nEscalate for 1 USDC\n\nReminder @Evert0x\n\n**sherlock-admin**\n\n > Escalate for 1 USDC\n> \n> Reminder @Evert0x\n\nYou've created a valid escalation for 1 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**KenzoAgada**\n\nEscalate for 40 USDC\nSee sponsor's comments. Seems like unlikely external conditions are needed so this might be better described as medium severity.\n\n**sherlock-admin**\n\n > Escalate for 40 USDC\n> See sponsor's comments. Seems like unlikely external conditions are needed so this might be better described as medium severity.\n\nYou've created a valid escalation for 40 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation accepted\n\n**sherlock-admin**\n\n> Escalation accepted\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/12",
  "Code": [
    {
      "filename": "pkg/core/src/Divider.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.13;\n\n// External references\nimport { Pausable } from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport { ERC20 } from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\nimport { SafeTransferLib } from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\nimport { ReentrancyGuard } from \"@rari-capital/solmate/src/utils/ReentrancyGuard.sol\";\nimport { DateTime } from \"./external/DateTime.sol\";\nimport { FixedMath } from \"./external/FixedMath.sol\";\n\n// Internal references\nimport { Errors } from \"@sense-finance/v1-utils/src/libs/Errors.sol\";\n\nimport { Levels } from \"@sense-finance/v1-utils/src/libs/Levels.sol\";\nimport { Trust } from \"@sense-finance/v1-utils/src/Trust.sol\";\nimport { YT } from \"./tokens/YT.sol\";\nimport { Token } from \"./tokens/Token.sol\";\nimport { BaseAdapter as Adapter } from \"./adapters/abstract/BaseAdapter.sol\";\n\n/// @title Sense Divider: Divide Assets in Two\n/// @author fedealconada + jparklev\n/// @notice You can use this contract to issue, combine, and redeem Sense ERC20 Principal and Yield Tokens\ncontract Divider is Trust, ReentrancyGuard, Pausable {\n    using SafeTransferLib for ERC20;\n    using FixedMath for uint256;\n    using Levels for uint256;\n\n    /* ========== PUBLIC CONSTANTS ========== */\n\n    /// @notice Buffer before and after the actual maturity in which only the sponsor can settle the Series\n    uint256 public constant SPONSOR_WINDOW = 3 hours;\n\n    /// @notice Buffer after the sponsor window in which anyone can settle the Series\n    uint256 public constant SETTLEMENT_WINDOW = 3 hours;\n\n    /// @notice 5% issuance fee cap\n    uint256 public constant ISSUANCE_FEE_CAP = 0.05e18;\n\n    /* ========== PUBLIC MUTABLE STORAGE ========== */\n\n    address public periphery;\n\n    /// @notice Sense community multisig\n    address public immutable cup;\n\n    /// @notice Principal/Yield tokens deployer\n    address public immutable tokenHandler;\n\n    /// @notice Permissionless flag\n    bool public permissionless;\n\n    /// @notice Guarded launch flag\n    bool public guarded = true;\n\n    /// @notice Number of adapters (including turned off)\n    uint248 public adapterCounter;\n\n    /// @notice adapter ID -> adapter address\n    mapping(uint256 => address) public adapterAddresses;\n\n    /// @notice adapter data\n    mapping(address => AdapterMeta) public adapterMeta;\n\n    /// @notice adapter -> maturity -> Series\n    mapping(address => mapping(uint256 => Series)) public series;\n\n    /// @notice adapter -> maturity -> user -> lscale (last scale)\n    mapping(address => mapping(uint256 => mapping(address => uint256))) public lscales;\n\n    /* ========== DATA STRUCTURES ========== */\n\n    struct Series {\n        // Principal ERC20 token\n        address pt;\n        // Timestamp of series initialization\n        uint48 issuance;\n        // Yield ERC20 token\n        address yt;\n        // % of underlying principal initially reserved for Yield\n        uint96 tilt;\n        // Actor who initialized the Series\n        address sponsor;\n        // Tracks fees due to the series' settler\n        uint256 reward;\n        // Scale at issuance\n        uint256 iscale;\n        // Scale at maturity\n        uint256 mscale;\n        // Max scale value from this series' lifetime\n        uint256 maxscale;\n    }\n\n    struct AdapterMeta {\n        // Adapter ID\n        uint248 id;\n        // Adapter enabled/disabled\n        bool enabled;\n        // Max amount of Target allowed to be issued\n        uint256 guard;\n        // Adapter level\n        uint248 level;\n    }\n\n    constructor(address _cup, address _tokenHandler) Trust(msg.sender) {\n        cup = _cup;\n        tokenHandler = _tokenHandler;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /// @notice Enable an adapter\n    /// @dev when permissionless is disabled, only the Periphery can onboard adapters\n    /// @dev after permissionless is enabled, anyone can onboard adapters\n    /// @param adapter Adapter's address\n    function addAdapter(address adapter) external whenNotPaused {\n        if (!permissionless && msg.sender != periphery) revert Errors.OnlyPermissionless();\n        if (adapterMeta[adapter].id > 0 && !adapterMeta[adapter].enabled) revert Errors.InvalidAdapter();\n        _setAdapter(adapter, true);\n    }\n\n    /// @notice Initializes a new Series\n    /// @dev Deploys two ERC20 contracts, one for PTs and the other one for YTs\n    /// @dev Transfers some fixed amount of stake asset to this contract\n    /// @param adapter Adapter to associate with the Series\n    /// @param maturity Maturity date for the new Series, in units of unix time\n    /// @param sponsor Sponsor of the Series that puts up a token stake and receives the issuance fees\n    function initSeries(\n        address adapter,\n        uint256 maturity,\n        address sponsor\n    ) external nonReentrant whenNotPaused returns (address pt, address yt) {\n        if (periphery != msg.sender) revert Errors.OnlyPeriphery();\n        if (!adapterMeta[adapter].enabled) revert Errors.InvalidAdapter();\n        if (_exists(adapter, maturity)) revert Errors.DuplicateSeries();\n        if (!_isValid(adapter, maturity)) revert Errors.InvalidMaturity();\n\n        // Transfer stake asset stake from caller to adapter\n        (address target, address stake, uint256 stakeSize) = Adapter(adapter).getStakeAndTarget();\n\n        // Deploy Principal & Yield Tokens for this new Series\n        (pt, yt) = TokenHandler(tokenHandler).deploy(adapter, adapterMeta[adapter].id, maturity);\n\n        // Initialize the new Series struct\n        uint256 scale = Adapter(adapter).scale();\n\n        series[adapter][maturity].pt = pt;\n        series[adapter][maturity].issuance = uint48(block.timestamp);\n        series[adapter][maturity].yt = yt;\n        series[adapter][maturity].tilt = uint96(Adapter(adapter).tilt());\n        series[adapter][maturity].sponsor = sponsor;\n        series[adapter][maturity].iscale = scale;\n        series[adapter][maturity].maxscale = scale;\n\n        ERC20(stake).safeTransferFrom(msg.sender, adapter, stakeSize);\n\n        emit SeriesInitialized(adapter, maturity, pt, yt, sponsor, target);\n    }\n\n    /// @notice Settles a Series and transfers the settlement reward to the caller\n    /// @dev The Series' sponsor has a grace period where only they can settle the Series\n    /// @dev After that, the reward becomes MEV\n    /// @param adapter Adapter to associate with the Series\n    /// @param maturity Maturity date for the new Series\n    function settleSeries(address adapter, uint256 maturity) external nonReentrant whenNotPaused {\n        if (!adapterMeta[adapter].enabled) revert Errors.InvalidAdapter();\n        if (!_exists(adapter, maturity)) revert Errors.SeriesDoesNotExist();\n        if (_settled(adapter, maturity)) revert Errors.AlreadySettled();\n        if (!_canBeSettled(adapter, maturity)) revert Errors.OutOfWindowBoundaries();\n\n        // The maturity scale value is all a Series needs for us to consider it \"settled\"\n        uint256 mscale = Adapter(adapter).scale();\n        series[adapter][maturity].mscale = mscale;\n\n        if (mscale > series[adapter][maturity].maxscale) {\n            series[adapter][maturity].maxscale = mscale;\n        }\n\n        // Reward the caller for doing the work of settling the Series at around the correct time\n        (address target, address stake, uint256 stakeSize) = Adapter(adapter).getStakeAndTarget();\n        ERC20(target).safeTransferFrom(adapter, msg.sender, series[adapter][maturity].reward);\n        ERC20(stake).safeTransferFrom(adapter, msg.sender, stakeSize);\n\n        emit SeriesSettled(adapter, maturity, msg.sender);\n    }\n\n    /// @notice Mint Principal & Yield Tokens of a specific Series\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series [unix time]\n    /// @param tBal Balance of Target to deposit\n    /// @dev The balance of PTs and YTs minted will be the same value in units of underlying (less fees)\n    function issue(\n        address adapter,\n        uint256 maturity,\n        uint256 tBal\n    ) external nonReentrant whenNotPaused returns (uint256 uBal) {\n        if (!adapterMeta[adapter].enabled) revert Errors.InvalidAdapter();\n        if (!_exists(adapter, maturity)) revert Errors.SeriesDoesNotExist();\n        if (_settled(adapter, maturity)) revert Errors.IssueOnSettle();\n\n        uint256 level = adapterMeta[adapter].level;\n        if (level.issueRestricted() && msg.sender != adapter) revert Errors.IssuanceRestricted();\n\n        ERC20 target = ERC20(Adapter(adapter).target());\n\n        // Take the issuance fee out of the deposited Target, and put it towards the settlement reward\n        uint256 issuanceFee = Adapter(adapter).ifee();\n        if (issuanceFee > ISSUANCE_FEE_CAP) revert Errors.IssuanceFeeCapExceeded();\n        uint256 fee = tBal.fmul(issuanceFee);\n\n        unchecked {\n            // Safety: bounded by the Target's total token supply\n            series[adapter][maturity].reward += fee;\n        }\n        uint256 tBalSubFee = tBal - fee;\n\n        // Ensure the caller won't hit the issuance cap with this action\n        unchecked {\n            // Safety: bounded by the Target's total token supply\n            if (guarded && target.balanceOf(adapter) + tBal > adapterMeta[address(adapter)].guard)\n                revert Errors.GuardCapReached();\n        }\n\n        // Update values on adapter\n        Adapter(adapter).notify(msg.sender, tBalSubFee, true);\n\n        uint256 scale = level.collectDisabled() ? series[adapter][maturity].iscale : Adapter(adapter).scale();\n\n        // Determine the amount of Underlying equal to the Target being sent in (the principal)\n        uBal = tBalSubFee.fmul(scale);\n\n        // If the caller has not collected on YT before, use the current scale, otherwise\n        // use the harmonic mean of the last and the current scale value\n        lscales[adapter][maturity][msg.sender] = lscales[adapter][maturity][msg.sender] == 0\n            ? scale\n            : _reweightLScale(\n                adapter,\n                maturity,\n                YT(series[adapter][maturity].yt).balanceOf(msg.sender),\n                uBal,\n                msg.sender,\n                scale\n            );\n\n        // Mint equal amounts of PT and YT\n        Token(series[adapter][maturity].pt).mint(msg.sender, uBal);\n        YT(series[adapter][maturity].yt).mint(msg.sender, uBal);\n\n        target.safeTransferFrom(msg.sender, adapter, tBal);\n\n        emit Issued(adapter, maturity, uBal, msg.sender);\n    }\n\n    /// @notice Reconstitute Target by burning PT and YT\n    /// @dev Explicitly burns YTs before maturity, and implicitly does it at/after maturity through `_collect()`\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param uBal Balance of PT and YT to burn\n    function combine(\n        address adapter,\n        uint256 maturity,\n        uint256 uBal\n    ) external nonReentrant whenNotPaused returns (uint256 tBal) {\n        if (!adapterMeta[adapter].enabled) revert Errors.InvalidAdapter();\n        if (!_exists(adapter, maturity)) revert Errors.SeriesDoesNotExist();\n\n        uint256 level = adapterMeta[adapter].level;\n        if (level.combineRestricted() && msg.sender != adapter) revert Errors.CombineRestricted();\n\n        // Burn the PT\n        Token(series[adapter][maturity].pt).burn(msg.sender, uBal);\n\n        // Collect whatever excess is due\n        uint256 collected = _collect(msg.sender, adapter, maturity, uBal, uBal, address(0));\n\n        uint256 cscale = series[adapter][maturity].mscale;\n        bool settled = _settled(adapter, maturity);\n        if (!settled) {\n            // If it's not settled, then YT won't be burned automatically in `_collect()`\n            YT(series[adapter][maturity].yt).burn(msg.sender, uBal);\n            // If collect has been restricted, use the initial scale, otherwise use the current scale\n            cscale = level.collectDisabled()\n                ? series[adapter][maturity].iscale\n                : lscales[adapter][maturity][msg.sender];\n        }\n\n        // Convert from units of Underlying to units of Target\n        tBal = uBal.fdiv(cscale);\n        ERC20(Adapter(adapter).target()).safeTransferFrom(adapter, msg.sender, tBal);\n\n        // Notify only when Series is not settled as when it is, the _collect() call above would trigger a _redeemYT which will call notify\n        if (!settled) Adapter(adapter).notify(msg.sender, tBal, false);\n        unchecked {\n            // Safety: bounded by the Target's total token supply\n            tBal += collected;\n        }\n        emit Combined(adapter, maturity, tBal, msg.sender);\n    }\n\n    /// @notice Burn PT of a Series once it's been settled\n    /// @dev The balance of redeemable Target is a function of the change in Scale\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param uBal Amount of PT to burn, which should be equivalent to the amount of Underlying owed to the caller\n    function redeem(\n        address adapter,\n        uint256 maturity,\n        uint256 uBal\n    ) external nonReentrant whenNotPaused returns (uint256 tBal) {\n        // If a Series is settled, we know that it must have existed as well, so that check is unnecessary\n        if (!_settled(adapter, maturity)) revert Errors.NotSettled();\n\n        uint256 level = adapterMeta[adapter].level;\n        if (level.redeemRestricted() && msg.sender != adapter) revert Errors.RedeemRestricted();\n\n        // Burn the caller's PT\n        Token(series[adapter][maturity].pt).burn(msg.sender, uBal);\n\n        // Principal Token holder's share of the principal = (1 - part of the principal that belongs to Yield)\n        uint256 zShare = FixedMath.WAD - series[adapter][maturity].tilt;\n\n        // If Principal Token are at a loss and Yield have some principal to help cover the shortfall,\n        // take what we can from Yield Token's principal\n        if (series[adapter][maturity].mscale.fdiv(series[adapter][maturity].maxscale) >= zShare) {\n            tBal = (uBal * zShare) / series[adapter][maturity].mscale;\n        } else {\n            tBal = uBal.fdiv(series[adapter][maturity].maxscale);\n        }\n\n        if (!level.redeemHookDisabled()) {\n            Adapter(adapter).onRedeem(uBal, series[adapter][maturity].mscale, series[adapter][maturity].maxscale, tBal);\n        }\n\n        ERC20(Adapter(adapter).target()).safeTransferFrom(adapter, msg.sender, tBal);\n        emit PTRedeemed(adapter, maturity, tBal);\n    }\n\n    function collect(\n        address usr,\n        address adapter,\n        uint256 maturity,\n        uint256 uBalTransfer,\n        address to\n    ) external nonReentrant onlyYT(adapter, maturity) whenNotPaused returns (uint256 collected) {\n        uint256 uBal = YT(msg.sender).balanceOf(usr);\n        return _collect(usr, adapter, maturity, uBal, uBalTransfer > 0 ? uBalTransfer : uBal, to);\n    }\n\n    /// @notice Collect YT excess before, at, or after maturity\n    /// @dev If `to` is set, we copy the lscale value from usr to this address\n    /// @param usr User who's collecting for their YTs\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param uBal yield Token balance\n    /// @param uBalTransfer original transfer value\n    /// @param to address to set the lscale value from usr\n    function _collect(\n        address usr,\n        address adapter,\n        uint256 maturity,\n        uint256 uBal,\n        uint256 uBalTransfer,\n        address to\n    ) internal returns (uint256 collected) {\n        if (!_exists(adapter, maturity)) revert Errors.SeriesDoesNotExist();\n\n        // If the adapter is disabled, its Yield Token can only collect\n        // if associated Series has been settled, which implies that an admin\n        // has backfilled it\n        if (!adapterMeta[adapter].enabled && !_settled(adapter, maturity)) revert Errors.InvalidAdapter();\n\n        Series memory _series = series[adapter][maturity];\n\n        // Get the scale value from the last time this holder collected (default to maturity)\n        uint256 lscale = lscales[adapter][maturity][usr];\n\n        uint256 level = adapterMeta[adapter].level;\n        if (level.collectDisabled()) {\n            // If this Series has been settled, we ensure everyone's YT will\n            // collect yield accrued since issuance\n            if (_settled(adapter, maturity)) {\n                lscale = series[adapter][maturity].iscale;\n                // If the Series is not settled, we ensure no collections can happen\n            } else {\n                return 0;\n            }\n        }\n\n        // If the Series has been settled, this should be their last collect, so redeem the user's Yield Tokens for them\n        if (_settled(adapter, maturity)) {\n            _redeemYT(usr, adapter, maturity, uBal);\n        } else {\n            // If we're not settled and we're past maturity + the sponsor window,\n            // anyone can settle this Series so revert until someone does\n            if (block.timestamp > maturity + SPONSOR_WINDOW) {\n                revert Errors.CollectNotSettled();\n                // Otherwise, this is a valid pre-settlement collect and we need to determine the scale value\n            } else {\n                uint256 cscale = Adapter(adapter).scale();\n                // If this is larger than the largest scale we've seen for this Series, use it\n                if (cscale > _series.maxscale) {\n                    _series.maxscale = cscale;\n                    lscales[adapter][maturity][usr] = cscale;\n                    // If not, use the previously noted max scale value\n                } else {\n                    lscales[adapter][maturity][usr] = _series.maxscale;\n                }\n            }\n        }\n\n        // Determine how much underlying has accrued since the last time this user collected, in units of Target.\n        // (Or take the last time as issuance if they haven't yet)\n        //\n        // Reminder: `Underlying / Scale = Target`\n        // So the following equation is saying, for some amount of Underlying `u`:\n        // \"Balance of Target that equaled `u` at the last collection _minus_ Target that equals `u` now\"\n        //\n        // Because maxscale must be increasing, the Target balance needed to equal `u` decreases, and that \"excess\"\n        // is what Yield holders are collecting\n        uint256 tBalNow = uBal.fdivUp(_series.maxscale); // preventive round-up towards the protocol\n        uint256 tBalPrev = uBal.fdiv(lscale);\n        unchecked {\n            collected = tBalPrev > tBalNow ? tBalPrev - tBalNow : 0;\n        }\n        ERC20(Adapter(adapter).target()).safeTransferFrom(adapter, usr, collected);\n        Adapter(adapter).notify(usr, collected, false); // Distribute reward tokens\n\n        // If this collect is a part of a token transfer to another address, set the receiver's\n        // last collection to a synthetic scale weighted based on the scale on their last collect,\n        // the time elapsed, and the current scale\n        if (to != address(0)) {\n            uint256 ytBal = YT(_series.yt).balanceOf(to);\n            // If receiver holds yields, we set lscale to a computed \"synthetic\" lscales value that,\n            // for the updated yield balance, still assigns the correct amount of yield.\n            lscales[adapter][maturity][to] = ytBal > 0\n                ? _reweightLScale(adapter, maturity, ytBal, uBalTransfer, to, _series.maxscale)\n                : _series.maxscale;\n            uint256 tBalTransfer = uBalTransfer.fdiv(_series.maxscale);\n            Adapter(adapter).notify(usr, tBalTransfer, false);\n            Adapter(adapter).notify(to, tBalTransfer, true);\n        }\n        series[adapter][maturity] = _series;\n\n        emit Collected(adapter, maturity, collected);\n    }\n\n    /// @notice calculate the harmonic mean of the current scale and the last scale,\n    /// weighted by amounts associated with each\n    function _reweightLScale(\n        address adapter,\n        uint256 maturity,\n        uint256 ytBal,\n        uint256 uBal,\n        address receiver,\n        uint256 scale\n    ) internal view returns (uint256) {\n        // Target Decimals * 18 Decimals [from fdiv] / (Target Decimals * 18 Decimals [from fdiv] / 18 Decimals)\n        // = 18 Decimals, which is the standard for scale values\n        return (ytBal + uBal).fdiv((ytBal.fdiv(lscales[adapter][maturity][receiver]) + uBal.fdiv(scale)));\n    }\n\n    function _redeemYT(\n        address usr,\n        address adapter,\n        uint256 maturity,\n        uint256 uBal\n    ) internal {\n        // Burn the users's YTs\n        YT(series[adapter][maturity].yt).burn(usr, uBal);\n\n        // Default principal for a YT\n        uint256 tBal = 0;\n\n        // Principal Token holder's share of the principal = (1 - part of the principal that belongs to Yield Tokens)\n        uint256 zShare = FixedMath.WAD - series[adapter][maturity].tilt;\n\n        // If PTs are at a loss and YTs had their principal cut to help cover the shortfall,\n        // calculate how much YTs have left\n        if (series[adapter][maturity].mscale.fdiv(series[adapter][maturity].maxscale) >= zShare) {\n            tBal = uBal.fdiv(series[adapter][maturity].maxscale) - (uBal * zShare) / series[adapter][maturity].mscale;\n            ERC20(Adapter(adapter).target()).safeTransferFrom(adapter, usr, tBal);\n        }\n\n        // Always notify the Adapter of the full Target balance that will no longer\n        // have its rewards distributed\n        Adapter(adapter).notify(usr, uBal.fdivUp(series[adapter][maturity].maxscale), false);\n\n        emit YTRedeemed(adapter, maturity, tBal);\n    }\n\n    /* ========== ADMIN ========== */\n\n    /// @notice Enable or disable a adapter\n    /// @param adapter Adapter's address\n    /// @param isOn Flag setting this adapter to enabled or disabled\n    function setAdapter(address adapter, bool isOn) public requiresTrust {\n        _setAdapter(adapter, isOn);\n    }\n\n    /// @notice Set adapter's guard\n    /// @param adapter Adapter address\n    /// @param cap The max target that can be deposited on the Adapter\n    function setGuard(address adapter, uint256 cap) external requiresTrust {\n        adapterMeta[adapter].guard = cap;\n        emit GuardChanged(adapter, cap);\n    }\n\n    /// @notice Set guarded mode\n    /// @param _guarded bool\n    function setGuarded(bool _guarded) external requiresTrust {\n        guarded = _guarded;\n        emit GuardedChanged(_guarded);\n    }\n\n    /// @notice Set periphery's contract\n    /// @param _periphery Target address\n    function setPeriphery(address _periphery) external requiresTrust {\n        periphery = _periphery;\n        emit PeripheryChanged(_periphery);\n    }\n\n    /// @notice Set paused flag\n    /// @param _paused boolean\n    function setPaused(bool _paused) external requiresTrust {\n        _paused ? _pause() : _unpause();\n    }\n\n    /// @notice Set permissioless mode\n    /// @param _permissionless bool\n    function setPermissionless(bool _permissionless) external requiresTrust {\n        permissionless = _permissionless;\n        emit PermissionlessChanged(_permissionless);\n    }\n\n    /// @notice Backfill a Series' Scale value at maturity if keepers failed to settle it\n    /// @param adapter Adapter's address\n    /// @param maturity Maturity date for the Series\n    /// @param mscale Value to set as the Series' Scale value at maturity\n    /// @param _usrs Values to set on lscales mapping\n    /// @param _lscales Values to set on lscales mapping\n    function backfillScale(\n        address adapter,\n        uint256 maturity,\n        uint256 mscale,\n        address[] calldata _usrs,\n        uint256[] calldata _lscales\n    ) external requiresTrust {\n        if (!_exists(adapter, maturity)) revert Errors.SeriesDoesNotExist();\n\n        uint256 cutoff = maturity + SPONSOR_WINDOW + SETTLEMENT_WINDOW;\n        // Admin can never backfill before maturity\n        if (block.timestamp <= cutoff) revert Errors.OutOfWindowBoundaries();\n\n        // Set user's last scale values the Series (needed for the `collect` method)\n        for (uint256 i = 0; i < _usrs.length; i++) {\n            lscales[adapter][maturity][_usrs[i]] = _lscales[i];\n        }\n\n        if (mscale > 0) {\n            Series memory _series = series[adapter][maturity];\n            // Set the maturity scale for the Series (needed for `redeem` methods)\n            series[adapter][maturity].mscale = mscale;\n            if (mscale > _series.maxscale) {\n                series[adapter][maturity].maxscale = mscale;\n            }\n\n            (address target, address stake, uint256 stakeSize) = Adapter(adapter).getStakeAndTarget();\n\n            address stakeDst = adapterMeta[adapter].enabled ? cup : _series.sponsor;\n            ERC20(target).safeTransferFrom(adapter, cup, _series.reward);\n            series[adapter][maturity].reward = 0;\n            ERC20(stake).safeTransferFrom(adapter, stakeDst, stakeSize);\n        }\n\n        emit Backfilled(adapter, maturity, mscale, _usrs, _lscales);\n    }\n\n    /* ========== INTERNAL VIEWS ========== */\n\n    function _exists(address adapter, uint256 maturity) internal view returns (bool) {\n        return series[adapter][maturity].pt != address(0);\n    }\n\n    function _settled(address adapter, uint256 maturity) internal view returns (bool) {\n        return series[adapter][maturity].mscale > 0;\n    }\n\n    function _canBeSettled(address adapter, uint256 maturity) internal view returns (bool) {\n        uint256 cutoff = maturity + SPONSOR_WINDOW + SETTLEMENT_WINDOW;\n        // If the sender is the sponsor for the Series\n        if (msg.sender == series[adapter][maturity].sponsor) {\n            return maturity - SPONSOR_WINDOW <= block.timestamp && cutoff >= block.timestamp;\n        } else {\n            return maturity + SPONSOR_WINDOW < block.timestamp && cutoff >= block.timestamp;\n        }\n    }\n\n    function _isValid(address adapter, uint256 maturity) internal view returns (bool) {\n        (uint256 minm, uint256 maxm) = Adapter(adapter).getMaturityBounds();\n        if (maturity < block.timestamp + minm || maturity > block.timestamp + maxm) return false;\n        (, , uint256 day, uint256 hour, uint256 minute, uint256 second) = DateTime.timestampToDateTime(maturity);\n\n        if (hour != 0 || minute != 0 || second != 0) return false;\n        uint256 mode = Adapter(adapter).mode();\n        if (mode == 0) {\n            return day == 1;\n        }\n        if (mode == 1) {\n            return DateTime.getDayOfWeek(maturity) == 1;\n        }\n        return false;\n    }\n\n    /* ========== INTERNAL UTILS ========== */\n\n    function _setAdapter(address adapter, bool isOn) internal {\n        AdapterMeta memory am = adapterMeta[adapter];\n        if (am.enabled == isOn) revert Errors.ExistingValue();\n        am.enabled = isOn;\n\n        // If this adapter is being added for the first time\n        if (isOn && am.id == 0) {\n            am.id = ++adapterCounter;\n            adapterAddresses[am.id] = adapter;\n        }\n\n        // Set level and target (can only be done once);\n        am.level = uint248(Adapter(adapter).level());\n        adapterMeta[adapter] = am;\n        emit AdapterChanged(adapter, am.id, isOn);\n    }\n\n    /* ========== PUBLIC GETTERS ========== */\n\n    /// @notice Returns address of Principal Token\n    function pt(address adapter, uint256 maturity) public view returns (address) {\n        return series[adapter][maturity].pt;\n    }\n\n    /// @notice Returns address of Yield Token\n    function yt(address adapter, uint256 maturity) public view returns (address) {\n        return series[adapter][maturity].yt;\n    }\n\n    function mscale(address adapter, uint256 maturity) public view returns (uint256) {\n        return series[adapter][maturity].mscale;\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyYT(address adapter, uint256 maturity) {\n        if (series[adapter][maturity].yt != msg.sender) revert Errors.OnlyYT();\n        _;\n    }\n\n    /* ========== LOGS ========== */\n\n    /// @notice Admin\n    event Backfilled(\n        address indexed adapter,\n        uint256 indexed maturity,\n        uint256 mscale,\n        address[] _usrs,\n        uint256[] _lscales\n    );\n    event GuardChanged(address indexed adapter, uint256 cap);\n    event AdapterChanged(address indexed adapter, uint256 indexed id, bool indexed isOn);\n    event PeripheryChanged(address indexed periphery);\n\n    /// @notice Series lifecycle\n    /// *---- beginning\n    event SeriesInitialized(\n        address adapter,\n        uint256 indexed maturity,\n        address pt,\n        address yt,\n        address indexed sponsor,\n        address indexed target\n    );\n    /// -***- middle\n    event Issued(address indexed adapter, uint256 indexed maturity, uint256 balance, address indexed sender);\n    event Combined(address indexed adapter, uint256 indexed maturity, uint256 balance, address indexed sender);\n    event Collected(address indexed adapter, uint256 indexed maturity, uint256 collected);\n    /// ----* end\n    event SeriesSettled(address indexed adapter, uint256 indexed maturity, address indexed settler);\n    event PTRedeemed(address indexed adapter, uint256 indexed maturity, uint256 redeemed);\n    event YTRedeemed(address indexed adapter, uint256 indexed maturity, uint256 redeemed);\n    /// *----* misc\n    event GuardedChanged(bool indexed guarded);\n    event PermissionlessChanged(bool indexed permissionless);\n}\n\ncontract TokenHandler is Trust {\n    /// @notice Program state\n    address public divider;\n\n    constructor() Trust(msg.sender) {}\n\n    function init(address _divider) external requiresTrust {\n        if (divider != address(0)) revert Errors.AlreadyInitialized();\n        divider = _divider;\n    }\n\n    function deploy(\n        address adapter,\n        uint248 id,\n        uint256 maturity\n    ) external returns (address pt, address yt) {\n        if (msg.sender != divider) revert Errors.OnlyDivider();\n\n        ERC20 target = ERC20(Adapter(adapter).target());\n        uint8 decimals = target.decimals();\n        string memory symbol = target.symbol();\n        (string memory d, string memory m, string memory y) = DateTime.toDateString(maturity);\n        string memory date = DateTime.format(maturity);\n        string memory datestring = string(abi.encodePacked(d, \"-\", m, \"-\", y));\n        string memory adapterId = DateTime.uintToString(id);\n        pt = address(\n            new Token(\n                string(abi.encodePacked(date, \" \", symbol, \" Sense Principal Token, A\", adapterId)),\n                string(abi.encodePacked(\"sP-\", symbol, \":\", datestring, \":\", adapterId)),\n                decimals,\n                divider\n            )\n        );\n\n        yt = address(\n            new YT(\n                adapter,\n                maturity,\n                string(abi.encodePacked(date, \" \", symbol, \" Sense Yield Token, A\", adapterId)),\n                string(abi.encodePacked(\"sY-\", symbol, \":\", datestring, \":\", adapterId)),\n                decimals,\n                divider\n            )\n        );\n    }\n}"
    },
    {
      "filename": "test/fork/Contracts.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.16;\n\nlibrary Contracts {\n    // Sent to the lender contract constructor\n    // Swivel.sol v2 deployed contract\n    address constant SWIVEL = 0x093e4D20D9b2c3c8f68E8a20262D8Fb8EBCE08FA;\n    // Sushiswap router (https://docs.sushi.com/docs/Developers/Deployment%20Addresses)\n    // note used on lender\n    address constant PENDLE = 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F;\n    // note used on redeemer\n    address constant PENDLE_ROUTER = 0x1b6d3E5Da9004668E14Ca39d1553E9a46Fe842B3;\n    // https://docs.tempus.finance/docs/deployed-contracts (controller)\n    address constant TEMPUS = 0xdB5fD0678eED82246b599da6BC36B56157E4beD8;\n\n    // Prinicpal Tokens---------------------------------------------------------\n    // Notional deployed contracts: https://docs.notional.finance/developer-documentation/\n    // NOTE this is the DAI wrapped-fcash address\n    address constant NOTIONAL_TOKEN =\n        0xfcB060E09e452EEFf142949Bec214c187CDF25fA;\n    // Via the marketplace's markets call with USDC underlying and a maturity of 1664550000 (v2)\n    address constant SWIVEL_TOKEN = 0xC812c7aA52c97FacdE14b7FfFf4e0A9b1a1Dd179;\n    // Via sushi swap market (Dec 2022 - https://app.pendle.finance/market)\n    address constant PENDLE_TOKEN = 0x8fcb1783bF4b71A51F702aF0c266729C4592204a;\n    // via contracts.json (https://etherscan.io/address/0x53C2a1bA37FF3cDaCcb3EA030DB3De39358e5593#readContract)\n    address constant YIELD_TOKEN = 0x53C2a1bA37FF3cDaCcb3E"
    }
  ]
}