{
  "Title": "[M-10] Chainlink pricer is using a deprecated API",
  "Content": "_Submitted by cccz, also found by 0xDjango, 0xkatana, berndartmueller, Cr4ckM3, defsec, horsefacts, hyh, JMukesh, joshie, Jujic, pedroais, peritoflores, rayn, reassor, Ruhum, and WatchPug_\n\nAccording to Chainlink's documentation, the latestAnswer function is deprecated. This function might suddenly stop working if Chainlink stops supporting deprecated APIs. And the old API can return stale data.\n\n### Proof of Concept\n\n[FungibleAssetVaultForDAO.sol#L105](https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/FungibleAssetVaultForDAO.sol#L105)<br>\n[NFTVault.sol#L459](https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/NFTVault.sol#L459)<br>\n\n### Recommended Mitigation Steps\n\nUse the latestRoundData function to get the price instead. Add checks on the return data with proper revert messages if the price is stale or the round is uncomplete.<br>\n<https://docs.chain.link/docs/price-feeds-api-reference/>\n\n**[spaghettieth (JPEG'd) confirmed](https://github.com/code-423n4/2022-04-jpegd-findings/issues/4)**\n\n**[spaghettieth (JPEG'd) resolved and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/4#issuecomment-1099244659):**\n > Fixed in [jpegd/core#9](https://github.com/jpegd/core/pull/9).\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-04-jpegd-contest",
  "Code": [
    {
      "filename": "contracts/vaults/FungibleAssetVaultForDAO.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../interfaces/IAggregatorV3Interface.sol\";\nimport \"../interfaces/IStableCoin.sol\";\nimport \"../interfaces/IERC20Decimals.sol\";\n\n/// @title Fungible asset vault (for DAO and ecosystem contracts)\n/// @notice Allows the DAO and other whitelisted addresses to mint PUSD using fungible assets as collateral\n/// @dev The contract only supports one asset, meaning that multiple instances\n/// of this contract are going to be deployed if support for multiple assets is needed.\n/// The credit limit rate of the supported asset is set at deploy time.\n/// This contract doesn't support liquidations. In case of undercollateralization,\n/// the DAO will promptly deposit more collateral.\n/// The vault implements {AccessControlUpgradeable} and only allows whitelisted wallets\n/// to deposit/borrow/withdraw/repay. The contract doesn't keep track of the individual\n/// debt/deposited collateral of each whitelisted address, it instead uses global debt and deposited collateral.\n/// This is intentional and it's done to allow the DAO to repay debt of ecosystem contracts ({StrategyPUSDConvex}, for example)\ncontract FungibleAssetVaultForDAO is\n    AccessControlUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeERC20Upgradeable for IStableCoin;\n\n    event Deposit(address indexed user, uint256 depositAmount);\n    event Borrow(address indexed user, uint256 borrowAmount);\n    event Repay(address indexed user, uint256 repayAmount);\n    event Withdraw(address indexed user, uint256 withdrawAmount);\n\n    struct Rate {\n        uint128 numerator;\n        uint128 denominator;\n    }\n\n    bytes32 public constant WHITELISTED_ROLE = keccak256(\"WHITELISTED_ROLE\");\n\n    /// @dev This contract can handle unwrapped ETH if `address(0)` is passed as the `_collateralAsset`\n    /// parameter in the {initialize} function\n    address internal constant ETH = address(0);\n\n    address public collateralAsset;\n    IStableCoin public stablecoin;\n    /// @dev We store the value of a single unit of the collateral asset `10 ** decimals`\n    /// instead of fetching it everytime to save gas\n    uint256 private _collateralUnit;\n\n    IAggregatorV3Interface public oracle;\n\n    Rate public creditLimitRate;\n\n    /// @notice Amount of deposited collateral\n    uint256 public collateralAmount;\n    /// @notice Outstanding debt\n    uint256 public debtAmount;\n\n    /// @param _collateralAsset The address of the collateral asset - `address(0)` for ETH\n    /// @param _stablecoin PUSD address\n    /// @param _oracle Chainlink price feed for `_collateralAsset`/USD\n    /// @param _creditLimitRate Max outstanding debt to collateral ratio\n    function initialize(\n        address _collateralAsset,\n        IStableCoin _stablecoin,\n        IAggregatorV3Interface _oracle,\n        Rate memory _creditLimitRate\n    ) external initializer {\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n\n        setCreditLimitRate(_creditLimitRate);\n\n        collateralAsset = _collateralAsset;\n        stablecoin = _stablecoin;\n        if (_collateralAsset == ETH) {\n            _collateralUnit = 1 ether;\n        } else {\n            _collateralUnit = 10**IERC20Decimals(_collateralAsset).decimals();\n        }\n\n        oracle = _oracle;\n    }\n\n    /// @notice Allows members of the `DEFAULT_ADMIN_ROLE` to change the max outstanding debt to collateral ratio\n    /// @param _creditLimitRate The new ratio\n    function setCreditLimitRate(Rate memory _creditLimitRate) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(\n            _creditLimitRate.denominator > 0 &&\n                //denominator can be equal to the numerator in some cases (stablecoins used as collateral)\n                _creditLimitRate.denominator >= _creditLimitRate.numerator,\n            \"invalid_rate\"\n        );\n        creditLimitRate = _creditLimitRate;\n    }\n\n    /// @dev Returns the USD price of one unit of collateral asset, using 18 decimals precision\n    /// @return The USD price\n    function _collateralPriceUsd() internal view returns (uint256) {\n        int256 answer = oracle.latestAnswer();\n        uint8 decimals = oracle.decimals();\n\n        require(answer > 0, \"invalid_oracle_answer\");\n\n        //check chainlink's precision and convert it to 18 decimals\n        return\n            decimals > 18\n                ? uint256(answer) / 10**(decimals - 18)\n                : uint256(answer) * 10**(18 - decimals);\n    }\n\n    /// @dev Returns the USD value of `amount` units of collateral, using 18 decimals precision\n    /// @param amount The amount of collateral to calculate the value of\n    /// @return The USD value\n    function _getCollateralValue(uint256 amount)\n        internal\n        view\n        returns (uint256)\n    {\n        return (amount * _collateralPriceUsd()) / _collateralUnit;\n    }\n\n    /// @notice Returns the max debt for `amount` of collateral\n    /// @param amount The amount of collateral to calculate max debt for\n    /// @return Max debt value for `amount`\n    function getCreditLimit(uint256 amount) public view returns (uint256) {\n        uint256 collateralValue = _getCollateralValue(amount);\n        return\n            (collateralValue * creditLimitRate.numerator) /\n            creditLimitRate.denominator;\n    }\n\n    /// @notice Allows members of the `WHITELISTED_ROLE` to deposit `amount` of collateral\n    /// @dev Emits a {Deposit} event\n    /// @param amount The amount of collateral to deposit\n    function deposit(uint256 amount) external payable onlyRole(WHITELISTED_ROLE) {\n        require(amount > 0, \"invalid_amount\");\n\n        if (collateralAsset == ETH) {\n            require(msg.value == amount, \"invalid_msg_value\");\n        } else {\n            require(msg.value == 0, \"non_zero_eth_value\");\n            IERC20Upgradeable(collateralAsset).safeTransferFrom(\n                msg.sender,\n                address(this),\n                amount\n            );\n        }\n\n        collateralAmount += amount;\n\n        emit Deposit(msg.sender, amount);\n    }\n\n    /// @notice Allows members of the `WHITELISTED_ROLE` to borrow `amount` of PUSD against the deposited collateral\n    /// @dev Emits a {Borrow} event\n    /// @param amount The amount of PUSD to borrow\n    function borrow(uint256 amount) external onlyRole(WHITELISTED_ROLE) nonReentrant {\n        require(amount > 0, \"invalid_amount\");\n\n        uint256 creditLimit = getCreditLimit(collateralAmount);\n        uint256 newDebtAmount = debtAmount + amount;\n        require(newDebtAmount <= creditLimit, \"insufficient_credit\");\n\n        debtAmount = newDebtAmount;\n        stablecoin.mint(msg.sender, amount);\n\n        emit Borrow(msg.sender, amount);\n    }\n\n    /// @notice Allows members of the `WHITELISTED_ROLE` to repay `amount` of debt using PUSD\n    /// @dev Emits a {Repay} event\n    /// @param amount The amount of debt to repay\n    function repay(uint256 amount) external onlyRole(WHITELISTED_ROLE) nonReentrant {\n        require(amount > 0, \"invalid_amount\");\n\n        amount = amount > debtAmount ? debtAmount : amount;\n\n        debtAmount -= amount;\n        stablecoin.burnFrom(msg.sender, amount);\n\n        emit Repay(msg.sender, amount);\n    }\n\n    /// @notice Allows members of the `WHITELISTED_ROLE` to withdraw `amount` of deposited collateral\n    /// @dev Emits a {Withdraw} event\n    /// @param amount The amount of collateral to withdraw\n    function withdraw(uint256 amount) external onlyRole(WHITELISTED_ROLE) nonReentrant {\n        require(amount > 0 && amount <= collateralAmount, \"invalid_amount\");\n\n        uint256 creditLimit = getCreditLimit(collateralAmount - amount);\n        require(creditLimit >= debtAmount, \"insufficient_credit\");\n\n        collateralAmount -= amount;\n\n        if (collateralAsset == ETH) payable(msg.sender).transfer(amount);\n        else\n            IERC20Upgradeable(collateralAsset).safeTransfer(msg.sender, amount);\n\n        emit Withdraw(msg.sender, amount);\n    }\n\n    uint256[50] private __gap;\n}"
    },
    {
      "filename": "contracts/vaults/NFTVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\n\nimport \"../interfaces/IAggregatorV3Interface.sol\";\nimport \"../interfaces/IStableCoin.sol\";\nimport \"../interfaces/IJPEGLock.sol\";\n\n/// @title NFT lending vault\n/// @notice This contracts allows users to borrow PUSD using NFTs as collateral.\n/// The floor price of the NFT collection is fetched using a chainlink oracle, while some other more valuable traits\n/// can have an higher price set by the DAO. Users can also increase the price (and thus the borrow limit) of their\n/// NFT by submitting a governance proposal. If the proposal is approved the user can lock a percentage of the new price\n/// worth of JPEG to make it effective\ncontract NFTVault is AccessControlUpgradeable, ReentrancyGuardUpgradeable {\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\n\n    event PositionOpened(address indexed owner, uint256 indexed index);\n    event Borrowed(\n        address indexed owner,\n        uint256 indexed index,\n        uint256 amount\n    );\n    event Repaid(address indexed owner, uint256 indexed index, uint256 amount);\n    event PositionClosed(address indexed owner, uint256 indexed index);\n    event Liquidated(\n        address indexed liquidator,\n        address indexed owner,\n        uint256 indexed index,\n        bool insured\n    );\n    event Repurchased(address indexed owner, uint256 indexed index);\n    event InsuranceExpired(address indexed owner, uint256 indexed index);\n\n    enum BorrowType {\n        NOT_CONFIRMED,\n        NON_INSURANCE,\n        USE_INSURANCE\n    }\n\n    struct Position {\n        BorrowType borrowType;\n        uint256 debtPrincipal;\n        uint256 debtPortion;\n        uint256 debtAmountForRepurchase;\n        uint256 liquidatedAt;\n        address liquidator;\n    }\n\n    struct Rate {\n        uint128 numerator;\n        uint128 denominator;\n    }\n\n    struct VaultSettings {\n        Rate debtInterestApr;\n        Rate creditLimitRate;\n        Rate liquidationLimitRate;\n        Rate valueIncreaseLockRate;\n        Rate organizationFeeRate;\n        Rate insurancePurchaseRate;\n        Rate insuranceLiquidationPenaltyRate;\n        uint256 insuraceRepurchaseTimeLimit;\n        uint256 borrowAmountCap;\n    }\n\n    bytes32 public constant DAO_ROLE = keccak256(\"DAO_ROLE\");\n    bytes32 public constant LIQUIDATOR_ROLE = keccak256(\"LIQUIDATOR_ROLE\");\n\n    bytes32 public constant CUSTOM_NFT_HASH = keccak256(\"CUSTOM\");\n\n    IStableCoin public stablecoin;\n    /// @notice Chainlink ETH/USD price feed\n    IAggregatorV3Interface public ethAggregator;\n    /// @notice Chainlink JPEG/USD price feed\n    IAggregatorV3Interface public jpegAggregator;\n    /// @notice Chainlink NFT floor oracle\n    IAggregatorV3Interface public floorOracle;\n    /// @notice Chainlink NFT fallback floor oracle\n    IAggregatorV3Interface public fallbackOracle;\n    /// @notice JPEGLocker, used by this contract to lock JPEG and increase the value of an NFT\n    IJPEGLock public jpegLocker;\n    IERC721Upgradeable public nftContract;\n\n    /// @notice If true, the floor price won't be fetched using the Chainlink oracle but\n    /// a value set by the DAO will be used instead\n    bool public daoFloorOverride;\n    // @notice If true, the floor price will be fetched using the fallback oracle\n    bool public useFallbackOracle;\n    /// @notice Total outstanding debt\n    uint256 public totalDebtAmount;\n    /// @dev Last time debt was accrued. See {accrue} for more info\n    uint256 public totalDebtAccruedAt;\n    uint256 public totalFeeCollected;\n    uint256 internal totalDebtPortion;\n\n    VaultSettings public settings;\n\n    /// @dev Keeps track of all the NFTs used as collateral for positions\n    EnumerableSetUpgradeable.UintSet private positionIndexes;\n\n    mapping(uint256 => Position) private positions;\n    mapping(uint256 => address) public positionOwner;\n    mapping(bytes32 => uint256) public nftTypeValueETH;\n    mapping(uint256 => uint256) public nftValueETH;\n    //bytes32(0) is floor\n    mapping(uint256 => bytes32) public nftTypes;\n    mapping(uint256 => uint256) public pendingNFTValueETH;\n\n    /// @dev Checks if the provided NFT index is valid\n    /// @param nftIndex The index to check\n    modifier validNFTIndex(uint256 nftIndex) {\n        //The standard OZ ERC721 implementation of ownerOf reverts on a non existing nft isntead of returning address(0)\n        require(nftContract.ownerOf(nftIndex) != address(0), \"invalid_nft\");\n        _;\n    }\n\n    struct NFTCategoryInitializer {\n        bytes32 hash;\n        uint256 valueETH;\n        uint256[] nfts;\n    }\n\n    /// @param _stablecoin PUSD address\n    /// @param _nftContract The NFT contrat address. It could also be the address of an helper contract\n    /// if the target NFT isn't an ERC721 (CryptoPunks as an example)\n    /// @param _ethAggregator Chainlink ETH/USD price feed address\n    /// @param _jpegAggregator Chainlink JPEG/USD price feed address\n    /// @param _floorOracle Chainlink floor oracle address\n    /// @param _fallbackOracle Chainlink fallback floor oracle address\n    /// @param _typeInitializers Used to initialize NFT categories with their value and NFT indexes.\n    /// Floor NFT shouldn't be initialized this way\n    /// @param _jpegLocker JPEGLock address\n    /// @param _settings Initial settings used by the contract\n    function initialize(\n        IStableCoin _stablecoin,\n        IERC721Upgradeable _nftContract,\n        IAggregatorV3Interface _ethAggregator,\n        IAggregatorV3Interface _jpegAggregator,\n        IAggregatorV3Interface _floorOracle,\n        IAggregatorV3Interface _fallbackOracle,\n        NFTCategoryInitializer[] memory _typeInitializers,\n        IJPEGLock _jpegLocker,\n        VaultSettings memory _settings\n    ) external initializer {\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n\n        _setupRole(DAO_ROLE, msg.sender);\n        _setRoleAdmin(LIQUIDATOR_ROLE, DAO_ROLE);\n        _setRoleAdmin(DAO_ROLE, DAO_ROLE);\n\n        _validateRate(_settings.debtInterestApr);\n        _validateRate(_settings.creditLimitRate);\n        _validateRate(_settings.liquidationLimitRate);\n        _validateRate(_settings.valueIncreaseLockRate);\n        _validateRate(_settings.organizationFeeRate);\n        _validateRate(_settings.insurancePurchaseRate);\n        _validateRate(_settings.insuranceLiquidationPenaltyRate);\n\n        _validateCreditLimitAndLiquidationRate(\n            _settings.creditLimitRate,\n            _settings.liquidationLimitRate\n        );\n\n        stablecoin = _stablecoin;\n        jpegLocker = _jpegLocker;\n        ethAggregator = _ethAggregator;\n        jpegAggregator = _jpegAggregator;\n        floorOracle = _floorOracle;\n        fallbackOracle = _fallbackOracle;\n        nftContract = _nftContract;\n\n        settings = _settings;\n\n        //initializing the categories\n        for (uint256 i = 0; i < _typeInitializers.length; i++) {\n            NFTCategoryInitializer memory initializer = _typeInitializers[i];\n            nftTypeValueETH[initializer.hash] = initializer.valueETH;\n            for (uint256 j = 0; j < initializer.nfts.length; j++) {\n                nftTypes[initializer.nfts[j]] = initializer.hash;\n            }\n        }\n    }\n\n    /// @dev The {accrue} function updates the contract's state by calculating\n    /// the additional interest accrued since the last state update\n    function accrue() public {\n        uint256 additionalInterest = _calculateAdditionalInterest();\n\n        totalDebtAccruedAt = block.timestamp;\n\n        totalDebtAmount += additionalInterest;\n        totalFeeCollected += additionalInterest;\n    }\n\n    /// @notice Allows the DAO to change the total debt cap\n    /// @param _borrowAmountCap New total debt cap\n    function setBorrowAmountCap(uint256 _borrowAmountCap)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        settings.borrowAmountCap = _borrowAmountCap;\n    }\n\n    /// @notice Allows the DAO to change the interest APR on borrows\n    /// @param _debtInterestApr The new interest rate\n    function setDebtInterestApr(Rate memory _debtInterestApr)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_debtInterestApr);\n        settings.debtInterestApr = _debtInterestApr;\n    }\n\n    /// @notice Allows the DAO to change the amount of JPEG needed to increase the value of an NFT relative to the desired value\n    /// @param _valueIncreaseLockRate The new rate\n    function setValueIncreaseLockRate(Rate memory _valueIncreaseLockRate)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_valueIncreaseLockRate);\n        settings.valueIncreaseLockRate = _valueIncreaseLockRate;\n    }\n\n    /// @notice Allows the DAO to change the max debt to collateral rate for a position\n    /// @param _creditLimitRate The new rate\n    function setCreditLimitRate(Rate memory _creditLimitRate)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_creditLimitRate);\n        _validateCreditLimitAndLiquidationRate(\n            _creditLimitRate,\n            settings.liquidationLimitRate\n        );\n\n        settings.creditLimitRate = _creditLimitRate;\n    }\n\n    /// @notice Allows the DAO to change the minimum debt to collateral rate for a position to be market as liquidatable\n    /// @param _liquidationLimitRate The new rate\n    function setLiquidationLimitRate(Rate memory _liquidationLimitRate)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_liquidationLimitRate);\n        _validateCreditLimitAndLiquidationRate(\n            settings.creditLimitRate,\n            _liquidationLimitRate\n        );\n\n        settings.liquidationLimitRate = _liquidationLimitRate;\n    }\n\n    /// @notice Allows the DAO to toggle the fallback oracle\n    /// @param _useFallback Whether to use the fallback oracle\n    function toggleFallbackOracle(bool _useFallback)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        useFallbackOracle = _useFallback;\n    }\n\n    /// @notice Allows the DAO to change the amount of time JPEG tokens need to be locked to change the value of an NFT\n    /// @param _newLockTime The amount new lock time amount\n    function setJPEGLockTime(uint256 _newLockTime) external onlyRole(DAO_ROLE) {\n        jpegLocker.setLockTime(_newLockTime);\n    }\n\n    /// @notice Allows the DAO to bypass the floor oracle and override the NFT floor value\n    /// @param _newFloor The new floor\n    function overrideFloor(uint256 _newFloor) external onlyRole(DAO_ROLE) {\n        require(_newFloor > 0, \"Invalid floor\");\n        nftTypeValueETH[bytes32(0)] = _newFloor;\n        daoFloorOverride = true;\n    }\n\n    /// @notice Allows the DAO to stop overriding floor\n    function disableFloorOverride() external onlyRole(DAO_ROLE) {\n        daoFloorOverride = false;\n    }\n\n    /// @notice Allows the DAO to change the static borrow fee\n    /// @param _organizationFeeRate The new fee rate\n    function setOrganizationFeeRate(Rate memory _organizationFeeRate)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_organizationFeeRate);\n        settings.organizationFeeRate = _organizationFeeRate;\n    }\n\n    /// @notice Allows the DAO to change the cost of insurance\n    /// @param _insurancePurchaseRate The new insurance fee rate\n    function setInsurancePurchaseRate(Rate memory _insurancePurchaseRate)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_insurancePurchaseRate);\n        settings.insurancePurchaseRate = _insurancePurchaseRate;\n    }\n\n    /// @notice Allows the DAO to change the repurchase penalty rate in case of liquidation of an insured NFT\n    /// @param _insuranceLiquidationPenaltyRate The new rate\n    function setInsuranceLiquidationPenaltyRate(\n        Rate memory _insuranceLiquidationPenaltyRate\n    ) external onlyRole(DAO_ROLE) {\n        _validateRate(_insuranceLiquidationPenaltyRate);\n        settings\n            .insuranceLiquidationPenaltyRate = _insuranceLiquidationPenaltyRate;\n    }\n\n    /// @notice Allows the DAO to add an NFT to a specific price category\n    /// @param _nftIndex The index to add to the category\n    /// @param _type The category hash\n    function setNFTType(uint256 _nftIndex, bytes32 _type)\n        external\n        validNFTIndex(_nftIndex)\n        onlyRole(DAO_ROLE)\n    {\n        require(\n            _type == bytes32(0) || nftTypeValueETH[_type] > 0,\n            \"invalid_nftType\"\n        );\n        nftTypes[_nftIndex] = _type;\n    }\n\n    /// @notice Allows the DAO to change the value of an NFT category\n    /// @param _type The category hash\n    /// @param _amountETH The new value, in ETH\n    function setNFTTypeValueETH(bytes32 _type, uint256 _amountETH)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        nftTypeValueETH[_type] = _amountETH;\n    }\n\n    /// @notice Allows the DAO to set the value in ETH of the NFT at index `_nftIndex`.\n    /// A JPEG deposit by a user is required afterwards. See {finalizePendingNFTValueETH} for more details\n    /// @param _nftIndex The index of the NFT to change the value of\n    /// @param _amountETH The new desired ETH value\n    function setPendingNFTValueETH(uint256 _nftIndex, uint256 _amountETH)\n        external\n        validNFTIndex(_nftIndex)\n        onlyRole(DAO_ROLE)\n    {\n        pendingNFTValueETH[_nftIndex] = _amountETH;\n    }\n\n    /// @notice Allows a user to lock up JPEG to make the change in value of an NFT effective.\n    /// Can only be called after {setPendingNFTValueETH}, which requires a governance vote.\n    /// @dev The amount of JPEG that needs to be locked is calculated by applying `valueIncreaseLockRate`\n    /// to the new credit limit of the NFT\n    /// @param _nftIndex The index of the NFT\n    function finalizePendingNFTValueETH(uint256 _nftIndex)\n        external\n        validNFTIndex(_nftIndex)\n    {\n        uint256 pendingValue = pendingNFTValueETH[_nftIndex];\n        require(pendingValue > 0, \"no_pending_value\");\n        uint256 toLockJpeg = (((pendingValue *\n            _ethPriceUSD() *\n            settings.creditLimitRate.numerator) /\n            settings.creditLimitRate.denominator) *\n            settings.valueIncreaseLockRate.numerator) /\n            settings.valueIncreaseLockRate.denominator /\n            _jpegPriceUSD();\n\n        //lock JPEG using JPEGLock\n        jpegLocker.lockFor(msg.sender, _nftIndex, toLockJpeg);\n\n        nftTypes[_nftIndex] = CUSTOM_NFT_HASH;\n        nftValueETH[_nftIndex] = pendingValue;\n        //clear pending value\n        pendingNFTValueETH[_nftIndex] = 0;\n    }\n\n    /// @dev Validates the credit limit rate and the liquidation limit rate.\n    /// The credit limit rate must be less than the liquidation rate\n    /// @param _creditLimitRate The credit limit rate to validate\n    /// @param _liquidationLimitRate The liquidation limit rate\n    function _validateCreditLimitAndLiquidationRate(\n        Rate memory _creditLimitRate,\n        Rate memory _liquidationLimitRate\n    ) internal pure {\n        require(\n            _liquidationLimitRate.numerator * _creditLimitRate.denominator >\n                _creditLimitRate.numerator * _liquidationLimitRate.denominator,\n            \"credit_rate_exceeds_or_equals_liquidation_rate\"\n        );\n    }\n\n    /// @dev Validates a rate. The denominator must be greater than zero and greater than or equal to the numerator.\n    /// @param rate The rate to validate\n    function _validateRate(Rate memory rate) internal pure {\n        require(\n            rate.denominator > 0 && rate.denominator >= rate.numerator,\n            \"invalid_rate\"\n        );\n    }\n\n    /// @dev Returns the value in ETH of the NFT at index `_nftIndex`\n    /// @param _nftIndex The NFT to return the value of\n    /// @return The value of the NFT, 18 decimals\n    function _getNFTValueETH(uint256 _nftIndex)\n        internal\n        view\n        returns (uint256)\n    {\n        bytes32 nftType = nftTypes[_nftIndex];\n\n        if (nftType == bytes32(0) && !daoFloorOverride) {\n            return\n                _normalizeAggregatorAnswer(\n                    useFallbackOracle ? fallbackOracle : floorOracle\n                );\n        } else if (nftType == CUSTOM_NFT_HASH) return nftValueETH[_nftIndex];\n\n        return nftTypeValueETH[nftType];\n    }\n\n    /// @dev Returns the value in USD of the NFT at index `_nftIndex`\n    /// @param _nftIndex The NFT to return the value of\n    /// @return The value of the NFT in USD, 18 decimals\n    function _getNFTValueUSD(uint256 _nftIndex)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 nft_value = _getNFTValueETH(_nftIndex);\n        return (nft_value * _ethPriceUSD()) / 1 ether;\n    }\n\n    /// @dev Returns the current ETH price in USD\n    /// @return The current ETH price, 18 decimals\n    function _ethPriceUSD() internal view returns (uint256) {\n        return _normalizeAggregatorAnswer(ethAggregator);\n    }\n\n    /// @dev Returns the current JPEG price in USD\n    /// @return The current JPEG price, 18 decimals\n    function _jpegPriceUSD() internal view returns (uint256) {\n        return _normalizeAggregatorAnswer(jpegAggregator);\n    }\n\n    /// @dev Fetches and converts to 18 decimals precision the latest answer of a Chainlink aggregator\n    /// @param aggregator The aggregator to fetch the answer from\n    /// @return The latest aggregator answer, normalized\n    function _normalizeAggregatorAnswer(IAggregatorV3Interface aggregator)\n        internal\n        view\n        returns (uint256)\n    {\n        int256 answer = aggregator.latestAnswer();\n        uint8 decimals = aggregator.decimals();\n\n        require(answer > 0, \"invalid_oracle_answer\");\n        //converts the answer to have 18 decimals\n        return\n            decimals > 18\n                ? uint256(answer) / 10**(decimals - 18)\n                : uint256(answer) * 10**(18 - decimals);\n    }\n\n    struct NFTInfo {\n        uint256 index;\n        bytes32 nftType;\n        address owner;\n        uint256 nftValueETH;\n        uint256 nftValueUSD;\n    }\n\n    /// @notice Returns data relative to the NFT at index `_nftIndex`\n    /// @param _nftIndex The NFT index\n    /// @return nftInfo The data relative to the NFT\n    function getNFTInfo(uint256 _nftIndex)\n        external\n        view\n        returns (NFTInfo memory nftInfo)\n    {\n        nftInfo = NFTInfo(\n            _nftIndex,\n            nftTypes[_nftIndex],\n            nftContract.ownerOf(_nftIndex),\n            _getNFTValueETH(_nftIndex),\n            _getNFTValueUSD(_nftIndex)\n        );\n    }\n\n    /// @dev Returns the credit limit of an NFT\n    /// @param _nftIndex The NFT to return credit limit of\n    /// @return The NFT credit limit\n    function _getCreditLimit(uint256 _nftIndex)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 asset_value = _getNFTValueUSD(_nftIndex);\n        return\n            (asset_value * settings.creditLimitRate.numerator) /\n            settings.creditLimitRate.denominator;\n    }\n\n    /// @dev Returns the minimum amount of debt necessary to liquidate an NFT\n    /// @param _nftIndex The index of the NFT\n    /// @return The minimum amount of debt to liquidate the NFT\n    function _getLiquidationLimit(uint256 _nftIndex)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 asset_value = _getNFTValueUSD(_nftIndex);\n        return\n            (asset_value * settings.liquidationLimitRate.numerator) /\n            settings.liquidationLimitRate.denominator;\n    }\n\n    /// @dev Calculates current outstanding debt of an NFT\n    /// @param _nftIndex The NFT to calculate the outstanding debt of\n    /// @return The outstanding debt value\n    function _getDebtAmount(uint256 _nftIndex) internal view returns (uint256) {\n        uint256 calculatedDebt = _calculateDebt(\n            totalDebtAmount,\n            positions[_nftIndex].debtPortion,\n            totalDebtPortion\n        );\n\n        uint256 principal = positions[_nftIndex].debtPrincipal;\n\n        //_calculateDebt is prone to rounding errors that may cause\n        //the calculated debt amount to be 1 or 2 units less than\n        //the debt principal when the accrue() function isn't called\n        //in between the first borrow and the _calculateDebt call.\n        return principal > calculatedDebt ? principal : calculatedDebt;\n    }\n\n    /// @dev Calculates the total debt of a position given the global debt, the user's portion of the debt and the total user portions\n    /// @param total The global outstanding debt\n    /// @param userPortion The user's portion of debt\n    /// @param totalPortion The total user portions of debt\n    /// @return The outstanding debt of the position\n    function _calculateDebt(\n        uint256 total,\n        uint256 userPortion,\n        uint256 totalPortion\n    ) internal pure returns (uint256) {\n        return totalPortion == 0 ? 0 : (total * userPortion) / totalPortion;\n    }\n\n    /// @dev Opens a position\n    /// Emits a {PositionOpened} event\n    /// @param _owner The owner of the position to open\n    /// @param _nftIndex The NFT used as collateral for the position\n    function _openPosition(address _owner, uint256 _nftIndex) internal {\n        nftContract.transferFrom(_owner, address(this), _nftIndex);\n\n        positions[_nftIndex] = Position({\n            borrowType: BorrowType.NOT_CONFIRMED,\n            debtPrincipal: 0,\n            debtPortion: 0,\n            debtAmountForRepurchase: 0,\n            liquidatedAt: 0,\n            liquidator: address(0)\n        });\n        positionOwner[_nftIndex] = _owner;\n        positionIndexes.add(_nftIndex);\n\n        emit PositionOpened(_owner, _nftIndex);\n    }\n\n    /// @dev Calculates the additional global interest since last time the contract's state was updated by calling {accrue}\n    /// @return The additional interest value\n    function _calculateAdditionalInterest() internal view returns (uint256) {\n        // Number of seconds since {accrue} was called\n        uint256 elapsedTime = block.timestamp - totalDebtAccruedAt;\n        if (elapsedTime == 0) {\n            return 0;\n        }\n\n        if (totalDebtAmount == 0) {\n            return 0;\n        }\n\n        // Accrue interest\n        uint256 interestPerYear = (totalDebtAmount *\n            settings.debtInterestApr.numerator) /\n            settings.debtInterestApr.denominator;\n        uint256 interestPerSec = interestPerYear / 365 days;\n\n        return elapsedTime * interestPerSec;\n    }\n\n    /// @notice Returns the number of open positions\n    /// @return The number of open positions\n    function totalPositions() external view returns (uint256) {\n        return positionIndexes.length();\n    }\n\n    /// @notice Returns all open position NFT indexes\n    /// @return The open position NFT indexes\n    function openPositionsIndexes() external view returns (uint256[] memory) {\n        return positionIndexes.values();\n    }\n\n    struct PositionPreview {\n        address owner;\n        uint256 nftIndex;\n        bytes32 nftType;\n        uint256 nftValueUSD;\n        VaultSettings vaultSettings;\n        uint256 creditLimit;\n        uint256 debtPrincipal;\n        uint256 debtInterest;\n        BorrowType borrowType;\n        bool liquidatable;\n        uint256 liquidatedAt;\n        address liquidator;\n    }\n\n    /// @notice Returns data relative to a postition, existing or not\n    /// @param _nftIndex The index of the NFT used as collateral for the position\n    /// @return preview See assignment below\n    function showPosition(uint256 _nftIndex)\n        external\n        view\n        validNFTIndex(_nftIndex)\n        returns (PositionPreview memory preview)\n    {\n        address posOwner = positionOwner[_nftIndex];\n\n        uint256 debtPrincipal = positions[_nftIndex].debtPrincipal;\n        uint256 debtAmount = positions[_nftIndex].liquidatedAt > 0\n            ? positions[_nftIndex].debtAmountForRepurchase //calculate updated debt\n            : _calculateDebt(\n                totalDebtAmount + _calculateAddit"
    }
  ]
}