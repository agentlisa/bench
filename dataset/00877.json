{
  "Title": "Lack of Validation That Contract Receiving Messages Supports ITeleporterReceiver Interface",
  "Content": "A contract that would like to receive messages from the `TeleporterMessenger` contract [must implement the `receiveTeleporterMessage` function](https://github.com/ava-labs/teleporter/blob/253b833518aa7a6448650388cc288bd76d8470a7/contracts/src/Teleporter/ITeleporterReceiver.sol#L9) from the `ITeleporterReceiver` interface. This function is called when the [message is being executed](https://github.com/ava-labs/teleporter/blob/253b833518aa7a6448650388cc288bd76d8470a7/contracts/src/Teleporter/TeleporterMessenger.sol#L736). If a contract does not implement the `receiveTeleporterMessage` function, the call will fail and be [stored for a future execution](https://github.com/ava-labs/teleporter/blob/253b833518aa7a6448650388cc288bd76d8470a7/contracts/src/Teleporter/TeleporterMessenger.sol#L745-L747).\n\n\nHowever, if the receiving contract does not implement this function and instead implements a `fallback`, the call could be successful. This opens up the possibility whereby even though the message is being forwarded to the contract, the destination contract does not handle it but there is no reversion of the transaction. Moreover, implementing the `receiveTeleporterMessage` function cannot be used to assert that the destination address will be able to handle the message, leaving open the possibility of setting a destination address by mistake that will call its fallback function.\n\n\nIn favor of restricting the possibility of a message being delivered into a non-compatible contract on the destination subnet, consider using an EIP meant for introspection, such as [EIP-1820](https://eips.ethereum.org/EIPS/eip-1820), instead of assuming that contracts that do not possess a `receiveTeleporterMessage` hook cannot be called.\n\n\n***Update:** Acknowledged, not resolved. AVA Labs stated the following regarding the issue:*\n\n\n\n> *We think that trying to determine if a given contract address implements a specific interface would introduce more complexities than the benefits it provides. Even if the contract implements the required interface properly, it still may be unable to handle messages properly due to other implementation issues, as noted in the report, so even the best of guard rails doesn't ensure the correctness of applications built to use Teleporter. It is the responsibility of applications using Teleporter to ensure that they are able to send and receive their specific messages properly.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/Teleporter/ITeleporterReceiver.sol",
      "content": "// (c) 2022-2023, Ava Labs, Inc. All rights reserved.\n// See the file LICENSE for licensing terms.\n\n// SPDX-License-Identifier: Ecosystem\n\npragma solidity 0.8.18;\n\n/**\n * @dev Interface that cross-chain applications must implement to receive messages from Teleporter.\n */\ninterface ITeleporterReceiver {\n    /**\n     * @dev Called by TeleporterMessenger on the receiving chain.\n     *\n     * @param originChainID is provided by the TeleporterMessenger contract.\n     * @param originSenderAddress is provided by the TeleporterMessenger contract.\n     * @param message is the TeleporterMessage payload set by the sender.\n     */\n    function receiveTeleporterMessage(\n        bytes32 originChainID,\n        address originSenderAddress,\n        bytes calldata message\n    ) external;\n}"
    }
  ]
}