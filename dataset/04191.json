{
  "Title": "[H01] Improper Error Handling",
  "Content": "The `CompoundPrizePool` contract interacts with the Compound system to [mint new cTokens](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/compound/CompoundPrizePool.sol#L87) and [redeem them for the underlying asset](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/compound/CompoundPrizePool.sol#L101). In both cases the code ignores the returned [error code](https://github.com/compound-finance/compound-protocol/blob/master/contracts/CErc20.sol#L42). Since these calls are intended to be part of atomic operations that [mint](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol#L240-L242) and [burn](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol#L289-L294) pool tokens, failure to account for errors in the Compound calls could lead to internal inconsistencies, under-invested tokens and loss of user funds.\n\n\nConsider reverting the transaction whenever the Compound system returns an error, to ensure the operations remain atomic.\n\n\n***Update:** Fixed in [pull request #101](https://github.com/pooltogether/pooltogether-pool-contracts/pull/101/). The `_redeem` and `_supply` functions in `CompoundPrizePool.sol` now require that the value returned by the `cToken` contract equals zero, which represents the [NO\\_ERROR code in Compound](https://github.com/compound-finance/compound-protocol/blob/1cf040412fc8a0cfd1187bb0d8a525c3ae2f78aa/contracts/ErrorReporter.sol#L5).*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/prize-pool/compound/CompoundPrizePool.sol",
      "content": "pragma solidity 0.6.4;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\";\nimport \"@pooltogether/fixed-point/contracts/FixedPoint.sol\";\n\nimport \"../../external/compound/CTokenInterface.sol\";\nimport \"../PrizePool.sol\";\n\n/// @title Prize Pool with Compound's cToken\n/// @notice Manages depositing and withdrawing assets from the Prize Pool\ncontract CompoundPrizePool is PrizePool {\n  using SafeMath for uint256;\n\n  /// @notice Interface for the Yield-bearing cToken by Compound\n  CTokenInterface public cToken;\n\n  /// @notice Initializes the Prize Pool and Yield Service with the required contract connections\n  /// @param _trustedForwarder Address of the Forwarding Contract for GSN Meta-Txs\n  /// @param _prizeStrategy Address of the component-controller that manages the prize-strategy\n  /// @param _controlledTokens Array of addresses for the Ticket and Sponsorship Tokens controlled by the Prize Pool\n  /// @param _maxExitFeeMantissa The maximum exit fee size, relative to the withdrawal amount\n  /// @param _maxTimelockDuration The maximum length of time the withdraw timelock could be\n  /// @param _cToken Address of the Compound cToken interface\n  function initialize (\n    address _trustedForwarder,\n    PrizeStrategyInterface _prizeStrategy,\n    address[] memory _controlledTokens,\n    uint256 _maxExitFeeMantissa,\n    uint256 _maxTimelockDuration,\n    CTokenInterface _cToken\n  )\n    public\n    initializer\n  {\n    PrizePool.initialize(\n      _trustedForwarder,\n      _prizeStrategy,\n      _controlledTokens,\n      _maxExitFeeMantissa,\n      _maxTimelockDuration\n    );\n    cToken = _cToken;\n  }\n\n  /// @notice Estimates the accrued interest of a deposit of a given number of blocks\n  /// @dev Provides an estimate for the amount of accrued interest that would\n  /// be applied to the `principalAmount` over a given number of `blocks`\n  /// @param principalAmount The amount of asset tokens to provide an estimate on\n  /// @param blocks The number of blocks that the principal would accrue interest over\n  /// @return The estimated interest that would accrue on the principal\n  function estimateAccruedInterestOverBlocks(\n    uint256 principalAmount,\n    uint256 blocks\n  )\n    public\n    view\n    override\n    returns (uint256)\n  {\n    // estimated = principalAmount * supply rate per block * blocks\n    uint256 multiplier = principalAmount.mul(blocks);\n    return FixedPoint.multiplyUintByMantissa(multiplier, supplyRatePerBlock());\n  }\n\n  /// @dev Gets the current interest-rate the Compound cToken\n  /// @return The current exchange-rate\n  function supplyRatePerBlock() internal view returns (uint256) {\n    (bool success, bytes memory data) = address(cToken).staticcall(abi.encodeWithSignature(\"supplyRatePerBlock()\"));\n    require(success, \"CompoundPrizePool/supplyRatePerBlock-failed\");\n    return abi.decode(data, (uint256));\n  }\n\n  /// @dev Gets the balance of the underlying assets held by the Yield Service\n  /// @return The underlying balance of asset tokens\n  function _balance() internal override returns (uint256) {\n    return cToken.balanceOfUnderlying(address(this));\n  }\n\n  /// @dev Allows a user to supply asset tokens in exchange for yield-bearing tokens\n  /// to be held in escrow by the Yield Service\n  /// @param amount The amount of asset tokens to be supplied\n  function _supply(uint256 amount) internal override {\n    IERC20 assetToken = _token();\n    assetToken.approve(address(cToken), amount);\n    cToken.mint(amount);\n  }\n\n  /// @dev Checks with the Prize Pool if a specific token type may be awarded as a prize enhancement\n  /// @param _externalToken The address of the token to check\n  /// @return True if the token may be awarded, false otherwise\n  function _canAwardExternal(address _externalToken) internal override view returns (bool) {\n    return _externalToken != address(cToken);\n  }\n\n  /// @dev Allows a user to redeem yield-bearing tokens in exchange for the underlying\n  /// asset tokens held in escrow by the Yield Service\n  /// @param amount The amount of yield-bearing tokens to be redeemed\n  function _redeem(uint256 amount) internal override {\n    cToken.redeemUnderlying(amount);\n  }\n\n  /// @dev Gets the underlying asset token used by the Yield Service\n  /// @return A reference to the interface of the underling asset token\n  function _token() internal override view returns (IERC20) {\n    return IERC20(cToken.underlying());\n  }\n}"
    }
  ]
}