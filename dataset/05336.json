{
  "Title": "[G-09] State variables only set in the constructor should be declared immutable",
  "Content": "State variables only set in the constructor should be declared immutable as it avoids a Gsset (20000 gas) in the constructor, and replaces the first access in each transaction (Gcoldsload - 2100 gas) and each access thereafter (Gwarmacces - 100 gas) with a PUSH32 (3 gas).\n\n### Please note these instances were not included in the bot reports.\n\n### 6 Instances\n\n1. ### The `olas` state variable could be made `immutable` \n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Treasury.sol#L65\n\nMaking the `olas` state variable immutable would help avoid `Gsset` (20000 gas units) in the constructor during deployment. In implementing this change a cheaper stack read `3 gas` would be used in place of 1 `SLOAD` (cold access 2100 gas units) in the functions `depositTokenForOLAS()`and  `withdrawToAccount()` which reads the `olas` variable. The diff below shows how the code should be refactored: \n\n```solidity\nfile: tokenomics/contracts/Treasury.sol\n\n65:    address public olas;\n```\n\n```diff\ndiff --git a/tokenomics/contracts/Treasury.sol b/tokenomics/contracts/Treasury.sol\nindex 516c631..dfc0aae 100644\n--- a/tokenomics/contracts/Treasury.sol\n+++ b/tokenomics/contracts/Treasury.sol\n@@ -62,7 +62,7 @@ contract Treasury is IErrorsTokenomics {\n     uint96 public ETHFromServices;\n\n     // OLAS token address\n-    address public olas;\n+    address public immutable olas;\n     // ETH owned by treasury\n```\n```\nEstimated Gas saved: 24200 gas units\n```\n\n\n2. ### The `pool` state variable could be made `immutable` \n- https://github.com/code-423n4/2023-12-autonolas/blob/main/lockbox-solana/solidity/liquidity_lockbox.sol#L26\n\nMaking the `pool` state variable immutable would help avoid `Gsset` (20000 gas units) in the constructor during deployment. In implementing this change a cheaper stack read `3 gas` would be used in place of 1 `SLOAD` (cold access 2100 gas units) in the functions `depositToke_getPositionDatanForOLAS()`and  `withdraw()` which reads the `pool` variable. The diff below shows how the code should be refactored: \n\n<details>\n\n```solidity\nfile: lockbox-solana/solidity/liquidity_lockbox.sol\n\n26:    address public pool;\n```\n\n```diff\ndiff --git a/lockbox-solana/solidity/liquidity_lockbox.sol b/lockbox-solana/solidity/liquidity_lockbox.sol\nindex 6760041..90e50e4 100644\n--- a/lockbox-solana/solidity/liquidity_lockbox.sol\n+++ b/lockbox-solana/solidity/liquidity_lockbox.sol\n@@ -23,7 +23,7 @@ contract liquidity_lockbox {\n     // Orca whirlpool program address\n     address public constant orca = address\"whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc\";\n     // Whirlpool (LP) pool address\n-    address public pool;\n+    address public immutable pool;\n     // Current program owned PDA account address\n     address public pdaProgram;\n     // Bridged token mint address\n```\n```\nEstimated Gas saved: 24200 gas units\n```\n</details>\n\n3. ### The `pdaProgram` state variable could be made `immutable`\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/lockbox-solana/solidity/liquidity_lockbox.sol#L28\n\nMaking the `pdaProgram` state variable immutable would help avoid `Gsset` (20000 gas units) in the constructor during deployment. In implementing this change a cheaper stack read `3 gas` would be used in place of 1 `SLOAD` (cold access 2100 gas units) in the functions `deposit()`and  `withdraw()` which reads the `pdaProgram` variable. The diff below shows how the code should be refactored: \n\n<details>\n\n```solidity\nfile: lockbox-solana/solidity/liquidity_lockbox.sol\n\n28:    address public pdaProgram;\n```\n\n```diff\ndiff --git a/lockbox-solana/solidity/liquidity_lockbox.sol b/lockbox-solana/solidity/liquidity_lockbox.sol\nindex 6760041..a62337b 100644\n--- a/lockbox-solana/solidity/liquidity_lockbox.sol\n+++ b/lockbox-solana/solidity/liquidity_lockbox.sol\n@@ -25,7 +25,7 @@ contract liquidity_lockbox {\n     // Whirlpool (LP) pool address\n     address public pool;\n     // Current program owned PDA account address\n-    address public pdaProgram;\n+    address public immutable pdaProgram;\n     // Bridged token mint address\n     address public bridgedTokenMint;\n     // PDA bridged token account address\n```\n```\nEstimated Gas saved: 24200 gas units\n```\n</details>\n\n4. ### The `bridgedTokenMint` state variable could be made `immutable`\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/lockbox-solana/solidity/liquidity_lockbox.sol#L30\n\nMaking the `bridgedTokenMint` state variable immutable would help avoid `Gsset` (20000 gas units) in the constructor during deployment. In implementing this change a cheaper stack read `3 gas` would be used in place of 1 `SLOAD` (cold access 2100 gas units) in the functions `deposit()`and  `withdraw()` which reads the `bridgedTokenMint` variable. The diff below shows how the code should be refactored:\n\n<details>\n\n```diff\n30:    address public bridgedTokenMint;\n```\n\n```diff\ndiff --git a/lockbox-solana/solidity/liquidity_lockbox.sol b/lockbox-solana/solidity/liquidity_lockbox.sol\nindex 6760041..6e4b2dc 100644\n--- a/lockbox-solana/solidity/liquidity_lockbox.sol\n+++ b/lockbox-solana/solidity/liquidity_lockbox.sol\n@@ -27,7 +27,7 @@ contract liquidity_lockbox {\n     // Current program owned PDA account address\n     address public pdaProgram;\n     // Bridged token mint address\n-    address public bridgedTokenMint;\n+    address public immutable bridgedTokenMint;\n     // PDA bridged token account address\n     address public pdaBridgedTokenAccount;\n     // PDA header for position account\n```\n```\nEstimated Gas saved: 24200 gas units\n```\n</details>\n\n5. ### The `pdaBridgedTokenAccount` state variable could be made `immutable`\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/lockbox-solana/solidity/liquidity_lockbox.sol#L32\n\nMaking the `pdaBridgedTokenAccount` state variable immutable would help avoid `Gsset` (20000 gas units) in the constructor during deployment. In implementing this change a cheaper stack read `3 gas` would be used in place of 1 `SLOAD` (cold access 2100 gas units) in the `withdraw()` function which reads the `pdaBridgedTokenAccount` variable. The diff below shows how the code should be refactored:\n\n<details>\n\n```solidity\nfile: lockbox-solana/solidity/liquidity_lockbox.sol\n\n32:    address public pdaBridgedTokenAccount;\n```\n\n```diff\ndiff --git a/lockbox-solana/solidity/liquidity_lockbox.sol b/lockbox-solana/solidity/liquidity_lockbox.sol\nindex 6760041..88f6abd 100644\n--- a/lockbox-solana/solidity/liquidity_lockbox.sol\n+++ b/lockbox-solana/solidity/liquidity_lockbox.sol\n@@ -29,7 +29,7 @@ contract liquidity_lockbox {\n     // Bridged token mint address\n     address public bridgedTokenMint;\n     // PDA bridged token account address\n-    address public pdaBridgedTokenAccount;\n+    address public immutable pdaBridgedTokenAccount;\n     // PDA header for position account\n     uint64 public pdaHeader = 0xd0f7407ae48fbcaa;\n```\n```\nEstimated Gas saved: 22100 gas units\n```\n</details>\n\n6. ### The `pdaBump` state variable could be made `immutable`\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/lockbox-solana/solidity/liquidity_lockbox.sol#L38\n\nMaking the `pdaBump` state variable immutable would help avoid `Gsset` (20000 gas units) in the constructor during deployment. In implementing this change a cheaper stack read `3 gas` would be used in place of 1 `SLOAD` (cold access 2100 gas units) in the functions `deposit()` and  `withdraw()` which reads the `pdaBump` variable. The diff below shows how the code should be refactored:\n\n<details>\n\n```solidity\nfile: lockbox-solana/solidity/liquidity_lockbox.sol\n\n28:    bytes1 public pdaBump;\n```\n\n```diff\ndiff --git a/lockbox-solana/solidity/liquidity_lockbox.sol b/lockbox-solana/solidity/liquidity_lockbox.sol\nindex 6760041..7c6c4c9 100644\n--- a/lockbox-solana/solidity/liquidity_lockbox.sol\n+++ b/lockbox-solana/solidity/liquidity_lockbox.sol\n@@ -35,7 +35,7 @@ contract liquidity_lockbox {\n     // Program PDA seed\n     bytes public constant pdaProgramSeed = \"pdaProgram\";\n     // Program PDA bump\n-    bytes1 public pdaBump;\n+    bytes1 public immutable pdaBump;\n     int32 public constant minTickLowerIndex = -443632;\n     int32 public constant maxTickLowerIndex = 443632;\n```\n```\nEstimated Gas saved: 24200 gas units\n```\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-12-autonolas",
  "Code": [
    {
      "filename": "tokenomics/contracts/Treasury.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"./interfaces/IErrorsTokenomics.sol\";\nimport \"./interfaces/IOLAS.sol\";\nimport \"./interfaces/IToken.sol\";\nimport \"./interfaces/IServiceRegistry.sol\";\nimport \"./interfaces/ITokenomics.sol\";\n\n/*\n* In this contract we consider both ETH and OLAS tokens.\n* For ETH tokens, there are currently about 121 million tokens.\n* Even if the ETH inflation rate is 5% per year, it would take 130+ years to reach 2^96 - 1 of ETH total supply.\n* Lately the inflation rate was lower and could actually be deflationary.\n*\n* For OLAS tokens, the initial numbers will be as follows:\n*  - For the first 10 years there will be the cap of 1 billion (1e27) tokens;\n*  - After 10 years, the inflation rate is capped at 2% per year.\n* Starting from a year 11, the maximum number of tokens that can be reached per the year x is 1e27 * (1.02)^x.\n* To make sure that a unit(n) does not overflow the total supply during the year x, we have to check that\n* 2^n - 1 >= 1e27 * (1.02)^x. We limit n by 96, thus it would take 220+ years to reach that total supply.\n*\n* We then limit each time variable to last until the value of 2^32 - 1 in seconds.\n* 2^32 - 1 gives 136+ years counted in seconds starting from the year 1970.\n* Thus, this counter is safe until the year 2106.\n*\n* The number of blocks cannot be practically bigger than the number of seconds, since there is more than one second\n* in a block. Thus, it is safe to assume that uint32 for the number of blocks is also sufficient.\n*\n* In conclusion, this contract is only safe to use until 2106.\n*/\n\n/// @title Treasury - Smart contract for managing OLAS Treasury\n/// @author AL\n/// @author Aleksandr Kuperman - <aleksandr.kuperman@valory.xyz>\n/// Invariant does not support a failing call() function while transferring ETH when using the CEI pattern:\n/// revert TransferFailed(address(0), address(this), to, tokenAmount);\n/// invariant {:msg \"broken conservation law\"} address(this).balance == ETHFromServices + ETHOwned;\ncontract Treasury is IErrorsTokenomics {\n    event OwnerUpdated(address indexed owner);\n    event TokenomicsUpdated(address indexed tokenomics);\n    event DepositoryUpdated(address indexed depository);\n    event DispenserUpdated(address indexed dispenser);\n    event DepositTokenFromAccount(address indexed account, address indexed token, uint256 tokenAmount, uint256 olasAmount);\n    event DonateToServicesETH(address indexed sender, uint256[] serviceIds, uint256[] amounts, uint256 donation);\n    event Withdraw(address indexed token, address indexed to, uint256 tokenAmount);\n    event EnableToken(address indexed token);\n    event DisableToken(address indexed token);\n    event ReceiveETH(address indexed sender, uint256 amount);\n    event UpdateTreasuryBalances(uint256 ETHOwned, uint256 ETHFromServices);\n    event PauseTreasury();\n    event UnpauseTreasury();\n    event MinAcceptedETHUpdated(uint256 amount);\n\n    // A well-known representation of an ETH as address\n    address public constant ETH_TOKEN_ADDRESS = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n    // Owner address\n    address public owner;\n    // ETH received from services\n    // Even if the ETH inflation rate is 5% per year, it would take 130+ years to reach 2^96 - 1 of ETH total supply\n    uint96 public ETHFromServices;\n\n    // OLAS token address\n    address public olas;\n    // ETH owned by treasury\n    // Even if the ETH inflation rate is 5% per year, it would take 130+ years to reach 2^96 - 1 of ETH total supply\n    uint96 public ETHOwned;\n\n    // Tkenomics contract address\n    address public tokenomics;\n    // Minimum accepted donation value\n    uint96 public minAcceptedETH = 0.065 ether;\n\n    // Depository contract address\n    address public depository;\n    // Contract pausing\n    uint8 public paused = 1;\n    // Reentrancy lock\n    uint8 internal _locked;\n    \n    // Dispenser contract address\n    address public dispenser;\n\n    // Token address => token reserves\n    mapping(address => uint256) public mapTokenReserves;\n    // Token address => enabled / disabled status\n    mapping(address => bool) public mapEnabledTokens;\n\n    /// @dev Treasury constructor.\n    /// @param _olas OLAS token address.\n    /// @param _tokenomics Tokenomics address.\n    /// @param _depository Depository address.\n    /// @param _dispenser Dispenser address.\n    constructor(address _olas, address _tokenomics, address _depository, address _dispenser) payable {\n        owner = msg.sender;\n        _locked = 1;\n\n        // Check for at least one zero contract address\n        if (_olas == address(0) || _tokenomics == address(0) || _depository == address(0) || _dispenser == address(0)) {\n            revert ZeroAddress();\n        }\n\n        olas = _olas;\n        tokenomics = _tokenomics;\n        depository = _depository;\n        dispenser = _dispenser;\n\n        // Assign an initial contract address ETH balance\n        // If msg.value is passed in the constructor, it is already accounted for in the address balance\n        // This way the balance also accounts for possible transfers before the contract was created\n        ETHOwned = uint96(address(this).balance);\n    }\n\n    /// @dev Receives ETH.\n    /// #if_succeeds {:msg \"we do not touch the balance of developers\" } old(ETHFromServices) == ETHFromServices;\n    /// #if_succeeds {:msg \"conservation law\"} old(ETHOwned) + msg.value + old(ETHFromServices) <= type(uint96).max && ETHOwned == old(ETHOwned) + msg.value\n    /// ==> address(this).balance == ETHFromServices + ETHOwned;\n    /// #if_succeeds {:msg \"any paused\"} paused == 1 || paused == 2;\n    receive() external payable {\n        if (msg.value < minAcceptedETH) {\n            revert LowerThan(msg.value, minAcceptedETH);\n        }\n\n        uint256 amount = ETHOwned;\n        amount += msg.value;\n        // Check for the overflow values, specifically when fuzzing, since practically these amounts are not realistic\n        if (amount + ETHFromServices > type(uint96).max) {\n            revert Overflow(amount, type(uint96).max);\n        }\n        ETHOwned = uint96(amount);\n        emit ReceiveETH(msg.sender, msg.value);\n    }\n\n    /// @dev Changes the owner address.\n    /// @param newOwner Address of a new owner.\n    function changeOwner(address newOwner) external {\n        // Check for the contract ownership\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n\n        // Check for the zero address\n        if (newOwner == address(0)) {\n            revert ZeroAddress();\n        }\n\n        owner = newOwner;\n        emit OwnerUpdated(newOwner);\n    }\n\n    /// @dev Changes various managing contract addresses.\n    /// @param _tokenomics Tokenomics address.\n    /// @param _depository Depository address.\n    /// @param _dispenser Dispenser address.\n    function changeManagers(address _tokenomics, address _depository, address _dispenser) external {\n        // Check for the contract ownership\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n\n        // Change Tokenomics contract address\n        if (_tokenomics != address(0)) {\n            tokenomics = _tokenomics;\n            emit TokenomicsUpdated(_tokenomics);\n        }\n        // Change Depository contract address\n        if (_depository != address(0)) {\n            depository = _depository;\n            emit DepositoryUpdated(_depository);\n        }\n        // Change Dispenser contract address\n        if (_dispenser != address(0)) {\n            dispenser = _dispenser;\n            emit DispenserUpdated(_dispenser);\n        }\n    }\n\n    /// @dev Changes minimum accepted ETH amount by the Treasury.\n    /// @param _minAcceptedETH New minimum accepted ETH amount.\n    /// #if_succeeds {:msg \"Min accepted ETH\"} minAcceptedETH > 0 && minAcceptedETH <= type(uint96).max;\n    function changeMinAcceptedETH(uint256 _minAcceptedETH) external {\n        // Check for the contract ownership\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n\n        // Check for the zero value\n        if (_minAcceptedETH == 0) {\n            revert ZeroValue();\n        }\n\n        // Check for the overflow value\n        if (_minAcceptedETH > type(uint96).max) {\n            revert Overflow(_minAcceptedETH, type(uint96).max);\n        }\n\n        minAcceptedETH = uint96(_minAcceptedETH);\n        emit MinAcceptedETHUpdated(_minAcceptedETH);\n    }\n\n    /// @dev Allows the depository to deposit LP tokens for OLAS.\n    /// @notice Only depository contract can call this function.\n    /// @param account Account address making a deposit of LP tokens for OLAS.\n    /// @param tokenAmount Token amount to get OLAS for.\n    /// @param token Token address.\n    /// @param olasMintAmount Amount of OLAS token issued.\n    /// #if_succeeds {:msg \"we do not touch the total eth balance\"} old(address(this).balance) == address(this).balance;\n    /// #if_succeeds {:msg \"any paused\"} paused == 1 || paused == 2;\n    /// #if_succeeds {:msg \"OLAS balances\"} IToken(olas).balanceOf(msg.sender) == old(IToken(olas).balanceOf(msg.sender)) + olasMintAmount;\n    /// #if_succeeds {:msg \"OLAS supply\"} IToken(olas).totalSupply() == old(IToken(olas).totalSupply()) + olasMintAmount;\n    function depositTokenForOLAS(address account, uint256 tokenAmount, address token, uint256 olasMintAmount) external {\n        // Check for the depository access\n        if (depository != msg.sender) {\n            revert ManagerOnly(msg.sender, depository);\n        }\n\n        // Check if the token is authorized by the registry\n        if (!mapEnabledTokens[token]) {\n            revert UnauthorizedToken(token);\n        }\n\n        // Increase the amount of LP token reserves\n        uint256 reserves = mapTokenReserves[token] + tokenAmount;\n        mapTokenReserves[token] = reserves;\n\n        // Uniswap allowance implementation does not revert with the accurate message, need to check before the transfer is engaged\n        if (IToken(token).allowance(account, address(this)) < tokenAmount) {\n            revert InsufficientAllowance(IToken(token).allowance((account), address(this)), tokenAmount);\n        }\n\n        // Transfer tokens from account to treasury and add to the token treasury reserves\n        // We assume that authorized LP tokens in the protocol are safe as they are enabled via the governance\n        // UniswapV2ERC20 realization has a standard transferFrom() function that returns a boolean value\n        bool success = IToken(token).transferFrom(account, address(this), tokenAmount);\n        if (!success) {\n            revert TransferFailed(token, account, address(this), tokenAmount);\n        }\n\n        // Mint specified number of OLAS tokens corresponding to tokens bonding deposit\n        // The olasMintAmount is guaranteed by the product supply limit, which is limited by the effectiveBond\n        IOLAS(olas).mint(msg.sender, olasMintAmount);\n\n        emit DepositTokenFromAccount(account, token, tokenAmount, olasMintAmount);\n    }\n\n    /// @dev Deposits service donations in ETH.\n    /// @notice Each provided service Id must be deployed at least once, otherwise its components and agents are undefined.\n    /// @notice If a specific service is terminated with agent Ids being updated, incentives will be issued to its old\n    ///         configuration component / agent owners until the service is re-deployed when new agent Ids are accounted for.\n    /// @param serviceIds Set of service Ids.\n    /// @param amounts Set of corresponding amounts deposited on behalf of each service Id.\n    /// #if_succeeds {:msg \"we do not touch the owners balance\"} old(ETHOwned) == ETHOwned;\n    /// #if_succeeds {:msg \"updated ETHFromServices\"} old(ETHFromServices) + msg.value + old(ETHOwned) <= type(uint96).max && ETHFromServices == old(ETHFromServices) + msg.value\n    /// ==> address(this).balance == ETHFromServices + ETHOwned;\n    /// #if_succeeds {:msg \"any paused\"} paused == 1 || paused == 2;\n    function depositServiceDonationsETH(uint256[] memory serviceIds, uint256[] memory amounts) external payable {\n        // Reentrancy guard\n        if (_locked > 1) {\n            revert ReentrancyGuard();\n        }\n        _locked = 2;\n\n        // Check that the amount donated has at least a practical minimal value\n        if (msg.value < minAcceptedETH) {\n            revert LowerThan(msg.value, minAcceptedETH);\n        }\n\n        // Check for the same length of arrays\n        uint256 numServices = serviceIds.length;\n        if (amounts.length != numServices) {\n            revert WrongArrayLength(numServices, amounts.length);\n        }\n\n        uint256 totalAmount;\n        for (uint256 i = 0; i < numServices; ++i) {\n            if (amounts[i] == 0) {\n                revert ZeroValue();\n            }\n            totalAmount += amounts[i];\n        }\n\n        // Check if the total transferred amount corresponds to the sum of amounts from services\n        if (msg.value != totalAmount) {\n            revert WrongAmount(msg.value, totalAmount);\n        }\n\n        // Accumulate received donation from services\n        uint256 donationETH = ETHFromServices + msg.value;\n        // Check for the overflow values, specifically when fuzzing, since realistically these amounts are assumed to be not possible\n        if (donationETH + ETHOwned > type(uint96).max) {\n            revert Overflow(donationETH, type(uint96).max);\n        }\n        ETHFromServices = uint96(donationETH);\n        emit DonateToServicesETH(msg.sender, serviceIds, amounts, msg.value);\n\n        // Track service donations on the Tokenomics side\n        ITokenomics(tokenomics).trackServiceDonations(msg.sender, serviceIds, amounts, msg.value);\n\n        _locked = 1;\n    }\n\n    /// @dev Allows owner to transfer tokens from treasury reserves to a specified address.\n    /// @param to Address to transfer funds to.\n    /// @param tokenAmount Token amount to get reserves from.\n    /// @param token Token or ETH address.\n    /// @return success True if the transfer is successful.\n    /// #if_succeeds {:msg \"we do not touch the balance of developers\"} old(ETHFromServices) == ETHFromServices;\n    /// #if_succeeds {:msg \"updated ETHOwned\"} token == ETH_TOKEN_ADDRESS ==> ETHOwned == old(ETHOwned) - tokenAmount;\n    /// #if_succeeds {:msg \"ETH balance\"} token == ETH_TOKEN_ADDRESS ==> address(this).balance == old(address(this).balance) - tokenAmount;\n    /// #if_succeeds {:msg \"updated token reserves\"} token != ETH_TOKEN_ADDRESS ==> mapTokenReserves[token] == old(mapTokenReserves[token]) - tokenAmount;\n    /// #if_succeeds {:msg \"any paused\"} paused == 1 || paused == 2;\n    function withdraw(address to, uint256 tokenAmount, address token) external returns (bool success) {\n        // Check for the contract ownership\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n\n        // Check that the withdraw address is not treasury itself\n        if (to == address(this)) {\n            revert TransferFailed(token, address(this), to, tokenAmount);\n        }\n\n        // Check for the zero withdraw amount\n        if (tokenAmount == 0) {\n            revert ZeroValue();\n        }\n\n        // ETH address is taken separately, and all the LP tokens must be validated with corresponding token reserves\n        if (token == ETH_TOKEN_ADDRESS) {\n            uint256 amountOwned = ETHOwned;\n            // Check if treasury has enough amount of owned ETH\n            if (amountOwned >= tokenAmount) {\n                // This branch is used to transfer ETH to a specified address\n                amountOwned -= tokenAmount;\n                ETHOwned = uint96(amountOwned);\n                emit Withdraw(ETH_TOKEN_ADDRESS, to, tokenAmount);\n                // Send ETH to the specified address\n                (success, ) = to.call{value: tokenAmount}(\"\");\n                if (!success) {\n                    revert TransferFailed(ETH_TOKEN_ADDRESS, address(this), to, tokenAmount);\n                }\n            } else {\n                // Insufficient amount of treasury owned ETH\n                revert LowerThan(tokenAmount, amountOwned);\n            }\n        } else {\n            // Only approved token reserves can be used for redemptions\n            if (!mapEnabledTokens[token]) {\n                revert UnauthorizedToken(token);\n            }\n            // Decrease the global LP token reserves record\n            uint256 reserves = mapTokenReserves[token];\n            if (reserves >= tokenAmount) {\n                reserves -= tokenAmount;\n                mapTokenReserves[token] = reserves;\n\n                emit Withdraw(token, to, tokenAmount);\n                // Transfer LP tokens\n                // We assume that LP tokens enabled in the protocol are safe by default\n                // UniswapV2ERC20 realization has a standard transfer() function\n                success = IToken(token).transfer(to, tokenAmount);\n                if (!success) {\n                    revert TransferFailed(token, address(this), to, tokenAmount);\n                }\n            }  else {\n                // Insufficient amount of LP tokens\n                revert LowerThan(tokenAmount, reserves);\n            }\n        }\n    }\n\n    /// @dev Withdraws ETH and / or OLAS amounts to the requested account address.\n    /// @notice Only dispenser contract can call this function.\n    /// @notice Reentrancy guard is on a dispenser side.\n    /// @notice Zero account address is not possible, since the dispenser contract interacts with msg.sender.\n    /// @param account Account address.\n    /// @param accountRewards Amount of account rewards.\n    /// @param accountTopUps Amount of account top-ups.\n    /// @return success True if the function execution is successful.\n    /// #if_succeeds {:msg \"we do not touch the owners balance\"} old(ETHOwned) == ETHOwned;\n    /// #if_succeeds {:msg \"updated ETHFromServices\"} accountRewards > 0 && ETHFromServices >= accountRewards ==> ETHFromServices == old(ETHFromServices) - accountRewards;\n    /// #if_succeeds {:msg \"ETH balance\"} accountRewards > 0 && ETHFromServices >= accountRewards ==> address(this).balance == old(address(this).balance) - accountRewards;\n    /// #if_succeeds {:msg \"updated OLAS balances\"} accountTopUps > 0 ==> IToken(olas).balanceOf(account) == old(IToken(olas).balanceOf(account)) + accountTopUps;\n    /// #if_succeeds {:msg \"OLAS supply\"} IToken(olas).totalSupply() == old(IToken(olas).totalSupply()) + accountTopUps;\n    /// #if_succeeds {:msg \"unpaused\"} paused == 1;\n    function withdrawToAccount(address account, uint256 accountRewards, uint256 accountTopUps) external\n        returns (bool success)\n    {\n        // Check if the contract is paused\n        if (paused == 2) {\n            revert Paused();\n        }\n\n        // Check for the dispenser access\n        if (dispenser != msg.sender) {\n            revert ManagerOnly(msg.sender, dispenser);\n        }\n\n        uint256 amountETHFromServices = ETHFromServices;\n        // Send ETH rewards, if any\n        if (accountRewards > 0 && amountETHFromServices >= accountRewards) {\n            amountETHFromServices -= accountRewards;\n            ETHFromServices = uint96(amountETHFromServices);\n            emit Withdraw(ETH_TOKEN_ADDRESS, account, accountRewards);\n            (success, ) = account.call{value: accountRewards}(\"\");\n            if (!success) {\n                revert TransferFailed(address(0), address(this), account, accountRewards);\n            }\n        }\n\n        // Send OLAS top-ups\n        if (accountTopUps > 0) {\n            // Tokenomics has already accounted for the account's top-up amount,\n            // thus the the mint does not break the inflation schedule\n            IOLAS(olas).mint(account, accountTopUps);\n            success = true;\n            emit Withdraw(olas, account, accountTopUps);\n        }\n    }\n\n    /// @dev Re-balances treasury funds to account for the treasury reward for a specific epoch.\n    /// @param treasuryRewards Treasury rewards.\n    /// @return success True, if the function execution is successful.\n    /// #if_succeeds {:msg \"we do not touch the total eth balance\"} old(address(this).balance) == address(this).balance;\n    /// #if_succeeds {:msg \"conservation law\"} old(ETHFromServices + ETHOwned) == ETHFromServices + ETHOwned;\n    /// #if_succeeds {:msg \"unpaused\"} paused == 1;\n    function rebalanceTreasury(uint256 treasuryRewards) external returns (bool success) {\n        // Check if the contract is paused\n        if (paused == 2) {\n            revert Paused();\n        }\n\n        // Check for the tokenomics contract access\n        if (msg.sender != tokenomics) {\n            revert ManagerOnly(msg.sender, tokenomics);\n        }\n\n        // Collect treasury's own reward share\n        success = true;\n        if (treasuryRewards > 0) {\n            uint256 amountETHFromServices = ETHFromServices;\n            if (amountETHFromServices >= treasuryRewards) {\n                // Update ETH from services value\n                amountETHFromServices -= treasuryRewards;\n                // Update treasury ETH owned values\n                uint256 amountETHOwned = ETHOwned;\n                amountETHOwned += treasuryRewards;\n                // Assign back to state variables\n                ETHOwned = uint96(amountETHOwned);\n                ETHFromServices = uint96(amountETHFromServices);\n                emit UpdateTreasuryBalances(amountETHOwned, amountETHFromServices);\n            } else {\n                // There is not enough amount from services to allocate to the treasury\n                success = false;\n            }\n        }\n    }\n\n    /// @dev Drains slashed funds from the service registry.\n    /// @return amount Drained amount.\n    /// #if_succeeds {:msg \"correct update total eth balance\"} address(this).balance == old(address(this).balance) + amount;\n    /// #if_succeeds {:msg \"conservation law\"} ETHFromServices + ETHOwned == old(ETHFromServices + ETHOwned) + amount;\n    ///if_succeeds {:msg \"slashed funds check\"} IServiceRegistry(ITokenomics(tokenomics).serviceRegistry()).slashedFunds() >= minAcceptedETH\n    /// ==> old(IServiceRegistry(ITokenomics(tokenomics).serviceRegistry()).slashedFunds()) == amount;\n    function drainServiceSlashedFunds() external returns (uint256 amount) {\n        // Check for the contract ownership\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n\n        // Get the service registry contract address\n        address serviceRegistry = ITokenomics(tokenomics).serviceRegistry();\n\n        // Check if the amount of slashed funds are at least the minimum required amount to receive by the Treasury\n        uint256 slashedFunds = IServiceRegistry(serviceRegistry).slashedFunds();\n        if (slashedFunds < minAcceptedETH) {\n            revert LowerThan(slashedFunds, minAcceptedETH);\n        }\n\n        // Call the service registry drain function\n        amount = IServiceRegistry(serviceRegistry).drain();\n    }\n\n    /// @dev Enables an LP token to be bonded for OLAS.\n    /// @param token Token address.\n    function enableToken(address token) external {\n        // Check for the contract ownership\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n\n        // Check for the zero address token\n        if (token == address(0)) {\n            revert ZeroAddress();\n        }\n\n        // Authorize the token\n        if (!mapEnabledTokens[token]) {\n            mapEnabledTokens[token] = true;\n            emit EnableToken(token);\n        }\n    }\n\n    /// @dev Disables an LP token from the ability to bond for OLAS.\n    /// @param token Token address.\n    function disableToken(address token) external {\n        // Check for the contract ownership\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n\n        if (mapEnabledTokens[token]) {\n            // The reserves of a token must be zero in order to disable it\n            if (mapTokenReserves[token] > 0) {\n                revert NonZeroValue();\n            }\n            mapEnabledTokens[token] = false;\n            emit DisableToken(token);\n        }\n    }\n\n    /// @dev Gets information about token being enabled for bonding.\n    /// @param token Token address.\n    /// @return enabled True if token is enabled.\n    function isEnabled(address token) external view returns (bool enabled) {\n        enabled = mapEnabledTokens[token];\n    }\n\n    /// @dev Pauses the contract.\n    function pause() external {\n        // Check for the contract ownership\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n\n        paused = 2;\n        emit PauseTreasury();\n    }\n\n    /// @dev Unpauses the contract.\n    function unpause() external {\n        // Check for the contract ownership\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n\n        paused = 1;\n        emit UnpauseTreasury();\n    }\n}"
    },
    {
      "filename": "lockbox-solana/solidity/liquidity_lockbox.sol",
      "content": "import \"./library/spl_token.sol\";\nimport \"./interfaces/whirlpool.sol\";\n\n// Position struct\nstruct Position {\n    // Whirlpool (LP pool) address, 32 bytes\n    address whirlpool;\n    // Position mint (liquidity NFT) address, 32 bytes\n    address positionMint;\n    // Position liquidity, 16 bytes\n    uint128 liquidity;\n    // Tick lower index, 4 bytes\n    int32 tickLowerIndex;\n    /// Tick upper index, 4 bytes\n    int32 tickUpperIndex;\n}\n\n/// @dev The liquidity in the position cannot be practically bigger than the max of uint64 since\n///      spl token functions are limited by the uint64 value.\n\n@program_id(\"GUGGHzwC8wEKY3g7QS38YmoS8t5Q2faWAGAfxDK2bXbb\")\ncontract liquidity_lockbox {\n    // Orca whirlpool program address\n    address public constant orca = address\"whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc\";\n    // Whirlpool (LP) pool address\n    address public pool;\n    // Current program owned PDA account address\n    address public pdaProgram;\n    // Bridged token mint address\n    address public bridgedTokenMint;\n    // PDA bridged token account address\n    address public pdaBridgedTokenAccount;\n    // PDA header for position account\n    uint64 public pdaHeader = 0xd0f7407ae48fbcaa;\n    // Program PDA seed\n    bytes public constant pdaProgramSeed = \"pdaProgram\";\n    // Program PDA bump\n    bytes1 public pdaBump;\n    int32 public constant minTickLowerIndex = -443632;\n    int32 public constant maxTickLowerIndex = 443632;\n\n    // Total number of token accounts (even those that hold no positions anymore)\n    uint32 public numPositionAccounts;\n    // First available account index in the set of accounts;\n    uint32 public firstAvailablePositionAccountIndex;\n    // Total liquidity in a lockbox\n    uint64 public totalLiquidity;\n\n    //\n    mapping(address => uint64) public mapPositionAccountLiquidity;\n    mapping(address => address) public mapPositionAccountPdaAta;\n    address[type(uint32).max] public positionAccounts;\n\n    @space(10000)\n    @payer(payer)\n    @seed(\"pdaProgram\")\n    constructor(\n        address _pool,\n        address _bridgedTokenMint,\n        address _pdaBridgedTokenAccount,\n        @bump bytes1 _bump\n    ) {\n        pool = _pool;\n        bridgedTokenMint = _bridgedTokenMint;\n        pdaBridgedTokenAccount = _pdaBridgedTokenAccount;\n\n        // Independently derive the PDA address from the seeds, bump, and programId\n        (address pda, bytes1 bump) = try_find_program_address([\"pdaProgram\"], type(liquidity_lockbox).program_id);\n\n        // Verify that the bump passed to the constructor matches the bump derived from the seeds and programId\n        if (bump != _bump) {\n            revert(\"Invalid bump\");\n        }\n\n        // Assign pda and bump\n        pdaProgram = pda;\n        pdaBump = bump;\n    }\n\n    /// @dev Gets the position data.\n    /// @param position Position account.\n    /// @param positionMint Position mint (NFT).\n    /// @return positionData Position data.\n    function _getPositionData(AccountInfo position, address positionMint) internal view returns (Position positionData) {\n        // Extract the position data\n        positionData = Position({\n            whirlpool: position.data.readAddress(8),\n            positionMint: position.data.readAddress(40),\n            liquidity: position.data.readUint128LE(72),\n            tickLowerIndex: position.data.readInt32LE(88),\n            tickUpperIndex: position.data.readInt32LE(92)\n        });\n\n        // Check that the liquidity is within uint64 bounds\n        if (positionData.liquidity > type(uint64).max) {\n            revert(\"Liquidity overflow\");\n        }\n\n        // Check the whirlpool\n        if (positionData.whirlpool != pool) {\n            revert(\"Wrong pool address\");\n        }\n\n        // Check the NFT address\n        if (positionData.positionMint != positionMint) {\n            revert(\"Wrong NFT address\");\n        }\n\n        // Check tick values\n        if (positionData.tickLowerIndex != minTickLowerIndex || positionData.tickUpperIndex != maxTickLowerIndex) {\n            revert(\"Wrong ticks\");\n        }\n\n        // Check the PDA ownership\n        if (position.owner != orca) {\n            revert(\"Wrong PDA owner\");\n        }\n\n        // Check the PDA header data\n        uint64 header = position.data.readUint64LE(0);\n        if (header != pdaHeader) {\n            revert(\"Wrong PDA header\");\n        }\n\n        // Check the PDA address correctness\n        (address pdaPosition, ) = try_find_program_address([\"position\", positionData.positionMint], orca);\n        if (pdaPosition != position.key) {\n            revert(\"Wrong position PDA\");\n        }\n    }\n\n    /// @dev Deposits the position mint (NFT) in order to get a corresponding liquidity amount of bridged tokens\n    @mutableAccount(userPositionAccount)\n    @mutableAccount(pdaPositionAccount)\n    @mutableAccount(userBridgedTokenAccount)\n    @mutableAccount(bridgedTokenMint)\n    @account(position)\n    @account(positionMint)\n    @signer(userWallet)\n    function deposit() external {\n        // Get the position data based on provided accounts\n        Position positionData = _getPositionData(tx.accounts.position, tx.accounts.positionMint.key);\n\n        uint64 positionLiquidity = uint64(positionData.liquidity);\n\n        // Check that the mint of the user position ATA matches the position mint\n        address positionMint = tx.accounts.userPositionAccount.data.readAddress(0);\n        if (positionMint != tx.accounts.positionMint.key) {\n            revert(\"Wrong user position ATA\");\n        }\n\n        // Check that the bridged token mint account is correct\n        if (tx.accounts.bridgedTokenMint.key != bridgedTokenMint) {\n            revert(\"Wrong bridged token mint account\");\n        }\n\n        // PDA position account owner must be the PDA program account\n        address pdaPositionOwner = tx.accounts.pdaPositionAccount.data.readAddress(32);\n        if (pdaPositionOwner != pdaProgram) {\n            revert(\"Wrong PDA position owner\");\n        }\n\n        // Transfer the position NFT to the pdaPositionAccount address of this program\n        SplToken.transfer(\n            tx.accounts.userPositionAccount.key,\n            tx.accounts.pdaPositionAccount.key,\n            tx.accounts.userWallet.key,\n            1);\n\n        // Mint bridged tokens to the user\n        SplToken.pda_mint_to(\n            bridgedTokenMint,\n            tx.accounts.userBridgedTokenAccount.key,\n            pdaProgram,\n            positionLiquidity,\n            pdaProgramSeed,\n            pdaBump);\n\n        // Record position liquidity amount and its correspondent account address\n        address positionAddress = tx.accounts.position.key;\n        mapPositionAccountLiquidity[positionAddress] = positionLiquidity;\n        address pdaPositionAta = tx.accounts.pdaPositionAccount.key;\n        mapPositionAccountPdaAta[positionAddress] = pdaPositionAta;\n        positionAccounts[numPositionAccounts] = positionAddress;\n\n        // Increase the total number of positions\n        numPositionAccounts++;\n        // Increase the amount of total liquidity\n        totalLiquidity += positionLiquidity;\n    }\n\n    /// @dev Withdraws LP tokens separately to each token ATA and burns provided bridge tokens.\n    /// @param amount Bridged token amount.\n    @mutableAccount(pool)\n    @account(tokenProgramId)\n    @mutableAccount(position)\n    @mutableAccount(userBridgedTokenAccount)\n    @mutableAccount(pdaBridgedTokenAccount)\n    @mutableAccount(userWallet)\n    @mutableAccount(bridgedTokenMint)\n    @mutableAccount(pdaPositionAccount)\n    @mutableAccount(userTokenAccountA)\n    @mutableAccount(userTokenAccountB)\n    @mutableAccount(tokenVaultA)\n    @mutableAccount(tokenVaul"
    }
  ]
}