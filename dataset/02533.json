{
  "Title": "H-2: Loans can be rolled an unlimited number of times",
  "Content": "# Issue H-2: Loans can be rolled an unlimited number of times \n\nSource: https://github.com/sherlock-audit/2023-01-cooler-judging/issues/215 \n\n## Found by \n0x52, enckrish, IllIllI, cducrest-brainbot, banditx0x, simon135, Allarious, Trumpero, Breeje, neumo, Atarpara, yixxas, libratus, usmannk, ali\\_shehab, oxcm, thekmj, HollaDieWaldfee, HonorLt, bin2chen\n\n## Summary\n\nLoans can be rolled an unlimited number of times, without letting the lender decide if has been done too many times already\n\n\n## Vulnerability Detail\n\nThe lender is expected to be able to toggle whether a loan can be rolled or not, but once it's enabled, there is no way to prevent the borrower from rolling an unlimited number of times in the same transaction or in quick succession.\n\n\n## Impact\n\nIf the lender is giving an interest-free loan and assumes that allowing a roll will only extend the term by one, they'll potentially be forced to wait until the end of the universe if the borrower chooses to roll an excessive number of times.\n\nIf the borrower is using a quickly-depreciating collateral, the lender may be happy to allow one a one-term extension, but will lose money if the term is rolled multiple times and the borrower defaults thereafter.\n\nThe initial value of `loan.rollable` is always `true`, so unless the lender calls `toggleRoll()` in the same transaction that they call `clear()`, a determined attacker will be able to roll as many times as they wish.\n\n\n## Code Snippet\n\nAs long as the borrower is willing to pay the interest up front, they can call `roll()` any number of times, extending the duration of the total loan to however long they wish:\n```solidity\n// File: src/Cooler.sol : Cooler.roll()   #1\n\n129        function roll (uint256 loanID) external {\n130            Loan storage loan = loans[loanID];\n131            Request memory req = loan.request;\n132    \n133            if (block.timestamp > loan.expiry) \n134                revert Default();\n135    \n136            if (!loan.rollable)\n137                revert NotRollable();\n138    \n139            uint256 newCollateral = collateralFor(loan.amount, req.loanToCollateral) - loan.collateral;\n140            uint256 newDebt = interestFor(loan.amount, req.interest, req.duration);\n141    \n142            loan.amount += newDebt;\n143            loan.expiry += req.duration;\n144            loan.collateral += newCollateral;\n145            \n146            collateral.transferFrom(msg.sender, address(this), newCollateral);\n147:       }\n```\nhttps://github.com/sherlock-audit/2023-01-cooler/blob/main/src/Cooler.sol#L129-L147\n\n[`toggleRoll()`](https://github.com/sherlock-audit/2023-01-cooler/blob/main/src/Cooler.sol#L185-L193) can't be used to stop rolls if they're all done in a single transaction.\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nHave a variable controlling the number of rolls the lender is allowing, and or only allow a roll if the current `block.timestamp` is within one `req.duration` of the current `loan.expiry`\n\n\n## Discussion\n\n**hrishibhat**\n\nSponsor comment:\n> Will resolve as result of change for #265\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/36",
  "Code": [
    {
      "filename": "src/Cooler.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./lib/mininterfaces.sol\";\nimport \"./Factory.sol\";\n\n/// @notice A Cooler is a smart contract escrow that facilitates fixed-duration loans\n///         for a specific user and debt-collateral pair.\ncontract Cooler {\n    // Errors\n\n    error OnlyApproved();\n    error Deactivated();\n    error Default();\n    error NoDefault();\n    error NotRollable();\n\n    // Data Structures\n\n    Request[] public requests;\n    struct Request { // A loan begins with a borrow request. It specifies:\n        uint256 amount; // the amount they want to borrow,\n        uint256 interest; // the annualized percentage they will pay as interest,\n        uint256 loanToCollateral; // the loan-to-collateral ratio they want,\n        uint256 duration; // and the length of time until the loan defaults.\n        bool active; // Any lender can clear an active loan request.\n    } \n\n    Loan[] public loans;\n    struct Loan { // A request is converted to a loan when a lender clears it.\n        Request request; // The terms of the loan are saved, along with:\n        uint256 amount; // the amount of debt owed,\n        uint256 collateral; // the amount of collateral pledged,\n        uint256 expiry; // the time when the loan defaults,\n        bool rollable; // whether the loan can be rolled over,\n        address lender; // and the lender's address.\n    }\n\n    // Facilitates transfer of lender ownership to new address\n    mapping(uint256 => address) public approvals;\n\n    // Immutables\n\n    // This address owns the collateral in escrow.\n    address private immutable owner;\n    // This token is borrowed against.\n    ERC20 public immutable collateral;\n    // This token is lent.\n    ERC20 public immutable debt;\n    // This contract created the Cooler\n    CoolerFactory public immutable factory;\n\n    // This makes the code look prettier.\n    uint256 private constant decimals = 1e18;\n\n    // Initialization\n\n    constructor (address o, ERC20 c, ERC20 d) {\n        owner = o;\n        collateral = c;\n        debt = d;\n        factory = CoolerFactory(msg.sender);\n    }\n\n    // Borrower\n\n    /// @notice request a loan with given parameters\n    /// @notice collateral is taken at time of request\n    /// @param amount of debt tokens to borrow\n    /// @param interest to pay (annualized % of 'amount')\n    /// @param loanToCollateral debt tokens per collateral token pledged\n    /// @param duration of loan tenure in seconds\n    /// @param reqID index of request in requests[]\n    function request (\n        uint256 amount,\n        uint256 interest,\n        uint256 loanToCollateral,\n        uint256 duration\n    ) external returns (uint256 reqID) {\n        reqID = requests.length;\n        factory.newEvent(reqID, CoolerFactory.Events.Request);\n        requests.push(\n            Request(amount, interest, loanToCollateral, duration, true)\n        );\n        collateral.transferFrom(msg.sender, address(this), collateralFor(amount, loanToCollateral));\n    }\n\n    /// @notice cancel a loan request and return collateral\n    /// @param reqID index of request in requests[]\n    function rescind (uint256 reqID) external {\n        if (msg.sender != owner) \n            revert OnlyApproved();\n\n        factory.newEvent(reqID, CoolerFactory.Events.Rescind);\n\n        Request storage req = requests[reqID];\n\n        if (!req.active)\n            revert Deactivated();\n        \n        req.active = false;\n        collateral.transfer(owner, collateralFor(req.amount, req.loanToCollateral));\n    }\n\n    /// @notice repay a loan to recoup collateral\n    /// @param loanID index of loan in loans[]\n    /// @param repaid debt tokens to repay\n    function repay (uint256 loanID, uint256 repaid) external {\n        Loan storage loan = loans[loanID];\n\n        if (block.timestamp > loan.expiry) \n            revert Default();\n        \n        uint256 decollateralized = loan.collateral * repaid / loan.amount;\n\n        if (repaid == loan.amount) delete loans[loanID];\n        else {\n            loan.amount -= repaid;\n            loan.collateral -= decollateralized;\n        }\n\n        debt.transferFrom(msg.sender, loan.lender, repaid);\n        collateral.transfer(owner, decollateralized);\n    }\n\n    /// @notice roll a loan over\n    /// @notice uses terms from request\n    /// @param loanID index of loan in loans[]\n    function roll (uint256 loanID) external {\n        Loan storage loan = loans[loanID];\n        Request memory req = loan.request;\n\n        if (block.timestamp > loan.expiry) \n            revert Default();\n\n        if (!loan.rollable)\n            revert NotRollable();\n\n        uint256 newCollateral = collateralFor(loan.amount, req.loanToCollateral) - loan.collateral;\n        uint256 newDebt = interestFor(loan.amount, req.interest, req.duration);\n\n        loan.amount += newDebt;\n        loan.expiry += req.duration;\n        loan.collateral += newCollateral;\n        \n        collateral.transferFrom(msg.sender, address(this), newCollateral);\n    }\n\n    /// @notice delegate voting power on collateral\n    /// @param to address to delegate\n    function delegate (address to) external {\n        if (msg.sender != owner) \n            revert OnlyApproved();\n        IDelegateERC20(address(collateral)).delegate(to);\n    }\n\n    // Lender\n\n    /// @notice fill a requested loan as a lender\n    /// @param reqID index of request in requests[]\n    /// @param loanID index of loan in loans[]\n    function clear (uint256 reqID) external returns (uint256 loanID) {\n        Request storage req = requests[reqID];\n\n        factory.newEvent(reqID, CoolerFactory.Events.Clear);\n\n        if (!req.active) \n            revert Deactivated();\n        else req.active = false;\n\n        uint256 interest = interestFor(req.amount, req.interest, req.duration);\n        uint256 collat = collateralFor(req.amount, req.loanToCollateral);\n        uint256 expiration = block.timestamp + req.duration;\n\n        loanID = loans.length;\n        loans.push(\n            Loan(req, req.amount + interest, collat, expiration, true, msg.sender)\n        );\n        debt.transferFrom(msg.sender, owner, req.amount);\n    }\n\n    /// @notice change 'rollable' status of loan\n    /// @param loanID index of loan in loans[]\n    /// @return bool new 'rollable' status\n    function toggleRoll(uint256 loanID) external returns (bool) {\n        Loan storage loan = loans[loanID];\n\n        if (msg.sender != loan.lender)\n            revert OnlyApproved();\n\n        loan.rollable = !loan.rollable;\n        return loan.rollable;\n    }\n\n    /// @notice send collateral to lender upon default\n    /// @param loanID index of loan in loans[]\n    /// @return uint256 collateral amount\n    function defaulted (uint256 loanID) external returns (uint256) {\n        Loan memory loan = loans[loanID];\n        delete loans[loanID];\n\n        if (block.timestamp <= loan.expiry) \n            revert NoDefault();\n\n        collateral.transfer(loan.lender, loan.collateral);\n        return loan.collateral;\n    }\n\n    /// @notice approve transfer of loan ownership to new address\n    /// @param to address to approve\n    /// @param loanID index of loan in loans[]\n    function approve (address to, uint256 loanID) external {\n        Loan memory loan = loans[loanID];\n\n        if (msg.sender != loan.lender)\n            revert OnlyApproved();\n\n        approvals[loanID] = to;\n    }\n\n    /// @notice execute approved transfer of loan ownership\n    /// @param loanID index of loan in loans[]\n    function transfer (uint256 loanID) external {\n        if (msg.sender != approvals[loanID])\n            revert OnlyApproved();\n\n        approvals[loanID] = address(0);\n        loans[loanID].lender = msg.sender;\n    }\n\n    // Views\n\n    /// @notice compute collateral needed for loan amount at given loan to collateral ratio\n    /// @param amount of collateral tokens\n    /// @param loanToCollateral ratio for loan\n    function collateralFor(uint256 amount, uint256 loanToCollateral) public pure returns (uint256) {\n        return amount * decimals / loanToCollateral;\n    }\n\n    /// @notice compute interest cost on amount for duration at given annualized rate\n    /// @param amount of debt tokens\n    /// @param rate of interest (annualized)\n    /// @param duration of loan in seconds\n    /// @return interest as a number of debt tokens\n    function interestFor(uint256 amount, uint256 rate, uint256 duration) public pure returns (uint256) {\n        uint256 interest = rate * duration / 365 days;\n        return amount * interest / decimals;\n    }\n\n    /// @notice check if given loan is in default\n    /// @param loanID index of loan in loans[]\n    /// @return defaulted status\n    function isDefaulted(uint256 loanID) external view returns (bool) {\n        return block.timestamp > loans[loanID].expiry;\n    }\n\n    /// @notice check if given request is active\n    /// @param reqID index of request in requests[]\n    /// @return active status\n    function isActive(uint256 reqID) external view returns (bool) {\n        return requests[reqID].active;\n    }\n}"
    },
    {
      "filename": "src/Cooler.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./lib/mininterfaces.sol\";\nimport \"./Factory.sol\";\n\n/// @notice A Cooler is a smart contract escrow that facilitates fixed-duration loans\n///         for a specific user and debt-collateral pair.\ncontract Cooler {\n    // Errors\n\n    error OnlyApproved();\n    error Deactivated();\n    error Default();\n    error NoDefault();\n    error NotRollable();\n\n    // Data Structures\n\n    Request[] public requests;\n    struct Request { // A loan begins with a borrow request. It specifies:\n        uint256 amount; // the amount they want to borrow,\n        uint256 interest; // the annualized percentage they will pay as interest,\n        uint256 loanToCollateral; // the loan-to-collateral ratio they want,\n        uint256 duration; // and the length of time until the loan defaults.\n        bool active; // Any lender can clear an active loan request.\n    } \n\n    Loan[] public loans;\n    struct Loan { // A request is converted to a loan when a lender clears it.\n        Request request; // The terms of the loan are saved, along with:\n        uint256 amount; // the amount of debt owed,\n        uint256 collateral; // the amount of collateral pledged,\n        uint256 expiry; // the time when the loan defaults,\n        bool rollable; // whether the loan can be rolled over,\n        address lender; // and the lender's address.\n    }\n\n    // Facilitates transfer of lender ownership to new address\n    mapping(uint256 => address) public approvals;\n\n    // Immutables\n\n    // This address owns the collateral in escrow.\n    address private immutable owner;\n    // This token is borrowed against.\n    ERC20 public immutable collateral;\n    // This token is lent.\n    ERC20 public immutable debt;\n    // This contract created the Cooler\n    CoolerFactory public immutable factory;\n\n    // This makes the code look prettier.\n    uint256 private constant decimals = 1e18;\n\n    // Initialization\n\n    constructor (address o, ERC20 c, ERC20 d) {\n        owner = o;\n        collateral = c;\n        debt = d;\n        factory = CoolerFactory(msg.sender);\n    }\n\n    // Borrower\n\n    /// @notice request a loan with given parameters\n    /// @notice collateral is taken at time of request\n    /// @param amount of debt tokens to borrow\n    /// @param interest to pay (annualized % of 'amount')\n    /// @param loanToCollateral debt tokens per collateral token pledged\n    /// @param duration of loan tenure in seconds\n    /// @param reqID index of request in requests[]\n    function request (\n        uint256 amount,\n        uint256 interest,\n        uint256 loanToCollateral,\n        uint256 duration\n    ) external returns (uint256 reqID) {\n        reqID = requests.length;\n        factory.newEvent(reqID, CoolerFactory.Events.Request);\n        requests.push(\n            Request(amount, interest, loanToCollateral, duration, true)\n        );\n        collateral.transferFrom(msg.sender, address(this), collateralFor(amount, loanToCollateral));\n    }\n\n    /// @notice cancel a loan request and return collateral\n    /// @param reqID index of request in requests[]\n    function rescind (uint256 reqID) external {\n        if (msg.sender != owner) \n            revert OnlyApproved();\n\n        factory.newEvent(reqID, CoolerFactory.Events.Rescind);\n\n        Request storage req = requests[reqID];\n\n        if (!req.active)\n            revert Deactivated();\n        \n        req.active = false;\n        collateral.transfer(owner, collateralFor(req.amount, req.loanToCollateral));\n    }\n\n    /// @notice repay a loan to recoup collateral\n    /// @param loanID index of loan in loans[]\n    /// @param repaid debt tokens to repay\n    function repay (uint256 loanID, uint256 repaid) external {\n        Loan storage loan = loans[loanID];\n\n        if (block.timestamp > loan.expiry) \n            revert Default();\n        \n        uint256 decollateralized = loan.collateral * repaid / loan.amount;\n\n        if (repaid == loan.amount) delete loans[loanID];\n        else {\n            loan.amount -= repaid;\n            loan.collateral -= decollateralized;\n        }\n\n        debt.transferFrom(msg.sender, loan.lender, repaid);\n        collateral.transfer(owner, decollateralized);\n    }\n\n    /// @notice roll a loan over\n    /// @notice uses terms from request\n    /// @param loanID index of loan in loans[]\n    function roll (uint256 loanID) external {\n        Loan storage loan = loans[loanID];\n        Request memory req = loan.request;\n\n        if (block.timestamp > loan.expiry) \n            revert Default();\n\n        if (!loan.rollable)\n            revert NotRollable();\n\n        uint256 newCollateral = collateralFor(loan.amount, req.loanToCollateral) - loan.collateral;\n        uint256 newDebt = interestFor(loan.amount, req.interest, req.duration);\n\n        loan.amount += newDebt;\n        loan.expiry += req.duration;\n        loan.collateral += newCollateral;\n        \n        collateral.transferFrom(msg.sender, address(this), newCollateral);\n    }\n\n    /// @notice delegate voting power on collateral\n    /// @param to address to delegate\n    function delegate (address to) external {\n        if (msg.sender != owner) \n            revert OnlyApproved();\n        IDelegateERC20(address(collateral)).delegate(to);\n    }\n\n    // Lender\n\n    /// @notice fill a requested loan as a lender\n    /// @param reqID index of request in requests[]\n    /// @param loanID index of loan in loans[]\n    function clear (uint256 reqID) external returns (uint256 loanID) {\n        Request storage req = requests[reqID];\n\n        factory.newEvent(reqID, CoolerFactory.Events.Clear);\n\n        if (!req.active) \n            revert Deactivated();\n        else req.active = false;\n\n        uint256 interest = interestFor(req.amount, req.interest, req.duration);\n        uint256 collat = collateralFor(req.amount, req.loanToCollateral);\n        uint256 expiration = block.timestamp + req.duration;\n\n        loanID = loans.length;\n        loans.push(\n            Loan(req, req.amount + interest, collat, expiration, true, msg.sender)\n        );\n        debt.transferFrom(msg.sender, owner, req.amount);\n    }\n\n    /// @notice change 'rollable' status of loan\n    /// @param loanID index of loan in loans[]\n    /// @return bool new 'rollable' status\n    function toggleRoll(uint256 loanID) external returns (bool) {\n        Loan storage loan = loans[loanID];\n\n        if (msg.sender != loan.lender)\n            revert OnlyApproved();\n\n        loan.rollable = !loan.rollable;\n        return loan.rollable;\n    }\n\n    /// @notice send collateral to lender upon default\n    /// @param loanID index of loan in loans[]\n    /// @return uint256 collateral amount\n    function defaulted (uint256 loanID) external returns (uint256) {\n        Loan memory loan = loans[loanID];\n        delete loans[loanID];\n\n        if (block.timestamp <= loan.expiry) \n            revert NoDefault();\n\n        collateral.transfer(loan.lender, loan.collateral);\n        return loan.collateral;\n    }\n\n    /// @notice approve transfer of loan ownership to new address\n    /// @param to address to approve\n    /// @param loanID index of loan in loans[]\n    function approve (address to, uint256 loanID) external {\n        Loan memory loan = loans[loanID];\n\n        if (msg.sender != loan.lender)\n            revert OnlyApproved();\n\n        approvals[loanID] = to;\n    }\n\n    /// @notice execute approved transfer of loan ownership\n    /// @param loanID index of loan in loans[]\n    function transfer (uint256 loanID) external {\n        if (msg.sender != approvals[loanID])\n            revert OnlyApproved();\n\n        approvals[loanID] = address(0);\n        loans[loanID].lender = msg.sender;\n    }\n\n    // Views\n\n    /// @notice compute collateral needed for loan amount at given loan to collateral ratio\n    /// @param amount of collateral tokens\n    /// @param loanToCollateral ratio for loan\n    function collateralFor(uint256 amount, uint256 loanToCollateral) public pure returns (uint256) {\n        return amount * decimals / loanToCollateral;\n    }\n\n    /// @notice compute interest cost on amount for duration at given annualized rate\n    /// @param amount of debt tokens\n    /// @param rate of interest (annualized)\n    /// @param duration of loan in seconds\n    /// @return interest as a number of debt tokens\n    function interestFor(uint256 amount, uint256 rate, uint256 duration) public pure returns (uint256) {\n        uint256 interest = rate * duration / 365 days;\n        return amount * interest / decimals;\n    }\n\n    /// @notice check if given loan is in default\n    /// @param loanID index of loan in loans[]\n    /// @return defaulted status\n    function isDefaulted(uint256 loanID) external view returns (bool) {\n        return block.timestamp > loans[loanID].expiry;\n    }\n\n    /// @notice check if given request is active\n    /// @param reqID index of request in requests[]\n    /// @return active status\n    function isActive(uint256 reqID) external view returns (bool) {\n        return requests[reqID].active;\n    }\n}"
    }
  ]
}