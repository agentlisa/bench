{
  "Title": "M-8: Inadequate slippage control",
  "Content": "# Issue M-8: Inadequate slippage control \n\nSource: https://github.com/sherlock-audit/2023-03-notional-judging/issues/177 \n\n## Found by \nxiaoming90\n## Summary\n\nThe current slippage control mechanism checks a user's acceptable interest rate limit against the post-trade rate, which could result in trades proceeding at rates exceeding the user's defined limit.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/internal/markets/InterestRateCurve.sol#L421\n\n```solidity\nFile: InterestRateCurve.sol\n421:     function _getNetCashAmountsUnderlying(\n422:         InterestRateParameters memory irParams,\n423:         MarketParameters memory market,\n424:         CashGroupParameters memory cashGroup,\n425:         int256 totalCashUnderlying,\n426:         int256 fCashToAccount,\n427:         uint256 timeToMaturity\n428:     ) private pure returns (int256 postFeeCashToAccount, int256 netUnderlyingToMarket, int256 cashToReserve) {\n429:         uint256 utilization = getfCashUtilization(fCashToAccount, market.totalfCash, totalCashUnderlying);\n430:         // Do not allow utilization to go above 100 on trading\n431:         if (utilization > uint256(Constants.RATE_PRECISION)) return (0, 0, 0);\n432:         uint256 preFeeInterestRate = getInterestRate(irParams, utilization);\n433: \n434:         int256 preFeeCashToAccount = fCashToAccount.divInRatePrecision(\n435:             getfCashExchangeRate(preFeeInterestRate, timeToMaturity)\n436:         ).neg();\n437: \n438:         uint256 postFeeInterestRate = getPostFeeInterestRate(irParams, preFeeInterestRate, fCashToAccount < 0);\n439:         postFeeCashToAccount = fCashToAccount.divInRatePrecision(\n440:             getfCashExchangeRate(postFeeInterestRate, timeToMaturity)\n441:         ).neg();\n```\n\nWhen executing a fCash trade, the interest rate is computed based on the utilization of the current market (Refer to Line 432). The `postFeeInterestRate` is then computed based on the `preFeeCashToAccount` and trading fee, and this rate will be used to derive the exchange rate needed to convert `fCashToAccount` to the net prime cash (`postFeeCashToAccount`).\n\nNote that the interest rate used for the trade is `postFeeInterestRate`, and `postFeeCashToAccount` is the amount of cash credit or debit to an account.\n\nIf there is any slippage control in place, the slippage should be checked against the `postFeeInterestRate` or `postFeeCashToAccount`. As such, there are two approaches to implementing slippage controls:\n\n- 1st Approach - The current interest rate is `2%`. User sets their acceptable interest rate limit at 3% when the user submits the trade transaction. The user's tolerance is `1%`. From the time the trade is initiated to when it's executed, the rate (`postFeeInterestRate`) rises to 5%, the transaction should revert due to the increased slippage beyond the user's tolerance.\n- 2nd Approach - If a user sets the minimum trade return of 1000 cash, but the return is only 900 cash (`postFeeCashToAccount`) when the trade is executed, the transaction should revert as it exceeded the user's slippage tolerance\n\nNote: When users submit a trade transaction, the transaction is held in the mempool for a period of time before executing, and thus the market condition and interest rate might change during this period, and slippage control is used to protect users from these fluctuations.\n\nHowever, within the codebase, it was observed that the slippage was not checked against the `postFeeInterestRate` or `postFeeCashToAccount`.\n\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/internal/markets/InterestRateCurve.sol#L405\n\n```solidity\nFile: InterestRateCurve.sol\n371:         // returns the net cash amounts to apply to each of the three relevant balances.\n372:         (\n373:             int256 netUnderlyingToAccount,\n374:             int256 netUnderlyingToMarket,\n375:             int256 netUnderlyingToReserve\n376:         ) = _getNetCashAmountsUnderlying(\n377:             irParams,\n378:             market,\n379:             cashGroup,\n380:             totalCashUnderlying,\n381:             fCashToAccount,\n382:             timeToMaturity\n383:         );\n..SNIP..\n388:         {\n389:             // Do not allow utilization to go above 100 on trading, calculate the utilization after\n390:             // the trade has taken effect, meaning that fCash changes and cash changes are applied to\n391:             // the market totals.\n392:             market.totalfCash = market.totalfCash.subNoNeg(fCashToAccount);\n393:             totalCashUnderlying = totalCashUnderlying.add(netUnderlyingToMarket);\n394: \n395:             uint256 utilization = getfCashUtilization(0, market.totalfCash, totalCashUnderlying);\n396:             if (utilization > uint256(Constants.RATE_PRECISION)) return (0, 0);\n397: \n398:             uint256 newPreFeeImpliedRate = getInterestRate(irParams, utilization);\n..SNIP..\n404:             // Saves the preFeeInterestRate and fCash\n405:             market.lastImpliedRate = newPreFeeImpliedRate;\n406:         }\n```\n\nAfter computing the net prime cash (`postFeeCashToAccount == netUnderlyingToAccount`) at Line 373 above, it updates the `market.totalfCash` and `totalCashUnderlying`. Line 395 computes the `utilization` after the trade happens, and uses the latest `utilization` to compute the new interest rate after the trade and save it within the `market.lastImpliedRate`\n\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/external/actions/TradingAction.sol#L268\n\n```solidity\nFile: TradingAction.sol\n234:     function _executeLendBorrowTrade(\n..SNIP..\n256:         cashAmount = market.executeTrade(\n257:             account,\n258:             cashGroup,\n259:             fCashAmount,\n260:             market.maturity.sub(blockTime),\n261:             marketIndex\n262:         );\n263: \n264:         uint256 rateLimit = uint256(uint32(bytes4(trade << 104)));\n265:         if (rateLimit != 0) {\n266:             if (tradeType == TradeActionType.Borrow) {\n267:                 // Do not allow borrows over the rate limit\n268:                 require(market.lastImpliedRate <= rateLimit, \"Trade failed, slippage\");\n269:             } else {\n270:                 // Do not allow lends under the rate limit\n271:                 require(market.lastImpliedRate >= rateLimit, \"Trade failed, slippage\");\n272:             }\n273:         }\n274:     }\n```\n\nThe trade is executed at Line 256 above. After the trade is executed, it will check for the slippage at Line 264-273 above.\n\nLet $IR_1$ be the interest rate used during the trade (`postFeeInterestRate`), $IR_2$ be the interest rate after the trade (`market.lastImpliedRate`), and $IR_U$ be the user's acceptable interest rate limit (`rateLimit`). \n\nBased on the current slippage control implementation, $IR_U$ is checked against $IR_2$. Since the purpose of having slippage control in DeFi trade is to protect users from unexpected and unfavorable price changes **during** the execution of a trade, $IR_1$ should be used instead.\n\nAssume that at the time of executing a trade (`TradeActionType.Borrow`), $IR_1$ spikes up and exceeds $IR_U$. However, since the slippage control checks $IR_U$ against $IR_2$, which may have resettled to $IR_U$ or lower, the transaction proceeds despite exceeding the user's acceptable rate limit. So, the transaction succeeds without a revert. \n\nThis issue will exacerbate when executing large trades relative to pool liquidity.\n\n## Impact\n\nThe existing slippage control does not provide the desired protection against unexpected interest rate fluctuations during the transaction. As a result, users might be borrowing at a higher cost or lending at a lower return than they intended, leading to losses.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/internal/markets/InterestRateCurve.sol#L421\n\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/internal/markets/InterestRateCurve.sol#L405\n\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/external/actions/TradingAction.sol#L268\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider updating the slippage control to compare the user's acceptable interest rate limit (`rateLimit`) against the interest rate used during the trade execution (`postFeeInterestRate`).\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/59",
  "Code": [
    {
      "filename": "contracts-v2/contracts/internal/markets/InterestRateCurve.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport {LibStorage} from \"../../global/LibStorage.sol\";\nimport {\n    InterestRateCurveSettings,\n    InterestRateParameters,\n    CashGroupParameters,\n    MarketParameters,\n    PrimeRate\n} from \"../../global/Types.sol\";\nimport {CashGroup} from \"./CashGroup.sol\";\nimport {PrimeRateLib} from \"../pCash/PrimeRateLib.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {SafeUint256} from \"../../math/SafeUint256.sol\";\nimport {SafeInt256} from \"../../math/SafeInt256.sol\";\nimport {ABDKMath64x64} from \"../../math/ABDKMath64x64.sol\";\n\nlibrary InterestRateCurve {\n    using SafeInt256 for int256;\n    using SafeUint256 for uint256;\n    using CashGroup for CashGroupParameters;\n    using PrimeRateLib for PrimeRate;\n\n    uint8 private constant PRIME_CASH_OFFSET = 0;\n    uint8 private constant PRIME_CASH_SHIFT = 192;\n\n    uint256 private constant KINK_UTILIZATION_1_BYTE = 0;\n    uint256 private constant KINK_UTILIZATION_2_BYTE = 1;\n    uint256 private constant MAX_RATE_BYTE           = 2;\n    uint256 private constant KINK_RATE_1_BYTE        = 3;\n    uint256 private constant KINK_RATE_2_BYTE        = 4;\n    uint256 private constant MIN_FEE_RATE_BYTE       = 5;\n    uint256 private constant MAX_FEE_RATE_BYTE       = 6;\n    uint256 private constant FEE_RATE_PERCENT_BYTE   = 7;\n\n    uint256 private constant KINK_UTILIZATION_1_BIT = KINK_UTILIZATION_1_BYTE * 8;\n    uint256 private constant KINK_UTILIZATION_2_BIT = KINK_UTILIZATION_2_BYTE * 8;\n    uint256 private constant MAX_RATE_BIT           = MAX_RATE_BYTE * 8;\n    uint256 private constant KINK_RATE_1_BIT        = KINK_RATE_1_BYTE * 8;\n    uint256 private constant KINK_RATE_2_BIT        = KINK_RATE_2_BYTE * 8;\n    uint256 private constant MIN_FEE_RATE_BIT       = MIN_FEE_RATE_BYTE * 8;\n    uint256 private constant MAX_FEE_RATE_BIT       = MAX_FEE_RATE_BYTE * 8;\n    uint256 private constant FEE_RATE_PERCENT_BIT   = FEE_RATE_PERCENT_BYTE * 8;\n\n    /// @notice Returns the marketIndex byte offset.\n    /// @dev marketIndex = 0 is unused for fCash markets (they are 1-indexed). In the storage\n    /// slot the marketIndex = 0 space is reserved for the prime cash borrow curve\n    function _getMarketIndexOffset(uint256 marketIndex) private pure returns (uint8 offset) {\n        require(0 < marketIndex);\n        require(marketIndex <= Constants.MAX_TRADED_MARKET_INDEX);\n        offset = uint8(marketIndex < 4 ? marketIndex : marketIndex - 4) * 8;\n    }\n\n    function _getfCashInterestRateParams(\n        uint16 currencyId,\n        uint256 marketIndex,\n        mapping(uint256 => bytes32[2]) storage store\n    ) private view returns (InterestRateParameters memory i) {\n        uint8 offset = _getMarketIndexOffset(marketIndex);\n        bytes32 data = store[currencyId][marketIndex < 4 ? 0 : 1];\n        return unpackInterestRateParams(offset, data);\n    }\n\n    function unpackInterestRateParams(\n        uint8 offset,\n        bytes32 data\n    ) internal pure returns (InterestRateParameters memory i) {\n        // Kink utilization is stored as a value less than 100 and on the stack it is\n        // in RATE_PRECISION where RATE_PRECISION = 100\n        i.kinkUtilization1 = uint256(uint8(data[offset + KINK_UTILIZATION_1_BYTE])) * uint256(Constants.RATE_PRECISION)\n            / uint256(Constants.PERCENTAGE_DECIMALS);\n        i.kinkUtilization2 = uint256(uint8(data[offset + KINK_UTILIZATION_2_BYTE])) * uint256(Constants.RATE_PRECISION)\n            / uint256(Constants.PERCENTAGE_DECIMALS);\n        // Max Rate is stored in 25 basis point increments\n        i.maxRate = uint256(uint8(data[offset + MAX_RATE_BYTE])) * 25 * uint256(Constants.BASIS_POINT);\n        // Kink Rates are stored as 1/256 increments of maxRate, this allows governance\n        // to set more precise kink rates relative to how how interest rates can go\n        i.kinkRate1 = uint256(uint8(data[offset + KINK_RATE_1_BYTE])) * i.maxRate / 256;\n        i.kinkRate2 = uint256(uint8(data[offset + KINK_RATE_2_BYTE])) * i.maxRate / 256;\n\n        // Fee rates are stored in basis points\n        i.minFeeRate = uint256(uint8(data[offset + MIN_FEE_RATE_BYTE])) * uint256(Constants.BASIS_POINT);\n        i.maxFeeRate = uint256(uint8(data[offset + MAX_FEE_RATE_BYTE])) * uint256(Constants.BASIS_POINT);\n        i.feeRatePercent = uint256(uint8(data[offset + FEE_RATE_PERCENT_BYTE]));\n    }\n\n    function packInterestRateParams(InterestRateCurveSettings memory settings) internal pure returns (bytes32) {\n        require(settings.kinkUtilization1 < settings.kinkUtilization2);\n        require(settings.kinkUtilization2 <= 100);\n        require(settings.kinkRate1 < settings.kinkRate2);\n        require(settings.minFeeRateBPS <= settings.maxFeeRateBPS);\n        require(settings.feeRatePercent < 100);\n\n        return (\n            bytes32(uint256(settings.kinkUtilization1)) << 56 - KINK_UTILIZATION_1_BIT |\n            bytes32(uint256(settings.kinkUtilization2)) << 56 - KINK_UTILIZATION_2_BIT |\n            bytes32(uint256(settings.maxRate25BPS))     << 56 - MAX_RATE_BIT           |\n            bytes32(uint256(settings.kinkRate1))        << 56 - KINK_RATE_1_BIT        |\n            bytes32(uint256(settings.kinkRate2))        << 56 - KINK_RATE_2_BIT        |\n            bytes32(uint256(settings.minFeeRateBPS))    << 56 - MIN_FEE_RATE_BIT       |\n            bytes32(uint256(settings.maxFeeRateBPS))    << 56 - MAX_FEE_RATE_BIT       |\n            bytes32(uint256(settings.feeRatePercent))   << 56 - FEE_RATE_PERCENT_BIT\n        );\n    }\n\n    function _setInterestRateParameters(\n        bytes32 data,\n        uint8 offset,\n        InterestRateCurveSettings memory settings\n    ) internal pure returns (bytes32) {\n        // Does checks against interest rate params inside\n        bytes32 packedSettings = packInterestRateParams(settings);\n        packedSettings = (packedSettings << offset);\n\n        // Use the mask to clear the previous settings\n        bytes32 mask = ~(bytes32(uint256(type(uint64).max)) << offset);\n        return (data & mask) | packedSettings;\n    }\n\n    function setNextInterestRateParameters(\n        uint16 currencyId,\n        uint256 marketIndex,\n        InterestRateCurveSettings memory settings\n    ) internal {\n        bytes32[2] storage nextStorage = LibStorage.getNextInterestRateParameters()[currencyId];\n        // 256 - 64 bits puts the offset at 192 bits (64 bits is how wide each set of interest\n        // rate parameters is)\n        uint8 shift = PRIME_CASH_SHIFT - _getMarketIndexOffset(marketIndex) * 8;\n        uint8 slot = marketIndex < 4 ? 0 : 1;\n\n        nextStorage[slot] = _setInterestRateParameters(nextStorage[slot], shift, settings);\n    }\n\n    function getActiveInterestRateParameters(\n        uint16 currencyId,\n        uint256 marketIndex\n    ) internal view returns (InterestRateParameters memory i) {\n        return _getfCashInterestRateParams(\n            currencyId,\n            marketIndex,\n            LibStorage.getActiveInterestRateParameters()\n        );\n    }\n\n    function getNextInterestRateParameters(\n        uint16 currencyId,\n        uint256 marketIndex\n    ) internal view returns (InterestRateParameters memory i) {\n        return _getfCashInterestRateParams(\n            currencyId,\n            marketIndex,\n            LibStorage.getNextInterestRateParameters()\n        );\n    }\n\n    function getPrimeCashInterestRateParameters(\n        uint16 currencyId\n    ) internal view returns (InterestRateParameters memory i) {\n        bytes32 data = LibStorage.getActiveInterestRateParameters()[currencyId][0];\n        return unpackInterestRateParams(PRIME_CASH_OFFSET, data);\n    }\n\n    /// @notice Sets prime cash interest rate parameters, which are always in active storage\n    /// at left most bytes8 slot. This corresponds to marketIndex = 0 which is unused by fCash\n    /// markets.\n    function setPrimeCashInterestRateParameters(\n        uint16 currencyId,\n        InterestRateCurveSettings memory settings\n    ) internal {\n        bytes32[2] storage activeStorage = LibStorage.getActiveInterestRateParameters()[currencyId];\n        bytes32[2] storage nextStorage = LibStorage.getNextInterestRateParameters()[currencyId];\n        // Set the settings in both active and next. On the next market roll the prime cash parameters\n        // will be preserved\n        activeStorage[0] = _setInterestRateParameters(activeStorage[0], PRIME_CASH_SHIFT, settings);\n        nextStorage[0] = _setInterestRateParameters(nextStorage[0], PRIME_CASH_SHIFT, settings);\n    }\n\n    function setActiveInterestRateParameters(uint16 currencyId) internal {\n        // Whenever we set the active interest rate parameters, we just copy the next\n        // values into the active storage values.\n        bytes32[2] storage nextStorage = LibStorage.getNextInterestRateParameters()[currencyId];\n        bytes32[2] storage activeStorage = LibStorage.getActiveInterestRateParameters()[currencyId];\n        activeStorage[0] = nextStorage[0];\n        activeStorage[1] = nextStorage[1];\n    }\n\n    /// @notice Oracle rate protects against short term price manipulation. Time window will be set to a value\n    /// on the order of minutes to hours. This is to protect fCash valuations from market manipulation. For example,\n    /// a trader could use a flash loan to dump a large amount of cash into the market and depress interest rates.\n    /// Since we value fCash in portfolios based on these rates, portfolio values will decrease and they may then\n    /// be liquidated.\n    ///\n    /// Oracle rates are calculated when the values are loaded from storage.\n    ///\n    /// The oracle rate is a lagged weighted average over a short term price window. If we are past\n    /// the short term window then we just set the rate to the lastImpliedRate, otherwise we take the\n    /// weighted average:\n    ///     lastInterestRatePreTrade * (currentTs - previousTs) / timeWindow +\n    ///         oracleRatePrevious * (1 - (currentTs - previousTs) / timeWindow)\n    function updateRateOracle(\n        uint256 lastUpdateTime,\n        uint256 lastInterestRate,\n        uint256 oracleRate,\n        uint256 rateOracleTimeWindow,\n        uint256 blockTime\n    ) internal pure returns (uint256 newOracleRate) {\n        require(rateOracleTimeWindow > 0); // dev: update rate oracle, time window zero\n\n        // This can occur when using a view function get to a market state in the past\n        if (lastUpdateTime > blockTime) return lastInterestRate;\n\n        uint256 timeDiff = blockTime.sub(lastUpdateTime);\n        // If past the time window just return the lastInterestRate\n        if (timeDiff > rateOracleTimeWindow) return lastInterestRate;\n\n        // (currentTs - previousTs) / timeWindow\n        uint256 lastTradeWeight = timeDiff.divInRatePrecision(rateOracleTimeWindow);\n\n        // 1 - (currentTs - previousTs) / timeWindow\n        uint256 oracleWeight = uint256(Constants.RATE_PRECISION).sub(lastTradeWeight);\n\n        // lastInterestRatePreTrade * lastTradeWeight + oracleRatePrevious * oracleWeight\n        newOracleRate =\n            (lastInterestRate.mul(lastTradeWeight).add(oracleRate.mul(oracleWeight)))\n                .div(uint256(Constants.RATE_PRECISION));\n    }\n\n    /// @notice Returns the utilization for an fCash market:\n    /// (totalfCash +/- fCashToAccount) / (totalfCash + totalCash)\n    function getfCashUtilization(\n        int256 fCashToAccount,\n        int256 totalfCash,\n        int256 totalCashUnderlying\n    ) internal pure returns (uint256 utilization) {\n        require(totalfCash >= 0);\n        require(totalCashUnderlying >= 0);\n        utilization = totalfCash.subNoNeg(fCashToAccount)\n            .divInRatePrecision(totalCashUnderlying.add(totalfCash))\n            .toUint();\n    }\n\n    /// @notice Returns the preFeeInterestRate given interest rate parameters and utilization\n    function getInterestRate(\n        InterestRateParameters memory irParams,\n        uint256 utilization\n    ) internal pure returns (uint256 preFeeInterestRate) {\n        // If this is not set, then assume that the rate parameters have not been initialized\n        // and revert.\n        require(irParams.maxRate > 0);\n        // Do not allow trading past 100% utilization, revert for safety here to prevent\n        // underflows, however in calculatefCashTrade we check this explicitly to prevent\n        // a revert. nToken redemption relies on the behavior that calculateTrade returns 0\n        // during an unsuccessful trade.\n        require(utilization <= uint256(Constants.RATE_PRECISION));\n\n        if (utilization <= irParams.kinkUtilization1) {\n            // utilization * kinkRate1 / kinkUtilization1\n            preFeeInterestRate = utilization\n                .mul(irParams.kinkRate1)\n                .div(irParams.kinkUtilization1);\n        } else if (utilization <= irParams.kinkUtilization2) {\n            // (utilization - kinkUtilization1) * (kinkRate2 - kinkRate1) \n            // ---------------------------------------------------------- + kinkRate1\n            //            (kinkUtilization2 - kinkUtilization1)\n            preFeeInterestRate = (utilization - irParams.kinkUtilization1) // underflow checked\n                .mul(irParams.kinkRate2 - irParams.kinkRate1) // underflow checked by definition\n                .div(irParams.kinkUtilization2 - irParams.kinkUtilization1) // underflow checked by definition\n                .add(irParams.kinkRate1);\n        } else {\n            // (utilization - kinkUtilization2) * (maxRate - kinkRate2) \n            // ---------------------------------------------------------- + kinkRate2\n            //                  (1 - kinkUtilization2)\n            preFeeInterestRate = (utilization - irParams.kinkUtilization2) // underflow checked\n                .mul(irParams.maxRate - irParams.kinkRate2) // underflow checked by definition\n                .div(uint256(Constants.RATE_PRECISION) - irParams.kinkUtilization2) // underflow checked by definition\n                .add(irParams.kinkRate2);\n        }\n    }\n\n    /// @notice Calculates a market utilization via the interest rate, is the\n    /// inverse of getInterestRate\n    function getUtilizationFromInterestRate(\n        InterestRateParameters memory irParams,\n        uint256 interestRate\n    ) internal pure returns (uint256 utilization) {\n        // If this is not set, then assume that the rate parameters have not been initialized\n        // and revert.\n        require(irParams.maxRate > 0);\n\n        if (interestRate <= irParams.kinkRate1) {\n            // interestRate * kinkUtilization1 / kinkRate1\n            utilization = interestRate\n                .mul(irParams.kinkUtilization1)\n                .div(irParams.kinkRate1);\n        } else if (interestRate <= irParams.kinkRate2) {\n            // (interestRate - kinkRate1) * (kinkUtilization2 - kinkUtilization1) \n            // ------------------------------------------------------------------   + kinkUtilization1\n            //                  (kinkRate2 - kinkRate1)\n            utilization = (interestRate - irParams.kinkRate1) // underflow checked\n                .mul(irParams.kinkUtilization2 - irParams.kinkUtilization1) // underflow checked by definition\n                .div(irParams.kinkRate2 - irParams.kinkRate1) // underflow checked by definition\n                .add(irParams.kinkUtilization1);\n        } else {\n            // NOTE: in this else block, it is possible for interestRate > maxRate and therefore this\n            // method will return a utilization greater than 100%. During initialize markets, if this condition\n            // exists then the utilization will be marked down to the leverage threshold which is by definition\n            // less than 100% utilization.\n\n            // (interestRate - kinkRate2) * (1 - kinkUtilization2)\n            // -----------------------------------------------------  + kinkUtilization2\n            //                  (maxRate - kinkRate2)\n            utilization = (interestRate - irParams.kinkRate2) // underflow checked\n                .mul(uint256(Constants.RATE_PRECISION) - irParams.kinkUtilization2) // underflow checked by definition\n                .div(irParams.maxRate - irParams.kinkRate2) // underflow checked by definition\n                .add(irParams.kinkUtilization2);\n        }\n    }\n\n    /// @notice Applies fees to an interest rate\n    /// @param irParams contains the relevant fee parameters\n    /// @param preFeeInterestRate the interest rate before the fee\n    /// @param isBorrow if true, the fee increases the rate, else it decreases the rate\n    /// @return postFeeInterestRate the interest rate with a fee applied, floored at zero\n    function getPostFeeInterestRate(\n        InterestRateParameters memory irParams,\n        uint256 preFeeInterestRate,\n        bool isBorrow\n    ) internal pure returns (uint256 postFeeInterestRate) {\n        uint256 feeRate = preFeeInterestRate.mul(irParams.feeRatePercent).div(uint256(Constants.PERCENTAGE_DECIMALS));\n        if (feeRate < irParams.minFeeRate) feeRate = irParams.minFeeRate;\n        if (feeRate > irParams.maxFeeRate) feeRate = irParams.maxFeeRate;\n\n        if (isBorrow) {\n            // Borrows increase the interest rate, it is ok for the feeRate to exceed the maxRate here.\n            postFeeInterestRate = preFeeInterestRate.add(feeRate);\n        } else {\n            // Lending decreases the interest rate, do not allow the postFeeInterestRate to underflow\n            postFeeInterestRate = feeRate > preFeeInterestRate ? 0 : (preFeeInterestRate - feeRate);\n        }\n    }\n\n    /// @notice Calculates the asset cash amount the results from trading fCashToAccount with the market. A positive\n    /// fCashToAccount is equivalent of lending, a negative is borrowing. Updates the market state in memory.\n    /// @param market the current market state\n    /// @param cashGroup cash group configuration parameters\n    /// @param fCashToAccount the fCash amount that will be deposited into the user's portfolio. The net change\n    /// to the market is in the opposite direction.\n    /// @param timeToMaturity number of seconds until maturity\n    /// @param marketIndex the relevant tenor of the market to trade on\n    /// @return netAssetCash amount of asset cash to credit or debit to an account\n    /// @return netAssetCashToReserve amount of cash to credit to the reserve (always positive)\n    function calculatefCashTrade(\n        MarketParameters memory market,\n        CashGroupParameters memory cashGroup,\n        int256 fCashToAccount,\n        uint256 timeToMaturity,\n        uint256 marketIndex\n    ) internal view returns (int256, int256) {\n        // Market index must be greater than zero\n        require(marketIndex > 0);\n        // We return false if there is not enough fCash to support this trade.\n        // if fCashToAccount > 0 and totalfCash - fCashToAccount <= 0 then the trade will fail\n        // if fCashToAccount < 0 and totalfCash > 0 then this will always pass\n        if (market.totalfCash <= fCashToAccount) return (0, 0);\n\n        InterestRateParameters memory irParams = getActiveInterestRateParameters(cashGroup.currencyId, marketIndex);\n        int256 totalCashUnderlying = cashGroup.primeRate.convertToUnderlying(market.totalPrimeCash);\n\n        // returns the net cash amounts to apply to each of the three relevant balances.\n        (\n            int256 netUnderlyingToAccount,\n            int256 netUnderlyingToMarket,\n            int256 netUnderlyingToReserve\n        ) = _getNetCashAmountsUnderlying(\n            irParams,\n            market,\n            cashGroup,\n            totalCashUnderlying,\n            fCashToAccount,\n            timeToMaturity\n        );\n\n        // Signifies a failed net cash amount calculation\n        if (netUnderlyingToAccount == 0) return (0, 0);\n\n        {\n            // Do not allow utilization to go above 100 on trading, calculate the utilization after\n            // the trade has taken effect, meaning that fCash changes and cash changes are applied to\n            // the market totals.\n            market.totalfCash = market.totalfCash.subNoNeg(fCashToAccount);\n            totalCashUnderlying = totalCashUnderlying.add(netUnderlyingToMarket);\n\n            uint256 utilization = getfCashUtilization(0, market.totalfCash, totalCashUnderlying);\n            if (utilization > uint256(Constants.RATE_PRECISION)) return (0, 0);\n\n            uint256 newPreFeeImpliedRate = getInterestRate(irParams, utilization);\n\n            // It's technically possible that the implied rate is actually exactly zero we will still\n            // fail in this case. If this does happen we may assume that markets are not initialized.\n            if (newPreFeeImpliedRate == 0) return (0, 0);\n\n            // Saves the preFeeInterestRate and fCash\n            market.lastImpliedRate = newPreFeeImpliedRate;\n        }\n\n        return _setNewMarketState(\n            market,\n            cashGroup.primeRate,\n            netUnderlyingToAccount,\n            netUnderlyingToMarket,\n            netUnderlyingToReserve\n        );\n    }\n\n    /// @notice Returns net underlying cash amounts to the account, the market and the reserve.\n    /// @return postFeeCashToAccount this is a positive or negative amount of cash change to the account\n    /// @return netUnderlyingToMarket this is a positive or negative amount of cash change in the market\n    /// @return cashToReserve this is always a positive amount of cash accrued to the reserve\n    function _getNetCashAmountsUnderlying(\n        InterestRateParameters memory irParams,\n        MarketParameters memory market,\n        CashGroupParameters memory cashGroup,\n        int256 totalCashUnderlying,\n        int256 fCashToAccount,\n        uint256 timeToMaturity\n    ) private pure returns (int256 postFeeCashToAccount, int256 netUnderlyingToMarket, int256 cashToReserve) {\n        uint256 utilization = getfCashUtilization(fCashToAccount, market.totalfCash, totalCashUnderlying);\n        // Do not allow utilization to go above 100 on trading\n        if (utilization > uint256(Constants.RATE_PRECISION)) return (0, 0, 0);\n        uint256 preFeeInterestRate = getInterestRate(irParams, utilization);\n\n        int256 preFeeCashToAccount = fCashToAccount.divInRatePrecision(\n            getfCashExchangeRate(preFeeInterestRate, timeToMaturity)\n        ).neg();\n\n        uint256 postFeeInterestRate = getPostFeeInterestRate(irParams, preFeeInterestRate, fCashToAccount < 0);\n        postFeeCashToAccount = fCashToAccount.divInRatePrecision(\n            getfCashExchangeRate(postFeeInterestRate, timeToMaturity)\n        ).neg();\n\n        require(postFeeCashToAccount <= preFeeCashToAccount);\n        // Both pre fee cash to account and post fee cash to account are either negative (lending) or positive\n        // (borrowing). Fee will be positive or zero as a result.\n        int256 fee = preFeeCashToAccount.sub(postFeeCashToAccount);\n\n        cashToReserve = fee.mul(cashGroup.getReserveFeeShare()).div(Constants.PERCENTAGE_DECIMALS);\n\n        // This inequality must hold inside given the fees:\n        //  netToMarket + cashToReserve + postFeeCashToAccount = 0\n\n        // Example: Lending\n        // Pre Fee Cash: -97 ETH\n        // Post Fee Cash: -100 ETH\n        // Fee: 3 ETH\n        // To Reserve: 1 ETH\n        // Net To Market = 99 ETH\n        // 99 + 1 - 100 == 0\n\n        // Example: Borrowing\n        // Pre Fee Cash: 100 ETH\n        // Post Fee Cash: 97 ETH\n        // Fee: 3 ETH\n        // To Reserve: 1 ETH\n        // Net To Market = -98 ETH\n        // 97 + 1 - 98 == 0\n\n        // Therefore:\n        //  netToMarket = - cashToReserve - postFeeCashToAccount\n        //  netToMarket = - (cashToReserve + postFeeCashToAccount)\n\n        netUnderlyingToMarket = (postFeeCashToAccount.add(cashToReserve)).neg();\n    }\n\n    /// @notice Sets the new market state\n    /// @return netAssetCashToAccount: the positive or negative change in asset cash to the account\n    /// @return assetCashToReserve: the positive amount of cash that accrues to the reserve\n    function _setNewMarketState(\n        MarketParameters memory market,\n        PrimeRate memory primeRate,\n        int256 netUnderlyingToAccount,\n        int256 netUnderlyingToMarket,\n        int256 netUnderlyingToReserve\n    ) private view returns (int256, int256) {\n        int256 netPrimeCashToMarket = primeRate.convertFromUnderlying(netUnderlyingToMarket);\n        // Set storage checks that total prime cash is above zero\n        market.totalPrimeCash = market.totalPrimeCash.add(netPrimeCashToMarket);\n\n        // Sets the trade time for the next oracle update\n        market.previousTradeTime = block.timestamp;\n        int256 primeCashToReserve = primeRate.convertFromUnderlying(netUnderlyingToReserve);\n        int256 netPrimeCashToAccount = primeRate.convertFromUnderlying(netUnderlyingToAccount);\n        return (netPrimeCashToAccount, primeCashToReserve);\n    }\n\n    /// @notice Converts an interest rate to an exchange rate given a time to maturity. The\n    /// formula is E = e^rt\n    function getfCashExchangeRate(\n        uint256 interestRate,\n        uint256 timeToMaturity\n    ) internal pure returns (int256 exchangeRate) {\n        int128 expValue =\n            ABDKMath64x64.fromUInt(interestRate.mul(timeToMaturity).div(Constants.YEAR));\n        int128 expValueScaled = ABDKMath64x64.div(expValue, Constants.RATE_PRECISION_64x64);\n        int128 expResult = ABDKMath64x64.exp(expValueScaled);\n        int128 expResultScaled = ABDKMath64x64.mul(expResult, Constants.RATE_PRECISION_64x64);\n\n        exchangeRate = ABDKMath64x64.toInt(expResultScaled);\n    }\n\n    /// @notice Uses secant method to converge on an fCash amount given the amount\n    /// of cash. The relation between cash and fCash is:\n    /// f(fCash) = cashAmount * exchangeRatePostFee(fCash) + fCash = 0\n    /// where exchangeRatePostFee = e ^ (interestRatePostFee * timeToMaturity)\n    ///       and interestRatePostFee = interestRateFunc(utilization)\n    ///       and utilization = (totalfCash - fCashToAccount) / (totalfCash + totalCash)\n    ///\n    /// interestRateFunc is guaranteed to be monotonic and continuous, however, it is not\n    /// differentiable therefore we must use the secant method instead of Newton's method.\n    ///\n    /// Secant method is:\n    ///                          x_1 - x_0\n    ///  x_n = x_1 - f(x_1) * ---------------\n    ///                       f(x_1) - f(x_0)\n    ///\n    ///  break when (x_n - x_1) < maxDelta\n    ///\n    /// The initial guesses for x_0 and x_1 depend on the direction of the trade.\n    ///     netUnderlyingToAccount > 0, then fCashToAccount < 0 and the interest rate will increase\n    ///         therefore x_0 = f @ current utilization and x_1 = f @ max utilization\n    ///     netUnderlyingToAccount < 0, then fCashToAccount > 0 and the interest rate will decrease\n    ///         therefore x_0 = f @ min utilization and x_1 = f @ current utilization\n    ///\n    /// These initial guesses will ensure that the method converges to a root (if one exists).\n    function getfCashGivenCashAmount(\n        InterestRateParameters memory irParams,\n        int256 totalfCash,\n        int256 netUnderlyingToAccount,\n        int256 totalCashUnderlying,\n        uint256 timeToMaturity\n    ) internal pure returns (int256) {\n        require(netUnderlyingToAccount != 0);\n        // Cannot borrow more than total cash underlying\n        require(netUnderlyingToAccount <= totalCashUnderlying, \"Over Market Limit\");\n\n        int256 fCash_0;\n        int256 fCash_1;\n        {\n            // Calculate fCash rate at the current mid point\n            int256 currentfCashExchangeRate = _calculatePostFeeExchangeRate(\n                irParams,\n                totalfCash,\n                totalCashUnderlying,\n                timeToMaturity,\n                netUnderlyingToAccount > 0 ? int256(-1) : int256(1) // set this such that we get the correct fee direction\n            );\n\n            if (netUnderlyingToAccount < 0) {\n                // Lending\n                // Minimum guess is lending at 0% interest, which means receiving fCash 1-1\n                // with underlying cash amounts\n                fCash_0 = netUnderlyingToAccount.neg();\n                fCash_1 = netUnderlyingToAccount.mulInRatePrecision(currentfCashExchangeRate).neg();\n            } else {\n                // Borrowing\n                fCash_0 = netUnderlyingToAccount.mulInRatePrecision(currentfCashExchangeRate).neg();\n                fCash_1 = netUnderlyingToAccount.mulInRatePrecision(\n                    getfCashExchangeRate(irParams.maxRate, timeToMaturity)\n                ).neg();\n            }\n        }\n\n        int256 diff_0 = _calculateDiff(\n            irParams,\n            totalfCash,\n            totalCashUnderlying,\n            fCash_0,\n            timeToMaturity,\n            netUnderlyingToAccount\n        );\n\n        for (uint8 i = 0; i < 250; i++) {\n            int256 fCashDelta = (fCash_1 - fCash_0);\n            if (fCashDelta == 0) return fCash_1;\n            int256 diff_1 = _calculateDiff(\n                irParams,\n                totalfCash,\n                totalCashUnderlying,\n                fCash_1,\n                timeToMaturity,\n                netUnderlyingToAccount\n            );\n            int256 fCash_n = fCash_1.sub(diff_1.mul(fCashDelta).div(diff_1.sub(diff_0)));\n\n            // Assign new values for next comparison\n            (fCash_1, fCash_0) = (fCash_n, fCash_1);\n            diff_0 = diff_1;\n        }\n\n        revert(\"No convergence\");\n    }\n\n    function _calculateDiff(\n        InterestRateParameters memory irParams,\n        int256 totalfCash,\n        int256 totalCashUnderlying,\n        int256 fCashToAccount,\n        uint256 timeToMaturity,\n        int256 netUnderlyingToAccount\n    ) private pure returns (int256) {\n        int256 exchangeRate =  _calculatePostFeeExchangeRate(\n            irParams,\n            totalfCash,\n            totalCashUnderlying,\n            timeToMaturity,\n            fCashToAccount\n        );\n\n        return fCashToAccount.add(netUnderlyingToAccount.mulInRatePrecision(exchangeRate));\n    }\n\n    function _calculatePostFeeExchangeRate(\n        InterestRateParameters memory irParams,\n        int256 totalfCash,\n        int256 totalCashUnderlying,\n        uint256 timeToMaturity,\n        int256 fCashToAccount\n    ) private pure returns (int256) {\n        uint256 preFeeInterestRate = getInterestRate(\n            irParams,\n            getfCashUtilization(fCashToAccount, totalfCash, totalCashUnderlying)\n        );\n        uint256 postFeeInterestRate = getPostFeeInterestRate(irParams, preFeeInterestRate, fCashToAccount < 0);\n\n        return getfCashExchangeRate(postFeeInterestRate, timeToMaturity);\n    }\n}"
    },
    {
      "filename": "contracts-v2/contracts/internal/markets/InterestRateCurve.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport {LibStorage} from \"../../global/LibStorage.sol\";\nimport {\n    InterestRateCurveSettings,\n    InterestRateParameters,\n    CashGroupParameters,\n    MarketParameters,\n    PrimeRate\n} from \"../../global/Types.sol\";\nimport {CashGroup} from \"./CashGroup.sol\";\nimport {PrimeRateLib} from \"../pCash/PrimeRateLib.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {SafeUint256} from \"../../math/SafeUint256.sol\";\nimport {SafeInt256} from \"../../math/SafeInt256.sol\";\nimport {ABDKMath64x64} from \"../../math/ABDKMath64x64.sol\";\n\nlibrary InterestRateCurve {\n    using SafeInt256 for int256;\n    using SafeUint256 for uint256;\n    using CashGroup for CashGroupParameters;\n    using PrimeRateLib for PrimeRate;\n\n    uint8 private constant PRIME_CASH_OFFSET = 0;\n    uint8 private constant PRIME_CASH_SHIFT = 192;\n\n    uint256 private constant KINK_UTILIZATION_1_BYTE = 0;\n    uint256 private constant KINK_UTILIZATION_2_BYTE = 1;\n    uint256 private constant MAX_RATE_BYTE           = 2;\n    uint256 private constant KINK_RATE_1_BYTE        = 3;\n    uint256 private constant KINK_RATE_2_BYTE        = 4;\n    uint256 private constant MIN_FEE_RATE_BYTE       = 5;\n    uint256 private constant MAX_FEE_RATE_BYTE       = 6;\n    uint256 private constant FEE_RATE_PERCENT_BYTE   = 7;\n\n    uint256 private constant KINK_UTILIZATION_1_BIT = KINK_UTILIZATION_1_BYTE * 8;\n    uint256 private constant KINK_UTILIZATION_2_BIT = KINK_UTILIZATION_2_BYTE * 8;\n    uint256 private constant MAX_RATE_BIT           = MAX_RATE_BYTE * 8;\n    uint256 private constant KINK_RATE_1_BIT        = KINK_RATE_1_BYTE * 8;\n    uint256 private constant KINK_RATE_2_BIT        = KINK_RATE_2_BYTE * 8;\n    uint256 private constant MIN_FEE_RATE_BIT       = MIN_FEE_RATE_B"
    }
  ]
}