{
  "Title": "M-3: Limit index isn't checked in repayDebt, so user control is void",
  "Content": "# Issue M-3: Limit index isn't checked in repayDebt, so user control is void \n\nSource: https://github.com/sherlock-audit/2023-04-ajna-judging/issues/85 \n\n## Found by \nhyh\n## Summary\n\nrepayDebt() resulting LUP `_revertIfPriceDroppedBelowLimit()` check is not performed in the case of pure debt repayment without collateral pulling.\n\n## Vulnerability Detail\n\nLUP will move (up or no change) as a result of debt repayment and repayDebt() have `limitIndex_` argument. As a part of multi-position strategy a user might not be satisfied with repay results if LUP has increased not substantially enough.\n\nI.e. there is a user control argument, it is detrimental from UX perspective to request, but not use it, as for any reason a borrower might want to control for that move: they might expect the final level to be somewhere, as an example for the sake of other loans of that borrower.\n\n## Impact\n\nUnfavorable repayDebt() operations will be executed and the borrowers, whose strategies were dependent on the realized LUP move, can suffer a loss.\n\nProbability of execution is high (no prerequisites, current ordinary behavior), while the probability of the following loss is medium, so placing the severity to be medium.\n\n## Code Snippet\n\nThere is a `limitIndex_` parameter in repayDebt():\n\nhttps://github.com/sherlock-audit/2023-04-ajna/blob/main/ajna-core/src/ERC20Pool.sol#L208-L232\n\n```solidity\n    function repayDebt(\n        address borrowerAddress_,\n        uint256 maxQuoteTokenAmountToRepay_,\n        uint256 collateralAmountToPull_,\n        address collateralReceiver_,\n>>      uint256 limitIndex_\n    ) external nonReentrant {\n        ...\n\n        RepayDebtResult memory result = BorrowerActions.repayDebt(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_,\n            maxQuoteTokenAmountToRepay_,\n            collateralAmountToPull_,\n>>          limitIndex_\n        );\n```\n\nCurrently `_revertIfPriceDroppedBelowLimit()` is done on collateral pulling only:\n\nhttps://github.com/sherlock-audit/2023-04-ajna/blob/main/ajna-core/src/libraries/external/BorrowerActions.sol#L365-L375\n\n```solidity\n        if (vars.pull) {\n            // only intended recipient can pull collateral\n            if (borrowerAddress_ != msg.sender) revert BorrowerNotSender();\n\n            // an auctioned borrower in not allowed to pull collateral (even if collateralized at the new LUP) if auction is not settled\n            if (result_.inAuction) revert AuctionActive();\n\n            // calculate LUP only if it wasn't calculated in repay action\n            if (!vars.repay) result_.newLup = Deposits.getLup(deposits_, result_.poolDebt);\n\n>>          _revertIfPriceDroppedBelowLimit(result_.newLup, limitIndex_);\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adding the same check in the repayment part:\n\nhttps://github.com/sherlock-audit/2023-04-ajna/blob/main/ajna-core/src/libraries/external/BorrowerActions.sol#L328\n\n```diff\n            result_.newLup = Deposits.getLup(deposits_, result_.poolDebt);\n+           _revertIfPriceDroppedBelowLimit(result_.newLup, limitIndex_);\n```\n\nIf no repay or pull it looks ok to skip the check to save gas.\n\n\n\n## Discussion\n\n**grandizzy**\n\nRepayment can only make the position less risky, so don't see a need for frontrunning/stale TX protection. Documentation should clearly state this behavior.\n\n**0xffff11**\n\nI do see the issue being valid. As sponsor said, they don't see a need to implement a safeguard, but the watson demonstrated that users can suffer a loss if non-favorable repays are executed. Could keep the medium.\n\n**grandizzy**\n\nre discussed within team and we're going to provide a change for this behavior: https://github.com/ajna-finance/contracts/pull/914\n\n**0xffff11**\n\nWill keep the medium severity\n\n**dmitriia**\n\n> re discussed within team and we're going to provide a change for this behavior: [ajna-finance/contracts#914](https://github.com/ajna-finance/contracts/pull/914)\n\nLooks ok, `limitIndex_` in `repayDebt()` is now effective in all the cases.\n\nBut it looks like when `vars.repay == vars.pull == false` the check will always revert the call as `newPrice_ = result_.newLup == 0`:\n\nhttps://github.com/ajna-finance/contracts/blob/0332f341856e1efe4da8bb675886c8cfbee57b71/src/libraries/helpers/RevertsHelper.sol#L71-L76\n\n```solidity\n    function _revertIfPriceDroppedBelowLimit(\n        uint256 newPrice_,\n        uint256 limitIndex_\n    ) pure {\n        if (newPrice_ < _priceAt(limitIndex_)) revert LimitIndexExceeded();\n    }\n```\n\nConsider:\n\nhttps://github.com/ajna-finance/contracts/blob/0332f341856e1efe4da8bb675886c8cfbee57b71/src/libraries/external/BorrowerActions.sol#L393-L394\n\n```diff\n        // check limit price and revert if price dropped below\n-       _revertIfPriceDroppedBelowLimit(result_.newLup, limitIndex_);\n+       if (vars.pull || vars.repay) _revertIfPriceDroppedBelowLimit(result_.newLup, limitIndex_);\n```\n\n**grandizzy**\n\n> > re discussed within team and we're going to provide a change for this behavior: [ajna-finance/contracts#914](https://github.com/ajna-finance/contracts/pull/914)\n> \n> Looks ok, `limitIndex_` in `repayDebt()` is now effective in all the cases.\n> \n> But it looks like when `vars.repay == vars.pull == false` the check will always revert the call as `newPrice_ = result_.newLup == 0`:\n> \n> https://github.com/ajna-finance/contracts/blob/0332f341856e1efe4da8bb675886c8cfbee57b71/src/libraries/helpers/RevertsHelper.sol#L71-L76\n> \n> ```solidity\n>     function _revertIfPriceDroppedBelowLimit(\n>         uint256 newPrice_,\n>         uint256 limitIndex_\n>     ) pure {\n>         if (newPrice_ < _priceAt(limitIndex_)) revert LimitIndexExceeded();\n>     }\n> ```\n> \n> Consider:\n> \n> https://github.com/ajna-finance/contracts/blob/0332f341856e1efe4da8bb675886c8cfbee57b71/src/libraries/external/BorrowerActions.sol#L393-L394\n> \n> ```diff\n>         // check limit price and revert if price dropped below\n> -       _revertIfPriceDroppedBelowLimit(result_.newLup, limitIndex_);\n> +       if (vars.pull || vars.repay) _revertIfPriceDroppedBelowLimit(result_.newLup, limitIndex_);\n> ```\n\nin that case we early revert with InvalidAmount at L288 https://github.com/ajna-finance/contracts/blob/0332f341856e1efe4da8bb675886c8cfbee57b71/src/libraries/external/BorrowerActions.sol#L288\n```Solidity\n        // revert if no amount to pull or repay\n        if (!vars.repay && !vars.pull) revert InvalidAmount();\n```\nso later check not needed\n\n**dmitriia**\n\nLooks ok\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/75",
  "Code": [
    {
      "filename": "ajna-core/src/ERC20Pool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.18;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 }    from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { \n    IERC20Pool,\n    IERC20PoolBorrowerActions,\n    IERC20PoolImmutables,\n    IERC20PoolLenderActions\n}                              from './interfaces/pool/erc20/IERC20Pool.sol';\nimport { IERC20Taker }         from './interfaces/pool/erc20/IERC20Taker.sol';\n\nimport {\n    IPoolLenderActions,\n    IPoolKickerActions,\n    IPoolTakerActions,\n    IPoolSettlerActions\n}                            from './interfaces/pool/IPool.sol';\nimport {\n    IERC3156FlashBorrower,\n    IERC3156FlashLender\n}                            from './interfaces/pool/IERC3156FlashLender.sol';\n\nimport {\n    DrawDebtResult,\n    RepayDebtResult,\n    SettleParams,\n    SettleResult,\n    TakeResult\n}                    from './interfaces/pool/commons/IPoolInternals.sol';\nimport { PoolState } from './interfaces/pool/commons/IPoolState.sol';\n\nimport { FlashloanablePool } from './base/FlashloanablePool.sol';\n\nimport {\n    _getCollateralDustPricePrecisionAdjustment,\n    _roundToScale,\n    _roundUpToScale\n}                                               from './libraries/helpers/PoolHelper.sol';\nimport { \n    _revertIfAuctionClearable,\n    _revertAfterExpiry \n}                               from './libraries/helpers/RevertsHelper.sol';\n\nimport { Loans }    from './libraries/internal/Loans.sol';\nimport { Deposits } from './libraries/internal/Deposits.sol';\nimport { Maths }    from './libraries/internal/Maths.sol';\n\nimport { BorrowerActions } from './libraries/external/BorrowerActions.sol';\nimport { LenderActions }   from './libraries/external/LenderActions.sol';\nimport { SettlerActions }  from './libraries/external/SettlerActions.sol';\nimport { TakerActions }    from './libraries/external/TakerActions.sol';\n\n/**\n *  @title  ERC20 Pool contract\n *  @notice Entrypoint of `ERC20` Pool actions for pool actors:\n *          - `Lenders`: add, remove and move quote tokens; transfer `LP`\n *          - `Borrowers`: draw and repay debt\n *          - `Traders`: add, remove and move quote tokens; add and remove collateral\n *          - `Kickers`: kick undercollateralized loans; settle auctions; claim bond rewards\n *          - `Bidders`: take auctioned collateral\n *          - `Reserve purchasers`: start auctions; take reserves\n *          - `Flash borrowers`: initiate flash loans on quote tokens and collateral\n *  @dev    Contract is `FlashloanablePool` with flash loan logic.\n *  @dev    Contract is base `Pool` with logic to handle `ERC20` collateral.\n *  @dev    Calls logic from external `PoolCommons`, `LenderActions`, `BorrowerActions` and `Auction` actions libraries.\n */\ncontract ERC20Pool is FlashloanablePool, IERC20Pool {\n    using SafeERC20 for IERC20;\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    /// @dev Immutable collateral scale arg offset.\n    uint256 internal constant COLLATERAL_SCALE = 93;\n\n    /****************************/\n    /*** Initialize Functions ***/\n    /****************************/\n\n    /// @inheritdoc IERC20Pool\n    function initialize(\n        uint256 rate_\n    ) external override {\n        if (isPoolInitialized) revert AlreadyInitialized();\n\n        inflatorState.inflator       = uint208(1e18);\n        inflatorState.inflatorUpdate = uint48(block.timestamp);\n\n        interestState.interestRate       = uint208(rate_);\n        interestState.interestRateUpdate = uint48(block.timestamp);\n\n        Loans.init(loans);\n\n        // increment initializations count to ensure these values can't be updated\n        isPoolInitialized = true;\n    }\n\n    /******************/\n    /*** Immutables ***/\n    /******************/\n\n    /// @inheritdoc IERC20PoolImmutables\n    function collateralScale() external pure override returns (uint256) {\n        return _getArgUint256(COLLATERAL_SCALE);\n    }\n\n    /// @inheritdoc IERC20Pool\n    function bucketCollateralDust(uint256 bucketIndex_) external pure override returns (uint256) {\n        return _bucketCollateralDust(bucketIndex_);\n    }\n\n    /***********************************/\n    /*** Borrower External Functions ***/\n    /***********************************/\n\n    /**\n     *  @inheritdoc IERC20PoolBorrowerActions\n     *  @dev    === Write state ===\n     *  @dev    - decrement `poolBalances.t0DebtInAuction` accumulator\n     *  @dev    - increment `poolBalances.pledgedCollateral` accumulator\n     *  @dev    - increment `poolBalances.t0Debt` accumulator\n     *  @dev    - update `t0Debt2ToCollateral` ratio only if loan not in auction, debt and collateral pre action are considered 0 if auction settled\n     *  @dev    === Emit events ===\n     *  @dev    - `DrawDebt`\n     */\n    function drawDebt(\n        address borrowerAddress_,\n        uint256 amountToBorrow_,\n        uint256 limitIndex_,\n        uint256 collateralToPledge_\n    ) external nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // ensure the borrower is not charged for additional debt that they did not receive\n        amountToBorrow_     = _roundToScale(amountToBorrow_, poolState.quoteTokenScale);\n        // ensure the borrower is not credited with a fractional amount of collateral smaller than the token scale\n        collateralToPledge_ = _roundToScale(collateralToPledge_, _getArgUint256(COLLATERAL_SCALE));\n\n        DrawDebtResult memory result = BorrowerActions.drawDebt(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            poolState,\n            _availableQuoteToken(),\n            borrowerAddress_,\n            amountToBorrow_,\n            limitIndex_,\n            collateralToPledge_\n        );\n\n        emit DrawDebt(borrowerAddress_, amountToBorrow_, collateralToPledge_, result.newLup);\n\n        // update in memory pool state struct\n        poolState.debt       = result.poolDebt;\n        poolState.t0Debt     = result.t0PoolDebt;\n        if (result.t0DebtInAuctionChange != 0) poolState.t0DebtInAuction -= result.t0DebtInAuctionChange;\n        poolState.collateral = result.poolCollateral;\n\n        // adjust t0Debt2ToCollateral ratio if loan not in auction\n        if (!result.inAuction) {\n            _updateT0Debt2ToCollateral(\n                result.settledAuction ? 0 : result.debtPreAction,       // debt pre settle (for loan in auction) not taken into account\n                result.debtPostAction,\n                result.settledAuction ? 0 : result.collateralPreAction, // collateral pre settle (for loan in auction) not taken into account\n                result.collateralPostAction\n            );\n        }\n\n        // update pool interest rate state\n        _updateInterestState(poolState, result.newLup);\n\n        if (collateralToPledge_ != 0) {\n            // update pool balances state\n            if (result.t0DebtInAuctionChange != 0) {\n                poolBalances.t0DebtInAuction = poolState.t0DebtInAuction;\n            }\n            poolBalances.pledgedCollateral = poolState.collateral;\n\n            // move collateral from sender to pool\n            _transferCollateralFrom(msg.sender, collateralToPledge_);\n        }\n\n        if (amountToBorrow_ != 0) {\n            // update pool balances state\n            poolBalances.t0Debt = poolState.t0Debt;\n\n            // move borrowed amount from pool to sender\n            _transferQuoteToken(msg.sender, amountToBorrow_);\n        }\n    }\n\n    /**\n     *  @inheritdoc IERC20PoolBorrowerActions\n     *  @dev    === Write state ===\n     *  @dev    - decrement `poolBalances.t0Debt accumulator`\n     *  @dev    - decrement `poolBalances.t0DebtInAuction accumulator`\n     *  @dev    - decrement `poolBalances.pledgedCollateral accumulator`\n     *  @dev    - update `t0Debt2ToCollateral` ratio only if loan not in auction, debt and collateral pre action are considered 0 if auction settled\n     *  @dev    === Emit events ===\n     *  @dev    - `RepayDebt`\n     */\n    function repayDebt(\n        address borrowerAddress_,\n        uint256 maxQuoteTokenAmountToRepay_,\n        uint256 collateralAmountToPull_,\n        address collateralReceiver_,\n        uint256 limitIndex_\n    ) external nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // ensure accounting is performed using the appropriate token scale\n        if (maxQuoteTokenAmountToRepay_ != type(uint256).max)\n            maxQuoteTokenAmountToRepay_ = _roundToScale(maxQuoteTokenAmountToRepay_, poolState.quoteTokenScale);\n        collateralAmountToPull_         = _roundToScale(collateralAmountToPull_,     _getArgUint256(COLLATERAL_SCALE));\n\n        RepayDebtResult memory result = BorrowerActions.repayDebt(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_,\n            maxQuoteTokenAmountToRepay_,\n            collateralAmountToPull_,\n            limitIndex_\n        );\n\n        emit RepayDebt(borrowerAddress_, result.quoteTokenToRepay, collateralAmountToPull_, result.newLup);\n\n        // update in memory pool state struct\n        poolState.debt       = result.poolDebt;\n        poolState.t0Debt     = result.t0PoolDebt;\n        if (result.t0DebtInAuctionChange != 0) poolState.t0DebtInAuction -= result.t0DebtInAuctionChange;\n        poolState.collateral = result.poolCollateral;\n\n        // adjust t0Debt2ToCollateral ratio if loan not in auction\n        if (!result.inAuction) {\n            _updateT0Debt2ToCollateral(\n                result.settledAuction ? 0 : result.debtPreAction,       // debt pre settle (for loan in auction) not taken into account\n                result.debtPostAction,\n                result.settledAuction ? 0 : result.collateralPreAction, // collateral pre settle (for loan in auction) not taken into account\n                result.collateralPostAction\n            );\n        }\n\n        // update pool interest rate state\n        _updateInterestState(poolState, result.newLup);\n\n        if (result.quoteTokenToRepay != 0) {\n            // update pool balances state\n            poolBalances.t0Debt = poolState.t0Debt;\n            if (result.t0DebtInAuctionChange != 0) {\n                poolBalances.t0DebtInAuction = poolState.t0DebtInAuction;\n            }\n\n            // move amount to repay from sender to pool\n            _transferQuoteTokenFrom(msg.sender, result.quoteTokenToRepay);\n        }\n        if (collateralAmountToPull_ != 0) {\n            // update pool balances state\n            poolBalances.pledgedCollateral = poolState.collateral;\n\n            // move collateral from pool to address specified as collateral receiver\n            _transferCollateral(collateralReceiver_, collateralAmountToPull_);\n        }\n    }\n\n    /*********************************/\n    /*** Lender External Functions ***/\n    /*********************************/\n\n    /**\n     *  @inheritdoc IERC20PoolLenderActions\n     *  @dev    === Reverts on ===\n     *  @dev    - `DustAmountNotExceeded()`\n     *  @dev    === Emit events ===\n     *  @dev    - `AddCollateral`\n     */\n    function addCollateral(\n        uint256 amountToAdd_,\n        uint256 index_,\n        uint256 expiry_\n    ) external override nonReentrant returns (uint256 bucketLP_) {\n        _revertAfterExpiry(expiry_);\n        PoolState memory poolState = _accruePoolInterest();\n\n        // revert if the dust amount was not exceeded, but round on the scale amount\n        if (amountToAdd_ != 0 && amountToAdd_ < _bucketCollateralDust(index_)) revert DustAmountNotExceeded();\n        amountToAdd_ = _roundToScale(amountToAdd_, _getArgUint256(COLLATERAL_SCALE));\n\n        bucketLP_ = LenderActions.addCollateral(\n            buckets,\n            deposits,\n            amountToAdd_,\n            index_\n        );\n\n        emit AddCollateral(msg.sender, index_, amountToAdd_, bucketLP_);\n\n        // update pool interest rate state\n        _updateInterestState(poolState, Deposits.getLup(deposits, poolState.debt));\n\n        // move required collateral from sender to pool\n        _transferCollateralFrom(msg.sender, amountToAdd_);\n    }\n\n    /**\n     *  @inheritdoc IPoolLenderActions\n     *  @dev    === Emit events ===\n     *  @dev    - `RemoveCollateral`\n     */\n    function removeCollateral(\n        uint256 maxAmount_,\n        uint256 index_\n    ) external override nonReentrant returns (uint256 removedAmount_, uint256 redeemedLP_) {\n        _revertIfAuctionClearable(auctions, loans);\n\n        PoolState memory poolState = _accruePoolInterest();\n\n        // round the collateral amount appropriately based on token precision\n        maxAmount_ = _roundToScale(maxAmount_, _getArgUint256(COLLATERAL_SCALE));\n\n        (removedAmount_, redeemedLP_) = LenderActions.removeMaxCollateral(\n            buckets,\n            deposits,\n            _bucketCollateralDust(index_),\n            maxAmount_,\n            index_\n        );\n\n        emit RemoveCollateral(msg.sender, index_, removedAmount_, redeemedLP_);\n\n        // update pool interest rate state\n        _updateInterestState(poolState, Deposits.getLup(deposits, poolState.debt));\n\n        // move collateral from pool to lender\n        _transferCollateral(msg.sender, removedAmount_);\n    }\n\n    /*******************************/\n    /*** Pool Auctions Functions ***/\n    /*******************************/\n\n    /**\n     *  @inheritdoc IPoolSettlerActions\n     *  @dev    === Write state ===\n     *  @dev    - decrement `poolBalances.t0Debt` accumulator\n     *  @dev    - decrement `poolBalances.t0DebtInAuction` accumulator\n     *  @dev    - decrement `poolBalances.pledgedCollateral` accumulator\n     *  @dev    - no update of `t0Debt2ToCollateral` ratio as debt and collateral pre settle are not taken into account (pre debt and pre collateral = 0)\n     *  @dev     and loan is removed from auction queue only when there's no more debt (post debt = 0)\n     */\n    function settle(\n        address borrowerAddress_,\n        uint256 maxDepth_\n    ) external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        SettleResult memory result = SettlerActions.settlePoolDebt(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            reserveAuction,\n            poolState,\n            SettleParams({\n                borrower:    borrowerAddress_,\n                poolBalance: _getNormalizedPoolQuoteTokenBalance(),\n                bucketDepth: maxDepth_\n            })\n        );\n\n        _updatePostSettleState(result, poolState);\n    }\n\n    /**\n     *  @inheritdoc IPoolTakerActions\n     *  @dev    === Write state ===\n     *  @dev    - decrement `poolBalances.t0Debt` accumulator\n     *  @dev    - decrement `poolBalances.t0DebtInAuction` accumulator\n     *  @dev    - decrement `poolBalances.pledgedCollateral` accumulator\n     *  @dev    - update `t0Debt2ToCollateral` ratio only if auction settled, debt and collateral pre action are considered 0\n     */\n    function take(\n        address        borrowerAddress_,\n        uint256        maxAmount_,\n        address        callee_,\n        bytes calldata data_\n    ) external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        uint256 collateralTokenScale = _getArgUint256(COLLATERAL_SCALE);\n\n        // round requested collateral to an amount which can actually be transferred\n        maxAmount_ = _roundToScale(maxAmount_, collateralTokenScale);\n\n        TakeResult memory result = TakerActions.take(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_,\n            maxAmount_,\n            collateralTokenScale\n        );\n        // round quote token up to cover the cost of purchasing the collateral\n        result.quoteTokenAmount = _roundUpToScale(result.quoteTokenAmount, poolState.quoteTokenScale);\n\n        _updatePostTakeState(result, poolState);\n\n        _transferCollateral(callee_, result.collateralAmount);\n\n        if (data_.length != 0) {\n            IERC20Taker(callee_).atomicSwapCallback(\n                result.collateralAmount / collateralTokenScale,\n                result.quoteTokenAmount / poolState.quoteTokenScale,\n                data_\n            );\n        }\n\n        _transferQuoteTokenFrom(msg.sender, result.quoteTokenAmount);\n    }\n\n    /**\n     *  @inheritdoc IPoolTakerActions\n     *  @dev    === Write state ===\n     *  @dev    - decrement `poolBalances.t0Debt` accumulator\n     *  @dev    - decrement `poolBalances.t0DebtInAuction` accumulator\n     *  @dev    - decrement `poolBalances.pledgedCollateral` accumulator\n     *  @dev    - update `t0Debt2ToCollateral` ratio only if auction settled, debt and collateral pre action are considered 0\n     */\n    function bucketTake(\n        address borrowerAddress_,\n        bool    depositTake_,\n        uint256 index_\n    ) external override nonReentrant {\n\n        PoolState memory poolState = _accruePoolInterest();\n\n        TakeResult memory result = TakerActions.bucketTake(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_,\n            depositTake_,\n            index_,\n            _getArgUint256(COLLATERAL_SCALE)\n        );\n\n        _updatePostTakeState(result, poolState);\n    }\n\n    /***************************/\n    /*** Flashloan Functions ***/\n    /***************************/\n\n    /**\n     *  @inheritdoc FlashloanablePool\n     *  @dev Override default implementation and allows flashloans for both quote and collateral token.\n     */\n    function _isFlashloanSupported(\n        address token_\n    ) internal virtual view override returns (bool) {\n        return token_ == _getArgAddress(QUOTE_ADDRESS) || token_ == _getArgAddress(COLLATERAL_ADDRESS);\n    }\n\n    /************************/\n    /*** Helper Functions ***/\n    /************************/\n\n    /**\n     *  @notice Helper function to transfer amount of collateral tokens from sender to pool contract.\n     *  @param  from_    Sender address.\n     *  @param  amount_  Amount to transfer from sender (`WAD` precision). Scaled to collateral precision before transfer.\n     */\n    function _transferCollateralFrom(address from_, uint256 amount_) internal {\n        // Transfer amount in favour of the pool\n        uint256 transferAmount = Maths.ceilDiv(amount_, _getArgUint256(COLLATERAL_SCALE));\n        IERC20(_getArgAddress(COLLATERAL_ADDRESS)).safeTransferFrom(from_, address(this), transferAmount);\n    }\n\n    /**\n     *  @notice Helper function to transfer amount of collateral tokens from pool contract.\n     *  @param  to_     Receiver address.\n     *  @param  amount_ Amount to transfer to receiver (`WAD` precision). Scaled to collateral precision before transfer.\n     */\n    function _transferCollateral(address to_, uint256 amount_) internal {\n        IERC20(_getArgAddress(COLLATERAL_ADDRESS)).safeTransfer(to_, amount_ / _getArgUint256(COLLATERAL_SCALE));\n    }\n\n    /**\n     *  @notice Helper function to calculate the minimum amount of collateral an actor may have in a bucket.\n     *  @param  bucketIndex_  Bucket index.\n     *  @return Amount of collateral dust amount of the bucket.\n     */\n    function _bucketCollateralDust(uint256 bucketIndex_) internal pure returns (uint256) {\n        // price precision adjustment will always be 0 for encumbered collateral\n        uint256 pricePrecisionAdjustment = _getCollateralDustPricePrecisionAdjustment(bucketIndex_);\n        // difference between the normalized scale and the collateral token's scale\n        return Maths.max(_getArgUint256(COLLATERAL_SCALE), 10 ** pricePrecisionAdjustment);\n    } \n}"
    },
    {
      "filename": "ajna-core/src/libraries/external/BorrowerActions.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.18;\n\nimport {\n    AuctionsState,\n    Borrower,\n    Bucket,\n    DepositsState,\n    LoansState,\n    PoolState\n}                   from '../../interfaces/pool/commons/IPoolState.sol';\nimport {\n    DrawDebtResult,\n    RepayDebtResult\n}                   from '../../interfaces/pool/commons/IPoolInternals.sol';\n\nimport {\n    _borrowFeeRate,\n    _priceAt,\n    _isCollateralized\n}                           from '../helpers/PoolHelper.sol';\nimport { \n    _revertIfPriceDroppedBelowLimit,\n    _revertOnMinDebt\n}                           from '../helpers/RevertsHelper.sol';\n\nimport { Buckets }  from '../internal/Buckets.sol';\nimport { Deposits } from '../internal/Deposits.sol';\nimport { Loans }    from '../internal/Loans.sol';\nimport { Maths }    from '../internal/Maths.sol';\n\nimport { SettlerActions } from './SettlerActions.sol';\n\n/**\n    @title  BorrowerActions library\n    @notice External library containing logic for for pool actors:\n            - `Borrowers`: pledge collateral and draw debt; repay debt and pull collateral\n */\nlibrary BorrowerActions {\n\n    /*************************/\n    /*** Local Var Structs ***/\n    /*************************/\n\n    /// @dev Struct used for `drawDebt` function local vars.\n    struct DrawDebtLocalVars {\n        bool    borrow;                // true if borrow action\n        uint256 borrowerDebt;          // [WAD] borrower's accrued debt\n        uint256 compensatedCollateral; // [WAD] amount of borrower collateral that is compensated with LP (NFTs only)\n        uint256 t0BorrowAmount;        // [WAD] t0 amount to borrow\n        uint256 t0DebtChange;          // [WAD] additional t0 debt resulted from draw debt action\n        bool    pledge;                // true if pledge action\n        bool    stampT0Np;             // true if loan's t0 neutral price should be restamped (when drawing debt or pledge settles auction)\n    }\n\n    /// @dev Struct used for `repayDebt` function local vars.\n    struct RepayDebtLocalVars {\n        uint256 borrowerDebt;          // [WAD] borrower's accrued debt\n        uint256 compensatedCollateral; // [WAD] amount of borrower collateral that is compensated with LP (NFTs only)\n        bool    pull;                  // true if pull action\n        bool    repay;                 // true if repay action\n        bool    stampT0Np;             // true if loan's t0 neutral price should be restamped (when repay settles auction or pull collateral)\n        uint256 t0DebtInAuctionChange; // [WAD] t0 change amount of debt after repayment\n        uint256 t0RepaidDebt;          // [WAD] t0 debt repaid\n    }\n\n    /**************/\n    /*** Events ***/\n    /**************/\n\n    // See `IPoolEvents` for descriptions\n    event LoanStamped(address indexed borrowerAddress);\n\n    /**************/\n    /*** Errors ***/\n    /**************/\n\n    // See `IPoolErrors` for descriptions\n    error AuctionActive();\n    error BorrowerNotSender();\n    error BorrowerUnderCollateralized();\n    error InsufficientLiquidity();\n    error InsufficientCollateral();\n    error InvalidAmount();\n    error LimitIndexExceeded();\n    error NoDebt();\n\n    /***************************/\n    /***  External Functions ***/\n    /***************************/\n\n    /**\n     *  @notice See `IERC20PoolBorrowerActions` and `IERC721PoolBorrowerActions` for descriptions\n     *  @dev    === Write state ===\n     *  @dev    - `SettlerActions._settleAuction` (`_removeAuction`):\n     *  @dev      decrement kicker locked accumulator, increment kicker claimable accumumlator\n     *  @dev      decrement auctions count accumulator\n     *  @dev      update auction queue state\n     *  @dev    - `Loans.update` (`_upsert`):\n     *  @dev      insert or update loan in loans array\n     *  @dev      remove loan from loans array\n     *  @dev      update borrower in `address => borrower` mapping\n     *  @dev    === Reverts on ===\n     *  @dev    not enough quote tokens available `InsufficientLiquidity()`\n     *  @dev    borrower not sender `BorrowerNotSender()`\n     *  @dev    borrower debt less than pool min debt `AmountLTMinDebt()`\n     *  @dev    limit price reached `LimitIndexExceeded()`\n     *  @dev    borrower cannot draw more debt `BorrowerUnderCollateralized()`\n     *  @dev    === Emit events ===\n     *  @dev    - `SettlerActions._settleAuction`: `AuctionNFTSettle` or `AuctionSettle`\n     */\n    function drawDebt(\n        AuctionsState storage auctions_,\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        LoansState    storage loans_,\n        PoolState calldata poolState_,\n        uint256 maxAvailable_,\n        address borrowerAddress_,\n        uint256 amountToBorrow_,\n        uint256 limitIndex_,\n        uint256 collateralToPledge_\n    ) external returns (\n        DrawDebtResult memory result_\n    ) {\n        // revert if not enough pool balance to borrow\n        if (amountToBorrow_ > maxAvailable_) revert InsufficientLiquidity();\n\n        DrawDebtLocalVars memory vars;\n        vars.pledge = collateralToPledge_ != 0;\n        vars.borrow = amountToBorrow_ != 0;\n\n        // revert if no amount to pledge or borrow\n        if (!vars.pledge && !vars.borrow) revert InvalidAmount();\n\n        Borrower memory borrower = loans_.borrowers[borrowerAddress_];\n\n        vars.borrowerDebt = Maths.wmul(borrower.t0Debt, poolState_.inflator);\n\n        result_.inAuction           = _inAuction(auctions_, borrowerAddress_);\n        result_.debtPreAction       = borrower.t0Debt;\n        result_.collateralPreAction = borrower.collateral;\n        result_.t0PoolDebt          = poolState_.t0Debt;\n        result_.poolDebt            = poolState_.debt;\n        result_.poolCollateral      = poolState_.collateral;\n        result_.remainingCollateral = borrower.collateral;\n\n        if (vars.pledge) {\n            // add new amount of collateral to pledge to borrower balance\n            borrower.collateral  += collateralToPledge_;\n\n            result_.remainingCollateral += collateralToPledge_;\n            result_.newLup              = Deposits.getLup(deposits_, result_.poolDebt);\n\n            // if loan is auctioned and becomes collateralized by newly pledged collateral then settle auction\n            if (\n                result_.inAuction &&\n                _isCollateralized(vars.borrowerDebt, borrower.collateral, result_.newLup, poolState_.poolType)\n            ) {\n                // stamp borrower t0Np when exiting from auction\n                vars.stampT0Np = true;\n\n                // borrower becomes re-collateralized, entire borrower debt is removed from pool auctions debt accumulator\n                result_.inAuction             = false;\n                result_.settledAuction        = true;\n                result_.t0DebtInAuctionChange = borrower.t0Debt;\n\n                // settle auction and update borrower's collateral with value after settlement\n                (\n                    result_.remainingCollateral,\n                    vars.compensatedCollateral\n                ) = SettlerActions._settleAuction(\n                    auctions_,\n                    buckets_,\n                    deposits_,\n                    borrowerAddress_,\n                    borrower.collateral,\n                    poolState_.poolType\n                );\n                result_.poolCollateral -= vars.compensatedCollateral;\n\n                borrower.collateral = result_.remainingCollateral;                \n            }\n\n            // add new amount of collateral to pledge to pool balance\n            result_.poolCollateral += collateralToPledge_;\n        }\n\n        if (vars.borrow) {\n            // only intended recipient can borrow quote\n            if (borrowerAddress_ != msg.sender) revert BorrowerNotSender();\n\n            // an auctioned borrower in not allowed to draw more debt (even if collateralized at the new LUP) if auction is not settled\n            if (result_.inAuction) revert AuctionActive();\n\n            vars.t0BorrowAmount = Maths.ceilWdiv(amountToBorrow_, poolState_.inflator);\n\n            // t0 debt change is t0 amount to borrow plus the origination fee\n            vars.t0DebtChange = Maths.wmul(vars.t0BorrowAmount, _borrowFeeRate(poolState_.rate) + Maths.WAD);\n\n            borrower.t0Debt += vars.t0DebtChange;\n\n            vars.borrowerDebt = Maths.wmul(borrower.t0Debt, poolState_.inflator);\n\n            // check that drawing debt doesn't leave borrower debt under pool min debt amount\n            _revertOnMinDebt(\n                loans_,\n                result_.poolDebt,\n                vars.borrowerDebt,\n                poolState_.quoteTokenScale\n            );\n\n            // add debt change to pool's debt\n            result_.t0PoolDebt += vars.t0DebtChange;\n            result_.poolDebt   = Maths.wmul(result_.t0PoolDebt, poolState_.inflator);\n            result_.newLup     = Deposits.getLup(deposits_, result_.poolDebt);\n\n            // revert if borrow drives LUP price under the specified price limit\n            _revertIfPriceDroppedBelowLimit(result_.newLup, limitIndex_);\n\n            // use new lup to check borrow action won't push borrower into a state of under-collateralization\n            // this check also covers the scenario when loan is already auctioned\n            if (!_isCollateralized(vars.borrowerDebt, borrower.collateral, result_.newLup, poolState_.poolType)) {\n                revert BorrowerUnderCollateralized();\n            }\n\n            // stamp borrower t0Np when draw debt\n            vars.stampT0Np = true;\n        }\n\n        // update loan state\n        Loans.update(\n            loans_,\n            auctions_,\n            deposits_,\n            borrower,\n            borrowerAddress_,\n            result_.poolDebt,\n            poolState_.rate,\n            result_.newLup,\n            result_.inAuction,\n            vars.stampT0Np\n        );\n\n        result_.debtPostAction       = borrower.t0Debt;\n        result_.collateralPostAction = borrower.collateral;\n    }\n\n    /**\n     *  @notice See `IERC20PoolBorrowerActions` and `IERC721PoolBorrowerActions` for descriptions\n     *  @dev    === Write state ===\n     *  @dev    - `SettlerActions._settleAuction` (`_removeAuction`):\n     *  @dev      decrement kicker locked accumulator, increment kicker claimable accumumlator\n     *  @dev      decrement auctions count accumulator\n     *  @dev      update auction queue state\n     *  @dev    - `Loans.update` (`_upsert`):\n     *  @dev      insert or update loan in loans array\n     *  @dev      remove loan from loans array\n     *  @dev      update borrower in `address => borrower` mapping\n     *  @dev    === Reverts on ===\n     *  @dev    no debt to repay `NoDebt()`\n     *  @dev    borrower debt less than pool min debt `AmountLTMinDebt()`\n     *  @dev    borrower not sender `BorrowerNotSender()`\n     *  @dev    not enough collateral to pull `InsufficientCollateral()`\n     *  @dev    limit price reached `LimitIndexExceeded()`\n     *  @dev    === Emit events ===\n     *  @dev    - `SettlerActions._settleAuction`: `AuctionNFTSettle` or `AuctionSettle`\n     */\n    function repayDebt(\n        AuctionsState storage auctions_,\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        LoansState    storage loans_,\n        PoolState calldata poolState_,\n        address borrowerAddress_,\n        uint256 maxQuoteTokenAmountToRepay_,\n        uint256 collateralAmountToPull_,\n        uint256 limitIndex_\n    ) external returns (\n        RepayDebtResult memory result_\n    ) {\n        RepayDebtLocalVars memory vars;\n        vars.repay = maxQuoteTokenAmountToRepay_ != 0;\n        vars.pull  = collateralAmountToPull_     != 0;\n\n        // revert if no amount to pull or repay\n        if (!vars.repay && !vars.pull) revert InvalidAmount();\n\n        Borrower memory borrower = loans_.borrowers[borrowerAddress_];\n\n        vars.borrowerDebt = Maths.wmul(borrower.t0Debt, poolState_.inflator);\n\n        result_.inAuction           = _inAuction(auctions_, borrowerAddress_);\n        result_.debtPreAction       = borrower.t0Debt;\n        result_.collateralPreAction = borrower.collateral;\n        result_.t0PoolDebt          = poolState_.t0Debt;\n        result_.poolDebt            = poolState_.debt;\n        result_.poolCollateral      = poolState_.collateral;\n        result_.remainingCollateral = borrower.collateral;\n\n        if (vars.repay) {\n            if (borrower.t0Debt == 0) revert NoDebt();\n\n            if (maxQuoteTokenAmountToRepay_ == type(uint256).max) {\n                vars.t0RepaidDebt = borrower.t0Debt;\n            } else {\n                vars.t0RepaidDebt = Maths.min(\n                    borrower.t0Debt,\n                    Maths.floorWdiv(maxQuoteTokenAmountToRepay_, poolState_.inflator)\n                );\n            }\n\n            result_.t0PoolDebt        -= vars.t0RepaidDebt;"
    }
  ]
}