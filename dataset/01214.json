{
  "Title": "No check if bridge already exists",
  "Content": "# No check if bridge already exists\n\n### Severity\nLow Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/OwnerFacet.sol#L274-L284\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/OwnerFacet.sol#L274-L284</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibVault.sol#L42-L53\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibVault.sol#L42-L53</a>\n\n\n## Summary\nIn the current `createBridge` function of the OwnerFacet.sol contract, a critical check to verify if the bridge already exists is missing. This omission can potentially result in double accounting in the yield generation process.\n\n## Vulnerability Details\nIn the rest of the OwnerFacet.sol contract functionality, there are checks in place to prevent the recreation of Vaults or Markets. However, this essential check is absent in the `createBridge()` function. The absence of this check can lead to the unintended creation of duplicate bridges, resulting in double accounting of yield if multiple vaults utilize the same bridge more than once. You can find the missing check in the code here: [Link to code](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/OwnerFacet.sol#L274-L284).\n\nThe potential for double accounting of yield is evident in the following code block:\n\n```Solidity\nfunction getZethTotal(uint256 vault) internal view returns (uint256 zethTotal) {\n    AppStorage storage s = appStorage();\n    address[] storage bridges = s.vaultBridges[vault];\n    uint256 bridgeCount = bridges.length;\n\n    for (uint256 i; i < bridgeCount;) {\n        zethTotal += IBridge(bridges[i]).getZethValue(); \n        unchecked {\n            ++i;\n        }\n    }\n}\n```\n### Proof of Concept\nTo demonstrate this behavior, a simple Proof of Concept (PoC) was created. (The test was placed in the Yield.t.sol file.)\n\n```Solidity\nfunction test_double_bridge_push() public {\n    vm.prank(owner);\n    diamond.createBridge(_bridgeReth, Vault.CARBON, 0, 0);\n    diamond.getUndistributedYield(Vault.CARBON); \n    assert(diamond.getUndistributedYield(Vault.CARBON) > 0); // As no yield was generated, this should not be true, but in current situation, it is a proof of double accounting.\n}\n```\n## Impact\nIn specific circumstances, if a DAO proposal is confirmed, it could inadvertently trigger the creation of a bridge with the same address for a vault that already uses it. This scenario can lead to double accounting of yield and, as a consequence, potentially expose the protocol to vulnerabilities such as Denial of Service and yield theft.\n\nHowever, it's important to note that the likelihood of this issue occurring is relatively low, and the function is governed by the DAO. After discussing this with the sponsor, we have classified this finding as low severity.\n\n## Tools Used\nManual review.\n\n## Recommendations\nTo address this vulnerability, it is recommended to add the following mitigation to the createBridge function:\n\n```diff\n...\n+ for (uint i = 0; i < s.vaultBridges[vault].length; i++) {\n+     if (s.vaultBridges[vault][i] == bridge) {\n+         revert Errors.BridgeAlreadyExist();\n+     }\n+ }\n```\nThis change will prevent the inadvertent creation of duplicate bridges and mitigate the risk of double accounting of yield.",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clm871gl00001mp081mzjdlwc",
  "Code": [
    {
      "filename": "contracts/facets/OwnerFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {STypes, MTypes, SR} from \"contracts/libraries/DataTypes.sol\";\nimport {LibDiamond} from \"contracts/libraries/LibDiamond.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract OwnerFacet is Modifiers {\n    using U256 for uint256;\n\n    /**\n     * @notice Initialize data for newly deployed market\n     * @dev Single use only\n     *\n     * @param asset The market that will be impacted\n     * @param a The market settings\n     */\n\n    /*\n     * @param oracle The oracle for the asset\n     * @param initialMargin Initial margin value of the new market\n     * @param primaryLiquidationCR Liquidation ratio (Maintenance margin) value of the new market\n     * @param secondaryLiquidationCR CRatio threshold for secondary liquidations\n     * @param forcedBidPriceBuffer Liquidation limit value of the new market\n     * @param minimumCR Lowest threshold for shortRecord to not lose collateral during liquidation\n     * @param resetLiquidationTime Time limit for when flagged shorts get reset\n     * @param secondLiquidationTime Time limit for when flagged shorts can be liquidated by others, not just flagger\n     * @param firstLiquidationTime Time limit for when flagged shorts get be liquidated by flagger\n     * @param tappFeePct Primary liquidation fee sent to TAPP out of shorter collateral\n     * @param callerFeePct Primary liquidation fee sent to margin caller out of shorter collateral\n     * @param minBidEth Minimum bid dust amount\n     * @param minAskEth Minimum ask dust amount\n     * @param minShortErc Minimum short record debt amount\n    */\n\n    function createMarket(address asset, STypes.Asset memory a) external onlyDAO {\n        STypes.Asset storage Asset = s.asset[asset];\n        // can check non-zero ORDER_ID to prevent creating same asset\n        if (Asset.orderId != 0) revert Errors.MarketAlreadyCreated();\n\n        Asset.vault = a.vault;\n        _setAssetOracle(asset, a.oracle);\n\n        Asset.assetId = uint8(s.assets.length);\n        s.assetMapping[s.assets.length] = asset;\n        s.assets.push(asset);\n\n        STypes.Order memory guardOrder;\n        guardOrder.prevId = Constants.HEAD;\n        guardOrder.id = Constants.HEAD;\n        guardOrder.nextId = Constants.TAIL;\n        //@dev parts of OB depend on having sell's HEAD's price and creationTime = 0\n        s.asks[asset][Constants.HEAD] = s.shorts[asset][Constants.HEAD] = guardOrder;\n\n        //@dev Using Bid's HEAD's order contain oracle data\n        guardOrder.creationTime = LibOrders.getOffsetTime();\n        guardOrder.ercAmount = uint80(LibOracle.getOraclePrice(asset));\n        s.bids[asset][Constants.HEAD] = guardOrder;\n\n        //@dev hardcoded value\n        Asset.orderId = Constants.STARTING_ID; // 100\n        Asset.startingShortId = Constants.HEAD;\n\n        //@dev comment with initial values\n        _setInitialMargin(asset, a.initialMargin); // 500 -> 5 ether\n        _setPrimaryLiquidationCR(asset, a.primaryLiquidationCR); // 400 -> 4 ether\n        _setSecondaryLiquidationCR(asset, a.secondaryLiquidationCR); // 150 -> 1.5 ether\n        _setForcedBidPriceBuffer(asset, a.forcedBidPriceBuffer); // 110 -> 1.1 ether\n        _setMinimumCR(asset, a.minimumCR); // 110 -> 1.1 ether\n        _setResetLiquidationTime(asset, a.resetLiquidationTime); // 1600 -> 16 hours\n        _setSecondLiquidationTime(asset, a.secondLiquidationTime); // 1200 -> 12 hours\n        _setFirstLiquidationTime(asset, a.firstLiquidationTime); // 1000 -> 10 hours\n        _setTappFeePct(asset, a.tappFeePct); //25 -> .025 ether\n        _setCallerFeePct(asset, a.callerFeePct); //5 -> .005 ether\n        _setMinBidEth(asset, a.minBidEth); //1 -> 0.001 ether\n        _setMinAskEth(asset, a.minAskEth); //1 -> 0.001 ether\n        _setMinShortErc(asset, a.minShortErc); //2000 -> 2000 ether\n\n        // Create TAPP short\n        LibShortRecord.createShortRecord(\n            asset, address(this), SR.FullyFilled, 0, 0, 0, 0, 0\n        );\n        emit Events.CreateMarket(asset, Asset);\n    }\n\n    //@dev does not need read only re-entrancy\n    function owner() external view returns (address) {\n        return LibDiamond.contractOwner();\n    }\n\n    function admin() external view returns (address) {\n        return s.admin;\n    }\n\n    //@dev does not need read only re-entrancy\n    function ownerCandidate() external view returns (address) {\n        return s.ownerCandidate;\n    }\n\n    function transferOwnership(address newOwner) external onlyDAO {\n        s.ownerCandidate = newOwner;\n        emit Events.NewOwnerCandidate(newOwner);\n    }\n\n    //@dev event emitted in setContractOwner\n    function claimOwnership() external {\n        if (s.ownerCandidate != msg.sender) revert Errors.NotOwnerCandidate();\n        LibDiamond.setContractOwner(msg.sender);\n        delete s.ownerCandidate;\n    }\n\n    //No need for claim step because DAO can also set admin\n    function transferAdminship(address newAdmin) external onlyAdminOrDAO {\n        s.admin = newAdmin;\n        emit Events.NewAdmin(newAdmin);\n    }\n\n    //When deactivating an asset make sure to zero out the oracle.\n    function setAssetOracle(address asset, address oracle) external onlyDAO {\n        _setAssetOracle(asset, oracle);\n        emit Events.UpdateAssetOracle(asset, oracle);\n    }\n\n    function createVault(\n        address zeth,\n        uint256 vault,\n        MTypes.CreateVaultParams calldata params\n    ) external onlyDAO {\n        if (s.zethVault[zeth] != 0) revert Errors.VaultAlreadyCreated();\n        s.zethVault[zeth] = vault;\n        _setTithe(vault, params.zethTithePercent);\n        _setDittoMatchedRate(vault, params.dittoMatchedRate);\n        _setDittoShorterRate(vault, params.dittoShorterRate);\n        emit Events.CreateVault(zeth, vault);\n    }\n\n    // Update eligibility requirements for yield accrual\n    function setTithe(uint256 vault, uint16 zethTithePercent) external onlyAdminOrDAO {\n        _setTithe(vault, zethTithePercent);\n        emit Events.ChangeVaultSetting(vault);\n    }\n\n    function setDittoMatchedRate(uint256 vault, uint16 rewardRate)\n        external\n        onlyAdminOrDAO\n    {\n        _setDittoMatchedRate(vault, rewardRate);\n        emit Events.ChangeVaultSetting(vault);\n    }\n\n    function setDittoShorterRate(uint256 vault, uint16 rewardRate)\n        external\n        onlyAdminOrDAO\n    {\n        _setDittoShorterRate(vault, rewardRate);\n        emit Events.ChangeVaultSetting(vault);\n    }\n\n    // For Short Record collateral ratios\n    // initialMargin > primaryLiquidationCR > secondaryLiquidationCR > minimumCR\n    // After initial market creation. Set CRs from smallest to largest to prevent triggering the require checks\n\n    function setInitialMargin(address asset, uint16 value) external onlyAdminOrDAO {\n        require(value > s.asset[asset].primaryLiquidationCR, \"below primary liquidation\");\n        _setInitialMargin(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setPrimaryLiquidationCR(address asset, uint16 value)\n        external\n        onlyAdminOrDAO\n    {\n        require(\n            value > s.asset[asset].secondaryLiquidationCR, \"below secondary liquidation\"\n        );\n        _setPrimaryLiquidationCR(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setSecondaryLiquidationCR(address asset, uint16 value)\n        external\n        onlyAdminOrDAO\n    {\n        _setSecondaryLiquidationCR(asset, value);\n        require(\n            LibAsset.secondaryLiquidationCR(asset) > LibAsset.minimumCR(asset),\n            \"below minimum CR\"\n        );\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setForcedBidPriceBuffer(address asset, uint8 value)\n        external\n        onlyAdminOrDAO\n    {\n        _setForcedBidPriceBuffer(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setMinimumCR(address asset, uint8 value) external onlyAdminOrDAO {\n        _setMinimumCR(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    // Used for Primary Margin Call\n    // resetLiquidationTime > secondLiquidationTime > firstLiquidationTime\n\n    function setResetLiquidationTime(address asset, uint16 value)\n        external\n        onlyAdminOrDAO\n    {\n        _setResetLiquidationTime(asset, value);\n        require(\n            value >= s.asset[asset].secondLiquidationTime, \"below secondLiquidationTime\"\n        );\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setSecondLiquidationTime(address asset, uint16 value)\n        external\n        onlyAdminOrDAO\n    {\n        _setSecondLiquidationTime(asset, value);\n        require(\n            value >= s.asset[asset].firstLiquidationTime, \"below firstLiquidationTime\"\n        );\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setFirstLiquidationTime(address asset, uint16 value)\n        external\n        onlyAdminOrDAO\n    {\n        _setFirstLiquidationTime(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setTappFeePct(address asset, uint8 value) external onlyAdminOrDAO {\n        _setTappFeePct(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setCallerFeePct(address asset, uint8 value) external onlyAdminOrDAO {\n        _setCallerFeePct(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setMinBidEth(address asset, uint8 value) external onlyAdminOrDAO {\n        _setMinBidEth(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setMinAskEth(address asset, uint8 value) external onlyAdminOrDAO {\n        _setMinAskEth(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setMinShortErc(address asset, uint16 value) external onlyAdminOrDAO {\n        _setMinShortErc(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function createBridge(\n        address bridge,\n        uint256 vault,\n        uint16 withdrawalFee,\n        uint8 unstakeFee\n    ) external onlyDAO {\n        s.vaultBridges[vault].push(bridge);\n        s.bridge[bridge].vault = uint8(vault);\n        _setWithdrawalFee(bridge, withdrawalFee);\n        _setUnstakeFee(bridge, unstakeFee);\n        emit Events.CreateBridge(bridge, s.bridge[bridge]);\n    }\n\n    function deleteBridge(address bridge) external onlyDAO {\n        uint256 vault = s.bridge[bridge].vault;\n        if (vault == 0) revert Errors.InvalidBridge();\n\n        address[] storage VaultBridges = s.vaultBridges[vault];\n        uint256 length = VaultBridges.length;\n        for (uint256 i; i < length; i++) {\n            if (VaultBridges[i] == bridge) {\n                if (i != length - 1) {\n                    VaultBridges[i] = VaultBridges[length - 1];\n                }\n                VaultBridges.pop();\n                break;\n            }\n        }\n        delete s.bridge[bridge];\n        emit Events.DeleteBridge(bridge);\n    }\n\n    function setWithdrawalFee(address bridge, uint16 withdrawalFee)\n        external\n        onlyAdminOrDAO\n    {\n        _setWithdrawalFee(bridge, withdrawalFee);\n        emit Events.ChangeBridgeSetting(bridge);\n    }\n\n    function setUnstakeFee(address bridge, uint8 unstakeFee) external onlyAdminOrDAO {\n        _setUnstakeFee(bridge, unstakeFee);\n        emit Events.ChangeBridgeSetting(bridge);\n    }\n\n    function _setAssetOracle(address asset, address oracle) private {\n        if (asset == address(0) || oracle == address(0)) revert Errors.ParameterIsZero();\n        s.asset[asset].oracle = oracle;\n    }\n\n    function _setTithe(uint256 vault, uint16 zethTithePercent) private {\n        if (zethTithePercent > 33_33) revert Errors.InvalidTithe();\n        s.vault[vault].zethTithePercent = zethTithePercent;\n    }\n\n    function _setDittoMatchedRate(uint256 vault, uint16 rewardRate) private {\n        require(rewardRate <= 100, \"above 100\");\n        s.vault[vault].dittoMatchedRate = rewardRate;\n    }\n\n    function _setDittoShorterRate(uint256 vault, uint16 rewardRate) private {\n        require(rewardRate <= 100, \"above 100\");\n        s.vault[vault].dittoShorterRate = rewardRate;\n    }\n\n    function _setInitialMargin(address asset, uint16 value) private {\n        require(value > 100, \"below 1.0\");\n        s.asset[asset].initialMargin = value;\n        require(LibAsset.initialMargin(asset) < Constants.CRATIO_MAX, \"above max CR\");\n    }\n\n    function _setPrimaryLiquidationCR(address asset, uint16 value) private {\n        require(value > 100, \"below 1.0\");\n        require(value <= 500, \"above 5.0\");\n        require(value < s.asset[asset].initialMargin, \"above initial margin\");\n        s.asset[asset].primaryLiquidationCR = value;\n    }\n\n    function _setSecondaryLiquidationCR(address asset, uint16 value) private {\n        require(value > 100, \"below 1.0\");\n        require(value <= 500, \"above 5.0\");\n        require(value < s.asset[asset].primaryLiquidationCR, \"above primary liquidation\");\n        s.asset[asset].secondaryLiquidationCR = value;\n    }\n\n    function _setForcedBidPriceBuffer(address asset, uint8 value) private {\n        require(value >= 100, \"below 1.0\");\n        require(value <= 200, \"above 2.0\");\n        s.asset[asset].forcedBidPriceBuffer = value;\n    }\n\n    function _setMinimumCR(address asset, uint8 value) private {\n        require(value >= 100, \"below 1.0\");\n        require(value <= 200, \"above 2.0\");\n        s.asset[asset].minimumCR = value;\n        require(\n            LibAsset.minimumCR(asset) < LibAsset.secondaryLiquidationCR(asset),\n            \"above secondary liquidation\"\n        );\n    }\n\n    // Used for Primary Margin Call\n    // resetLiquidationTime > secondLiquidationTime > firstLiquidationTime\n\n    function _setResetLiquidationTime(address asset, uint16 value) private {\n        require(value >= 100, \"below 1.00\");\n        require(value <= 4800, \"above 48.00\");\n        s.asset[asset].resetLiquidationTime = value;\n    }\n\n    function _setSecondLiquidationTime(address asset, uint16 value) private {\n        require(value >= 100, \"below 1.00\");\n        require(\n            value <= s.asset[asset].resetLiquidationTime, \"above resetLiquidationTime\"\n        );\n        s.asset[asset].secondLiquidationTime = value;\n    }\n\n    function _setFirstLiquidationTime(address asset, uint16 value) private {\n        require(value >= 100, \"below 1.00\");\n        require(\n            value <= s.asset[asset].secondLiquidationTime, \"above secondLiquidationTime\"\n        );\n        s.asset[asset].firstLiquidationTime = value;\n    }\n\n    function _setTappFeePct(address asset, uint8 value) private {\n        require(value > 0, \"Can't be zero\");\n        require(value <= 250, \"above 25.0\");\n        s.asset[asset].tappFeePct = value;\n    }\n\n    function _setCallerFeePct(address asset, uint8 value) private {\n        require(value > 0, \"Can't be zero\");\n        require(value <= 250, \"above 25.0\");\n        s.asset[asset].callerFeePct = value;\n    }\n\n    function _setMinBidEth(address asset, uint8 value) private {\n        //no upperboard check because uint8 max - 255\n        require(value > 0, \"Can't be zero\");\n        s.asset[asset].minBidEth = value;\n    }\n\n    function _setMinAskEth(address asset, uint8 value) private {\n        //no upperboard check because uint8 max - 255\n        require(value > 0, \"Can't be zero\");\n        s.asset[asset].minAskEth = value;\n    }\n\n    function _setMinShortErc(address asset, uint16 value) private {\n        //no upperboard check because uint8 max - 65,535\n        require(value > 0, \"Can't be zero\");\n        s.asset[asset].minShortErc = value;\n    }\n\n    function _setWithdrawalFee(address bridge, uint16 withdrawalFee) private {\n        require(withdrawalFee <= 1500, \"above 15.00%\");\n        s.bridge[bridge].withdrawalFee = withdrawalFee;\n    }\n\n    function _setUnstakeFee(address bridge, uint8 unstakeFee) private {\n        require(unstakeFee <= 250, \"above 2.50%\");\n        s.bridge[bridge].unstakeFee = unstakeFee;\n    }\n}"
    },
    {
      "filename": "contracts/libraries/LibVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {IBridge} from \"contracts/interfaces/IBridge.sol\";\n\nimport {STypes} from \"contracts/libraries/DataTypes.sol\";\nimport {AppStorage, appStorage} from \"contracts/libraries/AppStorage.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\nimport {U256, U88} from \"contracts/libraries/PRBMathHelper.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\nlibrary LibVault {\n    using U256 for uint256;\n    using U88 for uint88;\n    using {zethTithePercent} for uint256;\n\n    // BridgeRouterFacet\n    function addZeth(uint256 vault, uint88 amount) internal {\n        AppStorage storage s = appStorage();\n        s.vaultUser[vault][msg.sender].ethEscrowed += amount;\n        s.vault[vault].zethTotal += amount;\n    }\n\n    function removeZeth(uint256 vault, uint88 amount, uint88 fee) internal {\n        AppStorage storage s = appStorage();\n        s.vaultUser[vault][msg.sender].ethEscrowed -= (amount + fee);\n        s.vault[vault].zethTotal -= amount;\n    }\n\n    // default of .1 ether, stored in uint16 as 10_00\n    // range of [0-33],\n    // i.e. 12.34% as 12_34 / 10_000 -> 0.1234 ether\n    // @dev percentage of yield given to TAPP\n    function zethTithePercent(uint256 vault) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        return (uint256(s.vault[vault].zethTithePercent) * 1 ether)\n            / Constants.FOUR_DECIMAL_PLACES;\n    }\n\n    function getZethTotal(uint256 vault) internal view returns (uint256 zethTotal) {\n        AppStorage storage s = appStorage();\n        address[] storage bridges = s.vaultBridges[vault];\n        uint256 bridgeCount = bridges.length;\n\n        for (uint256 i; i < bridgeCount;) {\n            zethTotal += IBridge(bridges[i]).getZethValue();\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Updates the vault yield rate from staking rewards earned by bridge contracts holding LSD\n     * @dev Does not distribute yield to any individual owner of shortRecords\n     *\n     * @param vault The vault that will be impacted\n     */\n\n    function updateYield(uint256 vault) internal {\n        AppStorage storage s = appStorage();\n\n        STypes.Vault storage Vault = s.vault[vault];\n        STypes.VaultUser storage TAPP = s.vaultUser[vault][address(this)];\n        // Retrieve vault variables\n        uint88 zethTotalNew = uint88(getZethTotal(vault)); // @dev(safe-cast)\n        uint88 zethTotal = Vault.zethTotal;\n        uint88 zethCollateral = Vault.zethCollateral;\n        uint88 zethTreasury = TAPP.ethEscrowed;\n\n        // Calculate vault yield and overwrite previous total\n        if (zethTotalNew <= zethTotal) return;\n        uint88 yield = zethTotalNew - zethTotal;\n        Vault.zethTotal = zethTotalNew;\n\n        // If no short records, yield goes to treasury\n        if (zethCollateral == 0) {\n            TAPP.ethEscrowed += yield;\n            return;\n        }\n\n        // Assign yield to zethTreasury\n        uint88 zethTreasuryReward = yield.mul(zethTreasury).divU88(zethTotal);\n        yield -= zethTreasuryReward;\n        // Assign tithe of the remaining yield to treasuryF\n        uint88 tithe = yield.mulU88(vault.zethTithePercent());\n        yield -= tithe;\n        // Realize assigned yields\n        TAPP.ethEscrowed += zethTreasuryReward + tithe;\n        Vault.zethYieldRate += yield.divU80(zethCollateral);\n        Vault.zethCollateralReward += yield;\n    }\n}"
    },
    {
      "filename": "contracts/facets/OwnerFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {STypes, MTypes, SR} from \"contracts/libraries/DataTypes.sol\";\nimport {LibDiamond} from \"contracts/libraries/LibDiamond.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract OwnerFacet is Modifiers {\n    using U256 for uint256;\n\n    /**\n     * @notice Initialize data for newly deployed market\n     * @dev Single use only\n     *\n     * @param asset The market that will be impacted\n     * @param a The market settings\n     */\n\n    /*\n     * @param oracle The oracle for the asset\n     * @param initialMargin Initial margin value of the new market\n     * @param primaryLiquidationCR Liquidation ratio (Maintenance margin) value of the new market\n     * @param secondaryLiquidationCR CRatio threshold for secondary liquidations\n     * @param forcedBidPriceBuffer Liquidation limit value of the new market\n     * @param minimumCR Lowest threshold for shortRecord to not lose collateral during liquidation\n     * @param resetLiquidationTime Time limit for when flagged shorts get reset\n     * @param secondLiquidationTime Time limit for when flagged shorts can be liquidated by others, not just flagger\n     * @param firstLiquidationTime Time limit for when flagged shorts get be liquidated by flagger\n     * @param tappFeePct Primary liquidation fee sent to TAPP out of shorter collateral\n     * @param callerFeePct Primary liquidation fee sent to margin caller out of shorter collateral\n     * @param minBidEth Minimum bid dust amount\n     * @param minAskEth Minimum ask dust amount\n     * @param minShortErc Minimum short record debt amount\n    */\n\n    function createMarket(address asset, STypes.Asset memory a) external onlyDAO {\n        STypes.Asset storage Asset = s.asset[asset];\n        // can check non-zero ORDER_ID to prevent creating same asset\n        if (Asset.orderId != 0) revert Errors.MarketAlreadyCreated();\n\n        Asset.vault = a.vault;\n        _setAssetOracle(asset, a.oracle);\n\n        Asset.assetId = uint8(s.assets.length);\n        s.assetMapping[s.assets.length] = asset;\n        s.assets.push(asset);\n\n        STypes.Order memory guardOrder;\n        guardOrder.prevId = Constants.HEAD;\n        guardOrder.id = Constants.HEAD;\n        guardOrder.nextId = Constants.TAIL;\n        //@dev parts of OB depend on having sell's HEAD's price and creationTime = 0\n        s.asks[asset][Constants.HEAD] = s.shorts[asset][Constants.HEAD] = guardOrder;\n\n        //@dev Using Bid's HEAD's order contain oracle data\n        guardOrder.creationTime = LibOrders.getOffsetTime();\n        guardOrder.ercAmount = uint80(LibOracle.getOraclePrice(asset));\n        s.bids[asset][Constants.HEAD] = guardOrder;\n\n        //@dev hardcoded value\n        Asset.orderId = Constants.STARTING_ID; // 100\n        Asset.startingShortId = Constants.HEAD;\n\n        //@dev comment with initial values\n        _setInitialMargin(asset, a.initialMargin); // 500 -> 5 ether\n        _setPrimaryLiquidationCR(asset, a.primaryLiquidationCR); // 400 -> 4 ether\n        _setSecondaryLiquidationCR(asset, a.secondaryLiquidationCR); // 150 -> 1.5 ether\n        _setForcedBidPriceBuffer(asset, a.forcedBidPriceBuffer); // 110 -> 1.1 ether\n        _setMinimumCR(asset, a.minimumCR); // 110 -> 1.1 ether\n        _setResetLiquidationTime(asset, a.resetLiquidationTime); // 1600 -> 16 hours\n        _setSecondLiquidationTime(asset, a.secondLiquidationTime); // 1200 -> 12 hours\n        _setFirstLiquidationTime(asset, a.firstLiquidationTime); // 1000 -> 10 hours\n        _setTappFeePct(asset, a.tappFeePct); //25 -> .025 ether\n        _setCallerFeePct(asset, a.callerFeePct); //5 -> .005 ether\n        _setMinBidEth(asset, a.minBidEth); //1 -> 0.001 ether\n        _setMinAskEth(asset, a.minAskEth); //1 -> 0.001 ether\n        _setMinShortErc(asset, a.minShortErc); //2000 -> 2000 ether\n\n        // Create TAPP short\n        LibShortRecord.createShortRecord(\n            asset, address(this), SR.FullyFilled, 0, 0, 0, 0, 0\n        );\n        emit Events.CreateMarket(asset, Asset);\n    }\n\n    //@dev does not need read only re-entrancy\n    function owner() external view returns (address) {\n        return LibDiamond.contractOwner();\n    }\n\n    function admin() external view returns (address) {\n        return s.admin;\n    }\n\n    //@dev does not need read only re-entrancy\n    function ownerCandidate() external view returns (address) {\n        return s.ownerCandidate;\n    }\n\n    function transferOwnership(address newOwner) external onlyDAO {\n        s.ownerCandidate = newOwner;\n        emit Events.NewOwnerCandidate(newOwner);\n    }\n\n    //@dev event emitted in setContractOwner\n    function claimOwnership() external {\n        if (s.ownerCandidate != msg.sender) revert Errors.NotOwnerCandidate();\n        LibDiamond.setContractOwner(msg.sender);\n        delete s.ownerCandidate;\n    }\n\n    //No need for claim step because DAO can also set admin\n    function transferAdminship(address newAdmin) external onlyAdminOrDAO {\n        s.admin = newAdmin;\n        emit Events.NewAdmin(newAdmin);\n    }\n\n    //When deactivating an asset make sure to zero out the oracle.\n    function setAssetOracle(address asset, address oracle) external onlyDAO {\n        _setAssetOracle(asset, oracle);\n        emit Events.UpdateAssetOracle(asset, oracle);\n    }\n\n    function createVault(\n        address zeth,\n        uint256 vault,\n        MTypes.CreateVaultParams calldata params\n    ) external onlyDAO {\n        if (s.zethVault[zeth] != 0) revert Errors.VaultAlreadyCreated();\n        s.zethVault[zeth] = vault;\n        _setTithe(vault, params.zethTithePercent);\n        _setDittoMatchedRate(vault, params.dittoMatchedRate);\n        _setDittoShorterRate(vault, params.dittoShorterRate);\n        emit Events.CreateVault(zeth, vault);\n    }\n\n    // Update eligibility requirements for yield accrual\n    function setTithe(uint256 vault, uint16 zethTithePercent) external onlyAdminOrDAO {\n        _setTithe(vault, zethTithePercent);\n        emit Events.ChangeVaultSetting(vault);\n    }\n\n    function setDittoMatchedRate(uint256 vault, uint16 rewardRate)\n        external\n        onlyAdminOrDAO\n    {\n        _setDittoMatchedRate(vault, rewardRate);\n        emit Events.ChangeVaultSetting(vault);\n    }\n\n    function setDittoShorterRate(uint256 vault, uint16 rewardRate)\n        external\n        onlyAdminOrDAO\n    {\n        _setDittoShorterRate(vault, rewardRate);\n        emit Events.ChangeVaultSetting(vault);\n    }\n\n    // For Short Record collateral ratios\n    // initialMargin > primaryLiquidationCR > secondaryLiquidationCR > minimumCR\n    // After initial market creation. Set CRs from smallest to largest to prevent triggering the require checks\n\n    function setInitialMargin(address asset, uint16 value) external onlyAdminOrDAO {\n        require(value > s.asset[asset].primaryLiquidationCR, \"below primary liquidation\");\n        _setInitialMargin(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setPrimaryLiquidationCR(address asset, uint16 value)\n        external\n        onlyAdminOrDAO\n    {\n        require(\n            value > s.asset[asset].secondaryLiquidationCR, \"below secondary liquidation\"\n        );\n        _setPrimaryLiquidationCR(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setSecondaryLiquidationCR(address asset, uint16 value)\n        external\n        onlyAdminOrDAO\n    {\n        _setSecondaryLiquidationCR(asset, value);\n        require(\n            LibAsset.secondaryLiquidationCR(asset) > LibAsset.minimumCR(asset),\n            \"below minimum CR\"\n        );\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setForcedBidPriceBuffer(address asset, uint8 value)\n        external\n        onlyAdminOrDAO\n    {\n        _setForcedBidPriceBuffer(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setMinimumCR(address asset, uint8 value) external onlyAdminOrDAO {\n        _setMinimumCR(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    // Used for Primary Margin Call\n    // resetLiquidationTime > secondLiquidationTime > firstLiquidationTime\n\n    function setResetLiquidationTime(address asset, uint16 value)\n        external\n        onlyAdminOrDAO\n    {\n        _setResetLiquidationTime(asset, value);\n        require(\n            value >= s.asset[asset].secondLiquidationTime, \"below secondLiquidationTime\"\n        );\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setSecondLiquidationTime(address asset, uint16 value)\n        external\n        onlyAdminOrDAO\n    {\n        _setSecondLiquidationTime(asset, value);\n        require(\n            value >= s.asset[asset].firstLiquidationTime, \"below firstLiquidationTime\"\n        );\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setFirstLiquidationTime(address asset, uint16 value)\n        external\n        onlyAdminOrDAO\n    {\n        _setFirstLiquidationTime(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setTappFeePct(address asset, uint8 value) external onlyAdminOrDAO {\n        _setTappFeePct(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setCallerFeePct(address asset, uint8 value) external onlyAdminOrDAO {\n        _setCallerFeePct(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setMinBidEth(address asset, uint8 value) external onlyAdminOrDAO {\n        _setMinBidEth(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setMinAskEth(address asset, uint8 value) external onlyAdminOrDAO {\n        _setMinAskEth(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setMinShortErc(address asset, uint16 value) external onlyAdminOrDAO {\n        _setMinShortErc(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function createBridge(\n        address bridge,\n        uint256 vault,\n        uint16 withdrawalFee,\n        uint8 unstakeFee\n    ) external onlyDAO {\n        s.vaultBridges[vault].push(bridge);\n        s.bridge[bridge].vault = uint8(vault);\n        _setWithdrawalFee(bridge, withdrawalFee);\n        _setUnstakeFee(bridge, unstakeFee);\n        emit Events.CreateBridge(bridge, s.bridge[bridge]);\n    }\n\n    function deleteBridge(address bridge) external onlyDAO {\n        uint256 vault = s.bridge[bridge].vault;\n        if (vault == 0) revert Errors.InvalidBridge();\n\n        address[] storage VaultBridges = s.vaultBridges[vault];\n        uint256 length = VaultBridges.length;\n        for (uint256 i; i < length; i++) {\n            if (VaultBridges[i] == bridge) {\n                if (i != length - 1) {\n                    VaultBridges[i] = VaultBridges[length - 1];\n                }\n                VaultBridges.pop();\n                break;\n            }\n        }\n        delete s.bridge[bridge];\n        emit Events.DeleteBridge(bridge);\n    }\n\n    function setWithdrawalFee(address bridge, uint16 withdrawalFee)\n        external\n        onlyAdminOrDAO\n    {\n        _setWithdrawalFee(bridge, withdrawalFee);\n        emit Events.ChangeBridgeSetting(bridge);\n    }\n\n    function setUnstakeFee(address bridge, uint8 unstakeFee) external onlyAdminOrDAO {\n        _setUnstakeFee(bridge, unstakeFee);\n        emit Events.ChangeBridgeSetting(bridge);\n    }\n\n    function _setAssetOracle(address asset, address oracle) private {\n        if (asset == address(0) || oracle == address(0)) revert Errors.ParameterIsZero();\n        s.asset[asset].oracle = oracle;\n    }\n\n    function _setTithe(uint256 vault, uint16 zethTithePercent) private {\n        if (zethTithePercent > 33_33) revert Errors.InvalidTithe();\n        s.vault[vault].zethTithePercent = zethTithePercent;\n    }\n\n    function _setDittoMatchedRate(uint256 vault, uint16 rewardRate) private {\n        require(rewardRate <= 100, \"above 100\");\n        s.vault[vault].dittoMatchedRate = rewardRate;\n    }\n\n    function _setDittoShorterRate(uint256 vault, uint16 rewar"
    }
  ]
}