{
  "Title": "M-7: All Rage Trade functions allow sending tokens to a different address, leading to incorrect tokensIn",
  "Content": "# Issue M-7: All Rage Trade functions allow sending tokens to a different address, leading to incorrect tokensIn \n\nSource: https://github.com/sherlock-audit/2023-01-sentiment-judging/issues/5 \n\n## Found by \nobront\n\n## Summary\n\nAll three approved functions on Rage Trade (`depositTokens()`, `withdrawTokens()` and `redeemTokens()`) allow for a `receiver` argument to be included, which sends the resulting tokens to that address. The corresponding Controller assumes that all tokens are withdrawn to the Sentiment account that called the function.\n\n## Vulnerability Detail\n\nThe three functions that can be called on Rage Trade have the following signatures:\n- depositToken(address token, address receiver, uint256 amount)\n- redeemToken(address token, address receiver, uint256 amount)\n- withdrawToken(address token, address receiver, uint256 amount)\n\nEach of these functions contains a `receiver` argument, which can be passed any address that will receive the outputted tokens. \n\nThe DNGMXVaultController incorrectly assumes in all cases that the outputted tokens will be received by the Sentiment account in question, regardless of what is entered as a receiver.\n\n## Impact\n\nAccounting on user accounts can be thrown off (intentionally or unintentionally), resulting in mismatches between their assets array and hasAsset mapping and the reality of their account.\n\nThis specific Impact was judged as Medium for multiple issues in the previous contest:\n- https://github.com/sherlock-audit/2022-11-sentiment-judging/issues/20\n- https://github.com/sherlock-audit/2022-11-sentiment-judging/issues/7\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-01-sentiment/blob/main/controller-52/src/rage/DNGMXVaultController.sol#L60-L73\n\nhttps://github.com/sherlock-audit/2023-01-sentiment/blob/main/controller-52/src/rage/DNGMXVaultController.sol#L75-L88\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWhen decoding the data from the call to Rage Trade, confirm that receiver == msg.sender. Here's an example with the deposit function:\n\n```diff\nfunction canDeposit(bytes calldata data)\n    internal\n    view\n    returns (bool, address[] memory, address[] memory)\n{\n    (address token, address receiver,) = abi.decode(\n        data, (address, address, uint256)\n    );\n+   if (receiver != msg.sender) return (true, vault, new address[](0));\n\n    address[] memory tokensOut = new address[](1);\n    tokensOut[0] = token;\n\n    return (true, vault, tokensOut);\n}\n```\n\n\n## Discussion\n\n**r0ohafza**\n\nAgree with the issue mentioned. Disagree with the fix provided since the receiver can be any other account and still lead to an accounting error, I think the recommended fix mentioned by @zobront  on issue #10 will resolve this as well.\n\n**bahurum**\n\nEscalate for 50 USDC.\nI believe that this issue is Low severity.\nI filed it as a low severity myself (https://github.com/sherlock-audit/2023-01-sentiment-judging/issues/26). See the 3rd point in the Vulnerability Detail section.\nThis issue will never lead to loss or lockup of funds. So by Sherlock judging criteria this is Low severity. \nOtherwise, please provide a scenario where this issue leads to a loss or lockup of funds.\nThe watson mentions some similiar issues previously judged as Medium. I didn't see those before or I would have escalated them as well for the same reason.\n\n**sherlock-admin**\n\n > Escalate for 50 USDC.\n> I believe that this issue is Low severity.\n> I filed it as a low severity myself (https://github.com/sherlock-audit/2023-01-sentiment-judging/issues/26). See the 3rd point in the Vulnerability Detail section.\n> This issue will never lead to loss or lockup of funds. So by Sherlock judging criteria this is Low severity. \n> Otherwise, please provide a scenario where this issue leads to a loss or lockup of funds.\n> The watson mentions some similiar issues previously judged as Medium. I didn't see those before or I would have escalated them as well for the same reason.\n\nYou've created a valid escalation for 50 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted\n\nWhile the above issue is not considered a low in this case, \nconsidering issue #26 as a valid medium based on further discussions in issue #10 \n\n\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> While the above issue is not considered a low in this case, \n> considering issue #26 as a valid medium based on further discussions in issue #10 \n> \n> \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/37",
  "Code": [
    {
      "filename": "controller-52/src/rage/DNGMXVaultController.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {IController} from \"../core/IController.sol\";\n\n/**\n    @title Rage Trade delta netural gmx vault controller\n*/\ncontract DNGMXVaultController is IController {\n\n    /* -------------------------------------------------------------------------- */\n    /*                             CONSTANT VARIABLES                             */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice depositToken(address,address,uint256)\n    bytes4 constant DEPOSIT = 0xfb0f97a8;\n\n    /// @notice redeemToken(address,address,uint256)\n    bytes4 constant REDEEM = 0x0d71bdc3;\n\n    /// @notice withdrawToken(address,address,uint256)\n    bytes4 constant WITHDRAW = 0x01e33667;\n\n    /// @notice rage trade delta netural jr vault\n    address[] public vault;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 CONSTRUCTOR                                */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @param _vault rage trade delta netural jr vault\n    */\n    constructor(address _vault) {\n        vault.push(_vault);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                              PUBLIC FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IController\n    function canCall(address, bool, bytes calldata data)\n        external\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        bytes4 sig = bytes4(data);\n\n        if (sig == DEPOSIT) return canDeposit(data[4:]);\n        if (sig == REDEEM || sig == WITHDRAW) return canWithdraw(data[4:]);\n\n        return (false, new address[](0), new address[](0));\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             INTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    function canDeposit(bytes calldata data)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        (address token,,) = abi.decode(\n            data, (address, address, uint256)\n        );\n\n        address[] memory tokensOut = new address[](1);\n        tokensOut[0] = token;\n\n        return (true, vault, tokensOut);\n    }\n\n    function canWithdraw(bytes calldata data)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        (address token,,) = abi.decode(\n            data, (address, address, uint256)\n        );\n\n        address[] memory tokensIn = new address[](1);\n        tokensIn[0] = token;\n\n        return (true, tokensIn, vault);\n    }\n}"
    },
    {
      "filename": "controller-52/src/rage/DNGMXVaultController.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {IController} from \"../core/IController.sol\";\n\n/**\n    @title Rage Trade delta netural gmx vault controller\n*/\ncontract DNGMXVaultController is IController {\n\n    /* -------------------------------------------------------------------------- */\n    /*                             CONSTANT VARIABLES                             */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice depositToken(address,address,uint256)\n    bytes4 constant DEPOSIT = 0xfb0f97a8;\n\n    /// @notice redeemToken(address,address,uint256)\n    bytes4 constant REDEEM = 0x0d71bdc3;\n\n    /// @notice withdrawToken(address,address,uint256)\n    bytes4 constant WITHDRAW = 0x01e33667;\n\n    /// @notice rage trade delta netural jr vault\n    address[] public vault;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 CONSTRUCTOR                                */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @param _vault rage trade delta netural jr vault\n    */\n    constructor(address _vault) {\n        vault.push(_vault);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                              PUBLIC FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IController\n    function canCall(address, bool, bytes calldata data)\n        external\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        bytes4 sig = bytes4(data);\n\n        if (sig == DEPOSIT) return canDeposit(data[4:]);\n        if (sig == REDEEM || sig == WITHDRAW) return canWithdraw(data[4:]);\n\n        return (false, new address[](0), new address[](0));\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             INTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    function canDeposit(bytes calldata data)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        (address token,,) = abi.decode(\n            data, (address, address, uint256)\n        );\n\n        address[] memory tokensOut = new address[](1);\n        tokensOut[0] = token;\n\n        return (true, vault, tokensOut);\n    }\n\n    function canWithdraw(bytes calldata data)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        (address token,,) = abi.decode(\n            data, (address, address, uint256)\n        );\n\n        address[] memory tokensIn = new address[](1);\n        tokensIn[0] = token;\n\n        return (true, tokensIn, vault);\n    }\n}"
    }
  ]
}