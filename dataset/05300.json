{
  "Title": "[M-01] A malicious lender can freeze borrower's ERC1155 tokens indefinitely because the guard can't differentiate between rented and non-rented ERC1155 tokens in the borrower's safe.",
  "Content": "\n### Pre-requisite knowledge & an overview of the features in question\n\n***\n\n1.  **Gnosis safe guards**: A gnosis guard is a contract that acts as a transaction guard which allows the owner of the safe to limit the contracts and functions that may be called by the multisig owners of the safe. ReNFT has created it's own gnosis guard contract, which is [Guard.sol](https://github.com/re-nft/smart-contracts/blob/main/src/policies/Guard.sol).\n\n    **Example utility**: When you ask reNFT to create a rental safe for you by calling [deployRentalSafe()](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L138) in [Factory.sol](https://github.com/re-nft/smart-contracts/blob/main/src/policies/Factory.sol), reNFT creates a rental safe for you and automatically installs it's own guard contract on it. Everytime you send a call from your gnosis safe, this call has to first pass through that guard. If you're for example, trying to move a NFT token you rented using `transferFrom()`, it'll prevent you from doing so. When it intercepts the transaction you're trying to send, it checks for a [list of function signatures](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L195) that can be malicious, for example it checks if you're trying to enable/disable a module it has not authorized. It checks if you're trying to change the guard contract address itself, It also checks if you're trying to transfer or approve a rented NFT or ERC1155 token using the most common functions like `approve()`, `safeTransferFrom()`, `transferFrom()`, `setApprovalForAll()`. This guard acts as the single and most important defense line against rented ERC721/1155 token theft.\n\n***\n\n### The Vulnerability & Exploitation Steps\n\n***\n\nThe vulnerability exists in the [Guard.sol](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol) contract, [L-242](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L242)\n\n        } else if (selector == e1155_safe_transfer_from_selector) {\n            // Load the token ID from calldata.\n            uint256 tokenId = uint256(\n                _loadValueFromCalldata(data, e1155_safe_transfer_from_token_id_offset)\n            );\n\n            // Check if the selector is allowed.\n            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n\nThe guard does not differentiate between ERC1155 tokens of address of same ID that are actively being rented and those that aren't rented. So for example, you had 2,000 \"GameToken\" ERC1155 tokens with an id of 5, that are not rented. And you rented 10 \"GameToken\" ERC1155 tokens of the same id \"5\", you will not be able to move or transfer the non-rented 2,000 \"GameToken\" ERC1155 tokens which you had prior to rented the other 10 tokens, until the 10 \"GameToken\" rental expires and gets stopped/finalized.\n\nThe problem is that a malicious lender can exploit this to freeze the borrower's pre-existing funds of the same kind indefinitely by preventing his rental (the rental in which the lender lended ERC1155 tokens to the borrower), from being stopped even if the expiry date of the rental has passed. He can do so by utilizing the fact that the `Reclaimer` contract utilizes `safeTransferFrom` to give the lender his tokens back after the rental gets stopped. The lender can then set up a `onERC1155Receive()` hook that reverts until he decides otherwise. This will prevent the rental from being stopped and therefore, it'll prevent the borrower from transferring his pre-rental tokens, making them indefinitely stuck.\n\n**Proof of concept**\n\n1.  The borrower, Jack, has 1,000 ERC1155 tokens of id 5 that are not rented.\n2.  Jack decides to lend 10 ERC1155 tokens of same id, 5, from Alice (malicious lender). Rental period will last 10 days.\n3.  Alice (malicious smart contract lender) sets a `onERC1155Receive()` hook which reverts if certain time has not passed\n4.  Whenever Jack tries to stop the rental after 10 days have passed by calling `stopRent()`, it will revert.\n5.  Jack will not be able to transfer his non-rented 1,000 ERC1155 tokens out of his rental safe until the malicious lender decides otherwise.\n\n***\n\n### Proof of concept code\n\n***\n\nTo run the PoC, you'll need to do the following:\n\n1.  You'll need to add the following two files to the test/ folder:\n    1.  `SetupExploit.sol` -> Sets up everything from seaport, gnosis, reNFT contracts\n    2.  `Exploit.sol` -> The actual exploit PoC which relies on `SetupExploit.sol` as a base.\n2.  You'll need to run this command\n    `forge test --match-contract Exploit --match-test test_ERC1155_Freeze_Exploit -vv`\n\n*Note: All of my 7 PoCs throughout my reports include the `SetupExploit.sol`. Please do not rely on the previous `SetupExploit.sol` file if you already had one from another PoC run in the tests/ folder. In some PoCs, there are slight modifications done in that file to properly set up the test infrastructure needed for the exploit*\n\n**The files:**\n\n<details>\n<summary><b>SetupExploit.sol</b></summary>\n<br>\n\n    // SPDX-License-Identifier: BUSL-1.1\n    pragma solidity ^0.8.20;\n\n    import {\n        ConsiderationItem,\n        OfferItem,\n        OrderParameters,\n        OrderComponents,\n        Order,\n        AdvancedOrder,\n        ItemType,\n        ItemType as SeaportItemType,\n        CriteriaResolver,\n        OrderType as SeaportOrderType,\n        Fulfillment,\n        FulfillmentComponent\n    } from \"@seaport-types/lib/ConsiderationStructs.sol\";\n    import {\n        AdvancedOrderLib,\n        ConsiderationItemLib,\n        FulfillmentComponentLib,\n        FulfillmentLib,\n        OfferItemLib,\n        OrderComponentsLib,\n        OrderLib,\n        OrderParametersLib,\n        SeaportArrays,\n        ZoneParametersLib\n    } from \"@seaport-sol/SeaportSol.sol\";\n\n    import {\n        OrderMetadata,\n        OrderType,\n        OrderFulfillment,\n        RentPayload,\n        RentalOrder,\n        Item,\n        SettleTo,\n        ItemType as RentalItemType\n    } from \"@src/libraries/RentalStructs.sol\";\n\n    import {ECDSA} from \"@openzeppelin-contracts/utils/cryptography/ECDSA.sol\";\n    import {OrderMetadata, OrderType, Hook} from \"@src/libraries/RentalStructs.sol\";\n    import {Vm} from \"@forge-std/Vm.sol\";\n    import {Test} from \"@forge-std/Test.sol\";\n    import {Assertions} from \"@test/utils/Assertions.sol\";\n    import {Constants} from \"@test/utils/Constants.sol\";\n    import {LibString} from \"@solady/utils/LibString.sol\";\n    import {SafeL2} from \"@safe-contracts/SafeL2.sol\";\n    import {Safe} from \"@safe-contracts/Safe.sol\";\n    // import {BaseExternal} from \"@test/fixtures/external/BaseExternal.sol\";\n    import {SafeProxyFactory} from \"@safe-contracts/proxies/SafeProxyFactory.sol\";\n    import {Create2Deployer} from \"@src/Create2Deployer.sol\";\n    import {Kernel, Actions} from \"@src/Kernel.sol\";\n    import {Storage} from \"@src/modules/Storage.sol\";\n    import {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\";\n    import {Create} from \"@src/policies/Create.sol\";\n    import {Stop} from \"@src/policies/Stop.sol\";\n    import {Factory} from \"@src/policies/Factory.sol\";\n    import {Admin} from \"@src/policies/Admin.sol\";\n    import {Guard} from \"@src/policies/Guard.sol\";\n    import {toRole} from \"@src/libraries/KernelUtils.sol\";\n    import {Proxy} from \"@src/proxy/Proxy.sol\";\n    import {Events} from \"@src/libraries/Events.sol\";\n    import {HandlerContext} from \"@safe-contracts/handler/HandlerContext.sol\";\n    import {CompatibilityFallbackHandler} from \"@safe-contracts/handler/CompatibilityFallbackHandler.sol\";\n    import {Ownable} from \"@openzeppelin-contracts/access/Ownable.sol\";\n    import {ERC1155} from '@openzeppelin-contracts/token/ERC1155/ERC1155.sol';\n    import {ISignatureValidator} from \"@safe-contracts/interfaces/ISignatureValidator.sol\";\n\n    import {ProtocolAccount} from \"@test/utils/Types.sol\";\n    import {MockERC20} from \"@test/mocks/tokens/standard/MockERC20.sol\";\n    import {MockERC721} from \"@test/mocks/tokens/standard/MockERC721.sol\";\n    import {MockERC1155} from \"@test/mocks/tokens/standard/MockERC1155.sol\";\n    import {SafeUtils} from \"@test/utils/GnosisSafeUtils.sol\";\n    import {Enum} from \"@safe-contracts/common/Enum.sol\";\n    import {ISafe} from \"@src/interfaces/ISafe.sol\";\n\n    import {Seaport} from \"@seaport-core/Seaport.sol\";\n    import {ConduitController} from \"@seaport-core/conduit/ConduitController.sol\";\n    import {ConduitControllerInterface} from \"@seaport-types/interfaces/ConduitControllerInterface.sol\";\n    import {ConduitInterface} from \"@seaport-types/interfaces/ConduitInterface.sol\";\n\n    import \"@forge-std/console.sol\";\n\n\n\n    // Deploys all Seaport protocol contracts\n    contract External_Seaport is Test {\n        // seaport protocol contracts\n        Seaport public seaport;\n        ConduitController public conduitController;\n        ConduitInterface public conduit;\n\n        // conduit owner and key\n        Vm.Wallet public conduitOwner;\n        bytes32 public conduitKey;\n\n        function setUp() public virtual {\n            // generate conduit owner wallet\n            conduitOwner = vm.createWallet(\"conduitOwner\");\n\n            // deploy conduit controller\n            conduitController = new ConduitController();\n\n            // deploy seaport\n            seaport = new Seaport(address(conduitController));\n\n            // create a conduit key (first 20 bytes must be conduit creator)\n            conduitKey = bytes32(uint256(uint160(conduitOwner.addr))) << 96;\n\n            // create a new conduit\n            vm.prank(conduitOwner.addr);\n            address conduitAddress = conduitController.createConduit(\n                conduitKey,\n                conduitOwner.addr\n            );\n\n            // set the conduit address\n            conduit = ConduitInterface(conduitAddress);\n\n            // open a channel for seaport on the conduit\n            vm.prank(conduitOwner.addr);\n            conduitController.updateChannel(address(conduit), address(seaport), true);\n\n            // label the contracts\n            vm.label(address(seaport), \"Seaport\");\n            vm.label(address(conduitController), \"ConduitController\");\n            vm.label(address(conduit), \"Conduit\");\n        }\n    }\n\n    // Deploys the Create2Deployer contract\n    contract External_Create2Deployer is Test {\n        Create2Deployer public create2Deployer;\n\n        function setUp() public virtual {\n            // Deploy the create2 deployer contract\n            create2Deployer = new Create2Deployer();\n\n            // label the contract\n            vm.label(address(create2Deployer), \"Create2Deployer\");\n        }\n    }\n\n    // Deploys all Gnosis Safe protocol contracts\n    contract External_Safe is Test {\n        SafeL2 public safeSingleton;\n        SafeProxyFactory public safeProxyFactory;\n\n        CompatibilityFallbackHandler public fallbackHandler;\n\n        function setUp() public virtual {\n            // Deploy safe singleton contract\n            safeSingleton = new SafeL2();\n\n            // Deploy safe proxy factory\n            safeProxyFactory = new SafeProxyFactory();\n\n            // Deploy the compatibility token handler\n            fallbackHandler = new CompatibilityFallbackHandler();\n\n            // Label the contracts\n            vm.label(address(safeSingleton), \"SafeSingleton\");\n            vm.label(address(safeProxyFactory), \"SafeProxyFactory\");\n            vm.label(address(fallbackHandler), \"TokenCallbackHandler\");\n        }\n    }\n\n    contract BaseExternal is External_Create2Deployer, External_Seaport, External_Safe {\n        // This is an explicit entrypoint for all external contracts that the V3 protocol depends on.\n        //\n        // It contains logic for:\n        // - setup of the Create2Deployer contract\n        // - setup of all Seaport protocol contracts\n        // - setup of all Gnosis Safe protocol contracts\n        //\n        // The inheritance chain is as follows:\n        // External_Create2Deployer + External_Seaport + External_Safe\n        // --> BaseExternal\n\n        function setUp()\n            public\n            virtual\n            override(External_Create2Deployer, External_Seaport, External_Safe)\n        {\n            // set up dependencies\n            External_Create2Deployer.setUp();\n            External_Seaport.setUp();\n            External_Safe.setUp();\n        }\n    }\n\n    // Deploys all V3 protocol contracts\n    contract Protocol is BaseExternal {\n        // Kernel\n        Kernel public kernel;\n\n        // Modules\n        Storage public STORE;\n        PaymentEscrow public ESCRW;\n\n        // Module implementation addresses\n        Storage public storageImplementation;\n        PaymentEscrow public paymentEscrowImplementation;\n\n        // Policies\n        Create public create;\n        Stop public stop;\n        Factory public factory;\n        Admin public admin;\n        Guard public guard;\n\n        // Protocol accounts\n        Vm.Wallet public rentalSigner;\n        Vm.Wallet public deployer;\n\n        // protocol constants\n        bytes12 public protocolVersion;\n        bytes32 public salt;\n\n        function _deployKernel() internal {\n            // abi encode the kernel bytecode and constructor arguments\n            bytes memory kernelInitCode = abi.encodePacked(\n                type(Kernel).creationCode,\n                abi.encode(deployer.addr, deployer.addr)\n            );\n\n            // Deploy kernel contract\n            vm.prank(deployer.addr);\n            kernel = Kernel(create2Deployer.deploy(salt, kernelInitCode));\n\n            // label the contract\n            vm.label(address(kernel), \"kernel\");\n        }\n\n        function _deployStorageModule() internal {\n            // abi encode the storage bytecode and constructor arguments\n            // for the implementation contract\n            bytes memory storageImplementationInitCode = abi.encodePacked(\n                type(Storage).creationCode,\n                abi.encode(address(0))\n            );\n\n            // Deploy storage implementation contract\n            vm.prank(deployer.addr);\n            storageImplementation = Storage(\n                create2Deployer.deploy(salt, storageImplementationInitCode)\n            );\n\n            // abi encode the storage bytecode and initialization arguments\n            // for the proxy contract\n            bytes memory storageProxyInitCode = abi.encodePacked(\n                type(Proxy).creationCode,\n                abi.encode(\n                    address(storageImplementation),\n                    abi.encodeWithSelector(\n                        Storage.MODULE_PROXY_INSTANTIATION.selector,\n                        address(kernel)\n                    )\n                )\n            );\n\n            // Deploy storage proxy contract\n            vm.prank(deployer.addr);\n            STORE = Storage(create2Deployer.deploy(salt, storageProxyInitCode));\n\n            // label the contracts\n            vm.label(address(STORE), \"STORE\");\n            vm.label(address(storageImplementation), \"STORE_IMPLEMENTATION\");\n        }\n\n        function _deployPaymentEscrowModule() internal {\n            // abi encode the payment escrow bytecode and constructor arguments\n            // for the implementation contract\n            bytes memory paymentEscrowImplementationInitCode = abi.encodePacked(\n                type(PaymentEscrow).creationCode,\n                abi.encode(address(0))\n            );\n\n            // Deploy payment escrow implementation contract\n            vm.prank(deployer.addr);\n            paymentEscrowImplementation = PaymentEscrow(\n                create2Deployer.deploy(salt, paymentEscrowImplementationInitCode)\n            );\n\n            // abi encode the payment escrow bytecode and initialization arguments\n            // for the proxy contract\n            bytes memory paymentEscrowProxyInitCode = abi.encodePacked(\n                type(Proxy).creationCode,\n                abi.encode(\n                    address(paymentEscrowImplementation),\n                    abi.encodeWithSelector(\n                        PaymentEscrow.MODULE_PROXY_INSTANTIATION.selector,\n                        address(kernel)\n                    )\n                )\n            );\n\n            // Deploy payment escrow contract\n            vm.prank(deployer.addr);\n            ESCRW = PaymentEscrow(create2Deployer.deploy(salt, paymentEscrowProxyInitCode));\n\n            // label the contracts\n            vm.label(address(ESCRW), \"ESCRW\");\n            vm.label(address(paymentEscrowImplementation), \"ESCRW_IMPLEMENTATION\");\n        }\n\n        function _deployCreatePolicy() internal {\n            // abi encode the create policy bytecode and constructor arguments\n            bytes memory createInitCode = abi.encodePacked(\n                type(Create).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy create rental policy contract\n            vm.prank(deployer.addr);\n            create = Create(create2Deployer.deploy(salt, createInitCode));\n\n            // label the contract\n            vm.label(address(create), \"CreatePolicy\");\n        }\n\n        function _deployStopPolicy() internal {\n            // abi encode the stop policy bytecode and constructor arguments\n            bytes memory stopInitCode = abi.encodePacked(\n                type(Stop).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy stop rental policy contract\n            vm.prank(deployer.addr);\n            stop = Stop(create2Deployer.deploy(salt, stopInitCode));\n\n            // label the contract\n            vm.label(address(stop), \"StopPolicy\");\n        }\n\n        function _deployAdminPolicy() internal {\n            // abi encode the admin policy bytecode and constructor arguments\n            bytes memory adminInitCode = abi.encodePacked(\n                type(Admin).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy admin policy contract\n            vm.prank(deployer.addr);\n            admin = Admin(create2Deployer.deploy(salt, adminInitCode));\n\n            // label the contract\n            vm.label(address(admin), \"AdminPolicy\");\n        }\n\n        function _deployGuardPolicy() internal {\n            // abi encode the guard policy bytecode and constructor arguments\n            bytes memory guardInitCode = abi.encodePacked(\n                type(Guard).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy guard policy contract\n            vm.prank(deployer.addr);\n            guard = Guard(create2Deployer.deploy(salt, guardInitCode));\n\n            // label the contract\n            vm.label(address(guard), \"GuardPolicy\");\n        }\n\n        function _deployFactoryPolicy() internal {\n            // abi encode the factory policy bytecode and constructor arguments\n            bytes memory factoryInitCode = abi.encodePacked(\n                type(Factory).creationCode,\n                abi.encode(\n                    address(kernel),\n                    address(stop),\n                    address(guard),\n                    address(fallbackHandler),\n                    address(safeProxyFactory),\n                    address(safeSingleton)\n                )\n            );\n\n            // Deploy factory policy contract\n            vm.prank(deployer.addr);\n            factory = Factory(create2Deployer.deploy(salt, factoryInitCode));\n\n            // label the contract\n            vm.label(address(factory), \"FactoryPolicy\");\n        }\n\n        function _setupKernel() internal {\n            // Start impersonating the deployer\n            vm.startPrank(deployer.addr);\n\n            // Install modules\n            kernel.executeAction(Actions.InstallModule, address(STORE));\n            kernel.executeAction(Actions.InstallModule, address(ESCRW));\n\n            // Approve policies\n            kernel.executeAction(Actions.ActivatePolicy, address(create));\n            kernel.executeAction(Actions.ActivatePolicy, address(stop));\n            kernel.executeAction(Actions.ActivatePolicy, address(factory));\n            kernel.executeAction(Actions.ActivatePolicy, address(guard));\n            kernel.executeAction(Actions.ActivatePolicy, address(admin));\n\n            // Grant `seaport` role to seaport protocol\n            kernel.grantRole(toRole(\"SEAPORT\"), address(seaport));\n\n            // Grant `signer` role to the protocol signer to sign off on create payloads\n            kernel.grantRole(toRole(\"CREATE_SIGNER\"), rentalSigner.addr);\n\n            // Grant 'admin_admin` role to the address which can conduct admin operations on the protocol\n            kernel.grantRole(toRole(\"ADMIN_ADMIN\"), deployer.addr);\n\n            // Grant 'guard_admin` role to the address which can toggle hooks\n            kernel.grantRole(toRole(\"GUARD_ADMIN\"), deployer.addr);\n\n            // Grant `stop_admin` role to the address which can skim funds from the payment escrow\n            kernel.grantRole(toRole(\"STOP_ADMIN\"), deployer.addr);\n\n            // Stop impersonating the deployer\n            vm.stopPrank();\n        }\n\n        function setUp() public virtual override {\n            // setup dependencies\n            super.setUp();\n\n            // create the rental signer address and private key\n            rentalSigner = vm.createWallet(\"rentalSigner\");\n\n            // create the deployer address and private key\n            deployer = vm.createWallet(\"deployer\");\n\n            // contract salts (using 0x000000000000000000000100 to represent a version 1.0.0 of each contract)\n            protocolVersion = 0x000000000000000000000100;\n            salt = create2Deployer.generateSaltWithSender(deployer.addr, protocolVersion);\n\n            // deploy kernel\n            _deployKernel();\n\n            // Deploy payment escrow\n            _deployPaymentEscrowModule();\n\n            // Deploy rental storage\n            _deployStorageModule();\n\n            // deploy create policy\n            _deployCreatePolicy();\n\n            // deploy stop policy\n            _deployStopPolicy();\n\n            // deploy admin policy\n            _deployAdminPolicy();\n\n            // Deploy guard policy\n            _deployGuardPolicy();\n\n            // deploy rental factory\n            _deployFactoryPolicy();\n\n            // intialize the kernel\n            _setupKernel();\n        }\n    }\n\n\n    // Creates test accounts to interact with the V3 protocol\n    // Borrowed from test/fixtures/protocol/AccountCreator\n    contract AccountCreator is Protocol {\n        // Protocol accounts for testing\n        ProtocolAccount public alice;\n        ProtocolAccount public bob;\n        ProtocolAccount public carol;\n        ProtocolAccount public dan;\n        ProtocolAccount public eve;\n        ProtocolAccount public attacker;\n        MaliciousLender maliciousLenderContract;\n\n        // Mock tokens for testing\n        MockERC20[] public erc20s;\n        MockERC721[] public erc721s;\n        MockERC1155[] public erc1155s;\n\n        function setUp() public virtual override {\n            super.setUp();\n\n            // deploy 3 erc20 tokens, 3 erc721 tokens, and 3 erc1155 tokens\n            _deployTokens(3);\n\n            // instantiate all wallets and deploy rental safes for each\n            alice = _fundWalletAndDeployRentalSafe(\"alice\");\n            bob = _fundWalletAndDeployRentalSafe(\"bob\");\n            carol = _fundWalletAndDeployRentalSafe(\"carol\");\n            dan = _fundWalletAndDeployRentalSafe(\"dan\");\n            eve = _fundWalletAndDeployRentalSafe(\"eve\");\n            attacker = _fundWalletAndDeployRentalSafe(\"attacker\");\n\n            vm.prank(attacker.addr);\n            maliciousLenderContract = new MaliciousLender(); // attacker.addr will be the owner of this contract\n\n\n        }\n\n        function _deployTokens(uint256 numTokens) internal {\n            for (uint256 i; i < numTokens; i++) {\n                _deployErc20Token();\n                _deployErc721Token();\n                _deployErc1155Token();\n            }\n        }\n\n        function _deployErc20Token() internal returns (uint256 i) {\n            // save the token's index\n            i = erc20s.length;\n\n            // deploy the mock token\n            MockERC20 token = new MockERC20();\n\n            // push the token to the array of mocks\n            erc20s.push(token);\n\n            // set the token label with the index\n            vm.label(address(token), string.concat(\"MERC20_\", LibString.toString(i)));\n        }\n\n        function _deployErc721Token() internal returns (uint256 i) {\n            // save the token's index\n            i = erc721s.length;\n\n            // deploy the mock token\n            MockERC721 token = new MockERC721();\n\n            // push the token to the array of mocks\n            erc721s.push(token);\n\n            // set the token label with the index\n            vm.label(address(token), string.concat(\"MERC721_\", LibString.toString(i)));\n        }\n\n        function _deployErc1155Token() internal returns (uint256 i) {\n            // save the token's index\n            i = erc1155s.length;\n\n            // deploy the mock token\n            MockERC1155 token = new MockERC1155();\n\n            // push the token to the array of mocks\n            erc1155s.push(token);\n\n            // set the token label with the index\n            vm.label(address(token), string.concat(\"MERC1155_\", LibString.toString(i)));\n        }\n\n        function _deployRentalSafe(\n            address owner,\n            string memory name\n        ) internal returns (address safe) {\n            // Deploy a 1/1 rental safe\n            address[] memory owners = new address[](1);\n            owners[0] = owner;\n            safe = factory.deployRentalSafe(owners, 1);\n\n        }\n\n        function _fundWalletAndDeployRentalSafe(\n            string memory name\n        ) internal returns (ProtocolAccount memory account) {\n            // create a wallet with a address, public key, and private key\n            Vm.Wallet memory wallet = vm.createWallet(name);\n\n            // deploy a rental safe for the address\n            address rentalSafe = _deployRentalSafe(wallet.addr, name);\n\n            // fund the wallet with ether, all erc20s, and approve the conduit for erc20s, erc721s, erc1155s\n            _allocateTokensAndApprovals(wallet.addr, 10000);\n\n            // create an account\n            account = ProtocolAccount({\n                addr: wallet.addr,\n                safe: SafeL2(payable(rentalSafe)),\n                publicKeyX: wallet.publicKeyX,\n                publicKeyY: wallet.publicKeyY,\n                privateKey: wallet.privateKey\n            });\n\n        }\n\n\n\n        function _allocateTokensAndApprovals(address to, uint128 amount) internal {\n            // deal ether to the recipient\n            vm.deal(to, amount);\n\n            // mint all erc20 tokens to the recipient\n            for (uint256 i = 0; i < erc20s.length; ++i) {\n                erc20s[i].mint(to, amount);\n            }\n\n            // set token approvals\n            _setApprovals(to);\n        }\n\n        function _setApprovals(address owner) internal {\n            // impersonate the owner address\n            vm.startPrank(owner);\n\n            // set all approvals for erc20 tokens\n            for (uint256 i = 0; i < erc20s.length; ++i) {\n                erc20s[i].approve(address(conduit), type(uint256).max);\n            }\n\n            // set all approvals for erc721 tokens\n            for (uint256 i = 0; i < erc721s.length; ++i) {\n                erc721s[i].setApprovalForAll(address(conduit), true);\n            }\n\n            // set all approvals for erc1155 tokens\n            for (uint256 i = 0; i < erc1155s.length; ++i) {\n                erc1155s[i].setApprovalForAll(address(conduit), true);\n            }\n\n            // stop impersonating\n            vm.stopPrank();\n        }\n    }\n\n\n    // Sets up logic in the test engine related to order creation\n    // Borrowed from test/fixtures/engine/OrderCreator\n    contract OrderCreator is AccountCreator {\n        using OfferItemLib for OfferItem;\n        using ConsiderationItemLib for ConsiderationItem;\n        using OrderComponentsLib for OrderComponents;\n        using OrderLib for Order;\n        using ECDSA for bytes32;\n\n        // defines a config for a standard order component\n        string constant STANDARD_ORDER_COMPONENTS = \"standard_order_components\";\n\n        struct OrderToCreate {\n            ProtocolAccount offerer;\n            OfferItem[] offerItems;\n            ConsiderationItem[] considerationItems;\n            OrderMetadata metadata;\n        }\n\n        // keeps track of tokens used during a test\n        uint256[] usedOfferERC721s;\n        uint256[] usedOfferERC1155s;\n\n        uint256[] usedConsiderationERC721s;\n        uint256[] usedConsiderationERC1155s;\n\n        // components of an order\n        OrderToCreate orderToCreate;\n\n        function setUp() public virtual override {\n            super.setUp();\n\n            // Define a standard OrderComponents struct which is ready for\n            // use with the Create Policy and the protocol conduit contract\n            OrderComponentsLib\n                .empty()\n                .withOrderType(SeaportOrderType.FULL_RESTRICTED)\n                .withZone(address(create))\n                .withStartTime(block.timestamp)\n                .withEndTime(block.timestamp + 100)\n                .withSalt(123456789)\n                .withConduitKey(conduitKey)\n                .saveDefault(STANDARD_ORDER_COMPONENTS);\n\n            // for each test token, create a storage slot\n            for (uint256 i = 0; i < erc721s.length; i++) {\n                usedOfferERC721s.push();\n                usedConsiderationERC721s.push();\n\n                usedOfferERC1155s.push();\n                usedConsiderationERC1155s.push();\n            }\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                                Order Creation                               //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        // creates an order based on the provided context. The defaults on this order\n        // are good for most test cases.\n        function createOrder(\n            ProtocolAccount memory offerer,\n            OrderType orderType,\n            uint256 erc721Offers,\n            uint256 erc1155Offers,\n            uint256 erc20Offers,\n            uint256 erc721Considerations,\n            uint256 erc1155Considerations,\n            uint256 erc20Considerations\n        ) internal {\n            // require that the number of offer items or consideration items\n            // dont exceed the number of test tokens\n            require(\n                erc721Offers <= erc721s.length &&\n                    erc721Offers <= erc1155s.length &&\n                    erc20Offers <= erc20s.length,\n                \"TEST: too many offer items defined\"\n            );\n            require(\n                erc721Considerations <= erc721s.length &&\n                    erc1155Considerations <= erc1155s.length &&\n                    erc20Considerations <= erc20s.length,\n                \"TEST: too many consideration items defined\"\n            );\n\n            // create the offerer\n            _createOfferer(offerer);\n\n            // add the offer items\n            _createOfferItems(erc721Offers, erc1155Offers, erc20Offers);\n\n            // create the consideration items\n            _createConsiderationItems(\n                erc721Considerations,\n                erc1155Considerations,\n                erc20Considerations\n            );\n\n            // Create order metadata\n            _createOrderMetadata(orderType);\n        }\n\n        // Creates an offerer on the order to create\n        function _createOfferer(ProtocolAccount memory offerer) private {\n            orderToCreate.offerer = offerer;\n        }\n\n        // Creates offer items which are good for most tests\n        function _createOfferItems(\n            uint256 erc721Offers,\n            uint256 erc1155Offers,\n            uint256 erc20Offers\n        ) private {\n            // generate the ERC721 offer items\n            for (uint256 i = 0; i < erc721Offers; ++i) {\n                // create the offer item\n                orderToCreate.offerItems.push(\n                    OfferItemLib\n                        .empty()\n                        .withItemType(ItemType.ERC721)\n                        .withToken(address(erc721s[i]))\n                        .withIdentifierOrCriteria(usedOfferERC721s[i])\n                   ",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-01-renft",
  "Code": [
    {
      "filename": "src/policies/Factory.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {SafeL2} from \"@safe-contracts/SafeL2.sol\";\nimport {SafeProxyFactory} from \"@safe-contracts/proxies/SafeProxyFactory.sol\";\nimport {TokenCallbackHandler} from \"@safe-contracts/handler/TokenCallbackHandler.sol\";\n\nimport {ISafe} from \"@src/interfaces/ISafe.sol\";\n\nimport {Kernel, Policy, Permissions, Keycode} from \"@src/Kernel.sol\";\nimport {toKeycode} from \"@src/libraries/KernelUtils.sol\";\nimport {Errors} from \"@src/libraries/Errors.sol\";\nimport {Events} from \"@src/libraries/Events.sol\";\nimport {Storage} from \"@src/modules/Storage.sol\";\nimport {Stop} from \"@src/policies/Stop.sol\";\nimport {Guard} from \"@src/policies/Guard.sol\";\n\n/**\n * @title Factory\n * @notice Acts as an interface for all behavior related to deploying rental safes.\n */\ncontract Factory is Policy {\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Policy Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    // Modules that the policy depends on.\n    Storage public STORE;\n\n    // policies.\n    Stop public immutable stopPolicy;\n    Guard public immutable guardPolicy;\n\n    // External contracts.\n    TokenCallbackHandler public immutable fallbackHandler;\n    SafeProxyFactory public immutable safeProxyFactory;\n    SafeL2 public immutable safeSingleton;\n\n    /**\n     * @dev Instantiate this contract as a policy.\n     *\n     * @param kernel_           Address of the kernel contract.\n     * @param stopPolicy_       Address of the stop policy.\n     * @param guardPolicy_      Address of the guard policy.\n     * @param fallbackHandler_  Gnosis safe fallback handler address.\n     * @param safeProxyFactory_ Gnosis safe proxy factory address.\n     * @param safeSingleton_    Gnosis safe logic contract address.\n     */\n    constructor(\n        Kernel kernel_,\n        Stop stopPolicy_,\n        Guard guardPolicy_,\n        TokenCallbackHandler fallbackHandler_,\n        SafeProxyFactory safeProxyFactory_,\n        SafeL2 safeSingleton_\n    ) Policy(kernel_) {\n        stopPolicy = stopPolicy_;\n        guardPolicy = guardPolicy_;\n        fallbackHandler = fallbackHandler_;\n        safeProxyFactory = safeProxyFactory_;\n        safeSingleton = safeSingleton_;\n    }\n\n    /**\n     * @notice Upon policy activation, configures the modules that the policy depends on.\n     *         If a module is ever upgraded that this policy depends on, the kernel will\n     *         call this function again to ensure this policy has the current address\n     *         of the module.\n     *\n     * @return dependencies Array of keycodes which represent modules that\n     *                      this policy depends on.\n     */\n    function configureDependencies()\n        external\n        override\n        onlyKernel\n        returns (Keycode[] memory dependencies)\n    {\n        dependencies = new Keycode[](1);\n\n        dependencies[0] = toKeycode(\"STORE\");\n        STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n    }\n\n    /**\n     * @notice Upon policy activation, permissions are requested from the kernel to access\n     *         particular keycode <> function selector pairs. Once these permissions are\n     *         granted, they do not change and can only be revoked when the policy is\n     *         deactivated by the kernel.\n     *\n     * @return requests Array of keycode <> function selector pairs which represent\n     *                  permissions for the policy.\n     */\n    function requestPermissions()\n        external\n        view\n        override\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {\n        requests = new Permissions[](1);\n        requests[0] = Permissions(toKeycode(\"STORE\"), STORE.addRentalSafe.selector);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            External Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Initializes a rental safe by setting it up with the stop policy and\n     *         rental guard during deployment.\n     *\n     *          Warning: This function assumes the invariant that delegate call will be\n     *          disabled or restricted by the guard policy. If delegate call were to be\n     *          freely allowed, then a safe could call this function after deployment\n     *          and change the module/guard contacts which would allow transferring\n     *          of rented assets out of the safe.\n     *\n     * @param _stopPolicy  Address of the stop policy to add as a module to the safe.\n     * @param _guardPolicy Address of the guard policy to add as a guard on the safe.\n     */\n    function initializeRentalSafe(address _stopPolicy, address _guardPolicy) external {\n        // Enable the module.\n        ISafe(address(this)).enableModule(_stopPolicy);\n\n        // Set the guard.\n        ISafe(address(this)).setGuard(_guardPolicy);\n    }\n\n    /**\n     * @notice Deploys and initializes a rental safe.\n     *\n     * @param owners    Array of owner addresses which will have the ability to sign\n     *                  transactions for the safe.\n     * @param threshold Number of signatures required to executed a transaction\n     *                  on the safe.\n     */\n    function deployRentalSafe(\n        address[] calldata owners,\n        uint256 threshold\n    ) external returns (address safe) {\n        // Require that the threshold is valid.\n        if (threshold == 0 || threshold > owners.length) {\n            revert Errors.FactoryPolicy_InvalidSafeThreshold(threshold, owners.length);\n        }\n\n        // Delegate call from the safe so that the rental manager module can be enabled\n        // right after the safe is deployed.\n        bytes memory data = abi.encodeCall(\n            Factory.initializeRentalSafe,\n            (address(stopPolicy), address(guardPolicy))\n        );\n\n        // Create gnosis initializer payload.\n        bytes memory initializerPayload = abi.encodeCall(\n            ISafe.setup,\n            (\n                // owners array.\n                owners,\n                // number of signatures needed to execute transactions.\n                threshold,\n                // Address to direct the payload to.\n                address(this),\n                // Encoded call to execute.\n                data,\n                // Fallback manager address.\n                address(fallbackHandler),\n                // Payment token.\n                address(0),\n                // Payment amount.\n                0,\n                // Payment receiver\n                payable(address(0))\n            )\n        );\n\n        // Deploy a safe proxy using initializer values for the Safe.setup() call\n        // with a salt nonce that is unique to each chain to guarantee cross-chain\n        // unique safe addresses.\n        safe = address(\n            safeProxyFactory.createProxyWithNonce(\n                address(safeSingleton),\n                initializerPayload,\n                uint256(keccak256(abi.encode(STORE.totalSafes() + 1, block.chainid)))\n            )\n        );\n\n        // Store the deployed safe.\n        STORE.addRentalSafe(safe);\n\n        // Emit the event.\n        emit Events.RentalSafeDeployment(safe, owners, threshold);\n    }\n}"
    }
  ]
}