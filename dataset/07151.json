{
  "Title": "[H-02] TimeswapV2LiquidityToken should not use `totalSupply()+1` as tokenId",
  "Content": "\n<https://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-token/src/TimeswapV2LiquidityToken.sol#L114> \n\n<https://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-token/src/TimeswapV2Token.sol#L103>\n\n### Impact\n\nAssuming ERC1155Enumerable is acting normally, there is an **Accounting Issue** about TimeswapV2LiquidityToken and TimeswapV2Token's tokenId.\n\nDifferent liquidities can have the same `tokenId`, leading to serious balance manipulation.\n\nI'm submitting this issue as medium because current implementation ERC1155Enumerable is wrong, which exactly mitigates this issue making it not exploitable. But this issue will become dangerous once we fixed ERC1155Enumerable.\n\n### Proof of Concept\n\nIn this PoC, the attacker will do these steps:\n\n1.  Add liquidity of token0 and token1, thus receiving TimeswapV2LiquidityToken tokenId 1.\n2.  Add liquidity of token2 and token3, thus receiving TimeswapV2LiquidityToken tokenId 2.\n3.  Burn his liquidity from step1, which will make totalSupply decrease (if ERC1155Enumerable has been patched).\n4.  Add liquidity of token4 and token5, and receive TimeswapV2LiquidityToken tokenId 2. This is wrong tokenId, which should be 3.\n\nExplanation:\n\n<https://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-token/src/TimeswapV2LiquidityToken.sol#L112>\n\nAs the comment said, `if the position does not exist, create it`, but the new tokenId is set as `totalSupply() + 1`.\n\nFunction totalSupply is defined in `packages/v2-token/src/base/ERC1155Enumerable.sol`, which is simply `\\_allTokens.length`: <https://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-token/src/base/ERC1155Enumerable.sol#L37-L38>\n\n`\\_allTokens.length` can be decreased in `_removeTokenFromAllTokensEnumeration` function, which is called by `_removeTokenEnumeration`, and by `_afterTokenTransfer`. In simple words, when all token amounts for a specific tokenId are burned (`_idTotalSupply[id] == 0`), totalSupply should be decreased.\n\nCurrent implementation of ERC1155Enumerable has a bug, which will never trigger `_removeTokenFromAllTokensEnumeration`: Calling `\\_removeTokenEnumeration needs amount>0`, but only `_idTotalSupply[id] == 0` can trigger `\\_removeTokenFromAllTokensEnumeration`.\n\n        function _removeTokenEnumeration(address from, address to, uint256 id, uint256 amount) internal {\n            if (to == address(0)) {\n                if (_idTotalSupply[id] == 0 && _additionalConditionRemoveTokenFromAllTokensEnumeration(id)) _removeTokenFromAllTokensEnumeration(id);\n                _idTotalSupply[id] -= amount;\n            }\n\nOnce the above code gets fixed (swapping the if line and `_idTotalSupply[id] -= amount;` line, patch given below), this issue becomes exploitable, making the accounting of LP wrong.\n\n***\n\nProof of Concept steps:\n\nFirst, we need to patch two contracts:\n\n*   making TimeswapV2LiquidityToken's `\\_timeswapV2LiquidityTokenPositionIds` as public for testing, this can be removed when depolying\n*   ERC1155Enumerable's `\\_removeTokenEnumeration` has been patched to behave correctly, which will decrease `totalSupply` when all token amount of a specific tokenId has been burned.\n\n<!---->\n\n    diff --git a/packages/v2-token/src/TimeswapV2LiquidityToken.sol b/packages/v2-token/src/TimeswapV2LiquidityToken.sol\n    index 2f71a25..f3910d9 100644\n    --- a/packages/v2-token/src/TimeswapV2LiquidityToken.sol\n    +++ b/packages/v2-token/src/TimeswapV2LiquidityToken.sol\n    @@ -42,7 +42,7 @@ contract TimeswapV2LiquidityToken is ITimeswapV2LiquidityToken, ERC1155Enumerabl\n     \n         mapping(uint256 => TimeswapV2LiquidityTokenPosition) private _timeswapV2LiquidityTokenPositions;\n     \n    -    mapping(bytes32 => uint256) private _timeswapV2LiquidityTokenPositionIds;\n    +    mapping(bytes32 => uint256) public _timeswapV2LiquidityTokenPositionIds;\n     \n         mapping(uint256 => mapping(address => FeesPosition)) private _feesPositions;\n     \n    diff --git a/packages/v2-token/src/base/ERC1155Enumerable.sol b/packages/v2-token/src/base/ERC1155Enumerable.sol\n    index 4ec23ff..4f51fb4 100644\n    --- a/packages/v2-token/src/base/ERC1155Enumerable.sol\n    +++ b/packages/v2-token/src/base/ERC1155Enumerable.sol\n    @@ -91,8 +91,8 @@ abstract contract ERC1155Enumerable is IERC1155Enumerable, ERC1155 {\n         /// @dev Remove token enumeration list if necessary.\n         function _removeTokenEnumeration(address from, address to, uint256 id, uint256 amount) internal {\n             if (to == address(0)) {\n    -            if (_idTotalSupply[id] == 0 && _additionalConditionRemoveTokenFromAllTokensEnumeration(id)) _removeTokenFromAllTokensEnumeration(id);\n                 _idTotalSupply[id] -= amount;\n    +            if (_idTotalSupply[id] == 0 && _additionalConditionRemoveTokenFromAllTokensEnumeration(id)) _removeTokenFromAllTokensEnumeration(id);\n             }\n     \n             if (from != address(0) && from != to) {\n\nAdd a new test file in `2023-01-timeswap/packages/v2-token/test/TimeswapV2LiquidityToken_MultiMint.t.sol`:\n\n```\n// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.8;\n\nimport \"forge-std/Test.sol\";\n\nimport \"forge-std/console.sol\";\n\nimport \"../src/TimeswapV2LiquidityToken.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@timeswap-labs/v2-option/src/TimeswapV2OptionFactory.sol\";\nimport \"@timeswap-labs/v2-option/src/interfaces/ITimeswapV2Option.sol\";\nimport {TimeswapV2LiquidityTokenCollectParam} from \"../src/structs/Param.sol\";\nimport \"@timeswap-labs/v2-pool/src/TimeswapV2PoolFactory.sol\";\nimport \"@timeswap-labs/v2-pool/src/interfaces/ITimeswapV2Pool.sol\";\nimport {TimeswapV2PoolMintParam} from \"@timeswap-labs/v2-pool/src/structs/Param.sol\";\nimport {TimeswapV2PoolMintChoiceCallbackParam, TimeswapV2PoolMintCallbackParam} from \"@timeswap-labs/v2-pool/src/structs/CallbackParam.sol\";\n\nimport {TimeswapV2OptionMintCallbackParam, TimeswapV2OptionSwapCallbackParam} from \"@timeswap-labs/v2-option/src/structs/CallbackParam.sol\";\n\n// import \"@timeswap-labs/v2-option/src/TimeswapV2OptionFactory.sol\";\n// // import \"@timeswap-labs/v2-option/src/interfaces/ITimeswapV2Option.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\nimport {TimeswapV2LiquidityTokenPosition, PositionLibrary} from \"../src/structs/Position.sol\";\nimport {TimeswapV2PoolMint} from \"@timeswap-labs/v2-pool/src/enums/Transaction.sol\";\nimport {TimeswapV2OptionMint} from \"@timeswap-labs/v2-option/src/enums/Transaction.sol\";\n\nimport {StrikeConversion} from \"@timeswap-labs/v2-library/src/StrikeConversion.sol\";\nimport {DurationCalculation} from \"@timeswap-labs/v2-pool/src/libraries/DurationCalculation.sol\";\nimport {FullMath} from \"@timeswap-labs/v2-library/src/FullMath.sol\";\n\ncontract HelperERC20 is ERC20 {\n    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) {\n        _mint(msg.sender, type(uint256).max);\n    }\n}\nstruct Timestamps {\n    uint256 maturity;\n    uint256 timeNow;\n}\nstruct MintOutput {\n    uint160 liquidityAmount;\n    uint256 long0Amount;\n    uint256 long1Amount;\n    uint256 shortAmount;\n    bytes data;\n}\n\ncontract TimeswapV2LiquidityTokenTest is Test, ERC1155Holder {\n    ITimeswapV2Option opPair;\n    ITimeswapV2Option opPair2;\n    ITimeswapV2Option opPair3;\n    ITimeswapV2Option opPairCurrent;\n    TimeswapV2OptionFactory optionFactory;\n    TimeswapV2PoolFactory poolFactory;\n    ITimeswapV2Pool pool;\n    ITimeswapV2Pool pool2;\n    ITimeswapV2Pool pool3;\n    ITimeswapV2Pool poolCurrent;\n    using PositionLibrary for TimeswapV2LiquidityTokenPosition;\n\n    uint256 chosenTransactionFee = 5;\n    uint256 chosenProtocolFee = 4;\n\n    HelperERC20 token0;\n    HelperERC20 token1;\n    HelperERC20 token2;\n    HelperERC20 token3;\n    HelperERC20 token4;\n    HelperERC20 token5;\n    HelperERC20 token0Current;\n    HelperERC20 token1Current;\n    TimeswapV2LiquidityToken mockLiquidityToken;\n\n    function timeswapV2PoolMintChoiceCallback(TimeswapV2PoolMintChoiceCallbackParam calldata param) external returns (uint256 long0Amount, uint256 long1Amount, bytes memory data) {\n        vm.assume(param.longAmount < (1 << 127));\n        long0Amount = StrikeConversion.turn(param.longAmount / 2, param.strike, false, true) + 1;\n        long1Amount = StrikeConversion.turn(param.longAmount / 2, param.strike, true, true) + 1;\n        vm.assume(\n            param.longAmount < StrikeConversion.combine(long0Amount, long1Amount, param.strike, false) && param.shortAmount < StrikeConversion.combine(long0Amount, long1Amount, param.strike, false)\n        );\n    }\n\n    function timeswapV2PoolMintCallback(TimeswapV2PoolMintCallbackParam calldata param) external returns (bytes memory data) {\n        // have to transfer param.long0Amount, param.long1Amount and param.short to msg.sender\n        console.log(param.long0Amount, param.long1Amount);\n        TimeswapV2OptionMintParam memory mparam = TimeswapV2OptionMintParam({\n            strike: param.strike,\n            maturity: param.maturity,\n            long0To: msg.sender,\n            long1To: msg.sender,\n            shortTo: msg.sender,\n            transaction: TimeswapV2OptionMint.GivenTokensAndLongs,\n            amount0: param.long0Amount,\n            amount1: param.long1Amount,\n            data: \"\"\n        });\n        opPairCurrent.mint(mparam);\n        console.log(\"opPair mint ok\");\n    }\n\n    function timeswapV2OptionMintCallback(TimeswapV2OptionMintCallbackParam calldata param) external returns (bytes memory data) {\n        data = param.data;\n        //console.log(\"token0 bal:\", token0.balanceOf(address(this)));\n        //console.log(\"token1 bal:\", token1.balanceOf(address(this)));\n        token0Current.transfer(msg.sender, param.token0AndLong0Amount);\n        token1Current.transfer(msg.sender, param.token1AndLong1Amount);\n    }\n\n    function timeswapV2LiquidityTokenMintCallback(TimeswapV2LiquidityTokenMintCallbackParam calldata param) external returns (bytes memory data) {\n        TimeswapV2PoolMintParam memory param1 = TimeswapV2PoolMintParam({\n            strike: param.strike, \n            maturity: param.maturity, \n            to: address(this), \n            transaction: TimeswapV2PoolMint.GivenLiquidity, \n            delta: param.liquidityAmount, \n            data: \"\"}\n        );\n\n        poolCurrent.mint(param1);\n        poolCurrent.transferLiquidity(param.strike, param.maturity, msg.sender, param.liquidityAmount);\n        data = bytes(\"\");\n    }\n\n    function setUp() public {\n        optionFactory = new TimeswapV2OptionFactory();\n        token0 = new HelperERC20(\"Token A\", \"A\");\n        token1 = new HelperERC20(\"Token B\", \"B\");\n        token2 = new HelperERC20(\"Token C\", \"C\");\n        token3 = new HelperERC20(\"Token D\", \"D\");\n        token4 = new HelperERC20(\"Token E\", \"E\");\n        token5 = new HelperERC20(\"Token F\", \"F\");\n        if (address(token1) < address(token0)) {\n            (token0, token1) = (token1, token0);\n        }\n        if (address(token3) < address(token2)) {\n            (token2, token3) = (token3, token2);\n        }\n        if (address(token5) < address(token4)) {\n            (token4, token5) = (token5, token4);\n        }\n        address opAddress = optionFactory.create(address(token0), address(token1));\n        opPair = ITimeswapV2Option(opAddress);\n        address opAddress2 = optionFactory.create(address(token2), address(token3));\n        opPair2 = ITimeswapV2Option(opAddress2);\n        address opAddress3 = optionFactory.create(address(token4), address(token5));\n        opPair3 = ITimeswapV2Option(opAddress3);\n        poolFactory = new TimeswapV2PoolFactory(address(this), chosenTransactionFee, chosenProtocolFee);\n        pool = ITimeswapV2Pool(poolFactory.create(opAddress));\n        pool2 = ITimeswapV2Pool(poolFactory.create(opAddress2));\n        pool3 = ITimeswapV2Pool(poolFactory.create(opAddress3));\n        mockLiquidityToken = new TimeswapV2LiquidityToken(address(optionFactory), address(poolFactory));\n    }\n\n    function testMint(uint256 strike, uint160 amt, uint256 maturity, uint160 rate, address to) public {\n        setUp();\n\n        // vm.assume(strike != 0 && (maturity < type(uint96).max) && (maturity > 10000) && amt > 100 && delta != 0 && rate != 0);\n        vm.assume(to != address(0));\n        vm.assume(\n            maturity < type(uint96).max &&\n                amt < type(uint160).max &&\n                amt != 0 &&\n                to != address(0) &&\n                strike != 0 &&\n                maturity > block.timestamp &&\n                maturity > 10000 && rate>0\n        );\n\n        console.log(\"init\");\n        pool.initialize(strike, maturity, rate);\n        pool2.initialize(strike, maturity, rate);\n        pool3.initialize(strike, maturity, rate);\n\n        //TimeswapV2PoolMintParam memory param = TimeswapV2PoolMintParam({strike: strike, maturity: maturity, to: address(this), transaction: TimeswapV2PoolMint.GivenLiquidity, delta: amt, data: \"\"});\n\n        //MintOutput memory response;\n        //(response.liquidityAmount, response.long0Amount, response.long1Amount, response.shortAmount, response.data) = pool.mint(param);\n        uint256 id1;\n        uint256 id2;\n        {\n            token0Current = token0;\n            token1Current = token1;\n            poolCurrent = pool;\n            opPairCurrent = opPair;\n            TimeswapV2LiquidityTokenMintParam memory liqTokenMintParam = TimeswapV2LiquidityTokenMintParam({\n                token0: address(token0Current),\n                token1: address(token1Current),\n                strike: strike,\n                maturity: maturity,\n                to: address(this),\n                liquidityAmount: amt,\n                data: \"\"\n            });\n\n            mockLiquidityToken.mint(liqTokenMintParam);\n            //console.log(mockLiquidityToken.balanceOf(address(this)));\n            TimeswapV2LiquidityTokenPosition memory timeswapV2LiquidityTokenPosition = TimeswapV2LiquidityTokenPosition({\n                token0: address(token0Current),\n                token1: address(token1Current),\n                strike: strike,\n                maturity: maturity\n            });\n\n            bytes32 key1 = timeswapV2LiquidityTokenPosition.toKey();\n            id1 = mockLiquidityToken._timeswapV2LiquidityTokenPositionIds(key1);\n            console.log(\"key1:\");\n            console.logBytes32(key1);\n            console.log(\"id1:\", id1);\n            assertEq(mockLiquidityToken.balanceOf(address(this), id1), amt);\n            assertEq(mockLiquidityToken.totalSupply(), 1);\n            //console.log(\"_idTotalSupply id1:\", mockLiquidityToken._idTotalSupply(id1));\n            console.log(\"========\");\n        }\n\n\n        {\n            token0Current = token2;\n            token1Current = token3;\n            poolCurrent = pool2;\n            opPairCurrent = opPair2;\n            TimeswapV2LiquidityTokenMintParam memory liqTokenMintParam2 = TimeswapV2LiquidityTokenMintParam({\n                token0: address(token0Current),\n                token1: address(token1Current),\n                strike: strike,\n                maturity: maturity,\n                to: address(this),\n                liquidityAmount: amt,\n                data: \"\"\n            });\n\n            mockLiquidityToken.mint(liqTokenMintParam2);\n            //console.log(mockLiquidityToken.balanceOf(address(this)));\n            TimeswapV2LiquidityTokenPosition memory timeswapV2LiquidityTokenPosition2 = TimeswapV2LiquidityTokenPosition({\n                token0: address(token0Current),\n                token1: address(token1Current),\n                strike: strike,\n                maturity: maturity\n            });\n\n            bytes32 key2 = timeswapV2LiquidityTokenPosition2.toKey();\n            id2 = mockLiquidityToken._timeswapV2LiquidityTokenPositionIds(key2);\n            console.log(\"key2:\");\n            console.logBytes32(key2);\n            console.log(\"id2:\", id2);\n            assertEq(mockLiquidityToken.balanceOf(address(this), id2), amt);\n            assertEq(mockLiquidityToken.totalSupply(), 2);\n            console.log(\"========\");\n        }\n\n        TimeswapV2LiquidityTokenBurnParam memory burnParam = TimeswapV2LiquidityTokenBurnParam({\n            token0: address(token0),\n            token1: address(token1),\n            strike: strike,\n            maturity: maturity,\n            to: address(this),\n            liquidityAmount: amt,\n            data: \"\"\n        });\n        mockLiquidityToken.burn(burnParam);\n        console.log(\"balanceOf id1:\", mockLiquidityToken.balanceOf(address(this), id1));\n        //console.log(\"_idTotalSupply id1:\", mockLiquidityToken._idTotalSupply(id1));\n        console.log(\"current totalSupply():\", mockLiquidityToken.totalSupply());\n\n        {\n            token0Current = token4;\n            token1Current = token5;\n            poolCurrent = pool3;\n            opPairCurrent = opPair3;\n            TimeswapV2LiquidityTokenMintParam memory liqTokenMintParam3 = TimeswapV2LiquidityTokenMintParam({\n                token0: address(token0Current),\n                token1: address(token1Current),\n                strike: strike,\n                maturity: maturity,\n                to: address(this),\n                liquidityAmount: amt,\n                data: \"\"\n            });\n\n            mockLiquidityToken.mint(liqTokenMintParam3);\n            //console.log(mockLiquidityToken.balanceOf(address(this)));\n            TimeswapV2LiquidityTokenPosition memory timeswapV2LiquidityTokenPosition3 = TimeswapV2LiquidityTokenPosition({\n                token0: address(token0Current),\n                token1: address(token1Current),\n                strike: strike,\n                maturity: maturity\n            });\n\n            bytes32 key3 = timeswapV2LiquidityTokenPosition3.toKey();\n            uint256 id3 = mockLiquidityToken._timeswapV2LiquidityTokenPositionIds(key3);\n            console.log(\"key3:\");\n            console.logBytes32(key3);\n            console.log(\"id3:\", id3);\n            //assertEq(mockLiquidityToken.balanceOf(address(this), id3), amt);\n            if (id2 == id3) {revert(\"id3 should not equal to id2\");}\n            console.log(\"========\");\n        }\n\n        console.log(\"yo\");\n    }\n}\n\n```\n\nHere is the log for the above test: `forge test --match-path test/TimeswapV2LiquidityToken_MultiMint.t.sol -vv`\n\n    Running 1 test for test/TimeswapV2LiquidityToken.t.sol:TimeswapV2LiquidityTokenTest\n    [FAIL. Reason: id3 should not equal to id2 Counterexample: calldata=0x31b83c070000000000000000000000000000000000000000000000000000000000000d77000000000000000000000000000000000000000000000000000000000000234100000000000000000000000000000000000000000000000000000000277c306f00000000000000000000000000000000000000000000000000000000000032e0000000000000000000000000000000000000000000000000000000000000025f, args=[3447, 9025, 662450287, 13024, 0x000000000000000000000000000000000000025F]] testMint(uint256,uint160,uint256,uint160,address) (runs: 0, μ: 0, ~: 0)\n    Logs:\n      init\n      2709883200956651719220887728062100075977988725238523898809710331 27450636006266724768954781627\n      opPair mint ok\n      key1:\n      0x3ad1cfe6142808456d576d32877db082ef58ce80e40fb5019d9e5f73aebfde46\n      id1: 1\n      ========\n      2709883200956651719220887728062100075977988725238523898809710331 27450636006266724768954781627\n      opPair mint ok\n      key2:\n      0x4b911bdfb2c97775c28fae58288d53335ea7b59d3675acf0460ff4083897e18c\n      id2: 2\n      ========\n      balanceOf id1: 0\n      current totalSupply(): 1\n      2709883200956651719220887728062100075977988725238523898809710331 27450636006266724768954781627\n      opPair mint ok\n      key3:\n      0x6b43d3a16273d9e9f13739b825952b03e59127b9d41c4e0d9d58d635e8d2f5d2\n      id3: 2\n\n    Test result: FAILED. 0 passed; 1 failed; finished in 91.76ms\n\n    Failing tests:\n    Encountered 1 failing test in test/TimeswapV2LiquidityToken.t.sol:TimeswapV2LiquidityTokenTest\n    [FAIL. Reason: id3 should not equal to id2 Counterexample: calldata=0x31b83c070000000000000000000000000000000000000000000000000000000000000d77000000000000000000000000000000000000000000000000000000000000234100000000000000000000000000000000000000000000000000000000277c306f00000000000000000000000000000000000000000000000000000000000032e0000000000000000000000000000000000000000000000000000000000000025f, args=[3447, 9025, 662450287, 13024, 0x000000000000000000000000000000000000025F]] testMint(uint256,uint160,uint256,uint160,address) (runs: 0, μ: 0, ~: 0)\n\n    Encountered a total of 1 failing tests, 0 tests succeeded\n\n\n### Recommended Mitigation Steps\n\nDo not use `totalSupply()` or other maybe-decreasing variables for new tokenId.\n\nPatch file can be like this:\n\n    diff --git a/packages/v2-token/src/TimeswapV2LiquidityToken.sol b/packages/v2-token/src/TimeswapV2LiquidityToken.sol\n    index 2f71a25..94e4006 100644\n    --- a/packages/v2-token/src/TimeswapV2LiquidityToken.sol\n    +++ b/packages/v2-token/src/TimeswapV2LiquidityToken.sol\n    @@ -32,6 +32,7 @@ contract TimeswapV2LiquidityToken is ITimeswapV2LiquidityToken, ERC1155Enumerabl\n     \n         address public immutable optionFactory;\n         address public immutable poolFactory;\n    +    uint256 public tokenIdCounter;\n     \n         constructor(address chosenOptionFactory, address chosenPoolFactory) ERC1155(\"Timeswap V2 uint160 address\") {\n             optionFactory = chosenOptionFactory;\n    @@ -111,7 +112,7 @@ contract TimeswapV2LiquidityToken is ITimeswapV2LiquidityToken, ERC1155Enumerabl\n     \n             // if the position does not exist, create it\n             if (id == 0) {\n    -            id = totalSupply() + 1;\n    +            id = ++tokenIdCounter;\n                 _timeswapV2LiquidityTokenPositions[id] = timeswapV2LiquidityTokenPosition;\n                 _timeswapV2LiquidityTokenPositionIds[key] = id;\n             }\n\n**[Picodes (judge) increased severity to High](https://github.com/code-423n4/2023-01-timeswap-findings/issues/219)** \n\n**[vhawk19 (Timeswap) confirmed and resolved](https://github.com/code-423n4/2023-01-timeswap-findings/issues/219#issuecomment-1429307516):**\n > Fixed in [PR](https://github.com/Timeswap-Labs/Timeswap-V2-Monorepo/pull/293).\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-01-timeswap",
  "Code": [
    {
      "filename": "packages/v2-token/src/TimeswapV2LiquidityToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\nimport {ERC1155} from \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n\nimport {ITimeswapV2Pool} from \"@timeswap-labs/v2-pool/src/interfaces/ITimeswapV2Pool.sol\";\n\nimport {PoolFactoryLibrary} from \"@timeswap-labs/v2-pool/src/libraries/PoolFactory.sol\";\nimport {ReentrancyGuard} from \"@timeswap-labs/v2-pool/src/libraries/ReentrancyGuard.sol\";\n\nimport {ITimeswapV2LiquidityToken} from \"./interfaces/ITimeswapV2LiquidityToken.sol\";\n\nimport {ITimeswapV2LiquidityTokenMintCallback} from \"./interfaces/callbacks/ITimeswapV2LiquidityTokenMintCallback.sol\";\nimport {ITimeswapV2LiquidityTokenBurnCallback} from \"./interfaces/callbacks/ITimeswapV2LiquidityTokenBurnCallback.sol\";\nimport {ITimeswapV2LiquidityTokenCollectCallback} from \"./interfaces/callbacks/ITimeswapV2LiquidityTokenCollectCallback.sol\";\n\nimport {ERC1155Enumerable} from \"./base/ERC1155Enumerable.sol\";\n\nimport {TimeswapV2LiquidityTokenPosition, PositionLibrary} from \"./structs/Position.sol\";\nimport {FeesPosition, FeesPositionLibrary} from \"./structs/FeesPosition.sol\";\nimport {TimeswapV2LiquidityTokenMintParam, TimeswapV2LiquidityTokenBurnParam, TimeswapV2LiquidityTokenCollectParam, ParamLibrary} from \"./structs/Param.sol\";\nimport {TimeswapV2LiquidityTokenMintCallbackParam, TimeswapV2LiquidityTokenBurnCallbackParam, TimeswapV2LiquidityTokenCollectCallbackParam} from \"./structs/CallbackParam.sol\";\nimport {Error} from \"@timeswap-labs/v2-library/src/Error.sol\";\n\n/// @title An implementation for TS-V2 liquidity token system\n/// @author Timeswap Labs\ncontract TimeswapV2LiquidityToken is ITimeswapV2LiquidityToken, ERC1155Enumerable {\n    using ReentrancyGuard for uint96;\n\n    using PositionLibrary for TimeswapV2LiquidityTokenPosition;\n    using FeesPositionLibrary for FeesPosition;\n\n    address public immutable optionFactory;\n    address public immutable poolFactory;\n\n    constructor(address chosenOptionFactory, address chosenPoolFactory) ERC1155(\"Timeswap V2 uint160 address\") {\n        optionFactory = chosenOptionFactory;\n        poolFactory = chosenPoolFactory;\n    }\n\n    mapping(bytes32 => uint96) private reentrancyGuards;\n\n    mapping(uint256 => TimeswapV2LiquidityTokenPosition) private _timeswapV2LiquidityTokenPositions;\n\n    mapping(bytes32 => uint256) private _timeswapV2LiquidityTokenPositionIds;\n\n    mapping(uint256 => mapping(address => FeesPosition)) private _feesPositions;\n\n    function changeInteractedIfNecessary(bytes32 key) private {\n        if (reentrancyGuards[key] == ReentrancyGuard.NOT_INTERACTED) reentrancyGuards[key] = ReentrancyGuard.NOT_ENTERED;\n    }\n\n    /// @dev internal function to start the reentrancy guard\n    function raiseGuard(bytes32 key) private {\n        reentrancyGuards[key].check();\n        reentrancyGuards[key] = ReentrancyGuard.ENTERED;\n    }\n\n    /// @dev internal function to end the reentrancy guard\n    function lowerGuard(bytes32 key) private {\n        reentrancyGuards[key] = ReentrancyGuard.NOT_ENTERED;\n    }\n\n    /// @inheritdoc ITimeswapV2LiquidityToken\n    function positionOf(address owner, TimeswapV2LiquidityTokenPosition calldata timeswapV2LiquidityTokenPosition) external view returns (uint256 amount) {\n        amount = balanceOf(owner, _timeswapV2LiquidityTokenPositionIds[timeswapV2LiquidityTokenPosition.toKey()]);\n    }\n\n    /// @inheritdoc ITimeswapV2LiquidityToken\n    function transferTokenPositionFrom(address from, address to, TimeswapV2LiquidityTokenPosition calldata timeswapV2LiquidityTokenPosition, uint160 liquidityAmount) external {\n        safeTransferFrom(from, to, _timeswapV2LiquidityTokenPositionIds[timeswapV2LiquidityTokenPosition.toKey()], liquidityAmount, bytes(\"\"));\n    }\n\n    /// @inheritdoc ITimeswapV2LiquidityToken\n    function transferFeesFrom(address from, address to, TimeswapV2LiquidityTokenPosition calldata position, uint256 long0Fees, uint256 long1Fees, uint256 shortFees) external override {\n        if (from == address(0)) Error.zeroAddress();\n        if (to == address(0)) Error.zeroAddress();\n\n        if (!isApprovedForAll(from, msg.sender)) revert NotApprovedToTransferFees();\n\n        uint256 id = _timeswapV2LiquidityTokenPositionIds[position.toKey()];\n\n        if (long0Fees != 0 || long1Fees != 0 || shortFees != 0) _addTokenEnumeration(from, to, id, 0);\n\n        // add/mint the fees for the new user\n        _feesPositions[id][to].mint(long0Fees, long1Fees, shortFees);\n\n        _updateFeesPositions(from, to, id);\n\n        // remove/burn the fees\n        _feesPositions[id][from].burn(long0Fees, long1Fees, shortFees);\n\n        if (long0Fees != 0 || long1Fees != 0 || shortFees != 0) _removeTokenEnumeration(from, to, id, 0);\n\n        emit TransferFees(from, to, position, long0Fees, long1Fees, shortFees);\n    }\n\n    /// @inheritdoc ITimeswapV2LiquidityToken\n    function mint(TimeswapV2LiquidityTokenMintParam calldata param) external returns (bytes memory data) {\n        ParamLibrary.check(param);\n\n        TimeswapV2LiquidityTokenPosition memory timeswapV2LiquidityTokenPosition = TimeswapV2LiquidityTokenPosition({\n            token0: param.token0,\n            token1: param.token1,\n            strike: param.strike,\n            maturity: param.maturity\n        });\n\n        bytes32 key = timeswapV2LiquidityTokenPosition.toKey();\n        uint256 id = _timeswapV2LiquidityTokenPositionIds[key];\n\n        // if the position does not exist, create it\n        if (id == 0) {\n            id = totalSupply() + 1;\n            _timeswapV2LiquidityTokenPositions[id] = timeswapV2LiquidityTokenPosition;\n            _timeswapV2LiquidityTokenPositionIds[key] = id;\n        }\n\n        changeInteractedIfNecessary(key);\n        raiseGuard(key);\n\n        (, address poolPair) = PoolFactoryLibrary.getWithCheck(optionFactory, poolFactory, param.token0, param.token1);\n\n        // calculate the amount of liquidity tokens to mint\n        uint160 liquidityBalanceTarget = ITimeswapV2Pool(poolPair).liquidityOf(param.strike, param.maturity, address(this)) + param.liquidityAmount;\n\n        // mint the liquidity tokens to the recipient\n        _mint(param.to, id, param.liquidityAmount, bytes(\"\"));\n\n        // ask the msg.sender to transfer the liquidity to this contract\n        data = ITimeswapV2LiquidityTokenMintCallback(msg.sender).timeswapV2LiquidityTokenMintCallback(\n            TimeswapV2LiquidityTokenMintCallbackParam({\n                token0: param.token0,\n                token1: param.token1,\n                strike: param.strike,\n                maturity: param.maturity,\n                liquidityAmount: param.liquidityAmount,\n                data: param.data\n            })\n        );\n\n        // check if the enough liquidity amount target is received\n        Error.checkEnough(ITimeswapV2Pool(poolPair).liquidityOf(param.strike, param.maturity, address(this)), liquidityBalanceTarget);\n\n        // stop the reentrancy guard\n        lowerGuard(key);\n    }\n\n    /// @inheritdoc ITimeswapV2LiquidityToken\n    function burn(TimeswapV2LiquidityTokenBurnParam calldata param) external returns (bytes memory data) {\n        ParamLibrary.check(param);\n\n        bytes32 key = TimeswapV2LiquidityTokenPosition({token0: param.token0, token1: param.token1, strike: param.strike, maturity: param.maturity}).toKey();\n\n        raiseGuard(key);\n\n        (, address poolPair) = PoolFactoryLibrary.getWithCheck(optionFactory, poolFactory, param.token0, param.token1);\n\n        // transfer the equivalent liquidity amount to the recipient from pool\n        ITimeswapV2Pool(poolPair).transferLiquidity(param.strike, param.maturity, param.to, param.liquidityAmount);\n\n        if (param.data.length != 0)\n            data = ITimeswapV2LiquidityTokenBurnCallback(msg.sender).timeswapV2LiquidityTokenBurnCallback(\n                TimeswapV2LiquidityTokenBurnCallbackParam({\n                    token0: param.token0,\n                    token1: param.token1,\n                    strike: param.strike,\n                    maturity: param.maturity,\n                    liquidityAmount: param.liquidityAmount,\n                    data: param.data\n                })\n            );\n\n        // burn the liquidity tokens from the msg.sender\n        _burn(msg.sender, _timeswapV2LiquidityTokenPositionIds[key], param.liquidityAmount);\n\n        // stop the guard for reentrancy\n        lowerGuard(key);\n    }\n\n    /// @inheritdoc ITimeswapV2LiquidityToken\n    function collect(TimeswapV2LiquidityTokenCollectParam calldata param) external returns (uint256 long0Fees, uint256 long1Fees, uint256 shortFees, bytes memory data) {\n        ParamLibrary.check(param);\n\n        bytes32 key = TimeswapV2LiquidityTokenPosition({token0: param.token0, token1: param.token1, strike: param.strike, maturity: param.maturity}).toKey();\n\n        // start the reentrancy guard\n        raiseGuard(key);\n\n        (, address poolPair) = PoolFactoryLibrary.getWithCheck(optionFactory, poolFactory, param.token0, param.token1);\n\n        // transfer the fees amount to the recipient\n        ITimeswapV2Pool(poolPair).transferFees(param.strike, param.maturity, param.to, long0Fees, long1Fees, shortFees);\n\n        uint256 id = _timeswapV2LiquidityTokenPositionIds[key];\n\n        _updateFeesPositions(msg.sender, address(0), id);\n\n        (long0Fees, long1Fees, shortFees) = _feesPositions[id][msg.sender].getFees(param.long0FeesDesired, param.long1FeesDesired, param.shortFeesDesired);\n\n        if (param.data.length != 0)\n            data = ITimeswapV2LiquidityTokenCollectCallback(msg.sender).timeswapV2LiquidityTokenCollectCallback(\n                TimeswapV2LiquidityTokenCollectCallbackParam({\n                    token0: param.token0,\n                    token1: param.token1,\n                    strike: param.strike,\n                    maturity: param.maturity,\n                    long0Fees: long0Fees,\n                    long1Fees: long1Fees,\n                    shortFees: shortFees,\n                    data: param.data\n                })\n            );\n\n        // burn the desired fees from the fees position\n        _feesPositions[id][msg.sender].burn(long0Fees, long1Fees, shortFees);\n\n        if (long0Fees != 0 || long1Fees != 0 || shortFees != 0) _removeTokenEnumeration(msg.sender, address(0), id, 0);\n\n        // stop the reentrancy guard\n        lowerGuard(key);\n    }\n\n    function _beforeTokenTransfer(address operator, address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i; i < ids.length; ) {\n            if (amounts[i] != 0) _updateFeesPositions(from, to, ids[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _updateFeesPositions(address from, address to, uint256 id) private {\n        if (from != to) {\n            TimeswapV2LiquidityTokenPosition memory timeswapV2LiquidityTokenPosition = _timeswapV2LiquidityTokenPositions[id];\n\n            uint256 long0FeeGrowth;\n            uint256 long1FeeGrowth;\n            uint256 shortFeeGrowth;\n            {\n                (, address poolPair) = PoolFactoryLibrary.getWithCheck(optionFactory, poolFactory, timeswapV2LiquidityTokenPosition.token0, timeswapV2LiquidityTokenPosition.token1);\n\n                (long0FeeGrowth, long1FeeGrowth, shortFeeGrowth) = ITimeswapV2Pool(poolPair).feeGrowth(timeswapV2LiquidityTokenPosition.strike, timeswapV2LiquidityTokenPosition.maturity);\n            }\n\n            if (from != address(0)) _feesPositions[id][from].update(uint160(balanceOf(from, id)), long0FeeGrowth, long1FeeGrowth, shortFeeGrowth);\n\n            if (to != address(0)) _feesPositions[id][to].update(uint160(balanceOf(to, id)), long0FeeGrowth, long1FeeGrowth, shortFeeGrowth);\n        }\n    }\n\n    function _additionalConditionAddTokenToOwnerEnumeration(address to, uint256 id) internal view override returns (bool) {\n        return _additionalConditionForOwnerTokenEnumeration(to, id);\n    }\n\n    function _additionalConditionRemoveTokenFromOwnerEnumeration(address from, uint256 id) internal view override returns (bool) {\n        return _additionalConditionForOwnerTokenEnumeration(from, id);\n    }\n\n    function _additionalConditionForOwnerTokenEnumeration(address owner, uint256 id) private view returns (bool) {\n        TimeswapV2LiquidityTokenPosition memory timeswapV2LiquidityTokenPosition = _timeswapV2LiquidityTokenPositions[id];\n\n        uint256 long0FeeGrowth;\n        uint256 long1FeeGrowth;\n        uint256 shortFeeGrowth;\n        {\n            (, address poolPair) = PoolFactoryLibrary.getWithCheck(optionFactory, poolFactory, timeswapV2LiquidityTokenPosition.token0, timeswapV2LiquidityTokenPosition.token1);\n\n            (long0FeeGrowth, long1FeeGrowth, shortFeeGrowth) = ITimeswapV2Pool(poolPair).feeGrowth(timeswapV2LiquidityTokenPosition.strike, timeswapV2LiquidityTokenPosition.maturity);\n        }\n\n        FeesPosition memory feesPosition = _feesPositions[id][owner];\n\n        (uint256 long0Fees, uint256 long1Fees, uint256 shortFees) = feesPosition.feesEarnedOf(uint160(balanceOf(owner, id)), long0FeeGrowth, long1FeeGrowth, shortFeeGrowth);\n\n        return long0Fees == 0 && long1Fees == 0 && shortFees == 0;\n    }\n}"
    },
    {
      "filename": "packages/v2-token/src/TimeswapV2Token.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\nimport {ERC1155} from \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport \"forge-std/console.sol\";\n\nimport {ITimeswapV2Option} from \"@timeswap-labs/v2-option/src/interfaces/ITimeswapV2Option.sol\";\n\nimport {OptionFactoryLibrary} from \"@timeswap-labs/v2-option/src/libraries/OptionFactory.sol\";\nimport {ReentrancyGuard} from \"@timeswap-labs/v2-pool/src/libraries/ReentrancyGuard.sol\";\n\nimport {TimeswapV2OptionPosition} from \"@timeswap-labs/v2-option/src/enums/Position.sol\";\n\nimport {ITimeswapV2Token} from \"./interfaces/ITimeswapV2Token.sol\";\n\nimport {ITimeswapV2TokenMintCallback} from \"./interfaces/callbacks/ITimeswapV2TokenMintCallback.sol\";\nimport {ITimeswapV2TokenBurnCallback} from \"./interfaces/callbacks/ITimeswapV2TokenBurnCallback.sol\";\n\nimport {ERC1155Enumerable} from \"./base/ERC1155Enumerable.sol\";\n\nimport {TimeswapV2TokenPosition, PositionLibrary} from \"./structs/Position.sol\";\nimport {TimeswapV2TokenMintParam, TimeswapV2TokenBurnParam, ParamLibrary} from \"./structs/Param.sol\";\nimport {TimeswapV2TokenMintCallbackParam, TimeswapV2TokenBurnCallbackParam} from \"./structs/CallbackParam.sol\";\nimport {Error} from \"@timeswap-labs/v2-library/src/Error.sol\";\n\n/// @title\n/// @author Timeswap Labs\n/// @notice TimeswapV2Token tokenizes the TimeswapV2 native option positions (long0, long1, short)\ncontract TimeswapV2Token is ITimeswapV2Token, ERC1155Enumerable {\n    using ReentrancyGuard for uint96;\n\n    using PositionLibrary for TimeswapV2TokenPosition;\n\n    address public immutable optionFactory;\n\n    mapping(bytes32 => uint96) private reentrancyGuards;\n\n    mapping(uint256 => TimeswapV2TokenPosition) private _timeswapV2TokenPositions;\n    mapping(bytes32 => uint256) private _timeswapV2TokenPositionIds;\n\n    constructor(address chosenOptionFactory) ERC1155(\"Timeswap V2 address\") {\n        optionFactory = chosenOptionFactory;\n    }\n\n    function changeInteractedIfNecessary(address token0, address token1, uint256 strike, uint256 maturity) private {\n        bytes32 key = keccak256(abi.encode(token0, token1, strike, maturity));\n\n        if (reentrancyGuards[key] == ReentrancyGuard.NOT_INTERACTED) reentrancyGuards[key] = ReentrancyGuard.NOT_ENTERED;\n    }\n\n    /// @dev internal function to start the reentrancy guard\n    function raiseGuard(address token0, address token1, uint256 strike, uint256 maturity) private {\n        bytes32 key = keccak256(abi.encode(token0, token1, strike, maturity));\n\n        reentrancyGuards[key].check();\n        reentrancyGuards[key] = ReentrancyGuard.ENTERED;\n    }\n\n    /// @dev internal function to end the reentrancy guard\n    function lowerGuard(address token0, address token1, uint256 strike, uint256 maturity) private {\n        bytes32 key = keccak256(abi.encode(token0, token1, strike, maturity));\n        reentrancyGuards[key] = ReentrancyGuard.NOT_ENTERED;\n    }\n\n    /// @inheritdoc ITimeswapV2Token\n    function positionOf(address owner, TimeswapV2TokenPosition calldata timeswapV2TokenPosition) public view returns (uint256 amount) {\n        amount = ERC1155.balanceOf(owner, _timeswapV2TokenPositionIds[timeswapV2TokenPosition.toKey()]);\n    }\n\n    /// @inheritdoc ITimeswapV2Token\n    function transferTokenPositionFrom(address from, address to, TimeswapV2TokenPosition calldata timeswapV2TokenPosition, uint256 amount) external override {\n        safeTransferFrom(from, to, _timeswapV2TokenPositionIds[timeswapV2TokenPosition.toKey()], (amount), bytes(\"\"));\n    }\n\n    /// @inheritdoc ITimeswapV2Token\n    function mint(TimeswapV2TokenMintParam calldata param) external override returns (bytes memory data) {\n        ParamLibrary.check(param);\n        changeInteractedIfNecessary(param.token0, param.token1, param.strike, param.maturity);\n        raiseGuard(param.token0, param.token1, param.strike, param.maturity);\n\n        address optionPair = OptionFactoryLibrary.getWithCheck(optionFactory, param.token0, param.token1);\n\n        uint256 long0BalanceTarget;\n        // mints TimeswapV2Token in case of the long0 position\n        if (param.long0Amount != 0) {\n            // get the initial balance of the long0 position and add the long0 amount to mint\n            long0BalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long0) + param.long0Amount;\n\n            TimeswapV2TokenPosition memory timeswapV2TokenPosition = TimeswapV2TokenPosition({\n                token0: param.token0,\n                token1: param.token1,\n                strike: param.strike,\n                maturity: param.maturity,\n                position: TimeswapV2OptionPosition.Long0\n            });\n\n            bytes32 key = timeswapV2TokenPosition.toKey();\n            // get the unique id of the TimeswapV2Token position\n            uint256 id = _timeswapV2TokenPositionIds[key];\n\n            // if the id is 0, it means that the position has not been minted yet\n            if (id == 0) {\n                id = totalSupply() + 1;\n                _timeswapV2TokenPositions[id] = timeswapV2TokenPosition;\n                _timeswapV2TokenPositionIds[key] = id;\n            }\n\n            // mint the TimeswapV2Token long0 position\n            console.log(\"reaches right before mint in timeswapv2Tokne::mint\");\n            _mint(param.long0To, id, (param.long0Amount), bytes(\"\"));\n        }\n\n        uint256 long1BalanceTarget;\n        // mints TimeswapV2Token in case of the long1 position\n        if (param.long1Amount != 0) {\n            // get the initial balance of the long1 position and add the long1 amount to mint\n            long1BalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long1) + param.long1Amount;\n\n            TimeswapV2TokenPosition memory timeswapV2TokenPosition = TimeswapV2TokenPosition({\n                token0: param.token0,\n                token1: param.token1,\n                strike: param.strike,\n                maturity: param.maturity,\n                position: TimeswapV2OptionPosition.Long1\n            });\n\n            bytes32 key = timeswapV2TokenPosition.toKey();\n            // get the unique id of the TimeswapV2Token position\n            uint256 id = _timeswapV2TokenPositionIds[key];\n\n            // if the id is 0, it means that the position has not been minted yet\n            if (id == 0) {\n                id = totalSupply() + 1;\n                _timeswapV2TokenPositions[id] = timeswapV2TokenPosition;\n                _timeswapV2TokenPositionIds[key] = id;\n            }\n\n            // mint the TimeswapV2Token long1 position\n            _mint(param.long1To, id, (param.long1Amount), bytes(\"\"));\n        }\n\n        uint256 shortBalanceTarget;\n        // mints TimeswapV2Token in case of the short position\n        if (param.shortAmount != 0) {\n            // get the initial balance of the short position and add the short amount to mint\n            shortBalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Short) + param.shortAmount;\n\n            TimeswapV2TokenPosition memory timeswapV2TokenPosition = TimeswapV2TokenPosition({\n                token0: param.token0,\n                token1: param.token1,\n                strike: param.strike,\n                maturity: param.maturity,\n                position: TimeswapV2OptionPosition.Short\n            });\n\n            bytes32 key = timeswapV2TokenPosition.toKey();\n            // get the unique id of the TimeswapV2Token position\n            uint256 id = _timeswapV2TokenPositionIds[key];\n\n            // if the id is 0, it means that the position has not been minted yet\n            if (id == 0) {\n                id = totalSupply() + 1;\n                _timeswapV2TokenPositions[id] = timeswapV2TokenPosition;\n                _timeswapV2TokenPositionIds[key] = id;\n            }\n\n            // mint the TimeswapV2Token short position\n            _mint(param.shortTo, id, (param.shortAmount), bytes(\"\"));\n        }\n        // console.log()\n        // ask the msg.sender to transfer the long0/long1/short amount to the this contract\n        data = ITimeswapV2TokenMintCallback(msg.sender).timeswapV2TokenMintCallback(\n            TimeswapV2TokenMintCallbackParam({\n                token0: param.token0,\n                token1: param.token1,\n                strike: param.strike,\n                maturity: param.maturity,\n                long0Amount: param.long0Amount,\n                long1Amount: param.long1Amount,\n                shortAmount: param.shortAmount,\n                data: param.data\n            })\n        );\n\n        // check if the long0 position token balance target is achieved. If not, revert the transaction\n        if (param.long0Amount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long0), long0BalanceTarget);\n\n        // check if the long1 position token balance target is achieved. If not, revert the transaction\n        if (param.long1Amount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long1), long1BalanceTarget);\n\n        // check if the short position token balance target is achieved. If not, revert the transaction\n        if (param.shortAmount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Short), shortBalanceTarget);\n\n        lowerGuard(param.token0, param.token1, param.strike, param.maturity);\n    }\n\n    /// @inheritdoc ITimeswapV2Token\n    function burn(TimeswapV2TokenBurnParam calldata param) external override returns (bytes memory data) {\n        ParamLibrary.check(param);\n        raiseGuard(param.token0, param.token1, param.strike, param.maturity);\n\n        address optionPair = OptionFactoryLibrary.getWithCheck(optionFactory, param.token0, param.token1);\n\n        // case when the long0 position is to be burned\n        if (param.long0Amount != 0) ITimeswapV2Option(optionPair).transferPosition(param.strike, param.maturity, param.long0To, TimeswapV2OptionPosition.Long0, param.long0Amount);\n\n        // case when the long1 position is to be burned\n        if (param.long1Amount != 0)\n            // transfer the underlying equivalent long1 position amount to address of the recipient of long1 position.\n            ITimeswapV2Option(optionPair).transferPosition(param.strike, param.maturity, param.long1To, TimeswapV2OptionPosition.Long1, param.long1Amount);\n\n        // case when the short position is to be burned\n        if (param.shortAmount != 0) ITimeswapV2Option(optionPair).transferPosition(param.strike, param.maturity, param.shortTo, TimeswapV2OptionPosition.Short, param.shortAmount);\n\n        if (param.data.length != 0)\n            data = ITimeswapV2TokenBurnCallback(msg.sender).timeswapV2TokenBurnCallback(\n                TimeswapV2TokenBurnCallbackParam({\n                    token0: param.token0,\n                    token1: param.token1,\n                    strike: param.strike,\n                    maturity: param.maturity,\n                    long0Amount: param.long0Amount,\n                    long1Amount: param.long1Amount,\n                    shortAmount: param.shortAmount,\n                    data: param.data\n                })\n            );\n\n        // case when the long0 position is to be burned\n        if (param.long0Amount != 0) {\n            TimeswapV2TokenPosition memory timeswapV2TokenPosition = TimeswapV2TokenPosition({\n                token0: param.token0,\n                token1: param.token1,\n                strike: param.strike,\n                maturity: param.maturity,\n                position: TimeswapV2OptionPosition.Long0\n            });\n\n            // burn the TimeswapV2Token representing long0 position\n            _burn(msg.sender, _timeswapV2TokenPositionIds[timeswapV2TokenPosition.toKey()], param.long0Amount);\n        }\n\n        // case when the long1 position is to be burned\n        if (param.long1Amount != 0) {\n            TimeswapV2TokenPosition memory timeswapV2TokenPosition = TimeswapV2TokenPosition({\n                token0: param.token0,\n                token1: param.token1,\n                strike: param.strike,\n                maturity: param.maturity,\n                position: TimeswapV2OptionPosition.Long1\n            });\n\n            // burn the TimeswapV2Token representing long1 position\n            _burn(msg.sender, _timeswapV2TokenPositionIds[timeswapV2TokenPosition.toKey()], param.long1Amount);\n        }\n\n        // case when the short position is to be burned\n        if (param.shortAmount != 0) {\n            TimeswapV2TokenPosition memory timeswapV2TokenPosition = TimeswapV2TokenPosition({\n                token0: param.token0,\n                token1: param.token1,\n                strike: param.strike,\n                maturity: param.maturity,\n                position: TimeswapV2OptionPosition.Short\n            });\n\n            // burn the TimeswapV2Token representing short position\n            _burn(msg.sender, _timeswapV2TokenPositionIds[timeswapV2TokenPosition.toKey()], param.shortAmount);\n        }\n\n        // stop the guard of reentrancy\n        lowerGuard(param.token0, param.token1, param.strike, param.maturity);\n    }\n}"
    },
    {
      "filename": "packages/v2-token/src/TimeswapV2LiquidityToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\nimport {ERC1155} from \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n\nimport {ITimeswapV2Pool} from \"@timeswap-labs/v2-pool/src/interfaces/ITimeswapV2Pool.sol\";\n\nimport {PoolFactoryLibrary} from \"@timeswap-labs/v2-pool/src/libraries/PoolFactory.sol\";\nimport {ReentrancyGuard} from \"@timeswap-labs/v2-pool/src/libraries/ReentrancyGuard.sol\";\n\nimport {ITimeswapV2LiquidityToken} from \"./interfaces/ITimeswapV2LiquidityToken.sol\";\n\nimport {ITimeswapV2LiquidityTokenMintCallback} from \"./interfaces/callbacks/ITimeswapV2LiquidityTokenMintCallback.sol\";\nimport {ITimeswapV2LiquidityTokenBurnCallback} from \"./interfaces/callbacks/ITimeswapV2LiquidityTokenBurnCallback.sol\";\nimport {ITimeswapV2LiquidityTokenCollectCallback} from \"./interfaces/callbacks/ITimeswapV2LiquidityTokenCollectCallback.sol\";\n\nimport {ERC1155Enumerable} from \"./base/ERC1155Enumerable.sol\";\n\nimport {TimeswapV2LiquidityTokenPosition, PositionLibrary} from \"./structs/Position.sol\";\nimport {FeesPosition, FeesPositionLibrary} from \"./structs/FeesPosition.sol\";\nimport {TimeswapV2LiquidityTokenMintParam, TimeswapV2LiquidityTokenBurnParam, TimeswapV2LiquidityTokenCollectParam, ParamLibrary} from \"./structs/Param.sol\";\nimport {TimeswapV2LiquidityTokenMintCallbackParam, TimeswapV2LiquidityTokenBurnCallbackParam, TimeswapV2LiquidityTokenCollectCallbackParam} from \"./structs/CallbackParam.sol\";\nimport {Error} from \"@timeswap-labs/v2-library/src/Error.sol\";\n\n/// @title An implementation for TS-V2 liquidity token system\n/// @author Timeswap Labs\ncontract TimeswapV2LiquidityToken is ITimeswapV2LiquidityToken, ERC1155Enumerable {\n    using ReentrancyGuard for uint96;\n\n    using PositionLibrary for TimeswapV2LiquidityTokenPosition;\n    using FeesPositionLibrary for FeesPosition;\n\n    address public immutable optionFactory;\n    address public immutable poolFactory;\n\n    constructor(address chosenOptionFactory, address chosenPoolFactory) ERC1155(\"Timeswap V2 uint160 address\") {\n        optionFactory = chosenOptionFactory;\n        poolFactory = chosenPoolFactory;\n    }\n\n    mapping(bytes32 => uint96) private reentrancyGuards;\n\n    mapping(uint256 => TimeswapV2LiquidityTokenPosition) private _timeswapV2LiquidityTokenPositions;\n\n    mapping(bytes32 => uint256) private _timeswapV2LiquidityTokenPositionIds;\n\n    mapping(uint256 => mapping(address => FeesPosition)) private _feesPositions;\n\n    function changeInteractedIfNecessary(bytes32 key) private {\n        if (reentrancyGuards[key] == ReentrancyGuard.NOT_INTERACTED) reentrancyGuards[key] = ReentrancyGuard.NOT_ENTERED;\n    }\n\n    /// @dev internal function to start the reentrancy guard\n    function raiseGuard(bytes32 key) private {\n        reentrancyGuards[key].check();\n        reentrancyGuards[key] = ReentrancyGuard.ENTERED;\n    }\n\n    /// @dev internal function to end the reentrancy guard\n    function lowerGuard(bytes32 key) private {\n        reentrancyGuards[key] = ReentrancyGuard.NOT_ENTERED;\n    }\n\n    /// @inheritdoc ITimeswapV2LiquidityToken\n    function positionOf(address owner, TimeswapV2LiquidityTokenPosition calldata timeswapV2LiquidityTokenPosition) external view returns (uint256 amount) {\n        amount = balanceOf(owner, _timeswapV2LiquidityTokenPositionIds[timeswapV2LiquidityTokenPosition.toKey()]);\n    }\n\n    /// @inheritdoc ITimeswapV2LiquidityToken\n    function transferTokenPositionFrom(address from, address to, TimeswapV2LiquidityTokenPosition calldata timeswapV2LiquidityTokenPosition, uint160 liquidityAmount) external {\n        safeTransferFrom(from, to, _timeswapV2LiquidityTokenPositionIds[timeswapV2LiquidityTokenPosition.toKey()], liquidityAmount, bytes(\"\"));\n    }\n\n    /// @inheritdoc ITimeswapV2LiquidityToken\n    function transferFeesFrom(address from, address to, TimeswapV2LiquidityTokenPosition calldata position, uint256 long0Fees, uint256 long1Fees, uint256 shortFees) external override {\n        if (from == address(0)) Error.zeroAddress();\n        if (to == address(0)) Error.zeroAddress();\n\n        if (!isApprovedForAll(from, msg.sender)) revert NotApprovedToTransferFees();\n\n        uint256 id = _timeswapV2LiquidityTokenPositionIds[position.toKey()];\n\n        if (long0Fees != 0 || long1Fees != 0 || shortFees != 0) _addTokenEnumeration(from, to, id, 0);\n\n        // add/mint the fees for the new user\n        _feesPositions[id][to].mint(long0Fees, long1Fees, shortFees);\n\n        _updateFeesPositions(from, to, id);\n\n        // remove/burn the fees\n        _feesPositions[id][from].burn(long0Fees, long1Fees, shortFees);\n\n        if (long0Fees != 0 || long1Fees != 0 || shortFees != 0) _removeTokenEnumeration(from, to, id, 0);\n\n        emit TransferFees(from, to, position, long0Fees, long1Fees, shortFees);\n    }\n\n    /// @inheritdoc ITimeswapV2LiquidityToken\n    function mint(TimeswapV2LiquidityTokenMintParam calldata param) external returns (bytes memory data) {\n        ParamLibrary.check(param);\n\n        TimeswapV2LiquidityTokenPosition memory timeswapV2LiquidityTokenPosition = TimeswapV2LiquidityTokenPosition({\n            token0: param.token0,\n            token1: param.token1,\n            strike: param.strike,\n            maturity: param.maturity\n        });\n\n        bytes32 key = timeswapV2LiquidityTokenPosition.toKey();\n        uint256 id = _timeswapV2LiquidityTokenPositionIds[key];\n\n        // if the position does not exist, create it\n        if (id == 0) {\n            id = totalSupply() + 1;\n            _timeswapV2LiquidityTokenPositions[id] = timeswapV2LiquidityTokenPosition;\n            _timeswapV2LiquidityTokenPositionIds[key] = id;\n        }\n\n        changeInteractedIfNecessary(key);\n        raiseGuard(key);\n\n        (, address poolPair) = PoolFactoryLibrary.getWithCheck(optionFactory, poolFactory, param.token0, param.token1);\n\n        // calculate the amount of liquidity tokens to mint\n        uint160 liquidityBalanceTarget = ITimeswapV2Pool(poolPair).liquidityOf(param.stri"
    }
  ]
}