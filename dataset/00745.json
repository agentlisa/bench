{
  "Title": "Users May Be Able to Borrow swEth at an Outdated Price",
  "Content": "The [`getPrice` function](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/oracles/spot/SwEthSpotOracle.sol#L32) of `SwEthSpotOracle` uses a TWAP oracle which means that a sudden change in price would not immediately affect the return value. This value is used in the [`getSpot` function](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/oracles/spot/SpotOracle.sol#L37) which calculates the spot price as the minimum of the result of `getPrice` (the TWAP price) and the exchange rate from the `ReserveOracle`. Using the minimum is a safety mechanism which ensures that the user can only borrow the more pessimistic of the two oracle values.\n\n\nHowever, both the reserve oracle and the TWAP oracle have the property that there is a time delay before the price is updated. The reserve oracle is only updated when the [`updateExchangeRate` function](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/oracles/reserve/ReserveOracle.sol#L95) is called. If the price of the swEth token decreases as a step function, due to a smart contract failure or large slashing event, both the TWAP oracle and reserve oracle will not update immediately.\n\n\nThus, a user could borrow against the swEth token in the `IonPool` contract using an out-of-date exchange rate. If the price discrepancy is large enough, it would be profitable for an attacker to deposit a large amount of swEth and borrow the maximum allowed amount of WETH which would exceed the value of the collateral after the price has been updated. Since this deposit and borrow can be executed in a single transaction, the protocol is vulnerable to being drained during a depegging event even if the TWAP window is relatively short.\n\n\nConsider using a price oracle that better reflects price jumps for the swEth token. Alternatively, consider monitoring for sharp price drops and quickly pausing the ability to borrow in this case.\n\n\n***Update:** Acknowledged, not resolved. Ion Protocol team stated:*\n\n\n\n> *The TWAP range will be chosen carefully to avoid potentially feeding outdated prices while being resilient against short term price manipulations. We will be monitoring the oracle closely for any necessary pauses.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/oracles/spot/SwEthSpotOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IUniswapV3Pool } from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport { TickMath } from \"src/libraries/uniswap/TickMath.sol\";\nimport { UniswapOracleLibrary } from \"src/libraries/uniswap/UniswapOracleLibrary.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SpotOracle } from \"./SpotOracle.sol\";\nimport { WAD } from \"src/libraries/math/WadRayMath.sol\";\n\ncontract SwEthSpotOracle is SpotOracle {\n    using Math for uint256;\n\n    IUniswapV3Pool immutable POOL;\n    uint32 immutable SECONDS_AGO;\n\n    constructor(\n        uint256 _ltv,\n        address _reserveOracle,\n        address _uniswapPool,\n        uint32 _secondsAgo\n    )\n        SpotOracle(_ltv, _reserveOracle)\n    {\n        POOL = IUniswapV3Pool(_uniswapPool);\n        SECONDS_AGO = _secondsAgo;\n    }\n\n    // @notice Gets the price of swETH in ETH. \n    // @dev Uniswap returns price in swETH per ETH. This needs to be inversed.\n    // @return ethPerSwEth price of swETH in ETH [wad] \n    function getPrice() public view override returns (uint256 ethPerSwEth) {\n        (int24 arithmeticMeanTick,) = UniswapOracleLibrary.consult(address(POOL), SECONDS_AGO);\n        uint256 sqrtPriceX96 = TickMath.getSqrtRatioAtTick(arithmeticMeanTick);\n        // swETH per ETH\n        uint256 swEthPerEth = _getPriceX96FromSqrtPriceX96(sqrtPriceX96); // [wad]\n        ethPerSwEth = WAD * WAD / swEthPerEth; // [wad] * [wad] / [wad]\n    }\n\n    function _getPriceX96FromSqrtPriceX96(uint256 sqrtPriceX96) internal pure returns (uint256 priceX96) {\n        return (sqrtPriceX96 * sqrtPriceX96).mulDiv(WAD, 2 ** 192); // [wad]\n    }\n}"
    },
    {
      "filename": "src/oracles/reserve/ReserveOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IReserveFeed } from \"src/interfaces/IReserveFeed.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { WadRayMath } from \"src/libraries/math/WadRayMath.sol\";\n\n// should equal to the number of feeds available in the contract\nuint8 constant MAX_FEED_COUNT = 3;\n\nabstract contract ReserveOracle {\n    using SafeCast for *;\n    using WadRayMath for uint256;\n\n    uint8 public immutable ILK_INDEX;\n    uint8 public immutable QUORUM; // the number of feeds to aggregate\n    uint256 public immutable MAX_CHANGE; // maximum change allowed in percentage [ray] i.e. 3e25 [ray] would be 3%\n\n    IReserveFeed public immutable FEED0; // different reserve oracle feeds excluding the protocol exchange rate\n    IReserveFeed public immutable FEED1;\n    IReserveFeed public immutable FEED2;\n\n    uint256 public currentExchangeRate; // [wad] the bounded queried last time\n\n    // --- Events ---\n    event UpdateExchangeRate(uint256 exchangeRate);\n\n    // --- Errors ---\n    error InvalidQuorum(uint8 quorum);\n    error InvalidFeedLength(uint256 length);\n    error InvalidInitialization(uint256 exchangeRate);\n\n    // --- Override ---\n    function _getProtocolExchangeRate() internal view virtual returns (uint256);\n\n    function getProtocolExchangeRate() external view returns (uint256) {\n        return _getProtocolExchangeRate();\n    }\n\n    constructor(uint8 _ilkIndex, address[] memory _feeds, uint8 _quorum, uint256 _maxChange) {\n        if (_feeds.length > MAX_FEED_COUNT) {\n            revert InvalidFeedLength(_feeds.length);\n        }\n        if (_quorum > MAX_FEED_COUNT) {\n            revert InvalidQuorum(_quorum);\n        }\n\n        ILK_INDEX = _ilkIndex;\n        QUORUM = _quorum;\n        MAX_CHANGE = _maxChange;\n\n        FEED0 = IReserveFeed(_feeds[0]);\n        FEED1 = IReserveFeed(_feeds[1]);\n        FEED2 = IReserveFeed(_feeds[2]);\n    }\n\n    /**\n     * @dev queries values from whitelisted data feeds and calculates\n     *      the min. Does not include the protocol exchange rate.\n     * @notice if quorum isn't met, should revert\n     */\n    function _aggregate(uint8 _ILK_INDEX) internal view returns (uint256 val) {\n        if (QUORUM == 0) {\n            return type(uint256).max;\n        } else if (QUORUM == 1) {\n            val = IReserveFeed(FEED0).getExchangeRate(_ILK_INDEX);\n        } else if (QUORUM == 2) {\n            uint256 feed0ExchangeRate = IReserveFeed(FEED0).getExchangeRate(_ILK_INDEX);\n            uint256 feed1ExchangeRate = IReserveFeed(FEED1).getExchangeRate(_ILK_INDEX);\n            val = ((feed0ExchangeRate + feed1ExchangeRate) / uint256(QUORUM));\n        } else if (QUORUM == 3) {\n            uint256 feed0ExchangeRate = IReserveFeed(FEED0).getExchangeRate(_ILK_INDEX);\n            uint256 feed1ExchangeRate = IReserveFeed(FEED1).getExchangeRate(_ILK_INDEX);\n            uint256 feed2ExchangeRate = IReserveFeed(FEED2).getExchangeRate(_ILK_INDEX);\n            val = ((feed0ExchangeRate + feed1ExchangeRate + feed2ExchangeRate) / uint256(QUORUM));\n        }\n    }\n\n    // bound the final reported value between the min and the max\n    function _bound(uint256 value, uint256 min, uint256 max) internal pure returns (uint256) {\n        return Math.max(min, Math.min(max, value));\n    }\n\n    function _initializeExchangeRate() internal {\n        currentExchangeRate = Math.min(_getProtocolExchangeRate(), _aggregate(ILK_INDEX));\n        if (currentExchangeRate == 0) {\n            revert InvalidInitialization(currentExchangeRate);\n        }\n    }\n\n    // @dev Takes the minimum between the aggregated values and the protocol exchange rate,\n    // then bounds it up to the maximum change and writes the bounded value to the state.\n    // NOTE: keepers should call this update to reflect recent values\n    function updateExchangeRate() public {\n        uint256 _currentExchangeRate = currentExchangeRate;\n\n        uint256 minimum = Math.min(_getProtocolExchangeRate(), _aggregate(ILK_INDEX));\n        uint256 diff = _currentExchangeRate.rayMulDown(MAX_CHANGE);\n\n        uint256 bounded = _bound(minimum, _currentExchangeRate - diff, _currentExchangeRate + diff);\n        currentExchangeRate = bounded;\n\n        emit UpdateExchangeRate(bounded);\n    }\n}"
    }
  ]
}