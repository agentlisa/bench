{
  "Title": "[M-16] WithdrawProxy allows `redeem()` to be called before withdraw reserves are transferred in",
  "Content": "\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/WithdrawProxy.sol#L152-L161>\n\nThe WithdrawProxy contract has the `onlyWhenNoActiveAuction` modifier on the `withdraw()` and `redeem()` functions. This modifier stops these functions from being called when an auction is active:\n\n    modifier onlyWhenNoActiveAuction() {\n      WPStorage storage s = _loadSlot();\n      if (s.finalAuctionEnd != 0) {\n        revert InvalidState(InvalidStates.NOT_CLAIMED);\n      }\n      _;\n    }\n\nFurthermore, both `withdraw()` and `redeem()` can only be called when `totalAssets() > 0` based on logic within those functions.\n\nThe intention of these two checks is that the WithdrawProxy shares can only be cashed out after the PublicVault has called `transferWithdrawReserve`.\n\nHowever, because `s.finalAuctionEnd == 0` before an auction has started, and `totalAssets()` is calculated by taking the balance of the contract directly (`ERC20(asset()).balanceOf(address(this));`), a user may redeem their shares before the vault has been fully funded, and take less than their share of the balance, benefiting the other withdrawer.\n\n### Proof of Concept\n\n*   A depositor decides to withdraw from the PublicVault and receives WithdrawProxy shares in return\n*   A malicious actor deposits a small amount of the underlying asset into the WithdrawProxy, making `totalAssets() > 0`\n*   The depositor accidentally redeems, or is tricked into redeeming, from the WithdrawProxy, getting only a share of the small amount of the underlying asset rather than their share of the full withdrawal\n*   PublicVault properly processes epoch and full withdrawReserve is sent to WithdrawProxy\n*   All remaining holders of WithdrawProxy shares receive an outsized share of the withdrawReserve\n\n### Recommended Mitigation Steps\n\nAdd an additional storage variable that is explicitly switched to `open` when it is safe to withdraw funds.\n\n**[SantiagoGregory (Astaria) acknowledged and commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/358#issuecomment-1412910031):**\n > This is intentional, the UI will block people from redeeming early. The option is there both to save some gas, and as a last resort if an LP urgently needs money (it will only make it better for the rest of the LPs).\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/358#issuecomment-1441319563):**\n > I do consider this a valid medium severity issue, considering there is the `onlyWhenNoActiveAuction` so the intent of the code is not to block people from redeeming early but to prevent them from doing so. Note that the sponsor is right to highlight that it could be desirable to have an `emergencyRedeemFunction` where LPs do not wait for the completion of auctions.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-01-astaria",
  "Code": [
    {
      "filename": "src/WithdrawProxy.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**                                                     \n*  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗ \n* ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n* ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n* ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n* ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n* ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n*\n* Astaria Labs, Inc\n*/\n\npragma solidity =0.8.17;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\nimport {ERC4626Cloned} from \"gpl/ERC4626-Cloned.sol\";\nimport {WithdrawVaultBase} from \"core/WithdrawVaultBase.sol\";\nimport {IWithdrawProxy} from \"core/interfaces/IWithdrawProxy.sol\";\nimport {PublicVault} from \"core/PublicVault.sol\";\nimport {IERC20Metadata} from \"core/interfaces/IERC20Metadata.sol\";\nimport {IERC4626} from \"core/interfaces/IERC4626.sol\";\n\n/**\n * @title WithdrawProxy\n * @notice This contract collects funds for liquidity providers who are exiting. When a liquidity provider is the first\n * in an epoch to mark that they would like to withdraw their funds, a WithdrawProxy for the liquidity provider's\n * PublicVault is deployed to collect loan repayments until the end of the next epoch. Users are minted WithdrawTokens\n * according to their balance in the protocol which are redeemable 1:1 for the underlying PublicVault asset by the end\n * of the next epoch.\n *\n */\n\ncontract WithdrawProxy is ERC4626Cloned, WithdrawVaultBase {\n  using SafeTransferLib for ERC20;\n  using FixedPointMathLib for uint256;\n  using SafeCastLib for uint256;\n\n  event Claimed(\n    address withdrawProxy,\n    uint256 withdrawProxyAmount,\n    address publicVault,\n    uint256 publicVaultAmount\n  );\n\n  uint256 private constant WITHDRAW_PROXY_SLOT =\n    uint256(keccak256(\"xyz.astaria.WithdrawProxy.storage.location\")) - 1;\n\n  struct WPStorage {\n    uint88 withdrawRatio;\n    uint88 expected; // The sum of the remaining debt (amountOwed) accrued against the NFT at the timestamp when it is liquidated. yIntercept (virtual assets) of a PublicVault are not modified on liquidation, only once an auction is completed.\n    uint40 finalAuctionEnd; // when this is deleted, we know the final auction is over\n    uint256 withdrawReserveReceived; // amount received from PublicVault. The WETH balance of this contract - withdrawReserveReceived = amount received from liquidations.\n  }\n\n  enum InvalidStates {\n    PROCESS_EPOCH_NOT_COMPLETE,\n    FINAL_AUCTION_NOT_OVER,\n    NOT_CLAIMED,\n    CANT_CLAIM\n  }\n  error InvalidState(InvalidStates);\n\n  function minDepositAmount()\n    public\n    view\n    virtual\n    override(ERC4626Cloned)\n    returns (uint256)\n  {\n    return 0;\n  }\n\n  function decimals() public pure override returns (uint8) {\n    return 18;\n  }\n\n  function asset()\n    public\n    pure\n    override(ERC4626Cloned, WithdrawVaultBase)\n    returns (address)\n  {\n    return super.asset();\n  }\n\n  function totalAssets()\n    public\n    view\n    override(ERC4626Cloned, IERC4626)\n    returns (uint256)\n  {\n    return ERC20(asset()).balanceOf(address(this));\n  }\n\n  /**\n   * @notice Public view function to return the name of this WithdrawProxy.\n   * @return The name of this WithdrawProxy.\n   */\n  function name()\n    public\n    view\n    override(IERC20Metadata, WithdrawVaultBase)\n    returns (string memory)\n  {\n    return\n      string(abi.encodePacked(\"AST-WithdrawVault-\", ERC20(asset()).symbol()));\n  }\n\n  /**\n   * @notice Public view function to return the symbol of this WithdrawProxy.\n   * @return The symbol of this WithdrawProxy.\n   */\n  function symbol()\n    public\n    view\n    override(IERC20Metadata, WithdrawVaultBase)\n    returns (string memory)\n  {\n    return\n      string(abi.encodePacked(\"AST-W\", VAULT(), \"-\", ERC20(asset()).symbol()));\n  }\n\n  /**\n   * @notice Mints WithdrawTokens for withdrawing liquidity providers, redeemable by the end of the next epoch.\n   * @param receiver The receiver of the Withdraw Tokens.\n   * @param shares The number of shares to mint.\n   */\n  function mint(uint256 shares, address receiver)\n    public\n    virtual\n    override(ERC4626Cloned, IERC4626)\n    returns (uint256 assets)\n  {\n    require(msg.sender == VAULT(), \"only vault can mint\");\n    _mint(receiver, shares);\n    return shares;\n  }\n\n  function deposit(uint256 assets, address receiver)\n    public\n    virtual\n    override(ERC4626Cloned, IERC4626)\n    returns (uint256 shares)\n  {\n    revert NotSupported();\n  }\n\n  modifier onlyWhenNoActiveAuction() {\n    WPStorage storage s = _loadSlot();\n    // If auction funds have been collected to the WithdrawProxy\n    // but the PublicVault hasn't claimed its share, too much money will be sent to LPs\n    if (s.finalAuctionEnd != 0) {\n      // if finalAuctionEnd is 0, no auctions were added\n      revert InvalidState(InvalidStates.NOT_CLAIMED);\n    }\n    _;\n  }\n\n  function withdraw(\n    uint256 assets,\n    address receiver,\n    address owner\n  )\n    public\n    virtual\n    override(ERC4626Cloned, IERC4626)\n    onlyWhenNoActiveAuction\n    returns (uint256 shares)\n  {\n    return super.withdraw(assets, receiver, owner);\n  }\n\n  /**\n   * @notice Redeem funds collected in the WithdrawProxy.\n   * @param shares The number of WithdrawToken shares to redeem.\n   * @param receiver The receiver of the underlying asset.\n   * @param owner The owner of the WithdrawTokens.\n   * @return assets The amount of the underlying asset redeemed.\n   */\n  function redeem(\n    uint256 shares,\n    address receiver,\n    address owner\n  )\n    public\n    virtual\n    override(ERC4626Cloned, IERC4626)\n    onlyWhenNoActiveAuction\n    returns (uint256 assets)\n  {\n    return super.redeem(shares, receiver, owner);\n  }\n\n  function supportsInterface(bytes4 interfaceId)\n    external\n    view\n    virtual\n    returns (bool)\n  {\n    return interfaceId == type(IWithdrawProxy).interfaceId;\n  }\n\n  function _loadSlot() internal pure returns (WPStorage storage s) {\n    uint256 slot = WITHDRAW_PROXY_SLOT;\n\n    assembly {\n      s.slot := slot\n    }\n  }\n\n  function getFinalAuctionEnd() public view returns (uint256) {\n    WPStorage storage s = _loadSlot();\n    return s.finalAuctionEnd;\n  }\n\n  function getWithdrawRatio() public view returns (uint256) {\n    WPStorage storage s = _loadSlot();\n    return s.withdrawRatio;\n  }\n\n  function getExpected() public view returns (uint256) {\n    WPStorage storage s = _loadSlot();\n    return s.expected;\n  }\n\n  modifier onlyVault() {\n    require(msg.sender == VAULT(), \"only vault can call\");\n    _;\n  }\n\n  function increaseWithdrawReserveReceived(uint256 amount) external onlyVault {\n    WPStorage storage s = _loadSlot();\n    s.withdrawReserveReceived += amount;\n  }\n\n  function claim() public {\n    WPStorage storage s = _loadSlot();\n\n    if (s.finalAuctionEnd == 0) {\n      revert InvalidState(InvalidStates.CANT_CLAIM);\n    }\n\n    if (PublicVault(VAULT()).getCurrentEpoch() < CLAIMABLE_EPOCH()) {\n      revert InvalidState(InvalidStates.PROCESS_EPOCH_NOT_COMPLETE);\n    }\n    if (block.timestamp < s.finalAuctionEnd) {\n      revert InvalidState(InvalidStates.FINAL_AUCTION_NOT_OVER);\n    }\n\n    uint256 transferAmount = 0;\n    uint256 balance = ERC20(asset()).balanceOf(address(this)) -\n      s.withdrawReserveReceived; // will never underflow because withdrawReserveReceived is always increased by the transfer amount from the PublicVault\n\n    if (balance < s.expected) {\n      PublicVault(VAULT()).decreaseYIntercept(\n        (s.expected - balance).mulWadDown(1e18 - s.withdrawRatio)\n      );\n    } else {\n      PublicVault(VAULT()).increaseYIntercept(\n        (balance - s.expected).mulWadDown(1e18 - s.withdrawRatio)\n      );\n    }\n\n    if (s.withdrawRatio == uint256(0)) {\n      ERC20(asset()).safeTransfer(VAULT(), balance);\n    } else {\n      transferAmount = uint256(s.withdrawRatio).mulDivDown(\n        balance,\n        10**ERC20(asset()).decimals()\n      );\n\n      unchecked {\n        balance -= transferAmount;\n      }\n\n      if (balance > 0) {\n        ERC20(asset()).safeTransfer(VAULT(), balance);\n      }\n    }\n    s.finalAuctionEnd = 0;\n\n    emit Claimed(address(this), transferAmount, VAULT(), balance);\n  }\n\n  function drain(uint256 amount, address withdrawProxy)\n    public\n    onlyVault\n    returns (uint256)\n  {\n    uint256 balance = ERC20(asset()).balanceOf(address(this));\n    if (amount > balance) {\n      amount = balance;\n    }\n    ERC20(asset()).safeTransfer(withdrawProxy, amount);\n    return amount;\n  }\n\n  function setWithdrawRatio(uint256 liquidationWithdrawRatio) public onlyVault {\n    _loadSlot().withdrawRatio = liquidationWithdrawRatio.safeCastTo88();\n  }\n\n  function handleNewLiquidation(\n    uint256 newLienExpectedValue,\n    uint256 finalAuctionDelta\n  ) public onlyVault {\n    WPStorage storage s = _loadSlot();\n\n    unchecked {\n      s.expected += newLienExpectedValue.safeCastTo88();\n      uint40 auctionEnd = (block.timestamp + finalAuctionDelta).safeCastTo40();\n      if (auctionEnd > s.finalAuctionEnd) s.finalAuctionEnd = auctionEnd;\n    }\n  }\n}"
    }
  ]
}