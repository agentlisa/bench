{
  "Title": "[M-03] SuperVault's leverageSwap and emptyVaultOperation can become stuck",
  "Content": "_Submitted by hyh, also found by cccz, berndartmueller, delfin454000, joestakey, robee, defsec, and 0xDjango_\n\n<https://github.com/code-423n4/2022-04-mimo/blob/b18670f44d595483df2c0f76d1c57a7bfbfbc083/supervaults/contracts/SuperVault.sol#L320-L326>\n\n<https://github.com/code-423n4/2022-04-mimo/blob/b18670f44d595483df2c0f76d1c57a7bfbfbc083/supervaults/contracts/SuperVault.sol#L198-L199>\n\nleverageSwap and emptyVaultOperation can be run repeatedly for the same tokens. If these tokens happen to be an ERC20 that do not allow for approval of positive amount when allowance already positive, both functions can become stuck.\n\n<https://github.com/d-xo/weird-erc20#approval-race-protections>\n\nIn both cases, logic doesn't seem to guarantee full usage of the allowance given. If it's not used fully, the token will revert each next approve attempt, which will render the functions unavailable for the token.\n\nWhile emptyVaultOperation can be cured by emptying the balance and rerun, in the leverageSwap case there is no such fix possible.\n\nSetting severity to medium as this clearly impacts leverageSwap and emptyVaultOperation availability to the users.\n\n### Proof of Concept\n\nleverageSwap calls target token for maximum approval of core each time:\n\n<https://github.com/code-423n4/2022-04-mimo/blob/b18670f44d595483df2c0f76d1c57a7bfbfbc083/supervaults/contracts/SuperVault.sol#L320-L326>\n\n```solidity\n  ///@param token The leveraged asset to swap PAR for\n  function leverageSwap(bytes memory params, IERC20 token) internal {\n    (uint256 parToSell, bytes memory dexTxData, uint dexIndex) = abi.decode(\n      params,\n      (uint256, bytes, uint )\n    );\n    token.approve(address(a.core()), 2**256 - 1);\n```\n\nSome tokens do not have maximum amount as an exception, simply reverting any attempt to approve positive from positive, for example current USDT contract, L205:\n\n<https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code>\n\nI.e. if leverageSwap be run again with USDT it will revert all the times after the first.\n\nemptyVaultOperation approves core for the whole balance of stablex:\n\n<https://github.com/code-423n4/2022-04-mimo/blob/b18670f44d595483df2c0f76d1c57a7bfbfbc083/supervaults/contracts/SuperVault.sol#L198-L199>\n\n```solidity\n    IERC20 par = IERC20(a.stablex());\n    par.approve(address(a.core()), par.balanceOf(address(this)));\n```\n\n### Recommended Mitigation Steps\n\nConsider adding zero amount approval before actual amount approval, i.e. force zero allowance before current approval.\n\n**[m19 (Mimo DeFi) acknowledged](https://github.com/code-423n4/2022-04-mimo-findings/issues/145)**\n\n**[gzeoneth (judge) commented](https://github.com/code-423n4/2022-04-mimo-findings/issues/145#issuecomment-1146831466):**\n > Having `approve(0)` first will still revert with USDT because the interface expect it to return a bool but USDT return void. Fund also won't be stuck because it will revert. Judging as Med Risk as function availability could be impacted. Unlike the core protocol, `SuperVault` can take any token as input and USDT is listed on various lending protocol like AAVE.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-04-mimo-defi-contest",
  "Code": [
    {
      "filename": "supervaults/contracts/SuperVault.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.8.10;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport { IPool } from \"@aave/core-v3/contracts/interfaces/IPool.sol\";\n\nimport \"./interfaces/IAddressProvider.sol\";\nimport \"./interfaces/IGovernanceAddressProvider.sol\";\nimport \"./interfaces/IVaultsCore.sol\";\nimport \"./interfaces/IGenericMiner.sol\";\nimport \"./interfaces/IDexAddressProvider.sol\";\n\n/// @title A parallel protocol vault with added functionality\n/// @notice You can use this for collateral rebalancing\n/// @dev This contract should be cloned and initialized with a SuperVaultFactory contract\ncontract SuperVault is AccessControl, Initializable {\n  enum Operation {\n    LEVERAGE,\n    REBALANCE,\n    EMPTY\n  }\n\n  struct AggregatorRequest {\n    uint256 parToSell;\n    bytes dexTxData;\n    uint dexIndex;\n  }\n\n  IAddressProvider public a;\n  IGovernanceAddressProvider public ga;\n  IPool public lendingPool;\n  IDexAddressProvider internal _dexAP;\n\n  modifier onlyOwner() {\n    require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"SV001\");\n    _;\n  }\n\n  ///@notice Initializes the Supervault contract\n  ///@dev This replaces the constructor function as in the factory design pattern\n  ///@param _a The address of the protocol's AddressProvider\n  ///@param _ga The address of the protocol's GovernanceAddressProvider\n  ///@param _lendingPool The address of the lendingPool from where flashLoans are taken\n  ///@param _owner The owner of this SuperVault contract\n  function initialize(\n    IAddressProvider _a,\n    IGovernanceAddressProvider _ga,\n    IPool _lendingPool,\n    address _owner,\n    IDexAddressProvider dexAP\n  ) external initializer {\n    require(address(_a) != address(0));\n    require(address(_ga) != address(0));\n    require(address(_lendingPool) != address(0));\n    require(address(dexAP) != address(0));\n\n    a = _a;\n    ga = _ga;\n    lendingPool = _lendingPool;\n    _dexAP = dexAP;\n\n    _setupRole(DEFAULT_ADMIN_ROLE, _owner);\n  }\n\n  ///@notice Routes a call from a flashloan pool to a leverage or rebalance operation\n  ///@dev This Integrates with AAVE V2 flashLoans\n  ///@dev This function is called by the lendingPool during execution of the leverage function\n  ///@param assets An address array with one element corresponding to the address of the leveraged or rebalanced asset\n  ///@param amounts A uint array with one element corresponding to the amount of the leveraged or rebalanced asset\n  ///@param premiums A uint array with one element corresponding to the flashLoan fees\n  ///@param params Bytes sent by the leverage or rebalance function that contains information on the aggregator swap\n  function executeOperation(\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address,\n    bytes calldata params\n  ) external returns (bool) {\n    require(msg.sender == address(lendingPool), \"SV002\");\n    (Operation operation, bytes memory operationParams) = abi.decode(params, (Operation, bytes));\n    IERC20 asset = IERC20(assets[0]);\n    uint256 flashloanRepayAmount = amounts[0] + premiums[0];\n    if (operation == Operation.LEVERAGE) {\n      leverageOperation(asset, flashloanRepayAmount, operationParams);\n    }\n    if (operation == Operation.REBALANCE) {\n      rebalanceOperation(asset, amounts[0], flashloanRepayAmount, operationParams);\n    }\n    if (operation == Operation.EMPTY) {\n      emptyVaultOperation(asset, amounts[0], flashloanRepayAmount, operationParams);\n    }\n\n    asset.approve(address(lendingPool), flashloanRepayAmount);\n    return true;\n  }\n\n  ///@notice Used by executeOperation to call an aggregator to swap and deposit the swapped asset into a vault\n  function leverageOperation(\n    IERC20 token,\n    uint256 flashloanRepayAmount,\n    bytes memory params\n  ) internal {\n    leverageSwap(params, token);\n\n    require(token.balanceOf(address(this)) >= flashloanRepayAmount, \"SV101\");\n    a.core().deposit(address(token), token.balanceOf(address(this)) - flashloanRepayAmount);\n  }\n\n  ///@notice Leverage an asset using a flashloan to balance collateral\n  ///@dev This uses an AAVE V2 flashLoan that will call executeOperation\n  ///@param asset The address of the asset to leverage\n  ///@param depositAmount The initial starting amount, e.g. 1 ETH\n  ///@param borrowAmount The amount to be borrowed, e.g. 2 ETH, bringing the total to 3 ETH\n  ///@param parToSell The amount of PAR we'll borrow so we can repay the leverage\n  ///@param dexTxData Bytes that will be passed to executeOperation that encodes args for the aggregator Swap\n  ///@param dexIndex DexAddressProvider index of the aggregator to be used for selling PAR, either OneInch or Paraswap\n  function leverage(\n    address asset,\n    uint256 depositAmount, //\n    uint256 borrowAmount, //\n    uint256 parToSell, //\n    bytes calldata dexTxData,\n    uint dexIndex \n  ) external onlyOwner {\n    IERC20(asset).transferFrom(msg.sender, address(this), depositAmount);\n    bytes memory leverageParams = abi.encode(parToSell, dexTxData, dexIndex);\n    bytes memory params = abi.encode(Operation.LEVERAGE, leverageParams);\n    takeFlashLoan(asset, borrowAmount, params);\n    checkAndSendMIMO();\n  }\n\n  ///@notice Used by executeOperation to flashloan an asset, call an aggregator to swap for toAsset, and then rebalance the vault\n  function rebalanceOperation(\n    IERC20 fromCollateral,\n    uint256 amount,\n    uint256 flashloanRepayAmount,\n    bytes memory params\n  ) internal {\n    (uint256 vaultId, address toCollateral, uint256 parAmount, bytes memory dexTxData, uint dexIndex) = abi\n      .decode(params, (uint256, address, uint256, bytes, uint ));\n    aggregatorSwap(dexIndex, fromCollateral, amount, dexTxData);\n\n    uint256 depositAmount = IERC20(toCollateral).balanceOf(address(this));\n\n    IERC20(toCollateral).approve(address(a.core()), depositAmount);\n\n    a.core().depositAndBorrow(toCollateral, depositAmount, parAmount);\n    a.core().repay(vaultId, parAmount);\n\n    a.core().withdraw(vaultId, flashloanRepayAmount);\n\n    require(fromCollateral.balanceOf(address(this)) >= flashloanRepayAmount, \"SV101\");\n  }\n\n  ///@notice Uses a flashloan to exchange one collateral type for another, e.g. to hold less volatile collateral\n  ///@notice Both collateral vaults must have been created by this contract using the depositToVault or depositAndBorrowFromVault functions\n  ///@dev This uses an AAVE V2 flashLoan that will call executeOperation\n  ///@param vaultId The Id of the vault to reduce the collateral of\n  ///@param toCollateral Address of the collateral to rebalance to\n  ///@param fromCollateral Address of the starting collateral that will be reduced\n  ///@param fromCollateralAmount Amount of starting collateral to deleverage\n  ///@param parAmount Amount of par that will be deposited to exchange for\n  ///@param dexTxData Bytes that will be passed to executeOperation that encodes args for the aggregator Swap\n  ///@param dexIndex DexAddressProvider index representing the aggregator to be used for selling PAR, either OneInch or Paraswap\n  function rebalance(\n    uint256 vaultId, // vaultId to deleverage\n    address toCollateral,\n    address fromCollateral, // save some gas by just passing in collateral type instead of querying VaultsDataProvider for it\n    uint256 fromCollateralAmount, // amount of collateral to reduce in main vault and borrow from Aave first\n    uint256 parAmount, // amount of PAR to repay and deleverage\n    bytes calldata dexTxData,\n    uint dexIndex \n  ) external onlyOwner {\n    bytes memory rebalanceParams = abi.encode(vaultId, toCollateral, parAmount, dexTxData, dexIndex);\n    bytes memory params = abi.encode(Operation.REBALANCE, rebalanceParams);\n\n    takeFlashLoan(fromCollateral, fromCollateralAmount, params);\n    checkAndSendMIMO();\n  }\n\n  ///@notice Used by executeOperation to repay all debt for a vault, withdraw collateral from the vault, and send the collateral back to the user\n  ///@notice There will likely be some leftover par after repaying the loan; that will also be sent back to the user\n  function emptyVaultOperation(\n    IERC20 vaultCollateral,\n    uint256 amount,\n    uint256 flashloanRepayAmount,\n    bytes memory params\n  ) internal {\n    // Use par to repay debt\n    (uint256 vaultId, bytes memory dexTxData, uint dexIndex) = abi.decode(params, (uint256, bytes, uint));\n\n    aggregatorSwap(dexIndex, vaultCollateral, amount, dexTxData); // swap assets for par to repay back loan\n\n    IERC20 par = IERC20(a.stablex());\n    par.approve(address(a.core()), par.balanceOf(address(this)));\n\n    // Repay the par debt\n    a.core().repayAll(vaultId);\n    uint256 vaultBalance = a.vaultsData().vaultCollateralBalance(vaultId);\n    // Withdraw all collateral\n    a.core().withdraw(vaultId, vaultBalance);\n\n    require(vaultCollateral.balanceOf(address(this)) >= flashloanRepayAmount, \"SV101\");\n  }\n\n  ///@notice Uses a flashloan to repay all debts for a vault and send all collateral in the vault to the owner\n  ///@notice This vault must have been created by this contract\n  ///@dev This uses an AAVE V2 flashLoan that will call executeOperation\n  ///@param vaultId The Id of the vault to empty\n  ///@param collateralType Address of the collateral of the vault\n  ///@param repayAmount Amount of par that needs to be repaid before all collateral can be withdrawn\n  ///@param dexTxData Bytes that contain the low-level call to swap the vault asset for par to repay the vault loan\n  ///@param dexIndex Index to use for swapping the vault collateral for par\n  function emptyVault(\n    uint256 vaultId,\n    address collateralType,\n    uint256 repayAmount, // Amount, in collateral type, needed to borrow to repay current vault debt\n    bytes calldata dexTxData,\n    uint dexIndex \n  ) external onlyOwner {\n    // Flashloan collateral and swap for par to repay any outstanding vault debt\n    bytes memory emptyVaultParams = abi.encode(vaultId, dexTxData, dexIndex);\n    bytes memory params = abi.encode(Operation.EMPTY, emptyVaultParams);\n    takeFlashLoan(collateralType, repayAmount, params);\n\n    checkAndSendMIMO();\n\n    // Send remaining par, mimo, and collateral back to the owner\n    require(IERC20(a.stablex()).transfer(msg.sender, IERC20(a.stablex()).balanceOf(address(this))));\n    checkAndSendMIMO();\n\n    IERC20 collateral = IERC20(collateralType);\n    collateral.transfer(msg.sender, collateral.balanceOf(address(this)));\n  }\n\n  ///@notice Withdraw collateral from a vault\n  ///@notice Vault must have been created through leverage, depositToVault, or depositAndBorrowFromVault from this contract\n  ///@param vaultId The ID of the vault to withdraw from\n  ///@param amount The amount of collateral to withdraw\n  function withdrawFromVault(uint256 vaultId, uint256 amount) external onlyOwner {\n    a.core().withdraw(vaultId, amount);\n    IERC20 asset = IERC20(a.vaultsData().vaultCollateralType(vaultId));\n    require(asset.transfer(msg.sender, amount));\n  }\n\n  ///@notice Borrow PAR from a vault\n  ///@param vaultId The ID of the vault to borrow from\n  ///@param amount The amount of PAR to borrow\n  function borrowFromVault(uint256 vaultId, uint256 amount) external onlyOwner {\n    a.core().borrow(vaultId, amount);\n    require(IERC20(a.stablex()).transfer(msg.sender, IERC20(a.stablex()).balanceOf(address(this))));\n    checkAndSendMIMO();\n  }\n\n  ///@notice Withdraw all of one type of collateral from this contract\n  ///@notice Can only be used on vaults which have been created by this contract\n  ///@param asset The address of the collateral type\n  function withdrawAsset(address asset) external onlyOwner {\n    IERC20 token = IERC20(asset);\n    require(token.transfer(msg.sender, token.balanceOf(address(this))));\n  }\n\n  ///@notice Deposit collateral into a vault\n  ///@notice Requires approval of asset for amount before calling\n  ///@param asset Address of the collateral type\n  ///@param amount Amount to deposit\n  function depositToVault(address asset, uint256 amount) external {\n    IERC20 token = IERC20(asset);\n    token.approve(address(a.core()), amount);\n    token.transferFrom(msg.sender, address(this), amount);\n    a.core().deposit(asset, amount);\n  }\n\n  ///@notice Deposit collateral into a vault and borrow PAR\n  ///@notice Requires approval of asset for amount before calling\n  ///@param asset Address of the collateral type\n  ///@param depositAmount Amount to deposit\n  ///@param borrowAmount Amount of PAR to borrow after depositing\n  function depositAndBorrowFromVault(\n    address asset,\n    uint256 depositAmount,\n    uint256 borrowAmount\n  ) external onlyOwner {\n    IERC20 token = IERC20(asset);\n    token.approve(address(a.core()), depositAmount);\n    token.transferFrom(msg.sender, address(this), depositAmount);\n    a.core().depositAndBorrow(asset, depositAmount, borrowAmount);\n    require(IERC20(a.stablex()).transfer(msg.sender, IERC20(a.stablex()).balanceOf(address(this)))); //par\n    checkAndSendMIMO();\n  }\n\n  ///@notice Release MIMO from a MIMO miner to the owner\n  ///@param minerAddress The address of the MIMO miner\n  function releaseMIMO(address minerAddress) external payable onlyOwner {\n    IGenericMiner miner = IGenericMiner(minerAddress);\n    miner.releaseMIMO(address(this));\n    checkAndSendMIMO();\n  }\n\n  ///@notice Wrap ETH and deposit WETH as collateral into a vault\n  function depositETHToVault() external payable {\n    a.core().depositETH{ value: msg.value }();\n  }\n\n  ///@notice Wrap ETH and deposit WETH as collateral into a vault, then borrow PAR from vault\n  ///@param borrowAmount The amount of PAR to borrow after depositing ETH\n  function depositETHAndBorrowFromVault(uint256 borrowAmount) external payable onlyOwner {\n    a.core().depositETHAndBorrow{ value: msg.value }(borrowAmount);\n    require(IERC20(a.stablex()).transfer(msg.sender, IERC20(a.stablex()).balanceOf(address(this)))); //par\n    checkAndSendMIMO();\n  }\n\n  ///@notice Helper function to call an aggregator to swap PAR for a leveraged asset\n  ///@dev This helper function is used to limit the number of local variables in the leverageOperation function\n  ///@param params The params passed from the leverageOperation function for the aggregator call\n  ///@param token The leveraged asset to swap PAR for\n  function leverageSwap(bytes memory params, IERC20 token) internal {\n    (uint256 parToSell, bytes memory dexTxData, uint dexIndex) = abi.decode(\n      params,\n      (uint256, bytes, uint )\n    );\n    token.approve(address(a.core()), 2**256 - 1);\n    a.core().depositAndBorrow(address(token), token.balanceOf(address(this)), parToSell);\n    IERC20 par = IERC20(a.stablex());\n    aggregatorSwap(dexIndex, par, parToSell, dexTxData);\n  }\n\n  ///@notice Helper function to approve and swap an asset using an aggregator\n  ///@param dexIndex The DexAddressProvider index of aggregator to use to swap\n  ///@param token The starting token to swap for another asset\n  ///@param amount The amount of starting token to swap for\n  ///@param dexTxData The low-level data to call the aggregator with\n  function aggregatorSwap(\n    uint256 dexIndex,\n    IERC20 token,\n    uint256 amount,\n    bytes memory dexTxData\n  ) internal {\n    (address proxy, address router) = _dexAP.dexMapping(dexIndex);\n    require(proxy != address(0) && router != address(0), \"SV201\"); \n    token.approve(proxy, amount);\n    router.call(dexTxData);\n  }\n\n  ///@notice Helper function to format arguments to take a flashloan\n  ///@dev The flashloan call will call the executeOperation function on this contract\n  ///@param asset The address of the asset to loan\n  ///@param amount The amount to borrow\n  ///@param params The params that will be sent to executeOperation after the asset is borrowed\n  function takeFlashLoan(\n    address asset,\n    uint256 amount,\n    bytes memory params\n  ) internal {\n    uint8 referralCode;\n    address[] memory assets = new address[](1);\n    uint256[] memory amounts = new uint256[](1);\n    uint256[] memory modes = new uint256[](1);\n    (assets[0], amounts[0]) = (asset, amount);\n    lendingPool.flashLoan(address(this), assets, amounts, modes, address(this), params, referralCode);\n  }\n\n  ///@notice Helper function to transfer all MIMO owned by this contract to the Owner\n  function checkAndSendMIMO() internal {\n    if (ga.mimo().balanceOf(address(this)) > 0) {\n      require(ga.mimo().transfer(msg.sender, ga.mimo().balanceOf(address(this))));\n    }\n  }\n}"
    },
    {
      "filename": "supervaults/contracts/SuperVault.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.8.10;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport { IPool } from \"@aave/core-v3/contracts/interfaces/IPool.sol\";\n\nimport \"./interfaces/IAddressProvider.sol\";\nimport \"./interfaces/IGovernanceAddressProvider.sol\";\nimport \"./interfaces/IVaultsCore.sol\";\nimport \"./interfaces/IGenericMiner.sol\";\nimport \"./interfaces/IDexAddressProvider.sol\";\n\n/// @title A parallel protocol vault with added functionality\n/// @notice You can use this for collateral rebalancing\n/// @dev This contract should be cloned and initialized with a SuperVaultFactory contract\ncontract SuperVault is AccessControl, Initializable {\n  enum Operation {\n    LEVERAGE,\n    REBALANCE,\n    EMPTY\n  }\n\n  struct AggregatorRequest {\n    uint256 parToSell;\n    bytes dexTxData;\n    uint dexIndex;\n  }\n\n  IAddressProvider public a;\n  IGovernanceAddressProvider public ga;\n  IPool public lendingPool;\n  IDexAddressProvider internal _dexAP;\n\n  modifier onlyOwner() {\n    require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"SV001\");\n    _;\n  }\n\n  ///@notice Initializes the Supervault contract\n  ///@dev This replaces the constructor function as in the factory design pattern\n  ///@param _a The address of the protocol's AddressProvider\n  ///@param _ga The address of the protocol's GovernanceAddressProvider\n  ///@param _lendingPool The address of the lendingPool from where flashLoans are taken\n  ///@param _owner The owner of this SuperVault contract\n  function initialize(\n    IAddressProvider _a,\n    IGovernanceAddressProvider _ga,\n    IPool _lendingPool,\n    address _owner,\n    IDexAddressProvider dexAP\n  ) external initializer {\n    require(address(_a) != address(0));\n    require(address(_ga) != address(0));\n    require(address(_lendingPool) != address(0));\n    require(address(dexAP) != address(0));\n\n    a = _a;\n    ga = _ga;\n    lendingPool = _lendingPool;\n    _dexAP = dexAP;\n\n    _setupRole(DEFAULT_ADMIN_ROLE, _owner);\n  }\n\n  ///@notice Routes a call from a flashloan pool to a leverage or rebalance operation\n  ///@dev This Integrates with AAVE V2 flashLoans\n  ///@dev This function is called by the lendingPool during execution of the leverage function\n  ///@param assets An address array with one element corresponding to the address of the leveraged or rebalanced asset\n  ///@param amounts A uint array with one element corresponding to the amount of the leveraged or rebalanced asset\n  ///@param premiums A uint array with one element corresponding to the flashLoan fees\n  ///@param params Bytes sent by the leverage or rebalance function that contains information on the aggregator swap\n  function executeOperation(\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address,\n    bytes calldata params\n  ) external returns (bool) {\n    require(msg.sender == address(lendingPool), \"SV002\");\n    (Operation operation, bytes memory operationParams) = abi.decode(params, (Operation, bytes));\n    IERC20 asset = IERC20(assets[0]);\n    uint256 flashloanRepayAmount = amounts[0] + premiums[0];\n    if (operation == Operation.LEVERAGE) {\n      leverageOperation(asset, flashloanRepayAmount, operationParams);\n    }\n    if (operation == Operation.REBALANCE) {\n      rebalanceOperation(asset, amounts[0], flashloanRepayAmount, operationParams);\n    }\n    if (operation == Operation.EMPTY) {\n      emptyVaultOperation(asset, amounts[0], flashloanRepayAmount, operationParams);\n    }\n\n    asset.approve(address(lendingPool), flashloanRepayAmount);\n    return true;\n  }\n\n  ///@notice Used by executeOperation to call an aggregator to swap and deposit the swapped asset into a vault\n  function leverageOperation(\n    IERC20 token,\n    uint256 flashloanRepayAmount,\n    bytes memory params\n  ) internal {\n    leverageSwap(params, token);\n\n    require(token.balanceOf(address(this)) >= flashloanRepayAmount, \"SV101\");\n    a.core().deposit(address(token), token.balanceOf(address(this)) - flashloanRepayAmount);\n  }\n\n  ///@notice Leverage an asset using a flashloan to balance collateral\n  ///@dev This uses an AAVE V2 flashLoan that will call executeOperation\n  ///@param asset The address of the asset to leverage\n  ///@param depositAmount The initial starting amount, e.g. 1 ETH\n  ///@param borrowAmount The amount to be borrowed, e.g. 2 ETH, bringing the total to 3 ETH\n  ///@param parToSell The amount of PAR we'll borrow so we can repay the leverage\n  ///@param dexTxData Bytes that will be passed to executeOperation that encodes args for the aggregator Swap\n  ///@param dexIndex DexAddressProvider index of the aggregator to be used for selling PAR, either OneInch or Paraswap\n  function leverage(\n    address asset,\n    uint256 depositAmount, //\n    uint256 borrowAmount, //\n    uint256 parToSell, //\n    bytes calldata dexTxData,\n    uint dexIndex \n  ) external onlyOwner {\n    IERC20(asset).transferFrom(msg.sender, address(this), depositAmount);\n    bytes memory leverageParams = abi.encode(parToSell, dexTxData, dexIndex);\n    bytes memory params = abi.encode(Operation.LEVERAGE, leverageParams);\n    takeFlashLoan(asset, borrowAmount, params);\n    checkAndSendMIMO();\n  }\n\n  ///@notice Used by executeOperation to flashloan an asset, call an aggregator to swap for toAsset, and then rebalance the vault\n  function rebalanceOperation(\n    IERC20 fromCollateral,\n    uint256 amount,\n    uint256 flashloanRepayAmount,\n    bytes memory params\n  ) internal {\n    (uint256 vaultId, address toCollateral, uint256 parAmount, bytes memory dexTxData, uint dexIndex) = abi\n      .decode(params, (uint256, address, uint256, bytes, uint ));\n    aggregatorSwap(dexIndex, fromCollateral, amount, dexTxData);\n\n    uint256 depositAmount = IERC20(toCollateral).balanceOf(address(this));\n\n    IERC20(toCollateral).approve(address(a.core()), depositAmount);\n\n    a.core().depositAndBorrow(toCollateral, depositAmount, parAmount);\n    a.core().repay(vaultId, parAmount);\n\n    a.core().withdraw(vaultId, flashloanRepayAmount);\n\n    require(fromCollateral.balanceOf(address(this)) >= flashloanRepayAmount, \"SV101\");\n  }\n\n  ///@notice Uses a flashloan to exchange one collateral type for another, e.g. to hold less volatile collateral\n  ///@notice Both collateral vaults must have been created by this contract using the depositToVault or depositAndBorrowFromVault functions\n  ///@dev This uses an AAVE V2 flashLoan that will call executeOperation\n  ///@param vaultId The Id of the vault to reduce the collateral of\n  ///@param toCollateral Address of the collateral to rebalance to\n  ///@param fromCollateral Address of the starting collateral that will be reduced\n  ///@param fromCollateralAmount Amount of starting collateral to deleverage\n  ///@param parAmount Amount of par that will be deposited to exchange for\n  ///@param dexTxData Bytes that will be passed to executeOperation that encodes args for the aggregator Swap\n  ///@param dexIndex DexAddressProvider index representing the aggregator to be used for selling PAR, either OneInch or Paraswap\n  function rebalance(\n    uint256 vaultId, // vaultId to deleverage\n    address toCollateral,\n    address fromCollateral, // save some gas by just passing in collateral type instead of querying VaultsDataProvider for it\n    uint256 fromCollateralAmount, // amount of collateral to reduce in main vault and borrow from Aave first\n    uint256 parAmount, // amount of PAR to repay and deleverage\n    bytes calldata dexTxData,\n    uint dexIndex \n  ) external onlyOwner {\n    bytes memory rebalanceParams = abi.encode(vaultId, toCollateral, parAmount, dexTxData, dexIndex);\n    bytes memory params = abi.encode(Operation.REBALANCE, rebalanceParams);\n\n    takeFlashLoan(fromCollateral, fromCollateralAmount, params);\n    checkAndSendMIMO();\n  }\n\n  ///@notice Used by executeOperation to repay all debt for a vault, withdraw collateral from the vault, and send the collateral back to the user\n  ///@notice There will likely be some leftover par after repaying the loan; that will also be sent back to the user\n  function emptyVaultOperation(\n    IERC20 vaultCollateral,\n    uint256 amount,\n    uint256 flashloanRepayAmount,\n    bytes memory params\n  ) internal {\n    // Use par to repay debt\n    (uint256 vaultId, bytes memory dexTxData, uint dexIndex) = abi.decode(params, (uint256, bytes, uint));\n\n    aggregatorSwap(dexIndex, vaultCollateral, amount, dexTxData); // swap assets for par to repay back loan\n\n    IERC20 par = IERC20(a.stablex());\n    par.approve(address(a.core()), par.balanceOf(address(this)));\n\n    // Repay the par debt\n    a.core().repayAll(vaultId);\n    uint256 vaultBalance = a.vaultsData().vaultCollateralBalance(vaultId);\n    // Withdraw all collateral\n    a.core().withdraw(vaultId, vaultBalance);\n\n    require(vaultCollateral.balanceOf(address(this)) >= flashloanRepayAmount, \"SV101\");\n  }\n\n  ///@notice Uses a flashloan to repay all debts for a vault and send all collateral in the vault to the owner\n  ///@notice This vault must have been created by this contract\n  ///@dev This uses an AAVE V2 flashLoan that will call executeOperation\n  ///@param vaultId The Id of the vault to empty\n  ///@param collateralType Address of the collateral of the vault\n  ///@param repayAmount Amount of par that needs to be repaid before all collateral can be withdrawn\n  ///@param dexTxData Bytes that contain the low-level call to swap the vault asset for par to repay the vault loan\n  ///@param dexIndex Index to use for swapping the vault collateral for par\n  function emptyVault(\n    uint256 vaultId,\n    address collateralType,\n    uint256 repayAmount, // Amount, in collateral type, needed to borrow to repay current vault debt\n    bytes calldata dexTxData,\n    uint dexIndex \n  ) external onlyOwner {\n    // Flashloan collateral and swap for par to repay any outstanding vault debt\n    bytes memory emptyVaultParams = abi.encode(vaultId, dexTxData, dexIndex);\n    bytes memory params = abi.encode(Operation.EMPTY, emptyVaultParams);\n    takeFlashLoan(collateralType, repayAmount, params);\n\n    checkAndSendMIMO();\n\n    // Send remaining par, mimo, and collateral back to the owner\n    require(IERC20(a.stablex()).transfer(msg.sender, IERC20(a.stablex()).balanceOf(address(this))));\n    checkAndSendMIMO();\n\n    IERC20 collateral = IERC20(collateralType);\n    collateral.transfer(msg.sender, collateral.balanceOf(address(this)));\n  }\n\n  ///@notice Withdraw collateral from a vault\n  ///@notice Vault must have been created through leverage, depositToVault, or depositAndBorrowFromVault from this contract\n  ///@param vaultId The ID of the vault to withdraw from\n  ///@param amount The amount of collateral to withdraw\n  function withdrawFromVault(uint256 vaultId, uint256 amount) external onlyOwner {\n    a.core().withdraw(vaultId, amount);\n    IERC20 asset = IERC20(a.vaultsData().vaultCollateralType(vaultId));\n    require(asset.transfer(msg.sender, amount));\n  }\n\n  ///@notice Borrow PAR from a vault\n  ///@param vaultId The ID of the vault to borrow from\n  ///@param amount The amount of PAR to borrow\n  function borrowFromVault(uint256 vaultId, uint256 amount) external onlyOwner {\n    a.core().borrow(vaultId, amount);\n    require(IERC20(a.stablex()).transfer(msg.sender, IERC20(a.stablex()).balanceOf(address(this))));\n    checkAndSendMIMO();\n  }\n\n  ///@notice Withdraw all of one type of collateral from this contract\n  ///@notice Can only be used on vaults which have been created by this contract\n  ///@param asset The address of the collateral type\n  function withdrawAsset(address asset) external onlyOwner {\n    IERC20 token = IERC20(asset);\n    require(token.transfer(msg.sender, token.balanceOf(address(this))));\n  }\n\n  ///@notice Deposit collateral into a vault\n  ///@notice Requires approval of asset for amount before calling\n  ///@param asset Address of the collateral type\n  ///@param amount Amount to deposit\n  function depositToVault(address asset, uint256 amount) external {\n    IERC20 token = IERC20(asset);\n    token.approve(address(a.core()), amount);\n    token.transferFrom(msg.sender, address(this), amount);\n    a.core().deposit(asset, amount);\n  }\n\n  ///@notice Deposit collateral into a vault and borrow PAR\n  ///@notice Requires approval of asset for amount before calling\n  ///@param asset Address of the collateral type\n  ///@param depositAmount Amount to deposit\n  ///@param borrowAmount Amount of PAR to borrow after depositing\n  function depositAndBorrowFromVault(\n    address asset,\n    uint256 depositAmount,\n    uint256 borrowAmount\n  ) external onlyOwner {\n    IERC20 token = IERC20(asset);\n    token.approve(address(a.core()), depositAmount);\n    token.transferFrom(msg.sender, address(this), depositAmount);\n    a.core().depositAndBorrow(asset, depositAmount, borrowAmount);\n    require(IERC20(a.stablex()).transfer(msg.sender, IERC20(a.stablex()).balanceOf(address(this)))); //par\n    checkAndSendMIMO();\n  }\n\n  ///@notice Release MIMO from a MIMO miner to the owner\n  ///@param minerAddress The address of the MIMO miner\n  function releaseMIMO(address minerAddress) external payable onlyOwner {\n    IGenericMiner miner = IGenericMiner(minerAddress);\n    miner.releaseMIMO(address(this));\n    checkAndSendMIMO();\n  }\n\n  ///@notice Wrap ETH and deposit WETH as collateral into a vault\n  function depositETHToVault() external payable {\n    a.core().depositETH{ value: msg.value }();\n  }\n\n  ///@notice Wrap ETH and deposit WETH as collateral into a vault, then borrow PAR from vault\n  ///@param borrowAmount The amount of PAR to borrow after depositing ETH\n  function depositETHAndBorrowFromVault(uint256 borrowAmount) external payable onlyOwner {\n    a.core().depositETHAndBorrow{ value: msg.value }(borrowAmount);\n    require(IERC20(a.stablex()).transfer(msg.sender, IERC20(a.stablex()).balanceOf(address(this)))); //par\n    checkAndSendMIMO();\n  }\n\n  ///@notice Helper function to call an aggregator to swap PAR for a leveraged asset\n  ///@dev This helper function is used to limit the number of local variables in the leverageOperation function\n  ///@param params The params passed from the leverageOperation function for the aggregator call\n  ///@param token The leveraged asset to swap PAR for\n  function leverageSwap(bytes memory params, IERC20 token) internal {\n    (uint256 parToSell, bytes memory dexTxData, uint dexIndex) = abi.decode(\n      params,\n      (uint256, bytes, uint )\n    );\n    token.approve(address(a.core()), 2**256 - 1);\n    a.core().depositAndBorrow(address(token), token.balanceOf(address(this)), parToSell);\n    IERC20 par = IERC20(a.stablex());\n    aggregatorSwap(dexIndex, par, parToSell, dexTxData);\n  }\n\n  ///@notice Helper function to approve and swap an asset using an aggregator\n  ///@param dexIndex The DexAddressProvider index of aggregator to use to swap\n  ///@param token The starting token to swap for another asset\n  ///@param amount The amount of starting token to swap for\n  ///@param dexTxData The low-level data to call the aggregator with\n  function aggregatorSwap(\n    uint256 dexIndex,\n    IERC20 token,\n    uint256 amount,\n    bytes memory dexTxData\n  ) internal {\n    (address proxy, address router) = _dexAP.dexMapping(dexIndex);\n    require(proxy != address(0) && router != address(0), \"SV201\"); \n    token.approve(proxy, amount);\n    router.call(dexTxData);\n  }\n\n  ///@notice Helper function to format arguments to take a flashloan\n  ///@dev The flashloan call will call the executeOperation function on this contract\n  ///@param asset The address of the asset to loan\n  ///@param amount The amount to borrow\n  ///@param params The params that will be sent to executeOperation after the asset is borrowed\n  function takeFlashLoan(\n    address asset,\n    uint256 amount,\n    bytes memory params\n  ) internal {\n    uint8 referralCode;\n    address[] memory assets = new address[](1);\n    uint256[] memory amounts = new uint256[](1);\n    uint256[] memory modes = new uint256["
    }
  ]
}