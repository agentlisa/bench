{
  "Title": "M-3: SetLimit does not take into account burned OHM",
  "Content": "# Issue M-3: SetLimit does not take into account burned OHM \n\nSource: https://github.com/sherlock-audit/2023-03-olympus-judging/issues/48 \n\n## Found by \nchaduke, cducrest-brainbot\n\n## Summary\n\nThe function `setLimit()` may not be able to sufficiently restrict mint ability of manager.\n\n## Vulnerability Detail\n\nThe `setLimit()` function reverts when `newLimit_ < deployedOhm`, mintOhmToVault will revert if `deployedOhm + amount_ > ohmLimit + circulatingOhmBurned`. If the value of `circulatingOhmBurned` is high, and the admin can only set the limit above `deployedOhm`, they could end up in a state where they cannot limit the amount the vault is allowed to burn sufficiently. I.e. the vault is always able to mint at least `circulatingOhmBurned` new tokens.\n\nNote that `circulatingOhmBurned` is never lowered (even when minting new tokens), so this value could grow arbitrarily high.\n\n## Impact\n\nLack of control of admin on mint ability of manager.\n\n## Code Snippet\n\nSetLimit function:\nhttps://github.com/sherlock-audit/2023-03-olympus/blob/main/sherlock-olympus/src/policies/BoostedLiquidity/BLVaultManagerLido.sol#L480-L483\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse similar restrictions as in `mintOhmToVault()` for `setLimit` or lower `circulatingOhmBurned` when minting new OHM.\n\n## Discussion\n\n**0xLienid**\n\nSame issue as #018\n\n**0xLienid**\n\nFix Implementation: https://github.com/0xLienid/sherlock-olympus/pull/2/files\n\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/60",
  "Code": [
    {
      "filename": "sherlock-olympus/src/policies/BoostedLiquidity/BLVaultManagerLido.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// Import system dependencies\nimport {MINTRv1} from \"src/modules/MINTR/MINTR.v1.sol\";\nimport {ROLESv1, RolesConsumer} from \"src/modules/ROLES/OlympusRoles.sol\";\nimport {TRSRYv1} from \"src/modules/TRSRY/TRSRY.v1.sol\";\nimport {BLREGv1} from \"src/modules/BLREG/BLREG.v1.sol\";\nimport \"src/Kernel.sol\";\n\n// Import external dependencies\nimport {AggregatorV3Interface} from \"interfaces/AggregatorV2V3Interface.sol\";\nimport {IAuraRewardPool, IAuraMiningLib} from \"policies/BoostedLiquidity/interfaces/IAura.sol\";\nimport {JoinPoolRequest, IVault, IBasePool, IBalancerHelper} from \"policies/BoostedLiquidity/interfaces/IBalancer.sol\";\nimport {IWsteth} from \"policies/BoostedLiquidity/interfaces/ILido.sol\";\n\n// Import vault dependencies\nimport {RewardsData} from \"policies/BoostedLiquidity/interfaces/IBLVaultLido.sol\";\nimport {IBLVaultManagerLido} from \"policies/BoostedLiquidity/interfaces/IBLVaultManagerLido.sol\";\nimport {BLVaultLido} from \"policies/BoostedLiquidity/BLVaultLido.sol\";\n\n// Import libraries\nimport {ClonesWithImmutableArgs} from \"clones/ClonesWithImmutableArgs.sol\";\n\ncontract BLVaultManagerLido is Policy, IBLVaultManagerLido, RolesConsumer {\n    using ClonesWithImmutableArgs for address;\n\n    // ========= ERRORS ========= //\n\n    error BLManagerLido_AlreadyActive();\n    error BLManagerLido_AlreadyInactive();\n    error BLManagerLido_Inactive();\n    error BLManagerLido_InvalidVault();\n    error BLManagerLido_LimitViolation();\n    error BLManagerLido_InvalidLpAmount();\n    error BLManagerLido_InvalidLimit();\n    error BLManagerLido_InvalidFee();\n    error BLManagerLido_BadPriceFeed();\n    error BLManagerLido_VaultAlreadyExists();\n\n    // ========= EVENTS ========= //\n\n    event VaultDeployed(address vault, address owner, uint64 fee);\n\n    // ========= STATE VARIABLES ========= //\n\n    // Modules\n    MINTRv1 public MINTR;\n    TRSRYv1 public TRSRY;\n    BLREGv1 public BLREG;\n\n    // Tokens\n    address public ohm;\n    address public pairToken; // wstETH for this implementation\n    address public aura;\n    address public bal;\n\n    // Exchange Info\n    string public exchangeName;\n    BalancerData public balancerData;\n\n    // Aura Info\n    AuraData public auraData;\n    IAuraMiningLib public auraMiningLib;\n\n    // Oracle Info\n    OracleFeed public ohmEthPriceFeed;\n    OracleFeed public stethEthPriceFeed;\n\n    // Vault Info\n    BLVaultLido public implementation;\n    mapping(BLVaultLido => address) public vaultOwners;\n    mapping(address => BLVaultLido) public userVaults;\n\n    // Vaults State\n    uint256 public totalLp;\n    uint256 public deployedOhm;\n    uint256 public circulatingOhmBurned;\n\n    // System Configuration\n    uint256 public ohmLimit;\n    uint64 public currentFee;\n    bool public isLidoBLVaultActive;\n\n    // Constants\n    uint32 public constant MAX_FEE = 10_000; // 100%\n\n    //============================================================================================//\n    //                                      POLICY SETUP                                          //\n    //============================================================================================//\n\n    constructor(\n        Kernel kernel_,\n        TokenData memory tokenData_,\n        BalancerData memory balancerData_,\n        AuraData memory auraData_,\n        address auraMiningLib_,\n        OracleFeed memory ohmEthPriceFeed_,\n        OracleFeed memory stethEthPriceFeed_,\n        address implementation_,\n        uint256 ohmLimit_,\n        uint64 fee_\n    ) Policy(kernel_) {\n        // Set exchange name\n        {\n            exchangeName = \"Balancer\";\n        }\n\n        // Set tokens\n        {\n            ohm = tokenData_.ohm;\n            pairToken = tokenData_.pairToken;\n            aura = tokenData_.aura;\n            bal = tokenData_.bal;\n        }\n\n        // Set exchange info\n        {\n            balancerData = balancerData_;\n        }\n\n        // Set Aura Pool\n        {\n            auraData = auraData_;\n            auraMiningLib = IAuraMiningLib(auraMiningLib_);\n        }\n\n        // Set oracle info\n        {\n            ohmEthPriceFeed = ohmEthPriceFeed_;\n            stethEthPriceFeed = stethEthPriceFeed_;\n        }\n\n        // Set vault implementation\n        {\n            implementation = BLVaultLido(implementation_);\n        }\n\n        // Configure system\n        {\n            ohmLimit = ohmLimit_;\n            currentFee = fee_;\n        }\n    }\n\n    /// @inheritdoc Policy\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](4);\n        dependencies[0] = toKeycode(\"MINTR\");\n        dependencies[1] = toKeycode(\"TRSRY\");\n        dependencies[2] = toKeycode(\"BLREG\");\n        dependencies[3] = toKeycode(\"ROLES\");\n\n        MINTR = MINTRv1(getModuleAddress(dependencies[0]));\n        TRSRY = TRSRYv1(getModuleAddress(dependencies[1]));\n        BLREG = BLREGv1(getModuleAddress(dependencies[2]));\n        ROLES = ROLESv1(getModuleAddress(dependencies[3]));\n    }\n\n    /// @inheritdoc Policy\n    function requestPermissions()\n        external\n        view\n        override\n        returns (Permissions[] memory permissions)\n    {\n        Keycode mintrKeycode = MINTR.KEYCODE();\n        Keycode blregKeycode = BLREG.KEYCODE();\n\n        permissions = new Permissions[](5);\n        permissions[0] = Permissions(mintrKeycode, MINTR.mintOhm.selector);\n        permissions[1] = Permissions(mintrKeycode, MINTR.burnOhm.selector);\n        permissions[2] = Permissions(mintrKeycode, MINTR.increaseMintApproval.selector);\n        permissions[3] = Permissions(blregKeycode, BLREG.addVault.selector);\n        permissions[4] = Permissions(blregKeycode, BLREG.removeVault.selector);\n    }\n\n    //============================================================================================//\n    //                                           MODIFIERS                                        //\n    //============================================================================================//\n\n    modifier onlyWhileActive() {\n        if (!isLidoBLVaultActive) revert BLManagerLido_Inactive();\n        _;\n    }\n\n    modifier onlyVault() {\n        if (vaultOwners[BLVaultLido(msg.sender)] == address(0)) revert BLManagerLido_InvalidVault();\n        _;\n    }\n\n    //============================================================================================//\n    //                                        VAULT DEPLOYMENT                                    //\n    //============================================================================================//\n\n    /// @inheritdoc IBLVaultManagerLido\n    function deployVault() external override onlyWhileActive returns (address vault) {\n        if (address(userVaults[msg.sender]) != address(0))\n            revert BLManagerLido_VaultAlreadyExists();\n\n        // Create clone of vault implementation\n        bytes memory data = abi.encodePacked(\n            msg.sender, // Owner\n            this, // Vault Manager\n            address(TRSRY), // Treasury\n            address(MINTR), // Minter\n            ohm, // OHM\n            pairToken, // Pair Token (wstETH)\n            aura, // Aura\n            bal, // Balancer\n            balancerData.vault, // Balancer Vault\n            balancerData.liquidityPool, // Balancer Pool\n            auraData.pid, // Aura PID\n            auraData.auraBooster, // Aura Booster\n            auraData.auraRewardPool, // Aura Reward Pool\n            currentFee\n        );\n        BLVaultLido clone = BLVaultLido(address(implementation).clone(data));\n\n        // Initialize clone of vault implementation (for reentrancy state)\n        clone.initializeClone();\n\n        // Set vault owner\n        vaultOwners[clone] = msg.sender;\n        userVaults[msg.sender] = clone;\n\n        // Emit event\n        emit VaultDeployed(address(clone), msg.sender, currentFee);\n\n        // Return vault address\n        return address(clone);\n    }\n\n    //============================================================================================//\n    //                                         OHM MANAGEMENT                                     //\n    //============================================================================================//\n\n    /// @inheritdoc IBLVaultManagerLido\n    function mintOhmToVault(uint256 amount_) external override onlyWhileActive onlyVault {\n        // Check that minting will not exceed limit\n        if (deployedOhm + amount_ > ohmLimit + circulatingOhmBurned)\n            revert BLManagerLido_LimitViolation();\n\n        deployedOhm += amount_;\n\n        // Mint OHM\n        MINTR.increaseMintApproval(address(this), amount_);\n        MINTR.mintOhm(msg.sender, amount_);\n    }\n\n    /// @inheritdoc IBLVaultManagerLido\n    function burnOhmFromVault(uint256 amount_) external override onlyWhileActive onlyVault {\n        // Account for how much OHM has been deployed by the Vault system or burned from circulating supply.\n        // If we are burning more OHM than has been deployed by the system we are removing previously\n        // circulating OHM which should be tracked separately.\n        if (amount_ > deployedOhm) {\n            circulatingOhmBurned += amount_ - deployedOhm;\n            deployedOhm = 0;\n        } else {\n            deployedOhm -= amount_;\n        }\n\n        // Burn OHM\n        MINTR.burnOhm(msg.sender, amount_);\n    }\n\n    //============================================================================================//\n    //                                     VAULT STATE MANAGEMENT                                 //\n    //============================================================================================//\n\n    /// @inheritdoc IBLVaultManagerLido\n    function increaseTotalLp(uint256 amount_) external override onlyWhileActive onlyVault {\n        totalLp += amount_;\n    }\n\n    /// @inheritdoc IBLVaultManagerLido\n    function decreaseTotalLp(uint256 amount_) external override onlyWhileActive onlyVault {\n        if (amount_ > totalLp) revert BLManagerLido_InvalidLpAmount();\n        totalLp -= amount_;\n    }\n\n    //============================================================================================//\n    //                                         VIEW FUNCTIONS                                     //\n    //============================================================================================//\n\n    /// @inheritdoc IBLVaultManagerLido\n    function getLpBalance(address user_) external view override returns (uint256) {\n        if (address(userVaults[user_]) == address(0)) return 0;\n        return userVaults[user_].getLpBalance();\n    }\n\n    /// @inheritdoc IBLVaultManagerLido\n    function getUserPairShare(address user_) external view override returns (uint256) {\n        if (address(userVaults[user_]) == address(0)) return 0;\n        return userVaults[user_].getUserPairShare();\n    }\n\n    /// @inheritdoc IBLVaultManagerLido\n    function getOutstandingRewards(\n        address user_\n    ) external view override returns (RewardsData[] memory) {\n        // Get user's vault address\n        BLVaultLido vault = userVaults[user_];\n        if (address(vault) == address(0)) return new RewardsData[](0);\n\n        RewardsData[] memory rewards = vault.getOutstandingRewards();\n        return rewards;\n    }\n\n    /// @inheritdoc IBLVaultManagerLido\n    function getMaxDeposit() external view override returns (uint256) {\n        uint256 maxOhmAmount = ohmLimit + circulatingOhmBurned - deployedOhm;\n\n        // Convert max OHM mintable amount to pair token amount\n        uint256 ohmTknPrice = getOhmTknPrice();\n        uint256 maxTknAmount = (maxOhmAmount * 1e18) / ohmTknPrice;\n\n        return maxTknAmount;\n    }\n\n    /// @inheritdoc IBLVaultManagerLido\n    /// @dev    This is an external function but should only be used in a callstatic from an external\n    ///         source like the frontend.\n    function getExpectedLpAmount(uint256 amount_) external override returns (uint256 bptAmount) {\n        IBasePool pool = IBasePool(balancerData.liquidityPool);\n        IBalancerHelper balancerHelper = IBalancerHelper(balancerData.balancerHelper);\n\n        // Calculate OHM amount to mint\n        uint256 ohmTknPrice = getOhmTknPrice();\n        uint256 ohmMintAmount = (amount_ * ohmTknPrice) / 1e18;\n\n        // Build join pool request\n        address[] memory assets = new address[](2);\n        assets[0] = ohm;\n        assets[1] = pairToken;\n\n        uint256[] memory maxAmountsIn = new uint256[](2);\n        maxAmountsIn[0] = ohmMintAmount;\n        maxAmountsIn[1] = amount_;\n\n        JoinPoolRequest memory joinPoolRequest = JoinPoolRequest({\n            assets: assets,\n            maxAmountsIn: maxAmountsIn,\n            userData: abi.encode(1, maxAmountsIn, 0),\n            fromInternalBalance: false\n        });\n\n        // Join pool query\n        (bptAmount, ) = balancerHelper.queryJoin(\n            pool.getPoolId(),\n            address(this),\n            address(this),\n            joinPoolRequest\n        );\n    }\n\n    /// @inheritdoc IBLVaultManagerLido\n    function getRewardTokens() external view override returns (address[] memory) {\n        IAuraRewardPool auraPool = IAuraRewardPool(auraData.auraRewardPool);\n\n        uint256 numExtraRewards = auraPool.extraRewardsLength();\n        address[] memory rewardTokens = new address[](numExtraRewards + 2);\n        rewardTokens[0] = aura;\n        rewardTokens[1] = auraPool.rewardToken();\n        for (uint256 i; i < numExtraRewards; ) {\n            IAuraRewardPool extraRewardPool = IAuraRewardPool(auraPool.extraRewards(i));\n            rewardTokens[i + 2] = extraRewardPool.rewardToken();\n\n            unchecked {\n                ++i;\n            }\n        }\n        return rewardTokens;\n    }\n\n    /// @inheritdoc IBLVaultManagerLido\n    function getRewardRate(\n        address rewardToken_\n    ) external view override returns (uint256 rewardRate) {\n        IAuraRewardPool auraPool = IAuraRewardPool(auraData.auraRewardPool);\n\n        if (rewardToken_ == bal) {\n            // If reward token is Bal, return rewardRate from Aura Pool\n            rewardRate = auraPool.rewardRate();\n        } else if (rewardToken_ == aura) {\n            // If reward token is Aura, calculate rewardRate from AuraMiningLib\n            uint256 balRewardRate = auraPool.rewardRate();\n            rewardRate = auraMiningLib.convertCrvToCvx(balRewardRate);\n        } else {\n            uint256 numExtraRewards = auraPool.extraRewardsLength();\n            for (uint256 i; i < numExtraRewards; ) {\n                IAuraRewardPool extraRewardPool = IAuraRewardPool(auraPool.extraRewards(i));\n                if (rewardToken_ == extraRewardPool.rewardToken()) {\n                    rewardRate = extraRewardPool.rewardRate();\n                    break;\n                }\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n    }\n\n    /// @inheritdoc IBLVaultManagerLido\n    function getPoolOhmShare() public view override returns (uint256) {\n        // Cast addresses\n        IVault vault = IVault(balancerData.vault);\n        IBasePool pool = IBasePool(balancerData.liquidityPool);\n\n        // Get pool total supply\n        uint256 poolTotalSupply = pool.totalSupply();\n\n        // Get token balances in pool\n        (, uint256[] memory balances_, ) = vault.getPoolTokens(pool.getPoolId());\n\n        // Balancer pool tokens are sorted alphabetically by token address. In the case of this\n        // deployment, OHM is the first token in the pool. Therefore, the OHM balance is at index 0.\n        if (poolTotalSupply == 0) return 0;\n        else return (balances_[0] * totalLp) / poolTotalSupply;\n    }\n\n    /// @inheritdoc IBLVaultManagerLido\n    function getOhmSupplyChangeData()\n        external\n        view\n        override\n        returns (uint256 poolOhmShare, uint256 deployedOhm, uint256 circulatingOhmBurned)\n    {\n        // Net emitted is the amount of OHM that was minted to the pool but is no longer in the\n        // pool beyond what has been burned in the past. Net removed is the amount of OHM that is\n        // in the pool but wasnâ€™t minted there plus what has been burned in the past. Here we just return\n        // the data components to calculate that.\n\n        uint256 currentPoolOhmShare = getPoolOhmShare();\n        return (currentPoolOhmShare, deployedOhm, circulatingOhmBurned);\n    }\n\n    /// @inheritdoc IBLVaultManagerLido\n    function getOhmTknPrice() public view override returns (uint256) {\n        // Get stETH per wstETH (18 Decimals)\n        uint256 stethPerWsteth = IWsteth(pairToken).stEthPerToken();\n\n        // Get ETH per OHM (18 Decimals)\n        uint256 ethPerOhm = _validatePrice(ohmEthPriceFeed.feed, ohmEthPriceFeed.updateThreshold);\n\n        // Get stETH per ETH (18 Decimals)\n        uint256 stethPerEth = _validatePrice(\n            stethEthPriceFeed.feed,\n            stethEthPriceFeed.updateThreshold\n        );\n\n        // Calculate OHM per wstETH (9 decimals)\n        return (stethPerWsteth * stethPerEth) / (ethPerOhm * 1e9);\n    }\n\n    /// @inheritdoc IBLVaultManagerLido\n    function getTknOhmPrice() public view override returns (uint256) {\n        // Get stETH per wstETH (18 Decimals)\n        uint256 stethPerWsteth = IWsteth(pairToken).stEthPerToken();\n\n        // Get ETH per OHM (18 Decimals)\n        uint256 ethPerOhm = _validatePrice(ohmEthPriceFeed.feed, ohmEthPriceFeed.updateThreshold);\n\n        // Get stETH per ETH (18 Decimals)\n        uint256 stethPerEth = _validatePrice(\n            stethEthPriceFeed.feed,\n            stethEthPriceFeed.updateThreshold\n        );\n\n        // Calculate wstETH per OHM (18 decimals)\n        return (ethPerOhm * 1e36) / (stethPerWsteth * stethPerEth);\n    }\n\n    //============================================================================================//\n    //                                        ADMIN FUNCTIONS                                     //\n    //============================================================================================//\n\n    /// @inheritdoc IBLVaultManagerLido\n    function setLimit(uint256 newLimit_) external override onlyRole(\"liquidityvault_admin\") {\n        if (newLimit_ < deployedOhm) revert BLManagerLido_InvalidLimit();\n        ohmLimit = newLimit_;\n    }\n\n    /// @inheritdoc IBLVaultManagerLido\n    function setFee(uint64 newFee_) external override onlyRole(\"liquidityvault_admin\") {\n        if (newFee_ > MAX_FEE) revert BLManagerLido_InvalidFee();\n        currentFee = newFee_;\n    }\n\n    /// @inheritdoc IBLVaultManagerLido\n    function changeUpdateThresholds(\n        uint48 ohmEthUpdateThreshold_,\n        uint48 stethEthUpdateThreshold_\n    ) external onlyRole(\"liquidityvault_admin\") {\n        ohmEthPriceFeed.updateThreshold = ohmEthUpdateThreshold_;\n        stethEthPriceFeed.updateThreshold = stethEthUpdateThreshold_;\n    }\n\n    /// @inheritdoc IBLVaultManagerLido\n    function activate() external override onlyRole(\"liquidityvault_admin\") {\n        if (isLidoBLVaultActive) revert BLManagerLido_AlreadyActive();\n\n        isLidoBLVaultActive = true;\n        BLREG.addVault(address(this));\n    }\n\n    /// @inheritdoc IBLVaultManagerLido\n    function deactivate() external override onlyRole(\"liquidityvault_admin\") {\n        if (!isLidoBLVaultActive) revert BLManagerLido_AlreadyInactive();\n\n        isLidoBLVaultActive = false;\n        BLREG.removeVault(address(this));\n    }\n\n    //============================================================================================//\n    //                                      INTERNAL FUNCTIONS                                    //\n    //============================================================================================//\n\n    function _validatePrice(\n        AggregatorV3Interface priceFeed_,\n        uint48 updateThreshold_\n    ) internal view returns (uint256) {\n        // Get price data\n        (uint80 roundId, int256 priceInt, , uint256 updatedAt, uint80 answeredInRound) = priceFeed_\n            .latestRoundData();\n\n        // Validate chainlink price feed data\n        // 1. Price should be greater than 0\n        // 2. Updated at timestamp should be within the update threshold\n        // 3. Answered in round ID should be the same as round ID\n        if (\n            priceInt <= 0 ||\n            updatedAt < block.timestamp - updateThreshold_ ||\n            answeredInRound != roundId\n        ) revert BLManagerLido_BadPriceFeed();\n\n        return uint256(priceInt);\n    }\n}"
    }
  ]
}