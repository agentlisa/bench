{
  "Title": "[M-12] ReaperVaultERC4626 is not EIP-4626 compliant and integrations can result in loss of funds",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Vault/contracts/ReaperVaultV2.sol#L368-L408\n\n\n# Vulnerability details\n\n## Impact\nContracts that integrate with the `ReaperVaultERC4626` vault (including Ethos contracts) may wrongly assume that the functions are EIP-4626 compliant, which it might cause integration problems in the future, that can lead to a wide range of issues for both parties, including loss of funds.\n\n## Proof of Concept\n\nThis PoC describes this issue for the `withdraw` function, but there is the same problem with the `redeem` function.\n\nEIP-4626 specification says that the `withdraw` function:\n\n```\n// Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n\n// MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage,\n// the owner not having enough shares, etc).\n```\n\nThis is the `withdraw` function:\n\n```solidity\nFile: Ethos-Vault\\contracts\\ReaperVaultERC4626.sol\n\n202:     function withdraw(\n203:         uint256 assets,\n204:         address receiver,\n205:         address owner\n206:     ) external override returns (uint256 shares) {\n207:         shares = previewWithdraw(assets); // previewWithdraw() rounds up so exactly \"assets\" are withdrawn and not 1 wei less\n208:         if (msg.sender != owner) _spendAllowance(owner, msg.sender, shares);\n209:         _withdraw(shares, receiver, owner);\n210:     }\n```\n\nWhen the internal `_withdraw` is called, the `value` represents the total amount of assets that will be transferred to the receiver. \nThere is a special case where there could be a withdrawal that exceeds the total balance of the vault:\n\n```solidity\nFile: Ethos-Vault\\contracts\\ReaperVaultV2.sol\n\n368:         if (value > token.balanceOf(address(this))) {\n369:             uint256 totalLoss = 0;\n370:             uint256 queueLength = withdrawalQueue.length;\n371:             uint256 vaultBalance = 0;\n372:             for (uint256 i = 0; i < queueLength; i = i.uncheckedInc()) {\n373:                 vaultBalance = token.balanceOf(address(this));\n374:                 if (value <= vaultBalance) {\n375:                     break;\n376:                 }\n377: \n378:                 address stratAddr = withdrawalQueue[i];\n379:                 uint256 strategyBal = strategies[stratAddr].allocated;\n380:                 if (strategyBal == 0) {\n381:                     continue;\n382:                 }\n383: \n384:                 uint256 remaining = value - vaultBalance;\n385:                 uint256 loss = IStrategy(stratAddr).withdraw(Math.min(remaining, strategyBal));\n386:                 uint256 actualWithdrawn = token.balanceOf(address(this)) - vaultBalance;\n387: \n388:                 // Withdrawer incurs any losses from withdrawing as reported by strat\n389:                 if (loss != 0) {\n390:                     value -= loss;\n391:                     totalLoss += loss;\n392:                     _reportLoss(stratAddr, loss);\n393:                 }\n394: \n395:                 strategies[stratAddr].allocated -= actualWithdrawn;\n396:                 totalAllocated -= actualWithdrawn;\n397:             }\n398: \n399:             vaultBalance = token.balanceOf(address(this));\n400:             if (value > vaultBalance) {\n401:                 value = vaultBalance;\n402:             }\n403: \n404:             require(\n405:                 totalLoss <= ((value + totalLoss) * withdrawMaxLoss) / PERCENT_DIVISOR,\n406:                 \"Withdraw loss exceeds slippage\"\n407:             );\n408:         }\n409: \n410:         token.safeTransfer(_receiver, value);\n```\nIn this case, if a strategy incurs any losses, the actual withdrawal amount will NOT be the exact same specified when calling the `withdraw` function, as it will be less than that, as **the loss is detracted from the withdrawn value**:\n\n```solidity\nFile: Ethos-Vault\\contracts\\ReaperVaultV2.sol\n\n388:                 // Withdrawer incurs any losses from withdrawing as reported by strat\n389:                 if (loss != 0) {\n390:                     value -= loss;\n391:                     totalLoss += loss;\n392:                     _reportLoss(stratAddr, loss);\n393:                 }\n```\nIf that happens, then `assets requested > assets received`.\n\nAs the specification says that the withdrawal process `MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner not having enough shares, etc)`, this makes the `ReaperVaultERC4626` non EIP-4626 compliant.\n\nThis might cause integration problems in the future, which can lead to a wide range of issues, including loss of funds.\n\nBecause EIP-4626 is aimed to create a consistent and robust implementation pattern for Tokenized Vaults, and even a slight deviation from the standard would break composability (and potentially lead to a loss of funds), this is categorized as a high risk.\n\n## Tools Used\nManual review\n\n## Recommended Mitigation Steps\nThe `withdraw` and `redeem` functions should be modified to meet the specifications of EIP-4626: the `value` transferred must always be equal to the `assets` withdrawn. In case this is not true, the transaction must be reverted.",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-02-ethos-reserve-contest",
  "Code": [
    {
      "filename": "Ethos-Vault/contracts/ReaperVaultV2.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IERC4626Events.sol\";\nimport \"./interfaces/IStrategy.sol\";\nimport \"./libraries/ReaperMathUtils.sol\";\nimport \"./mixins/ReaperAccessControl.sol\";\nimport \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/**\n * @notice Implementation of a vault to deposit funds for yield optimizing.\n * This is the contract that receives funds and that users interface with.\n * The yield optimizing strategy itself is implemented in a separate 'Strategy.sol' contract.\n */\ncontract ReaperVaultV2 is ReaperAccessControl, ERC20, IERC4626Events, AccessControlEnumerable, ReentrancyGuard {\n    using ReaperMathUtils for uint256;\n    using SafeERC20 for IERC20Metadata;\n\n    struct StrategyParams {\n        uint256 activation; // Activation block.timestamp\n        uint256 feeBPS; // Performance fee taken from profit, in BPS\n        uint256 allocBPS; // Allocation in BPS of vault's total assets\n        uint256 allocated; // Amount of capital allocated to this strategy\n        uint256 gains; // Total returns that Strategy has realized for Vault\n        uint256 losses; // Total losses that Strategy has realized for Vault\n        uint256 lastReport; // block.timestamp of the last time a report occured\n    }\n\n    mapping(address => StrategyParams) public strategies;\n\n    // Ordering that `withdraw` uses to determine which strategies to pull funds from\n    address[] public withdrawalQueue;\n\n    uint256 public constant DEGRADATION_COEFFICIENT = 10**18; // The unit for calculating profit degradation.\n    uint256 public constant PERCENT_DIVISOR = 10000;\n    uint256 public tvlCap;\n\n    uint256 public totalAllocBPS; // Sum of allocBPS across all strategies (in BPS, <= 10k)\n    uint256 public totalAllocated; // Amount of tokens that have been allocated to all strategies\n    uint256 public lastReport; // block.timestamp of last report from any strategy\n\n    uint256 public immutable constructionTime;\n    bool public emergencyShutdown;\n\n    // The token the vault accepts and looks to maximize.\n    IERC20Metadata public immutable token;\n\n    // Max slippage(loss) allowed when withdrawing, in BPS (0.01%)\n    uint256 public withdrawMaxLoss = 1;\n    uint256 public lockedProfitDegradation; // rate per block of degradation. DEGRADATION_COEFFICIENT is 100% per block\n    uint256 public lockedProfit; // how much profit is locked and cant be withdrawn\n\n    /**\n     * Reaper Roles in increasing order of privilege.\n     * {DEPOSITOR} - Role conferred to EOAs/contracts that are allowed to deposit in the vault.\n     * {STRATEGIST} - Role conferred to authors of the strategy, allows for tweaking non-critical params.\n     * {GUARDIAN} - Multisig requiring 2 signatures for invoking emergency measures.\n     * {ADMIN}- Multisig requiring 3 signatures for deactivating emergency measures and changing TVL cap.\n     *\n     * The DEFAULT_ADMIN_ROLE (in-built access control role) will be granted to a multisig requiring 4\n     * signatures. This role would have the ability to add strategies, as well as the ability to grant any other\n     * roles.\n     *\n     * Also note that roles are cascading. So any higher privileged role should be able to perform all the functions\n     * of any lower privileged role.\n     */\n    bytes32 public constant DEPOSITOR = keccak256(\"DEPOSITOR\");\n    bytes32 public constant STRATEGIST = keccak256(\"STRATEGIST\");\n    bytes32 public constant GUARDIAN = keccak256(\"GUARDIAN\");\n    bytes32 public constant ADMIN = keccak256(\"ADMIN\");\n\n    address public treasury; // address to whom performance fee is remitted in the form of vault shares\n\n    event StrategyAdded(address indexed strategy, uint256 feeBPS, uint256 allocBPS);\n    event StrategyFeeBPSUpdated(address indexed strategy, uint256 feeBPS);\n    event StrategyAllocBPSUpdated(address indexed strategy, uint256 allocBPS);\n    event StrategyRevoked(address indexed strategy);\n    event UpdateWithdrawalQueue(address[] withdrawalQueue);\n    event WithdrawMaxLossUpdated(uint256 withdrawMaxLoss);\n    event EmergencyShutdown(bool active);\n    event InCaseTokensGetStuckCalled(address token, uint256 amount);\n    event TvlCapUpdated(uint256 newTvlCap);\n    event LockedProfitDegradationUpdated(uint256 degradation);\n    event StrategyReported(\n        address indexed strategy,\n        uint256 gain,\n        uint256 loss,\n        uint256 debtPaid,\n        uint256 gains,\n        uint256 losses,\n        uint256 allocated,\n        uint256 allocationAdded,\n        uint256 allocBPS\n    );\n\n    /**\n     * @notice Initializes the vault's own 'RF' token.\n     * This token is minted when someone does a deposit. It is burned in order\n     * to withdraw the corresponding portion of the underlying assets.\n     * @param _token the token to maximize.\n     * @param _name the name of the vault token.\n     * @param _symbol the symbol of the vault token.\n     * @param _tvlCap initial deposit cap for scaling TVL safely\n     */\n    constructor(\n        address _token,\n        string memory _name,\n        string memory _symbol,\n        uint256 _tvlCap,\n        address _treasury,\n        address[] memory _strategists,\n        address[] memory _multisigRoles\n    ) ERC20(string(_name), string(_symbol)) {\n        token = IERC20Metadata(_token);\n        constructionTime = block.timestamp;\n        lastReport = block.timestamp;\n        tvlCap = _tvlCap;\n        treasury = _treasury;\n        lockedProfitDegradation = (DEGRADATION_COEFFICIENT * 46) / 10**6; // 6 hours in blocks\n\n        uint256 numStrategists = _strategists.length;\n        for (uint256 i = 0; i < numStrategists; i = i.uncheckedInc()) {\n            _grantRole(STRATEGIST, _strategists[i]);\n        }\n\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(DEFAULT_ADMIN_ROLE, _multisigRoles[0]);\n        _grantRole(ADMIN, _multisigRoles[1]);\n        _grantRole(GUARDIAN, _multisigRoles[2]);\n    }\n\n    /**\n     * @notice Adds a new strategy to the vault with a given allocation amount in basis points.\n     * @param _strategy The strategy to add.\n     * @param _feeBPS The performance fee (taken from profit) in basis points\n     * @param _allocBPS The strategy allocation in basis points\n     */\n    function addStrategy(\n        address _strategy,\n        uint256 _feeBPS,\n        uint256 _allocBPS\n    ) external {\n        _atLeastRole(DEFAULT_ADMIN_ROLE);\n        require(!emergencyShutdown, \"Cannot add strategy during emergency shutdown\");\n        require(_strategy != address(0), \"Invalid strategy address\");\n        require(strategies[_strategy].activation == 0, \"Strategy already added\");\n        require(address(this) == IStrategy(_strategy).vault(), \"Strategy's vault does not match\");\n        require(address(token) == IStrategy(_strategy).want(), \"Strategy's want does not match\");\n        require(_feeBPS <= PERCENT_DIVISOR / 5, \"Fee cannot be higher than 20 BPS\");\n        require(_allocBPS + totalAllocBPS <= PERCENT_DIVISOR, \"Invalid allocBPS value\");\n\n        strategies[_strategy] = StrategyParams({\n            activation: block.timestamp,\n            feeBPS: _feeBPS,\n            allocBPS: _allocBPS,\n            allocated: 0,\n            gains: 0,\n            losses: 0,\n            lastReport: block.timestamp\n        });\n\n        totalAllocBPS += _allocBPS;\n        withdrawalQueue.push(_strategy);\n        emit StrategyAdded(_strategy, _feeBPS, _allocBPS);\n    }\n\n    /**\n     * @notice Updates the strategy's performance fee.\n     * @param _strategy The strategy to update.\n     * @param _feeBPS The new performance fee in basis points.\n     */\n    function updateStrategyFeeBPS(address _strategy, uint256 _feeBPS) external {\n        _atLeastRole(ADMIN);\n        require(strategies[_strategy].activation != 0, \"Invalid strategy address\");\n        require(_feeBPS <= PERCENT_DIVISOR / 5, \"Fee cannot be higher than 20 BPS\");\n        strategies[_strategy].feeBPS = _feeBPS;\n        emit StrategyFeeBPSUpdated(_strategy, _feeBPS);\n    }\n\n    /**\n     * @notice Updates the allocation points for a given strategy.\n     * @param _strategy The strategy to update.\n     * @param _allocBPS The strategy allocation in basis points\n     */\n    function updateStrategyAllocBPS(address _strategy, uint256 _allocBPS) external {\n        _atLeastRole(STRATEGIST);\n        require(strategies[_strategy].activation != 0, \"Invalid strategy address\");\n        totalAllocBPS -= strategies[_strategy].allocBPS;\n        strategies[_strategy].allocBPS = _allocBPS;\n        totalAllocBPS += _allocBPS;\n        require(totalAllocBPS <= PERCENT_DIVISOR, \"Invalid BPS value\");\n        emit StrategyAllocBPSUpdated(_strategy, _allocBPS);\n    }\n\n    /**\n     * @notice Removes any allocation to a given strategy.\n     * @param _strategy The strategy to revoke.\n     */\n    function revokeStrategy(address _strategy) external {\n        if (msg.sender != _strategy) {\n            _atLeastRole(GUARDIAN);\n        }\n\n        if (strategies[_strategy].allocBPS == 0) {\n            return;\n        }\n\n        totalAllocBPS -= strategies[_strategy].allocBPS;\n        strategies[_strategy].allocBPS = 0;\n        emit StrategyRevoked(_strategy);\n    }\n\n    /**\n     * @notice Called by a strategy to determine the amount of capital that the vault is\n     * able to provide it. A positive amount means that vault has excess capital to provide\n     * the strategy, while a negative amount means that the strategy has a balance owing to\n     * the vault.\n     */\n    function availableCapital() public view returns (int256) {\n        address stratAddr = msg.sender;\n        if (totalAllocBPS == 0 || emergencyShutdown) {\n            return -int256(strategies[stratAddr].allocated);\n        }\n\n        uint256 stratMaxAllocation = (strategies[stratAddr].allocBPS * balance()) / PERCENT_DIVISOR;\n        uint256 stratCurrentAllocation = strategies[stratAddr].allocated;\n\n        if (stratCurrentAllocation > stratMaxAllocation) {\n            return -int256(stratCurrentAllocation - stratMaxAllocation);\n        } else if (stratCurrentAllocation < stratMaxAllocation) {\n            uint256 vaultMaxAllocation = (totalAllocBPS * balance()) / PERCENT_DIVISOR;\n            uint256 vaultCurrentAllocation = totalAllocated;\n\n            if (vaultCurrentAllocation >= vaultMaxAllocation) {\n                return 0;\n            }\n\n            uint256 available = stratMaxAllocation - stratCurrentAllocation;\n            available = Math.min(available, vaultMaxAllocation - vaultCurrentAllocation);\n            available = Math.min(available, token.balanceOf(address(this)));\n\n            return int256(available);\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Updates the withdrawalQueue to match the addresses and order specified.\n     * @param _withdrawalQueue The new withdrawalQueue to update to.\n     */\n    function setWithdrawalQueue(address[] calldata _withdrawalQueue) external {\n        _atLeastRole(ADMIN);\n        uint256 queueLength = _withdrawalQueue.length;\n        require(queueLength != 0, \"Queue must not be empty\");\n\n        delete withdrawalQueue;\n        for (uint256 i = 0; i < queueLength; i = i.uncheckedInc()) {\n            address strategy = _withdrawalQueue[i];\n            StrategyParams storage params = strategies[strategy];\n            require(params.activation != 0, \"Invalid strategy address\");\n            withdrawalQueue.push(strategy);\n        }\n        emit UpdateWithdrawalQueue(_withdrawalQueue);\n    }\n\n    /**\n     * @dev It calculates the total underlying value of {token} held by the system.\n     * It takes into account the vault contract balance, and the balance deployed across\n     * all the strategies.\n     */\n    function balance() public view returns (uint256) {\n        return token.balanceOf(address(this)) + totalAllocated;\n    }\n\n    /**\n     * @notice It calculates the amount of free funds available after profit locking.\n     * For calculating share price, issuing shares during deposit, or burning shares during withdrawal.\n     * @return freeFunds - the total amount of free funds available.\n     */\n    function _freeFunds() internal view returns (uint256) {\n        return balance() - _calculateLockedProfit();\n    }\n\n    /**\n     * @dev Function for various UIs to display the current value of one of our yield tokens.\n     * Returns an uint256 with 18 decimals of how much underlying asset one vault share represents.\n     */\n    function getPricePerFullShare() public view returns (uint256) {\n        return totalSupply() == 0 ? 10**decimals() : (_freeFunds() * 10**decimals()) / totalSupply();\n    }\n\n    /**\n     * @dev A helper function to call deposit() with all the sender's funds.\n     */\n    function depositAll() external {\n        _deposit(token.balanceOf(msg.sender), msg.sender);\n    }\n\n    /**\n     * @notice The entrypoint of funds into the system. People deposit with this function\n     * into the vault.\n     * @notice the _before and _after variables are used to account properly for\n     * 'burn-on-transaction' tokens.\n     * @param _amount The amount of assets to deposit\n     */\n    function deposit(uint256 _amount) external {\n        _deposit(_amount, msg.sender);\n    }\n\n    // Internal helper function to deposit {_amount} of assets and mint corresponding\n    // shares to {_receiver}. Returns the number of shares that were minted.\n    function _deposit(uint256 _amount, address _receiver) internal nonReentrant returns (uint256 shares) {\n        _atLeastRole(DEPOSITOR);\n        require(!emergencyShutdown, \"Cannot deposit during emergency shutdown\");\n        require(_amount != 0, \"Invalid amount\");\n        uint256 pool = balance();\n        require(pool + _amount <= tvlCap, \"Vault is full\");\n\n        uint256 freeFunds = _freeFunds();\n        uint256 balBefore = token.balanceOf(address(this));\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        uint256 balAfter = token.balanceOf(address(this));\n        _amount = balAfter - balBefore;\n        if (totalSupply() == 0) {\n            shares = _amount;\n        } else {\n            shares = (_amount * totalSupply()) / freeFunds; // use \"freeFunds\" instead of \"pool\"\n        }\n        _mint(_receiver, shares);\n        emit Deposit(msg.sender, _receiver, _amount, shares);\n    }\n\n    /**\n     * @dev A helper function to call withdraw() with all the sender's funds.\n     */\n    function withdrawAll() external {\n        _withdraw(balanceOf(msg.sender), msg.sender, msg.sender);\n    }\n\n    /**\n     * @notice Function to exit the system. The vault will withdraw the required tokens\n     * from the strategies and pay up the token holder. A proportional number of IOU\n     * tokens are burned in the process.\n     * @param _shares the number of shares to burn\n     */\n    function withdraw(uint256 _shares) external {\n        _withdraw(_shares, msg.sender, msg.sender);\n    }\n\n    // Internal helper function to burn {_shares} of vault shares belonging to {_owner}\n    // and return corresponding assets to {_receiver}. Returns the number of assets that were returned.\n    function _withdraw(\n        uint256 _shares,\n        address _receiver,\n        address _owner\n    ) internal nonReentrant returns (uint256 value) {\n        require(_shares != 0, \"Invalid amount\");\n        value = (_freeFunds() * _shares) / totalSupply();\n        _burn(_owner, _shares);\n\n        if (value > token.balanceOf(address(this))) {\n            uint256 totalLoss = 0;\n            uint256 queueLength = withdrawalQueue.length;\n            uint256 vaultBalance = 0;\n            for (uint256 i = 0; i < queueLength; i = i.uncheckedInc()) {\n                vaultBalance = token.balanceOf(address(this));\n                if (value <= vaultBalance) {\n                    break;\n                }\n\n                address stratAddr = withdrawalQueue[i];\n                uint256 strategyBal = strategies[stratAddr].allocated;\n                if (strategyBal == 0) {\n                    continue;\n                }\n\n                uint256 remaining = value - vaultBalance;\n                uint256 loss = IStrategy(stratAddr).withdraw(Math.min(remaining, strategyBal));\n                uint256 actualWithdrawn = token.balanceOf(address(this)) - vaultBalance;\n\n                // Withdrawer incurs any losses from withdrawing as reported by strat\n                if (loss != 0) {\n                    value -= loss;\n                    totalLoss += loss;\n                    _reportLoss(stratAddr, loss);\n                }\n\n                strategies[stratAddr].allocated -= actualWithdrawn;\n                totalAllocated -= actualWithdrawn;\n            }\n\n            vaultBalance = token.balanceOf(address(this));\n            if (value > vaultBalance) {\n                value = vaultBalance;\n            }\n\n            require(\n                totalLoss <= ((value + totalLoss) * withdrawMaxLoss) / PERCENT_DIVISOR,\n                \"Withdraw loss exceeds slippage\"\n            );\n        }\n\n        token.safeTransfer(_receiver, value);\n        emit Withdraw(msg.sender, _receiver, _owner, value, _shares);\n    }\n\n    /**\n     * @notice It calculates the amount of locked profit from recent harvests.\n     * @return the amount of locked profit.\n     */\n    function _calculateLockedProfit() internal view returns (uint256) {\n        uint256 lockedFundsRatio = (block.timestamp - lastReport) * lockedProfitDegradation;\n        if (lockedFundsRatio < DEGRADATION_COEFFICIENT) {\n            return lockedProfit - ((lockedFundsRatio * lockedProfit) / DEGRADATION_COEFFICIENT);\n        }\n\n        return 0;\n    }\n\n    /**\n     * @notice Helper function to report a loss by a given strategy.\n     * @param strategy The strategy to report the loss for.\n     * @param loss The amount lost.\n     */\n    function _reportLoss(address strategy, uint256 loss) internal {\n        StrategyParams storage stratParams = strategies[strategy];\n        // Loss can only be up the amount of capital allocated to the strategy\n        uint256 allocation = stratParams.allocated;\n        require(loss <= allocation, \"Strategy loss cannot be greater than allocation\");\n\n        if (totalAllocBPS != 0) {\n            // reduce strat's allocBPS proportional to loss\n            uint256 bpsChange = Math.min((loss * totalAllocBPS) / totalAllocated, stratParams.allocBPS);\n\n            // If the loss is too small, bpsChange will be 0\n            if (bpsChange != 0) {\n                stratParams.allocBPS -= bpsChange;\n                totalAllocBPS -= bpsChange;\n            }\n        }\n\n        // Finally, adjust our strategy's parameters by the loss\n        stratParams.losses += loss;\n        stratParams.allocated -= loss;\n        totalAllocated -= loss;\n    }\n\n    /**\n     * @notice Helper function to charge fees from the gain reported by a strategy.\n     * Fees is charged by issuing the corresponding amount of vault shares to the treasury.\n     * @param strategy The strategy that reported gain.\n     * @param gain The amount of profit reported.\n     * @return The fee amount in assets.\n     */\n    function _chargeFees(address strategy, uint256 gain) internal returns (uint256) {\n        uint256 performanceFee = (gain * strategies[strategy].feeBPS) / PERCENT_DIVISOR;\n        if (performanceFee != 0) {\n            uint256 supply = totalSupply();\n            uint256 shares = supply == 0 ? performanceFee : (performanceFee * supply) / _freeFunds();\n            _mint(treasury, shares);\n        }\n        return performanceFee;\n    }\n\n    // To avoid \"stack too deep\" errors\n    struct LocalVariables_report {\n        address stratAddr;\n        uint256 loss;\n        uint256 gain;\n        uint256 fees;\n        int256 available;\n        uint256 debt;\n        uint256 credit;\n        uint256 debtPayment;\n        uint256 freeWantInStrat;\n        uint256 lockedProfitBeforeLoss;\n    }\n\n    /**\n     * @notice Main contact point where each strategy interacts with the vault during its harvest\n     * to report profit/loss as well as any repayment of debt.\n     * @param _roi The return on investment (positive or negative) given as the total amount\n     * gained or lost from the harvest.\n     * @param _repayment The repayment of debt by the strategy.\n     */\n    function report(int256 _roi, uint256 _repayment) external returns (uint256) {\n        LocalVariables_report memory vars;\n        vars.stratAddr = msg.sender;\n        StrategyParams storage strategy = strategies[vars.stratAddr];\n        require(strategy.activation != 0, \"Unauthorized strategy\");\n\n        if (_roi < 0) {\n            vars.loss = uint256(-_roi);\n            _reportLoss(vars.stratAddr, vars.loss);\n        } else if (_roi > 0) {\n            vars.gain = uint256(_roi);\n            vars.fees = _chargeFees(vars.stratAddr, vars.gain);\n            strategy.gains += vars.gain;\n        }\n\n        vars.available = availableCapital();\n        if (vars.available < 0) {\n            vars.debt = uint256(-vars.available);\n            vars.debtPayment = Math.min(vars.debt, _repayment);\n\n            if (vars.debtPayment != 0) {\n                strategy.allocated -= vars.debtPayment;\n                totalAllocated -= vars.debtPayment;\n                vars.debt -= vars.debtPayment; // tracked for return value\n            }\n        } else if (vars.available > 0) {\n            vars.credit = uint256(vars.available);\n            strategy.allocated += vars.credit;\n            totalAllocated += vars.credit;\n        }\n\n        vars.freeWantInStrat = vars.gain + _repayment;\n        if (vars.credit > vars.freeWantInStrat) {\n            token.safeTransfer(vars.stratAddr, vars.credit - vars.freeWantInStrat);\n        } else if (vars.credit < vars.freeWantInStrat) {\n            token.safeTransferFrom(vars.stratAddr, address(this), vars.freeWantInStrat - vars.credit);\n        }\n\n        // Profit is locked and gradually released per block\n        // NOTE: compute current locked profit and replace with sum of current and new\n        vars.lockedProfitBeforeLoss = _calculateLockedProfit() + vars.gain - vars.fees;\n        if (vars.lockedProfitBeforeLoss > vars.loss) {\n            lockedProfit = vars.lockedProfitBeforeLoss - vars.loss;\n        } else {\n            lockedProfit = 0;\n        }\n\n        strategy.lastReport = block.timestamp;\n        lastReport = block.timestamp;\n\n        emit StrategyReported(\n            vars.stratAddr,\n            vars.gain,\n            vars.loss,\n            vars.debtPayment,\n            strategy.gains,\n            strategy.losses,\n            strategy.allocated,\n            vars.credit,\n            strategy.allocBPS\n        );\n\n        if (strategy.allocBPS == 0 || emergencyShutdown) {\n            return IStrategy(vars.stratAddr).balanceOf();\n        }\n\n        return vars.debt;\n    }\n\n    /**\n     * @notice Updates the withdrawMaxLoss which is the maximum allowed slippage.\n     * @param _withdrawMaxLoss The new value, in basis points.\n     */\n    function updateWithdrawMaxLoss(uint256 _withdrawMaxLoss) external {\n        _atLeastRole(STRATEGIST);\n        require(_withdrawMaxLoss <= PERCENT_DIVISOR, \"Invalid BPS value\");\n        withdrawMaxLoss = _withdrawMaxLoss;\n        emit WithdrawMaxLossUpdated(_withdrawMaxLoss);\n    }\n\n    /**\n     * @notice Updates the vault tvl cap (the max amount of assets held by the vault).\n     * @dev pass in max value of uint to effectively remove TVL cap.\n     * @param _newTvlCap The new tvl cap.\n     */\n    function updateTvlCap(uint256 _newTvlCap) public {\n        _atLeastRole(ADMIN);\n        tvlCap = _newTvlCap;\n        emit TvlCapUpdated(tvlCap);\n    }\n\n    /**\n     * @dev helper function to remove TVL cap\n     */\n    function removeTvlCap() external {\n        updateTvlCap(type(uint256).max);\n    }\n\n    /**\n     * Activates or deactivates Vault mode where all Strategies go into full\n     * withdrawal.\n     * During Emergency Shutdown:\n     * 1. No Users may deposit into the Vault (but may withdraw as usual.)\n     * 2. New Strategies may not be added.\n     * 3. Each Strategy must pay back their debt as quickly as reasonable to\n     * minimally affect their position.\n     *\n     * If true, the Vault goes into Emergency Shutdown. If false, the Vault\n     * goes back into Normal Operation.\n     */\n    function setEmergencyShutdown(bool _active) external {\n        if (_active) {\n            _atLeastRole(GUARDIAN);\n        } else {\n            _atLeastRole(ADMIN);\n        }\n        emergencyShutdown = _active;\n        emit EmergencyShutdown(_active);\n    }\n\n    /**\n     * @notice Changes the locked profit degradation.\n     * @param degradation - The rate of degradation in percent per second scaled to 1e18.\n     */\n    function setLockedProfitDegradation(uint256 degradation) external {\n        _atLeastRole(ADMIN);\n        require(degradation <= DEGRADATION_COEFFICIENT, \"Degradation cannot be more than 100%\");\n        lockedProfitDegradation = degradation;\n        emit LockedProfitDegradationUpdated(degradation);\n    }\n\n    /**\n     * @notice Only DEFAULT_ADMIN_ROLE can update treasury address.\n     */\n    function updateTreasury(address newTreasury) external {\n        _atLeastRole(DEFAULT_ADMIN_ROLE);\n        require(newTreasury != address(0), \"Invalid address\");\n        treasury = newTreasury;\n    }\n\n    /**\n     * @dev Rescues random funds stuck that the strat can't handle.\n     * @param _token address of the token to rescue.\n     */\n    function inCaseTokensGetStuck(address _token) external {\n        _atLeastRole(ADMIN);\n        require(_token != address(token), \"!token\");\n\n        uint256 amount = IERC20Metadata(_token).balanceOf(address(this));\n        IERC20Metadata(_token).safeTransfer(msg.sender, amount);\n        emit InCaseTokensGetStuckCalled(_token, amount);\n    }\n\n    /**\n     * @dev Overrides the default 18 decimals for the vault ERC20 to\n     * match the same decimals as the underlying token used\n     */\n    function decimals() public view override returns (uint8) {\n        return token.decimals();\n    }\n\n    /**\n     * @dev Returns an array of all the relevant roles arranged in descending order of privilege.\n     *      Subclasses should override this to specify their unique roles arranged in the correct\n     *      order, for example, [SUPER-ADMIN, ADMIN, GUARDIAN, STRATEGIST].\n     */\n    function _cascadingAccessRoles() internal view override returns (bytes32[] memory) {\n        bytes32[] memory cascadingAccessRoles = new bytes32[](5);\n        cascadingAccessRoles[0] = DEFAULT_ADMIN_ROLE;\n        cascadingAccessRoles[1] = ADMIN;\n        cascadingAccessRoles[2] = GUARDIAN;\n        cascadingAccessRoles[3] = STRATEGIST;\n        cascadingAccessRoles[4] = DEPOSITOR;\n        return cascadingAccessRoles;\n    }\n\n    /**\n     * @dev Returns {true} if {_account} has been granted {_role}. Subclasses should override\n     *      this to specify their unique role-checking criteria.\n     */\n    function _hasRole(bytes32 _role, address _account) internal view override returns (bool) {\n        return hasRole(_role, _account);\n    }\n}"
    }
  ]
}