{
  "Title": "[L01] Duplicated getters",
  "Content": "The `Managed` contract has been refactored to add getter functions that [retrieve the addresses of the five contracts](https://github.com/graphprotocol/contracts/blob/cab50f4975580d71cb43b5731a62b86d07d951bc/contracts/governance/Managed.sol#L92) through the call to the [`_resolveContract`](https://github.com/graphprotocol/contracts/blob/cab50f4975580d71cb43b5731a62b86d07d951bc/contracts/governance/Managed.sol#L132) internal function.\n\n\nContracts are set in the `_syncContract` function [to the `addressCache` mapping](https://github.com/graphprotocol/contracts/blob/cab50f4975580d71cb43b5731a62b86d07d951bc/contracts/governance/Managed.sol#L23) that uses the [`keccak256` representation of the contract names as key values](https://github.com/graphprotocol/contracts/blob/cab50f4975580d71cb43b5731a62b86d07d951bc/contracts/governance/Managed.sol#L147).\n\n\nAt the same time, the `addressCache` mapping is defined as public, and it exposes an automatically generated getter function that can be used to retrieve the same addresses by the direct use of the `keccak256` name representation.\n\n\nTo be more gas efficient, consider either defining the `addressCache` mapping as private or removing the explicit getters to avoid duplicate getter functions.\n\n\n**Update:** *Fixed in commit [`01dea49469c3c7bee0c1989ff80baa267c14fb0f`](https://github.com/graphprotocol/contracts/pull/430/commits/01dea49469c3c7bee0c1989ff80baa267c14fb0f) where the `addressCache` mapping is defined to be private.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/governance/Managed.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.3;\n\nimport \"./IManaged.sol\";\nimport \"./IController.sol\";\n\nimport \"../curation/ICuration.sol\";\nimport \"../epochs/IEpochManager.sol\";\nimport \"../rewards/IRewardsManager.sol\";\nimport \"../staking/IStaking.sol\";\nimport \"../token/IGraphToken.sol\";\n\n/**\n * @title Graph Managed contract\n * @dev The Managed contract provides an interface for contracts to interact with the Controller\n * Inspired by Livepeer:\n * https://github.com/livepeer/protocol/blob/streamflow/contracts/Controller.sol\n */\ncontract Managed {\n    // Controller that contract is registered with\n    IController public controller;\n    mapping(bytes32 => address) public addressCache;\n    uint256[10] private __gap;\n\n    event ParameterUpdated(string param);\n    event SetController(address controller);\n\n    function _notPartialPaused() internal view {\n        require(!controller.paused(), \"Paused\");\n        require(!controller.partialPaused(), \"Partial-paused\");\n    }\n\n    function _notPaused() internal view {\n        require(!controller.paused(), \"Paused\");\n    }\n\n    function _onlyGovernor() internal view {\n        require(msg.sender == controller.getGovernor(), \"Caller must be Controller governor\");\n    }\n\n    modifier notPartialPaused {\n        _notPartialPaused();\n        _;\n    }\n\n    modifier notPaused {\n        _notPaused();\n        _;\n    }\n\n    // Check if sender is controller\n    modifier onlyController() {\n        require(msg.sender == address(controller), \"Caller must be Controller\");\n        _;\n    }\n\n    modifier onlyGovernor() {\n        _onlyGovernor();\n        _;\n    }\n\n    /**\n     * @dev Initialize the controller\n     */\n    function _initialize(address _controller) internal {\n        _setController(_controller);\n    }\n\n    /**\n     * @notice Set Controller. Only callable by current controller\n     * @param _controller Controller contract address\n     */\n    function setController(address _controller) external onlyController {\n        _setController(_controller);\n    }\n\n    /**\n     * @dev Set controller.\n     * @param _controller Controller contract address\n     */\n    function _setController(address _controller) internal {\n        require(_controller != address(0), \"Controller must be set\");\n        controller = IController(_controller);\n        emit SetController(_controller);\n    }\n\n    /**\n     * @dev Return Curation interface\n     * @return Curation contract registered with Controller\n     */\n    function curation() internal view returns (ICuration) {\n        return ICuration(_resolveContract(keccak256(\"Curation\")));\n    }\n\n    /**\n     * @dev Return EpochManager interface\n     * @return Epoch manager contract registered with Controller\n     */\n    function epochManager() internal view returns (IEpochManager) {\n        return IEpochManager(_resolveContract(keccak256(\"EpochManager\")));\n    }\n\n    /**\n     * @dev Return RewardsManager interface\n     * @return Rewards manager contract registered with Controller\n     */\n    function rewardsManager() internal view returns (IRewardsManager) {\n        return IRewardsManager(_resolveContract(keccak256(\"RewardsManager\")));\n    }\n\n    /**\n     * @dev Return Staking interface\n     * @return Staking contract registered with Controller\n     */\n    function staking() internal view returns (IStaking) {\n        return IStaking(_resolveContract(keccak256(\"Staking\")));\n    }\n\n    /**\n     * @dev Return GraphToken interface\n     * @return Graph token contract registered with Controller\n     */\n    function graphToken() internal view returns (IGraphToken) {\n        return IGraphToken(_resolveContract(keccak256(\"GraphToken\")));\n    }\n\n    /**\n     * @dev Resolve a contract address from the cache or the Controller if not found\n     * @return Address of the contract\n     */\n    function _resolveContract(bytes32 _nameHash) internal view returns (address) {\n        address contractAddress = addressCache[_nameHash];\n        if (contractAddress == address(0)) {\n            contractAddress = controller.getContractProxy(_nameHash);\n        }\n        return contractAddress;\n    }\n\n    /**\n     * @dev Cache a contract address from the Controller registry\n     */\n    function _syncContract(string memory name) internal {\n        bytes32 nameHash = keccak256(abi.encodePacked(name));\n        address contractAddress = controller.getContractProxy(nameHash);\n        if (addressCache[nameHash] != contractAddress) {\n            addressCache[nameHash] = contractAddress;\n        }\n    }\n\n    /**\n     * @dev Sync protocol contract addresses from the Controller registry\n     */\n    function syncAllContracts() external {\n        _syncContract(\"Curation\");\n        _syncContract(\"EpochManager\");\n        _syncContract(\"RewardsManager\");\n        _syncContract(\"Staking\");\n        _syncContract(\"GraphToken\");\n    }\n}"
    },
    {
      "filename": "contracts/governance/Managed.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.3;\n\nimport \"./IManaged.sol\";\nimport \"./IController.sol\";\n\nimport \"../curation/ICuration.sol\";\nimport \"../epochs/IEpochManager.sol\";\nimport \"../rewards/IRewardsManager.sol\";\nimport \"../staking/IStaking.sol\";\nimport \"../token/IGraphToken.sol\";\n\n/**\n * @title Graph Managed contract\n * @dev The Managed contract provides an interface for contracts to interact with the Controller\n * Inspired by Livepeer:\n * https://github.com/livepeer/protocol/blob/streamflow/contracts/Controller.sol\n */\ncontract Managed {\n    // Controller that contract is registered with\n    IController public controller;\n    mapping(bytes32 => address) public addressCache;\n    uint256[10] private __gap;\n\n    event ParameterUpdated(string param);\n    event SetController(address controller);\n\n    function _notPartialPaused() internal view {\n        require(!controller.paused(), \"Paused\");\n        require(!controller.partialPaused(), \"Partial-paused\");\n    }\n\n    function _notPaused() internal view {\n        require(!controller.paused(), \"Paused\");\n    }\n\n    function _onlyGovernor() internal view {\n        require(msg.sender == controller.getGovernor(), \"Caller must be Controller governor\");\n    }\n\n    modifier notPartialPaused {\n        _notPartialPaused();\n        _;\n    }\n\n    modifier notPaused {\n        _notPaused();\n        _;\n    }\n\n    // Check if sender is controller\n    modifier onlyController() {\n        require(msg.sender == address(controller), \"Caller must be Controller\");\n        _;\n    }\n\n    modifier onlyGovernor() {\n        _onlyGovernor();\n        _;\n    }\n\n    /**\n     * @dev Initialize the controller\n     */\n    function _initialize(address _controller) internal {\n        _setController(_controller);\n    }\n\n    /**\n     * @notice Set Controller. Only callable by current controller\n     * @param _controller Controller contract address\n     */\n    function setController(address _controller) external onlyController {\n        _setController(_controller);\n    }\n\n    /**\n     * @dev Set controller.\n     * @param _controller Controller contract address\n     */\n    function _setController(address _controller) internal {\n        require(_controller != address(0), \"Controller must be set\");\n        controller = IController(_controller);\n        emit SetController(_controller);\n    }\n\n    /**\n     * @dev Return Curation interface\n     * @return Curation contract registered with Controller\n     */\n    function curation() internal view returns (ICuration) {\n        return ICuration(_resolveContract(keccak256(\"Curation\")));\n    }\n\n    /**\n     * @dev Return EpochManager interface\n     * @return Epoch manager contract registered with Controller\n     */\n    function epochManager() internal view returns (IEpochManager) {\n        return IEpochManager(_resolveContract(keccak256(\"EpochManager\")));\n    }\n\n    /**\n     * @dev Return RewardsManager interface\n     * @return Rewards manager contract registered with Controller\n     */\n    function rewardsManager() internal view returns (IRewardsManager) {\n        return IRewardsManager(_resolveContract(keccak256(\"RewardsManager\")));\n    }\n\n    /**\n     * @dev Return Staking interface\n     * @return Staking contract registered with Controller\n     */\n    function staking() internal view returns (IStaking) {\n        return IStaking(_resolveContract(keccak256(\"Staking\")));\n    }\n\n    /**\n     * @dev Return GraphToken interface\n     * @return Graph token contract registered with Controller\n     */\n    function graphToken() internal view returns (IGraphToken) {\n        return IGraphToken(_resolveContract(keccak256(\"GraphToken\")));\n    }\n\n    /**\n     * @dev Resolve a contract address from the cache or the Controller if not found\n     * @return Address of the contract\n     */\n    function _resolveContract(bytes32 _nameHash) internal view returns (address) {\n        address contractAddress = addressCache[_nameHash];\n        if (contractAddress == address(0)) {\n            contractAddress = controller.getContractProxy(_nameHash);\n        }\n        return contractAddress;\n    }\n\n    /**\n     * @dev Cache a contract address from the Controller registry\n     */\n    function _syncContract(string memory name) internal {\n        bytes32 nameHash = keccak256(abi.encodePacked(name));\n        address contractAddress = controller.getContractProxy(nameHash);\n        if (addressCache[nameHash] != contractAddress) {\n            addressCache[nameHash] = contractAddress;\n        }\n    }\n\n    /**\n     * @dev Sync protocol contract addresses from the Controller registry\n     */\n    function syncAllContracts() external {\n        _syncContract(\"Curation\");\n        _syncContract(\"EpochManager\");\n        _syncContract(\"RewardsManager\");\n        _syncContract(\"Staking\");\n        _syncContract(\"GraphToken\");\n    }\n}"
    }
  ]
}