{
  "Title": "H-15: Liquidation fees are permanently frozen on Penrose YB account",
  "Content": "# Issue H-15: Liquidation fees are permanently frozen on Penrose YB account \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/148 \n\n## Found by \nbin2chen, duc, hyh\n## Summary\n\nThere is no treatment of liquidation fees in SGL, they are frozen on Penrose YB account.\n\n## Vulnerability Detail\n\nThere are 3 kinds of fees, borrow/interest and liquidation ones. The latter miss the handling logic, so such funds are accumulated and frozen.\n\n## Impact\n\nProtocol-wide loss of funds, which othwerwise would be channelled to stakers.\n\n## Code Snippet\n\nInterest fees are accumulated in the `accrueInfo.feesEarnedFraction` variable:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/singularity/SGLCommon.sol#L103-L105\n\n```solidity\n        uint256 feeAmount = (extraAmount * protocolFee) / FEE_PRECISION; // % of interest paid goes to fee\n        feeFraction = (feeAmount * _totalAsset.base) / (fullAssetAmount - feeAmount);\n        _accrueInfo.feesEarnedFraction += feeFraction.toUint128();\n```\n\nWhich is then accumulated on internal Penrose account via withdrawing `feeShares = _removeAsset(_feeTo, msg.sender, balanceOf[address(penrose)])`:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/Penrose.sol#L565-L568\n\n```solidity\n    function _depositFeesToTwTap(IMarket market, ITwTap twTap) private {\n        if (!isMarketRegistered[address(market)]) revert NotValid();\n\n>>      uint256 feeShares = market.refreshPenroseFees();\n```\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/singularity/Singularity.sol#L285-L298\n\n```solidity\n    function refreshPenroseFees() external onlyOwner returns (uint256 feeShares) {\n        address _feeTo = address(penrose);\n        // withdraw the fees accumulated in `accrueInfo.feesEarnedFraction` to the balance of `feeTo`.\n        if (accrueInfo.feesEarnedFraction > 0) {\n            _accrue();\n            uint256 _feesEarnedFraction = accrueInfo.feesEarnedFraction;\n            balanceOf[_feeTo] += _feesEarnedFraction;\n            emit Transfer(address(0), _feeTo, _feesEarnedFraction);\n            accrueInfo.feesEarnedFraction = 0;\n            emit LogWithdrawFees(_feeTo, _feesEarnedFraction);\n        }\n\n>>      feeShares = _removeAsset(_feeTo, msg.sender, balanceOf[_feeTo]);\n    }\n```\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/singularity/SGLCommon.sol#L199-L216\n\n```solidity\n    function _removeAsset(address from, address to, uint256 fraction) internal returns (uint256 share) {\n        if (totalAsset.base == 0) {\n            return 0;\n        }\n        Rebase memory _totalAsset = totalAsset;\n        uint256 allShare = _totalAsset.elastic + yieldBox.toShare(assetId, totalBorrow.elastic, false);\n>>      share = (fraction * allShare) / _totalAsset.base;\n\n        _totalAsset.base -= fraction.toUint128();\n        if (_totalAsset.base < 1000) revert MinLimit();\n\n        balanceOf[from] -= fraction;\n        emit Transfer(from, address(0), fraction);\n        _totalAsset.elastic -= share.toUint128();\n        totalAsset = _totalAsset;\n        emit LogRemoveAsset(from, to, share, fraction);\n>>      yieldBox.transfer(address(this), to, assetId, share);\n    }\n```\n\nHowever, liquidation fees are being placed to Penrose account directly and aren't included in the `feeShares = share` variable above:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/singularity/SGLLiquidation.sol#L297-L312\n\n```solidity\n    function _extractLiquidationFees(uint256 extraShare, uint256 callerReward)\n        ...\n    {\n        callerShare = (extraShare * callerReward) / FEE_PRECISION; //  y%  of profit goes to caller.\n>>      feeShare = extraShare - callerShare; // rest goes to the fee\n\n        if (feeShare > 0) {\n>>          uint256 feeAmount = yieldBox.toAmount(assetId, feeShare, false);\n>>          yieldBox.depositAsset(assetId, address(this), address(penrose), feeAmount, 0);\n        }\n        if (callerShare > 0) {\n            uint256 callerAmount = yieldBox.toAmount(assetId, callerShare, false);\n            yieldBox.depositAsset(assetId, address(this), msg.sender, callerAmount, 0);\n        }\n    }\n```\n\nBut `_depositFeesToTwTap()` uses only `refreshPenroseFees()` returned `yieldBox.toAmount(_assetId, feeShares, false)`, which consists of interest and borrowing fees only:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/Penrose.sol#L565-L578\n\n```solidity\n    function _depositFeesToTwTap(IMarket market, ITwTap twTap) private {\n        ...\n\n>>      uint256 feeShares = market.refreshPenroseFees();\n        ...\n        yieldBox.withdraw(_assetId, address(this), address(this), 0, feeShares);\n\n        uint256 rewardTokenId = twTap.rewardTokenIndex(_asset);\n>>      uint256 feeAmount = yieldBox.toAmount(_assetId, feeShares, false);\n>>      _distributeOnTwTap(feeAmount, rewardTokenId, _asset, twTap);\n    }\n```\n\nThis way liquidation fees accumulated on Penrose's YB account are frozen there as there are no Singularity fees distribution mechanics besides `withdrawAllMarketFees()` $\\rightarrow$ `_depositFeesToTwTap()`:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/Penrose.sol#L240-L255\n\n```solidity\n    /// @notice Loop through the master contracts and call `_depositFeesToTwTap()` to each one of their clones.\n    /// @param markets_ Singularity &/ BigBang markets array\n    /// @param twTap the TwTap contract\n    function withdrawAllMarketFees(IMarket[] calldata markets_, ITwTap twTap) external onlyOwner notPaused {\n        if (address(twTap) == address(0)) revert ZeroAddress();\n\n        uint256 length = markets_.length;\n        unchecked {\n            for (uint256 i; i < length;) {\n                _depositFeesToTwTap(markets_[i], twTap);\n                ++i;\n            }\n        }\n\n        emit ProtocolWithdrawal(markets_, block.timestamp);\n    }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider placing liquidation fees into Penrose internal account, leaving them with common YB account of SGL, e.g.:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/singularity/SGLLiquidation.sol#L304-L307\n\n```diff\n        if (feeShare > 0) {\n            uint256 feeAmount = yieldBox.toAmount(assetId, feeShare, false);\n+           uint256 fullAssetAmount = yieldBox.toAmount(assetId, totalAsset.elastic, false) + totalBorrow.elastic;\n+           uint256 feeFraction = (feeAmount * totalAsset.base) / fullAssetAmount;\n+           balanceOf[address(penrose)] += feeFraction;\n+           totalAsset.base += feeFraction.toUint128();\n+           totalAsset.elastic += feeShare.toUint128();\n-           yieldBox.depositAsset(assetId, address(this), address(penrose), feeAmount, 0);\n+           yieldBox.depositAsset(assetId, address(this), address(this), 0, feeShare);\n        }\n```\n\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Tapioca-DAO/Tapioca-bar/pull/371.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "Tapioca-bar/contracts/markets/singularity/SGLCommon.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {ISingularity, IMarket} from \"tapioca-periph/interfaces/bar/ISingularity.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n// Tapioca\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {ICluster} from \"tapioca-periph/interfaces/periph/ICluster.sol\";\nimport {SGLStorage} from \"./SGLStorage.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract SGLCommon is SGLStorage {\n    using RebaseLibrary for Rebase;\n    using SafeCast for uint256;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error TooMuch();\n    error MinLimit();\n    error TransferFailed();\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    /// @notice Accrues the interest on the borrowed tokens and handles the accumulation of fees.\n    function accrue() external {\n        _accrue();\n    }\n\n    function getInterestDetails()\n        external\n        view\n        returns (ISingularity.AccrueInfo memory _accrueInfo, uint256 utilization)\n    {\n        (_accrueInfo,,,,, utilization,) = _getInterestRate();\n    }\n\n    // ************************** //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _getInterestRate()\n        internal\n        view\n        returns (\n            ISingularity.AccrueInfo memory _accrueInfo,\n            Rebase memory _totalBorrow,\n            Rebase memory _totalAsset,\n            uint256 extraAmount,\n            uint256 feeFraction,\n            uint256 utilization,\n            bool logStartingInterest\n        )\n    {\n        _accrueInfo = accrueInfo;\n        _totalBorrow = totalBorrow;\n        _totalAsset = totalAsset;\n        extraAmount = 0;\n        feeFraction = 0;\n        logStartingInterest = false;\n\n        uint256 fullAssetAmount = yieldBox.toAmount(assetId, _totalAsset.elastic, false) + _totalBorrow.elastic;\n\n        utilization =\n            fullAssetAmount == 0 ? 0 : (uint256(_totalBorrow.elastic) * UTILIZATION_PRECISION) / fullAssetAmount;\n\n        // Number of seconds since accrue was called\n        uint256 elapsedTime = block.timestamp - _accrueInfo.lastAccrued;\n        if (elapsedTime == 0) {\n            return (_accrueInfo, totalBorrow, totalAsset, 0, 0, utilization, logStartingInterest);\n        }\n        _accrueInfo.lastAccrued = block.timestamp.toUint64();\n\n        if (_totalBorrow.base == 0) {\n            // If there are no borrows, reset the interest rate\n            if (_accrueInfo.interestPerSecond != startingInterestPerSecond) {\n                _accrueInfo.interestPerSecond = startingInterestPerSecond;\n                logStartingInterest = true;\n            }\n            return (_accrueInfo, _totalBorrow, totalAsset, 0, 0, utilization, logStartingInterest);\n        }\n\n        // Accrue interest\n        extraAmount = (uint256(_totalBorrow.elastic) * _accrueInfo.interestPerSecond * elapsedTime) / 1e18;\n        _totalBorrow.elastic += extraAmount.toUint128();\n\n        //take accrued values into account\n        fullAssetAmount = yieldBox.toAmount(assetId, _totalAsset.elastic, false) + _totalBorrow.elastic;\n\n        uint256 feeAmount = (extraAmount * protocolFee) / FEE_PRECISION; // % of interest paid goes to fee\n        feeFraction = (feeAmount * _totalAsset.base) / (fullAssetAmount - feeAmount);\n        _accrueInfo.feesEarnedFraction += feeFraction.toUint128();\n        _totalAsset.base = _totalAsset.base + feeFraction.toUint128();\n\n        utilization =\n            fullAssetAmount == 0 ? 0 : (uint256(_totalBorrow.elastic) * UTILIZATION_PRECISION) / fullAssetAmount;\n\n        // Update interest rate\n        if (utilization < minimumTargetUtilization) {\n            uint256 underFactor =\n                ((minimumTargetUtilization - utilization) * FACTOR_PRECISION) / minimumTargetUtilization;\n            uint256 scale = interestElasticity + (underFactor * underFactor * elapsedTime);\n            _accrueInfo.interestPerSecond =\n                ((uint256(_accrueInfo.interestPerSecond) * interestElasticity) / scale).toUint64();\n            if (_accrueInfo.interestPerSecond < minimumInterestPerSecond) {\n                _accrueInfo.interestPerSecond = minimumInterestPerSecond; // 0.25% APR minimum\n            }\n        } else if (utilization > maximumTargetUtilization) {\n            uint256 overFactor = ((utilization - maximumTargetUtilization) * FACTOR_PRECISION) / fullUtilizationMinusMax;\n            uint256 scale = interestElasticity + (overFactor * overFactor * elapsedTime);\n            uint256 newInterestPerSecond = (uint256(_accrueInfo.interestPerSecond) * scale) / interestElasticity;\n            if (newInterestPerSecond > maximumInterestPerSecond) {\n                newInterestPerSecond = maximumInterestPerSecond; // 1000% APR maximum\n            }\n            _accrueInfo.interestPerSecond = newInterestPerSecond.toUint64();\n        }\n    }\n\n    function _accrueView() internal view override returns (Rebase memory _totalBorrow) {\n        (, _totalBorrow,,,,,) = _getInterestRate();\n    }\n\n    function _accrue() internal override {\n        (\n            ISingularity.AccrueInfo memory _accrueInfo,\n            Rebase memory _totalBorrow,\n            Rebase memory _totalAsset,\n            uint256 extraAmount,\n            uint256 feeFraction,\n            uint256 utilization,\n            bool logStartingInterest\n        ) = _getInterestRate();\n\n        if (logStartingInterest) {\n            emit LogAccrue(0, 0, startingInterestPerSecond, 0);\n        } else {\n            emit LogAccrue(extraAmount, feeFraction, _accrueInfo.interestPerSecond, utilization);\n        }\n        accrueInfo = _accrueInfo;\n        totalBorrow = _totalBorrow;\n        totalAsset = _totalAsset;\n    }\n\n    /// @dev Helper function to move tokens.\n    /// @param from Account to debit tokens from, in `yieldBox`.\n    /// @param _assetId The ERC-20 token asset ID in yieldBox.\n    /// @param share The amount in shares to add.\n    /// @param total Grand total amount to deduct from this contract's balance. Only applicable if `skim` is True.\n    /// Only used for accounting checks.\n    /// @param skim If True, only does a balance check on this contract.\n    /// False if tokens from msg.sender in `yieldBox` should be transferred.\n    function _addTokens(address from, address, uint256 _assetId, uint256 share, uint256 total, bool skim) internal {\n        if (skim) {\n            if (share > yieldBox.balanceOf(address(this), _assetId) - total) {\n                revert TooMuch();\n            }\n        } else {\n            // yieldBox.transfer(from, address(this), _assetId, share);\n            bool isErr = pearlmit.transferFromERC1155(from, address(this), address(yieldBox), _assetId, share);\n            if (isErr) {\n                revert TransferFailed();\n            }\n        }\n    }\n\n    /// @dev Concrete implementation of `addAsset`.\n    function _addAsset(address from, address to, bool skim, uint256 share) internal returns (uint256 fraction) {\n        Rebase memory _totalAsset = totalAsset;\n        uint256 totalAssetShare = _totalAsset.elastic;\n        uint256 allShare = _totalAsset.elastic + yieldBox.toShare(assetId, totalBorrow.elastic, true);\n        fraction = allShare == 0 ? share : (share * _totalAsset.base) / allShare;\n        if (_totalAsset.base + fraction.toUint128() < 1000) {\n            return 0;\n        }\n        totalAsset = _totalAsset.add(share, fraction);\n\n        balanceOf[to] += fraction;\n        emit Transfer(address(0), to, fraction);\n\n        _addTokens(from, to, assetId, share, totalAssetShare, skim);\n        emit LogAddAsset(skim ? address(yieldBox) : from, to, share, fraction);\n    }\n\n    /// @dev Concrete implementation of `removeAsset`.\n    /// @param from The account to remove from. Should always be msg.sender except for `depositFeesToyieldBox()`.\n    function _removeAsset(address from, address to, uint256 fraction) internal returns (uint256 share) {\n        if (totalAsset.base == 0) {\n            return 0;\n        }\n        Rebase memory _totalAsset = totalAsset;\n        uint256 allShare = _totalAsset.elastic + yieldBox.toShare(assetId, totalBorrow.elastic, false);\n        share = (fraction * allShare) / _totalAsset.base;\n\n        _totalAsset.base -= fraction.toUint128();\n        if (_totalAsset.base < 1000) revert MinLimit();\n\n        balanceOf[from] -= fraction;\n        emit Transfer(from, address(0), fraction);\n        _totalAsset.elastic -= share.toUint128();\n        totalAsset = _totalAsset;\n        emit LogRemoveAsset(from, to, share, fraction);\n        yieldBox.transfer(address(this), to, assetId, share);\n    }\n\n    /// @dev Return the equivalent of collateral borrow part in asset amount.\n    function _getAmountForBorrowPart(uint256 borrowPart) internal view returns (uint256) {\n        return totalBorrow.toElastic(borrowPart, false);\n    }\n\n    function _isWhitelisted(uint16 _chainId, address _contract) internal view returns (bool) {\n        return ICluster(penrose.cluster()).isWhitelisted(_chainId, _contract);\n    }\n\n    struct _ViewLiquidationStruct {\n        address user;\n        uint256 maxBorrowPart;\n        uint256 minLiquidationBonus;\n        uint256 exchangeRate;\n        IYieldBox yieldBox;\n        uint256 collateralId;\n        uint256 userCollateralShare;\n        uint256 userBorrowPart;\n        Rebase totalBorrow;\n        uint256 liquidationBonusAmount;\n        uint256 liquidationCollateralizationRate;\n        uint256 liquidationMultiplier;\n        uint256 exchangeRatePrecision;\n        uint256 feeDecimalsPrecision;\n    }\n}"
    },
    {
      "filename": "Tapioca-bar/contracts/Penrose.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {IERC20} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport {BoringFactory} from \"@boringcrypto/boring-solidity/contracts/BoringFactory.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n// Tapioca\nimport {\n    ERC20WithoutStrategy, IStrategy, IYieldBox as IBoringYieldBox\n} from \"yieldbox/strategies/ERC20WithoutStrategy.sol\";\nimport {PearlmitHandler, IPearlmit} from \"tapioca-periph/pearlmit/PearlmitHandler.sol\";\nimport {ICluster} from \"tapioca-periph/interfaces/periph/ICluster.sol\";\nimport {IMarket} from \"tapioca-periph/interfaces/bar/ISingularity.sol\";\nimport {ITwTap} from \"tapioca-periph/interfaces/tap-token/ITwTap.sol\";\nimport {IPenrose} from \"tapioca-periph/interfaces/bar/IPenrose.sol\";\nimport {IBigBang} from \"tapioca-periph/interfaces/bar/IBigBang.sol\";\nimport {TokenType} from \"yieldbox/enums/YieldBoxTokenType.sol\";\nimport {IUsdo} from \"tapioca-periph/interfaces/oft/IUsdo.sol\";\nimport {IYieldBox} from \"yieldbox/interfaces/IYieldBox.sol\";\nimport {SafeApprove} from \"./libraries/SafeApprove.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/// @title Global market registry\n/// @notice Singularity management\ncontract Penrose is Ownable, PearlmitHandler, BoringFactory {\n    using SafeApprove for address;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    /// @notice returns the Conservator address\n    address public conservator;\n    /// @notice returns the pause state of the contract\n    bool public paused;\n    /// @notice returns the Cluster contract\n    ICluster public cluster;\n\n    /// @notice returns the YieldBox contract\n    IYieldBox public immutable yieldBox;\n    /// @notice returns the TAP contract\n    IERC20 public immutable tapToken;\n    /// @notice returns TAP asset id registered in the YieldBox contract\n    uint256 public immutable tapAssetId;\n    /// @notice returns USDO contract\n    IERC20 public usdoToken;\n    /// @notice returns USDO asset id registered in the YieldBox contract\n    uint256 public usdoAssetId;\n    /// @notice returns the WETH/main contract\n    IERC20 public immutable mainToken;\n    /// @notice returns WETH/main asset id registered in the YieldBox contract\n    uint256 public immutable mainAssetId;\n\n    /// @notice Singularity master contracts\n    IPenrose.MasterContract[] public singularityMasterContracts;\n    /// @notice BigBang master contracts\n    IPenrose.MasterContract[] public bigbangMasterContracts;\n\n    /// @notice Used to check if a Singularity master contract is registered\n    mapping(address => bool) public isSingularityMasterContractRegistered;\n    /// @notice Used to check if a BigBang master contract is registered\n    mapping(address => bool) public isBigBangMasterContractRegistered;\n    /// @notice Used to check if a SGL/BB is a real market\n    mapping(address => bool) public isMarketRegistered;\n    /// @notice default LZ Chain id\n    uint32 public immutable hostLzChainId;\n\n    /// @notice BigBang ETH market addressf\n    address public bigBangEthMarket;\n    /// @notice BigBang ETH market debt rate\n    uint256 public bigBangEthDebtRate;\n\n    /// @notice registered empty strategies\n    mapping(address => IStrategy) public emptyStrategies;\n\n    address[] public allBigBangMarkets;\n\n    mapping(address => bool) public isOriginRegistered;\n    address[] public allOriginsMarkets;\n\n    /// @notice creates a Penrose contract\n    /// @param _yieldBox YieldBox contract address\n    /// @param _cluster Cluster contract address\n    /// @param tapToken_ TapOFT contract address\n    /// @param mainToken_ WETH contract address\n    /// @param _owner owner address\n    constructor(\n        IYieldBox _yieldBox,\n        ICluster _cluster,\n        IERC20 tapToken_,\n        IERC20 mainToken_,\n        IPearlmit _pearlmit,\n        address _owner\n    ) PearlmitHandler(_pearlmit) {\n        yieldBox = _yieldBox;\n        cluster = _cluster;\n        tapToken = tapToken_;\n\n        emptyStrategies[address(tapToken_)] =\n            IStrategy(address(new ERC20WithoutStrategy(IBoringYieldBox(address(_yieldBox)), tapToken_)));\n        tapAssetId = uint96(\n            _yieldBox.registerAsset(\n                TokenType.ERC20, address(tapToken_), address(emptyStrategies[address(tapToken_)]), 0\n            )\n        );\n\n        mainToken = mainToken_;\n        emptyStrategies[address(mainToken_)] =\n            IStrategy(address(new ERC20WithoutStrategy(IBoringYieldBox(address(_yieldBox)), mainToken_)));\n        mainAssetId = uint96(\n            _yieldBox.registerAsset(\n                TokenType.ERC20, address(mainToken_), address(emptyStrategies[address(mainToken_)]), 0\n            )\n        );\n\n        bigBangEthDebtRate = 5e15;\n\n        _transferOwnership(_owner);\n    }\n\n    // **************//\n    // *** EVENTS *** //\n    // ************** //\n    /// @notice event emitted when fees are extracted\n    event ProtocolWithdrawal(IMarket[] indexed markets, uint256 indexed timestamp);\n    /// @notice event emitted when Singularity master contract is registered\n    event RegisterSingularityMasterContract(address indexed location, IPenrose.ContractType indexed risk);\n    /// @notice event emitted when BigBang master contract is registered\n    event RegisterBigBangMasterContract(address indexed location, IPenrose.ContractType indexed risk);\n    /// @notice event emitted when Singularity is registered\n    event RegisterSingularity(address indexed location, address indexed masterContract);\n    /// @notice event emitted when BigBang is registered\n    event RegisterBigBang(address indexed location, address indexed masterContract);\n    /// @notice event emitted when Origins is registered\n    event RegisterOrigins(address indexed location);\n    /// @notice event emitted when USDO address is updated\n    event UsdoTokenUpdated(address indexed usdoToken, uint256 indexed assetId);\n    /// @notice event emitted when conservator is updated\n    event ConservatorUpdated(address indexed old, address indexed _new);\n    /// @notice event emitted when pause state is updated\n    event PausedUpdated(bool indexed oldState, bool indexed newState);\n    /// @notice event emitted when BigBang ETH market address is updated\n    event BigBangEthMarketUpdated(address indexed _oldAddress, address indexed _newAddress);\n    /// @notice event emitted when BigBang ETH market debt rate is updated\n    event BigBangEthMarketDebtRateUpdated(uint256 indexed _oldRate, uint256 indexed _newRate);\n    /// @notice event emitted when fees are deposited to twTap\n    event LogTwTapFeesDeposit(uint256 indexed amount);\n    /// @notice event emitted when Cluster is set\n    event ClusterSet(address indexed old, address indexed _new);\n    /// @notice event emitted when total BB markets debt is computed\n    event TotalUsdoDebt(uint256 indexed amount);\n    /// @notice event emitted when markets are re-accrued\n    event ReaccruedMarkets(bool indexed mainMarketIncluded);\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error NotRegistered();\n    error NotValid();\n    error Paused();\n    error NotAuthorized();\n    error Registered();\n    error ZeroAddress();\n    error Failed();\n    error AlreadyAdded();\n    error LengthMismatch();\n\n    // ******************//\n    // *** MODIFIERS *** //\n    // ***************** //\n    modifier registeredSingularityMasterContract(address mc) {\n        if (!isSingularityMasterContractRegistered[mc]) revert NotRegistered();\n        _;\n    }\n\n    modifier registeredBigBangMasterContract(address mc) {\n        if (!isBigBangMasterContractRegistered[mc]) revert NotRegistered();\n        _;\n    }\n\n    modifier notPaused() {\n        if (paused) revert Paused();\n        _;\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice Get all the Singularity contract addresses\n    /// @return markets list of available markets\n    function singularityMarkets() external view returns (address[] memory markets) {\n        markets = getAllMasterContractClones(singularityMasterContracts);\n    }\n\n    /// @notice Get all the BigBang contract addresses\n    /// @return markets list of available markets\n    function bigBangMarkets() external view returns (address[] memory markets) {\n        markets = getAllMasterContractClones(bigbangMasterContracts);\n    }\n\n    /// @notice Get the length of `singularityMasterContracts`\n    function singularityMasterContractLength() external view returns (uint256) {\n        return singularityMasterContracts.length;\n    }\n\n    /// @notice Get the length of `bigbangMasterContracts`\n    function bigBangMasterContractLength() external view returns (uint256) {\n        return bigbangMasterContracts.length;\n    }\n\n    /// @notice Returns total markets debt\n    /// @dev does not include Origins markets\n    function viewTotalDebt() public view returns (uint256) {\n        uint256 _totalUsdoDebt = 0;\n        uint256 len = allBigBangMarkets.length;\n        for (uint256 i; i < len; i++) {\n            IMarket market = IMarket(allBigBangMarkets[i]);\n            if (isMarketRegistered[address(market)]) {\n                (uint256 elastic,) = market.totalBorrow();\n                _totalUsdoDebt += elastic;\n            }\n        }\n\n        return _totalUsdoDebt;\n    }\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n    /// @notice Loop through the master contracts and call `_depositFeesToTwTap()` to each one of their clones.\n    /// @param markets_ Singularity &/ BigBang markets array\n    /// @param twTap the TwTap contract\n    function withdrawAllMarketFees(IMarket[] calldata markets_, ITwTap twTap) external onlyOwner notPaused {\n        if (address(twTap) == address(0)) revert ZeroAddress();\n\n        uint256 length = markets_.length;\n        unchecked {\n            for (uint256 i; i < length;) {\n                _depositFeesToTwTap(markets_[i], twTap);\n                ++i;\n            }\n        }\n\n        emit ProtocolWithdrawal(markets_, block.timestamp);\n    }\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n    /// @notice mints USDO based on current open interest\n    /// @dev Penrose should be an allowed minter for USDO\n    /// @param twTap the twTap contract address\n    function mintOpenInterestDebt(address twTap) external onlyOwner {\n        uint256 usdoSupply = usdoToken.totalSupply();\n\n        // nothing to mint when there's no activity\n        if (usdoSupply > 0) {\n            // re-compute latest debt\n            uint256 totalUsdoDebt = computeTotalDebt();\n\n            //add Origins debt\n            //Origins market doesn't accrue in time but increases totalSupply\n            //and needs to be taken into account here\n            uint256 len = allOriginsMarkets.length;\n            for (uint256 i; i < len; i++) {\n                IMarket market = IMarket(allOriginsMarkets[i]);\n                if (isOriginRegistered[address(market)]) {\n                    (uint256 elastic,) = market.totalBorrow();\n                    totalUsdoDebt += elastic;\n                }\n            }\n\n            //debt should always be > USDO supply\n            if (totalUsdoDebt > usdoSupply) {\n                uint256 _amount = totalUsdoDebt - usdoSupply;\n\n                //mint against the open interest; supply should be fully minted now\n                IUsdo(address(usdoToken)).mint(address(this), _amount);\n\n                //send it to twTap\n                uint256 rewardTokenId = ITwTap(twTap).rewardTokenIndex(address(usdoToken));\n                _distributeOnTwTap(_amount, rewardTokenId, address(usdoToken), ITwTap(twTap));\n            }\n        }\n    }\n\n    /// @notice sets the Cluster address\n    /// @dev can only be called by the owner\n    /// @param _newCluster the new address\n    function setCluster(address _newCluster) external onlyOwner {\n        if (_newCluster == address(0)) revert ZeroAddress();\n        emit ClusterSet(address(cluster), _newCluster);\n        cluster = ICluster(_newCluster);\n    }\n\n    /// @notice sets the main BigBang market debt rate\n    /// @dev can only be called by the owner\n    /// @param _rate the new rate\n    function setBigBangEthMarketDebtRate(uint256 _rate) external onlyOwner {\n        if (bigBangEthMarket != address(0)) {\n            IBigBang(bigBangEthMarket).accrue();\n        }\n        bigBangEthDebtRate = _rate;\n        emit BigBangEthMarketDebtRateUpdated(bigBangEthDebtRate, _rate);\n    }\n\n    /// @notice sets the main BigBang market\n    /// @dev needed for the variable debt computation\n    /// @param _market the new market address\n    function setBigBangEthMarket(address _market) external onlyOwner {\n        if (_market == address(0)) revert ZeroAddress();\n\n        if (bigBangEthMarket != address(0)) {\n            uint256 len = allBigBangMarkets.length;\n            address[] memory markets = allBigBangMarkets;\n            for (uint256 i = 0; i < len; i++) {\n                address market = markets[i];\n                if (market != bigBangEthMarket && isMarketRegistered[market]) {\n                    IBigBang(market).accrue();\n                }\n            }\n        }\n\n        emit BigBangEthMarketUpdated(bigBangEthMarket, _market);\n        bigBangEthMarket = _market;\n    }\n\n    /// @notice updates the pause state of the contract\n    /// @dev can only be called by the conservator\n    /// @param val the new value\n    function updatePause(bool val) external {\n        if (msg.sender != conservator) revert NotAuthorized();\n        if (val == paused) revert NotValid();\n        emit PausedUpdated(paused, val);\n        paused = val;\n    }\n\n    /// @notice Set the Conservator address\n    /// @dev Conservator can pause the contract\n    /// @param _conservator The new address\n    function setConservator(address _conservator) external onlyOwner {\n        if (_conservator == address(0)) revert ZeroAddress();\n        emit ConservatorUpdated(conservator, _conservator);\n        conservator = _conservator;\n    }\n\n    /// @notice Set the USDO token\n    /// @dev sets usdoToken and usdoAssetId\n    ///      can only by called by the owner\n    /// @param _usdoToken the USDO token address\n    function setUsdoToken(address _usdoToken) external onlyOwner {\n        if (address(usdoToken) != address(0)) revert NotAuthorized();\n        usdoToken = IERC20(_usdoToken);\n\n        emptyStrategies[_usdoToken] =\n            IStrategy(address(new ERC20WithoutStrategy(IBoringYieldBox(address(yieldBox)), IERC20(_usdoToken))));\n        usdoAssetId =\n            uint96(yieldBox.registerAsset(TokenType.ERC20, _usdoToken, address(emptyStrategies[_usdoToken]), 0));\n        emit UsdoTokenUpdated(_usdoToken, usdoAssetId);\n    }\n\n    /// @notice Register a Singularity master contract\n    /// @dev can only be called by the owner\n    /// @param mcAddress The address of the contract\n    /// @param contractType_ The risk type of the contract\n    function registerSingularityMasterContract(address mcAddress, IPenrose.ContractType contractType_)\n        external\n        onlyOwner\n    {\n        if (isSingularityMasterContractRegistered[mcAddress]) {\n            revert Registered();\n        }\n\n        IPenrose.MasterContract memory mc;\n        mc.location = mcAddress;\n        mc.risk = contractType_;\n        singularityMasterContracts.push(mc);\n        isSingularityMasterContractRegistered[mcAddress] = true;\n\n        emit RegisterSingularityMasterContract(mcAddress, contractType_);\n    }\n\n    /// @notice Register a BigBang master contract\n    /// @dev can only be called by the owner\n    /// @param mcAddress The address of the contract\n    /// @param contractType_ The risk type of the contract\n    function registerBigBangMasterContract(address mcAddress, IPenrose.ContractType contractType_) external onlyOwner {\n        if (isBigBangMasterContractRegistered[mcAddress]) revert Registered();\n\n        IPenrose.MasterContract memory mc;\n        mc.location = mcAddress;\n        mc.risk = contractType_;\n        bigbangMasterContracts.push(mc);\n        isBigBangMasterContractRegistered[mcAddress] = true;\n\n        emit RegisterBigBangMasterContract(mcAddress, contractType_);\n    }\n\n    /// @notice Registers a Singularity market\n    /// @dev can only be called by the owner\n    /// @param mc The address of the master contract which must be already registered\n    /// @param data The init data of the Singularity\n    /// @param useCreate2 Whether to use create2 or not\n    /// @return _contract the created contract\n    function registerSingularity(address mc, bytes calldata data, bool useCreate2)\n        external\n        payable\n        onlyOwner\n        registeredSingularityMasterContract(mc)\n        returns (address _contract)\n    {\n        _contract = deploy(mc, data, useCreate2);\n        if (_contract == address(0)) revert ZeroAddress();\n        if (_contract.code.length == 0) revert Failed();\n        isMarketRegistered[_contract] = true;\n        emit RegisterSingularity(_contract, mc);\n    }\n\n    /// @notice Registers an existing Singularity market (without deployment)\n    /// @dev can only be called by the owner\n    /// @param mc The address of the master contract which must be already registered\n    /// @param _contract The address of SGL\n    function addSingularity(address mc, address _contract) external onlyOwner registeredSingularityMasterContract(mc) {\n        if (isMarketRegistered[_contract]) revert AlreadyAdded();\n        isMarketRegistered[_contract] = true;\n        clonesOf[mc].push(_contract);\n        masterContractOf[_contract] = mc;\n        emit RegisterSingularity(_contract, mc);\n    }\n\n    /// @notice Registers a BigBang market\n    /// @dev can only be called by the owner\n    /// @param mc The address of the master contract which must be already registered\n    /// @param data The init data of the BigBang contract\n    /// @param useCreate2 Whether to use create2 or not\n    /// @return _contract the created contract\n    function registerBigBang(address mc, bytes calldata data, bool useCreate2)\n        external\n        payable\n        onlyOwner\n        registeredBigBangMasterContract(mc)\n        returns (address _contract)\n    {\n        _contract = deploy(mc, data, useCreate2);\n        if (_contract == address(0)) revert ZeroAddress();\n        if (_contract.code.length == 0) revert Failed();\n        isMarketRegistered[_contract] = true;\n        allBigBangMarkets.push(_contract);\n        emit RegisterBigBang(_contract, mc);\n    }\n\n    /// @notice Registers an existing BigBang market (without deployment)\n    /// @dev can only be called by the owner\n    /// @param mc The address of the master contract which must be already registered\n    /// @param _contract The address of BB\n    function addBigBang(address mc, address _contract) external onlyOwner registeredBigBangMasterContract(mc) {\n        if (isMarketRegistered[_contract]) revert AlreadyAdded();\n        isMarketRegistered[_contract] = true;\n        clonesOf[mc].push(_contract);\n        masterContractOf[_contract] = mc;\n        allBigBangMarkets.push(_contract);\n        emit RegisterBigBang(_contract, mc);\n    }\n\n    function addOriginsMarket(address _contract) external onlyOwner {\n        if (isOriginRegistered[_contract]) revert AlreadyAdded();\n        isOriginRegistered[_contract] = true;\n        allOriginsMarkets.push(_contract);\n        emit RegisterOrigins(_contract);\n    }\n\n    /// @notice Execute an only owner function inside of a Singularity or a BigBang market\n    /// @param mc Master contracts array\n    /// @param data array\n    /// @param forceSuccess if true, method reverts in case of an unsuccessful execution\n    function executeMarketFn(address[] calldata mc, bytes[] memory data, bool forceSuccess)\n        external\n        onlyOwner\n        returns (bool[] memory success, bytes[] memory result)\n    {\n        uint256 len = mc.length;\n        if (len != data.length) revert LengthMismatch();\n        success = new bool[](len);\n        result = new bytes[](len);\n        for (uint256 i; i < len;) {\n            if (\n                !isSingularityMasterContractRegistered[masterContractOf[mc[i]]]\n                    && !isBigBangMasterContractRegistered[masterContractOf[mc[i]]]\n            ) revert NotAuthorized();\n            if (address(mc[i]).code.length == 0) revert NotValid();\n            (success[i], result[i]) = mc[i].call(data[i]);\n            if (forceSuccess) {\n                require(success[i], _getRevertMsg(result[i]));\n            }\n            ++i;\n        }\n    }\n\n    /// @notice Calls `accrue()` on all BigBang registered markets\n    /// @dev callable by BigBang ETH market only\n    function reAccrueBigBangMarkets() external notPaused {\n        if (msg.sender == bigBangEthMarket) {\n            _reAccrueMarkets(false);\n        }\n    }\n\n    /// @notice computes total USDO debt of all BB markets\n    /// @dev this works because all BB markets have USDO as the asset\n    function computeTotalDebt() public notPaused returns (uint256 totalUsdoDebt) {\n        // allow other registered Markets, owner or Penrose to call it\n        if (!isMarketRegistered[msg.sender] && msg.sender != owner() && msg.sender != address(this)) {\n            revert NotAuthorized();\n        }\n\n        //accrue to the latest point in time\n        _reAccrueMarkets(true);\n\n        // compute debt\n        totalUsdoDebt = viewTotalDebt();\n\n        emit TotalUsdoDebt(totalUsdoDebt);\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _getRevertMsg(bytes memory _returnData) private pure returns (string memory) {\n        if (_returnData.length > 1000) return \"SGL: reason too long\";\n\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return \"SGL: no return data\";\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n\n    function _reAccrueMarkets(bool includeMainMarket)"
    }
  ]
}