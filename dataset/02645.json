{
  "Title": "M-10: Vault_Base_ERC20#_updateVirtualPrice calculates interest incorrectly if updated frequently",
  "Content": "# Issue M-10: Vault_Base_ERC20#_updateVirtualPrice calculates interest incorrectly if updated frequently \n\nSource: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/158 \n\n## Found by \nbin2chen, HollaDieWaldfee, Jeiwan, hansfriese, libratus, rvierdiiev, wagmi, 0x52, KingNFT, Atarpara\n\n## Summary\n\nUpdating the virtual price of an asset happens in discrete increments of 3 minutes. This is done to reduce the chance of DOS loops. The issue is that it updates the time to an incorrect timestamp. It should update to the truncated 3 minute interval but instead updates to the current timestamp. The result is that the interest calculation can be abused to lower effective interest rate.\n\n## Vulnerability Detail\n\n    function _updateVirtualPrice(uint256 _currentBlockTime, address _collateralAddress) internal { \n        (   ,\n            ,\n            ,\n            uint256 interestPer3Min,\n            uint256 lastUpdateTime,\n            uint256 virtualPrice,\n\n        ) = _getCollateral(_collateralAddress);\n        uint256 timeDelta = _currentBlockTime - lastUpdateTime;\n        //exit gracefully if two users call the function for the same collateral in the same 3min period\n        //@audit increments \n        uint256 threeMinuteDelta = timeDelta / 180; \n        if(threeMinuteDelta > 0) {\n            for (uint256 i = 0; i < threeMinuteDelta; i++ ){\n            virtualPrice = (virtualPrice * interestPer3Min) / LOAN_SCALE; \n            }\n            collateralBook.vaultUpdateVirtualPriceAndTime(_collateralAddress, virtualPrice, _currentBlockTime);\n        }\n    }\n\n_updateVirtualPrice is used to update the interest calculations for the specified collateral and is always called with block.timestamp. Due to truncation threeMinuteDelta is always rounded down, that is if there has been 1.99 3-minute intervals it will truncate to 1. The issue is that in the collateralBook#vaultUpdateVirtualPriceAndTime subcall the time is updated to block.timestamp (_currentBlockTime). \n\nExample:\nlastUpdateTime = 1000 and block.timestamp (_currentBlockTime) = 1359.\n\ntimeDelta = 1359 - 1000 = 359\n\nthreeMinuteDelta = 359 / 180 = 1\n\nThis updates the interest by only as single increment but pushes the new time forward 359 seconds. When called again it will use 1359 as lastUpdateTime which means that 179 seconds worth of interest have been permanently lost. Users with large loan positions could abuse this to effectively halve their interest accumulation. Given how cheap optimism transactions are it is highly likely this could be exploited profitably with a bot.\n\n## Impact\n\nInterest calculations will be incorrect if they are updated frequently, which can be abused by users with large amounts of debt to halve their accumulated interest\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/Vault_Base_ERC20.sol#L203-L221\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nBefore updating the interest time it should first truncate it to the closest 3-minute interval:\n\n        if(threeMinuteDelta > 0) {\n            for (uint256 i = 0; i < threeMinuteDelta; i++ ){\n                virtualPrice = (virtualPrice * interestPer3Min) / LOAN_SCALE; \n            }\n    +       _currentBlockTime = (_currentBlockTime / 180) * 180;\n            collateralBook.vaultUpdateVirtualPriceAndTime(_collateralAddress, virtualPrice, _currentBlockTime);\n        }\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor confirmed, will fix.\n\n**kree-dotcom**\n\nFixed https://github.com/kree-dotcom/isomorph/commit/ae410496c024af5b061cf85997f225ae46fd56e6\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/22",
  "Code": [
    {
      "filename": "contracts/Isomorph/contracts/Vault_Base_ERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Vault_Base_ERC20.sol for isomorph.loans\n// Bug bounties available\n\npragma solidity =0.8.9; \npragma abicoder v2;\n\n// Interfaces\nimport \"./interfaces/IisoUSDToken.sol\";\nimport \"./interfaces/ICollateralBook.sol\";\n\n//Open Zeppelin dependancies\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\n//Time delayed governance\nimport \"./RoleControl.sol\";\n\nuint256 constant VAULT_TIME_DELAY = 3 days;\n\nabstract contract Vault_Base_ERC20 is RoleControl(VAULT_TIME_DELAY), Pausable {\n\n    \n    //these mappings store the loan details of each users loan against each collateral.\n    //collateral address => user address => quantity\n    mapping(address => mapping(address => uint256)) public collateralPosted;\n    //this stores the original loan principle requested, used for burning when closing\n    //collateral address => user address => loan principle quantity\n    mapping(address => mapping(address => uint256)) public isoUSDLoaned;\n    //this records loan amounts requested and grows by interest accrued\n    //collateral address => user address => total loan and interest owed\n    mapping(address => mapping(address => uint256)) public isoUSDLoanAndInterest;\n\n    //variables relating to access control and setting new roles\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    //Constants\n    uint256 public constant LIQUIDATION_RETURN = 95 ether /100; //95% returned on liquidiation\n    uint256 public constant LOAN_SCALE = 1 ether; //base for division/decimal maths\n    uint256 public constant TENTH_OF_CENT = 1 ether /1000; //$0.001\n\n    //Enums// collateral type identifiers to revert if the wrong collateral is interacted with by the wrong Vault.\n    enum AssetType {Synthetix_Synth, Lyra_LP} \n    \n    \n    //Variables \n    //These three control max loans opened per day\n    uint256 public dailyMax = 1_000_000 ether; //one million with 18d.p.\n    uint256 public dayCounter = block.timestamp;\n    uint256 public dailyTotal = 0;\n\n    //These two handle fees paid to liquidators and the protocol by users \n    uint256 public loanOpenFee = 1 ether /100; //1 percent opening fee.\n\n    \n    //The treasury is where moUSD fees are paid, to keep this upgradable we allow changing by the admin, after a timelock period\n    address public treasury;\n    address public pendingTreasury;\n    uint256 public updateTreasuryTimestamp;\n\n    IisoUSDToken public isoUSD;\n    ICollateralBook public collateralBook;\n    \n   \n\n    event OpenOrIncreaseLoan(address indexed user, uint256 loanTaken, bytes32 indexed collateralToken, uint256 collateralAmount); \n    event IncreaseCollateral(address indexed user, bytes32 indexed collateralToken, uint256 collateralAmount); \n    event ClosedLoan(address indexed user, uint256 loanAmountReturned, bytes32 indexed collateralToken, uint256 returnedCapital);\n    event Liquidation(address indexed loanHolder, address indexed Liquidator, uint256 loanAmountReturned, bytes32 indexed collateralToken, uint256 liquidatedCapital);\n    event BadDebtCleared(address indexed loanHolder, address indexed Liquidator, uint256 debtCleared, bytes32 indexed collateralToken);\n    event ChangeDailyMax(uint256 newDailyMax, uint256 oldDailyMax);\n    event ChangeOpenLoanFee(uint256 newOpenLoanFee, uint256 oldOpenLoanFee);\n    event ChangeTreasury(address oldTreasury, address newTreasury);\n\n    event SystemPaused(address indexed pausedBy);\n    event SystemUnpaused(address indexed unpausedBy);\n    \n\n    /**\n        External onlyAdmin or onlyPauser governance functions\n     */\n\n\n    /// @notice sets state to paused only triggerable by pauser (all admins are pausers also)\n    function pause() external  {\n        bool validUser = hasRole(ADMIN_ROLE, msg.sender) || hasRole(PAUSER_ROLE, msg.sender);\n        require(validUser, \"Caller is not able to call pause\");\n        _pause();\n        emit SystemPaused(msg.sender);\n    }\n    /// @notice sets state to unpaused only triggerable by admin\n    function unpause() external onlyAdmin {\n        _unpause();\n        emit SystemUnpaused(msg.sender);\n    }\n\n    /// @notice dailyMax can be set to 0 effectively preventing anyone from opening new loans.\n    function setDailyMax(uint256 _newDailyMax) external onlyAdmin {\n        require(_newDailyMax < 100_000_000 ether ); //sanity check, require less than 100 million opened per day\n        emit ChangeDailyMax(_newDailyMax, dailyMax); //ignoring CEI pattern here\n        dailyMax = _newDailyMax;\n        \n        \n    }\n\n    /// @notice openLoanFee can be set to 10% max, fee applied to all loans on opening\n    function setOpenLoanFee(uint256 _newOpenLoanFee) external onlyAdmin {\n        require(_newOpenLoanFee <= 1 ether /10 ); \n        emit ChangeOpenLoanFee(_newOpenLoanFee, loanOpenFee); //ignoring CEI pattern here\n        loanOpenFee = _newOpenLoanFee;\n        \n        \n    }\n\n    /// @notice admin only function to queue treasury address change which must wait the timelock period before being implemented\n    function proposeTreasury(address _newTreasury) external onlyAdmin {\n        require(_newTreasury != address(0)); \n        pendingTreasury = _newTreasury;\n        updateTreasuryTimestamp = block.timestamp + VAULT_TIME_DELAY;\n    }\n\n    /// @notice admin only function to change treasury target after timelock delay\n    function setTreasury() external onlyAdmin {\n        require(updateTreasuryTimestamp < block.timestamp); \n        address copyOfPendingTreasury = pendingTreasury;\n        require(copyOfPendingTreasury != address(0));\n        emit ChangeTreasury(treasury, copyOfPendingTreasury); //ignoring CEI pattern here\n        treasury = copyOfPendingTreasury;\n    }\n\n    /**\n        Internal helper and check functions\n     */\n\n    /// @dev process for Synthetix assets\n    /// @dev leverages synthetix system to verify that the collateral in question is currently trading\n    /// @dev this prevents people frontrunning closed weekend markets for expected price crashes etc\n    /// @notice this call verifies Synthetix system, exchange and the synths in question are all available.\n    /// @notice if any of them aren't the function will revert.\n    /// @param _currencyKey the code used by synthetix to identify different synths, linked in collateral structure to collateral address\n    function _checkIfCollateralIsActive(bytes32 _currencyKey) internal virtual view;\n\n    /// @notice while this could be abused to DOS the system, given the openLoan fee this is an expensive attack to maintain\n    function _checkDailyMaxLoans(uint256 _amountAdded) internal {\n        if (block.timestamp > dayCounter + 1 days ){\n            dailyTotal = _amountAdded;\n            dayCounter = block.timestamp;\n        }\n        else{\n            dailyTotal += _amountAdded;\n        }\n        require( dailyTotal  < dailyMax, \"Try again tomorrow loan opening limit hit\");\n    }\n    \n    /// @notice basic checks to verify collateral being used exists\n    /// @dev should be called by any external function modifying a loan\n    function _collateralExists(address _collateralAddress) internal {\n        require(collateralBook.collateralValid(_collateralAddress), \"Unsupported collateral!\");\n    }\n\n    /// @param _collateralAddress the address of the collateral token you are fetching\n    /// @notice returns all collateral struct fields seperately so that functions requiring \n    /// @notice them can only locally store the ones they need\n    function _getCollateral(address _collateralAddress) internal returns(\n        bytes32 ,\n        uint256 ,\n        uint256 ,\n        uint256 ,\n        uint256 ,\n        uint256,\n        AssetType \n        ){\n        ICollateralBook.Collateral memory collateral = collateralBook.collateralProps(_collateralAddress);\n        return (\n            collateral.currencyKey,\n            collateral.minOpeningMargin,\n            collateral.liquidatableMargin, \n            collateral.interestPer3Min, \n            collateral.lastUpdateTime, \n            collateral.virtualPrice,\n            AssetType(collateral.assetType)\n            );\n    }\n\n\n\n    /// @param _percentToPay the percentage of the total sum express as a fee\n    /// @param _amount quantity of which to work out the percentage splits of\n    /// @dev internal function used to calculate treasury fees on opening loans\n    /// @return postFees is the quantity after the percentToPay has been deducted from it,\n    /// @return feeToPay is the percentToPay of original _amount.\n    function _findFees(uint256 _percentToPay, uint256 _amount) internal pure returns(uint256, uint256){\n        uint256 feeToPay = ((_amount * _percentToPay) / LOAN_SCALE);\n        uint256 postFees = _amount - feeToPay; //if the user loan is too small this will revert\n        return (postFees, feeToPay);\n    }\n\n\n    /// @param _currentBlockTime this should always be block.timestamp, passed in by trusted functions\n    /// @param _collateralAddress the address of the collateral token you wish to update the virtual price of \n    /// @dev this function should ONLY be called by other vault functions in which they pass in the block timestamp directly to this.\n    /// @dev currently uses interest calculations per 3 minutes to save gas and prevent DOS loop situations\n    function _updateVirtualPrice(uint256 _currentBlockTime, address _collateralAddress) internal { \n        (   ,\n            ,\n            ,\n            uint256 interestPer3Min,\n            uint256 lastUpdateTime,\n            uint256 virtualPrice,\n\n        ) = _getCollateral(_collateralAddress);\n        uint256 timeDelta = _currentBlockTime - lastUpdateTime;\n        //exit gracefully if two users call the function for the same collateral in the same 3min period\n        uint256 threeMinuteDelta = timeDelta / 180; \n        if(threeMinuteDelta > 0) {\n            for (uint256 i = 0; i < threeMinuteDelta; i++ ){\n            virtualPrice = (virtualPrice * interestPer3Min) / LOAN_SCALE; \n            }\n            collateralBook.vaultUpdateVirtualPriceAndTime(_collateralAddress, virtualPrice, _currentBlockTime);\n        }\n    }\n    \n\n     /**\n      * @notice Only Vault can mint isoUSD.\n      * @dev internal function to handle increases of loan\n      * @param _loanAmount amount of isoUSD to be borrowed, some is used to pay the opening fee the rest is sent to the user.\n     **/\n    function _increaseLoan(uint256 _loanAmount) internal {\n        uint256 userMint;\n        uint256 loanFee;\n        _checkDailyMaxLoans(_loanAmount);\n        (userMint, loanFee) = _findFees(loanOpenFee, _loanAmount);\n        isoUSD.mint(_loanAmount);\n        //isoUSD reverts on transfer failure so we can safely ignore slither's warnings for it.\n        //slither-disable-next-line unchecked-transfer\n        isoUSD.transfer(msg.sender, userMint);\n        //slither-disable-next-line unchecked-transfer\n        isoUSD.transfer(treasury, loanFee);\n    }\n    /// @dev internal function used to increase user collateral on loan.\n    /// @param _collateral the ERC20 compatible collateral to use, already set up in another function\n    /// @param _colAmount the amount of collateral to be transfered to the vault. \n    function _increaseCollateral(IERC20 _collateral, uint256 _colAmount) internal {\n        bool success  =_collateral.transferFrom(msg.sender, address(this), _colAmount);\n        //due to contract size we cannot use SafeERC20 so we check for non-reverting ERC20 failures\n        require(success);\n        \n    }\n\n    \n    /// @dev internal function used to decrease user collateral on loan.\n    /// @param _collateralAddress the ERC20 compatible collateral Address NOT already set up as an IERC20.\n    /// @param _amount the amount of collateral to be transfered back to the user.\n    /// @param _USDReturned quantity of isoUSD being returned to the vault, this can be zero.\n    /// @param _interestPaid quantity of interest paid on closing loan, this is transfered to the treasury , this can be zero\n    function _decreaseLoan(address _collateralAddress, uint256 _amount, uint256 _USDReturned, uint256 _interestPaid) internal {\n        IERC20 collateral = IERC20(_collateralAddress);\n        //_interestPaid is always less than _USDReturned so this is safe.\n        uint256 USDBurning = _USDReturned - _interestPaid;\n        //slither-disable-next-line unchecked-transfer\n        isoUSD.transferFrom(msg.sender, address(this), _USDReturned);\n        //burn original loan principle\n        isoUSD.burn(address(this), USDBurning);\n        //transfer interest earned on loan to treasury\n        //slither-disable-next-line unchecked-transfer\n        isoUSD.transfer(treasury, _interestPaid);\n        bool success  = collateral.transfer(msg.sender, _amount);\n        //due to contract size we cannot use SafeERC20 so we check for non-reverting ERC20 failures\n        require(success);\n        \n    }\n\n\n    /// @notice function required because of stack depth on closeLoan, only called by closeLoan function.\n    /// @param _collateralAddress address of the collateral token being used.\n    /// @param _collateralToUser quantity of collateral proposed to be returned to user closing loan\n    /// @param _USDToVault proposed quantity of isoUSD being returned (burnt) to the vault on closing the loan.\n    function _closeLoanChecks(address _collateralAddress, uint256 _collateralToUser, uint256 _USDToVault) internal view {\n        require(collateralPosted[_collateralAddress][msg.sender] >= _collateralToUser, \"User never posted this much collateral!\");\n        require(isoUSD.balanceOf(msg.sender) >= _USDToVault, \"Insufficient user isoUSD balance!\");\n    }\n\n    /**\n        Public functions \n    */\n\n\n    //isoUSD is assumed to be valued at $1 by all of the system to avoid oracle attacks. \n    /// @param _currencyKey code used by Synthetix to identify each collateral/synth\n    /// @param _amount quantity of collateral to price into sUSD\n    /// @return returns the value of the given synth in sUSD which is assumed to be pegged at $1.\n    function priceCollateralToUSD(bytes32 _currencyKey, uint256 _amount) public view virtual returns(uint256);\n\n    /**\n        External user loan interaction functions\n     */\n\n\n     /**\n      * @notice Only Vaults can mint isoUSD.\n      * @dev Mints 'USDborrowed' amount of isoUSD to vault and transfers to msg.sender and emits transfer event.\n      * @param _collateralAddress address of collateral token being used.\n      * @param _colAmount amount of collateral tokens being used.\n      * @param _USDborrowed amount of isoUSD to be minted, it is then split into the amount sent and the opening fee.\n     **/\n    function openLoan(\n        address _collateralAddress,\n        uint256 _colAmount,\n        uint256 _USDborrowed\n        ) external virtual;\n\n\n    /**\n      * @dev Increases collateral supplied against an existing loan. \n      * @notice Checks adding the collateral will keep the user above liquidation, \n      * @notice this debatable check isn't technically needed but feels fairer to end users.\n      * @param _collateralAddress address of collateral token being used.\n      * @param _colAmount amount of collateral tokens being used.\n     **/\n    function increaseCollateralAmount(\n        address _collateralAddress,\n        uint256 _colAmount\n        ) external virtual;\n\n\n     /**\n      * @notice Only Vault can destroy isoUSD.\n      * @dev destroys USDreturned of isoUSD held by caller, returns user collateral, close debt \n      * @dev if debt remains, checks minimum collateral ratio is upheld \n      * @dev if cost of a transaction can be <$0.01 YOU MUST UPDATE TENTH_OF_CENT check otherwise users can open microloans and close, withdrawing collateral without repaying. \n      * @param _collateralAddress address of collateral token being used.\n      * @param _collateralToUser amount of collateral tokens being returned to user.\n      * @param _USDToVault amount of isoUSD to be burnt.\n     **/\n\n    function closeLoan(\n        address _collateralAddress,\n        uint256 _collateralToUser,\n        uint256 _USDToVault\n        ) external virtual;\n    \n    \n\n    /**\n        Liquidation functions\n     \n    */\n    \n    // @dev this functions trusts all inputs, never call it without having done all validation first.\n    function _liquidate(\n        address _loanHolder,\n        address _collateralAddress,\n        uint256 _collateralLiquidated,\n        uint256 _isoUSDReturned,\n        bytes32 _currencyKey, \n        uint256 _virtualPrice\n        ) internal {\n        //record paying off loan principle before interest\n            uint256 loanPrinciple = isoUSDLoaned[_collateralAddress][_loanHolder];\n            //slither-disable-next-line uninitialized-local-variables\n            uint256 interestPaid;\n            if( loanPrinciple >= _isoUSDReturned){\n                //pay off loan principle first\n                isoUSDLoaned[_collateralAddress][_loanHolder] = loanPrinciple - _isoUSDReturned;\n            }\n            else{\n                interestPaid = _isoUSDReturned - loanPrinciple;\n                //loan principle is fully repaid so record this.\n                isoUSDLoaned[_collateralAddress][_loanHolder] = 0;\n            }\n        //if non-zero we are not handling a bad debt so the loanAndInterest will need updating\n        if(isoUSDLoanAndInterest[_collateralAddress][_loanHolder] > 0){\n            //\n            isoUSDLoanAndInterest[_collateralAddress][_loanHolder] = isoUSDLoanAndInterest[_collateralAddress][_loanHolder] - ((_isoUSDReturned * LOAN_SCALE) / _virtualPrice);\n        }\n        else{\n            //now that we've determined how much principle and interest is being repaid we wipe the principle for bad debts too\n            isoUSDLoaned[_collateralAddress][_loanHolder] = 0;\n        }\n        \n        collateralPosted[_collateralAddress][_loanHolder] = collateralPosted[_collateralAddress][_loanHolder] - _collateralLiquidated;\n        \n        emit Liquidation(_loanHolder, msg.sender, _isoUSDReturned, _currencyKey, _collateralLiquidated);\n        //finally handle transfer of collateral and isoUSD.\n        _decreaseLoan(_collateralAddress, _collateralLiquidated, _isoUSDReturned, interestPaid);\n    }\n\n       \n/**\n* @notice This function handles the maths of determining when a loan is liquidatable and is written\n          such that users can view the liquidatable amount gas free by being a pure function, \n          enabling website integration or for liquidator bot when determining which debts to liquidate\n**/ \n    function viewLiquidatableAmount(\n        uint256 _collateralAmount,\n        uint256 _collateralPrice,\n        uint256 _userDebt,\n        uint256 _liquidatableMargin\n        ) public pure returns(uint256){\n        uint256 minimumCollateralPoint = _userDebt*_liquidatableMargin;\n        uint256 actualCollateralPoint = _collateralAmount*_collateralPrice;\n        if(minimumCollateralPoint <=  actualCollateralPoint){\n            //in this case the loan is not liquidatable at all and so we return zero\n            return 0;\n        }\n        uint256 numerator =  minimumCollateralPoint - actualCollateralPoint; \n        uint256 denominator = (_collateralPrice*LIQUIDATION_RETURN*_liquidatableMargin/LOAN_SCALE - _collateralPrice*LOAN_SCALE)/LOAN_SCALE;\n        return(numerator  / denominator);\n\n    }\n\n     /**\n      * @notice Anyone can liquidate any other undercollateralised loan.\n      * @notice The max acceptable liquidation quantity is calculated using viewLiquidatableAmount\n      * @dev checks that partial liquidation would be insufficient to recollaterize the loanHolder's debt \n      * @dev caller is paid 1e18 -`LIQUIDATION_RETURN` as reward for calling the liquidation.\n      * @dev In the event of full liquidation being insufficient the leftover debt is written off and an event tracking this is emitted.\n      * @param _loanHolder address of loanee being liquidated.\n      * @param _collateralAddress address of collateral token being used.\n     **/\n        \n        function callLiquidation(\n            address _loanHolder,\n            address _collateralAddress\n        ) external virtual ;\n}"
    }
  ]
}