{
  "Title": "[M-07] DOS attack prevents refunding previous bid in Shortfall.sol and malicious bidder always wins the auction",
  "Content": "\n<https://github.com/code-423n4/2023-05-venus/blob/main/contracts/Shortfall/Shortfall.sol#L183> <br><https://github.com/code-423n4/2023-05-venus/blob/main/contracts/Shortfall/Shortfall.sol#L190>\n\nThe auction logic in `Shortfall.sol` refunds the previously accepted (highest) bid when a new acceptable bid is placed via the `placeBid` function.\n\nIt is important that this refund succeeds as otherwise a new acceptable (higher) bid is not possible and the auction is disrupted which consequently makes the current highest bidder the auction winner and causes a loss for the Venus project and its users.\n\nWhen refunding the `safeTransfer` of OpenZeppelin `SafeERC20Upgradeable` (inheriting from `SafeERC20`) is used which deals with the multiple ways in which different ERC-20 (BEP-20) tokens indicate the success/failure of a token transfer.\n\nFor details see: <https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol#L12>\n\nNevertheless, there are additional scenarios that may still disrupt the auction and put it into a state of DOS (Denial of Service). Specifically, 2 scenarios were identified:\n\n1.  DOS with the underlying token implementing a blacklist.\n2.  DOS with the underlying token being an ERC20-compatible ERC777 token.\n\n### Proof of Concept\n\n### 1. DOS with the underlying token implementing a blacklist\n\nIn this scenario, the underlying token is implemented with a blacklist (also known as blocklist).\n\nBecause this is common for tokens on the Ethereum network (e.g. USDC/USDT implementing blacklist/blocklist; See: <https://github.com/d-xo/weird-erc20>) this is a scenario also possible for tokens on the Binance Chain.\n\nAnd since it is not specifically stated that such tokens are excluded from the Venus project, while the fee on transfer/deflationary/rebase tokens are specifically mentioned to be excluded, this is assumed to be a potential issue.\n\nThe following steps describe the issue:\n\n1.  Bidder 1 makes a bid while he is not on the token blacklist.\n2.  After the bid, he is put on the token blacklist.\n3.  Bidder 2 makes a higher bid and the refund to bidder 1 is attempted.\n4.  The refund reverts due to bidder 1 being blacklisted which blocks the token transfer back.\n5.  Bidder 1 remains the highest bidder and wins the auction.\n\n### 2. DOS with the underlying token being an ERC20-compatible ERC777 token.\n\nIn this scenario, the underlying token is an ER777 token instead of an ERC20. Since the audit does not specifically state that ERC777 tokens (which are ERC-20 compatible) are out of scope, this is assumed to be a potential issue.\n\nSee <https://docs.openzeppelin.com/contracts/2.x/api/token/erc777> for details on ERC777 tokens.\n\nThe following steps describe the issue:\n\n1.  Bidder 1 implements a contract that acts as an \"ERC777 recipient\" which can either accept/reject tokens that are transferred to it.\n2.  Bidder 1 makes a bid not with an EOA (externally owned account) but uses his smart contract to make the bid.\n3.  After the bid was accepted, he activates his smart contract and rejects any tokens transferred to it.\n4.  Bidder 2 makes a higher bid and the refund to the smart contract of bidder 1 is attempted.\n5.  The refund fails due to the smart contract of bidder 1 rejecting the token transfer (ERC777 token calls `tokensReceived` function of receiving a smart contract to finalize the token transfer which reverts).\n6.  Bidder 1 remains the highest bidder and wins the auction.\n\n### Coded POC\n\nTo prove both aforementioned scenarios of putting the auction into a state of DOS, the `Shortfall.ts` test was modified and 1 test case for each scenario was added. Code for additional required mock tokens etc. (`MockTokenERC20Blacklistable.sol`, `MockTokenERC777.sol`, `ERC777Recipient.sol`) are included.\n\n*Note: see [DOS attack prevents refunding previous bid in Shortfall.sol and malicious bidder always wins the auction\n](https://github.com/code-423n4/2023-05-venus-findings/issues/305) for coding details.*\n\n### Recommended Mitigation Steps\n\nUse a withdrawal pattern (\"pull over push\") instead of directly refunding the highest bidder during the bid. See: https://fravoll.github.io/solidity-patterns/pull_over_push.html for details. This way, the auction will not get into a state of DOS.\n\n### Assessed type\n\nDoS\n\n**[chechu (Venus) confirmed and commented via duplicate issue #376](https://github.com/code-423n4/2023-05-venus-findings/issues/376#issuecomment-1560145119):**\n>We won’t accept ERC777 tokens as underlying tokens. But we have upgradable ERC20 tokens that can include a similar behavior, so the risk exists and we’ll try to mitigate it by applying some changes.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-venus",
  "Code": [
    {
      "filename": "contracts/Shortfall/Shortfall.sol",
      "content": "/// @notice  SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@venusprotocol/oracle/contracts/PriceOracle.sol\";\n\nimport \"../VToken.sol\";\nimport \"../ComptrollerInterface.sol\";\nimport \"../RiskFund/IRiskFund.sol\";\nimport \"./IShortfall.sol\";\nimport \"../Pool/PoolRegistry.sol\";\nimport \"../Pool/PoolRegistryInterface.sol\";\nimport \"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\";\n\ncontract Shortfall is Ownable2StepUpgradeable, AccessControlledV8, ReentrancyGuardUpgradeable, IShortfall {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @notice Type of auction\n    enum AuctionType {\n        LARGE_POOL_DEBT,\n        LARGE_RISK_FUND\n    }\n\n    /// @notice Status of auction\n    enum AuctionStatus {\n        NOT_STARTED,\n        STARTED,\n        ENDED\n    }\n\n    /// @notice Auction metadata\n    struct Auction {\n        uint256 startBlock;\n        AuctionType auctionType;\n        AuctionStatus status;\n        VToken[] markets;\n        uint256 seizedRiskFund;\n        address highestBidder;\n        uint256 highestBidBps;\n        uint256 highestBidBlock;\n        uint256 startBidBps;\n        mapping(VToken => uint256) marketDebt;\n    }\n\n    /// @notice Pool registry address\n    address public poolRegistry;\n\n    /// @notice Risk fund address\n    IRiskFund private riskFund;\n\n    /// @notice Minimum USD debt in pool for shortfall to trigger\n    uint256 public minimumPoolBadDebt;\n\n    /// @notice Incentive to auction participants, initial value set to 1000 or 10%\n    uint256 private incentiveBps;\n\n    /// @notice Max basis points i.e., 100%\n    uint256 private constant MAX_BPS = 10000;\n\n    /// @notice Time to wait for next bidder. initially waits for 10 blocks\n    uint256 public nextBidderBlockLimit;\n\n    /// @notice Time to wait for first bidder. initially waits for 100 blocks\n    uint256 public waitForFirstBidder;\n\n    /// @notice base asset contract address\n    address public convertibleBaseAsset;\n\n    /// @notice Auctions for each pool\n    mapping(address => Auction) public auctions;\n\n    /// @notice Emitted when a auction starts\n    event AuctionStarted(\n        address indexed comptroller,\n        uint256 auctionStartBlock,\n        AuctionType auctionType,\n        VToken[] markets,\n        uint256[] marketsDebt,\n        uint256 seizedRiskFund,\n        uint256 startBidBps\n    );\n\n    /// @notice Emitted when a bid is placed\n    event BidPlaced(address indexed comptroller, uint256 auctionStartBlock, uint256 bidBps, address indexed bidder);\n\n    /// @notice Emitted when a auction is completed\n    event AuctionClosed(\n        address indexed comptroller,\n        uint256 auctionStartBlock,\n        address indexed highestBidder,\n        uint256 highestBidBps,\n        uint256 seizedRiskFind,\n        VToken[] markets,\n        uint256[] marketDebt\n    );\n\n    /// @notice Emitted when a auction is restarted\n    event AuctionRestarted(address indexed comptroller, uint256 auctionStartBlock);\n\n    /// @notice Emitted when pool registry address is updated\n    event PoolRegistryUpdated(address indexed oldPoolRegistry, address indexed newPoolRegistry);\n\n    /// @notice Emitted when minimum pool bad debt is updated\n    event MinimumPoolBadDebtUpdated(uint256 oldMinimumPoolBadDebt, uint256 newMinimumPoolBadDebt);\n\n    /// @notice Emitted when wait for first bidder block count is updated\n    event WaitForFirstBidderUpdated(uint256 oldWaitForFirstBidder, uint256 newWaitForFirstBidder);\n\n    /// @notice Emitted when next bidder block limit is updated\n    event NextBidderBlockLimitUpdated(uint256 oldNextBidderBlockLimit, uint256 newNextBidderBlockLimit);\n\n    /// @notice Emitted when incentiveBps is updated\n    event IncentiveBpsUpdated(uint256 oldIncentiveBps, uint256 newIncentiveBps);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        // Note that the contract is upgradeable. Use initialize() or reinitializers\n        // to set the state variables.\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initalize the shortfall contract\n     * @param convertibleBaseAsset_ Asset to swap the funds to\n     * @param riskFund_ RiskFund contract address\n     * @param minimumPoolBadDebt_ Minimum bad debt in base asset for a pool to start auction\n     * @param accessControlManager_ AccessControlManager contract address\n     */\n    function initialize(\n        address convertibleBaseAsset_,\n        IRiskFund riskFund_,\n        uint256 minimumPoolBadDebt_,\n        address accessControlManager_\n    ) external initializer {\n        require(convertibleBaseAsset_ != address(0), \"invalid base asset address\");\n        require(address(riskFund_) != address(0), \"invalid risk fund address\");\n        require(minimumPoolBadDebt_ != 0, \"invalid minimum pool bad debt\");\n\n        __Ownable2Step_init();\n        __AccessControlled_init_unchained(accessControlManager_);\n        __ReentrancyGuard_init();\n        minimumPoolBadDebt = minimumPoolBadDebt_;\n        convertibleBaseAsset = convertibleBaseAsset_;\n        riskFund = riskFund_;\n        waitForFirstBidder = 100;\n        nextBidderBlockLimit = 10;\n        incentiveBps = 1000;\n    }\n\n    /**\n     * @notice Place a bid greater than the previous in an ongoing auction\n     * @param comptroller Comptroller address of the pool\n     * @param bidBps The bid percent of the risk fund or bad debt depending on auction type\n     * @custom:event Emits BidPlaced event on success\n     */\n    function placeBid(address comptroller, uint256 bidBps) external nonReentrant {\n        Auction storage auction = auctions[comptroller];\n\n        require(_isStarted(auction), \"no on-going auction\");\n        require(!_isStale(auction), \"auction is stale, restart it\");\n        require(bidBps <= MAX_BPS, \"basis points cannot be more than 10000\");\n        require(\n            (auction.auctionType == AuctionType.LARGE_POOL_DEBT &&\n                ((auction.highestBidder != address(0) && bidBps > auction.highestBidBps) ||\n                    (auction.highestBidder == address(0) && bidBps >= auction.startBidBps))) ||\n                (auction.auctionType == AuctionType.LARGE_RISK_FUND &&\n                    ((auction.highestBidder != address(0) && bidBps < auction.highestBidBps) ||\n                        (auction.highestBidder == address(0) && bidBps <= auction.startBidBps))),\n            \"your bid is not the highest\"\n        );\n\n        uint256 marketsCount = auction.markets.length;\n        for (uint256 i; i < marketsCount; ++i) {\n            VToken vToken = VToken(address(auction.markets[i]));\n            IERC20Upgradeable erc20 = IERC20Upgradeable(address(vToken.underlying()));\n\n            if (auction.auctionType == AuctionType.LARGE_POOL_DEBT) {\n                if (auction.highestBidder != address(0)) {\n                    uint256 previousBidAmount = ((auction.marketDebt[auction.markets[i]] * auction.highestBidBps) /\n                        MAX_BPS);\n                    erc20.safeTransfer(auction.highestBidder, previousBidAmount);\n                }\n\n                uint256 currentBidAmount = ((auction.marketDebt[auction.markets[i]] * bidBps) / MAX_BPS);\n                erc20.safeTransferFrom(msg.sender, address(this), currentBidAmount);\n            } else {\n                if (auction.highestBidder != address(0)) {\n                    erc20.safeTransfer(auction.highestBidder, auction.marketDebt[auction.markets[i]]);\n                }\n\n                erc20.safeTransferFrom(msg.sender, address(this), auction.marketDebt[auction.markets[i]]);\n            }\n        }\n\n        auction.highestBidder = msg.sender;\n        auction.highestBidBps = bidBps;\n        auction.highestBidBlock = block.number;\n\n        emit BidPlaced(comptroller, auction.startBlock, bidBps, msg.sender);\n    }\n\n    /**\n     * @notice Close an auction\n     * @param comptroller Comptroller address of the pool\n     * @custom:event Emits AuctionClosed event on successful close\n     */\n    function closeAuction(address comptroller) external nonReentrant {\n        Auction storage auction = auctions[comptroller];\n\n        require(_isStarted(auction), \"no on-going auction\");\n        require(\n            block.number > auction.highestBidBlock + nextBidderBlockLimit && auction.highestBidder != address(0),\n            \"waiting for next bidder. cannot close auction\"\n        );\n\n        uint256 marketsCount = auction.markets.length;\n        uint256[] memory marketsDebt = new uint256[](marketsCount);\n\n        auction.status = AuctionStatus.ENDED;\n\n        for (uint256 i; i < marketsCount; ++i) {\n            VToken vToken = VToken(address(auction.markets[i]));\n            IERC20Upgradeable erc20 = IERC20Upgradeable(address(vToken.underlying()));\n\n            if (auction.auctionType == AuctionType.LARGE_POOL_DEBT) {\n                uint256 bidAmount = ((auction.marketDebt[auction.markets[i]] * auction.highestBidBps) / MAX_BPS);\n                erc20.safeTransfer(address(auction.markets[i]), bidAmount);\n                marketsDebt[i] = bidAmount;\n            } else {\n                erc20.safeTransfer(address(auction.markets[i]), auction.marketDebt[auction.markets[i]]);\n                marketsDebt[i] = auction.marketDebt[auction.markets[i]];\n            }\n\n            auction.markets[i].badDebtRecovered(marketsDebt[i]);\n        }\n\n        uint256 riskFundBidAmount;\n\n        if (auction.auctionType == AuctionType.LARGE_POOL_DEBT) {\n            riskFundBidAmount = auction.seizedRiskFund;\n        } else {\n            riskFundBidAmount = (auction.seizedRiskFund * auction.highestBidBps) / MAX_BPS;\n        }\n\n        uint256 transferredAmount = riskFund.transferReserveForAuction(comptroller, riskFundBidAmount);\n        IERC20Upgradeable(convertibleBaseAsset).safeTransfer(auction.highestBidder, riskFundBidAmount);\n\n        emit AuctionClosed(\n            comptroller,\n            auction.startBlock,\n            auction.highestBidder,\n            auction.highestBidBps,\n            transferredAmount,\n            auction.markets,\n            marketsDebt\n        );\n    }\n\n    /**\n     * @notice Start a auction when there is not currently one active\n     * @param comptroller Comptroller address of the pool\n     * @custom:event Emits AuctionStarted event on success\n     */\n    function startAuction(address comptroller) external {\n        _startAuction(comptroller);\n    }\n\n    /**\n     * @notice Restart an auction\n     * @param comptroller Address of the pool\n     * @custom:event Emits AuctionRestarted event on successful restart\n     */\n    function restartAuction(address comptroller) external {\n        Auction storage auction = auctions[comptroller];\n\n        require(_isStarted(auction), \"no on-going auction\");\n        require(_isStale(auction), \"you need to wait for more time for first bidder\");\n\n        auction.status = AuctionStatus.ENDED;\n\n        emit AuctionRestarted(comptroller, auction.startBlock);\n        _startAuction(comptroller);\n    }\n\n    /**\n     * @notice Update next bidder block limit which is used determine when an auction can be closed\n     * @param _nextBidderBlockLimit  New next bidder block limit\n     * @custom:event Emits NextBidderBlockLimitUpdated on success\n     * @custom:access Restricted to owner\n     */\n    function updateNextBidderBlockLimit(uint256 _nextBidderBlockLimit) external {\n        _checkAccessAllowed(\"updateNextBidderBlockLimit(uint256)\");\n        require(_nextBidderBlockLimit != 0, \"_nextBidderBlockLimit must not be 0\");\n        uint256 oldNextBidderBlockLimit = nextBidderBlockLimit;\n        nextBidderBlockLimit = _nextBidderBlockLimit;\n        emit NextBidderBlockLimitUpdated(oldNextBidderBlockLimit, _nextBidderBlockLimit);\n    }\n\n    /**\n     * @notice Updates the inventive BPS\n     * @param _incentiveBps New incentive BPS\n     * @custom:event Emits IncentiveBpsUpdated on success\n     * @custom:access Restricted to owner\n     */\n    function updateIncentiveBps(uint256 _incentiveBps) external {\n        _checkAccessAllowed(\"updateIncentiveBps(uint256)\");\n        require(_incentiveBps != 0, \"incentiveBps must not be 0\");\n        uint256 oldIncentiveBps = incentiveBps;\n        incentiveBps = _incentiveBps;\n        emit IncentiveBpsUpdated(oldIncentiveBps, _incentiveBps);\n    }\n\n    /**\n     * @notice Update minimum pool bad debt to start auction\n     * @param _minimumPoolBadDebt Minimum bad debt in BUSD for a pool to start auction\n     * @custom:event Emits MinimumPoolBadDebtUpdated on success\n     * @custom:access Restricted to owner\n     */\n    function updateMinimumPoolBadDebt(uint256 _minimumPoolBadDebt) external {\n        _checkAccessAllowed(\"updateMinimumPoolBadDebt(uint256)\");\n        uint256 oldMinimumPoolBadDebt = minimumPoolBadDebt;\n        minimumPoolBadDebt = _minimumPoolBadDebt;\n        emit MinimumPoolBadDebtUpdated(oldMinimumPoolBadDebt, _minimumPoolBadDebt);\n    }\n\n    /**\n     * @notice Update wait for first bidder block count. If the first bid is not made within this limit, the auction is closed and needs to be restarted\n     * @param _waitForFirstBidder  New wait for first bidder block count\n     * @custom:event Emits WaitForFirstBidderUpdated on success\n     * @custom:access Restricted to owner\n     */\n    function updateWaitForFirstBidder(uint256 _waitForFirstBidder) external {\n        _checkAccessAllowed(\"updateWaitForFirstBidder(uint256)\");\n        uint256 oldWaitForFirstBidder = waitForFirstBidder;\n        waitForFirstBidder = _waitForFirstBidder;\n        emit WaitForFirstBidderUpdated(oldWaitForFirstBidder, _waitForFirstBidder);\n    }\n\n    /**\n     * @notice Update the pool registry this shortfall supports\n     * @dev After Pool Registry is deployed we need to set the pool registry address\n     * @param _poolRegistry Address of pool registry contract\n     * @custom:event Emits PoolRegistryUpdated on success\n     * @custom:access Restricted to owner\n     */\n    function updatePoolRegistry(address _poolRegistry) external onlyOwner {\n        require(_poolRegistry != address(0), \"invalid address\");\n        address oldPoolRegistry = poolRegistry;\n        poolRegistry = _poolRegistry;\n        emit PoolRegistryUpdated(oldPoolRegistry, _poolRegistry);\n    }\n\n    /**\n     * @notice Start a auction when there is not currently one active\n     * @param comptroller Comptroller address of the pool\n     */\n    function _startAuction(address comptroller) internal {\n        PoolRegistryInterface.VenusPool memory pool = PoolRegistry(poolRegistry).getPoolByComptroller(comptroller);\n        require(pool.comptroller == comptroller, \"comptroller doesn't exist pool registry\");\n\n        Auction storage auction = auctions[comptroller];\n        require(\n            (auction.startBlock == 0 && auction.status == AuctionStatus.NOT_STARTED) ||\n                auction.status == AuctionStatus.ENDED,\n            \"auction is on-going\"\n        );\n\n        auction.highestBidBps = 0;\n        auction.highestBidBlock = 0;\n\n        uint256 marketsCount = auction.markets.length;\n        for (uint256 i; i < marketsCount; ++i) {\n            VToken vToken = auction.markets[i];\n            auction.marketDebt[vToken] = 0;\n        }\n\n        delete auction.markets;\n\n        VToken[] memory vTokens = _getAllMarkets(comptroller);\n        marketsCount = vTokens.length;\n        PriceOracle priceOracle = _getPriceOracle(comptroller);\n        uint256 poolBadDebt;\n\n        uint256[] memory marketsDebt = new uint256[](marketsCount);\n        auction.markets = new VToken[](marketsCount);\n\n        for (uint256 i; i < marketsCount; ++i) {\n            uint256 marketBadDebt = vTokens[i].badDebt();\n\n            priceOracle.updatePrice(address(vTokens[i]));\n            uint256 usdValue = (priceOracle.getUnderlyingPrice(address(vTokens[i])) * marketBadDebt) / 1e18;\n\n            poolBadDebt = poolBadDebt + usdValue;\n            auction.markets[i] = vTokens[i];\n            auction.marketDebt[vTokens[i]] = marketBadDebt;\n            marketsDebt[i] = marketBadDebt;\n        }\n\n        require(poolBadDebt >= minimumPoolBadDebt, \"pool bad debt is too low\");\n\n        uint256 riskFundBalance = riskFund.poolReserves(comptroller);\n        uint256 remainingRiskFundBalance = riskFundBalance;\n        uint256 incentivizedRiskFundBalance = poolBadDebt + ((poolBadDebt * incentiveBps) / MAX_BPS);\n        if (incentivizedRiskFundBalance >= riskFundBalance) {\n            auction.startBidBps =\n                (MAX_BPS * MAX_BPS * remainingRiskFundBalance) /\n                (poolBadDebt * (MAX_BPS + incentiveBps));\n            remainingRiskFundBalance = 0;\n            auction.auctionType = AuctionType.LARGE_POOL_DEBT;\n        } else {\n            uint256 maxSeizeableRiskFundBalance = incentivizedRiskFundBalance;\n\n            remainingRiskFundBalance = remainingRiskFundBalance - maxSeizeableRiskFundBalance;\n            auction.auctionType = AuctionType.LARGE_RISK_FUND;\n            auction.startBidBps = MAX_BPS;\n        }\n\n        auction.seizedRiskFund = riskFundBalance - remainingRiskFundBalance;\n        auction.startBlock = block.number;\n        auction.status = AuctionStatus.STARTED;\n        auction.highestBidder = address(0);\n\n        emit AuctionStarted(\n            comptroller,\n            auction.startBlock,\n            auction.auctionType,\n            auction.markets,\n            marketsDebt,\n            auction.seizedRiskFund,\n            auction.startBidBps\n        );\n    }\n\n    /**\n     * @dev Returns the price oracle of the pool\n     * @param comptroller Address of the pool's comptroller\n     * @return oracle The pool's price oracle\n     */\n    function _getPriceOracle(address comptroller) internal view returns (PriceOracle) {\n        return PriceOracle(ComptrollerViewInterface(comptroller).oracle());\n    }\n\n    /**\n     * @dev Returns all markets of the pool\n     * @param comptroller Address of the pool's comptroller\n     * @return markets The pool's markets as VToken array\n     */\n    function _getAllMarkets(address comptroller) internal view returns (VToken[] memory) {\n        return ComptrollerInterface(comptroller).getAllMarkets();\n    }\n\n    /**\n     * @dev Checks if the auction has started\n     * @param auction The auction to query the status for\n     */\n    function _isStarted(Auction storage auction) internal view returns (bool) {\n        return auction.startBlock != 0 && auction.status == AuctionStatus.STARTED;\n    }\n\n    /**\n     * @dev Checks if the auction is stale, i.e. there's no bidder and the auction\n     *   was started more than waitForFirstBidder blocks ago.\n     * @param auction The auction to query the status for\n     */\n    function _isStale(Auction storage auction) internal view returns (bool) {\n        bool noBidder = auction.highestBidder == address(0);\n        return noBidder && (block.number > auction.startBlock + waitForFirstBidder);\n    }\n}"
    },
    {
      "filename": "contracts/token/ERC20/utils/SafeERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}"
    }
  ]
}