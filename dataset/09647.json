{
  "Title": "[G-17] `require()` or `revert()` statements that check input arguments should be at the top of the function",
  "Content": "\n1.  File: splits/contracts/Splitter.sol (line [164](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L164))\n\n```solidity\n        require(royaltyAmount > 0, \"No additional funds for window\");\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-03-joyn-contest",
  "Code": [
    {
      "filename": "splits/contracts/Splitter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {SplitStorage} from \"./SplitStorage.sol\";\nimport {IRoyaltyVault} from \"@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title Splitter\n * Building on the work from the Uniswap team at Uniswap and Mirror.xyz Team\n */\ncontract Splitter is SplitStorage {\n    /**** Mutable variables ****/\n    uint256 public constant PERCENTAGE_SCALE = 10e5;\n    bytes4 public constant IID_IROYALTY = type(IRoyaltyVault).interfaceId;\n\n    // The TransferETH event is emitted after each eth transfer in the split is attempted.\n    event TransferETH(\n        // The account to which the transfer was attempted.\n        address account,\n        // The amount for transfer that was attempted.\n        uint256 amount,\n        // Whether or not the transfer succeeded.\n        bool success\n    );\n\n    // Emits when a window is incremented.\n    event WindowIncremented(uint256 currentWindow, uint256 fundsAvailable);\n\n    /**\n     * @dev Claim the funds from the all windows.\n     * @param percentageAllocation {uint256} percentage of allocation to be claimed\n     * @param merkleProof {bytes32} The Merkle proof of the allocation\n     */\n    function claimForAllWindows(\n        uint256 percentageAllocation,\n        bytes32[] calldata merkleProof\n    ) external {\n        // Make sure that the user has this allocation granted.\n        require(\n            verifyProof(\n                merkleProof,\n                merkleRoot,\n                getNode(msg.sender, percentageAllocation)\n            ),\n            \"Invalid proof\"\n        );\n\n        uint256 amount = 0;\n        for (uint256 i = 0; i < currentWindow; i++) {\n            if (!isClaimed(msg.sender, i)) {\n                setClaimed(msg.sender, i);\n\n                amount += scaleAmountByPercentage(\n                    balanceForWindow[i],\n                    percentageAllocation\n                );\n            }\n        }\n\n        transferSplitAsset(msg.sender, amount);\n    }\n\n    /**\n     * @dev get Node hash of given data.\n     * @param who {address} whitelisted user address\n     * @param percentageAllocation {uint256} percentage of allocation\n     * @return {bytes32} node hash\n     */\n    function getNode(\n        address who,\n        uint256 percentageAllocation\n    ) private pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    who,\n                    percentageAllocation\n                )\n            );\n    }\n\n    /**\n     * @dev get scaled amount from given amount and percentage.\n     * @param amount {uint256} amount\n     * @param scaledPercent {uint256} scaled percentage\n     * @return scaledAmount {uint256} scaled amount\n     */\n    function scaleAmountByPercentage(uint256 amount, uint256 scaledPercent)\n        public\n        pure\n        returns (uint256 scaledAmount)\n    {\n        /*\n            Example:\n                If there is 100 ETH in the account, and someone has \n                an allocation of 2%, we call this with 100 as the amount, and 200\n                as the scaled percent.\n\n                To find out the amount we use, for example: (100 * 200) / (100 * 100)\n                which returns 2 -- i.e. 2% of the 100 ETH balance.\n         */\n        scaledAmount = (amount * scaledPercent) / (10000);\n    }\n\n    /**\n     * @dev claim for the given window.\n     * @param window {uint256} Window to claim\n     * @param scaledPercentageAllocation {uint256} percentage of allocation to be claimed\n     * @param merkleProof {bytes32} The Merkle proof of the allocation\n     */\n    function claim(\n        uint256 window,\n        uint256 scaledPercentageAllocation,\n        bytes32[] calldata merkleProof\n    ) external {\n        require(currentWindow > window, \"cannot claim for a future window\");\n        require(\n            !isClaimed(msg.sender, window),\n            \"NFT has already claimed the given window\"\n        );\n\n        setClaimed(msg.sender, window);\n\n        require(\n            verifyProof(\n                merkleProof,\n                merkleRoot,\n                getNode(msg.sender, scaledPercentageAllocation)\n            ),\n            \"Invalid proof\"\n        );\n\n        transferSplitAsset(\n            msg.sender,\n            // The absolute amount that's claimable.\n            scaleAmountByPercentage(\n                balanceForWindow[window],\n                scaledPercentageAllocation\n            )\n        );\n    }\n\n    /**\n     * @dev Function which handles increment window and puts amount to current window\n     * @param royaltyAmount {uint256} Amount needs to be added in window.\n     * @return {bool} Whether or not the window was incremented.\n     */\n    function incrementWindow(uint256 royaltyAmount) public returns (bool) {\n        uint256 wethBalance;\n\n        require(\n            IRoyaltyVault(msg.sender).supportsInterface(IID_IROYALTY),\n            \"Royalty Vault not supported\"\n        );\n        require(\n            IRoyaltyVault(msg.sender).getSplitter() == address(this),\n            \"Unauthorised to increment window\"\n        );\n\n        wethBalance = IERC20(splitAsset).balanceOf(address(this));\n        require(wethBalance >= royaltyAmount, \"Insufficient funds\");\n\n        require(royaltyAmount > 0, \"No additional funds for window\");\n        balanceForWindow.push(royaltyAmount);\n        currentWindow += 1;\n        emit WindowIncremented(currentWindow, royaltyAmount);\n        return true;\n    }\n\n    /**\n     * @dev Function checks if the given window and tokenId has been claimed.\n     * @param who {address} whitelisted user address\n     * @param window {uint256} Window to check\n     * @return {bool} Whether or not the window has been claimed.\n     */\n    function isClaimed(\n        address who,\n        uint256 window\n    ) public view returns (bool) {\n        return claimed[getClaimHash(who, window)];\n    }\n\n    /**** Private Functions ****/\n\n    /**\n     * @dev Function checks if the given window and tokenId has been claimed.\n     * @param who {address} whitelisted user address\n     * @param window {uint256} Window to check\n     */\n    function setClaimed(\n        address who,\n        uint256 window\n    ) private {\n        claimed[getClaimHash(who, window)] = true;\n    }\n\n    /**\n     * @dev Function which returns the hash of the given window, tokenId and membershipContract.\n     * @param who {address} whitelisted user address\n     * @param window {uint256} Window to check\n     * @return {bytes32} Hash of the given window, tokenId and membershipContract.\n     */\n    function getClaimHash(\n        address who,\n        uint256 window\n    ) private pure returns (bytes32) {\n        return keccak256(abi.encodePacked(who, window));\n    }\n\n    /**\n     * @dev Function to convert output amount from percentages.\n     * @param amount {uint256} Amount for which percentage is to be calculated.\n     * @param percent {uint256} Percentage\n     * @return {uint256} Output amount.\n     */\n    function amountFromPercent(uint256 amount, uint32 percent)\n        private\n        pure\n        returns (uint256)\n    {\n        // Solidity 0.8.0 lets us do this without SafeMath.\n        return (amount * percent) / 100;\n    }\n\n    /**\n     * @dev Function to transfer split asset to the given address.\n     * @param to {address} Address to transfer the split asset to.\n     * @param value {uint256} Amount to transfer.\n     */\n    function transferSplitAsset(address to, uint256 value)\n        private\n        returns (bool didSucceed)\n    {\n        // Try to transfer ETH to the given recipient.\n        didSucceed = IERC20(splitAsset).transfer(to, value);\n        require(didSucceed, \"Failed to transfer ETH\");\n\n        emit TransferETH(to, value, didSucceed);\n    }\n\n    /**\n     * @dev transfer given amount of ETH in contract to the given address.\n     * @param to {address} Address to transfer asset\n     * @param value {uint256} Amount to transfer\n     * @return {bool} Whether or not the transfer was successful.\n     */\n    function attemptETHTransfer(address to, uint256 value)\n        private\n        returns (bool)\n    {\n        // Here increase the gas limit a reasonable amount above the default, and try\n        // to send ETH to the recipient.\n        // NOTE: This might allow the recipient to attempt a limited reentrancy attack.\n        (bool success, ) = to.call{value: value, gas: 30000}(\"\");\n        return success;\n    }\n\n    // From https://github.com/protofire/zeppelin-solidity/blob/master/contracts/MerkleProof.sol\n    /**\n     * @dev Function to verify the given proof.\n     * @param proof {bytes32[]} Proof to verify\n     * @param root {bytes32} Root of the Merkle tree\n     * @param leaf {bytes32} Leaf to verify\n     * @return {bool} Whether or not the proof is valid.\n     */\n    function verifyProof(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) private pure returns (bool) {\n        bytes32 computedHash = leaf;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(\n                    abi.encodePacked(computedHash, proofElement)\n                );\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(\n                    abi.encodePacked(proofElement, computedHash)\n                );\n            }\n        }\n\n        // Check if the computed hash (root) is equal to the provided root\n        return computedHash == root;\n    }\n}"
    }
  ]
}