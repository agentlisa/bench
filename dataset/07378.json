{
  "Title": "[L-01]  Bid size is an unfair ordering metric",
  "Content": "The README states that this is intentional, so I've filed it as Low rather than Medium, but giving priority to bids with the smaller quantity is not a fair ordering mechanic. A person with a lot of funds may have gotten that by pooling externally to the contract, and it's not fair to kick them out of the pool earlier than another address that came in later.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: /src/lib/MinPriorityQueue.sol\n\n111      function isGreater(\n112          Queue storage self,\n113          uint256 i,\n114          uint256 j\n115      ) private view returns (bool) {\n116          Bid memory bidI = self.bidIdToBidMap[self.bidIdList[i]];\n117          Bid memory bidJ = self.bidIdToBidMap[self.bidIdList[j]];\n118          if (bidI.price == bidJ.price) {\n119              return bidI.quantity <= bidJ.quantity;\n120          }\n121          return bidI.price > bidJ.price;\n122:     }\n\n```\nhttps://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/lib/MinPriorityQueue.sol#L111-L122\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-12-tessera",
  "Code": [
    {
      "filename": "src/lib/MinPriorityQueue.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.8.13;\n\nstruct Bid {\n    uint256 bidId;\n    address owner;\n    uint256 price;\n    uint256 quantity;\n}\n\n///@notice a min priority queue implementation, based off https://algs4.cs.princeton.edu/24pq/MinPQ.java.html\nlibrary MinPriorityQueue {\n    struct Queue {\n        ///@notice incrementing bid id\n        uint256 nextBidId;\n        ///@notice array backing priority queue\n        uint256[] bidIdList;\n        ///@notice total number of bids in queue\n        uint256 numBids;\n        //@notice map bid ids to bids\n        mapping(uint256 => Bid) bidIdToBidMap;\n        ///@notice map addreses to bids they own\n        mapping(address => uint256[]) ownerToBidIds;\n    }\n\n    ///@notice initialize must be called before using queue.\n    function initialize(Queue storage self) public {\n        self.bidIdList.push(0);\n        self.nextBidId = 1;\n    }\n\n    function isEmpty(Queue storage self) public view returns (bool) {\n        return self.numBids == 0;\n    }\n\n    function getNumBids(Queue storage self) public view returns (uint256) {\n        return self.numBids;\n    }\n\n    ///@notice view min bid\n    function getMin(Queue storage self) public view returns (Bid storage) {\n        require(!isEmpty(self), \"nothing to return\");\n        uint256 minId = self.bidIdList[1];\n        return self.bidIdToBidMap[minId];\n    }\n\n    ///@notice move bid up heap\n    function swim(Queue storage self, uint256 k) private {\n        while (k > 1 && isGreater(self, k / 2, k)) {\n            exchange(self, k, k / 2);\n            k = k / 2;\n        }\n    }\n\n    ///@notice move bid down heap\n    function sink(Queue storage self, uint256 k) private {\n        while (2 * k <= self.numBids) {\n            uint256 j = 2 * k;\n            if (j < self.numBids && isGreater(self, j, j + 1)) {\n                j++;\n            }\n            if (!isGreater(self, k, j)) {\n                break;\n            }\n            exchange(self, k, j);\n            k = j;\n        }\n    }\n\n    ///@notice insert bid in heap\n    function insert(\n        Queue storage self,\n        address owner,\n        uint256 price,\n        uint256 quantity\n    ) public {\n        insert(self, Bid(self.nextBidId++, owner, price, quantity));\n    }\n\n    ///@notice insert bid in heap\n    function insert(Queue storage self, Bid memory bid) private {\n        self.bidIdList.push(bid.bidId);\n        self.bidIdToBidMap[bid.bidId] = bid;\n        self.numBids += 1;\n        swim(self, self.numBids);\n        self.ownerToBidIds[bid.owner].push(bid.bidId);\n    }\n\n    ///@notice delete min bid from heap and return\n    function delMin(Queue storage self) public returns (Bid memory) {\n        require(!isEmpty(self), \"nothing to delete\");\n        Bid memory min = self.bidIdToBidMap[self.bidIdList[1]];\n        exchange(self, 1, self.numBids--);\n        self.bidIdList.pop();\n        delete self.bidIdToBidMap[min.bidId];\n        sink(self, 1);\n        uint256[] storage curUserBids = self.ownerToBidIds[min.owner];\n        for (uint256 i = 0; i < curUserBids.length; i++) {\n            if (curUserBids[i] == min.bidId) {\n                //remove from array and delete struct\n                curUserBids[i] = curUserBids[curUserBids.length - 1];\n                curUserBids.pop();\n                break;\n            }\n        }\n        return min;\n    }\n\n    ///@notice helper function to determine ordering. When two bids have the same price, give priority\n    ///to the one with the larger quantity\n    function isGreater(\n        Queue storage self,\n        uint256 i,\n        uint256 j\n    ) private view returns (bool) {\n        Bid memory bidI = self.bidIdToBidMap[self.bidIdList[i]];\n        Bid memory bidJ = self.bidIdToBidMap[self.bidIdList[j]];\n        if (bidI.price == bidJ.price) {\n            return bidI.quantity <= bidJ.quantity;\n        }\n        return bidI.price > bidJ.price;\n    }\n\n    ///@notice helper function to exchange to bids in the heap\n    function exchange(\n        Queue storage self,\n        uint256 i,\n        uint256 j\n    ) private {\n        uint256 tempId = self.bidIdList[i];\n        self.bidIdList[i] = self.bidIdList[j];\n        self.bidIdList[j] = tempId;\n    }\n}"
    }
  ]
}