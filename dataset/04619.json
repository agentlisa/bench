{
  "Title": "Use safe math",
  "Content": "There is [one unchecked math operation](https://github.com/decentraland/mana/blob/a13905356378cc0153dd3c2153c8ceae6400970d/contracts/ContinuousCrowdsale.sol#L49) which could overflow. Since it consists of token amounts, the probability is low, but it’s always better to be safe and perform checked operations. Consider [using a safe math library](https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol), or performing pre-condition checks on any math operation.\n\n\n**EDIT:** fixed in commit [`66cd12ef7d135a3cad17a35e48e974bb65a46cbf`](https://github.com/decentraland/mana/commit/66cd12ef7d135a3cad17a35e48e974bb65a46cbf).\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/ContinuousCrowdsale.sol",
      "content": "pragma solidity ^0.4.11;\n\nimport \"zeppelin-solidity/contracts/crowdsale/Crowdsale.sol\";\n\n/**\n * @title ContinuousCrowdsale\n * @dev ContinuousCrowdsale implements a contract for managing a continuous token sale\n */\ncontract ContinuousCrowdsale is Crowdsale {\n    // time bucket size\n    uint256 public constant BUCKET_SIZE = 12 hours;\n\n    // true if continous sale is enabled\n    bool public continuousSale = false;\n\n    // last time bucket from which tokens have been purchased\n    uint256 public lastBucket = 0;\n\n    // amount issued in the last bucket\n    uint256 public bucketAmount = 0;\n\n    // max amount of tokens to mint per time bucket\n    uint256 public issuance = 0;\n\n    function buyTokens(address beneficiary) payable {\n        require(beneficiary != 0x0);\n\n        if (continuousSale) {\n            prepareContinuousPurchase();\n            uint256 tokens = processPurchase(beneficiary);\n            checkContinuousPurchase(tokens);\n        } else {\n            require(validPurchase());\n            processPurchase(beneficiary);\n        }\n    }\n\n    function prepareContinuousPurchase() internal {\n        uint256 timestamp = block.timestamp;\n        uint256 bucket = timestamp - (timestamp % BUCKET_SIZE);\n\n        if (bucket > lastBucket) {\n            lastBucket = bucket;\n            bucketAmount = 0;\n        }\n    }\n\n    function checkContinuousPurchase(uint256 tokens) internal {\n        bucketAmount += tokens;\n        require(bucketAmount <= issuance);\n    }\n\n    function processPurchase(address beneficiary) internal returns(uint256) {\n        uint256 weiAmount = msg.value;\n        uint256 updatedWeiRaised = weiRaised.add(weiAmount);\n\n        // calculate token amount to be created\n        uint256 tokens = weiAmount.mul(rate);\n\n        // update state\n        weiRaised = updatedWeiRaised;\n\n        token.mint(beneficiary, tokens);\n        TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n\n        forwardFunds();\n\n        return tokens;\n    }\n}"
    }
  ]
}