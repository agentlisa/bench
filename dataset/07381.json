{
  "Title": "[L-04]  `require()` should be used instead of `assert()`",
  "Content": "Prior to solidity version 0.8.0, hitting an assert consumes the **remainder of the transaction's available gas** rather than returning it, as `require()`/`revert()` do. `assert()` should be avoided even past solidity version 0.8.0 as its [documentation](https://docs.soliditylang.org/en/v0.8.14/control-structures.html#panic-via-assert-and-error-via-require) states that \"The assert function creates an error of type Panic(uint256). ... Properly functioning code should never create a Panic, not even on invalid external input. If this happens, then there is a bug in your contract which you should fix\".\n\n*There are 2 instances of this issue:*\n\n```solidity\nFile: src/seaport/targets/SeaportLister.sol\n\n45:           assert(ConsiderationInterface(_consideration).validate(_orders));\n\n52:           assert(ConsiderationInterface(_consideration).cancel(_orders));\n\n```\nhttps://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/targets/SeaportLister.sol#L45\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-12-tessera",
  "Code": [
    {
      "filename": "src/seaport/targets/SeaportLister.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\nimport {IERC721} from \"../../interfaces/IERC721.sol\";\nimport {IERC1155} from \"../../interfaces/IERC1155.sol\";\n\nimport {ConsiderationInterface} from \"seaport/interfaces/ConsiderationInterface.sol\";\nimport {ItemType, OfferItem} from \"seaport/lib/ConsiderationStructs.sol\";\nimport {ISeaportLister, Order, OrderComponents} from \"../interfaces/ISeaportLister.sol\";\n\n/// @title SeaportLister\n/// @author Tessera\n/// @notice Target contract for executing the listing and delisting of orders on Seaport\ncontract SeaportLister is ISeaportLister {\n    /// @notice Address of the conduit that is approved to spend the items\n    address public immutable conduit;\n\n    constructor(address _conduit) {\n        conduit = _conduit;\n    }\n\n    /// @notice Approves the conduit to list the offer items\n    /// @param _consideration Address of the Consideration contract (Seaport)\n    /// @param _orders List of orders being validated\n    function validateListing(address _consideration, Order[] memory _orders) external {\n        uint256 ordersLength = _orders.length;\n        unchecked {\n            for (uint256 i; i < ordersLength; ++i) {\n                uint256 offerLength = _orders[i].parameters.offer.length;\n                for (uint256 j; j < offerLength; ++j) {\n                    OfferItem memory offer = _orders[i].parameters.offer[j];\n                    address token = offer.token;\n                    ItemType itemType = offer.itemType;\n                    if (itemType == ItemType.ERC721)\n                        IERC721(token).setApprovalForAll(conduit, true);\n                    if (itemType == ItemType.ERC1155)\n                        IERC1155(token).setApprovalForAll(conduit, true);\n                    if (itemType == ItemType.ERC20)\n                        IERC20(token).approve(conduit, type(uint256).max);\n                }\n            }\n        }\n        // Validates the order on-chain so no signature is required to fill it\n        assert(ConsiderationInterface(_consideration).validate(_orders));\n    }\n\n    /// @notice Cancels the listing of all offer items\n    /// @param _consideration Address of the Consideration contract (Seaport)\n    /// @param _orders List of orders being canceled\n    function cancelListing(address _consideration, OrderComponents[] memory _orders) external {\n        assert(ConsiderationInterface(_consideration).cancel(_orders));\n    }\n}"
    }
  ]
}