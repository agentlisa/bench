{
  "Title": "[M-03] Attacker can utilize function `CdpManager.redeemCollateral()` to break the order of sortedCdps",
  "Content": "\n<https://github.com/code-423n4/2023-10-badger/blob/f2f2e2cf9965a1020661d179af46cb49e993cb7e/packages/contracts/contracts/CdpManager.sol#L434-L443> \n\n<https://github.com/code-423n4/2023-10-badger/blob/f2f2e2cf9965a1020661d179af46cb49e993cb7e/packages/contracts/contracts/CdpManager.sol#L209-L214>\n\nThe `CdpManager.redeemCollateral()` function is used to send the `_debt` amount of EBTC to the system and redeem the corresponding amount of stETH. There are two important features to note about this function before delving into the problem:\n\n*   The function begins redemption from the Cdp with the smallest ICR, where the ICR is greater than or equal to MCR. The subsequently redeemed Cdps will follow the ascending order of NICR in the `SortedCdps` list.\n*   All Cdps that are redeemed, with the likely exception of the last one, will end up with no remaining debt and will be closed. If the last Cdp does have some remaining debt and collateral (indicating a valid and meaningful ICR), it will be reinserted into the `SortedCdps` list using the \"hint\" provided by the users/front-end.\n\nThe protocol utilizes a new technique by employing a `sortedCdps.batchRemove()` function to remove a consecutive sequence of Cdps in the sorted list after the redemption loop, instead of removing each one individually in each iteration of the loop for gas-saving purposes.\n\n```solidity\nwhile (\n    currentBorrower != address(0) && totals.remainingDebtToRedeem > 0 && _maxIterations > 0\n) {\n    ... \n    SingleRedemptionValues memory singleRedemption = _redeemCollateralFromCdp(\n        _redeemColFromCdp\n    );\n    ... \n}\n\n// remove from sortedCdps\nif (_numCdpsFullyRedeemed == 1) {\n    sortedCdps.remove(_firstRedeemed);\n} else if (_numCdpsFullyRedeemed > 1) {\n    bytes32[] memory _toRemoveIds = _getCdpIdsToRemove(\n        _lastRedeemed,\n        _numCdpsFullyRedeemed,\n        _firstRedeemed\n    );\n    sortedCdps.batchRemove(_toRemoveIds);\n}\n```\n\nAs we observe, in each iteration of the loop, the internal function `CdpManager._redeemCollateralFromCdp()` is triggered, executing the following logic:\n\n*   If there is no remaining debt, the Cdp should be closed. To accomplish this, the function `CdpManagerStorage._closeCdpByRedemption()` will be [triggered](https://github.com/code-423n4/2023-10-badger/blob/f2f2e2cf9965a1020661d179af46cb49e993cb7e/packages/contracts/contracts/CdpManager.sol#L171-L177), assigning the new STORAGE debt and collateral for the corresponding Cdp:\n\n    *   `Cdps[_cdpId].coll = 0;`\n    *   `Cdps[_cdpId].debt = 0;`\n\n    However, no \"remove\" operation will be executed for the Cdp in the `SortedCdps` list. Consequently, the removed Cdp will remain in the same position in the sorted list after the for-loop, with the new collateralization ratio (NICR), which is `type(uint256).max` following these [lines of code](https://github.com/code-423n4/2023-10-badger/blob/f2f2e2cf9965a1020661d179af46cb49e993cb7e/packages/contracts/contracts/Dependencies/EbtcMath.sol#L92-L101).\n\n*   Otherwise, the Cdp will be assigned a remaining value of debt and collateral and will immediately be reinserted into the `SortedCdps` list.\n\nThe flaw arises when the partially redeemed Cdp is reinserted while the fully redeemed Cdps haven't been removed from the sorted list yet.\n\nTo make it clearer, consider the following scenario:\nIn a regular flow of the redemption process, we have:\n\n1.  The `SortedCdps` list described by a sequence of `n` elements $x\\_1, x\\_2, ..., x_n$ in which:\n    *   $$x\\_1 \\geq x\\_2 \\geq ... \\geq x_n$$\n\n2.  A redemption request fully redeems Cdps from position `i+1 -> j-1` in the sorted list. Thus, the NICR of all Cdps in that range becomes `inf = type(uint256).max`. In other words:\n    *   $$x\\_{i+1} = x\\_{i+2} = ... = x\\_{j-1} = inf$$\n\n3.  The Cdp in position `i` is partially redeemed and updated with its NICR to $x_i'$. If the new $x_i'$ is greater than $x\\_{i-1}$, it should be reinserted in a smaller position than `i-1`, assuming it should be inserted between $x\\_{i-3}$ and $x\\_{i-2}$. The new `SortedCdps` list right after the loop should be:\n    *   $$x\\_1, ; ..., ; x\\_{i-3}, ; x\\_{i}', ; x\\_{i-2}, ; x\\_{i-1}, ; inf, ; ..., ; inf, ; x_j, ; ..., ; x_n$$\n    This means that the values passed by the sender of `_upperPartialRedemptionHint` and `_lowerPartialRedemptionHint` should be `i-2, i-3`.\n\n4.  After that, the process will execute the batch removal to remove all the Cdps that are fully redeemed, and the sorted list will be:\n    *   $$x\\_1, ; ..., ; x\\_{i-3}, ; x\\_{i}', ; x\\_{i-2}, ; x\\_{i-1}, ; x_j, ; ..., ; x_n$$\n\nTo disrupt this flow, the attacker can interfere in STEP 3 by passing malicious values of `_upperPartialRedemptionHint` and `_lowerPartialRedemptionHint`. In the example above, the attacker should use:\n\n*   `_upperPartialRedemptionHint = j-1`\n*   `_lowerPartialRedemptionHint = j`\n\nSince the Cdp at position `j-1` hasn't been removed yet in STEP 3, all the conditions for a valid insertion for $x\\_{i}'$ will be satisfied because:\n\n*   $x\\_{i}' ; > ; x\\_{i-1} ; >= ; x_j$\n*   $x\\_{i}' ; < ; inf ; = ; x\\_{j-1}$\n\nThus, the `SortedCdps` list will look like this after the redemption process:\n\n$$$\nx_1, ;..., ; x_{i-3}, ; x_{i-2}, ; x_{i-1}, ; x_i', ; x_j, ; ..., ; x_{n}\n$$$\n\nThis breaks the order of the `SortedCdps`, because $x_i' > x\\_{i-1}$ but has a larger position.\n\n### Impact\n\nThe sequence of the `sortedCdps` list will be disrupted, and given that essential protocol functions operate in accordance with this sequence, the severity of the issue is significant.\n\n### Recommended Mitigation Steps\n\nInstead of inserting the partially redeemed Cdp back in the for-loop, the function should reinsert it after removing the fully redeemed Cdp.\n\n**[Alex the Entreprenerd (Badger) disputed and commented](https://github.com/code-423n4/2023-10-badger-findings/issues/173#issuecomment-1818681956):**\n > The finding is known and part of the known broken invariants + cantina report.\n> \n> We would be more lenient if any impact was demonstrated but afaict there's only an edge case for Redemptions not working when liquidations are more profitable which would lead me to dispute even in that case.\n> \n> We are interested in more impacts if those were found.\n>\n> We would want to ask the Warden for the POC as we have a concern for the issue being valid, but it seems like the finding is impossible in practice.\n\n**[rayeaster (Badger) commented](https://github.com/code-423n4/2023-10-badger-findings/issues/173#issuecomment-1824252432):**\n > [Here](https://gist.github.com/CodingNameKiki/4925e433ee47be70e6a4ef3eebe75b81?permalink_comment_id=4770452#gistcomment-4770452) is a working POC to verify the finding.\n\n**[ronnyx2017 (Judge) commented](https://github.com/code-423n4/2023-10-badger-findings/issues/173#issuecomment-1827474072):**\n > > The finding is known and part of the known broken invariants + cantina report.\n> \n > I have noticed that a pull request https://github.com/ebtc-protocol/ebtc/pull/725 has been submitted to the main repo for this issue. Is this really OOS, @Alex the Entreprenerd?\n\n**[Alex the Entreprenerd (Badger) commented](https://github.com/code-423n4/2023-10-badger-findings/issues/173#issuecomment-1827750199):**\n > The breaking of sorting is known but the mechanism through which this was achieved was not, so we believe the finding to be in scope.\n> \n> The impact of this finding is unclear.\n\n**[ronnyx2017 (Judge) commented](https://github.com/code-423n4/2023-10-badger-findings/issues/173#issuecomment-1834962777):**\n >  The attack scenario provided by the warden is very clear, but I don't see any actual profit or loss from it. Warden might argue that the CDP's position is incorrect after partial redemption, leading to damage upon the next redemption. However, in reality, it could have been fully redeemed initially, and the attacker wouldn't have gained any additional profits from it. But this clearly violates a critical invariant, especially when carefully crafted inputs are used as attack vectors. Therefore, I believe this falls into a med category.\n\n**[CodingNameKiki (Warden) commented](https://github.com/code-423n4/2023-10-badger-findings/issues/173#issuecomment-1837848836):**\n > Currently working alongside the Badger team on some mitigations.\n> \n> So on short explanation I understood that this issue:\n> - Have no impact that I am aware of.\n> - Messes up only the first redeemable node after the attack.\n> - The node ordering is back to normal when someone else redeems after the attack.\n> \n> > The attack scenario provided by the warden is very clear, but I don't see any actual profit or loss from it.\n> \n> Agree with you on this one, at the same time an interesting question is why would anyone want to do this if there is no profit from it, no impact and the sorted order is back to normal on the next redeem.\n> \n> https://gist.github.com/CodingNameKiki/b3f36aacc704c082df2b974b2db89c78\n\n**[ronnyx2017 (Judge) decreased severity to Low/Non-critical and commented](https://github.com/code-423n4/2023-10-badger-findings/issues/173#issuecomment-1839714678):**\n > Thanks for the poc and verification from @CodingNameKiki . And the sponsor finally convinced me. The invariant was only temporarily broken, and whatever the attacker does during this intermediate stage will get back to the previous state. This impact is so minimal that it can be downgraded to a QA.\n\n**[WelToHackerLand (Warden) commented](https://github.com/code-423n4/2023-10-badger-findings/issues/173#issuecomment-1839885882):**\n > Hello @ronnyx2017 & @rayeaster, thank you for reviewing the issue.\n> \n> I would like to respectfully question the severity of the problem for the following reasons:\n> \n> - Initially, there doesn't seem to be an attacker involved in this issue, as a regular user seeking partial redemption could potentially disrupt the sorted cdps. The provided Proof of Concept (POC) demonstrates that the hints used by the sender are derived from the `hintHelpers` contract rather than being predetermined by an attacker.\n> \n> - Additionally, the POC presented by @CodingNameKiki might be applicable only when the redemption occurs immediately after. What if other transactions take place before the fixed redemption? For instance, consider a scenario where the NICR of `sortedCdps` post-redemption disrupts the order, such as [8, 12, 5]. If a user intends to open a new CDP with NICR = 9, the provided hints could be before NICR = 8, resulting in the new sorted cdps as [9, 8, 12, 5]. In this case, there are now two incorrect positions in the sorted list instead of one. The more `openCdp()` transactions are initiated, the more incorrect positions could emerge, and the cost to rectify the order becomes higher.\n> \n> Considering these factors, I believe the severity of this issue should be classified as medium.\n\n**[CodingNameKiki (Warden) commented](https://github.com/code-423n4/2023-10-badger-findings/issues/173#issuecomment-1840130729):**\n > > Initially, there doesn't seem to be an attacker involved in this issue, as a regular user seeking partial redemption could potentially disrupt the sorted cdps. The provided Proof of Concept (POC) demonstrates that the hints used by the sender are derived from the hintHelpers contract rather than being predetermined by an attacker.\n> \n> Do you mean providing wrong **\\_firstRedemptionHint** or wrong **\\_partialRedemptionHintNICR**, if that's the case the system will manually find the correct redeemable hint which is the first node with ICR >= MCR, on the other hand if you provide a wrong partial hint NICR the partial redeeming will be cancelled. \n> \n> ```solidity\n>         if (_isValidFirstRedemptionHint(_firstRedemptionHint, totals.price)) {\n>             currentBorrower = sortedCdps.getOwnerAddress(_firstRedemptionHint);\n>         } else {\n>             _cId = sortedCdps.getLast();\n>             currentBorrower = sortedCdps.getOwnerAddress(_cId);\n>             // Find the first cdp with ICR >= MCR\n>             while (currentBorrower != address(0) && getSyncedICR(_cId, totals.price) < MCR) {\n>                 _cId = sortedCdps.getPrev(_cId);\n>                 currentBorrower = sortedCdps.getOwnerAddress(_cId);\n>             }\n>         }\n> ```\n> ```solidity\n>             if (\n>                 newNICR != _redeemColFromCdp.partialRedemptionHintNICR ||\n>                 collateral.getPooledEthByShares(newColl) < MIN_NET_STETH_BALANCE\n>             ) {\n>                 singleRedemption.cancelledPartial = true;\n>                 return singleRedemption;\n>             }\n> ```\n> \n> In case you are talking about the **upper** and **lower** hints used in the POC, I tried every other possible hints and the system is working correctly. So this scenario is only possible if someone provided the exact hints and only when the system fully redeems a node and partially redeems from another.\n> \n> > We would be more lenient if any impact was demonstrated but afaict there's only an edge case for Redemptions not working when liquidations are more profitable which would lead me to dispute even in that case\n> We are interested in more impacts if those were found\n> \n> As mentioned we are already aware and it's known that wrong sorting can happen from the broken invariants, the question should be what impact does this issue lead to? Would suggest for a further research on the impact here and coded POC.\n\n**[huuducsc (Warden) commented](https://github.com/code-423n4/2023-10-badger-findings/issues/173#issuecomment-1841303646):**\n > @ronnyx2017, @rayeaster, & @Alex the Entreprenerd -\n> I would like to explain the reasons why I believe this issue should be considered at least a medium severity. I also believe that these explanations can address the concerns raised from @codingnamekiki and others to downgrade this issue.\n> \n> 1.  I believe the provided attack vector is very clear, indicating that an attacker can disrupt the sorting order of CDPs through partial redemption. The attacker just needs to call the function redeemCollateral with malicious values for `_upperPartialRedemptionHint` and `_lowerPartialRedemptionHint` to place the partially redeemed CDP in the wrong position. The scenario was described very clearly in the report, and there is another proof of concept (POC) mentioned in [the comment by @rayeaster](https://github.com/code-423n4/2023-10-badger-findings/issues/173#issuecomment-1824252432).<br>\n> Additionally, I believe it's not a known issue because the known scenario that also breaks the order is from redistribution of debt and yield, which is different. This scenario allows an external attacker to interact with and manipulate the broken invariants. It has a significant impact, which will be described below.\n> \n> 2.  An attacker can increase the NICR of a partially redeemed CDP to a very large value and place it in the wrong position. To achieve this, the attacker can calculate the redemption amount to leave the remaining debt of the partially redeemed CDP at 1. For example, if a CDP has &#36;15e18 in collateral and &#36;10e18 in debt, the attacker can calculate a partial redemption with a debt of &#36;10e18 - 1, resulting in a remaining debt of 1 and remaining collateral of 5e18 (assuming remaining collateral can bypass MIN\\_NET\\_STETH\\_BALANCE). This manipulation causes the new NICR to become very large.<br>\n> Consider the scenario in the report. After redemption, the sortedCdps list will be:<br>\n> $$x_1, \\;..., \\; x_{i-3}, \\; x_{i-2}, \\; x_{i-1}, \\; ..., \\; x_i', \\; x_j, \\; ..., \\; x_{n} $$\n> $x_{i}'$ may have a very large NICR (up to infinity), and it is the first node with ICR >= MCR because the ICR of $x_{j}$ is below MCR. Therefore, any new CDP that is opened with `_upperHint` as dummy or invalid will be placed after the CDP $x_{i}'$. This is because the `_findInsertPosition` function will find the position in ascending order if the `_prevId `parameter is dummy or invalid.You can read this [code snippet](https://github.com/code-423n4/2023-10-badger/blob/f2f2e2cf9965a1020661d179af46cb49e993cb7e/packages/contracts/contracts/SortedCdps.sol#L699-L701) to understand this flow.<br>\n> For example, when the NICR of $x_{i}'$ is very large (considered infinity), the NICR list of sortedCdps is like:<br>\n> 300%, 250%, ..., 160%, 150%, inf, 125%, 124%, ...<br>\n> When opening a CDP with a 200% NICR and `_upperHint` as dummy or invalid, the list will become:<br>\n> 300%, 250%, ..., 160%, 150%, inf, 200%, 125%, 124%, ...<br>\n> Therefore, the new CDP (200% NICR) will be inserted to a wrong position and become the first node (most right) with ICR > MCR and will be redeemed with priority, even though the NICR of that CDP is still good.<br>\n> Here is a POC of this scenario: https://gist.github.com/huuducsc/c6885a06058d56cd4f6669f3b11c8f7d\n> \n> 3.  Due to the above scenario, I disagree with [the statement](https://github.com/code-423n4/2023-10-badger-findings/issues/173#issuecomment-1839714678) made by @ronnyx2017: \"The invariant was only temporarily broken, and whatever the attacker does during this intermediate stage will get back to the previous state.\"<br>\n> The attacker can open numerous new Cdps into incorrect positions using dummy `upperHint` and invalid `lowerHint` (details are described in the scenario and PoC of section 2), disrupting the order of protocols. Moreover, the attacker can front-run any opening CDP transaction by users to break the order, make it becomes the first position to be redeemed. \n> Here are the details of the impacts that cause significant damage to protocol:<br>\n> * The attacker can break the order of `sortedCdps` and disrupt it by opening many new CDPs with `_upperHint` is dummy, placing them in incorrect positions (as described above). Therefore, sortedCdps will have many incorrect positions that are not easy to resolve. This disruption can mess up the protocol's data and may result in incorrect returns from the HintHelpers contract.\n> * After the mentioned manipulation, any new CDP will be at risk of being redeemed with priority, even though its NICR is still good. This can happen if the `_upperHint` passed to the `openCdp` function of users is dummy or invalid, which can occur normally due to changes in on-chain data like front-running or incorrect returns from the HintHelper contract. It creates an unfair situation for protocol users, as they may be compelled to redeem their assets (acquiring debt assets and losing collateral assets) even when they have a CDP with a high NICR.\n> \n> In conclusion, this issue has a significant impact that can disrupt the ordered state of the protocol and put users at risk of having their assets forcibly redeemed. However, the severity may increase if attackers identify other attack vectors (which I haven't found until now) to manipulate the state and exploit vulnerabilities since attackers are able to break order invariants externally.\n\n**[CodingNameKiki (Warden) commented](https://github.com/code-423n4/2023-10-badger-findings/issues/173#issuecomment-1841381369):**\n > ^ Thanks for the reply, check the below POC which confirms the above statements.\n> \n> https://gist.github.com/CodingNameKiki/0f4bc68802cfcbfe255759554b735b38\n\n**[ronnyx2017 (Judge) increased severity to Medium and commented](https://github.com/code-423n4/2023-10-badger-findings/issues/173#issuecomment-1842395637):**\n > Thank you warden for providing additional information on the impact. This has made the report ultimately comprehensive and clear.\n> \n> I have discussed the final rating based on the following facts, rules, and input from two senior judges. We ultimately elevate this issue to MEDIUM.<br>\n> **Record I (recommendations from senior judges):**\n> > As the original submission doesn't contain a PoC of the final impact, I think Medium is more appropriate.\n> \n> **Record II (my assessment):**\n> > 1. For the impact I. \n> > \n> > > This disruption can mess up the protocol's data and may result in incorrect returns from the HintHelpers contract.\n> > \n> > it meets the criteria of MED. Although it is not dos, it affected the availability of the protocol for normal users.\n> > \n> > > but the function of the protocol or its availability could be impacted\n> > \n> > 2. For impact II.\n> > \n> > > It creates an unfair situation for protocol users, as they may be compelled to redeem their assets (acquiring debt assets and losing collateral assets) even when they have a CDP with a high NICR.\n> > \n> > It's based on impact I, but I think it can be a HIGH according to the criteria:\n> > \n> > > Assets can be ~stolen/lost/~ compromised ~directly or~ indirectly if there is a valid attack path that does not have hand-wavy hypotheticals\n> > \n> > Because attackers are able to break order invariants externally, we can believe the attack path is explicit (include front run). And the redemption from high NICR cdp won't result in a direct loss of assets, but it is clearly a form of compromise.\n\n_Note: For further discussion, see [here](https://github.com/code-423n4/2023-10-badger-findings/issues/173)._\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-badger",
  "Code": [
    {
      "filename": "packages/contracts/contracts/CdpManager.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./Interfaces/ICdpManager.sol\";\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/IEBTCToken.sol\";\nimport \"./Interfaces/ISortedCdps.sol\";\nimport \"./Dependencies/ICollateralTokenOracle.sol\";\nimport \"./CdpManagerStorage.sol\";\nimport \"./Dependencies/Proxy.sol\";\n\n/// @title CdpManager is mainly in charge of all Cdp related core processing like collateral & debt accounting, split fee calculation, redemption, etc\n/// @notice Except for redemption, end user typically will interact with BorrowerOeprations for individual Cdp actions\n/// @dev CdpManager also handles liquidation through delegatecall to LiquidationLibrary\ncontract CdpManager is CdpManagerStorage, ICdpManager, Proxy {\n    // --- Dependency setter ---\n\n    /// @notice Constructor for CdpManager contract.\n    /// @dev Sets up dependencies and initial staking reward split.\n    /// @param _liquidationLibraryAddress Address of the liquidation library.\n    /// @param _authorityAddress Address of the authority.\n    /// @param _borrowerOperationsAddress Address of BorrowerOperations.\n    /// @param _collSurplusPoolAddress Address of CollSurplusPool.\n    /// @param _ebtcTokenAddress Address of the eBTC token.\n    /// @param _sortedCdpsAddress Address of the SortedCDPs.\n    /// @param _activePoolAddress Address of the ActivePool.\n    /// @param _priceFeedAddress Address of the price feed.\n    /// @param _collTokenAddress Address of the collateral token.\n    constructor(\n        address _liquidationLibraryAddress,\n        address _authorityAddress,\n        address _borrowerOperationsAddress,\n        address _collSurplusPoolAddress,\n        address _ebtcTokenAddress,\n        address _sortedCdpsAddress,\n        address _activePoolAddress,\n        address _priceFeedAddress,\n        address _collTokenAddress\n    )\n        CdpManagerStorage(\n            _liquidationLibraryAddress,\n            _authorityAddress,\n            _borrowerOperationsAddress,\n            _collSurplusPoolAddress,\n            _ebtcTokenAddress,\n            _sortedCdpsAddress,\n            _activePoolAddress,\n            _priceFeedAddress,\n            _collTokenAddress\n        )\n    {\n        stakingRewardSplit = STAKING_REWARD_SPLIT;\n        // Emit initial value for analytics\n        emit StakingRewardSplitSet(stakingRewardSplit);\n\n        (uint256 _oldIndex, uint256 _newIndex) = _readStEthIndex();\n        _syncStEthIndex(_oldIndex, _newIndex);\n        systemStEthFeePerUnitIndex = DECIMAL_PRECISION;\n    }\n\n    // --- Getters ---\n\n    /// @notice Get the count of active Cdps in the system\n    /// @return The number of current active Cdps (not closed) in the system.\n    function getActiveCdpsCount() external view override returns (uint256) {\n        return CdpIds.length;\n    }\n\n    /// @notice Get the CdpId at a given _index in the global active CdpIds array.\n    /// @param _index Index of the CdpIds array.\n    /// @return Cdp ID at the specified _index within the global active CdpIds array.\n    function getIdFromCdpIdsArray(uint256 _index) external view override returns (bytes32) {\n        return CdpIds[_index];\n    }\n\n    // --- Cdp Liquidation functions ---\n    // -----------------------------------------------------------------\n    //    Cdp ICR     |       Liquidation Behavior (TODO gas compensation?)\n    //\n    //  < MCR         |  debt could be fully repaid by liquidator\n    //                |  and ALL collateral transferred to liquidator\n    //                |  OR debt could be partially repaid by liquidator and\n    //                |  liquidator could get collateral of (repaidDebt * max(LICR, min(ICR, MCR)) / price)\n    //\n    //  > MCR & < TCR |  only liquidatable in Recovery Mode (TCR < CCR)\n    //                |  debt could be fully repaid by liquidator\n    //                |  and up to (repaid debt * MCR) worth of collateral\n    //                |  transferred to liquidator while the residue of collateral\n    //                |  will be available in CollSurplusPool for owner to claim\n    //                |  OR debt could be partially repaid by liquidator and\n    //                |  liquidator could get collateral of (repaidDebt * max(LICR, min(ICR, MCR)) / price)\n    // -----------------------------------------------------------------\n\n    /// @notice Fully liquidate a single Cdp by ID. Cdp must meet the criteria for liquidation at the time of execution.\n    /// @notice callable by anyone, attempts to liquidate the CdpId. Executes successfully if Cdp meets the conditions for liquidation (e.g. in Normal Mode, it liquidates if the Cdp's ICR < the system MCR).\n    /// @dev forwards msg.data directly to the liquidation library using OZ proxy core delegation function\n    /// @param _cdpId ID of the Cdp to liquidate.\n    function liquidate(bytes32 _cdpId) external override {\n        _delegate(liquidationLibrary);\n    }\n\n    /// @notice Partially liquidate a single Cdp.\n    /// @dev forwards msg.data directly to the liquidation library using OZ proxy core delegation function\n    /// @param _cdpId ID of the Cdp to partially liquidate.\n    /// @param _partialAmount Amount to partially liquidate.\n    /// @param _upperPartialHint Upper hint for reinsertion of the Cdp into the linked list.\n    /// @param _lowerPartialHint Lower hint for reinsertion of the Cdp into the linked list.\n    function partiallyLiquidate(\n        bytes32 _cdpId,\n        uint256 _partialAmount,\n        bytes32 _upperPartialHint,\n        bytes32 _lowerPartialHint\n    ) external override {\n        _delegate(liquidationLibrary);\n    }\n\n    // --- Batch/Sequence liquidation functions ---\n\n    /// @notice Attempt to liquidate a custom list of Cdps provided by the caller\n    /// @notice Callable by anyone, accepts a custom list of Cdps addresses as an argument.\n    /// @notice Steps through the provided list and attempts to liquidate every Cdp, until it reaches the end or it runs out of gas.\n    /// @notice A Cdp is liquidated only if it meets the conditions for liquidation.\n    /// @dev forwards msg.data directly to the liquidation library using OZ proxy core delegation function\n    /// @param _cdpArray Array of Cdps to liquidate.\n    function batchLiquidateCdps(bytes32[] memory _cdpArray) external override {\n        _delegate(liquidationLibrary);\n    }\n\n    // --- Redemption functions ---\n\n    /// @notice // Redeem as much collateral as possible from given Cdp in exchange for EBTC up to specified maximum\n    /// @param _redeemColFromCdp Struct containing variables for redeeming collateral.\n    /// @return singleRedemption Struct containing redemption values.\n    function _redeemCollateralFromCdp(\n        SingleRedemptionInputs memory _redeemColFromCdp\n    ) internal returns (SingleRedemptionValues memory singleRedemption) {\n        // Determine the remaining amount (lot) to be redeemed,\n        // capped by the entire debt of the Cdp minus the liquidation reserve\n        singleRedemption.debtToRedeem = EbtcMath._min(\n            _redeemColFromCdp.maxEBTCamount,\n            Cdps[_redeemColFromCdp.cdpId].debt /// @audit Redeem everything\n        );\n\n        singleRedemption.collSharesDrawn = collateral.getSharesByPooledEth(\n            (singleRedemption.debtToRedeem * DECIMAL_PRECISION) / _redeemColFromCdp.price\n        );\n\n        // Repurposing this struct here to avoid stack too deep.\n        CdpDebtAndCollShares memory _oldDebtAndColl = CdpDebtAndCollShares(\n            Cdps[_redeemColFromCdp.cdpId].debt,\n            Cdps[_redeemColFromCdp.cdpId].coll\n        );\n\n        // Decrease the debt and collateral of the current Cdp according to the EBTC lot and corresponding ETH to send\n        uint256 newDebt = _oldDebtAndColl.debt - singleRedemption.debtToRedeem;\n        uint256 newColl = _oldDebtAndColl.collShares - singleRedemption.collSharesDrawn;\n\n        if (newDebt == 0) {\n            // No debt remains, close Cdp\n            // No debt left in the Cdp, therefore the cdp gets closed\n            {\n                address _borrower = sortedCdps.getOwnerAddress(_redeemColFromCdp.cdpId);\n                uint256 _liquidatorRewardShares = Cdps[_redeemColFromCdp.cdpId]\n                    .liquidatorRewardShares;\n\n                singleRedemption.collSurplus = newColl; // Collateral surplus processed on full redemption\n                singleRedemption.liquidatorRewardShares = _liquidatorRewardShares;\n                singleRedemption.fullRedemption = true;\n\n                _closeCdpByRedemption(\n                    _redeemColFromCdp.cdpId,\n                    0,\n                    newColl,\n                    _liquidatorRewardShares,\n                    _borrower\n                );\n\n                emit CdpUpdated(\n                    _redeemColFromCdp.cdpId,\n                    _borrower,\n                    msg.sender,\n                    _oldDebtAndColl.debt,\n                    _oldDebtAndColl.collShares,\n                    0,\n                    0,\n                    0,\n                    CdpOperation.redeemCollateral\n                );\n            }\n        } else {\n            // Debt remains, reinsert Cdp\n            uint256 newNICR = EbtcMath._computeNominalCR(newColl, newDebt);\n\n            /*\n             * If the provided hint is out of date, we bail since trying to reinsert without a good hint will almost\n             * certainly result in running out of gas.\n             *\n             * If the resultant net coll of the partial is less than the minimum, we bail.\n             */\n            if (\n                newNICR != _redeemColFromCdp.partialRedemptionHintNICR ||\n                collateral.getPooledEthByShares(newColl) < MIN_NET_STETH_BALANCE\n            ) {\n                singleRedemption.cancelledPartial = true;\n                return singleRedemption;\n            }\n\n            sortedCdps.reInsert(\n                _redeemColFromCdp.cdpId,\n                newNICR,\n                _redeemColFromCdp.upperPartialRedemptionHint,\n                _redeemColFromCdp.lowerPartialRedemptionHint\n            );\n\n            Cdps[_redeemColFromCdp.cdpId].debt = newDebt;\n            Cdps[_redeemColFromCdp.cdpId].coll = newColl;\n            _updateStakeAndTotalStakes(_redeemColFromCdp.cdpId);\n\n            emit CdpUpdated(\n                _redeemColFromCdp.cdpId,\n                ISortedCdps(sortedCdps).getOwnerAddress(_redeemColFromCdp.cdpId),\n                msg.sender,\n                _oldDebtAndColl.debt,\n                _oldDebtAndColl.collShares,\n                newDebt,\n                newColl,\n                Cdps[_redeemColFromCdp.cdpId].stake,\n                CdpOperation.redeemCollateral\n            );\n        }\n\n        return singleRedemption;\n    }\n\n    /*\n     * Called when a full redemption occurs, and closes the cdp.\n     * The redeemer swaps (debt) EBTC for (debt)\n     * worth of stETH, so the stETH liquidation reserve is all that remains.\n     * In order to close the cdp, the stETH liquidation reserve is returned to the Cdp owner,\n     * The debt recorded on the cdp's struct is zero'd elswhere, in _closeCdp.\n     * Any surplus stETH left in the cdp, is sent to the Coll surplus pool, and can be later claimed by the borrower.\n     */\n    function _closeCdpByRedemption(\n        bytes32 _cdpId,\n        uint256 _EBTC,\n        uint256 _collSurplus,\n        uint256 _liquidatorRewardShares,\n        address _borrower\n    ) internal {\n        _closeCdpWithoutRemovingSortedCdps(_cdpId, Status.closedByRedemption);\n\n        // Update Active Pool EBTC, and send ETH to account\n        activePool.decreaseSystemDebt(_EBTC);\n\n        // Register stETH surplus from upcoming transfers of stETH collateral and liquidator reward shares\n        collSurplusPool.increaseSurplusCollShares(_borrower, _collSurplus + _liquidatorRewardShares);\n\n        // CEI: send stETH coll and liquidator reward shares from Active Pool to CollSurplus Pool\n        activePool.transferSystemCollSharesAndLiquidatorReward(\n            address(collSurplusPool),\n            _collSurplus,\n            _liquidatorRewardShares\n        );\n    }\n\n    /// @notice Returns true if the CdpId specified is the lowest-ICR Cdp in the linked list that still has MCR > ICR\n    /// @dev Returns false if the specified CdpId hint is blank\n    /// @dev Returns false if the specified CdpId hint doesn't exist in the list\n    /// @dev Returns false if the ICR of the specified CdpId is < MCR\n    /// @dev Returns true if the specified CdpId is not blank, exists in the list, has an ICR > MCR, and the next lower Cdp in the list is either blank or has an ICR < MCR.\n    function _isValidFirstRedemptionHint(\n        bytes32 _firstRedemptionHint,\n        uint256 _price\n    ) internal view returns (bool) {\n        if (\n            _firstRedemptionHint == sortedCdps.nonExistId() ||\n            !sortedCdps.contains(_firstRedemptionHint) ||\n            getSyncedICR(_firstRedemptionHint, _price) < MCR\n        ) {\n            return false;\n        }\n\n        bytes32 nextCdp = sortedCdps.getNext(_firstRedemptionHint);\n        return nextCdp == sortedCdps.nonExistId() || getSyncedICR(nextCdp, _price) < MCR;\n    }\n\n    /// @notice Send _debt EBTC to the system and redeem the corresponding amount of collateral\n    /// @notice from as many Cdps as are needed to fill the redemption request.\n    /// @notice\n    /// @notice Note that if _debt is very large, this function can run out of gas, specially if traversed cdps are small (meaning many small Cdps are redeemed against).\n    /// @notice This can be easily avoided by splitting the total _debt in appropriate chunks and calling the function multiple times.\n    /// @notice\n    /// @notice There is a optional parameter `_maxIterations` which can also be provided, so the loop through Cdps is capped (if itâ€™s zero, it will be ignored).\n    /// @notice This makes it easier to avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough,\n    /// @notice without needing to know the \"topology\" of the cdp list. It also avoids the need to set the cap in stone in the contract,\n    /// @notice nor doing gas calculations, as both gas price and opcode costs can vary.\n    /// @notice\n    /// @notice All Cdps that are redeemed from -- with the likely exception of the last one -- will end up with no debt left,\n    /// @notice therefore they will be closed.\n    /// @notice If the last Cdp does have some remaining debt & collateral (it has a valid meaningful ICR) then reinsertion of the CDP\n    /// @notice could be anywhere in the entire SortedCdps list, therefore this redemption requires a hint.\n    /// @notice\n    /// @notice A frontend should use HintHelper.getRedemptionHints() to calculate what the ICR of this Cdp will be after redemption,\n    /// @notice and pass a hint for its position in the SortedCdps list along with the ICR value that the hint was found for.\n    /// @notice\n    /// @notice If another transaction modifies the list between calling getRedemptionHints()\n    /// @notice and passing the hints to redeemCollateral(), it is very likely that the last (partially)\n    /// @notice redeemed Cdp would end up with a different ICR than what the hint is for.\n    /// @notice\n    /// @notice In this case, the redemption will stop after the last completely redeemed Cdp and the sender will keep the\n    /// @notice remaining EBTC amount, which they can attempt to redeem later.\n    /// @param _debt The total eBTC debt amount to be redeemed\n    /// @param _firstRedemptionHint The first CdpId to be considered for redemption, could get from HintHelper.getRedemptionHints()\n    /// @param _upperPartialRedemptionHint The first CdpId to be considered for redemption, could get from HintHelper.getApproxHint(_partialRedemptionHintNICR) then SortedCdps.findInsertPosition(_partialRedemptionHintNICR)\n    /// @param _lowerPartialRedemptionHint The first CdpId to be considered for redemption, could get from HintHelper.getApproxHint(_partialRedemptionHintNICR) then SortedCdps.findInsertPosition(_partialRedemptionHintNICR)\n    /// @param _partialRedemptionHintNICR The new Nominal Collateral Ratio (NICR) of the last redeemed CDP after partial redemption, could get from HintHelper.getRedemptionHints()\n    /// @param _maxIterations The maximum allowed iteration along the SortedCdps loop, if zero then there is no limit\n    /// @param _maxFeePercentage The maximum allowed redemption fee for this redemption\n    function redeemCollateral(\n        uint256 _debt,\n        bytes32 _firstRedemptionHint,\n        bytes32 _upperPartialRedemptionHint,\n        bytes32 _lowerPartialRedemptionHint,\n        uint256 _partialRedemptionHintNICR,\n        uint256 _maxIterations,\n        uint256 _maxFeePercentage\n    ) external override nonReentrantSelfAndBOps {\n        RedemptionTotals memory totals;\n\n        // early check to ensure redemption is not paused\n        require(redemptionsPaused == false, \"CdpManager: Redemptions Paused\");\n\n        _requireValidMaxFeePercentage(_maxFeePercentage);\n\n        _syncGlobalAccounting(); // Apply state, we will syncGracePeriod at end of function\n\n        totals.price = priceFeed.fetchPrice();\n        {\n            (\n                uint256 tcrAtStart,\n                uint256 systemCollSharesAtStart,\n                uint256 systemDebtAtStart\n            ) = _getTCRWithSystemDebtAndCollShares(totals.price);\n            totals.tcrAtStart = tcrAtStart;\n            totals.systemCollSharesAtStart = systemCollSharesAtStart;\n            totals.systemDebtAtStart = systemDebtAtStart;\n        }\n\n        _requireTCRisNotBelowMCR(totals.price, totals.tcrAtStart);\n        _requireAmountGreaterThanZero(_debt);\n\n        _requireEbtcBalanceCoversRedemptionAndWithinSupply(\n            msg.sender,\n            _debt,\n            totals.systemDebtAtStart\n        );\n\n        totals.remainingDebtToRedeem = _debt;\n        address currentBorrower;\n        bytes32 _cId = _firstRedemptionHint;\n\n        if (_isValidFirstRedemptionHint(_firstRedemptionHint, totals.price)) {\n            currentBorrower = sortedCdps.getOwnerAddress(_firstRedemptionHint);\n        } else {\n            _cId = sortedCdps.getLast();\n            currentBorrower = sortedCdps.getOwnerAddress(_cId);\n            // Find the first cdp with ICR >= MCR\n            while (currentBorrower != address(0) && getSyncedICR(_cId, totals.price) < MCR) {\n                _cId = sortedCdps.getPrev(_cId);\n                currentBorrower = sortedCdps.getOwnerAddress(_cId);\n            }\n        }\n\n        // Loop through the Cdps starting from the one with lowest collateral\n        // ratio until _amount of EBTC is exchanged for collateral\n        if (_maxIterations == 0) {\n            _maxIterations = type(uint256).max;\n        }\n\n        bytes32 _firstRedeemed = _cId;\n        bytes32 _lastRedeemed = _cId;\n        uint256 _numCdpsFullyRedeemed;\n\n        /**\n            Core Redemption Loop\n        */\n        while (\n            currentBorrower != address(0) && totals.remainingDebtToRedeem > 0 && _maxIterations > 0\n        ) {\n            // Save the address of the Cdp preceding the current one, before potentially modifying the list\n            {\n                _syncAccounting(_cId); /// @audit This happens even if the re-insertion doesn't\n\n                SingleRedemptionInputs memory _redeemColFromCdp = SingleRedemptionInputs(\n                    _cId,\n                    totals.remainingDebtToRedeem,\n                    totals.price,\n                    _upperPartialRedemptionHint,\n                    _lowerPartialRedemptionHint,\n                    _partialRedemptionHintNICR\n                );\n                SingleRedemptionValues memory singleRedemption = _redeemCollateralFromCdp(\n                    _redeemColFromCdp\n                );\n                // Partial redemption was cancelled (out-of-date hint, or new net debt < minimum),\n                // therefore we could not redeem from the last Cdp\n                if (singleRedemption.cancelledPartial) break;\n\n                totals.debtToRedeem = totals.debtToRedeem + singleRedemption.debtToRedeem;\n                totals.collSharesDrawn = totals.collSharesDrawn + singleRedemption.collSharesDrawn;\n                totals.remainingDebtToRedeem =\n                    totals.remainingDebtToRedeem -\n                    singleRedemption.debtToRedeem;\n                totals.totalCollSharesSurplus =\n                    totals.totalCollSharesSurplus +\n                    singleRedemption.collSurplus;\n\n                if (singleRedemption.fullRedemption) {\n                    _lastRedeemed = _cId;\n                    _numCdpsFullyRedeemed = _numCdpsFullyRedeemed + 1;\n                }\n\n                bytes32 _nextId = sortedCdps.getPrev(_cId);\n                address nextUserToCheck = sortedCdps.getOwnerAddress(_nextId);\n                currentBorrower = nextUserToCheck;\n                _cId = _nextId;\n            }\n            _maxIterations--;\n        }\n        require(totals.collSharesDrawn > 0, \"CdpManager: Unable to redeem any amount\");\n\n        // remove from sortedCdps\n        if (_numCdpsFullyRedeemed == 1) {\n            sortedCdps.remove(_firstRedeemed);\n        } else if (_numCdpsFullyRedeemed > 1) {\n            bytes32[] memory _toRemoveIds = _getCdpIdsToRemove(\n                _lastRedeemed,\n                _numCdpsFullyRedeemed,\n                _firstRedeemed\n            );\n            sortedCdps.batchRemove(_toRemoveIds);\n        }\n\n        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption.\n        // Use the saved total EBTC supply value, from before it was reduced by the redemption.\n        _updateBaseRateFromRedemption(\n            totals.collSharesDrawn,\n            totals.price,\n            totals.systemDebtAtStart\n        );\n\n        // Calculate the ETH fee\n        totals.feeCollShares = _getRedemptionFee(totals.collSharesDrawn);\n\n        _requireUserAcceptsFee(totals.feeCollShares, totals.collSharesDrawn, _maxFeePercentage);\n\n        totals.collSharesToRedeemer = totals.collSharesDrawn - totals.feeCollShares;\n\n        _syncGracePeriodForGivenValues(\n            totals.systemCollSharesAtStart - totals.collSharesDrawn - totals.totalCollSharesSurplus,\n            totals.systemDebtAtStart - totals.debtToRedeem,\n            totals.price\n        );\n\n        emit Redemption(\n            _debt,\n            totals.debtToRedeem,\n            totals.collSharesDrawn,\n            totals.feeCollShares,\n            msg.sender\n        );\n\n        // Burn the total eBTC that is redeemed\n        ebtcToken.burn(msg.sender, totals.debtToRedeem);\n\n        // Update Active Pool eBTC debt internal accounting\n        activePool.decreaseSystemDebt(totals.debtToRedeem);\n\n        // Allocate the stETH fee to the FeeRecipient\n        activePool.allocateSystemCollSharesToFeeRecipient(totals.feeCollShares);\n\n        // CEI: Send the stETH drawn to the redeemer\n        activePool.transferSystemCollShares(msg.sender, totals.collSharesToRedeemer);\n    }\n\n    // --- Helper functions ---\n\n    function _getCdpIdsToRemove(\n        bytes32 _start,\n        uint256 _total,\n        bytes32 _end\n    ) internal view returns (bytes32[] memory) {\n        uint256 _cnt = _total;\n        bytes32 _id = _start;\n        bytes32[] memory _toRemoveIds = new bytes32[](_total);\n        while (_cnt > 0 && _id != bytes32(0)) {\n            _toRemoveIds[_total - _cnt] = _id;\n            _cnt = _cnt - 1;\n            _id = sortedCdps.getNext(_id);\n        }\n        require(_toRemoveIds[0] == _start, \"CdpManager: batchRemoveSortedCdpIds check start error\");\n        require(\n            _toRemoveIds[_total - 1] == _end,\n            \"CdpManager: batchRemoveSortedCdpIds check end error\"\n        );\n        return _toRemoveIds;\n    }\n\n    /// @notice Synchorize the accounting for the specified Cdp\n    /// @notice It will synchronize global accounting with stETH share index first\n    /// @notice then apply split fee and debt redistribution if any\n    /// @param _cdpId cdpId to sync pending accounting state for\n    function syncAccounting(bytes32 _cdpId) external virtual override {\n        /// @audit Opening can cause invalid reordering of Cdps due to changing values without reInserting into sortedCdps\n        _requireCallerIsBorrowerOperations();\n        return _syncAccounting(_cdpId);\n    }\n\n    /// @notice Update stake for the specified Cdp and total stake within the system.\n    /// @dev Only BorrowerOperations is allowed to call this function\n    /// @param _cdpId cdpId to update stake for\n    function updateStakeAndTotalStakes(bytes32 _cdpId) external override returns (uint256) {\n        _requireCallerIsBorrowerOperations();\n        return _updateStakeAndTotalStakes(_cdpId);\n    }\n\n    /// @notice Close the specified Cdp by ID.\n    /// @dev Only BorrowerOperations is allowed to call this function.\n    /// @dev This will close the Cdp and update its status to `closedByOwner`\n    /// @dev The collateral and debt will be zero'd out\n    /// @dev The Cdp will be removed from the sorted list\n    /// @dev The close will emit a `CdpUpdated` event containing closing details\n    /// @param _cdpId ID of the Cdp to close\n    /// @param _borrower Address of the Cdp borrower\n    /// @param _debt The recorded Cdp debt prior to closing\n    /// @param _coll The recorded Cdp collateral shares prior to closing\n    function closeCdp(\n        bytes32 _cdpId,\n        address _borrower,\n        uint256 _debt,\n        uint256 _coll\n    ) external override {\n        _requireCallerIsBorrowerOperations();\n        emit CdpUpdated(_cdpId, _borrower, msg.sender, _debt, _coll, 0, 0, 0, CdpOperation.closeCdp);\n        return _closeCdp(_cdpId, Status.closedByOwner);\n    }\n\n    // Push the owner's address to the Cdp owners list, and record the corresponding array index on the Cdp struct\n    function _addCdpIdToArray(bytes32 _cdpId) internal returns (uint128 index) {\n        /* Max array size is 2**128 - 1, i.e. ~3e30 cdps. No risk of overflow, since cdps have minimum EBTC\n        debt of liquidation reserve plus MIN_NET_DEBT.\n        3e30 EBTC dwarfs the value of all wealth in the world ( which is < 1e15 USD). */\n\n        // Push the Cdpowner to the array\n        CdpIds.push(_cdpId);\n\n        // Record the index of the new Cdpowner on their Cdp struct\n        index = uint128(CdpIds.length - 1);\n        Cdps[_cdpId].arrayIndex = index;\n\n        return index;\n    }\n\n    // --- Recovery Mode and TCR functions ---\n\n    /// @notice Get the sum of debt units assigned to all Cdps within eBTC system\n    /// @dev It is actually the `systemDebt` value of the ActivePool.\n    /// @return entireSystemDebt entire system debt accounting value\n    function getSystemDebt() public view returns (uint256 entireSystemDebt) {\n        return _getSystemDebt();\n    }\n\n    /// @notice The total collateralization ratio (TCR) of the system as a cached \"view\" (maybe outdated)\n    /// @dev It is based on the current recorded system debt and collateral.\n    /// @dev Possible split fee is not considered with this function.\n    /// @dev Please use getSyncedTCR() otherwise\n    /// @param _price The current stETH:BTC price\n    /// @return TCR The cached total collateralization ratio (TCR) of the system (does not take into account pending global state)\n    function getCachedTCR(uint256 _price) external view override returns (uint256) {\n        return _getCachedTCR(_price);\n    }\n\n    /// @notice Whether or not the system is in Recovery Mode (TCR is below the CCR)\n    /// @dev Possible split fee is not considered with this function.\n    /// @dev Please use getSyncedTCR() otherwise\n    /// @param _price The current stETH:BTC price\n    /// @return True if system is in recovery mode with cached values (TCR < CCR), false otherwise\n    function checkRecoveryMode(uint256 _price) external view override returns (bool) {\n        return _checkRecoveryMode(_price);\n    }\n\n    // Check whether or not the system *would be* in Recovery Mode,\n    // given an ETH:USD price, and the entire system coll and debt.\n    function _checkPotentialRecoveryMode(\n        uint256 _systemCollShares,\n        uint256 _systemDebt,\n        uint256 _price\n    ) internal view returns (bool) {\n        uint256 TCR = _computeTCRWithGivenSystemValues(_systemCollShares, _systemDebt, _price);\n        return TCR < CCR;\n    }\n\n    // --- Redemption fee functions ---\n\n    /*\n     * This function has two impacts on the baseRate state variable:\n     * 1) decays the baseRate based on time passed since last redemption or EBTC borrowing operation.\n     * then,\n     * 2) increases the baseRate based on the amount redeemed, as a proportion of total supply\n     */\n    function _updateBaseRateFromRedemption(\n        uint256 _ETHDrawn,\n        uint256 _price,\n        uint256 _totalEBTCSupply\n    ) internal returns (uint256) {\n        uint256 decayedBaseRate = _calcDecayedBaseRate();\n\n        /* Convert the drawn ETH back to EBTC at face value rate (1 EBTC:1 USD), in order to get\n         * the fraction of total supply that was redeemed at face value. */\n        uint256 redeemedEBTCFraction = (collateral.getPooledEthByShares(_ETHDrawn) * _price) /\n            _totalEBTCSupply;\n\n        uint256 newBaseRate = decayedBaseRate + (redeemedEBTCFraction / beta);\n        newBaseRate = EbtcMath._min(newBaseRate, DECIMAL_PRECISION); // cap baseRate at a maximum of 100%\n        require(newBaseRate > 0, \"CdpManager: new baseRate is zero!\"); // Base rate is always non-zero after redemption\n\n        // Update the baseRate state variable\n        baseRate = newBaseRate;\n        emit BaseRateUpdated(newBaseRate);\n\n        _updateLastRedemptionTimestamp();\n\n        return newBaseRate;\n    }\n\n    /// @return current fee rate for redemption with base rate\n    function getRedemptionRate() public view override returns (uint256) {\n        return _calcRedemptionRate(baseRate);\n    }\n\n    /// @return current fee rate for redemption with decayed base rate\n    function getRedemptionRateWithDecay() public view override returns (uint256) {\n        return _calcRedemptionRate(_calcDecayedBaseRate());\n    }\n\n    function _calcRedemptionRate(uint256 _baseRate) internal view returns (uint256) {\n        return\n            EbtcMath._min(\n                redemptionFeeFloor + _baseRate,\n                DECIMAL_PRECISION // cap at a maximum of 100%\n            );\n    }\n\n    function _getRedemptionFee(uint256 _ETHDrawn) internal view returns (uint256) {\n        return _calcRedemptionFee(getRedemptionRate(), _ETHDrawn);\n    }\n\n    /// @return redemption fee for the specified collateral amount\n    /// @param _stETHToRedeem The total expected stETH amount to redeem\n    function getRedemptionFeeWithDecay(\n        uint256 _stETHToRedeem\n    ) external view override returns (uint256) {\n        return _calcRedemptionFee(getRedemptionRateWithDecay(), _stETHToRedeem);\n    }\n\n    function _calcRedemptionFee(\n        uint256 _redemptionRate,\n        uint256 _ETHDrawn\n    ) internal pure returns (uint256) {\n        uint256 redemptionFee = (_redemptionRate * _ETHDrawn) / DECIMAL_PRECISION;\n        require(redemptionFee < _ETHDrawn, \"CdpManager: Fee would eat up all returned collateral\");\n        return redemptionFee;\n    }\n\n    function _decayBaseRate() internal {\n        uint256 decayedBaseRate = _calcDecayedBaseRate();\n        require(decayedBaseRate <= DECIMAL_PRECISION, \"CdpManager: baseRate too large!\"); // The baseRate can decay to 0\n\n        baseRate = decayedBaseRate;\n        emit BaseRateUpdated(decayedBaseRate);\n\n        _updateLastRedemptionTimestamp();\n    }\n\n    // --- Internal fee functions ---\n\n    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.\n    function _updateLastRedemptionTimestamp() internal {\n        uint256 timePassed = block.timestamp > lastRedemptionTimestamp\n            ? block.timestamp - lastRedemptionTimestamp\n            : 0;\n\n        if (timePassed >= SECONDS_IN_ONE_MINUTE) {\n            // Using the effective elapsed time that is consumed so far to update lastRedemptionTimestamp\n            // instead block.timestamp for consistency with _calcDecayedBaseRate()\n            lastRedemptionTimestamp += _minutesPassedSinceLastRedemption() * SECONDS_IN_ONE_MINUTE;\n            emit LastRedemptionTimestampUpdated(block.timestamp);\n        }\n    }\n\n    function _calcDecayedBaseRate() internal view returns (uint256) {\n        uint256 minutesPassed = _minutesPassedSinceLastRedemption();\n        uint256 decayFactor = EbtcMath._decPow(minuteDecayFactor, minutesPassed);\n\n        return (baseRate * decayFactor) / DECIMAL_PRECIS"
    }
  ]
}