{
  "Title": "Unrestricted Execution with _swap Function",
  "Content": "The `_swap` function is designed to allow users to exchange collateral removed from a Comet market, ensuring there are enough assets to repay the flash loan. However, the swap process, executed on [line 85](https://github.com/widolabs/wido-contracts/blob/d96ef2dd6a7ff3d04c44ebe87994411d1f8c84e7/contracts/compound/libraries/LibCollateralSwap.sol#L85) of `LibCollateralSwap.sol`, heavily relies on user inputs. This dependence creates a vulnerability, where an attacker might inject malicious inputs into the contract, thereby potentially initiating unrestricted calls to any other smart contract within the blockchain. Combined with other issues found (see C01, H01, M02, and L03) this leads to scenarios where calling users can have all of their Comet positions stolen.\n\n\nBelow is an illustration of this attack, demonstrating how an attacker can exploit the signatures provided by any user, along with the contract's manager-level access over the user's Comet funds, to steal the user's collateral:\n\n\n* Alice holds a debt position in Comet and she wishes to exchange a portion of her collateral for a new one\n* An attacker sees Alice's public transaction and her signatures, and makes a new transaction. They keep Alice's signatures and pass in a malicious contract's address as the Comet address to gain control whenever Comet is called from the protocol\n* The attacker front-runs Alice's transaction\n* The attacker takes a flash loan for the contract, triggering [`executeOperation`](https://github.com/widolabs/wido-contracts/blob/d96ef2dd6a7ff3d04c44ebe87994411d1f8c84e7/contracts/compound/WidoCollateralSwap_Aave.sol#L68)\n* The attacker gains control on [line 121](https://github.com/widolabs/wido-contracts/blob/d96ef2dd6a7ff3d04c44ebe87994411d1f8c84e7/contracts/compound/libraries/LibCollateralSwap.sol#L121) of `LibCollateralSwap.sol`, where the contract has manager access over the user's Comet funds\n* Attacker re-enters the collateral swap function, this time aiming for [line 85](https://github.com/widolabs/wido-contracts/blob/d96ef2dd6a7ff3d04c44ebe87994411d1f8c84e7/contracts/compound/libraries/LibCollateralSwap.sol#L85) of `LibCollateralSwap.sol` providing malicious inputs to steal all of Alice's unlocked funds. They specify an official Comet address as `swap.router` and `transferAssetFrom(address,address,address,uint256)` as `swap.callData` to steal the user's unlocked collateral.\n\n\nAs a side note, the attacker can go further and unlock all of the user's Comet collateral with a flash loan before the whole process, to effectively steal all of their collateral, close the debt position and come out with a profit since the position is over-collateralized.\n\n\nConsider sanitizing the swap input to ensure users are calling the correct swap contract. Also, you can utilize [OpenZeppelin's reenterancy guard](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/2472e51e80e581a90370cfd59d6bba6a12bfdf52/contracts/utils/ReentrancyGuard.sol) to ensure the flow is executed once at a time.\n\n\n***Update**: Resolved in [pull request #38](https://github.com/widolabs/wido-contracts/pull/38/files) at commit [e093542](https://github.com/widolabs/wido-contracts/tree/e093542385a1fc21803a5ada683a7adb2f6548af).*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/compound/libraries/LibCollateralSwap.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.7;\n\nimport {IERC20} from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IComet} from \"../interfaces/IComet.sol\";\n\nlibrary LibCollateralSwap {\n    using SafeMath for uint256;\n\n    error WidoRouterFailed();\n\n    struct Collateral {\n        address addr;\n        uint256 amount;\n    }\n\n    struct Signatures {\n        Signature allow;\n        Signature revoke;\n    }\n\n    struct Signature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    struct WidoSwap {\n        address router;\n        address tokenManager;\n        bytes callData;\n    }\n\n    /// @dev Performs all the steps to swap collaterals on the Comet contract\n    function performCollateralSwap(\n        address borrowedAsset,\n        uint256 borrowedAmount,\n        uint256 fee,\n        bytes memory data\n    ) external {\n        // decode payload\n        (\n        address user,\n        IComet comet,\n        Collateral memory existingCollateral,\n        Signatures memory signatures,\n        WidoSwap memory swapDetails\n        ) = abi.decode(\n            data,\n            (address, IComet, Collateral, Signatures, WidoSwap)\n        );\n\n        // supply new collateral on behalf of user\n        _supplyTo(comet, user, borrowedAsset, borrowedAmount.sub(fee));\n\n        // withdraw existing collateral\n        _withdrawFrom(comet, user, existingCollateral, signatures);\n\n        // execute swap\n        _swap(existingCollateral, swapDetails);\n\n        // check amount of surplus collateral\n        uint256 surplusAmount = IERC20(borrowedAsset).balanceOf(address(this)) - borrowedAmount - fee;\n\n        // if positive slippage, supply extra to user\n        if (surplusAmount > 0) {\n            _supplyTo(comet, user, borrowedAsset, surplusAmount);\n        }\n    }\n\n    /// @dev Performs the swap of the collateral on the WidoRouter\n    function _swap(\n        Collateral memory collateral,\n        WidoSwap memory swap\n    ) internal {\n        // approve WidoTokenManager initial collateral to make the swap\n        IERC20(collateral.addr).approve(\n            swap.tokenManager,\n            collateral.amount\n        );\n\n        // execute swap\n        (bool success, bytes memory result) = swap.router.call(swap.callData);\n\n        if (!success) {\n            if (result.length < 68) revert WidoRouterFailed();\n            assembly {\n                result := add(result, 0x04)\n            }\n            revert(abi.decode(result, (string)));\n        }\n    }\n\n    /// @dev Supplies collateral on behalf of user\n    function _supplyTo(\n        IComet comet,\n        address user,\n        address asset,\n        uint256 amount\n    ) internal {\n        IERC20(asset).approve(address(comet), amount);\n        comet.supplyTo(user, asset, amount);\n    }\n\n    /// @dev This function withdraws the collateral from the user.\n    ///  It requires two consecutive EIP712 signatures to allow and revoke\n    ///  permissions to and from this contract.\n    function _withdrawFrom(\n        IComet comet,\n        address user,\n        Collateral memory collateral,\n        Signatures memory sigs\n    ) internal {\n        // get current nonce\n        uint256 nonce = comet.userNonce(user);\n        // allow the contract\n        _allowBySig(comet, user, true, nonce, sigs.allow);\n        // withdraw assets\n        comet.withdrawFrom(user, address(this), collateral.addr, collateral.amount);\n        // increment nonce\n        unchecked { nonce++; }\n        // revoke permission\n        _allowBySig(comet, user, false, nonce, sigs.revoke);\n    }\n\n    /// @dev Executes a single `allowBySig` operation on the Comet contract\n    function _allowBySig(\n        IComet comet,\n        address user,\n        bool allowed,\n        uint256 nonce,\n        Signature memory sig\n    ) internal {\n        comet.allowBySig(\n            user,\n            address(this),\n            allowed,\n            nonce,\n            10e9,\n            sig.v,\n            sig.r,\n            sig.s\n        );\n    }\n\n}"
    },
    {
      "filename": "contracts/compound/WidoCollateralSwap_Aave.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.7;\n\nimport {IERC20} from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IPoolAddressesProvider} from \"aave-v3-core/contracts/interfaces/IPoolAddressesProvider.sol\";\nimport {IFlashLoanSimpleReceiver} from \"aave-v3-core/contracts/flashloan/interfaces/IFlashLoanSimpleReceiver.sol\";\nimport {IPool} from \"aave-v3-core/contracts/interfaces/IPool.sol\";\nimport {IComet} from \"./interfaces/IComet.sol\";\nimport {LibCollateralSwap} from \"./libraries/LibCollateralSwap.sol\";\nimport {IWidoCollateralSwap} from \"./interfaces/IWidoCollateralSwap.sol\";\n\ncontract WidoCollateralSwap_Aave is IFlashLoanSimpleReceiver, IWidoCollateralSwap {\n    using SafeMath for uint256;\n\n    /// @dev Aave addresses provider contract\n    IPoolAddressesProvider public immutable override ADDRESSES_PROVIDER;\n\n    /// @dev Aave Pool contract\n    IPool public immutable override POOL;\n\n    error InvalidProvider();\n\n    constructor(IPoolAddressesProvider _addressProvider) {\n        ADDRESSES_PROVIDER = _addressProvider;\n        POOL = IPool(_addressProvider.getPool());\n    }\n\n    /// @notice Performs a collateral swap with Aave\n    /// @param existingCollateral The collateral currently locked in the Comet contract\n    /// @param finalCollateral The final collateral desired collateral\n    /// @param sigs The required signatures to allow and revoke permission to this contract\n    /// @param swap The necessary data to swap one collateral for the other\n    /// @param comet The address of the Comet contract to interact with\n    function swapCollateral(\n        LibCollateralSwap.Collateral calldata existingCollateral,\n        LibCollateralSwap.Collateral calldata finalCollateral,\n        LibCollateralSwap.Signatures calldata sigs,\n        LibCollateralSwap.WidoSwap calldata swap,\n        address comet\n    ) external override {\n        bytes memory data = abi.encode(\n            msg.sender,\n            comet,\n            existingCollateral,\n            sigs,\n            swap\n        );\n\n        POOL.flashLoanSimple(\n            address(this),\n            finalCollateral.addr,\n            finalCollateral.amount,\n            data,\n            0\n        );\n    }\n\n    /// @notice Executes an operation after receiving the flash-borrowed asset\n    /// @dev Ensure that the contract can return the debt + premium, e.g., has\n    ///      enough funds to repay and has approved the Pool to pull the total amount\n    /// @param asset The address of the flash-borrowed asset\n    /// @param amount The amount of the flash-borrowed asset\n    /// @param premium The fee of the flash-borrowed asset\n    /// @param params The byte-encoded params passed when initiating the flashloan\n    /// @return True if the execution of the operation succeeds, false otherwise\n    function executeOperation(\n        address asset,\n        uint256 amount,\n        uint256 premium,\n        address /*initiator*/,\n        bytes calldata params\n    ) external override returns (bool) {\n        if (msg.sender != address(POOL)) {\n            revert InvalidProvider();\n        }\n\n        LibCollateralSwap.performCollateralSwap(asset, amount, premium, params);\n\n        // approve loan provider to pull lent amount + fee\n        IERC20(asset).approve(\n            address(POOL),\n            amount.add(premium)\n        );\n\n        return true;\n    }\n}"
    },
    {
      "filename": "contracts/compound/libraries/LibCollateralSwap.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.7;\n\nimport {IERC20} from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IComet} from \"../interfaces/IComet.sol\";\n\nlibrary LibCollateralSwap {\n    using SafeMath for uint256;\n\n    error WidoRouterFailed();\n\n    struct Collateral {\n        address addr;\n        uint256 amount;\n    }\n\n    struct Signatures {\n        Signature allow;\n        Signature revoke;\n    }\n\n    struct Signature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    struct WidoSwap {\n        address router;\n        address tokenManager;\n        bytes callData;\n    }\n\n    /// @dev Performs all the steps to swap collaterals on the Comet contract\n    function performCollateralSwap(\n        address borrowedAsset,\n        uint256 borrowedAmount,\n        uint256 fee,\n        bytes memory data\n    ) external {\n        // decode payload\n        (\n        address user,\n        IComet comet,\n        Collateral memory existingCollateral,\n        Signatures memory signatures,\n        WidoSwap memory swapDetails\n        ) = abi.decode(\n            data,\n            (address, IComet, Collateral, Signatures, WidoSwap)\n        );\n\n        // supply new collateral on behalf of user\n        _supplyTo(comet, user, borrowedAsset, borrowedAmount.sub(fee));\n\n        // withdraw existing collateral\n        _withdrawFrom(comet, user, existingCollateral, signatures);\n\n        // execute swap\n        _swap(existingCollateral, swapDetails);\n\n        // check amount of surplus collateral\n        uint256 surplusAmount = IERC20(borrowedAsset).balanceOf(address(this)) - borrowedAmount - fee;\n\n        // if positive slippage, supply extra to user\n        if (surplusAmount > 0) {\n            _supplyTo(comet, user, borrowedAsset, surplusAmount);\n        }\n    }\n\n    /// @dev Performs the swap of the collateral on the WidoRouter\n    function _swap(\n        Collateral memory collateral,\n        WidoSwap memory swap\n    ) internal {\n        // approve WidoTokenManager initial collateral to make the swap\n        IERC20(collateral.addr).approve(\n            swap.tokenManager,\n            collateral.amount\n        );\n\n        // execute swap\n        (bool success, bytes memory result) = swap.router.call(swap.callData);\n\n        if (!success) {\n            if (result.length < 68) revert WidoRouterFailed();\n            assembly {\n                result := add(result, 0x04)\n            }\n            revert(abi.decode(result, (string)));\n        }\n    }\n\n    /// @dev Supplies collateral on behalf of user\n    function _supplyTo(\n        IComet comet,\n        address user,\n        address asset,\n        uint256 amount\n    ) internal {\n        IERC20(asset).approve(address(comet), amount);\n        comet.supplyTo(user, asset, amount);\n    }\n\n    /// @dev This function withdraws the collateral from the user.\n    ///  It requires two consecutive EIP712 signatures to allow and revoke\n    ///  permissions to and from this contract.\n    function _withdrawFrom(\n        IComet comet,\n        address user,\n        Collateral memory collateral,\n        Signatures memory sigs\n    ) internal {\n        // get current nonce\n        uint256 nonce = comet.userNonce(user);\n        // allow the contract\n        _allowBySig(comet, user, true, nonce, sigs.allow);\n        // withdraw assets\n        comet.withdrawFrom(user, address(this), collateral.addr, collateral.amount);\n        // increment nonce\n        unchecked { nonce++; }\n        // revoke permission\n        _allowBySig(comet, user, false, nonce, sigs.revoke);\n    }\n\n    /// @dev Executes a single `allowBySig` operation on the Comet contract\n    function _allowBySig(\n        IComet comet,\n        address user,\n        bool allowed,\n        uint256 nonce,\n        Signature memory sig\n    ) internal {\n        comet.allowBySig(\n            user,\n            address(this),\n            allowed,\n            nonce,\n            10e9,\n            sig.v,\n            sig.r,\n            sig.s\n        );\n    }\n\n}"
    },
    {
      "filename": "contracts/compound/libraries/LibCollateralSwap.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.7;\n\nimport {IERC20} from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IComet} from \"../interfaces/IComet.sol\";\n\nlibrary LibCollateralSwap {\n    using SafeMath for uint256;\n\n    error WidoRouterFailed();\n\n    struct Collateral {\n        address addr;\n        uint256 amount;\n    }\n\n    struct Signatures {\n        Signature allow;\n        Signature revoke;\n    }\n\n    struct Signature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    struct WidoSwap {\n        address router;\n        address tokenManager;\n        bytes callData;\n    }\n\n    /// @dev Performs all the steps to swap collaterals on the Comet contract\n    function performCollateralSwap(\n        address borrowedAsset,\n        uint256 borrowedAmount,\n        uint256 fee,\n        bytes memory data\n    ) external {\n        // decode payload\n        (\n        address user,\n        IComet comet,\n        Collateral memory existingCollateral,\n        Signatures memory signatures,\n        WidoSwap memory swapDetails\n        ) = abi.decode(\n            data,\n            (address, IComet, Collateral, Signatures, WidoSwap)\n        );\n\n        // supply new collateral on behalf of user\n        _supplyTo(comet, user, borrowedAsset, borrowedAmount.sub(fee));\n\n        // withdraw existing collateral\n        _withdrawFrom(comet, user, existingCollateral, signatures);\n\n        // execute swap\n        _swap(existingCollateral, swapDetails);\n\n        // check amount of surplus collateral\n        uint256 surplusAmount = IERC20(borrowedAsset).balanceOf(address(this)) - borrowedAmount - fee;\n\n        // if positive slippage, supply extra to user\n        if (surplusAmount > 0) {\n            _supplyTo(comet, user, borrowedAsset, surplusAmount);\n        }\n    }\n\n    /// @dev Performs the swap of the collateral on the WidoRouter\n    function _swap(\n        Collateral memory collateral,\n        WidoSwap memory swap\n    ) internal {\n        // approve WidoTokenManager initial collateral to make the swap\n        IERC20(collateral.addr).approve(\n            swap.tokenManager,\n            collateral.amount\n        );\n\n        // execute swap\n        (bool success, bytes memory result) = swap.router.call(swap.callData);\n\n        if (!success) {\n            if (result.length < 68) revert WidoRouterFailed();\n            assembly {\n                result := add(result, 0x04)\n            }\n            revert(abi.decode(result, (string)));\n        }\n    }\n\n    /// @dev Supplies collateral on behalf of user\n    function _supplyTo(\n        IComet comet,\n        address user,\n        address asset,\n        uint256 amount\n    ) internal {\n        IERC20(asset).approve(address(comet), amount);\n        comet.supplyTo(user, asset, amount);\n    }\n\n    /// @dev This function withdraws the collateral from the user.\n    ///  It requires two consecutive EIP712 signatures to allow and revoke\n    ///  permissions to and from this contract.\n    function _withdrawFrom(\n        IComet comet,\n        address user,\n        Collateral memory collateral,\n        Signatures memory sigs\n    ) internal {\n        // get current nonce\n        uint256 nonce = comet.userNonce(user);\n        // allow the contract\n        _allowBySig(comet, user, true, nonce, sigs.allow);\n        // withdraw assets\n        comet.withdrawFrom(user, address(this), collateral.addr, collateral.amount);\n        // increment nonce\n        unchecked { nonce++; }\n        // revoke permission\n        _allowBySig(comet, user, false, nonce, sigs.revoke);\n    }\n\n    /// @dev Executes a single `allowBySig` operation on the Comet contract\n    function _allowBySig(\n        IComet comet,\n        address user,\n        bool allowed,\n        uint256 nonce,\n        Signature memory sig\n    ) internal {\n        comet.allowBySig(\n            user,\n            address(this),\n            allowed,\n            nonce,\n            10e9,\n            sig.v,\n            sig.r,\n            sig.s\n        );\n    }\n\n}"
    }
  ]
}