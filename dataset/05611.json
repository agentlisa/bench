{
  "Title": "[M-06] `create2WithStoredInitCode()` does not revert if contract deployment failed",
  "Content": "\nIn `LibStoredInitCode.sol`, the `create2WithStoredInitCode()` function, which is used to deploy contracts with the `CREATE2` opcode, is as shown:\n\n[LibStoredInitCode.sol#L106-L117](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/libraries/LibStoredInitCode.sol#L106-L117)\n\n```solidity\n  function create2WithStoredInitCode(\n    address initCodeStorage,\n    bytes32 salt,\n    uint256 value\n  ) internal returns (address deployment) {\n    assembly {\n      let initCodePointer := mload(0x40)\n      let initCodeSize := sub(extcodesize(initCodeStorage), 1)\n      extcodecopy(initCodeStorage, initCodePointer, 1, initCodeSize)\n      deployment := create2(value, initCodePointer, initCodeSize, salt)\n    }\n  }\n```\n\nThe `create2` opcode returns `address(0)` if contract deployment reverted. However, as seen from above,  `create2WithStoredInitCode()` does not check if the `deployment` address is `address(0)`.\n\nThis is an issue as `deployMarket()` will not revert when deployment of the `WildcatMarket` contract fails:\n\n[WildcatMarketController.sol#L354-L357](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/WildcatMarketController.sol#L354-L357)\n\n```solidity\n    LibStoredInitCode.create2WithStoredInitCode(marketInitCodeStorage, salt);\n\n    archController.registerMarket(market);\n    _controlledMarkets.add(market);\n```\n\nTherefore, if the origination fee is enabled for the protocol, users that call `deployMarket()` will pay the origination fee even if the market was not deployed.\n\nAdditionally, the `market` address will be registered in the `WildcatArchController` contract and added to `_addControlledMarkets`. This will cause both sets to become inaccurate if deployment failed as `market` would be an address that has no code.\n\nThis also leads to more problems if a user attempts to call `deployMarket()` with the same `asset`, `namePrefix` and `symbolPrefix`. Since the `market` address has already been registered, `registerMarket()` will revert when called for a second time:\n\n[WildcatArchController.sol#L192-L195](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/WildcatArchController.sol#L192-L195)\n\n```solidity\n  function registerMarket(address market) external onlyController {\n    if (!_markets.add(market)) {\n      revert MarketAlreadyExists();\n    }\n```\n\nAs such, if a user calls `deployMarket()` and market deployment fails, they cannot call `deployMarket()` with the same set of parameters ever again.\n\nNote that it is possible for market deployment to fail, as seen in the constructor of `WildcatMarketBase`:\n\n[WildcatMarketBase.sol#L79-L99](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/market/WildcatMarketBase.sol#L79-L99)\n\n```solidity\n    if ((parameters.protocolFeeBips > 0).and(parameters.feeRecipient == address(0))) {\n      revert FeeSetWithoutRecipient();\n    }\n    if (parameters.annualInterestBips > BIP) {\n      revert InterestRateTooHigh();\n    }\n    if (parameters.reserveRatioBips > BIP) {\n      revert ReserveRatioBipsTooHigh();\n    }\n    if (parameters.protocolFeeBips > BIP) {\n      revert InterestFeeTooHigh();\n    }\n    if (parameters.delinquencyFeeBips > BIP) {\n      revert PenaltyFeeTooHigh();\n    }\n\n    // Set asset metadata\n    asset = parameters.asset;\n    name = string.concat(parameters.namePrefix, queryName(parameters.asset));\n    symbol = string.concat(parameters.symbolPrefix, querySymbol(parameters.asset));\n    decimals = IERC20Metadata(parameters.asset).decimals();\n```\n\nFor example, the protocol could have configured `protocolFeeBips` or `feeRecipient` incorrectly. Alternatively, `asset` could be an invalid address, or an ERC20 token that does not have the `name()`, `symbol()` or `decimal()` function.\n\n### Impact\n\nSince `deployMarket()` does not revert when creation of the `WildcatMarket` contract fails, users will pay the origination fee for failed deployments, causing a loss of funds.\n\nAdditionally, `deployMarket()` will not be callable for the same `asset`, `namePrefix` and `symbolPrefix`, thus a user can never deploy a market with these parameters.\n\n### Proof of Concept\n\nThe following test demonstrates how `deployMarket()` does not revert even if deployment of the `WildcatMarket` contract failed, and how it reverts when attempting to deploy the same market with valid parameters afterward:\n\n<details>\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport 'src/WildcatArchController.sol';\nimport 'src/WildcatMarketControllerFactory.sol';\n\nimport 'forge-std/Test.sol';\nimport 'test/shared/TestConstants.sol';\nimport 'test/helpers/MockERC20.sol';\n\ncontract MarketDeploymentRevertTest is Test {\n    // Wildcat contracts\n    WildcatArchController archController;\n    WildcatMarketControllerFactory controllerFactory;\n    WildcatMarketController controller;\n    \n    // Test contracts\n    MockERC20 originationFeeAsset = new MockERC20();\n    MockERC20 marketAsset = new MockERC20();\n\n    // Users\n    address BORROWER;\n\n    function setUp() external {\n        // Deploy Wildcat contracts\n        archController = new WildcatArchController();\n        MarketParameterConstraints memory constraints = MarketParameterConstraints({\n            minimumDelinquencyGracePeriod: MinimumDelinquencyGracePeriod,\n            maximumDelinquencyGracePeriod: MaximumDelinquencyGracePeriod,\n            minimumReserveRatioBips: MinimumReserveRatioBips,\n            maximumReserveRatioBips: MaximumReserveRatioBips,\n            minimumDelinquencyFeeBips: MinimumDelinquencyFeeBips,\n            maximumDelinquencyFeeBips: MaximumDelinquencyFeeBips,\n            minimumWithdrawalBatchDuration: MinimumWithdrawalBatchDuration,\n            maximumWithdrawalBatchDuration: MaximumWithdrawalBatchDuration,\n            minimumAnnualInterestBips: MinimumAnnualInterestBips,\n            maximumAnnualInterestBips: MaximumAnnualInterestBips\n        });\n        controllerFactory = new WildcatMarketControllerFactory(\n            address(archController),\n            address(0),\n            constraints\n        );\n\n        // Register controllerFactory in archController\n        archController.registerControllerFactory(address(controllerFactory));\n\n        // Setup borrower\n        BORROWER = makeAddr(\"BORROWER\");\n        originationFeeAsset.mint(BORROWER, 10e18);\n        archController.registerBorrower(BORROWER);\n\n        // Deploy controller\n        vm.prank(BORROWER);\n        controller = WildcatMarketController(controllerFactory.deployController());\n    }\n\n    function test_marketDeploymentDoesntRevert() public {\n        // Set protocol fee to larger than BIP\n        controllerFactory.setProtocolFeeConfiguration(\n            address(1),\n            address(originationFeeAsset),\n            5e18, // originationFeeAmount,\n            1e4 + 1 // protocolFeeBips\n        );\n\n        string memory namePrefix = \"Market \";\n        string memory symbolPrefix = \"MKT-\";\n\n        // deployMarket() does not revert\n        vm.startPrank(BORROWER);\n        originationFeeAsset.approve(address(controller), 5e18);\n        address market = controller.deployMarket(\n            address(marketAsset),\n            namePrefix,\n            symbolPrefix,\n            type(uint128).max,\n            MaximumAnnualInterestBips,\n            MaximumDelinquencyFeeBips,\n            MaximumWithdrawalBatchDuration,\n            MaximumReserveRatioBips,\n            MaximumDelinquencyGracePeriod\n        );\n        vm.stopPrank();\n\n        // However, the market was never deployed and borrower paid the origination fee\n        assertEq(market.code.length, 0);\n        assertEq(originationFeeAsset.balanceOf(BORROWER), 5e18);\n\n        // Set protocol fee to valid value\n        controllerFactory.setProtocolFeeConfiguration(\n            address(1),\n            address(originationFeeAsset),\n            5e18, // originationFeeAmount,\n            0 // protocolFeeBips\n        );\n\n        // Call deployMarket() with valid parameters reverts as market address is already registered\n        vm.startPrank(BORROWER);\n        originationFeeAsset.approve(address(controller), 5e18);\n        vm.expectRevert(WildcatArchController.MarketAlreadyExists.selector);\n        market = controller.deployMarket(\n            address(marketAsset),\n            namePrefix,\n            symbolPrefix,\n            type(uint128).max,\n            MaximumAnnualInterestBips,\n            MaximumDelinquencyFeeBips,\n            MaximumWithdrawalBatchDuration,\n            MaximumReserveRatioBips,\n            MaximumDelinquencyGracePeriod\n        );\n        vm.stopPrank();\n    }\n}\n```\n\n</details>\n\n### Recommended Mitigation\n\nIn `create2WithStoredInitCode()`, consider checking if the `deployment` address is `address(0)`, and reverting if so:\n\n[LibStoredInitCode.sol#L106-L117](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/libraries/LibStoredInitCode.sol#L106-L117)\n\n```diff\n  function create2WithStoredInitCode(\n    address initCodeStorage,\n    bytes32 salt,\n    uint256 value\n  ) internal returns (address deployment) {\n    assembly {\n      let initCodePointer := mload(0x40)\n      let initCodeSize := sub(extcodesize(initCodeStorage), 1)\n      extcodecopy(initCodeStorage, initCodePointer, 1, initCodeSize)\n      deployment := create2(value, initCodePointer, initCodeSize, salt)\n+     if iszero(deployment) {\n+         mstore(0x00, 0x30116425) // DeploymentFailed()\n+         revert(0x1c, 0x04)\n+     }\n    }\n  }\n```\n\n### Assessed type\n\nLibrary\n\n**[laurenceday (Wildcat) commented](https://github.com/code-423n4/2023-10-wildcat-findings/issues/499#issuecomment-1803389819):**\n > Mitigated [here](https://github.com/wildcat-finance/wildcat-protocol/commit/e93bcd9625e3e51d4689fdb0d45c58e7d57929d7).\n\n**[laurenceday (Wildcat) confirmed](https://github.com/code-423n4/2023-10-wildcat-findings/issues/499#issuecomment-1810766041)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-wildcat",
  "Code": [
    {
      "filename": "src/libraries/LibStoredInitCode.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nlibrary LibStoredInitCode {\n  error InitCodeDeploymentFailed();\n\n  function deployInitCode(bytes memory data) internal returns (address initCodeStorage) {\n    assembly {\n      let size := mload(data)\n      let createSize := add(size, 0x0b)\n      // Prefix Code\n      //\n      // Has trailing STOP instruction so the deployed data\n      // can not be executed as a smart contract.\n      //\n      // Instruction                | Stack\n      // ----------------------------------------------------\n      // PUSH2 size                 | size                  |\n      // PUSH0                      | 0, size               |\n      // DUP2                       | size, 0, size         |\n      // PUSH1 10 (offset to STOP)  | 10, size, 0, size     |\n      // PUSH0                      | 0, 10, size, 0, size  |\n      // CODECOPY                   | 0, size               |\n      // RETURN                     |                       |\n      // STOP                       |                       |\n      // ----------------------------------------------------\n\n      // Shift (size + 1) to position it in front of the PUSH2 instruction.\n      // Reuse `data.length` memory for the create prefix to avoid\n      // unnecessary memory allocation.\n      mstore(data, or(shl(64, add(size, 1)), 0x6100005f81600a5f39f300))\n      // Deploy the code storage\n      initCodeStorage := create(0, add(data, 21), createSize)\n      // if (initCodeStorage == address(0)) revert InitCodeDeploymentFailed();\n      if iszero(initCodeStorage) {\n        mstore(0, 0x11c8c3c0)\n        revert(0x1c, 0x04)\n      }\n      // Restore `data.length`\n      mstore(data, size)\n    }\n  }\n\n  /**\n   * @dev Returns the create2 prefix for a given deployer address.\n   *      Equivalent to `uint256(uint160(deployer)) | (0xff << 160)`\n   */\n  function getCreate2Prefix(address deployer) internal pure returns (uint256 create2Prefix) {\n    assembly {\n      create2Prefix := or(deployer, 0xff0000000000000000000000000000000000000000)\n    }\n  }\n\n  function calculateCreate2Address(\n    uint256 create2Prefix,\n    bytes32 salt,\n    uint256 initCodeHash\n  ) internal pure returns (address create2Address) {\n    assembly {\n      // Cache the free memory pointer so it can be restored\n      // at the end\n      let ptr := mload(0x40)\n\n      // Write 0xff + address to bytes 11:32\n      mstore(0x00, create2Prefix)\n\n      // Write salt to bytes 32:64\n      mstore(0x20, salt)\n\n      // Write initcode hash to bytes 64:96\n      mstore(0x40, initCodeHash)\n\n      // Calculate create2 hash for token0, token1\n      // The EVM only looks at the last 20 bytes, so the dirty\n      // bits at the beginning do not need to be cleaned\n      create2Address := keccak256(0x0b, 0x55)\n\n      // Restore the free memory pointer\n      mstore(0x40, ptr)\n    }\n  }\n\n  function createWithStoredInitCode(address initCodeStorage) internal returns (address deployment) {\n    deployment = createWithStoredInitCode(initCodeStorage, 0);\n  }\n\n  function createWithStoredInitCode(\n    address initCodeStorage,\n    uint256 value\n  ) internal returns (address deployment) {\n    assembly {\n      let initCodePointer := mload(0x40)\n      let initCodeSize := sub(extcodesize(initCodeStorage), 1)\n      extcodecopy(initCodeStorage, initCodePointer, 1, initCodeSize)\n      deployment := create(value, initCodePointer, initCodeSize)\n    }\n  }\n\n  function create2WithStoredInitCode(\n    address initCodeStorage,\n    bytes32 salt\n  ) internal returns (address deployment) {\n    deployment = create2WithStoredInitCode(initCodeStorage, salt, 0);\n  }\n\n  function create2WithStoredInitCode(\n    address initCodeStorage,\n    bytes32 salt,\n    uint256 value\n  ) internal returns (address deployment) {\n    assembly {\n      let initCodePointer := mload(0x40)\n      let initCodeSize := sub(extcodesize(initCodeStorage), 1)\n      extcodecopy(initCodeStorage, initCodePointer, 1, initCodeSize)\n      deployment := create2(value, initCodePointer, initCodeSize, salt)\n    }\n  }\n}"
    },
    {
      "filename": "src/WildcatMarketController.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport { EnumerableSet } from 'openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport 'solady/utils/SafeTransferLib.sol';\nimport './market/WildcatMarket.sol';\nimport './interfaces/IWildcatArchController.sol';\nimport './interfaces/IWildcatMarketControllerEventsAndErrors.sol';\nimport './interfaces/IWildcatMarketControllerFactory.sol';\nimport './libraries/LibStoredInitCode.sol';\nimport './libraries/MathUtils.sol';\n\nstruct TemporaryReserveRatio {\n  uint128 reserveRatioBips;\n  uint128 expiry;\n}\n\nstruct TmpMarketParameterStorage {\n  address asset;\n  string namePrefix;\n  string symbolPrefix;\n  address feeRecipient;\n  uint16 protocolFeeBips;\n  uint128 maxTotalSupply;\n  uint16 annualInterestBips;\n  uint16 delinquencyFeeBips;\n  uint32 withdrawalBatchDuration;\n  uint16 reserveRatioBips;\n  uint32 delinquencyGracePeriod;\n}\n\ncontract WildcatMarketController is IWildcatMarketControllerEventsAndErrors {\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using SafeCastLib for uint256;\n  using SafeTransferLib for address;\n\n  /* -------------------------------------------------------------------------- */\n  /*                                 Immutables                                 */\n  /* -------------------------------------------------------------------------- */\n\n  IWildcatArchController public immutable archController;\n\n  IWildcatMarketControllerFactory public immutable controllerFactory;\n\n  address public immutable borrower;\n\n  address public immutable sentinel;\n\n  address public immutable marketInitCodeStorage;\n\n  uint256 public immutable marketInitCodeHash;\n\n  uint256 internal immutable ownCreate2Prefix = LibStoredInitCode.getCreate2Prefix(address(this));\n\n  uint32 internal immutable MinimumDelinquencyGracePeriod;\n  uint32 internal immutable MaximumDelinquencyGracePeriod;\n\n  uint16 internal immutable MinimumReserveRatioBips;\n  uint16 internal immutable MaximumReserveRatioBips;\n\n  uint16 internal immutable MinimumDelinquencyFeeBips;\n  uint16 internal immutable MaximumDelinquencyFeeBips;\n\n  uint32 internal immutable MinimumWithdrawalBatchDuration;\n  uint32 internal immutable MaximumWithdrawalBatchDuration;\n\n  uint16 internal immutable MinimumAnnualInterestBips;\n  uint16 internal immutable MaximumAnnualInterestBips;\n\n  EnumerableSet.AddressSet internal _authorizedLenders;\n  EnumerableSet.AddressSet internal _controlledMarkets;\n\n  /// @dev Temporary storage for market parameters, used during market deployment\n  TmpMarketParameterStorage internal _tmpMarketParameters;\n\n  mapping(address => TemporaryReserveRatio) public temporaryExcessReserveRatio;\n\n  // MarketParameterConstraints internal immutable constraints\n\n  modifier onlyBorrower() {\n    if (msg.sender != borrower) {\n      revert CallerNotBorrower();\n    }\n    _;\n  }\n\n  modifier onlyControlledMarket(address market) {\n    if (!_controlledMarkets.contains(market)) {\n      revert NotControlledMarket();\n    }\n    _;\n  }\n\n  constructor() {\n    controllerFactory = IWildcatMarketControllerFactory(msg.sender);\n    MarketControllerParameters memory parameters = controllerFactory.getMarketControllerParameters();\n    archController = IWildcatArchController(parameters.archController);\n    borrower = parameters.borrower;\n    sentinel = parameters.sentinel;\n    marketInitCodeStorage = parameters.marketInitCodeStorage;\n    marketInitCodeHash = parameters.marketInitCodeHash;\n    MinimumDelinquencyGracePeriod = parameters.minimumDelinquencyGracePeriod;\n    MaximumDelinquencyGracePeriod = parameters.maximumDelinquencyGracePeriod;\n    MinimumReserveRatioBips = parameters.minimumReserveRatioBips;\n    MaximumReserveRatioBips = parameters.maximumReserveRatioBips;\n    MinimumDelinquencyFeeBips = parameters.minimumDelinquencyFeeBips;\n    MaximumDelinquencyFeeBips = parameters.maximumDelinquencyFeeBips;\n    MinimumWithdrawalBatchDuration = parameters.minimumWithdrawalBatchDuration;\n    MaximumWithdrawalBatchDuration = parameters.maximumWithdrawalBatchDuration;\n    MinimumAnnualInterestBips = parameters.minimumAnnualInterestBips;\n    MaximumAnnualInterestBips = parameters.maximumAnnualInterestBips;\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                               Lender Registry                              */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @dev Returns the set of authorized lenders.\n   */\n  function getAuthorizedLenders() external view returns (address[] memory) {\n    return _authorizedLenders.values();\n  }\n\n  function getAuthorizedLenders(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _authorizedLenders.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _authorizedLenders.at(start + i);\n    }\n  }\n\n  function getAuthorizedLendersCount() external view returns (uint256) {\n    return _authorizedLenders.length();\n  }\n\n  function isAuthorizedLender(address lender) external view virtual returns (bool) {\n    return _authorizedLenders.contains(lender);\n  }\n\n  /**\n   * @dev Grant authorization for a set of lenders.\n   *\n   *      Note: Only updates the internal set of approved lenders.\n   *      Must call `updateLenderAuthorization` to apply changes\n   *      to existing market accounts\n   */\n  function authorizeLenders(address[] memory lenders) external onlyBorrower {\n    for (uint256 i = 0; i < lenders.length; i++) {\n      address lender = lenders[i];\n      if (_authorizedLenders.add(lender)) {\n        emit LenderAuthorized(lender);\n      }\n    }\n  }\n\n  /**\n   * @dev Revoke authorization for a set of lenders.\n   *\n   *      Note: Only updates the internal set of approved lenders.\n   *      Must call `updateLenderAuthorization` to apply changes\n   *      to existing market accounts\n   */\n  function deauthorizeLenders(address[] memory lenders) external onlyBorrower {\n    for (uint256 i = 0; i < lenders.length; i++) {\n      address lender = lenders[i];\n      if (_authorizedLenders.remove(lender)) {\n        emit LenderDeauthorized(lender);\n      }\n    }\n  }\n\n  /**\n   * @dev Update lender authorization for a set of markets to the current\n   *      status.\n   */\n  function updateLenderAuthorization(address lender, address[] memory markets) external {\n    for (uint256 i; i < markets.length; i++) {\n      address market = markets[i];\n      if (!_controlledMarkets.contains(market)) {\n        revert NotControlledMarket();\n      }\n      WildcatMarket(market).updateAccountAuthorization(lender, _authorizedLenders.contains(lender));\n    }\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                                Market Queries                               */\n  /* -------------------------------------------------------------------------- */\n\n  function isControlledMarket(address market) external view returns (bool) {\n    return _controlledMarkets.contains(market);\n  }\n\n  function getControlledMarkets() external view returns (address[] memory) {\n    return _controlledMarkets.values();\n  }\n\n  function getControlledMarkets(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _controlledMarkets.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _controlledMarkets.at(start + i);\n    }\n  }\n\n  function getControlledMarketsCount() external view returns (uint256) {\n    return _controlledMarkets.length();\n  }\n\n  function computeMarketAddress(\n    address asset,\n    string memory namePrefix,\n    string memory symbolPrefix\n  ) external view returns (address) {\n    bytes32 salt = _deriveSalt(asset, namePrefix, symbolPrefix);\n    return LibStoredInitCode.calculateCreate2Address(ownCreate2Prefix, salt, marketInitCodeHash);\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                              Market Deployment                              */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @dev Get the temporarily stored market parameters for a market that is\n   *      currently being deployed.\n   */\n  function getMarketParameters() external view returns (MarketParameters memory parameters) {\n    parameters.asset = _tmpMarketParameters.asset;\n    parameters.namePrefix = _tmpMarketParameters.namePrefix;\n    parameters.symbolPrefix = _tmpMarketParameters.symbolPrefix;\n    parameters.borrower = borrower;\n    parameters.controller = address(this);\n    parameters.feeRecipient = _tmpMarketParameters.feeRecipient;\n    parameters.sentinel = sentinel;\n    parameters.maxTotalSupply = _tmpMarketParameters.maxTotalSupply;\n    parameters.protocolFeeBips = _tmpMarketParameters.protocolFeeBips;\n    parameters.annualInterestBips = _tmpMarketParameters.annualInterestBips;\n    parameters.delinquencyFeeBips = _tmpMarketParameters.delinquencyFeeBips;\n    parameters.withdrawalBatchDuration = _tmpMarketParameters.withdrawalBatchDuration;\n    parameters.reserveRatioBips = _tmpMarketParameters.reserveRatioBips;\n    parameters.delinquencyGracePeriod = _tmpMarketParameters.delinquencyGracePeriod;\n  }\n\n  function _resetTmpMarketParameters() internal {\n    _tmpMarketParameters.asset = address(1);\n    _tmpMarketParameters.namePrefix = '_';\n    _tmpMarketParameters.symbolPrefix = '_';\n    _tmpMarketParameters.feeRecipient = address(1);\n    _tmpMarketParameters.protocolFeeBips = 1;\n    _tmpMarketParameters.maxTotalSupply = 1;\n    _tmpMarketParameters.annualInterestBips = 1;\n    _tmpMarketParameters.delinquencyFeeBips = 1;\n    _tmpMarketParameters.withdrawalBatchDuration = 1;\n    _tmpMarketParameters.reserveRatioBips = 1;\n    _tmpMarketParameters.delinquencyGracePeriod = 1;\n  }\n\n  /**\n   * @dev Deploys a create2 deployment of `WildcatMarket` unique to the\n   *      combination of `asset, namePrefix, symbolPrefix` and registers\n   *      it with the arch-controller.\n   *\n   *      If a market has already been deployed with these parameters,\n   *      reverts with `MarketAlreadyDeployed`.\n   *\n   *      If `msg.sender` is not `borrower` or `controllerFactory`,\n   *      reverts with `CallerNotBorrowerOrControllerFactory`.\n   *\n   *\t    If `msg.sender == borrower && !archController.isRegisteredBorrower(msg.sender)`,\n   *\t\t  reverts with `NotRegisteredBorrower`.\n   *\n   *      If called by `controllerFactory`, skips borrower check.\n   *\n   *      If either string is empty, reverts with `EmptyString`.\n   *\n   *      If `originationFeeAmount` returned by controller factory is not zero,\n   *      transfers `originationFeeAmount` of `originationFeeAsset` from\n   *      `msg.sender` to `feeRecipient`.\n   */\n  function deployMarket(\n    address asset,\n    string memory namePrefix,\n    string memory symbolPrefix,\n    uint128 maxTotalSupply,\n    uint16 annualInterestBips,\n    uint16 delinquencyFeeBips,\n    uint32 withdrawalBatchDuration,\n    uint16 reserveRatioBips,\n    uint32 delinquencyGracePeriod\n  ) external returns (address market) {\n    if (msg.sender == borrower) {\n      if (!archController.isRegisteredBorrower(msg.sender)) {\n        revert NotRegisteredBorrower();\n      }\n    } else if (msg.sender != address(controllerFactory)) {\n      revert CallerNotBorrowerOrControllerFactory();\n    }\n\n    enforceParameterConstraints(\n      namePrefix,\n      symbolPrefix,\n      annualInterestBips,\n      delinquencyFeeBips,\n      withdrawalBatchDuration,\n      reserveRatioBips,\n      delinquencyGracePeriod\n    );\n\n    TmpMarketParameterStorage memory parameters = TmpMarketParameterStorage({\n      asset: asset,\n      namePrefix: namePrefix,\n      symbolPrefix: symbolPrefix,\n      feeRecipient: address(0),\n      maxTotalSupply: maxTotalSupply,\n      protocolFeeBips: 0,\n      annualInterestBips: annualInterestBips,\n      delinquencyFeeBips: delinquencyFeeBips,\n      withdrawalBatchDuration: withdrawalBatchDuration,\n      reserveRatioBips: reserveRatioBips,\n      delinquencyGracePeriod: delinquencyGracePeriod\n    });\n\n    address originationFeeAsset;\n    uint80 originationFeeAmount;\n    (\n      parameters.feeRecipient,\n      originationFeeAsset,\n      originationFeeAmount,\n      parameters.protocolFeeBips\n    ) = controllerFactory.getProtocolFeeConfiguration();\n\n    _tmpMarketParameters = parameters;\n\n    if (originationFeeAsset != address(0)) {\n      originationFeeAsset.safeTransferFrom(borrower, parameters.feeRecipient, originationFeeAmount);\n    }\n\n    bytes32 salt = _deriveSalt(asset, namePrefix, symbolPrefix);\n    market = LibStoredInitCode.calculateCreate2Address(ownCreate2Prefix, salt, marketInitCodeHash);\n    if (market.codehash != bytes32(0)) {\n      revert MarketAlreadyDeployed();\n    }\n    LibStoredInitCode.create2WithStoredInitCode(marketInitCodeStorage, salt);\n\n    archController.registerMarket(market);\n    _controlledMarkets.add(market);\n\n    _resetTmpMarketParameters();\n  }\n\n  /**\n   * @dev Derive create2 salt for a market given the asset address,\n   *      name prefix and symbol prefix.\n   *\n   *      The salt is unique to each market deployment in the controller,\n   *      so only one market can be deployed for each combination of `asset`,\n   *      `namePrefix` and `symbolPrefix`\n   */\n  function _deriveSalt(\n    address asset,\n    string memory namePrefix,\n    string memory symbolPrefix\n  ) internal pure returns (bytes32 salt) {\n    assembly {\n      // Cache free memory pointer\n      let freeMemoryPointer := mload(0x40)\n      // `keccak256(abi.encode(asset, keccak256(namePrefix), keccak256(symbolPrefix)))`\n      mstore(0x00, asset)\n      mstore(0x20, keccak256(add(namePrefix, 32), mload(namePrefix)))\n      mstore(0x40, keccak256(add(symbolPrefix, 32), mload(symbolPrefix)))\n      salt := keccak256(0, 0x60)\n      // Restore free memory pointer\n      mstore(0x40, freeMemoryPointer)\n    }\n  }\n\n  /**\n   * @dev Enforce constraints on market parameters, ensuring that\n   *      `annualInterestBips`, `delinquencyFeeBips`, `withdrawalBatchDuration`,\n   *      `reserveRatioBips` and `delinquencyGracePeriod` are within the\n   *      allowed ranges and that `namePrefix` and `symbolPrefix` are not null.\n   */\n  function enforceParameterConstraints(\n    string memory namePrefix,\n    string memory symbolPrefix,\n    uint16 annualInterestBips,\n    uint16 delinquencyFeeBips,\n    uint32 withdrawalBatchDuration,\n    uint16 reserveRatioBips,\n    uint32 delinquencyGracePeriod\n  ) internal view virtual {\n    assembly {\n      if or(iszero(mload(namePrefix)), iszero(mload(symbolPrefix))) {\n        // revert EmptyString();\n        mstore(0x00, 0xecd7b0d1)\n        revert(0x1c, 0x04)\n      }\n    }\n    assertValueInRange(\n      annualInterestBips,\n      MinimumAnnualInterestBips,\n      MaximumAnnualInterestBips,\n      AnnualInterestBipsOutOfBounds.selector\n    );\n    assertValueInRange(\n      delinquencyFeeBips,\n      MinimumDelinquencyFeeBips,\n      MaximumDelinquencyFeeBips,\n      DelinquencyFeeBipsOutOfBounds.selector\n    );\n    assertValueInRange(\n      withdrawalBatchDuration,\n      MinimumWithdrawalBatchDuration,\n      MaximumWithdrawalBatchDuration,\n      WithdrawalBatchDurationOutOfBounds.selector\n    );\n    assertValueInRange(\n      reserveRatioBips,\n      MinimumReserveRatioBips,\n      MaximumReserveRatioBips,\n      ReserveRatioBipsOutOfBounds.selector\n    );\n    assertValueInRange(\n      delinquencyGracePeriod,\n      MinimumDelinquencyGracePeriod,\n      MaximumDelinquencyGracePeriod,\n      DelinquencyGracePeriodOutOfBounds.selector\n    );\n  }\n\n  /**\n   * @dev Returns immutable constraints on market parameters that\n   *      the controller variant will enforce.\n   */\n  function getParameterConstraints()\n    external\n    view\n    returns (MarketParameterConstraints memory constraints)\n  {\n    constraints.minimumDelinquencyGracePeriod = MinimumDelinquencyGracePeriod;\n    constraints.maximumDelinquencyGracePeriod = MaximumDelinquencyGracePeriod;\n    constraints.minimumReserveRatioBips = MinimumReserveRatioBips;\n    constraints.maximumReserveRatioBips = MaximumReserveRatioBips;\n    constraints.minimumDelinquencyFeeBips = MinimumDelinquencyFeeBips;\n    constraints.maximumDelinquencyFeeBips = MaximumDelinquencyFeeBips;\n    constraints.minimumWithdrawalBatchDuration = MinimumWithdrawalBatchDuration;\n    constraints.maximumWithdrawalBatchDuration = MaximumWithdrawalBatchDuration;\n    constraints.minimumAnnualInterestBips = MinimumAnnualInterestBips;\n    constraints.maximumAnnualInterestBips = MaximumAnnualInterestBips;\n  }\n\n  /**\n   * @dev Modify the interest rate for a market.\n   * If the new interest rate is lower than the current interest rate,\n   * the reserve ratio is set to 90% for the next two weeks.\n   */\n  function setAnnualInterestBips(\n    address market,\n    uint16 annualInterestBips\n  ) external virtual onlyBorrower onlyControlledMarket(market) {\n    // If borrower is reducing the interest rate, increase the reserve\n    // ratio for the next two weeks.\n    if (annualInterestBips < WildcatMarket(market).annualInterestBips()) {\n      TemporaryReserveRatio storage tmp = temporaryExcessReserveRatio[market];\n\n      if (tmp.expiry == 0) {\n        tmp.reserveRatioBips = uint128(WildcatMarket(market).reserveRatioBips());\n\n        // Require 90% liquidity coverage for the next 2 weeks\n        WildcatMarket(market).setReserveRatioBips(9000);\n      }\n\n      tmp.expiry = uint128(block.timestamp + 2 weeks);\n    }\n\n    WildcatMarket(market).setAnnualInterestBips(annualInterestBips);\n  }\n\n  function resetReserveRatio(address market) external virtual {\n    TemporaryReserveRatio memory tmp = temporaryExcessReserveRatio[market];\n    if (tmp.expiry == 0) {\n      revertWithSelector(AprChangeNotPending.selector);\n    }\n    if (block.timestamp < tmp.expiry) {\n      revertWithSelector(ExcessReserveRatioStillActive.selector);\n    }\n\n    WildcatMarket(market).setReserveRatioBips(uint256(tmp.reserveRatioBips).toUint16());\n    delete temporaryExcessReserveRatio[market];\n  }\n\n  function assertValueInRange(\n    uint256 value,\n    uint256 min,\n    uint256 max,\n    bytes4 errorSelector\n  ) internal pure {\n    assembly {\n      if or(lt(value, min), gt(value, max)) {\n        mstore(0, errorSelector)\n        revert(0, 4)\n      }\n    }\n  }\n}"
    },
    {
      "filename": "src/WildcatArchController.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport { EnumerableSet } from 'openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport 'solady/auth/Ownable.sol';\nimport './libraries/MathUtils.sol';\n\ncontract WildcatArchController is Ownable {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  EnumerableSet.AddressSet internal _markets;\n  EnumerableSet.AddressSet internal _controllerFactories;\n  EnumerableSet.AddressSet internal _borrowers;\n  EnumerableSet.AddressSet internal _controllers;\n\n  error NotControllerFactory();\n  error NotController();\n\n  error BorrowerAlreadyExists();\n  error ControllerFactoryAlreadyExists();\n  error ControllerAlreadyExists();\n  error MarketAlreadyExists();\n\n  error BorrowerDoesNotExist();\n  error ControllerFactoryDoesNotExist();\n  error ControllerDoesNotExist();\n  error MarketDoesNotExist();\n\n  event MarketAdded(address indexed controller, address market);\n  event MarketRemoved(address market);\n\n  event ControllerFactoryAdded(address controllerFactory);\n  event ControllerFactoryRemoved(address controllerFactory);\n\n  event BorrowerAdded(address borrower);\n  event BorrowerRemoved(address borrower);\n\n  event ControllerAdded(address indexed controllerFactory, address controller);\n  event ControllerRemoved(address controller);\n\n  modifier onlyControllerFactory() {\n    if (!_controllerFactories.contains(msg.sender)) {\n      revert NotControllerFactory();\n    }\n    _;\n  }\n\n  modifier onlyController() {\n    if (!_controllers.contains(msg.sender)) {\n      revert NotController();\n    }\n    _;\n  }\n\n  constructor() {\n    _initializeOwner(msg.sender);\n  }\n\n  /* ========================================================================== */\n  /*                                  Borrowers                                 */\n  /* ========================================================================== */\n\n  function registerBorrower(address borrower) external onlyOwner {\n    if (!_borrowers.add(borrower)) {\n      revert BorrowerAlreadyExists();\n    }\n    emit BorrowerAdded(borrower);\n  }\n\n  function removeBorrower(address borrower) external onlyOwner {\n    if (!_borrowers.remove(borrower)) {\n      revert BorrowerDoesNotExist();\n    }\n    emit BorrowerRemoved(borrower);\n  }\n\n  function isRegisteredBorrower(address borrower) external view returns (bool) {\n    return _borrowers.contains(borrower);\n  }\n\n  function getRegisteredBorrowers() external view returns (address[] memory) {\n    return _borrowers.values();\n  }\n\n  function getRegisteredBorrowers(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _borrowers.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _borrowers.at(start + i);\n    }\n  }\n\n  function getRegisteredBorrowersCount() external view returns (uint256) {\n    return _borrowers.length();\n  }\n\n  /* ========================================================================== */\n  /*                            Controller Factories                            */\n  /* ========================================================================== */\n\n  function registerControllerFactory(address factory) external onlyOwner {\n    if (!_controllerFactories.add(factory)) {\n      revert ControllerFactoryAlreadyExists();\n    }\n    emit ControllerFactoryAdded(factory);\n  }\n\n  function removeControllerFactory(address factory) external onlyOwner {\n    if (!_controllerFactories.remove(factory)) {\n      revert ControllerFactoryDoesNotExist();\n    }\n    emit ControllerFactoryRemoved(factory);\n  }\n\n  function isRegisteredControllerFactory(address factory) external view returns (bool) {\n    return _controllerFactories.contains(factory);\n  }\n\n  function getRegisteredControllerFactories() external view returns (address[] memory) {\n    return _controllerFactories.values();\n  }\n\n  function getRegisteredControllerFactories(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _controllerFactories.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _controllerFactories.at(start + i);\n    }\n  }\n\n  function getRegisteredControllerFactoriesCount() external view returns (uint256) {\n    return _controllerFactories.length();\n  }\n\n  /* ========================================================================== */\n  /*                                 Controllers                                */\n  /* ========================================================================== */\n\n  function registerController(address controller) external onlyControllerFactory {\n    if (!_controllers.add(controller)) {\n      revert ControllerAlreadyExists();\n    }\n    emit ControllerAdded(msg.sender, controller);\n  }\n\n  function removeController(address controller) external onlyOwner {\n    if (!_controllers.remove(controller)) {\n      revert ControllerDoesNotExist();\n    }\n    emit ControllerRemoved(controller);\n  }\n\n  function isRegisteredController(address controller) external view returns (bool) {\n    return _controllers.contains(controller);\n  }\n\n  function getRegisteredControllers() external view returns (address[] memory) {\n    return _controllers.values();\n  }\n\n  function getRegisteredControllers(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _controllers.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _controllers.at(start + i);\n    }\n  }\n\n  function getRegisteredControllersCount() external view returns (uint256) {\n    return _controllers.length();\n  }\n\n  /* ========================================================================== */\n  /*                                   Markets                                   */\n  /* ========================================================================== */\n\n  function registerMarket(address market) external onlyController {\n    if (!_markets.add(market)) {\n      revert MarketAlreadyExists();\n    }\n    emit MarketAdded(msg.sender, market);\n  }\n\n  function removeMarket(address market) external onlyOwner {\n    if (!_markets.remove(market)) {\n      revert MarketDoesNotExist();\n    }\n    emit MarketRemoved(market);\n  }\n\n  function isRegisteredMarket(address market) external view returns (bool) {\n    return _markets.contains(market);\n  }\n\n  function getRegisteredMarkets() external view returns (address[] memory) {\n    return _markets.values();\n  }\n\n  function getRegisteredMarkets(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _markets.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _markets.at(start + i);\n    }\n  }\n\n  function getRegisteredMarketsCount() external view returns (uint256) {\n    return _markets.length();\n  }\n}"
    },
    {
      "filename": "src/market/WildcatMarketBase.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport '../libraries/FeeMath.sol';\nimport '../libraries/Withdrawal.sol';\nimport { queryName, querySymbol } from '../libraries/StringQuery.sol';\nimport '../interfaces/IMarketEventsAndErrors.sol';\nimport '../interfaces/IWildcatMarketController.sol';\nimport '../interfaces/IWildcatSanctionsSentinel.sol';\nimport { IERC20, IERC20Metadata } from '../interfaces/IERC20Metadata.sol';\nimport '../ReentrancyGuard.sol';\nimport '../libraries/BoolUtils.sol';\n\ncontract WildcatMarketBase is ReentrancyGuard, IMarketEventsAndErrors {\n  using WithdrawalLib for MarketState;\n  using SafeCastLib for uint256;\n  using MathUtils for uint256;\n  using BoolUtils for bool;\n\n  // ==================================================================== //\n  //                       Market Config (immutable)                       //\n  // ==================================================================== //\n\n  string public constant version = '1.0';\n\n  /// @dev Account with blacklist control, used for blocking sanctioned addresses.\n  address public immutable sentinel;\n\n  /// @dev Account with authority to borrow assets from the market.\n  address public immutable borrower;\n\n  /// @dev Account that receives protocol fees.\n  address public immutable feeRecipient;\n\n  /// @dev Protocol fee added to interest paid by borrower.\n  uint256 public immutable protocolFeeBips;\n\n  /// @dev Penalty fee added to interest earned by lenders, does not affect protocol fee.\n  uint256 public immutable delinquencyFeeBips;\n\n  /// @dev Time after which delinquency incurs penalty fee.\n  uint256 public immutable delinquencyGracePeriod;\n\n  /// @dev Address of the Market Controller.\n  address public immutable controller;\n\n  /// @dev Address of the underlying asset.\n  address public immutable asset;\n\n  /// @dev Time before withdrawal batches are processed.\n  uint256 public immutable withdrawalBatchDuration;\n\n  /// @dev Token decimals (same as underlying asset).\n  uint8 public immutable decimals;\n\n  /// @dev Token name (prefixed name of underlying asset).\n  string public name;\n\n  /// @dev Token symbol (prefixed symbol of underlying asset).\n  string public symbol;\n\n  // ===================================================================== //\n  //                             Market State                               //\n  // ===================================================================== //\n\n  MarketState internal _state;\n\n  mapping(address => Account) internal _accounts;\n\n  WithdrawalData internal _withdrawalData;\n\n  // ===================================================================== //\n  //                             Constructor                               //\n  // ===================================================================== //\n\n  constructor() {\n    MarketParameters memory parameters = IWildcatMarketController(msg.sender).getMarketParameters();\n\n    if ((parameters.proto"
    }
  ]
}