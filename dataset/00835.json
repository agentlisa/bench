{
  "Title": "H-4: getBunniTokenPrice wrongly returns the total price of all tokens",
  "Content": "# Issue H-4: getBunniTokenPrice wrongly returns the total price of all tokens \n\nSource: https://github.com/sherlock-audit/2023-11-olympus-judging/issues/198 \n\n## Found by \nArabadzhiev, Drynooo, ge6a, hash, jasonxiale, tvdung94\n## Summary\n\nThe function getBunniTokenPrice() is supposed to return the price of 1 Bunni token (1 share) like all other feeds, but it doesn't.  It returns the total price of all minted tokens/shares for a specific pool (total value of position's reserves) which is wrong. \n\n## Vulnerability Detail\n\nThis happens because the totalValue on line 163 is not devided by the total tokens supply. \n\nhttps://github.com/sherlock-audit/2023-11-olympus/blob/main/bophades/src/modules/PRICE/submodules/feeds/BunniPrice.sol#L110-L166\n\n## Impact\n\nThe function getBunniTokenPrice always returns wrong price. This would impact the operation of the RBS module. For instance, using the wrong price during a swap may lead to financial losses for the protocol.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-11-olympus/blob/main/bophades/src/modules/PRICE/submodules/feeds/BunniPrice.sol#L110-L166\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nDevide totalValue by the total tokens supply. \n\n\n\n## Discussion\n\n**0xrusowsky**\n\nhttps://github.com/OlympusDAO/bophades/pull/244  \n\n**IAm0x52**\n\nFix looks good. Token price is now normalized to get price per token.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/128",
  "Code": [
    {
      "filename": "bophades/src/modules/PRICE/submodules/feeds/BunniPrice.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\n// Bophades modules\nimport \"modules/PRICE/PRICE.v2.sol\";\n\n// Bunni contracts\nimport {BunniLens} from \"src/external/bunni/BunniLens.sol\";\nimport {BunniToken} from \"src/external/bunni/BunniToken.sol\";\nimport {BunniKey} from \"src/external/bunni/base/Structs.sol\";\nimport {IBunniHub} from \"src/external/bunni/interfaces/IBunniHub.sol\";\n\n// Standard libraries\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\n// Libraries\nimport {FullMath} from \"libraries/FullMath.sol\";\nimport {Deviation} from \"libraries/Deviation.sol\";\nimport {UniswapV3OracleHelper} from \"libraries/UniswapV3/Oracle.sol\";\nimport {BunniHelper} from \"libraries/UniswapV3/BunniHelper.sol\";\n\n/// @title      BunniPrice\n/// @author     0xJem\n/// @notice     A PRICE submodule that provides data on OHM deployed into Uniswap V3 pools that\n/// @notice     are managed by the BunniManager policy and its associated BunniHub.\ncontract BunniPrice is PriceSubmodule {\n    using FullMath for uint256;\n\n    // ========== CONSTANTS ========== //\n\n    /// @notice     Struct containing parameters for the submodule\n    struct BunniParams {\n        address bunniLens;\n        uint16 twapMaxDeviationsBps;\n        uint32 twapObservationWindow;\n    }\n\n    // ========== ERRORS ========== //\n\n    /// @notice             `bunniToken_` is not a valid BunniToken\n    /// @param bunniToken_  The invalid token\n    error BunniPrice_Params_InvalidBunniToken(address bunniToken_);\n\n    /// @notice             `bunniLens_` is not a valid BunniLens\n    /// @param bunniLens_   The invalid BunniLens\n    error BunniPrice_Params_InvalidBunniLens(address bunniLens_);\n\n    /// @notice                 The BunniHub does not match between the BunniToken and BunniLens\n    /// @param bunniTokenHub_   The address of the BunniHub configured in the BunniToken\n    /// @param bunniLensHub_    The address of the BunniHub configured in the BunniLens\n    error BunniPrice_Params_HubMismatch(address bunniTokenHub_, address bunniLensHub_);\n\n    /// @notice                   The calculated pool price deviates from the TWAP by more than the maximum deviation.\n    ///\n    /// @param pool_              The address of the pool\n    /// @param baseInQuoteTWAP_   The calculated TWAP price in terms of the quote token\n    /// @param baseInQuotePrice_  The calculated current price in terms of the quote token\n    error BunniPrice_PriceMismatch(\n        address pool_,\n        uint256 baseInQuoteTWAP_,\n        uint256 baseInQuotePrice_\n    );\n\n    // ========== STATE VARIABLES ========== //\n\n    uint16 internal constant TWAP_MAX_DEVIATION_BASE = 10_000; // 100%\n\n    // ========== CONSTRUCTOR ========== //\n\n    constructor(Module parent_) Submodule(parent_) {}\n\n    // ========== SUBMODULE FUNCTIONS =========== //\n\n    /// @inheritdoc     Submodule\n    function SUBKEYCODE() public pure override returns (SubKeycode) {\n        return toSubKeycode(\"PRICE.BNI\");\n    }\n\n    /// @inheritdoc     Submodule\n    function VERSION() public pure override returns (uint8 major, uint8 minor) {\n        major = 1;\n        minor = 0;\n    }\n\n    // ========== TOKEN PRICE FUNCTIONS ========== //\n\n    /// @notice                 Determines the price of `bunniToken_` (representing a Uniswap V3 pool) in USD\n    /// @dev                    This function performs the following:\n    /// @dev                    - Decodes the parameters\n    /// @dev                    - Check that the token is a valid BunniToken\n    /// @dev                    - Check that the lens is a valid BunniLens\n    /// @dev                    - Check that the token and lens have the same BunniHub address\n    /// @dev                    - Fetches the reserves contained in the Uniswap V3 position\n    /// @dev                    - Determines the value of each reserve token in USD\n    ///\n    /// @dev                    This function accesses the reserves of the registered\n    /// @dev                    Uniswap V3 pools, and can be susceptible to re-entrancy attacks.\n    /// @dev                    The BunniLens contract used by this Submodule performs a re-entrancy check.\n    ///\n    /// @dev                    This function reverts if:\n    /// @dev                    - The token is not a valid BunniToken\n    /// @dev                    - The lens (from `params_`) is not a valid BunniLens\n    /// @dev                    - The token and lens do not have the same BunniHub address\n    /// @dev                    - The reserves of the pool deviate from the TWAP by more than the maximum deviation\n    /// @dev                    - Any of the reserve assets are not defined as assets in PRICE\n    ///\n    /// @param bunniToken_      The address of the BunniToken contract\n    /// @param outputDecimals_  The number of decimals to use for the output price\n    /// @param params_          The encoded parameters for the function call\n    function getBunniTokenPrice(\n        address bunniToken_,\n        uint8 outputDecimals_,\n        bytes calldata params_\n    ) external view returns (uint256) {\n        // Decode the parameters\n        BunniParams memory params;\n        {\n            params = abi.decode(params_, (BunniParams));\n            if (params.bunniLens == address(0)) {\n                revert BunniPrice_Params_InvalidBunniLens(params.bunniLens);\n            }\n\n            // Check for invalid bunniToken_\n            if (bunniToken_ == address(0)) {\n                revert BunniPrice_Params_InvalidBunniToken(bunniToken_);\n            }\n        }\n\n        // Validate the token\n        BunniToken token = BunniToken(bunniToken_);\n        BunniLens lens = BunniLens(params.bunniLens);\n        {\n            address tokenHub;\n            try token.hub() returns (IBunniHub tokenHub_) {\n                tokenHub = address(tokenHub_);\n            } catch (bytes memory) {\n                revert BunniPrice_Params_InvalidBunniToken(bunniToken_);\n            }\n\n            // Validate the lens\n            address lensHub;\n            try lens.hub() returns (IBunniHub lensHub_) {\n                lensHub = address(lensHub_);\n            } catch (bytes memory) {\n                revert BunniPrice_Params_InvalidBunniLens(params.bunniLens);\n            }\n\n            // Check that the hub matches\n            if (tokenHub != lensHub) {\n                revert BunniPrice_Params_HubMismatch(tokenHub, lensHub);\n            }\n        }\n\n        // Validate reserves\n        _validateReserves(\n            _getBunniKey(token),\n            lens,\n            params.twapMaxDeviationsBps,\n            params.twapObservationWindow\n        );\n\n        // Fetch the reserves\n        uint256 totalValue = _getTotalValue(token, lens, outputDecimals_);\n\n        return totalValue;\n    }\n\n    // ========== INTERNAL FUNCTIONS ========== //\n\n    /// @notice         Returns the BunniKey for the pool repesented by `token_` and the full-range ticks\n    ///\n    /// @param token_   The address of the BunniToken contract\n    /// @return         The BunniKey for the pool\n    function _getBunniKey(BunniToken token_) internal view returns (BunniKey memory) {\n        return\n            BunniKey({\n                pool: token_.pool(),\n                tickLower: token_.tickLower(),\n                tickUpper: token_.tickUpper()\n            });\n    }\n\n    /// @notice                 Fetches the reserves of a Uniswap V3 position\n    ///\n    /// @param token_           The address of the BunniToken contract\n    /// @param lens_            The address of the BunniLens contract\n    /// @param outputDecimals_  The number of decimals to use for the output price\n    /// @return token0          The address of the first reserve token\n    /// @return reserve0        The amount of the first reserve token (in `outputDecimals_`)\n    /// @return token1          The address of the second reserve token\n    /// @return reserve1        The amount of the second reserve token (in `outputDecimals_`)\n    function _getBunniReserves(\n        BunniToken token_,\n        BunniLens lens_,\n        uint8 outputDecimals_\n    ) internal view returns (address token0, uint256 reserve0, address token1, uint256 reserve1) {\n        BunniKey memory key = _getBunniKey(token_);\n        (uint112 reserve0_, uint112 reserve1_) = lens_.getReserves(key);\n\n        // Get the token addresses\n        token0 = key.pool.token0();\n        token1 = key.pool.token1();\n        uint8 token0Decimals = ERC20(token0).decimals();\n        uint8 token1Decimals = ERC20(token1).decimals();\n        reserve0 = uint256(reserve0_).mulDiv(10 ** outputDecimals_, 10 ** token0Decimals);\n        reserve1 = uint256(reserve1_).mulDiv(10 ** outputDecimals_, 10 ** token1Decimals);\n    }\n\n    /// @notice                 Determines the total value of the Uniswap V3 position represented by `token_`\n    ///\n    /// @param token_           The BunniToken representing the Uniswap V3 position\n    /// @param lens_            The BunniLens to use for determining reserves\n    /// @param outputDecimals_  The decimal scale to use\n    /// @return                 The total value of the position in USD in the scale of `outputDecimals_`\n    function _getTotalValue(\n        BunniToken token_,\n        BunniLens lens_,\n        uint8 outputDecimals_\n    ) internal view returns (uint256) {\n        (address token0, uint256 reserve0, address token1, uint256 reserve1) = _getBunniReserves(\n            token_,\n            lens_,\n            outputDecimals_\n        );\n        uint256 outputScale = 10 ** outputDecimals_;\n\n        // Determine the value of each reserve token in USD\n        uint256 totalValue;\n        totalValue += _PRICE().getPrice(token0).mulDiv(reserve0, outputScale);\n        totalValue += _PRICE().getPrice(token1).mulDiv(reserve1, outputScale);\n\n        return totalValue;\n    }\n\n    /// @notice                         Validates that the reserves of the pool represented by `key_` are within\n    /// @notice                         the maximum deviation from the pool's TWAP.\n    ///\n    /// @param key_                     The BunniKey for the pool\n    /// @param lens_                    The BunniLens contract\n    /// @param twapMaxDeviationBps_     The maximum deviation from the TWAP in basis points\n    /// @param twapObservationWindow_   The TWAP observation window in seconds\n    function _validateReserves(\n        BunniKey memory key_,\n        BunniLens lens_,\n        uint16 twapMaxDeviationBps_,\n        uint32 twapObservationWindow_\n    ) internal view {\n        uint256 reservesTokenRatio = BunniHelper.getReservesRatio(key_, lens_);\n        uint256 twapTokenRatio = UniswapV3OracleHelper.getTWAPRatio(\n            address(key_.pool),\n            twapObservationWindow_\n        );\n\n        // Revert if the relative deviation is greater than the maximum.\n        if (\n            // `isDeviatingWithBpsCheck()` will revert if `deviationBps` is invalid.\n            Deviation.isDeviatingWithBpsCheck(\n                reservesTokenRatio,\n                twapTokenRatio,\n                twapMaxDeviationBps_,\n                TWAP_MAX_DEVIATION_BASE\n            )\n        ) {\n            revert BunniPrice_PriceMismatch(address(key_.pool), twapTokenRatio, reservesTokenRatio);\n        }\n    }\n}"
    },
    {
      "filename": "bophades/src/modules/PRICE/submodules/feeds/BunniPrice.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\n// Bophades modules\nimport \"modules/PRICE/PRICE.v2.sol\";\n\n// Bunni contracts\nimport {BunniLens} from \"src/external/bunni/BunniLens.sol\";\nimport {BunniToken} from \"src/external/bunni/BunniToken.sol\";\nimport {BunniKey} from \"src/external/bunni/base/Structs.sol\";\nimport {IBunniHub} from \"src/external/bunni/interfaces/IBunniHub.sol\";\n\n// Standard libraries\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\n// Libraries\nimport {FullMath} from \"libraries/FullMath.sol\";\nimport {Deviation} from \"libraries/Deviation.sol\";\nimport {UniswapV3OracleHelper} from \"libraries/UniswapV3/Oracle.sol\";\nimport {BunniHelper} from \"libraries/UniswapV3/BunniHelper.sol\";\n\n/// @title      BunniPrice\n/// @author     0xJem\n/// @notice     A PRICE submodule that provides data on OHM deployed into Uniswap V3 pools that\n/// @notice     are managed by the BunniManager policy and its associated BunniHub.\ncontract BunniPrice is PriceSubmodule {\n    using FullMath for uint256;\n\n    // ========== CONSTANTS ========== //\n\n    /// @notice     Struct containing parameters for the submodule\n    struct BunniParams {\n        address bunniLens;\n        uint16 twapMaxDeviationsBps;\n        uint32 twapObservationWindow;\n    }\n\n    // ========== ERRORS ========== //\n\n    /// @notice             `bunniToken_` is not a valid BunniToken\n    /// @param bunniToken_  The invalid token\n    error BunniPrice_Params_InvalidBunniToken(address bunniToken_);\n\n    /// @notice             `bunniLens_` is not a valid BunniLens\n    /// @param bunniLens_   The invalid BunniLens\n    error BunniPrice_Params_InvalidBunniLens(address bunniLens_);\n\n    /// @notice                 The BunniHub does not match between the BunniToken and BunniLens\n    /// @param bunniTokenHub_   The address of the BunniHub configured in the BunniToken\n    /// @param bunniLensHub_    The address of the BunniHub configured in the BunniLens\n    error BunniPrice_Params_HubMismatch(address bunniTokenHub_, address bunniLensHub_);\n\n    /// @notice                   The calculated pool price deviates from the TWAP by more than the maximum deviation.\n    ///\n    /// @param pool_              The address of the pool\n    /// @param baseInQuoteTWAP_   The calculated TWAP price in terms of the quote token\n    /// @param baseInQuotePrice_  The calculated current price in terms of the quote token\n    error BunniPrice_PriceMismatch(\n        address pool_,\n        uint256 baseInQuoteTWAP_,\n        uint256 baseInQuotePrice_\n    );\n\n    // ========== STATE VARIABLES ========== //\n\n    uint16 internal constant TWAP_MAX_DEVIATION_BASE = 10_000; // 100%\n\n    // ========== CONSTRUCTOR ========== //\n\n    constructor(Module parent_) Submodule(parent_) {}\n\n    // ========== SUBMODULE FUNCTIONS =========== //\n\n    /// @inheritdoc     Submodule\n    function SUBKEYCODE() public pure override returns (SubKeycode) {\n        return toSubKeycode(\"PRICE.BNI\");\n    }\n\n    /// @inheritdoc     Submodule\n    function VERSION() public pure override returns (uint8 major, uint8 minor) {\n        major = 1;\n        minor = 0;\n    }\n\n    // ========== TOKEN PRICE FUNCTIONS ========== //\n\n    /// @notice                 Determines the price of `bunniToken_` (representing a Uniswap V3 pool) in USD\n    /// @dev                    This function performs the following:\n    /// @dev                    - Decodes the parameters\n    /// @dev                    - Check that the token is a valid BunniToken\n    /// @dev                    - Check that the lens is a valid BunniLens\n    /// @dev                    - Check that the token and lens have the same BunniHub address\n    /// @dev                    - Fetches the reserves contained in the Uniswap V3 position\n    /// @dev                    - Determines the value of each reserve token in USD\n    ///\n    /// @dev                    This function accesses the reserves of the registered\n    /// @dev                    Uniswap V3 pools, and can be susceptible to re-entrancy attacks.\n    /// @dev                    The BunniLens contract used by this Submodule performs a re-entrancy check.\n    ///\n    /// @dev                    This function reverts if:\n    /// @dev                    - The token is not a valid BunniToken\n    /// @dev                    - The lens (from `params_`) is not a valid BunniLens\n    /// @dev                    - The token and lens do not have the same BunniHub address\n    /// @dev                    - The reserves of the pool deviate from the TWAP by more than the maximum deviation\n    /// @dev                    - Any of the reserve assets are not defined as assets in PRICE\n    ///\n    /// @param bunniToken_      The address of the BunniToken contract\n    /// @param outputDecimals_  The number of decimals to use for the output price\n    /// @param params_          The encoded parameters for the function call\n    function getBunniTokenPrice(\n        address bunniToken_,\n        uint8 outputDecimals_,\n        bytes calldata params_\n    ) external view returns (uint256) {\n        // Decode the parameters\n        BunniParams memory params;\n        {\n            params = abi.decode(params_, (BunniParams));\n            if (params.bunniLens == address(0)) {\n                revert BunniPrice_Params_InvalidBunniLens(params.bunniLens);\n            }\n\n            // Check for invalid bunniToken_\n            if (bunniToken_ == address(0)) {\n                revert BunniPrice_Params_InvalidBunniToken(bunniToken_);\n            }\n        }\n\n        // Validate the token\n        BunniToken token = BunniToken(bunniToken_);\n        BunniLens lens = BunniLens(params.bunniLens);\n        {\n            address tokenHub;\n            try token.hub() returns (IBunniHub tokenHub_) {\n                tokenHub = address(tokenHub_);\n            } catch (bytes memory) {\n                revert BunniPrice_Params_InvalidBunniToken(bunniToken_);\n            }\n\n            // Validate the lens\n            address lensHub;\n            try lens.hub() returns (IBunniHub lensHub_) {\n                lensHub = address(lensHub_);\n            } catch (bytes memory) {\n                revert BunniPrice_Params_InvalidBunniLens(params.bunniLens);\n            }\n\n            // Check that the hub matches\n            if (tokenHub != lensHub) {\n                revert BunniPrice_Params_HubMismatch(tokenHub, lensHub);\n            }\n        }\n\n        // Validate reserves\n        _validateReserves(\n            _getBunniKey(token),\n            lens,\n            params.twapMaxDeviationsBps,\n            params.twapObservationWindow\n        );\n\n        // Fetch the reserves\n        uint256 totalValue = _getTotalValue(token, lens, outputDecimals_);\n\n        return totalValue;\n    }\n\n    // ========== INTERNAL FUNCTIONS ========== //\n\n    /// @notice         Returns the BunniKey for the pool repesented by `token_` and the full-range ticks\n    ///\n    /// @param token_   The address of the BunniToken contract\n    /// @return         The BunniKey for the pool\n    function _getBunniKey(BunniToken token_) internal view returns (BunniKey memory) {\n        return\n            BunniKey({\n                pool: token_.pool(),\n                tickLower: token_.tickLower(),\n                tickUpper: token_.tickUpper()\n            });\n    }\n\n    /// @notice                 Fetches the reserves of a Uniswap V3 position\n    ///\n    /// @param token_           The address of the BunniToken contract\n    /// @param lens_            The address of the BunniLens contract\n    /// @param outputDecimals_  The number of decimals to use for the output price\n    /// @return token0          The address of the first reserve token\n    /// @return reserve0        The amount of the first reserve token (in `outputDecimals_`)\n    /// @return token1          The address of the second reserve token\n    /// @return reserve1        The amount of the second reserve token (in `outputDecimals_`)\n    function _getBunniReserves(\n        BunniToken token_,\n        BunniLens lens_,\n        uint8 outputDecimals_\n    ) internal view returns (address token0, uint256 reserve0, address token1, uint256 reserve1) {\n        BunniKey memory key = _getBunniKey(token_);\n        (uint112 reserve0_, uint112 reserve1_) = lens_.getReserves(key);\n\n        // Get the token addresses\n        token0 = key.pool.token0();\n        token1 = key.pool.token1();\n        uint8 token0Decimals = ERC20(token0).decimals();\n        uint8 token1Decimals = ERC20(token1).decimals();\n        reserve0 = uint256(reserve0_).mulDiv(10 ** outputDecimals_, 10 ** token0Decimals);\n        reserve1 = uint256(reserve1_).mulDiv(10 ** outputDecimals_, 10 ** token1Decimals);\n    }\n\n    /// @notice                 Determines the total value of the Uniswap V3 position represented by `token_`\n    ///\n    /// @param token_           The BunniToken representing the Uniswap V3 position\n    /// @param lens_            The BunniLens to use for determining reserves\n    /// @param outputDecimals_  The decimal scale to use\n    /// @return                 The total value of the position in USD in the scale of `outputDecimals_`\n    function _getTotalValue(\n        BunniToken token_,\n        BunniLens lens_,\n        uint8 outputDecimals_\n    ) internal view returns (uint256) {\n        (address token0, uint256 reserve0, address token1, uint256 reserve1) = _getBunniReserves(\n            token_,\n            lens_,\n            outputDecimals_\n        );\n        uint256 outputScale = 10 ** outputDecimals_;\n\n        // Determine the value of each reserve token in USD\n        uint256 totalValue;\n        totalValue += _PRICE().getPrice(token0).mulDiv(reserve0, outputScale);\n        totalValue += _PRICE().getPrice(token1).mulDiv(reserve1, outputScale);\n\n        return totalValue;\n    }\n\n    /// @notice                         Validates that the reserves of the pool represented by `key_` are within\n    /// @notice                         the maximum deviation from the pool's TWAP.\n    ///\n    /// @param key_                     The BunniKey for the pool\n    /// @param lens_                    The BunniLens contract\n    /// @param twapMaxDeviationBps_     The maximum deviation from the TWAP in basis points\n    /// @param twapObservationWindow_   The TWAP observation window in seconds\n    function _validateReserves(\n        BunniKey memory key_,\n        BunniLens lens_,\n        uint16 twapMaxDeviationBps_,\n        uint32 twapObservationWindow_\n    ) internal view {\n        uint256 reservesTokenRatio = BunniHelper.getReservesRatio(key_, lens_);\n        uint256 twapTokenRatio = UniswapV3OracleHelper.getTWAPRatio(\n            address(key_.pool),\n            twapObservationWindow_\n        );\n\n        // Revert if the relative deviation is greater than the maximum.\n        if (\n            // `isDeviatingWithBpsCheck()` will revert if `deviationBps` is invalid.\n            Deviation.isDeviatingWithBpsCheck(\n                reservesTokenRatio,\n                twapTokenRatio,\n                twapMaxDeviationBps_,\n                TWAP_MAX_DEVIATION_BASE\n            )\n        ) {\n            revert BunniPrice_PriceMismatch(address(key_.pool), twapTokenRatio, reservesTokenRatio);\n        }\n    }\n}"
    }
  ]
}