{
  "Title": "[M01] Incorrect value of MAX_UINT",
  "Content": "In line 38 of `ReleaseGold.sol`, there is a [constant called `MAX_UINT`](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/governance/ReleaseGold.sol#L38). This constant equals the value `0xffffffffffffffffffffffffffffffff`, which is 32 hex digits or 128 bits. Since default `uint` types in solidity have 256 bits, the `MAX_UINT` value should be `0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (with 64 hexidecimal `f`â€˜s).\n\n\nWhen the [`initialize` function](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/governance/ReleaseGold.sol#L157) is called with an [`initialDistributionRatio`](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/governance/ReleaseGold.sol#L221) of `1000` and the [`totalGrant`](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/governance/ReleaseGold.sol#L216) is greater than this erroneous value of `MAX_INT`, it will result in [some gold not being able to be withdrawn](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/governance/ReleaseGold.sol#L304). In the same way, an erroneous distribution could happen in the [`setMaxDistribution` function](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/governance/ReleaseGold.sol#L255).\n\n\nConsider changing `MAX_UINT` to the correct value. Furthermore, to be extra careful, consider setting `maxDistribution` to [`totalGrant`](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/governance/ReleaseGold.sol#L220) and [`totalBalance`](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/governance/ReleaseGold.sol#L262), instead of using the maximum possible value which is usually going to be much larger than the [total withdrawable amount](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/governance/ReleaseGold.sol#L305).\n\n\n***Update:** Fixed in [pull request #3274](https://github.com/celo-org/celo-monorepo/pull/3274). It is now forcing an underflow to get the maximum possible value for a `uint256`. Note however that this is not clear, and it might cause problems in the future if Solidity decides to [change the default behavior for underflows](https://github.com/ethereum/solidity/issues/796).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/governance/ReleaseGold.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\nimport \"./interfaces/IReleaseGold.sol\";\nimport \"../common/FixidityLib.sol\";\n\nimport \"../common/Initializable.sol\";\nimport \"../common/UsingRegistry.sol\";\n\ncontract ReleaseGold is UsingRegistry, ReentrancyGuard, IReleaseGold, Initializable {\n  using SafeMath for uint256;\n  using FixidityLib for FixidityLib.Fraction;\n\n  struct ReleaseSchedule {\n    // Timestamp (in UNIX time) that releasing begins.\n    uint256 releaseStartTime;\n    // Timestamp (in UNIX time) of the releasing cliff.\n    uint256 releaseCliff;\n    // Number of release periods.\n    uint256 numReleasePeriods;\n    // Duration (in seconds) of one period.\n    uint256 releasePeriod;\n    // Amount that is to be released per period.\n    uint256 amountReleasedPerPeriod;\n  }\n\n  struct RevocationInfo {\n    // Indicates if the contract is revocable.\n    bool revocable;\n    // Released gold instance balance at time of revocation.\n    uint256 releasedBalanceAtRevoke;\n    // The time at which the release schedule was revoked.\n    uint256 revokeTime;\n  }\n\n  uint256 internal constant MAX_UINT = 0xffffffffffffffffffffffffffffffff;\n\n  // Beneficiary of the Celo Gold released in this contract.\n  address payable public beneficiary;\n\n  // Address capable of (where applicable) revoking, setting the liquidity provision, and\n  // adjusting the maximum withdrawal amount.\n  address public releaseOwner;\n\n  // Address that receives refunded gold if contract is revoked.\n  address payable public refundAddress;\n\n  // Indicates how much of the released amount has been withdrawn so far.\n  uint256 public totalWithdrawn;\n\n  // Indicates the maximum gold currently available for distribution, regardless of schedule.\n  // Only settable by the `releaseOwner` address, subject to grant conditions.\n  uint256 public maxDistribution;\n\n  // Indicates if the schedule contains a liquidity provision that has not yet been met.\n  // Only settable by the `releaseOwner` address, subject to grant conditions.\n  bool public liquidityProvisionMet;\n\n  // Indicates if this schedule's unreleased gold can be used for validating.\n  bool public canValidate;\n\n  // Indicates if this schedule's unreleased gold can be used for voting.\n  bool public canVote;\n\n  // Public struct housing params pertaining to releasing gold.\n  ReleaseSchedule public releaseSchedule;\n\n  // Public struct housing params pertaining to revocation.\n  RevocationInfo public revocationInfo;\n\n  event ReleaseGoldInstanceCreated(address indexed beneficiary, address indexed atAddress);\n  event ReleaseScheduleRevoked(uint256 revokeTimestamp, uint256 releasedBalanceAtRevoke);\n  event DistributionLimitSet(address indexed beneficiary, uint256 maxDistribution);\n  event LiquidityProvisionSet(address indexed beneficiary);\n  event BeneficiarySet(address indexed beneficiary);\n\n  modifier onlyReleaseOwner() {\n    require(msg.sender == releaseOwner, \"Sender must be the registered releaseOwner address\");\n    _;\n  }\n\n  modifier onlyBeneficiary() {\n    require(msg.sender == beneficiary, \"Sender must be the registered beneficiary address\");\n    _;\n  }\n\n  modifier onlyRevoked() {\n    require(isRevoked(), \"Release schedule instance must have already been revoked\");\n    _;\n  }\n\n  modifier onlyRevocable() {\n    require(revocationInfo.revocable, \"Release schedule instance must be revocable\");\n    _;\n  }\n\n  modifier onlyCanVote() {\n    require(canVote, \"Release Gold contract does not have permission to vote\");\n    _;\n  }\n\n  modifier onlyCanValidate() {\n    require(canValidate, \"Release Gold contract does not have permission to validate\");\n    _;\n  }\n\n  modifier onlyReleaseOwnerAndRevoked() {\n    require(\n      msg.sender == releaseOwner && isRevoked(),\n      \"Sender must be the releaseOwner and state must be revoked\"\n    );\n    _;\n  }\n\n  modifier onlyBeneficiaryAndNotRevoked() {\n    require(\n      msg.sender == beneficiary && !isRevoked(),\n      \"Sender must be the beneficiary and state must not be revoked\"\n    );\n    _;\n  }\n\n  modifier onlyWhenInProperState() {\n    bool isRevoked = isRevoked();\n    require(\n      (msg.sender == releaseOwner && isRevoked) || (msg.sender == beneficiary && !isRevoked),\n      \"Must be called by releaseOwner when revoked or beneficiary before revocation\"\n    );\n    _;\n  }\n\n  function() external payable {} // solhint-disable no-empty-blocks\n\n  /**\n   * @notice A constructor for initialising a new instance of a Releasing Schedule contract.\n   * @param releaseStartTime The time (in Unix time) at which point releasing starts.\n   * @param releaseCliffTime Duration (in seconds) after `releaseStartTime` of the golds' cliff.\n   * @param numReleasePeriods Number of releasing periods.\n   * @param releasePeriod Duration (in seconds) of each release period.\n   * @param amountReleasedPerPeriod The released gold amount per period.\n   * @param revocable Whether the release schedule is revocable or not.\n   * @param _beneficiary Address of the beneficiary to whom released tokens are transferred.\n   * @param _releaseOwner Address capable of revoking, setting the liquidity provision\n   *                      and setting the withdrawal amount.\n   *                      0x0 if grant is not subject to these operations.\n   * @param _refundAddress Address that receives refunded funds if contract is revoked.\n   *                       0x0 if contract is not revocable.\n   * @param subjectToLiquidityProvision If this schedule is subject to a liquidity provision.\n   * @param initialDistributionRatio Amount in range [0, 1000] (3 significant figures)\n   *                                 indicating % of total balance available for distribution.\n   * @param _canValidate If this schedule's gold can be used for validating.\n   * @param _canVote If this schedule's gold can be used for voting.\n   * @param registryAddress Address of the deployed contracts registry.\n   */\n  function initialize(\n    uint256 releaseStartTime,\n    uint256 releaseCliffTime,\n    uint256 numReleasePeriods,\n    uint256 releasePeriod,\n    uint256 amountReleasedPerPeriod,\n    bool revocable,\n    address payable _beneficiary,\n    address _releaseOwner,\n    address payable _refundAddress,\n    bool subjectToLiquidityProvision,\n    uint256 initialDistributionRatio,\n    bool _canValidate,\n    bool _canVote,\n    address registryAddress\n  ) external initializer {\n    _transferOwnership(msg.sender);\n    releaseSchedule.numReleasePeriods = numReleasePeriods;\n    releaseSchedule.amountReleasedPerPeriod = amountReleasedPerPeriod;\n    releaseSchedule.releasePeriod = releasePeriod;\n    releaseSchedule.releaseCliff = releaseStartTime.add(releaseCliffTime);\n    releaseSchedule.releaseStartTime = releaseStartTime;\n    require(releaseSchedule.numReleasePeriods >= 1, \"There must be at least one releasing period\");\n    require(\n      releaseSchedule.amountReleasedPerPeriod > 0,\n      \"The released amount per period must be greater than zero\"\n    );\n    require(\n      _beneficiary != address(0),\n      \"The release schedule beneficiary cannot be the zero addresss\"\n    );\n    require(registryAddress != address(0), \"The registry address cannot be the zero address\");\n    require(\n      releaseSchedule.releaseStartTime.add(\n        releaseSchedule.numReleasePeriods.mul(releaseSchedule.releasePeriod)\n      ) >\n        block.timestamp,\n      \"Release schedule end time must be in the future\"\n    );\n    require(\n      address(this).balance ==\n        releaseSchedule.amountReleasedPerPeriod.mul(releaseSchedule.numReleasePeriods),\n      \"Contract balance must equal the entire grant amount\"\n    );\n    require(!(revocable && _canValidate), \"Revocable contracts cannot validate\");\n    require(initialDistributionRatio <= 1000, \"Initial distribution ratio out of bounds\");\n    require(\n      (revocable && _refundAddress != address(0)) || (!revocable && _refundAddress == address(0)),\n      \"If contract is revocable there must be an address to refund\"\n    );\n\n    setRegistry(registryAddress);\n    _setBeneficiary(_beneficiary);\n    revocationInfo.revocable = revocable;\n    releaseOwner = _releaseOwner;\n    refundAddress = _refundAddress;\n\n    if (initialDistributionRatio < 1000) {\n      // Cannot use `getTotalBalance()` here because the factory has not yet sent the gold.\n      uint256 totalGrant = releaseSchedule.amountReleasedPerPeriod.mul(\n        releaseSchedule.numReleasePeriods\n      );\n      // Initial ratio is expressed to 3 significant figures: [0, 1000].\n      maxDistribution = totalGrant.mul(initialDistributionRatio).div(1000);\n    } else {\n      maxDistribution = MAX_UINT;\n    }\n\n    liquidityProvisionMet = (subjectToLiquidityProvision) ? false : true;\n    canValidate = _canValidate;\n    canVote = _canVote;\n    emit ReleaseGoldInstanceCreated(beneficiary, address(this));\n  }\n\n  /**\n   * @notice Returns if the release schedule has been revoked or not.\n   * @return True if instance revoked.\n   */\n  function isRevoked() public view returns (bool) {\n    return revocationInfo.revokeTime > 0;\n  }\n\n  /**\n   * @notice Controls if the liquidity provision has been met, allowing gold to be withdrawn.\n   */\n  function setLiquidityProvision() external onlyReleaseOwner {\n    require(!liquidityProvisionMet, \"Liquidity provision has already been set\");\n    liquidityProvisionMet = true;\n    emit LiquidityProvisionSet(beneficiary);\n  }\n\n  /**\n   * @notice Controls the maximum distribution ratio.\n   *         Calculates `distributionRatio`/1000 of current `totalBalance()`\n   *         and sets this value as the maximum allowed gold to be currently withdrawn.\n   * @param distributionRatio Amount in range [0, 1000] (3 significant figures)\n   *                          indicating % of total balance available for distribution.\n   */\n  function setMaxDistribution(uint256 distributionRatio) external onlyReleaseOwner {\n    require(distributionRatio <= 1000, \"Max distribution ratio must be within bounds\");\n    // If ratio is 1000, we set maxDistribution to maxUint to account for future rewards.\n    if (distributionRatio == 1000) {\n      maxDistribution = MAX_UINT;\n    } else {\n      uint256 totalBalance = getTotalBalance();\n      maxDistribution = totalBalance.mul(distributionRatio).div(1000);\n    }\n    emit DistributionLimitSet(beneficiary, maxDistribution);\n  }\n\n  /**\n   * @notice Sets the beneficiary of the instance\n   * @param newBeneficiary The address of the new beneficiary\n   */\n  function setBeneficiary(address payable newBeneficiary) external onlyOwner {\n    _setBeneficiary(newBeneficiary);\n  }\n\n  /**\n   * @notice Sets the beneficiary of the instance\n   * @param newBeneficiary The address of the new beneficiary\n   */\n  function _setBeneficiary(address payable newBeneficiary) private {\n    require(newBeneficiary != address(0x0), \"Can't set the beneficiary to the zero address\");\n    beneficiary = newBeneficiary;\n    emit BeneficiarySet(newBeneficiary);\n  }\n\n  /**\n   * @notice Transfers gold from this release schedule instance to the beneficiary.\n   * @param amount The requested gold amount.\n   */\n  function withdraw(uint256 amount) external nonReentrant onlyBeneficiary {\n    require(amount > 0, \"Requested withdrawal amount must be greater than zero\");\n    require(liquidityProvisionMet, \"Requested withdrawal before liquidity provision is met\");\n\n    uint256 releasedAmount;\n    if (isRevoked()) {\n      releasedAmount = revocationInfo.releasedBalanceAtRevoke;\n    } else {\n      releasedAmount = getCurrentReleasedTotalAmount();\n    }\n\n    require(\n      releasedAmount.sub(totalWithdrawn) >= amount,\n      \"Requested amount is greater than available released funds\"\n    );\n    require(\n      maxDistribution >= totalWithdrawn + amount,\n      \"Requested amount exceeds current alloted maximum distribution\"\n    );\n    require(\n      getRemainingUnlockedBalance() >= amount,\n      \"Insufficient unlocked balance to withdraw amount\"\n    );\n    totalWithdrawn = totalWithdrawn.add(amount);\n    beneficiary.transfer(amount);\n    if (getRemainingTotalBalance() == 0) {\n      selfdestruct(refundAddress);\n    }\n  }\n\n  /**\n   * @notice Refund the releaseOwner and beneficiary after the release schedule has been revoked.\n   */\n  function refundAndFinalize() external nonReentrant onlyReleaseOwnerAndRevoked {\n    require(getRemainingLockedBalance() == 0, \"Total gold balance must be unlocked\");\n    uint256 beneficiaryAmount = revocationInfo.releasedBalanceAtRevoke.sub(totalWithdrawn);\n    beneficiary.transfer(beneficiaryAmount);\n    uint256 revokerAmount = getRemainingUnlockedBalance();\n    refundAddress.transfer(revokerAmount);\n    selfdestruct(refundAddress);\n  }\n\n  /**\n   * @notice Revoke the future release schedule.\n   */\n  function revoke() external nonReentrant onlyReleaseOwner onlyRevocable {\n    require(!isRevoked(), \"Release schedule instance must not already be revoked\");\n    revocationInfo.revokeTime = block.timestamp;\n    revocationInfo.releasedBalanceAtRevoke = getCurrentReleasedTotalAmount();\n    emit ReleaseScheduleRevoked(revocationInfo.revokeTime, revocationInfo.releasedBalanceAtRevoke);\n  }\n\n  /**\n   * @notice Calculates the total balance of the release schedule instance including withdrawals.\n   * @return The total released instance gold balance.\n   * @dev The returned amount may vary over time due to locked gold rewards.\n   */\n  function getTotalBalance() public view returns (uint256) {\n    return getRemainingUnlockedBalance().add(getRemainingLockedBalance()).add(totalWithdrawn);\n  }\n\n  /**\n   * @notice Calculates the sum of locked and unlocked gold in the release schedule instance.\n   * @return The remaining total released instance gold balance.\n   * @dev The returned amount may vary over time due to locked gold rewards.\n   */\n  function getRemainingTotalBalance() public view returns (uint256) {\n    return getRemainingUnlockedBalance().add(getRemainingLockedBalance());\n  }\n\n  /**\n   * @notice Calculates remaining unlocked gold balance in the release schedule instance.\n   * @return The available unlocked release schedule instance gold balance.\n   */\n  function getRemainingUnlockedBalance() public view returns (uint256) {\n    return address(this).balance;\n  }\n\n  /**\n   * @notice Calculates remaining locked gold balance in the release schedule instance.\n   * @return The remaining locked gold of the release schedule instance.\n   * @dev The returned amount may vary over time due to locked gold rewards.\n   */\n  function getRemainingLockedBalance() public view returns (uint256) {\n    return getLockedGold().getAccountTotalLockedGold(address(this));\n  }\n\n  /**\n   * @dev Calculates the total amount that has already released up to now.\n   * @return The already released amount up to the point of call.\n   * @dev The returned amount may vary over time due to locked gold rewards.\n   */\n  function getCurrentReleasedTotalAmount() public view returns (uint256) {\n    if (block.timestamp < releaseSchedule.releaseCliff || !liquidityProvisionMet) {\n      return 0;\n    }\n    uint256 totalBalance = getTotalBalance();\n\n    if (\n      block.timestamp >=\n      releaseSchedule.releaseStartTime.add(\n        releaseSchedule.numReleasePeriods.mul(releaseSchedule.releasePeriod)\n      )\n    ) {\n      return totalBalance;\n    }\n\n    uint256 timeSinceStart = block.timestamp.sub(releaseSchedule.releaseStartTime);\n    uint256 periodsSinceStart = timeSinceStart.div(releaseSchedule.releasePeriod);\n    return totalBalance.mul(periodsSinceStart).div(releaseSchedule.numReleasePeriods);\n  }\n\n  /**\n   * @notice A wrapper function for the lock gold method.\n   * @param value The value of gold to be locked.\n   */\n  function lockGold(uint256 value) external nonReentrant onlyBeneficiaryAndNotRevoked {\n    getLockedGold().lock.gas(gasleft()).value(value)();\n  }\n\n  /**\n   * @notice A wrapper function for the unlock gold method function.\n   * @param value The value of gold to be unlocked for the release schedule instance.\n   */\n  function unlockGold(uint256 value) external nonReentrant onlyWhenInProperState {\n    getLockedGold().unlock(value);\n  }\n\n  /**\n   * @notice A wrapper function for the relock locked gold method function.\n   * @param index The index of the pending locked gold withdrawal.\n   * @param value The value of gold to be relocked for the release schedule instance.\n   */\n  function relockGold(uint256 index, uint256 value)\n    external\n    nonReentrant\n    onlyBeneficiaryAndNotRevoked\n  {\n    getLockedGold().relock(index, value);\n  }\n\n  /**\n   * @notice A wrapper function for the withdraw locked gold method function.\n   * @param index The index of the pending locked gold withdrawal.\n   * @dev The amount shall be withdrawn back to the release schedule instance.\n   */\n  function withdrawLockedGold(uint256 index) external nonReentrant onlyWhenInProperState {\n    getLockedGold().withdraw(index);\n  }\n\n  /**\n   * @notice A wrapper function for the authorize vote signer account method.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev The v,r and s signature should be a signed message by the beneficiary\n   *      encrypting the authorized address.\n   */\n  function authorizeVoteSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n    onlyCanVote\n    onlyWhenInProperState\n  {\n    getAccounts().authorizeVoteSigner(signer, v, r, s);\n  }\n\n  /**\n   * @notice A wrapper function for the authorize validator signer account method.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev The v,r and s signature should be a signed message by the beneficiary\n   *      encrypting the authorized address.\n   */\n  function authorizeValidatorSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n    onlyCanValidate\n    onlyWhenInProperState\n  {\n    getAccounts().authorizeValidatorSigner(signer, v, r, s);\n  }\n\n  /**\n   * @notice A wrapper function for the authorize attestation signer account method.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev The v,r and s signature should be a signed message by the beneficiary\n   *      encrypting the authorized address.\n   */\n  function authorizeAttestationSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n    onlyCanValidate\n    onlyWhenInProperState\n  {\n    getAccounts().authorizeAttestationSigner(signer, v, r, s);\n  }\n\n  /**\n   * @notice A convenience wrapper setter for the name, dataEncryptionKey\n   *         and wallet address for an account.\n   * @param name A string to set as the name of the account.\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   * @param walletAddress The wallet address to set for the account.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Wallet address can be zero. This means that the owner of the wallet\n   *      does not want to be paid directly without interaction, and instead wants users to\n   *      contact them, using the data encryption key, and arrange a payment.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender` (unless the wallet address\n   *      is 0x0 or msg.sender).\n   */\n  function setAccount(\n    string calldata name,\n    bytes calldata dataEncryptionKey,\n    address walletAddress,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external onlyBeneficiaryAndNotRevoked {\n    getAccounts().setAccount(name, dataEncryptionKey, walletAddress, v, r, s);\n  }\n\n  /**\n   * @notice A wrapper setter function for creating an account.\n   */\n  function createAccount() external onlyCanVote onlyBeneficiaryAndNotRevoked {\n    require(getAccounts().createAccount(), \"Account creation failed\");\n  }\n\n  /**\n   * @notice A wrapper setter function for the name of an account.\n   * @param name A string to set as the name of the account.\n   */\n  function setAccountName(string calldata name) external onlyBeneficiaryAndNotRevoked {\n    getAccounts().setName(name);\n  }\n\n  /**\n   * @notice A wrapper setter function for the wallet address of an account.\n   * @param walletAddress The wallet address to set for the account.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Wallet address can be zero. This means that the owner of the wallet\n   *      does not want to be paid directly without interaction, and instead wants users to\n   *      contact them, using the data encryption key, and arrange a payment.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender` (unless the wallet address\n   *      is 0x0 or msg.sender).\n   */\n  function setAccountWalletAddress(address walletAddress, uint8 v, bytes32 r, bytes32 s)\n    external\n    onlyBeneficiaryAndNotRevoked\n  {\n    getAccounts().setWalletAddress(walletAddress, v, r, s);\n  }\n\n  /**\n   * @notice A wrapper setter function for the for the data encryption key\n   *         and version of an account.\n   * @param dataEncryptionKey Secp256k1 public key for data encryption.\n   *                          Preferably compressed.\n   */\n  function setAccountDataEncryptionKey(bytes calldata dataEncryptionKey)\n    external\n    onlyBeneficiaryAndNotRevoked\n  {\n    getAccounts().setAccountDataEncryptionKey(dataEncryptionKey);\n  }\n\n  /**\n   * @notice A wrapper setter function for the metadata of an account.\n   * @param metadataURL The URL to access the metadata..\n   */\n  function setAccountMetadataURL(string calldata metadataURL)\n    external\n    onlyBeneficiaryAndNotRevoked\n  {\n    getAccounts().setMetadataURL(metadataURL);\n  }\n\n  /**\n   * @notice Revokes `value` active votes for `group`.\n   * @param group The validator group to revoke votes from.\n   * @param value The number of votes to revoke.\n   * @param lesser The group receiving fewer votes than the group for which the vote was revoked,\n   *               or 0 if that group has the fewest votes of any validator group.\n   * @param greater The group receiving more votes than the group for which the vote was revoked,\n   *               or 0 if that group has the most votes of any validator group.\n   * @param index The index of the group in the account's voting list.\n   * @dev Fails if the account has not voted on a validator group.\n   */\n  function revokeActive(\n    address group,\n    uint256 value,\n    address lesser,\n    address greater,\n    uint256 index\n  ) external nonReentrant onlyWhenInProperState {\n    getElection().revokeActive(group, value, lesser, greater, index);\n  }\n\n  /**\n   * @notice Revokes `value` pending votes for `group`.\n   * @param group The validator group to revoke votes from.\n   * @param value The number of votes to revoke.\n   * @param lesser The group receiving fewer votes than the group for which the vote was revoked,\n   *               or 0 if that group has the fewest votes of any validator group.\n   * @param greater The group receiving more votes than the group for which the vote was revoked,\n   *                or 0 if that group has the most votes of any validator group.\n   * @param index The index of the group in the account's voting list.\n   * @dev Fails if the account has not voted on a validator group.\n   */\n  function revokePending(\n    address group,\n    uint256 value,\n    address lesser,\n    address greater,\n    uint256 index\n  ) external nonReentrant onlyWhenInProperState {\n    getElection().revokePending(group, value, lesser, greater, index);\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/governance/ReleaseGold.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\nimport \"./interfaces/IReleaseGold.sol\";\nimport \"../common/FixidityLib.sol\";\n\nimport \"../common/Initializable.sol\";\nimport \"../common/UsingRegistry.sol\";\n\ncontract ReleaseGold is UsingRegistry, ReentrancyGuard, IReleaseGold, Initializable {\n  using SafeMath for uint256;\n  using FixidityLib for FixidityLib.Fraction;\n\n  struct ReleaseSchedule {\n    // Timestamp (in UNIX time) that releasing begins.\n    uint256 releaseStartTime;\n    // Timestamp (in UNIX time) of the releasing cliff.\n    uint256 releaseCliff;\n    // Number of release periods.\n    uint256 numReleasePeriods;\n    // Duration (in seconds) of one period.\n    uint256 releasePeriod;\n    // Amount that is to be released per period.\n    uint256 amountReleasedPerPeriod;\n  }\n\n  struct RevocationInfo {\n    // Indicates if the contract is revocable.\n    bool revocable;\n    // Released gold instance balance at time of revocation.\n    uint256 releasedBalanceAtRevoke;\n    // The time at which the release schedule was revoked.\n    uint256 revokeTime;\n  }\n\n  uint256 internal constant MAX_UINT = 0xffffffffffffffffffffffffffffffff;\n\n  // Beneficiary of the Celo Gold released in this contract.\n  address payable public beneficiary;\n\n  // Address capable of (where applicable) revoking, setting the liquidity provision, and\n  // adjusting the maximum withdrawal amount.\n  address public releaseOwner;\n\n  // Address that receives refunded gold if contract is revoked.\n  address payable public refundAddress;\n\n  // Indicates how much of the released amount has been withdrawn so far.\n  uint256 public totalWithdrawn;\n\n  // Indicates the maximum gold currently available for distribution, regardless of schedule.\n  // Only settable by the `releaseOwner` address, subject to grant conditions.\n  uint256 public maxDistribution;\n\n  // Indicates if the schedule contains a liquidity provision that has not yet been met.\n  // Only settable by the `releaseOwner` address, subject to grant conditions.\n  bool public liquidityProvisionMet;\n\n  // Indicates if this schedule's unreleased gold can be used for validating.\n  bool public canValidate;\n\n  // Indicates if this schedule's unreleased gold can be used for voting.\n  bool public canVote;\n\n  // Public struct housing params pertaining to releasing gold.\n  ReleaseSchedule public releaseSchedule;\n\n  // Public struct housing params pertaining to revocation.\n  RevocationInfo public revocationInfo;\n\n  event ReleaseGoldInstanceCreated(address indexed beneficiary, address indexed atAddress);\n  event ReleaseScheduleRevoked(uint256 revokeTimestamp, uint256 releasedBalanceAtRevoke);\n  event DistributionLimitSet(address indexed beneficiary, uint256 maxDistribution);\n  event LiquidityProvisionSet(address indexed beneficiary);\n  event BeneficiarySet(address indexed beneficiary);\n\n  modifier onlyReleaseOwner() {\n    require(msg.sender == releaseOwner, \"Sender must be the registered releaseOwner address\");\n    _;\n  }\n\n  modifier onlyBeneficiary() {\n    require(msg.sender == beneficiary, \"Sender must be the registered beneficiary address\");\n    _;\n  }\n\n  modifier onlyRevoked() {\n    require(isRevoked(), \"Release schedule instance must have already been revoked\");\n    _;\n  }\n\n  modifier onlyRevocable() {\n    require(revocationInfo.revocable, \"Release schedule instance must be revocable\");\n    _;\n  }\n\n  modifier onlyCanVote() {\n    require(canVote, \"Release Gold contract does not have permission to vote\");\n    _;\n  }\n\n  modifier onlyCanValidate() {\n    require(canValidate, \"Release Gold contract does not have permission to validate\");\n    _;\n  }\n\n  modifier onlyReleaseOwnerAndRevoked() {\n    require(\n      msg.sender == releaseOwner && isRevoked(),\n      \"Sender must be the releaseOwner and state must be revoked\"\n    );\n    _;\n  }\n\n  modifier onlyBeneficiaryAndNotRevoked() {\n    require(\n      msg.sender == beneficiary && !isRevoked(),\n      \"Sender must be the beneficiary and state must not be revoked\"\n    );\n    _;\n  }\n\n  modifier onlyWhenInProperState() {\n    bool isRevoked = isRevoked();\n    require(\n      (msg.sender == releaseOwner && isRevoked) || (msg.sender == beneficiary && !isRevoked),\n      \"Must be called by releaseOwner when revoked or beneficiary before revocation\"\n    );\n    _;\n  }\n\n  function() external payable {} // solhint-disable no-empty-blocks\n\n  /**\n   * @notice A constructor for initialising a new instance of a Releasing Schedule contract.\n   * @param releaseStartTime The time (in Unix time) at which point releasing starts.\n   * @param releaseCliffTime Duration (in seconds) after `releaseStartTime` of the golds' cliff.\n   * @param numReleasePeriods Number of releasing periods.\n   * @param releasePeriod Duration (in seconds) of each release period.\n   * @param amountReleasedPerPeriod The released gold amount per period.\n   * @param revocable Whether the release schedule is revocable or not.\n   * @param _beneficiary Address of the beneficiary to whom released tokens are transferred.\n   * @param _releaseOwner Address capable of revoking, setting the liquidity provision\n   *                      and setting the withdrawal amount.\n   *                      0x0 if grant is not subject to these operations.\n   * @param _refundAddress Address that receives refunded funds if contract is revoked.\n   *                       0x0 if contract is not revocable.\n   * @param subjectToLiquidityProvision If this schedule is subject to a liquidity provision.\n   * @param initialDistributionRatio Amount in range [0, 1000] (3 significant figures)\n   *                                 indicating % of total balance available for distribution.\n   * @param _canValidate If this schedule's gold can be used for validating.\n   * @param _canVote If this schedule's gold can be used for voting.\n   * @param registryAddress Address of the deployed contracts registry.\n   */\n  function initialize(\n    uint256 releaseStartTime,\n    uint256 releaseCliffTime,\n    uint256 numReleasePeriods,\n    uint256 releasePeriod,\n    uint256 amountReleasedPerPeriod,\n    bool revocable,\n    address payable _beneficiary,\n    address _releaseOwner,\n    address payable _refundAddress,\n    bool subjectToLiquidityProvision,\n    uint256 initialDistributionRatio,\n    bool _canValidate,\n    bool _canVote,\n    address registryAddress\n  ) external initializer {\n    _transferOwnership(msg.sender);\n    releaseSchedule.numReleasePeriods = numReleasePeriods;\n    releaseSchedule.amountReleasedPerPeriod = amountReleasedPerPeriod;\n    releaseSchedule.releasePeriod = releasePeriod;\n    releaseSchedule.releaseCliff = releaseStartTime.add(releaseCliffTime);\n    releaseSchedule.releaseStartTime = releaseStartTime;\n    require(releaseSchedule.numReleasePeriods >= 1, \"There must be at least one releasing period\");\n    require(\n      releaseSchedule.amountReleasedPerPeriod > 0,\n      \"The released amount per period must be greater than zero\"\n    );\n    require(\n      _beneficiary != address(0),\n      \"The release schedule beneficiary cannot be the zero addresss\"\n    );\n    require(registryAddress != address(0), \"The registry address cannot be the zero address\");\n    require(\n      releaseSchedule.releaseStartTime.add(\n        releaseSchedule.numReleasePeriods.mul(releaseSchedule.releasePeriod)\n      ) >\n        block.timestamp,\n      \"Release schedule end time must be in the future\"\n    );\n    require(\n      address(this).balance ==\n        releaseSchedule.amountReleasedPerPeriod.mul(releaseSchedule.numReleasePeriods),\n      \"Contract balance must equal the entire grant amount\"\n    );\n    require(!(revocable && _canValidate), \"Revocable contracts cannot validate\");\n    require(initialDistributionRatio <= 1000, \"Initial distribution ratio out of bounds\");\n    require(\n      (revocable && _refundAddress != address(0)) || (!revocable && _refundAddress == address(0)),\n      \"If contract is revocable there must be an address to refund\"\n    );\n\n    setRegistry(registryAddress);\n    _setBeneficiary(_beneficiary);\n    revocationInfo.revocable = revocable;\n    releaseOwner = _releaseOwner;\n    refundAddress = _refundAddress;\n\n    if (initialDistributionRatio < 1000) {\n      // Cannot use `getTotalBalance()` here because the factory has not yet sent the gold.\n      uint256 totalGrant = releaseSchedule.amountReleasedPerPeriod.mul(\n        releaseSchedule.numReleasePeriods\n      );\n      // Initial ratio is expressed to 3 significant figures: [0"
    }
  ]
}