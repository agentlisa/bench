{
  "Title": "[H-02] Wrong usage of `positionId` in `ConcentratedLiquidityPoolManager`",
  "Content": "_Submitted by broccoli, also found by 0xsanson, cmichel, hickuphh3, and pauliax_\n\n#### Impact\nIn the `subscribe` function of `ConcentratedLiquidityPoolManager`, the `incentive` to subscribed is determined as follows:\n\n```solidity\nIncentive memory incentive = incentives[pool][positionId];\n```\n\nHowever, `positionId` should be `incentiveId`, a counter that increases by one whenever a new incentive is added to the pool. The usage of `positionId` could cause the wrong incentive to be used, and in general, the incentive is not found, and the transaction reverts (the condition `block.timestamp < incentive.endTime` is not met). The `getReward` and `claimReward` functions have the bug of misusing `positionId` as the index of incentives.\n\n#### Proof of Concept\nReferenced code:\n- [ConcentratedLiquidityPoolManager.sol#L68](https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L68)\n- [ConcentratedLiquidityPoolManager.sol#L87](https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L87)\n- [ConcentratedLiquidityPoolManager.sol#L105](https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L105)\n\n#### Recommended Mitigation Steps\nChange `positionId` to `incentiveId` in the referenced lines of code.\n\n**[sarangparikh22 (Sushi) confirmed but disagreed with severity](https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/86#issuecomment-940846279)**\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2021-09-sushitrident-2",
  "Code": [
    {
      "filename": "contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"../../interfaces/IConcentratedLiquidityPool.sol\";\nimport \"./ConcentratedLiquidityPosition.sol\";\n\n/// @notice Trident Concentrated Liquidity Pool periphery contract that combines non-fungible position management and staking.\ncontract ConcentratedLiquidityPoolManager is ConcentratedLiquidityPosition {\n    event AddIncentive(IConcentratedLiquidityPool indexed pool, Incentive indexed incentive);\n    event ReclaimIncentive(IConcentratedLiquidityPool indexed pool, uint256 indexed incentiveId);\n    event Subscribe(uint256 indexed positionId, uint256 indexed incentiveId);\n    event ClaimReward(uint256 indexed positionId, uint256 indexed incentiveId, address indexed recipient);\n\n    struct Incentive {\n        address owner;\n        address token;\n        uint256 rewardsUnclaimed;\n        uint160 secondsClaimed; // @dev x128.\n        uint32 startTime;\n        uint32 endTime;\n        uint32 expiry;\n    }\n\n    struct Stake {\n        uint160 secondsInsideLast; // @dev x128.\n        bool initialized;\n    }\n\n    mapping(IConcentratedLiquidityPool => uint256) public incentiveCount;\n    mapping(IConcentratedLiquidityPool => mapping(uint256 => Incentive)) public incentives;\n    mapping(uint256 => mapping(uint256 => Stake)) public stakes;\n\n    constructor(address wETH, address _masterDeployer) ConcentratedLiquidityPosition(wETH, _masterDeployer) {}\n\n    function addIncentive(IConcentratedLiquidityPool pool, Incentive memory incentive) public {\n        uint32 current = uint32(block.timestamp);\n        require(current <= incentive.startTime, \"ALREADY_STARTED\");\n        require(current <= incentive.endTime, \"ALREADY_ENDED\");\n        require(incentive.startTime < incentive.endTime, \"START_PAST_END\");\n        require(incentive.endTime + 5 weeks < incentive.expiry, \"END_PAST_BUFFER\");\n        require(incentive.rewardsUnclaimed != 0, \"NO_REWARDS\");\n        incentives[pool][incentiveCount[pool]++] = incentive;\n        _transfer(incentive.token, msg.sender, address(this), incentive.rewardsUnclaimed, false);\n        emit AddIncentive(pool, incentive);\n    }\n\n    /// @dev Withdraws any unclaimed incentive rewards.\n    function reclaimIncentive(\n        IConcentratedLiquidityPool pool,\n        uint256 incentiveId,\n        uint256 amount,\n        address receiver,\n        bool unwrapBento\n    ) public {\n        Incentive storage incentive = incentives[pool][incentiveId];\n        require(incentive.owner == msg.sender, \"NOT_OWNER\");\n        require(incentive.expiry < block.timestamp, \"EXPIRED\");\n        require(incentive.rewardsUnclaimed >= amount, \"ALREADY_CLAIMED\");\n        _transfer(incentive.token, address(this), receiver, amount, unwrapBento);\n        emit ReclaimIncentive(pool, incentiveId);\n    }\n\n    /// @dev Subscribes a non-fungible position token to an incentive.\n    function subscribe(uint256 positionId, uint256 incentiveId) public {\n        Position memory position = positions[positionId];\n        IConcentratedLiquidityPool pool = position.pool;\n        Incentive memory incentive = incentives[pool][positionId];\n        Stake storage stake = stakes[positionId][incentiveId];\n        require(position.liquidity != 0, \"INACTIVE\");\n        require(stake.secondsInsideLast == 0, \"SUBSCRIBED\");\n        require(incentiveId <= incentiveCount[pool], \"NOT_INCENTIVE\");\n        require(block.timestamp > incentive.startTime && block.timestamp < incentive.endTime, \"TIMED_OUT\");\n        stakes[positionId][incentiveId] = Stake(uint160(pool.rangeSecondsInside(position.lower, position.upper)), true);\n        emit Subscribe(positionId, incentiveId);\n    }\n\n    function claimReward(\n        uint256 positionId,\n        uint256 incentiveId,\n        address recipient,\n        bool unwrapBento\n    ) public {\n        require(ownerOf[positionId] == msg.sender, \"OWNER\");\n        Position memory position = positions[positionId];\n        IConcentratedLiquidityPool pool = position.pool;\n        Incentive storage incentive = incentives[position.pool][positionId];\n        Stake storage stake = stakes[positionId][incentiveId];\n        require(stake.initialized, \"UNINITIALIZED\");\n        uint256 secondsPerLiquidityInside = pool.rangeSecondsInside(position.lower, position.upper) - stake.secondsInsideLast;\n        uint256 secondsInside = secondsPerLiquidityInside * position.liquidity;\n        uint256 maxTime = incentive.endTime < block.timestamp ? block.timestamp : incentive.endTime;\n        uint256 secondsUnclaimed = (maxTime - incentive.startTime) << (128 - incentive.secondsClaimed);\n        uint256 rewards = (incentive.rewardsUnclaimed * secondsInside) / secondsUnclaimed;\n        incentive.rewardsUnclaimed -= rewards;\n        incentive.secondsClaimed += uint160(secondsInside);\n        stake.secondsInsideLast += uint160(secondsPerLiquidityInside);\n        _transfer(incentive.token, address(this), recipient, rewards, unwrapBento);\n        emit ClaimReward(positionId, incentiveId, recipient);\n    }\n\n    function getReward(uint256 positionId, uint256 incentiveId) public view returns (uint256 rewards, uint256 secondsInside) {\n        Position memory position = positions[positionId];\n        IConcentratedLiquidityPool pool = position.pool;\n        Incentive memory incentive = incentives[pool][positionId];\n        Stake memory stake = stakes[positionId][incentiveId];\n        if (stake.initialized) {\n            secondsInside = (pool.rangeSecondsInside(position.lower, position.upper) - stake.secondsInsideLast) * position.liquidity;\n            uint256 maxTime = incentive.endTime < block.timestamp ? block.timestamp : incentive.endTime;\n            uint256 secondsUnclaimed = (maxTime - incentive.startTime) << (128 - incentive.secondsClaimed);\n            rewards = (incentive.rewardsUnclaimed * secondsInside) / secondsUnclaimed;\n        }\n    }\n}"
    },
    {
      "filename": "contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"../../interfaces/IConcentratedLiquidityPool.sol\";\nimport \"./ConcentratedLiquidityPosition.sol\";\n\n/// @notice Trident Concentrated Liquidity Pool periphery contract that combines non-fungible position management and staking.\ncontract ConcentratedLiquidityPoolManager is ConcentratedLiquidityPosition {\n    event AddIncentive(IConcentratedLiquidityPool indexed pool, Incentive indexed incentive);\n    event ReclaimIncentive(IConcentratedLiquidityPool indexed pool, uint256 indexed incentiveId);\n    event Subscribe(uint256 indexed positionId, uint256 indexed incentiveId);\n    event ClaimReward(uint256 indexed positionId, uint256 indexed incentiveId, address indexed recipient);\n\n    struct Incentive {\n        address owner;\n        address token;\n        uint256 rewardsUnclaimed;\n        uint160 secondsClaimed; // @dev x128.\n        uint32 startTime;\n        uint32 endTime;\n        uint32 expiry;\n    }\n\n    struct Stake {\n        uint160 secondsInsideLast; // @dev x128.\n        bool initialized;\n    }\n\n    mapping(IConcentratedLiquidityPool => uint256) public incentiveCount;\n    mapping(IConcentratedLiquidityPool => mapping(uint256 => Incentive)) public incentives;\n    mapping(uint256 => mapping(uint256 => Stake)) public stakes;\n\n    constructor(address wETH, address _masterDeployer) ConcentratedLiquidityPosition(wETH, _masterDeployer) {}\n\n    function addIncentive(IConcentratedLiquidityPool pool, Incentive memory incentive) public {\n        uint32 current = uint32(block.timestamp);\n        require(current <= incentive.startTime, \"ALREADY_STARTED\");\n        require(current <= incentive.endTime, \"ALREADY_ENDED\");\n        require(incentive.startTime < incentive.endTime, \"START_PAST_END\");\n        require(incentive.endTime + 5 weeks < incentive.expiry, \"END_PAST_BUFFER\");\n        require(incentive.rewardsUnclaimed != 0, \"NO_REWARDS\");\n        incentives[pool][incentiveCount[pool]++] = incentive;\n        _transfer(incentive.token, msg.sender, address(this), incentive.rewardsUnclaimed, false);\n        emit AddIncentive(pool, incentive);\n    }\n\n    /// @dev Withdraws any unclaimed incentive rewards.\n    function reclaimIncentive(\n        IConcentratedLiquidityPool pool,\n        uint256 incentiveId,\n        uint256 amount,\n        address receiver,\n        bool unwrapBento\n    ) public {\n        Incentive storage incentive = incentives[pool][incentiveId];\n        require(incentive.owner == msg.sender, \"NOT_OWNER\");\n        require(incentive.expiry < block.timestamp, \"EXPIRED\");\n        require(incentive.rewardsUnclaimed >= amount, \"ALREADY_CLAIMED\");\n        _transfer(incentive.token, address(this), receiver, amount, unwrapBento);\n        emit ReclaimIncentive(pool, incentiveId);\n    }\n\n    /// @dev Subscribes a non-fungible position token to an incentive.\n    function subscribe(uint256 positionId, uint256 incentiveId) public {\n        Position memory position = positions[positionId];\n        IConcentratedLiquidityPool pool = position.pool;\n        Incentive memory incentive = incentives[pool][positionId];\n        Stake storage stake = stakes[positionId][incentiveId];\n        require(position.liquidity != 0, \"INACTIVE\");\n        require(stake.secondsInsideLast == 0, \"SUBSCRIBED\");\n        require(incentiveId <= incentiveCount[pool], \"NOT_INCENTIVE\");\n        require(block.timestamp > incentive.startTime && block.timestamp < incentive.endTime, \"TIMED_OUT\");\n        stakes[positionId][incentiveId] = Stake(uint160(pool.rangeSecondsInside(position.lower, position.upper)), true);\n        emit Subscribe(positionId, incentiveId);\n    }\n\n    function claimReward(\n        uint256 positionId,\n        uint256 incentiveId,\n        address recipient,\n        bool unwrapBento\n    ) public {\n        require(ownerOf[positionId] == msg.sender, \"OWNER\");\n        Position memory position = positions[positionId];\n        IConcentratedLiquidityPool pool = position.pool;\n        Incentive storage incentive = incentives[position.pool][positionId];\n        Stake storage stake = stakes[positionId][incentiveId];\n        require(stake.initialized, \"UNINITIALIZED\");\n        uint256 secondsPerLiquidityInside = pool.rangeSecondsInside(position.lower, position.upper) - stake.secondsInsideLast;\n        uint256 secondsInside = secondsPerLiquidityInside * position.liquidity;\n        uint256 maxTime = incentive.endTime < block.timestamp ? block.timestamp : incentive.endTime;\n        uint256 secondsUnclaimed = (maxTime - incentive.startTime) << (128 - incentive.secondsClaimed);\n        uint256 rewards = (incentive.rewardsUnclaimed * secondsInside) / secondsUnclaimed;\n        incentive.rewardsUnclaimed -= rewards;\n        incentive.secondsClaimed += uint160(secondsInside);\n        stake.secondsInsideLast += uint160(secondsPerLiquidityInside);\n        _transfer(incentive.token, address(this), recipient, rewards, unwrapBento);\n        emit ClaimReward(positionId, incentiveId, recipient);\n    }\n\n    function getReward(uint256 positionId, uint256 incentiveId) public view returns (uint256 rewards, uint256 secondsInside) {\n        Position memory position = positions[positionId];\n        IConcentratedLiquidityPool pool = position.pool;\n        Incentive memory incentive = incentives[pool][positionId];\n        Stake memory stake = stakes[positionId][incentiveId];\n        if (stake.initialized) {\n            secondsInside = (pool.rangeSecondsInside(position.lower, position.upper) - stake.secondsInsideLast) * position.liquidity;\n            uint256 maxTime = incentive.endTime < block.timestamp ? block.timestamp : incentive.endTime;\n            uint256 secondsUnclaimed = (maxTime - incentive.startTime) << (128 - incentive.secondsClaimed);\n            rewards = (incentive.rewardsUnclaimed * secondsInside) / secondsUnclaimed;\n        }\n    }\n}"
    },
    {
      "filename": "contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"../../interfaces/IConcentratedLiquidityPool.sol\";\nimport \"./ConcentratedLiquidityPosition.sol\";\n\n/// @notice Trident Concentrated Liquidity Pool periphery contract that combines non-fungible position management and staking.\ncontract ConcentratedLiquidityPoolManager is ConcentratedLiquidityPosition {\n    event AddIncentive(IConcentratedLiquidityPool indexed pool, Incentive indexed incentive);\n    event ReclaimIncentive(IConcentratedLiquidityPool indexed pool, uint256 indexed incentiveId);\n    event Subscribe(uint256 indexed positionId, uint256 indexed incentiveId);\n    event ClaimReward(uint256 indexed positionId, uint256 indexed incentiveId, address indexed recipient);\n\n    struct Incentive {\n        address owner;\n        address token;\n        uint256 rewardsUnclaimed;\n        uint160 secondsClaimed; // @dev x128.\n        uint32 startTime;\n        uint32 endTime;\n        uint32 expiry;\n    }\n\n    struct Stake {\n        uint160 secondsInsideLast; // @dev x128.\n        bool initialized;\n    }\n\n    mapping(IConcentratedLiquidityPool => uint256) public incentiveCount;\n    mapping(IConcentratedLiquidityPool => mapping(uint256 => Incentive)) public incentives;\n    mapping(uint256 => mapping(uint256 => Stake)) public stakes;\n\n    constructor(address wETH, address _masterDeployer) ConcentratedLiquidityPosition(wETH, _masterDeployer) {}\n\n    function addIncentive(IConcentratedLiquidityPool pool, Incentive memory incentive) public {\n        uint32 current = uint32(block.timestamp);\n        require(current <= incentive.startTime, \"ALREADY_STARTED\");\n        require(current <= incentive.endTime, \"ALREADY_ENDED\");\n        require(incentive.startTime < incentive.endTime, \"START_PAST_END\");\n        require(incentive.endTime + 5 weeks < incentive.expiry, \"END_PAST_BUFFER\");\n        require(incentive.rewardsUnclaimed != 0, \"NO_REWARDS\");\n        incentives[pool][incentiveCount[pool]++] = incentive;\n        _transfer(incentive.token, msg.sender, address(this), incentive.rewardsUnclaimed, false);\n        emit AddIncentive(pool, incentive);\n    }\n\n    /// @dev Withdraws any unclaimed incentive rewards.\n    function reclaimIncentive(\n        IConcentratedLiquidityPool pool,\n        uint256 incentiveId,\n        uint256 amount,\n        address receiver,\n        bool unwrapBento\n    ) public {\n        Incentive storage incentive = incentives[pool][incentiveId];\n        require(incentive.owner == msg.sender, \"NOT_OWNER\");\n        require(incentive.expiry < block.timestamp, \"EXPIRED\");\n        require(incentive.rewardsUnclaimed >= amount, \"ALREADY_CLAIMED\");\n        _transfer(incentive.token, address(this), receiver, amount, unwrapBento);\n        emit ReclaimIncentive(pool, incentiveId);\n    }\n\n    /// @dev Subscribes a non-fungible position token to an incentive.\n    function subscribe(uint256 positionId, uint256 incentiveId) public {\n        Position memory position = positions[positionId];\n        IConcentratedLiquidityPool pool = position.pool;\n        Incentive memory incentive = incentives[pool][positionId];\n        Stake storage stake = stakes[positionId][incentiveId];\n        require(position.liquidity != 0, \"INACTIVE\");\n        require(stake.secondsInsideLast == 0, \"SUBSCRIBED\");\n        require(incentiveId <= incentiveCount[pool], \"NOT_INCENTIVE\");\n        require(block.timestamp > incentive.startTime && block.timestamp < incentive.endTime, \"TIMED_OUT\");\n        stakes[positionId][incentiveId] = Stake(uint160(pool.rangeSecondsInside(position.lower, position.upper)), true);\n        emit Subscribe(positionId, incentiveId);\n    }\n\n    function claimReward(\n        uint256 positionId,\n        uint256 incentiveId,\n        address recipient,\n        bool unwrapBento\n    ) public {\n        require(ownerOf[positionId] == msg.sender, \"OWNER\");\n        Position memory position = positions[positionId];\n        IConcentratedLiquidityPool pool = position.pool;\n        Incentive storage incentive = incentives[position.pool][positionId];\n        Stake storage stake = stakes[positionId][incentiveId];\n        require(stake.initialized, \"UNINITIALIZED\");\n        uint256 secondsPerLiquidityInside = pool.rangeSecondsInside(position.lower, position.upper) - stake.secondsInsideLast;\n        uint256 secondsInside = secondsPerLiquidityInside * position.liquidity;\n        uint256 maxTime = incentive.endTime < block.timestamp ? block.timestamp : incentive.endTime;\n        uint256 secondsUnclaimed = (maxTime - incentive.startTime) << (128 - incentive.secondsClaimed);\n        uint256 rewards = (incentive.rewardsUnclaimed * secondsInside) / secondsUnclaimed;\n        incentive.rewardsUnclaimed -= rewards;\n        incentive.secondsClaimed += uint160(secondsInside);\n        stake.secondsInsideLast += uint160(secondsPerLiquidityInside);\n        _transfer(incentive.token, address(this), recipient, rewards, unwrapBento);\n        emit ClaimReward(positionId, incentiveId, recipient);\n    }\n\n    function getReward(uint256 positionId, uint256 incentiveId) public view returns (uint256 rewards, uint256 secondsInside) {\n        Position memory position = positions[positionId];\n        IConcentratedLiquidityPool pool = position.pool;\n        Incentive memory incentive = incentives[pool][positionId];\n        Stake memory stake = stakes[positionId][incentiveId];\n        if (stake.initialized) {\n            secondsInside = (pool.rangeSecondsInside(position.lower, position.upper) - stake.secondsInsideLast) * position.liquidity;\n            uint256 maxTime = incentive.endTime < block.timestamp ? block.timestamp : incentive.endTime;\n            uint256 secondsUnclaimed = (maxTime - incentive.startTime) << (128 - incentive.secondsClaimed);\n            rewards = (incentive.rewardsUnclaimed * secondsInside) / secondsUnclaimed;\n        }\n    }\n}"
    }
  ]
}