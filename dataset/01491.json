{
  "Title": "M-10: Drained oracle fees from market by depositing and withdrawing immediately without triggering settlement fees",
  "Content": "# Issue M-10: Drained oracle fees from market by depositing and withdrawing immediately without triggering settlement fees \n\nSource: https://github.com/sherlock-audit/2023-07-perennial-judging/issues/153 \n\n## Found by \n0x73696d616f\nThe oracle fee can be drained, as requests can be made without paying fees by depositing and withdrawing immediately, leading to theft of yield to the `keeper` and potentially a DoS in the system. The DoS happens because the oracle version must be increased to trigger the settlements ([`global`](https://github.com/sherlock-audit/2023-07-perennial/blob/main/perennial-v2/packages/perennial/contracts/Market.sol#L336) and [`local`](https://github.com/sherlock-audit/2023-07-perennial/blob/main/perennial-v2/packages/perennial/contracts/Market.sol#L342)), such that a `keeper` amount must be available prior to the new version oracle request. This `keeper` amount would not be available as attackers would have drained the fees before any settlement occurs.\n\n## Vulnerability Detail\n`Market` advances in the id of the [`Global`](https://github.com/sherlock-audit/2023-07-perennial/blob/main/perennial-v2/packages/perennial/contracts/Market.sol#L257-L260) and [`Local`](https://github.com/sherlock-audit/2023-07-perennial/blob/main/perennial-v2/packages/perennial/contracts/Market.sol#L261-L264) states by fetching `latestVersion` and `currentTimestamp` from the oracle, increasing it if there is an update. \n\nWhen a new position is updated by calling `update()`, if the order is [not empty](https://github.com/sherlock-audit/2023-07-perennial/blob/main/perennial-v2/packages/perennial/contracts/Market.sol#L284) (when there is a modification in the `maker` , `long` or `short` amounts), it requests a new version from the oracle. This means that users can trigger a request with the smallest position possible (1), not paying any fees.\n\nFetching a price in the oracle is expensive, thus `Perennial` attributes an `oracleFee` to the oracle, which is then [fed](https://github.com/sherlock-audit/2023-07-perennial/blob/main/perennial-v2/packages/perennial-oracle/contracts/pyth/PythOracle.sol#L127) to the `keeper` for commiting prices in the oracle. Notice that anyone can be the `keeper`, the only requirement is to submit a [valid price](https://github.com/sherlock-audit/2023-07-perennial/blob/main/perennial-v2/packages/perennial-oracle/contracts/pyth/PythOracle.sol#L136) to the oracle.\n\nIn the oracle, the incentive is only paid if there was a [previous request](https://github.com/sherlock-audit/2023-07-perennial/blob/main/perennial-v2/packages/perennial-oracle/contracts/pyth/PythOracle.sol#L132), most likely from `Market` (can be any [`authorized`](https://github.com/sherlock-audit/2023-07-perennial/blob/main/perennial-v2/packages/perennial-oracle/contracts/pyth/PythOracle.sol#L77) entity). As the `oracleFee` is only increased on settlements, an oracle request can be triggered at any block (only [1 request per block](https://github.com/sherlock-audit/2023-07-perennial/blob/main/perennial-v2/packages/perennial-oracle/contracts/pyth/PythOracle.sol#L78-L80) is allowed) by depositing and withdrawing in the same block, without providing any settlement fee. \n\nThus, this mechanism can be exploited to give maximum profit to the `keeper`, which would force the protocol to manually add fees to the oracle or be DoSed (could be both).\n\n## Impact\nTheft of yield and protocol funds by abusing the `keeper` role and DoS of the `Market`.\n\n## Code Snippet\nAdded the following test to `Market.test.ts`, proving that the request can be triggered without paying any fees. The attacker would then proceed to commit a price to the oracle and get the fees (possible at every block), until there are no more fees in the `Market`. \n```solidity\nit.only('POC opens and closes the position to trigger an oracle request without paying any fee', async () => { \n  const dustCollateral = parse6decimal(\"100\");\n  const dustPosition = parse6decimal (\"0.000001\");\n  dsu.transferFrom.whenCalledWith(user.address, market.address, dustCollateral.mul(1e12)).returns(true)\n\n  await expect(market.connect(user).update(user.address, dustPosition, 0, 0, dustCollateral, false))\n    .to.emit(market, 'Updated')\n    .withArgs(user.address, ORACLE_VERSION_2.timestamp, dustPosition, 0, 0, dustCollateral, false)\n\n  expectLocalEq(await market.locals(user.address), {\n    currentId: 1,\n    latestId: 0,\n    collateral: dustCollateral,\n    reward: 0,\n    protection: 0,\n  })\n  expectPositionEq(await market.positions(user.address), {\n    ...DEFAULT_POSITION,\n    timestamp: ORACLE_VERSION_1.timestamp,\n  })\n  expectPositionEq(await market.pendingPositions(user.address, 1), {\n    ...DEFAULT_POSITION,\n    timestamp: ORACLE_VERSION_2.timestamp,\n    maker: dustPosition,\n    delta: dustCollateral,\n  })\n  expectGlobalEq(await market.global(), {\n    currentId: 1,\n    latestId: 0,\n    protocolFee: 0,\n    oracleFee: 0,\n    riskFee: 0,\n    donation: 0,\n  })\n  expectPositionEq(await market.position(), {\n    ...DEFAULT_POSITION,\n    timestamp: ORACLE_VERSION_1.timestamp,\n  })\n  expectPositionEq(await market.pendingPosition(1), {\n    ...DEFAULT_POSITION,\n    timestamp: ORACLE_VERSION_2.timestamp,\n    maker: dustPosition,\n  })\n  expectVersionEq(await market.versions(ORACLE_VERSION_1.timestamp), {\n    makerValue: { _value: 0 },\n    longValue: { _value: 0 },\n    shortValue: { _value: 0 },\n    makerReward: { _value: 0 },\n    longReward: { _value: 0 },\n    shortReward: { _value: 0 },\n  })\n\n  dsu.transfer.whenCalledWith(user.address, dustCollateral.mul(1e12)).returns(true)\n  await expect(market.connect(user).update(user.address, 0, 0, 0, dustCollateral.mul(-1), false))\n    .to.emit(market, 'Updated')\n    .withArgs(user.address, ORACLE_VERSION_2.timestamp, 0, 0, 0, dustCollateral.mul(-1), false)\n\n    expect(oracle.request).to.have.been.calledWith(user.address)\n})\n```\n\n## Tool used\nVscode, Hardhat, Manual Review\n\n## Recommendation\nWhitelist the keeper role to prevent malicious users from figuring out ways to profit from the incentive mechanism. Additionally, the whitelisted keppers could skip oracle requests if they don't contribute to settlements (when there are no orders to settle), to ensure that funds are always available.\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**__141345__** commented:\n> x\n\n**panprog** commented:\n> invalid because deposit will add pending keeper fees and minCollateral will ensure that at least minCollateral can not be withdrawn before position is closed\n\n\n\n**0x73696d616f**\n\nEscalate\nAs long as there are no new positions to settle and the oracle version/timestamp is not updated, it's possible to keep opening and closing positions at each block, triggering consecutive requests, without paying any fees to the protocol.\n\nThen, after a few requests are triggered or someone else either opens a position or commits a new price, the attacker can commit all the previous requests. The only requirement is that the publish time of the requests are within the `MIN_VALID_TIME_AFTER_VERSION` and `MAX_VALID_TIME_AFTER_VERSION` window.\n\nThis would pay the attacker the incentives and the profit depends on the specific math (considering the gas fees). Additionally, over a long enough period, it could drain the protocol of keeper fees, which would lead to DoS due to lack of fees to commit new prices.\n\nI tweaked the POC a bit to show how several requests can be made consecutively without paying any fees to the protocol. The positions are opened and closed in the `loop` (incrementing the block.timestamp at each iteration), triggering several requests. The next step would be to commit these requests in the oracle, but that should not require a POC.\n\n```solidity\nit.only('POC opens and closes the position to trigger an oracle request without paying any fee', async () => { \n  const dustCollateral = parse6decimal(\"100\");\n  const dustPosition = parse6decimal (\"0.000001\");\n\n  for (let i = 0; i < 5; i++) {\n    dsu.transferFrom.whenCalledWith(user.address, market.address, dustCollateral.mul(1e12)).returns(true)\n\n    await expect(market.connect(user).update(user.address, dustPosition, 0, 0, dustCollateral, false))\n      .to.emit(market, 'Updated')\n      .withArgs(user.address, ORACLE_VERSION_2.timestamp, dustPosition, 0, 0, dustCollateral, false)\n\n    expectLocalEq(await market.locals(user.address), {\n      currentId: 1,\n      latestId: 0,\n      collateral: dustCollateral,\n      reward: 0,\n      protection: 0,\n    })\n    expectPositionEq(await market.positions(user.address), {\n      ...DEFAULT_POSITION,\n      timestamp: ORACLE_VERSION_1.timestamp,\n    })\n    expectPositionEq(await market.pendingPositions(user.address, 1), {\n      ...DEFAULT_POSITION,\n      timestamp: ORACLE_VERSION_2.timestamp,\n      maker: dustPosition,\n      delta: dustCollateral,\n    })\n    expectGlobalEq(await market.global(), {\n      currentId: 1,\n      latestId: 0,\n      protocolFee: 0,\n      oracleFee: 0,\n      riskFee: 0,\n      donation: 0,\n    })\n    expectPositionEq(await market.position(), {\n      ...DEFAULT_POSITION,\n      timestamp: ORACLE_VERSION_1.timestamp,\n    })\n    expectPositionEq(await market.pendingPosition(1), {\n      ...DEFAULT_POSITION,\n      timestamp: ORACLE_VERSION_2.timestamp,\n      maker: dustPosition,\n    })\n    expectVersionEq(await market.versions(ORACLE_VERSION_1.timestamp), {\n      makerValue: { _value: 0 },\n      longValue: { _value: 0 },\n      shortValue: { _value: 0 },\n      makerReward: { _value: 0 },\n      longReward: { _value: 0 },\n      shortReward: { _value: 0 },\n    })\n\n    dsu.transfer.whenCalledWith(user.address, dustCollateral.mul(1e12)).returns(true)\n    await expect(market.connect(user).update(user.address, 0, 0, 0, dustCollateral.mul(-1), false))\n      .to.emit(market, 'Updated')\n      .withArgs(user.address, ORACLE_VERSION_2.timestamp, 0, 0, 0, dustCollateral.mul(-1), false)\n\n      expect(oracle.request).to.have.been.calledWith(user.address)\n\n    await time.increase(1)\n  }\n})\n```\n\n\n**sherlock-admin2**\n\n> Escalate\n> As long as there are no new positions to settle and the oracle version/timestamp is not updated, it's possible to keep opening and closing positions at each block, triggering consecutive requests, without paying any fees to the protocol.\n> \n> Then, after a few requests are triggered or someone else either opens a position or commits a new price, the attacker can commit all the previous requests. The only requirement is that the publish time of the requests are within the `MIN_VALID_TIME_AFTER_VERSION` and `MAX_VALID_TIME_AFTER_VERSION` window.\n> \n> This would pay the attacker the incentives and the profit depends on the specific math (considering the gas fees). Additionally, over a long enough period, it could drain the protocol of keeper fees, which would lead to DoS due to lack of fees to commit new prices.\n> \n> I tweaked the POC a bit to show how several requests can be made consecutively without paying any fees to the protocol. The positions are opened and closed in the `loop` (incrementing the block.timestamp at each iteration), triggering several requests. The next step would be to commit these requests in the oracle, but that should not require a POC.\n> \n> ```solidity\n> it.only('POC opens and closes the position to trigger an oracle request without paying any fee', async () => { \n>   const dustCollateral = parse6decimal(\"100\");\n>   const dustPosition = parse6decimal (\"0.000001\");\n> \n>   for (let i = 0; i < 5; i++) {\n>     dsu.transferFrom.whenCalledWith(user.address, market.address, dustCollateral.mul(1e12)).returns(true)\n> \n>     await expect(market.connect(user).update(user.address, dustPosition, 0, 0, dustCollateral, false))\n>       .to.emit(market, 'Updated')\n>       .withArgs(user.address, ORACLE_VERSION_2.timestamp, dustPosition, 0, 0, dustCollateral, false)\n> \n>     expectLocalEq(await market.locals(user.address), {\n>       currentId: 1,\n>       latestId: 0,\n>       collateral: dustCollateral,\n>       reward: 0,\n>       protection: 0,\n>     })\n>     expectPositionEq(await market.positions(user.address), {\n>       ...DEFAULT_POSITION,\n>       timestamp: ORACLE_VERSION_1.timestamp,\n>     })\n>     expectPositionEq(await market.pendingPositions(user.address, 1), {\n>       ...DEFAULT_POSITION,\n>       timestamp: ORACLE_VERSION_2.timestamp,\n>       maker: dustPosition,\n>       delta: dustCollateral,\n>     })\n>     expectGlobalEq(await market.global(), {\n>       currentId: 1,\n>       latestId: 0,\n>       protocolFee: 0,\n>       oracleFee: 0,\n>       riskFee: 0,\n>       donation: 0,\n>     })\n>     expectPositionEq(await market.position(), {\n>       ...DEFAULT_POSITION,\n>       timestamp: ORACLE_VERSION_1.timestamp,\n>     })\n>     expectPositionEq(await market.pendingPosition(1), {\n>       ...DEFAULT_POSITION,\n>       timestamp: ORACLE_VERSION_2.timestamp,\n>       maker: dustPosition,\n>     })\n>     expectVersionEq(await market.versions(ORACLE_VERSION_1.timestamp), {\n>       makerValue: { _value: 0 },\n>       longValue: { _value: 0 },\n>       shortValue: { _value: 0 },\n>       makerReward: { _value: 0 },\n>       longReward: { _value: 0 },\n>       shortReward: { _value: 0 },\n>     })\n> \n>     dsu.transfer.whenCalledWith(user.address, dustCollateral.mul(1e12)).returns(true)\n>     await expect(market.connect(user).update(user.address, 0, 0, 0, dustCollateral.mul(-1), false))\n>       .to.emit(market, 'Updated')\n>       .withArgs(user.address, ORACLE_VERSION_2.timestamp, 0, 0, 0, dustCollateral.mul(-1), false)\n> \n>       expect(oracle.request).to.have.been.calledWith(user.address)\n> \n>     await time.increase(1)\n>   }\n> })\n> ```\n> \n\nThe escalation could not be created because you are not exceeding the escalation threshold.\n\nYou can view the required number of additional valid issues/judging contest payouts in your Profile page,\nin the [Sherlock webapp](https://app.sherlock.xyz/audits/).\n\n\n**arjun-io**\n\nThis is a great find - while the keeper and position fees are correctly accounted for in most cases, this single version open and close _does not_ correctly debit these fees and require the collateral balance to be higher than the fee amount. Thank you for the thorough test case as well. We will fix this\n\n**nevillehuang**\n\nEscalate\n\nConfirmed by sponsor above, fees are not correctly debited for single version open and close.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> Confirmed by sponsor above, fees are not correctly debited for single version open and close.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**141345**\n\nThe severity of medium seems more appropriate.\n\nBecause according to sherlock's HM [criteria](https://docs.sherlock.xyz/audits/judging/judging):\n\n> Medium: \n> viable scenario (even if unlikely) that could cause the protocol to enter a state where a material amount of funds can be lost.\n> The attack path is possible with assumptions that either mimic on-chain conditions or reflect conditions that have a reasonable chance of becoming true in the future.\n> \n> High: \n> This vulnerability would result in a material loss of funds, and the cost of the attack is low.\n\n\nHere:\n- The loss is on oracle fee. \n- Each time the loss is capped by one time keeper fee, not significant compared to the trading volume. \n- And there is cost to fetch valid price data for the attacker.\n\nIn summary, the loss is limited with cost, medium might be suffice.\n\n\n**arjun-io**\n\nFixed: https://github.com/equilibria-xyz/perennial-v2/pull/88\n\n**hrishibhat**\n\nResult:\nMedium\nUnique \nConsidering this issue a valid medium based on the escalation and Sponsor's comment\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [nevillehuang](https://github.com/sherlock-audit/2023-07-perennial-judging/issues/153/#issuecomment-1693887644): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/106",
  "Code": [
    {
      "filename": "perennial-v2/packages/perennial/contracts/Market.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport \"@equilibria/root/attribute/Instance.sol\";\nimport \"@equilibria/root/attribute/ReentrancyGuard.sol\";\nimport \"./interfaces/IMarket.sol\";\nimport \"./interfaces/IMarketFactory.sol\";\n\n/// @title Market\n/// @notice Manages logic and state for a single market.\n/// @dev Cloned by the Factory contract to launch new markets.\ncontract Market is IMarket, Instance, ReentrancyGuard {\n    /// @dev The underlying token that the market settles in\n    Token18 public token;\n\n    /// @dev The token that incentive rewards are paid in\n    Token18 public reward;\n\n    /// @dev The oracle that provides the market price\n    IOracleProvider public oracle;\n\n    /// @dev The payoff function over the underlying oracle\n    IPayoffProvider public payoff;\n\n    /// @dev Beneficiary of the market, receives donations\n    address public beneficiary;\n\n    /// @dev Risk coordinator of the market\n    address public coordinator;\n\n    /// @dev Risk parameters of the market\n    RiskParameterStorage private _riskParameter;\n\n    /// @dev Parameters of the market\n    MarketParameterStorage private _parameter;\n\n    /// @dev Current global state of the market\n    GlobalStorage private _global;\n\n    /// @dev Current global position of the market\n    PositionStorageGlobal private _position;\n\n    /// @dev The global pending versions for each id\n    mapping(uint256 => PositionStorageGlobal) private _pendingPosition;\n\n    /// @dev Current local state of each account\n    mapping(address => LocalStorage) private _locals;\n\n    /// @dev Current local position of each account\n    mapping(address => PositionStorageLocal) private _positions;\n\n    /// @dev The local pending versions for each id for each account\n    mapping(address => mapping(uint256 => PositionStorageLocal)) private _pendingPositions;\n\n    /// @dev The historical version accumulator data for each accessed version\n    mapping(uint256 => VersionStorage) private _versions;\n\n    /// @notice Initializes the contract state\n    /// @param definition_ The market definition\n    function initialize(IMarket.MarketDefinition calldata definition_) external initializer(1) {\n        __Instance__initialize();\n        __UReentrancyGuard__initialize();\n\n        token = definition_.token;\n        oracle = definition_.oracle;\n        payoff = definition_.payoff;\n    }\n\n    /// @notice Updates the account's position and collateral\n    /// @param account The account to operate on\n    /// @param newMaker The new maker position for the account\n    /// @param newMaker The new long position for the account\n    /// @param newMaker The new short position for the account\n    /// @param collateral The collateral amount to add or remove from the account\n    /// @param protect Whether to put the account into a protected status for liquidations\n    function update(\n        address account,\n        UFixed6 newMaker,\n        UFixed6 newLong,\n        UFixed6 newShort,\n        Fixed6 collateral,\n        bool protect\n    ) external nonReentrant whenNotPaused {\n        Context memory context = _loadContext(account);\n        _settle(context, account);\n        _update(context, account, newMaker, newLong, newShort, collateral, protect);\n        _saveContext(context, account);\n    }\n\n    /// @notice Updates the beneficiary of the market\n    /// @param newBeneficiary The new beneficiary address\n    function updateBeneficiary(address newBeneficiary) external onlyOwner {\n        beneficiary = newBeneficiary;\n        emit BeneficiaryUpdated(newBeneficiary);\n    }\n\n    /// @notice Updates the coordinator of the market\n    /// @param newCoordinator The new coordinator address\n    function updateCoordinator(address newCoordinator) external onlyOwner {\n        coordinator = newCoordinator;\n        emit CoordinatorUpdated(newCoordinator);\n    }\n\n    /// @notice Updates the parameter set of the market\n    /// @param newParameter The new parameter set\n    function updateParameter(MarketParameter memory newParameter) external onlyOwner {\n        _parameter.validateAndStore(newParameter, IMarketFactory(address(factory())).parameter(), reward);\n        emit ParameterUpdated(newParameter);\n    }\n\n    /// @notice Updates the risk parameter set of the market\n    /// @param newRiskParameter The new risk parameter set\n    function updateRiskParameter(RiskParameter memory newRiskParameter) external onlyCoordinator {\n        _riskParameter.validateAndStore(newRiskParameter, IMarketFactory(address(factory())).parameter());\n        emit RiskParameterUpdated(newRiskParameter);\n    }\n\n    /// @notice Updates the reward token of the market\n    /// @param newReward The new reward token\n    function updateReward(Token18 newReward) public onlyOwner {\n        if (!reward.eq(Token18Lib.ZERO)) revert MarketRewardAlreadySetError();\n        if (newReward.eq(token)) revert MarketInvalidRewardError();\n\n        reward = newReward;\n        emit RewardUpdated(newReward);\n    }\n\n    /// @notice Claims any available fee that the sender has accrued\n    /// @dev Applicable fees include: protocol, oracle, risk, and donation\n    function claimFee() external {\n        Global memory newGlobal = _global.read();\n\n        if (_claimFee(address(factory()), newGlobal.protocolFee)) newGlobal.protocolFee = UFixed6Lib.ZERO;\n        if (_claimFee(address(IMarketFactory(address(factory())).oracleFactory()), newGlobal.oracleFee))\n            newGlobal.oracleFee = UFixed6Lib.ZERO;\n        if (_claimFee(coordinator, newGlobal.riskFee)) newGlobal.riskFee = UFixed6Lib.ZERO;\n        if (_claimFee(beneficiary, newGlobal.donation)) newGlobal.donation = UFixed6Lib.ZERO;\n\n        _global.store(newGlobal);\n    }\n\n    /// @notice Helper function to handle a singular fee claim\n    /// @param receiver The address to receive the fee\n    /// @param fee The amount of the fee to claim\n    function _claimFee(address receiver, UFixed6 fee) private returns (bool) {\n        if (msg.sender != receiver) return false;\n\n        token.push(receiver, UFixed18Lib.from(fee));\n        emit FeeClaimed(receiver, fee);\n        return true;\n    }\n\n    /// @notice Claims any available reward that the sender has accrued\n    function claimReward() external {\n        Local memory newLocal = _locals[msg.sender].read();\n\n        reward.push(msg.sender, UFixed18Lib.from(newLocal.reward));\n        emit RewardClaimed(msg.sender, newLocal.reward);\n\n        newLocal.reward = UFixed6Lib.ZERO;\n        _locals[msg.sender].store(newLocal);\n    }\n\n    /// @notice Returns the current parameter set\n    function parameter() external view returns (MarketParameter memory) {\n        return _parameter.read();\n    }\n\n    /// @notice Returns the current risk parameter set\n    function riskParameter() external view returns (RiskParameter memory) {\n        return _riskParameter.read();\n    }\n\n    /// @notice Returns the current global position\n    function position() external view returns (Position memory) {\n        return _position.read();\n    }\n\n    /// @notice Returns the current local position for the account\n    /// @param account The account to query\n    function positions(address account) external view returns (Position memory) {\n        return _positions[account].read();\n    }\n\n    /// @notice Returns the current global state\n    function global() external view returns (Global memory) {\n        return _global.read();\n    }\n\n    /// @notice Returns the historical version snapshot at the given timestamp\n    /// @param timestamp The timestamp to query\n    function versions(uint256 timestamp) external view returns (Version memory) {\n        return _versions[timestamp].read();\n    }\n\n    /// @notice Returns the local state for the given account\n    /// @param account The account to query\n    function locals(address account) external view returns (Local memory) {\n        return _locals[account].read();\n    }\n\n    /// @notice Returns the global pending position for the given id\n    /// @param id The id to query\n    function pendingPosition(uint256 id) external view returns (Position memory) {\n        return _pendingPosition[id].read();\n    }\n\n    /// @notice Returns the local pending position for the given account and id\n    /// @param account The account to query\n    /// @param id The id to query\n    function pendingPositions(address account, uint256 id) external view returns (Position memory) {\n        return _pendingPositions[account][id].read();\n    }\n\n    /// @notice Loads the current position context for the given account\n    /// @param context The context to load to\n    /// @param account The account to query\n    function _loadCurrentPositionContext(\n        Context memory context,\n        address account\n    ) private view returns (PositionContext memory positionContext) {\n        positionContext.global = _pendingPosition[context.global.currentId].read();\n        positionContext.local = _pendingPositions[account][context.local.currentId].read();\n        if (context.global.currentId == context.global.latestId)\n            positionContext.global.invalidate(context.latestPosition.global);\n        if (context.local.currentId == context.local.latestId)\n            positionContext.local.invalidate(context.latestPosition.local);\n    }\n\n    /// @notice Updates the current position\n    /// @param context The context to use\n    /// @param account The account to update\n    /// @param newMaker The new maker position size\n    /// @param newLong The new long position size\n    /// @param newShort The new short position size\n    /// @param collateral The change in collateral\n    /// @param protect Whether to protect the position for liquidation\n    function _update(\n        Context memory context,\n        address account,\n        UFixed6 newMaker,\n        UFixed6 newLong,\n        UFixed6 newShort,\n        Fixed6 collateral,\n        bool protect\n    ) private {\n        // read\n        context.currentPosition = _loadCurrentPositionContext(context, account);\n\n        // magic values\n        if (collateral.eq(Fixed6Lib.MIN)) collateral = context.local.collateral.mul(Fixed6Lib.NEG_ONE);\n        if (newMaker.eq(UFixed6Lib.MAX)) newMaker = context.currentPosition.local.maker;\n        if (newLong.eq(UFixed6Lib.MAX)) newLong = context.currentPosition.local.long;\n        if (newShort.eq(UFixed6Lib.MAX)) newShort = context.currentPosition.local.short;\n\n        // advance to next id if applicable\n        if (context.currentTimestamp > context.currentPosition.local.timestamp) {\n            context.local.currentId++;\n            context.currentPosition.local.prepare();\n        }\n        if (context.currentTimestamp > context.currentPosition.global.timestamp) {\n            context.global.currentId++;\n            context.currentPosition.global.prepare();\n        }\n\n        // update position\n        Order memory newOrder =\n            context.currentPosition.local.update(context.currentTimestamp, newMaker, newLong, newShort);\n        context.currentPosition.global.update(context.currentTimestamp, newOrder, context.riskParameter);\n\n        // update fee\n        newOrder.registerFee(context.latestVersion, context.marketParameter, context.riskParameter);\n        context.currentPosition.local.registerFee(newOrder);\n        context.currentPosition.global.registerFee(newOrder);\n\n        // update collateral\n        context.local.update(collateral);\n        context.currentPosition.local.update(collateral);\n\n        // protect account\n        bool protected = context.local.protect(context.latestPosition.local, context.currentTimestamp, protect);\n\n        // request version\n        if (!newOrder.isEmpty()) oracle.request(account);\n\n        // after\n        _invariant(context, account, newOrder, collateral, protected);\n\n        // store\n        _pendingPosition[context.global.currentId].store(context.currentPosition.global);\n        _pendingPositions[account][context.local.currentId].store(context.currentPosition.local);\n\n        // fund\n        if (collateral.sign() == 1) token.pull(msg.sender, UFixed18Lib.from(collateral.abs()));\n        if (collateral.sign() == -1) token.push(msg.sender, UFixed18Lib.from(collateral.abs()));\n\n        // events\n        emit Updated(account, context.currentTimestamp, newMaker, newLong, newShort, collateral, protect);\n    }\n\n    function _loadContext(address account) private view returns (Context memory context) {\n        // parameters\n        context.protocolParameter = IMarketFactory(address(factory())).parameter();\n        context.marketParameter = _parameter.read();\n        context.riskParameter = _riskParameter.read();\n\n        // state\n        context.global = _global.read();\n        context.local = _locals[account].read();\n\n        // oracle\n        (context.latestVersion, context.currentTimestamp) = _oracleVersion();\n        context.positionVersion = _oracleVersionAtPosition(context, _position.read());\n    }\n\n    /// @notice Stores the given context\n    /// @param context The context to store\n    /// @param account The account to store for\n    function _saveContext(Context memory context, address account) private {\n        _global.store(context.global);\n        _locals[account].store(context.local);\n    }\n\n    /// @notice Settles the account position up to the latest version\n    /// @param context The context to use\n    /// @param account The account to settle\n    function _settle(Context memory context, address account) private {\n        context.latestPosition.global = _position.read();\n        context.latestPosition.local = _positions[account].read();\n\n        Position memory nextPosition;\n\n        // settle\n        while (\n            context.global.currentId != context.global.latestId &&\n            (nextPosition = _pendingPosition[context.global.latestId + 1].read()).ready(context.latestVersion)\n        ) _processPositionGlobal(context, context.global.latestId + 1, nextPosition);\n\n        while (\n            context.local.currentId != context.local.latestId &&\n            (nextPosition = _pendingPositions[account][context.local.latestId + 1].read())\n                .ready(context.latestVersion)\n        ) {\n            Fixed6 previousDelta = _pendingPositions[account][context.local.latestId].read().delta;\n            _processPositionLocal(context, account, context.local.latestId + 1, nextPosition);\n            _checkpointCollateral(context, account, previousDelta, nextPosition);\n        }\n\n        // sync\n        if (context.latestVersion.timestamp > context.latestPosition.global.timestamp) {\n            nextPosition = _pendingPosition[context.global.latestId].read();\n            nextPosition.sync(context.latestVersion);\n            _processPositionGlobal(context, context.global.latestId, nextPosition);\n        }\n\n        if (context.latestVersion.timestamp > context.latestPosition.local.timestamp) {\n            nextPosition = _pendingPositions[account][context.local.latestId].read();\n            nextPosition.sync(context.latestVersion);\n            _processPositionLocal(context, account, context.local.latestId, nextPosition);\n        }\n\n        _position.store(context.latestPosition.global);\n        _positions[account].store(context.latestPosition.local);\n    }\n\n    /// @notice Places a collateral checkpoint for the account on the given pending position\n    /// @param context The context to use\n    /// @param account The account to checkpoint for\n    /// @param previousDelta The previous pending position's delta value\n    /// @param nextPosition The next pending position\n    function _checkpointCollateral(\n        Context memory context,\n        address account,\n        Fixed6 previousDelta,\n        Position memory nextPosition\n    ) private {\n        Position memory latestAccountPosition = _pendingPositions[account][context.local.latestId].read();\n        Position memory currentAccountPosition = _pendingPositions[account][context.local.currentId].read();\n        latestAccountPosition.collateral = context.local.collateral\n            .sub(currentAccountPosition.delta.sub(previousDelta))         // deposits happen after snapshot point\n            .add(Fixed6Lib.from(nextPosition.fee))                        // position fee happens after snapshot point\n            .add(Fixed6Lib.from(nextPosition.keeper));                    // keeper fee happens after snapshot point\n        _pendingPositions[account][context.local.latestId].store(latestAccountPosition);\n    }\n\n    /// @notice Processes the given global pending position into the latest position\n    /// @param context The context to use\n    /// @param newPositionId The id of the pending position to process\n    /// @param newPosition The pending position to process\n    function _processPositionGlobal(Context memory context, uint256 newPositionId, Position memory newPosition) private {\n        Version memory version = _versions[context.latestPosition.global.timestamp].read();\n        OracleVersion memory oracleVersion = _oracleVersionAtPosition(context, newPosition);\n        if (!oracleVersion.valid) newPosition.invalidate(context.latestPosition.global);\n\n        (uint256 fromTimestamp, uint256 fromId) = (context.latestPosition.global.timestamp, context.global.latestId);\n        (VersionAccumulationResult memory accumulationResult, UFixed6 accumulatedFee) = version.accumulate(\n            context.global,\n            context.latestPosition.global,\n            newPosition,\n            context.positionVersion,\n            oracleVersion,\n            context.marketParameter,\n            context.riskParameter\n        );\n        context.latestPosition.global.update(newPosition);\n        context.global.update(newPositionId, oracleVersion.price);\n        context.global.incrementFees(\n            accumulatedFee,\n            newPosition.keeper,\n            context.marketParameter,\n            context.protocolParameter\n        );\n        context.positionVersion = oracleVersion;\n        _versions[newPosition.timestamp].store(version);\n\n        // events\n        emit PositionProcessed(\n            fromTimestamp,\n            newPosition.timestamp,\n            fromId,\n            accumulationResult\n        );\n    }\n\n    /// @notice Processes the given local pending position into the latest position\n    /// @param context The context to use\n    /// @param account The account to process for\n    /// @param newPositionId The id of the pending position to process\n    /// @param newPosition The pending position to process\n    function _processPositionLocal(\n        Context memory context,\n        address account,\n        uint256 newPositionId,\n        Position memory newPosition\n    ) private {\n        Version memory version = _versions[newPosition.timestamp].read();\n        if (!version.valid) newPosition.invalidate(context.latestPosition.local);\n\n        (uint256 fromTimestamp, uint256 fromId) = (context.latestPosition.local.timestamp, context.local.latestId);\n        LocalAccumulationResult memory accumulationResult = context.local.accumulate(\n            newPositionId,\n            context.latestPosition.local,\n            newPosition,\n            _versions[context.latestPosition.local.timestamp].read(),\n            version\n        );\n        context.latestPosition.local.update(newPosition);\n\n        // events\n        emit AccountPositionProcessed(\n            account,\n            fromTimestamp,\n            newPosition.timestamp,\n            fromId,\n            accumulationResult\n        );\n    }\n\n    /// @notice Verifies the invariant of the market\n    /// @param context The context to use\n    /// @param account The account to verify the invariant for\n    /// @param newOrder The order to verify the invariant for\n    /// @param collateral The collateral change to verify the invariant for\n    /// @param protected Whether the new position is protected\n    function _invariant(\n        Context memory context,\n        address account,\n        Order memory newOrder,\n        Fixed6 collateral,\n        bool protected\n    ) private view {\n        // load all pending state\n        (Position[] memory pendingLocalPositions, Fixed6 collateralAfterFees) = _loadPendingPositions(context, account);\n\n        if (protected && (\n            !context.currentPosition.local.magnitude().isZero() ||\n            context.latestPosition.local.collateralized(\n                context.latestVersion,\n                context.riskParameter,\n                collateralAfterFees.sub(collateral)\n            ) ||\n            collateral.lt(Fixed6Lib.from(-1, _liquidationFee(context)))\n        )) revert MarketInvalidProtectionError();\n\n        if (context.currentTimestamp - context.latestVersion.timestamp >= context.riskParameter.staleAfter)\n            revert MarketStalePriceError();\n\n        if (context.marketParameter.closed && newOrder.increasesPosition())\n            revert MarketClosedError();\n\n        if (context.currentPosition.global.maker.gt(context.riskParameter.makerLimit))\n            revert MarketMakerOverLimitError();\n\n        if (!context.currentPosition.local.singleSided())\n            revert MarketNotSingleSidedError();\n\n        if (protected) return; // The following invariants do not apply to protected position updates (liquidations)\n\n        if (\n            msg.sender != account &&                                                                        // sender is operating on own account\n            !IMarketFactory(address(factory())).operators(account, msg.sender) &&                           // sender is operating on own account\n            !(newOrder.isEmpty() && collateralAfterFees.isZero() && collateral.gt(Fixed6Lib.ZERO))     // sender is repaying shortfall for this account\n        ) revert MarketOperatorNotAllowedError();\n\n        if (\n            context.global.currentId > context.global.latestId + context.marketParameter.maxPendingGlobal ||\n            context.local.currentId > context.local.latestId + context.marketParameter.maxPendingLocal\n        ) revert MarketExceedsPendingIdLimitError();\n\n        if (\n            !context.latestPosition.local.collateralized(context.latestVersion, context.riskParameter, collateralAfterFees)\n        ) revert MarketInsufficientCollateralizationError();\n\n        for (uint256 i; i < pendingLocalPositions.length; i++)\n            if (\n                !pendingLocalPositions[i].collateralized(context.latestVersion, context.riskParameter, collateralAfterFees)\n            ) revert MarketInsufficientCollateralizationError();\n\n        if (\n            (context.local.protection > context.latestPosition.local.timestamp) &&\n            !newOrder.isEmpty()\n        ) revert MarketProtectedError();\n\n        if (\n            newOrder.liquidityCheckApplicable(context.marketParameter) &&\n            newOrder.efficiency.lt(Fixed6Lib.ZERO) &&\n            context.currentPosition.global.efficiency().lt(context.riskParameter.efficiencyLimit)\n        ) revert MarketEfficiencyUnderLimitError();\n\n        if (\n            newOrder.liquidityCheckApplicable(context.marketParameter) &&\n            context.currentPosition.global.socialized() &&\n            newOrder.decreasesLiquidity()\n        ) revert MarketInsufficientLiquidityError();\n\n        if (collateral.lt(Fixed6Lib.ZERO) && collateralAfterFees.lt(Fixed6Lib.ZERO))\n            revert MarketInsufficientCollateralError();\n    }\n\n    /// @notice Loads data about all pending positions for the invariant check\n    /// @param context The context to use\n    /// @param account The account to load the pending positions for\n    /// @return pendingLocalPositions All pending positions for the account\n    /// @return collateralAfterFees The account's collateral after fees\n    function _loadPendingPositions(\n        Context memory context,\n        address account\n    ) private view returns (Position[] memory pendingLocalPositions, Fixed6 collateralAfterFees) {\n        collateralAfterFees = context.local.collateral;\n        pendingLocalPositions = new Position[](\n            context.local.currentId - Math.min(context.local.latestId, context.local.currentId)\n        );\n        for (uint256 i; i < pendingLocalPositions.length - 1; i++) {\n            pendingLocalPositions[i] = _pendingPositions[account][context.local.latestId + 1 + i].read();\n            collateralAfterFees = collateralAfterFees\n                .sub(Fixed6Lib.from(pendingLocalPositions[i].fee))\n                .sub(Fixed6Lib.from(pendingLocalPositions[i].keeper));\n        }\n        pendingLocalPositions[pendingLocalPositions.length - 1] = context.currentPosition.local; // current local position hasn't been stored yet\n    }\n\n    /// @notice Computes the liquidation fee for the current latest local position\n    /// @param context The context to use\n    /// @return The liquidation fee\n    function _liquidationFee(Context memory context) private view returns (UFixed6) {\n        return context.latestPosition.local\n            .liquidationFee(context.latestVersion, context.riskParameter)\n            .min(UFixed6Lib.from(token.balanceOf()));\n    }\n\n    /// @notice Computes the current oracle status with the market's payoff\n    /// @return latestVersion The latest oracle version with payoff applied\n    /// @return currentTimestamp The current oracle timestamp\n    function _oracleVersion() private view returns (OracleVersion memory latestVersion, uint256 currentTimestamp) {\n        (latestVersion, currentTimestamp) = oracle.status();\n        _transform(latestVersion);\n    }\n\n    /// @notice Computes the latest oracle version at a given timestamp with the market's payoff\n    /// @param timestamp The timestamp to use\n    /// @return oracleVersion The oracle version at the given timestamp with payoff applied\n    function _oracleVersionAt(uint256 timestamp) private view returns (OracleVersion memory oracleVersion) {\n        oracleVersion = oracle.at(timestamp);\n        _transform(oracleVersion);\n    }\n\n    /// @notice Computes the latest oracle version at a given position with the market's payoff\n    /// @dev applies the latest valid price when the version at position is invalid\n    /// @param context The context to use\n    /// @param toPosition The position to use\n    /// @return oracleVersion The oracle version at the given position\n    function _oracleVersionAtPosition(\n        Context memory context,\n        Position memory toPosition\n    ) private view returns (OracleVersion memory oracleVersion) {\n        oracleVersion = _oracleVersionAt(toPosition.timestamp);\n        if (!oracleVersion.valid) oracleVersion.price = context.global.latestPrice;\n    }\n\n    /// @notice Applies the market's payoff to an oracle version\n    /// @param oracleVersion The oracle version to transform\n    function _transform(OracleVersion memory oracleVersion) private view {\n        if (address(payoff) != address(0)) oracleVersion.price = payoff.payoff(oracleVersion.price);\n    }\n\n    /// @notice Only the coordinator or the owner can call\n    modifier onlyCoordinator {\n        if (msg.sender != coordinator && msg.sender != factory().owner()) revert MarketNotCoordinatorError();\n        _;\n    }\n}"
    },
    {
      "filename": "perennial-v2/packages/perennial/contracts/Market.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport \"@equilibria/root/attribute/Instance.sol\";\nimport \"@equilibria/root/attribute/ReentrancyGuard.sol\";\nimport \"./interfaces/IMarket.sol\";\nimport \"./interfaces/IMarketFactory.sol\";\n\n/// @title Market\n/// @notice Manages logic and state for a single market.\n/// @dev Cloned by the Factory contract to launch new markets.\ncontract Market is IMarket, Instance, ReentrancyGuard {\n    /// @dev The underlying token that the market settles in\n    Token18 public token;\n\n    /// @dev The token that incentive rewards are paid in\n    Token18 public reward;\n\n    /// @dev The oracle that provides the market price\n    IOracleProvider public oracle;\n\n    /// @dev The payoff function over the underlying oracle\n    IPayoffProvider public payoff;\n\n    /// @dev Beneficiary of the market, receives donations\n    address public beneficiary;\n\n    /// @dev Risk coordinator of the market\n    address public coordinator;\n\n    /// @dev Risk parameters of the market\n    RiskParameterStorage private _riskParameter;\n\n    /// @dev Parameters of the market\n    MarketParameterStorage private _parameter;\n\n    /// @dev Current global state of the market\n    GlobalStorage private _global;\n\n    /// @dev Current global position of the market\n    PositionStorageGlobal private _position;\n\n    /// @dev The global pending versions for each id\n    mapping(uint256 => PositionStorageGlobal) private _pendingPosition;\n\n    /// @dev Current local state of each account\n    mapping(address => LocalStorage) private _locals;\n\n    /// @dev Current local position of each account\n    mapping(address => PositionStorageLocal) private _positions;\n\n    /// @dev The local pending versions for each id for each account\n    mapping(address => mapping(uint256 => PositionStorageLocal)) private _pendingPositions;\n\n    /// @dev The historical version accumulator data for each accessed version\n    mapping(uint256 => VersionStorage) private _versions;\n\n    /// @notice Initializes the contract state\n    /// @param definition_ The market definition\n    function initialize(IMarket.MarketDefinition calldata definition_) external initializer(1) {\n        __Instance__initialize();\n        __UReentrancyGuard__initialize();\n\n        token = definition_.token;\n        oracle = definition_.oracle;\n        payoff = definition_.payoff;\n    }\n\n    /// @notice Updates the account's position and collateral\n    /// @param account The account to operate on\n    /// @param newMaker The new maker position for the account\n    /// @param newMaker The new long position for the account\n    /// @param newMaker The new short position for the account\n    /// @param collateral The collateral amount to add or remove from the account\n    /// @param protect Whether to put the account into a protected status for liquidations\n    function update(\n        address account,\n        UFixed6 newMaker,\n        UFixed6 newLong,\n        UFixed6 newShort,\n        Fixed6 collateral,\n        bool protect\n    ) external nonReentrant whenNotPaused {\n        Context memory context = _loadContext(account);\n        _settle(context, account);\n        _update(context, account, newMaker, newLong, newShort, collateral, protect);\n        _saveContext(context, account);\n    }\n\n    /// @notice Updates the beneficiary of the market\n    /// @param newBeneficiary The new beneficiary address\n    function updateBeneficiary(address newBeneficiary) external onlyOwner {\n        beneficiary = newBeneficiary;\n        emit BeneficiaryUpdated(newBeneficiary);\n    }\n\n    /// @notice Updates the coordinator of the market\n    /// @param newCoordinator The new coordinator address\n    function updateCoordinator(address newCoordinator) external onlyOwner {\n        coordinator = newCoordinator;\n        emit CoordinatorUpdated(newCoordinator);\n    }\n\n    /// @notice Updates the parameter set of the market\n    /// @param newParameter The new parameter set\n    function updateParameter(MarketParameter memory newParameter) external onlyOwner {\n        _parameter.validateAndStore(newParameter, IMarketFactory(address(factory())).parameter(), reward);\n        emit ParameterUpdated(newParameter);\n    }\n\n    /// @notice Updates the risk parameter set of the market\n    /// @param newRiskParameter The new risk parameter set\n    function updateRiskParameter(RiskParameter memory newRiskParameter) external onlyCoordinator {\n        _riskParameter.validateAndStore(newRiskParameter, IMarketFactory(address(factory())).parameter());\n        emit RiskParameterUpdated(newRiskParameter);\n    }\n\n    /// @notice Updates the reward token of the market\n    /// @param newReward The new reward token\n    function updateReward(Token18 newReward) public onlyOwner {\n        if (!reward.eq(Token18Lib.ZERO)) revert MarketRewardAlreadySetError();\n        if (newReward.eq(token)) revert MarketInvalidRewardError();\n\n        reward = newReward;\n        emit RewardUpdated(newReward);\n    }\n\n    /// @notice Claims any available fee that the sender has accrued\n    /// @dev Applicable fees include: protocol, oracle, risk, and donation\n    function claimFee() external {\n        Global memory newGlobal = _global.read();\n\n        if (_claimFee(address(factory()), newGlobal.protocolFee)) newGlobal.protocolFee = UFixed6Lib.ZERO;\n        if (_claimFee(address(IMarketFactory(address(factory())).oracleFactory()), newGlobal.oracleFee))\n            newGlobal.oracleFee = UFixed6Lib.ZERO;\n        if (_claimFee(coordinator, newGlobal.riskFee)) newGlobal.riskFee = UFixed6Lib.ZERO;\n        if (_claimFee(beneficiary, newGlobal.donat"
    }
  ]
}