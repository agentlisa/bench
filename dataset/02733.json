{
  "Title": "M-12: BondAggregator.liveMarketsBy eventually will revert because of block gas limit",
  "Content": "# Issue M-12: BondAggregator.liveMarketsBy eventually will revert because of block gas limit \n\nSource: https://github.com/sherlock-audit/2022-11-bond-judging/issues/10 \n\n## Found by \nrvierdiiev\n\n## Summary\nBondAggregator.liveMarketsBy eventually will revert because of block gas limit\n## Vulnerability Detail\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondAggregator.sol#L259-L280\n```solidity\n    function liveMarketsBy(address owner_) external view returns (uint256[] memory) {\n        uint256 count;\n        IBondAuctioneer auctioneer;\n        for (uint256 i; i < marketCounter; ++i) {\n            auctioneer = marketsToAuctioneers[i];\n            if (auctioneer.isLive(i) && auctioneer.ownerOf(i) == owner_) {\n                ++count;\n            }\n        }\n\n\n        uint256[] memory ids = new uint256[](count);\n        count = 0;\n        for (uint256 i; i < marketCounter; ++i) {\n            auctioneer = marketsToAuctioneers[i];\n            if (auctioneer.isLive(i) && auctioneer.ownerOf(i) == owner_) {\n                ids[count] = i;\n                ++count;\n            }\n        }\n\n\n        return ids;\n    }\n```\nBondAggregator.liveMarketsBy function is looping through all markets and does at least `marketCounter` amount of external calls(when all markets are not live) and at most 4 * `marketCounter` external calls(when all markets are live and owner matches. This  all consumes a lot of gas, even that is called from view function. And each new market increases loop size.\n\nThat means that after some time `marketsToAuctioneers` mapping will be big enough that the gas amount sent for view/pure function will be not enough to retrieve all data(50 million gas according to [this](https://ethereum.stackexchange.com/questions/9824/can-solidity-view-pure-functions-be-arbitrarily-complex)). So the function will revert.\n\nAlso similar problem is with `findMarketFor`, `marketsFor` and `liveMarketsFor` functions.\n## Impact\nFunctions will always revert and whoever depends on it will not be able to get information.\n## Code Snippet\nProvided above\n## Tool used\n\nManual Review\n\n## Recommendation\nRemove not active markets or some start and end indices to functions.\n\n## Discussion\n\n**Evert0x**\n\nMessage from sponsor\n\n----\n\nAgree. We added start and stop indices to the BondAggregator.liveMarketsBy function to allow pagination through the bond markets and avoid the block gas limit.\n\n\n\n\n**xiaoming9090**\n\nFixed in https://github.com/Bond-Protocol/bonds/commit/5a2a9a982f3bdfc31d22f72d270bf2d556096281\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/20",
  "Code": [
    {
      "filename": "src/BondAggregator.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\n\nimport {IBondAggregator} from \"./interfaces/IBondAggregator.sol\";\nimport {IBondTeller} from \"./interfaces/IBondTeller.sol\";\nimport {IBondAuctioneer} from \"./interfaces/IBondAuctioneer.sol\";\n\nimport {FullMath} from \"./lib/FullMath.sol\";\n\n/// @title Bond Aggregator\n/// @notice Bond Aggregator Contract\n/// @dev Bond Protocol is a permissionless system to create Olympus-style bond markets\n///      for any token pair. The markets do not require maintenance and will manage\n///      bond prices based on activity. Bond issuers create BondMarkets that pay out\n///      a Payout Token in exchange for deposited Quote Tokens. Users can purchase\n///      future-dated Payout Tokens with Quote Tokens at the current market price and\n///      receive Bond Tokens to represent their position while their bond vests.\n///      Once the Bond Tokens vest, they can redeem it for the Quote Tokens.\n///\n/// @dev The Aggregator contract keeps a unique set of market IDs across multiple\n///      Tellers and Auctioneers. Additionally, it aggregates market data from\n///      multiple Auctioneers in convenient view functions for front-end interfaces.\n///      The Aggregator contract should be deployed first since Tellers, Auctioneers, and\n///      Callbacks all require it in their constructors.\n///\n/// @author Oighty, Zeus, Potted Meat, indigo\ncontract BondAggregator is IBondAggregator, Auth {\n    using FullMath for uint256;\n\n    /* ========== ERRORS ========== */\n    error Aggregator_OnlyAuctioneer();\n    error Aggregator_AlreadyRegistered(address auctioneer_);\n    error Aggregator_InvalidParams();\n\n    /* ========== STATE VARIABLES ========== */\n\n    /// @notice Counter for bond markets on approved auctioneers\n    uint256 public marketCounter;\n\n    /// @notice Approved auctioneers\n    IBondAuctioneer[] public auctioneers;\n    mapping(address => bool) internal _whitelist;\n\n    /// @notice Auctioneer for Market ID\n    mapping(uint256 => IBondAuctioneer) public marketsToAuctioneers;\n\n    /// @notice Market IDs for payout token\n    mapping(address => uint256[]) public marketsForPayout;\n\n    /// @notice Market IDs for quote token\n    mapping(address => uint256[]) public marketsForQuote;\n\n    // A 'vesting' param longer than 50 years is considered a timestamp for fixed expiry.\n    uint48 private constant MAX_FIXED_TERM = 52 weeks * 50;\n\n    constructor(address guardian_, Authority authority_) Auth(guardian_, authority_) {}\n\n    /// @inheritdoc IBondAggregator\n    function registerAuctioneer(IBondAuctioneer auctioneer_) external requiresAuth {\n        // Restricted to authorized addresses\n\n        // Check that the auctioneer is not already registered\n        if (_whitelist[address(auctioneer_)])\n            revert Aggregator_AlreadyRegistered(address(auctioneer_));\n\n        // Add the auctioneer to the whitelist\n        auctioneers.push(auctioneer_);\n        _whitelist[address(auctioneer_)] = true;\n    }\n\n    /// @inheritdoc IBondAggregator\n    function registerMarket(ERC20 payoutToken_, ERC20 quoteToken_)\n        external\n        override\n        returns (uint256 marketId)\n    {\n        if (!_whitelist[msg.sender]) revert Aggregator_OnlyAuctioneer();\n        if (address(payoutToken_) == address(0) || address(quoteToken_) == address(0))\n            revert Aggregator_InvalidParams();\n        marketId = marketCounter;\n        marketsToAuctioneers[marketId] = IBondAuctioneer(msg.sender);\n        marketsForPayout[address(payoutToken_)].push(marketId);\n        marketsForQuote[address(quoteToken_)].push(marketId);\n        ++marketCounter;\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /// @inheritdoc IBondAggregator\n    function getAuctioneer(uint256 id_) external view returns (IBondAuctioneer) {\n        return marketsToAuctioneers[id_];\n    }\n\n    /// @inheritdoc IBondAggregator\n    function marketPrice(uint256 id_) public view override returns (uint256) {\n        IBondAuctioneer auctioneer = marketsToAuctioneers[id_];\n        return auctioneer.marketPrice(id_);\n    }\n\n    /// @inheritdoc IBondAggregator\n    function marketScale(uint256 id_) external view override returns (uint256) {\n        IBondAuctioneer auctioneer = marketsToAuctioneers[id_];\n        return auctioneer.marketScale(id_);\n    }\n\n    /// @inheritdoc IBondAggregator\n    function payoutFor(\n        uint256 amount_,\n        uint256 id_,\n        address referrer_\n    ) public view override returns (uint256) {\n        IBondAuctioneer auctioneer = marketsToAuctioneers[id_];\n        return auctioneer.payoutFor(amount_, id_, referrer_);\n    }\n\n    /// @inheritdoc IBondAggregator\n    function maxAmountAccepted(uint256 id_, address referrer_) external view returns (uint256) {\n        IBondAuctioneer auctioneer = marketsToAuctioneers[id_];\n        return auctioneer.maxAmountAccepted(id_, referrer_);\n    }\n\n    /// @inheritdoc IBondAggregator\n    function isInstantSwap(uint256 id_) external view returns (bool) {\n        IBondAuctioneer auctioneer = marketsToAuctioneers[id_];\n        return auctioneer.isInstantSwap(id_);\n    }\n\n    /// @inheritdoc IBondAggregator\n    function isLive(uint256 id_) public view override returns (bool) {\n        IBondAuctioneer auctioneer = marketsToAuctioneers[id_];\n        return auctioneer.isLive(id_);\n    }\n\n    /// @inheritdoc IBondAggregator\n    function liveMarketsBetween(uint256 firstIndex_, uint256 lastIndex_)\n        external\n        view\n        override\n        returns (uint256[] memory)\n    {\n        uint256 count;\n        for (uint256 i = firstIndex_; i < lastIndex_; ++i) {\n            if (isLive(i)) ++count;\n        }\n\n        uint256[] memory ids = new uint256[](count);\n        count = 0;\n        for (uint256 i = firstIndex_; i < lastIndex_; ++i) {\n            if (isLive(i)) {\n                ids[count] = i;\n                ++count;\n            }\n        }\n        return ids;\n    }\n\n    /// @inheritdoc IBondAggregator\n    function liveMarketsFor(address token_, bool isPayout_)\n        public\n        view\n        override\n        returns (uint256[] memory)\n    {\n        uint256[] memory mkts;\n\n        mkts = isPayout_ ? marketsForPayout[token_] : marketsForQuote[token_];\n\n        uint256 count;\n        uint256 len = mkts.length;\n\n        for (uint256 i; i < len; ++i) {\n            if (isLive(mkts[i])) ++count;\n        }\n\n        uint256[] memory ids = new uint256[](count);\n        count = 0;\n\n        for (uint256 i; i < len; ++i) {\n            if (isLive(mkts[i])) {\n                ids[count] = mkts[i];\n                ++count;\n            }\n        }\n\n        return ids;\n    }\n\n    /// @inheritdoc IBondAggregator\n    function marketsFor(address payout_, address quote_) public view returns (uint256[] memory) {\n        uint256[] memory forPayout = liveMarketsFor(payout_, true);\n        uint256 count;\n\n        ERC20 quoteToken;\n        IBondAuctioneer auctioneer;\n        uint256 len = forPayout.length;\n        for (uint256 i; i < len; ++i) {\n            auctioneer = marketsToAuctioneers[forPayout[i]];\n            (, , , quoteToken, , ) = auctioneer.getMarketInfoForPurchase(forPayout[i]);\n            if (isLive(forPayout[i]) && address(quoteToken) == quote_) ++count;\n        }\n\n        uint256[] memory ids = new uint256[](count);\n        count = 0;\n\n        for (uint256 i; i < len; ++i) {\n            auctioneer = marketsToAuctioneers[forPayout[i]];\n            (, , , quoteToken, , ) = auctioneer.getMarketInfoForPurchase(forPayout[i]);\n            if (isLive(forPayout[i]) && address(quoteToken) == quote_) {\n                ids[count] = forPayout[i];\n                ++count;\n            }\n        }\n\n        return ids;\n    }\n\n    /// @inheritdoc IBondAggregator\n    function findMarketFor(\n        address payout_,\n        address quote_,\n        uint256 amountIn_,\n        uint256 minAmountOut_,\n        uint256 maxExpiry_\n    ) external view returns (uint256) {\n        uint256[] memory ids = marketsFor(payout_, quote_);\n        uint256 len = ids.length;\n        uint256[] memory payouts = new uint256[](len);\n\n        uint256 highestOut;\n        uint256 id = type(uint256).max; // set to max so an empty set doesn't return 0, the first index\n        uint48 vesting;\n        uint256 maxPayout;\n        IBondAuctioneer auctioneer;\n        for (uint256 i; i < len; ++i) {\n            auctioneer = marketsToAuctioneers[ids[i]];\n            (, , , , vesting, maxPayout) = auctioneer.getMarketInfoForPurchase(ids[i]);\n\n            uint256 expiry = (vesting <= MAX_FIXED_TERM) ? block.timestamp + vesting : vesting;\n\n            if (expiry <= maxExpiry_) {\n                payouts[i] = minAmountOut_ <= maxPayout\n                    ? payoutFor(amountIn_, ids[i], address(0))\n                    : 0;\n\n                if (payouts[i] > highestOut) {\n                    highestOut = payouts[i];\n                    id = ids[i];\n                }\n            }\n        }\n\n        return id;\n    }\n\n    /// @inheritdoc IBondAggregator\n    function liveMarketsBy(address owner_) external view returns (uint256[] memory) {\n        uint256 count;\n        IBondAuctioneer auctioneer;\n        for (uint256 i; i < marketCounter; ++i) {\n            auctioneer = marketsToAuctioneers[i];\n            if (auctioneer.isLive(i) && auctioneer.ownerOf(i) == owner_) {\n                ++count;\n            }\n        }\n\n        uint256[] memory ids = new uint256[](count);\n        count = 0;\n        for (uint256 i; i < marketCounter; ++i) {\n            auctioneer = marketsToAuctioneers[i];\n            if (auctioneer.isLive(i) && auctioneer.ownerOf(i) == owner_) {\n                ids[count] = i;\n                ++count;\n            }\n        }\n\n        return ids;\n    }\n\n    /// @inheritdoc IBondAggregator\n    function getTeller(uint256 id_) external view returns (IBondTeller) {\n        IBondAuctioneer auctioneer = marketsToAuctioneers[id_];\n        return auctioneer.getTeller();\n    }\n\n    /// @inheritdoc IBondAggregator\n    function currentCapacity(uint256 id_) external view returns (uint256) {\n        IBondAuctioneer auctioneer = marketsToAuctioneers[id_];\n        return auctioneer.currentCapacity(id_);\n    }\n}"
    }
  ]
}