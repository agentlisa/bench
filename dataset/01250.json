{
  "Title": "Infinite loop breaks protocol functionality.",
  "Content": "# Infinite loop breaks protocol functionality.\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/OrdersFacet.sol#L124-L178\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/OrdersFacet.sol#L124-L178</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibOrders.sol#L952-L968\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibOrders.sol#L952-L968</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"\"></a>\n\n\n## Summary\n\nProtocol documentation says that DAO is able to cancel up to 1,000 orders when order count is above 65,000. However, because of the faulty `for loop` it is impossible to cancel more than 255 orders.\n\n## Vulnerability details\n\n`orderId` is implemented in protocol to index orders in orderbook. In the protocol documentation it is written that it can handle above 65,000 orders because of reusable orderIds. When there are more than 65,500 orders DAO can cancel up to 1,000 orders. Here are the code blocks from `cancelOrderFarFromOracle` function which allows DAO to cancel orders. It also allows user to cancel one order.\n\nIt makes sure that there are more than 65,000 orders.\n\n```solidity\n\n    if (s.asset[asset].orderId < 65000) {\n        revert Errors.OrderIdCountTooLow();\n    }\n\n```\n\nThis ensures that DAO can't cancel more than 1,000 orders.\n\n```solidity\n\n     if (numOrdersToCancel > 1000) {\n        revert Errors.CannotCancelMoreThan1000Orders();\n    }\n\n```\n\nLater `cancelOrderFarFromOracle` checks if `msg.sender == LibDiamond.diamondStorage().contractOwner` and based on the boolean value (true or false) of this statement it allows to cancel the desired amount of orders.\n\nThe problem occurs in `cancelManyOrders` (`LibOrders.sol`) which is called on the mapping of orders of specified earlier `orderType`.\n\n```solidity\n\nfunction cancelManyOrders(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset,\n        uint16 lastOrderId,\n        uint16 numOrdersToCancel\n    ) internal {\n        uint16 prevId;\n        uint16 currentId = lastOrderId;\n        for (uint8 i; i < numOrdersToCancel;) {\n            prevId = orders[asset][currentId].prevId;\n            LibOrders.cancelOrder(orders, asset, currentId);\n            currentId = prevId;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    \n```\n\nThis function receives parameters:\n- mapping of orders to cancel\n- address of asset (market that will be impacted)\n- last order id\n- number of orders to cancel\n\nWhen we look at the implementation of this function we can see that `uint8` was used as a variable for the iteration in the `for loop`. `uint8 i` maximum value is `255`. As we can see in the `for loop` there is `unchecked` statement which allows uint underflow / overflow.\n\n```solidity\n    unchecked {\n        ++i;\n}   \n```\n\nSo when we try to add 1 to 255 (255 + 1) solidity would automaticly `revert` due to uint overflow but when we use `unchecked` solidity allows us to do this operation and the result of this will be `0`.\n\nWhen DAO would like to cancel more than 255 orders it would result in infinite loop since:\n- the for loop will iterate when `i < numOrdersToCancel`\n- the vaule of `i` will always be less than 256 because it can't get bigger than that due to overflow\n\n`i = 255` and `i < 256` `unchecked {++i;}` \nNext iteration\n`i = 0` and `i < 256` `unchecked {++i;}`\n\n## PoC / Scenario\n\nI created pretty simple PoC in Remix.\n\n```solidity\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.21;\n\n\ncontract PoC {\n\n   uint256 public iterationsCount;\n\n   function infiniteForLoop(uint256 amountOfIterations) public {\n      for(uint8 i; i < amountOfIterations;) {\n         iterationsCount += 1;\n         unchecked {\n            ++i;\n         }\n      }\n   }\n\n}\n\n```\n\nTo see that this function can't handle more than 255 orders cancelations run this function with input parameter (amountOfItertions) equal to 256 or above.\n\n## Further explenation\n\nAfter DAO tries to cancel more than 255 orders the infinite loop will be created which will terminate the transaction.\n\nThe transaction will fail because of gas consumption. For loop will run as many times as it can with provided gas. Since it will try to run infinitely it will run out of gas.\n\n## Impact\n\nProtocol documentation states that DAO is able to cancel 1,000 orders. Since it is not possible with the current implementation of the code this issue disrupts protocols functionality. The implemented code can't handle desired functionality.\n\n## Tools used\n\nVScode, Manual Review, Remix\n\n## Recommendations\n\nTo solve this problem change `uint8 i` to `uint16` or any higher uint that can handle the desired amount of iterations.",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clm871gl00001mp081mzjdlwc",
  "Code": [
    {
      "filename": "contracts/facets/OrdersFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U88} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {STypes, O, SR} from \"contracts/libraries/DataTypes.sol\";\nimport {LibDiamond} from \"contracts/libraries/LibDiamond.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract OrdersFacet is Modifiers {\n    using U256 for uint256;\n    using U88 for uint88;\n    using LibOrders for mapping(address => mapping(uint16 => STypes.Order));\n\n    /**\n     * @notice Cancels unfilled bid on market\n     *\n     * @param asset The market that will be impacted\n     * @param id Id of bid\n     */\n\n    function cancelBid(address asset, uint16 id)\n        external\n        onlyValidAsset(asset)\n        nonReentrant\n    {\n        STypes.Order storage bid = s.bids[asset][id];\n        if (msg.sender != bid.addr) revert Errors.NotOwner();\n        O orderType = bid.orderType;\n        if (orderType == O.Cancelled || orderType == O.Matched) {\n            revert Errors.NotActiveOrder();\n        }\n\n        uint256 vault = s.asset[asset].vault;\n        uint88 eth = bid.ercAmount.mulU88(bid.price);\n        s.vaultUser[vault][msg.sender].ethEscrowed += eth;\n\n        s.bids.cancelOrder(asset, id);\n    }\n\n    /**\n     * @notice Cancels unfilled ask on market\n     *\n     * @param asset The market that will be impacted\n     * @param id Id of ask\n     */\n\n    function cancelAsk(address asset, uint16 id)\n        external\n        onlyValidAsset(asset)\n        nonReentrant\n    {\n        STypes.Order storage ask = s.asks[asset][id];\n        if (msg.sender != ask.addr) revert Errors.NotOwner();\n        O orderType = ask.orderType;\n        if (orderType == O.Cancelled || orderType == O.Matched) {\n            revert Errors.NotActiveOrder();\n        }\n\n        s.assetUser[asset][msg.sender].ercEscrowed += ask.ercAmount;\n\n        s.asks.cancelOrder(asset, id);\n    }\n\n    /**\n     * @notice Cancels unfilled short on market\n     *\n     * @param asset The market that will be impacted\n     * @param id Id of short\n     */\n\n    function cancelShort(address asset, uint16 id)\n        external\n        onlyValidAsset(asset)\n        nonReentrant\n    {\n        STypes.Order storage short = s.shorts[asset][id];\n        if (msg.sender != short.addr) revert Errors.NotOwner();\n        O orderType = short.orderType;\n        if (orderType == O.Cancelled || orderType == O.Matched) {\n            revert Errors.NotActiveOrder();\n        }\n\n        STypes.Asset storage Asset = s.asset[asset];\n        uint88 eth = short.ercAmount.mulU88(short.price).mulU88(\n            LibOrders.convertCR(short.initialMargin)\n        );\n        s.vaultUser[Asset.vault][msg.sender].ethEscrowed += eth;\n\n        // Update ShortRecord if exists\n        uint8 shortRecordId = short.shortRecordId;\n        if (shortRecordId >= Constants.SHORT_STARTING_ID) {\n            STypes.ShortRecord storage shortRecord =\n                s.shortRecords[asset][msg.sender][shortRecordId];\n            if (shortRecord.status == SR.Cancelled) {\n                LibShortRecord.deleteShortRecord(asset, msg.sender, shortRecordId);\n            } else {\n                shortRecord.status = SR.FullyFilled;\n            }\n        }\n\n        // Approximating the startingShortId, rather than expecting exact match\n        if (id == Asset.startingShortId) {\n            uint256 oraclePrice = LibOracle.getPrice(asset);\n            uint256 prevPrice = s.shorts[asset][short.prevId].price;\n            if (prevPrice >= oraclePrice) {\n                Asset.startingShortId = short.prevId;\n            } else {\n                Asset.startingShortId = short.nextId;\n            }\n        }\n\n        s.shorts.cancelOrder(asset, id);\n    }\n\n    //@dev public function to handle when orderId has hit limit. Used to deter attackers\n    function cancelOrderFarFromOracle(\n        address asset,\n        O orderType,\n        uint16 lastOrderId,\n        uint16 numOrdersToCancel\n    ) external onlyValidAsset(asset) nonReentrant {\n        if (s.asset[asset].orderId < 65000) {\n            revert Errors.OrderIdCountTooLow();\n        }\n\n        if (numOrdersToCancel > 1000) {\n            revert Errors.CannotCancelMoreThan1000Orders();\n        }\n\n        if (msg.sender == LibDiamond.diamondStorage().contractOwner) {\n            if (\n                orderType == O.LimitBid\n                    && s.bids[asset][lastOrderId].nextId == Constants.TAIL\n            ) {\n                s.bids.cancelManyOrders(asset, lastOrderId, numOrdersToCancel);\n            } else if (\n                orderType == O.LimitAsk\n                    && s.asks[asset][lastOrderId].nextId == Constants.TAIL\n            ) {\n                s.asks.cancelManyOrders(asset, lastOrderId, numOrdersToCancel);\n            } else if (\n                orderType == O.LimitShort\n                    && s.shorts[asset][lastOrderId].nextId == Constants.TAIL\n            ) {\n                s.shorts.cancelManyOrders(asset, lastOrderId, numOrdersToCancel);\n            } else {\n                revert Errors.NotLastOrder();\n            }\n        } else {\n            //@dev if address is not DAO, you can only cancel last order of a side\n            if (\n                orderType == O.LimitBid\n                    && s.bids[asset][lastOrderId].nextId == Constants.TAIL\n            ) {\n                s.bids.cancelOrder(asset, lastOrderId);\n            } else if (\n                orderType == O.LimitAsk\n                    && s.asks[asset][lastOrderId].nextId == Constants.TAIL\n            ) {\n                s.asks.cancelOrder(asset, lastOrderId);\n            } else if (\n                orderType == O.LimitShort\n                    && s.shorts[asset][lastOrderId].nextId == Constants.TAIL\n            ) {\n                s.shorts.cancelOrder(asset, lastOrderId);\n            } else {\n                revert Errors.NotLastOrder();\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/libraries/LibOrders.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, Math104, U80, U88} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {AppStorage, appStorage} from \"contracts/libraries/AppStorage.sol\";\nimport {STypes, MTypes, O, SR, OF} from \"contracts/libraries/DataTypes.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\nlibrary LibOrders {\n    using LibOracle for address;\n    using U256 for uint256;\n    using Math104 for uint104;\n    using U80 for uint80;\n    using U88 for uint88;\n\n    // @dev in seconds\n    function getOffsetTime() internal view returns (uint32 timeInSeconds) {\n        // shouldn't overflow in 136 years\n        return uint32(block.timestamp - Constants.STARTING_TIME); // @dev(safe-cast)\n    }\n\n    // @dev in hours\n    function getOffsetTimeHours() internal view returns (uint24 timeInHours) {\n        return uint24(getOffsetTime() / 1 hours);\n    }\n\n    function convertCR(uint16 cr) internal pure returns (uint256) {\n        return (uint256(cr) * 1 ether) / Constants.TWO_DECIMAL_PLACES;\n    }\n\n    // For matched token reward\n    function increaseSharesOnMatch(\n        address asset,\n        STypes.Order memory order,\n        MTypes.Match memory matchTotal,\n        uint88 eth\n    ) internal {\n        AppStorage storage s = appStorage();\n\n        // @dev use the diff to get more time (2159), to prevent overflow at year 2106\n        uint32 timeTillMatch = getOffsetTime() - order.creationTime;\n        if (timeTillMatch > Constants.MIN_DURATION) {\n            // shares in eth-days\n            uint88 shares = eth * (timeTillMatch / 1 days);\n            matchTotal.dittoMatchedShares += shares;\n\n            uint256 vault = s.asset[asset].vault;\n            s.vaultUser[vault][order.addr].dittoMatchedShares += shares;\n        }\n    }\n\n    function currentOrders(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset\n    ) internal view returns (STypes.Order[] memory) {\n        uint16 currentId = orders[asset][Constants.HEAD].nextId;\n        uint256 size;\n\n        while (currentId != Constants.TAIL) {\n            size++;\n            currentId = orders[asset][currentId].nextId;\n        }\n\n        STypes.Order[] memory list = new STypes.Order[](size);\n        currentId = orders[asset][Constants.HEAD].nextId; // reset currentId\n\n        for (uint256 i = 0; i < size; i++) {\n            list[i] = orders[asset][currentId];\n            currentId = orders[asset][currentId].nextId;\n        }\n        return list;\n    }\n\n    function isShort(STypes.Order memory order) internal pure returns (bool) {\n        return order.orderType == O.LimitShort;\n    }\n\n    function addBid(\n        address asset,\n        STypes.Order memory order,\n        MTypes.OrderHint[] memory orderHintArray\n    ) internal {\n        AppStorage storage s = appStorage();\n        uint16 hintId;\n\n        if (order.orderType == O.MarketBid) {\n            return;\n        }\n        uint16 nextId = s.bids[asset][Constants.HEAD].nextId;\n        if (order.price > s.bids[asset][nextId].price || nextId == Constants.TAIL) {\n            hintId = Constants.HEAD;\n        } else {\n            hintId = findOrderHintId(s.bids, asset, orderHintArray);\n        }\n\n        addOrder(s.bids, asset, order, hintId);\n\n        uint256 vault = s.asset[asset].vault;\n        uint88 eth = order.ercAmount.mulU88(order.price);\n        s.vaultUser[vault][order.addr].ethEscrowed -= eth;\n    }\n\n    function addAsk(\n        address asset,\n        STypes.Order memory order,\n        MTypes.OrderHint[] memory orderHintArray\n    ) internal {\n        AppStorage storage s = appStorage();\n        uint16 hintId;\n\n        if (order.orderType == O.MarketAsk) {\n            return;\n        }\n        uint16 nextId = s.asks[asset][Constants.HEAD].nextId;\n        if (order.price < s.asks[asset][nextId].price || nextId == Constants.TAIL) {\n            hintId = Constants.HEAD;\n        } else {\n            hintId = findOrderHintId(s.asks, asset, orderHintArray);\n        }\n        addOrder(s.asks, asset, order, hintId);\n\n        s.assetUser[asset][order.addr].ercEscrowed -= order.ercAmount;\n    }\n\n    /**\n     * @notice Add short struct onto market\n     *\n     * @param asset The market that will be impacted\n     * @param order The short struct passed from shortMatchAlgo\n     * @param orderHintArray array of Id passed in front end for optimized looping\n     */\n\n    function addShort(\n        address asset,\n        STypes.Order memory order,\n        MTypes.OrderHint[] memory orderHintArray\n    ) internal {\n        AppStorage storage s = appStorage();\n        uint16 hintId;\n        uint16 nextId = s.shorts[asset][Constants.HEAD].nextId;\n        if (order.price < s.shorts[asset][nextId].price || nextId == Constants.TAIL) {\n            hintId = Constants.HEAD;\n        } else {\n            hintId = findOrderHintId(s.shorts, asset, orderHintArray);\n        }\n\n        //@dev: Only need to set this when placing incomingShort onto market\n        addOrder(s.shorts, asset, order, hintId);\n        updateStartingShortIdViaShort(asset, order);\n        uint256 vault = s.asset[asset].vault;\n        uint88 eth = order.ercAmount.mulU88(order.price).mulU88(\n            LibOrders.convertCR(order.initialMargin)\n        );\n        s.vaultUser[vault][order.addr].ethEscrowed -= eth;\n    }\n\n    /**\n     * @notice Add ask/short struct onto market\n     *\n     * @param asset The market that will be impacted\n     * @param incomingOrder The ask or short struct passed from sellMatchAlgo\n     * @param orderHintArray array of Id passed in front end for optimized looping\n     */\n\n    function addSellOrder(\n        STypes.Order memory incomingOrder,\n        address asset,\n        MTypes.OrderHint[] memory orderHintArray\n    ) private {\n        O o = normalizeOrderType(incomingOrder.orderType);\n        if (o == O.LimitShort) {\n            addShort(asset, incomingOrder, orderHintArray);\n        } else if (o == O.LimitAsk) {\n            addAsk(asset, incomingOrder, orderHintArray);\n        }\n    }\n\n    /**\n     * @notice Adds order onto market\n     * @dev Reuses order ids for gas saving and id recycling\n     *\n     * @param orders the order mapping\n     * @param asset The market that will be impacted\n     * @param incomingOrder Bid, Ask, or Short Order\n     * @param hintId Id passed in front end for optimized looping\n     */\n\n    // @dev partial addOrder\n    function addOrder(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset,\n        STypes.Order memory incomingOrder,\n        uint16 hintId\n    ) private {\n        AppStorage storage s = appStorage();\n        // hint.prevId <-> hint <-> hint.nextId\n        // set links of incoming to hint\n        uint16 prevId = findPrevOfIncomingId(orders, asset, incomingOrder, hintId);\n        uint16 nextId = orders[asset][prevId].nextId;\n        incomingOrder.prevId = prevId;\n        incomingOrder.nextId = nextId;\n        uint16 id = incomingOrder.id;\n        uint16 canceledID = orders[asset][Constants.HEAD].prevId;\n        // @dev (ID) is exiting, [ID] is inserted\n        // in this case, the protocol is re-using (ID) and moving it to [ID]\n        // check if a previously cancelled or matched order exists\n        if (canceledID != Constants.HEAD) {\n            incomingOrder.prevOrderType = orders[asset][canceledID].orderType;\n            // BEFORE: CancelledID <- (ID) <- HEAD <-> .. <-> PREV <----------> NEXT\n            // AFTER1: CancelledID <--------- HEAD <-> .. <-> PREV <-> [ID] <-> NEXT\n            uint16 prevCanceledID = orders[asset][canceledID].prevId;\n            if (prevCanceledID != Constants.HEAD) {\n                orders[asset][Constants.HEAD].prevId = prevCanceledID;\n            } else {\n                // BEFORE: HEAD <- (ID) <- HEAD <-> .. <-> PREV <----------> NEXT\n                // AFTER1: HEAD <--------- HEAD <-> .. <-> PREV <-> [ID] <-> NEXT\n                orders[asset][Constants.HEAD].prevId = Constants.HEAD;\n            }\n            // re-use the previous order's id\n            id = incomingOrder.id = canceledID;\n        } else {\n            // BEFORE: HEAD <-> .. <-> PREV <--------------> NEXT\n            // AFTER1: HEAD <-> .. <-> PREV <-> (NEW ID) <-> NEXT\n            // otherwise just increment to a new order id\n            // and the market grows in height/size\n            s.asset[asset].orderId += 1;\n        }\n        orders[asset][id] = incomingOrder;\n        if (nextId != Constants.TAIL) {\n            orders[asset][nextId].prevId = incomingOrder.id;\n        }\n\n        orders[asset][prevId].nextId = incomingOrder.id;\n    }\n\n    /**\n     * @notice Verifies that bid id is between two id based on price\n     *\n     * @param asset The market that will be impacted\n     * @param _prevId The first id supposedly preceding the new price\n     * @param _newPrice price of prospective order\n     * @param _nextId The first id supposedly following the new price\n     *\n     * @return direction int direction to search (PREV, EXACT, NEXT)\n     */\n\n    function verifyBidId(address asset, uint16 _prevId, uint256 _newPrice, uint16 _nextId)\n        internal\n        view\n        returns (int256 direction)\n    {\n        AppStorage storage s = appStorage();\n        //@dev: TAIL can't be prevId because it will always be last item in list\n        bool check1 =\n            s.bids[asset][_prevId].price >= _newPrice || _prevId == Constants.HEAD;\n        bool check2 =\n            _newPrice > s.bids[asset][_nextId].price || _nextId == Constants.TAIL;\n\n        if (check1 && check2) {\n            return Constants.EXACT;\n        } else if (!check1) {\n            return Constants.PREV;\n        } else if (!check2) {\n            return Constants.NEXT;\n        }\n    }\n\n    /**\n     * @notice Verifies that short id is between two id based on price\n     *\n     * @param asset The market that will be impacted\n     * @param _prevId The first id supposedly preceding the new price\n     * @param _newPrice price of prospective order\n     * @param _nextId The first id supposedly following the new price\n     *\n     * @return direction int direction to search (PREV, EXACT, NEXT)\n     */\n    function verifySellId(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset,\n        uint16 _prevId,\n        uint256 _newPrice,\n        uint16 _nextId\n    ) private view returns (int256 direction) {\n        //@dev: TAIL can't be prevId because it will always be last item in list\n        bool check1 =\n            orders[asset][_prevId].price <= _newPrice || _prevId == Constants.HEAD;\n\n        bool check2 =\n            _newPrice < orders[asset][_nextId].price || _nextId == Constants.TAIL;\n\n        if (check1 && check2) {\n            return Constants.EXACT;\n        } else if (!check1) {\n            return Constants.PREV;\n        } else if (!check2) {\n            return Constants.NEXT;\n        }\n    }\n\n    /**\n     * @notice Handles the reordering of market when order is canceled\n     * @dev Reuses order ids for gas saving and id recycling\n     *\n     * @param orders the order mapping\n     * @param asset The market that will be impacted\n     * @param id Id of order\n     */\n\n    function cancelOrder(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset,\n        uint16 id\n    ) internal {\n        // save this since it may be replaced\n        uint16 prevHEAD = orders[asset][Constants.HEAD].prevId;\n\n        // remove the links of ID in the market\n        // @dev (ID) is exiting, [ID] is inserted\n        // BEFORE: PREV <-> (ID) <-> NEXT\n        // AFTER : PREV <----------> NEXT\n        orders[asset][orders[asset][id].nextId].prevId = orders[asset][id].prevId;\n        orders[asset][orders[asset][id].prevId].nextId = orders[asset][id].nextId;\n\n        // create the links using the other side of the HEAD\n        emit Events.CancelOrder(asset, id, orders[asset][id].orderType);\n        _reuseOrderIds(orders, asset, id, prevHEAD, O.Cancelled);\n    }\n\n    /**\n     * @notice moves the matched id to the prev side of HEAD\n     * @dev this is how an id gets re-used\n     *\n     * @param orders the order mapping\n     * @param asset The market that will be impacted\n     * @param id ID of most recent matched order\n     *\n     */\n    function matchOrder(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset,\n        uint16 id\n    ) internal {\n        uint16 prevHEAD = orders[asset][Constants.HEAD].prevId;\n        _reuseOrderIds(orders, asset, id, prevHEAD, O.Matched);\n    }\n\n    // shared function for both canceling and order and matching an order\n    function _reuseOrderIds(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset,\n        uint16 id,\n        uint16 prevHEAD,\n        O cancelledOrMatched\n    ) private {\n        // matching ID1 and ID2\n        // BEFORE: HEAD <- <---------------- HEAD <-> (ID1) <-> (ID2) <-> (ID3) <-> NEXT\n        // AFTER1: HEAD <- [ID1] <---------- HEAD <-----------> (ID2) <-> (ID3) <-> NEXT\n        // AFTER2: HEAD <- [ID1] <- [ID2] <- HEAD <---------------------> (ID3) <-> NEXT\n\n        // @dev mark as cancelled instead of deleting the order itself\n        orders[asset][id].orderType = cancelledOrMatched;\n        orders[asset][Constants.HEAD].prevId = id;\n        // Move the cancelled ID behind HEAD to re-use it\n        // note: C_IDs (cancelled ids) only need to point back (set prevId, can retain nextId)\n        // BEFORE: .. C_ID2 <- C_ID1 <--------- HEAD <-> ... [ID]\n        // AFTER1: .. C_ID2 <- C_ID1 <- [ID] <- HEAD <-> ...\n        if (prevHEAD != Constants.HEAD) {\n            orders[asset][id].prevId = prevHEAD;\n        } else {\n            // if this is the first ID cancelled\n            // HEAD.prevId needs to be HEAD\n            // and one of the cancelled id.prevID should point to HEAD\n            // BEFORE: HEAD <--------- HEAD <-> ... [ID]\n            // AFTER1: HEAD <- [ID] <- HEAD <-> ...\n            orders[asset][id].prevId = Constants.HEAD;\n        }\n    }\n\n    /**\n     * @notice Helper function for finding the (previous) id so that an incoming\n     * @notice order can be placed onto the correct market.\n     * @notice Uses hintId if possible, otherwise fallback to traversing the\n     * @notice list of orders starting from HEAD\n     *\n     * @param orders the order mapping\n     * @param asset The market that will be impacted\n     * @param incomingOrder the Order to be placed\n     * @param hintId Id used to optimize finding the place to insert into ob\n     */\n\n    function findPrevOfIncomingId(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset,\n        STypes.Order memory incomingOrder,\n        uint16 hintId\n    ) internal view returns (uint16) {\n        uint16 nextId = orders[asset][hintId].nextId;\n\n        // if invalid hint (if the id points to 0 then it's an empty id)\n        if (hintId == 0 || nextId == 0) {\n            return getOrderId(\n                orders,\n                asset,\n                Constants.NEXT,\n                Constants.HEAD,\n                incomingOrder.price,\n                incomingOrder.orderType\n            );\n        }\n\n        // check if the hint is valid\n        int256 direction = verifyId(\n            orders, asset, hintId, incomingOrder.price, nextId, incomingOrder.orderType\n        );\n\n        // if its 0, it's correct\n        // otherwise it could be off because a tx could of modified state\n        // so search in a direction based on price.\n        if (direction == Constants.EXACT) {\n            return hintId;\n        } else if (direction == Constants.NEXT) {\n            return getOrderId(\n                orders,\n                asset,\n                Constants.NEXT,\n                nextId,\n                incomingOrder.price,\n                incomingOrder.orderType\n            );\n        } else {\n            uint16 prevId = orders[asset][hintId].prevId;\n            return getOrderId(\n                orders,\n                asset,\n                Constants.PREV,\n                prevId,\n                incomingOrder.price,\n                incomingOrder.orderType\n            );\n        }\n    }\n\n    /**\n     * @notice Verifies that an id is between two id based on price and orderType\n     *\n     * @param asset The market that will be impacted\n     * @param prevId The first id supposedly preceding the new price\n     * @param newPrice price of prospective order\n     * @param nextId The first id supposedly following the new price\n     * @param orderType order type (bid, ask, short)\n     *\n     * @return direction int direction to search (PREV, EXACT, NEXT)\n     */\n    function verifyId(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset,\n        uint16 prevId,\n        uint256 newPrice,\n        uint16 nextId,\n        O orderType\n    ) internal view returns (int256 direction) {\n        orderType = normalizeOrderType(orderType);\n\n        if (orderType == O.LimitAsk || orderType == O.LimitShort) {\n            return verifySellId(orders, asset, prevId, newPrice, nextId);\n        } else if (orderType == O.LimitBid) {\n            return verifyBidId(asset, prevId, newPrice, nextId);\n        }\n    }\n\n    // @dev not used to change state, just which methods to call\n    function normalizeOrderType(O o) private pure returns (O newO) {\n        if (o == O.LimitBid || o == O.MarketBid) {\n            return O.LimitBid;\n        } else if (o == O.LimitAsk || o == O.MarketAsk) {\n            return O.LimitAsk;\n        } else if (o == O.LimitShort) {\n            return O.LimitShort;\n        }\n    }\n\n    /**\n     * @notice Helper function for finding and returning id of potential order\n     *\n     * @param orders the order mapping\n     * @param asset The market that will be impacted\n     * @param direction int direction to search (PREV, EXACT, NEXT)\n     * @param hintId hint id\n     * @param _newPrice price of prospective order used to find the id\n     * @param orderType which OrderType to verify\n     */\n\n    function getOrderId(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset,\n        int256 direction,\n        uint16 hintId,\n        uint256 _newPrice,\n        O orderType\n    ) internal view returns (uint16 _hintId) {\n        while (true) {\n            uint16 nextId = orders[asset][hintId].nextId;\n\n            if (\n                verifyId(orders, asset, hintId, _newPrice, nextId, orderType)\n                    == Constants.EXACT\n            ) {\n                return hintId;\n            }\n\n            if (direction == Constants.PREV) {\n                uint16 prevId = orders[asset][hintId].prevId;\n                hintId = prevId;\n            } else {\n                hintId = nextId;\n            }\n        }\n    }\n\n    /**\n     * @notice Helper function for updating the bids mapping when matched\n     * @dev More efficient way to remove matched orders. Instead\n     * @dev Instead of canceling each one, just wait till the last match and only swap prevId/nextId there, since the rest are gone\n     *\n     * @param orders The market that will be impacted\n     * @param asset The market that will be impacted\n     * @param id Most recent matched Bid\n     * @param isOrderFullyFilled Boolean to see if full or partial\n     */\n    function updateBidOrdersOnMatch(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset,\n        uint16 id,\n        bool isOrderFullyFilled\n    ) internal {\n        // BEFORE: HEAD <-> ... <-> (ID) <-> NEXT\n        // AFTER : HEAD <------------------> NEXT\n        if (isOrderFullyFilled) {\n            _updateOrders(orders, asset, Constants.HEAD, id);\n        } else {\n            // BEFORE: HEAD <-> ... <-> (ID)\n            // AFTER : HEAD <---------> (ID)\n            orders[asset][id].prevId = Constants.HEAD;\n            orders[asset][Constants.HEAD].nextId = id;\n        }\n    }\n\n    /**\n     * @notice Helper function for updating the asks/shorts mapping when matched by incomingBid\n     * @dev firstShortId isn't necessarily HEAD because orders start matching from oracle price\n     *\n     * @param asset The market that will be impacted\n     * @param b Memory based struct passed from BidMatchAlgo\n     */\n    function updateSellOrdersOnMatch(address asset, MTypes.BidMatchAlgo memory b)\n        internal\n    {\n        AppStorage storage s = appStorage();\n        if (b.matchedAskId != 0) {\n            _updateOrders(s.asks, asset, Constants.HEAD, b.matchedAskId);\n        }\n\n        if (b.matchedShortId != 0) {\n            if (!b.isMovingBack && !b.isMovingFwd) {\n                //@dev Handles only matching one thing\n                //@dev If does not get fully matched, b.matchedShortId == 0 and therefore not hit this block\n                _updateOrders(s.shorts, asset, b.prevShortId, b.matchedShortId);\n            } else if (!b.isMovingBack && b.isMovingFwd) {\n                //@dev Handles moving forward only\n                _updateOrders(\n                    s.shorts, asset, b.firstShortIdBelowOracle, b.matchedShortId\n                );\n            } else if (b.isMovingBack && !b.isMovingFwd) {\n                //@handles moving backwards only.\n                _updateOrders(s.shorts, asset, b.prevShortId, b.shortHintId);\n            } else if (b.isMovingBack && b.isMovingFwd) {\n                uint16 id = b.prevShortId == b.firstShortIdBelowOracle\n                    ? b.shortHintId\n                    : b.matchedShortId;\n                //@dev Handle going backward and forward\n                _updateOrders(s.shorts, asset, b.firstShortIdBelowOracle, id);\n            }\n        }\n    }\n\n    /**\n     * @notice Base helper function for updating any kind of orders\n     *\n     * @param orders the order mapping\n     * @param asset The market that will be impacted\n     * @param headId Either HEAD or first SHORT with price >= oracle price\n     * @param lastMatchedId Most recent matched SHORT in a specific Bid transaction\n     */\n    function _updateOrders(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset,\n        uint16 headId,\n        uint16 lastMatchedId\n    ) private {\n        // BEFORE: FIRST <-> ... <-> (LAST) <-> NEXT\n        // AFTER : FIRST <--------------------> NEXT\n        uint16 nextAskId = orders[asset][lastMatchedId].nextId;\n        if (nextAskId != Constants.TAIL) {\n            orders[asset][nextAskId].prevId = headId;\n        }\n        orders[asset][headId].nextId = nextAskId;\n    }\n\n    /**\n     * @notice The matching algorithm for asks\n     *\n     * @param asset The market that will be impacted\n     * @param incomingAsk Newly created ask struct\n     * @param orderHintArray Id passed in from front end for optimized looping\n     * @param minAskEth Minimum ask dust amount\n     *\n     */\n\n    function sellMatchAlgo(\n        address asset,\n        STypes.Order memory incomingAsk,\n        MTypes.OrderHint[] memory orderHintArray,\n        uint256 minAskEth\n    ) internal {\n        AppStorage storage s = appStorage();\n        uint16 startingId = s.bids[asset][Constants.HEAD].nextId;\n        STypes.Order storage highestBidInitial = s.bids[asset][startingId];\n        if (incomingAsk.price > highestBidInitial.price) {\n            if (incomingAsk.ercAmount.mul(incomingAsk.price) >= minAskEth) {\n                addSellOrder(incomingAsk, asset, orderHintArray);\n            }\n            return;\n        }\n        // matching loop starts\n        MTypes.Match memory matchTotal;\n        while (true) {\n            STypes.Order memory highestBid = s.bids[asset][startingId];\n            if (incomingAsk.price <= highestBid.price) {\n                // Consider ask filled if only dust amount left\n                if (incomingAsk.ercAmount.mul(highestBid.price) == 0) {\n                    updateBidOrdersOnMatch(s.bids, asset, highestBid.id, false);\n                    incomingAsk.ercAmount = 0;\n                    matchIncomingSell(asset, incomingAsk, matchTotal);\n                    return;\n                }\n                matchHighestBid(incomingAsk, highestBid, asset, matchTotal);\n                if (incomingAsk.ercAmount > highestBid.ercAmount) {\n                    incomingAsk.ercAmount -= highestBid.ercAmount;\n                    highestBid.ercAmount = 0;\n                    matchOrder(s.bids, asset, highestBid.id);\n\n                    // loop\n                    startingId = highestBid.nextId;\n                    if (startingId == Constants.TAIL) {\n                        incomingAsk.shortRecordId =\n                            matchIncomingSell(asset, incomingAsk, matchTotal);\n\n                        if (incomingAsk.ercAmount.mul(incomingAsk.price) >= minAskEth) {\n                            addSellOrder(incomingAsk, asset, orderHintArray);\n                        }\n                        s.bids[asset][Constants.HEAD].nextId = Constants.TAIL;\n                        return;\n                    }\n                } else {\n                    // If the product of remaining ercAmount and price rounds down to 0 just close the bid order\n                    bool dustErcAmount = (highestBid.ercAmount - incomingAsk.ercAmount)\n                        .mul(highestBid.price) == 0;\n\n                    if (dustErcAmount || incomingAsk.ercAmount == highestBid.ercAmount) {\n                        matchOrder(s.bids, asset, highestBid.id);\n                        updateBidOrdersOnMatch(s.bids, asset, highestBid.id, true);\n                    } else {\n                        s.bids[asset][highestBid.id].ercAmount =\n                            highestBid.ercAmount - incomingAsk.ercAmount;\n                        updateBidOrdersOnMatch(s.bids, asset, highestBid.id, false);\n                    }\n                    incomingAsk.ercAmount = 0;\n                    matchIncomingSell(asset, incomingAsk, matchTotal);\n                    return;\n                }\n            } e"
    }
  ]
}