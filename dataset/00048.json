{
  "Title": "M-5: Slippage on `MetapoolRouter.addLiquidityOneETHKeepYt`",
  "Content": "# Issue M-5: Slippage on `MetapoolRouter.addLiquidityOneETHKeepYt` \n\nSource: https://github.com/sherlock-audit/2024-05-napier-update-judging/issues/28 \n\n## Found by \nIronsidesec\n## Summary\nAs a user, I don't want to mint liquidity at a lower LP price and receive the manipulated / hugely changed YT price/amount.\n\nA user can call `MetapoolRouter.addLiquidityOneETHKeepYt` to add liquidity (only PT) to metaPool (PT -tricrypto) and get YT (yield tokens)\nThere's slippage protection `minLiquidity`, but no `minYT`.\nDue to volatility or MEV or normal events listed below, the amount of YT tokens received can be fewer which were issued at inflated price which dips within few blocks or receive huge at dipped price because there is no slippage to amount of YT you get.\n\n## Vulnerability Detail\n\n1. Issue PT and YT using the received ETH\n2. Add liquidity to the Curve metapool\n3. Send the received LP token and YT to the recipient\n\n**Attack / issue flow** :\n1. The amount of liquidity to mint depends on the `3LST-PT TriCrypto LP token`, `Napier Principal Token`, and the global scales when issuing the PT + YT tokens.\n2. So, if someone removed PT from twocrypto ,then adding even fewer PT tokens than normal will mint more liquidity. So, if the global scales or tranche issues changes, the value of PT decreases, so someone removes PT tokens from two crytpo LP, and since price of PT decreases, makes the amount of YT increase.\n3. The exact opposite scenario can happen, where fewer YT tokes are issued but minimum liquidity slippage is passed. So, as a user I don't want to receive lower YT tokens when price of PT/YT suddenly changed. Add slippage to amount of PY issued.\n\nDuring the issuance, the user will deposit underlying assets (e.g., ETH) to the Tranche contract, and the Tranche contract will forward them to the Adaptor contract for depositing. The number of shares minted is depending on the current scale of the adaptor. The current scale of the adaptor can increase or decrease at any time, depending on the current on-chain condition when the transaction is executed. For instance, the LIDO's daily oracle/rebase update will increase the stETH balance, which will, in turn, increase the adaptor's scale. On the other hand, if there is a mass validator slashing event, the ETH claimed from the withdrawal queue will be less than expected, leading to a decrease in the adaptor's scale. Thus, one cannot ensure the result from the off-chain simulation will be the same as the on-chain execution.\n\nhttps://github.com/sherlock-audit/2024-05-napier-update/blob/c31af59c6399182fd04b40530d79d98632d2bfa7/metapool-router/src/MetapoolRouter.sol#L356-L392\n\n```solidity\nFile: 2024-05-napier-update\\metapool-router\\src\\MetapoolRouter.sol\n\n371:     function addLiquidityOneETHKeepYt(address metapool, uint256 minLiquidity, address recipient, uint256 deadline)\n372:         external payable nonReentrant checkDeadline(deadline) checkMetapool(metapool) returns (uint256 liquidity)\n378:     {\n379:         // Steps:\n380:         // 1. Issue PT and YT using the received ETH\n381:         // 2. Add liquidity to the Curve metapool\n382:         // 3. Send the received LP token and YT to the recipient\n383: \n...SNIP...\n393:         uint256 pyAmount = pt.issue({to: address(this), underlyingAmount: msg.value}); \n395: \n...SNIP...\n401:         liquidity = Twocrypto(metapool).add_liquidity({\n402:             amounts: [pyAmount, 0],\n403:             min_mint_amount: minLiquidity,\n404:             receiver: recipient\n405:         });\n406: \n407:   >>>   IERC20(pt.yieldToken()).transfer(recipient, pyAmount); \n409:     }\n\n```\n\n## Impact\nLoss of YT tokens. Unintended amount of YT is received.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-05-napier-update/blob/c31af59c6399182fd04b40530d79d98632d2bfa7/metapool-router/src/MetapoolRouter.sol#L356-L392\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nImplement a slippage control that allows the users to revert if the amount of YT they received is less than the amount they expected.\n\nhttps://github.com/sherlock-audit/2024-05-napier-update/blob/c31af59c6399182fd04b40530d79d98632d2bfa7/metapool-router/src/MetapoolRouter.sol#L356-L392\n\n```diff\n-   function addLiquidityOneETHKeepYt(address metapool, uint256 minLiquidity, address recipient, uint256 deadline)\n+   function addLiquidityOneETHKeepYt(address metapool, uint256 minLiquidity, uint256 minYT, address recipient, uint256 deadline)\n        external\n        payable\n        nonReentrant\n        checkDeadline(deadline)\n        checkMetapool(metapool)\n        returns (uint256 liquidity)\n    {\n...\n\n        ITranche pt = ITranche(Twocrypto(metapool).coins(PEGGED_PT_INDEX));\n        // Issue PT and YT using the received ETH\n        if (_isApproved(address(WETH9), address(pt)) == 0) {\n            _setApproval(address(WETH9), address(pt));\n            WETH9.approve(address(pt), type(uint256).max);\n        }\n        uint256 pyAmount = pt.issue({to: address(this), underlyingAmount: msg.value}); \n+       if (pyAmount < minYT) revert InsufficientYTOut();\n\n        // Add liquidity to the Curve metapool\n        if (_isApproved(address(pt), metapool) == 0) {\n            _setApproval(address(pt), metapool);\n            pt.approve(metapool, type(uint256).max);\n        }\n...\n    }\n```\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/napierfi/metapool-router/pull/30\n\n\n**sherlock-admin2**\n\nThe Lead Senior Watson signed off on the fix.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/369",
  "Code": [
    {
      "filename": "metapool-router/src/MetapoolRouter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.24;\n\n// Interfaces\nimport {IERC20, SafeERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/utils/SafeERC20.sol\";\nimport {CurveTricryptoOptimizedWETH} from \"@napier/v1-pool/src/interfaces/external/CurveTricryptoOptimizedWETH.sol\";\nimport {CurveTricryptoFactory} from \"@napier/v1-pool/src/interfaces/external/CurveTricryptoFactory.sol\";\nimport {IWETH9} from \"@napier/v1-tranche/src/interfaces/IWETH9.sol\";\nimport {INapierPool} from \"@napier/v1-pool/src/interfaces/INapierPool.sol\";\nimport {ITranche} from \"@napier/v1-tranche/src/interfaces/ITranche.sol\";\nimport {Twocrypto} from \"./interfaces/external/Twocrypto.sol\";\nimport {IVault} from \"./interfaces/external/balancer/IVault.sol\";\nimport {IFlashLoanRecipient} from \"./interfaces/external/balancer/IFlashLoanRecipient.sol\";\nimport {MetapoolFactory} from \"./MetapoolFactory.sol\";\n\nimport {IMetapoolRouter} from \"./interfaces/IMetapoolRouter.sol\";\n\n// Libraries\nimport {TransientStorage} from \"./TransientStorage.sol\";\nimport {Math} from \"@openzeppelin/contracts@4.9.3/utils/math/Math.sol\";\nimport {TrancheMathHelper} from \"@napier/v1-pool/src/libs/TrancheMathHelper.sol\";\nimport {ApproxParams} from \"@napier/v1-pool/src/interfaces/ApproxParams.sol\";\nimport {Errors} from \"./Errors.sol\";\n\n// Inherits\nimport {ReentrancyGuard} from \"@openzeppelin/contracts@4.9.3/security/ReentrancyGuard.sol\";\n\n/// @title MetapoolRouter - A contract for swapping between PT, YT, and ETH on the 3LST NapierPool, 3LST-PT tricrypto, and Twocrypto metapools\ncontract MetapoolRouter is ReentrancyGuard, IFlashLoanRecipient, IMetapoolRouter {\n    /// @dev Constants for the Twocrypto metapool indexes\n    /// coins(0) is the pegged token (PT) and coins(1) is the base pool token (triLST-PT Tricrypto)\n    uint128 constant PEGGED_PT_INDEX = 0;\n    uint128 constant BASE_POOL_INDEX = 1;\n\n    /// @dev Transient storage slots\n    uint256 constant TSLOT_0 = 0; // Authorization flag for `receiveFlashLoan`\n    uint256 constant TSLOT_1 = 1; // Temporary storage for `swapETHForYt` function return value\n    uint256 constant TSLOT_CB_DATA_METAPOOL = 2; // `FlashLoanData.metapool` slot for `receiveFlashLoan` callback data\n    uint256 constant TSLOT_CB_DATA_PT = 3; // `FlashLoanData.pt` slot for `receiveFlashLoan` callback data\n    uint256 constant TSLOT_CB_DATA_SENDER = 4; // `FlashLoanData.sender` slot for `receiveFlashLoan` callback data\n    uint256 constant TSLOT_CB_DATA_VALUE = 5; // `FlashLoanData.msgValue` slot for `receiveFlashLoan` callback data\n    uint256 constant TSLOT_CB_DATA_MAX_ETH_SPENT = 6; // `FlashLoanData.maxEthSpent` slot for `receiveFlashLoan` callback data\n    uint256 constant TSLOT_CB_DATA_RECEIPIENT = 7; // `FlashLoanData.recipient` slot for `receiveFlashLoan` callback data\n\n    /// @notice The WETH9 contract\n    IWETH9 public immutable WETH9;\n\n    /// @notice The Factory contract for the Principal Token metapools\n    MetapoolFactory public immutable metapoolFactory;\n\n    /// @notice The rETH-PT<>stETH-PT<>sfrxETH-PT Curve TricryptoNG pool (triLST-PT Tricrypto)\n    CurveTricryptoOptimizedWETH public immutable tricryptoLST;\n\n    /// @notice The triLST-PT<>WETH NapierPool\n    INapierPool public immutable triLSTPool;\n\n    /// @notice The Balancer Vault contract for flash loans\n    IVault public immutable vault;\n\n    /// @dev The approval slot of (`token`, `spender`) is given by:\n    /// ```\n    ///     mstore(0x20, spender)\n    ///     mstore(0x0c, _IS_APPROVED_SLOT_SEED)\n    ///     mstore(0x00, token)\n    ///     let allowanceSlot := keccak256(0x0c, 0x34)\n    /// ```\n    /// @dev Optimized storage slot for approval flags\n    /// `mapping (address token => mapping (address spender => uint256 approved)) _isApproved;`\n    uint256 private constant _IS_APPROVED_SLOT_SEED = 0xa8fe4407;\n\n    /// @notice If the transaction is too old, revert.\n    /// @param deadline Transaction deadline in unix timestamp\n    modifier checkDeadline(uint256 deadline) {\n        if (block.timestamp > deadline) revert Errors.MetapoolRouterTransactionTooOld();\n        _;\n    }\n\n    /// @notice If the metapool is not a TwoCrypto with Principal Token, revert.\n    modifier checkMetapool(address metapool) {\n        if (!metapoolFactory.isPtMetapool(metapool)) revert Errors.MetapoolRouterInvalidMetapool();\n        _;\n    }\n\n    receive() external payable {\n        if (msg.sender != address(WETH9)) revert Errors.NotWETH();\n    }\n\n    constructor(MetapoolFactory _metapoolFactory, INapierPool _triLSTPool, IVault _vault) {\n        metapoolFactory = _metapoolFactory;\n        triLSTPool = _triLSTPool;\n        vault = _vault;\n        WETH9 = IWETH9(_metapoolFactory.WETH9());\n        tricryptoLST = _triLSTPool.tricrypto();\n\n        (bool s, bytes memory data) = CurveTricryptoOptimizedWETH(tricryptoLST).factory().staticcall(\n            abi.encodeWithSignature(\"get_coins(address)\", tricryptoLST)\n        );\n        require(s);\n        address[3] memory coins = abi.decode(data, (address[3]));\n        // Approve rETH-PT<>stETH-PT<>sfrxETH-PT Curve TricryptoNG pool (triLST-PT Tricrypto) to spend meta tokens\n        IERC20(coins[0]).approve(address(tricryptoLST), type(uint256).max);\n        IERC20(coins[1]).approve(address(tricryptoLST), type(uint256).max);\n        IERC20(coins[2]).approve(address(tricryptoLST), type(uint256).max);\n        // Approve triLST-PT<>WETH NapierPool to spend WETH9\n        SafeERC20.forceApprove(IWETH9(WETH9), address(triLSTPool), type(uint256).max);\n        // Approve triLST-PT<>WETH NapierPool to spend tricryptoLST\n        SafeERC20.forceApprove(tricryptoLST, address(triLSTPool), type(uint256).max);\n    }\n\n    /// @notice Swap ETH for PT\n    /// @notice A caller must send ETH enough greater than the `maxEthSpent`. Remaining ETH will be sent back to the caller.\n    /// @dev This function can't swap ETH for the exact amount of PT because of precision loss. So, `minPtOut` must be specified by the caller.\n    /// @param metapool The address of the Twocrypto metapool\n    /// @param ptAmount The amount of PT tokens to receive\n    /// @param maxEthSpent The maximum amount of ETH to spend in the swap\n    /// @param minPtOut The minimum amount of PT tokens to receive\n    /// @param recipient The address to receive the swapped PT tokens\n    /// @param deadline The timestamp after which the transaction will be reverted\n    /// @return ethSpent The amount of ETH spent in the swap\n    function swapETHForPt(\n        address metapool,\n        uint256 ptAmount,\n        uint256 maxEthSpent,\n        uint256 minPtOut, // TODO: really need this?\n        address recipient,\n        uint256 deadline\n    ) external payable nonReentrant checkDeadline(deadline) checkMetapool(metapool) returns (uint256 ethSpent) {\n        // Steps:\n        // 1. Quote swap PT -> base pool token on triLST-PT Tricrypto (get_dx)\n        // 2. Swap ETH -> base pool token on triLST-PT<>WETH NapierPool\n        // 3. Swap base pool token -> PT on twocrypto metapool\n        // 4. Send remaining ETH to the recipient\n\n        // Calculate the amount of base pool token required for the specified PT amount\n        uint256 basePoolTokenAmount = Twocrypto(metapool).get_dx({i: BASE_POOL_INDEX, j: PEGGED_PT_INDEX, dy: ptAmount});\n\n        // Wrap the received ETH into WETH\n        if (maxEthSpent > msg.value) revert Errors.MetapoolRouterInsufficientETHReceived();\n        _wrapETH(msg.value);\n\n        // Swap the received WETH for the required amount of base pool token on the NapierPool\n        /// @dev Txn may revert if the triLSTPool tries to swap more than the received ETH.\n        ethSpent = triLSTPool.swapUnderlyingForExactBaseLpToken({baseLpOut: basePoolTokenAmount, recipient: metapool});\n\n        // Swap the received base pool token for PT on the Curve metapool\n        Twocrypto(metapool).exchange_received({\n            i: BASE_POOL_INDEX,\n            j: PEGGED_PT_INDEX,\n            dx: basePoolTokenAmount,\n            // `get_dx` has a precision loss, so the actual amount of PT received may be less than `ptAmount`.\n            min_dy: minPtOut,\n            receiver: recipient\n        });\n\n        if (ethSpent > maxEthSpent) revert Errors.MetapoolRouterExceededLimitETHIn();\n\n        // Send the remaining WETH back to the sender\n        uint256 remainingWeth = msg.value - ethSpent;\n        if (remainingWeth > 0) _unwrapWETH(msg.sender, remainingWeth);\n\n        return ethSpent;\n    }\n\n    /// @notice Swap PT for ETH on the Curve metapool through the 3LST-PT<>ETH NapierPool\n    /// @param metapool The address of the Twocrypto metapool\n    /// @param ptAmount The amount of PT to swap\n    /// @param minEthOut The minimum amount of ETH to receive\n    /// @param recipient The address to receive the ETH\n    /// @param deadline The timestamp after which the transaction will be reverted\n    function swapPtForETH(address metapool, uint256 ptAmount, uint256 minEthOut, address recipient, uint256 deadline)\n        external\n        nonReentrant\n        checkDeadline(deadline)\n        checkMetapool(metapool)\n        returns (uint256 ethOut)\n    {\n        // Steps:\n        // 1. Exchange PT for the base pool token on twoCrypto metapool\n        // 2. Swap ETH -> base pool token on twocrypto metapool\n        // 3. Swap the received base pool token -> ETH on triLST-PT<>WETH NapierPool\n        // 4. Send remaining ETH to the recipient\n\n        // Swap PT for the base pool token on the Curve metapool\n        SafeERC20.safeTransferFrom(IERC20(Twocrypto(metapool).coins(PEGGED_PT_INDEX)), msg.sender, metapool, ptAmount);\n        uint256 basePoolTokenAmount =\n            Twocrypto(metapool).exchange_received(PEGGED_PT_INDEX, BASE_POOL_INDEX, ptAmount, 0, address(this));\n\n        // Swap the received base pool token for ETH on the 3LST-PT<>ETH NapierPool\n        ethOut =\n            triLSTPool.swapExactBaseLpTokenForUnderlying({baseLptIn: basePoolTokenAmount, recipient: address(this)});\n\n        // Check slippage\n        if (minEthOut > ethOut) revert Errors.MetapoolRouterInsufficientETHOut();\n\n        // Send native ETH to the recipient\n        _unwrapWETH(recipient, ethOut);\n\n        return ethOut;\n    }\n\n    /// @notice Swap Ethereum (ETH) for Yield Tokens (YT)\n    /// @dev This function first issues PT and YT using ETH, then swaps the PT for the base pool token on the Curve metapool,\n    ///      and finally swaps the received base pool token for ETH on the NapierPool.\n    /// @notice Caller must send enough ETH equal to the `maxEthSpent` and the remaining ETH will be sent back to the caller.\n    /// @dev `recipient` will receive at least `ytAmount` YTs and at most `ytAmount * (1 + approx.eps / 1e18)` YTs.\n    /// @param metapool The address of the Curve metapool contract\n    /// @param ytAmount The amount of YT tokens to receive\n    /// @param maxEthSpent The maximum amount of ETH to spend in the swap\n    /// @param recipient The address to receive the swapped YT tokens\n    /// @param deadline The timestamp after which the transaction will be reverted\n    /// @return ethSpent The amount of ETH spent in the swap\n    function swapETHForYt(\n        address metapool,\n        uint256 ytAmount,\n        uint256 maxEthSpent,\n        address recipient,\n        uint256 deadline,\n        ApproxParams calldata approx\n    ) external payable nonReentrant checkDeadline(deadline) checkMetapool(metapool) returns (uint256 ethSpent) {\n        // Steps:\n        // 1. Estimate the amount of WETH required to issue the PT and YT\n        // 2. Issue PT and YT using the WETH\n        // 3. Swap PT -> Base pool token on the Twocrypto metapool\n        // 4. Swap Base pool token -> ETH on the NapierPool\n        // 5. Refund the remaining WETH to the sender\n\n        ITranche pt = ITranche(Twocrypto(metapool).coins(PEGGED_PT_INDEX));\n\n        if (maxEthSpent > msg.value) revert Errors.MetapoolRouterInsufficientETHReceived();\n\n        // Estimate the amount of WETH required to issue the PT and YT\n        // Bisection method is used to find the approximate amount of WETH needed, which ensures the at least `ytAmount` YT tokens are issued.\n        uint256 wethDeposit =\n            TrancheMathHelper.getApproxUnderlyingNeededByYt({pt: pt, ytDesired: ytAmount, approx: approx});\n\n        // Authorize access to `receiveFlashLoan` at the last step (flag=address(this))\n        assembly {\n            // Note: This slot should be used only for authorization purpose and should be cleared after use\n            tstore(TSLOT_0, address())\n        }\n\n        IERC20[] memory tokens = new IERC20[](1);\n        uint256[] memory amounts = new uint256[](1);\n        tokens[0] = WETH9;\n        amounts[0] = wethDeposit;\n        // Record the flash loan data in the transient storage\n        // Note: Based on try-and-error, passing userData directly is more expensive than using transient storage.\n        assembly {\n            tstore(TSLOT_CB_DATA_METAPOOL, metapool)\n            tstore(TSLOT_CB_DATA_PT, shr(96, shl(96, pt)))\n            tstore(TSLOT_CB_DATA_SENDER, caller())\n            tstore(TSLOT_CB_DATA_VALUE, callvalue())\n            tstore(TSLOT_CB_DATA_MAX_ETH_SPENT, maxEthSpent)\n            tstore(TSLOT_CB_DATA_RECEIPIENT, recipient)\n        }\n\n        _wrapETH(msg.value);\n        vault.flashLoan(this, tokens, amounts, \"\"); // call receiveFlashLoan\n\n        assembly {\n            ethSpent := tload(TSLOT_1)\n            tstore(TSLOT_1, 0) // clear transitient storage\n        }\n\n        return ethSpent;\n    }\n\n    /// @notice Receive the flash loan and run operations to swap ETH for YT\n    /// @dev Revert if the call is not initiated by the `swapETHForYt` function.\n    /// @custom:param userData - Data structure for the flash loan callback data.\n    /// @dev Those members are stored in the transient storage slots with prefix `TSLOT_CB_DATA_`.\n    /// ```\n    /// struct UserData {\n    ///     address _metapool;\n    ///     address _pt;\n    ///     address _sender; // The address of the caller of `swapETHForYt`\n    ///     uint256 _msgValue; // The amount of ETH sent with the call to `swapETHForYt`\n    ///     uint256 _maxEthSpent;\n    ///     address _recipient;\n    /// }\n    /// ```\n    function receiveFlashLoan(\n        IERC20[] calldata, /* tokens */\n        uint256[] calldata amounts,\n        uint256[] calldata feeAmounts,\n        bytes calldata /* userData */\n    ) external {\n        // CHECK\n        // Note: Call only through `swapETHForYt` && from the Vault should be allowed.\n        // This ensures that the function call is invoked by `swapETHForYt` entry point.\n        // Checking `msg.sender == address(vault)` may not be sufficient as the call may be initiated by other contracts and pass arbitrary data.\n        assembly {\n            let ctx := tload(TSLOT_0)\n            tstore(TSLOT_0, 0) // Delete the authorization (flag=address(0))\n            if iszero(eq(ctx, address())) {\n                mstore(0x00, 0x5c501941) // `MetapoolRouterUnauthorized()`\n                revert(0x1c, 0x04)\n            }\n        }\n\n        address pt = TransientStorage.tloadAddress(TSLOT_CB_DATA_PT);\n        address metapool = TransientStorage.tloadAddress(TSLOT_CB_DATA_METAPOOL);\n\n        // Issue PT tokens using the WETH\n        if (_isApproved(address(WETH9), pt) == 0) {\n            _setApproval(address(WETH9), pt);\n            WETH9.approve(pt, type(uint256).max);\n        }\n        uint256 wethDeposit = amounts[0];\n        uint256 pyIssued = ITranche(pt).issue(address(this), wethDeposit);\n\n        // Swap the PT for the base pool token on the Curve metapool\n        ITranche(pt).transfer(metapool, pyIssued);\n        uint256 basePoolTokenOut =\n            Twocrypto(metapool).exchange_received(PEGGED_PT_INDEX, BASE_POOL_INDEX, pyIssued, 0, address(this));\n\n        // Swap the received base pool token for ETH on the NapierPool\n        uint256 wethReceived = triLSTPool.swapExactBaseLpTokenForUnderlying(basePoolTokenOut, address(this));\n\n        // Unreasonable situation: Received more WETH than sold\n        if (wethReceived > wethDeposit) revert Errors.MetapoolRouterNonSituationSwapETHForYt();\n\n        // Calculate the amount of ETH spent in the swap\n        uint256 repayAmount = wethDeposit + feeAmounts[0];\n        uint256 spent = repayAmount - wethReceived; // wethDeposit + feeAmounts[0] - wethReceived\n\n        // Revert if the ETH spent exceeds the specified maximum\n        if (spent > TransientStorage.tloadU256(TSLOT_CB_DATA_MAX_ETH_SPENT)) {\n            revert Errors.MetapoolRouterExceededLimitETHIn();\n        }\n\n        uint256 remaining = TransientStorage.tloadU256(TSLOT_CB_DATA_VALUE) - spent;\n        if (repayAmount > remaining) revert Errors.MetapoolRouterInsufficientETHRepay(); // Can't repay the flash loan\n\n        // Temporarily store a return value of `swapETHForYt` function across the call context\n        assembly {\n            tstore(TSLOT_1, spent)\n        }\n\n        // Transfer the YT tokens to the recipient\n        IERC20(ITranche(pt).yieldToken()).transfer(TransientStorage.tloadAddress(TSLOT_CB_DATA_RECEIPIENT), pyIssued);\n\n        // Repay the flash loan\n        WETH9.transfer(msg.sender, repayAmount);\n\n        // Unwrap and send the remaining WETH back to the sender\n        _unwrapWETH(TransientStorage.tloadAddress(TSLOT_CB_DATA_SENDER), remaining);\n    }\n\n    /// @notice Add liquidity to the Curve metapool using native ETH and receive LP tokens and YT\n    /// @dev Revert if timestamp exceeds the maturity date.\n    /// @param metapool The address of the Curve metapool contract\n    /// @param minLiquidity The minimum amount of LP tokens to receive\n    /// @param recipient The address to receive the LP tokens and YT\n    /// @param deadline The timestamp after which the transaction will be reverted\n    function addLiquidityOneETHKeepYt(address metapool, uint256 minLiquidity, address recipient, uint256 deadline)\n        external\n        payable\n        nonReentrant\n        checkDeadline(deadline)\n        checkMetapool(metapool)\n        returns (uint256 liquidity)\n    {\n        // Steps:\n        // 1. Issue PT and YT using the received ETH\n        // 2. Add liquidity to the Curve metapool\n        // 3. Send the received LP token and YT to the recipient\n\n        // Wrap the received ETH into WETH\n        _wrapETH(msg.value);\n\n        ITranche pt = ITranche(Twocrypto(metapool).coins(PEGGED_PT_INDEX));\n        // Issue PT and YT using the received ETH\n        if (_isApproved(address(WETH9), address(pt)) == 0) {\n            _setApproval(address(WETH9), address(pt));\n            WETH9.approve(address(pt), type(uint256).max);\n        }\n        uint256 pyAmount = pt.issue({to: address(this), underlyingAmount: msg.value});\n\n        // Add liquidity to the Curve metapool\n        if (_isApproved(address(pt), metapool) == 0) {\n            _setApproval(address(pt), metapool);\n            pt.approve(metapool, type(uint256).max);\n        }\n        liquidity = Twocrypto(metapool).add_liquidity({\n            amounts: [pyAmount, 0],\n            min_mint_amount: minLiquidity,\n            receiver: recipient\n        });\n\n        IERC20(pt.yieldToken()).transfer(recipient, pyAmount);\n    }\n\n    /// @notice Remove liquidity from the Curve twocrypto (metapool) and receive native ETH\n    /// @notice Before the maturity date of PT, the PT is not redeemable, so the PT is swapped for the Base pool Token\n    /// @param metapool The address of the Curve metapool contract\n    /// @param liquidity The amount of LP tokens to remove from the Curve twocrypto (metapool)\n    /// @param minEthOut The minimum amount of ETH to receive\n    /// @param recipient The address to receive the ETH\n    /// @param deadline The timestamp after which the transaction will be reverted\n    function removeLiquidityOneETH(\n        address metapool,\n        uint256 liquidity,\n        uint256 minEthOut,\n        address recipient,\n        uint256 deadline\n    ) external nonReentrant checkDeadline(deadline) checkMetapool(metapool) returns (uint256 ethOut) {\n        // Steps:\n        // If PT is matured, redemption of PT is allowed:\n        // 1. Remove liquidity from the Curve metapool and withdraw one PT\n        // 2. Redeem the PT for ETH\n\n        // If PT is not matured: redemption of PT is not allowed yet:\n        // 1. Remove liquidity from the Curve metapool and withdraw one base pool token\n        // 2. Swap the received base pool token for ETH on the NapierPool\n\n        ITranche pt = ITranche(Twocrypto(metapool).coins(PEGGED_PT_INDEX));\n\n        SafeERC20.safeTransferFrom(Twocrypto(metapool), msg.sender, address(this), liquidity);\n\n        if (block.timestamp >= pt.maturity()) {\n            // If PT is matured, we can directly redeem the PT for ETH\n            uint256 ptAmount = Twocrypto(metapool).remove_liquidity_one_coin(liquidity, PEGGED_PT_INDEX, 0);\n            ethOut = pt.redeem({principalAmount: ptAmount, to: address(this), from: address(this)});\n        } else {\n            // Otherwise, redemption of PT is not allowed, so we need to swap the base pool token for ETH\n            uint256 basePoolTokenAmount = Twocrypto(metapool).remove_liquidity_one_coin(liquidity, BASE_POOL_INDEX, 0);\n            ethOut = triLSTPool.swapExactBaseLpTokenForUnderlying(basePoolTokenAmount, address(this));\n        }\n\n        if (minEthOut > ethOut) revert Errors.MetapoolRouterInsufficientETHOut();\n\n        _unwrapWETH(recipient, ethOut);\n    }\n\n    //// Helper functions ////\n\n    /// @dev Get the approval status of the spender for the token. Return 1 if approved, 0 otherwise.\n    function _isApproved(address token, address spender) internal view returns (uint256 approved) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, spender)\n            mstore(0x0c, _IS_APPROVED_SLOT_SEED)\n            mstore(0x00, token)\n            approved := sload(keccak256(0x0c, 0x34))\n        }\n    }\n\n    /// @dev Set the approval status to 1 for the spender for the token.\n    function _setApproval(address token, address spender) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the approval slot and store the amount.\n            mstore(0x20, spender)\n            mstore(0x0c, _IS_APPROVED_SLOT_SEED)\n            mstore(0x00, token)\n            sstore(keccak256(0x0c, 0x34), 1)\n        }\n    }\n\n    function _wrapETH(uint256 value) internal {\n        WETH9.deposit{value: value}();\n    }\n\n    function _unwrapWETH(address recipient, uint256 value) internal {\n        WETH9.withdraw(value);\n        _safeTransferETH(recipient, value);\n    }\n\n    /// @notice transfer ether safely\n    function _safeTransferETH(address to, uint256 value) internal {\n        (bool success,) = to.call{value: value}(new bytes(0));\n        if (!success) revert Errors.FailedToSendEther();\n    }\n}"
    },
    {
      "filename": "metapool-router/src/MetapoolRouter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.24;\n\n// Interfaces\nimport {IERC20, SafeERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/utils/SafeERC20.sol\";\nimport {CurveTricryptoOptimizedWETH} from \"@napier/v1-pool/src/interfaces/external/CurveTricryptoOptimizedWETH.sol\";\nimport {CurveTricryptoFactory} from \"@napier/v1-pool/src/interfaces/external/CurveTricryptoFactory.sol\";\nimport {IWETH9} from \"@napier/v1-tranche/src/interfaces/IWETH9.sol\";\nimport {INapierPool} from \"@napier/v1-pool/src/interfaces/INapierPool.sol\";\nimport {ITranche} from \"@napier/v1-tranche/src/interfaces/ITranche.sol\";\nimport {Twocrypto} from \"./interfaces/external/Twocrypto.sol\";\nimport {IVault} from \"./interfaces/external/balancer/IVault.sol\";\nimport {IFlashLoanRecipient} from \"./interfaces/external/balancer/IFlashLoanRecipient.sol\";\nimport {MetapoolFactory} from \"./MetapoolFactory.sol\";\n\nimport {IMetapoolRouter} from \"./interfaces/IMetapoolRouter.sol\";\n\n// Libraries\nimport {TransientStorage} from \"./TransientStorage.sol\";\nimport {Math} from \"@openzeppelin/contracts@4.9.3/utils/math/Math.sol\";\nimport {TrancheMathHelper} from \"@napier/v1-pool/src/libs/TrancheMathHelper.sol\";\nimport {ApproxParams} from \"@napier/v1-pool/src/interfaces/ApproxParams.sol\";\nimport {Errors} from \"./Errors.sol\";\n\n// Inherits\nimport {ReentrancyGuard} from \"@openzeppelin/contracts@4.9.3/security/ReentrancyGuard.sol\";\n\n/// @title MetapoolRouter - A contract for swapping between PT, YT, and ETH on the 3LST NapierPool, 3LST-PT tricrypto, and Twocrypto metapools\ncontract MetapoolRouter is ReentrancyGuard, IFlashLoanRecipient, IMetapoolRouter {\n    /// @dev Constants for the Twocrypto metapool indexes\n    /// coins(0) is the pegged token (PT) and coins(1) is the base pool token (triLST-PT Tricrypto)\n    uint128 constant PEGGED_PT_INDEX = 0;\n    uint128 constant BASE_POOL_INDEX = 1;\n\n    /// @dev Transient storage slots\n    uint256 constant TSLOT_0 = 0; // Authorization flag for `receiveFlashLoan`\n    uint256 constant TSLOT_1 = 1; // Temporary storage for `swapETHForYt` function return value\n    uint256 constant TSLOT_CB_DATA_METAPOOL = 2; // `FlashLoanData.metapool` slot for `receiveFlashLoan` callback data\n    uint256 constant TSLOT_CB_DATA_PT = 3; // `FlashLoanData.pt` slot for `receiveFlashLoan` callback data\n    uint256 constant TSLOT_CB_DATA_SENDER = 4; // `FlashLoanData.sender` slot for `receiveFlashLoan` callback data\n    uint256 constant TSLOT_CB_DATA_VALUE = 5; // `FlashLoanData.msgValue` slot for `receiveFlashLoan` callback data\n    uint256 constant TSLOT_CB_DATA_MAX_ETH_SPENT = 6; // `FlashLoanData.maxEthSpent` slot for `receiveFlashLoan` callback data\n    uint256 constant TSLOT_CB_DATA_RECEIPIENT = 7; // `FlashLoanData.recipient` slot for `receiveFlashLoan` callback data\n\n    /// @notice The WETH9 contract\n    IWETH9 public immutable WETH9;\n\n    /// @notice The Factory contract for the Principal Token metapools\n    MetapoolFactory public immutable metapoolFactory;\n\n    /// @notice The rETH-PT<>stETH-PT<>sfrxETH-PT Curve TricryptoNG pool (triLST-PT Tricrypto)\n    CurveTricryptoOptimizedWETH public immutable tricryptoLST;\n\n    /// @notice The triLST-PT<>WETH NapierPool\n    INapierPool public immutable triLSTPool;\n\n    /// @notice The Balancer Vault contract for flash loans\n    IVault public immutable vault;\n\n    /// @dev The approval slot of (`token`, `spender`) is given by:\n    /// ```\n    ///     mstore(0x20, spender)\n    ///     mstore(0x0c, _IS_APPROVED_SLOT_SEED)\n    ///     mstore(0x00, token)\n    ///     let allowanceSlot := keccak256(0x0c, 0x34)\n    /// ```\n    /// @dev Optimized storage slot for approval flags\n    /// `mapping (address token => mapping (address spender => uint256 approved)) _isApproved;`\n    uint256 private constant _IS_APPROVED_SLOT_SEED = 0xa8fe4407;\n\n    /// @notice If the transaction is too old, revert.\n    /// @param deadline Transaction deadline in unix timestamp\n    modifier checkDeadline(uint256 deadline) {\n        if (block.timestamp > deadline) revert Errors.MetapoolRouterTransactionTooOld();\n        _;\n    }\n\n    /// @notice If the metapool is not a TwoCrypto with Principal Token, revert.\n    modifier checkMetapool(address metapool) {\n        if (!metapoolFactory.isPtMetapool(metapool)) revert Errors.MetapoolRouterInvalidMetapool();\n        _;\n    }\n\n    receive() external payable {\n        if (msg.sender != address(WETH9)) revert Errors.NotWETH();\n    }\n\n    constructor(MetapoolFactory _metapoolFactory, INapierPool _triLSTPool, IVault _vault) {\n        metapoolFactory = _metapoolFactory;\n        triLSTPool = _triLSTPool;\n        vault = _vault;\n        WETH9 = IWETH9(_metapoolFactory.WETH9());\n        tricryptoLST = _triLSTPool.tricrypto();\n\n        (bool s, bytes memory data) = CurveTricryptoOptimizedWETH(tricryptoLST).factory().staticcall(\n            abi.encodeWithSignature(\"get_coins(address)\", tricryptoLST)\n        );\n        require(s);\n        address[3] memory coins = abi.decode(data, (address[3]));\n        // Approve rETH-PT<>stETH-PT<>sfrxETH-PT Curve TricryptoNG pool (triLST-PT Tricrypto) to spend meta tokens\n        IERC20(coins[0]).approve(address(tricryptoLST), type(uint256).max);\n        IERC20(coins[1]).approve(address(tricryptoLST), type(uint256).max);\n        IERC20(coins[2]).approve(address(tricryptoLST), type(uint256).max);\n        // Approve triLST-PT<>WETH NapierPool to spend WETH9\n        SafeERC20.forceApprove(IWETH9(WETH9), address(triLSTPool), type(uint256).max);\n        // Approve triLST-PT<>WETH NapierPool to spend tricryptoLST\n        SafeERC20.forceApprove(tricryptoLST, address(triLSTPool), type(uint256).max);\n    }\n\n    /// @notice Swap ETH for PT\n    /// @notice A caller must send ETH enough greater than the `maxEthSpent`. Remaining ETH will be sent back to the caller.\n    /// @dev This function can't swap ETH for the exact amount of PT because of precision loss. So, `minPtOut` must be specified by the caller.\n    /// @param metapool The address of the Twocrypto metapool\n    /// @param ptAmount The amount of PT tokens to receive\n    /// @param maxEthSpent The maximum amount of ETH to spend in the swap\n    /// @param minPtOut The minimum amount of PT tokens to receive\n    /// @param recipient The address to receive the swapped PT tokens\n    /// @param deadline The timestamp after which the transaction will be reverted\n    /// @return ethSpent The amount of ETH spent in the swap\n    function swapETHForPt(\n        address metapool,\n        uint256 ptAmount,\n        uint256 maxEthSpent,\n        uint256 minPtOut, // TODO: really need this?\n        address recipient,\n        uint256 deadline\n    ) external payable nonReentrant checkDeadline(deadline) checkMetapool(metapool) returns (uint256 ethSpent) {\n        // Steps:\n        // 1. Quote swap PT -> base pool token on triLST-PT Tricrypto (get_dx)\n        // 2. Swap ETH -> base pool token on triLST-PT<>WETH NapierPool\n        // 3. Swap base pool token -> PT on twocrypto metapool\n        // 4. Send remaining ETH to the recipient\n\n        // Calculate the amount of base pool token required for the specified PT amount\n        uint256 basePoolTokenAmount = Twocrypto(metapool).get_dx({i: BASE_POOL_INDEX, j: PEGGED_PT_INDEX, dy: ptAmount});\n\n        // Wrap the received ETH into WETH\n        if (maxEthSpent > msg.value) revert Errors.MetapoolRouterInsufficientETHReceived();\n        _wrapETH(msg.value);\n\n        // Swap the received WETH for the required amount of base pool token on the NapierPool\n        /// @dev Txn may revert if the triLSTPool tries to swap more than the received ETH.\n        ethSpent = triLSTPool.swapUnderlyingForExactBaseLpToken({baseLpOut: basePoolTokenAmount, recipient: metapool});\n\n        // Swap the received base pool token for PT on the Curve metapool\n        Twocrypto(metapool).exchange_received({\n            i: BASE_POOL_INDEX,\n            j: PEGGED_PT_INDEX,\n            dx: basePoolTokenAmount,\n            // `get_dx` has a precision loss, so the actual amount of PT received may be less than `ptAmount`.\n            min_dy: minPtOut,\n            receiver: recipient\n        });\n\n        if (ethSpent > maxEthSpent) revert Errors.MetapoolRouterExceededLimitETHIn();\n\n        // Send the remaining WETH back to the sender\n        uint256 remainingWeth = msg.value - ethSpent;\n        if (remainingWeth > 0) _unwrapWETH(msg.sender, remainingWeth);\n\n        return ethSpent;\n    }\n\n    /// @notice Swap PT for ETH on the Curve metapool through the 3LST-PT<>ETH NapierPool\n    /// @param metapool The address of the Twocrypto metapool\n    /// @param ptAmount The amount of PT to swap\n    /// @param minEthOut The minimum amount of ETH to receive\n    /// @param recipient The address to receive the ETH\n    /// @param deadline The timestamp after which the transaction will be reverted\n    function swapPtForETH(address metapool, uint256 ptAmount, uint256 minEthOut, address recipient, uint256 deadline)\n        external\n        nonReentrant\n        checkDeadline(deadline)\n        checkMetapool(metapool)\n        returns (uint256 ethOut)\n    {\n        // Steps:\n        // 1. Exchange PT for the base pool token on twoCrypto metapool\n        // 2. Swap ETH -> base pool token on twocrypto metapool\n        // 3. Swap the received base pool token -> ETH on triLST-PT<>WETH NapierPool\n        // 4. Send remaining ETH to the recipient\n\n        // Swap PT for the base pool token on the Curve metapool\n        SafeERC20.safeTransferFrom(IERC20(Twocrypto(metapool).coins(PEGGED_PT_INDEX)), msg.sender, metapool, ptAmount);\n        uint256 basePoolTokenAmount =\n            Twocrypto(metapool).exchange_received(PEGGED_PT_INDEX, BASE_POOL_INDEX, ptAmount, 0, address(this));\n\n        // Swap the received base pool token for ETH on the 3LST-PT<>ETH NapierPool\n        ethOut ="
    }
  ]
}