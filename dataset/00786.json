{
  "Title": "M-2: Sablier stream update in `CouncilMember.sol` can cause loss of funds if the streamed balance is not withdrawn.",
  "Content": "# Issue M-2: Sablier stream update in `CouncilMember.sol` can cause loss of funds if the streamed balance is not withdrawn. \n\nSource: https://github.com/sherlock-audit/2024-01-telcoin-judging/issues/99 \n\n## Found by \nAamirusmani1552, Tricko\n## Summary\n\nThe vulnerability in the `CouncilMember` contract pertains to the failure to withdraw streamed tokens during a contract stream update, potentially resulting in fund loss for both the contract and the entire council.\n\n## Vulnerability Detail\n\nSablier Streams facilitate token streaming on a per-second basis, involving a sender who initiates the stream and a receiver who receives the streamed tokens. The receiver can withdraw tokens up to the elapsed seconds from the stream's start. The responsibility to claim streamed tokens lies with the receiver, as stated in the documentation and Sablier stream contracts (read the cancel stream docs [here](https://docs.sablier.com/contracts/v2/guides/stream-management/cancel)) . Once tokens are streamed, the sender cannot withdraw them.\n\nAlso sender has the authority to cancel the the stream and claim back the un-streamed amount. But streamed Balance upto the elapsed time can still be claimed by the receiver or person who is approved by the receiver only.\n\nCheck the `SablierV2Lockup::cancel()` here ðŸ‘‡:\nhttps://github.com/sablier-labs/v2-core/blob/b0016437ef3cc8606e1100965dd911d7e658b40b/src/abstracts/SablierV2Lockup.sol#L153-L168\n\nDocs for the same could be find here ðŸ‘‡:\nhttps://docs.sablier.com/contracts/v2/guides/stream-management/cancel\n\nAs we check from the resources given above, if a stream is canceled only the un-streamed balance will be available for the sender to withdraw. Rest if for the receiver.\n\nThe issue arises in the `CouncilMember` contract's functions (`CouncilMember::updateStream(...)`, `CouncilMember::updateID(...)`, and `CouncilMember::updateTarget(...)`) as they do not check whether the entire streamed amount has been withdrawn from the Sablier stream before updating the stream states in the contract. Consequently, if there is an active streamed balance in the Sablier stream, the `CouncilMember` contract will not be able to withdraw it. And now the balance is lying idle in the Sablier stream contract.\n\nHowever, the previously streamed balance can be reclaimed by adding the old stream back to the `CouncilMember` contract, provided the sender is aware that the streamed balance has not been withdrawn. Nonetheless, complications may arise if modifications are made to the `CouncilMember` contract following the stream update. For instance, the removal of a Council Member could lead to the omitted member not receiving their balance, while the addition of a new member may result in every old member receiving fewer tokens and new members gaining tokens share. This can happen because all update stream functions are handled by the role `GOVERNANCE_COUNCIL_ROLE` in the `CouncilMember` contract. And if it is a multi-sig or governance then it would required a vote to happend in order to perform the new updated. And sponsor confirmed that the multi-sig can be added for this role. Here is the conversation:\n\n**_Question Asked by me:_**\n>And last one is, Governance council will be a contract or EOA ( can be multisig). If governance council will be multisig, then how often can it make updates to the contracts?\n\n**_Answer from Sponsor:_**\n![image](https://github.com/sherlock-audit/2024-01-telcoin-judging/assets/1048185/bf5bbaee-66ee-408d-abcd-87819a665355)\n\n\nSo if this is the case then new update will be done after some time and a lot of things might happen in that time.\n\nAlso the sender's awareness play important role in this. Two scenarios may unfold because of this:\n1. The stream has fully distributed its balance, and the sender assumes that the funds have been appropriately allocated to the `CouncilMember` contract.\n2. The stream needs to be prematurely canceled for specific reasons, requiring the addition of a new stream.\n\nIn both of the scenarios if the sender is unaware then it will be complete loss of tokens.\n\n## Impact\n\nCouncil members face potential token losses due to the inability to withdraw streamed balances.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-01-telcoin/blob/main/telcoin-audit/contracts/sablier/core/CouncilMember.sol#L229C3-L257C1\n\n## Tool used\n\n- Manual Review\n\n## Recommendation\n\nTo mitigate this potential issue, the following actions are advised:\n\n### 1. Implement Sablier Hooks:\nSablier offers essential hooks to address scenarios where the receiver is a contract. These hooks enable the receiver contract to update its state accurately. While these hooks are optional, Sablier strongly recommends their implementation. Of particular relevance in this context is the onStreamCanceled hook, triggered by the Sablier stream contract when the sender cancels the stream. By incorporating this hook in the CouncilMember contract, the receiver can invoke the _retrieve() function upon stream cancellation, ensuring the withdrawal of the entire streamed balance.\n\n**_File: CouncilMember.sol_**\n\n```diff\n+ import { ISablierV2LockupRecipient } from \"@sablier/v2-core/src/interfaces/hooks/ISablierV2LockupRecipient.sol\";\n\n    contract CouncilMember is\n        ERC721EnumerableUpgradeable,\n        AccessControlEnumerableUpgradeable\n+    ISablierV2LockupRecipient\n    {\n\n+    function onStreamCanceled(\n+        uint256 streamId,\n+        uint128, /* senderAmount */\n+        uint128 /* recipientAmount */\n+    )\n+        external\n+        pure\n+    {\n+        _retrieve();\n+    }\n\n    }\n```  \n\n### 2. Check Stream Depletion in Update Function:\nIn the stream update function, verify whether the stream is depleted or not. If not, withdraw the streamed tokens before updating the balances. It is crucial to check if the stream is depleted because if the `_retrieve()` function is directly called and the stream has been depleted (all tokens withdrawn by the receiver), invoking `stream.withdrawMax()` will revert. This could lead to a revert in the `_retrieve()` function and potentially cause a denial-of-service (DoS) situation in the stream update function.\n\n**_File: CouncilMember.sol_**\n```diff\n+    // Syncronize the update process\n+    function updateStreamData( IPRBProxy stream_,  address target_, uint256 updateID ) external onlyRole(GOVERNANCE_COUNCIL_ROLE){\n+     _checkIfDepleted();    \n+     _updateStream(stream_);\n+     _updateTarget(target_);\n+     _updateID(updateID);\n+    }\n\n-    function updateStream(\n+    function _updateStream(\n        IPRBProxy stream_\n-    ) external onlyRole(GOVERNANCE_COUNCIL_ROLE) {\n+   ) internal {\n        _stream = stream_;\n        emit StreamUpdated(_stream);\n    }\n\n\n    /**\n     * @notice Update the target address\n     * @dev Restricted to the GOVERNANCE_COUNCIL_ROLE.\n     * @param target_ New target address.\n     */\n-    function updateTarget(\n+    function _updateTarget(\n        address target_\n-    ) external onlyRole(GOVERNANCE_COUNCIL_ROLE) {\n+   ) internal {\n        _target = target_;\n        emit TargetUpdated(_target);\n    }\n\n\n    /**\n     * @notice Update the ID for a council member\n     * @dev Restricted to the GOVERNANCE_COUNCIL_ROLE.\n     * @param id_ New ID for the council member.\n     */\n-       function updateID(uint256 id_) external onlyRole(GOVERNANCE_COUNCIL_ROLE) {\n+      function _updateID(uint256 id_) internal {\n        _id = id_;\n        emit IDUpdated(_id);\n      }\n\n+   // assuming IPRBProxy will return results like given below since we have not been provided with PRBProxy in the codebase.\n+  // make changes according to the interface to below given function.\n+   function _checkIfDepleted() _internal view {\n+        (bool success, bytes memory data) = _stream.execute(\n+            _target,\n+            abi.encodeWithSelector(\n+                ISablierV2ProxyTarget.isDepleted.selector,\n+                _id\n+            )\n+        );\n        \n+      require(success, \"Call failed\");\n+      require(abi.decode(data, (bool)), \"Stream is not depleted yet.\");\n+   }\n```\n  \n**Note**: Make necessary adjustments in the interfaces used.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  invalid because { This is invalid because the funcions in question (updateStream and updateId) have a governance modifier which requires the governance to execute this action; according to sherlock its invalid}\n\n\n\n**amshirif**\n\nDuplicate issue\nhttps://github.com/sherlock-audit/2024-01-telcoin-judging/issues/112\n\n**amshirif**\n\nhttps://github.com/telcoin/telcoin-audit/pull/49\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/156",
  "Code": [
    {
      "filename": "src/abstracts/SablierV2Lockup.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport { IERC4906 } from \"@openzeppelin/contracts/interfaces/IERC4906.sol\";\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { IERC721Metadata } from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\n\nimport { ISablierV2Comptroller } from \"../interfaces/ISablierV2Comptroller.sol\";\nimport { ISablierV2Lockup } from \"../interfaces/ISablierV2Lockup.sol\";\nimport { ISablierV2NFTDescriptor } from \"../interfaces/ISablierV2NFTDescriptor.sol\";\nimport { ISablierV2LockupRecipient } from \"../interfaces/hooks/ISablierV2LockupRecipient.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\nimport { Lockup } from \"../types/DataTypes.sol\";\nimport { SablierV2Base } from \"./SablierV2Base.sol\";\n\n/// @title SablierV2Lockup\n/// @notice See the documentation in {ISablierV2Lockup}.\nabstract contract SablierV2Lockup is\n    IERC4906, // 2 inherited components\n    SablierV2Base, // 4 inherited components\n    ISablierV2Lockup, // 4 inherited components\n    ERC721 // 6 inherited components\n{\n    /*//////////////////////////////////////////////////////////////////////////\n                                USER-FACING STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ISablierV2Lockup\n    uint256 public override nextStreamId;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                  INTERNAL STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Contract that generates the non-fungible token URI.\n    ISablierV2NFTDescriptor internal _nftDescriptor;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @param initialAdmin The address of the initial contract admin.\n    /// @param initialComptroller The address of the initial comptroller.\n    /// @param initialNFTDescriptor The address of the initial NFT descriptor.\n    constructor(\n        address initialAdmin,\n        ISablierV2Comptroller initialComptroller,\n        ISablierV2NFTDescriptor initialNFTDescriptor\n    )\n        SablierV2Base(initialAdmin, initialComptroller)\n    {\n        _nftDescriptor = initialNFTDescriptor;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      MODIFIERS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Checks that `streamId` does not reference a null stream.\n    modifier notNull(uint256 streamId) {\n        if (!isStream(streamId)) {\n            revert Errors.SablierV2Lockup_Null(streamId);\n        }\n        _;\n    }\n\n    /// @dev Emits an ERC-4906 event to trigger an update of the NFT metadata.\n    modifier updateMetadata(uint256 streamId) {\n        _;\n        emit MetadataUpdate({ _tokenId: streamId });\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                           USER-FACING CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ISablierV2Lockup\n    function getRecipient(uint256 streamId) external view override returns (address recipient) {\n        // Checks: the stream NFT exists.\n        _requireMinted({ tokenId: streamId });\n\n        // The NFT owner is the stream's recipient.\n        recipient = _ownerOf(streamId);\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function isCold(uint256 streamId) external view override notNull(streamId) returns (bool result) {\n        Lockup.Status status = _statusOf(streamId);\n        result = status == Lockup.Status.SETTLED || status == Lockup.Status.CANCELED || status == Lockup.Status.DEPLETED;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function isDepleted(uint256 streamId) public view virtual override returns (bool result);\n\n    /// @inheritdoc ISablierV2Lockup\n    function isStream(uint256 streamId) public view virtual override returns (bool result);\n\n    /// @inheritdoc ISablierV2Lockup\n    function isWarm(uint256 streamId) external view override notNull(streamId) returns (bool result) {\n        Lockup.Status status = _statusOf(streamId);\n        result = status == Lockup.Status.PENDING || status == Lockup.Status.STREAMING;\n    }\n\n    /// @inheritdoc ERC721\n    function tokenURI(uint256 streamId) public view override(IERC721Metadata, ERC721) returns (string memory uri) {\n        // Checks: the stream NFT exists.\n        _requireMinted({ tokenId: streamId });\n\n        // Generate the URI describing the stream NFT.\n        uri = _nftDescriptor.tokenURI({ sablier: this, streamId: streamId });\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function wasCanceled(uint256 streamId) public view virtual override returns (bool result);\n\n    /// @inheritdoc ISablierV2Lockup\n    function withdrawableAmountOf(uint256 streamId)\n        external\n        view\n        override\n        notNull(streamId)\n        returns (uint128 withdrawableAmount)\n    {\n        withdrawableAmount = _withdrawableAmountOf(streamId);\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function isTransferable(uint256 streamId) public view virtual returns (bool);\n\n    /*//////////////////////////////////////////////////////////////////////////\n                         USER-FACING NON-CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ISablierV2Lockup\n    function burn(uint256 streamId) external override noDelegateCall {\n        // Checks: only depleted streams can be burned. This also checks that the stream is not null.\n        if (!isDepleted(streamId)) {\n            revert Errors.SablierV2Lockup_StreamNotDepleted(streamId);\n        }\n\n        // Checks:\n        // 1. NFT exists (see {IERC721.getApproved}).\n        // 2. `msg.sender` is either the owner of the NFT or an approved third party.\n        if (!_isCallerStreamRecipientOrApproved(streamId)) {\n            revert Errors.SablierV2Lockup_Unauthorized(streamId, msg.sender);\n        }\n\n        // Effects: burn the NFT.\n        _burn({ tokenId: streamId });\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function cancel(uint256 streamId) public override noDelegateCall {\n        // Checks: the stream is neither depleted nor canceled. This also checks that the stream is not null.\n        if (isDepleted(streamId)) {\n            revert Errors.SablierV2Lockup_StreamDepleted(streamId);\n        } else if (wasCanceled(streamId)) {\n            revert Errors.SablierV2Lockup_StreamCanceled(streamId);\n        }\n\n        // Checks: `msg.sender` is the stream's sender.\n        if (!_isCallerStreamSender(streamId)) {\n            revert Errors.SablierV2Lockup_Unauthorized(streamId, msg.sender);\n        }\n\n        // Checks, Effects and Interactions: cancel the stream.\n        _cancel(streamId);\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function cancelMultiple(uint256[] calldata streamIds) external override noDelegateCall {\n        // Iterate over the provided array of stream ids and cancel each stream.\n        uint256 count = streamIds.length;\n        for (uint256 i = 0; i < count;) {\n            // Effects and Interactions: cancel the stream.\n            cancel(streamIds[i]);\n\n            // Increment the loop iterator.\n            unchecked {\n                i += 1;\n            }\n        }\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function renounce(uint256 streamId) external override noDelegateCall notNull(streamId) updateMetadata(streamId) {\n        // Checks: the stream is not cold.\n        Lockup.Status status = _statusOf(streamId);\n        if (status == Lockup.Status.DEPLETED) {\n            revert Errors.SablierV2Lockup_StreamDepleted(streamId);\n        } else if (status == Lockup.Status.CANCELED) {\n            revert Errors.SablierV2Lockup_StreamCanceled(streamId);\n        } else if (status == Lockup.Status.SETTLED) {\n            revert Errors.SablierV2Lockup_StreamSettled(streamId);\n        }\n\n        // Checks: `msg.sender` is the stream's sender.\n        if (!_isCallerStreamSender(streamId)) {\n            revert Errors.SablierV2Lockup_Unauthorized(streamId, msg.sender);\n        }\n\n        // Checks and Effects: renounce the stream.\n        _renounce(streamId);\n\n        // Log the renouncement.\n        emit ISablierV2Lockup.RenounceLockupStream(streamId);\n\n        // Interactions: if the recipient is a contract, try to invoke the renounce hook on the recipient without\n        // reverting if the hook is not implemented, and also without bubbling up any potential revert.\n        address recipient = _ownerOf(streamId);\n        if (recipient.code.length > 0) {\n            try ISablierV2LockupRecipient(recipient).onStreamRenounced(streamId) { } catch { }\n        }\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function setNFTDescriptor(ISablierV2NFTDescriptor newNFTDescriptor) external override onlyAdmin {\n        // Effects: set the NFT descriptor.\n        ISablierV2NFTDescriptor oldNftDescriptor = _nftDescriptor;\n        _nftDescriptor = newNFTDescriptor;\n\n        // Log the change of the NFT descriptor.\n        emit ISablierV2Lockup.SetNFTDescriptor({\n            admin: msg.sender,\n            oldNFTDescriptor: oldNftDescriptor,\n            newNFTDescriptor: newNFTDescriptor\n        });\n\n        // Refresh the NFT metadata for all streams.\n        emit BatchMetadataUpdate({ _fromTokenId: 1, _toTokenId: nextStreamId - 1 });\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function withdraw(\n        uint256 streamId,\n        address to,\n        uint128 amount\n    )\n        public\n        override\n        noDelegateCall\n        updateMetadata(streamId)\n    {\n        // Checks: the stream is not depleted. This also checks that the stream is not null.\n        if (isDepleted(streamId)) {\n            revert Errors.SablierV2Lockup_StreamDepleted(streamId);\n        }\n\n        bool isCallerStreamSender = _isCallerStreamSender(streamId);\n\n        // Checks: `msg.sender` is the stream's sender, the stream's recipient, or an approved third party.\n        if (!isCallerStreamSender && !_isCallerStreamRecipientOrApproved(streamId)) {\n            revert Errors.SablierV2Lockup_Unauthorized(streamId, msg.sender);\n        }\n\n        // Retrieve the recipient from storage.\n        address recipient = _ownerOf(streamId);\n\n        // Checks: if `msg.sender` is the stream's sender, the withdrawal address must be the recipient.\n        if (isCallerStreamSender && to != recipient) {\n            revert Errors.SablierV2Lockup_InvalidSenderWithdrawal(streamId, msg.sender, to);\n        }\n\n        // Checks: the withdrawal address is not zero.\n        if (to == address(0)) {\n            revert Errors.SablierV2Lockup_WithdrawToZeroAddress();\n        }\n\n        // Checks: the withdraw amount is not zero.\n        if (amount == 0) {\n            revert Errors.SablierV2Lockup_WithdrawAmountZero(streamId);\n        }\n\n        // Checks: the withdraw amount is not greater than the withdrawable amount.\n        uint128 withdrawableAmount = _withdrawableAmountOf(streamId);\n        if (amount > withdrawableAmount) {\n            revert Errors.SablierV2Lockup_Overdraw(streamId, amount, withdrawableAmount);\n        }\n\n        // Effects and Interactions: make the withdrawal.\n        _withdraw(streamId, to, amount);\n\n        // Interactions: if `msg.sender` is not the recipient and the recipient is a contract, try to invoke the\n        // withdraw hook on it without reverting if the hook is not implemented, and also without bubbling up\n        // any potential revert.\n        if (msg.sender != recipient && recipient.code.length > 0) {\n            try ISablierV2LockupRecipient(recipient).onStreamWithdrawn({\n                streamId: streamId,\n                caller: msg.sender,\n                to: to,\n                amount: amount\n            }) { } catch { }\n        }\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function withdrawMax(uint256 streamId, address to) external override {\n        withdraw({ streamId: streamId, to: to, amount: _withdrawableAmountOf(streamId) });\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function withdrawMaxAndTransfer(\n        uint256 streamId,\n        address newRecipient\n    )\n        external\n        override\n        noDelegateCall\n        notNull(streamId)\n    {\n        // Checks: the caller is the current recipient. This also checks that the NFT was not burned.\n        address currentRecipient = _ownerOf(streamId);\n        if (msg.sender != currentRecipient) {\n            revert Errors.SablierV2Lockup_Unauthorized(streamId, msg.sender);\n        }\n\n        // Skip the withdrawal if the withdrawable amount is zero.\n        uint128 withdrawableAmount = _withdrawableAmountOf(streamId);\n        if (withdrawableAmount > 0) {\n            withdraw({ streamId: streamId, to: currentRecipient, amount: withdrawableAmount });\n        }\n\n        // Checks and Effects: transfer the NFT.\n        _transfer({ from: currentRecipient, to: newRecipient, tokenId: streamId });\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function withdrawMultiple(\n        uint256[] calldata streamIds,\n        address to,\n        uint128[] calldata amounts\n    )\n        external\n        override\n        noDelegateCall\n    {\n        // Checks: there is an equal number of `streamIds` and `amounts`.\n        uint256 streamIdsCount = streamIds.length;\n        uint256 amountsCount = amounts.length;\n        if (streamIdsCount != amountsCount) {\n            revert Errors.SablierV2Lockup_WithdrawArrayCountsNotEqual(streamIdsCount, amountsCount);\n        }\n\n        // Iterate over the provided array of stream ids and withdraw from each stream.\n        for (uint256 i = 0; i < streamIdsCount;) {\n            // Checks, Effects and Interactions: check the parameters and make the withdrawal.\n            withdraw(streamIds[i], to, amounts[i]);\n\n            // Increment the loop iterator.\n            unchecked {\n                i += 1;\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                             INTERNAL CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Overrides the internal ERC-721 transfer function to emit an ERC-4906 event upon transfer. The goal is to\n    /// refresh the NFT metadata on external platforms.\n    /// @dev This event is also emitted when the NFT is minted or burned.\n    function _afterTokenTransfer(\n        address, /* from */\n        address, /* to */\n        uint256 streamId,\n        uint256 /* batchSize */\n    )\n        internal\n        override\n        updateMetadata(streamId)\n    { }\n\n    /// @notice Overrides the internal ERC-721 transfer function to check that the stream is transferable.\n    /// @dev There are two cases when the transferable flag is ignored:\n    /// - If `from` is 0, then the transfer is a mint and is allowed.\n    /// - If `to` is 0, then the transfer is a burn and is also allowed.\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 streamId,\n        uint256 /* batchSize */\n    )\n        internal\n        view\n        override\n    {\n        if (!isTransferable(streamId) && to != address(0) && from != address(0)) {\n            revert Errors.SablierV2Lockup_NotTransferable(streamId);\n        }\n    }\n\n    /// @notice Checks whether `msg.sender` is the stream's recipient or an approved third party.\n    /// @param streamId The stream id for the query.\n    function _isCallerStreamRecipientOrApproved(uint256 streamId) internal view returns (bool) {\n        address recipient = _ownerOf(streamId);\n        return msg.sender == recipient || isApprovedForAll({ owner: recipient, operator: msg.sender })\n            || getApproved(streamId) == msg.sender;\n    }\n\n    /// @notice Checks whether `msg.sender` is the stream's sender.\n    /// @param streamId The stream id for the query.\n    function _isCallerStreamSender(uint256 streamId) internal view virtual returns (bool);\n\n    /// @dev Retrieves the stream's status without performing a null check.\n    function _statusOf(uint256 streamId) internal view virtual returns (Lockup.Status);\n\n    /// @dev See the documentation for the user-facing functions that call this internal function.\n    function _withdrawableAmountOf(uint256 streamId) internal view virtual returns (uint128);\n\n    /*//////////////////////////////////////////////////////////////////////////\n                           INTERNAL NON-CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev See the documentation for the user-facing functions that call this internal function.\n    function _cancel(uint256 tokenId) internal virtual;\n\n    /// @dev See the documentation for the user-facing functions that call this internal function.\n    function _renounce(uint256 streamId) internal virtual;\n\n    /// @dev See the documentation for the user-facing functions that call this internal function.\n    function _withdraw(uint256 streamId, address to, uint128 amount) internal virtual;\n}"
    },
    {
      "filename": "telcoin-audit/contracts/sablier/core/CouncilMember.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/extensions/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"../interfaces/ISablierV2ProxyTarget.sol\";\nimport \"../interfaces/IPRBProxy.sol\";\n\n/**\n * @title CouncilMember\n * @author Amir M. Shirif\n * @notice A Telcoin Laboratories Contract\n * @notice A contract to signify ownership council membership\n * @dev Relies on OpenZeppelin's open source smart contracts\n */\ncontract CouncilMember is\n    ERC721EnumerableUpgradeable,\n    AccessControlEnumerableUpgradeable\n{\n    using SafeERC20 for IERC20;\n\n    /* ========== EVENTS ========== */\n    // Event fired when the stream is updated\n    event StreamUpdated(IPRBProxy newStream);\n    // Event fired when the target address is updated\n    event TargetUpdated(address newTarget);\n    // Event fired when the ID is updated\n    event IDUpdated(uint256 newID);\n\n    /* ========== STATE VARIABLES ========== */\n    // The main token of this ecosystem\n    IERC20 public TELCOIN;\n    // Stream proxy address for this contract\n    IPRBProxy public _stream;\n    // here is the implentation address\n    address public _target;\n    // the id associated with the sablier NFT\n    uint256 public _id;\n    // balance left over from last rebalancing\n    uint256 private runningBalance;\n    // current uncliamed members balances\n    uint256[] public balances;\n    // Mapping of who can send each NFT index\n    mapping(uint256 => address) private _tokenApproval;\n\n    /* ========== ROLES ========== */\n    // Role assigned for the governance council\n    bytes32 public constant GOVERNANCE_COUNCIL_ROLE =\n        keccak256(\"GOVERNANCE_COUNCIL_ROLE\");\n    // Support role for additional functionality\n    bytes32 public constant SUPPORT_ROLE = keccak256(\"SUPPORT_ROLE\");\n\n    /* ========== INITIALIZER ========== */\n    function initialize(\n        IERC20 telcoin,\n        string memory name_,\n        string memory symbol_,\n        IPRBProxy stream_,\n        address target_,\n        uint256 id_\n    ) external initializer {\n        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        __ERC721_init(name_, symbol_);\n        TELCOIN = telcoin;\n        _stream = stream_;\n        _target = target_;\n        _id = id_;\n    }\n\n    /************************************************\n     *   external functions\n     ************************************************/\n\n    /**\n     * @notice Allows authorized personnel to retrieve and distribute TELCOIN to council members\n     * @dev The main logic behind the TELCOIN distribution is encapsulated in this function.\n     * @dev This function should be called before any significant state changes to ensure accurate distribution.\n     * @dev Only the owner council members can call this function\n     */\n    function retrieve() external OnlyAuthorized {\n        _retrieve();\n    }\n\n    /**\n     * @notice Allows council members to claim their allocated amounts of TELCOIN\n     * @dev Checks if the caller is the owner of the provided tokenId and if the requested amount is available.\n     * @param tokenId The NFT index associated with a council member.\n     * @param amount Amount of TELCOIN the council member wants to withdraw.\n     */\n    function claim(uint256 tokenId, uint256 amount) external {\n        // Ensure the function caller is the owner of the token (council member) they're trying to claim for\n        require(\n            _msgSender() == ownerOf(tokenId),\n            \"CouncilMember: caller is not council member holding this NFT index\"\n        );\n        // Retrieve and distribute any pending TELCOIN for all council members\n        _retrieve();\n\n        // Ensure the requested amount doesn't exceed the balance of the council member\n        require(\n            amount <= balances[tokenId],\n            \"CouncilMember: withdrawal amount is higher than balance\"\n        );\n\n        // Deduct the claimed amount from the token's balance\n        balances[tokenId] -= amount;\n        // Safely transfer the claimed amount of TELCOIN to the function caller\n        TELCOIN.safeTransfer(_msgSender(), amount);\n    }\n\n    /**\n     * @notice Replace an existing council member with a new one and withdraws the old member's TELCOIN allocation\n     * @dev This function is restricted to the GOVERNANCE_COUNCIL_ROLE.\n     * @dev Allows TEL reward to be sent to a different address\n     * @param from Address of the current council member to be replaced.\n     * @param to Address of the new council member.\n     * @param tokenId Token ID of the council member NFT.\n     * @param rewardRecipient Address where the old member's TELCOIN will be sent.\n     */\n    function removeFromOffice(\n        address from,\n        address to,\n        uint256 tokenId,\n        address rewardRecipient\n    ) external onlyRole(GOVERNANCE_COUNCIL_ROLE) {\n        // Retrieve and distribute any pending TELCOIN for all council members\n        _retrieve();\n        // Withdraw all the TELCOIN rewards for the specified token to the rewardRecipient\n        _withdrawAll(rewardRecipient, tokenId);\n        // Transfer the token (representing the council membership) from one address to another\n        _transfer(from, to, tokenId);\n    }\n\n    /************************************************\n     *   view functions\n     ************************************************/\n\n    /**\n     * @notice Check if the contract supports a specific interface\n     * @dev Overrides the supportsInterface function from OpenZeppelin.\n     * @param interfaceId ID of the interface to check for support.\n     * @return True if the contract supports the interface, false otherwise.\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        pure\n        override(\n            AccessControlEnumerableUpgradeable,\n            ERC721EnumerableUpgradeable\n        )\n        returns (bool)\n    {\n        return\n            interfaceId ==\n            type(AccessControlEnumerableUpgradeable).interfaceId ||\n            interfaceId == type(ERC721EnumerableUpgradeable).interfaceId;\n    }\n\n    /************************************************\n     *   mutative functions\n     ************************************************/\n\n    /**\n     * @notice Mint new council member NFTs\n     * @dev This function also retrieves and distributes TELCOIN.\n     * @dev Restricted to the GOVERNANCE_COUNCIL_ROLE.\n     * @param newMember Address of the new council member.\n     */\n    function mint(\n        address newMember\n    ) external onlyRole(GOVERNANCE_COUNCIL_ROLE) {\n        if (totalSupply() != 0) {\n            _retrieve();\n        }\n\n        balances.push(0);\n        _mint(newMember, totalSupply());\n    }\n\n    /**\n     * @notice Approve a specific address for a specific NFT\n     * @dev Overrides the approve function from ERC721.\n     * @dev Restricted to the GOVERNANCE_COUNCIL_ROLE.\n     * @param to Address to be approved.\n     * @param tokenId Token ID of the NFT to be approved.\n     */\n    function approve(\n        address to,\n        uint256 tokenId\n    )\n        public\n        override(ERC721Upgradeable, IERC721)\n        onlyRole(GOVERNANCE_COUNCIL_ROLE)\n    {\n        _tokenApproval[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @notice Burn a council member NFT\n     * @dev The function retrieves and distributes TELCOIN before burning the NFT.\n     * @dev Restricted to the GOVERNANCE_COUNCIL_ROLE.\n     * @param tokenId Token ID of the council member NFT to be burned.\n     * @param recipient Address to receive the burned NFT holder's TELCOIN allocation.\n     */\n    function burn(\n        uint256 tokenId,\n        address recipient\n    ) external onlyRole(GOVERNANCE_COUNCIL_ROLE) {\n        require(totalSupply() > 1, \"CouncilMember: must maintain council\");\n        _retrieve();\n        _withdrawAll(recipient, tokenId);\n\n        uint256 balance = balances[balances.length - 1];\n        balances[tokenId] = balance;\n        balances.pop();\n        _burn(tokenId);\n    }\n\n    /**\n     * @notice Update the stream proxy address\n     * @dev Restricted to the GOVERNANCE_COUNCIL_ROLE.\n     * @param stream_ New stream proxy address.\n     */\n    function updateStream(\n        IPRBProxy stream_\n    ) external onlyRole(GOVERNANCE_COUNCIL_ROLE) {\n        _stream = stream_;\n        emit StreamUpdated(_stream);\n    }\n\n    /**\n     * @notice Update the target address\n     * @dev Restricted to the GOVERNANCE_COUNCIL_ROLE.\n     * @param target_ New target address.\n     */\n    function updateTarget(\n        address target_\n    ) external onlyRole(GOVERNANCE_COUNCIL_ROLE) {\n        _target = target_;\n        emit TargetUpdated(_target);\n    }\n\n    /**\n     * @notice Update the ID for a council member\n     * @dev Restricted to the GOVERNANCE_COUNCIL_ROLE.\n     * @param id_ New ID for the council member.\n     */\n    function updateID(uint256 id_) external onlyRole(GOVERNANCE_COUNCIL_ROLE) {\n        _id = id_;\n        emit IDUpdated(_id);\n    }\n\n    /************************************************\n     *   internal functions\n     ************************************************/\n\n    /**\n     * @notice Retrieve and distribute TELCOIN to council members based on the stream from _target\n     * @dev This function fetches the maximum possible TELCOIN and distributes it equally among all council members.\n     * @dev It also updates the running balance to ensure accurate distribution during subsequent calls.\n     */\n    function _retrieve() internal {\n        // Get the initial TELCOIN balance of the contract\n        uint256 initialBalance = TELCOIN.balanceOf(address(this));\n        // Execute the withdrawal from the _target, which might be a Sablier stream or another protocol\n        _stream.execute(\n            _target,\n            abi.encodeWithSelector(\n                ISablierV2ProxyTarget.withdrawMax.selector,\n                _target,\n                _id,\n                address(this)\n            )\n        );\n\n        // Get the new balance after the withdrawal\n        uint256 currentBalance = TELCOIN.balanceOf(address(this));\n        // Calculate the amount of TELCOIN that was withdrawn during this operation\n        uint256 finalBalance = (currentBalance - initialBalance) +\n            runningBalance;\n        // Distribute the TELCOIN equally among all council members\n        uint256 individualBalance = finalBalance / totalSupply();\n        // Update the running balance which keeps track of any TELCOIN that can't be evenly distributed\n        runningBalance = finalBalance % totalSupply();\n\n        // Add the individual balance to each council member's balance\n        for (uint i = 0; i < balances.length; i++) {\n            balances[i] += individualBalance;\n        }\n    }\n\n    /**\n     * @notice Determines if an address is approved or is the owner for a specific token ID\n     * @dev This function checks if the spender has GOVERNANCE_COUNCIL_ROLE or is the approved address for the token.\n     * @param spender Address to check approval or ownership for.\n     * @param tokenId Token ID to check against.\n     * @return True if the address is approved or is the owner, false otherwise.\n     */\n    function _isAuthorized(\n        address,\n        address spender,\n        uint256 tokenId\n    ) internal view override returns (bool) {\n        return (hasRole(GOVERNANCE_COUNCIL_ROLE, spender) ||\n            _tokenApproval[tokenId] == spender);\n    }\n\n    /**\n     * @notice Handle operations to be performed before transferring a token\n     * @dev This function retrieves and distributes TELCOIN before the token transfer.\n     * @dev It is an override of the _beforeTokenTransfer from OpenZeppelin's ERC721.\n     * @param to Address from which the token is being transferred.\n     * @param tokenId Token ID that's being transferred.\n     * @param auth Token ID that's being transferred.\n     */\n    function _update(\n        address to,\n        uint256 tokenId,\n        address auth\n    ) internal override returns (address) {\n        if (totalSupply() != 0) {\n            _retrieve();\n        }\n\n        return super._update(to, tokenId, auth);\n    }\n\n    /**\n     * @notice Withdraws all allocated TELCOIN for a council member\n     * @dev This function safely transfers the TELCOIN to the given address and resets their balance.\n     * @param from Address to which the TELCOIN will be sent.\n     * @param tokenId Token ID of the council member to withdraw the TELCOIN for.\n     */\n    function _withdrawAll(address from, uint256 tokenId) internal {\n        TELCOIN.safeTransfer(from, balances[tokenId]);\n        balances[tokenId] = 0;\n    }\n\n    /************************************************\n     *   helper functions\n     ************************************************/\n\n    /**\n     * @notice Rescues any ERC20 token sent accidentally to the contract\n     * @dev Only addresses with the SUPPORT_ROLE can call this function.\n     * @param token ERC20 token address which needs to be rescued.\n     * @param destination Address where the tokens will be sent.\n     * @param amount Amount of tokens to be transferred.\n     */\n    function erc20Rescue(\n        IERC20 token,\n        address destination,\n        uint256 amount\n    ) external onlyRole(SUPPORT_ROLE) {\n        token.safeTransfer(destination, amount);\n    }\n\n    /************************************************\n     *   modifiers\n     ************************************************/\n\n    /**\n     * @notice Checks if the caller is authorized either by being a council member or having the GOVERNANCE_COUNCIL_ROLE\n     * @dev This modifier is used to restrict certain operations to council members or governance personnel.\n     */\n    modifier OnlyAuthorized() {\n        require(\n            hasRole(GOVERNANCE_COUNCIL_ROLE, _msgSender()) ||\n                ERC721Upgradeable.balanceOf(_msgSender()) >= 1,\n            \"CouncilMember: caller is not council member or owner\"\n        );\n        _;\n    }\n}"
    }
  ]
}