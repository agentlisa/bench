{
  "Title": "Fee Regulation Might Not Work as Expected on Non-Mainnet Chains",
  "Content": "The [`_isPriorityFeeValid`](https://github.com/1inch/limit-order-settlement/blob/ff7909c4f32bee8879211607275dc30d788afee8/contracts/SettlementExtension.sol#L188-L206) function implements the fee regulation check proposed in [1IP-43](https://snapshot.org/#/1inch.eth/proposal/0xa040c60050147a0f67042ae024673e92e813b5d2c0f748abf70ddfa1ed107cbe). This check constrains the priority fee when interacting with the protocol, which should reduce the gas competition between resolvers and improve prices for users. Given the multi-chain nature of the protocol, however, the check might not work as expected on chains other than the Ethereum mainnet.\n\n\nFor example, Aurora, which is currently supported by 1inch, [sets the base fee to zero for all blocks](https://github.com/aurora-is-near/aurora-engine/blob/668de1fdf786181e8bc73328a4f5132a45490b5f/engine/src/engine.rs#L1846-L1848) which would lead to [reverts in the `_isPriorityFeeValid` function](https://github.com/1inch/limit-order-settlement/blob/ff7909c4f32bee8879211607275dc30d788afee8/contracts/SettlementExtension.sol#L199). Some other chains such as Scroll, which are not currently supported but might be in the future, [revert when the base fee is accessed](https://docs.scroll.io/en/developers/ethereum-and-scroll-differences/#evm-opcodes). Other chains like Optimism might have [significantly different base fee dynamics](https://community.optimism.io/docs/developers/build/transaction-fees/#base-fee) which makes values hardcoded in the protocol less robust.\n\n\nBefore deploying the fee regulation on a new chain, consider validating that the check done by the `_isPriorityFeeValid` function works as intended. Alternatively, consider introducing the fee regulation only on the Ethereum mainnet.\n\n\n***Update:** Resolved. The 1inch team stated:*\n\n\n\n> *The `priorityFee` limitation applies only to the mainnet, so the extension will be deployed on other chains without that check.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/SettlementExtension.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@1inch/limit-order-protocol-contract/contracts/interfaces/IPostInteraction.sol\";\nimport \"@1inch/limit-order-protocol-contract/contracts/interfaces/IAmountGetter.sol\";\nimport \"@1inch/solidity-utils/contracts/libraries/SafeERC20.sol\";\nimport \"./FeeBankCharger.sol\";\n\n/**\n * @title Settlement contract\n * @notice Contract to execute limit orders settlement, created by Fusion mode.\n */\ncontract SettlementExtension is IPostInteraction, IAmountGetter, FeeBankCharger {\n    using SafeERC20 for IERC20;\n    using AddressLib for Address;\n\n    error OnlyLimitOrderProtocol();\n    error ResolverIsNotWhitelisted();\n    error InvalidPriorityFee();\n\n    uint256 private constant _TAKING_FEE_BASE = 1e9;\n    uint256 private constant _ORDER_FEE_BASE_POINTS = 1e15;\n    uint256 private constant _BASE_POINTS = 10_000_000; // 100%\n    uint256 private constant _RESOLVER_ADDRESS_MASK = 0xffffffffffffffffffff;\n\n    IOrderMixin private immutable _limitOrderProtocol;\n\n    /// @dev Modifier to check if the caller is the limit order protocol contract.\n    modifier onlyLimitOrderProtocol {\n        if (msg.sender != address(_limitOrderProtocol)) revert OnlyLimitOrderProtocol();\n        _;\n    }\n\n    /**\n     * @notice Initializes the contract.\n     * @param limitOrderProtocol The limit order protocol contract.\n     * @param token The token to charge protocol fees in.\n     */\n    constructor(IOrderMixin limitOrderProtocol, IERC20 token)\n        FeeBankCharger(token)\n    {\n        _limitOrderProtocol = limitOrderProtocol;\n    }\n\n    function getMakingAmount(\n        IOrderMixin.Order calldata order,\n        bytes calldata /* extension */,\n        bytes32 /* orderHash */,\n        address /* taker */,\n        uint256 takingAmount,\n        uint256 /* remainingMakingAmount */,\n        bytes calldata extraData\n    ) external view returns (uint256) {\n        uint256 rateBump = _getRateBump(extraData);\n        return Math.mulDiv(order.makingAmount, takingAmount * _BASE_POINTS, order.takingAmount * (_BASE_POINTS + rateBump));\n    }\n\n    function getTakingAmount(\n        IOrderMixin.Order calldata order,\n        bytes calldata /* extension */,\n        bytes32 /* orderHash */,\n        address /* taker */,\n        uint256 makingAmount,\n        uint256 /* remainingMakingAmount */,\n        bytes calldata extraData\n    ) external view returns (uint256) {\n        uint256 rateBump = _getRateBump(extraData);\n        return Math.mulDiv(order.takingAmount, makingAmount * (_BASE_POINTS + rateBump), order.makingAmount * _BASE_POINTS, Math.Rounding.Up);\n    }\n\n    /// struct AuctionDetails {\n    ///     bytes4 auctionStartTime;\n    ///     bytes3 auctionDuration;\n    ///     bytes3 initialRateBump;\n    ///     (bytes3,bytes2)[N] pointsAndTimeDeltas;\n    /// }\n\n    function _getRateBump(bytes calldata auctionDetails) private view returns (uint256) {\n        unchecked {\n            uint256 auctionStartTime = uint32(bytes4(auctionDetails[0:4]));\n            uint256 auctionFinishTime = auctionStartTime + uint24(bytes3(auctionDetails[4:7]));\n            uint256 initialRateBump = uint24(bytes3(auctionDetails[7:10]));\n\n            if (block.timestamp <= auctionStartTime) {\n                return initialRateBump;\n            } else if (block.timestamp >= auctionFinishTime) {\n                return 0; // Means 0% bump\n            }\n\n            auctionDetails = auctionDetails[10:];\n            uint256 pointsSize = auctionDetails.length / 5;\n            uint256 currentPointTime = auctionStartTime;\n            uint256 currentRateBump = initialRateBump;\n\n            for (uint256 i = 0; i < pointsSize; i++) {\n                uint256 nextRateBump = uint24(bytes3(auctionDetails[:3]));\n                uint256 nextPointTime = currentPointTime + uint16(bytes2(auctionDetails[3:5]));\n                if (block.timestamp <= nextPointTime) {\n                    return ((block.timestamp - currentPointTime) * nextRateBump + (nextPointTime - block.timestamp) * currentRateBump) / (nextPointTime - currentPointTime);\n                }\n                currentRateBump = nextRateBump;\n                currentPointTime = nextPointTime;\n                auctionDetails = auctionDetails[5:];\n            }\n            return (auctionFinishTime - block.timestamp) * currentRateBump / (auctionFinishTime - currentPointTime);\n        }\n    }\n\n    function postInteraction(\n        IOrderMixin.Order calldata order,\n        bytes calldata /* extension */,\n        bytes32 /* orderHash */,\n        address taker,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 /* remainingMakingAmount */,\n        bytes calldata extraData\n    ) external onlyLimitOrderProtocol {\n        (uint256 resolverFee, address integrator, uint256 integrationFee, bytes calldata whitelist) = _parseFeeData(extraData, order.makingAmount, makingAmount, takingAmount);\n\n        if (!_isWhitelisted(whitelist, taker)) revert ResolverIsNotWhitelisted();\n        if (!_isPriorityFeeValid()) revert InvalidPriorityFee();\n\n        _chargeFee(taker, resolverFee);\n        if (integrationFee > 0) {\n            IERC20(order.takerAsset.get()).safeTransferFrom(taker, integrator, integrationFee);\n        }\n    }\n\n    /// struct FeeData {\n    ///     bytes1 feeTypes; 1 = resolverFee, 2 = intergrationFee\n    ///     bytes4 resolverFee; optional\n    ///     bytes20 integrator; optional\n    ///     bytes4 integrationFee; optional\n    ///     bytes whitelist;\n    /// }\n\n    function _parseFeeData(\n        bytes calldata extraData,\n        uint256 orderMakingAmount,\n        uint256 actualMakingAmount,\n        uint256 actualTakingAmount\n    ) private pure returns (uint256 resolverFee, address integrator, uint256 integrationFee, bytes calldata whitelist) {\n        bytes1 feeType = extraData[0];\n        extraData = extraData[1:];\n        if (feeType & 0x01 == 0x01) {\n            // resolverFee enabled\n            resolverFee = uint256(uint32(bytes4(extraData[:4]))) * _ORDER_FEE_BASE_POINTS * actualMakingAmount / orderMakingAmount;\n            extraData = extraData[4:];\n        }\n        if (feeType & 0x02 == 0x02) {\n            // integratorFee enabled\n            integrator = address(bytes20(extraData[:20]));\n            integrationFee = actualTakingAmount * uint256(uint32(bytes4(extraData[20:24]))) / _TAKING_FEE_BASE;\n            extraData = extraData[24:];\n        }\n        whitelist = extraData;\n    }\n\n    /// struct WhitelistDetails {\n    ///     bytes4 auctionStartTime;\n    ///     (bytes10,bytes2)[N] resolversAddressesAndTimeDeltas;\n    /// }\n\n    function _isWhitelisted(bytes calldata whitelist, address resolver) private view returns (bool) {\n        unchecked {\n            uint256 allowedTime = uint32(bytes4(whitelist[0:4])); // initially set to auction start time\n            whitelist = whitelist[4:];\n            uint256 whitelistSize = whitelist.length / 12;\n            uint80 maskedResolverAddress = uint80(uint160(resolver) & _RESOLVER_ADDRESS_MASK);\n            for (uint256 i = 0; i < whitelistSize; i++) {\n                uint80 whitelistedAddress = uint80(bytes10(whitelist[:10]));\n                allowedTime += uint16(bytes2(whitelist[10:12])); // add next time delta\n                if (maskedResolverAddress == whitelistedAddress) {\n                    return allowedTime <= block.timestamp;\n                } else if (allowedTime > block.timestamp) {\n                    return false;\n                }\n                whitelist = whitelist[12:];\n            }\n            return false;\n        }\n    }\n\n    /// @notice Validates priority fee according to the spec\n    /// https://snapshot.org/#/1inch.eth/proposal/0xa040c60050147a0f67042ae024673e92e813b5d2c0f748abf70ddfa1ed107cbe\n    /// For blocks with baseFee <10.6 gwei – the priorityFee is capped at 70% of the baseFee.\n    /// For blocks with baseFee between 10.6 gwei and 104.1 gwei – the priorityFee is capped at 50% of the baseFee.\n    /// For blocks with baseFee >104.1 gwei – priorityFee is capped at 65% of the block’s baseFee.\n    function _isPriorityFeeValid() private view returns(bool) {\n        unchecked {\n            uint256 baseFee = block.basefee;\n            uint256 priorityFee = tx.gasprice - baseFee;\n\n            if (baseFee < 10.6 gwei) {\n                return priorityFee * 100 <= baseFee * 70;\n            } else if (baseFee < 104.1 gwei) {\n                return priorityFee * 2 <= baseFee;\n            } else {\n                return priorityFee * 100 <= baseFee * 65;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "engine/src/engine.rs",
      "content": "use crate::parameters::{\n    CallArgs, NEP141FtOnTransferArgs, ResultLog, SubmitArgs, SubmitResult, ViewCallArgs,\n};\nuse aurora_engine_types::public_key::PublicKey;\nuse aurora_engine_types::PhantomData;\nuse core::mem;\nuse evm::backend::{Apply, ApplyBackend, Backend, Basic, Log};\nuse evm::executor;\nuse evm::{Config, CreateScheme, ExitError, ExitFatal, ExitReason};\n\nuse crate::map::BijectionMap;\nuse crate::{errors, state};\nuse aurora_engine_sdk::caching::FullCache;\nuse aurora_engine_sdk::env::Env;\nuse aurora_engine_sdk::io::{StorageIntermediate, IO};\nuse aurora_engine_sdk::promise::{PromiseHandler, PromiseId, ReadOnlyPromiseHandler};\n\nuse crate::accounting;\n#[cfg(not(feature = \"ext-connector\"))]\nuse crate::contract_methods::connector;\nuse crate::contract_methods::silo;\nuse crate::parameters::{DeployErc20TokenArgs, TransactionStatus};\nuse crate::pausables::{\n    EngineAuthorizer, EnginePrecompilesPauser, PausedPrecompilesChecker, PrecompileFlags,\n};\nuse crate::prelude::parameters::RefundCallArgs;\nuse crate::prelude::precompiles::native::{exit_to_ethereum, exit_to_near};\nuse crate::prelude::precompiles::xcc::cross_contract_call;\nuse crate::prelude::precompiles::Precompiles;\nuse crate::prelude::transactions::{EthTransactionKind, NormalizedEthTransaction};\nuse crate::prelude::{\n    address_to_key, bytes_to_key, sdk, storage_to_key, u256_to_arr, vec, AccountId, Address,\n    BTreeMap, BorshDeserialize, Cow, KeyPrefix, PromiseArgs, PromiseCreateArgs, Vec, Wei, Yocto,\n    ERC20_DIGITS_SELECTOR, ERC20_MINT_SELECTOR, ERC20_NAME_SELECTOR, ERC20_SET_METADATA_SELECTOR,\n    ERC20_SYMBOL_SELECTOR, H160, H256, U256,\n};\nuse crate::state::EngineState;\nuse aurora_engine_modexp::{AuroraModExp, ModExpAlgorithm};\nuse aurora_engine_precompiles::PrecompileConstructorContext;\nuse aurora_engine_types::parameters::connector::{\n    Erc20Identifier, Erc20Metadata, MirrorErc20TokenArgs,\n};\nuse aurora_engine_types::parameters::engine::FunctionCallArgsV2;\nuse aurora_engine_types::types::EthGas;\nuse core::cell::RefCell;\nuse core::iter::once;\n\n/// Used as the first byte in the concatenation of data used to compute the blockhash.\n/// Could be useful in the future as a version byte, or to distinguish different types of blocks.\nconst BLOCK_HASH_PREFIX: u8 = 0;\nconst BLOCK_HASH_PREFIX_SIZE: usize = 1;\nconst BLOCK_HEIGHT_SIZE: usize = 8;\nconst CHAIN_ID_SIZE: usize = 32;\n\n/// Block height where the bug fix for parsing transactions to the zero address\n/// is deployed. The current value is only approximate; will be updated once the\n/// fix is actually deployed.\npub const ZERO_ADDRESS_FIX_HEIGHT: u64 = 61_200_152;\n\n#[must_use]\npub fn current_address(current_account_id: &AccountId) -> Address {\n    aurora_engine_sdk::types::near_account_to_evm_address(current_account_id.as_bytes())\n}\n\n#[derive(Debug, Clone, Eq, PartialEq)]\n#[cfg_attr(feature = \"impl-serde\", derive(serde::Serialize))]\npub struct EngineError {\n    pub kind: EngineErrorKind,\n    pub gas_used: u64,\n}\n\nimpl From<EngineErrorKind> for EngineError {\n    fn from(kind: EngineErrorKind) -> Self {\n        Self { kind, gas_used: 0 }\n    }\n}\n\nimpl AsRef<[u8]> for EngineError {\n    fn as_ref(&self) -> &[u8] {\n        self.kind.as_bytes()\n    }\n}\n\n/// Errors with the EVM engine.\n#[derive(Debug, Clone, Eq, PartialEq)]\n#[cfg_attr(feature = \"impl-serde\", derive(serde::Serialize))]\npub enum EngineErrorKind {\n    /// Normal EVM errors.\n    EvmError(ExitError),\n    /// Fatal EVM errors.\n    EvmFatal(ExitFatal),\n    /// Incorrect nonce.\n    IncorrectNonce,\n    FailedTransactionParse(crate::prelude::transactions::Error),\n    InvalidChainId,\n    InvalidSignature,\n    IntrinsicGasNotMet,\n    MaxPriorityGasFeeTooLarge,\n    GasPayment(GasPaymentError),\n    GasOverflow,\n    FixedGasOverflow,\n    NotAllowed,\n    SameOwner,\n    NotOwner,\n    NonExistedKey,\n    Erc20FromNep141,\n}\n\nimpl EngineErrorKind {\n    #[must_use]\n    pub fn as_bytes(&self) -> &[u8] {\n        match self {\n            Self::EvmError(ExitError::StackUnderflow) => errors::ERR_STACK_UNDERFLOW,\n            Self::EvmError(ExitError::StackOverflow) => errors::ERR_STACK_OVERFLOW,\n            Self::EvmError(ExitError::InvalidJump) => errors::ERR_INVALID_JUMP,\n            Self::EvmError(ExitError::InvalidRange) => errors::ERR_INVALID_RANGE,\n            Self::EvmError(ExitError::DesignatedInvalid) => errors::ERR_DESIGNATED_INVALID,\n            Self::EvmError(ExitError::CallTooDeep) => errors::ERR_CALL_TOO_DEEP,\n            Self::EvmError(ExitError::CreateCollision) => errors::ERR_CREATE_COLLISION,\n            Self::EvmError(ExitError::CreateContractLimit) => errors::ERR_CREATE_CONTRACT_LIMIT,\n            Self::EvmError(ExitError::InvalidCode(_)) => errors::ERR_INVALID_OPCODE,\n            Self::EvmError(ExitError::OutOfOffset) => errors::ERR_OUT_OF_OFFSET,\n            Self::EvmError(ExitError::OutOfGas) => errors::ERR_OUT_OF_GAS,\n            Self::EvmError(ExitError::OutOfFund) => errors::ERR_OUT_OF_FUND,\n            Self::EvmError(ExitError::CreateEmpty) => errors::ERR_CREATE_EMPTY,\n            Self::EvmError(ExitError::MaxNonce) => errors::ERR_MAX_NONCE,\n            Self::EvmFatal(ExitFatal::NotSupported) => errors::ERR_NOT_SUPPORTED,\n            Self::EvmFatal(ExitFatal::UnhandledInterrupt) => errors::ERR_UNHANDLED_INTERRUPT,\n            Self::EvmError(ExitError::Other(m)) | Self::EvmFatal(ExitFatal::Other(m)) => {\n                m.as_bytes()\n            }\n            Self::IncorrectNonce => errors::ERR_INCORRECT_NONCE,\n            Self::FailedTransactionParse(e) => e.as_ref(),\n            Self::InvalidChainId => errors::ERR_INVALID_CHAIN_ID,\n            Self::InvalidSignature => errors::ERR_INVALID_ECDSA_SIGNATURE,\n            Self::IntrinsicGasNotMet => errors::ERR_INTRINSIC_GAS,\n            Self::MaxPriorityGasFeeTooLarge => errors::ERR_MAX_PRIORITY_FEE_GREATER,\n            Self::GasPayment(e) => e.as_ref(),\n            Self::GasOverflow => errors::ERR_GAS_OVERFLOW,\n            Self::FixedGasOverflow => errors::ERR_FIXED_GAS_OVERFLOW,\n            Self::NotAllowed => errors::ERR_NOT_ALLOWED,\n            Self::SameOwner => errors::ERR_SAME_OWNER,\n            Self::NotOwner => errors::ERR_NOT_OWNER,\n            Self::NonExistedKey => errors::ERR_FUNCTION_CALL_KEY_NOT_FOUND,\n            Self::Erc20FromNep141 => errors::ERR_GETTING_ERC20_FROM_NEP141,\n            Self::EvmFatal(_) | Self::EvmError(_) => unreachable!(), // unused misc\n        }\n    }\n}\n\nimpl AsRef<[u8]> for EngineErrorKind {\n    fn as_ref(&self) -> &[u8] {\n        self.as_bytes()\n    }\n}\n\nimpl From<ExitError> for EngineErrorKind {\n    fn from(e: ExitError) -> Self {\n        Self::EvmError(e)\n    }\n}\n\nimpl From<ExitFatal> for EngineErrorKind {\n    fn from(e: ExitFatal) -> Self {\n        Self::EvmFatal(e)\n    }\n}\n\n/// An engine result.\npub type EngineResult<T> = Result<T, EngineError>;\n\ntrait ExitIntoResult {\n    /// Checks if the EVM exit is ok or an error.\n    fn into_result(self, data: Vec<u8>) -> Result<TransactionStatus, EngineErrorKind>;\n}\n\nimpl ExitIntoResult for ExitReason {\n    fn into_result(self, data: Vec<u8>) -> Result<TransactionStatus, EngineErrorKind> {\n        match self {\n            Self::Succeed(_) => Ok(TransactionStatus::Succeed(data)),\n            Self::Revert(_) => Ok(TransactionStatus::Revert(data)),\n            Self::Error(ExitError::OutOfOffset) => Ok(TransactionStatus::OutOfOffset),\n            Self::Error(ExitError::OutOfFund) => Ok(TransactionStatus::OutOfFund),\n            Self::Error(ExitError::OutOfGas) => Ok(TransactionStatus::OutOfGas),\n            Self::Error(e) => Err(e.into()),\n            Self::Fatal(e) => Err(e.into()),\n        }\n    }\n}\n\n#[derive(Debug, Clone, Eq, PartialEq)]\n#[cfg_attr(feature = \"impl-serde\", derive(serde::Serialize, serde::Deserialize))]\npub struct BalanceOverflow;\n\nimpl AsRef<[u8]> for BalanceOverflow {\n    fn as_ref(&self) -> &[u8] {\n        errors::ERR_BALANCE_OVERFLOW\n    }\n}\n\n/// Errors resulting from trying to pay for gas\n#[derive(Debug, Clone, Eq, PartialEq)]\n#[cfg_attr(feature = \"impl-serde\", derive(serde::Serialize, serde::Deserialize))]\npub enum GasPaymentError {\n    /// Overflow adding ETH to an account balance (should never happen)\n    BalanceOverflow(BalanceOverflow),\n    /// Overflow in gas * gas_price calculation\n    EthAmountOverflow,\n    /// Not enough balance for account to cover the gas cost\n    OutOfFund,\n}\n\nimpl AsRef<[u8]> for GasPaymentError {\n    fn as_ref(&self) -> &[u8] {\n        match self {\n            Self::BalanceOverflow(overflow) => overflow.as_ref(),\n            Self::EthAmountOverflow => errors::ERR_GAS_ETH_AMOUNT_OVERFLOW,\n            Self::OutOfFund => errors::ERR_OUT_OF_FUND,\n        }\n    }\n}\n\nimpl From<BalanceOverflow> for GasPaymentError {\n    fn from(overflow: BalanceOverflow) -> Self {\n        Self::BalanceOverflow(overflow)\n    }\n}\n\n#[derive(Debug)]\npub enum DeployErc20Error {\n    State(state::EngineStateError),\n    Failed(TransactionStatus),\n    Engine(EngineError),\n    Register(RegisterTokenError),\n}\n\nimpl AsRef<[u8]> for DeployErc20Error {\n    fn as_ref(&self) -> &[u8] {\n        match self {\n            Self::State(e) => e.as_ref(),\n            Self::Failed(e) => e.as_ref(),\n            Self::Engine(e) => e.as_ref(),\n            Self::Register(e) => e.as_ref(),\n        }\n    }\n}\n\npub struct ERC20Address(pub Address);\n\nimpl AsRef<[u8]> for ERC20Address {\n    fn as_ref(&self) -> &[u8] {\n        self.0.as_bytes()\n    }\n}\n\nimpl TryFrom<Vec<u8>> for ERC20Address {\n    type Error = AddressParseError;\n\n    fn try_from(bytes: Vec<u8>) -> Result<Self, Self::Error> {\n        if bytes.len() == 20 {\n            Ok(Self(\n                Address::try_from_slice(&bytes).map_err(|_| AddressParseError)?,\n            ))\n        } else {\n            Err(AddressParseError)\n        }\n    }\n}\n\npub struct AddressParseError;\n\nimpl AsRef<[u8]> for AddressParseError {\n    fn as_ref(&self) -> &[u8] {\n        errors::ERR_PARSE_ADDRESS\n    }\n}\n\npub struct NEP141Account(pub AccountId);\n\nimpl AsRef<[u8]> for NEP141Account {\n    fn as_ref(&self) -> &[u8] {\n        self.0.as_bytes()\n    }\n}\n\nimpl TryFrom<Vec<u8>> for NEP141Account {\n    type Error = aurora_engine_types::account_id::ParseAccountError;\n\n    fn try_from(bytes: Vec<u8>) -> Result<Self, Self::Error> {\n        AccountId::try_from(bytes).map(Self)\n    }\n}\n\n#[derive(Debug)]\npub enum GetErc20FromNep141Error {\n    InvalidNep141AccountId,\n    Nep141NotFound,\n    InvalidAddress,\n}\n\nimpl AsRef<[u8]> for GetErc20FromNep141Error {\n    fn as_ref(&self) -> &[u8] {\n        match self {\n            Self::InvalidNep141AccountId => errors::ERR_INVALID_NEP141_ACCOUNT_ID,\n            Self::Nep141NotFound => errors::ERR_NEP141_NOT_FOUND,\n            Self::InvalidAddress => errors::ERR_PARSE_ADDRESS,\n        }\n    }\n}\n\n#[derive(Debug)]\npub enum RegisterTokenError {\n    InvalidNep141AccountId,\n    TokenAlreadyRegistered,\n    InvalidAddress,\n}\n\nimpl AsRef<[u8]> for RegisterTokenError {\n    fn as_ref(&self) -> &[u8] {\n        match self {\n            Self::InvalidNep141AccountId => errors::ERR_INVALID_NEP141_ACCOUNT_ID,\n            Self::TokenAlreadyRegistered => errors::ERR_NEP141_TOKEN_ALREADY_REGISTERED,\n            Self::InvalidAddress => errors::ERR_PARSE_ADDRESS,\n        }\n    }\n}\n\n#[derive(Debug)]\npub enum ReadMetadataError {\n    DecodeError,\n    WrongType,\n    NoValue,\n    Nep141NotFound,\n    EngineError(EngineErrorKind),\n}\n\nimpl AsRef<[u8]> for ReadMetadataError {\n    fn as_ref(&self) -> &[u8] {\n        match self {\n            Self::DecodeError => errors::ERR_DECODING_TOKEN,\n            Self::WrongType => errors::ERR_WRONG_TOKEN_TYPE,\n            Self::NoValue => errors::ERR_TOKEN_NO_VALUE,\n            Self::Nep141NotFound => errors::ERR_NEP141_NOT_FOUND,\n            Self::EngineError(e) => e.as_ref(),\n        }\n    }\n}\n\npub struct StackExecutorParams<'a, I, E, H> {\n    precompiles: Precompiles<'a, I, E, H>,\n    gas_limit: u64,\n}\n\nimpl<'env, I: IO + Copy, E: Env, H: ReadOnlyPromiseHandler> StackExecutorParams<'env, I, E, H> {\n    const fn new(gas_limit: u64, precompiles: Precompiles<'env, I, E, H>) -> Self {\n        Self {\n            precompiles,\n            gas_limit,\n        }\n    }\n\n    #[allow(clippy::type_complexity)]\n    fn make_executor<'a, M: ModExpAlgorithm>(\n        &'a self,\n        engine: &'a Engine<'env, I, E, M>,\n    ) -> executor::stack::StackExecutor<\n        'static,\n        'a,\n        executor::stack::MemoryStackState<Engine<'env, I, E, M>>,\n        Precompiles<'env, I, E, H>,\n    > {\n        let metadata = executor::stack::StackSubstateMetadata::new(self.gas_limit, CONFIG);\n        let state = executor::stack::MemoryStackState::new(metadata, engine);\n        executor::stack::StackExecutor::new_with_precompiles(state, CONFIG, &self.precompiles)\n    }\n}\n\n#[derive(Debug, Default, PartialEq, Eq)]\npub struct GasPaymentResult {\n    pub prepaid_amount: Wei,\n    pub effective_gas_price: U256,\n    pub priority_fee_per_gas: U256,\n}\n\npub struct Engine<'env, I: IO, E: Env, M = AuroraModExp> {\n    state: EngineState,\n    origin: Address,\n    gas_price: U256,\n    current_account_id: AccountId,\n    io: I,\n    env: &'env E,\n    generation_cache: RefCell<BTreeMap<Address, u32>>,\n    account_info_cache: RefCell<FullCache<Address, Basic>>,\n    contract_code_cache: RefCell<FullCache<Address, Vec<u8>>>,\n    contract_storage_cache: RefCell<FullCache<(Address, H256), H256>>,\n    modexp_algorithm: PhantomData<M>,\n}\n\npub(crate) const CONFIG: &Config = &Config::shanghai();\n\nimpl<'env, I: IO + Copy, E: Env, M: ModExpAlgorithm> Engine<'env, I, E, M> {\n    pub fn new(\n        origin: Address,\n        current_account_id: AccountId,\n        io: I,\n        env: &'env E,\n    ) -> Result<Self, state::EngineStateError> {\n        state::get_state(&io)\n            .map(|state| Self::new_with_state(state, origin, current_account_id, io, env))\n    }\n\n    pub fn new_with_state(\n        state: EngineState,\n        origin: Address,\n        current_account_id: AccountId,\n        io: I,\n        env: &'env E,\n    ) -> Self {\n        Self {\n            state,\n            origin,\n            gas_price: U256::zero(),\n            current_account_id,\n            io,\n            env,\n            generation_cache: RefCell::new(BTreeMap::new()),\n            account_info_cache: RefCell::new(FullCache::default()),\n            contract_code_cache: RefCell::new(FullCache::default()),\n            contract_storage_cache: RefCell::new(FullCache::default()),\n            modexp_algorithm: PhantomData,\n        }\n    }\n\n    pub fn charge_gas(\n        &mut self,\n        sender: &Address,\n        transaction: &NormalizedEthTransaction,\n        max_gas_price: Option<U256>,\n        fixed_gas: Option<EthGas>,\n    ) -> Result<GasPaymentResult, GasPaymentError> {\n        if transaction.max_fee_per_gas.is_zero() && fixed_gas.is_none() {\n            return Ok(GasPaymentResult::default());\n        }\n\n        let priority_fee_per_gas = transaction\n            .max_priority_fee_per_gas\n            .min(transaction.max_fee_per_gas - self.block_base_fee_per_gas());\n        let priority_fee_per_gas = max_gas_price.map_or(priority_fee_per_gas, |price| {\n            price.min(priority_fee_per_gas)\n        });\n        let effective_gas_price = priority_fee_per_gas + self.block_base_fee_per_gas();\n        // First we try to use `fixed_gas`. At this point we already know that the `fixed_gas` is\n        // less than the `gas_limit`. It allows to avoid refund unused gas to the sender later.\n        let prepaid_amount = fixed_gas\n            .map_or(transaction.gas_limit, EthGas::as_u256)\n            .checked_mul(effective_gas_price)\n            .map(Wei::new)\n            .ok_or(GasPaymentError::EthAmountOverflow)?;\n\n        let new_balance = get_balance(&self.io, sender)\n            .checked_sub(prepaid_amount)\n            .ok_or(GasPaymentError::OutOfFund)?;\n\n        set_balance(&mut self.io, sender, &new_balance);\n\n        self.gas_price = effective_gas_price;\n\n        Ok(GasPaymentResult {\n            prepaid_amount,\n            effective_gas_price,\n            priority_fee_per_gas,\n        })\n    }\n\n    pub fn deploy_code_with_input<P: PromiseHandler>(\n        &mut self,\n        input: Vec<u8>,\n        address: Option<Address>,\n        handler: &mut P,\n    ) -> EngineResult<SubmitResult> {\n        let origin = Address::new(self.origin());\n        let value = Wei::zero();\n        self.deploy_code(origin, value, input, address, u64::MAX, Vec::new(), handler)\n    }\n\n    #[allow(clippy::too_many_arguments)]\n    pub fn deploy_code<P: PromiseHandler>(\n        &mut self,\n        origin: Address,\n        value: Wei,\n        input: Vec<u8>,\n        address: Option<Address>,\n        gas_limit: u64,\n        access_list: Vec<(H160, Vec<H256>)>, // See EIP-2930\n        handler: &mut P,\n    ) -> EngineResult<SubmitResult> {\n        let pause_flags = EnginePrecompilesPauser::from_io(self.io).paused();\n        let precompiles = self.create_precompiles(pause_flags, handler);\n\n        let executor_params = StackExecutorParams::new(gas_limit, precompiles);\n        let mut executor = executor_params.make_executor(self);\n        let scheme = address.map_or_else(\n            || CreateScheme::Legacy {\n                caller: origin.raw(),\n            },\n            |address| CreateScheme::Fixed(address.raw()),\n        );\n        let address = executor.create_address(scheme);\n        let (exit_reason, return_value) = match scheme {\n            CreateScheme::Legacy { caller } => {\n                executor.transact_create(caller, value.raw(), input, gas_limit, access_list)\n            }\n            CreateScheme::Fixed(address) => executor.transact_create_fixed(\n                origin.raw(),\n                address,\n                value.raw(),\n                input,\n                gas_limit,\n                access_list,\n            ),\n            CreateScheme::Create2 { .. } => unreachable!(),\n        };\n        let result = if exit_reason.is_succeed() {\n            address.0.to_vec()\n        } else {\n            return_value\n        };\n\n        let used_gas = executor.used_gas();\n        let status = exit_reason.into_result(result)?;\n\n        let (values, logs) = executor.into_state().deconstruct();\n        let logs = filter_promises_from_logs(&self.io, handler, logs, &self.current_account_id);\n\n        self.apply(values, Vec::<Log>::new(), true);\n\n        Ok(SubmitResult::new(status, used_gas, logs))\n    }\n\n    /// Call the EVM contract with arguments\n    pub fn call_with_args<P: PromiseHandler>(\n        &mut self,\n        args: CallArgs,\n        handler: &mut P,\n    ) -> EngineResult<SubmitResult> {\n        let origin = Address::new(self.origin());\n        match args {\n            CallArgs::V2(call_args) => {\n                let contract = call_args.contract;\n                let value = call_args.value.into();\n                let input = call_args.input;\n                self.call(\n                    &origin,\n                    &contract,\n                    value,\n                    input,\n                    u64::MAX,\n                    Vec::new(),\n                    handler,\n                )\n            }\n            CallArgs::V1(call_args) => {\n                let contract = call_args.contract;\n                let value = Wei::zero();\n                let input = call_args.input;\n                self.call(\n                    &origin,\n                    &contract,\n                    value,\n                    input,\n                    u64::MAX,\n                    Vec::new(),\n                    handler,\n                )\n            }\n        }\n    }\n\n    #[allow(clippy::too_many_arguments)]\n    pub fn call<P: PromiseHandler>(\n        &mut self,\n        origin: &Address,\n        contract: &Address,\n        value: Wei,\n        input: Vec<u8>,\n        gas_limit: u64,\n        access_list: Vec<(H160, Vec<H256>)>, // See EIP-2930\n        handler: &mut P,\n    ) -> EngineResult<SubmitResult> {\n        let pause_flags = EnginePrecompilesPauser::from_io(self.io).paused();\n        let precompiles = self.create_precompiles(pause_flags, handler);\n\n        let executor_params = StackExecutorParams::new(gas_limit, precompiles);\n        let mut executor = executor_params.make_executor(self);\n        let (exit_reason, result) = executor.transact_call(\n            origin.raw(),\n            contract.raw(),\n            value.raw(),\n            input,\n            gas_limit,\n            access_list,\n        );\n\n        let used_gas = executor.used_gas();\n        let status = exit_reason.into_result(result)?;\n\n        let (values, logs) = executor.into_state().deconstruct();\n        let logs = filter_promises_from_logs(&self.io, handler, logs, &self.current_account_id);\n        // The logs could be encoded as base64 or hex string.\n        self.apply(values, Vec::<Log>::new(), true);\n\n        Ok(SubmitResult::new(status, used_gas, logs))\n    }\n\n    pub fn view_with_args(&self, args: ViewCallArgs) -> Result<TransactionStatus, EngineErrorKind> {\n        let origin = &args.sender;\n        let contract = &args.address;\n        let value = U256::from_big_endian(&args.amount);\n        // View calls cannot interact with promises\n        let handler = aurora_engine_sdk::promise::Noop;\n        let pause_flags = EnginePrecompilesPauser::from_io(self.io).paused();\n        let precompiles = self.create_precompiles(pause_flags, &handler);\n\n        let executor_params = StackExecutorParams::new(u64::MAX, precompiles);\n        self.view(\n            origin,\n            contract,\n            Wei::new(value),\n            args.input,\n            &executor_params,\n        )\n    }\n\n    pub fn view(\n        &self,\n        origin: &Address,\n        contract: &Address,\n        value: Wei,\n        input: Vec<u8>,\n        executor_params: &StackExecutorParams<I, E, aurora_engine_sdk::promise::Noop>,\n    ) -> Result<TransactionStatus, EngineErrorKind> {\n        let mut executor = executor_params.make_executor(self);\n        let (status, result) = executor.transact_call(\n            origin.raw(),\n            contract.raw(),\n            value.raw(),\n            input,\n            executor_params.gas_limit,\n            Vec::new(),\n        );\n        status.into_result(result)\n    }\n\n    fn relayer_key(account_id: &[u8]) -> Vec<u8> {\n        bytes_to_key(KeyPrefix::RelayerEvmAddressMap, account_id)\n    }\n\n    pub fn register_relayer(&mut self, account_id: &[u8], evm_address: Address) {\n        let key = Self::relayer_key(account_id);\n        self.io.write_storage(&key, evm_address.as_bytes());\n    }\n\n    pub fn get_relayer(&self, account_id: &[u8]) -> Option<Address> {\n        let key = Self::relayer_key(account_id);\n        let raw_addr = self.io.read_storage(&key).map(|v| v.to_vec())?;\n        Address::try_from_slice(&raw_addr[..]).ok()\n    }\n\n    pub fn register_token(\n        &mut self,\n        erc20_token: Address,\n        nep141_token: AccountId,\n    ) -> Result<(), RegisterTokenError> {\n        match get_erc20_from_nep141(&self.io, &nep141_token) {\n            Err(GetErc20FromNep141Error::Nep141NotFound) => (),\n            Err(GetErc20FromNep141Error::InvalidNep141AccountId) => {\n                return Err(RegisterTokenError::InvalidNep141AccountId);\n            }\n            Err(GetErc20FromNep141Error::InvalidAddress) => {\n                return Err(RegisterTokenError::InvalidAddress);\n            }\n            Ok(_) => return Err(RegisterTokenError::TokenAlreadyRegistered),\n        }\n\n        let erc20_token = ERC20Address(erc20_token);\n        let nep141_token = NEP141Account(nep141_token);\n        nep141_erc20_map(self.io).insert(&nep141_token, &erc20_token);\n        Ok(())\n    }\n\n    /// Transfers an amount from a given sender to a receiver, provided that\n    /// they have enough in their balance.\n    ///\n    /// If the sender can send, and the receiver can receive, then the transfer\n    /// will execute successfully.\n    pub fn transfer<P: PromiseHandler>(\n        &mut self,\n        sender: Address,\n        receiver: Address,"
    }
  ]
}