{
  "Title": "[M-18] Users may not be able to redeem their shares due to underflow",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/tokens/TokenggAVAX.sol#L191\nhttps://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/tokens/TokenggAVAX.sol#L88\n\n\n# Vulnerability details\n\n## Impact\n\nThe ```totalReleasedAssets``` variable is updated on the [syncRewards()](https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/tokens/TokenggAVAX.sol#L88) function if someone calls the function before ```rewardsCycleEnd``` the [redeemAVAX()](https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/tokens/TokenggAVAX.sol#L191) will be reverted because the ```totalReleasedAssets``` may not include all the rewards.\n\nThe ggAvax holder can not redeem his funds until the ```rewardsCycleEnd```\n\n## Proof of Concept\n\nI did the next test:\n\n1. Create minipool (2000 avax)\n2. Deposit rewards to the minipool (200 AVAX rewards)\n3. Sync the rewards before the cycle ends\n4. Redeem function will revert\n5. Redeem will be available after the cycle end\n\n```solidity\nfunction testRedeemUnderOverFlow() public {\n    // Redeem function reverts arithmetic error\n    // 1.- Create minipool\n    // 2.- Deposit rewards to the minipool\n    // 3.- Sync the Rewards before the cycle end\n    // 4.- Redeem function will revert\n    // 5.- Redeem will be available after the cycle end.\n    // Deposit liquid staker funds\n    uint256 depositAmount = 1200 ether;\n    uint256 nodeAmt = 2000 ether;\n    uint128 ggpStakeAmt = 200 ether;\n    vm.deal(bob, depositAmount);\n    vm.prank(bob);\n    ggAVAX.depositAVAX{value: depositAmount}();//Avax deposit 1200\n    //\n    // 1.- Create minipool\n    //\n    address nodeOp = getActorWithTokens(\"nodeOp\", uint128(depositAmount), ggpStakeAmt);\n    // Nodeop stake GGP and create minipoool\n    vm.startPrank(nodeOp);\n    ggp.approve(address(staking), ggpStakeAmt);\n    staking.stakeGGP(ggpStakeAmt);\n    MinipoolManager.Minipool memory mp = createMinipool(nodeAmt / 2, nodeAmt / 2, duration);\n    vm.stopPrank();\n    // Rialto init recordStakingStart\n    vm.startPrank(address(rialto));\n    minipoolMgr.claimAndInitiateStaking(mp.nodeID);\n    minipoolMgr.recordStakingStart(mp.nodeID, randHash(), block.timestamp);\n    vm.stopPrank();\n    skip(mp.duration);\n    //\n    // 2.- Deposit rewards to the minipool\n    //\n    uint256 rewardsAmt = nodeAmt.mulDivDown(0.1 ether, 1 ether);\n    console.log(\"Rewards amount:\", rewardsAmt / 1 ether);\n    vm.deal(address(rialto), address(rialto).balance + rewardsAmt);\n    vm.prank(address(rialto));\n    minipoolMgr.recordStakingEnd{value: nodeAmt + rewardsAmt}(mp.nodeID, block.timestamp, rewardsAmt);\n    //\n    // 3.- Sync the Rewards before the cycle end\n    //\n    ggAVAX.syncRewards();\n    uint256 maxRedeemSharesBob = ggAVAX.maxRedeem(bob);\n    console.log(\"TotalReleasedAssets after syncRewards:\", ggAVAX.totalReleasedAssets() / 1 ether);\n    console.log(\"LastRewards after syncRewards:\", ggAVAX.lastRewardsAmt() / 1 ether);\n    console.log(\"Bob maxRedeem():\", maxRedeemSharesBob / 1 ether);\n    //\n    // 4.- Redeem function will revert\n    //\n    skip(1 days);\n    console.log(\"Bob PreviewRedeem() after skip one day:\", ggAVAX.previewRedeem(maxRedeemSharesBob) / 1 ether);\n    vm.prank(bob);\n    vm.expectRevert(stdError.arithmeticError); // Revert by arithmetic error\n    ggAVAX.redeemAVAX(maxRedeemSharesBob);\n    //\n    // 5.- Redeem will be available after the cycle end.\n    //\n    skip(ggAVAX.rewardsCycleLength() + 1 days);\n    ggAVAX.syncRewards();\n    maxRedeemSharesBob = ggAVAX.maxRedeem(bob);\n    console.log(\"\");\n    console.log(\"TotalReleasedAssets after syncRewards:\", ggAVAX.totalReleasedAssets() / 1 ether);\n    console.log(\"LastRewards after syncRewards:\", ggAVAX.lastRewardsAmt() / 1 ether);\n    console.log(\"Bob maxRedeem():\", maxRedeemSharesBob / 1 ether);\n    console.log(\"Bob PreviewRedeem() after skip to the cycle end:\", ggAVAX.previewRedeem(maxRedeemSharesBob) / 1 ether);\n    vm.prank(bob);\n    ggAVAX.redeemAVAX(maxRedeemSharesBob);\n}\n```\n\nOutput:\n\n```\n[PASS] testRedeemUnderOverFlow() (gas: 1244356)\nLogs:\n  Rewards amount: 200\n  TotalReleasedAssets after syncRewards: 1200\n  LastRewards after syncRewards: 85\n  Bob maxRedeem(): 1200\n  Bob PreviewRedeem() after skip one day: 1206\n  \n  TotalReleasedAssets after syncRewards: 1285\n  LastRewards after syncRewards: 0\n  Bob maxRedeem(): 1200\n  Bob PreviewRedeem() after skip to the cycle end: 1285\n```\n\n## Tools used\nFoundry/VsCode\n\n## Recommended Mitigation Steps\nConsider redeem the max available amount for the shares owner instead of revert. The ```maxRedeem()``` function amount is not the same as the ```previewRedeem()``` amount.\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-12-gogopool-contest",
  "Code": [
    {
      "filename": "contracts/contract/tokens/TokenggAVAX.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n// Copied from https://github.com/fei-protocol/ERC4626/blob/main/src/xERC4626.sol\n// Rewards logic inspired by xERC20 (https://github.com/ZeframLou/playpen/blob/main/src/xERC20.sol)\npragma solidity 0.8.17;\n\nimport \"../BaseUpgradeable.sol\";\nimport {ERC20Upgradeable} from \"./upgradeable/ERC20Upgradeable.sol\";\nimport {ERC4626Upgradeable} from \"./upgradeable/ERC4626Upgradeable.sol\";\nimport {ProtocolDAO} from \"../ProtocolDAO.sol\";\nimport {Storage} from \"../Storage.sol\";\n\nimport {IWithdrawer} from \"../../interface/IWithdrawer.sol\";\nimport {IWAVAX} from \"../../interface/IWAVAX.sol\";\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\nimport {ERC20} from \"@rari-capital/solmate/src/mixins/ERC4626.sol\";\nimport {FixedPointMathLib} from \"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\";\nimport {SafeCastLib} from \"@rari-capital/solmate/src/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\n\n/// @dev Local variables and parent contracts must remain in order between contract upgrades\ncontract TokenggAVAX is Initializable, ERC4626Upgradeable, UUPSUpgradeable, BaseUpgradeable {\n\tusing SafeTransferLib for ERC20;\n\tusing SafeTransferLib for address;\n\tusing SafeCastLib for *;\n\tusing FixedPointMathLib for uint256;\n\n\terror SyncError();\n\terror ZeroShares();\n\terror ZeroAssets();\n\terror InvalidStakingDeposit();\n\terror WithdrawAmountTooLarge();\n\n\tevent NewRewardsCycle(uint256 indexed cycleEnd, uint256 rewardsAmt);\n\tevent WithdrawnForStaking(address indexed caller, uint256 assets);\n\tevent DepositedFromStaking(address indexed caller, uint256 baseAmt, uint256 rewardsAmt);\n\n\t/// @notice the effective start of the current cycle\n\tuint32 public lastSync;\n\n\t/// @notice the maximum length of a rewards cycle\n\tuint32 public rewardsCycleLength;\n\n\t/// @notice the end of the current cycle. Will always be evenly divisible by `rewardsCycleLength`.\n\tuint32 public rewardsCycleEnd;\n\n\t/// @notice the amount of rewards distributed in a the most recent cycle.\n\tuint192 public lastRewardsAmt;\n\n\t/// @notice the total amount of avax (including avax sent out for staking and all incoming rewards)\n\tuint256 public totalReleasedAssets;\n\n\t/// @notice total amount of avax currently out for staking (not including any rewards)\n\tuint256 public stakingTotalAssets;\n\n\tmodifier whenTokenNotPaused(uint256 amt) {\n\t\tif (amt > 0 && getBool(keccak256(abi.encodePacked(\"contract.paused\", \"TokenggAVAX\")))) {\n\t\t\trevert ContractPaused();\n\t\t}\n\t\t_;\n\t}\n\n\t/// @custom:oz-upgrades-unsafe-allow constructor\n\tconstructor() {\n\t\t// The constructor is exectued only when creating implementation contract\n\t\t// so prevent it's reinitialization\n\t\t_disableInitializers();\n\t}\n\n\tfunction initialize(Storage storageAddress, ERC20 asset) public initializer {\n\t\t__ERC4626Upgradeable_init(asset, \"GoGoPool Liquid Staking Token\", \"ggAVAX\");\n\t\t__BaseUpgradeable_init(storageAddress);\n\n\t\trewardsCycleLength = 14 days;\n\t\t// Ensure it will be evenly divisible by `rewardsCycleLength`.\n\t\trewardsCycleEnd = (block.timestamp.safeCastTo32() / rewardsCycleLength) * rewardsCycleLength;\n\t}\n\n\t/// @notice only accept AVAX via fallback from the WAVAX contract\n\treceive() external payable {\n\t\tassert(msg.sender == address(asset));\n\t}\n\n\t/// @notice Distributes rewards to TokenggAVAX holders. Public, anyone can call.\n\t/// \t\t\t\tAll surplus `asset` balance of the contract over the internal balance becomes queued for the next cycle.\n\tfunction syncRewards() public {\n\t\tuint32 timestamp = block.timestamp.safeCastTo32();\n\n\t\tif (timestamp < rewardsCycleEnd) {\n\t\t\trevert SyncError();\n\t\t}\n\n\t\tuint192 lastRewardsAmt_ = lastRewardsAmt;\n\t\tuint256 totalReleasedAssets_ = totalReleasedAssets;\n\t\tuint256 stakingTotalAssets_ = stakingTotalAssets;\n\n\t\tuint256 nextRewardsAmt = (asset.balanceOf(address(this)) + stakingTotalAssets_) - totalReleasedAssets_ - lastRewardsAmt_;\n\n\t\t// Ensure nextRewardsCycleEnd will be evenly divisible by `rewardsCycleLength`.\n\t\tuint32 nextRewardsCycleEnd = ((timestamp + rewardsCycleLength) / rewardsCycleLength) * rewardsCycleLength;\n\n\t\tlastRewardsAmt = nextRewardsAmt.safeCastTo192();\n\t\tlastSync = timestamp;\n\t\trewardsCycleEnd = nextRewardsCycleEnd;\n\t\ttotalReleasedAssets = totalReleasedAssets_ + lastRewardsAmt_;\n\t\temit NewRewardsCycle(nextRewardsCycleEnd, nextRewardsAmt);\n\t}\n\n\t/// @notice Compute the amount of tokens available to share holders.\n\t///         Increases linearly during a reward distribution period from the sync call, not the cycle start.\n\tfunction totalAssets() public view override returns (uint256) {\n\t\t// cache global vars\n\t\tuint256 totalReleasedAssets_ = totalReleasedAssets;\n\t\tuint192 lastRewardsAmt_ = lastRewardsAmt;\n\t\tuint32 rewardsCycleEnd_ = rewardsCycleEnd;\n\t\tuint32 lastSync_ = lastSync;\n\n\t\tif (block.timestamp >= rewardsCycleEnd_) {\n\t\t\t// no rewards or rewards are fully unlocked\n\t\t\t// entire reward amount is available\n\t\t\treturn totalReleasedAssets_ + lastRewardsAmt_;\n\t\t}\n\n\t\t// rewards are not fully unlocked\n\t\t// return unlocked rewards and stored total\n\t\tuint256 unlockedRewards = (lastRewardsAmt_ * (block.timestamp - lastSync_)) / (rewardsCycleEnd_ - lastSync_);\n\t\treturn totalReleasedAssets_ + unlockedRewards;\n\t}\n\n\tfunction amountAvailableForStaking() public view returns (uint256) {\n\t\tProtocolDAO protocolDAO = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n\t\tuint256 targetCollateralRate = protocolDAO.getTargetGGAVAXReserveRate();\n\n\t\tuint256 totalAssets_ = totalAssets();\n\n\t\tuint256 reservedAssets = totalAssets_.mulDivDown(targetCollateralRate, 1 ether);\n\t\treturn totalAssets_ - reservedAssets - stakingTotalAssets;\n\t}\n\n\tfunction depositFromStaking(uint256 baseAmt, uint256 rewardAmt) public payable onlySpecificRegisteredContract(\"MinipoolManager\", msg.sender) {\n\t\tuint256 totalAmt = msg.value;\n\t\tif (totalAmt != (baseAmt + rewardAmt) || baseAmt > stakingTotalAssets) {\n\t\t\trevert InvalidStakingDeposit();\n\t\t}\n\n\t\temit DepositedFromStaking(msg.sender, baseAmt, rewardAmt);\n\t\tstakingTotalAssets -= baseAmt;\n\t\tIWAVAX(address(asset)).deposit{value: totalAmt}();\n\t}\n\n\tfunction withdrawForStaking(uint256 assets) public onlySpecificRegisteredContract(\"MinipoolManager\", msg.sender) {\n\t\tif (assets > amountAvailableForStaking()) {\n\t\t\trevert WithdrawAmountTooLarge();\n\t\t}\n\n\t\temit WithdrawnForStaking(msg.sender, assets);\n\n\t\tstakingTotalAssets += assets;\n\t\tIWAVAX(address(asset)).withdraw(assets);\n\t\tIWithdrawer withdrawer = IWithdrawer(msg.sender);\n\t\twithdrawer.receiveWithdrawalAVAX{value: assets}();\n\t}\n\n\tfunction depositAVAX() public payable returns (uint256 shares) {\n\t\tuint256 assets = msg.value;\n\t\t// Check for rounding error since we round down in previewDeposit.\n\t\tif ((shares = previewDeposit(assets)) == 0) {\n\t\t\trevert ZeroShares();\n\t\t}\n\n\t\temit Deposit(msg.sender, msg.sender, assets, shares);\n\n\t\tIWAVAX(address(asset)).deposit{value: assets}();\n\t\t_mint(msg.sender, shares);\n\t\tafterDeposit(assets, shares);\n\t}\n\n\tfunction withdrawAVAX(uint256 assets) public returns (uint256 shares) {\n\t\tshares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\t\tbeforeWithdraw(assets, shares);\n\t\t_burn(msg.sender, shares);\n\n\t\temit Withdraw(msg.sender, msg.sender, msg.sender, assets, shares);\n\n\t\tIWAVAX(address(asset)).withdraw(assets);\n\t\tmsg.sender.safeTransferETH(assets);\n\t}\n\n\tfunction redeemAVAX(uint256 shares) public returns (uint256 assets) {\n\t\t// Check for rounding error since we round down in previewRedeem.\n\t\tif ((assets = previewRedeem(shares)) == 0) {\n\t\t\trevert ZeroAssets();\n\t\t}\n\t\tbeforeWithdraw(assets, shares);\n\t\t_burn(msg.sender, shares);\n\n\t\temit Withdraw(msg.sender, msg.sender, msg.sender, assets, shares);\n\n\t\tIWAVAX(address(asset)).withdraw(assets);\n\t\tmsg.sender.safeTransferETH(assets);\n\t}\n\n\t/// @notice Max amount of assets owner would be able to withdraw taking into account liquidity in this contract\n\tfunction maxWithdraw(address _owner) public view override returns (uint256) {\n\t\tif (getBool(keccak256(abi.encodePacked(\"contract.paused\", \"TokenggAVAX\")))) {\n\t\t\treturn 0;\n\t\t}\n\t\tuint256 assets = convertToAssets(balanceOf[_owner]);\n\t\tuint256 avail = totalAssets() - stakingTotalAssets;\n\t\treturn assets > avail ? avail : assets;\n\t}\n\n\t/// @notice Max amount of shares owner would be able to withdraw taking into account liquidity in this contract\n\tfunction maxRedeem(address _owner) public view override returns (uint256) {\n\t\tif (getBool(keccak256(abi.encodePacked(\"contract.paused\", \"TokenggAVAX\")))) {\n\t\t\treturn 0;\n\t\t}\n\t\tuint256 shares = balanceOf[_owner];\n\t\tuint256 avail = convertToShares(totalAssets() - stakingTotalAssets);\n\t\treturn shares > avail ? avail : shares;\n\t}\n\n\tfunction previewDeposit(uint256 assets) public view override whenTokenNotPaused(assets) returns (uint256) {\n\t\treturn super.previewDeposit(assets);\n\t}\n\n\tfunction previewMint(uint256 shares) public view override whenTokenNotPaused(shares) returns (uint256) {\n\t\treturn super.previewMint(shares);\n\t}\n\n\tfunction previewWithdraw(uint256 assets) public view override whenTokenNotPaused(assets) returns (uint256) {\n\t\treturn super.previewWithdraw(assets);\n\t}\n\n\tfunction previewRedeem(uint256 shares) public view override whenTokenNotPaused(shares) returns (uint256) {\n\t\treturn super.previewRedeem(shares);\n\t}\n\n\tfunction beforeWithdraw(\n\t\tuint256 amount,\n\t\tuint256 /* shares */\n\t) internal override {\n\t\ttotalReleasedAssets -= amount;\n\t}\n\n\tfunction afterDeposit(\n\t\tuint256 amount,\n\t\tuint256 /* shares */\n\t) internal override {\n\t\ttotalReleasedAssets += amount;\n\t}\n\n\tfunction _authorizeUpgrade(address newImplementation) internal override onlyGuardian {}\n}"
    },
    {
      "filename": "contracts/contract/tokens/TokenggAVAX.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n// Copied from https://github.com/fei-protocol/ERC4626/blob/main/src/xERC4626.sol\n// Rewards logic inspired by xERC20 (https://github.com/ZeframLou/playpen/blob/main/src/xERC20.sol)\npragma solidity 0.8.17;\n\nimport \"../BaseUpgradeable.sol\";\nimport {ERC20Upgradeable} from \"./upgradeable/ERC20Upgradeable.sol\";\nimport {ERC4626Upgradeable} from \"./upgradeable/ERC4626Upgradeable.sol\";\nimport {ProtocolDAO} from \"../ProtocolDAO.sol\";\nimport {Storage} from \"../Storage.sol\";\n\nimport {IWithdrawer} from \"../../interface/IWithdrawer.sol\";\nimport {IWAVAX} from \"../../interface/IWAVAX.sol\";\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\nimport {ERC20} from \"@rari-capital/solmate/src/mixins/ERC4626.sol\";\nimport {FixedPointMathLib} from \"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\";\nimport {SafeCastLib} from \"@rari-capital/solmate/src/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\n\n/// @dev Local variables and parent contracts must remain in order between contract upgrades\ncontract TokenggAVAX is Initializable, ERC4626Upgradeable, UUPSUpgradeable, BaseUpgradeable {\n\tusing SafeTransferLib for ERC20;\n\tusing SafeTransferLib for address;\n\tusing SafeCastLib for *;\n\tusing FixedPointMathLib for uint256;\n\n\terror SyncError();\n\terror ZeroShares();\n\terror ZeroAssets();\n\terror InvalidStakingDeposit();\n\terror WithdrawAmountTooLarge();\n\n\tevent NewRewardsCycle(uint256 indexed cycleEnd, uint256 rewardsAmt);\n\tevent WithdrawnForStaking(address indexed caller, uint256 assets);\n\tevent DepositedFromStaking(address indexed caller, uint256 baseAmt, uint256 rewardsAmt);\n\n\t/// @notice the effective start of the current cycle\n\tuint32 public lastSync;\n\n\t/// @notice the maximum length of a rewards cycle\n\tuint32 public rewardsCycleLength;\n\n\t/// @notice the end of the current cycle. Will always be evenly divisible by `rewardsCycleLength`.\n\tuint32 public rewardsCycleEnd;\n\n\t/// @notice the amount of rewards distributed in a the most recent cycle.\n\tuint192 public lastRewardsAmt;\n\n\t/// @notice the total amount of avax (including avax sent out for staking and all incoming rewards)\n\tuint256 public totalReleasedAssets;\n\n\t/// @notice total amount of avax currently out for staking (not including any rewards)\n\tuint256 public stakingTotalAssets;\n\n\tmodifier whenTokenNotPaused(uint256 amt) {\n\t\tif (amt > 0 && getBool(keccak256(abi.encodePacked(\"contract.paused\", \"TokenggAVAX\")))) {\n\t\t\trevert ContractPaused();\n\t\t}\n\t\t_;\n\t}\n\n\t/// @custom:oz-upgrades-unsafe-allow constructor\n\tconstructor() {\n\t\t// The constructor is exectued only when creating implementation contract\n\t\t// so prevent it's reinitialization\n\t\t_disableInitializers();\n\t}\n\n\tfunction initialize(Storage storageAddress, ERC20 asset) public initializer {\n\t\t__ERC4626Upgradeable_init(asset, \"GoGoPool Liquid Staking Token\", \"ggAVAX\");\n\t\t__BaseUpgradeable_init(storageAddress);\n\n\t\trewardsCycleLength = 14 days;\n\t\t// Ensure it will be evenly divisible by `rewardsCycleLength`.\n\t\trewardsCycleEnd = (block.timestamp.safeCastTo32() / rewardsCycleLength) * rewardsCycleLength;\n\t}\n\n\t/// @notice only accept AVAX via fallback from the WAVAX contract\n\treceive() external payable {\n\t\tassert(msg.sender == address(asset));\n\t}\n\n\t/// @notice Distributes rewards to TokenggAVAX holders. Public, anyone can call.\n\t/// \t\t\t\tAll surplus `asset` balance of the contract over the internal balance becomes queued for the next cycle.\n\tfunction syncRewards() public {\n\t\tuint32 timestamp = block.timestamp.safeCastTo32();\n\n\t\tif (timestamp < rewardsCycleEnd) {\n\t\t\trevert SyncError();\n\t\t}\n\n\t\tuint192 lastRewardsAmt_ = lastRewardsAmt;\n\t\tuint256 totalReleasedAssets_ = totalReleasedAssets;\n\t\tuint256 stakingTotalAssets_ = stakingTotalAssets;\n\n\t\tuint256 nextRewardsAmt = (asset.balanceOf(address(this)) + stakingTotalAssets_) - totalReleasedAssets_ - lastRewardsAmt_;\n\n\t\t// Ensure nextRewardsCycleEnd will be evenly divisible by `rewardsCycleLength`.\n\t\tuint32 nextRewardsCycleEnd = ((timestamp + rewardsCycleLength) / rewardsCycleLength) * rewardsCycleLength;\n\n\t\tlastRewardsAmt = nextRewardsAmt.safeCastTo192();\n\t\tlastSync = timestamp;\n\t\trewardsCycleEnd = nextRewardsCycleEnd;\n\t\ttotalReleasedAssets = totalReleasedAssets_ + lastRewardsAmt_;\n\t\temit NewRewardsCycle(nextRewardsCycleEnd, nextRewardsAmt);\n\t}\n\n\t/// @notice Compute the amount of tokens available to share holders.\n\t///         Increases linearly during a reward distribution period from the sync call, not the cycle start.\n\tfunction totalAssets() public view override returns (uint256) {\n\t\t// cache global vars\n\t\tuint256 totalReleasedAssets_ = totalReleasedAssets;\n\t\tuint192 lastRewardsAmt_ = lastRewardsAmt;\n\t\tuint32 rewardsCycleEnd_ = rewardsCycleEnd;\n\t\tuint32 lastSync_ = lastSync;\n\n\t\tif (block.timestamp >= rewardsCycleEnd_) {\n\t\t\t// no rewards or rewards are fully unlocked\n\t\t\t// entire reward amount is available\n\t\t\treturn totalReleasedAssets_ + lastRewardsAmt_;\n\t\t}\n\n\t\t// rewards are not fully unlocked\n\t\t// return unlocked rewards and stored total\n\t\tuint256 unlockedRewards = (lastRewardsAmt_ * (block.timestamp - lastSync_)) / (rewardsCycleEnd_ - lastSync_);\n\t\treturn totalReleasedAssets_ + unlockedRewards;\n\t}\n\n\tfunction amountAvailableForStaking() public view returns (uint256) {\n\t\tProtocolDAO protocolDAO = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n\t\tuint256 targetCollateralRate = protocolDAO.getTargetGGAVAXReserveRate();\n\n\t\tuint256 totalAssets_ = totalAssets();\n\n\t\tuint256 reservedAssets = totalAssets_.mulDivDown(targetCollateralRate, 1 ether);\n\t\treturn totalAssets_ - reservedAssets - stakingTotalAssets;\n\t}\n\n\tfunction depositFromStaking(uint256 baseAmt, uint256 rewardAmt) public payable onlySpecificRegisteredContract(\"MinipoolManager\", msg.sender) {\n\t\tuint256 totalAmt = msg.value;\n\t\tif (totalAmt != (baseAmt + rewardAmt) || baseAmt > stakingTotalAssets) {\n\t\t\trevert InvalidStakingDeposit();\n\t\t}\n\n\t\temit DepositedFromStaking(msg.sender, baseAmt, rewardAmt);\n\t\tstakingTotalAssets -= baseAmt;\n\t\tIWAVAX(address(asset)).deposit{value: totalAmt}();\n\t}\n\n\tfunction withdrawForStaking(uint256 assets) public onlySpecificRegisteredContract(\"MinipoolManager\", msg.sender) {\n\t\tif (assets > amountAvailableForStaking()) {\n\t\t\trevert WithdrawAmountTooLarge();\n\t\t}\n\n\t\temit WithdrawnForStaking(msg.sender, assets);\n\n\t\tstakingTotalAssets += assets;\n\t\tIWAVAX(address(asset)).withdraw(assets);\n\t\tIWithdrawer withdrawer = IWithdrawer(msg.sender);\n\t\twithdrawer.receiveWithdrawalAVAX{value: assets}();\n\t}\n\n\tfunction depositAVAX() public payable returns (uint256 shares) {\n\t\tuint256 assets = msg.value;\n\t\t// Check for rounding error since we round down in previewDeposit.\n\t\tif ((shares = previewDeposit(assets)) == 0) {\n\t\t\trevert ZeroShares();\n\t\t}\n\n\t\temit Deposit(msg.sender, msg.sender, assets, shares);\n\n\t\tIWAVAX(address(asset)).deposit{value: assets}();\n\t\t_mint(msg.sender, shares);\n\t\tafterDeposit(assets, shares);\n\t}\n\n\tfunction withdrawAVAX(uint256 assets) public returns (uint256 shares) {\n\t\tshares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\t\tbeforeWithdraw(assets, shares);\n\t\t_burn(msg.sender, shares);\n\n\t\temit Withdraw(msg.sender, msg.sender, msg.sender, assets, shares);\n\n\t\tIWAVAX(address(asset)).withdraw(assets);\n\t\tmsg.sender.safeTransferETH(assets);\n\t}\n\n\tfunction redeemAVAX(uint256 shares) public returns (uint256 assets) {\n\t\t// Check for rounding error since we round down in previewRedeem.\n\t\tif ((assets = previewRedeem(shares)) == 0) {\n\t\t\trevert ZeroAssets();\n\t\t}\n\t\tbeforeWithdraw(assets, shares);\n\t\t_burn(msg.sender, shares);\n\n\t\temit Withdraw(msg.sender, msg.sender, msg.sender, assets, shares);\n\n\t\tIWAVAX(address(asset)).withdraw(assets);\n\t\tmsg.sender.safeTransferETH(assets);\n\t}\n\n\t/// @notice Max amount of assets owner would be able to withdraw taking into account liquidity in this contract\n\tfunction maxWithdraw(address _owner) public view override returns (uint256) {\n\t\tif (getBool(keccak256(abi.encodePacked(\"contract.paused\", \"TokenggAVAX\")))) {\n\t\t\treturn 0;\n\t\t}\n\t\tuint256 assets = convertToAssets(balanceOf[_owner]);\n\t\tuint256 avail = totalAssets() - stakingTotalAssets;\n\t\treturn assets > avail ? avail : assets;\n\t}\n\n\t/// @notice Max amount of shares owner would be able to withdraw taking into account liquidity in this contract\n\tfunction maxRedeem(address _owner) public view override returns (uint256) {\n\t\tif (getBool(keccak256(abi.encodePacked(\"contract.paused\", \"TokenggAVAX\")))) {\n\t\t\treturn 0;\n\t\t}\n\t\tuint256 shares = balanceOf[_owner];\n\t\tuint256 avail = convertToShares(totalAssets() - stakingTotalAssets);\n\t\treturn shares > avail ? avail : shares;\n\t}\n\n\tfunction previewDeposit(uint256 assets) public view override whenTokenNotPaused(assets) returns (uint256) {\n\t\treturn super.previewDeposit(assets);\n\t}\n\n\tfunction previewMint(uint256 shares) public view override whenTokenNotPaused(shares) returns (uint256) {\n\t\treturn super.previewMint(shares);\n\t}\n\n\tfunction previewWithdraw(uint256 assets) public view override whenTokenNotPaused(assets) returns (uint256) {\n\t\treturn super.previewWithdraw(assets);\n\t}\n\n\tfunction previewRedeem(uint256 shares) public view override whenTokenNotPaused(shares) returns (uint256) {\n\t\treturn super.previewRedeem(shares);\n\t}\n\n\tfunction beforeWithdraw(\n\t\tuint256 amount,\n\t\tuint256 /* shares */\n\t) internal override {\n\t\ttotalReleasedAssets -= amount;\n\t}\n\n\tfunction afterDeposit(\n\t\tuint256 amount,\n\t\tuint256 /* shares */\n\t) internal override {\n\t\ttotalReleasedAssets += amount;\n\t}\n\n\tfunction _authorizeUpgrade(address newImplementation) internal override onlyGuardian {}\n}"
    }
  ]
}