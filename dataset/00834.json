{
  "Title": "H-3: Incorrect StablePool BPT price calculation",
  "Content": "# Issue H-3: Incorrect StablePool BPT price calculation \n\nSource: https://github.com/sherlock-audit/2023-11-olympus-judging/issues/176 \n\n## Found by \nBauer, ast3ros, ge6a, hash, jasonxiale, tvdung94\n## Summary\nIncorrect StablePool BPT price calculation as rate's are not considered \n\n## Vulnerability Detail\nThe price of a stable pool BPT is computed as:\n\n> minimum price among the pool tokens obtained via feeds * return value of `getRate()`\n \nThis method is used referring to an old documentation of Balancer \n\n```solidity\n    function getStablePoolTokenPrice(\n        address,\n        uint8 outputDecimals_,\n        bytes calldata params_\n    ) external view returns (uint256) {\n        // Prevent overflow\n        if (outputDecimals_ > BASE_10_MAX_EXPONENT)\n            revert Balancer_OutputDecimalsOutOfBounds(outputDecimals_, BASE_10_MAX_EXPONENT);\n\n\n        address[] memory tokens;\n        uint256 poolRate; // pool decimals\n        uint8 poolDecimals;\n        bytes32 poolId;\n        {\n\n        ......\n\n            // Get tokens in the pool from vault\n            (address[] memory tokens_, , ) = balVault.getPoolTokens(poolId);\n            tokens = tokens_;\n\n            // Get rate\n            try pool.getRate() returns (uint256 rate_) {\n                if (rate_ == 0) {\n                    revert Balancer_PoolStableRateInvalid(poolId, 0);\n                }\n\n\n                poolRate = rate_;\n\n        ......\n\n        uint256 minimumPrice; // outputDecimals_\n        {\n            /**\n             * The Balancer docs do not currently state this, but a historical version noted\n             * that getRate() should be multiplied by the minimum price of the tokens in the\n             * pool in order to get a valuation. This is the same approach as used by Curve stable pools.\n             */\n            for (uint256 i; i < len; i++) {\n                address token = tokens[i];\n                if (token == address(0)) revert Balancer_PoolTokenInvalid(poolId, i, token);\n\n                (uint256 price_, ) = _PRICE().getPrice(token, PRICEv2.Variant.CURRENT); // outputDecimals_\n\n\n                if (minimumPrice == 0) {\n                    minimumPrice = price_;\n                } else if (price_ < minimumPrice) {\n                    minimumPrice = price_;\n                }\n            }\n        }\n\n        uint256 poolValue = poolRate.mulDiv(minimumPrice, 10 ** poolDecimals); // outputDecimals_\n```\n\nThe `getRate()` function returns the exchange rate of a BPT to the underlying base asset of the pool which can be different from the minimum market priced asset for pools with rateProviders. To consider this, the price obtained from feeds must be divided by the `rate` provided by `rateProviders` before choosing the minimum as mentioned in the previous version of Balancer's documentation.   \n\nhttps://github.com/balancer/docs/blob/663e2f4f2c3eee6f85805e102434629633af92a2/docs/concepts/advanced/valuing-bpt/bpt-as-collateral.md#metastablepools-eg-wsteth-weth \n\n\n#### 1. Get market price for each constituent token\n\nGet market price of wstETH and WETH in terms of USD, using chainlink oracles.\n\n#### 2. Get RateProvider price for each constituent token\n\nSince wstETH - WETH pool is a MetaStablePool and not a ComposableStablePool, it does not have `getTokenRate()` function.\nTherefore, it`s needed to get the RateProvider price manually for wstETH, using the rate providers of the pool. The rate \nprovider will return the wstETH token in terms of stETH.\n\nNote that WETH does not have a rate provider for this pool. In that case, assume a value of `1e18` (it means,\nmarket price of WETH won't be divided by any value, and it's used purely in the minPrice formula).\n\n#### 3. Get minimum price\n\n$$ minPrice = min({P_{M_{wstETH}} \\over P_{RP_{wstETH}}}, P_{M_{WETH}}) $$\n\n#### 4. Calculates the BPT price\n\n$$ P_{BPT_{wstETH-WETH}} = minPrice * rate_{pool_{wstETH-WETH}} $$\n\nwhere `rate_pool_wstETH-WETH` is `pool.getRate()` of wstETH-WETH pool.\n\n### Example\n\nThe wstEth-cbEth pool is a MetaStablePool having rate providers for both tokens since neither of them is the base token\nhttps://app.balancer.fi/#/ethereum/pool/0x9c6d47ff73e0f5e51be5fd53236e3f595c5793f200020000000000000000042c\n\nAt block 18821323:\ncbeth : 2317.48812\nwstEth : 2526.84\npool total supply : 0.273259897168240633\ngetRate() : 1.022627523581711856\nwstRateprovider rate : 1.150725009180224306\ncbEthRateProvider rate : 1.058783029570983377\nwstEth balance : 0.133842314907166538\ncbeth balance : 0.119822100236557012\ntvl : (0.133842314907166538 * 2526.84 + 0.119822100236557012 * 2317.48812) == 615.884408812\n\naccording to current implementation:\nbpt price = 2317.48812 * 1.022627523581711856 == 2369.927137086\ncalculated tvl = bpt price * total supply = 647.606045776\n\ncorrect calculation:\nrate_provided_adjusted_cbeth = (2317.48812 / 1.058783029570983377) == 2188.822502132\nrate_provided_adjusted_wsteth = (2526.84 / 1.150725009180224306) == 2195.867804942\nbpt price = 2188.822502132 * 1.022627523581711856 == 2238.350134915\ncalculated tvl = bpt price * total supply = (2238.350134915 * 0.273259897168240633) == 611.651327693\n\n## Impact\nIncorrect calculation of bpt price. Has possibility to be over and under valued.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-11-olympus/blob/main/bophades/src/modules/PRICE/submodules/feeds/BalancerPoolTokenPrice.sol#L514-L539\n\n## Tool used\nManual Review\n\n## Recommendation\nFor pools having rate providers, divide prices by rate before choosing the minimum\n\n\n\n## Discussion\n\n**0xJem**\n\nThis is a valid issue and highlights problems with Balancer's documentation.\n\nWe are likely to drop both the Balancer submodules from the final version, since we no longer have any Balancer pools used for POL and don't have any assets that require price resolution via Balancer pools.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> This is invalid. Never meant to interact with composable stable pools as shown by this comment here where they explicitly state it will revert if it is a composable stable pool:\n> \n> https://github.com/sherlock-audit/2023-11-olympus/blob/9c8df76dc9820b4c6605d2e1e6d87dcfa9e50070/bophades/src/modules/PRICE/submodules/feeds/BalancerPoolTokenPrice.sol#L441-L444\n\n    You've deleted an escalation for this issue.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/128",
  "Code": [
    {
      "filename": "docs/concepts/advanced/valuing-bpt/bpt-as-collateral.md",
      "content": "# `StablePool` BPT as Collateral\n\nThroughout this document, the term \"`StablePools` with `RateProviders`\" is used. This refers to any Balancer V2 \npool employing the `StableMath` library and allowing for the inclusion of `RateProviders` for some or all \nconstituent tokens. Several pool factories deploy pools which employ `StableMath`, such as `MetaStablePool`, \n`StablePhantomPool`, and `ComposableStablePool`.\n\n## Pricing `StablePool` BPT (without `RateProviders`)\n\n[Chainlink's article on pricing Curve LP tokens](https://blog.chain.link/using-chainlink-oracles-to-securely-utilize-curve-lp-pools/) \nserves as the canonical reference. The article describes a methodology for computing the worst-case price of \ntraditional `StableSwap` liquidity positions, which can be useful specifically for lending markets. The approach \nhas been utilized by countless Curve integrators, including Aave, Maker, and Yearn.\n\n### Curve\n\nCurve's methodology is as follows (consider a classical Curve 3pool):\n\n1. Query Chainlink prices for `DAI`, `USDC`, and `USDT`.\n2. Compute the minimum of those three prices and call it `minPrice`.\n3. The final answer is `minPrice * pool.get_virtual_price()`.\n\nCurve's `get_virtual_price()` is perfectly analogous to Balancer's `getRate()`: it returns the price of the pool \nin terms of its \"base asset\", which in the case of the 3pool is some imaginary version of \"USD\". In other words, \n`get_virtual_price()` accounts for the accumulation of yield since the creation of the pool, and **assuming all \nthree underlying price pegs are good**, it can be considered a valid USD price of the 3pool LP token.\n\nIn case of a depeg, step #2 above ensures that we underprice (at worst) the LP token so as not to make any poor \nprice assumptions to the upside and leave lending markets at risk of accumulating bad debt. It is better to \nunderestimate and over-liquidate than it is to do the opposite, and in fact the minimum price should be \nrepresentative of the pool's entire balance as long as the amplification factor is sufficiently high.\n\n### Balancer\n\nTo translate this methodology for any Balancer `StablePool` (from the original `StablePoolFactory`, \nwhich does not include `RateProviders`):\n\n1. Query Chainlink prices for all constituent tokens (i.e., `vault.getPoolTokens(poolId)`).\n2. Compute the minimum of those prices and call it `minPrice`.\n3. Return `minPrice * pool.getRate()`.\n\n## Problem: Introducing `RateProviders`\n\nThe introduction of `RateProviders` into the `StablePool` creates an obvious issue. Consider the computation of the \nminimum price (we use $P_i$ to denote the price of constituent $i$):\n\n$$ minPrice = min({P_0}, {P_1}, {P_2}) $$\n\nIf the constituent tokens have `RateProviders`, then by definition they cannot be **like-kind assets**. \nTheoretically, they are all somehow pegged to the same \"base asset\", or else they wouldn't be included in \na `StablePool`, but the nature of each peg can now differ. One token might be worth $1 while another is worth \n$1.50 and the third $100. If that's the case, then the minimum formula is not applicable and in fact returns a \nvery wrong result.\n\nThere's a reason to use the term \"constituent\" instead of \"underlying\":\n\n* \"constituent\" assets are the exact tokens included in the pool;\n* \"underlying\" assets are the innermost constituents of nested derivatives (pools or wrapped tokens). \n\nExample: in `bb-a-USD`, the constituents are three `LinearPool` BPTs: `bb-a-DAI`, `bb-a-USDC`, and `bb-a-USDT`. But the \nunderlying tokens are `DAI`, `USDC`, and `USDT`.\n\n## The Solution\n\nThe mathematical demonstration of the solution is found at the [Appendix](#appendix).\n\nThe constituent tokens have two different valuations: the market price (Chainlink oracles) and the pool price\n(from a `RateProvider`). The market price and the `RateProvider` price are usually close in value, so a division between these\nnumbers tends to be close to 1, making the division a good candidate to normalize prices and find the minimum\nprice. So, the `minPrice` (from the `minPrice * pool.getRate()` formula described above) would be calculated using\n\n$$ minPrice = min({P_{M_0} \\over P_{RP_0}}, {P_{M_1} \\over P_{RP_1}}, {P_{M_2} \\over P_{RP_2}}, ...) $$\n\nwhere\n* $P_{M_i}$ is market price of constituent `i`;\n* $P_{RP_i}$ is the `RateProvider` price for constituent `i`. When no `RateProvider` is available, use `1e18`.\n\nTherefore, the BPT price can be calculated using\n\n$$ bptPrice = minPrice * pool.getRate() $$\n\n### How to choose the right market price oracle?\n\nSince `pool.getRate()` will be divided by `RateProvider` price, the resulting number has no unit. Therefore, any token\ncan be used as base of a market price oracle (ETH, USD, etc.), as long as the same token is used as base for all oracles \nof all pool tokens.\n\n## Examples\n\n### `ComposableStablePools` with `LinearPool` BPTs (e.g. `bb-a-USD`)\n\n#### 1. Get the market price of each constituent token of `bb-a-USD`.\n\nIn order to get the market price of each constituent token of `bb-a-USD` (i.e., `bb-a-USDT`, `bb-a-USDC`, `bb-a-DAI`), we should use \nthe following formula (using `USDT` as an example):\n\n$$ P_{M_{bb-a-USDT}} = P_{USDT} * rate_{pool_{aUSDT}} $$\n\nwhere\n* $P_{USDT}$ is the Chainlink oracle price for `USDT` (in terms of USD);\n* $rate_{pool_{aUSDT}}$ is `pool.getRate()` from the `bb-a-USDT` pool;\n\n#### 2. Get the `RateProvider` price of each constituent token.\n\nIn order to get the `RateProvider` price of each constituent token of `bb-a-USD`, we should use the `getTokenRate()` function of the\n`bb-a-USD` pool for each token address (`bb-a-USDT`, `bb-a-USDC` and `bb-a-DAI`).\n\n$$ P_{RP_{bb-a-TOKEN}} = tokenRate_{bb-a-TOKEN} $$\n\nIn this case, $tokenRate_{bb-a-TOKEN}$ is equal to `pool.getRate()` from the given pool (e.g., `bb-a-USDT`, `bb-a-USDC`, `bb-a-DAI`).\n\nIt may seem redundant to multiply by `pool.getRate()` to get the market price, then divide by `pool.getRate()` again.\nRemember that this is a generic method to calculate BPT prices that works for tokens of different types, as will be \ndemonstrated in the next examples.\n\n#### 3. Get the minimum price.\n\n$$ minPrice = min({P_{M_{bb-a-USDT}} \\over P_{RP_{bb-a-USDT}}}, {P_{M_{bb-a-USDC}} \\over P_{RP_{bb-a-USDC}}}, {P_{M_{bb-a-DAI}} \\over P_{RP_{bb-a-DAI}}}) $$\n\nSince $tokenRate_{bb-a-TOKEN}$ is equal to `pool.getRate()` from the `bb-a-TOKEN` pool, the division \n${P_{M_{bb-a-TOKEN}} \\over P_{RP_{bb-a-TOKEN}}}$ can be simplified:\n\n$$ {P_{M_{bb-a-TOKEN}} \\over P_{RP_{bb-a-TOKEN}}} = {P_{TOKEN} * rate_{pool_{aTOKEN}} \\over rate_{pool_{aTOKEN}}} = P_{TOKEN}$$\n\nTherefore, minPrice is calculated as\n\n$$ minPrice = min(P_{USDT}, P_{USDC}, P_{DAI}) $$\n\nRemember, the `RateProvider` price will not always be included in the market price. This simplification is valid only for\nLinear Pool tokens.\n\n#### 4. Calculate the BPT price.\n\n$$ P_{BPT_{bb-a-USD}} = minPrice * rate_{pool_{bb-a-USD}} $$\n\nwhere $rate_{pool_{bb-a-USD}}$ is `pool.getRate()` from the `bb-a-USD` pool.\n\n### MetaStablePools (e.g. wstETH-WETH)\n\n#### 1. Get market price for each constituent token\n\nGet market price of wstETH and WETH in terms of USD, using chainlink oracles.\n\n#### 2. Get RateProvider price for each constituent token\n\nSince wstETH - WETH pool is a MetaStablePool and not a ComposableStablePool, it does not have `getTokenRate()` function.\nTherefore, it`s needed to get the RateProvider price manually for wstETH, using the rate providers of the pool. The rate \nprovider will return the wstETH token in terms of stETH.\n\nNote that WETH does not have a rate provider for this pool. In that case, assume a value of `1e18` (it means,\nmarket price of WETH won't be divided by any value, and it's used purely in the minPrice formula).\n\n#### 3. Get minimum price\n\n$$ minPrice = min({P_{M_{wstETH}} \\over P_{RP_{wstETH}}}, P_{M_{WETH}}) $$\n\n#### 4. Calculates the BPT price\n\n$$ P_{BPT_{wstETH-WETH}} = minPrice * rate_{pool_{wstETH-WETH}} $$\n\nwhere `rate_pool_wstETH-WETH` is `pool.getRate()` of wstETH-WETH pool.\n\n### ComposableStablePools (stMATIC-wMATIC)\n\nstMATIC is a special case, since `stMATIC` accrues value and doesn't rebase, so it's not 1:1 with WMATIC. Therefore,\nit cannot be reduced to anoter underlying token.\n\nHowever, the generalized formula from the solution above also works for this.\n\n#### 1. Get market price for each constituent token\n\nGet market price of stMATIC and wMATIC in terms of USD, using chainlink oracles.\n\n#### 2. Get RateProvider price for each constituent token\n\nSince stMATIC-wMATIC pool is a ComposableStablePool, it has `getTokenRate()` function, which make it easier to fetch\nRateProvider rates for each token. Notice that wMATIC rate is 1e18, even if the rate provider is not set for this token.\n\n#### 3. Get minimum price\n\n$$ minPrice = min({P_{M_{stMATIC}} \\over P_{RP_{stMATIC}}}, {P_{M_{wMATIC}} \\over P_{RP_{wMATIC}}}) $$\n\n#### 4. Calculates the BPT price\n\n$$ P_{BPT_{stMATIC-wMATIC}} = minPrice * rate_{pool_{stMATIC-wMATIC}} $$\n\nwhere `rate_pool_stMATIC-wMATIC` is `pool.getRate()` of stMATIC-wMATIC pool.\n\n## Appendix\n\n### Proof of the solution\n\n**How do we choose the token with the minimum price, if the prices are not expected to be 1:1?**\n\nAnswering the question above is the key to calculate the BPT price for a `StablePool` with `RateProviders`.\nConsider the basic formula of a `StablePool` invariant near equilibrium:\n\n$$ k = chi * (\\sum_{i=0}^{n} P_{RP_i} * B_i) + (\\prod_{i=0}^{n} P_{RP_i} * B_i)$$\n\nwhere\n* $P_{RP_i}$ is the price from the `RateProvider` of token `i`;\n* $B_i$ is the balance of token `i`;\n* $chi$ is a function of the amplification factor of the `StablePool`. The closer to the equilibrium,\n  the greater is $chi$;\n* $n$ is the total number of tokens in the pool.\n\nWhen the `StablePool` is near equilibrium, the $chi$ parameter is near infinite, so the invariant will be approximately\nthe constant sum invariant.\n\n$$ invariant = \\sum_{i=0}^{n} P_{RP_i} * B_i $$\n\nThe invariant is used to calculate `pool.getRate()`, which is `uint256 rate = invariant/actualBptSupply`. So, in order \nto multiply `minPrice * pool.getRate()`, the `RateProvider` prices of the invariant must be normalized. Accomplishing\nthat requires an understanding of the price components of an underlying token.\n\n### Constituent Token Prices\n\nThe constituent tokens have two different valuations: the market price (Chainlink oracles) and the pool price\n(`RateProvider`). The market price and the `RateProvider` price are usually close in value, so a division between these\nnumbers tends to be close to 1, making the division a good candidate to normalize prices and find the minimum\nprice. So, the `minPrice` would be calculated using\n\n$$ minPrice = min({P_{M_0} \\over P_{RP_0}}, {P_{M_1} \\over P_{RP_1}}, ..., {P_{M_n} \\over P_{RP_n}}) $$\n\nwhere\n* $P_{M_i}$ is market price of constituent `i`;\n* $P_{RP_i}$ is the `RateProvider` price for constituent `i`. When no `RateProvider` is available, use `1e18`;\n* $n$ is the total number of tokens in the pool.\n\nThe following calculation for BPT price is achieved using this `minPrice` and multiplying by `pool.getRate()`, \nassuming that the `StablePool` is near equilibrium and `token 0` is the token with the minimum price:\n\n$$ bptPrice = minPrice * pool.getRate() = {P_{M_0} \\over P_{RP_0}} * {\\sum_{i=0}^{n} P_{RP_i} * B_i \\over actualBptSupply} $$\n\nSimplifying the formula above produces:\n\n$$ bptPrice = P_{M_0} * {(B_0 + \\sum_{i=1}^{n} {P_{RP_i} \\over P_{RP_0}} * B_i) \\over actualBptSupply} $$\n\nNote that `RateProvider` prices were normalized by $P_{RP_0}$, for all tokens, before multiplying by $P_{M_0}$\n(market price of token 0)."
    },
    {
      "filename": "bophades/src/modules/PRICE/submodules/feeds/BalancerPoolTokenPrice.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport \"modules/PRICE/PRICE.v2.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {FullMath} from \"src/libraries/FullMath.sol\";\nimport {StableMath} from \"src/libraries/Balancer/math/StableMath.sol\";\nimport {IVault} from \"src/libraries/Balancer/interfaces/IVault.sol\";\nimport {IBasePool} from \"src/libraries/Balancer/interfaces/IBasePool.sol\";\nimport {IWeightedPool} from \"src/libraries/Balancer/interfaces/IWeightedPool.sol\";\nimport {IStablePool} from \"src/libraries/Balancer/interfaces/IStablePool.sol\";\nimport {VaultReentrancyLib} from \"src/libraries/Balancer/contracts/VaultReentrancyLib.sol\";\nimport {LogExpMath} from \"src/libraries/Balancer/math/LogExpMath.sol\";\nimport {FixedPoint} from \"src/libraries/Balancer/math/FixedPoint.sol\";\n\n/// @title      BalancerPoolTokenPrice\n/// @author     0xJem\n/// @notice     Provides prices related to Balancer pools\ncontract BalancerPoolTokenPrice is PriceSubmodule {\n    using FullMath for uint256;\n\n    /// @notice     Any token or pool with a decimal scale greater than this would result in an overflow\n    uint8 internal constant BASE_10_MAX_EXPONENT = 50;\n\n    /// @notice     Used when calculating the value of a token in a weighted pool\n    uint8 internal constant WEIGHTED_POOL_POW_DECIMALS = 18;\n\n    /// @notice             Parameters for a Balancer weighted pool\n    ///\n    /// @param pool         Address of the Balancer pool\n    struct BalancerWeightedPoolParams {\n        IWeightedPool pool;\n    }\n\n    /// @notice             Parameters for a Balancer stable pool\n    ///\n    /// @param pool         Address of the Balancer pool\n    struct BalancerStablePoolParams {\n        IStablePool pool;\n    }\n\n    /// @notice             Struct to cache data related to a Balancer weighted pool\n    /// @dev                This is not persisted between calls, and is only used to reduce the number of parameters\n    struct BalancerWeightedPoolCache {\n        address[] tokens;\n        uint256[] weights;\n        uint256[] balances;\n        uint8 decimals;\n        bytes32 poolId;\n    }\n\n    // ========== ERRORS ========== //\n\n    /// @notice             The number of decimals of the asset is greater than the maximum allowed\n    ///\n    /// @param asset_       The address of the asset\n    /// @param decimals_    The number of decimals of the asset\n    /// @param maxDecimals_ The maximum number of decimals allowed\n    error Balancer_AssetDecimalsOutOfBounds(address asset_, uint8 decimals_, uint8 maxDecimals_);\n\n    /// @notice             The provided token was not found in the Balancer pool\n    ///\n    /// @param poolId_      The id of the Balancer pool\n    /// @param asset_       The address of the token\n    error Balancer_LookupTokenNotFound(bytes32 poolId_, address asset_);\n\n    /// @notice                 The desired number of output decimals is greater than the maximum allowed\n    ///\n    /// @param outputDecimals_  The desired number of output decimals\n    /// @param maxDecimals_     The maximum number of decimals allowed\n    error Balancer_OutputDecimalsOutOfBounds(uint8 outputDecimals_, uint8 maxDecimals_);\n\n    /// @notice                 The number of decimals of the pool is greater than the maximum allowed\n    ///\n    /// @param poolId_          The id of the Balancer pool\n    /// @param poolDecimals_    The number of decimals of the pool\n    /// @param maxDecimals_     The maximum number of decimals allowed\n    error Balancer_PoolDecimalsOutOfBounds(\n        bytes32 poolId_,\n        uint8 poolDecimals_,\n        uint8 maxDecimals_\n    );\n\n    /// @notice             The stable rate returned by the pool is invalid\n    /// @dev                This currently only occurs if the rate is 0\n    ///\n    /// @param poolId_      The id of the Balancer pool\n    /// @param rate_        The stable rate returned by the pool\n    error Balancer_PoolStableRateInvalid(bytes32 poolId_, uint256 rate_);\n\n    /// @notice             The total supply returned by the pool is invalid\n    /// @dev                This currently only occurs if the total supply is 0\n    ///\n    /// @param poolId_      The id of the Balancer pool\n    /// @param supply_      The total supply returned by the pool\n    error Balancer_PoolSupplyInvalid(bytes32 poolId_, uint256 supply_);\n\n    /// @notice             A token in the pool is invalid\n    /// @dev                This currently only occurs if the token address is 0\n    ///\n    /// @param poolId_      The id of the Balancer pool\n    /// @param index_       The index of the token in the pool\n    /// @param token_       The address of the token\n    error Balancer_PoolTokenInvalid(bytes32 poolId_, uint256 index_, address token_);\n\n    /// @notice             The value of the Balancer pool is zero\n    /// @dev                This currently only occurs if the number of tokens is 0\n    ///\n    /// @param poolId_      The id of the Balancer pool\n    error Balancer_PoolValueZero(bytes32 poolId_);\n\n    /// @notice             There is a mismatch between the number of tokens and weights\n    /// @dev                This is unlikely to occur, but is in place to be defensive\n    ///\n    /// @param poolId_      The id of the Balancer pool\n    /// @param tokenCount_  The number of tokens in the Balancer pool\n    /// @param weightCount_ The number of weights in the Balancer pool\n    error Balancer_PoolTokenWeightMismatch(\n        bytes32 poolId_,\n        uint256 tokenCount_,\n        uint256 weightCount_\n    );\n\n    /// @notice                 There is a mismatch between the number of tokens and balances\n    /// @dev                    This is unlikely to occur, but is in place to be defensive\n    ///\n    /// @param poolId_          The id of the Balancer pool\n    /// @param tokenCount_      The number of tokens in the Balancer pool\n    /// @param balanceCount_    The number of balances in the Balancer pool\n    error Balancer_PoolTokenBalanceMismatch(\n        bytes32 poolId_,\n        uint256 tokenCount_,\n        uint256 balanceCount_\n    );\n\n    /// @notice                 There is a mismatch between the number of tokens, balances and weights\n    /// @dev                    This is unlikely to occur, but is in place to be defensive\n    ///\n    /// @param poolId_          The id of the Balancer pool\n    /// @param tokenCount_      The number of tokens in the Balancer pool\n    /// @param balanceCount_    The number of balances in the Balancer pool\n    /// @param weightCount_     The number of weights in the Balancer pool\n    error Balancer_PoolTokenBalanceWeightMismatch(\n        bytes32 poolId_,\n        uint256 tokenCount_,\n        uint256 balanceCount_,\n        uint256 weightCount_\n    );\n\n    /// @notice             The pool is not a stable pool\n    ///\n    /// @param poolId_      The id of the Balancer pool\n    error Balancer_PoolTypeNotStable(bytes32 poolId_);\n\n    /// @notice             The pool is not a weighted pool\n    ///\n    /// @param poolId_      The id of the Balancer pool\n    error Balancer_PoolTypeNotWeighted(bytes32 poolId_);\n\n    /// @notice             A weight in the pool is invalid\n    /// @dev                This currently only occurs if the weight is 0\n    ///\n    /// @param poolId_      The id of the Balancer pool\n    /// @param index_       The index of the weight in the pool\n    /// @param weight_      The value of the weight\n    error Balancer_PoolWeightInvalid(bytes32 poolId_, uint256 index_, uint256 weight_);\n\n    /// @notice             The price of a corresponding token could not be found\n    /// @dev                This occurs if there are no asset definitions in PRICE\n    /// @dev                for the other tokens in the Balancer pool, and hence\n    /// @dev                the price of the lookup token cannot be determined\n    ///\n    /// @param poolId_      The id of the Balancer pool\n    /// @param lookupToken_ The token to determine the price of\n    error Balancer_PriceNotFound(bytes32 poolId_, address lookupToken_);\n\n    // ========== STATE VARIABLES ========== //\n\n    /// @notice     Address of the Balancer vault\n    IVault public immutable balVault;\n\n    // ========== CONSTRUCTOR ========== //\n\n    constructor(Module parent_, IVault balVault_) Submodule(parent_) {\n        balVault = balVault_;\n    }\n\n    // ========== SUBMODULE FUNCTIONS =========== //\n\n    /// @inheritdoc Submodule\n    function SUBKEYCODE() public pure override returns (SubKeycode) {\n        return toSubKeycode(\"PRICE.BPT\");\n    }\n\n    /// @inheritdoc Submodule\n    function VERSION() public pure override returns (uint8 major, uint8 minor) {\n        major = 1;\n        minor = 0;\n    }\n\n    // ========== HELPER FUNCTIONS ========== //\n\n    /// @notice                     Converts `value_` from the ERC20 token's decimals to `outputDecimals_`\n    /// @dev                        This function will revert if:\n    /// @dev                        - Converting the token's decimals would result in an overflow.\n    ///\n    /// @param value_               Value in native ERC20 token decimals\n    /// @param token_               The address of the ERC20 token\n    /// @param outputDecimals_      The desired number of decimals\n    /// @return                     Number in the scale of `outputDecimals_`\n    function _convertERC20Decimals(\n        uint256 value_,\n        address token_,\n        uint8 outputDecimals_\n    ) internal view returns (uint256) {\n        uint8 tokenDecimals = ERC20(token_).decimals();\n        if (tokenDecimals > BASE_10_MAX_EXPONENT)\n            revert Balancer_AssetDecimalsOutOfBounds(token_, tokenDecimals, BASE_10_MAX_EXPONENT);\n\n        return value_.mulDiv(10 ** outputDecimals_, 10 ** tokenDecimals);\n    }\n\n    /// @notice                     Obtains the balance/weight ratio of the token at index `index_` in the pool\n    /// @dev                        This function will revert if:\n    /// @dev                        - Converting the pool's decimals would result in an overflow.\n    ///\n    /// @dev                        As this function is accessing the balances of the pool, ensure that VaultReentrancyLib\n    /// @dev                        is called in order to prevent re-entrancy attacks.\n    ///\n    /// @param cache                Cached data related to the Balancer weighted pool\n    /// @param index_               Index of the token in the Balancer pool\n    /// @param outputDecimals_      The desired number of decimals\n    /// @return                     Balance in the scale of `outputDecimals_`\n    function _getTokenBalanceWeighting(\n        BalancerWeightedPoolCache memory cache,\n        uint256 index_,\n        uint8 outputDecimals_\n    ) internal view returns (uint256) {\n        uint256 tokenBalance = _convertERC20Decimals(\n            cache.balances[index_],\n            cache.tokens[index_],\n            outputDecimals_\n        );\n\n        uint256 tokenWeight = cache.weights[index_].mulDiv(\n            10 ** outputDecimals_,\n            10 ** cache.decimals\n        );\n\n        return tokenBalance.mulDiv(10 ** outputDecimals_, tokenWeight);\n    }\n\n    /// @notice                     Calculates the value of a token in a Balancer weighted pool\n    /// @dev                        This function will revert if:\n    /// @dev                        - The provided token is address(0)\n    /// @dev                        - The provided weight is 0\n    ///\n    /// @param token_               Address of the token\n    /// @param weight_              Weight of the token in the Balancer pool\n    /// @param poolDecimals_        The number of decimals of the Balancer pool\n    /// @param outputDecimals_      The desired number of decimals\n    /// @param poolId_              id of the Balancer pool\n    /// @param index_               Index of the token in the Balancer pool\n    /// @return                     Value in the scale of `outputDecimals_`\n    function _getTokenValueInWeightedPool(\n        address token_,\n        uint256 weight_,\n        uint8 poolDecimals_,\n        uint8 outputDecimals_,\n        bytes32 poolId_,\n        uint256 index_\n    ) internal view returns (uint256) {\n        if (token_ == address(0)) revert Balancer_PoolTokenInvalid(poolId_, index_, token_);\n        if (weight_ == 0) revert Balancer_PoolWeightInvalid(poolId_, index_, weight_);\n\n        uint256 price; // Scale: `WEIGHTED_POOL_POW_DECIMALS`\n        {\n            /**\n             * PRICE will revert if there is an issue resolving the price, or if it is 0.\n             *\n             * As the value of the pool token is reliant on the price of every underlying token,\n             * the revert from PRICE is not caught.\n             */\n            (uint256 price_, ) = _PRICE().getPrice(token_, PRICEv2.Variant.CURRENT); // Scale: `outputDecimals_`\n\n            price = price_.mulDiv(10 ** WEIGHTED_POOL_POW_DECIMALS, 10 ** outputDecimals_);\n        }\n\n        // Scale: `WEIGHTED_POOL_POW_DECIMALS`\n        uint256 weight = weight_.mulDiv(10 ** WEIGHTED_POOL_POW_DECIMALS, 10 ** poolDecimals_);\n\n        // All inputs to pow need to be in the scale of WEIGHTED_POOL_POW_DECIMALS, so adjust for that\n        uint256 value = LogExpMath.pow(\n            price.mulDiv(10 ** WEIGHTED_POOL_POW_DECIMALS, weight),\n            weight\n        ); // Scale: `WEIGHTED_POOL_POW_DECIMALS`\n\n        // Adjust for `outputDecimals_`\n        return value.mulDiv(10 ** outputDecimals_, 10 ** WEIGHTED_POOL_POW_DECIMALS);\n    }\n\n    /// @notice                     Calculates the value of a Balancer weighted pool\n    /// @dev                        This function calculates the value of each token and returns the sum.\n    ///\n    /// @param tokens_              Array of tokens in the Balancer pool\n    /// @param weights_             Array of weights of the tokens in the Balancer pool\n    /// @param poolDecimals_        The number of decimals of the Balancer pool\n    /// @param outputDecimals_      The desired number of decimals\n    /// @return                     Value in the scale of `outputDecimals_`\n    function _getWeightedPoolRawValue(\n        address[] memory tokens_,\n        uint256[] memory weights_,\n        uint8 poolDecimals_,\n        uint8 outputDecimals_,\n        bytes32 poolId_\n    ) internal view returns (uint256) {\n        uint256 len = tokens_.length;\n\n        uint256 poolValue = 0; // Scale: `outputDecimals_`\n        for (uint256 i; i < len; ) {\n            uint256 currentValue = _getTokenValueInWeightedPool(\n                tokens_[i],\n                weights_[i],\n                poolDecimals_,\n                outputDecimals_,\n                poolId_,\n                i\n            );\n\n            if (poolValue == 0) {\n                poolValue = currentValue;\n            } else {\n                poolValue = poolValue.mulDiv(currentValue, 10 ** outputDecimals_);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return poolValue;\n    }\n\n    // ========== POOL TOKEN PRICE FUNCTIONS ========== //\n\n    /// @notice                 Determines the unit price of the pool token for the Balancer weighted pool specified in `params_`.\n    /// @dev                    To avoid price manipulation, this function calculated the pool token price in the manner recommended by\n    /// @dev                    Balancer at https://docs.balancer.fi/concepts/advanced/valuing-bpt/valuing-bpt.html#on-chain-price-evaluation :\n    /// @dev                    - Obtains the prices of all tokens in the pool from PRICE (usually using price feeds)\n    /// @dev                    - Applies a guard to protect against re-entrancy attacks on the Balancer pool\n    ///\n    /// @dev                    This function will revert if:\n    /// @dev                    - The scale of `outputDecimals_` or the pool's decimals is too high\n    /// @dev                    - The pool is mis-configured\n    /// @dev                    - If the pool is not a weighted pool\n    ///\n    /// @param outputDecimals_  The number of output decimals\n    /// @param params_          Balancer pool parameters of type `BalancerWeightedPoolParams`\n    /// @return                 Price in the scale of `outputDecimals_`\n    function getWeightedPoolTokenPrice(\n        address,\n        uint8 outputDecimals_,\n        bytes calldata params_\n    ) external view returns (uint256) {\n        // Prevent overflow\n        if (outputDecimals_ > BASE_10_MAX_EXPONENT)\n            revert Balancer_OutputDecimalsOutOfBounds(outputDecimals_, BASE_10_MAX_EXPONENT);\n\n        address[] memory tokens;\n        uint256[] memory weights;\n        uint256 poolMultiplier; // outputDecimals_\n        uint8 poolDecimals;\n        bytes32 poolId;\n        {\n            // Decode params\n            BalancerWeightedPoolParams memory params = abi.decode(\n                params_,\n                (BalancerWeightedPoolParams)\n            );\n            if (address(params.pool) == address(0)) revert Balancer_PoolTypeNotWeighted(bytes32(0));\n\n            IWeightedPool pool = IWeightedPool(params.pool);\n\n            // Get pool ID\n            poolId = pool.getPoolId();\n\n            // Prevent re-entrancy attacks\n            VaultReentrancyLib.ensureNotInVaultContext(balVault);\n\n            // Get tokens in the pool from vault\n            (address[] memory tokens_, , ) = balVault.getPoolTokens(poolId);\n            tokens = tokens_;\n\n            // Get weights\n            try pool.getNormalizedWeights() returns (uint256[] memory weights_) {\n                weights = weights_;\n            } catch {\n                // Exit if it is not a weighted pool\n                revert Balancer_PoolTypeNotWeighted(poolId);\n            }\n\n            uint256 poolSupply_ = pool.totalSupply(); // pool decimals\n            if (poolSupply_ == 0) revert Balancer_PoolSupplyInvalid(poolId, 0);\n\n            uint256 poolInvariant_ = pool.getInvariant(); // pool decimals\n\n            poolDecimals = pool.decimals();\n            if (poolDecimals > BASE_10_MAX_EXPONENT)\n                revert Balancer_PoolDecimalsOutOfBounds(poolId, poolDecimals, BASE_10_MAX_EXPONENT);\n\n            // The invariant and supply have the same scale, so we can shift the result into outputDecimals_\n            poolMultiplier = poolInvariant_.mulDiv(10 ** outputDecimals_, poolSupply_);\n        }\n\n        // Iterate through tokens, get prices, and determine pool value\n        uint256 len = tokens.length;\n        if (weights.length != len)\n            revert Balancer_PoolTokenWeightMismatch(poolId, len, weights.length);\n\n        uint256 poolValue = _getWeightedPoolRawValue(\n            tokens,\n            weights,\n            poolDecimals,\n            outputDecimals_,\n            poolId\n        );\n        // No coins or balances\n        if (poolValue == 0) revert Balancer_PoolValueZero(poolId);\n\n        // Calculate price of pool token in terms of outputDecimals_\n        uint256 poolTokenPrice = poolMultiplier.mulDiv(poolValue, 10 ** outputDecimals_);\n\n        return poolTokenPrice;\n    }\n\n    /// @notice                 Determines the unit price of the pool token for the Balancer stable pool specified in `params_`.\n    /// @dev                    To avoid price manipulation, this function calculated the pool token price in the following manner:\n    /// @dev                    - Applies a guard to protect against re-entrancy attacks on the Balancer pool\n    /// @dev                    - Utilises the formula suggested by Balancer: https://docs.balancer.fi/concepts/advanced/valuing-bpt/valuing-bpt.html#on-chain-price-evaluation\n    ///\n    /// @dev                    This function will revert if:\n    /// @dev                    - The scale of `outputDecimals_` or the pool's decimals is too high\n    /// @dev                    - The pool is mis-configured\n    /// @dev                    - If the pool is not a stable pool or is a composable stable pool (determined by the absence of the `getLastInvariant()` function)\n    ///\n    /// @dev                    NOTE: If there is a significant de-peg between the prices of constituent assets, the token price will be inaccurate. See the now-deleted mention of this: https://github.com/balancer/docs/pull/112/files\n    ///\n    /// @param outputDecimals_  The number of output decimals\n    /// @param params_          Balancer pool parameters of type `BalancerStablePoolParams`\n    /// @return                 Price in the scale of outputDecimals_\n    function getStablePoolTokenPrice(\n        address,\n        uint8 outputDecimals_,\n        bytes calldata params_\n    ) external view returns (uint256) {\n        // Prevent overflow\n        if (outputDecimals_ > BASE_10_MAX_EXPONENT)\n            revert Balancer_OutputDecimalsOutOfBounds(outputDecimals_, BASE_10_MAX_EXPONENT);\n\n        address[] memory tokens;\n        uint256 poolRate; // pool decimals\n        uint8 poolDecimals;\n        bytes32 poolId;\n        {\n            // Decode params\n            BalancerStablePoolParams memory params = abi.decode(\n                params_,\n                (BalancerStableP"
    }
  ]
}