{
  "Title": "Add condition",
  "Content": "##### Description\nFor the line: https://github.com/Gearbox-protocol/gearbox-contracts/blob/0ac33ba87212ce056ac6b6357ad74161d417158a/contracts/credit/CreditFilter.sol#L159\nin the `allowToken ()` function, the existence of the `token` - `underlyingToken` pair is checked.\nBut it is better to immediately check if the value of this pair is greater than 0:\n```\nrequire(\nIPriceOracle(priceOracle).getLastPrice(token, underlyingToken) > 0, \nErrors.CF_TOKEN_IS_NOT_ALLOWED\n);\n```\n##### Recommendation\nIt is recommended to make corrections to the source code.",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/credit/CreditFilter.sol",
      "content": "// SPDX-License-Identifier: BSL-1.1\n// Gearbox. Generalized leverage protocol that allows to take leverage and then use it across other DeFi protocols and platforms in a composable way.\n// (c) Gearbox.fi, 2021\npragma solidity ^0.7.4;\npragma abicoder v2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport {PercentageMath} from \"../libraries/math/PercentageMath.sol\";\n\nimport {ICreditManager} from \"../interfaces/ICreditManager.sol\";\nimport {ICreditAccount} from \"../interfaces/ICreditAccount.sol\";\nimport {IPriceOracle} from \"../interfaces/IPriceOracle.sol\";\nimport {ICreditFilter} from \"../interfaces/ICreditFilter.sol\";\nimport {IPoolService} from \"../interfaces/IPoolService.sol\";\n\nimport {AddressProvider} from \"../core/AddressProvider.sol\";\nimport {ACLTrait} from \"../core/ACLTrait.sol\";\nimport {Constants} from \"../libraries/helpers/Constants.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\n\nimport \"hardhat/console.sol\";\nimport \"../core/ContractsRegister.sol\";\n\n/// @title CreditFilter\n/// @notice Implements filter logic for allowed tokens & contract-adapters\n///   - Sets/Gets tokens for allowed tokens list\n///   - Sets/Gets adapters & allowed contracts\n///   - Calculates total value for credit account\n///   - Calculates threshold weighted value for credit account\n///   - Keeps enabled tokens for credit accounts\n///\n/// More: https://dev.gearbox.fi/developers/credit/credit-filter\ncontract CreditFilter is ICreditFilter, ACLTrait {\n    using PercentageMath for uint256;\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    // Address of credit Manager\n    address public creditManager;\n\n    // Allowed tokens list\n    mapping(address => bool) public _allowedTokensMap;\n\n    // Allowed tokens array\n    address[] public override allowedTokens;\n\n    // Allowed contracts list\n    mapping(address => uint256) public override liquidationThresholds;\n\n    // map token address to its mask\n    mapping(address => uint256) public tokenMasksMap;\n\n    // credit account token enables mask. each bit (in order as tokens stored in allowedTokens array) set 1 if token was enable\n    mapping(address => uint256) public override enabledTokens;\n\n    // keeps last block we use fast check. Fast check is not allowed to use more than one time in block\n    mapping(address => uint256) public fastCheckCounter;\n\n    // Allowed contracts array\n    EnumerableSet.AddressSet private allowedContractsSet;\n\n    // Allowed adapters list\n    mapping(address => bool) public allowedAdapters;\n\n    // Mapping from allowed contract to allowed adapters\n    // If contract is not allowed, contractToAdapter[contract] == address(0)\n    mapping(address => address) public override contractToAdapter;\n\n    // Price oracle - uses in evaluation credit account\n    address public override priceOracle;\n\n    // Underlying token address\n    address public override underlyingToken;\n\n    // Pooll Service address\n    address public poolService;\n\n    // Address of WETH token\n    address public wethAddress;\n\n    // Minimum chi threshold for fast check\n    uint256 public chiThreshold;\n\n    // Maxmimum allowed fast check operations between full health factor checks\n    uint256 public hfCheckInterval;\n\n    /// Checks that sender is connected credit manager\n    modifier creditManagerOnly {\n        require(msg.sender == creditManager, Errors.CF_CREDIT_MANAGERS_ONLY); // T:[CF-20]\n        _;\n    }\n\n    /// Checks that sender is adapter\n    modifier adapterOnly {\n        require(allowedAdapters[msg.sender], Errors.CF_ADAPTERS_ONLY); // T:[CF-20]\n        _;\n    }\n\n    /// Restring any operations after setup is finalised\n    modifier duringConfigOnly() {\n        require(\n            creditManager == address(0),\n            Errors.IMMUTABLE_CONFIG_CHANGES_FORBIDDEN\n        ); // T:[CF-9,13]\n        _;\n    }\n\n    constructor(address _addressProvider, address _underlyingToken)\n        ACLTrait(_addressProvider)\n    {\n        priceOracle = AddressProvider(_addressProvider).getPriceOracle(); // T:[CF-21]\n\n        wethAddress = AddressProvider(_addressProvider).getWethToken(); // T:[CF-21]\n\n        underlyingToken = _underlyingToken; // T:[CF-21]\n\n        liquidationThresholds[underlyingToken] = Constants\n        .UNDERLYING_TOKEN_LIQUIDATION_THRESHOLD; // T:[CF-21]\n\n        allowToken(\n            underlyingToken,\n            Constants.UNDERLYING_TOKEN_LIQUIDATION_THRESHOLD\n        ); // T:[CF-8, 21]\n\n        setFastCheckParameters(\n            Constants.CHI_THRESHOLD,\n            Constants.HF_CHECK_INTERVAL_DEFAULT\n        ); // T:[CF-21]\n    }\n\n    //\n    // STATE-CHANGING FUNCTIONS\n    //\n\n    /// @dev Adds token to the list of allowed tokens\n    /// @param token Address of allowed token\n    /// @param liquidationThreshold The credit Manager constant showing the maximum allowable ratio of Loan-To-Value for the i-th asset.\n    function allowToken(address token, uint256 liquidationThreshold)\n        public\n        override\n        configuratorOnly // T:[CF-1]\n    {\n        require(token != address(0), Errors.ZERO_ADDRESS_IS_NOT_ALLOWED); // T:[CF-2]\n\n        require(\n            liquidationThreshold > 0 &&\n                liquidationThreshold <= liquidationThresholds[underlyingToken],\n            Errors.CF_INCORRECT_LIQUIDATION_THRESHOLD\n        ); // T:[CF-3]\n\n        require(allowedTokens.length < 256, Errors.CF_TOO_MUCH_ALLOWED_TOKENS); // T:[CF-5]\n\n        // Checks that contract has balanceOf method and it returns uint256\n        require(IERC20(token).balanceOf(address(this)) >= 0); // T:[CF-11]\n\n        // Checks that pair token - underlyingToken has priceFeed\n        IPriceOracle(priceOracle).getLastPrice(token, underlyingToken); // T:[CF-15]\n\n        // we add allowed tokens to array if it wasn't added before\n        // T:[CF-6] controls that\n        if (!_allowedTokensMap[token]) {\n            _allowedTokensMap[token] = true; // T:[CF-4]\n\n            tokenMasksMap[token] = 1 << allowedTokens.length; // T:[CF-4]\n            allowedTokens.push(token); // T:[CF-4]\n        }\n\n        liquidationThresholds[token] = liquidationThreshold; // T:[CF-4, 6]\n\n        emit TokenAllowed(token, liquidationThreshold); // T:[CF-4]\n    }\n\n    /// @dev Adds contract and adapter to the list of allowed contracts\n    /// if contract exists it updates adapter only\n    /// @param targetContract Address of allowed contract\n    /// @param adapter Adapter contract address\n    function allowContract(address targetContract, address adapter)\n        external\n        override\n        configuratorOnly // T:[CF-1]\n    {\n        require(\n            targetContract != address(0) && adapter != address(0),\n            Errors.ZERO_ADDRESS_IS_NOT_ALLOWED\n        ); // T:[CF-2]\n\n        // Remove previous adapter from allowed list and set up new one\n        allowedAdapters[contractToAdapter[targetContract]] = false; // T:[CF-10]\n        allowedAdapters[adapter] = true; // T:[CF-9, 10]\n\n        allowedContractsSet.add(targetContract);\n        contractToAdapter[targetContract] = adapter; // T:[CF-9, 10]\n\n        emit ContractAllowed(targetContract, adapter); // T:[CF-12]\n    }\n\n    /// @dev Forbids contract to use with credit manager\n    /// @param targetContract Address of contract to be forbidden\n    function forbidContract(address targetContract)\n        external\n        override\n        configuratorOnly // T:[CF-1]\n    {\n        require(\n            targetContract != address(0),\n            Errors.ZERO_ADDRESS_IS_NOT_ALLOWED\n        ); // T:[CF-2]\n\n        require(\n            allowedContractsSet.remove(targetContract),\n            Errors.CF_CONTRACT_IS_NOT_IN_ALLOWED_LIST\n        ); // T:[CF-31]\n\n        // Remove previous adapter from allowed list\n        allowedAdapters[contractToAdapter[targetContract]] = false; // T:[CF-32]\n\n        // Sets adapter to address(0), which means to forbid it usage\n        contractToAdapter[targetContract] = address(0); // T:[CF-32]\n\n        emit ContractForbidden(targetContract); // T:[CF-32]\n    }\n\n    /// @dev Connects credit manager and checks that it has the same underlying token as pool\n    function connectCreditManager(address _creditManager)\n        external\n        override\n        duringConfigOnly // T:[CF-13]\n        configuratorOnly // T:[CF-1]\n    {\n        creditManager = _creditManager; // T:[CF-14]\n        poolService = ICreditManager(_creditManager).poolService(); //  T:[CF-14]\n\n        require(\n            IPoolService(poolService).underlyingToken() == underlyingToken,\n            Errors.CF_UNDERLYING_TOKEN_FILTER_CONFLICT\n        ); // T:[CF-16]\n    }\n\n    /// @dev Checks the financial order and reverts if tokens aren't in list or collateral protection alerts\n    /// @param creditAccount Address of credit account\n    /// @param tokenIn Address of token In in swap operation\n    /// @param tokenOut Address of token Out in swap operation\n    /// @param amountIn Amount of tokens in\n    /// @param amountOut Amount of tokens out\n    function checkCollateralChange(\n        address creditAccount,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOut\n    )\n        public\n        override\n        adapterOnly // T:[CF-20]\n    {\n        _checkAndEnableToken(creditAccount, tokenOut); // T:[CF-22]\n\n        // Convert to WETH is more gas efficient and doesn't make difference for ratio\n        uint256 amountInCollateral = IPriceOracle(priceOracle).convert(\n            amountIn,\n            tokenIn,\n            wethAddress\n        ); // T:[CF-24]\n\n        // Convert to WETH is more gas efficient and doesn't make difference for ratio\n        uint256 amountOutCollateral = IPriceOracle(priceOracle).convert(\n            amountOut,\n            tokenOut,\n            wethAddress\n        ); // T:[CF-24]\n\n        _checkCollateral(\n            creditAccount,\n            amountInCollateral,\n            amountOutCollateral\n        );\n    }\n\n    /// @dev Checks collateral for operation which returns more than 1 token\n    /// @param creditAccount Address of credit account\n    /// @param tokenOut Addresses of returned tokens\n    function checkMultiTokenCollateral(\n        address creditAccount,\n        uint256[] memory amountIn,\n        uint256[] memory amountOut,\n        address[] memory tokenIn,\n        address[] memory tokenOut\n    )\n        external\n        override\n        adapterOnly // T:[CF-20]\n    {\n        // Convert to WETH is more gas efficient and doesn't make difference for ratio\n        uint256 amountInCollateral = 0;\n        uint256 amountOutCollateral = 0;\n\n        for (uint256 i = 0; i < amountIn.length; i++) {\n            amountInCollateral = amountInCollateral.add(\n                IPriceOracle(priceOracle).convert(\n                    amountIn[i],\n                    tokenIn[i],\n                    wethAddress\n                )\n            );\n        }\n\n        for (uint256 i = 0; i < amountOut.length; i++) {\n            _checkAndEnableToken(creditAccount, tokenOut[i]); // T: [CF-33]\n            amountOutCollateral = amountOutCollateral.add(\n                IPriceOracle(priceOracle).convert(\n                    amountOut[i],\n                    tokenOut[i],\n                    wethAddress\n                )\n            );\n        }\n\n        _checkCollateral(\n            creditAccount,\n            amountInCollateral,\n            amountOutCollateral\n        ); // T: [CF-33]\n    }\n\n    /// @dev Checks health factor after operations\n    /// @param creditAccount Address of credit account\n    function _checkCollateral(\n        address creditAccount,\n        uint256 collateralIn,\n        uint256 collateralOut\n    ) internal {\n        if (\n            (collateralOut.mul(PercentageMath.PERCENTAGE_FACTOR) >\n                collateralIn.mul(chiThreshold)) &&\n            fastCheckCounter[creditAccount] <= hfCheckInterval\n        ) {\n            fastCheckCounter[creditAccount]++; // T:[CF-25, 33]\n        } else {\n            // Require Hf > 1\n\n            console.log(calcCreditAccountHealthFactor(creditAccount));\n            require(\n                calcCreditAccountHealthFactor(creditAccount) >=\n                    PercentageMath.PERCENTAGE_FACTOR,\n                Errors.CF_OPERATION_LOW_HEALTH_FACTOR\n            ); // T:[CF-25, 33, 34]\n            fastCheckCounter[creditAccount] = 1; // T:[CF-34]\n        }\n    }\n\n    /// @dev Initializes enabled tokens\n    function initEnabledTokens(address creditAccount)\n        external\n        override\n        creditManagerOnly // T:[CF-20]\n    {\n        // at opening account underlying token is enabled only\n        enabledTokens[creditAccount] = 1; // T:[CF-19]\n        fastCheckCounter[creditAccount] = 1; // T:[CF-19]\n    }\n\n    /// @dev Checks that token is in allowed list and updates enabledTokenMask\n    /// for provided credit account if needed\n    /// @param creditAccount Address of credit account\n    /// @param token Address of token to be checked\n    function checkAndEnableToken(address creditAccount, address token)\n        external\n        override\n        creditManagerOnly // [CF-20]\n    {\n        _checkAndEnableToken(creditAccount, token); // T:[CF-22, 23]\n    }\n\n    /// @dev Checks that token is in allowed list and updates enabledTokenMask\n    /// for provided credit account if needed\n    /// @param creditAccount Address of credit account\n    /// @param token Address of token to be checked\n    function _checkAndEnableToken(address creditAccount, address token)\n        internal\n    {\n        revertIfTokenNotAllowed(token); //T:[CF-22, 36]\n\n        if (enabledTokens[creditAccount] & tokenMasksMap[token] == 0) {\n            enabledTokens[creditAccount] =\n                enabledTokens[creditAccount] |\n                tokenMasksMap[token];\n        } // T:[CF-23]\n    }\n\n    /// @dev Change allowedTokenMask bit for partical token to opposite\n    /// It disables enabled tokens and vice versa\n    function changeAllowedTokenState(address token, bool state)\n        external\n        configuratorOnly // T:[CF-1]\n    {\n        _allowedTokensMap[token] = state; // T: [CF-35, 36]\n    }\n\n    /// @dev Sets fast check parameters chi & hfCheckCollateral\n    /// It reverts if 1 - chi ** hfCheckCollateral > feeLiquidation\n    function setFastCheckParameters(\n        uint256 _chiThreshold,\n        uint256 _hfCheckInterval\n    )\n        public\n        configuratorOnly // T:[CF-1]\n    {\n        chiThreshold = _chiThreshold; // T:[CF-30]\n        hfCheckInterval = _hfCheckInterval; // T:[CF-30]\n\n        revertIfIncorrectFastCheckParams();\n\n        emit NewFastCheckParameters(_chiThreshold, _hfCheckInterval); // T:[CF-30]\n    }\n\n    /// @dev It updates liquidation threshold for underlying token threshold\n    /// to have enough buffer for liquidation (liquidaion premium + fee liq.)\n    /// It reverts if that buffer is less with new paremters, or there is any\n    /// liquidaiton threshold > new LT\n    function updateUnderlyingTokenLiquidationThreshold()\n        external\n        override\n        creditManagerOnly // T:[CF-20]\n    {\n        require(\n            ICreditManager(creditManager).feeSuccess() <\n                PercentageMath.PERCENTAGE_FACTOR &&\n                ICreditManager(creditManager).feeInterest() <\n                PercentageMath.PERCENTAGE_FACTOR &&\n                ICreditManager(creditManager).feeLiquidation() <\n                PercentageMath.PERCENTAGE_FACTOR &&\n                ICreditManager(creditManager).liquidationDiscount() <\n                PercentageMath.PERCENTAGE_FACTOR,\n            Errors.CM_INCORRECT_FEES\n        ); // T:[CM-36]\n\n        // Otherwise, new credit account will be immediately liquidated\n        require(\n            ICreditManager(creditManager).minHealthFactor() >\n                PercentageMath.PERCENTAGE_FACTOR,\n            Errors.CM_MAX_LEVERAGE_IS_TOO_HIGH\n        ); // T:[CM-40]\n\n        liquidationThresholds[underlyingToken] = ICreditManager(creditManager)\n        .liquidationDiscount()\n        .sub(ICreditManager(creditManager).feeLiquidation()); // T:[CF-38]\n\n        for (uint256 i = 1; i < allowedTokens.length; i++) {\n            require(\n                liquidationThresholds[allowedTokens[i]] <=\n                    liquidationThresholds[underlyingToken],\n                Errors.CF_SOME_LIQUIDATION_THRESHOLD_MORE_THAN_NEW_ONE\n            ); // T:[CF-39]\n        }\n\n        revertIfIncorrectFastCheckParams(); // T:[CF-39]\n    }\n\n    /// @dev It checks that 1 - chi ** hfCheckInterval < feeLiquidation\n    function revertIfIncorrectFastCheckParams() internal view {\n        // if credit manager is set, we add additional check\n        if (creditManager != address(0)) {\n            // computes maximum possible collateral drop between two health factor checks\n            uint256 maxPossibleDrop = PercentageMath.PERCENTAGE_FACTOR.sub(\n                calcMaxPossibleDrop(chiThreshold, hfCheckInterval)\n            ); // T:[CF-39]\n\n            require(\n                maxPossibleDrop <\n                    ICreditManager(creditManager).feeLiquidation(),\n                Errors.CF_FAST_CHECK_NOT_COVERED_COLLATERAL_DROP\n            ); // T:[CF-39]\n        }\n    }\n\n    // @dev it computes percentage ** times\n    // @param percentage Percentage in PERCENTAGE FACTOR format\n    function calcMaxPossibleDrop(uint256 percentage, uint256 times)\n        public\n        pure\n        returns (uint256 value)\n    {\n        value = PercentageMath.PERCENTAGE_FACTOR.mul(percentage); // T:[CF-37]\n        for (uint256 i = 0; i < times.sub(1); i++) {\n            value = value.mul(percentage).div(PercentageMath.PERCENTAGE_FACTOR); // T:[CF-37]\n        }\n        value = value.div(PercentageMath.PERCENTAGE_FACTOR); // T:[CF-37]\n    }\n\n    //\n    // GETTERS\n    //\n\n    /// @dev Calculates total value for provided address\n    /// More: https://dev.gearbox.fi/developers/credit/economy#total-value\n    ///\n    /// @param creditAccount Token creditAccount address\n    function calcTotalValue(address creditAccount)\n        external\n        view\n        override\n        returns (uint256 total)\n    {\n        total = 0; // T:[CF-17]\n\n        uint256 tokenMask;\n        uint256 eTokens = enabledTokens[creditAccount];\n        for (uint256 i = 0; i < allowedTokensCount(); i++) {\n            tokenMask = 1 << i; // T:[CF-17]\n            if (eTokens & tokenMask > 0) {\n                (, , uint256 tv, ) = getCreditAccountTokenById(\n                    creditAccount,\n                    i\n                );\n                total = total.add(tv);\n            } // T:[CF-17]\n        }\n    }\n\n    /// @dev Calculates Threshold Weighted Total Value\n    /// More: https://dev.gearbox.fi/developers/credit/economy#threshold-weighted-value\n    ///\n    /// @param creditAccount Credit account address\n    function calcThresholdWeightedValue(address creditAccount)\n        public\n        view\n        override\n        returns (uint256 total)\n    {\n        total = 0;\n        uint256 tokenMask;\n        uint256 eTokens = enabledTokens[creditAccount];\n        for (uint256 i = 0; i < allowedTokensCount(); i++) {\n            tokenMask = 1 << i; // T:[CF-18]\n            if (eTokens & tokenMask > 0) {\n                (, , , uint256 twv) = getCreditAccountTokenById(\n                    creditAccount,\n                    i\n                );\n                total = total.add(twv);\n            }\n        } // T:[CF-18]\n        return total.div(PercentageMath.PERCENTAGE_FACTOR); // T:[CF-18]\n    }\n\n    /// @dev Returns quantity of tokens in allowed list\n    function allowedTokensCount() public view override returns (uint256) {\n        return allowedTokens.length; // T:[CF-4, 6]\n    }\n\n    /// @dev Returns true if token is in allowed list otherwise false\n    function isTokenAllowed(address token) public view override returns (bool) {\n        return _allowedTokensMap[token]; // T:[CF-4, 6]\n    }\n\n    /// @dev Reverts if token isn't in token allowed list\n    function revertIfTokenNotAllowed(address token) public view override {\n        require(isTokenAllowed(token), Errors.CF_TOKEN_IS_NOT_ALLOWED); // T:[CF-7, 36]\n    }\n\n    /// @dev Returns quantity of contracts in allowed list\n    function allowedContractsCount() public view override returns (uint256) {\n        return allowedContractsSet.length(); // T:[CF-9]\n    }\n\n    /// @dev Returns allowed contract by index\n    function allowedContracts(uint256 i)\n        public\n        view\n        override\n        returns (address)\n    {\n        return allowedContractsSet.at(i); // T:[CF-9]\n    }\n\n    /// @dev Returns address & balance of token by the id of allowed token in the list\n    /// @param creditAccount Credit account address\n    /// @param id Id of token in allowed list\n    /// @return token Address of token\n    /// @return balance Token balance\n    /// @return tv Balance converted to undelying asset using price oracle\n    /// @return tvw Balance converted to undelying asset using price oracle multipled with liquidation threshold\n    function getCreditAccountTokenById(address creditAccount, uint256 id)\n        public\n        view\n        override\n        returns (\n            address token,\n            uint256 balance,\n            uint256 tv,\n            uint256 tvw\n        )\n    {\n        token = allowedTokens[id]; // T:[CF-28]\n        balance = IERC20(token).balanceOf(creditAccount); // T:[CF-28]\n\n        // balance ==0 : T: [CF-28]\n        if (balance > 1) {\n            tv = IPriceOracle(priceOracle).convert(\n                balance,\n                token,\n                underlyingToken\n            ); // T:[CF-28]\n            tvw = tv.mul(liquidationThresholds[token]); // T:[CF-28]\n        }\n    }\n\n    /// @dev Calculates credit account interest accrued\n    /// More: https://dev.gearbox.fi/developers/credit/economy#interest-rate-accrued\n    ///\n    /// @param creditAccount Credit account address\n    function calcCreditAccountAccruedInterest(address creditAccount)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return\n            ICreditAccount(creditAccount)\n                .borrowedAmount()\n                .mul(IPoolService(poolService).calcLinearCumulative_RAY())\n                .div(ICreditAccount(creditAccount).cumulativeIndexAtOpen()); // T: [CF-26]\n    }\n\n    /**\n     * @dev Calculates health factor for the credit account\n     *\n     *         sum(asset[i] * liquidation threshold[i])\n     *   Hf = --------------------------------------------\n     *             borrowed amount + interest accrued\n     *\n     *\n     * More info: https://dev.gearbox.fi/developers/credit/economy#health-factor\n     *\n     * @param creditAccount Credit account address\n     * @return Health factor in percents (see PERCENTAGE FACTOR in PercentageMath.sol)\n     */\n    function calcCreditAccountHealthFactor(address creditAccount)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return\n            calcThresholdWeightedValue(creditAccount)\n                .mul(PercentageMath.PERCENTAGE_FACTOR)\n                .div(calcCreditAccountAccruedInterest(creditAccount)); // T:[CF-27]\n    }\n}"
    }
  ]
}