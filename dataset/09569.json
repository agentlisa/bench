{
  "Title": "[M-05] Arbitrary contract call within UniV3LpVault._swap with controllable swapPath",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-04-dualityfocus/blob/main/contracts/vault_and_oracles/UniV3LpVault.sol#L621\nhttps://github.com/code-423n4/2022-04-dualityfocus/blob/main/contracts/vault_and_oracles/UniV3LpVault.sol#L379\nhttps://github.com/code-423n4/2022-04-dualityfocus/blob/main/contracts/vault_and_oracles/UniV3LpVault.sol#L520\nhttps://github.com/code-423n4/2022-04-dualityfocus/blob/main/contracts/vault_and_oracles/UniV3LpVault.sol#L521\n\n\n# Vulnerability details\n\n## Impact\n\n`UniV3LpVault._swap` utilizes `swapRouter.exactInput` to perform swaps between two tokens. During swaps, `transfer` function of each token along the path will be called to propagate the assets.\n\nSince anyone can create a uniswap pair of arbitrary assets, it is possible to include intermediate hop with malicious tokens within the path. Thus `UniV3LpVault._swap` effectively grants users the ability to perform arbitrary contract calls during the swap process if `swapPath` is not validated properly.\n\nUsage of invalidated `swapPath` can be found in `UniV3LpVault.flashFocusCall` and `UniV3LpVault.repayDebt`.\n\n## Proof of Concept\n\nThe security of `Comptroller` and `UniV3LpVault` relies on validating all used tokens thoroughly. This is done by a whitelist mechanism where admin decides a predefined set of usable tokens, and users can only perform actions within the allowed range. This whitelist approach eliminates most of the attack surface regarding directly passing in malicious tokens as arguments.\n\nApart from passing malicious tokens directly, there are a few other potential weaknesses, the most obvious one is leveraging flash loans for collaterals. However, due to the adoption of AAVE LendingPool, the external validation within flash loan pool blocks this approach.\n\nUnfortunately, a more obscure path exists. Looking at the swapping mechanism, it is not hard to realize it is backed by uniswapV3. An interesting characteristic of uniswap pools is that anyone can create pools for any token pairs, thus if we don't fully validate each and every pool we are using, chances are there will be malicious entries hidden within them.\n\nThis is partially the case which we see here, the user gets to supply a path, where the source and target are validated against benign tokens, the intermediate ones are not. An example of utilizing path for arbitrary function call is illustrated below\n1. Create malicious token tokenM\n2. Create pools tokenS<->tokenM and tokenM<->tokenT where tokenS and tokenT are benign tokens\n3. Supply path (tokenS, tokenM, tokenT) for swapping\n\nIn the above case, when transferring tokenM while doing swap, we have full control over code executed and can insert arbitrary contract calls within.\n\nNoticeably, while gaining arbitrary contract calls sounds dangerous, it does not necessarily mean the contract is exploitable. It still depends on the scenario in which an arbitrary call happens.\n\nIn the case of duality, the two locations where arbitrary `swapPath` can be provided is in `flashFocusCall` and `repayDebt`, both in which holds a local lock over `UniV3LpVault`. No global are applied to `Comptroller` or `Ctokens` while performing swaps.\n\n```\n    function flashFocusCall(FlashFocusParams calldata params) external override {\n        ...\n        {\n            ...\n            if (!tokenOfPool && params.swapPath.length > 0) amountIn0 = _swap(params.swapPath, params.amount);\n            ...\n        }\n        ...\n    }\n\n    function flashFocus(FlashFocusParams calldata params)\n        external\n        override\n        nonReentrant(true)\n        isAuthorizedForToken(params.tokenId)\n        avoidsShortfall\n    {\n        ...\n        flashLoan.LENDING_POOL().flashLoan(\n            receiverAddress,\n            assets,\n            amounts,\n            modes,\n            onBehalfOf,\n            newParams,\n            referralCode\n        );\n    }\n\n    function repayDebt(RepayDebtParams calldata params)\n        external\n        override\n        nonReentrant(true)\n        isAuthorizedForToken(params.tokenId)\n        avoidsShortfall\n        returns (uint256 amountReturned)\n    {\n        ...\n        {\n            ...\n            if (amountOutFrom0 == 0 && params.swapPath0.length > 0) amountOutFrom0 = _swap(params.swapPath0, amount0);\n            if (amountOutFrom1 == 0 && params.swapPath1.length > 0) amountOutFrom1 = _swap(params.swapPath1, amount1);\n            ...\n        }\n        ...\n    }\n```\n\n\nThe lack of global locks here had us doubting whether an attack is possible. While we spent a considerable amount of time and failed to come up with any possible attack vectors, the complexity of the system held us back from concluding that an attack is impossible.\n\nThus we report this finding here in hope of inspiring developers either to prove the attack impossible or mitigate the attack surface.\n\n## Tools Used\n\nvim, ganache-cli\n\n## Recommended Mitigation Steps\n\nThe easiest way to mitigate this is to validate the entire path against a predefined whitelist while in `_checkSwapPath`. This approach is far from optimal and also limits the flexibility of swapping between tokens. However, before security is proved, this is the best approach we can come up with.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-04-duality-focus-contest",
  "Code": [
    {
      "filename": "contracts/vault_and_oracles/UniV3LpVault.sol",
      "content": "pragma solidity ^0.7.6;\npragma abicoder v2;\n\n// interfaces\nimport { ComptrollerInterface, TickOracleInterface, CErc20Interface } from \"../interfaces/CompoundInterfaces.sol\";\nimport \"../interfaces/IUniV3LpVault.sol\";\nimport \"../interfaces/IERC20Detailed.sol\";\nimport { IFlashLoanReceiver } from \"../external/aave/AaveInterfaces.sol\";\nimport \"../external/openzeppelin/token/ERC721/IERC721.sol\";\nimport \"../external/uniswap/v3-periphery/interfaces/INonfungiblePositionManager.sol\";\nimport \"../external/uniswap/v3-periphery/interfaces/ISwapRouter.sol\";\n\n// libs\nimport \"../external/uniswap/v3-core/libraries/TransferHelper.sol\";\nimport \"../external/uniswap/v3-periphery/libraries/BytesLib.sol\";\nimport { Uint256Casting } from \"../external/opyn/Uint256Casting.sol\";\nimport { SafeMath } from \"../external/openzeppelin/math/SafeMath.sol\";\nimport \"../libs/LiquidityLibrary.sol\";\n\n/**\n * @title UniV3LpVault\n * @author Duality (h/t to Uniswap's UniswapV3Staker as a starting point)\n */\ncontract UniV3LpVault is IUniV3LpVault {\n    using SafeMath for uint256;\n    using Uint256Casting for uint256;\n    using BytesLib for bytes;\n\n    address public override factory;\n\n    INonfungiblePositionManager public override nonfungiblePositionManager;\n\n    ISwapRouter public override swapRouter;\n\n    ComptrollerInterface public override comptroller;\n\n    IFlashLoanReceiver public override flashLoan;\n\n    mapping(address => bool) public override flashLoanAuthorized;\n\n    /// @dev ownerOf[tokenId] => address owner\n    mapping(uint256 => address) public override ownerOf;\n\n    /// @dev userTokens[userAddress] => tokenIds[]\n    mapping(address => uint256[]) public userTokens;\n\n    /// @notice max number of userTokens for a single userAddress\n    uint256 public override userTokensMax = 4;\n\n    /// @notice whether or not periphery functionality has been paused\n    bool public peripheryGuardianPaused;\n\n    /// @notice whether or not deposits have been paused\n    bool public depositGuardianPaused;\n\n    /// @dev Guard variable for re-entrancy checks\n    bool internal _notEntered;\n\n    constructor(\n        address _factory,\n        INonfungiblePositionManager _nonfungiblePositionManager,\n        ISwapRouter _swapRouter,\n        ComptrollerInterface _comptroller\n    ) {\n        factory = _factory;\n        nonfungiblePositionManager = _nonfungiblePositionManager;\n        swapRouter = _swapRouter;\n        comptroller = _comptroller;\n        _notEntered = true;\n    }\n\n    /*** External Mutator Functions ***/\n\n    /// @dev Upon receiving a Uniswap V3 ERC721, creates the token deposit setting owner to `from`\n    /// @inheritdoc IERC721Receiver\n    function onERC721Received(\n        address,\n        address from,\n        uint256 tokenId,\n        bytes calldata\n    ) external override nonReentrant(false) returns (bytes4) {\n        require(!depositGuardianPaused, \"deposit is paused\");\n        require(msg.sender == address(nonfungiblePositionManager), \"IUniV3LpVault::onERC721Received: not a Uni V3 nft\");\n\n        _processNewToken(tokenId, from);\n        emit TokenDeposited(from, tokenId);\n        return this.onERC721Received.selector;\n    }\n\n    /**\n     * @notice Withdraw a tokenId from the vault, so long as the caller's debt is still sufficiently collateralized\n     * @param tokenId The tokenId of the NFT to be withdrawn\n     * @param to The address to send tokenId to\n     * @param data any data to provide for the safeTransferFrom call\n     */\n    function withdrawToken(\n        uint256 tokenId,\n        address to,\n        bytes memory data\n    ) external override nonReentrant(false) avoidsShortfall {\n        require(to != address(this), \"IUniV3LpVault::withdrawToken: cannot withdraw to vault\");\n        require(ownerOf[tokenId] == msg.sender, \"IUniV3LpVault::withdrawToken: only owner can withdraw token\");\n\n        _deleteOldToken(msg.sender, tokenId);\n\n        nonfungiblePositionManager.safeTransferFrom(address(this), to, tokenId, data);\n        emit TokenWithdrawn(msg.sender, to, tokenId);\n    }\n\n    /**\n     * @notice Seize fees and/or liquidity from a borrower's LP NFT, assuming the seizure is allowed.\n     *          To be called exclusively from the CToken of the debt asset (Best mirroring original compound liquidation path)\n     * @param liquidator The address of the EOA/Contract claiming the liquidation + incentive\n     * @param borrower The address of the account currently in shortfall. Owner of tokenId.\n     * @param tokenId The tokenId to be partially or fully liquidated. Owned by Borrower.\n     * @param seizeFeesToken0 The amount of token0 to seize from tokenId's fees\n     * @param seizeFeesToken1 The amount of token1 to seize from tokenId's fees\n     * @param seizeLiquidity The amount of liquidity to convert to token0/token1 and seize\n     */\n    function seizeAssets(\n        address liquidator,\n        address borrower,\n        uint256 tokenId,\n        uint256 seizeFeesToken0,\n        uint256 seizeFeesToken1,\n        uint256 seizeLiquidity\n    ) external override nonReentrant(true) {\n        require(ownerOf[tokenId] == borrower, \"borrower must own tokenId\");\n\n        // make call to comptroller to ensure seize is allowed\n        uint256 allowed = ComptrollerInterface(comptroller).seizeAllowedUniV3(\n            address(this),\n            msg.sender,\n            liquidator,\n            borrower,\n            tokenId,\n            seizeFeesToken0,\n            seizeFeesToken1,\n            seizeLiquidity\n        );\n\n        // TODO: do we want some Comptroller like error handling/messaging here?\n        require(allowed == 0, \"seize not allowed according to Comptroller\");\n\n        if (seizeLiquidity > 0) {\n            // liquidate seizeLiquidity from tokenId position\n            _decreaseLiquidity(tokenId, uint128(seizeLiquidity));\n\n            // claim all fees + tokens from liquidity removal\n            nonfungiblePositionManager.collect(\n                INonfungiblePositionManager.CollectParams(tokenId, liquidator, type(uint128).max, type(uint128).max)\n            );\n        } else {\n            // claim feesAmountToken0 and feesAmountToken1 and send to liquidator\n            nonfungiblePositionManager.collect(\n                INonfungiblePositionManager.CollectParams(\n                    tokenId,\n                    liquidator,\n                    uint128(seizeFeesToken0),\n                    uint128(seizeFeesToken1)\n                )\n            );\n        }\n    }\n\n    // TODO: do we want a \"decreaseLiquidityAndCollect\" function?\n\n    /**\n     * @notice Passthrough function to NonfungiblePositionManager for an owner of an NFT to decrease its liquidity.\n     *          Checks that the user's position is still sufficiently collateralized after taking this action\n     * @param params INonfungiblePositionManager's decreaseLiquidityParams for the passthrough call\n     */\n    function decreaseLiquidity(INonfungiblePositionManager.DecreaseLiquidityParams calldata params)\n        external\n        override\n        nonReentrant(false)\n        isAuthorizedForToken(params.tokenId)\n        avoidsShortfall\n    {\n        require(!peripheryGuardianPaused, \"periphery functionality is paused\");\n\n        nonfungiblePositionManager.decreaseLiquidity(params);\n        emit LiquidityDecreased(msg.sender, params.tokenId, params.liquidity);\n    }\n\n    /**\n     * @notice Passthrough function to NonfungiblePositionManager for an owner of an NFT to collect its fees.\n     *          Checks that the user's position is still sufficiently collateralized after taking this action\n     * @param params INonfungiblePositionManager's CollectParams for the passthrough call\n     */\n    function collectFees(INonfungiblePositionManager.CollectParams calldata params)\n        external\n        override\n        nonReentrant(false)\n        isAuthorizedForToken(params.tokenId)\n        avoidsShortfall\n    {\n        require(!peripheryGuardianPaused, \"periphery functionality is paused\");\n\n        (uint256 amount0, uint256 amount1) = nonfungiblePositionManager.collect(params);\n        emit FeesCollected(msg.sender, params.tokenId, amount0, amount1);\n    }\n\n    /**\n     * @notice function for an owner of an NFT to automatically compound fees into liquidity of a range.\n     *          Checks that the user's position is still sufficiently collateralized after taking this action\n     *\n     *          Target balance of fees for swap are pre-computed off-chain along with slippage tolerance.\n     *\n     *          Swap is made by swapping the extra of token0 (according to expectedAmount0) to token1, depositing\n     *          the max liquidity possible (along with min checks), and any remnants left are sent back to the user\n     *\n     * @param params our CompoundFeesParams, described at definition in the interface\n     */\n    function compoundFees(CompoundFeesParams calldata params)\n        external\n        override\n        nonReentrant(false)\n        isAuthorizedForToken(params.tokenId)\n        avoidsShortfall\n    {\n        require(!peripheryGuardianPaused, \"periphery functionality is paused\");\n\n        // collect all fees\n        (uint256 amount0, uint256 amount1) = _collectMax(params.tokenId);\n\n        address token0;\n        address token1;\n\n        {\n            // avoid stack too deep\n            uint24 fee;\n            (, , token0, token1, fee, , , , , , , ) = nonfungiblePositionManager.positions(params.tokenId);\n\n            // trade assets to expectedAmounts (assuming correct off-chain computation)\n            (amount0, amount1) = _prepareForDeposit(\n                token0,\n                token1,\n                fee,\n                params.expectedAmount0,\n                params.expectedAmount1,\n                amount0,\n                amount1\n            );\n        }\n\n        // attempt to deposit amount0 and amount1 into our range\n        (uint256 amountTaken0, uint256 amountTaken1) = _increaseLiquidity(\n            params.tokenId,\n            token0,\n            token1,\n            amount0,\n            amount1,\n            params.amount0Min,\n            params.amount1Min\n        );\n\n        uint256 amountReturned0 = amount0 > amountTaken0 ? amount0.sub(amountTaken0) : 0;\n        uint256 amountReturned1 = amount1 > amountTaken1 ? amount1.sub(amountTaken1) : 0;\n\n        // send back remnants to user\n        if (amountReturned0 > 0) TransferHelper.safeTransfer(token0, msg.sender, amountReturned0);\n        if (amountReturned1 > 0) TransferHelper.safeTransfer(token1, msg.sender, amountReturned1);\n        emit FeesCompounded(msg.sender, params.tokenId, amountTaken0, amountTaken1, amountReturned0, amountReturned1);\n    }\n\n    /**\n     * @notice function for an owner of an NFT to move liquidity of one range into a new range.\n     *          Checks that the user's position is still sufficiently collateralized after taking this action\n     *\n     *          Target balance of fees for swap are pre-computed off-chain along with slippage tolerance.\n     *\n     *          Swap is made by swapping the extra of token0 (according to expectedAmount0) to token1, depositing\n     *          the max liquidity possible (along with min checks), and any remnants left are sent back to the user\n     *\n     * @param params our MoveRangeParams, described at definition in the interface\n     * @return newTokenId The tokenId of our new Uni V3 LP position\n     */\n    function moveRange(MoveRangeParams calldata params)\n        external\n        override\n        nonReentrant(false)\n        isAuthorizedForToken(params.tokenId)\n        avoidsShortfall\n        returns (uint256 newTokenId)\n    {\n        require(!peripheryGuardianPaused, \"periphery functionality is paused\");\n\n        // remove params.liquidity from token (moves to token's fees)\n        if (params.liquidity > 0) _decreaseLiquidity(params.tokenId, params.liquidity);\n\n        // collect all fees (includes decreased liquidity)\n        (uint256 amount0, uint256 amount1) = _collectMax(params.tokenId);\n\n        (, , address token0, address token1, uint24 fee, , , , , , , ) = nonfungiblePositionManager.positions(\n            params.tokenId\n        );\n\n        // trade assets to expectedAmounts (assuming correct off-chain computation)\n        (amount0, amount1) = _prepareForDeposit(\n            token0,\n            token1,\n            fee,\n            params.expectedAmount0,\n            params.expectedAmount1,\n            amount0,\n            amount1\n        );\n\n        // prepare mintParams\n        INonfungiblePositionManager.MintParams memory mintParams = INonfungiblePositionManager.MintParams(\n            token0,\n            token1,\n            fee,\n            params.newTickLower,\n            params.newTickUpper,\n            amount0,\n            amount1,\n            params.amount0Min,\n            params.amount1Min,\n            msg.sender, // _mint utilizes this appropriately\n            block.timestamp + 200\n        );\n\n        // burn old token if emptied\n        (, , , , , , , uint128 newLiquidity, , , , ) = nonfungiblePositionManager.positions(params.tokenId);\n        if (newLiquidity == 0) _burn(msg.sender, params.tokenId);\n\n        {\n            uint256 amountTaken0;\n            uint256 amountTaken1;\n\n            // mint new range\n            (newTokenId, amountTaken0, amountTaken1) = _mint(mintParams);\n\n            // send back remnants to user\n            if (amount0 > amountTaken0) TransferHelper.safeTransfer(token0, msg.sender, amount0.sub(amountTaken0));\n            if (amount1 > amountTaken1) TransferHelper.safeTransfer(token1, msg.sender, amount1.sub(amountTaken1));\n        }\n\n        emit RangeMoved(msg.sender, params.tokenId, newTokenId, params.liquidity, newLiquidity == 0);\n    }\n\n    /**\n     * @notice function only to be called by flashloan contract initiated from the NFT owner\n     * @param params our MoveRangeParams, described at definition in the interface\n     */\n    function flashFocusCall(FlashFocusParams calldata params) external override {\n        address owner = ownerOf[params.tokenId];\n        (, , address token0, address token1, , , , , , , , ) = nonfungiblePositionManager.positions(params.tokenId);\n\n        bool tokenOfPool = params.asset == token0 || params.asset == token1;\n\n        require(!peripheryGuardianPaused, \"periphery functionality is paused\");\n        require(msg.sender == address(flashLoan), \"Can only be called from our flashLoan contract\");\n        require(flashLoanAuthorized[owner], \"flashLoan action must have been authorized by tokenId owner\");\n        require(\n            tokenOfPool || params.swapPath.length > 0,\n            \"flashLoaned asset must be a pool asset or swapping to token0\"\n        );\n        require(_checkSwapPath(params.swapPath, params.asset, token0), \"swapPath did not pass integrity check\");\n\n        flashLoanAuthorized[owner] = false;\n\n        // transfer flashLoaned assets to vault\n        IERC20Detailed(params.asset).transferFrom(msg.sender, address(this), params.amount);\n\n        uint256 amount0;\n        uint256 amount1;\n\n        {\n            // creating local scope, avoiding stack too deep\n\n            // calculate our starting amounts of each asset\n            uint256 amountIn0 = params.asset == token0 ? params.amount : 0;\n            uint256 amountIn1 = params.asset == token1 ? params.amount : 0;\n\n            // swap everything to token0 if swap path is provided and params.asset is neither of the tokens\n            if (!tokenOfPool && params.swapPath.length > 0) amountIn0 = _swap(params.swapPath, params.amount);\n\n            (, , , , uint24 fee, , , , , , , ) = nonfungiblePositionManager.positions(params.tokenId);\n\n            // trade assets to expectedAmounts (assuming correct off-chain computation)\n            (amount0, amount1) = _prepareForDeposit(\n                token0,\n                token1,\n                fee,\n                params.expectedAmount0,\n                params.expectedAmount1,\n                amountIn0,\n                amountIn1\n            );\n        }\n\n        // attempt to deposit amount0 and amount1 into our range\n        (uint256 amountTaken0, uint256 amountTaken1) = _increaseLiquidity(\n            params.tokenId,\n            token0,\n            token1,\n            amount0,\n            amount1,\n            params.amount0Min,\n            params.amount1Min\n        );\n\n        {\n            // another local scope :)\n            uint256 owedBack = params.amount.add(params.premium);\n\n            // borrow the flashloaned asset in preparation for closing loan\n            uint256 success = CErc20Interface(comptroller.cTokensByUnderlying(params.asset)).borrowBehalf(\n                owner,\n                owedBack\n            );\n            require(success == 0, \"borrow failed\");\n\n            // approve borrowed assets for flashLoan to pull\n            IERC20Detailed(params.asset).approve(msg.sender, owedBack);\n        }\n\n        uint256 amountReturned0 = amount0 > amountTaken0 ? amount0.sub(amountTaken0) : 0;\n        uint256 amountReturned1 = amount1 > amountTaken1 ? amount1.sub(amountTaken1) : 0;\n\n        // send back remnants to user\n        if (amountReturned0 > 0) TransferHelper.safeTransfer(token0, msg.sender, amountReturned0);\n        if (amountReturned1 > 0) TransferHelper.safeTransfer(token1, msg.sender, amountReturned1);\n        emit FlashFocus(\n            msg.sender,\n            params.tokenId,\n            params.asset,\n            params.amount,\n            amountTaken0,\n            amountTaken1,\n            amountReturned0,\n            amountReturned1\n        );\n    }\n\n    /**\n     * @notice function for an owner of an NFT to be able enter into a focused position in one click.\n     *          Allows a user, via flashloan, to open debt and re-deposit as liquidity into their NFT range\n     *          up to max leverage in one tx.\n     *          Reentrancy guard must be local, or split up around call to CToken\n     * @param params our FlashFocusParams, described at definition in the interface\n     */\n    function flashFocus(FlashFocusParams calldata params)\n        external\n        override\n        nonReentrant(true)\n        isAuthorizedForToken(params.tokenId)\n        avoidsShortfall\n    {\n        require(!peripheryGuardianPaused, \"periphery functionality is paused\");\n        address receiverAddress = address(flashLoan);\n\n        address[] memory assets = new address[](1);\n        uint256[] memory amounts = new uint256[](1);\n        uint256[] memory modes = new uint256[](1);\n\n        assets[0] = params.asset;\n        amounts[0] = params.amount;\n        modes[0] = 0;\n\n        address onBehalfOf = address(this);\n        bytes memory newParams = abi.encode(params);\n        uint16 referralCode = 0;\n\n        flashLoanAuthorized[msg.sender] = true;\n        flashLoan.LENDING_POOL().flashLoan(\n            receiverAddress,\n            assets,\n            amounts,\n            modes,\n            onBehalfOf,\n            newParams,\n            referralCode\n        );\n    }\n\n    /**\n     * @notice function for an owner of an NFT to be able to repay a debt using an NFT in one click.\n     *          Allows a user to repay debt by removing liquidity / fees from an NFT and swapping to\n     *          the debt token in one tx.\n     * @param params our RepayDebtParams, described at definition in the interface\n     * @return amountReturned The amount of the debtToken returned to the function caller\n     */\n    function repayDebt(RepayDebtParams calldata params)\n        external\n        override\n        nonReentrant(true)\n        isAuthorizedForToken(params.tokenId)\n        avoidsShortfall\n        returns (uint256 amountReturned)\n    {\n        require(!peripheryGuardianPaused, \"periphery functionality is paused\");\n        require(comptroller.markets(params.debtCToken).isListed, \"Debt CToken must be listed by comptroller\");\n        require(\n            params.underlying == CErc20Interface(params.debtCToken).underlying(),\n            \"Underlying must match CToken underlying\"\n        );\n\n        (, , address token0, address token1, , , , , , , , ) = nonfungiblePositionManager.positions(params.tokenId);\n        require(_checkSwapPath(params.swapPath0, token0, params.underlying), \"swapPath0 did not pass integrity check\");\n        require(_checkSwapPath(params.swapPath1, token1, params.underlying), \"swapPath1 did not pass integrity check\");\n\n        // remove params.liquidity from token (moves to token's fees)\n        if (params.liquidity > 0) _decreaseLiquidity(params.tokenId, params.liquidity);\n\n        uint256 amountOutTotal;\n\n        {\n            // collect all fees (includes decreased liquidity)\n            (uint256 amount0, uint256 amount1) = _collectMax(params.tokenId);\n\n            // calculate the totalAmount of debt asset we have.\n            // check if token0 or token1 are the debt asset. otherwise, swap token0 and token1 to debt asset using swapPaths\n            uint256 amountOutFrom0 = token0 == params.underlying ? amount0 : 0;\n            uint256 amountOutFrom1 = token1 == params.underlying ? amount1 : 0;\n\n            if (amountOutFrom0 == 0 && params.swapPath0.length > 0) amountOutFrom0 = _swap(params.swapPath0, amount0);\n            if (amountOutFrom1 == 0 && params.swapPath1.length > 0) amountOutFrom1 = _swap(params.swapPath1, amount1);\n\n            // total amount of debtAsset we've collected to use towards repay\n            amountOutTotal = amountOutFrom0.add(amountOutFrom1);\n        }\n\n        require(\n            amountOutTotal > params.repayAmount,\n            \"not enough liquidity burned: Repay debt must repay repayAmount of debt\"\n        );\n\n        // repay the debt for user with new funds\n        IERC20Detailed(params.underlying).approve(address(params.debtCToken), params.repayAmount);\n        uint256 succeeded = CErc20Interface(params.debtCToken).repayBorrowBehalf(msg.sender, params.repayAmount);\n        require(succeeded == 0, \"repay debt did not succeed\");\n        IERC20Detailed(params.underlying).approve(address(params.debtCToken), 0);\n\n        // return remnants to user\n        amountReturned = amountOutTotal > params.repayAmount ? amountOutTotal.sub(params.repayAmount) : 0;\n\n        if (amountReturned > 0) TransferHelper.safeTransfer(params.underlying, msg.sender, amountReturned);\n\n        emit RepayDebt(\n            msg.sender,\n            params.tokenId,\n            params.liquidity,\n            params.debtCToken,\n            params.underlying,\n            params.repayAmount,\n            amountReturned\n        );\n    }\n\n    /*** External View Functions ***/\n\n    /**\n     * @notice gets the length of UserTokens for an account. Allows comptroller to query NFTs for value\n     * @param account The address of the account we want the user tokens length for\n     * @return length The length of the user's userTokens array\n     */\n    function getUserTokensLength(address account) external view override returns (uint256 length) {\n        length = userTokens[account].length;\n    }\n\n    /**\n     * @notice gets the poolAddress for a deposited tokenId\n     * @param tokenId The tokenId to get the poolAddress of\n     * @return poolAddress The address of the pool the token is a deposit of\n     */\n    function getPoolAddress(uint256 tokenId) external view override returns (address poolAddress) {\n        poolAddress = _getPoolAddress(tokenId);\n    }\n\n    /*** Internal Mutator Functions ***/\n\n    /**\n     * @notice Internal function to prepare for a deposit liquidity into a Uni V3 range.\n     *          uses a pool to swap amount0 and amount1 to expectedAmount0 and expectedAmount1.\n     *          uses naive logic, assumes adequate off-chain computation for expectedAmounts\n     *\n     * @param token0 Address of token0\n     * @param token1 Address of token1\n     * @param fee Fee of the pool to swap with\n     * @param expectedAmount0 The amount of token0 that we expect to deposit into a range\n     * @param expectedAmount1 The amount of token1 that we expect to deposit into a range\n     * @param amount0 The amount of token0 that we currently hold and are preparing for deposit (some may be swapped for token1)\n     * @param amount1 The amount of token1 that we currently hold and are preparing for deposit (some may be swapped for token1)\n     * @return newAmount0 Amount of token0 after preparation\n     *         newAmount1 Amount of token1 after preparation\n     */\n    function _prepareForDeposit(\n        address token0,\n        address token1,\n        uint24 fee,\n        uint256 expectedAmount0,\n        uint256 expectedAmount1,\n        uint256 amount0,\n        uint256 amount1\n    ) internal returns (uint256 newAmount0, uint256 newAmount1) {\n        if (expectedAmount0 < amount0) {\n            // have extra token0, trade all of the extra to token1\n            uint256 amountOut = _swap(abi.encodePacked(token0, fee, token1), amount0.sub(expectedAmount0));\n            newAmount0 = expectedAmount0;\n            newAmount1 = amount1.add(amountOut);\n        } else if (expectedAmount1 < amount1) {\n            // have extra of token1, trade all of the extra to token0\n            uint256 amountOut = _swap(abi.encodePacked(token1, fee, token0), amount1.sub(expectedAmount1));\n            newAmount0 = amount0.add(amountOut);\n            newAmount1 = expectedAmount1;\n        } else {\n            newAmount0 = amount0;\n            newAmount1 = amount1;\n        }\n    }\n\n    /**\n     * @notice Executes a swap. Performs necessary approval beforehand, and zeros out afterwards for safety\n     * @param swapPath The path to swap along\n     * @param amount The amount of the first token to swap\n     */\n    function _swap(bytes memory swapPath, uint256 amount) internal returns (uint256 amountOut) {\n        IERC20Detailed(swapPath.toAddress(0)).approve(address(swapRouter), amount);\n        amountOut = swapRouter.exactInput(\n            ISwapRouter.ExactInputParams(swapPath, address(this), block.timestamp + 200, amount, 0)\n        );\n        IERC20Detailed(swapPath.toAddress(0)).approve(address(swapRouter), 0);\n    }\n\n    /**\n     * @notice Increases liquidity of a Uni V3 NFT\n     * @param tokenId The tokenId of the NFT we are depositing liquidity into\n     * @param token0 The address of the first token of the pool\n     * @param token1 The address of the second token of the pool\n     * @param amount0 The amount of token0 that we expect to deposit\n     * @param amount1 The amount of token1 that we expect to deposit\n     * @param amount0Min The min amount of token0 that we are willing to deposit (slippage check)\n     * @param amount1Min The min amount of token1 that we are willing to deposit (slippage check)\n     * @return amountOut0 Amount of token0 deposited into tokenId\n     *         amountOut1 Amount of token1 deposited into tokenId\n     */\n    function _increaseLiquidity(\n        uint256 tokenId,\n        address token0,\n        address token1,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 amount0Min,\n        uint256 amount1Min\n    ) internal returns (uint256 amountOut0, uint256 amountOut1) {\n        IERC20Detailed(token0).approve(address(nonfungiblePositionManager), amount0);\n        IERC20Detailed(token1).approve(address(nonfungiblePositionManager), amount1);\n\n        // deposit liquidity into tokenId\n        (, amountOut0, amountOut1) = nonfungiblePositionManager.increaseLiquidity(\n            INonfungiblePositionManager.IncreaseLiquidityParams(\n                tokenId,\n                amount0,\n                amount1,\n                amount0Min,\n                amount1Min,\n                block.timestamp + 200\n            )\n        );\n\n        IERC20Detailed(token0).approve(address(nonfungiblePositionManager), 0);\n        IERC20Detailed(token1).approve(address(nonfungiblePositionManager), 0);\n    }\n\n    /**\n     * @notice Decreases liquidity of a Uni V3 NFT\n     * @param tokenId The tokenId of the NFT we are decreasing liquidity of\n     * @param liquidity The amount of liquidity that we will be decreasing of tokenId\n     */\n    function _decreaseLiquidity(uint256 tokenId, uint128 liquidity) internal {\n        nonfungiblePositionManager.decreaseLiquidity(\n            INonfungiblePositionManager.DecreaseLiquidityParams(tokenId, liquidity, 0, 0, block.timestamp + 200)\n        );\n    }\n\n    /**\n     * @notice Collects the maximum amount of fees available from the NFT to this contract\n     * @param tokenId The tokenId of the NFT we are collecting fees from\n     */\n    function _collectMax(uint256 tokenId) internal returns (uint256 amount0, uint256 amount1) {\n        (amount0, amount1) = nonfungiblePositionManager.collect(\n            INonfungiblePositionManager.CollectParams(tokenId, address(this), type(uint128).max, type(uint128).max)\n        );\n    }\n\n    /**\n     * @notice mints a fresh Uni V3 NFT on behalf of a user of this contract.\n     *          Ownership of the mint is replaced with this contract, and the new token is then processed as a new token\n     *          in this contract under the user's ownership\n     * @param params NonfungiblePositionManager's MintParams. Acts as a passthrough except for ownership management\n     */\n    function _mint(INonfungiblePositionManager.MintParams memory params)\n        internal\n        returns (\n            uint256 tokenId,\n            uint256 amount0,\n            uint256 amount1\n        )\n    {\n        IERC20Detailed(params.token0).approve(address(nonfungiblePositionManager), params.amount0Desired);\n        IERC20Detailed(params.token1).approve(address(nonfungiblePositionManager), params.amount1Desired);\n\n        (tokenId, , amount0, amount1) = nonfungiblePositionManager.mint(\n            INonfungiblePositionManager.MintParams(\n                params.token0,\n                params.token1,\n                params.fee,\n                params.tickLower,\n                params.tickUpper,\n                params.amount0Desired,\n                params.amount1Desired,\n                params.amount0Min,\n                params.amount1Min,\n                address(this), // replace recipient, and denote owner on deposit entry\n                params.deadline\n            )\n        );\n\n        IERC20Detailed(params.token0).approve(address(nonfungiblePositionManager), 0);\n        IERC20Detailed(params.token1).approve(address(nonfungiblePositionManager), 0);\n\n        // process the token for our internal accounting with the correct recipient\n        _processNewToken(tokenId, params.recipient);\n    }\n\n    /**\n     * @notice burns a Uni V3 NFT on behalf of a user of this contract.\n     *          Manages accounting, deleting user ownership of this token in this contract\n     * @param user Address of the user we are burning the token on behalf of\n     * @param tokenId The Id of the Uni V3 NFT that we are burning\n     */\n    function _burn(address user, uint256 tokenId) internal {\n        _deleteOldToken(user, tokenId);\n        nonfungiblePositionManager.burn(tokenId);\n    }\n\n    /**\n     * @notice processes a new token, checking that the NFT deposit is valid and adding to contract accounting\n     *          on behalf of user\n     * @param tokenId The Id of the Uni V3 NFT being processed\n     * @param account Address of the user we are processing on behalf of\n     */\n    function _processNewToken(uint256 tokenId, address account) internal {\n        require(userTokens[account].length < userTokensMax, \"Cannot process new token: user has too many tokens\");\n        // get poolAddress via helper\n        address poolAddress = _getPoolAddress(tokenId);\n        require(\n            comptroller.isSupportedPool(poolAddress),\n            \"comptroller does not support this pool's liquidity as collateral\"\n        );\n\n        userTokens[account].push(tokenId);\n        ownerOf[tokenId] = account;\n    }\n\n    /**\n     * @notice deletes an old token from internal accounting\n     * @param user Address of the user we are deleting the token on behalf of\n     * @param tokenId The tokenId to be deleted from accounting\n     */\n    function _deleteOldToken(address user, uint256 tokenId) internal {\n        uint256[] memory userTokensArr = userTokens[user];\n        uint256 len = userTokensArr.length;\n        uint256 assetIndex = len;\n\n        for (uint256 i = 0; i < len; i++) {\n            if (userTokensArr[i] == tokenId) {\n                assetIndex = i;\n                break;\n            }\n        }\n\n        // We *must* have found the asset in the list or our redundant data structure is broken\n        assert(assetIndex < len);\n\n        // copy last item in list to location of item to be removed, reduce length by 1\n        uint256[] storage storedList = userTokens[user];\n        storedList[assetIndex] = storedList[storedList.length - 1];\n        storedList.pop();"
    }
  ]
}