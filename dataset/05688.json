{
  "Title": "[01] Dangerous execution path",
  "Content": "\nIn [L1WethBridge, function `deposit`](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/contracts/ethereum/contracts/bridge/L1WethBridge.sol#L143C1-L151C50), and [L1ERC20Bridge, function `deposit`](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/contracts/ethereum/contracts/bridge/L1ERC20Bridge.sol#L161C1-L169C50), some invariants must hold to apply address aliasing to the refund recipient:\n\n1. `_refundRecipient` on L2 = `_refundRecipient` if it is an EOA in L1.\n2. `_refundRecipient` on L2 = `alias(_refundRecipient)` if it is **NOT** an EOA in L1.\n3. `_refundRecipient` on L2 = `msg.sender` if it is an EOA in L1 **AND** `_refundRecipient` is `address(0)`.\n4. `_refundRecipient` on L2 = `alias(msg.sender)` if it is **NOT** an EOA in L1 **AND** `_refundRecipient` is `address(0)`.\n\nFor that, both bridges check 3 and 4 by doing:\n\n```solidity\n        address refundRecipient = _refundRecipient;\nif (_refundRecipient == address(0)) {\nrefundRecipient = msg.sender != tx.origin ? AddressAliasHelper.applyL1ToL2Alias(msg.sender) : msg.sender;\n}\n```\n\n`refundRecipient` is used as an argument to [Mailbox, requestL2Transaction](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L236). The issue is that [Mailbox, requestL2Transaction](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L236) does apply address aliasing too (checks 1 and 2).\n\n[Mailbox, lines 309 to 314](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L309C1-L314C10)\n\n```solidity\n        // If the `_refundRecipient` is not provided, we use the `_sender` as the recipient.\n        address refundRecipient = _refundRecipient == address(0) ? _sender : _refundRecipient;\n        // If the `_refundRecipient` is a smart contract, we apply the L1 to L2 alias to prevent foot guns.\n        if (refundRecipient.code.length > 0) {\n            refundRecipient = AddressAliasHelper.applyL1ToL2Alias(refundRecipient);\n        }\n```\n\nThere is an edge case that breaks our four invariants:\n\n`_refundRecipient` on L2 = `alias(alias(msg.sender))` if `msg.sender` is **NOT** an EOA in L1 **AND** `alias(msg.sender)` is **NOT** an EOA in L1 **and** `_refundRecipient` is `address(0)`.\n\nThis is bad because the excess of gas may be sent to the wrong `_refundRecipient` or, even worst, if a WETH transfer fails on L2, the whole amount transferred. Although **VERY** unlikely to occur (`2^k` execution steps to find a collision), I would remove this possibility from happening by modifying the code in both bridges:\n\n```diff\n         // If the refund recipient is not specified, the refund will be sent to the sender of the transaction.\n         // Otherwise, the refund will be sent to the specified address.\n         // If the recipient is a contract on L1, the address alias will be applied.\n         address refundRecipient = _refundRecipient;\n         if (_refundRecipient == address(0)) {\n-            refundRecipient = msg.sender != tx.origin ? AddressAliasHelper.applyL1ToL2Alias(msg.sender) : msg.sender;\n+            refundRecipient = msg.sender; // it will be aliased by Mailbox if it is a contract and will default to msg.sender if EOA\n        }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-10-zksync",
  "Code": [
    {
      "filename": "code/contracts/ethereum/contracts/bridge/L1WethBridge.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/IL1Bridge.sol\";\nimport \"./interfaces/IL2WethBridge.sol\";\nimport \"./interfaces/IL2Bridge.sol\";\nimport \"./interfaces/IWETH9.sol\";\nimport \"../zksync/interfaces/IZkSync.sol\";\nimport \"../common/interfaces/IAllowList.sol\";\n\nimport \"./libraries/BridgeInitializationHelper.sol\";\n\nimport \"../common/AllowListed.sol\";\nimport \"../common/libraries/UnsafeBytes.sol\";\nimport \"../common/ReentrancyGuard.sol\";\nimport \"../common/libraries/L2ContractHelper.sol\";\nimport {L2_ETH_TOKEN_SYSTEM_CONTRACT_ADDR} from \"../common/L2ContractAddresses.sol\";\nimport \"../vendor/AddressAliasHelper.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @dev This contract is designed to streamline and enhance the user experience\n/// for bridging WETH tokens between L1 and L2 networks. The primary goal of this bridge is to\n/// simplify the process by minimizing the number of transactions required, thus improving\n/// efficiency and user experience.\n/// @dev The default workflow for bridging WETH is performing three separate transactions: unwrap WETH to ETH,\n/// deposit ETH to L2, and wrap ETH to WETH on L2. The `L1WethBridge` reduces this to a single\n/// transaction, enabling users to bridge their WETH tokens directly between L1 and L2 networks.\n/// @dev This contract accepts WETH deposits on L1, unwraps them to ETH, and sends the ETH to the L2\n/// WETH bridge contract, where it is wrapped back into WETH and delivered to the L2 recipient.\n/// @dev For withdrawals, the contract receives ETH from the L2 WETH bridge contract, wraps it into\n/// WETH, and sends the WETH to the L1 recipient.\n/// @dev The `L1WethBridge` contract works in conjunction with its L2 counterpart, `L2WethBridge`.\ncontract L1WethBridge is IL1Bridge, AllowListed, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    /// @dev Event emitted when ETH is received by the contract.\n    event EthReceived(uint256 amount);\n\n    /// @dev The address of the WETH token on L1\n    address payable public immutable l1WethAddress;\n\n    /// @dev The smart contract that manages the list with permission to call contract functions\n    IAllowList public immutable allowList;\n\n    /// @dev zkSync smart contract that is used to operate with L2 via asynchronous L2 <-> L1 communication\n    IZkSync public immutable zkSync;\n\n    /// @dev The address of deployed L2 WETH bridge counterpart\n    address public l2Bridge;\n\n    /// @dev The address of the WETH on L2\n    address public l2WethAddress;\n\n    /// @dev A mapping L2 batch number => message number => flag\n    /// @dev Used to indicate that zkSync L2 -> L1 WETH message was already processed\n    mapping(uint256 => mapping(uint256 => bool)) public isWithdrawalFinalized;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(address payable _l1WethAddress, IZkSync _zkSync, IAllowList _allowList) reentrancyGuardInitializer {\n        l1WethAddress = _l1WethAddress;\n        zkSync = _zkSync;\n        allowList = _allowList;\n    }\n\n    /// @dev Initializes a contract bridge for later use. Expected to be used in the proxy\n    /// @dev During initialization deploys L2 WETH bridge counterpart as well as provides some factory deps for it\n    /// @param _factoryDeps A list of raw bytecodes that are needed for deployment of the L2 WETH bridge\n    /// @notice _factoryDeps[0] == a raw bytecode of L2 WETH bridge implementation\n    /// @notice _factoryDeps[1] == a raw bytecode of proxy that is used as L2 WETH bridge\n    /// @param _l2WethAddress Pre-calculated address of L2 WETH token\n    /// @param _governor Address which can change L2 WETH token implementation and upgrade the bridge\n    /// @param _deployBridgeImplementationFee The fee that will be paid for the L1 -> L2 transaction for deploying L2\n    /// bridge implementation\n    /// @param _deployBridgeProxyFee The fee that will be paid for the L1 -> L2 transaction for deploying L2 bridge\n    /// proxy\n    function initialize(\n        bytes[] calldata _factoryDeps,\n        address _l2WethAddress,\n        address _governor,\n        uint256 _deployBridgeImplementationFee,\n        uint256 _deployBridgeProxyFee\n    ) external payable reentrancyGuardInitializer {\n        require(_l2WethAddress != address(0), \"L2 WETH address cannot be zero\");\n        require(_governor != address(0), \"Governor address cannot be zero\");\n        require(_factoryDeps.length == 2, \"Invalid factory deps length provided\");\n        require(\n            msg.value == _deployBridgeImplementationFee + _deployBridgeProxyFee,\n            \"Miscalculated deploy transactions fees\"\n        );\n\n        l2WethAddress = _l2WethAddress;\n\n        bytes32 l2WethBridgeImplementationBytecodeHash = L2ContractHelper.hashL2Bytecode(_factoryDeps[0]);\n        bytes32 l2WethBridgeProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(_factoryDeps[1]);\n\n        // Deploy L2 bridge implementation contract\n        address wethBridgeImplementationAddr = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeImplementationFee,\n            l2WethBridgeImplementationBytecodeHash,\n            \"\", // Empty constructor data\n            _factoryDeps // All factory deps are needed for L2 bridge\n        );\n\n        // Prepare the proxy constructor data\n        bytes memory l2WethBridgeProxyConstructorData;\n        {\n            // Data to be used in delegate call to initialize the proxy\n            bytes memory proxyInitializationParams = abi.encodeCall(\n                IL2WethBridge.initialize,\n                (address(this), l1WethAddress, _l2WethAddress)\n            );\n            l2WethBridgeProxyConstructorData = abi.encode(\n                wethBridgeImplementationAddr,\n                _governor,\n                proxyInitializationParams\n            );\n        }\n\n        // Deploy L2 bridge proxy contract\n        l2Bridge = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeProxyFee,\n            l2WethBridgeProxyBytecodeHash,\n            l2WethBridgeProxyConstructorData,\n            // No factory deps are needed for L2 bridge proxy, because it is already passed in the previous step\n            new bytes[](0)\n        );\n    }\n\n    /// @notice Initiates a WETH deposit by depositing WETH into the L1 bridge contract, unwrapping it to ETH\n    /// and sending it to the L2 bridge contract where ETH will be wrapped again to WETH and sent to the L2 recipient.\n    /// @param _l2Receiver The account address that should receive WETH on L2\n    /// @param _l1Token The L1 token address which is deposited (needs to be WETH address)\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient's address to eliminate sending funds to addresses\n    /// out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will\n    /// be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be\n    /// sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds\n    /// are controllable through the Mailbox,\n    /// since the Mailbox applies address aliasing to the from address for the L2 tx if the L1 msg.sender is a contract.\n    /// Without address aliasing for L1 contracts as refund recipients they would not be able to make proper L2 tx\n    /// requests\n    /// through the Mailbox to use or withdraw the funds from L2, and the funds would be lost.\n    /// @return txHash The L2 transaction hash of deposit finalization\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable nonReentrant senderCanCallFunction(allowList) returns (bytes32 txHash) {\n        require(_l1Token == l1WethAddress, \"Invalid L1 token address\");\n        require(_amount != 0, \"Amount cannot be zero\");\n\n        // Deposit WETH tokens from the depositor address to the smart contract address\n        IERC20(l1WethAddress).safeTransferFrom(msg.sender, address(this), _amount);\n        // Unwrap WETH tokens (smart contract address receives the equivalent amount of ETH)\n        IWETH9(l1WethAddress).withdraw(_amount);\n\n        // Request the finalization of the deposit on the L2 side\n        bytes memory l2TxCalldata = _getDepositL2Calldata(msg.sender, _l2Receiver, l1WethAddress, _amount);\n\n        // If the refund recipient is not specified, the refund will be sent to the sender of the transaction.\n        // Otherwise, the refund will be sent to the specified address.\n        // If the recipient is a contract on L1, the address alias will be applied.\n        address refundRecipient = _refundRecipient;\n        if (_refundRecipient == address(0)) {\n            refundRecipient = msg.sender != tx.origin ? AddressAliasHelper.applyL1ToL2Alias(msg.sender) : msg.sender;\n        }\n        txHash = zkSync.requestL2Transaction{value: _amount + msg.value}(\n            l2Bridge,\n            _amount,\n            l2TxCalldata,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            new bytes[](0),\n            refundRecipient\n        );\n\n        emit DepositInitiated(txHash, msg.sender, _l2Receiver, _l1Token, _amount);\n    }\n\n    /// @dev Generate a calldata for calling the deposit finalization on the L2 WETH bridge contract\n    function _getDepositL2Calldata(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount\n    ) internal pure returns (bytes memory txCalldata) {\n        txCalldata = abi.encodeCall(\n            IL2Bridge.finalizeDeposit,\n            (_l1Sender, _l2Receiver, _l1Token, _amount, new bytes(0))\n        );\n    }\n\n    /// @notice Withdraw funds from the initiated deposit, that failed when finalizing on L2.\n    /// Note: Refund is performed by sending an equivalent amount of ETH on L2 to the specified deposit refund\n    /// recipient address.\n    function claimFailedDeposit(\n        address, // _depositSender,\n        address, // _l1Token,\n        bytes32, // _l2TxHash\n        uint256, // _l2BatchNumber,\n        uint256, // _l2MessageIndex,\n        uint16, // _l2TxNumberInBatch,\n        bytes32[] calldata // _merkleProof\n    ) external pure {\n        revert(\"Method not supported. Failed deposit funds are sent to the L2 refund recipient address.\");\n    }\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the ETH (WETH) withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the ETH\n    /// withdrawal message containing additional data about WETH withdrawal\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the ETH withdrawal log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant senderCanCallFunction(allowList) {\n        require(!isWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex], \"Withdrawal is already finalized\");\n\n        (address l1WethWithdrawReceiver, uint256 amount) = _parseL2EthWithdrawalMessage(_message);\n\n        // Check if the withdrawal has already been finalized on L2.\n        bool alreadyFinalised = zkSync.isEthWithdrawalFinalized(_l2BatchNumber, _l2MessageIndex);\n        if (alreadyFinalised) {\n            // Check that the specified message was actually sent while withdrawing eth from L2.\n            L2Message memory l2ToL1Message = L2Message({\n                txNumberInBatch: _l2TxNumberInBatch,\n                sender: L2_ETH_TOKEN_SYSTEM_CONTRACT_ADDR,\n                data: _message\n            });\n            bool success = zkSync.proveL2MessageInclusion(_l2BatchNumber, _l2MessageIndex, l2ToL1Message, _merkleProof);\n            require(success, \"vq\");\n        } else {\n            // Finalize the withdrawal if it is not yet done.\n            zkSync.finalizeEthWithdrawal(_l2BatchNumber, _l2MessageIndex, _l2TxNumberInBatch, _message, _merkleProof);\n        }\n\n        // Wrap ETH to WETH tokens (smart contract address receives the equivalent amount of WETH)\n        IWETH9(l1WethAddress).deposit{value: amount}();\n        // Transfer WETH tokens from the smart contract address to the withdrawal receiver\n        IERC20(l1WethAddress).safeTransfer(l1WethWithdrawReceiver, amount);\n\n        isWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex] = true;\n\n        emit WithdrawalFinalized(l1WethWithdrawReceiver, l1WethAddress, amount);\n    }\n\n    /// @dev Decode the ETH withdraw message with additional data about WETH withdrawal that came from L2EthToken\n    /// contract\n    function _parseL2EthWithdrawalMessage(\n        bytes memory _message\n    ) internal view returns (address l1WethReceiver, uint256 ethAmount) {\n        // Check that the message length is correct.\n        // additionalData (WETH withdrawal data): l2 sender address + weth receiver address = 20 + 20 = 40 (bytes)\n        // It should be equal to the length of the function signature + eth receiver address + uint256 amount +\n        // additionalData = 4 + 20 + 32 + 40 = 96 (bytes).\n        require(_message.length == 96, \"Incorrect ETH message with additional data length\");\n\n        (uint32 functionSignature, uint256 offset) = UnsafeBytes.readUint32(_message, 0);\n        require(\n            bytes4(functionSignature) == IMailbox.finalizeEthWithdrawal.selector,\n            \"Incorrect ETH message function selector\"\n        );\n\n        address l1EthReceiver;\n        (l1EthReceiver, offset) = UnsafeBytes.readAddress(_message, offset);\n        require(l1EthReceiver == address(this), \"Wrong L1 ETH withdraw receiver\");\n\n        (ethAmount, offset) = UnsafeBytes.readUint256(_message, offset);\n\n        address l2Sender;\n        (l2Sender, offset) = UnsafeBytes.readAddress(_message, offset);\n        require(l2Sender == l2Bridge, \"The withdrawal was not initiated by L2 bridge\");\n\n        // Parse additional data\n        (l1WethReceiver, offset) = UnsafeBytes.readAddress(_message, offset);\n    }\n\n    /// @return l2Token Address of an L2 token counterpart.\n    function l2TokenAddress(address _l1Token) public view override returns (address l2Token) {\n        l2Token = _l1Token == l1WethAddress ? l2WethAddress : address(0);\n    }\n\n    /// @dev The receive function is called when ETH is sent directly to the contract.\n    receive() external payable {\n        // Expected to receive ether in two cases:\n        // 1. l1 WETH sends ether on `withdraw`\n        // 2. zkSync contract withdraw funds in `finalizeEthWithdrawal`\n        require(msg.sender == l1WethAddress || msg.sender == address(zkSync), \"pn\");\n        emit EthReceived(msg.value);\n    }\n}"
    },
    {
      "filename": "code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport {IMailbox, TxStatus} from \"../interfaces/IMailbox.sol\";\nimport {Merkle} from \"../libraries/Merkle.sol\";\nimport {PriorityQueue, PriorityOperation} from \"../libraries/PriorityQueue.sol\";\nimport {TransactionValidator} from \"../libraries/TransactionValidator.sol\";\nimport {L2Message, L2Log} from \"../Storage.sol\";\nimport {UncheckedMath} from \"../../common/libraries/UncheckedMath.sol\";\nimport {UnsafeBytes} from \"../../common/libraries/UnsafeBytes.sol\";\nimport {L2ContractHelper} from \"../../common/libraries/L2ContractHelper.sol\";\nimport {AddressAliasHelper} from \"../../vendor/AddressAliasHelper.sol\";\nimport {IAllowList} from \"../../common/interfaces/IAllowList.sol\";\nimport {Base} from \"./Base.sol\";\nimport {\n    REQUIRED_L2_GAS_PRICE_PER_PUBDATA,\n    FAIR_L2_GAS_PRICE,\n    L1_GAS_PER_PUBDATA_BYTE,\n    L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH,\n    PRIORITY_OPERATION_L2_TX_TYPE,\n    PRIORITY_EXPIRATION,\n    MAX_NEW_FACTORY_DEPS\n} from \"../Config.sol\";\nimport {\n    L2_BOOTLOADER_ADDRESS,\n    L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR,\n    L2_ETH_TOKEN_SYSTEM_CONTRACT_ADDR\n} from \"../../common/L2ContractAddresses.sol\";\n\n\n/// @title zkSync Mailbox contract providing interfaces for L1 <-> L2 interaction.\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ncontract MailboxFacet is Base, IMailbox {\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n\n    string public constant override getName = \"MailboxFacet\";\n\n    /// @notice Prove that a specific arbitrary-length message was sent in a specific L2 batch number\n    /// @param _batchNumber The executed L2 batch number in which the message appeared\n    /// @param _index The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _message Information about the sent message: sender address, the message itself, tx index in the L2 batch where the message was sent\n    /// @param _proof Merkle proof for inclusion of L2 log that was sent with the message\n    /// @return Whether the proof is valid\n    function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message memory _message,\n        bytes32[] calldata _proof\n    ) public view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _L2MessageToLog(_message), _proof);\n    }\n\n    /// @notice Prove that a specific L2 log was sent in a specific L2 batch\n    /// @param _batchNumber The executed L2 batch number in which the log appeared\n    /// @param _index The position of the l2log in the L2 logs Merkle tree\n    /// @param _log Information about the sent log\n    /// @param _proof Merkle proof for inclusion of the L2 log\n    /// @return Whether the proof is correct and L2 log is included in batch\n    function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _log, _proof);\n    }\n\n    /// @notice Prove that the L1 -> L2 transaction was processed with the specified status.\n    /// @param _l2TxHash The L2 canonical transaction hash\n    /// @param _l2BatchNumber The L2 batch number where the transaction was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction\n    /// @param _status The execution status of the L1 -> L2 transaction (true - success & 0 - fail)\n    /// @return Whether the proof is correct and the transaction was actually executed with provided status\n    /// NOTE: It may return `false` for incorrect proof, but it doesn't mean that the L1 -> L2 transaction has an opposite status!\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) public view override returns (bool) {\n        // Bootloader sends an L2 -> L1 log only after processing the L1 -> L2 transaction.\n        // Thus, we can verify that the L1 -> L2 transaction was included in the L2 batch with specified status.\n        //\n        // The semantics of such L2 -> L1 log is always:\n        // - sender = L2_BOOTLOADER_ADDRESS\n        // - key = hash(L1ToL2Transaction)\n        // - value = status of the processing transaction (1 - success & 0 - fail)\n        // - isService = true (just a conventional value)\n        // - l2ShardId = 0 (means that L1 -> L2 transaction was processed in a rollup shard, other shards are not available yet anyway)\n        // - txNumberInBatch = number of transaction in the batch\n        L2Log memory l2Log = L2Log({\n            l2ShardId: 0,\n            isService: true,\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: L2_BOOTLOADER_ADDRESS,\n            key: _l2TxHash,\n            value: bytes32(uint256(_status))\n        });\n        return _proveL2LogInclusion(_l2BatchNumber, _l2MessageIndex, l2Log, _merkleProof);\n    }\n\n    /// @notice Transfer ether from the contract to the receiver\n    /// @dev Reverts only if the transfer call failed\n    function _withdrawFunds(address _to, uint256 _amount) internal {\n        bool callSuccess;\n        // Low-level assembly call, to avoid any memory copying (save gas)\n        assembly {\n            callSuccess := call(gas(), _to, _amount, 0, 0, 0, 0)\n        }\n        require(callSuccess, \"pz\");\n    }\n\n    /// @dev Prove that a specific L2 log was sent in a specific L2 batch number\n    function _proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) internal view returns (bool) {\n        require(_batchNumber <= s.totalBatchesExecuted, \"xx\");\n\n        bytes32 hashedLog = keccak256(\n            abi.encodePacked(_log.l2ShardId, _log.isService, _log.txNumberInBatch, _log.sender, _log.key, _log.value)\n        );\n        // Check that hashed log is not the default one,\n        // otherwise it means that the value is out of range of sent L2 -> L1 logs\n        require(hashedLog != L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH, \"tw\");\n\n        // It is ok to not check length of `_proof` array, as length\n        // of leaf preimage (which is `L2_TO_L1_LOG_SERIALIZE_SIZE`) is not\n        // equal to the length of other nodes preimages (which are `2 * 32`)\n\n        bytes32 calculatedRootHash = Merkle.calculateRoot(_proof, _index, hashedLog);\n        bytes32 actualRootHash = s.l2LogsRootHashes[_batchNumber];\n\n        return actualRootHash == calculatedRootHash;\n    }\n\n    /// @dev Convert arbitrary-length message to the raw l2 log\n    function _L2MessageToLog(L2Message memory _message) internal pure returns (L2Log memory) {\n        return\n            L2Log({\n                l2ShardId: 0,\n                isService: true,\n                txNumberInBatch: _message.txNumberInBatch,\n                sender: L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR,\n                key: bytes32(uint256(uint160(_message.sender))),\n                value: keccak256(_message.data)\n            });\n    }\n\n    /// @notice Estimates the cost in Ether of requesting execution of an L2 transaction from L1\n    /// @param _gasPrice expected L1 gas price at which the user requests the transaction execution\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount of L2 gas that the operator may charge the user for a single byte of pubdata.\n    /// @return The estimated ETH spent on L2 gas for the transaction\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) public pure returns (uint256) {\n        uint256 l2GasPrice = _deriveL2GasPrice(_gasPrice, _l2GasPerPubdataByteLimit);\n        return l2GasPrice * _l2GasLimit;\n    }\n\n    /// @notice Derives the price for L2 gas in ETH to be paid.\n    /// @param _l1GasPrice The gas price on L1.\n    /// @param _gasPricePerPubdata The price for each pubdata byte in L2 gas\n    /// @return The price of L2 gas in ETH\n    function _deriveL2GasPrice(uint256 _l1GasPrice, uint256 _gasPricePerPubdata) internal pure returns (uint256) {\n        uint256 pubdataPriceETH = L1_GAS_PER_PUBDATA_BYTE * _l1GasPrice;\n        uint256 minL2GasPriceETH = (pubdataPriceETH + _gasPricePerPubdata - 1) / _gasPricePerPubdata;\n\n        return Math.max(FAIR_L2_GAS_PRICE, minL2GasPriceETH);\n    }\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external override nonReentrant senderCanCallFunction(s.allowList) {\n        require(!s.isEthWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex], \"jj\");\n\n        L2Message memory l2ToL1Message = L2Message({\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: L2_ETH_TOKEN_SYSTEM_CONTRACT_ADDR,\n            data: _message\n        });\n\n        (address _l1WithdrawReceiver, uint256 _amount) = _parseL2WithdrawalMessage(_message);\n\n        bool proofValid = proveL2MessageInclusion(_l2BatchNumber, _l2MessageIndex, l2ToL1Message, _merkleProof);\n        require(proofValid, \"pi\"); // Failed to verify that withdrawal was actually initialized on L2\n\n        s.isEthWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex] = true;\n        _withdrawFunds(_l1WithdrawReceiver, _amount);\n\n        emit EthWithdrawalFinalized(_l1WithdrawReceiver, _amount);\n    }\n\n    /// @notice Request execution of L2 transaction from L1.\n    /// @param _contractL2 The L2 receiver address\n    /// @param _l2Value `msg.value` of L2 transaction\n    /// @param _calldata The input of the L2 transaction\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount L2 gas that the operator may charge the user for single byte of pubdata.\n    /// @param _factoryDeps An array of L2 bytecodes that will be marked as known on L2\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient's address to eliminate sending funds to addresses out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds are controllable,\n    /// since address aliasing to the from address for the L2 tx will be applied if the L1 `msg.sender` is a contract.\n    /// Without address aliasing for L1 contracts as refund recipients they would not be able to make proper L2 tx requests\n    /// through the Mailbox to use or withdraw the funds from L2, and the funds would be lost.\n    /// @return canonicalTxHash The hash of the requested L2 transaction. This hash can be used to follow the transaction status\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable nonReentrant senderCanCallFunction(s.allowList) returns (bytes32 canonicalTxHash) {\n        // Change the sender address if it is a smart contract to prevent address collision between L1 and L2.\n        // Please note, currently zkSync address derivation is different from Ethereum one, but it may be changed in the future.\n        address sender = msg.sender;\n        if (sender != tx.origin) {\n            sender = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n        }\n\n        // Enforcing that `_l2GasPerPubdataByteLimit` equals to a certain constant number. This is needed\n        // to ensure that users do not get used to using \"exotic\" numbers for _l2GasPerPubdataByteLimit, e.g. 1-2, etc.\n        // VERY IMPORTANT: nobody should rely on this constant to be fixed and every contract should give their users the ability to provide the\n        // ability to provide `_l2GasPerPubdataByteLimit` for each independent transaction.\n        // CHANGING THIS CONSTANT SHOULD BE A CLIENT-SIDE CHANGE.\n        require(_l2GasPerPubdataByteLimit == REQUIRED_L2_GAS_PRICE_PER_PUBDATA, \"qp\");\n\n        // The L1 -> L2 transaction may be failed and funds will be sent to the `_refundRecipient`,\n        // so we use `msg.value` instead of `_l2Value` as the bridged amount.\n        _verifyDepositLimit(msg.sender, msg.value);\n        canonicalTxHash = _requestL2Transaction(\n            sender,\n            _contractL2,\n            _l2Value,\n            _calldata,\n            _l2GasLimit,\n            _l2GasPerPubdataByteLimit,\n            _factoryDeps,\n            false,\n            _refundRecipient\n        );\n    }\n\n    function _verifyDepositLimit(address _depositor, uint256 _amount) internal {\n        IAllowList.Deposit memory limitData = IAllowList(s.allowList).getTokenDepositLimitData(address(0)); // address(0) denotes the ETH\n        if (!limitData.depositLimitation) return; // no deposit limitation is placed for ETH\n\n        require(s.totalDepositedAmountPerUser[_depositor] + _amount <= limitData.depositCap, \"d2\");\n        s.totalDepositedAmountPerUser[_depositor] += _amount;\n    }\n\n    function _requestL2Transaction(\n        address _sender,\n        address _contractAddressL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        bool _isFree,\n        address _refundRecipient\n    ) internal returns (bytes32 canonicalTxHash) {\n        require(_factoryDeps.length <= MAX_NEW_FACTORY_DEPS, \"uj\");\n        uint64 expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION); // Safe to cast\n        uint256 txId = s.priorityQueue.getTotalPriorityTxs();\n\n        // Here we manually assign fields for the struct to prevent \"stack too deep\" error\n        WritePriorityOpParams memory params;\n\n        // Checking that the user provided enough ether to pay for the transaction.\n        // Using a new scope to prevent \"stack too deep\" error\n        {\n            params.l2GasPrice = _isFree ? 0 : _deriveL2GasPrice(tx.gasprice, _l2GasPerPubdataByteLimit);\n            uint256 baseCost = params.l2GasPrice * _l2GasLimit;\n            require(msg.value >= baseCost + _l2Value, \"mv\"); // The `msg.value` doesn't cover the transaction cost\n        }\n\n        // If the `_refundRecipient` is not provided, we use the `_sender` as the recipient.\n        address refundRecipient = _refundRecipient == address(0) ? _sender : _refundRecipient;\n        // If the `_refundRecipient` is a smart contract, we apply the L1 to L2 alias to prevent foot guns.\n        if (refundRecipient.code.length > 0) {\n            refundRecipient = AddressAliasHelper.applyL1ToL2Alias(refundRecipient);\n        }\n\n        params.sender = _sender;\n        params.txId = txId;\n        params.l2Value = _l2Value;\n        params.contract"
    }
  ]
}