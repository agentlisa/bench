{
  "Title": "[M-17] refresh() will revert on Oracle deprecation, effectively disabling part of the protocol",
  "Content": "# Lines of code\n\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/Asset.sol#L102\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/FiatCollateral.sol#L149\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/OracleLib.sol#L14-L31\n\n\n# Vulnerability details\n\n\n\n\nThe `Asset.refresh()` function calls `tryPrice()` and catches all errors except errors with empty data.\nAs explained in the [docs](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/docs/solidity-style.md#catching-empty-data) the reason empty errors aren't caught is in order to prevent an attacker from failing the `tryPrice()` intentionally by running it out of gas.\nHowever, an error with empty data isn't thrown only in case of out of gas, in the current way that Chainlink deprecates oracles (by setting `aggregator` to the zero address) a deprecated oracle would also throw an empty error.\n\n\n\n## Impact\nAny function that requires refreshing the assets will fail to execute (till the asset is replaced in the asset registry, passing the proposal via governance would usually take 7 days), that includes:\n* Issuance\n* Vesting\n* Redemption\n* Auctions (`manageTokens()`)\n* `StRSR.withdraw()`\n\n## Proof of Concept\n\nThe [docs](https://github.com/reserve-protocol/protocol/blob/d224c14c398d2727d39d133aa7511e1e6b161833/docs/recollateralization.md#:~:text=If%20an%20asset%27s%20oracle%20goes%20offline%20forever%2C%20its%20lotPrice()%20will%20eventually%20reach%20%5B0%2C%200%5D%20and%20the%20protocol%20will%20completely%20stop%20trading%20this%20asset.) imply in case of deprecation the protocol is expected continue to operate:\n> If an asset's oracle goes offline forever, its lotPrice() will eventually reach [0, 0] and the protocol will completely stop trading this asset.\n\nThe [docs](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/docs/collateral.md#refresh-should-never-revert) also clearly state that '`refresh()` should never revert'\n\n\nI've tracked a few Chainlink oracles that were deprecated on the Polygon network on Jan 11, the PoC below tests an `Asset.refresh()` call with a deprecated oracle.\n\n\n\nFile: `test/plugins/Deprecated.test.ts`\n```typescript\nimport { Wallet, ContractFactory } from 'ethers'\nimport { ethers, network, waffle } from 'hardhat'\nimport { IConfig } from '../../common/configuration'\nimport { bn, fp } from '../../common/numbers'\nimport {\n  Asset,\n  ATokenFiatCollateral,\n  CTokenFiatCollateral,\n  CTokenMock,\n  ERC20Mock,\n  FiatCollateral,\n  IAssetRegistry,\n  RTokenAsset,\n  StaticATokenMock,\n  TestIBackingManager,\n  TestIRToken,\n  USDCMock,\n} from '../../typechain'\nimport {\n  Collateral,\n  defaultFixture,\n} from '../fixtures'\n\nconst createFixtureLoader = waffle.createFixtureLoader\n\n\ndescribe('Assets contracts #fast', () => {\n  // Tokens\n  let rsr: ERC20Mock\n  let compToken: ERC20Mock\n  let aaveToken: ERC20Mock\n  let rToken: TestIRToken\n  let token: ERC20Mock\n  let usdc: USDCMock\n  let aToken: StaticATokenMock\n  let cToken: CTokenMock\n\n  // Assets\n  let collateral0: FiatCollateral\n  let collateral1: FiatCollateral\n  let collateral2: ATokenFiatCollateral\n  let collateral3: CTokenFiatCollateral\n\n  // Assets\n  let rsrAsset: Asset\n  let compAsset: Asset\n  let aaveAsset: Asset\n  let rTokenAsset: RTokenAsset\n  let basket: Collateral[]\n\n  // Config\n  let config: IConfig\n\n  // Main\n  let loadFixture: ReturnType<typeof createFixtureLoader>\n  let wallet: Wallet\n  let assetRegistry: IAssetRegistry\n  let backingManager: TestIBackingManager\n\n  // Factory\n  let AssetFactory: ContractFactory\n  let RTokenAssetFactory: ContractFactory\n\n  const amt = fp('1e4')\n\n  before('create fixture loader', async () => {\n    ;[wallet] = (await ethers.getSigners()) as unknown as Wallet[]\n    loadFixture = createFixtureLoader([wallet])\n  })\n\n  beforeEach(async () => {\n    // Deploy fixture\n    ;({\n      rsr,\n      rsrAsset,\n      compToken,\n      compAsset,\n      aaveToken,\n      aaveAsset,\n      basket,\n      assetRegistry,\n      backingManager,\n      config,\n      rToken,\n      rTokenAsset,\n    } = await loadFixture(defaultFixture))\n\n    // Get collateral tokens\n    collateral0 = <FiatCollateral>basket[0]\n    collateral1 = <FiatCollateral>basket[1]\n    collateral2 = <ATokenFiatCollateral>basket[2]\n    collateral3 = <CTokenFiatCollateral>basket[3]\n    token = <ERC20Mock>await ethers.getContractAt('ERC20Mock', await collateral0.erc20())\n    usdc = <USDCMock>await ethers.getContractAt('USDCMock', await collateral1.erc20())\n    aToken = <StaticATokenMock>(\n      await ethers.getContractAt('StaticATokenMock', await collateral2.erc20())\n    )\n    cToken = <CTokenMock>await ethers.getContractAt('CTokenMock', await collateral3.erc20())\n\n    await rsr.connect(wallet).mint(wallet.address, amt)\n    await compToken.connect(wallet).mint(wallet.address, amt)\n    await aaveToken.connect(wallet).mint(wallet.address, amt)\n\n    // Issue RToken to enable RToken.price\n    for (let i = 0; i < basket.length; i++) {\n      const tok = await ethers.getContractAt('ERC20Mock', await basket[i].erc20())\n      await tok.connect(wallet).mint(wallet.address, amt)\n      await tok.connect(wallet).approve(rToken.address, amt)\n    }\n    await rToken.connect(wallet)['issue(uint256)'](amt)\n\n    AssetFactory = await ethers.getContractFactory('Asset')\n    RTokenAssetFactory = await ethers.getContractFactory('RTokenAsset')\n  })\n\n  describe('Deployment', () => {\n    it('Deployment should setup assets correctly', async () => {\n\n        console.log(network.config.chainId);\n        // let validOracle = '0x443C5116CdF663Eb387e72C688D276e702135C87';\n        let deprecatedOracle = '0x2E5B04aDC0A3b7dB5Fd34AE817c7D0993315A8a6';\n        let priceTimeout_ = await aaveAsset.priceTimeout(),\n         chainlinkFeed_ = deprecatedOracle,\n         oracleError_ = await aaveAsset.oracleError(),\n         erc20_ = await aaveAsset.erc20(),\n         maxTradeVolume_ = await aaveAsset.maxTradeVolume(),\n         oracleTimeout_ = await aaveAsset.oracleTimeout();\n        \n        aaveAsset = await AssetFactory.deploy(priceTimeout_,\n            chainlinkFeed_ ,\n            oracleError_ ,\n            erc20_ ,\n            maxTradeVolume_ ,\n            oracleTimeout_  ) as Asset;\n\n        await aaveAsset.refresh();\n      \n    })\n  })\n\n})\n\n```\n\nModification of `hardhat.config.ts` to set it to the Polygon network:\n```diff\ndiff --git a/hardhat.config.ts b/hardhat.config.ts\nindex f1886d25..53565799 100644\n--- a/hardhat.config.ts\n+++ b/hardhat.config.ts\n@@ -24,18 +24,19 @@ const TIMEOUT = useEnv('SLOW') ? 3_000_000 : 300_000\n const src_dir = `./contracts/${useEnv('PROTO')}`\n const settings = useEnv('NO_OPT') ? {} : { optimizer: { enabled: true, runs: 200 } }\n \n+let recentBlockNumber = 38231040;\n+let jan6Block = 37731612; // causes 'missing trie node' error\n+\n const config: HardhatUserConfig = {\n   defaultNetwork: 'hardhat',\n   networks: {\n     hardhat: {\n       // network for tests/in-process stuff\n-      forking: useEnv('FORK')\n-        ? {\n-            url: MAINNET_RPC_URL,\n-            blockNumber: Number(useEnv('MAINNET_BLOCK', forkBlockNumber['default'].toString())),\n-          }\n-        : undefined,\n-      gas: 0x1ffffffff,\n+      forking: {\n+          url: \"https://rpc.ankr.com/polygon\",\n+          // blockNumber: recentBlockNumber\n+          },\n+          gas: 0x1ffffffff,\n       blockGasLimit: 0x1fffffffffffff,\n       allowUnlimitedContractSize: true,\n     },\n```\n\nOutput:\n```\n  1) Assets contracts #fast\n       Deployment\n         Deployment should setup assets correctly:\n     Error: Transaction reverted without a reason string\n    at Asset.refresh (contracts/plugins/assets/Asset.sol:102)\n    at processTicksAndRejections (node:internal/process/task_queues:95:5)\n    at async HardhatNode._mineBlockWithPendingTxs (node_modules/hardhat/src/internal/hardhat-network/provider/node.ts:1802:23)\n    at async HardhatNode.mineBlock (node_modules/hardhat/src/internal/hardhat-network/provider/node.ts:491:16)\n    at async EthModule._sendTransactionAndReturnHash (node_modules/hardhat/src/internal/hardhat-network/provider/modules/eth.ts:1522:18)\n    at async HardhatNetworkProvider.request (node_modules/hardhat/src/internal/hardhat-network/provider/provider.ts:118:18)\n    at async EthersProviderWrapper.send (node_modules/@nomiclabs/hardhat-ethers/src/internal/ethers-provider-wrapper.ts:13:20)\n```\n\nNotes:\n* Chainlink list deprecating oracles only till deprecation, afterwards they're removed from the website. For this reason I wasn't able to trace deprecated oracles on the mainnet\n* I was trying to prove this worked before deprecation, however, I kept getting the 'missing trie node' error when forking the older block. This isn't essential for the PoC so I decided to give up on it for now (writing this PoC was hard enough on its own).\n\n## Recommended Mitigation Steps\nAt `OracleLib.price()` catch the error and check if the error data is empty and the aggregator is set to the zero address, if it is a revert with a custom error. Otherwise revert with the original error data (this can be done with assembly).\nAnother approach might be to check in the `refresh()` function that the `tryPrice()` function didn't revert due to out of gas error by checking the gas before and after (in case of out of gas error only ~1/64 of the gas-before would be left). The advantage of this approach is that it would catch also other errors that might revert with empty data.",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-01-reserve-contest",
  "Code": [
    {
      "filename": "contracts/plugins/assets/Asset.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.9;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../../interfaces/IAsset.sol\";\nimport \"./OracleLib.sol\";\n\ncontract Asset is IAsset {\n    using FixLib for uint192;\n    using OracleLib for AggregatorV3Interface;\n\n    AggregatorV3Interface public immutable chainlinkFeed; // {UoA/tok}\n\n    IERC20Metadata public immutable erc20;\n\n    uint8 public immutable erc20Decimals;\n\n    uint192 public immutable override maxTradeVolume; // {UoA}\n\n    uint48 public immutable oracleTimeout; // {s} Seconds that an oracle value is considered valid\n\n    uint192 public immutable oracleError; // {1} The max % deviation allowed by the oracle\n\n    // === Lot price ===\n\n    uint48 public immutable priceTimeout; // {s} The period over which `savedHighPrice` decays to 0\n\n    uint192 public savedLowPrice; // {UoA/tok} The low price of the token during the last update\n\n    uint192 public savedHighPrice; // {UoA/tok} The high price of the token during the last update\n\n    uint48 public lastSave; // {s} The timestamp when prices were last saved\n\n    /// @param priceTimeout_ {s} The number of seconds over which savedHighPrice decays to 0\n    /// @param chainlinkFeed_ Feed units: {UoA/tok}\n    /// @param oracleError_ {1} The % the oracle feed can be off by\n    /// @param maxTradeVolume_ {UoA} The max trade volume, in UoA\n    /// @param oracleTimeout_ {s} The number of seconds until a oracle value becomes invalid\n    constructor(\n        uint48 priceTimeout_,\n        AggregatorV3Interface chainlinkFeed_,\n        uint192 oracleError_,\n        IERC20Metadata erc20_,\n        uint192 maxTradeVolume_,\n        uint48 oracleTimeout_\n    ) {\n        require(priceTimeout_ > 0, \"price timeout zero\");\n        require(address(chainlinkFeed_) != address(0), \"missing chainlink feed\");\n        require(oracleError_ > 0 && oracleError_ < FIX_ONE, \"oracle error out of range\");\n        require(address(erc20_) != address(0), \"missing erc20\");\n        require(maxTradeVolume_ > 0, \"invalid max trade volume\");\n        require(oracleTimeout_ > 0, \"oracleTimeout zero\");\n        priceTimeout = priceTimeout_;\n        chainlinkFeed = chainlinkFeed_;\n        oracleError = oracleError_;\n        erc20 = erc20_;\n        erc20Decimals = erc20.decimals();\n        maxTradeVolume = maxTradeVolume_;\n        oracleTimeout = oracleTimeout_;\n    }\n\n    /// Can revert, used by other contract functions in order to catch errors\n    /// Should not return FIX_MAX for low\n    /// Should only return FIX_MAX for high if low is 0\n    /// @dev The third (unused) variable is only here for compatibility with Collateral\n    /// @param low {UoA/tok} The low price estimate\n    /// @param high {UoA/tok} The high price estimate\n    function tryPrice()\n        external\n        view\n        virtual\n        returns (\n            uint192 low,\n            uint192 high,\n            uint192\n        )\n    {\n        uint192 p = chainlinkFeed.price(oracleTimeout); // {UoA/tok}\n        uint192 delta = p.mul(oracleError);\n        return (p - delta, p + delta, 0);\n    }\n\n    /// Should not revert\n    /// Refresh saved prices\n    function refresh() public virtual override {\n        try this.tryPrice() returns (uint192 low, uint192 high, uint192) {\n            // {UoA/tok}, {UoA/tok}\n            // (0, 0) is a valid price; (0, FIX_MAX) is unpriced\n\n            // Save prices if priced\n            if (high < FIX_MAX) {\n                savedLowPrice = low;\n                savedHighPrice = high;\n                lastSave = uint48(block.timestamp);\n            } else {\n                // must be unpriced\n                assert(low == 0);\n            }\n        } catch (bytes memory errData) {\n            // see: docs/solidity-style.md#Catching-Empty-Data\n            if (errData.length == 0) revert(); // solhint-disable-line reason-string\n        }\n    }\n\n    /// Should not revert\n    /// @dev Should be general enough to not need to be overridden\n    /// @return {UoA/tok} The lower end of the price estimate\n    /// @return {UoA/tok} The upper end of the price estimate\n    function price() public view virtual returns (uint192, uint192) {\n        try this.tryPrice() returns (uint192 low, uint192 high, uint192) {\n            assert(low <= high);\n            return (low, high);\n        } catch (bytes memory errData) {\n            // see: docs/solidity-style.md#Catching-Empty-Data\n            if (errData.length == 0) revert(); // solhint-disable-line reason-string\n            return (0, FIX_MAX);\n        }\n    }\n\n    /// Should not revert\n    /// lotLow should be nonzero when the asset might be worth selling\n    /// @dev Should be general enough to not need to be overridden\n    /// @return lotLow {UoA/tok} The lower end of the lot price estimate\n    /// @return lotHigh {UoA/tok} The upper end of the lot price estimate\n    function lotPrice() external view virtual returns (uint192 lotLow, uint192 lotHigh) {\n        try this.tryPrice() returns (uint192 low, uint192 high, uint192) {\n            // if the price feed is still functioning, use that\n            lotLow = low;\n            lotHigh = high;\n        } catch (bytes memory errData) {\n            // see: docs/solidity-style.md#Catching-Empty-Data\n            if (errData.length == 0) revert(); // solhint-disable-line reason-string\n\n            // if the price feed is broken, use a decayed historical value\n\n            uint48 delta = uint48(block.timestamp) - lastSave; // {s}\n            if (delta >= priceTimeout) return (0, 0); // no price after timeout elapses\n\n            // {1} = {s} / {s}\n            uint192 lotMultiplier = divuu(priceTimeout - delta, priceTimeout);\n\n            // {UoA/tok} = {UoA/tok} * {1}\n            lotLow = savedLowPrice.mul(lotMultiplier);\n            lotHigh = savedHighPrice.mul(lotMultiplier);\n        }\n        assert(lotLow <= lotHigh);\n    }\n\n    /// @return {tok} The balance of the ERC20 in whole tokens\n    function bal(address account) external view returns (uint192) {\n        return shiftl_toFix(erc20.balanceOf(account), -int8(erc20Decimals));\n    }\n\n    /// @return If the asset is an instance of ICollateral or not\n    function isCollateral() external pure virtual returns (bool) {\n        return false;\n    }\n\n    // solhint-disable no-empty-blocks\n\n    /// Claim rewards earned by holding a balance of the ERC20 token\n    /// @dev Use delegatecall\n    function claimRewards() external virtual {}\n\n    // solhint-enable no-empty-blocks\n}"
    },
    {
      "filename": "contracts/plugins/assets/FiatCollateral.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../../interfaces/IAsset.sol\";\nimport \"../../libraries/Fixed.sol\";\nimport \"./FiatCollateral.sol\";\nimport \"./Asset.sol\";\nimport \"./OracleLib.sol\";\n\nstruct CollateralConfig {\n    uint48 priceTimeout; // {s} The number of seconds over which saved prices decay\n    AggregatorV3Interface chainlinkFeed; // Feed units: {target/ref}\n    uint192 oracleError; // {1} The % the oracle feed can be off by\n    IERC20Metadata erc20; // The ERC20 of the collateral token\n    uint192 maxTradeVolume; // {UoA} The max trade volume, in UoA\n    uint48 oracleTimeout; // {s} The number of seconds until a oracle value becomes invalid\n    bytes32 targetName; // The bytes32 representation of the target name\n    uint192 defaultThreshold; // {1} A value like 0.05 that represents a deviation tolerance\n    // set defaultThreshold to zero to create SelfReferentialCollateral\n    uint48 delayUntilDefault; // {s} The number of seconds an oracle can mulfunction\n}\n\n/**\n * @title FiatCollateral\n * Parent class for all collateral. Can be extended to support changing refPerToks or non-fiat\n *\n * For: {tok} == {ref}, {ref} != {target}, {target} == {UoA}\n * Can be easily extended by (optionally) re-implementing:\n *   - tryPrice()\n *   - refPerTok()\n *   - targetPerRef()\n *   - claimRewards()\n * Should not have to re-implement any other methods.\n *\n * Can intentionally disable default checks by setting config.defaultThreshold to 0\n */\ncontract FiatCollateral is ICollateral, Asset {\n    using FixLib for uint192;\n    using OracleLib for AggregatorV3Interface;\n\n    // Default Status:\n    // _whenDefault == NEVER: no risk of default (initial value)\n    // _whenDefault > block.timestamp: delayed default may occur as soon as block.timestamp.\n    //                In this case, the asset may recover, reachiving _whenDefault == NEVER.\n    // _whenDefault <= block.timestamp: default has already happened (permanently)\n    uint48 private constant NEVER = type(uint48).max;\n    uint48 private _whenDefault = NEVER;\n\n    uint48 public immutable delayUntilDefault; // {s} e.g 86400\n\n    // targetName: The canonical name of this collateral's target unit.\n    bytes32 public immutable targetName;\n\n    uint192 public immutable pegBottom; // {target/ref} The bottom of the peg\n\n    uint192 public immutable pegTop; // {target/ref} The top of the peg\n\n    // does not become nonzero until after first refresh()\n    uint192 public prevReferencePrice; // previous rate, {ref/tok}\n\n    /// @param config.chainlinkFeed Feed units: {UoA/ref}\n    constructor(CollateralConfig memory config)\n        Asset(\n            config.priceTimeout,\n            config.chainlinkFeed,\n            config.oracleError,\n            config.erc20,\n            config.maxTradeVolume,\n            config.oracleTimeout\n        )\n    {\n        require(config.targetName != bytes32(0), \"targetName missing\");\n        if (config.defaultThreshold > 0) {\n            require(config.delayUntilDefault > 0, \"delayUntilDefault zero\");\n        }\n\n        targetName = config.targetName;\n        delayUntilDefault = config.delayUntilDefault;\n\n        // Cache constants\n        uint192 peg = targetPerRef(); // {target/ref}\n\n        // {target/ref}= {target/ref} * {1}\n        uint192 delta = peg.mul(config.defaultThreshold);\n        pegBottom = peg - delta;\n        pegTop = peg + delta;\n    }\n\n    /// Can revert, used by other contract functions in order to catch errors\n    /// Should not return FIX_MAX for low\n    /// Should only return FIX_MAX for high if low is 0\n    /// @dev Override this when pricing is more complicated than just a single oracle\n    /// @param low {UoA/tok} The low price estimate\n    /// @param high {UoA/tok} The high price estimate\n    /// @param pegPrice {target/ref} The actual price observed in the peg\n    function tryPrice()\n        external\n        view\n        virtual\n        override\n        returns (\n            uint192 low,\n            uint192 high,\n            uint192 pegPrice\n        )\n    {\n        pegPrice = chainlinkFeed.price(oracleTimeout); // {target/ref}\n\n        // {UoA/tok} = {target/ref} * {ref/tok} * {UoA/target} (1)\n        uint192 p = pegPrice.mul(refPerTok());\n        uint192 delta = p.mul(oracleError);\n\n        low = p - delta;\n        high = p + delta;\n    }\n\n    /// Should not revert\n    /// Refresh exchange rates and update default status.\n    /// @dev Should be general enough to not need to be overridden\n    function refresh() public virtual override(Asset, IAsset) {\n        if (alreadyDefaulted()) return;\n        CollateralStatus oldStatus = status();\n\n        // Check for soft default + save lotPrice\n        try this.tryPrice() returns (uint192 low, uint192 high, uint192 pegPrice) {\n            // {UoA/tok}, {UoA/tok}, {target/ref}\n            // (0, 0) is a valid price; (0, FIX_MAX) is unpriced\n\n            // Save prices if priced\n            if (high < FIX_MAX) {\n                savedLowPrice = low;\n                savedHighPrice = high;\n                lastSave = uint48(block.timestamp);\n            } else {\n                // must be unpriced\n                assert(low == 0);\n            }\n\n            // If the price is below the default-threshold price, default eventually\n            // uint192(+/-) is the same as Fix.plus/minus\n            if (pegPrice < pegBottom || pegPrice > pegTop || low == 0) {\n                markStatus(CollateralStatus.IFFY);\n            } else {\n                markStatus(CollateralStatus.SOUND);\n            }\n        } catch (bytes memory errData) {\n            // see: docs/solidity-style.md#Catching-Empty-Data\n            if (errData.length == 0) revert(); // solhint-disable-line reason-string\n            markStatus(CollateralStatus.IFFY);\n        }\n\n        // Check for hard default\n        uint192 referencePrice = refPerTok();\n        // uint192(<) is equivalent to Fix.lt\n        if (referencePrice < prevReferencePrice) {\n            markStatus(CollateralStatus.DISABLED);\n        }\n        prevReferencePrice = referencePrice;\n\n        CollateralStatus newStatus = status();\n        if (oldStatus != newStatus) {\n            emit CollateralStatusChanged(oldStatus, newStatus);\n        }\n    }\n\n    /// @return The collateral's status\n    function status() public view returns (CollateralStatus) {\n        if (_whenDefault == NEVER) {\n            return CollateralStatus.SOUND;\n        } else if (_whenDefault > block.timestamp) {\n            return CollateralStatus.IFFY;\n        } else {\n            return CollateralStatus.DISABLED;\n        }\n    }\n\n    // === Helpers for child classes ===\n\n    function markStatus(CollateralStatus status_) internal {\n        // untestable:\n        //      All calls to markStatus happen exclusively if the collateral is not defaulted\n        if (_whenDefault <= block.timestamp) return; // prevent DISABLED -> SOUND/IFFY\n\n        if (status_ == CollateralStatus.SOUND) {\n            _whenDefault = NEVER;\n        } else if (status_ == CollateralStatus.IFFY) {\n            uint256 sum = block.timestamp + uint256(delayUntilDefault);\n            if (sum >= NEVER) _whenDefault = NEVER;\n            else if (sum < _whenDefault) _whenDefault = uint48(sum);\n            // else: no change to _whenDefault\n            // untested:\n            //      explicit `if` to check DISABLED. else branch will never be hit\n        } else if (status_ == CollateralStatus.DISABLED) {\n            _whenDefault = uint48(block.timestamp);\n        }\n    }\n\n    function alreadyDefaulted() internal view returns (bool) {\n        return _whenDefault <= block.timestamp;\n    }\n\n    function whenDefault() external view returns (uint256) {\n        return _whenDefault;\n    }\n\n    // === End child helpers ===\n\n    /// @return {ref/tok} Quantity of whole reference units per whole collateral tokens\n    function refPerTok() public view virtual returns (uint192) {\n        return FIX_ONE;\n    }\n\n    /// @return {target/ref} Quantity of whole target units per whole reference unit in the peg\n    function targetPerRef() public view virtual returns (uint192) {\n        return FIX_ONE;\n    }\n\n    /// @return If the asset is an instance of ICollateral or not\n    function isCollateral() external pure virtual override(Asset, IAsset) returns (bool) {\n        return true;\n    }\n}"
    },
    {
      "filename": "contracts/plugins/assets/OracleLib.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.9;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"../../libraries/Fixed.sol\";\n\nerror StalePrice();\n\n/// Used by asset plugins to price their collateral\nlibrary OracleLib {\n    /// @dev Use for on-the-fly calculations that should revert\n    /// @param timeout The number of seconds after which oracle values should be considered stale\n    /// @return {UoA/tok}\n    function price(AggregatorV3Interface chainlinkFeed, uint48 timeout)\n        internal\n        view\n        returns (uint192)\n    {\n        (uint80 roundId, int256 p, , uint256 updateTime, uint80 answeredInRound) = chainlinkFeed\n            .latestRoundData();\n\n        if (updateTime == 0 || answeredInRound < roundId) {\n            revert StalePrice();\n        }\n        // Downcast is safe: uint256(-) reverts on underflow; block.timestamp assumed < 2^48\n        uint48 secondsSince = uint48(block.timestamp - updateTime);\n        if (secondsSince > timeout) revert StalePrice();\n\n        // {UoA/tok}\n        return shiftl_toFix(uint256(p), -int8(chainlinkFeed.decimals()));\n    }\n}"
    }
  ]
}