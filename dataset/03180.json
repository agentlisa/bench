{
  "Title": "[L03] Finite, fixed, and unrestricted token paymaster allowance [sample]",
  "Content": "On deployment, the `TokenPaymaster` [assigns the maximum token allowance](https://github.com/eth-infinitism/account-abstraction/blob/8832d6e04b9f4f706f612261c6e46b3f1745d61a/contracts/samples/TokenPaymaster.sol#L31) to its owner. However, there is no mechanism to update the allowance.\n\n\nIn principle, this means the allowance can run out. More plausibly, if ownership is transferred, the old owner will still be able to spend the tokens, and the new owner will not. Consider allowing the owner to refresh their token allowance. Additionally, consider removing the existing allowance when ownership is transferred.\n\n\nMoreover, the paymaster mints a single token unit to ensure the contract balance and total supply is non-zero for more predictable gas accounting. However, the owner can withdraw the contract’s total balance, restoring it to zero. Consider preventing the withdrawal of the last token unit.\n\n\n***Update**: Partially fixed in pull request [#75](https://github.com/eth-infinitism/account-abstraction/pull/75/files). A new `transferOwnership` function was added that sets the old owner’s allowance to 0 when ownership is transferred, and the new owner allowance is the maximum token allowance. This also implicitly allows refreshing a depleted allowance. The suggestion to prevent removal of the last token unit was not implemented. Ethereum Foundation’s comment on this issue:*\n\n\n\n> While we `mint(1)` in the constructor, to make all postOp calls cheaper, we don’t protect against the owner pulling this “last wei”: This is an “optimization” the owner should bear in mind that if the paymaster is depleted, the next transaction will cost the OWNER (not the calling wallet) more to change the balance.\n> \n> \n\n\n*It is worth noting that this analysis assumes the `COST_OF_POST` parameter includes the higher balance-changing cost, so in some sense, the calling wallet always pays the higher cost. Otherwise, it would be possible for the first `_postOp` call (and hence the user operation) to fail when the `TokenPaymaster` contract has zero balance.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/samples/TokenPaymaster.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./SimpleWalletForTokens.sol\";\nimport \"hardhat/console.sol\";\nimport \"../BasePaymaster.sol\";\n/**\n * A sample paymaster that define itself as a token to pay for gas.\n * The paymaster IS the token to use, since a paymaster cannot use an external contract.\n * Also, the exchange rate has to be fixed, since it can't reference an external Uniswap os other exchange contract.\n * subclass should override \"getTokenToEthOutputPrice to provide actual token exchange rate, settable by the owner.\n * Known Limitation: this paymaster is exploitable when put into a batch with multiple ops (of different wallets):\n * - while a single op can't exploit the paymaster (if postOp fails to withdraw the tokens, the user's op is reverted,\n *   and then we know we can withdraw the tokens), multiple ops with different senders (all using this paymaster)\n *   in a batch can withdraw funds from 2nd and further ops, forcing the paymaster itself to pay (from its stake)\n * - Possible workarounds are either use a more complex paymaster scheme (e.g. the DepositPaymaster) or\n *   to whitelist the wallet and the called method-ids.\n */\ncontract TokenPaymaster is BasePaymaster, ERC20 {\n\n    //calculated cost of the postOp\n    uint COST_OF_POST = 15000;\n\n    bytes32 immutable knownWallet;\n\n    constructor(string memory _symbol, EntryPoint _entryPoint) ERC20(_symbol, _symbol) BasePaymaster(_entryPoint) {\n        knownWallet = _knownWallet();\n        //make it non-empty\n        _mint(address (this),1);\n        approve(owner(), type(uint).max);\n    }\n\n    // known wallet construct we support the creation of.\n    function _knownWallet() internal view virtual returns (bytes32) {\n        return keccak256(type(SimpleWallet).creationCode);\n    }\n\n    //helpers for owner, to mint and withdraw tokens.\n    function mintTokens(address recipient, uint amount) external onlyOwner {\n        _mint(recipient, amount);\n    }\n\n    //TODO: this method assumes a fixed ratio of token-to-eth. subclass should override to supply oracle\n    // or a setter.\n    function getTokenToEthOutputPrice(uint valueEth) internal view virtual returns (uint valueToken) {\n        return valueEth / 100;\n    }\n\n    // verify that the user has enough tokens.\n    function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 /*requestId*/, uint requiredPreFund)\n    external view override returns (bytes memory context) {\n        uint tokenPrefund = getTokenToEthOutputPrice(requiredPreFund);\n\n        // make sure that verificationGas is high enough to handle postOp\n        require(userOp.verificationGas > 16000, \"TokenPaymaster: gas too low for postOp\");\n\n        if (userOp.initCode.length != 0) {\n            _validateConstructor(userOp);\n            require(balanceOf(userOp.sender) > tokenPrefund, \"TokenPaymaster: no balance (pre-create)\");\n        } else {\n\n            require(balanceOf(userOp.sender) > tokenPrefund, \"TokenPaymaster: no balance\");\n        }\n\n        return abi.encode(userOp.sender);\n    }\n\n    // when constructing a wallet, validate constructor code and parameters\n    function _validateConstructor(UserOperation calldata userOp) internal virtual view {\n        bytes32 bytecodeHash = keccak256(userOp.initCode[0 : userOp.initCode.length - 64]);\n        require(knownWallet == bytecodeHash, \"TokenPaymaster: unknown wallet constructor\");\n\n        //verify the token constructor params:\n        // first param (of 2) should be our entryPoint\n        bytes32 entryPointParam = bytes32(userOp.initCode[userOp.initCode.length - 64 :]);\n        require(address(uint160(uint256(entryPointParam))) == address(entryPoint), \"wrong paymaster in constructor\");\n\n        //the 2nd parameter is the owner, but we don't need to validate it (it is done in validateUserOp)\n    }\n\n    //actual charge of user.\n    // this method will be called just after the user's TX with mode==OpSucceeded|OpReverted.\n    // BUT: if the user changed its balance in a way that will cause  postOp to revert, then it gets called again, after reverting\n    // the user's TX\n    function _postOp(PostOpMode mode, bytes calldata context, uint actualGasCost) internal override {\n        //we don't really care about the mode, we just pay the gas with the user's tokens.\n        (mode);\n        address sender = abi.decode(context, (address));\n        uint charge = getTokenToEthOutputPrice(actualGasCost + COST_OF_POST);\n        //actualGasCost is known to be no larger than the above requiredPreFund, so the transfer should succeed.\n        _transfer(sender, address(this), charge);\n    }\n}"
    }
  ]
}