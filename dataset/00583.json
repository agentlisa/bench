{
  "Title": "An incorrect collateral value with decimals <> 18",
  "Content": "##### Description\nThe [current code](https://github.com/Threshold-USD/dev/blob/800c6c19e44628dfda3cecaea6eedcb498bf0bf3/packages/contracts/contracts/PriceFeed.sol#L124) in `PriceFeed.sol` is not suitable for the `ERC20` tokens with `decimals`() not equal to 18. If the `decimals`() value is less than 18, the collateral value will be underestimated, which can result in a trove creation failure due to the [`MIN_NET_DEBT`](https://github.com/Threshold-USD/dev/blob/800c6c19e44628dfda3cecaea6eedcb498bf0bf3/packages/contracts/contracts/BorrowerOperations.sol#L588) requirement. On the other hand, in the rare case where `decimals`() is greater than 18, the collateral value will be overestimated, which may allow minting of THUSD with an unreasonably low collateral value.\n\n##### Recommendation\nIt is recommended that the `PriceFeed.sol` contract should rely on the actual `decimals`() value of the `ERC20` token to ensure correct calculations of the collateral value. If no `ERC20` tokens with `decimals`() other than 18 are planned to use, it is recommended to assert the `decimals`() of the `ERC20` token used in the contract is equal to 18.\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "packages/contracts/contracts/PriceFeed.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport \"./Interfaces/IPriceFeed.sol\";\nimport \"./Interfaces/ITellorCaller.sol\";\nimport \"./Dependencies/AggregatorV3Interface.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/CheckContract.sol\";\nimport \"./Dependencies/BaseMath.sol\";\nimport \"./Dependencies/LiquityMath.sol\";\nimport \"./Dependencies/console.sol\";\n\n/*\n* PriceFeed for mainnet deployment, to be connected to Chainlink's live collateral:USD aggregator reference\n* contract, and a wrapper contract TellorCaller, which connects to TellorMaster contract.\n*\n* The PriceFeed uses Chainlink as primary oracle, and Tellor as fallback. It contains logic for\n* switching oracles based on oracle failures, timeouts, and conditions for returning to the primary\n* Chainlink oracle.\n*/\ncontract PriceFeed is Ownable, CheckContract, BaseMath, IPriceFeed {\n\n    string constant public NAME = \"PriceFeed\";\n\n    AggregatorV3Interface public priceAggregator;  // Mainnet Chainlink aggregator\n    ITellorCaller public tellorCaller;  // Wrapper contract that calls the Tellor system\n\n    // Core Liquity contracts\n    address borrowerOperationsAddress;\n    address troveManagerAddress;\n\n    // Use to convert a price answer to an 18-digit precision uint\n    uint256 constant public TARGET_DIGITS = 18;\n    uint256 constant public TELLOR_DIGITS = 6;\n\n    // Maximum time period allowed since Chainlink's latest round data timestamp, beyond which Chainlink is considered frozen.\n    uint256 constant public TIMEOUT = 14400;  // 4 hours: 60 * 60 * 4\n\n    // Maximum deviation allowed between two consecutive Chainlink oracle prices. 18-digit precision.\n    uint256 constant public MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND =  5e17; // 50%\n\n    /*\n    * The maximum relative price difference between two oracle responses allowed in order for the PriceFeed\n    * to return to using the Chainlink oracle. 18-digit precision.\n    */\n    uint256 constant public MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES = 5e16; // 5%\n\n    // The last good price seen from an oracle by Liquity\n    uint256 public lastGoodPrice;\n\n    struct ChainlinkResponse {\n        uint80 roundId;\n        int256 answer;\n        uint256 timestamp;\n        bool success;\n        uint8 decimals;\n    }\n\n    struct TellorResponse {\n        bool ifRetrieve;\n        uint256 value;\n        uint256 timestamp;\n        bool success;\n    }\n\n    enum Status {\n        chainlinkWorking,\n        usingTellorChainlinkUntrusted,\n        bothOraclesUntrusted,\n        usingTellorChainlinkFrozen,\n        usingChainlinkTellorUntrusted\n    }\n\n    // The current status of the PricFeed, which determines the conditions for the next price fetch attempt\n    Status public status;\n\n    event PriceFeedStatusChanged(Status newStatus);\n\n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _priceAggregatorAddress,\n        address _tellorCallerAddress\n    )\n        external\n        onlyOwner\n    {\n        checkContract(_priceAggregatorAddress);\n        checkContract(_tellorCallerAddress);\n\n        priceAggregator = AggregatorV3Interface(_priceAggregatorAddress);\n        tellorCaller = ITellorCaller(_tellorCallerAddress);\n\n        // Explicitly set initial system status\n        status = Status.chainlinkWorking;\n\n        // Get an initial price from Chainlink to serve as first reference for lastGoodPrice\n        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();\n        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(chainlinkResponse.roundId, chainlinkResponse.decimals);\n\n        require(!_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse) && !_chainlinkIsFrozen(chainlinkResponse),\n            \"PriceFeed: Chainlink must be working and current\");\n\n        _storeChainlinkPrice(chainlinkResponse);\n\n        _renounceOwnership();\n    }\n\n    // --- Functions ---\n\n    /*\n    * fetchPrice():\n    * Returns the latest price obtained from the Oracle. Called by Liquity functions that require a current price.\n    *\n    * Also callable by anyone externally.\n    *\n    * Non-view function - it stores the last good price seen by Liquity.\n    *\n    * Uses a main oracle (Chainlink) and a fallback oracle (Tellor) in case Chainlink fails. If both fail,\n    * it uses the last good price seen by Liquity.\n    *\n    */\n    function fetchPrice() external override returns (uint) {\n        // Get current and previous price data from Chainlink, and current price data from Tellor\n        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();\n        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(chainlinkResponse.roundId, chainlinkResponse.decimals);\n        TellorResponse memory tellorResponse = _getCurrentTellorResponse();\n\n        // --- CASE 1: System fetched last price from Chainlink  ---\n        if (status == Status.chainlinkWorking) {\n            // If Chainlink is broken, try Tellor\n            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {\n                // If Tellor is broken then both oracles are untrusted, so return the last good price\n                if (_tellorIsBroken(tellorResponse)) {\n                    _changeStatus(Status.bothOraclesUntrusted);\n                    return lastGoodPrice;\n                }\n                /*\n                * If Tellor is only frozen but otherwise returning valid data, return the last good price.\n                * Tellor may need to be tipped to return current data.\n                */\n                if (_tellorIsFrozen(tellorResponse)) {\n                    _changeStatus(Status.usingTellorChainlinkUntrusted);\n                    return lastGoodPrice;\n                }\n\n                // If Chainlink is broken and Tellor is working, switch to Tellor and return current Tellor price\n                _changeStatus(Status.usingTellorChainlinkUntrusted);\n                return _storeTellorPrice(tellorResponse);\n            }\n\n            // If Chainlink is frozen, try Tellor\n            if (_chainlinkIsFrozen(chainlinkResponse)) {\n                // If Tellor is broken too, remember Tellor broke, and return last good price\n                if (_tellorIsBroken(tellorResponse)) {\n                    _changeStatus(Status.usingChainlinkTellorUntrusted);\n                    return lastGoodPrice;\n                }\n\n                // If Tellor is frozen or working, remember Chainlink froze, and switch to Tellor\n                _changeStatus(Status.usingTellorChainlinkFrozen);\n\n                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}\n\n                // If Tellor is working, use it\n                return _storeTellorPrice(tellorResponse);\n            }\n\n            // If Chainlink price has changed by > 50% between two consecutive rounds, compare it to Tellor's price\n            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {\n                // If Tellor is broken, both oracles are untrusted, and return last good price\n                 if (_tellorIsBroken(tellorResponse)) {\n                    _changeStatus(Status.bothOraclesUntrusted);\n                    return lastGoodPrice;\n                }\n\n                // If Tellor is frozen, switch to Tellor and return last good price\n                if (_tellorIsFrozen(tellorResponse)) {\n                    _changeStatus(Status.usingTellorChainlinkUntrusted);\n                    return lastGoodPrice;\n                }\n\n                /*\n                * If Tellor is live and both oracles have a similar price, conclude that Chainlink's large price deviation between\n                * two consecutive rounds was likely a legitmate market price movement, and so continue using Chainlink\n                */\n                if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {\n                    return _storeChainlinkPrice(chainlinkResponse);\n                }\n\n                // If Tellor is live but the oracles differ too much in price, conclude that Chainlink's initial price deviation was\n                // an oracle failure. Switch to Tellor, and use Tellor price\n                _changeStatus(Status.usingTellorChainlinkUntrusted);\n                return _storeTellorPrice(tellorResponse);\n            }\n\n            // If Chainlink is working and Tellor is broken, remember Tellor is broken\n            if (_tellorIsBroken(tellorResponse)) {\n                _changeStatus(Status.usingChainlinkTellorUntrusted);\n            }\n\n            // If Chainlink is working, return Chainlink current price (no status change)\n            return _storeChainlinkPrice(chainlinkResponse);\n        }\n\n        // --- CASE 2: The system fetched last price from Tellor ---\n        if (status == Status.usingTellorChainlinkUntrusted) {\n            // If both Tellor and Chainlink are live, unbroken, and reporting similar prices, switch back to Chainlink\n            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {\n                _changeStatus(Status.chainlinkWorking);\n                return _storeChainlinkPrice(chainlinkResponse);\n            }\n\n            if (_tellorIsBroken(tellorResponse)) {\n                _changeStatus(Status.bothOraclesUntrusted);\n                return lastGoodPrice;\n            }\n\n            /*\n            * If Tellor is only frozen but otherwise returning valid data, just return the last good price.\n            * Tellor may need to be tipped to return current data.\n            */\n            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}\n\n            // Otherwise, use Tellor price\n            return _storeTellorPrice(tellorResponse);\n        }\n\n        // --- CASE 3: Both oracles were untrusted at the last price fetch ---\n        if (status == Status.bothOraclesUntrusted) {\n            /*\n            * If both oracles are now live, unbroken and similar price, we assume that they are reporting\n            * accurately, and so we switch back to Chainlink.\n            */\n            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {\n                _changeStatus(Status.chainlinkWorking);\n                return _storeChainlinkPrice(chainlinkResponse);\n            }\n\n            // Otherwise, return the last good price - both oracles are still untrusted (no status change)\n            return lastGoodPrice;\n        }\n\n        // --- CASE 4: Using Tellor, and Chainlink is frozen ---\n        if (status == Status.usingTellorChainlinkFrozen) {\n            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {\n                // If both Oracles are broken, return last good price\n                if (_tellorIsBroken(tellorResponse)) {\n                    _changeStatus(Status.bothOraclesUntrusted);\n                    return lastGoodPrice;\n                }\n\n                // If Chainlink is broken, remember it and switch to using Tellor\n                _changeStatus(Status.usingTellorChainlinkUntrusted);\n\n                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}\n\n                // If Tellor is working, return Tellor current price\n                return _storeTellorPrice(tellorResponse);\n            }\n\n            if (_chainlinkIsFrozen(chainlinkResponse)) {\n                // if Chainlink is frozen and Tellor is broken, remember Tellor broke, and return last good price\n                if (_tellorIsBroken(tellorResponse)) {\n                    _changeStatus(Status.usingChainlinkTellorUntrusted);\n                    return lastGoodPrice;\n                }\n\n                // If both are frozen, just use lastGoodPrice\n                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}\n\n                // if Chainlink is frozen and Tellor is working, keep using Tellor (no status change)\n                return _storeTellorPrice(tellorResponse);\n            }\n\n            // if Chainlink is live and Tellor is broken, remember Tellor broke, and return Chainlink price\n            if (_tellorIsBroken(tellorResponse)) {\n                _changeStatus(Status.usingChainlinkTellorUntrusted);\n                return _storeChainlinkPrice(chainlinkResponse);\n            }\n\n             // If Chainlink is live and Tellor is frozen, just use last good price (no status change) since we have no basis for comparison\n            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}\n\n            // If Chainlink is live and Tellor is working, compare prices. Switch to Chainlink\n            // if prices are within 5%, and return Chainlink price.\n            if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {\n                _changeStatus(Status.chainlinkWorking);\n                return _storeChainlinkPrice(chainlinkResponse);\n            }\n\n            // Otherwise if Chainlink is live but price not within 5% of Tellor, distrust Chainlink, and return Tellor price\n            _changeStatus(Status.usingTellorChainlinkUntrusted);\n            return _storeTellorPrice(tellorResponse);\n        }\n\n        // --- CASE 5: Using Chainlink, Tellor is untrusted ---\n        if (status == Status.usingChainlinkTellorUntrusted) {\n            // If Chainlink breaks, now both oracles are untrusted\n            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {\n                _changeStatus(Status.bothOraclesUntrusted);\n                return lastGoodPrice;\n            }\n\n            // If Chainlink is frozen, return last good price (no status change)\n            if (_chainlinkIsFrozen(chainlinkResponse)) {\n                return lastGoodPrice;\n            }\n\n            // If Chainlink and Tellor are both live, unbroken and similar price, switch back to chainlinkWorking and return Chainlink price\n            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {\n                _changeStatus(Status.chainlinkWorking);\n                return _storeChainlinkPrice(chainlinkResponse);\n            }\n\n            // If Chainlink is live but deviated >50% from it's previous price and Tellor is still untrusted, switch\n            // to bothOraclesUntrusted and return last good price\n            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {\n                _changeStatus(Status.bothOraclesUntrusted);\n                return lastGoodPrice;\n            }\n\n            // Otherwise if Chainlink is live and deviated <50% from it's previous price and Tellor is still untrusted,\n            // return Chainlink price (no status change)\n            return _storeChainlinkPrice(chainlinkResponse);\n        }\n        return lastGoodPrice;\n    }\n\n    // --- Helper functions ---\n\n    /* Chainlink is considered broken if its current or previous round data is in any way bad. We check the previous round\n    * for two reasons:\n    *\n    * 1) It is necessary data for the price deviation check in case 1,\n    * and\n    * 2) Chainlink is the PriceFeed's preferred primary oracle - having two consecutive valid round responses adds\n    * peace of mind when using or returning to Chainlink.\n    */\n    function _chainlinkIsBroken(ChainlinkResponse memory _currentResponse, ChainlinkResponse memory _prevResponse) internal view returns (bool) {\n        return _badChainlinkResponse(_currentResponse) || _badChainlinkResponse(_prevResponse);\n    }\n\n    function _badChainlinkResponse(ChainlinkResponse memory _response) internal view returns (bool) {\n         // Check for response call reverted\n        if (!_response.success) {return true;}\n        // Check for an invalid roundId that is 0\n        if (_response.roundId == 0) {return true;}\n        // Check for an invalid timeStamp that is 0, or in the future\n        if (_response.timestamp == 0 || _response.timestamp > block.timestamp) {return true;}\n        // Check for non-positive price\n        if (_response.answer <= 0) {return true;}\n\n        return false;\n    }\n\n    function _chainlinkIsFrozen(ChainlinkResponse memory _response) internal view returns (bool) {\n        return block.timestamp - _response.timestamp > TIMEOUT;\n    }\n\n    function _chainlinkPriceChangeAboveMax(ChainlinkResponse memory _currentResponse, ChainlinkResponse memory _prevResponse) internal pure returns (bool) {\n        uint256 currentScaledPrice = _scaleChainlinkPriceByDigits(uint256(_currentResponse.answer), _currentResponse.decimals);\n        uint256 prevScaledPrice = _scaleChainlinkPriceByDigits(uint256(_prevResponse.answer), _prevResponse.decimals);\n\n        uint256 minPrice = LiquityMath._min(currentScaledPrice, prevScaledPrice);\n        uint256 maxPrice = LiquityMath._max(currentScaledPrice, prevScaledPrice);\n\n        /*\n        * Use the larger price as the denominator:\n        * - If price decreased, the percentage deviation is in relation to the the previous price.\n        * - If price increased, the percentage deviation is in relation to the current price.\n        */\n        uint256 percentDeviation = (maxPrice - minPrice) * DECIMAL_PRECISION / maxPrice;\n\n        // Return true if price has more than doubled, or more than halved.\n        return percentDeviation > MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND;\n    }\n\n    function _tellorIsBroken(TellorResponse memory _response) internal view returns (bool) {\n        // Check for response call reverted\n        if (!_response.success) {return true;}\n        // Check for an invalid timeStamp that is 0, or in the future\n        if (_response.timestamp == 0 || _response.timestamp > block.timestamp) {return true;}\n        // Check for zero price\n        if (_response.value == 0) {return true;}\n\n        return false;\n    }\n\n     function _tellorIsFrozen(TellorResponse  memory _tellorResponse) internal view returns (bool) {\n        return block.timestamp - _tellorResponse.timestamp > TIMEOUT;\n    }\n\n    function _bothOraclesLiveAndUnbrokenAndSimilarPrice\n    (\n        ChainlinkResponse memory _chainlinkResponse,\n        ChainlinkResponse memory _prevChainlinkResponse,\n        TellorResponse memory _tellorResponse\n    )\n        internal\n        view\n        returns (bool)\n    {\n        // Return false if either oracle is broken or frozen\n        if\n        (\n            _tellorIsBroken(_tellorResponse) ||\n            _tellorIsFrozen(_tellorResponse) ||\n            _chainlinkIsBroken(_chainlinkResponse, _prevChainlinkResponse) ||\n            _chainlinkIsFrozen(_chainlinkResponse)\n        )\n        {\n            return false;\n        }\n\n        return _bothOraclesSimilarPrice(_chainlinkResponse, _tellorResponse);\n    }\n\n    function _bothOraclesSimilarPrice( ChainlinkResponse memory _chainlinkResponse, TellorResponse memory _tellorResponse) internal pure returns (bool) {\n        uint256 scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(_chainlinkResponse.answer), _chainlinkResponse.decimals);\n        uint256 scaledTellorPrice = _scaleTellorPriceByDigits(_tellorResponse.value);\n\n        // Get the relative price difference between the oracles. Use the lower price as the denominator, i.e. the reference for the calculation.\n        uint256 minPrice = LiquityMath._min(scaledTellorPrice, scaledChainlinkPrice);\n        uint256 maxPrice = LiquityMath._max(scaledTellorPrice, scaledChainlinkPrice);\n        uint256 percentPriceDifference = (maxPrice - minPrice) * DECIMAL_PRECISION / minPrice;\n\n        /*\n        * Return true if the relative price difference is <= 3%: if so, we assume both oracles are probably reporting\n        * the honest market price, as it is unlikely that both have been broken/hacked and are still in-sync.\n        */\n        return percentPriceDifference <= MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES;\n    }\n\n    function _scaleChainlinkPriceByDigits(uint256 _price, uint256 _answerDigits) internal pure returns (uint) {\n        /*\n        * Convert the price returned by the Chainlink oracle to an 18-digit decimal for use by Liquity.\n        * At date of Liquity launch, Chainlink uses an 8-digit price, but we also handle the possibility of\n        * future changes.\n        *\n        */\n        uint256 price;\n        if (_answerDigits >= TARGET_DIGITS) {\n            // Scale the returned price value down to Liquity's target precision\n            price = _price / (10 ** (_answerDigits - TARGET_DIGITS));\n        }\n        else if (_answerDigits < TARGET_DIGITS) {\n            // Scale the returned price value up to Liquity's target precision\n            price = _price * (10 ** (TARGET_DIGITS - _answerDigits));\n        }\n        return price;\n    }\n\n    function _scaleTellorPriceByDigits(uint256 _price) internal pure returns (uint) {\n        return _price * (10**(TARGET_DIGITS - TELLOR_DIGITS));\n    }\n\n    function _changeStatus(Status _status) internal {\n        status = _status;\n        emit PriceFeedStatusChanged(_status);\n    }\n\n    function _storePrice(uint256 _currentPrice) internal {\n        lastGoodPrice = _currentPrice;\n        emit LastGoodPriceUpdated(_currentPrice);\n    }\n\n     function _storeTellorPrice(TellorResponse memory _tellorResponse) internal returns (uint) {\n        uint256 scaledTellorPrice = _scaleTellorPriceByDigits(_tellorResponse.value);\n        _storePrice(scaledTellorPrice);\n\n        return scaledTellorPrice;\n    }\n\n    function _storeChainlinkPrice(ChainlinkResponse memory _chainlinkResponse) internal returns (uint) {\n        uint256 scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(_chainlinkResponse.answer), _chainlinkResponse.decimals);\n        _storePrice(scaledChainlinkPrice);\n\n        return scaledChainlinkPrice;\n    }\n\n    // --- Oracle response wrapper functions ---\n\n    function _getCurrentTellorResponse() internal view returns (TellorResponse memory tellorResponse) {\n        try tellorCaller.getTellorCurrentValue() returns\n        (\n            bool ifRetrieve,\n            uint256 value,\n            uint256 _timestampRetrieved\n        )\n        {\n            // If call to Tellor succeeds, return the response and success = true\n            tellorResponse.ifRetrieve = ifRetrieve;\n            tellorResponse.value = value;\n            tellorResponse.timestamp = _timestampRetrieved;\n            tellorResponse.success = true;\n\n            return (tellorResponse);\n        }catch {\n             // If call to Tellor reverts, return a zero response with success = false\n            return (tellorResponse);\n        }\n    }\n\n    function _getCurrentChainlinkResponse() internal view returns (ChainlinkResponse memory chainlinkResponse) {\n        // First, try to get current decimal precision:\n        try priceAggregator.decimals() returns (uint8 decimals) {\n            // If call to Chainlink succeeds, record the current decimal precision\n            chainlinkResponse.decimals = decimals;\n        } catch {\n            // If call to Chainlink aggregator reverts, return a zero response with success = false\n            return chainlinkResponse;\n        }\n\n        // Secondly, try to get latest price data:\n        try priceAggregator.latestRoundData() returns\n        (\n            uint80 roundId,\n            int256 answer,\n            uint256 /* startedAt */,\n            uint256 timestamp,\n            uint80 /* answeredInRound */\n        )\n        {\n            // If call to Chainlink succeeds, return the response and success = true\n            chainlinkResponse.roundId = roundId;\n            chainlinkResponse.answer = answer;\n            chainlinkResponse.timestamp = timestamp;\n            chainlinkResponse.success = true;\n            return chainlinkResponse;\n        } catch {\n            // If call to Chainlink aggregator reverts, return a zero response with success = false\n            return chainlinkResponse;\n        }\n    }\n\n    function _getPrevChainlinkResponse(uint80 _currentRoundId, uint8 _currentDecimals) internal view returns (ChainlinkResponse memory prevChainlinkResponse) {\n        /*\n        * NOTE: Chainlink only offers a current decimals() value - there is no way to obtain the decimal precision used in a\n        * previous round.  We assume the decimals used in the previous round are the same as the current round.\n        */\n        if (_currentRoundId == 0) {\n      \t\t\treturn prevChainlinkResponse;\n    \t\t}\n        // Try to get the price data from the previous round:\n        try priceAggregator.getRoundData(_currentRoundId - 1) returns\n        (\n            uint80 roundId,\n            int256 answer,\n            uint256 /* startedAt */,\n            uint256 timestamp,\n            uint80 /* answeredInRound */\n        )\n        {\n            // If call to Chainlink succeeds, return the response and success = true\n            prevChainlinkResponse.roundId = roundId;\n            prevChainlinkResponse.answer = answer;\n            prevChainlinkResponse.timestamp = timestamp;\n            prevChainlinkResponse.decimals = _currentDecimals;\n            prevChainlinkResponse.success = true;\n            return prevChainlinkResponse;\n        } catch {\n            // If call to Chainlink aggregator reverts, return a zero response with success = false\n            return prevChainlinkResponse;\n        }\n    }\n}"
    }
  ]
}