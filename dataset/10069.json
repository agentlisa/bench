{
  "Title": "[H-01] `createPromotion()` Lack of input validation for `_epochDuration` can potentially freeze promotion creator's funds",
  "Content": "_Submitted by WatchPug_\n\n<https://github.com/pooltogether/v4-periphery/blob/0e94c54774a6fce29daf9cb23353208f80de63eb/contracts/TwabRewards.sol#L88-L116>\n\n```solidity\nfunction createPromotion(\n    address _ticket,\n    IERC20 _token,\n    uint216 _tokensPerEpoch,\n    uint32 _startTimestamp,\n    uint32 _epochDuration,\n    uint8 _numberOfEpochs\n) external override returns (uint256) {\n    _requireTicket(_ticket);\n\n    uint256 _nextPromotionId = _latestPromotionId + 1;\n    _latestPromotionId = _nextPromotionId;\n\n    _promotions[_nextPromotionId] = Promotion(\n        msg.sender,\n        _ticket,\n        _token,\n        _tokensPerEpoch,\n        _startTimestamp,\n        _epochDuration,\n        _numberOfEpochs\n    );\n\n    _token.safeTransferFrom(msg.sender, address(this), _tokensPerEpoch * _numberOfEpochs);\n\n    emit PromotionCreated(_nextPromotionId);\n\n    return _nextPromotionId;\n}\n```\n\nIn the current implementation of `createPromotion()`, `_epochDuration` is allowed to be `0`.\n\nHowever, when `_epochDuration = 0`, it will be impossible for users to claim the rewards, and the promotion creator won't be able to cancel it.\n\n#### Proof of Concept\n\n1.  Alice called `createPromotion()` to create a promotion with the following parameters:\n    *   \\_token: `USDC`\n    *   \\_tokensPerEpoch: `10,000`\n    *   \\_epochDuration: `0`\n    *   \\_numberOfEpochs: `10`\n2.  `100,000 USDC` was transferred from Alice to the `TwabRewards` contract;\n3.  Users tries to `claimRewards()` but the transaction always revert at `_ticket.getAverageTotalSuppliesBetween()` -> `TwabLib.getAverageBalanceBetween()` due to div by 0.\n4.  Alice tries to `cancelPromotion()` to retrieve the funds, but it always reverts at `_requirePromotionActive()` since the promotion already ended.\n\nAs a result, Alice's `100,000 USDC` is frozen in the contract.\n\n#### Recommendation\n\nConsider adding `require(_epochDuration > 0)` in `createPromotion()`.\n\n**[PierrickGT (PoolTogether) marked as duplicate](https://github.com/code-423n4/2021-12-pooltogether-findings/issues/106#issuecomment-993713041):**\n > Duplicate of https://github.com/code-423n4/2021-12-pooltogether-findings/issues/29\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2021-12-pooltogether-findings/issues/106#issuecomment-1008322347):**\n > I do not consider this to be a duplicate of #29 because the warden in #29 does not mention this specific failure case. This is indeed an easy to encounter bug that can be triggered as the result of a user error or a frontend bug. Loss of all funds for the promotion would be the result.\n\n **PierrickGT (PoolTogether) confirmed and resolved:**\n > Implemented the suggested require: https://github.com/pooltogether/v4-periphery/blob/e0010b689fb170daac77af5f62abba7ca1397524/contracts/TwabRewards.sol#L126\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2021-12-pooltogether",
  "Code": [
    {
      "filename": "contracts/TwabRewards.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@pooltogether/v4-core/contracts/interfaces/ITicket.sol\";\n\nimport \"./interfaces/ITwabRewards.sol\";\n\n/**\n * @title PoolTogether V4 TwabRewards\n * @author PoolTogether Inc Team\n * @notice Contract to distribute rewards to depositors in a pool.\n * This contract supports the creation of several promotions that can run simultaneously.\n * In order to calculate user rewards, we use the TWAB (Time-Weighted Average Balance) from the Ticket contract.\n * This way, users simply need to hold their tickets to be eligible to claim rewards.\n * Rewards are calculated based on the average amount of tickets they hold during the epoch duration.\n */\ncontract TwabRewards is ITwabRewards {\n    using SafeERC20 for IERC20;\n\n    /* ============ Global Variables ============ */\n\n    /// @notice Settings of each promotion.\n    mapping(uint256 => Promotion) internal _promotions;\n\n    /// @notice Latest recorded promotion id.\n    /// @dev Starts at 0 and is incremented by 1 for each new promotion. So the first promotion will have id 1, the second 2, etc.\n    uint256 internal _latestPromotionId;\n\n    /// @notice Keeps track of claimed rewards per user.\n    /// @dev _claimedEpochs[promotionId][user] => claimedEpochs\n    /// @dev We pack epochs claimed by a user into a uint256. So we can't store more than 255 epochs.\n    mapping(uint256 => mapping(address => uint256)) internal _claimedEpochs;\n\n    /* ============ Events ============ */\n\n    /**\n        @notice Emitted when a promotion is created.\n        @param promotionId Id of the newly created promotion\n    */\n    event PromotionCreated(uint256 indexed promotionId);\n\n    /**\n        @notice Emitted when a promotion is cancelled.\n        @param promotionId Id of the promotion being cancelled\n        @param amount Amount of tokens transferred to the promotion creator\n    */\n    event PromotionCancelled(uint256 indexed promotionId, uint256 amount);\n\n    /**\n        @notice Emitted when a promotion is extended.\n        @param promotionId Id of the promotion being extended\n        @param numberOfEpochs Number of epochs the promotion has been extended by\n    */\n    event PromotionExtended(uint256 indexed promotionId, uint256 numberOfEpochs);\n\n    /**\n        @notice Emitted when rewards have been claimed.\n        @param promotionId Id of the promotion for which epoch rewards were claimed\n        @param epochIds Ids of the epochs being claimed\n        @param user Address of the user for which the rewards were claimed\n        @param amount Amount of tokens transferred to the recipient address\n    */\n    event RewardsClaimed(\n        uint256 indexed promotionId,\n        uint256[] epochIds,\n        address indexed user,\n        uint256 amount\n    );\n\n    /* ============ Modifiers ============ */\n\n    /// @dev Ensure that the caller is the creator of the promotion.\n    /// @param _promotionId Id of the promotion to check\n    modifier onlyPromotionCreator(uint256 _promotionId) {\n        require(\n            msg.sender == _getPromotion(_promotionId).creator,\n            \"TwabRewards/only-promotion-creator\"\n        );\n        _;\n    }\n\n    /* ============ External Functions ============ */\n\n    /// @inheritdoc ITwabRewards\n    function createPromotion(\n        address _ticket,\n        IERC20 _token,\n        uint216 _tokensPerEpoch,\n        uint32 _startTimestamp,\n        uint32 _epochDuration,\n        uint8 _numberOfEpochs\n    ) external override returns (uint256) {\n        _requireTicket(_ticket);\n\n        uint256 _nextPromotionId = _latestPromotionId + 1;\n        _latestPromotionId = _nextPromotionId;\n\n        _promotions[_nextPromotionId] = Promotion(\n            msg.sender,\n            _ticket,\n            _token,\n            _tokensPerEpoch,\n            _startTimestamp,\n            _epochDuration,\n            _numberOfEpochs\n        );\n\n        _token.safeTransferFrom(msg.sender, address(this), _tokensPerEpoch * _numberOfEpochs);\n\n        emit PromotionCreated(_nextPromotionId);\n\n        return _nextPromotionId;\n    }\n\n    /// @inheritdoc ITwabRewards\n    function cancelPromotion(uint256 _promotionId, address _to)\n        external\n        override\n        onlyPromotionCreator(_promotionId)\n        returns (bool)\n    {\n        Promotion memory _promotion = _getPromotion(_promotionId);\n\n        _requirePromotionActive(_promotion);\n        require(_to != address(0), \"TwabRewards/recipient-not-zero-address\");\n\n        uint256 _remainingRewards = _getRemainingRewards(_promotion);\n\n        delete _promotions[_promotionId];\n        _promotion.token.safeTransfer(_to, _remainingRewards);\n\n        emit PromotionCancelled(_promotionId, _remainingRewards);\n\n        return true;\n    }\n\n    /// @inheritdoc ITwabRewards\n    function extendPromotion(uint256 _promotionId, uint8 _numberOfEpochs)\n        external\n        override\n        returns (bool)\n    {\n        Promotion memory _promotion = _getPromotion(_promotionId);\n\n        _requirePromotionActive(_promotion);\n\n        uint8 _extendedNumberOfEpochs = _promotion.numberOfEpochs + _numberOfEpochs;\n        _promotions[_promotionId].numberOfEpochs = _extendedNumberOfEpochs;\n\n        uint256 _amount = _numberOfEpochs * _promotion.tokensPerEpoch;\n        _promotion.token.safeTransferFrom(msg.sender, address(this), _amount);\n\n        emit PromotionExtended(_promotionId, _numberOfEpochs);\n\n        return true;\n    }\n\n    /// @inheritdoc ITwabRewards\n    function claimRewards(\n        address _user,\n        uint256 _promotionId,\n        uint256[] calldata _epochIds\n    ) external override returns (uint256) {\n        Promotion memory _promotion = _getPromotion(_promotionId);\n\n        uint256 _rewardsAmount;\n        uint256 _userClaimedEpochs = _claimedEpochs[_promotionId][_user];\n\n        for (uint256 index = 0; index < _epochIds.length; index++) {\n            uint256 _epochId = _epochIds[index];\n\n            require(\n                !_isClaimedEpoch(_userClaimedEpochs, _epochId),\n                \"TwabRewards/rewards-already-claimed\"\n            );\n\n            _rewardsAmount += _calculateRewardAmount(_user, _promotion, _epochId);\n            _userClaimedEpochs = _updateClaimedEpoch(_userClaimedEpochs, _epochId);\n        }\n\n        _claimedEpochs[_promotionId][_user] = _userClaimedEpochs;\n\n        _promotion.token.safeTransfer(_user, _rewardsAmount);\n\n        emit RewardsClaimed(_promotionId, _epochIds, _user, _rewardsAmount);\n\n        return _rewardsAmount;\n    }\n\n    /// @inheritdoc ITwabRewards\n    function getPromotion(uint256 _promotionId) external view override returns (Promotion memory) {\n        return _getPromotion(_promotionId);\n    }\n\n    /// @inheritdoc ITwabRewards\n    function getCurrentEpochId(uint256 _promotionId) external view override returns (uint256) {\n        return _getCurrentEpochId(_getPromotion(_promotionId));\n    }\n\n    /// @inheritdoc ITwabRewards\n    function getRemainingRewards(uint256 _promotionId) external view override returns (uint256) {\n        return _getRemainingRewards(_getPromotion(_promotionId));\n    }\n\n    /// @inheritdoc ITwabRewards\n    function getRewardsAmount(\n        address _user,\n        uint256 _promotionId,\n        uint256[] calldata _epochIds\n    ) external view override returns (uint256[] memory) {\n        Promotion memory _promotion = _getPromotion(_promotionId);\n        uint256[] memory _rewardsAmount = new uint256[](_epochIds.length);\n\n        for (uint256 index = 0; index < _epochIds.length; index++) {\n            _rewardsAmount[index] = _calculateRewardAmount(_user, _promotion, _epochIds[index]);\n        }\n\n        return _rewardsAmount;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n    @notice Determine if address passed is actually a ticket.\n    @param _ticket Address to check\n   */\n    function _requireTicket(address _ticket) internal view {\n        require(_ticket != address(0), \"TwabRewards/ticket-not-zero-address\");\n\n        (bool succeeded, bytes memory data) = address(_ticket).staticcall(\n            abi.encodePacked(ITicket(_ticket).controller.selector)\n        );\n\n        address controllerAddress;\n\n        if (data.length > 0) {\n            controllerAddress = abi.decode(data, (address));\n        }\n\n        require(succeeded && controllerAddress != address(0), \"TwabRewards/invalid-ticket\");\n    }\n\n    /**\n        @notice Determine if a promotion is active.\n        @param _promotion Promotion to check\n    */\n    function _requirePromotionActive(Promotion memory _promotion) internal view {\n        uint256 _promotionEndTimestamp = _promotion.startTimestamp +\n            (_promotion.epochDuration * _promotion.numberOfEpochs);\n\n        require(\n            _promotionEndTimestamp > 0 && _promotionEndTimestamp >= block.timestamp,\n            \"TwabRewards/promotion-not-active\"\n        );\n    }\n\n    /**\n        @notice Get settings for a specific promotion.\n        @dev Will revert if the promotion does not exist.\n        @param _promotionId Promotion id to get settings for\n        @return Promotion settings\n     */\n    function _getPromotion(uint256 _promotionId) internal view returns (Promotion memory) {\n        return _promotions[_promotionId];\n    }\n\n    /**\n        @notice Get the current epoch id of a promotion.\n        @dev Epoch ids and their boolean values are tightly packed and stored in a uint256, so epoch id starts at 0.\n        @param _promotion Promotion to get current epoch for\n        @return Epoch id\n     */\n    function _getCurrentEpochId(Promotion memory _promotion) internal view returns (uint256) {\n        // elapsedTimestamp / epochDurationTimestamp\n        return (block.timestamp - _promotion.startTimestamp) / _promotion.epochDuration;\n    }\n\n    /**\n        @notice Get reward amount for a specific user.\n        @dev Rewards can only be claimed once the epoch is over.\n        @param _user User to get reward amount for\n        @param _promotion Promotion from which the epoch is\n        @param _epochId Epoch id to get reward amount for\n        @return Reward amount\n     */\n    function _calculateRewardAmount(\n        address _user,\n        Promotion memory _promotion,\n        uint256 _epochId\n    ) internal view returns (uint256) {\n        uint256 _epochDuration = _promotion.epochDuration;\n        uint256 _epochStartTimestamp = _promotion.startTimestamp + (_epochDuration * _epochId);\n        uint256 _epochEndTimestamp = _epochStartTimestamp + _epochDuration;\n\n        require(block.timestamp > _epochEndTimestamp, \"TwabRewards/epoch-not-over\");\n\n        ITicket _ticket = ITicket(_promotion.ticket);\n\n        uint256 _averageBalance = _ticket.getAverageBalanceBetween(\n            _user,\n            uint64(_epochStartTimestamp),\n            uint64(_epochEndTimestamp)\n        );\n\n        uint64[] memory _epochStartTimestamps = new uint64[](1);\n        _epochStartTimestamps[0] = uint64(_epochStartTimestamp);\n\n        uint64[] memory _epochEndTimestamps = new uint64[](1);\n        _epochEndTimestamps[0] = uint64(_epochEndTimestamp);\n\n        uint256[] memory _averageTotalSupplies = _ticket.getAverageTotalSuppliesBetween(\n            _epochStartTimestamps,\n            _epochEndTimestamps\n        );\n\n        if (_averageTotalSupplies[0] > 0) {\n            return (_promotion.tokensPerEpoch * _averageBalance) / _averageTotalSupplies[0];\n        }\n\n        return 0;\n    }\n\n    /**\n        @notice Get the total amount of tokens left to be rewarded.\n        @param _promotion Promotion to get the total amount of tokens left to be rewarded for\n        @return Amount of tokens left to be rewarded\n     */\n    function _getRemainingRewards(Promotion memory _promotion) internal view returns (uint256) {\n        // _tokensPerEpoch * _numberOfEpochsLeft\n        return\n            _promotion.tokensPerEpoch *\n            (_promotion.numberOfEpochs - _getCurrentEpochId(_promotion));\n    }\n\n    /**\n        @notice Set boolean value for a specific epoch.\n        @dev Bits are stored in a uint256 from right to left.\n        Let's take the example of the following 8 bits word. 0110 0011\n        To set the boolean value to 1 for the epoch id 2, we need to create a mask by shifting 1 to the left by 2 bits.\n        We get: 0000 0001 << 2 = 0000 0100\n        We then OR the mask with the word to set the value.\n        We get: 0110 0011 | 0000 0100 = 0110 0111\n        @param _userClaimedEpochs Tightly packed epoch ids with their boolean values\n        @param _epochId Id of the epoch to set the boolean for\n        @return Tightly packed epoch ids with the newly boolean value set\n    */\n    function _updateClaimedEpoch(uint256 _userClaimedEpochs, uint256 _epochId)\n        internal\n        pure\n        returns (uint256)\n    {\n        return _userClaimedEpochs | (uint256(1) << _epochId);\n    }\n\n    /**\n        @notice Check if rewards of an epoch for a given promotion have already been claimed by the user.\n        @dev Bits are stored in a uint256 from right to left.\n        Let's take the example of the following 8 bits word. 0110 0111\n        To retrieve the boolean value for the epoch id 2, we need to shift the word to the right by 2 bits.\n        We get: 0110 0111 >> 2 = 0001 1001\n        We then get the value of the last bit by masking with 1.\n        We get: 0001 1001 & 0000 0001 = 0000 0001 = 1\n        We then return the boolean value true since the last bit is 1.\n        @param _userClaimedEpochs Record of epochs already claimed by the user\n        @param _epochId Epoch id to check\n        @return true if the rewards have already been claimed for the given epoch, false otherwise\n     */\n    function _isClaimedEpoch(uint256 _userClaimedEpochs, uint256 _epochId)\n        internal\n        pure\n        returns (bool)\n    {\n        return (_userClaimedEpochs >> _epochId) & uint256(1) == 1;\n    }\n}"
    },
    {
      "filename": "contracts/TwabRewards.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@pooltogether/v4-core/contracts/interfaces/ITicket.sol\";\n\nimport \"./interfaces/ITwabRewards.sol\";\n\n/**\n * @title PoolTogether V4 TwabRewards\n * @author PoolTogether Inc Team\n * @notice Contract to distribute rewards to depositors in a pool.\n * This contract supports the creation of several promotions that can run simultaneously.\n * In order to calculate user rewards, we use the TWAB (Time-Weighted Average Balance) from the Ticket contract.\n * This way, users simply need to hold their tickets to be eligible to claim rewards.\n * Rewards are calculated based on the average amount of tickets they hold during the epoch duration.\n * @dev This contract supports only one prize pool ticket.\n * @dev This contract does not support the use of fee on transfer tokens.\n */\ncontract TwabRewards is ITwabRewards {\n    using SafeERC20 for IERC20;\n\n    /* ============ Global Variables ============ */\n\n    /// @notice Prize pool ticket for which the promotions are created.\n    ITicket public immutable ticket;\n\n    /// @notice Period during which the promotion owner can't destroy a promotion.\n    uint32 public constant GRACE_PERIOD = 60 days;\n\n    /// @notice Settings of each promotion.\n    mapping(uint256 => Promotion) internal _promotions;\n\n    /**\n     * @notice Latest recorded promotion id.\n     * @dev Starts at 0 and is incremented by 1 for each new promotion. So the first promotion will have id 1, the second 2, etc.\n     */\n    uint256 internal _latestPromotionId;\n\n    /**\n     * @notice Keeps track of claimed rewards per user.\n     * @dev _claimedEpochs[promotionId][user] => claimedEpochs\n     * @dev We pack epochs claimed by a user into a uint256. So we can't store more than 256 epochs.\n     */\n    mapping(uint256 => mapping(address => uint256)) internal _claimedEpochs;\n\n    /* ============ Events ============ */\n\n    /**\n     * @notice Emitted when a promotion is created.\n     * @param promotionId Id of the newly created promotion\n     */\n    event PromotionCreated(uint256 indexed promotionId);\n\n    /**\n     * @notice Emitted when a promotion is ended.\n     * @param promotionId Id of the promotion being ended\n     * @param recipient Address of the recipient that will receive the remaining rewards\n     * @param amount Amount of tokens transferred to the recipient\n     * @param epochNumber Epoch number at which the promotion ended\n     */\n    event PromotionEnded(\n        uint256 indexed promotionId,\n        address indexed recipient,\n        uint256 amount,\n        uint8 epochNumber\n    );\n\n    /**\n     * @notice Emitted when a promotion is destroyed.\n     * @param promotionId Id of the promotion being destroyed\n     * @param recipient Address of the recipient that will receive the unclaimed rewards\n     * @param amount Amount of tokens transferred to the recipient\n     */\n    event PromotionDestroyed(\n        uint256 indexed promotionId,\n        address indexed recipient,\n        uint256 amount\n    );\n\n    /**\n     * @notice Emitted when a promotion is extended.\n     * @param promotionId Id of the promotion being extended\n     * @param numberOfEpochs Number of epochs the promotion has been extended by\n     */\n    event PromotionExtended(uint256 indexed promotionId, uint256 numberOfEpochs);\n\n    /**\n     * @notice Emitted when rewards have been claimed.\n     * @param promotionId Id of the promotion for which epoch rewards were claimed\n     * @param epochIds Ids of the epochs being claimed\n     * @param user Address of the user for which the rewards were claimed\n     * @param amount Amount of tokens transferred to the recipient address\n     */\n    event RewardsClaimed(\n        uint256 indexed promotionId,\n        uint8[] epochIds,\n        address indexed user,\n        uint256 amount\n    );\n\n    /* ============ Constructor ============ */\n\n    /**\n     * @notice Constructor of the contract.\n     * @param _ticket Prize Pool ticket address for which the promotions will be created\n     */\n    constructor(ITicket _ticket) {\n        _requireTicket(_ticket);\n        ticket = _ticket;\n    }\n\n    /* ============ External Functions ============ */\n\n    /// @inheritdoc ITwabRewards\n    function createPromotion(\n        IERC20 _token,\n        uint64 _startTimestamp,\n        uint256 _tokensPerEpoch,\n        uint48 _epochDuration,\n        uint8 _numberOfEpochs\n    ) external override returns (uint256) {\n        require(_tokensPerEpoch > 0, \"TwabRewards/tokens-not-zero\");\n        require(_epochDuration > 0, \"TwabRewards/duration-not-zero\");\n        _requireNumberOfEpochs(_numberOfEpochs);\n\n        uint256 _nextPromotionId = _latestPromotionId + 1;\n        _latestPromotionId = _nextPromotionId;\n\n        uint256 _amount = _tokensPerEpoch * _numberOfEpochs;\n\n        _promotions[_nextPromotionId] = Promotion({\n            creator: msg.sender,\n            startTimestamp: _startTimestamp,\n            numberOfEpochs: _numberOfEpochs,\n            epochDuration: _epochDuration,\n            createdAt: uint48(block.timestamp),\n            token: _token,\n            tokensPerEpoch: _tokensPerEpoch,\n            rewardsUnclaimed: _amount\n        });\n\n        uint256 _beforeBalance = _token.balanceOf(address(this));\n\n        _token.safeTransferFrom(msg.sender, address(this), _amount);\n\n        uint256 _afterBalance = _token.balanceOf(address(this));\n\n        require(_beforeBalance + _amount == _afterBalance, \"TwabRewards/promo-amount-diff\");\n\n        emit PromotionCreated(_nextPromotionId);\n\n        return _nextPromotionId;\n    }\n\n    /// @inheritdoc ITwabRewards\n    function endPromotion(uint256 _promotionId, address _to) external override returns (bool) {\n        require(_to != address(0), \"TwabRewards/payee-not-zero-addr\");\n\n        Promotion memory _promotion = _getPromotion(_promotionId);\n        _requirePromotionCreator(_promotion);\n        _requirePromotionActive(_promotion);\n\n        uint8 _epochNumber = uint8(_getCurrentEpochId(_promotion));\n        _promotions[_promotionId].numberOfEpochs = _epochNumber;\n\n        uint256 _remainingRewards = _getRemainingRewards(_promotion);\n        _promotion.token.safeTransfer(_to, _remainingRewards);\n\n        emit PromotionEnded(_promotionId, _to, _remainingRewards, _epochNumber);\n\n        return true;\n    }\n\n    /// @inheritdoc ITwabRewards\n    function destroyPromotion(uint256 _promotionId, address _to) external override returns (bool) {\n        require(_to != address(0), \"TwabRewards/payee-not-zero-addr\");\n\n        Promotion memory _promotion = _getPromotion(_promotionId);\n        _requirePromotionCreator(_promotion);\n\n        uint256 _promotionEndTimestamp = _getPromotionEndTimestamp(_promotion);\n        uint256 _promotionCreatedAt = _promotion.createdAt;\n\n        uint256 _gracePeriodEndTimestamp = (\n            _promotionEndTimestamp < _promotionCreatedAt\n                ? _promotionCreatedAt\n                : _promotionEndTimestamp\n        ) + GRACE_PERIOD;\n\n        require(block.timestamp >= _gracePeriodEndTimestamp, \"TwabRewards/grace-period-active\");\n\n        uint256 _rewardsUnclaimed = _promotion.rewardsUnclaimed;\n        delete _promotions[_promotionId];\n\n        _promotion.token.safeTransfer(_to, _rewardsUnclaimed);\n\n        emit PromotionDestroyed(_promotionId, _to, _rewardsUnclaimed);\n\n        return true;\n    }\n\n    /// @inheritdoc ITwabRewards\n    function extendPromotion(uint256 _promotionId, uint8 _numberOfEpochs)\n        external\n        override\n        returns (bool)\n    {\n        _requireNumberOfEpochs(_numberOfEpochs);\n\n        Promotion memory _promotion = _getPromotion(_promotionId);\n        _requirePromotionActive(_promotion);\n\n        uint8 _currentNumberOfEpochs = _promotion.numberOfEpochs;\n\n        require(\n            _numberOfEpochs <= (type(uint8).max - _currentNumberOfEpochs),\n            \"TwabRewards/epochs-over-limit\"\n        );\n\n        _promotions[_promotionId].numberOfEpochs = _currentNumberOfEpochs + _numberOfEpochs;\n\n        uint256 _amount = _numberOfEpochs * _promotion.tokensPerEpoch;\n\n        _promotions[_promotionId].rewardsUnclaimed += _amount;\n        _promotion.token.safeTransferFrom(msg.sender, address(this), _amount);\n\n        emit PromotionExtended(_promotionId, _numberOfEpochs);\n\n        return true;\n    }\n\n    /// @inheritdoc ITwabRewards\n    function claimRewards(\n        address _user,\n        uint256 _promotionId,\n        uint8[] calldata _epochIds\n    ) external override returns (uint256) {\n        Promotion memory _promotion = _getPromotion(_promotionId);\n\n        uint256 _rewardsAmount;\n        uint256 _userClaimedEpochs = _claimedEpochs[_promotionId][_user];\n        uint256 _epochIdsLength = _epochIds.length;\n\n        for (uint256 index = 0; index < _epochIdsLength; index++) {\n            uint8 _epochId = _epochIds[index];\n\n            require(!_isClaimedEpoch(_userClaimedEpochs, _epochId), \"TwabRewards/rewards-claimed\");\n\n            _rewardsAmount += _calculateRewardAmount(_user, _promotion, _epochId);\n            _userClaimedEpochs = _updateClaimedEpoch(_userClaimedEpochs, _epochId);\n        }\n\n        _claimedEpochs[_promotionId][_user] = _userClaimedEpochs;\n        _promotions[_promotionId].rewardsUnclaimed -= _rewardsAmount;\n\n        _promotion.token.safeTransfer(_user, _rewardsAmount);\n\n        emit RewardsClaimed(_promotionId, _epochIds, _user, _rewardsAmount);\n\n        return _rewardsAmount;\n    }\n\n    /// @inheritdoc ITwabRewards\n    function getPromotion(uint256 _promotionId) external view override returns (Promotion memory) {\n        return _getPromotion(_promotionId);\n    }\n\n    /// @inheritdoc ITwabRewards\n    function getCurrentEpochId(uint256 _promotionId) external view override returns (uint256) {\n        return _getCurrentEpochId(_getPromotion(_promotionId));\n    }\n\n    /// @inheritdoc ITwabRewards\n    function getRemainingRewards(uint256 _promotionId) external view override returns (uint256) {\n        return _getRemainingRewards(_getPromotion(_promotionId));\n    }\n\n    /// @inheritdoc ITwabRewards\n    function getRewardsAmount(\n        address _user,\n        uint256 _promotionId,\n        uint8[] calldata _epochIds\n    ) external view override returns (uint256[] memory) {\n        Promotion memory _promotion = _getPromotion(_promotionId);\n\n        uint256 _epochIdsLength = _epochIds.length;\n        uint256[] memory _rewardsAmount = new uint256[](_epochIdsLength);\n\n        for (uint256 index = 0; index < _epochIdsLength; index++) {\n            if (_isClaimedEpoch(_claimedEpochs[_promotionId][_user], uint8(index))) {\n                _rewardsAmount[index] = 0;\n            } else {\n                _rewardsAmount[index] = _calculateRewardAmount(_user, _promotion, _epochIds[index]);\n            }\n        }\n\n        return _rewardsAmount;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * @notice Determine if address passed is actually a ticket.\n     * @param _ticket Address to check\n     */\n    function _requireTicket(ITicket _ticket) internal view {\n        require(address(_ticket) != address(0), \"TwabRewards/ticket-not-zero-addr\");\n\n        (bool succeeded, bytes memory data) = address(_ticket).staticcall(\n            abi.encodePacked(_ticket.controller.selector)\n        );\n\n        require(\n            succeeded && data.length > 0 && abi.decode(data, (uint160)) != 0,\n            \"TwabRewards/invalid-ticket\"\n        );\n    }\n\n    /**\n     * @notice Allow a promotion to be created or extended only by a positive number of epochs.\n     * @param _numberOfEpochs Number of epochs to check\n     */\n    function _requireNumberOfEpochs(uint8 _numberOfEpochs) internal pure {\n        require(_numberOfEpochs > 0, \"TwabRewards/epochs-not-zero\");\n    }\n\n    /**\n     * @notice Determine if a promotion is active.\n     * @param _promotion Promotion to check\n     */\n    function _requirePromotionActive(Promotion memory _promotion) internal view {\n        require(\n            _getPromotionEndTimestamp(_promotion) > block.timestamp,\n            \"TwabRewards/promotion-inactive\"\n        );\n    }\n\n    /**\n     * @notice Determine if msg.sender is the promotion creator.\n     * @param _promotion Promotion to check\n     */\n    function _requirePromotionCreator(Promotion memory _promotion) internal view {\n        require(msg.sender == _promotion.creator, \"TwabRewards/only-promo-creator\");\n    }\n\n    /**\n     * @notice Get settings for a specific promotion.\n     * @dev Will revert if the promotion does not exist.\n     * @param _promotionId Promotion id to get settings for\n     * @return Promotion settings\n     */\n    function _getPromotion(uint256 _promotionId) internal view returns (Promotion memory) {\n        Promotion memory _promotion = _promotions[_promotionId];\n        require(_promotion.creator != address(0), \"TwabRewards/invalid-promotion\");\n        return _promotion;\n    }\n\n    /**\n     * @notice Compute promotion end timestamp.\n     * @param _promotion Promotion to compute end timestamp for\n     * @return Promotion end timestamp\n     */\n    function _getPromotionEndTimestamp(Promotion memory _promotion)\n        internal\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            return\n                _promotion.startTimestamp + (_promotion.epochDuration * _promotion.numberOfEpochs);\n        }\n    }\n\n    /**\n     * @notice Get the current epoch id of a promotion.\n     * @dev Epoch ids and their boolean values are tightly packed and stored in a uint256, so epoch id starts at 0.\n     * @dev We return the current epoch id if the promotion has not ended.\n     * If the current timestamp is before the promotion start timestamp, we return 0.\n     * Otherwise, we return the epoch id at the current timestamp. This could be greater than the number of epochs of the promotion.\n     * @param _promotion Promotion to get current epoch for\n     * @return Epoch id\n     */\n    function _getCurrentEpochId(Promotion memory _promotion) internal view returns (uint256) {\n        uint256 _currentEpochId;\n\n        if (block.timestamp > _promotion.startTimestamp) {\n            unchecked {\n                _currentEpochId =\n                    (block.timestamp - _promotion.startTimestamp) /\n                    _promotion.epochDuration;\n            }\n        }\n\n        return _currentEpochId;\n    }\n\n    /**\n     * @notice Get reward amount for a specific user.\n     * @dev Rewards can only be calculated once the epoch is over.\n     * @dev Will revert if `_epochId` is over the total number of epochs or if epoch is not over.\n     * @dev Will return 0 if the user average balance of tickets is 0.\n     * @param _user User to get reward amount for\n     * @param _promotion Promotion from which the epoch is\n     * @param _epochId Epoch id to get reward amount for\n     * @return Reward amount\n     */\n    function _calculateRewardAmount(\n        address _user,\n        Promotion memory _promotion,\n        uint8 _epochId\n    ) internal view returns (uint256) {\n        uint64 _epochDuration = _promotion.epochDuration;\n        uint64 _epochStartTimestamp = _promotion.startTimestamp + (_epochDuration * _epochId);\n        uint64 _epochEndTimestamp = _epochStartTimestamp + _epochDuration;\n\n        require(block.timestamp >= _epochEndTimestamp, \"TwabRewards/epoch-not-over\");\n        require(_epochId < _promotion.numberOfEpochs, \"TwabRewards/invalid-epoch-id\");\n\n        uint256 _averageBalance = ticket.getAverageBalanceBetween(\n            _user,\n            _epochStartTimestamp,\n            _epochEndTimestamp\n        );\n\n        if (_averageBalance > 0) {\n            uint64[] memory _epochStartTimestamps = new uint64[](1);\n            _epochStartTimestamps[0] = _epochStartTimestamp;\n\n            uint64[] memory _epochEndTimestamps = new uint64[](1);\n            _epochEndTimestamps[0] = _epochEndTimestamp;\n\n            uint256 _averageTotalSupply = ticket.getAverageTotalSuppliesBetween(\n                _epochStartTimestamps,\n                _epochEndTimestamps\n            )[0];\n\n            return (_promotion.tokensPerEpoch * _averageBalance) / _averageTotalSupply;\n        }\n\n        return 0;\n    }\n\n    /**\n     * @notice Get the total amount of tokens left to be rewarded.\n     * @param _promotion Promotion to get the total amount of tokens left to be rewarded for\n     * @return Amount of tokens left to be rewarded\n     */\n    function _getRemainingRewards(Promotion memory _promotion) internal view returns (uint256) {\n        if (block.timestamp > _getPromotionEndTimestamp(_promotion)) {\n            return 0;\n        }\n\n        return\n            _promotion.tokensPerEpoch *\n            (_promotion.numberOfEpochs - _getCurrentEpochId(_promotion));\n    }\n\n    /**\n    * @notice Set boolean value for a specific epoch.\n    * @dev Bits are stored in a uint256 from right to left.\n        Let's take the example of the following 8 bits word. 0110 0011\n        To set the boolean value to 1 for the epoch id 2, we need to create a mask by shifting 1 to the left by 2 bits.\n        We get: 0000 0001 << 2 = 0000 0100\n        We then OR the mask with the word to set the value.\n        We get: 0110 0011 | 0000 0100 = 0110 0111\n    * @param _userClaimedEpochs Tightly packed epoch ids with their boolean values\n    * @param _epochId Id of the epoch to set the boolean for\n    * @return Tightly packed epoch ids with the newly boolean value set\n    */\n    function _updateClaimedEpoch(uint256 _userClaimedEpochs, uint8 _epochId)\n        internal\n        pure\n        returns (uint256)\n    {\n        return _userClaimedEpochs | (uint256(1) << _epochId);\n    }\n\n    /**\n    * @notice Check if rewards of an epoch for a given promotion have already been claimed by the user.\n    * @dev Bits are stored in a uint256 from right to left.\n        Let's take the example of the following 8 bits word. 0110 0111\n        To retrieve the boolean value for the epoch id 2, we need to shift the word to the right by 2 bits.\n        We get: 0110 0111 >> 2 = 0001 1001\n        We then get the value of the last bit by masking with 1.\n        We get: 0001 1001 & 0000 0001 = 0000 0001 = 1\n        We then return the boolean value true since the last bit is 1.\n    * @param _userClaimedEpochs Record of epochs already claimed by the user\n    * @param _epochId Epoch id to check\n    * @return true if the rewards have already been claimed for the given epoch, false otherwise\n     */\n    function _isClaimedEpoch(uint256 _userClaimedEpochs, uint8 _epochId)\n        internal\n        pure\n        returns (bool)\n    {\n        return (_userClaimedEpochs >> _epochId) & uint256(1) == 1;\n    }\n}"
    }
  ]
}