{
  "Title": "[H-02] ERC721Votesâ€™s delegation disables NFT transfers and burning",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L262-L268\n\n\n# Vulnerability details\n\nIf Alice the NFT owner first delegates her votes to herself, second delegates to anyone else with delegate() or delegateBySig() then all her NFT ids will become stuck: their transfers and burning will be disabled.\n\nThe issue is _afterTokenTransfer() callback running the _moveDelegateVotes() with an owner instead of her delegate. As Alice's votes in the checkpoint is zero after she delegated them, the subtraction _moveDelegateVotes() tries to perform during the move of the votes will be reverted.\n\nAs ERC721Votes is parent to Token and delegate is a kind of common and frequent operation, the impact is governance token moves being frozen in a variety of use cases, which interferes with governance voting process and can be critical for the project.\n\n## Proof of Concept\n\nSuppose Alice delegated all her votes to herself and then decided to delegate them to someone else with either delegate() or delegateBySig() calling _delegate():\n\nhttps://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L179-L190\n\n```solidity\n    function _delegate(address _from, address _to) internal {\n        // Get the previous delegate\n        address prevDelegate = delegation[_from];\n\n        // Store the new delegate\n        delegation[_from] = _to;\n\n        emit DelegateChanged(_from, prevDelegate, _to);\n\n        // Transfer voting weight from the previous delegate to the new delegate\n        _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));\n    }\n```\n\n_moveDelegateVotes() will set her votes to `0` as `_from == Alice` and `prevTotalVotes = _amount = balanceOf(Alice)` (as _afterTokenTransfer() incremented Alice's vote balance on each mint to her):\n\nhttps://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L196-L217\n\n```solidity\n    function _moveDelegateVotes(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        unchecked {\n            // If voting weight is being transferred:\n            if (_from != _to && _amount > 0) {\n                // If this isn't a token mint:\n                if (_from != address(0)) {\n                    // Get the sender's number of checkpoints\n                    uint256 nCheckpoints = numCheckpoints[_from]++;\n\n                    // Used to store the sender's previous voting weight\n                    uint256 prevTotalVotes;\n\n                    // If this isn't the sender's first checkpoint: Get their previous voting weight\n                    if (nCheckpoints != 0) prevTotalVotes = checkpoints[_from][nCheckpoints - 1].votes;\n\n                    // Update their voting weight\n                    _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes - _amount);\n                }\n```\n\nAfter that her votes in the checkpoint become zero. She will not be able to transfer the NFT as `_afterTokenTransfer` will revert on `_moveDelegateVotes`'s attempt to move `1` vote from `Alice` to `_to`, while `checkpoints[Alice][nCheckpoints - 1].votes` is `0`:\n\nhttps://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L262-L268\n\n```solidity\n    function _afterTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) internal override {\n        // Transfer 1 vote from the sender to the recipient\n        _moveDelegateVotes(_from, _to, 1);\n```\n\n## Recommended Mitigation Steps\n\nThe root issue is _afterTokenTransfer() dealing with Alice instead of Alice's delegate.\n\nConsider including delegates() call as a fix:\n\nhttps://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L262-L268\n\n```solidity\n    function _afterTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) internal override {\n        // Transfer 1 vote from the sender to the recipient\n-       _moveDelegateVotes(_from, _to, 1);\n+       _moveDelegateVotes(delegates(_from), delegates(_to), 1);\n```\n\nAs `delegates(address(0)) == address(0)` the burning/minting flow will persist:\n\nhttps://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L124-L129\n\n```solidity\n    /// @notice The delegate for an account\n    /// @param _account The account address\n    function delegates(address _account) external view returns (address) {\n        address current = delegation[_account];\n        return current == address(0) ? _account : current;\n    }\n```\n\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-09-nouns-builder-contest",
  "Code": [
    {
      "filename": "src/lib/token/ERC721Votes.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { IERC721Votes } from \"../interfaces/IERC721Votes.sol\";\nimport { ERC721 } from \"../token/ERC721.sol\";\nimport { EIP712 } from \"../utils/EIP712.sol\";\n\n/// @title ERC721Votes\n/// @author Rohan Kulkarni\n/// @notice Modified from OpenZeppelin Contracts v4.7.3 (token/ERC721/extensions/draft-ERC721Votes.sol) & Nouns DAO ERC721Checkpointable.sol commit 2cbe6c7 - licensed under the BSD-3-Clause license.\n/// - Uses custom errors defined in IERC721Votes\n/// - Checkpoints are based on timestamps instead of block numbers\n/// - Tokens are self-delegated by default\n/// - The total number of votes is the token supply itself\nabstract contract ERC721Votes is IERC721Votes, EIP712, ERC721 {\n    ///                                                          ///\n    ///                          CONSTANTS                       ///\n    ///                                                          ///\n\n    /// @dev The EIP-712 typehash to delegate with a signature\n    bytes32 internal constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address from,address to,uint256 nonce,uint256 deadline)\");\n\n    ///                                                          ///\n    ///                           STORAGE                        ///\n    ///                                                          ///\n\n    /// @notice The delegate for an account\n    /// @notice Account => Delegate\n    mapping(address => address) internal delegation;\n\n    /// @notice The number of checkpoints for an account\n    /// @dev Account => Num Checkpoints\n    mapping(address => uint256) internal numCheckpoints;\n\n    /// @notice The checkpoint for an account\n    /// @dev Account => Checkpoint Id => Checkpoint\n    mapping(address => mapping(uint256 => Checkpoint)) internal checkpoints;\n\n    ///                                                          ///\n    ///                        VOTING WEIGHT                     ///\n    ///                                                          ///\n\n    /// @notice The current number of votes for an account\n    /// @param _account The account address\n    function getVotes(address _account) public view returns (uint256) {\n        // Get the account's number of checkpoints\n        uint256 nCheckpoints = numCheckpoints[_account];\n\n        // Cannot underflow as `nCheckpoints` is ensured to be greater than 0 if reached\n        unchecked {\n            // Return the number of votes at the latest checkpoint if applicable\n            return nCheckpoints != 0 ? checkpoints[_account][nCheckpoints - 1].votes : 0;\n        }\n    }\n\n    /// @notice The number of votes for an account at a past timestamp\n    /// @param _account The account address\n    /// @param _timestamp The past timestamp\n    function getPastVotes(address _account, uint256 _timestamp) public view returns (uint256) {\n        // Ensure the given timestamp is in the past\n        if (_timestamp >= block.timestamp) revert INVALID_TIMESTAMP();\n\n        // Get the account's number of checkpoints\n        uint256 nCheckpoints = numCheckpoints[_account];\n\n        // If there are none return 0\n        if (nCheckpoints == 0) return 0;\n\n        // Get the account's checkpoints\n        mapping(uint256 => Checkpoint) storage accountCheckpoints = checkpoints[_account];\n\n        unchecked {\n            // Get the latest checkpoint id\n            // Cannot underflow as `nCheckpoints` is ensured to be greater than 0\n            uint256 lastCheckpoint = nCheckpoints - 1;\n\n            // If the latest checkpoint has a valid timestamp, return its number of votes\n            if (accountCheckpoints[lastCheckpoint].timestamp <= _timestamp) return accountCheckpoints[lastCheckpoint].votes;\n\n            // If the first checkpoint doesn't have a valid timestamp, return 0\n            if (accountCheckpoints[0].timestamp > _timestamp) return 0;\n\n            // Otherwise, find a checkpoint with a valid timestamp\n            // Use the latest id as the initial upper bound\n            uint256 high = lastCheckpoint;\n            uint256 low;\n            uint256 middle;\n\n            // Used to temporarily hold a checkpoint\n            Checkpoint memory cp;\n\n            // While a valid checkpoint is to be found:\n            while (high > low) {\n                // Find the id of the middle checkpoint\n                middle = high - (high - low) / 2;\n\n                // Get the middle checkpoint\n                cp = accountCheckpoints[middle];\n\n                // If the timestamp is a match:\n                if (cp.timestamp == _timestamp) {\n                    // Return the voting weight\n                    return cp.votes;\n\n                    // Else if the timestamp is before the one looking for:\n                } else if (cp.timestamp < _timestamp) {\n                    // Update the lower bound\n                    low = middle;\n\n                    // Else update the upper bound\n                } else {\n                    high = middle - 1;\n                }\n            }\n\n            return accountCheckpoints[low].votes;\n        }\n    }\n\n    ///                                                          ///\n    ///                          DELEGATION                      ///\n    ///                                                          ///\n\n    /// @notice The delegate for an account\n    /// @param _account The account address\n    function delegates(address _account) external view returns (address) {\n        address current = delegation[_account];\n        return current == address(0) ? _account : current;\n    }\n\n    /// @notice Delegates votes to an account\n    /// @param _to The address delegating votes to\n    function delegate(address _to) external {\n        _delegate(msg.sender, _to);\n    }\n\n    /// @notice Delegates votes from a signer to an account\n    /// @param _from The address delegating votes from\n    /// @param _to The address delegating votes to\n    /// @param _deadline The signature deadline\n    /// @param _v The 129th byte and chain id of the signature\n    /// @param _r The first 64 bytes of the signature\n    /// @param _s Bytes 64-128 of the signature\n    function delegateBySig(\n        address _from,\n        address _to,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        // Ensure the signature has not expired\n        if (block.timestamp > _deadline) revert EXPIRED_SIGNATURE();\n\n        // Used to store the digest\n        bytes32 digest;\n\n        // Cannot realistically overflow\n        unchecked {\n            // Compute the hash of the domain seperator with the typed delegation data\n            digest = keccak256(\n                abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR(), keccak256(abi.encode(DELEGATION_TYPEHASH, _from, _to, nonces[_from]++, _deadline)))\n            );\n        }\n\n        // Recover the message signer\n        address recoveredAddress = ecrecover(digest, _v, _r, _s);\n\n        // Ensure the recovered signer is the voter\n        if (recoveredAddress == address(0) || recoveredAddress != _from) revert INVALID_SIGNATURE();\n\n        // Update the delegate\n        _delegate(_from, _to);\n    }\n\n    /// @dev Updates delegate addresses\n    /// @param _from The address delegating votes from\n    /// @param _to The address delegating votes to\n    function _delegate(address _from, address _to) internal {\n        // Get the previous delegate\n        address prevDelegate = delegation[_from];\n\n        // Store the new delegate\n        delegation[_from] = _to;\n\n        emit DelegateChanged(_from, prevDelegate, _to);\n\n        // Transfer voting weight from the previous delegate to the new delegate\n        _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));\n    }\n\n    /// @dev Transfers voting weight\n    /// @param _from The address delegating votes from\n    /// @param _to The address delegating votes to\n    /// @param _amount The number of votes delegating\n    function _moveDelegateVotes(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        unchecked {\n            // If voting weight is being transferred:\n            if (_from != _to && _amount > 0) {\n                // If this isn't a token mint:\n                if (_from != address(0)) {\n                    // Get the sender's number of checkpoints\n                    uint256 nCheckpoints = numCheckpoints[_from]++;\n\n                    // Used to store the sender's previous voting weight\n                    uint256 prevTotalVotes;\n\n                    // If this isn't the sender's first checkpoint: Get their previous voting weight\n                    if (nCheckpoints != 0) prevTotalVotes = checkpoints[_from][nCheckpoints - 1].votes;\n\n                    // Update their voting weight\n                    _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes - _amount);\n                }\n\n                // If this isn't a token burn:\n                if (_to != address(0)) {\n                    // Get the recipients's number of checkpoints\n                    uint256 nCheckpoints = numCheckpoints[_to]++;\n\n                    // Used to store the recipient's previous voting weight\n                    uint256 prevTotalVotes;\n\n                    // If this isn't the recipient's first checkpoint: Get their previous voting weight\n                    if (nCheckpoints != 0) prevTotalVotes = checkpoints[_to][nCheckpoints - 1].votes;\n\n                    // Update their voting weight\n                    _writeCheckpoint(_to, nCheckpoints, prevTotalVotes, prevTotalVotes + _amount);\n                }\n            }\n        }\n    }\n\n    /// @dev Records a checkpoint\n    /// @param _account The account address\n    /// @param _id The checkpoint id\n    /// @param _prevTotalVotes The account's previous voting weight\n    /// @param _newTotalVotes The account's new voting weight\n    function _writeCheckpoint(\n        address _account,\n        uint256 _id,\n        uint256 _prevTotalVotes,\n        uint256 _newTotalVotes\n    ) private {\n        // Get the pointer to store the checkpoint\n        Checkpoint storage checkpoint = checkpoints[_account][_id];\n\n        // Record the updated voting weight and current time\n        checkpoint.votes = uint192(_newTotalVotes);\n        checkpoint.timestamp = uint64(block.timestamp);\n\n        emit DelegateVotesChanged(_account, _prevTotalVotes, _newTotalVotes);\n    }\n\n    /// @dev Enables each NFT to equal 1 vote\n    /// @param _from The token sender\n    /// @param _to The token recipient\n    /// @param _tokenId The ERC-721 token id\n    function _afterTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) internal override {\n        // Transfer 1 vote from the sender to the recipient\n        _moveDelegateVotes(_from, _to, 1);\n\n        super._afterTokenTransfer(_from, _to, _tokenId);\n    }\n}"
    }
  ]
}