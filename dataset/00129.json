{
  "Title": "`SiloFacet::transferDeposits` should only call `LibSiloPermit::_spendDepositAllowance` once",
  "Content": "`SiloFacet::transferDeposits` currently loops through the input `amounts` array and [calls](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/beanstalk/silo/SiloFacet/SiloFacet.sol#L185) `LibSiloPermit::_spendDepositAllowance` once for each `amounts[i]`.\n\nInstead, consider having a `totalAmount` stack variable that is incremented for each `amounts[i]` when looping through the inputs. Then, after the initial loop is complete, call `LibSiloPermit::_spendDepositAllowance` with `totalAmount` to save a significant number of storage reads & writes.\n\nConsider this simplified example using Foundry:\n```solidity\nuint256 s_allowance = 10;\n\nfunction _spendAllowance(uint256 amount) private {s_allowance-=amount;}\n\nfunction testBulkTransfer1() public {\n    // prepare input\n    uint256[10] memory amounts;\n    for(uint256 i=0; i<10; i++){amounts[i] = 1;}\n\n    // function implementation; update storage 1-by-1\n    for (uint256 i = 0; i < amounts.length; ++i) {\n        _spendAllowance(amounts[i]);\n    }\n\n    assert(s_allowance == 0);\n}\n\nfunction testBulkTransfer2() public {\n    // prepare input\n    uint256[10] memory amounts;\n    for(uint256 i=0; i<10; i++){amounts[i] = 1;}\n\n    // function implementation; cache total amount, update storage once\n    uint256 totalSpend;\n    for (uint256 i = 0; i < amounts.length; ++i) {\n        totalSpend += amounts[i];\n    }\n\n    _spendAllowance(totalSpend);\n\n    assert(s_allowance == 0);\n}\n\n[PASS] testBulkTransfer1() (gas: 5494)\n[PASS] testBulkTransfer2() (gas: 3435)\n```",
  "Impact": "GAS",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/beanstalk/silo/SiloFacet/SiloFacet.sol",
      "content": "/*\n * SPDX-License-Identifier: MIT\n */\n\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport \"./TokenSilo.sol\";\nimport \"contracts/libraries/Token/LibTransfer.sol\";\nimport \"contracts/libraries/Silo/LibSiloPermit.sol\";\n\n/**\n * @title SiloFacet\n * @author Publius, Brean, Pizzaman1337\n * @notice SiloFacet is the entry point for all Silo functionality.\n * \n * SiloFacet           public functions for modifying an account's Silo.\n * ↖ TokenSilo         accounting & storage for Deposits, Withdrawals, allowances\n * ↖ Silo              accounting & storage for Stalk, and Roots.\n * ↖ SiloExit          public view funcs for total balances, account balances \n *                     & other account state.\n * ↖ ReentrancyGuard   provides reentrancy guard modifier and access to {C}.\n *\n * \n */\ncontract SiloFacet is TokenSilo {\n\n    using SafeMath for uint256;\n    using LibSafeMath32 for uint32;\n\n    //////////////////////// DEPOSIT ////////////////////////\n\n    /** \n     * @notice Deposits an ERC20 into the Silo.\n     * @dev farmer is issued stalk and seeds based on token (i.e non-whitelisted tokens do not get any)\n     * @param token address of ERC20\n     * @param amount tokens to be transfered\n     * @param mode source of funds (INTERNAL, EXTERNAL, EXTERNAL_INTERNAL, INTERNAL_TOLERANT)\n     * @dev Depositing should:\n     * \n     *  1. Transfer `amount` of `token` from `account` to Beanstalk.\n     *  2. Calculate the current Bean Denominated Value (BDV) for `amount` of `token`.\n     *  3. Create or update a Deposit entry for `account` in the current Season.\n     *  4. Mint Stalk to `account`.\n     *  5. Emit an `AddDeposit` event.\n     * \n     */\n    function deposit(\n        address token,\n        uint256 _amount,\n        LibTransfer.From mode\n    ) \n        external\n        payable \n        nonReentrant \n        mowSender(token) \n        returns (uint256 amount, uint256 _bdv, int96 stem)\n    {\n        amount = LibTransfer.receiveToken(\n            IERC20(token),\n            _amount,\n            msg.sender,\n            mode\n        );\n        (_bdv, stem) = _deposit(msg.sender, token, amount);\n    }\n\n    //////////////////////// WITHDRAW ////////////////////////\n\n    /** \n     * @notice Withdraws an ERC20 Deposit from the Silo.\n     * @param token Address of the whitelisted ERC20 token to Withdraw.\n     * @param stem The stem to Withdraw from.\n     * @param amount Amount of `token` to Withdraw.\n     *\n     * @dev When Withdrawing a Deposit, the user must burn all of the Stalk\n     * associated with it, including:\n     *\n     * - base Stalk, received based on the BDV of the Deposit.\n     * - Grown Stalk, grown from BDV and stalkEarnedPerSeason while the deposit was held in the Silo.\n     *\n     * Note that the Grown Stalk associated with a Deposit is a function of the \n     * delta between the current Season and the Season in which a Deposit was made.\n     * \n     * Typically, a Farmer wants to withdraw more recent Deposits first, since\n     * these require less Stalk to be burned. This functionality is the default\n     * provided by the Beanstalk SDK, but is NOT provided at the contract level.\n     * \n     */\n    function withdrawDeposit(\n        address token,\n        int96 stem,\n        uint256 amount,\n        LibTransfer.To mode\n    ) external payable mowSender(token) nonReentrant {\n        _withdrawDeposit(msg.sender, token, stem, amount);\n        LibTransfer.sendToken(IERC20(token), amount, msg.sender, mode);\n    }\n\n    /** \n     * @notice Claims ERC20s from multiple Withdrawals.\n     * @param token Address of the whitelisted ERC20 token to Withdraw.\n     * @param stems stems to Withdraw from.\n     * @param amounts Amounts of `token` to Withdraw from corresponding `stems`.\n     * \n     * deposits.\n     * @dev Clients should factor in gas costs when withdrawing from multiple\n     * \n     * For example, if a user wants to withdraw X Beans, it may be preferable to\n     * withdraw from 1 older Deposit, rather than from multiple recent Deposits,\n     * if the difference in stems is minimal to save on gas.\n     */\n\n    function withdrawDeposits(\n        address token,\n        int96[] calldata stems,\n        uint256[] calldata amounts,\n        LibTransfer.To mode\n    ) external payable mowSender(token) nonReentrant {\n        uint256 amount = _withdrawDeposits(msg.sender, token, stems, amounts);\n        LibTransfer.sendToken(IERC20(token), amount, msg.sender, mode);\n    }\n\n\n    //////////////////////// TRANSFER ////////////////////////\n\n    /** \n     * @notice Transfer a single Deposit.\n     * @param sender Current owner of Deposit.\n     * @param recipient Destination account of Deposit.\n     * @param token Address of the whitelisted ERC20 token to Transfer.\n     * @param stem stem of Deposit from which to Transfer.\n     * @param amount Amount of `token` to Transfer.\n     * @return _bdv The BDV included in this transfer, now owned by `recipient`.\n     *\n     * @dev An allowance is required if `sender !== msg.sender`\n     * \n     * The {mowSender} modifier is not used here because _both_ the `sender` and\n     * `recipient` need their Silo updated, since both accounts experience a\n     * change in deposited BDV. See {Silo-_mow}.\n     */\n    function transferDeposit(\n        address sender,\n        address recipient,\n        address token,\n        int96 stem,\n        uint256 amount\n    ) public payable nonReentrant returns (uint256 _bdv) {\n        if (sender != msg.sender) {\n            LibSiloPermit._spendDepositAllowance(sender, msg.sender, token, amount);\n        }\n        LibSilo._mow(sender, token);\n        // Need to update the recipient's Silo as well.\n        LibSilo._mow(recipient, token);\n        _bdv = _transferDeposit(sender, recipient, token, stem, amount);\n    }\n\n    /** \n     * @notice Transfers multiple Deposits.\n     * @param sender Source of Deposit.\n     * @param recipient Destination of Deposit.\n     * @param token Address of the whitelisted ERC20 token to Transfer.\n     * @param stem stem of Deposit to Transfer. \n     * @param amounts Amounts of `token` to Transfer from corresponding `stem`.\n     * @return bdvs Array of BDV transferred from each Season, now owned by `recipient`.\n     *\n     * @dev An allowance is required if `sender !== msg.sender`. There must be enough allowance\n     * to transfer all of the requested Deposits, otherwise the transaction should revert.\n     * \n     * The {mowSender} modifier is not used here because _both_ the `sender` and\n     * `recipient` need their Silo updated, since both accounts experience a\n     * change in Seeds. See {Silo-_mow}.\n     */\n    function transferDeposits(\n        address sender,\n        address recipient,\n        address token,\n        int96[] calldata stem,\n        uint256[] calldata amounts\n    ) public payable nonReentrant returns (uint256[] memory bdvs) {\n        require(amounts.length > 0, \"Silo: amounts array is empty\");\n        for (uint256 i = 0; i < amounts.length; ++i) {\n            require(amounts[i] > 0, \"Silo: amount in array is 0\");\n            if (sender != msg.sender) {\n                LibSiloPermit._spendDepositAllowance(sender, msg.sender, token, amounts[i]);\n            }\n        }\n       \n        LibSilo._mow(sender, token);\n        // Need to update the recipient's Silo as well.\n        LibSilo._mow(recipient, token);\n        bdvs = _transferDeposits(sender, recipient, token, stem, amounts);\n    }\n\n    \n\n    /**\n     * @notice Transfer a single Deposit, conforming to the ERC1155 standard.\n     * @param sender Source of Deposit.\n     * @param recipient Destination of Deposit.\n     * @param depositId ID of Deposit to Transfer.\n     * @param amount Amount of `token` to Transfer.\n     * \n     * @dev the depositID is the token address and stem of a deposit, \n     * concatinated into a single uint256.\n     * \n     */\n    function safeTransferFrom(\n        address sender, \n        address recipient, \n        uint256 depositId, \n        uint256 amount,\n        bytes calldata\n    ) external {\n        require(recipient != address(0), \"ERC1155: transfer to the zero address\");\n        // allowance requirements are checked in transferDeposit\n        (address token, int96 cumulativeGrownStalkPerBDV) = \n            LibBytes.unpackAddressAndStem(depositId);\n        transferDeposit(\n            sender, \n            recipient,\n            token, \n            cumulativeGrownStalkPerBDV, \n            amount\n        );\n    }\n\n    /**\n     * @notice Transfer a multiple Deposits, conforming to the ERC1155 standard.\n     * @param sender Source of Deposit.\n     * @param recipient Destination of Deposit.\n     * @param depositIds list of ID of deposits to Transfer.\n     * @param amounts list of amounts of `token` to Transfer.\n     * \n     * @dev {transferDeposits} can be used to transfer multiple deposits, but only \n     * if they are all of the same token. Since the ERC1155 standard requires the abilty\n     * to transfer any set of depositIDs, the {transferDeposits} function cannot be used here.\n     */\n    function safeBatchTransferFrom(\n        address sender, \n        address recipient, \n        uint256[] calldata depositIds, \n        uint256[] calldata amounts, \n        bytes calldata\n    ) external {\n        require(depositIds.length == amounts.length, \"Silo: depositIDs and amounts arrays must be the same length\");\n        require(recipient != address(0), \"ERC1155: transfer to the zero address\");\n        // allowance requirements are checked in transferDeposit\n        address token;\n        int96 cumulativeGrownStalkPerBDV;\n        for(uint i; i < depositIds.length; ++i) {\n            (token, cumulativeGrownStalkPerBDV) = \n                LibBytes.unpackAddressAndStem(depositIds[i]);\n            transferDeposit(\n                sender, \n                recipient,\n                token, \n                cumulativeGrownStalkPerBDV, \n                amounts[i]\n            );\n        }\n    }\n\n    //////////////////////// YIELD DISTRUBUTION ////////////////////////\n\n    /**\n     * @notice Claim Grown Stalk for `account`.\n     * @dev See {Silo-_mow}.\n     */\n    function mow(address account, address token) external payable {\n        LibSilo._mow(account, token);\n    }\n\n    //function to mow multiple tokens given an address\n    function mowMultiple(address account, address[] calldata tokens) external payable {\n        for (uint256 i; i < tokens.length; ++i) {\n            LibSilo._mow(account, tokens[i]);\n        }\n    }\n\n\n    /** \n     * @notice Claim Earned Beans and their associated Stalk and Plantable Seeds for\n     * `msg.sender`.\n     *\n     * The Stalk associated with Earned Beans is commonly called \"Earned Stalk\".\n     * Earned Stalk DOES contribute towards the Farmer's Stalk when earned beans is issued.\n     * \n     * The Seeds associated with Earned Beans are commonly called \"Plantable\n     * Seeds\". The word \"Plantable\" is used to highlight that these Seeds aren't \n     * yet earning the Farmer new Stalk. In other words, Seeds do NOT automatically\n     * compound; they must first be Planted with {plant}.\n     * \n     * In practice, when Seeds are Planted, all Earned Beans are Deposited in \n     * the current Season.\n     */\n    function plant() external payable returns (uint256 beans, int96 stem) {\n        return _plant(msg.sender);\n    }\n\n    /** \n     * @notice Claim rewards from a Flood (Was Season of Plenty)\n     */\n    function claimPlenty() external payable {\n        _claimPlenty(msg.sender);\n    }\n\n    function bdv(address token, uint256 amount)\n        external\n        view\n        returns (uint256 _bdv)\n    {\n        _bdv = LibTokenSilo.beanDenominatedValue(token, amount);\n    }\n\n}"
    }
  ]
}