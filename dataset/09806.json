{
  "Title": "[H-03] An offer made after auction end can be stolen by an auction winner",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L556-L560\n\n\n# Vulnerability details\n\n\n## Impact\n\nAn Offer which is made for an NFT when auction has ended, but its winner hasn't received the NFT yet, can be stolen by this winner as `_transferFromEscrow` being called by `_acceptOffer` will transfer the NFT to the winner, finalising the auction, while no transfer to the user who made the offer will happen.\n\nThis way the auction winner will obtain both the NFT and the offer amount after the fees at no additional cost, at the expense of the user who made the offer.\n\n## Proof of Concept\n\nWhen an auction has ended, there is a possibility to make the offers for an auctioned NFT as:\n\n`makeOffer` checks `_isInActiveAuction`:\n\nhttps://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L200\n\n`_isInActiveAuction` returns false when `auctionIdToAuction[auctionId].endTime < block.timestamp`, so `makeOffer` above can proceed:\n\nhttps://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L666-L669\n\nThen, the auction winner can call `acceptOffer -> _acceptOffer` (or `setBuyPrice -> _autoAcceptOffer -> _acceptOffer`).\n\n`_acceptOffer` will try to transfer directly, and then calls `_transferFromEscrow`:\n\nhttps://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L262-L271\n\nIf the auction has ended, but a winner hasn't picked up the NFT yet, the direct transfer will fail, proceeding with `_transferFromEscrow` in the FNDNFTMarket defined order:\n```\nfunction _transferFromEscrow(\naddress nftContract,\nuint256 tokenId,\naddress recipient,\naddress seller\n) internal override(NFTMarketCore, NFTMarketReserveAuction, NFTMarketBuyPrice, NFTMarketOffer) {\nsuper._transferFromEscrow(nftContract, tokenId, recipient, seller);\n}\n```\n\nNFTMarketOffer._transferFromEscrow will call super as `nftContractToIdToOffer` was already deleted:\n\nhttps://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L296-L302\n\nNFTMarketBuyPrice._transferFromEscrow will call super as there is no buy price set:\n\nhttps://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketBuyPrice.sol#L283-L293\n\nFinally, NFTMarketReserveAuction._transferFromEscrow will send the NFT to the winner via `_finalizeReserveAuction`, not to the user who made the offer:\n\nhttps://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L556-L560\n\nThe `recipient` user who made the offer is not present in this logic, the NFT is being transferred to the `auction.bidder`, and the original `acceptOffer` will go through successfully.\n\n## Recommended Mitigation Steps\n\nAn attempt to set a buy price from auction winner will lead to auction finalisation, so `_buy` cannot be called with a not yet finalised auction, this way the NFTMarketReserveAuction._transferFromEscrow L550-L560 logic is called from the NFTMarketOffer._acceptOffer only:\n\nhttps://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L270\n\nis the only user of \n\nhttps://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L550-L560\n\n\nThis way the fix is to update L556-L560 for the described case as:\n\nNow:\n```\n// Finalization will revert if the auction has not yet ended.\n_finalizeReserveAuction(auctionId, false);\n\n// Finalize includes the transfer, so we are done here.\nreturn;\n```\n\nTo be, we leave the NFT in the escrow and let L564 super call to transfer it to the recipient:\n```\n// Finalization will revert if the auction has not yet ended.\n_finalizeReserveAuction(auctionId, true);\n```\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-02-foundation-contest",
  "Code": [
    {
      "filename": "contracts/mixins/NFTMarketReserveAuction.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"../libraries/AccountMigrationLibrary.sol\";\nimport \"./Constants.sol\";\nimport \"./FoundationTreasuryNode.sol\";\nimport \"./NFTMarketAuction.sol\";\nimport \"./NFTMarketCore.sol\";\nimport \"./NFTMarketFees.sol\";\nimport \"./SendValueWithFallbackWithdraw.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\n/// @param minAmount The minimum amount that must be bid in order for it to be accepted.\nerror NFTMarketReserveAuction_Bid_Must_Be_At_Least_Min_Amount(uint256 minAmount);\nerror NFTMarketReserveAuction_Cannot_Admin_Cancel_Without_Reason();\n/// @param reservePrice The current reserve price.\nerror NFTMarketReserveAuction_Cannot_Bid_Lower_Than_Reserve_Price(uint256 reservePrice);\n/// @param endTime The timestamp at which the auction had ended.\nerror NFTMarketReserveAuction_Cannot_Bid_On_Ended_Auction(uint256 endTime);\nerror NFTMarketReserveAuction_Cannot_Bid_On_Nonexistent_Auction();\nerror NFTMarketReserveAuction_Cannot_Cancel_Nonexistent_Auction();\nerror NFTMarketReserveAuction_Cannot_Finalize_Already_Settled_Auction();\n/// @param endTime The timestamp at which the auction will end.\nerror NFTMarketReserveAuction_Cannot_Finalize_Auction_In_Progress(uint256 endTime);\n/// @param seller The current owner of the NFT.\nerror NFTMarketReserveAuction_Cannot_Migrate_Non_Matching_Seller(address seller);\nerror NFTMarketReserveAuction_Cannot_Rebid_Over_Outstanding_Bid();\nerror NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();\n/// @param maxDuration The maximum configuration for a duration of the auction, in seconds.\nerror NFTMarketReserveAuction_Exceeds_Max_Duration(uint256 maxDuration);\n/// @param extensionDuration The extension duration, in seconds.\nerror NFTMarketReserveAuction_Less_Than_Extension_Duration(uint256 extensionDuration);\nerror NFTMarketReserveAuction_Must_Set_Non_Zero_Reserve_Price();\n/// @param seller The current owner of the NFT.\nerror NFTMarketReserveAuction_Not_Matching_Seller(address seller);\n/// @param owner The current owner of the NFT.\nerror NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(address owner);\nerror NFTMarketReserveAuction_Too_Much_Value_Provided();\n\n/**\n * @title Allows the owner of an NFT to list it in auction.\n * @notice NFTs in auction are escrowed in the market contract.\n * @dev There is room to optimize the storage for auctions, significantly reducing gas costs.\n * This may be done in the future, but for now it will remain as is in order to ease upgrade compatibility.\n */\nabstract contract NFTMarketReserveAuction is\n  Constants,\n  FoundationTreasuryNode,\n  NFTMarketCore,\n  ReentrancyGuardUpgradeable,\n  SendValueWithFallbackWithdraw,\n  NFTMarketFees,\n  NFTMarketAuction\n{\n  using AccountMigrationLibrary for address;\n\n  /// @notice Stores the auction configuration for a specific NFT.\n  struct ReserveAuction {\n    /// @notice The address of the NFT contract.\n    address nftContract;\n    /// @notice The id of the NFT.\n    uint256 tokenId;\n    /// @notice The owner of the NFT which listed it in auction.\n    address payable seller;\n    /// @notice The duration for this auction.\n    uint256 duration;\n    /// @notice The extension window for this auction.\n    uint256 extensionDuration;\n    /// @notice The time at which this auction will not accept any new bids.\n    /// @dev This is `0` until the first bid is placed.\n    uint256 endTime;\n    /// @notice The current highest bidder in this auction.\n    /// @dev This is `address(0)` until the first bid is placed.\n    address payable bidder;\n    /// @notice The latest price of the NFT in this auction.\n    /// @dev This is set to the reserve price, and then to the highest bid once the auction has started.\n    uint256 amount;\n  }\n\n  /// @notice The auction configuration for a specific auction id.\n  mapping(address => mapping(uint256 => uint256)) private nftContractToTokenIdToAuctionId;\n  /// @notice The auction id for a specific NFT.\n  /// @dev This is deleted when an auction is finalized or canceled.\n  mapping(uint256 => ReserveAuction) private auctionIdToAuction;\n\n  /**\n   * @dev Removing old unused variables in an upgrade safe way. Was:\n   * uint256 private __gap_was_minPercentIncrementInBasisPoints;\n   * uint256 private __gap_was_maxBidIncrementRequirement;\n   * uint256 private __gap_was_duration;\n   * uint256 private __gap_was_extensionDuration;\n   * uint256 private __gap_was_goLiveDate;\n   */\n  uint256[5] private __gap_was_config;\n\n  /// @notice How long an auction lasts for once the first bid has been received.\n  uint256 private immutable DURATION;\n\n  /// @notice The window for auction extensions, any bid placed in the final 15 minutes\n  /// of an auction will reset the time remaining to 15 minutes.\n  uint256 private constant EXTENSION_DURATION = 15 minutes;\n\n  /// @notice Caps the max duration that may be configured so that overflows will not occur.\n  uint256 private constant MAX_MAX_DURATION = 1000 days;\n\n  /**\n   * @notice Emitted when a bid is placed.\n   * @param auctionId The id of the auction this bid was for.\n   * @param bidder The address of the bidder.\n   * @param amount The amount of the bid.\n   * @param endTime The new end time of the auction (which may have been set or extended by this bid).\n   */\n  event ReserveAuctionBidPlaced(uint256 indexed auctionId, address indexed bidder, uint256 amount, uint256 endTime);\n  /**\n   * @notice Emitted when an auction is cancelled.\n   * @dev This is only possible if the auction has not received any bids.\n   * @param auctionId The id of the auction that was cancelled.\n   */\n  event ReserveAuctionCanceled(uint256 indexed auctionId);\n  /**\n   * @notice Emitted when an auction is canceled by a Foundation admin.\n   * @dev When this occurs, the highest bidder (if there was a bid) is automatically refunded.\n   * @param auctionId The id of the auction that was cancelled.\n   * @param reason The reason for the cancellation.\n   */\n  event ReserveAuctionCanceledByAdmin(uint256 indexed auctionId, string reason);\n  /**\n   * @notice Emitted when an NFT is listed for auction.\n   * @param seller The address of the seller.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @param duration The duration of the auction (always 24-hours).\n   * @param extensionDuration The duration of the auction extension window (always 15-minutes).\n   * @param reservePrice The reserve price to kick off the auction.\n   * @param auctionId The id of the auction that was created.\n   */\n  event ReserveAuctionCreated(\n    address indexed seller,\n    address indexed nftContract,\n    uint256 indexed tokenId,\n    uint256 duration,\n    uint256 extensionDuration,\n    uint256 reservePrice,\n    uint256 auctionId\n  );\n  /**\n   * @notice Emitted when an auction that has already ended is finalized,\n   * indicating that the NFT has been transferred and revenue from the sale distributed.\n   * @dev The amount of the highest bid / final sale price for this auction is `f8nFee` + `creatorFee` + `ownerRev`.\n   * @param auctionId The id of the auction that was finalized.\n   * @param seller The address of the seller.\n   * @param bidder The address of the highest bidder that won the NFT.\n   * @param f8nFee The amount of ETH that was sent to Foundation for this sale.\n   * @param creatorFee The amount of ETH that was sent to the creator for this sale.\n   * @param ownerRev The amount of ETH that was sent to the owner for this sale.\n   */\n  event ReserveAuctionFinalized(\n    uint256 indexed auctionId,\n    address indexed seller,\n    address indexed bidder,\n    uint256 f8nFee,\n    uint256 creatorFee,\n    uint256 ownerRev\n  );\n  /**\n   * @notice Emitted when an auction is invalidated due to other market activity.\n   * @dev This occurs when the NFT is sold another way, such as with `buy` or `acceptOffer`.\n   * @param auctionId The id of the auction that was invalidated.\n   */\n  event ReserveAuctionInvalidated(uint256 indexed auctionId);\n  /**\n   * @notice Emitted when the seller for an auction has been changed to a new account.\n   * @dev Account migrations require approval from both the original account and Foundation.\n   * @param auctionId The id of the auction that was updated.\n   * @param originalSellerAddress The original address of the auction's seller.\n   * @param newSellerAddress The new address for the auction's seller.\n   */\n  event ReserveAuctionSellerMigrated(\n    uint256 indexed auctionId,\n    address indexed originalSellerAddress,\n    address indexed newSellerAddress\n  );\n  /**\n   * @notice Emitted when the auction's reserve price is changed.\n   * @dev This is only possible if the auction has not received any bids.\n   * @param auctionId The id of the auction that was updated.\n   * @param reservePrice The new reserve price for the auction.\n   */\n  event ReserveAuctionUpdated(uint256 indexed auctionId, uint256 reservePrice);\n\n  /// @notice Confirms that the reserve price is not zero.\n  modifier onlyValidAuctionConfig(uint256 reservePrice) {\n    if (reservePrice == 0) {\n      revert NFTMarketReserveAuction_Must_Set_Non_Zero_Reserve_Price();\n    }\n    _;\n  }\n\n  /**\n   * @notice Configures the duration for auctions.\n   * @param duration The duration for auctions, in seconds.\n   */\n  constructor(uint256 duration) {\n    if (duration > MAX_MAX_DURATION) {\n      // This ensures that math in this file will not overflow due to a huge duration.\n      revert NFTMarketReserveAuction_Exceeds_Max_Duration(MAX_MAX_DURATION);\n    }\n    if (duration < EXTENSION_DURATION) {\n      // The auction duration configuration must be greater than the extension window of 15 minutes\n      revert NFTMarketReserveAuction_Less_Than_Extension_Duration(EXTENSION_DURATION);\n    }\n    DURATION = duration;\n  }\n\n  /**\n   * @notice Allows Foundation to cancel an auction, refunding the bidder and returning the NFT to\n   * the seller (if not active buy price set).\n   * This should only be used for extreme cases such as DMCA takedown requests.\n   * @param auctionId The id of the auction to cancel.\n   * @param reason The reason for the cancellation (a required field).\n   */\n  function adminCancelReserveAuction(uint256 auctionId, string calldata reason)\n    external\n    onlyFoundationAdmin\n    nonReentrant\n  {\n    if (bytes(reason).length == 0) {\n      revert NFTMarketReserveAuction_Cannot_Admin_Cancel_Without_Reason();\n    }\n    ReserveAuction memory auction = auctionIdToAuction[auctionId];\n    if (auction.amount == 0) {\n      revert NFTMarketReserveAuction_Cannot_Cancel_Nonexistent_Auction();\n    }\n\n    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];\n    delete auctionIdToAuction[auctionId];\n\n    // Return the NFT to the owner.\n    _transferFromEscrowIfAvailable(auction.nftContract, auction.tokenId, auction.seller);\n\n    if (auction.bidder != address(0)) {\n      // Refund the highest bidder if any bids were placed in this auction.\n      _sendValueWithFallbackWithdraw(auction.bidder, auction.amount, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n    }\n\n    emit ReserveAuctionCanceledByAdmin(auctionId, reason);\n  }\n\n  /**\n   * @notice Allows an NFT owner and Foundation to work together in order to update the seller\n   * for auctions they have listed to a new account.\n   * @dev This will gracefully skip any auctions that have already been finalized.\n   * @param listedAuctionIds The ids of the auctions to update.\n   * @param originalAddress The original address of the seller of these auctions.\n   * @param newAddress The new address for the seller of these auctions.\n   * @param signature Message `I authorize Foundation to migrate my account to ${newAccount.address.toLowerCase()}`\n   * signed by the original account.\n   */\n  function adminAccountMigration(\n    uint256[] calldata listedAuctionIds,\n    address originalAddress,\n    address payable newAddress,\n    bytes memory signature\n  ) external onlyFoundationOperator {\n    // Validate the owner of the original account has approved this change.\n    originalAddress.requireAuthorizedAccountMigration(newAddress, signature);\n\n    unchecked {\n      // The array length cannot overflow 256 bits.\n      for (uint256 i = 0; i < listedAuctionIds.length; ++i) {\n        uint256 auctionId = listedAuctionIds[i];\n        ReserveAuction storage auction = auctionIdToAuction[auctionId];\n        if (auction.seller != address(0)) {\n          // Only if the auction was found and not finalized before this transaction.\n\n          if (auction.seller != originalAddress) {\n            // Confirm that the signature approval was the correct owner of this auction.\n            revert NFTMarketReserveAuction_Cannot_Migrate_Non_Matching_Seller(auction.seller);\n          }\n\n          // Update the auction's seller address.\n          auction.seller = newAddress;\n\n          emit ReserveAuctionSellerMigrated(auctionId, originalAddress, newAddress);\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice If an auction has been created but has not yet received bids, it may be canceled by the seller.\n   * @dev The NFT is transferred back to the owner unless there is still has a buy price set.\n   * @param auctionId The id of the auction to cancel.\n   */\n  function cancelReserveAuction(uint256 auctionId) external nonReentrant {\n    ReserveAuction memory auction = auctionIdToAuction[auctionId];\n    if (auction.seller != msg.sender) {\n      revert NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(auction.seller);\n    }\n    if (auction.endTime != 0) {\n      revert NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();\n    }\n\n    // Remove the auction.\n    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];\n    delete auctionIdToAuction[auctionId];\n\n    // Transfer the NFT unless it still has a buy price set.\n    _transferFromEscrowIfAvailable(auction.nftContract, auction.tokenId, auction.seller);\n\n    emit ReserveAuctionCanceled(auctionId);\n  }\n\n  /**\n   * @notice Creates an auction for the given NFT.\n   * The NFT is held in escrow until the auction is finalized or canceled.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @param reservePrice The initial reserve price for the auction.\n   */\n  function createReserveAuction(\n    address nftContract,\n    uint256 tokenId,\n    uint256 reservePrice\n  ) external nonReentrant onlyValidAuctionConfig(reservePrice) {\n    uint256 auctionId = _getNextAndIncrementAuctionId();\n\n    // If the `msg.sender` is not the owner of the NFT, transferring into escrow should fail.\n    _transferToEscrow(nftContract, tokenId);\n\n    // Store the auction details\n    nftContractToTokenIdToAuctionId[nftContract][tokenId] = auctionId;\n    auctionIdToAuction[auctionId] = ReserveAuction(\n      nftContract,\n      tokenId,\n      payable(msg.sender),\n      DURATION,\n      EXTENSION_DURATION,\n      0, // endTime is only known once the reserve price is met\n      payable(0), // bidder is only known once a bid has been placed\n      reservePrice\n    );\n\n    emit ReserveAuctionCreated(msg.sender, nftContract, tokenId, DURATION, EXTENSION_DURATION, reservePrice, auctionId);\n  }\n\n  /**\n   * @notice Once the countdown has expired for an auction, anyone can settle the auction.\n   * This will send the NFT to the highest bidder and distribute revenue for this sale.\n   * @param auctionId The id of the auction to settle.\n   */\n  function finalizeReserveAuction(uint256 auctionId) external nonReentrant {\n    if (auctionIdToAuction[auctionId].endTime == 0) {\n      revert NFTMarketReserveAuction_Cannot_Finalize_Already_Settled_Auction();\n    }\n    _finalizeReserveAuction(auctionId, false);\n  }\n\n  /**\n   * @notice Place a bid in an auction.\n   * A bidder may place a bid which is at least the value defined by `getMinBidAmount`.\n   * If this is the first bid on the auction, the countdown will begin.\n   * If there is already an outstanding bid, the previous bidder will be refunded at this time\n   * and if the bid is placed in the final moments of the auction, the countdown may be extended.\n   * @param auctionId The id of the auction to bid on.\n   */\n  function placeBid(uint256 auctionId) external payable {\n    placeBidOf(auctionId, msg.value);\n  }\n\n  /**\n   * @notice Place a bid in an auction.\n   * A bidder may place a bid which is at least the amount defined by `getMinBidAmount`.\n   * If this is the first bid on the auction, the countdown will begin.\n   * If there is already an outstanding bid, the previous bidder will be refunded at this time\n   * and if the bid is placed in the final moments of the auction, the countdown may be extended.\n   * @dev `amount` - `msg.value` is withdrawn from the bidder's FETH balance.\n   * @param auctionId The id of the auction to bid on.\n   * @param amount The amount to bid, if this is more than `msg.value` funds will be withdrawn from your FETH balance.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function placeBidOf(uint256 auctionId, uint256 amount) public payable nonReentrant {\n    if (amount < msg.value) {\n      // The amount is specified by the bidder, so if too much ETH is sent then something went wrong.\n      revert NFTMarketReserveAuction_Too_Much_Value_Provided();\n    } else if (amount > msg.value) {\n      // Withdraw additional ETH required from their available FETH balance.\n\n      unchecked {\n        // The if above ensures delta will not underflow.\n        uint256 delta = amount - msg.value;\n\n        // Withdraw ETH from the buyer's account in the FETH token contract.\n        feth.marketWithdrawFrom(msg.sender, delta);\n      }\n    }\n\n    ReserveAuction storage auction = auctionIdToAuction[auctionId];\n\n    if (auction.amount == 0) {\n      // No auction found\n      revert NFTMarketReserveAuction_Cannot_Bid_On_Nonexistent_Auction();\n    }\n\n    if (auction.endTime == 0) {\n      // This is the first bid, kicking off the auction.\n\n      if (auction.amount > amount) {\n        // The bid must be >= the reserve price.\n        revert NFTMarketReserveAuction_Cannot_Bid_Lower_Than_Reserve_Price(auction.amount);\n      }\n\n      // Notify other market tools that an auction for this NFT has been kicked off.\n      _afterAuctionStarted(auction.nftContract, auction.tokenId);\n\n      // Store the bid details.\n      auction.amount = amount;\n      auction.bidder = payable(msg.sender);\n\n      // On the first bid, set the endTime to now + duration.\n      unchecked {\n        // Duration is always set to 24hrs so the below can't overflow.\n        auction.endTime = block.timestamp + auction.duration;\n      }\n    } else {\n      if (auction.endTime < block.timestamp) {\n        // The auction has already ended.\n        revert NFTMarketReserveAuction_Cannot_Bid_On_Ended_Auction(auction.endTime);\n      } else if (auction.bidder == msg.sender) {\n        // We currently do not allow a bidder to increase their bid unless another user has outbid them first.\n        revert NFTMarketReserveAuction_Cannot_Rebid_Over_Outstanding_Bid();\n      } else if (amount < _getMinIncrement(auction.amount)) {\n        // If this bid outbids another, it must be at least 10% greater than the last bid.\n        revert NFTMarketReserveAuction_Bid_Must_Be_At_Least_Min_Amount(_getMinIncrement(auction.amount));\n      }\n\n      // Cache and update bidder state\n      uint256 originalAmount = auction.amount;\n      address payable originalBidder = auction.bidder;\n      auction.amount = amount;\n      auction.bidder = payable(msg.sender);\n\n      unchecked {\n        // When a bid outbids another, check to see if a time extension should apply.\n        // We confirmed that the auction has not ended, so endTime is always >= the current timestamp.\n        if (auction.endTime - block.timestamp < auction.extensionDuration) {\n          // Current time plus extension duration (always 15 mins) cannot overflow.\n          auction.endTime = block.timestamp + auction.extensionDuration;\n        }\n      }\n\n      // Refund the previous bidder\n      _sendValueWithFallbackWithdraw(originalBidder, originalAmount, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n    }\n\n    emit ReserveAuctionBidPlaced(auctionId, msg.sender, amount, auction.endTime);\n  }\n\n  /**\n   * @notice If an auction has been created but has not yet received bids, the reservePrice may be\n   * changed by the seller.\n   * @param auctionId The id of the auction to change.\n   * @param reservePrice The new reserve price for this auction.\n   */\n  function updateReserveAuction(uint256 auctionId, uint256 reservePrice) external onlyValidAuctionConfig(reservePrice) {\n    ReserveAuction storage auction = auctionIdToAuction[auctionId];\n    if (auction.seller != msg.sender) {\n      revert NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(auction.seller);\n    } else if (auction.endTime != 0) {\n      revert NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();\n    }\n\n    // Update the current reserve price.\n    auction.amount = reservePrice;\n\n    emit ReserveAuctionUpdated(auctionId, reservePrice);\n  }\n\n  /**\n   * @notice Settle an auction that has already ended.\n   * This will send the NFT to the highest bidder and distribute revenue for this sale.\n   * @param keepInEscrow If true, the NFT will be kept in escrow to save gas by avoiding\n   * redundant transfers if the NFT should remain in escrow, such as when the new owner\n   * sets a buy price or lists it in a new auction.\n   */\n  function _finalizeReserveAuction(uint256 auctionId, bool keepInEscrow) private {\n    ReserveAuction memory auction = auctionIdToAuction[auctionId];\n\n    if (auction.endTime >= block.timestamp) {\n      revert NFTMarketReserveAuction_Cannot_Finalize_Auction_In_Progress(auction.endTime);\n    }\n\n    // Remove the auction.\n    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];\n    delete auctionIdToAuction[auctionId];\n\n    if (!keepInEscrow) {\n      /*\n       * Save gas by calling core directly since it cannot have another escrow requirement\n       * (buy price set or another auction listed) until this one has been finalized.\n       */\n      NFTMarketCore._transferFromEscrow(auction.nftContract, auction.tokenId, auction.bidder, address(0));\n    }\n\n    // Distribute revenue for this sale.\n    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(\n      auction.nftContract,\n      auction.tokenId,\n      auction.seller,\n      auction.amount\n    );\n\n    emit ReserveAuctionFinalized(auctionId, auction.seller, auction.bidder, f8nFee, creatorFee, ownerRev);\n  }\n\n  /**\n   * @inheritdoc NFTMarketCore\n   * @dev If an auction is found:\n   *  - If the auction is over, it will settle the auction and confirm the new seller won the auction.\n   *  - If the auction has not received a bid, it will invalidate the auction.\n   *  - If the auction is in progress, this will revert.\n   */\n  function _transferFromEscrow(\n    address nftContract,\n    uint256 tokenId,\n    address recipient,\n    address seller\n  ) internal virtual override {\n    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];\n    if (auctionId != 0) {\n      ReserveAuction storage auction = auctionIdToAuction[auctionId];\n      if (auction.endTime == 0) {\n        // The auction has not received any bids yet so it may be invalided.\n\n        if (auction.seller != seller) {\n          // The account trying to transfer the NFT is not the current owner.\n          revert NFTMarketReserveAuction_Not_Matching_Seller(auction.seller);\n        }\n\n        // Remove the auction.\n        delete nftContractToTokenIdToAuctionId[nftContract][tokenId];\n        delete auctionIdToAuction[auctionId];\n\n        emit ReserveAuctionInvalidated(auctionId);\n      } else {\n        // If the auction has started, the highest bidder will be the new owner.\n\n        if (auction.bidder != seller) {\n          revert NFTMarketReserveAuction_Not_Matching_Seller(auction.bidder);\n        }\n\n        // Finalization will revert if the auction has not yet ended.\n        _finalizeReserveAuction(auctionId, false);\n\n        // Finalize includes the transfer, so we are done here.\n        return;\n      }\n    }\n\n    super._transferFromEscrow(nftContract, tokenId, recipient, seller);\n  }\n\n  /**\n   * @inheritdoc NFTMarketCore\n   * @dev Checks if there is an auction for this NFT before allowing the transfer to continue.\n   */\n  function _transferFromEscrowIfAvailable(\n    address nftContract,\n    uint256 tokenId,\n    address recipient\n  ) internal virtual override {\n    if (nftContractToTokenIdToAuctionId[nftContract][tokenId] == 0) {\n      // No auction was found\n\n      super._transferFromEscrowIfAvailable(nftContract, tokenId, recipient);\n    }\n  }\n\n  /**\n   * @inheritdoc NFTMarketCore\n   */\n  function _transferToEscrow(address nftContract, uint256 tokenId) internal virtual override {\n    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];\n    if (auctionId == 0) {\n      // NFT is not in auction\n      super._transferToEscrow(nftContract, tokenId);\n      return;\n    }\n    // Using storage saves gas since most of the data is not needed\n    ReserveAuction storage auction = auctionIdToAuction[auctionId];\n    if (auction.endTime == 0) {\n      // Reserve price set, confirm the seller is a match\n      if (auction.seller != msg.sender) {\n        revert NFTMarketReserveAuction_Not_Matching_Seller(auction.seller);\n      }\n    } else {\n      // Auction in progress, confirm the highest bidder is a match\n      if (auction.bidder != msg.sender) {\n        revert NFTMarketReserveAuction_Not_Matching_Seller(auction.bidder);\n      }\n\n      // Finalize auction but leave NFT in escrow, reverts if the auction has not ended\n      _finalizeReserveAuction(auctionId, true);\n    }\n  }\n\n  /**\n   * @notice Returns the minimum amount a bidder must spend to participate in an auction.\n   * Bids must be greater than or equal to this value or they will revert.\n   * @param auctionId The id of the auction to check.\n   * @return minimum The minimum amount for a bid to be accepted.\n   */\n  function getMinBidAmount(uint256 auctionId) external view returns (uint256 minimum) {\n    ReserveAuction storage auction = auctionIdToAuction[auctionId];\n    if (auction.endTime == 0) {\n      return auction.amount;\n    }\n    return _getMinIncrement(auction.amount);\n  }\n\n  /**\n   * @notice Returns auction details for a given auctionId.\n   * @param auctionId The id of the auction to lookup.\n   * @return auction The auction details.\n   */\n  function getReserveAuction(uint256 auctionId) external view returns (ReserveAuction memory auction) {\n    return auctionIdToAuction[auctionId];\n  }\n\n  /**\n   * @notice Returns the auctionId for a given NFT, or 0 if no auction is found.\n   * @dev If an auction is canceled, it will not be returned. However the auction may be over and pending finalization.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @return auctionId The id of the auction, or 0 if no auction is found.\n   */\n  function getReserveAuctionIdFor(address nftContract, uint256 tokenId) external view returns (uint256 auctionId) {\n    return nftContractToTokenIdToAuctionId[nftContract][tokenId];\n  }\n\n  /**\n   * @inheritdoc NFTMarketCore\n   * @dev Returns the seller that has the given NFT in escrow for an auction,\n   * or bubbles the call up for other considerations.\n   */\n  function _getSellerFor(address nftContract, uint256 tokenId)\n    internal\n    view\n    virtual\n    override\n    returns (address payable seller)\n  {\n    seller = auctionIdToAuction[nftContractToTokenIdToAuctionId[nftContract][tokenId]].seller;\n    if (seller == address(0)) {\n      seller = super._getSellerFor(nftContract, tokenId);\n    }\n  }\n\n  /**\n   * @inheritdoc NFTMarketCore\n   */\n  function _isInActiveAuction(address nftContract, uint256 tokenId) internal view override returns (bool) {\n    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];\n    return auctionId != 0 && auctionIdToAuction[auctionId].endTime >= block.timestamp;\n  }\n\n  /**\n   * @notice This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[1000] private __gap;\n}"
    }
  ]
}