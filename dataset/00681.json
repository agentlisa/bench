{
  "Title": "`LpTokenStaker.getTimeToFullBoost()` - a full boost can be reached faster in some cases",
  "Content": "##### Description\n\nA full boost in this function only accounts for the time boost:\n\n- https://github.com/ConicFinance/protocol/blob/7a66d26ef84f93059a811a189655e17c11d95f5c/contracts/tokenomics/LpTokenStaker.sol#L136-L140\n\nThe function only calculates +30 days since `userBoost.lastUpdated`\n\nBut in fact, given `stakeBoost`, totalBoost can be reached much faster than 30 days if capped with MAX_BOOST amount.\nFor example, given max available `stakeBoost` of 5, `timeBoost` will reach the cap in ~3 days, not 30 days.\n\n##### Recommendation\n\nIf this behavior is not desired, we recommend taking into account `stakeBoost` when calculating the function.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/tokenomics/LpTokenStaker.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../interfaces/tokenomics/ILpTokenStaker.sol\";\nimport \"../../interfaces/tokenomics/IInflationManager.sol\";\nimport \"../../interfaces/IController.sol\";\nimport \"../../interfaces/pools/IConicPool.sol\";\nimport \"../../interfaces/pools/ILpToken.sol\";\nimport \"../../interfaces/tokenomics/ICNCToken.sol\";\nimport \"../../libraries/ScaledMath.sol\";\n\n/// @dev USD amounts in this contract are always scaled by 1e18\ncontract LpTokenStaker is ILpTokenStaker {\n    using SafeERC20 for IERC20;\n    using SafeERC20 for ILpToken;\n    using ScaledMath for uint256;\n    struct Boost {\n        uint256 timeBoost;\n        uint256 lastUpdated;\n    }\n\n    uint256 public constant MAX_BOOST = 10e18;\n    uint256 public constant MIN_BOOST = 1e18;\n    uint256 public constant TIME_STARTING_FACTOR = 1e17;\n    uint256 public constant INCREASE_PERIOD = 30 days;\n    uint256 public constant TVL_FACTOR = 50e18;\n\n    mapping(address => mapping(address => uint256)) internal stakedPerUser;\n    mapping(address => uint256) internal _stakedPerPool;\n    mapping(address => Boost) public boosts;\n\n    mapping(address => uint256) public poolShares;\n    mapping(address => uint256) public poolLastUpdated;\n\n    IController public immutable controller;\n    ICNCToken public immutable cnc;\n\n    bool public isShutdown;\n\n    modifier notShutdown() {\n        require(!isShutdown, \"LpTokenStaker: shutdown\");\n        _;\n    }\n\n    constructor(address controller_, ICNCToken _cnc) {\n        controller = IController(controller_);\n        cnc = _cnc;\n        _initializeLastUpdated();\n    }\n\n    function stake(uint256 amount, address conicPool) external override {\n        stakeFor(amount, conicPool, msg.sender);\n    }\n\n    function unstake(uint256 amount, address conicPool) external override {\n        unstakeFor(amount, conicPool, msg.sender);\n    }\n\n    function stakeFor(\n        uint256 amount,\n        address conicPool,\n        address account\n    ) public override notShutdown {\n        require(controller.isPool(conicPool), \"not a conic pool\");\n        ILpToken lpToken = IConicPool(conicPool).lpToken();\n        uint256 exchangeRate = IConicPool(conicPool).usdExchangeRate();\n        // Checkpoint all inflation logic\n        IConicPool(conicPool).rewardManager().accountCheckpoint(account);\n        _stakerCheckpoint(\n            account,\n            amount.convertScale(lpToken.decimals(), 18).mulDown(exchangeRate)\n        );\n        // Actual staking\n        lpToken.safeTransferFrom(msg.sender, address(this), amount);\n        if (!controller.isPool(msg.sender)) {\n            lpToken.taint(msg.sender, account);\n        }\n        stakedPerUser[account][conicPool] += amount;\n        _stakedPerPool[conicPool] += amount;\n    }\n\n    function unstakeFor(uint256 amount, address conicPool, address account) public override {\n        require(controller.isPool(conicPool), \"not a conic pool\");\n        require(stakedPerUser[msg.sender][conicPool] >= amount, \"not enough staked\");\n        // Checkpoint all inflation logic\n        if (!isShutdown) {\n            IConicPool(conicPool).rewardManager().accountCheckpoint(msg.sender);\n            _stakerCheckpoint(msg.sender, 0);\n        }\n        // Actual unstaking\n        stakedPerUser[msg.sender][conicPool] -= amount;\n        _stakedPerPool[conicPool] -= amount;\n        IConicPool(conicPool).lpToken().safeTransfer(account, amount);\n        IConicPool(conicPool).lpToken().taint(msg.sender, account);\n    }\n\n    function unstakeFrom(uint256 amount, address account) public override {\n        require(controller.isPool(msg.sender), \"only callable from conic pool\");\n        require(stakedPerUser[account][msg.sender] >= amount, \"not enough staked\");\n        // Checkpoint all inflation logic\n        IConicPool(msg.sender).rewardManager().accountCheckpoint(account);\n        _stakerCheckpoint(account, 0);\n        // Actual unstaking\n        stakedPerUser[account][msg.sender] -= amount;\n        _stakedPerPool[msg.sender] -= amount;\n        IConicPool(msg.sender).lpToken().safeTransfer(account, amount);\n    }\n\n    function shutdown() external {\n        require(msg.sender == address(controller), \"LpTokenStaker: not controller\");\n        address[] memory pools = controller.listPools();\n        for (uint256 i; i < pools.length; i++) {\n            _claimCNCRewardsForPool(pools[i]);\n        }\n        isShutdown = true;\n        emit Shutdown();\n    }\n\n    function getUserBalanceForPool(\n        address conicPool,\n        address account\n    ) external view override returns (uint256) {\n        return stakedPerUser[account][conicPool];\n    }\n\n    function getBalanceForPool(address conicPool) external view override returns (uint256) {\n        return _stakedPerPool[conicPool];\n    }\n\n    function getCachedBoost(address user) external view returns (uint256) {\n        return boosts[user].timeBoost;\n    }\n\n    function getTimeToFullBoost(address user) external view returns (uint256) {\n        uint256 fullBoostAt_ = boosts[user].lastUpdated + INCREASE_PERIOD;\n        if (fullBoostAt_ <= block.timestamp) return 0;\n        return fullBoostAt_ - block.timestamp;\n    }\n\n    function getBoost(address user) external view override returns (uint256) {\n        if (isShutdown) return MIN_BOOST;\n        (uint256 userStakedUSD, uint256 totalStakedUSD) = _getTotalStakedForUserCommonDenomination(\n            user\n        );\n        if (totalStakedUSD == 0 || userStakedUSD == 0) {\n            return MIN_BOOST;\n        }\n        uint256 stakeBoost = ScaledMath.ONE +\n            userStakedUSD.divDown(totalStakedUSD).mulDown(TVL_FACTOR);\n\n        Boost storage userBoost = boosts[user];\n        uint256 timeBoost = userBoost.timeBoost;\n        timeBoost += (block.timestamp - userBoost.lastUpdated).divDown(INCREASE_PERIOD).mulDown(\n            ScaledMath.ONE - TIME_STARTING_FACTOR\n        );\n        if (timeBoost > ScaledMath.ONE) {\n            timeBoost = ScaledMath.ONE;\n        }\n        uint256 totalBoost = stakeBoost.mulDown(timeBoost);\n        if (totalBoost < MIN_BOOST) {\n            totalBoost = MIN_BOOST;\n        } else if (totalBoost > MAX_BOOST) {\n            totalBoost = MAX_BOOST;\n        }\n        return totalBoost;\n    }\n\n    function updateBoost(address user) external override notShutdown {\n        (uint256 userStaked, ) = _getTotalStakedForUserCommonDenomination(user);\n        _updateTimeBoost(user, userStaked, 0);\n    }\n\n    function claimCNCRewardsForPool(address pool) external override notShutdown {\n        require(\n            msg.sender == address(IConicPool(pool).rewardManager()),\n            \"can only be called by reward manager\"\n        );\n        _claimCNCRewardsForPool(pool);\n    }\n\n    function _claimCNCRewardsForPool(address pool) internal {\n        require(controller.isPool(pool), \"not a pool\");\n        checkpoint(pool);\n        uint256 cncToMint = poolShares[pool];\n        if (cncToMint == 0) {\n            return;\n        }\n        cnc.mint(address(pool), cncToMint);\n        controller.inflationManager().executeInflationRateUpdate();\n        poolShares[pool] = 0;\n        emit TokensClaimed(pool, cncToMint);\n    }\n\n    function claimableCnc(address pool) public view override returns (uint256) {\n        if (isShutdown) return 0;\n        uint256 currentRate = controller.inflationManager().getCurrentPoolInflationRate(pool);\n        uint256 timeElapsed = block.timestamp - poolLastUpdated[pool];\n        return poolShares[pool] + (currentRate * timeElapsed);\n    }\n\n    function _stakerCheckpoint(address account, uint256 amountAddedUSD) internal {\n        (uint256 userStakedUSD, ) = _getTotalStakedForUserCommonDenomination(account);\n        _updateTimeBoost(account, userStakedUSD, amountAddedUSD);\n    }\n\n    function checkpoint(address pool) public override notShutdown returns (uint256) {\n        // Update the integral of total token supply for the pool\n        uint256 timeElapsed = block.timestamp - poolLastUpdated[pool];\n        if (timeElapsed == 0) return poolShares[pool];\n        poolCheckpoint(pool);\n        poolLastUpdated[pool] = block.timestamp;\n        return poolShares[pool];\n    }\n\n    function poolCheckpoint(address pool) internal {\n        uint256 currentRate = controller.inflationManager().getCurrentPoolInflationRate(pool);\n        uint256 timeElapsed = block.timestamp - poolLastUpdated[pool];\n        poolShares[pool] += (currentRate * timeElapsed);\n    }\n\n    function _updateTimeBoost(\n        address user,\n        uint256 userStakedUSD,\n        uint256 amountAddedUSD\n    ) internal {\n        Boost storage userBoost = boosts[user];\n\n        if (userStakedUSD == 0) {\n            userBoost.timeBoost = TIME_STARTING_FACTOR;\n            userBoost.lastUpdated = block.timestamp;\n            return;\n        }\n        uint256 newBoost;\n        newBoost = userBoost.timeBoost;\n        newBoost += (block.timestamp - userBoost.lastUpdated).divDown(INCREASE_PERIOD).mulDown(\n            ScaledMath.ONE - TIME_STARTING_FACTOR\n        );\n        if (newBoost > ScaledMath.ONE) {\n            newBoost = ScaledMath.ONE;\n        }\n        if (amountAddedUSD == 0) {\n            userBoost.timeBoost = newBoost;\n        } else {\n            uint256 newTotalStakedUSD = userStakedUSD + amountAddedUSD;\n            userBoost.timeBoost =\n                newBoost.mulDown(userStakedUSD.divDown(newTotalStakedUSD)) +\n                TIME_STARTING_FACTOR.mulDown(amountAddedUSD.divDown(newTotalStakedUSD));\n        }\n        userBoost.lastUpdated = block.timestamp;\n    }\n\n    function _getUserUSDStakedInPool(\n        address account,\n        address pool\n    ) internal view returns (uint256 poolStaked, uint256 poolUserStaked) {\n        uint256 curExchangeRate = IConicPool(pool).usdExchangeRate();\n\n        uint8 decimals = IConicPool(pool).lpToken().decimals();\n        poolStaked = _stakedPerPool[pool].convertScale(decimals, 18).mulDown(curExchangeRate);\n        poolUserStaked = stakedPerUser[account][pool].convertScale(decimals, 18).mulDown(\n            curExchangeRate\n        );\n    }\n\n    function _getTotalStakedForUserCommonDenomination(\n        address account\n    ) public view returns (uint256, uint256) {\n        address[] memory conicPools = controller.listPools();\n        uint256 totalStakedUSD = 0;\n        uint256 userStakedUSD = 0;\n        for (uint256 i; i < conicPools.length; i++) {\n            (uint256 poolStakedUSD, uint256 poolUserStakedUSD) = _getUserUSDStakedInPool(\n                account,\n                conicPools[i]\n            );\n            totalStakedUSD += poolStakedUSD;\n            userStakedUSD += poolUserStakedUSD;\n        }\n        return (userStakedUSD, totalStakedUSD);\n    }\n\n    function _initializeLastUpdated() internal {\n        address[] memory pools = controller.listPools();\n        for (uint256 i; i < pools.length; i++) {\n            poolLastUpdated[pools[i]] = block.timestamp;\n        }\n    }\n}"
    }
  ]
}