{
  "Title": "[L12] Unnecessary code repetition in CompleteSets contract",
  "Content": "The `CompleteSets` contract includes the functions [`publicSellCompleteSets`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/CompleteSets.sol#L69) and [`publicSellCompleteSetsWithCash`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/CompleteSets.sol#L76), which implement the exact same logic, both calling the [`sellCompleteSets`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/CompleteSets.sol#L83) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/CompleteSets.sol#L83). Similarly, the functions [`publicBuyCompleteSets`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/CompleteSets.sol#L35) and [`publicBuyCompleteSetsWithCash`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/CompleteSets.sol#L42) also behave the same, in this case calling the [`buyCompleteSets`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/CompleteSets.sol#L49) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/CompleteSets.sol#L49). Therefore, so as to favor simplicity, avoid confusions and reduce the codeâ€™s attack surface, consider removing one in each pair functions.\n\n\n***Update****: fixed in* [*`ebed2db`*](https://github.com/AugurProject/augur/commit/edeb2d90bf5b3f8b8906a4190b924dd25560c980) *by removing the* *`publicSellCompleteSetsWithCash`* *and* *`publicBuyCompleteSetsWithCash`* *functions.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/augur-core/source/contracts/trading/CompleteSets.sol",
      "content": "pragma solidity 0.5.4;\n\n\nimport 'ROOT/trading/ICompleteSets.sol';\nimport 'ROOT/IAugur.sol';\nimport 'ROOT/libraries/ReentrancyGuard.sol';\nimport 'ROOT/libraries/math/SafeMathUint256.sol';\nimport 'ROOT/trading/ICash.sol';\nimport 'ROOT/reporting/IMarket.sol';\nimport 'ROOT/reporting/IDisputeWindow.sol';\nimport 'ROOT/reporting/IAuction.sol';\nimport 'ROOT/trading/IOrders.sol';\nimport 'ROOT/libraries/Initializable.sol';\nimport 'ROOT/IAugur.sol';\n\n\ncontract CompleteSets is Initializable, ReentrancyGuard, ICompleteSets {\n    using SafeMathUint256 for uint256;\n\n    IAugur public augur;\n    ICash public cash;\n    address public fillOrder;\n\n    function initialize(IAugur _augur) public beforeInitialized returns (bool) {\n        endInitialization();\n        augur = _augur;\n        fillOrder = augur.lookup(\"FillOrder\");\n        cash = ICash(augur.lookup(\"Cash\"));\n        return true;\n    }\n\n    /**\n     * Buys `_amount` shares of every outcome in the specified market.\n    **/\n    function publicBuyCompleteSets(IMarket _market, uint256 _amount) external afterInitialized returns (bool) {\n        this.buyCompleteSets(msg.sender, _market, _amount);\n        augur.logCompleteSetsPurchased(_market.getUniverse(), _market, msg.sender, _amount);\n        _market.assertBalances();\n        return true;\n    }\n\n    function publicBuyCompleteSetsWithCash(IMarket _market, uint256 _amount) external afterInitialized returns (bool) {\n        this.buyCompleteSets(msg.sender, _market, _amount);\n        augur.logCompleteSetsPurchased(_market.getUniverse(), _market, msg.sender, _amount);\n        _market.assertBalances();\n        return true;\n    }\n\n    function buyCompleteSets(address _sender, IMarket _market, uint256 _amount) external nonReentrant returns (bool) {\n        require(augur.isValidMarket(_market));\n        require(msg.sender == fillOrder || msg.sender == address(this));\n        require(_sender != address(0));\n\n        uint256 _numOutcomes = _market.getNumberOfOutcomes();\n\n        uint256 _cost = _amount.mul(_market.getNumTicks());\n        require(augur.trustedTransfer(cash, _sender, address(_market), _cost));\n        for (uint256 _outcome = 0; _outcome < _numOutcomes; ++_outcome) {\n            _market.getShareToken(_outcome).createShares(_sender, _amount);\n        }\n\n        if (!_market.isFinalized()) {\n            _market.getUniverse().incrementOpenInterest(_cost);\n        }\n\n        return true;\n    }\n\n    function publicSellCompleteSets(IMarket _market, uint256 _amount) external afterInitialized returns (bool) {\n        (uint256 _creatorFee, uint256 _reportingFee) = this.sellCompleteSets(msg.sender, _market, _amount, address(0));\n        augur.logCompleteSetsSold(_market.getUniverse(), _market, msg.sender, _amount, _creatorFee, _reportingFee);\n        _market.assertBalances();\n        return true;\n    }\n\n    function publicSellCompleteSetsWithCash(IMarket _market, uint256 _amount) external afterInitialized returns (bool) {\n        (uint256 _creatorFee, uint256 _reportingFee) = this.sellCompleteSets(msg.sender, _market, _amount, address(0));\n        augur.logCompleteSetsSold(_market.getUniverse(), _market, msg.sender, _amount, _creatorFee, _reportingFee);\n        _market.assertBalances();\n        return true;\n    }\n\n    function sellCompleteSets(address _sender, IMarket _market, uint256 _amount, address _affiliateAddress) external afterInitialized nonReentrant returns (uint256 _creatorFee, uint256 _reportingFee) {\n        require(augur.isValidMarket(_market));\n        require(msg.sender == fillOrder || msg.sender == address(this));\n        require(_sender != address(0));\n\n        uint256 _numOutcomes = _market.getNumberOfOutcomes();\n        uint256 _payout = _amount.mul(_market.getNumTicks());\n        if (!_market.isFinalized()) {\n            _market.getUniverse().decrementOpenInterest(_payout);\n        }\n        _creatorFee = _market.deriveMarketCreatorFeeAmount(_payout);\n        uint256 _reportingFeeDivisor = _market.getUniverse().getOrCacheReportingFeeDivisor();\n        _reportingFee = _payout.div(_reportingFeeDivisor);\n        _payout = _payout.sub(_creatorFee).sub(_reportingFee);\n\n        // Takes shares away from participant and decreases the amount issued in the market since we're exchanging complete sets\n        for (uint256 _outcome = 0; _outcome < _numOutcomes; ++_outcome) {\n            _market.getShareToken(_outcome).destroyShares(_sender, _amount);\n        }\n\n        if (_creatorFee != 0) {\n            _market.recordMarketCreatorFees(_creatorFee, _affiliateAddress);\n        }\n        if (_reportingFee != 0) {\n            require(cash.transferFrom(address(_market), address(_market.getUniverse().getOrCreateNextDisputeWindow(false)), _reportingFee));\n        }\n        require(cash.transferFrom(address(_market), _sender, _payout));\n\n        return (_creatorFee, _reportingFee);\n    }\n}"
    }
  ]
}