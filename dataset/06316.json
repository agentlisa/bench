{
  "Title": "[03] `renounceOwnership()` doesn't notify `UniversalReceiver`",
  "Content": "\nFunction `renounceOwnership()` doesn't notify `UniversalReceiver`, while `transferOwnership()`  and `acceptOwnership()`.\nThis is inconsistent and could mean the administration and verification of ownership isn't accurate, especially because the operation can be started via a `controller` that isn't the `owner` (see [LSP0ERC725AccountCore.sol renounceOwnership](https://github.com/lukso-network/lsp-smart-contracts/blob/v0.10.2/contracts/LSP0ERC725Account/LSP0ERC725AccountCore.sol#L655-L679)).\n\n*Note: this situation exists in both `LSP0ERC725AccountCore` and `LSP14Ownable2Step`.*\n\n### Proof of Concept\n[LSP0ERC725AccountCore.sol#L557-L697](https://github.com/lukso-network/lsp-smart-contracts/blob/v0.10.2/contracts/LSP0ERC725Account/LSP0ERC725AccountCore.sol#L557-L697)\n```solidity\nabstract contract LSP0ERC725AccountCore is\n    function transferOwnership(...) ... {\n        ...\n        pendingNewOwner.tryNotifyUniversalReceiver(_TYPEID_LSP0_OwnershipTransferStarted,\"\");\n        ...\n    }\n    function acceptOwnership() ... {\n        ...\n        previousOwner.tryNotifyUniversalReceiver(_TYPEID_LSP0_OwnershipTransferred_SenderNotification,\"\");\n        msg.sender.tryNotifyUniversalReceiver(_TYPEID_LSP0_OwnershipTransferred_RecipientNotification,\"\");\n    }\n    function renounceOwnership() .. {\n       ... // no tryNotifyUniversalReceiver\n    }\n}\n```\n[LSP14Ownable2Step.sol#L66-L113](https://github.com/lukso-network/lsp-smart-contracts/blob/v0.10.2/contracts/LSP14Ownable2Step/LSP14Ownable2Step.sol#L66-L113)\n```solidity\nabstract contract LSP14Ownable2Step is ... {\n    function transferOwnership(...) ... { \n        ...\n        newOwner.tryNotifyUniversalReceiver(_TYPEID_LSP14_OwnershipTransferStarted,\"\");\n        ...\n    }\n    function acceptOwnership() public virtual {\n        ...\n        previousOwner.tryNotifyUniversalReceiver(_TYPEID_LSP14_OwnershipTransferred_SenderNotification,\"\");\n        msg.sender.tryNotifyUniversalReceiver(_TYPEID_LSP14_OwnershipTransferred_RecipientNotification,\"\");\n    }\n   function renounceOwnership() .. {\n       ... // no tryNotifyUniversalReceiver\n    }\n}\n```\n\n### Recommended Mitigation Steps\nAlso send updates from `renounceOwnership()`.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-06-lukso",
  "Code": [
    {
      "filename": "contracts/LSP0ERC725Account/LSP0ERC725AccountCore.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.4;\n\n// interfaces\nimport {IERC1271} from \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\nimport {ILSP0ERC725Account} from \"./ILSP0ERC725Account.sol\";\nimport {\n    ILSP1UniversalReceiver\n} from \"../LSP1UniversalReceiver/ILSP1UniversalReceiver.sol\";\n\n// libraries\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {\n    ERC165Checker\n} from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {LSP1Utils} from \"../LSP1UniversalReceiver/LSP1Utils.sol\";\nimport {LSP2Utils} from \"../LSP2ERC725YJSONSchema/LSP2Utils.sol\";\n\n// modules\nimport {ERC725YCore} from \"@erc725/smart-contracts/contracts/ERC725YCore.sol\";\nimport {ERC725XCore} from \"@erc725/smart-contracts/contracts/ERC725XCore.sol\";\nimport {\n    OwnableUnset\n} from \"@erc725/smart-contracts/contracts/custom/OwnableUnset.sol\";\nimport {LSP14Ownable2Step} from \"../LSP14Ownable2Step/LSP14Ownable2Step.sol\";\nimport {LSP17Extendable} from \"../LSP17ContractExtension/LSP17Extendable.sol\";\nimport {\n    LSP20CallVerification\n} from \"../LSP20CallVerification/LSP20CallVerification.sol\";\n\n// constants\nimport \"@erc725/smart-contracts/contracts/constants.sol\";\nimport {\n    _INTERFACEID_LSP0,\n    _INTERFACEID_ERC1271,\n    _ERC1271_MAGICVALUE,\n    _ERC1271_FAILVALUE,\n    _TYPEID_LSP0_OwnershipTransferStarted,\n    _TYPEID_LSP0_OwnershipTransferred_SenderNotification,\n    _TYPEID_LSP0_OwnershipTransferred_RecipientNotification\n} from \"../LSP0ERC725Account/LSP0Constants.sol\";\nimport {\n    _INTERFACEID_LSP1,\n    _LSP1_UNIVERSAL_RECEIVER_DELEGATE_PREFIX,\n    _LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY\n} from \"../LSP1UniversalReceiver/LSP1Constants.sol\";\nimport {_INTERFACEID_LSP14} from \"../LSP14Ownable2Step/LSP14Constants.sol\";\n\nimport {\n    _LSP17_EXTENSION_PREFIX\n} from \"../LSP17ContractExtension/LSP17Constants.sol\";\nimport {\n    _INTERFACEID_LSP20_CALL_VERIFICATION\n} from \"../LSP20CallVerification/LSP20Constants.sol\";\n\n// errors\nimport {\n    ERC725Y_DataKeysValuesLengthMismatch\n} from \"@erc725/smart-contracts/contracts/errors.sol\";\nimport {\n    NoExtensionFoundForFunctionSelector\n} from \"../LSP17ContractExtension/LSP17Errors.sol\";\n\n/**\n * @title The Core Implementation of LSP0-ERC725Account Standard\n *        https://github.com/lukso-network/LIPs/blob/main/LSPs/LSP-0-ERC725Account.md\n *\n * @author Fabian Vogelsteller <fabian@lukso.network>, Jean Cavallera (CJ42)\n * @dev A smart contract account including basic functionalities such as:\n * - Detecting supported standards using ERC165\n *   https://eips.ethereum.org/EIPS/eip-165\n *\n * - Executing several operation on other addresses including creating contracts using ERC725X\n *   https://github.com/ERC725Alliance/ERC725/blob/develop/docs/ERC-725.md\n *\n * - Storing data in a generic way using ERC725Y\n *   https://github.com/ERC725Alliance/ERC725/blob/develop/docs/ERC-725.md\n *\n * - Validating signatures using ERC1271\n *   https://eips.ethereum.org/EIPS/eip-1271\n *\n * - Receiving notification and react on them using LSP1\n *   https://github.com/lukso-network/LIPs/blob/main/LSPs/LSP-1-UniversalReceiver.md\n *\n * - Secure ownership management using LSP14\n *   https://github.com/lukso-network/LIPs/blob/main/LSPs/LSP-14-Ownable2Step.md\n *\n * - Extending the account with new functions and interfaceIds of future standards using LSP17\n *   https://github.com/lukso-network/LIPs/blob/main/LSPs/LSP-17-ContractExtension.md\n *\n * - Verifying calls on the owner to allow unified and standard interaction with the account using LSP20\n *   https://github.com/lukso-network/LIPs/blob/main/LSPs/LSP-20-CallVerification.md\n */\nabstract contract LSP0ERC725AccountCore is\n    ERC725XCore,\n    ERC725YCore,\n    IERC1271,\n    ILSP0ERC725Account,\n    ILSP1UniversalReceiver,\n    LSP14Ownable2Step,\n    LSP17Extendable,\n    LSP20CallVerification\n{\n    using ERC165Checker for address;\n    using LSP1Utils for address;\n    using Address for address;\n\n    /**\n     * @dev Executed:\n     * - when receiving some native tokens without any additional data.\n     * - on empty calls to the contract.\n     *\n     * @custom:events {ValueReceived} event when receiving native tokens.\n     */\n    receive() external payable virtual {\n        if (msg.value != 0) {\n            emit ValueReceived(msg.sender, msg.value);\n        }\n    }\n\n    // solhint-disable no-complex-fallback\n\n    /**\n     * @notice Achieves the goal of [LSP17-ContractExtension] standard by extending the contract to\n     * handle calls of functions that do not exist natively, forwarding the function call to the\n     * extension address mapped to the function being called.\n     *\n     * @dev This function is executed when:\n     *    - sending data of length less than 4 bytes to the contract.\n     *    - the first 4 bytes of the calldata do not match any publicly callable functions from the contract ABI.\n     *    - receiving native tokens with some calldata.\n     *\n     * 1. If the data is equal or longer than 4 bytes, the ERC725Y storage is queried with the following data key:\n     *   `[_LSP17_EXTENSION_PREFIX] + <bytes4 (msg.sig)>` (Check [LSP2-ERC725YJSONSchema] for encoding the data key)\n     *\n     *   - If there is no address stored under the following data key, revert with {NoExtensionFoundForFunctionSelector(bytes4)}\n     *     The data key relative to `bytes4(0)` is an exception, where no reverts occurs if there is no extension address stored under\n     *\n     *     This exception is made to allow users to send random data (graffiti) to the account and to be able to react on it.\n     *\n     *   - If there is an address, forward the `msg.data` to the extension using the CALL opcode,\n     *     appending 52 bytes (20 bytes of `msg.sender` and 32 bytes of `msg.value`).\n     *     Return what the calls returns, or revert if the call failed\n     *\n     * @custom:return if the data sent to this function is of length less than 4 bytes (not a function selector)\n     *\n     * @custom:events {ValueReceived} event when receiving native tokens.\n     */\n    fallback() external payable virtual {\n        if (msg.value != 0) {\n            emit ValueReceived(msg.sender, msg.value);\n        }\n\n        if (msg.data.length < 4) {\n            return;\n        }\n\n        _fallbackLSP17Extendable();\n    }\n\n    /**\n     * @dev Allows a caller to batch different function calls in one call.\n     * Perform a delegatecall on self, to call different functions with preserving the context\n     * It is not possible to send value along the functions call due to the use of delegatecall.\n     *\n     * @param data An array of ABI encoded function calls to be called on the contract.\n     * @return results An array of values returned by the executed functions.\n     */\n    function batchCalls(\n        bytes[] calldata data\n    ) public returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i; i < data.length; ) {\n            (bool success, bytes memory result) = address(this).delegatecall(\n                data[i]\n            );\n\n            if (!success) {\n                // Look for revert reason and bubble it up if present\n                if (result.length > 0) {\n                    // The easiest way to bubble the revert reason is using memory via assembly\n                    // solhint-disable no-inline-assembly\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        let returndata_size := mload(result)\n                        revert(add(32, result), returndata_size)\n                    }\n                } else {\n                    revert(\"LSP0: batchCalls reverted\");\n                }\n            }\n\n            results[i] = result;\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Executes any call on other addresses.\n     *\n     * @param operationType The operation to execute: `CALL = 0`, `CREATE = 1` `CREATE2 = 2`, `STATICCALL = 3`, `DELEGATECALL = 4`.\n     * @param target The address (smart contract/EOA) to interact with, `target` will be unused if a contract is created (`CREATE` & `CREATE2`).\n     * @param value The amount of native tokens to transfer (in Wei).\n     * @param data The call data to execute on `target`, or the bytecode of the contract to deploy.\n     *\n     * @custom:requirements\n     * - if a `value` is provided, the contract MUST have at least this amount in its balance to execute successfully.\n     * - if the operation type is `STATICCALL` or `DELEGATECALL`, `value` SHOULD be 0.\n     * - `target` SHOULD be `address(0)` when deploying a contract.\n     * - MUST pass when called by the owner or by an authorised address that pass the verification check performed on the owner accordinng to [LSP20-CallVerification] specification\n     *\n     * @custom:events\n     * - {Executed} event, when a call is executed under `operationType` 0, 3 and 4\n     * - {ContractCreated} event, when a contract is created under `operationType` 1 and 2\n     * - {ValueReceived} event when receiving native tokens.\n     */\n    function execute(\n        uint256 operationType,\n        address target,\n        uint256 value,\n        bytes memory data\n    ) public payable virtual override returns (bytes memory) {\n        if (msg.value != 0) {\n            emit ValueReceived(msg.sender, msg.value);\n        }\n\n        address _owner = owner();\n\n        // If the caller is the owner perform execute directly\n        if (msg.sender == _owner) {\n            return ERC725XCore._execute(operationType, target, value, data);\n        }\n\n        // If the caller is not the owner, call {lsp20VerifyCall} on the owner\n        // Depending on the magicValue returned, a second call is done after execution\n        bool verifyAfter = LSP20CallVerification._verifyCall(_owner);\n\n        // Perform the execution\n        bytes memory result = ERC725XCore._execute(\n            operationType,\n            target,\n            value,\n            data\n        );\n\n        // if verifyAfter is true, Call {lsp20VerifyCallResult} on the owner\n        if (verifyAfter) {\n            LSP20CallVerification._verifyCallResult(_owner, abi.encode(result));\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Generic batch executor function that executes any call on other addresses\n     *\n     * @param operationsType The list of operations type used: `CALL = 0`, `CREATE = 1`, `CREATE2 = 2`, `STATICCALL = 3`, `DELEGATECALL = 4`.\n     * @param targets The list of addresses to call. `targets` will be unused if a contract is created (`CREATE` & `CREATE2`).\n     * @param values The list of native token amounts to transfer (in Wei).\n     * @param datas The list of call data to execute on `targets`, or the creation bytecode of the contracts to deploy.\n     *\n     * @custom:requirements\n     * - The length of the parameters provided MUST be equal\n     * - if a `value` is provided, the contract MUST have at least this amount in its balance to execute successfully.\n     * - if the operation type is `STATICCALL` or `DELEGATECALL`, `value` SHOULD be 0.\n     * - `target` SHOULD be `address(0)` when deploying a contract.\n     * - MUST pass when called by the owner or by an authorised address that pass the verification check performed\n     * on the owner accordinng to [LSP20-CallVerification] specification\n     *\n     * @custom:events\n     * - {Executed} event, when a call is executed under `operationType` 0, 3 and 4 (each iteration)\n     * - {ContractCreated} event, when a contract is created under `operationType` 1 and 2 (each iteration)\n     * - {ValueReceived} event when receiving native tokens.\n     */\n    function executeBatch(\n        uint256[] memory operationsType,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory datas\n    ) public payable virtual override returns (bytes[] memory) {\n        if (msg.value != 0) {\n            emit ValueReceived(msg.sender, msg.value);\n        }\n\n        address _owner = owner();\n\n        // If the caller is the owner perform execute directly\n        if (msg.sender == _owner) {\n            return\n                ERC725XCore._executeBatch(\n                    operationsType,\n                    targets,\n                    values,\n                    datas\n                );\n        }\n\n        // If the caller is not the owner, call {lsp20VerifyCall} on the owner\n        // Depending on the magicValue returned, a second call is done after execution\n        bool verifyAfter = LSP20CallVerification._verifyCall(_owner);\n\n        // Perform the execution\n        bytes[] memory results = ERC725XCore._executeBatch(\n            operationsType,\n            targets,\n            values,\n            datas\n        );\n\n        // if verifyAfter is true, Call {lsp20VerifyCallResult} on the owner\n        if (verifyAfter) {\n            LSP20CallVerification._verifyCallResult(\n                _owner,\n                abi.encode(results)\n            );\n        }\n\n        return results;\n    }\n\n    /**\n     * @dev Sets singular data for a given `dataKey`\n     *\n     * @param dataKey The key to retrieve stored value\n     * @param dataValue The value to set\n     *\n     * @custom:requirements\n     * - MUST pass when called by the owner or by an authorised address that pass the verification check performed on the owner accordinng to [LSP20-CallVerification] specification\n     *\n     * @custom:events\n     * - {ValueReceived} event when receiving native tokens.\n     * - {DataChanged} event.\n     */\n    function setData(\n        bytes32 dataKey,\n        bytes memory dataValue\n    ) public payable virtual override {\n        if (msg.value != 0) {\n            emit ValueReceived(msg.sender, msg.value);\n        }\n\n        address _owner = owner();\n\n        // If the caller is the owner perform setData directly\n        if (msg.sender == _owner) {\n            return _setData(dataKey, dataValue);\n        }\n\n        // If the caller is not the owner, call {lsp20VerifyCall} on the owner\n        // Depending on the magicValue returned, a second call is done after setting data\n        bool verifyAfter = _verifyCall(_owner);\n\n        _setData(dataKey, dataValue);\n\n        // If verifyAfter is true, Call {lsp20VerifyCallResult} on the owner\n        // The setData function does not return, second parameter of {_verifyCallResult} will be empty\n        if (verifyAfter) {\n            _verifyCallResult(_owner, \"\");\n        }\n    }\n\n    /**\n     * @dev Sets array of data for multiple given `dataKeys`\n     *\n     * @param dataKeys The array of data keys for values to set\n     * @param dataValues The array of values to set\n     *\n     * @custom:requirements\n     * - MUST pass when called by the owner or by an authorised address that pass the verification check performed on the owner accordinng to [LSP20-CallVerification] specification\n     *\n     * @custom:events\n     * - {ValueReceived} event when receiving native tokens.\n     * - {DataChanged} event. (on each iteration of setting data)\n     */\n    function setDataBatch(\n        bytes32[] memory dataKeys,\n        bytes[] memory dataValues\n    ) public payable virtual override {\n        if (msg.value != 0) {\n            emit ValueReceived(msg.sender, msg.value);\n        }\n\n        if (dataKeys.length != dataValues.length) {\n            revert ERC725Y_DataKeysValuesLengthMismatch();\n        }\n\n        address _owner = owner();\n\n        // If the caller is the owner perform setData directly\n        if (msg.sender == _owner) {\n            for (uint256 i = 0; i < dataKeys.length; ) {\n                _setData(dataKeys[i], dataValues[i]);\n\n                unchecked {\n                    ++i;\n                }\n            }\n\n            return;\n        }\n\n        // If the caller is not the owner, call {lsp20VerifyCall} on the owner\n        // Depending on the magicValue returned, a second call is done after setting data\n        bool verifyAfter = _verifyCall(_owner);\n\n        for (uint256 i = 0; i < dataKeys.length; ) {\n            _setData(dataKeys[i], dataValues[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // If verifyAfter is true, Call {lsp20VerifyCallResult} on the owner\n        // The setData function does not return, second parameter of {_verifyCallResult} will be empty\n        if (verifyAfter) {\n            _verifyCallResult(_owner, \"\");\n        }\n    }\n\n    /**\n     * @notice Achieves the goal of [LSP1-UniversalReceiver] by allowing the account to be notified about incoming/outgoing\n     * transactions and enabling reactions to these actions.\n     *\n     * The reaction is achieved by having two external contracts (UniversalReceiverDelegates) that react on the whole transaction\n     * and on the specific typeId, respectively.\n     *\n     * The notification is achieved by emitting a {UniversalReceiver} event on the call with the function parameters, call options, and the\n     * response of the UniversalReceiverDelegates (URD) contract.\n     *\n     * @dev The function performs the following steps:\n     *\n     * 1. Query the ERC725Y storage with the data key `[_LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY]`.\n     *      - If there is an address stored under the data key, check if this address supports the LSP1 interfaceId.\n     *\n     *      - If yes, call this address with the typeId and data (params), along with additional calldata consisting of 20 bytes of `msg.sender` and 32 bytes of `msg.value`. If not, continue the execution of the function.\n     *\n     *\n     * 2. Query the ERC725Y storage with the data key `[_LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY] + <bytes32 typeId>`.\n     *   (Check [LSP2-ERC725YJSONSchema] for encoding the data key)\n     *\n     *      - If there is an address stored under the data key, check if this address supports the LSP1 interfaceId.\n     *\n     *      - If yes, call this address with the typeId and data (params), along with additional calldata consisting of 20 bytes of `msg.sender` and 32 bytes of `msg.value`. If not, continue the execution of the function.\n     *\n     * @param typeId The type of call received.\n     * @param receivedData The data received.\n     *\n     * @return returnedValues The ABI encoded return value of the LSP1UniversalReceiverDelegate call and the LSP1TypeIdDelegate call.\n     *\n     * @custom:events\n     * - {ValueReceived} when receiving native tokens.\n     * - {UniversalReceiver} event.\n     */\n    function universalReceiver(\n        bytes32 typeId,\n        bytes calldata receivedData\n    ) public payable virtual returns (bytes memory returnedValues) {\n        if (msg.value != 0) {\n            emit ValueReceived(msg.sender, msg.value);\n        }\n\n        // Query the ERC725Y storage with the data key {_LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY}\n        bytes memory lsp1DelegateValue = _getData(\n            _LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY\n        );\n        bytes memory resultDefaultDelegate;\n\n        if (lsp1DelegateValue.length >= 20) {\n            address universalReceiverDelegate = address(\n                bytes20(lsp1DelegateValue)\n            );\n\n            // Checking LSP1 InterfaceId support\n            if (\n                universalReceiverDelegate.supportsERC165InterfaceUnchecked(\n                    _INTERFACEID_LSP1\n                )\n            ) {\n                // calling {universalReceiver} function on URD appending the caller and the value sent\n                resultDefaultDelegate = universalReceiverDelegate\n                    .callUniversalReceiverWithCallerInfos(\n                        typeId,\n                        receivedData,\n                        msg.sender,\n                        msg.value\n                    );\n            }\n        }\n\n        // Generate the data key {_LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY + <bytes32 typeId>}\n        bytes32 lsp1typeIdDelegateKey = LSP2Utils.generateMappingKey(\n            _LSP1_UNIVERSAL_RECEIVER_DELEGATE_PREFIX,\n            bytes20(typeId)\n        );\n\n        // Query the ERC725Y storage with the data key {_LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY + <bytes32 typeId>}\n        bytes memory lsp1TypeIdDelegateValue = _getData(lsp1typeIdDelegateKey);\n        bytes memory resultTypeIdDelegate;\n\n        if (lsp1TypeIdDelegateValue.length >= 20) {\n            address universalReceiverDelegate = address(\n                bytes20(lsp1TypeIdDelegateValue)\n            );\n\n            // Checking LSP1 InterfaceId support\n            if (\n                universalReceiverDelegate.supportsERC165InterfaceUnchecked(\n                    _INTERFACEID_LSP1\n                )\n            ) {\n                // calling {universalReceiver} function on URD appending the caller and the value sent\n                resultTypeIdDelegate = universalReceiverDelegate\n                    .callUniversalReceiverWithCallerInfos(\n                        typeId,\n                        receivedData,\n                        msg.sender,\n                        msg.value\n                    );\n            }\n        }\n\n        returnedValues = abi.encode(\n            resultDefaultDelegate,\n            resultTypeIdDelegate\n        );\n        emit UniversalReceiver(\n            msg.sender,\n            msg.value,\n            typeId,\n            receivedData,\n            returnedValues\n        );\n    }\n\n    /**\n     * @notice Achieves the goal of LSP14Ownable2Step by implementing a 2-step ownership transfer process.\n     *\n     * @dev Sets the address of the `pendingNewOwner` as a pending owner that should call {`acceptOwnership()`} in order to complete\n     * the ownership transfer to become the new {`owner()`} of the account.\n     *\n     * Notifies the pending owner via LSP1Standard by calling {universalReceiver()} on the pending owner if it's\n     * an address that supports LSP1.\n     *\n     * @param pendingNewOwner The address of the new pending owner.\n     *\n     * @custom:requirements\n     * - MUST pass when called by the owner or by an authorized address that passes the verification check performed on the owner according to [LSP20-CallVerification] specification.\n     * - When notifying the new owner via LSP1, the `typeId` used MUST be `keccak256('LSP0OwnershipTransferStarted')`.\n     * - Pending owner cannot accept ownership in the same tx via the LSP1 hook.\n     */\n    function transferOwnership(\n        address pendingNewOwner\n    ) public virtual override(LSP14Ownable2Step, OwnableUnset) {\n        address currentOwner = owner();\n\n        // If the caller is the owner perform transferOwnership directly\n        if (msg.sender == currentOwner) {\n            // set the pending owner\n            LSP14Ownable2Step._transferOwnership(pendingNewOwner);\n            emit OwnershipTransferStarted(currentOwner, pendingNewOwner);\n\n            // notify the pending owner through LSP1\n            pendingNewOwner.tryNotifyUniversalReceiver(\n                _TYPEID_LSP0_OwnershipTransferStarted,\n                \"\"\n            );\n\n            // Require that the owner didn't change after the LSP1 Call\n            // (Pending owner didn't automate the acceptOwnership call through LSP1)\n            require(\n                currentOwner == owner(),\n                \"LSP14: newOwner MUST accept ownership in a separate transaction\"\n            );\n        } else {\n            // If the caller is not the owner, call {lsp20VerifyCall} on the owner\n            // Depending on the magicValue returned, a second call is done after transferring ownership\n            bool verifyAfter = _verifyCall(currentOwner);\n\n            // Set the pending owner if the call is allowed\n            LSP14Ownable2Step._transferOwnership(pendingNewOwner);\n            emit OwnershipTransferStarted(currentOwner, pendingNewOwner);\n\n            // notify the pending owner through LSP1\n            pendingNewOwner.tryNotifyUniversalReceiver(\n                _TYPEID_LSP0_OwnershipTransferStarted,\n                \"\"\n            );\n\n            // Require that the owner didn't change after the LSP1 Call\n            // (Pending owner didn't automate the acceptOwnership call through LSP1)\n            require(\n                currentOwner == owner(),\n                \"LSP14: newOwner MUST accept ownership in a separate transaction\"\n            );\n\n            // If verifyAfter is true, Call {lsp20VerifyCallResult} on the owner\n            // The transferOwnership function does not return, second parameter of {_verifyCallResult} will be empty\n            if (verifyAfter) {\n                _verifyCallResult(currentOwner, \"\");\n            }\n        }\n    }\n\n    /**\n     * @notice Achieves the goal of LSP14Ownable2Step by implementing a 2-step ownership transfer process.\n     *\n     * @dev Transfer ownership of the contract from the current {`owner()`} to the {`pendingOwner()`}.\n     *\n     * Once this function is called:\n     * - the current {`owner()`} will loose access to the functions restricted to the {`owner()`} only.\n     * - the {`pendingOwner()`} will gain access to the functions restricted to the {`owner()`} only.\n     *\n     * @custom:requirements\n     * - MUST be called by the pendingOwner.\n     * - When notifying the previous owner via LSP1, the typeId used MUST be `keccak256('LSP0OwnershipTransferred_SenderNotification')`.\n     * - When notifying the new owner via LSP1, the typeId used MUST be `keccak256('LSP0OwnershipTransferred_RecipientNotification')`.\n     */\n    function acceptOwnership() public virtual override {\n        address previousOwner = owner();\n\n        _acceptOwnership();\n\n        // notify the previous owner if supports LSP1\n        previousOwner.tryNotifyUniversalReceiver(\n            _TYPEID_LSP0_OwnershipTransferred_SenderNotification,\n            \"\"\n        );\n\n        // notify the pending owner if supports LSP1\n        msg.sender.tryNotifyUniversalReceiver(\n            _TYPEID_LSP0_OwnershipTransferred_RecipientNotification,\n            \"\"\n        );\n    }\n\n    /**\n     * @notice Achieves the goal of LSP14Ownable2Step by implementing a 2-step ownership renouncing process.\n     *\n     * @dev Renounce ownership of the contract in a 2-step process.\n     *\n     * 1. the first call will initiate the process of renouncing ownership.\n     * 2. the second is used as a confirmation and will leave the contract without an owner.\n     *\n     * MUST pass when called by the owner or by an authorised address that pass the verification check performed on the owner accordinng to [LSP20-CallVerification] specification\n     *\n     * @custom:danger Leaves the contract without an owner. Once ownership of the contract has been renounced, any functions that are restricted to be called by the owner will be permanently inaccessible, making these functions not callable anymore and unusable.\n     *\n     */\n    function renounceOwnership()\n        public\n        virtual\n        override(LSP14Ownable2Step, OwnableUnset)\n    {\n        address _owner = owner();\n\n        // If the caller is the owner perform renounceOwnership directly\n        if (msg.sender == _owner) {\n            return LSP14Ownable2Step._renounceOwnership();\n        }\n\n        // If the caller is not the owner, call {lsp20VerifyCall} on the owner\n        // Depending on the magicValue returned, a second call is done after transferring ownership\n        bool verifyAfter = _verifyCall(_owner);\n\n        // set the pending owner\n        LSP14Ownable2Step._renounceOwnership();\n\n        // If verifyAfter is true, Call {lsp20VerifyCallResult} on the owner\n        // The transferOwnership function does not return, second parameter of {_verifyCallResult} will be empty\n        if (verifyAfter) {\n            _verifyCallResult(_owner, \"\");\n        }\n    }\n\n    /**\n     * @notice Achieves the goal of ERC165 to detect supported interfaces and LSP17 by\n     * checking if the interfaceId being queried is supported on another linked extension.\n     *\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`.\n     *\n     * If the contract doesn't support the `interfaceId`, it forwards the call to the\n     * `supportsInterface` extension according to LSP17, and checks if the extension\n     * implements the interface defined by `interfaceId`.\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        view\n        virtual\n        override(ERC725XCore, ERC725YCore, LSP17Extendable)\n        returns (bool)\n    {\n        return\n            interfaceId == _INTERFACEID_ERC1271 ||\n            interfaceId == _INTERFACEID_LSP0 ||\n            interfaceId == _INTERFACEID_LSP1 ||\n            interfaceId == _INTERFACEID_LSP14 ||\n            interfaceId == _INTERFACEID_LSP20_CALL_VERIFICATION ||\n            super.supportsInterface(interfaceId) ||\n            LSP17Extendable._supportsInterfaceInERC165Extension(interfaceId);\n    }\n\n    /**\n     * @notice Achieves the goal of [EIP-1271] by validating signatures of smart contracts\n     * according to their own logic.\n     *\n     * @dev Handles two cases:\n     *\n     * 1. If the owner is an EOA, recovers an address from the hash and the signature provided:\n     *\n     *      - Returns the magicValue if the address recovered is the same as the owner, indicating that it was a valid signature.\n     *\n     *      - If the address is different, it returns the fail value indicating that the signature is not valid.\n     *\n     * 2. If the owner is a smart contract, it forwards the call of {isValidSignature()} to the owner contract:\n     *\n     *      - If the contract fails or returns the fail value, the {isValidSignature()} on the account returns the fail value, indicating that the signature is not valid.\n     *\n     *      - If the {isValidSignature()} on the owner returned the magicValue, the {isValidSignature()} on the account returns the magicValue, indicating that it's a valid signature.\n     *\n     * @param dataHash The hash of the data to be validated.\n     * @param signature A signature that can validate the previous parameter (Hash).\n     *\n     * @return magicValue A bytes4 value that indicates if the signature is valid or not.\n     */\n    function isValidSignature(\n        bytes32 dataHash,\n        bytes memory signature\n    ) public view virtual returns (bytes4 magicValue) {\n        address _owner = owner();\n\n        // If owner is a contract\n        if (_owner.code.length > 0) {\n            (bool success, bytes memory result) = _owner.staticcall(\n                abi.encodeWithSelector(\n                    IERC1271.isValidSignature.selector,\n                    dataHash,\n                    signature\n                )\n            );\n\n            bool isValid = (success &&\n                result.length == 32 &&\n                abi.decode(result, (bytes32)) == bytes32(_ERC1271_MAGICVALUE));\n\n            return isValid ? _ERC1271_MAGICVALUE : _ERC1271_FAILVALUE;\n        }\n        // If owner is an EOA\n        else {\n            // if isValidSignature fail, the error is catched in returnedError\n            (address recoveredAddress, ECDSA.RecoverError returnedError) = ECDSA\n                .tryRecover(dataHash, signature);\n\n            // if recovering throws an error, return the fail value\n            if (returnedError != ECDSA.RecoverError.NoError)\n                return _ERC1271_FAILVALUE;\n\n            // if recovering is successful and the recovered address matches the owner's address,\n            // return the ERC1271 magic value. Otherwise, return the ERC1271 fail value\n            // matches the address of the owner, otherwise return fail value\n            return\n                recoveredAddress == _owner\n                    ? _ERC1271_MAGICVALUE\n                    : _ERC1271_FAILVALUE;\n        }\n    }\n\n    // Internal functions\n\n    /**\n     * @dev Forwards the call to an extension mapped to a function selector.\n     *\n     * Calls {_getExtension} to get the address of the extension mapped to the function selector being\n     * called on the account. If there is no extension, the `address(0)` will be returned.\n     *\n     * Reverts if there is no extension for the function being called, except for the bytes4(0) function\n     * selector, which passes even if there is no extension for it.\n     *\n     * If there is an extension for the function selector being called, it calls the extension with the\n     * CALL opcode, passing the `msg.data` appended with the 20 bytes of the `msg.sender` and\n     * 32 bytes of the `msg.value`\n     *\n     * Because the function uses assembly `return()`/`revert()`"
    }
  ]
}