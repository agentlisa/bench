{
  "Title": "M-7: LES (Light Ethereum Subprotocol) doesn't forward the transaction to the sequencer",
  "Content": "# Issue M-7: LES (Light Ethereum Subprotocol) doesn't forward the transaction to the sequencer \n\nSource: https://github.com/sherlock-audit/2023-01-optimism-judging/issues/175 \n\n## Found by \nKoolex\n\n## Summary\nLES (Light Ethereum Subprotocol) doesn't forward the transaction to the sequencer when receiving it over RPC.\n\n## Vulnerability Detail\nWhen a user submits a transaction to op-geth node (validator/verfier mode), the node sends the transaction to the sequencer, if no error, it adds it to the tx pool.\n\n```sh\nfunc (b *EthAPIBackend) SendTx(ctx context.Context, tx *types.Transaction) error {\n\tif b.eth.seqRPCService != nil {\n\t\tdata, err := tx.MarshalBinary()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := b.eth.seqRPCService.CallContext(ctx, nil, \"eth_sendRawTransaction\", hexutil.Encode(data)); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn b.eth.txPool.AddLocal(tx)\n}\n```\n\nhttps://github.com/ethereum-optimism/op-geth/blob/optimism-history/eth/api_backend.go#L253-L264\n\n\nHowever, when LES, It only adds the transaction to the tx pool.\n\n```sh\nfunc (b *LesApiBackend) SendTx(ctx context.Context, signedTx *types.Transaction) error {\n\treturn b.eth.txPool.Add(ctx, signedTx)\n}\n```\n\nhttps://github.com/ethereum-optimism/op-geth/blob/optimism-history/les/api_backend.go#L193-L195\n\n\nNote: Sequencer http flag is configured only if we're running in verifier mode.\n\n## Impact\n- Transction isn't sent to the sequencer and will never be processed (submitted to L1).\n- Inconsistency among op-geth nodes validators/verifiers and the sequencer.\n- Additionally, from UX perspective, it is misleading as the user would think the transaction was submitted \"successfully\".\n\n## Code Snippet\nCheck above.\n\n## Tool used\n\nManual Review\n\n## Recommendation\nMatch this RPC change in the LES RPC. As it seems to be overlooked.\n\nRef:\nhttps://op-geth.optimism.io/\n\n## Discussion\n\n**rcstanciu**\n\nComment from Optimism\n\n---\n\n **Description:** LES doesn't forward transactions to the sequencer\n\n\n **Reason:** We don't support LES, so this is out-of-scope.\n\n\n **Action:** No action.\n\n\n\n**koolexcrypto**\n\nEscalate for 53 USDC\n\nI kindly ask you to reconsider the assessment due to the following reasons:\n\n1. In the contest description, it lists the components that are in scope:\n\t> The key components of the system can be found in our monorepo at commit 3f4b3c3281.\n\tL1 Contracts\n\tL2 Contracts (AKA Predeploys)\n\top-node\n\top-geth (in its own repo)\n\n\n\top-geth is listed as it is, and it is never mentioned anywhere in the docs that LES is out of scope. As a participant, I spent quite some time to look for bugs in LES. otherwise, I would have shifted my focus on some other parts of the component considering the short time of the contest. On a personal level, it feels a bit unfair.\n\n\n2. If you go over LES directory in the source code. You could see the code was adapted to match Optimism specs. This actually gave me a confirmation that it is in scope. Here are some examples:\n\t- L1CostFunc was added\n\t\t- https://github.com/ethereum-optimism/op-geth/blob/optimism/les/api_backend.go#L193\n\t- RollupSequencerHTTP and RollupHistoricalRPC \n\t\t- https://github.com/ethereum-optimism/op-geth/blob/optimism/les/client.go#L204-L222\n\t- Adapting stateAtTransaction func to consider L1CostFunc\n\t\t- https://github.com/ethereum-optimism/op-geth/blob/optimism/les/state_accessor.go#L70\n\n\n**sherlock-admin**\n\n > Escalate for 53 USDC\n> \n> I kindly ask you to reconsider the assessment due to the following reasons:\n> \n> 1. In the contest description, it lists the components that are in scope:\n> \t> The key components of the system can be found in our monorepo at commit 3f4b3c3281.\n> \tL1 Contracts\n> \tL2 Contracts (AKA Predeploys)\n> \top-node\n> \top-geth (in its own repo)\n> \n> \n> \top-geth is listed as it is, and it is never mentioned anywhere in the docs that LES is out of scope. As a participant, I spent quite some time to look for bugs in LES. otherwise, I would have shifted my focus on some other parts of the component considering the short time of the contest. On a personal level, it feels a bit unfair.\n> \n> \n> 2. If you go over LES directory in the source code. You could see the code was adapted to match Optimism specs. This actually gave me a confirmation that it is in scope. Here are some examples:\n> \t- L1CostFunc was added\n> \t\t- https://github.com/ethereum-optimism/op-geth/blob/optimism/les/api_backend.go#L193\n> \t- RollupSequencerHTTP and RollupHistoricalRPC \n> \t\t- https://github.com/ethereum-optimism/op-geth/blob/optimism/les/client.go#L204-L222\n> \t- Adapting stateAtTransaction func to consider L1CostFunc\n> \t\t- https://github.com/ethereum-optimism/op-geth/blob/optimism/les/state_accessor.go#L70\n> \n\nYou've created a valid escalation for 53 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation accepted.\n\nLabeling as medium severity.\n\nThis was an oversight on Optimism's part and there are markers that would suggest it should be in scope.\n\n\n\n**sherlock-admin**\n\n> Escalation accepted.\n> \n> Labeling as medium severity.\n> \n> This was an oversight on Optimism's part and there are markers that would suggest it should be in scope.\n> \n> \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/38",
  "Code": [
    {
      "filename": "eth/api_backend.go",
      "content": "// Copyright 2015 The go-ethereum Authors\n// This file is part of the go-ethereum library.\n//\n// The go-ethereum library is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// The go-ethereum library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.\n\npackage eth\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"time\"\n\n\t\"github.com/ethereum/go-ethereum\"\n\t\"github.com/ethereum/go-ethereum/accounts\"\n\t\"github.com/ethereum/go-ethereum/common\"\n\t\"github.com/ethereum/go-ethereum/common/hexutil\"\n\t\"github.com/ethereum/go-ethereum/consensus\"\n\t\"github.com/ethereum/go-ethereum/core\"\n\t\"github.com/ethereum/go-ethereum/core/bloombits\"\n\t\"github.com/ethereum/go-ethereum/core/rawdb\"\n\t\"github.com/ethereum/go-ethereum/core/state\"\n\t\"github.com/ethereum/go-ethereum/core/txpool\"\n\t\"github.com/ethereum/go-ethereum/core/types\"\n\t\"github.com/ethereum/go-ethereum/core/vm\"\n\t\"github.com/ethereum/go-ethereum/eth/gasprice\"\n\t\"github.com/ethereum/go-ethereum/eth/tracers\"\n\t\"github.com/ethereum/go-ethereum/ethdb\"\n\t\"github.com/ethereum/go-ethereum/event\"\n\t\"github.com/ethereum/go-ethereum/miner\"\n\t\"github.com/ethereum/go-ethereum/params\"\n\t\"github.com/ethereum/go-ethereum/rpc\"\n)\n\n// EthAPIBackend implements ethapi.Backend for full nodes\ntype EthAPIBackend struct {\n\textRPCEnabled       bool\n\tallowUnprotectedTxs bool\n\teth                 *Ethereum\n\tgpo                 *gasprice.Oracle\n}\n\n// ChainConfig returns the active chain configuration.\nfunc (b *EthAPIBackend) ChainConfig() *params.ChainConfig {\n\treturn b.eth.blockchain.Config()\n}\n\nfunc (b *EthAPIBackend) CurrentBlock() *types.Block {\n\treturn b.eth.blockchain.CurrentBlock()\n}\n\nfunc (b *EthAPIBackend) SetHead(number uint64) {\n\tb.eth.handler.downloader.Cancel()\n\tb.eth.blockchain.SetHead(number)\n}\n\nfunc (b *EthAPIBackend) HeaderByNumber(ctx context.Context, number rpc.BlockNumber) (*types.Header, error) {\n\t// Pending block is only known by the miner\n\tif number == rpc.PendingBlockNumber {\n\t\tblock := b.eth.miner.PendingBlock()\n\t\treturn block.Header(), nil\n\t}\n\t// Otherwise resolve and return the block\n\tif number == rpc.LatestBlockNumber {\n\t\treturn b.eth.blockchain.CurrentBlock().Header(), nil\n\t}\n\tif number == rpc.FinalizedBlockNumber {\n\t\tblock := b.eth.blockchain.CurrentFinalizedBlock()\n\t\tif block != nil {\n\t\t\treturn block.Header(), nil\n\t\t}\n\t\treturn nil, errors.New(\"finalized block not found\")\n\t}\n\tif number == rpc.SafeBlockNumber {\n\t\tblock := b.eth.blockchain.CurrentSafeBlock()\n\t\tif block != nil {\n\t\t\treturn block.Header(), nil\n\t\t}\n\t\treturn nil, errors.New(\"safe block not found\")\n\t}\n\treturn b.eth.blockchain.GetHeaderByNumber(uint64(number)), nil\n}\n\nfunc (b *EthAPIBackend) HeaderByNumberOrHash(ctx context.Context, blockNrOrHash rpc.BlockNumberOrHash) (*types.Header, error) {\n\tif blockNr, ok := blockNrOrHash.Number(); ok {\n\t\treturn b.HeaderByNumber(ctx, blockNr)\n\t}\n\tif hash, ok := blockNrOrHash.Hash(); ok {\n\t\theader := b.eth.blockchain.GetHeaderByHash(hash)\n\t\tif header == nil {\n\t\t\treturn nil, errors.New(\"header for hash not found\")\n\t\t}\n\t\tif blockNrOrHash.RequireCanonical && b.eth.blockchain.GetCanonicalHash(header.Number.Uint64()) != hash {\n\t\t\treturn nil, errors.New(\"hash is not currently canonical\")\n\t\t}\n\t\treturn header, nil\n\t}\n\treturn nil, errors.New(\"invalid arguments; neither block nor hash specified\")\n}\n\nfunc (b *EthAPIBackend) HeaderByHash(ctx context.Context, hash common.Hash) (*types.Header, error) {\n\treturn b.eth.blockchain.GetHeaderByHash(hash), nil\n}\n\nfunc (b *EthAPIBackend) BlockByNumber(ctx context.Context, number rpc.BlockNumber) (*types.Block, error) {\n\t// Pending block is only known by the miner\n\tif number == rpc.PendingBlockNumber {\n\t\tblock := b.eth.miner.PendingBlock()\n\t\treturn block, nil\n\t}\n\t// Otherwise resolve and return the block\n\tif number == rpc.LatestBlockNumber {\n\t\treturn b.eth.blockchain.CurrentBlock(), nil\n\t}\n\tif number == rpc.FinalizedBlockNumber {\n\t\treturn b.eth.blockchain.CurrentFinalizedBlock(), nil\n\t}\n\tif number == rpc.SafeBlockNumber {\n\t\treturn b.eth.blockchain.CurrentSafeBlock(), nil\n\t}\n\treturn b.eth.blockchain.GetBlockByNumber(uint64(number)), nil\n}\n\nfunc (b *EthAPIBackend) BlockByHash(ctx context.Context, hash common.Hash) (*types.Block, error) {\n\treturn b.eth.blockchain.GetBlockByHash(hash), nil\n}\n\nfunc (b *EthAPIBackend) BlockByNumberOrHash(ctx context.Context, blockNrOrHash rpc.BlockNumberOrHash) (*types.Block, error) {\n\tif blockNr, ok := blockNrOrHash.Number(); ok {\n\t\treturn b.BlockByNumber(ctx, blockNr)\n\t}\n\tif hash, ok := blockNrOrHash.Hash(); ok {\n\t\theader := b.eth.blockchain.GetHeaderByHash(hash)\n\t\tif header == nil {\n\t\t\treturn nil, errors.New(\"header for hash not found\")\n\t\t}\n\t\tif blockNrOrHash.RequireCanonical && b.eth.blockchain.GetCanonicalHash(header.Number.Uint64()) != hash {\n\t\t\treturn nil, errors.New(\"hash is not currently canonical\")\n\t\t}\n\t\tblock := b.eth.blockchain.GetBlock(hash, header.Number.Uint64())\n\t\tif block == nil {\n\t\t\treturn nil, errors.New(\"header found, but block body is missing\")\n\t\t}\n\t\treturn block, nil\n\t}\n\treturn nil, errors.New(\"invalid arguments; neither block nor hash specified\")\n}\n\nfunc (b *EthAPIBackend) PendingBlockAndReceipts() (*types.Block, types.Receipts) {\n\treturn b.eth.miner.PendingBlockAndReceipts()\n}\n\nfunc (b *EthAPIBackend) StateAndHeaderByNumber(ctx context.Context, number rpc.BlockNumber) (*state.StateDB, *types.Header, error) {\n\t// Pending state is only known by the miner\n\tif number == rpc.PendingBlockNumber {\n\t\tblock, state := b.eth.miner.Pending()\n\t\treturn state, block.Header(), nil\n\t}\n\t// Otherwise resolve the block number and return its state\n\theader, err := b.HeaderByNumber(ctx, number)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tif header == nil {\n\t\treturn nil, nil, fmt.Errorf(\"header %w\", ethereum.NotFound)\n\t}\n\tstateDb, err := b.eth.BlockChain().StateAt(header.Root)\n\treturn stateDb, header, err\n}\n\nfunc (b *EthAPIBackend) StateAndHeaderByNumberOrHash(ctx context.Context, blockNrOrHash rpc.BlockNumberOrHash) (*state.StateDB, *types.Header, error) {\n\tif blockNr, ok := blockNrOrHash.Number(); ok {\n\t\treturn b.StateAndHeaderByNumber(ctx, blockNr)\n\t}\n\tif hash, ok := blockNrOrHash.Hash(); ok {\n\t\theader, err := b.HeaderByHash(ctx, hash)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\tif header == nil {\n\t\t\treturn nil, nil, fmt.Errorf(\"header for hash %w\", ethereum.NotFound)\n\t\t}\n\t\tif blockNrOrHash.RequireCanonical && b.eth.blockchain.GetCanonicalHash(header.Number.Uint64()) != hash {\n\t\t\treturn nil, nil, errors.New(\"hash is not currently canonical\")\n\t\t}\n\t\tstateDb, err := b.eth.BlockChain().StateAt(header.Root)\n\t\treturn stateDb, header, err\n\t}\n\treturn nil, nil, errors.New(\"invalid arguments; neither block nor hash specified\")\n}\n\nfunc (b *EthAPIBackend) GetReceipts(ctx context.Context, hash common.Hash) (types.Receipts, error) {\n\treturn b.eth.blockchain.GetReceiptsByHash(hash), nil\n}\n\nfunc (b *EthAPIBackend) GetLogs(ctx context.Context, hash common.Hash, number uint64) ([][]*types.Log, error) {\n\treturn rawdb.ReadLogs(b.eth.chainDb, hash, number, b.ChainConfig()), nil\n}\n\nfunc (b *EthAPIBackend) GetTd(ctx context.Context, hash common.Hash) *big.Int {\n\tif header := b.eth.blockchain.GetHeaderByHash(hash); header != nil {\n\t\treturn b.eth.blockchain.GetTd(hash, header.Number.Uint64())\n\t}\n\treturn nil\n}\n\nfunc (b *EthAPIBackend) GetEVM(ctx context.Context, msg core.Message, state *state.StateDB, header *types.Header, vmConfig *vm.Config) (*vm.EVM, func() error, error) {\n\tif vmConfig == nil {\n\t\tvmConfig = b.eth.blockchain.GetVMConfig()\n\t}\n\ttxContext := core.NewEVMTxContext(msg)\n\tcontext := core.NewEVMBlockContext(header, b.eth.BlockChain(), nil)\n\tcontext.L1CostFunc = types.NewL1CostFunc(b.eth.blockchain.Config(), state)\n\treturn vm.NewEVM(context, txContext, state, b.eth.blockchain.Config(), *vmConfig), state.Error, nil\n}\n\nfunc (b *EthAPIBackend) SubscribeRemovedLogsEvent(ch chan<- core.RemovedLogsEvent) event.Subscription {\n\treturn b.eth.BlockChain().SubscribeRemovedLogsEvent(ch)\n}\n\nfunc (b *EthAPIBackend) SubscribePendingLogsEvent(ch chan<- []*types.Log) event.Subscription {\n\treturn b.eth.miner.SubscribePendingLogs(ch)\n}\n\nfunc (b *EthAPIBackend) SubscribeChainEvent(ch chan<- core.ChainEvent) event.Subscription {\n\treturn b.eth.BlockChain().SubscribeChainEvent(ch)\n}\n\nfunc (b *EthAPIBackend) SubscribeChainHeadEvent(ch chan<- core.ChainHeadEvent) event.Subscription {\n\treturn b.eth.BlockChain().SubscribeChainHeadEvent(ch)\n}\n\nfunc (b *EthAPIBackend) SubscribeChainSideEvent(ch chan<- core.ChainSideEvent) event.Subscription {\n\treturn b.eth.BlockChain().SubscribeChainSideEvent(ch)\n}\n\nfunc (b *EthAPIBackend) SubscribeLogsEvent(ch chan<- []*types.Log) event.Subscription {\n\treturn b.eth.BlockChain().SubscribeLogsEvent(ch)\n}\n\nfunc (b *EthAPIBackend) SendTx(ctx context.Context, tx *types.Transaction) error {\n\tif b.eth.seqRPCService != nil {\n\t\tdata, err := tx.MarshalBinary()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := b.eth.seqRPCService.CallContext(ctx, nil, \"eth_sendRawTransaction\", hexutil.Encode(data)); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn b.eth.txPool.AddLocal(tx)\n}\n\nfunc (b *EthAPIBackend) GetPoolTransactions() (types.Transactions, error) {\n\tpending := b.eth.txPool.Pending(false)\n\tvar txs types.Transactions\n\tfor _, batch := range pending {\n\t\ttxs = append(txs, batch...)\n\t}\n\treturn txs, nil\n}\n\nfunc (b *EthAPIBackend) GetPoolTransaction(hash common.Hash) *types.Transaction {\n\treturn b.eth.txPool.Get(hash)\n}\n\nfunc (b *EthAPIBackend) GetTransaction(ctx context.Context, txHash common.Hash) (*types.Transaction, common.Hash, uint64, uint64, error) {\n\ttx, blockHash, blockNumber, index := rawdb.ReadTransaction(b.eth.ChainDb(), txHash)\n\treturn tx, blockHash, blockNumber, index, nil\n}\n\nfunc (b *EthAPIBackend) GetPoolNonce(ctx context.Context, addr common.Address) (uint64, error) {\n\treturn b.eth.txPool.Nonce(addr), nil\n}\n\nfunc (b *EthAPIBackend) Stats() (pending int, queued int) {\n\treturn b.eth.txPool.Stats()\n}\n\nfunc (b *EthAPIBackend) TxPoolContent() (map[common.Address]types.Transactions, map[common.Address]types.Transactions) {\n\treturn b.eth.TxPool().Content()\n}\n\nfunc (b *EthAPIBackend) TxPoolContentFrom(addr common.Address) (types.Transactions, types.Transactions) {\n\treturn b.eth.TxPool().ContentFrom(addr)\n}\n\nfunc (b *EthAPIBackend) TxPool() *txpool.TxPool {\n\treturn b.eth.TxPool()\n}\n\nfunc (b *EthAPIBackend) SubscribeNewTxsEvent(ch chan<- core.NewTxsEvent) event.Subscription {\n\treturn b.eth.TxPool().SubscribeNewTxsEvent(ch)\n}\n\nfunc (b *EthAPIBackend) SyncProgress() ethereum.SyncProgress {\n\treturn b.eth.Downloader().Progress()\n}\n\nfunc (b *EthAPIBackend) SuggestGasTipCap(ctx context.Context) (*big.Int, error) {\n\treturn b.gpo.SuggestTipCap(ctx)\n}\n\nfunc (b *EthAPIBackend) FeeHistory(ctx context.Context, blockCount int, lastBlock rpc.BlockNumber, rewardPercentiles []float64) (firstBlock *big.Int, reward [][]*big.Int, baseFee []*big.Int, gasUsedRatio []float64, err error) {\n\treturn b.gpo.FeeHistory(ctx, blockCount, lastBlock, rewardPercentiles)\n}\n\nfunc (b *EthAPIBackend) ChainDb() ethdb.Database {\n\treturn b.eth.ChainDb()\n}\n\nfunc (b *EthAPIBackend) EventMux() *event.TypeMux {\n\treturn b.eth.EventMux()\n}\n\nfunc (b *EthAPIBackend) AccountManager() *accounts.Manager {\n\treturn b.eth.AccountManager()\n}\n\nfunc (b *EthAPIBackend) ExtRPCEnabled() bool {\n\treturn b.extRPCEnabled\n}\n\nfunc (b *EthAPIBackend) UnprotectedAllowed() bool {\n\treturn b.allowUnprotectedTxs\n}\n\nfunc (b *EthAPIBackend) RPCGasCap() uint64 {\n\treturn b.eth.config.RPCGasCap\n}\n\nfunc (b *EthAPIBackend) RPCEVMTimeout() time.Duration {\n\treturn b.eth.config.RPCEVMTimeout\n}\n\nfunc (b *EthAPIBackend) RPCTxFeeCap() float64 {\n\treturn b.eth.config.RPCTxFeeCap\n}\n\nfunc (b *EthAPIBackend) BloomStatus() (uint64, uint64) {\n\tsections, _, _ := b.eth.bloomIndexer.Sections()\n\treturn params.BloomBitsBlocks, sections\n}\n\nfunc (b *EthAPIBackend) ServiceFilter(ctx context.Context, session *bloombits.MatcherSession) {\n\tfor i := 0; i < bloomFilterThreads; i++ {\n\t\tgo session.Multiplex(bloomRetrievalBatch, bloomRetrievalWait, b.eth.bloomRequests)\n\t}\n}\n\nfunc (b *EthAPIBackend) Engine() consensus.Engine {\n\treturn b.eth.engine\n}\n\nfunc (b *EthAPIBackend) CurrentHeader() *types.Header {\n\treturn b.eth.blockchain.CurrentHeader()\n}\n\nfunc (b *EthAPIBackend) Miner() *miner.Miner {\n\treturn b.eth.Miner()\n}\n\nfunc (b *EthAPIBackend) StartMining(threads int) error {\n\treturn b.eth.StartMining(threads)\n}\n\nfunc (b *EthAPIBackend) StateAtBlock(ctx context.Context, block *types.Block, reexec uint64, base *state.StateDB, readOnly bool, preferDisk bool) (*state.StateDB, tracers.StateReleaseFunc, error) {\n\treturn b.eth.StateAtBlock(block, reexec, base, readOnly, preferDisk)\n}\n\nfunc (b *EthAPIBackend) StateAtTransaction(ctx context.Context, block *types.Block, txIndex int, reexec uint64) (core.Message, vm.BlockContext, *state.StateDB, tracers.StateReleaseFunc, error) {\n\treturn b.eth.stateAtTransaction(block, txIndex, reexec)\n}\n\nfunc (b *EthAPIBackend) HistoricalRPCService() *rpc.Client {\n\treturn b.eth.historicalRPCService\n}\n\nfunc (b *EthAPIBackend) Genesis() *types.Block {\n\treturn b.eth.blockchain.Genesis()\n}"
    },
    {
      "filename": "les/api_backend.go",
      "content": "// Copyright 2016 The go-ethereum Authors\n// This file is part of the go-ethereum library.\n//\n// The go-ethereum library is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// The go-ethereum library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.\n\npackage les\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"math/big\"\n\t\"time\"\n\n\t\"github.com/ethereum/go-ethereum\"\n\t\"github.com/ethereum/go-ethereum/accounts\"\n\t\"github.com/ethereum/go-ethereum/common\"\n\t\"github.com/ethereum/go-ethereum/consensus\"\n\t\"github.com/ethereum/go-ethereum/core\"\n\t\"github.com/ethereum/go-ethereum/core/bloombits\"\n\t\"github.com/ethereum/go-ethereum/core/rawdb\"\n\t\"github.com/ethereum/go-ethereum/core/state\"\n\t\"github.com/ethereum/go-ethereum/core/types\"\n\t\"github.com/ethereum/go-ethereum/core/vm\"\n\t\"github.com/ethereum/go-ethereum/eth/gasprice\"\n\t\"github.com/ethereum/go-ethereum/eth/tracers\"\n\t\"github.com/ethereum/go-ethereum/ethdb\"\n\t\"github.com/ethereum/go-ethereum/event\"\n\t\"github.com/ethereum/go-ethereum/light\"\n\t\"github.com/ethereum/go-ethereum/params\"\n\t\"github.com/ethereum/go-ethereum/rpc\"\n)\n\ntype LesApiBackend struct {\n\textRPCEnabled       bool\n\tallowUnprotectedTxs bool\n\teth                 *LightEthereum\n\tgpo                 *gasprice.Oracle\n}\n\nfunc (b *LesApiBackend) ChainConfig() *params.ChainConfig {\n\treturn b.eth.chainConfig\n}\n\nfunc (b *LesApiBackend) CurrentBlock() *types.Block {\n\treturn types.NewBlockWithHeader(b.eth.BlockChain().CurrentHeader())\n}\n\nfunc (b *LesApiBackend) SetHead(number uint64) {\n\tb.eth.handler.downloader.Cancel()\n\tb.eth.blockchain.SetHead(number)\n}\n\nfunc (b *LesApiBackend) HeaderByNumber(ctx context.Context, number rpc.BlockNumber) (*types.Header, error) {\n\t// Return the latest current as the pending one since there\n\t// is no pending notion in the light client. TODO(rjl493456442)\n\t// unify the behavior of `HeaderByNumber` and `PendingBlockAndReceipts`.\n\tif number == rpc.PendingBlockNumber {\n\t\treturn b.eth.blockchain.CurrentHeader(), nil\n\t}\n\tif number == rpc.LatestBlockNumber {\n\t\treturn b.eth.blockchain.CurrentHeader(), nil\n\t}\n\treturn b.eth.blockchain.GetHeaderByNumberOdr(ctx, uint64(number))\n}\n\nfunc (b *LesApiBackend) HeaderByNumberOrHash(ctx context.Context, blockNrOrHash rpc.BlockNumberOrHash) (*types.Header, error) {\n\tif blockNr, ok := blockNrOrHash.Number(); ok {\n\t\treturn b.HeaderByNumber(ctx, blockNr)\n\t}\n\tif hash, ok := blockNrOrHash.Hash(); ok {\n\t\theader, err := b.HeaderByHash(ctx, hash)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif header == nil {\n\t\t\treturn nil, errors.New(\"header for hash not found\")\n\t\t}\n\t\tif blockNrOrHash.RequireCanonical && b.eth.blockchain.GetCanonicalHash(header.Number.Uint64()) != hash {\n\t\t\treturn nil, errors.New(\"hash is not currently canonical\")\n\t\t}\n\t\treturn header, nil\n\t}\n\treturn nil, errors.New(\"invalid arguments; neither block nor hash specified\")\n}\n\nfunc (b *LesApiBackend) HeaderByHash(ctx context.Context, hash common.Hash) (*types.Header, error) {\n\treturn b.eth.blockchain.GetHeaderByHash(hash), nil\n}\n\nfunc (b *LesApiBackend) BlockByNumber(ctx context.Context, number rpc.BlockNumber) (*types.Block, error) {\n\theader, err := b.HeaderByNumber(ctx, number)\n\tif header == nil || err != nil {\n\t\treturn nil, err\n\t}\n\treturn b.BlockByHash(ctx, header.Hash())\n}\n\nfunc (b *LesApiBackend) BlockByHash(ctx context.Context, hash common.Hash) (*types.Block, error) {\n\treturn b.eth.blockchain.GetBlockByHash(ctx, hash)\n}\n\nfunc (b *LesApiBackend) BlockByNumberOrHash(ctx context.Context, blockNrOrHash rpc.BlockNumberOrHash) (*types.Block, error) {\n\tif blockNr, ok := blockNrOrHash.Number(); ok {\n\t\treturn b.BlockByNumber(ctx, blockNr)\n\t}\n\tif hash, ok := blockNrOrHash.Hash(); ok {\n\t\tblock, err := b.BlockByHash(ctx, hash)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif block == nil {\n\t\t\treturn nil, errors.New(\"header found, but block body is missing\")\n\t\t}\n\t\tif blockNrOrHash.RequireCanonical && b.eth.blockchain.GetCanonicalHash(block.NumberU64()) != hash {\n\t\t\treturn nil, errors.New(\"hash is not currently canonical\")\n\t\t}\n\t\treturn block, nil\n\t}\n\treturn nil, errors.New(\"invalid arguments; neither block nor hash specified\")\n}\n\nfunc (b *LesApiBackend) PendingBlockAndReceipts() (*types.Block, types.Receipts) {\n\treturn nil, nil\n}\n\nfunc (b *LesApiBackend) StateAndHeaderByNumber(ctx context.Context, number rpc.BlockNumber) (*state.StateDB, *types.Header, error) {\n\theader, err := b.HeaderByNumber(ctx, number)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tif header == nil {\n\t\treturn nil, nil, errors.New(\"header not found\")\n\t}\n\treturn light.NewState(ctx, header, b.eth.odr), header, nil\n}\n\nfunc (b *LesApiBackend) StateAndHeaderByNumberOrHash(ctx context.Context, blockNrOrHash rpc.BlockNumberOrHash) (*state.StateDB, *types.Header, error) {\n\tif blockNr, ok := blockNrOrHash.Number(); ok {\n\t\treturn b.StateAndHeaderByNumber(ctx, blockNr)\n\t}\n\tif hash, ok := blockNrOrHash.Hash(); ok {\n\t\theader := b.eth.blockchain.GetHeaderByHash(hash)\n\t\tif header == nil {\n\t\t\treturn nil, nil, errors.New(\"header for hash not found\")\n\t\t}\n\t\tif blockNrOrHash.RequireCanonical && b.eth.blockchain.GetCanonicalHash(header.Number.Uint64()) != hash {\n\t\t\treturn nil, nil, errors.New(\"hash is not currently canonical\")\n\t\t}\n\t\treturn light.NewState(ctx, header, b.eth.odr), header, nil\n\t}\n\treturn nil, nil, errors.New(\"invalid arguments; neither block nor hash specified\")\n}\n\nfunc (b *LesApiBackend) GetReceipts(ctx context.Context, hash common.Hash) (types.Receipts, error) {\n\tif number := rawdb.ReadHeaderNumber(b.eth.chainDb, hash); number != nil {\n\t\treturn light.GetBlockReceipts(ctx, b.eth.odr, hash, *number)\n\t}\n\treturn nil, nil\n}\n\nfunc (b *LesApiBackend) GetLogs(ctx context.Context, hash common.Hash, number uint64) ([][]*types.Log, error) {\n\treturn light.GetBlockLogs(ctx, b.eth.odr, hash, number)\n}\n\nfunc (b *LesApiBackend) GetTd(ctx context.Context, hash common.Hash) *big.Int {\n\tif number := rawdb.ReadHeaderNumber(b.eth.chainDb, hash); number != nil {\n\t\treturn b.eth.blockchain.GetTdOdr(ctx, hash, *number)\n\t}\n\treturn nil\n}\n\nfunc (b *LesApiBackend) GetEVM(ctx context.Context, msg core.Message, state *state.StateDB, header *types.Header, vmConfig *vm.Config) (*vm.EVM, func() error, error) {\n\tif vmConfig == nil {\n\t\tvmConfig = new(vm.Config)\n\t}\n\ttxContext := core.NewEVMTxContext(msg)\n\tcontext := core.NewEVMBlockContext(header, b.eth.blockchain, nil)\n\tcontext.L1CostFunc = types.NewL1CostFunc(b.eth.chainConfig, state)\n\treturn vm.NewEVM(context, txContext, state, b.eth.chainConfig, *vmConfig), state.Error, nil\n}\n\nfunc (b *LesApiBackend) SendTx(ctx context.Context, signedTx *types.Transaction) error {\n\treturn b.eth.txPool.Add(ctx, signedTx)\n}\n\nfunc (b *LesApiBackend) RemoveTx(txHash common.Hash) {\n\tb.eth.txPool.RemoveTx(txHash)\n}\n\nfunc (b *LesApiBackend) GetPoolTransactions() (types.Transactions, error) {\n\treturn b.eth.txPool.GetTransactions()\n}\n\nfunc (b *LesApiBackend) GetPoolTransaction(txHash common.Hash) *types.Transaction {\n\treturn b.eth.txPool.GetTransaction(txHash)\n}\n\nfunc (b *LesApiBackend) GetTransaction(ctx context.Context, txHash common.Hash) (*types.Transaction, common.Hash, uint64, uint64, error) {\n\treturn light.GetTransaction(ctx, b.eth.odr, txHash)\n}\n\nfunc (b *LesApiBackend) GetPoolNonce(ctx context.Context, addr common.Address) (uint64, error) {\n\treturn b.eth.txPool.GetNonce(ctx, addr)\n}\n\nfunc (b *LesApiBackend) Stats() (pending int, queued int) {\n\treturn b.eth.txPool.Stats(), 0\n}\n\nfunc (b *LesApiBackend) TxPoolContent() (map[common.Address]types.Transactions, map[common.Address]types.Transactions) {\n\treturn b.eth.txPool.Content()\n}\n\nfunc (b *LesApiBackend) TxPoolContentFrom(addr common.Address) (types.Transactions, types.Transactions) {\n\treturn b.eth.txPool.ContentFrom(addr)\n}\n\nfunc (b *LesApiBackend) SubscribeNewTxsEvent(ch chan<- core.NewTxsEvent) event.Subscription {\n\treturn b.eth.txPool.SubscribeNewTxsEvent(ch)\n}\n\nfunc (b *LesApiBackend) SubscribeChainEvent(ch chan<- core.ChainEvent) event.Subscription {\n\treturn b.eth.blockchain.SubscribeChainEvent(ch)\n}\n\nfunc (b *LesApiBackend) SubscribeChainHeadEvent(ch chan<- core.ChainHeadEvent) event.Subscription {\n\treturn b.eth.blockchain.SubscribeChainHeadEvent(ch)\n}\n\nfunc (b *LesApiBackend) SubscribeChainSideEvent(ch chan<- core.ChainSideEvent) event.Subscription {\n\treturn b.eth.blockchain.SubscribeChainSideEvent(ch)\n}\n\nfunc (b *LesApiBackend) SubscribeLogsEvent(ch chan<- []*types.Log) event.Subscription {\n\treturn b.eth.blockchain.SubscribeLogsEvent(ch)\n}\n\nfunc (b *LesApiBackend) SubscribePendingLogsEvent(ch chan<- []*types.Log) event.Subscription {\n\treturn event.NewSubscription(func(quit <-chan struct{}) error {\n\t\t<-quit\n\t\treturn nil\n\t})\n}\n\nfunc (b *LesApiBackend) SubscribeRemovedLogsEvent(ch chan<- core.RemovedLogsEvent) event.Subscription {\n\treturn b.eth.blockchain.SubscribeRemovedLogsEvent(ch)\n}\n\nfunc (b *LesApiBackend) SyncProgress() ethereum.SyncProgress {\n\treturn b.eth.Downloader().Progress()\n}\n\nfunc (b *LesApiBackend) ProtocolVersion() int {\n\treturn b.eth.LesVersion() + 10000\n}\n\nfunc (b *LesApiBackend) SuggestGasTipCap(ctx context.Context) (*big.Int, error) {\n\treturn b.gpo.SuggestTipCap(ctx)\n}\n\nfunc (b *LesApiBackend) FeeHistory(ctx context.Context, blockCount int, lastBlock rpc.BlockNumber, rewardPercentiles []float64) (firstBlock *big.Int, reward [][]*big.Int, baseFee []*big.Int, gasUsedRatio []float64, err error) {\n\treturn b.gpo.FeeHistory(ctx, blockCount, lastBlock, rewardPercentiles)\n}\n\nfunc (b *LesApiBackend) ChainDb() ethdb.Database {\n\treturn b.eth.chainDb\n}\n\nfunc (b *LesApiBackend) AccountManager() *accounts.Manager {\n\treturn b.eth.accountManager\n}\n\nfunc (b *LesApiBackend) ExtRPCEnabled() bool {\n\treturn b.extRPCEnabled\n}\n\nfunc (b *LesApiBackend) UnprotectedAllowed() bool {\n\treturn b.allowUnprotectedTxs\n}\n\nfunc (b *LesApiBackend) RPCGasCap() uint64 {\n\treturn b.eth.config.RPCGasCap\n}\n\nfunc (b *LesApiBackend) RPCEVMTimeout() time.Duration {\n\treturn b.eth.config.RPCEVMTimeout\n}\n\nfunc (b *LesApiBackend) RPCTxFeeCap() float64 {\n\treturn b.eth.config.RPCTxFeeCap\n}\n\nfunc (b *LesApiBackend) BloomStatus() (uint64, uint64) {\n\tif b.eth.bloomIndexer == nil {\n\t\treturn 0, 0\n\t}\n\tsections, _, _ := b.eth.bloomIndexer.Sections()\n\treturn params.BloomBitsBlocksClient, sections\n}\n\nfunc (b *LesApiBackend) ServiceFilter(ctx context.Context, session *bloombits.MatcherSession) {\n\tfor i := 0; i < bloomFilterThreads; i++ {\n\t\tgo session.Multiplex(bloomRetrievalBatch, bloomRetrievalWait, b.eth.bloomRequests)\n\t}\n}\n\nfunc (b *LesApiBackend) Engine() consensus.Engine {\n\treturn b.eth.engine\n}\n\nfunc (b *LesApiBackend) CurrentHeader() *types.Header {\n\treturn b.eth.blockchain.CurrentHeader()\n}\n\nfunc (b *LesApiBackend) StateAtBlock(ctx context.Context, block *types.Block, reexec uint64, base *state.StateDB, readOnly bool, preferDisk bool) (*state.StateDB, tracers.StateReleaseFunc, error) {\n\treturn b.eth.stateAtBlock(ctx, block, reexec)\n}\n\nfunc (b *LesApiBackend) StateAtTransaction(ctx context.Context, block *types.Block, txIndex int, reexec uint64) (core.Message, vm.BlockContext, *state.StateDB, tracers.StateReleaseFunc, error) {\n\treturn b.eth.stateAtTransaction(ctx, block, txIndex, reexec)\n}\n\nfunc (b *LesApiBackend) HistoricalRPCService() *rpc.Client {\n\treturn b.eth.historicalRPCService\n}\n\nfunc (b *LesApiBackend) Genesis() *types.Block {\n\treturn b.eth.blockchain.Genesis()\n}"
    }
  ]
}