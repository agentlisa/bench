{
  "Title": "Denial-of-Service Protection Not Initialized",
  "Content": "The `L2MessageService` contract defines a state variable called [`minimumFeeInWei`](https://github.com/Consensys/linea-contracts/blob/f08c1906855198e2dc0413a47dcb38291b7087e5/contracts/messageService/l2/L2MessageService.sol#L27) as a minimum fee to pay to transfer L2-to-L1 messages. Such a fee is intended as a way to [\"address DOS protection\"](https://github.com/Consensys/linea-contracts/blob/f08c1906855198e2dc0413a47dcb38291b7087e5/contracts/messageService/l2/L2MessageService.sol#L171).\n\n\nHowever, this fee is not set in the initializer, meaning that its value is initially 0 until [`setMinimumFee`](https://github.com/Consensys/linea-contracts/blob/f08c1906855198e2dc0413a47dcb38291b7087e5/contracts/messageService/l2/L2MessageService.sol#L174) is called.\n\n\nIf `minimumFeeInWei` is required to address a DOS risk that could be present from the launch of the protocol, consider initializing it in the initializer.\n\n\n***Update:** Acknowledged, will resolve. The Linea team stated:*\n\n\n\n> *This will be a future enhancement for testnet deployments. Mainnet has the fee set, so it includes Denial-of-Service protection.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/messageService/l2/L2MessageService.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.19;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { CodecV2 } from \"../lib/Codec.sol\";\nimport { IMessageService } from \"../../interfaces/IMessageService.sol\";\nimport { IGenericErrors } from \"../../interfaces/IGenericErrors.sol\";\nimport { RateLimiter } from \"../lib/RateLimiter.sol\";\nimport { L2MessageManager } from \"./L2MessageManager.sol\";\n\n/**\n * @title Contract to manage cross-chain messaging on L2.\n * @author ConsenSys Software Inc.\n */\ncontract L2MessageService is Initializable, RateLimiter, L2MessageManager, IMessageService, IGenericErrors {\n  // Keep free storage slots for future implementation updates to avoid storage collision.\n  uint256[50] private __gap_L2MessageService;\n\n  bytes32 public constant MINIMUM_FEE_SETTER_ROLE = keccak256(\"MINIMUM_FEE_SETTER_ROLE\");\n\n  address private _messageSender;\n\n  // @dev initialise to save user cost with existing slot.\n  uint256 public nextMessageNumber;\n\n  // @dev initialise minimumFeeInWei variable.\n  uint256 public minimumFeeInWei;\n\n  // @dev adding these should not affect storage as they are constants and are store in bytecode\n  uint256 private constant REFUND_OVERHEAD_IN_GAS = 45000;\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @notice Initialises underlying message service dependencies.\n   * @param _securityCouncil The address owning the security council role.\n   * @param _l1l2MessageSetter The address owning the add L1L2MessageHashes functionality.\n   * @param _rateLimitPeriod The period to rate limit against.\n   * @param _rateLimitAmount The limit allowed for withdrawing the period.\n   **/\n  function initialize(\n    address _securityCouncil,\n    address _l1l2MessageSetter,\n    uint256 _rateLimitPeriod,\n    uint256 _rateLimitAmount\n  ) public initializer {\n    if (_securityCouncil == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    if (_l1l2MessageSetter == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    __ERC165_init();\n    __Context_init();\n    __AccessControl_init();\n    __RateLimiter_init(_rateLimitPeriod, _rateLimitAmount);\n    __L2MessageManager_init(_l1l2MessageSetter);\n\n    nextMessageNumber = 1;\n\n    _grantRole(DEFAULT_ADMIN_ROLE, _securityCouncil);\n    _grantRole(MINIMUM_FEE_SETTER_ROLE, _securityCouncil);\n    _grantRole(RATE_LIMIT_SETTER_ROLE, _securityCouncil);\n    _grantRole(PAUSE_MANAGER_ROLE, _securityCouncil);\n\n    _messageSender = address(123456789);\n  }\n\n  /**\n   * @notice Adds a message for sending cross-chain and emits a relevant event.\n   * @dev The message number is preset and only incremented at the end if successful for the next caller.\n   * @param _to The address the message is intended for.\n   * @param _fee The fee being paid for the message delivery.\n   * @param _calldata The calldata to pass to the recipient.\n   **/\n  function sendMessage(address _to, uint256 _fee, bytes calldata _calldata) external payable {\n    _requireTypeNotPaused(L2_L1_PAUSE_TYPE);\n    _requireTypeNotPaused(GENERAL_PAUSE_TYPE);\n\n    if (_to == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    if (_fee > msg.value) {\n      revert ValueSentTooLow();\n    }\n\n    uint256 coinbaseFee = minimumFeeInWei;\n\n    if (_fee < coinbaseFee) {\n      revert FeeTooLow();\n    }\n\n    uint256 postmanFee;\n    uint256 valueSent;\n\n    unchecked {\n      postmanFee = _fee - coinbaseFee;\n      valueSent = msg.value - _fee;\n    }\n\n    uint256 messageNumber = nextMessageNumber;\n    /// @dev Rate limit and revert is in the rate limiter.\n    _addUsedAmount(valueSent + postmanFee);\n\n    bytes32 messageHash = keccak256(abi.encode(msg.sender, _to, postmanFee, valueSent, messageNumber, _calldata));\n\n    nextMessageNumber++;\n\n    (bool success, ) = block.coinbase.call{ value: coinbaseFee }(\"\");\n    if (!success) {\n      revert FeePaymentFailed(block.coinbase);\n    }\n\n    emit MessageSent(msg.sender, _to, postmanFee, valueSent, messageNumber, _calldata, messageHash);\n  }\n\n  /**\n   * @notice Claims and delivers a cross-chain message.\n   * @dev _feeRecipient Can be set to address(0) to receive as msg.sender.\n   * @dev messageSender Is set temporarily when claiming and reset post.\n   * @param _from The address of the original sender.\n   * @param _to The address the message is intended for.\n   * @param _fee The fee being paid for the message delivery.\n   * @param _value The value to be transferred to the destination address.\n   * @param _feeRecipient The recipient for the fee.\n   * @param _calldata The calldata to pass to the recipient.\n   * @param _nonce The unique auto generated message number used when sending the message.\n   **/\n  function claimMessage(\n    address _from,\n    address _to,\n    uint256 _fee,\n    uint256 _value,\n    address payable _feeRecipient,\n    bytes calldata _calldata,\n    uint256 _nonce\n  ) external distributeFees(_fee, _to, _calldata, _feeRecipient) {\n    _requireTypeNotPaused(L1_L2_PAUSE_TYPE);\n    _requireTypeNotPaused(GENERAL_PAUSE_TYPE);\n\n    bytes32 messageHash = keccak256(abi.encode(_from, _to, _fee, _value, _nonce, _calldata));\n\n    /// @dev Status check and revert is in the message manager.\n    _updateL1L2MessageStatusToClaimed(messageHash);\n\n    _messageSender = _from;\n\n    (bool callSuccess, bytes memory returnData) = _to.call{ value: _value }(_calldata);\n    if (!callSuccess) {\n      if (returnData.length > 0) {\n        assembly {\n          let data_size := mload(returnData)\n          revert(add(32, returnData), data_size)\n        }\n      } else {\n        revert MessageSendingFailed(_to);\n      }\n    }\n\n    _messageSender = address(123456789);\n    emit MessageClaimed(messageHash);\n  }\n\n  /**\n   * @notice The Fee Manager sets a minimum fee to address DOS protection.\n   * @param _feeInWei New minimum fee in Wei.\n   **/\n  function setMinimumFee(uint256 _feeInWei) external onlyRole(MINIMUM_FEE_SETTER_ROLE) {\n    minimumFeeInWei = _feeInWei;\n  }\n\n  /**\n   * @dev The _messageSender address is set temporarily when claiming.\n   * @return _messageSender address.\n   **/\n  function sender() external view returns (address) {\n    return _messageSender;\n  }\n\n  /**\n   * @notice Function to receive funds for liquidity purposes.\n   **/\n  receive() external payable virtual {}\n\n  /**\n   * @notice The unspent fee is refunded if applicable.\n   * @param _feeInWei The fee paid for delivery in Wei.\n   * @param _to The recipient of the message and gas refund.\n   * @param _calldata The calldata of the message.\n   **/\n  modifier distributeFees(\n    uint256 _feeInWei,\n    address _to,\n    bytes calldata _calldata,\n    address _feeRecipient\n  ) {\n    //pre-execution\n    uint256 startingGas = gasleft();\n    _;\n    //post-execution\n\n    // we have a fee\n    if (_feeInWei > 0) {\n      // default postman fee\n      uint256 deliveryFee = _feeInWei;\n\n      // do we have empty calldata?\n      if (_calldata.length == 0) {\n        bool isDestinationEOA;\n\n        assembly {\n          isDestinationEOA := iszero(extcodesize(_to))\n        }\n\n        // are we calling an EOA\n        if (isDestinationEOA) {\n          // initial + cost to call and refund minus gasleft\n          deliveryFee = (startingGas + REFUND_OVERHEAD_IN_GAS - gasleft()) * tx.gasprice;\n\n          if (_feeInWei > deliveryFee) {\n            _to.call{ value: (_feeInWei - deliveryFee) }(\"\");\n          } else {\n            deliveryFee = _feeInWei;\n          }\n        }\n      }\n\n      address feeReceiver = _feeRecipient == address(0) ? msg.sender : _feeRecipient;\n      (bool callSuccess, ) = feeReceiver.call{ value: deliveryFee }(\"\");\n      if (!callSuccess) {\n        revert FeePaymentFailed(feeReceiver);\n      }\n    }\n  }\n}"
    },
    {
      "filename": "contracts/messageService/l2/L2MessageService.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.19;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { CodecV2 } from \"../lib/Codec.sol\";\nimport { IMessageService } from \"../../interfaces/IMessageService.sol\";\nimport { IGenericErrors } from \"../../interfaces/IGenericErrors.sol\";\nimport { RateLimiter } from \"../lib/RateLimiter.sol\";\nimport { L2MessageManager } from \"./L2MessageManager.sol\";\n\n/**\n * @title Contract to manage cross-chain messaging on L2.\n * @author ConsenSys Software Inc.\n */\ncontract L2MessageService is Initializable, RateLimiter, L2MessageManager, IMessageService, IGenericErrors {\n  // Keep free storage slots for future implementation updates to avoid storage collision.\n  uint256[50] private __gap_L2MessageService;\n\n  bytes32 public constant MINIMUM_FEE_SETTER_ROLE = keccak256(\"MINIMUM_FEE_SETTER_ROLE\");\n\n  address private _messageSender;\n\n  // @dev initialise to save user cost with existing slot.\n  uint256 public nextMessageNumber;\n\n  // @dev initialise minimumFeeInWei variable.\n  uint256 public minimumFeeInWei;\n\n  // @dev adding these should not affect storage as they are constants and are store in bytecode\n  uint256 private constant REFUND_OVERHEAD_IN_GAS = 45000;\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @notice Initialises underlying message service dependencies.\n   * @param _securityCouncil The address owning the security council role.\n   * @param _l1l2MessageSetter The address owning the add L1L2MessageHashes functionality.\n   * @param _rateLimitPeriod The period to rate limit against.\n   * @param _rateLimitAmount The limit allowed for withdrawing the period.\n   **/\n  function initialize(\n    address _securityCouncil,\n    address _l1l2MessageSetter,\n    uint256 _rateLimitPeriod,\n    uint256 _rateLimitAmount\n  ) public initializer {\n    if (_securityCouncil == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    if (_l1l2MessageSetter == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    __ERC165_init();\n    __Context_init();\n    __AccessControl_init();\n    __RateLimiter_init(_rateLimitPeriod, _rateLimitAmount);\n    __L2MessageManager_init(_l1l2MessageSetter);\n\n    nextMessageNumber = 1;\n\n    _grantRole(DEFAULT_ADMIN_ROLE, _securityCouncil);\n    _grantRole(MINIMUM_FEE_SETTER_ROLE, _securityCouncil);\n    _grantRole(RATE_LIMIT_SETTER_ROLE, _securityCouncil);\n    _grantRole(PAUSE_MANAGER_ROLE, _securityCouncil);\n\n    _messageSender = address(123456789);\n  }\n\n  /**\n   * @notice Adds a message for sending cross-chain and emits a relevant event.\n   * @dev The message number is preset and only incremented at the end if successful for the next caller.\n   * @param _to The address the message is intended for.\n   * @param _fee The fee being paid for the message delivery.\n   * @param _calldata The calldata to pass to the recipient.\n   **/\n  function sendMessage(address _to, uint256 _fee, bytes calldata _calldata) external payable {\n    _requireTypeNotPaused(L2_L1_PAUSE_TYPE);\n    _requireTypeNotPaused(GENERAL_PAUSE_TYPE);\n\n    if (_to == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    if (_fee > msg.value) {\n      revert ValueSentTooLow();\n    }\n\n    uint256 coinbaseFee = minimumFeeInWei;\n\n    if (_fee < coinbaseFee) {\n      revert FeeTooLow();\n    }\n\n    uint256 postmanFee;\n    uint256 valueSent;\n\n    unchecked {\n      postmanFee = _fee - coinbaseFee;\n      valueSent = msg.value - _fee;\n    }\n\n    uint256 messageNumber = nextMessageNumber;\n    /// @dev Rate limit and revert is in the rate limiter.\n    _addUsedAmount(valueSent + postmanFee);\n\n    bytes32 messageHash = keccak256(abi.encode(msg.sender, _to, postmanFee, valueSent, messageNumber, _calldata));\n\n    nextMessageNumber++;\n\n    (bool success, ) = block.coinbase.call{ value: coinbaseFee }(\"\");\n    if (!success) {\n      revert FeePaymentFailed(block.coinbase);\n    }\n\n    emit MessageSent(msg.sender, _to, postmanFee, valueSent, messageNumber, _calldata, messageHash);\n  }\n\n  /**\n   * @notice Claims and delivers a cross-chain message.\n   * @dev _feeRecipient Can be set to address(0) to receive as msg.sender.\n   * @dev messageSender Is set temporarily when claiming and reset post.\n   * @param _from The address of the original sender.\n   * @param _to The address the message is intended for.\n   * @param _fee The fee being paid for the message delivery.\n   * @param _value The value to be transferred to the destination address.\n   * @param _feeRecipient The recipient for the fee.\n   * @param _calldata The calldata to pass to the recipient.\n   * @param _nonce The unique auto generated message number used when sending the message.\n   **/\n  function claimMessage(\n    address _from,\n    address _to,\n    uint256 _fee,\n    uint256 _value,\n    address payable _feeRecipient,\n    bytes calldata _calldata,\n    uint256 _nonce\n  ) external distributeFees(_fee, _to, _calldata, _feeRecipient) {\n    _requireTypeNotPaused(L1_L2_PAUSE_TYPE);\n    _requireTypeNotPaused(GENERAL_PAUSE_TYPE);\n\n    bytes32 messageHash = keccak256(abi.encode(_from, _to, _fee, _value, _nonce, _calldata));\n\n    /// @dev Status check and revert is in the message manager.\n    _updateL1L2MessageStatusToClaimed(messageHash);\n\n    _messageSender = _from;\n\n    (bool callSuccess, bytes memory returnData) = _to.call{ value: _value }(_calldata);\n    if (!callSuccess) {\n      if (returnData.length > 0) {\n        assembly {\n          let data_size := mload(returnData)\n          revert(add(32, returnData), data_size)\n        }\n      } else {\n        revert MessageSendingFailed(_to);\n      }\n    }\n\n    _messageSender = address(123456789);\n    emit MessageClaimed(messageHash);\n  }\n\n  /**\n   * @notice The Fee Manager sets a minimum fee to address DOS protection.\n   * @param _feeInWei New minimum fee in Wei.\n   **/\n  function setMinimumFee(uint256 _feeInWei) external onlyRole(MINIMUM_FEE_SETTER_ROLE) {\n    minimumFeeInWei = _feeInWei;\n  }\n\n  /**\n   * @dev The _messageSender address is set temporarily when claiming.\n   * @return _messageSender address.\n   **/\n  function sender() external view returns (address) {\n    return _messageSender;\n  }\n\n  /**\n   * @notice Function to receive funds for liquidity purposes.\n   **/\n  receive() external payable virtual {}\n\n  /**\n   * @notice The unspent fee is refunded if applicable.\n   * @param _feeInWei The fee paid for delivery in Wei.\n   * @param _to The recipient of the message and gas refund.\n   * @param _calldata The calldata of the message.\n   **/\n  modifier distributeFees(\n    uint256 _feeInWei,\n    address _to,\n    bytes calldata _calldata,\n    address _feeRecipient\n  ) {\n    //pre-execution\n    uint256 startingGas = gasleft();\n    _;\n    //post-execution\n\n    // we have a fee\n    if (_feeInWei > 0) {\n      // default postman fee\n      uint256 deliveryFee = _feeInWei;\n\n      // do we have empty calldata?\n      if (_calldata.length == 0) {\n        bool isDestinationEOA;\n\n        assembly {\n          isDestinationEOA := iszero(extcodesize(_to))\n        }\n\n        // are we calling an EOA\n        if (isDestinationEOA) {\n          // initial + cost to call and refund minus gasleft\n          deliveryFee = (startingGas + REFUND_OVERHEAD_IN_GAS - gasleft()) * tx.gasprice;\n\n          if (_feeInWei > deliveryFee) {\n            _to.call{ value: (_feeInWei - deliveryFee) }(\"\");\n          } else {\n            deliveryFee = _feeInWei;\n          }\n        }\n      }\n\n      address feeReceiver = _feeRecipient == address(0) ? msg.sender : _feeRecipient;\n      (bool callSuccess, ) = feeReceiver.call{ value: deliveryFee }(\"\");\n      if (!callSuccess) {\n        revert FeePaymentFailed(feeReceiver);\n      }\n    }\n  }\n}"
    }
  ]
}