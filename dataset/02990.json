{
  "Title": "M-11: Existing Slippage Control Can Be Bypassed During Vault Settlement",
  "Content": "# Issue M-11: Existing Slippage Control Can Be Bypassed During Vault Settlement \n\nSource: https://github.com/sherlock-audit/2022-09-notional-judging/issues/73 \n\n## Found by \nxiaoming90\n\n## Summary\n\nThe existing slippage control can be bypassed/disabled during vault settlement, thus allowing the trade to be executed without consideration of its slippage.\n\n## Vulnerability Detail\n\n> Note 1: This issue affects MetaStable2 and Boosted3 balancer leverage vaults\n>\n> Note 2: This issue affects the following three (3) processes. However, the root cause and the remediation action are the same for all. Therefore, only the PoC for the \"Emergency vault settlement\" process will be documented in this report, and the other two processes will be omitted for brevity. Refer to \"Appendix I - Normal and Post Maturity Vault Settlement\" for more details.\n>\n> - Emergency vault settlement\n> - Normal vault settlement\n> - Post-Maturity vault settlement. \n>\n> Note 3: The issue affects all the supported DEXs (Curve, Balancer V2, Uniswap V2, Uniswap V3 and 0x) within Notional\n\nThe `emergencySettlementSlippageLimitPercent` of the vault is set to 10% as per the environment file provided by Notional.\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/scripts/BalancerEnvironment.py#L43\n\n```python\nFile: BalancerEnvironment.py\n43:             \"postMaturitySettlementSlippageLimitPercent\": 10e6, # 10%\n44:             \"emergencySettlementSlippageLimitPercent\": 10e6, # 10%\n```\n\nWhen a user calls the `settleVaultEmergency` function, the vault will validate that the slippage (`DynamicTradeParams.oracleSlippagePercent`) defined by the caller is within the acceptable slippage range by calling `SettlementUtils._decodeParamsAndValidate` function.\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/external/Boosted3TokenAuraHelper.sol#L53\n\n```solidity\nFile: MetaStable2TokenAuraHelper.sol\n52:     function settleVaultEmergency(\n53:         MetaStable2TokenAuraStrategyContext calldata context, \n54:         uint256 maturity, \n55:         bytes calldata data\n56:     ) external {\n57:         RedeemParams memory params = SettlementUtils._decodeParamsAndValidate(\n58:             context.baseStrategy.vaultSettings.emergencySettlementSlippageLimitPercent,\n59:             data\n60:         );\n61: \n62:         uint256 bptToSettle = context.baseStrategy._getEmergencySettlementParams({\n63:             poolContext: context.poolContext.basePool, \n64:             maturity: maturity, \n65:             totalBPTSupply: IERC20(context.poolContext.basePool.pool).totalSupply()\n66:         });\n```\n\nThe `SettlementUtils._decodeParamsAndValidate` function will validate that the slippage (`DynamicTradeParams.oracleSlippagePercent`)  passed in by the caller does not exceed the designated threshold (10%). In Line 41-42, the transaction will revert if the `DynamicTradeParams.oracleSlippagePercent` exceeds the `slippageLimitPercent`. Note that `slippageLimitPercent` is equal to `emergencySettlementSlippageLimitPercent` which is `10%`.\n\nThere is an edge case with the condition at Line 41. Consider the following cases:\n\n- If `callbackData.oracleSlippagePercent` = 9% and `slippageLimitPercent` = 10%, the condition will evaluate as `False` and transaction will not revert\n- If `callbackData.oracleSlippagePercent` = 11% and `slippageLimitPercent` = 10%, the condition will evaluate as `True` and transaction will revert because it exceeds the designated threshold.\n- If `callbackData.oracleSlippagePercent` = 0% and `slippageLimitPercent` = 10%, the condition will evaluate as `False` and transaction will not revert\n\nThe problem is that when `callbackData.oracleSlippagePercent` is `0%`, this effectively means that there is no slippage limit. This essentially exceeded the designated threshold (10%), and the transaction should revert instead, but it did not.\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/settlement/SettlementUtils.sol#L32\n\n```solidity\nFile: SettlementUtils.sol\n27:     /// @notice Validates that the slippage passed in by the caller\n28:     /// does not exceed the designated threshold.\n29:     /// @param slippageLimitPercent configured limit on the slippage from the oracle price allowed\n30:     /// @param data trade parameters passed into settlement\n31:     /// @return params abi decoded redemption parameters\n32:     function _decodeParamsAndValidate(\n33:         uint32 slippageLimitPercent,\n34:         bytes memory data\n35:     ) internal view returns (RedeemParams memory params) {\n36:         params = abi.decode(data, (RedeemParams));\n37:         DynamicTradeParams memory callbackData = abi.decode(\n38:             params.secondaryTradeParams, (DynamicTradeParams)\n39:         );\n40: \n41:         if (callbackData.oracleSlippagePercent > slippageLimitPercent) {\n42:             revert Errors.SlippageTooHigh(callbackData.oracleSlippagePercent, slippageLimitPercent);\n43:         }\n44:     }\n```\n\nWithin `executeTradeWithDynamicSlippage` function, it will calculate the `trade.limit` by calling the `PROXY.getLimitAmount`. The `trade.limit` is the  maximum amount of sellToken that can be sold OR the minimum amount of buyToken the contract is expected to receive from the DEX depending on whether you are performing a sell or buy.\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/trading/TradingModule.sol#L109\n\n```solidity\nFile: TradingModule.sol\n109:     function executeTradeWithDynamicSlippage(\n110:         uint16 dexId,\n111:         Trade memory trade,\n112:         uint32 dynamicSlippageLimit\n113:     ) external override returns (uint256 amountSold, uint256 amountBought) {\n114:         // This method calls back into the implementation via the proxy so that it has proper\n115:         // access to storage.\n116:         trade.limit = PROXY.getLimitAmount(\n117:             trade.tradeType,\n118:             trade.sellToken,\n119:             trade.buyToken,\n120:             trade.amount,\n121:             dynamicSlippageLimit\n122:         );\n```\n\nWithin the `TradingUtils._getLimitAmount` function, when the `slippageLimit` is set to `0`,\n\n- If it is a sell trade, the `limitAmount` will be set to `type(uint256).max`. See Line 187\n- If it is a buy trade,  the `limitAmount` will be set to `0`. See Line 207\n\nThese effectively remove the slippage limit. Therefore, a malicious user can specify the `callbackData.oracleSlippagePercent` to be `0%` to bypass the slippage validation check.\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/trading/TradingUtils.sol#L162\n\n```solidity\nFile: TradingUtils.sol\n162:     function _getLimitAmount(\n163:         TradeType tradeType,\n164:         address sellToken,\n165:         address buyToken,\n166:         uint256 amount,\n167:         uint32 slippageLimit,\n168:         uint256 oraclePrice,\n169:         uint256 oracleDecimals\n170:     ) internal view returns (uint256 limitAmount) {\n171:         uint256 sellTokenDecimals = 10 **\n172:             (\n173:                 sellToken == Deployments.ETH_ADDRESS\n174:                     ? 18\n175:                     : IERC20(sellToken).decimals()\n176:             );\n177:         uint256 buyTokenDecimals = 10 **\n178:             (\n179:                 buyToken == Deployments.ETH_ADDRESS\n180:                     ? 18\n181:                     : IERC20(buyToken).decimals()\n182:             );\n183: \n184:         if (tradeType == TradeType.EXACT_OUT_SINGLE || tradeType == TradeType.EXACT_OUT_BATCH) {\n185:             // 0 means no slippage limit\n186:             if (slippageLimit == 0) {\n187:                 return type(uint256).max;\n188:             }\n189:             // For exact out trades, we need to invert the oracle price (1 / oraclePrice)\n190:             // We increase the precision before we divide because oraclePrice is in\n191:             // oracle decimals\n192:             oraclePrice = (oracleDecimals * oracleDecimals) / oraclePrice;\n193:             // For exact out trades, limitAmount is the max amount of sellToken the DEX can\n194:             // pull from the contract\n195:             limitAmount =\n196:                 ((oraclePrice + \n197:                     ((oraclePrice * uint256(slippageLimit)) /\n198:                         Constants.SLIPPAGE_LIMIT_PRECISION)) * amount) / \n199:                 oracleDecimals;\n200: \n201:             // limitAmount is in buyToken precision after the previous calculation,\n202:             // convert it to sellToken precision\n203:             limitAmount = (limitAmount * sellTokenDecimals) / buyTokenDecimals;\n204:         } else {\n205:             // 0 means no slippage limit\n206:             if (slippageLimit == 0) {\n207:                 return 0;\n208:             }\n209:             // For exact in trades, limitAmount is the min amount of buyToken the contract\n210:             // expects from the DEX\n211:             limitAmount =\n212:                 ((oraclePrice -\n213:                     ((oraclePrice * uint256(slippageLimit)) /\n214:                         Constants.SLIPPAGE_LIMIT_PRECISION)) * amount) /\n215:                 oracleDecimals;\n216: \n217:             // limitAmount is in sellToken precision after the previous calculation,\n218:             // convert it to buyToken precision\n219:             limitAmount = (limitAmount * buyTokenDecimals) / sellTokenDecimals;\n220:         }\n221:     }\n```\n\n#### Proof-of-Concept\n\nThe following test case shows that when the slippage is set to 11% (11e6), the transaction will be reverted and fails the test. This is working as intended because the slippage (11%) exceeded the threshold (`emergencySettlementSlippageLimitPercent` = `10%`).\n\n```python\ndef test_emergency_single_maturity_success(StratBoostedPoolUSDCPrimary):\n    (env, vault) = StratBoostedPoolUSDCPrimary\n    primaryBorrowAmount = 5000e8\n    depositAmount = 10000e6\n    env.tokens[\"USDC\"].approve(env.notional, 2 ** 256 - 1, {\"from\": env.whales[\"USDC\"]})\n    maturity = enterMaturity(env, vault, 2, 0, depositAmount, primaryBorrowAmount, env.whales[\"USDC\"])\n    strategyContext = vault.getStrategyContext()\n    settings = dict(strategyContext[\"baseStrategy\"][\"vaultSettings\"].dict())\n    settings[\"maxBalancerPoolShare\"] = 0\n    vault.setStrategyVaultSettings(\n        list(settings.values()), \n        {\"from\": env.notional.owner()}\n    )\n    # minPrimary is calculated internally for boosted pools \n    redeemParams = get_redeem_params(0, 0, \n        get_dynamic_trade_params(\n            DEX_ID[\"UNISWAP_V3\"], TRADE_TYPE[\"EXACT_IN_SINGLE\"], 11e6, True, get_univ3_single_data(3000)\n        )\n    )\n    vault.settleVaultEmergency(maturity, redeemParams, {\"from\": env.notional.owner()})\n    vaultState = env.notional.getVaultState(vault.address, maturity)\n    assert vaultState[\"totalStrategyTokens\"] == 0\n```\n\n```bash\n❯ brownie test tests/balancer/settlement/test_settlement_boosted_usdc.py --network mainnet-fork\nBrownie v1.18.1 - Python development framework for Ethereum\n\n=============================================================================================== test session starts ===============================================================================================\nplatform linux -- Python 3.8.10, pytest-6.2.5, py-1.11.0, pluggy-1.0.0\nplugins: eth-brownie-1.18.1, hypothesis-6.27.3, forked-1.4.0, xdist-1.34.0, web3-5.27.0\ncollected 1 item                                                                                                                                                                                                  \nAttached to local RPC client listening at '127.0.0.1:8545'...\n\ntests/balancer/settlement/test_settlement_boosted_usdc.py F                                                                                                                                                 [100%]\n\n==================================================================================================== FAILURES =====================================================================================================\n```\n\nThe following test case shows that when the slippage is set to 0, the transaction does not revert and passes the test. This is not working as intended because having no slippage (0) technically exceeded the threshold (`emergencySettlementSlippageLimitPercent` = `10%`).\n\n```python\ndef test_emergency_single_maturity_success(StratBoostedPoolUSDCPrimary):\n    (env, vault) = StratBoostedPoolUSDCPrimary\n    primaryBorrowAmount = 5000e8\n    depositAmount = 10000e6\n    env.tokens[\"USDC\"].approve(env.notional, 2 ** 256 - 1, {\"from\": env.whales[\"USDC\"]})\n    maturity = enterMaturity(env, vault, 2, 0, depositAmount, primaryBorrowAmount, env.whales[\"USDC\"])\n    strategyContext = vault.getStrategyContext()\n    settings = dict(strategyContext[\"baseStrategy\"][\"vaultSettings\"].dict())\n    settings[\"maxBalancerPoolShare\"] = 0\n    vault.setStrategyVaultSettings(\n        list(settings.values()), \n        {\"from\": env.notional.owner()}\n    )\n    # minPrimary is calculated internally for boosted pools \n    redeemParams = get_redeem_params(0, 0, \n        get_dynamic_trade_params(\n            DEX_ID[\"UNISWAP_V3\"], TRADE_TYPE[\"EXACT_IN_SINGLE\"], 0, True, get_univ3_single_data(3000)\n        )\n    )\n    vault.settleVaultEmergency(maturity, redeemParams, {\"from\": env.notional.owner()})\n    vaultState = env.notional.getVaultState(vault.address, maturity)\n    assert vaultState[\"totalStrategyTokens\"] == 0\n```\n\n```bash\n❯ brownie test tests/balancer/settlement/test_settlement_boosted_usdc.py --network mainnet-fork\nBrownie v1.18.1 - Python development framework for Ethereum\n\n=============================================================================================== test session starts ===============================================================================================\nplatform linux -- Python 3.8.10, pytest-6.2.5, py-1.11.0, pluggy-1.0.0\nplugins: eth-brownie-1.18.1, hypothesis-6.27.3, forked-1.4.0, xdist-1.34.0, web3-5.27.0\ncollected 1 item                                                                                                                                                                                                  \nAttached to local RPC client listening at '127.0.0.1:8545'...\n\ntests/balancer/settlement/test_settlement_boosted_usdc.py .                                                                                                                                                 [100%]\n\n========================================================================================== 1 passed, 1 warning in 4.31s ===========================================================================================\n```\n\n## Impact\n\nMalicious users can trigger the permissionless `settleVaultEmergency` function and cause the trade to suffer huge slippage. This results in loss of assets for the vaults and their users.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/scripts/BalancerEnvironment.py#L43\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/external/Boosted3TokenAuraHelper.sol#L53\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/settlement/SettlementUtils.sol#L32\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/trading/TradingModule.sol#L109\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/trading/TradingUtils.sol#L162\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUpdate the `SettlementUtils._decodeParamsAndValidate` function to revert if the slippage is set to zero.\n\n```diff\nFile: SettlementUtils.sol\n27:     /// @notice Validates that the slippage passed in by the caller\n28:     /// does not exceed the designated threshold.\n29:     /// @param slippageLimitPercent configured limit on the slippage from the oracle price allowed\n30:     /// @param data trade parameters passed into settlement\n31:     /// @return params abi decoded redemption parameters\n32:     function _decodeParamsAndValidate(\n33:         uint32 slippageLimitPercent,\n34:         bytes memory data\n35:     ) internal view returns (RedeemParams memory params) {\n36:         params = abi.decode(data, (RedeemParams));\n37:         DynamicTradeParams memory callbackData = abi.decode(\n38:             params.secondaryTradeParams, (DynamicTradeParams)\n39:         );\n40: \n-41:         if (callbackData.oracleSlippagePercent > slippageLimitPercent) {\n+41:         if (callbackData.oracleSlippagePercent == 0 || callbackData.oracleSlippagePercent > slippageLimitPercent) {\n42:             revert Errors.SlippageTooHigh(callbackData.oracleSlippagePercent, slippageLimitPercent);\n43:         }\n44:     }\n```\n\n## Appendix I - Normal and Post Maturity Vault Settlement\n\nThe `settlementSlippageLimitPercent` and `postMaturitySettlementSlippageLimitPercent` of the vault are set to 5% and 10% respectively per the environment file provided by Notional.\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/scripts/BalancerEnvironment.py#L42\n\n```python\nFile: BalancerEnvironment.py\n42:             \"settlementSlippageLimitPercent\": 5e6, # 5%\n43:             \"postMaturitySettlementSlippageLimitPercent\": 10e6, # 10%\n```\n\nWhen a user calls the `settleVaultNormal` or `settleVaultPostMaturity` function, the vault will validate that the slippage (`DynamicTradeParams.oracleSlippagePercent`) defined by the caller is within the acceptable slippage range by calling `SettlementUtils._decodeParamsAndValidate` function.\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/MetaStable2TokenAuraVault.sol#L105\n\n```solidity\nFile: MetaStable2TokenAuraVault.sol\n105:     function settleVaultNormal(\n106:         uint256 maturity,\n107:         uint256 strategyTokensToRedeem,\n108:         bytes calldata data\n109:     ) external {\n110:         if (maturity <= block.timestamp) {\n111:             revert Errors.PostMaturitySettlement();\n112:         }\n113:         if (block.timestamp < maturity - SETTLEMENT_PERIOD_IN_SECONDS) {\n114:             revert Errors.NotInSettlementWindow();\n115:         }\n116:         MetaStable2TokenAuraStrategyContext memory context = _strategyContext();\n117:         SettlementUtils._validateCoolDown(\n118:             context.baseStrategy.vaultState.lastSettlementTimestamp,\n119:             context.baseStrategy.vaultSettings.settlementCoolDownInMinutes\n120:         );\n121:         RedeemParams memory params = SettlementUtils._decodeParamsAndValidate(\n122:             context.baseStrategy.vaultSettings.settlementSlippageLimitPercent,\n123:             data\n124:         );\n125:         MetaStable2TokenAuraHelper.settleVault(\n126:             context, maturity, strategyTokensToRedeem, params\n127:         );\n128:         context.baseStrategy.vaultState.lastSettlementTimestamp = uint32(block.timestamp);\n129:         context.baseStrategy.vaultState.setStrategyVaultState();\n130:     }\n131: \n132:     function settleVaultPostMaturity(\n133:         uint256 maturity,\n134:         uint256 strategyTokensToRedeem,\n135:         bytes calldata data\n136:     ) external onlyNotionalOwner {\n137:         if (block.timestamp < maturity) {\n138:             revert Errors.HasNotMatured();\n139:         }\n140:         MetaStable2TokenAuraStrategyContext memory context = _strategyContext();\n141:         SettlementUtils._validateCoolDown(\n142:             context.baseStrategy.vaultState.lastPostMaturitySettlementTimestamp,\n143:             context.baseStrategy.vaultSettings.postMaturitySettlementCoolDownInMinutes\n144:         );\n145:         RedeemParams memory params = SettlementUtils._decodeParamsAndValidate(\n146:             context.baseStrategy.vaultSettings.postMaturitySettlementSlippageLimitPercent,\n147:             data\n148:         );\n149:         MetaStable2TokenAuraHelper.settleVault(\n150:             context, maturity, strategyTokensToRedeem, params\n151:         );\n152:         context.baseStrategy.vaultState.lastPostMaturitySettlementTimestamp = uint32(block.timestamp);    \n153:         context.baseStrategy.vaultState.setStrategyVaultState();  \n154:     }\n```\n\nSince the same vulnerable `SettlementUtils._decodeParamsAndValidate` function is being used here, the `settleVaultNormal` and `settleVaultPostMaturity` functions are affected by this issue too.\n\n## Discussion\n\n**jeffywu**\n\n@weitianjie2000\n\n**jeffywu**\n\nSlippage control removal is now set to uint256.max which will resolve this issue.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/2",
  "Code": [
    {
      "filename": "leveraged-vaults/scripts/BalancerEnvironment.py",
      "content": "import eth_abi\nfrom brownie import (\n    network, \n    nProxy,\n    MetaStable2TokenAuraVault,\n    Boosted3TokenAuraVault,\n    Boosted3TokenAuraHelper,\n    MetaStable2TokenAuraHelper\n)\nfrom brownie.network.contract import Contract\nfrom brownie.convert.datatypes import Wei\nfrom brownie.network.state import Chain\nfrom brownie.convert import to_bytes\nfrom scripts.common import deployArtifact, get_vault_config, set_flags\nfrom scripts.EnvironmentConfig import Environment\nfrom eth_utils import keccak\n\nchain = Chain()\nETH_ADDRESS = \"0x0000000000000000000000000000000000000000\"\n\nStrategyConfig = {\n    \"balancer2TokenStrats\": {\n        \"StratStableETHstETH\": {\n            \"vaultConfig\": get_vault_config(\n                flags=set_flags(0, ENABLED=True, ALLOW_ROLL_POSITION=True),\n                currencyId=1,\n                minAccountBorrowSize=1,\n                maxBorrowMarketIndex=3,\n                secondaryBorrowCurrencies=[0,0]\n            ),\n            \"secondaryBorrowCurrency\": None,\n            \"maxPrimaryBorrowCapacity\": 100_000_000e8,\n            \"name\": \"Balancer Stable ETH-stETH Strategy\",\n            \"primaryCurrency\": 1, # ETH\n            \"poolId\": \"0x32296969ef14eb0c6d29669c550d4a0449130230000200000000000000000080\",\n            \"liquidityGauge\": \"0xcd4722b7c24c29e0413bdcd9e51404b4539d14ae\",\n            \"auraRewardPool\": \"0xdcee1c640cc270121faf145f231fd8ff1d8d5cd4\",\n            \"feeReceiver\": \"0x0190702d5e52e0269c9319144d3ad62a60ebe526\",\n            \"maxUnderlyingSurplus\": 100e18, # 10 ETH\n            \"oracleWindowInSeconds\": 3600,\n            \"maxBalancerPoolShare\": 2e3, # 20%\n            \"settlementSlippageLimitPercent\": 5e6, # 5%\n            \"postMaturitySettlementSlippageLimitPercent\": 10e6, # 10%\n            \"emergencySettlementSlippageLimitPercent\": 10e6, # 10%\n            \"maxRewardTradeSlippageLimitPercent\": 5e6,\n            \"balancerOracleWeight\": 0.6e4, # 60%\n            \"settlementCoolDownInMinutes\": 60 * 6, # 6 hour settlement cooldown\n            \"postMaturitySettlementCoolDownInMinutes\": 60 * 6, # 6 hour settlement cooldown\n            \"feePercentage\": 1e2, # 1%\n            \"settlementWindow\": 3600 * 24 * 7,  # 1-week settlement\n            \"oraclePriceDeviationLimitPercent\": 500, # +/- 5%\n            \"balancerPoolSlippageLimitPercent\": 9900, # 1%\n        },\n        \"StratBoostedPoolDAIPrimary\": {\n            \"vaultConfig\": get_vault_config(\n                flags=set_flags(0, ENABLED=True, ALLOW_ROLL_POSITION=True),\n                currencyId=2,\n                minAccountBorrowSize=1,\n                maxBorrowMarketIndex=3,\n                secondaryBorrowCurrencies=[0,0]\n            ),\n            \"secondaryBorrowCurrency\": None,\n            \"maxPrimaryBorrowCapacity\": 100_000_000e8,\n            \"name\": \"Balancer Boosted Pool Strategy\",\n            \"primaryCurrency\": 2, # DAI\n            \"poolId\": \"0x7b50775383d3d6f0215a8f290f2c9e2eebbeceb20000000000000000000000fe\",\n            \"liquidityGauge\": \"0x68d019f64a7aa97e2d4e7363aee42251d08124fb\",\n            \"auraRewardPool\": \"0xcc2f52b57247f2bc58fec182b9a60dac5963d010\",\n            \"feeReceiver\": \"0x0190702d5e52e0269c9319144d3ad62a60ebe526\",\n            \"maxUnderlyingSurplus\": 10000e18, # 10000 DAI\n            \"oracleWindowInSeconds\": 0,\n            \"maxBalancerPoolShare\": 2e3, # 20%\n            \"settlementSlippageLimitPercent\": 5e6, # 5%\n            \"postMaturitySettlementSlippageLimitPercent\": 10e6, # 10%\n            \"emergencySettlementSlippageLimitPercent\": 10e6, # 10%\n            \"maxRewardTradeSlippageLimitPercent\": 5e6,\n            \"balancerOracleWeight\": 0,\n            \"settlementCoolDownInMinutes\": 60 * 6, # 6 hour settlement cooldown\n            \"postMaturitySettlementCoolDownInMinutes\": 60 * 6, # 6 hour settlement cooldown\n            \"feePercentage\": 1e2, # 1%\n            \"settlementWindow\": 3600 * 24 * 7,  # 1-week settlement\n            \"oraclePriceDeviationLimitPercent\": 50, # +/- 0.5%\n            \"balancerPoolSlippageLimitPercent\": 9900, # 1%\n        },\n        \"StratBoostedPoolUSDCPrimary\": {\n            \"vaultConfig\": get_vault_config(\n                flags=set_flags(0, ENABLED=True, ALLOW_ROLL_POSITION=True),\n                currencyId=3,\n                minAccountBorrowSize=1,\n                maxBorrowMarketIndex=3,\n                secondaryBorrowCurrencies=[0,0]\n            ),\n            \"secondaryBorrowCurrency\": None,\n            \"maxPrimaryBorrowCapacity\": 100_000_000e8,\n            \"name\": \"Balancer Boosted Pool Strategy\",\n            \"primaryCurrency\": 3, # USDC\n            \"poolId\": \"0x7b50775383d3d6f0215a8f290f2c9e2eebbeceb20000000000000000000000fe\",\n            \"liquidityGauge\": \"0x68d019f64a7aa97e2d4e7363aee42251d08124fb\",\n            \"auraRewardPool\": \"0xcc2f52b57247f2bc58fec182b9a60dac5963d010\",\n            \"feeReceiver\": \"0x0190702d5e52e0269c9319144d3ad62a60ebe526\",\n            \"maxUnderlyingSurplus\": 10000e6, # 10000 USDC\n            \"oracleWindowInSeconds\": 0,\n            \"maxBalancerPoolShare\": 2e3, # 20%\n            \"settlementSlippageLimitPercent\": 5e6, # 5%\n            \"postMaturitySettlementSlippageLimitPercent\": 10e6, # 10%\n            \"emergencySettlementSlippageLimitPercent\": 10e6, # 10%\n            \"maxRewardTradeSlippageLimitPercent\": 5e6,\n            \"balancerOracleWeight\": 0,\n            \"settlementCoolDownInMinutes\": 60 * 6, # 6 hour settlement cooldown\n            \"postMaturitySettlementCoolDownInMinutes\": 60 * 6, # 6 hour settlement cooldown\n            \"feePercentage\": 1e2, # 1%\n            \"settlementWindow\": 3600 * 24 * 7,  # 1-week settlement\n            \"oraclePriceDeviationLimitPercent\": 50, # +/- 0.5%\n            \"balancerPoolSlippageLimitPercent\": 9900, # 1%\n        }\n    }\n}\n\nclass BalancerEnvironment(Environment):\n    def __init__(self, network) -> None:\n        Environment.__init__(self, network)\n\n    def deployBalancerVault(self, strat, vaultContract, libs=None):\n        stratConfig = StrategyConfig[\"balancer2TokenStrats\"][strat]\n\n        # Deploy external libs\n        if libs != None:\n            for lib in libs:\n                lib.deploy({\"from\": self.deployer})\n\n        impl = vaultContract.deploy(\n            self.addresses[\"notional\"],\n            [\n                stratConfig[\"auraRewardPool\"],\n                [\n                    stratConfig[\"primaryCurrency\"],\n                    stratConfig[\"poolId\"],\n                    stratConfig[\"liquidityGauge\"],\n                    self.tradingModule.address,\n                    stratConfig[\"settlementWindow\"],\n                    stratConfig[\"feeReceiver\"]\n                ]\n            ],\n            {\"from\": self.deployer}\n        )\n\n        proxy = nProxy.deploy(impl.address, bytes(0), {\"from\": self.deployer})\n        vaultProxy = Contract.from_abi(stratConfig[\"name\"], proxy.address, vaultContract.abi)\n\n        print(\n            vaultProxy.initialize.encode_input(\n                [\n                    stratConfig[\"name\"],\n                    stratConfig[\"primaryCurrency\"],\n                    [\n                        stratConfig[\"maxUnderlyingSurplus\"],\n                        stratConfig[\"oracleWindowInSeconds\"],\n                        stratConfig[\"settlementSlippageLimitPercent\"], \n                        stratConfig[\"postMaturitySettlementSlippageLimitPercent\"], \n                        stratConfig[\"emergencySettlementSlippageLimitPercent\"], \n                        stratConfig[\"maxRewardTradeSlippageLimitPercent\"],\n                        stratConfig[\"maxBalancerPoolShare\"],\n                        stratConfig[\"balancerOracleWeight\"],\n                        stratConfig[\"settlementCoolDownInMinutes\"],\n                        stratConfig[\"postMaturitySettlementCoolDownInMinutes\"],\n                        stratConfig[\"feePercentage\"],\n                        stratConfig[\"oraclePriceDeviationLimitPercent\"],\n                        stratConfig[\"balancerPoolSlippageLimitPercent\"]\n                    ]\n                ]\n            )\n        )\n\n        vaultProxy.initialize(\n            [\n                stratConfig[\"name\"],\n                stratConfig[\"primaryCurrency\"],\n                [\n                    stratConfig[\"maxUnderlyingSurplus\"],\n                    stratConfig[\"oracleWindowInSeconds\"],\n                    stratConfig[\"settlementSlippageLimitPercent\"], \n                    stratConfig[\"postMaturitySettlementSlippageLimitPercent\"], \n                    stratConfig[\"emergencySettlementSlippageLimitPercent\"], \n                    stratConfig[\"maxRewardTradeSlippageLimitPercent\"],\n                    stratConfig[\"maxBalancerPoolShare\"],\n                    stratConfig[\"balancerOracleWeight\"],\n                    stratConfig[\"settlementCoolDownInMinutes\"],\n                    stratConfig[\"postMaturitySettlementCoolDownInMinutes\"],\n                    stratConfig[\"feePercentage\"],\n                    stratConfig[\"oraclePriceDeviationLimitPercent\"],\n                    stratConfig[\"balancerPoolSlippageLimitPercent\"]\n                ]\n            ],\n            {\"from\": self.notional.owner()}\n        )\n\n        self.notional.updateVault(\n            proxy.address,\n            stratConfig[\"vaultConfig\"],\n            stratConfig[\"maxPrimaryBorrowCapacity\"],\n            {\"from\": self.notional.owner()}\n        )\n\n        return vaultProxy\n\ndef getEnvironment(network = \"mainnet\"):\n    if network == \"mainnet-fork\" or network == \"hardhat-fork\":\n        network = \"mainnet\"\n    return BalancerEnvironment(network)\n\ndef main():\n    networkName = network.show_active()\n    if networkName == \"hardhat-fork\":\n        networkName = \"mainnet\"\n    env = BalancerEnvironment(networkName)\n    maturity = env.notional.getActiveMarkets(1)[0][1]\n\n    vault1 = env.deployBalancerVault(\n        \"StratStableETHstETH\", \n        MetaStable2TokenAuraVault,\n        [MetaStable2TokenAuraHelper]\n    )\n    vault2 = env.deployBalancerVault(\n        \"StratBoostedPoolDAIPrimary\", \n        Boosted3TokenAuraVault,\n        [Boosted3TokenAuraHelper]\n    )\n    vault3 = env.deployBalancerVault(\n        \"StratBoostedPoolUSDCPrimary\", \n        Boosted3TokenAuraVault,\n        [Boosted3TokenAuraHelper]\n    )"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/external/Boosted3TokenAuraHelper.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {\n    Boosted3TokenAuraStrategyContext, \n    StrategyContext,\n    RedeemParams,\n    ReinvestRewardParams,\n    ThreeTokenPoolContext,\n    StrategyContext,\n    AuraStakingContext,\n    BoostedOracleContext,\n    StrategyVaultSettings,\n    StrategyVaultState\n} from \"../BalancerVaultTypes.sol\";\nimport {BalancerConstants} from \"../internal/BalancerConstants.sol\";\nimport {BalancerEvents} from \"../BalancerEvents.sol\";\nimport {SettlementUtils} from \"../internal/settlement/SettlementUtils.sol\";\nimport {StrategyUtils} from \"../internal/strategy/StrategyUtils.sol\";\nimport {Boosted3TokenPoolUtils} from \"../internal/pool/Boosted3TokenPoolUtils.sol\";\nimport {Boosted3TokenAuraRewardUtils} from \"../internal/reward/Boosted3TokenAuraRewardUtils.sol\";\nimport {BalancerVaultStorage} from \"../internal/BalancerVaultStorage.sol\";\nimport {StableMath} from \"../internal/math/StableMath.sol\";\n\nlibrary Boosted3TokenAuraHelper {\n    using Boosted3TokenAuraRewardUtils for ThreeTokenPoolContext;\n    using Boosted3TokenPoolUtils for ThreeTokenPoolContext;\n    using StrategyUtils for StrategyContext;\n    using SettlementUtils for StrategyContext;\n    using BalancerVaultStorage for StrategyVaultSettings;\n\n    function settleVault(\n        Boosted3TokenAuraStrategyContext calldata context,\n        uint256 maturity,\n        uint256 strategyTokensToRedeem,\n        RedeemParams memory params\n    ) external {\n        uint256 bptToSettle = context.baseStrategy._convertStrategyTokensToBPTClaim(strategyTokensToRedeem);\n\n        _executeSettlement({\n            strategyContext: context.baseStrategy,\n            oracleContext: context.oracleContext,\n            poolContext: context.poolContext,\n            maturity: maturity,\n            bptToSettle: bptToSettle,\n            redeemStrategyTokenAmount: strategyTokensToRedeem,\n            params: params\n        });\n\n        emit BalancerEvents.VaultSettlement(maturity, bptToSettle, strategyTokensToRedeem);\n    }\n\n    function settleVaultEmergency(\n        Boosted3TokenAuraStrategyContext calldata context, \n        uint256 maturity, \n        bytes calldata data\n    ) external {\n        RedeemParams memory params = SettlementUtils._decodeParamsAndValidate(\n            context.baseStrategy.vaultSettings.emergencySettlementSlippageLimitPercent,\n            data\n        );\n\n        uint256 bptToSettle = context.baseStrategy._getEmergencySettlementParams({\n            poolContext: context.poolContext.basePool.basePool, \n            maturity: maturity, \n            totalBPTSupply: context.poolContext._getVirtualSupply(context.oracleContext)\n        });\n\n        uint256 redeemStrategyTokenAmount \n            = context.baseStrategy._convertBPTClaimToStrategyTokens(bptToSettle);\n        \n        _executeSettlement({\n            strategyContext: context.baseStrategy,\n            oracleContext: context.oracleContext,\n            poolContext: context.poolContext,\n            maturity: maturity,\n            bptToSettle: bptToSettle,\n            redeemStrategyTokenAmount: redeemStrategyTokenAmount,\n            params: params\n        });\n\n        emit BalancerEvents.EmergencyVaultSettlement(maturity, bptToSettle, redeemStrategyTokenAmount);\n    }\n\n    function _executeSettlement(\n        StrategyContext calldata strategyContext,\n        BoostedOracleContext calldata oracleContext,\n        ThreeTokenPoolContext calldata poolContext,\n        uint256 maturity,\n        uint256 bptToSettle,\n        uint256 redeemStrategyTokenAmount,\n        RedeemParams memory params\n    ) private {\n        // Calculate minPrimary using Chainlink oracle data\n        params.minPrimary = poolContext._getTimeWeightedPrimaryBalance(\n            oracleContext, strategyContext, bptToSettle\n        );\n        params.minPrimary = params.minPrimary * strategyContext.vaultSettings.balancerPoolSlippageLimitPercent / \n            uint256(BalancerConstants.VAULT_PERCENT_BASIS);\n\n        int256 expectedUnderlyingRedeemed = poolContext._convertStrategyToUnderlying({\n            strategyContext: strategyContext,\n            oracleContext: oracleContext,\n            strategyTokenAmount: redeemStrategyTokenAmount\n        });\n\n        strategyContext._executeSettlement({\n            maturity: maturity,\n            expectedUnderlyingRedeemed: expectedUnderlyingRedeemed,\n            redeemStrategyTokenAmount: redeemStrategyTokenAmount,\n            params: params\n        });\n    }\n\n    function reinvestReward(\n        Boosted3TokenAuraStrategyContext calldata context,\n        ReinvestRewardParams calldata params\n    ) external {        \n        StrategyContext calldata strategyContext = context.baseStrategy;\n        BoostedOracleContext calldata oracleContext = context.oracleContext;\n        AuraStakingContext calldata stakingContext = context.stakingContext;\n\n        (address rewardToken, uint256 primaryAmount) = context.poolContext._executeRewardTrades({\n            stakingContext: stakingContext,\n            tradingModule: strategyContext.tradingModule,\n            data: params.tradeData,\n            slippageLimit: strategyContext.vaultSettings.maxRewardTradeSlippageLimitPercent\n        });\n\n        uint256 minBPT = context.poolContext._getMinBPT(\n            oracleContext, strategyContext, primaryAmount\n        );\n\n        uint256 bptAmount = context.poolContext._joinPoolAndStake({\n            strategyContext: strategyContext,\n            stakingContext: stakingContext,\n            oracleContext: oracleContext,\n            deposit: primaryAmount,\n            minBPT: minBPT\n        });\n\n        emit BalancerEvents.RewardReinvested(rewardToken, primaryAmount, 0, bptAmount); \n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/internal/settlement/SettlementUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {\n    RedeemParams, \n    DynamicTradeParams,\n    StrategyContext,\n    PoolContext,\n    StrategyVaultSettings,\n    StrategyVaultState\n} from \"../../BalancerVaultTypes.sol\";\nimport {VaultState} from \"../../../../global/Types.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {Deployments} from \"../../../../global/Deployments.sol\";\nimport {Constants} from \"../../../../global/Constants.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {StrategyUtils} from \"../strategy/StrategyUtils.sol\";\nimport {BalancerVaultStorage} from \"../BalancerVaultStorage.sol\";\n\nlibrary SettlementUtils {\n    using TypeConvert for uint256;\n    using TypeConvert for int256;\n    using StrategyUtils for StrategyContext;\n    using BalancerVaultStorage for StrategyVaultSettings;\n\n    /// @notice Validates that the slippage passed in by the caller\n    /// does not exceed the designated threshold.\n    /// @param slippageLimitPercent configured limit on the slippage from the oracle price allowed\n    /// @param data trade parameters passed into settlement\n    /// @return params abi decoded redemption parameters\n    function _decodeParamsAndValidate(\n        uint32 slippageLimitPercent,\n        bytes memory data\n    ) internal view returns (RedeemParams memory params) {\n        params = abi.decode(data, (RedeemParams));\n        DynamicTradeParams memory callbackData = abi.decode(\n            params.secondaryTradeParams, (DynamicTradeParams)\n        );\n\n        if (callbackData.oracleSlippagePercent > slippageLimitPercent) {\n            revert Errors.SlippageTooHigh(callbackData.oracleSlippagePercent, slippageLimitPercent);\n        }\n    }\n\n    /// @notice Validates that the settlement is past a specified cool down period.\n    /// @param lastSettlementTimestamp the last time the vault was settled\n    /// @param coolDownInMinutes configured length of time required between settlements to ensure that\n    /// slippage thresholds are respected (gives the market time to arbitrage back into position)\n    function _validateCoolDown(uint32 lastSettlementTimestamp, uint32 coolDownInMinutes) internal view {\n        // Convert coolDown to seconds\n        if (lastSettlementTimestamp + (coolDownInMinutes * 60) > block.timestamp)\n            revert Errors.InSettlementCoolDown(lastSettlementTimestamp, coolDownInMinutes);\n    }\n\n    /// @notice Calculates the amount of BPT availTable for emergency settlement\n    function _getEmergencySettlementBPTAmount(\n        uint256 bptTotalSupply,\n        uint16 maxBalancerPoolShare,\n        uint256 totalBPTHeld,\n        uint256 bptHeldInMaturity\n    ) private pure returns (uint256 bptToSettle) {\n        // desiredPoolShare = maxPoolShare * bufferPercentage\n        uint256 desiredPoolShare = (maxBalancerPoolShare *\n            BalancerConstants.BALANCER_POOL_SHARE_BUFFER) /\n            BalancerConstants.VAULT_PERCENT_BASIS;\n        uint256 desiredBPTAmount = (bptTotalSupply * desiredPoolShare) /\n            BalancerConstants.VAULT_PERCENT_BASIS;\n        \n        bptToSettle = totalBPTHeld - desiredBPTAmount;\n\n        // Check to make sure we are not settling more than the amount of BPT\n        // available in the current maturity\n        // If more settlement is needed, call settleVaultEmergency\n        // again with a different maturity\n        if (bptToSettle > bptHeldInMaturity) {\n            bptToSettle = bptHeldInMaturity;\n        }\n    }\n\n    function _totalSupplyInMaturity(uint256 maturity) private view returns (uint256) {\n        VaultState memory vaultState = Deployments.NOTIONAL.getVaultState(address(this), maturity);\n        return vaultState.totalStrategyTokens;\n    }\n\n    function _getEmergencySettlementParams(\n        StrategyContext memory strategyContext,\n        PoolContext memory poolContext,\n        uint256 maturity,\n        uint256 totalBPTSupply\n    )  internal view returns(uint256 bptToSettle) {\n        StrategyVaultSettings memory settings = strategyContext.vaultSettings;\n        StrategyVaultState memory state = strategyContext.vaultState;\n\n        // Not in settlement window, check if BPT held is greater than maxBalancerPoolShare * total BPT supply\n        uint256 emergencyBPTWithdrawThreshold = settings._bptThreshold(totalBPTSupply);\n\n        if (strategyContext.totalBPTHeld <= emergencyBPTWithdrawThreshold)\n            revert Errors.InvalidEmergencySettlement();\n\n        uint256 bptHeldInMaturity = _getBPTHeldInMaturity(\n            state,\n            _totalSupplyInMaturity(maturity),\n            strategyContext.totalBPTHeld\n        );\n\n        bptToSettle = _getEmergencySettlementBPTAmount({\n            bptTotalSupply: totalBPTSupply,\n            maxBalancerPoolShare: settings.maxBalancerPoolShare,\n            totalBPTHeld: strategyContext.totalBPTHeld,\n            bptHeldInMaturity: bptHeldInMaturity\n        });\n    }\n\n    function _executeSettlement(\n        StrategyContext memory context,\n        uint256 maturity,\n        int256 expectedUnderlyingRedeemed,\n        uint256 redeemStrategyTokenAmount,\n        RedeemParams memory params\n    ) internal {\n        ( /* int256 assetCashRequiredToSettle */, int256 underlyingCashRequiredToSettle) \n            = Deployments.NOTIONAL.getCashRequiredToSettle(address(this), maturity);\n\n        // A negative surplus here means the account is insolvent\n        // (either expectedUnderlyingRedeemed is negative or\n        // expectedUnderlyingRedeemed is less than underlyingCashRequiredToSettle).\n        // If that's the case, we should just redeem and repay as much as possible (surplus\n        // check is ignored because maxUnderlyingSurplus can never be negative).\n        // If underlyingCashRequiredToSettle is negative, that means we already have surplus cash\n        // on the Notional side, it will just make the surplus larger and potentially\n        // cause it to go over maxUnderlyingSurplus.\n        int256 surplus = expectedUnderlyingRedeemed -\n            underlyingCashRequiredToSettle;\n\n        // Make sure we not redeeming too much to underlying\n        // This allows BPT to be accrued as the profit token.\n        if (surplus > context.vaultSettings.maxUnderlyingSurplus.toInt()) {\n            revert Errors.RedeemingTooMuch(\n                expectedUnderlyingRedeemed,\n                underlyingCashRequiredToSettle\n            );\n        }\n\n        ( /* int256 assetCashSurplus */, int256 underlyingCashSurplus) \n            = Deployments.NOTIONAL.redeemStrategyTokensToCash(\n                maturity, redeemStrategyTokenAmount, abi.encode(params)\n            );\n\n        if (underlyingCashSurplus <= 0 && maturity <= block.timestamp) {\n            Deployments.NOTIONAL.settleVault(address(this), maturity);\n        }\n    }\n\n    function _getBPTHeldInMaturity(\n        StrategyVaultState memory strategyVaultState, \n        uint256 totalSupplyInMaturity,\n        uint256 totalBPTHeld\n    ) private pure returns (uint256 bptHeldInMaturity) {\n        if (strategyVaultState.totalStrategyTokenGlobal == 0) return 0;\n        bptHeldInMaturity =\n            (totalBPTHeld * totalSupplyInMaturity) /\n            strategyVaultState.totalStrategyTokenGlobal;\n    }\n\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/trading/TradingModule.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport {Deployments} from \"../global/Deployments.sol\";\nimport {Constants} from \"../global/Constants.sol\";\nimport {BalancerV2Adapter} from \"./adapters/BalancerV2Adapter.sol\";\nimport {CurveAdapter} from \"./adapters/CurveAdapter.sol\";\nimport {UniV2Adapter} from \"./adapters/UniV2Adapter.sol\";\nimport {UniV3Adapter} from \"./adapters/UniV3Adapter.sol\";\nimport {ZeroExAdapter} from \"./adapters/ZeroExAdapter.sol\";\nimport {TradingUtils} from \"./TradingUtils.sol\";\n\nimport {IERC20} from \"../utils/TokenUtils.sol\";\nimport {NotionalProxy} from \"../../interfaces/notional/NotionalProxy.sol\";\nimport {ITradingModule} from \"../../interfaces/trading/ITradingModule.sol\";\nimport \"../../interfaces/trading/IVaultExchange.sol\";\nimport \"../../interfaces/chainlink/AggregatorV2V3Interface.sol\";\n\n/// @notice TradingModule is meant to be an upgradeable contract deployed to help Strategy Vaults\n/// exchange tokens via multiple DEXes as well as receive price oracle information\ncontract TradingModule is Initializable, UUPSUpgradeable, ITradingModule {\n    NotionalProxy public immutable NOTIONAL;\n    // Used to get the proxy address inside delegate call contexts\n    ITradingModule internal immutable PROXY;\n\n    error SellTokenEqualsBuyToken();\n    error UnknownDEX();\n\n    struct PriceOracle {\n        AggregatorV2V3Interface oracle;\n        uint8 rateDecimals;\n    }\n\n    int256 internal constant RATE_DECIMALS = 1e18;\n    mapping(address => PriceOracle) public priceOracles;\n    uint32 public maxOracleFreshnessInSeconds;\n\n    constructor(NotionalProxy notional_, ITradingModule proxy_) initializer { \n        NOTIONAL = notional_;\n        PROXY = proxy_;\n    }\n\n    modifier onlyNotionalOwner() {\n        require(msg.sender == NOTIONAL.owner());\n        _;\n    }\n\n    function _authorizeUpgrade(\n        address /* newImplementation */\n    ) internal override onlyNotionalOwner {}\n\n    function initialize(uint32 maxOracleFreshnessInSeconds_) external initializer onlyNotionalOwner {\n        maxOracleFreshnessInSeconds = maxOracleFreshnessInSeconds_;\n    }\n\n    function setMaxOracleFreshness(uint32 newMaxOracleFreshnessInSeconds) external onlyNotionalOwner {\n        emit MaxOracleFreshnessUpdated(maxOracleFreshnessInSeconds, newMaxOracleFreshnessInSeconds);\n        maxOracleFreshnessInSeconds = newMaxOracleFreshnessInSeconds;\n    }\n\n    function setPriceOracle(address token, AggregatorV2V3Interface oracle) external override onlyNotionalOwner {\n        PriceOracle storage oracleStorage = priceOracles[token];\n        oracleStorage.oracle = oracle;\n        oracleStorage.rateDecimals = oracle.decimals();\n\n        emit PriceOracleUpdated(token, address(oracle));\n    }\n\n    /// @notice Called to receive execution data for vaults that will execute trades without\n    /// delegating calls to this contract\n    /// @param dexId enum representing the id of the dex\n    /// @param from address for the contract executing the trade\n    /// @param trade trade object\n    /// @return spender the address to approve for the soldToken, will be address(0) if the\n    /// send token is ETH and therefore does not require approval\n    /// @return target contract to execute the call against\n    /// @return msgValue amount of ETH to transfer to the target, if any\n    /// @return executionCallData encoded call data for the trade\n    function getExecutionData(\n        uint16 dexId,\n        address from,\n        Trade calldata trade\n    )\n        external\n        view\n        override\n        returns (\n            address spender,\n            address target,\n            uint256 msgValue,\n            bytes memory executionCallData\n        )\n    {\n        return _getExecutionData(dexId, from, trade);\n    }\n\n    /// @notice Executes a trade with a dynamic slippage limit based on chainlink oracles.\n    /// @dev Expected to be called via delegatecall on the implementation directly. This means that\n    /// the contract's calling context does not have access to storage (accessible via the proxy\n    /// address).\n    /// @param dexId the dex to execute the trade on\n    /// @param trade trade object\n    /// @param dynamicSlippageLimit the slippage limit in 1e8 precision\n    /// @return amountSold amount of tokens sold\n    /// @return amountBought amount of tokens purchased\n    function executeTradeWithDynamicSlippage(\n        uint16 dexId,\n        Trade memory trade,\n        uint32 dynamicSlippageLimit\n    ) external override returns (uint256 amountSold, uint256 amountBought) {\n        // This method calls back into the implementation via the proxy so that it has proper\n        // access to storage.\n        trade.limit = PROXY.getLimitAmount(\n            trade.tradeType,\n            trade.sellToken,\n            trade.buyToken,\n            trade.amount,\n            dynamicSlippageLimit\n        );\n\n        (\n            address spender,\n            address target,\n            uint256 msgValue,\n            bytes memory executionData\n        ) = PROXY.getExecutionData(dexId, address(this), trade);\n\n        return\n            TradingUtils._executeInternal(\n                trade,\n                dexId,\n                spender,\n                target,\n                msgValue,\n                executionData\n            );\n    }\n\n    /// @notice Should be called via delegate call to execute a trade on behalf of the caller.\n    /// @param dexId enum representing the id of the dex\n    /// @param trade trade object\n    /// @return amountSold amount of tokens sold\n    /// @return amountBought amount of tokens purchased\n    function executeTrade(uint16 dexId, Trade calldata trade)\n        external\n        override\n        returns (uint256 amountSold, uint256 amountBought)\n    {\n        (\n            address spender,\n            address target,\n            uint256 msgValue,\n            bytes memory executionData\n        ) = _getExecutionData(dexId, address(this), trade);\n\n        return\n            TradingUtils._executeInternal(\n                trade,\n                dexId,\n                spender,\n                target,\n                msgValue,\n                executionData\n            );\n    }\n\n    function _getExecutionData(\n        uint16 dexId,\n        address from,\n        Trade calldata trade\n    )\n        internal\n        view\n        returns (\n            address spender,\n            address target,\n            uint256 msgValue,\n            bytes memory executionCallData\n        )\n    {\n        if (trade.buyToken == trade.sellToken) revert SellTokenEqualsBuyToken();\n\n        if (DexId(dexId) == DexId.UNISWAP_V2) {\n            return UniV2Adapter.getExecutionData(from, trade);\n        } else if (DexId(dexId) == DexId.UNISWAP_V3) {\n            return UniV3Adapter.getExecutionData(from, trade);\n        } else if (DexId(dexId) == DexId.BALANCER_V2) {\n            return BalancerV2Adapter.getExecutionData(from, trade);\n        } else if (DexId(dexId) == DexId.CURVE) {\n            return CurveAdapter.getExecutionData(from, trade);\n        } else if (DexId(dexId) == DexId.ZERO_EX) {\n            return ZeroExAdapter.getExecutionData(from, trade);\n        }\n\n        revert UnknownDEX();\n    }\n\n    /// @notice Returns the Chainlink oracle price between the baseToken and the quoteToken, the\n    /// Chainlink oracles. The quote currency between the oracles must match or the conversion\n    /// in this method does not work. Most Chainlink oracles are baseToken/USD pairs.\n    /// @param baseToken address of the first token in the pair, i.e. USDC in USDC/DAI\n    /// @param quoteToken address of the second token in the pair, i.e. DAI in USDC/DAI\n    /// @return answer exchange rate in rate decimals\n    /// @return decimals number of decimals in the rate, currently hardcoded to 1e18\n    function getOraclePrice(address baseToken, address quoteToken)\n        public\n        view\n        override\n        returns (int256 answer, int256 decimals)\n    {\n        PriceOracle memory baseOracle = priceOracles[baseToken];\n        PriceOracle memory quoteOracle = priceOracles[quoteToken];\n\n        int256 baseDecimals = int256(10**baseOracle.rateDecimals);\n        int256 quoteDecimals = int256(10**quoteOracle.rateDecimals);\n\n        (/* */, int256 basePrice, /* */, uint256 bpUpdatedAt, /* */) = baseOracle.oracle.latestRoundData();\n        require(block.timestamp - bpUpdatedAt <= maxOracleFreshnessInSeconds);\n        require(basePrice > 0); /// @dev: Chainlink Rate Error\n\n        (/* */, int256 quotePrice, /* */, uint256 qpUpdatedAt, /* */) = quoteOracle.oracle.latestRoundData();\n        require(block.timestamp - qpUpdatedAt <= maxOracleFreshnessInSeconds);\n        require(quotePrice > 0); /// @dev: Chainlink Rate Error\n\n        answer =\n            (basePrice * quoteDecimals * RATE_DECIMALS) /\n            (quotePrice * baseDecimals);\n        decimals = RATE_DECIMALS;\n    }\n\n    function getLimitAmount(\n        TradeType tradeType,\n        address sellToken,\n        address buyToken,\n        uint256 amount,\n        uint32 slippageLimit\n    ) external view override returns (uint256 limitAmount) {\n        // prettier-ignore\n        (int256 oraclePrice, int256 oracleDe"
    }
  ]
}