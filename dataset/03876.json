{
  "Title": "[M06] Using stale cToken exchange rate",
  "Content": "Throughout the [`CompoundProvider` contract](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/blob/943df3a8fcd8dd128af3beb0c85a0480c0e95ead/contracts/providers/CompoundProvider.sol#L305), when considering the exchange rate between cTokens and uTokens in a given Compound pool, the poolâ€™s [`exchangeRateStored`](https://github.com/compound-finance/compound-protocol/blob/c5fcc34222693ad5f547b14ed01ce719b5f4b000/contracts/CToken.sol#L328) function is used rather than its [`exchangeRateCurrent`](https://github.com/compound-finance/compound-protocol/blob/c5fcc34222693ad5f547b14ed01ce719b5f4b000/contracts/CToken.sol#L318) function. The result is that the exchange rate used is out of date, and relies on parties interacting with the Compound pool incredibly regularly. This leads to incorrect [calculations of fees](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/blob/943df3a8fcd8dd128af3beb0c85a0480c0e95ead/contracts/providers/CompoundProvider.sol#L225), incorrect [calculation of the underlying balance](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/blob/943df3a8fcd8dd128af3beb0c85a0480c0e95ead/contracts/providers/CompoundProvider.sol#L273), and incorrect [calculation of the expected COMP reward](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/blob/943df3a8fcd8dd128af3beb0c85a0480c0e95ead/contracts/providers/CompoundProvider.sol#L309).\n\n\nConsider using the [`exchangeRateCurrent`](https://github.com/compound-finance/compound-protocol/blob/c5fcc34222693ad5f547b14ed01ce719b5f4b000/contracts/CToken.sol#L318) function to increase the overall accuracy of the protocol.\n\n\n**Update**: *Fixed in commit [`6a2b956d6b9df4639358368c93e518ea458f5d68`](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/commit/6a2b956d6b9df4639358368c93e518ea458f5d68). There are no longer any instances of `exchangeRateStored` being used in the revised code. The referenced commit includes other changes to the codebase which have not been reviewed by OpenZeppelin.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/providers/CompoundProvider.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./../external-interfaces/uniswap/IUniswapV2Router.sol\";\nimport \"./../external-interfaces/compound-finance/ICToken.sol\";\nimport \"./../external-interfaces/compound-finance/IComptroller.sol\";\n\nimport \"./../lib/math/MathUtils.sol\";\n\nimport \"./CompoundController.sol\";\nimport \"./../oracle/IYieldOracle.sol\";\nimport \"./../IProvider.sol\";\n\ncontract CompoundProvider is IProvider {\n    using SafeMath for uint256;\n\n    // underlying token (ie. DAI)\n    address public uToken; // IERC20\n\n    // claim token (ie. cDAI)\n    address public cToken;\n\n    // compound.finance Comptroller\n    address public comptroller; // IComptroller\n\n    // deposit reward token (ie. COMP)\n    address public rewardCToken; // IERC20\n\n    // cToken.balanceOf(this) measuring only deposits by users (excludes dirrect cToken transfers to pool)\n    uint256 public cTokenBalance;\n\n    // --- COMP reward checkpoint\n    // saved comptroller.compSupplyState(cToken) value @ the moment the pool harvested\n    uint256 public compSupplierIndexLast;\n\n    // cumulative balanceOf @ last harvest\n    uint256 public cumulativeUnderlyingBalanceHarvestedLast;\n\n    // when we last harvested\n    uint256 public harvestedLast;\n    // --- /COMP reward checkpoint\n\n    bool public _setup;\n\n    modifier accountYield {\n        _accountYieldInternal();\n        IYieldOracle(IController(this.controller()).oracle()).update();\n\n        _;\n\n        underlyingBalanceLast = this.underlyingBalance();\n    }\n\n    function setup(\n        address smartYield_,\n        address controller_,\n        address cToken_\n    )\n      external\n    {\n        require(\n          false == _setup,\n          \"PPC: already setup\"\n        );\n\n        smartYield = smartYield_;\n        controller = controller_;\n        cToken = cToken_;\n        uToken = ICToken(cToken_).underlying();\n        comptroller = ICToken(cToken_).comptroller();\n        rewardCToken = IComptroller(comptroller).getCompAddress();\n\n        _enterMarket();\n\n        _setup = true;\n    }\n\n  // externals\n\n    // take underlyingAmount_ from from_\n    function _takeUnderlying(address from_, uint256 underlyingAmount_)\n      external override\n      onlySmartYield\n    {\n        require(\n            underlyingAmount_ <= IERC20(uToken).allowance(from_, address(this)),\n            \"PPC: _takeUnderlying allowance\"\n        );\n        require(\n            IERC20(uToken).transferFrom(from_, address(this), underlyingAmount_),\n            \"PPC: _takeUnderlying transferFrom\"\n        );\n    }\n\n    // transfer away underlyingAmount_ to to_\n    function _sendUnderlying(address to_, uint256 underlyingAmount_)\n      external override\n      onlySmartYield\n      returns (bool)\n    {\n        return IERC20(uToken).transfer(to_, underlyingAmount_);\n    }\n\n    // deposit underlyingAmount_ with the liquidity provider adds resulting cTokens to cTokenBalance\n    // on the very first call enters the compound.finance market and saves the checkpoint needed for compRewardExpected\n    function _depositProvider(uint256 underlyingAmount_, uint256 takeFees_)\n      external override\n      onlySmartYield\n    {\n        _depositProviderInternal(underlyingAmount_, takeFees_);\n    }\n\n    // withdraw underlyingAmount_ from the liquidity provider, substract the lost cTokens from cTokenBalance\n    function _withdrawProvider(uint256 underlyingAmount_, uint256 takeFees_)\n      external override\n      onlySmartYield\n      accountYield\n    {\n        underlyingFees += takeFees_;\n\n        uint256 cTokensBefore = ICTokenErc20(cToken).balanceOf(address(this));\n        uint256 err = ICToken(cToken).redeemUnderlying(underlyingAmount_);\n        require(0 == err, \"PPC: _withdrawProvider redeemUnderlying\");\n        cTokenBalance -= cTokensBefore - ICTokenErc20(cToken).balanceOf(address(this));\n    }\n\n    // called by anyone to convert pool's COMP -> underlying and then deposit it. caller gets HARVEST_REWARD of the harvest\n    function harvest()\n      external override\n    {\n        require(\n          harvestedLast < this.currentTime(),\n          \"PPC: harvest later\"\n        );\n\n        // this is 0 unless someone transfers underlying to the contract\n        uint256 underlyingBefore = IERC20(uToken).balanceOf(address(this));\n\n        // COMP gets on the pool when:\n        // 1) pool calls comptroller.claimComp()\n        // 2) anyone calls comptroller.claimComp()\n        // 3) anyone transfers COMP to the pool\n        // we want to yield closest to 1+2 but not 3\n        uint256 rewardExpected = compRewardExpected(); // COMP\n\n        address[] memory holders = new address[](1);\n        holders[0] = address(this);\n        address[] memory markets = new address[](1);\n        markets[0] = cToken;\n\n        IComptroller(comptroller).claimComp(holders, markets, false, true);\n\n        _updateCompState();\n\n        uint256 rewardGot = IERC20(rewardCToken).balanceOf(address(this)); // COMP\n\n        if (rewardGot > 0) {\n            address uniswap = CompoundController(controller).uniswap();\n\n            // should be like:\n            // address[] memory path = new address[](3);\n            // path[0] = address(rewardCToken);\n            // path[1] = address(wethToken);\n            // path[2] = address(uToken);\n            address[] memory path = CompoundController(controller).getUniswapPath();\n\n            // TODO: optimize pre-approve uniswap, gas\n            IERC20(rewardCToken).approve(address(uniswap), rewardGot);\n\n            IUniswapV2Router(uniswap).swapExactTokensForTokens(\n                rewardGot,\n                uint256(0),\n                path,\n                address(this),\n                this.currentTime() + 1800\n            );\n        }\n\n        uint256 underlyingGot = IERC20(uToken).balanceOf(address(this));\n\n        if (underlyingGot == 0) {\n          // got no goodies :(\n          return;\n        }\n\n        uint256 extra;\n\n        if (underlyingBefore > 0) {\n          // someone sent us a present as underlying -> add it to the fees\n          extra = underlyingBefore;\n          underlyingGot -= extra;\n        }\n\n        if (rewardGot > rewardExpected) {\n          // moar present as COMP reward -> add it to the fees\n          // throw event\n          uint256 rExtra = MathUtils.fractionOf(underlyingGot, (rewardGot - rewardExpected) * 1e18 / rewardGot);\n          extra += rExtra;\n          underlyingGot -= rExtra;\n        }\n\n        uint256 toCaller = MathUtils.fractionOf(underlyingGot, CompoundController(controller).HARVEST_REWARD());\n\n        // deposit pool reward to compound - harvest reward + any goodies we received\n        // any extra goodies go to fees\n        _depositProviderInternal(underlyingGot - toCaller + extra, extra);\n\n        // pay this man\n        IERC20(uToken).transfer(msg.sender, IERC20(uToken).balanceOf(address(this)));\n    }\n\n    function transferFees()\n      external\n      override\n      accountYield\n    {\n      // cleanup any cTokens dust or cTokens that may have been dumped on the pool\n      if (ICTokenErc20(cToken).balanceOf(address(this)) > cTokenBalance) {\n        underlyingFees += ICToken(cToken).exchangeRateStored() * (ICTokenErc20(cToken).balanceOf(address(this)) - cTokenBalance) / 1e18;\n      }\n      uint256 ctokensToPay = underlyingFees * 1e18 / ICToken(cToken).exchangeRateStored();\n      uint256 err = ICToken(cToken).redeem(\n          MathUtils.min(ctokensToPay, ICTokenErc20(cToken).balanceOf(address(this)))\n      );\n      require(0 == err, \"PPC: transferFees redeem\");\n      underlyingFees = 0;\n      cTokenBalance = ICTokenErc20(cToken).balanceOf(address(this));\n      IERC20(uToken).transfer(IController(controller).feesOwner(), IERC20(uToken).balanceOf(address(this)));\n    }\n\n    // returns cumulatives and accumulates/updates internal state\n    // oracle should call this when updating\n    function cumulatives()\n      external override\n    returns(uint256 cumulativeSecondlyYield, uint256 cumulativeUnderlyingBalance) {\n        _accountYieldInternal();\n        underlyingBalanceLast = this.underlyingBalance();\n        return (cumulativeSecondlyYieldLast, cumulativeUnderlyingBalanceLast);\n    }\n\n    // returns cumulated yield per 1 underlying coin (ie 1 DAI, 1 ETH) times 1e18\n    // per https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/libraries/UniswapV2OracleLibrary.sol#L16\n    function currentCumulatives()\n      external view override\n    returns (uint256 cumulativeSecondlyYield, uint256 cumulativeUnderlyingBalance)\n    {\n        uint32 blockTimestamp = uint32(this.currentTime() % 2**32);\n        cumulativeSecondlyYield = cumulativeSecondlyYieldLast;\n        cumulativeUnderlyingBalance = cumulativeUnderlyingBalanceLast;\n\n        uint32 timeElapsed = blockTimestamp - cumulativeTimestampLast; // overflow is desired\n        if (timeElapsed > 0) {\n            if (underlyingBalanceLast > 0) {\n              // cumulativeSecondlyYield overflows eventually,\n              // due to the way it is used in the oracle that's ok,\n              // as long as it doesn't overflow twice during the windowSize\n              // see OraclelizedMock.cumulativeOverflowProof() for proof\n              cumulativeSecondlyYield +=\n                  // (this.underlyingBalance() - underlyingBalanceLast) * 1e18 -> overflows only if (this.underlyingBalance() - underlyingBalanceLast) >~ 10^41 ETH, DAI, USDC etc\n                  // (this.underlyingBalance() - underlyingBalanceLast) never underflows\n                  ((this.underlyingBalance() - underlyingBalanceLast) * 1e18) / underlyingBalanceLast;\n            }\n            cumulativeUnderlyingBalance += this.underlyingBalance() * timeElapsed;\n        }\n        return (cumulativeSecondlyYield, cumulativeUnderlyingBalance);\n    }\n\n    // current total underlying balance, as measured by pool\n    function underlyingBalance()\n      external view virtual override\n    returns (uint256)\n    {\n        // https://compound.finance/docs#protocol-math\n        return\n            cTokenBalance * ICToken(cToken).exchangeRateStored() / 1e18;\n    }\n\n  // /externals\n\n    function currentTime()\n      public view virtual override\n      returns (uint256)\n    {\n        // mockable\n        return block.timestamp;\n    }\n\n    // computes how much COMP tokens compound.finance will give us at comptroller.claimComp()\n    // note: have to do it because comptroller.claimComp() is callable by anyone\n    // source: https://github.com/compound-finance/compound-protocol/blob/master/contracts/Comptroller.sol#L1145\n    function compRewardExpected()\n      public view virtual\n      returns (uint256)\n    {\n        (uint224 supplyStateIndex, ) = IComptroller(comptroller).compSupplyState(cToken);\n        uint256 supplyIndex = uint256(supplyStateIndex);\n        uint256 supplierIndex = compSupplierIndexLast;\n\n        uint256 deltaIndex = (supplyIndex).sub(supplierIndex); // a - b\n        (, uint256 cumulativeUnderlyingBalanceNow) = this.currentCumulatives();\n        uint256 timeElapsed = this.currentTime() - harvestedLast; // harvest() has require\n\n        uint256 waUnderlyingTotal = ((cumulativeUnderlyingBalanceNow - cumulativeUnderlyingBalanceHarvestedLast) * 1e18 / timeElapsed);\n        // uint256 supplierTokens = ICTokenErc20(cToken).balanceOf(address(this))\n        uint256 supplierTokens = waUnderlyingTotal / ICToken(cToken).exchangeRateStored();\n        return (supplierTokens).mul(deltaIndex).div(1e36); // a * b / doubleScale => uint\n    }\n\n  // internals\n\n    function _depositProviderInternal(uint256 underlyingAmount_, uint256 takeFees_)\n      internal\n      accountYield\n    {\n        if (0 == cTokenBalance && 0 == compSupplierIndexLast) {\n          // this will be called once only for the first comp deposit after pool deploy\n          _updateCompState();\n        }\n        underlyingFees += takeFees_;\n\n        uint256 cTokensBefore = ICTokenErc20(cToken).balanceOf(address(this));\n        // TODO: optimization, pre-approve provider: gas\n        IERC20(uToken).approve(address(cToken), underlyingAmount_);\n        uint256 err = ICToken(cToken).mint(underlyingAmount_);\n        require(0 == err, \"PPC: _depositProvider mint\");\n        cTokenBalance += ICTokenErc20(cToken).balanceOf(address(this)) - cTokensBefore;\n    }\n\n    function _accountYieldInternal()\n      internal\n    {\n        uint32 blockTimestamp = uint32(this.currentTime() % 2**32);\n        uint32 timeElapsed = blockTimestamp - cumulativeTimestampLast; // overflow is desired\n        // only for the first time in the block\n        if (timeElapsed > 0) {\n            // if there's underlying\n            if (underlyingBalanceLast > 0) {\n              // cumulativeSecondlyYieldLast overflows eventually,\n              // due to the way it is used in the oracle that's ok,\n              // as long as it doesn't overflow twice during the windowSize\n              // see OraclelizedMock.cumulativeOverflowProof() for proof\n              cumulativeSecondlyYieldLast +=\n                  // (this.underlyingBalance() - underlyingBalanceLast) * 1e18 -> overflows only if (this.underlyingBalance() - underlyingBalanceLast) >~ 10^41 ETH, DAI, USDC etc\n                  // (this.underlyingBalance() - underlyingBalanceLast) never underflows\n                  ((this.underlyingBalance() - underlyingBalanceLast) * 1e18) / underlyingBalanceLast;\n            }\n\n            cumulativeUnderlyingBalanceLast += this.underlyingBalance() * timeElapsed;\n\n            cumulativeTimestampLast = blockTimestamp;\n        }\n    }\n\n    // call comptroller.enterMarkets()\n    // needs to be called only once BUT before any interactions with the provider\n    function _enterMarket()\n      internal\n    {\n        address[] memory markets = new address[](1);\n        markets[0] = cToken;\n        uint256[] memory err = IComptroller(comptroller).enterMarkets(markets);\n        require(err[0] == 0, \"PPC: _enterMarket\");\n    }\n\n\n    // creates checkpoint items needed to compute compRewardExpected()\n    // needs to be called right after each claimComp(), and just before the first ever deposit\n    function _updateCompState()\n      internal\n    {\n        (uint224 supplyStateIndex, ) = IComptroller(comptroller).compSupplyState(cToken);\n        compSupplierIndexLast = uint256(supplyStateIndex);\n        (, cumulativeUnderlyingBalanceHarvestedLast) = this.currentCumulatives();\n        harvestedLast = this.currentTime();\n    }\n\n    // /internals\n\n}"
    },
    {
      "filename": "contracts/CToken.sol",
      "content": "pragma solidity ^0.5.16;\n\nimport \"./ComptrollerInterface.sol\";\nimport \"./CTokenInterfaces.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./Exponential.sol\";\nimport \"./EIP20Interface.sol\";\nimport \"./EIP20NonStandardInterface.sol\";\nimport \"./InterestRateModel.sol\";\n\n/**\n * @title Compound's CToken Contract\n * @notice Abstract base for CTokens\n * @author Compound\n */\ncontract CToken is CTokenInterface, Exponential, TokenErrorReporter {\n    /**\n     * @notice Initialize the money market\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ EIP-20 name of this token\n     * @param symbol_ EIP-20 symbol of this token\n     * @param decimals_ EIP-20 decimal precision of this token\n     */\n    function initialize(ComptrollerInterface comptroller_,\n                        InterestRateModel interestRateModel_,\n                        uint initialExchangeRateMantissa_,\n                        string memory name_,\n                        string memory symbol_,\n                        uint8 decimals_) public {\n        require(msg.sender == admin, \"only admin may initialize the market\");\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n        // Set the comptroller\n        uint err = _setComptroller(comptroller_);\n        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = mantissaOne;\n\n        // Set the interest rate model (depends on block number / borrow index)\n        err = _setInterestRateModelFresh(interestRateModel_);\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n        _notEntered = true;\n    }\n\n    /**\n     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n     * @dev Called by both `transfer` and `transferFrom` internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n        /* Fail if transfer not allowed */\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Do not allow self-transfers */\n        if (src == dst) {\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        /* Get the allowance, infinite for the account owner */\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = uint(-1);\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        /* Do the calculations, checking for {under,over}flow */\n        MathError mathErr;\n        uint allowanceNew;\n        uint srcTokensNew;\n        uint dstTokensNew;\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n        }\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        accountTokens[src] = srcTokensNew;\n        accountTokens[dst] = dstTokensNew;\n\n        /* Eat some of the allowance (if necessary) */\n        if (startingAllowance != uint(-1)) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n\n        /* We emit a Transfer event */\n        emit Transfer(src, dst, tokens);\n\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {\n        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {\n        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) external returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (-1 means infinite)\n     */\n    function allowance(address owner, address spender) external view returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n\n    /**\n     * @notice Get the token balance of the `owner`\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by `owner`\n     */\n    function balanceOf(address owner) external view returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by `owner`\n     */\n    function balanceOfUnderlying(address owner) external returns (uint) {\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n        require(mErr == MathError.NO_ERROR, \"balance could not be calculated\");\n        return balance;\n    }\n\n    /**\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n     */\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n        uint cTokenBalance = accountTokens[account];\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n\n        MathError mErr;\n\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n        if (mErr != MathError.NO_ERROR) {\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (mErr != MathError.NO_ERROR) {\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);\n    }\n\n    /**\n     * @dev Function to simply retrieve block number\n     *  This exists mainly for inheriting test contracts to stub this result.\n     */\n    function getBlockNumber() internal view returns (uint) {\n        return block.number;\n    }\n\n    /**\n     * @notice Returns the current per-block borrow interest rate for this cToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() external view returns (uint) {\n        return interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n    }\n\n    /**\n     * @notice Returns the current per-block supply interest rate for this cToken\n     * @return The supply interest rate per block, scaled by 1e18\n     */\n    function supplyRatePerBlock() external view returns (uint) {\n        return interestRateModel.getSupplyRate(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\n    }\n\n    /**\n     * @notice Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     */\n    function totalBorrowsCurrent() external nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n        return totalBorrows;\n    }\n\n    /**\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n        return borrowBalanceStored(account);\n    }\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return The calculated balance\n     */\n    function borrowBalanceStored(address account) public view returns (uint) {\n        (MathError err, uint result) = borrowBalanceStoredInternal(account);\n        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n        return result;\n    }\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\n     */\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n        /* Note: we do not assert that the market is up to date */\n        MathError mathErr;\n        uint principalTimesIndex;\n        uint result;\n\n        /* Get borrowBalance and borrowIndex */\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         */\n        if (borrowSnapshot.principal == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        /* Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         */\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        return (MathError.NO_ERROR, result);\n    }\n\n    /**\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() public nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n        return exchangeRateStored();\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() public view returns (uint) {\n        (MathError err, uint result) = exchangeRateStoredInternal();\n        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n        return result;\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return (error code, calculated exchange rate scaled by 1e18)\n     */\n    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n        uint _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            /*\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             */\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\n        } else {\n            /*\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             */\n            uint totalCash = getCashPrior();\n            uint cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n            MathError mathErr;\n\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\n        }\n    }\n\n    /**\n     * @notice Get cash balance of this cToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n    function getCash() external view returns (uint) {\n        return getCashPrior();\n    }\n\n    /**\n     * @notice Applies accrued interest to total borrows and reserves\n     * @dev This calculates interest accrued from the last checkpointed block\n     *   up to the current block and writes new checkpoint to storage.\n     */\n    function accrueInterest() public returns (uint) {\n        /* Remember the initial block number */\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return uint(Error.NO_ERROR);\n        }\n\n        /* Read the previous values out of storage */\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint reservesPrior = totalReserves;\n        uint borrowIndexPrior = borrowIndex;\n\n        /* Calculate the current borrow interest rate */\n        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        require(mathErr == MathError.NO_ERROR, \"could not calculate block delta\");\n\n        /*\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         */\n\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n        uint totalReservesNew;\n        uint borrowIndexNew;\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa: borrowRateMantissa}), blockDelta);\n        if (mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(mathErr));\n        }\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        if (mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(mathErr));\n        }\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        if (mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(mathErr));\n        }\n\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa"
    }
  ]
}