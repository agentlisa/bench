{
  "Title": "Consolidate unnecessary code duplication in `ConvertFacet::_withdrawTokens`",
  "Content": "`ConvertFacet::_withdrawTokens` duplicates the following code in [L119-132](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/beanstalk/silo/ConvertFacet.sol#L119-L132) then again in [L137-151](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/beanstalk/silo/ConvertFacet.sol#L137-L151):\n\n```solidity\nif (a.tokensRemoved.add(amounts[i]) < maxTokens) {\n    //keeping track of stalk removed must happen before we actually remove the deposit\n    //this is because LibTokenSilo.grownStalkForDeposit() uses the current deposit info\n    // @audit start duplicated code\n    depositBDV = LibTokenSilo.removeDepositFromAccount(\n        msg.sender,\n        token,\n        stems[i],\n        amounts[i]\n    );\n    bdvsRemoved[i] = depositBDV;\n    a.stalkRemoved = a.stalkRemoved.add(\n        LibSilo.stalkReward(\n            stems[i],\n            LibTokenSilo.stemTipForToken(token),\n            depositBDV.toUint128()\n        )\n    );\n    // @audit end duplicated code\n\n} else {\n    amounts[i] = maxTokens.sub(a.tokensRemoved);\n\n    // @audit start duplicated code\n    depositBDV = LibTokenSilo.removeDepositFromAccount(\n        msg.sender,\n        token,\n        stems[i],\n        amounts[i]\n    );\n\n    bdvsRemoved[i] = depositBDV;\n    a.stalkRemoved = a.stalkRemoved.add(\n        LibSilo.stalkReward(\n            stems[i],\n        LibTokenSilo.stemTipForToken(token),\n            depositBDV.toUint128()\n        )\n    );\n    // @audit end duplicated code\n}\n```\n\nConsider refactoring to remove the duplicated code by changing the `if` condition to only update `amounts[i]` when required then perform the same processing that is currently on each `if/else` branch:\n\n```solidity\nwhile ((i < stems.length) && (a.tokensRemoved < maxTokens)) {\n    if (a.tokensRemoved.add(amounts[i]) >= maxTokens) {\n        amounts[i] = maxTokens.sub(a.tokensRemoved);\n    }\n\n    //keeping track of stalk removed must happen before we actually remove the deposit\n    //this is because LibTokenSilo.grownStalkForDeposit() uses the current deposit info\n    depositBDV = LibTokenSilo.removeDepositFromAccount(\n        msg.sender,\n        token,\n        stems[i],\n        amounts[i]\n    );\n    bdvsRemoved[i] = depositBDV;\n    a.stalkRemoved = a.stalkRemoved.add(\n        LibSilo.stalkReward(\n            stems[i],\n            LibTokenSilo.stemTipForToken(token),\n            depositBDV.toUint128()\n        )\n    );\n\n    a.tokensRemoved = a.tokensRemoved.add(amounts[i]);\n    a.bdvRemoved = a.bdvRemoved.add(depositBDV);\n\n    depositIds[i] = uint256(LibBytes.packAddressAndStem(token, stems[i]));\n    i++;\n}\n```\n\n\n\\clearpage",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/beanstalk/silo/ConvertFacet.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {C} from \"contracts/C.sol\";\nimport {LibSilo} from \"contracts/libraries/Silo/LibSilo.sol\";\nimport {LibTokenSilo} from \"contracts/libraries/Silo/LibTokenSilo.sol\";\nimport {LibSafeMath32} from \"contracts/libraries/LibSafeMath32.sol\";\nimport {ReentrancyGuard} from \"../ReentrancyGuard.sol\";\nimport {LibBytes} from \"contracts/libraries/LibBytes.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {LibConvert} from \"contracts/libraries/Convert/LibConvert.sol\";\n\n/**\n * @author Publius, Brean, DeadManWalking\n * @title ConvertFacet handles converting Deposited assets within the Silo.\n **/\ncontract ConvertFacet is ReentrancyGuard {\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n    using LibSafeMath32 for uint32;\n\n    event Convert(\n        address indexed account,\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        uint256 toAmount\n    );\n\n    event RemoveDeposit(\n        address indexed account,\n        address indexed token,\n        int96 stem,\n        uint256 amount,\n        uint256 bdv\n    );\n\n    event RemoveDeposits(\n        address indexed account,\n        address indexed token,\n        int96[] stems,\n        uint256[] amounts,\n        uint256 amount,\n        uint256[] bdvs\n    );\n\n    /**\n     * @notice convert allows a user to convert a deposit to another deposit,\n     * given that the conversion is supported by the ConvertFacet.\n     * For example, a user can convert LP into Bean, only when beanstalk is below peg, \n     * or convert beans into LP, only when beanstalk is above peg.\n     * @param convertData  input parameters to determine the conversion type.\n     * @param stems the stems of the deposits to convert \n     * @param amounts the amounts within each deposit to convert\n     * @return toStem the new stems of the converted deposit\n     * @return fromAmount the amount of tokens converted from\n     * @return toAmount the amount of tokens converted to\n     * @return fromBdv the bdv of the deposits converted from\n     * @return toBdv the bdv of the deposit converted to\n     */\n    function convert(\n        bytes calldata convertData,\n        int96[] memory stems,\n        uint256[] memory amounts\n    )\n        external\n        payable\n        nonReentrant\n        returns (int96 toStem, uint256 fromAmount, uint256 toAmount, uint256 fromBdv, uint256 toBdv)\n    {\n        address toToken; address fromToken; uint256 grownStalk;\n        (toToken, fromToken, toAmount, fromAmount) = LibConvert.convert(convertData);\n\n        LibSilo._mow(msg.sender, fromToken);\n        LibSilo._mow(msg.sender, toToken);\n\n        (grownStalk, fromBdv) = _withdrawTokens(\n            fromToken,\n            stems,\n            amounts,\n            fromAmount\n        );\n\n        uint256 newBdv = LibTokenSilo.beanDenominatedValue(toToken, toAmount);\n        toBdv = newBdv > fromBdv ? newBdv : fromBdv;\n\n        toStem = _depositTokensForConvert(toToken, toAmount, toBdv, grownStalk);\n\n        emit Convert(msg.sender, fromToken, toToken, fromAmount, toAmount);\n    }\n\n    function _withdrawTokens(\n        address token,\n        int96[] memory stems,\n        uint256[] memory amounts,\n        uint256 maxTokens\n    ) internal returns (uint256, uint256) {\n        require(\n            stems.length == amounts.length,\n            \"Convert: stems, amounts are diff lengths.\"\n        );\n        LibSilo.AssetsRemoved memory a;\n        uint256 depositBDV;\n        uint256 i = 0;\n        // a bracket is included here to avoid the \"stack too deep\" error.\n        {\n            uint256[] memory bdvsRemoved = new uint256[](stems.length);\n            uint256[] memory depositIds = new uint256[](stems.length);\n            while ((i < stems.length) && (a.tokensRemoved < maxTokens)) {\n                if (a.tokensRemoved.add(amounts[i]) < maxTokens) {\n                    //keeping track of stalk removed must happen before we actually remove the deposit\n                    //this is because LibTokenSilo.grownStalkForDeposit() uses the current deposit info\n                    depositBDV = LibTokenSilo.removeDepositFromAccount(\n                        msg.sender,\n                        token,\n                        stems[i],\n                        amounts[i]\n                    );\n                    bdvsRemoved[i] = depositBDV;\n                    a.stalkRemoved = a.stalkRemoved.add(\n                        LibSilo.stalkReward(\n                            stems[i],\n                            LibTokenSilo.stemTipForToken(token),\n                            depositBDV.toUint128()\n                        )\n                    );\n                    \n                } else {\n                    amounts[i] = maxTokens.sub(a.tokensRemoved);\n                    \n                    depositBDV = LibTokenSilo.removeDepositFromAccount(\n                        msg.sender,\n                        token,\n                        stems[i],\n                        amounts[i]\n                    );\n\n                    bdvsRemoved[i] = depositBDV;\n                    a.stalkRemoved = a.stalkRemoved.add(\n                        LibSilo.stalkReward(\n                            stems[i],\n                        LibTokenSilo.stemTipForToken(token),\n                            depositBDV.toUint128()\n                        )\n                    );\n                    \n                }\n                \n                a.tokensRemoved = a.tokensRemoved.add(amounts[i]);\n                a.bdvRemoved = a.bdvRemoved.add(depositBDV);\n                \n                depositIds[i] = uint256(LibBytes.packAddressAndStem(\n                    token,\n                    stems[i]\n                ));\n                i++;\n            }\n            for (i; i < stems.length; ++i) amounts[i] = 0;\n            \n            emit RemoveDeposits(\n                msg.sender,\n                token,\n                stems,\n                amounts,\n                a.tokensRemoved,\n                bdvsRemoved\n            );\n\n            emit LibSilo.TransferBatch(\n                msg.sender, \n                msg.sender,\n                address(0), \n                depositIds, \n                amounts\n            );\n        }\n\n        require(\n            a.tokensRemoved == maxTokens,\n            \"Convert: Not enough tokens removed.\"\n        );\n        LibTokenSilo.decrementTotalDeposited(token, a.tokensRemoved, a.bdvRemoved);\n        LibSilo.burnStalk(\n            msg.sender,\n            a.stalkRemoved.add(a.bdvRemoved.mul(s.ss[token].stalkIssuedPerBdv))\n        );\n        return (a.stalkRemoved, a.bdvRemoved);\n    }\n\n    //this is only used internal to the convert facet\n    function _depositTokensForConvert(\n        address token,\n        uint256 amount,\n        uint256 bdv,\n        uint256 grownStalk // stalk grown previously by this deposit\n    ) internal returns (int96 stem) {\n        require(bdv > 0 && amount > 0, \"Convert: BDV or amount is 0.\");\n\n        //calculate stem index we need to deposit at from grownStalk and bdv\n        //if we attempt to deposit at a half-season (a grown stalk index that would fall between seasons)\n        //then in affect we lose that partial season's worth of stalk when we deposit\n        //so here we need to update grownStalk to be the amount you'd have with the above deposit\n        \n        /// @dev the two functions were combined into one function to save gas.\n        // _stemTip = LibTokenSilo.grownStalkAndBdvToStem(IERC20(token), grownStalk, bdv);\n        // grownStalk = uint256(LibTokenSilo.calculateStalkFromStemAndBdv(IERC20(token), _stemTip, bdv));\n\n        (grownStalk, stem) = LibTokenSilo.calculateGrownStalkAndStem(token, grownStalk, bdv);\n\n        LibSilo.mintStalk(msg.sender, bdv.mul(LibTokenSilo.stalkIssuedPerBdv(token)).add(grownStalk));\n\n        LibTokenSilo.incrementTotalDeposited(token, amount, bdv);\n        LibTokenSilo.addDepositToAccount(\n            msg.sender, \n            token, \n            stem, \n            amount, \n            bdv,\n            LibTokenSilo.Transfer.emitTransferSingle\n        );\n    }\n}"
    }
  ]
}