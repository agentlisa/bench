{
  "Title": "[H-02] An attacker is able to hijack any ERC721 / ERC1155 he borrows because guard is missing validation on the address supplied to function call `setFallbackHandler()`",
  "Content": "\n### Pre-requisite knowledge & an overview of the features in question\n\n***\n\n1.  **Gnosis safe fallback handlers**: Safes starting with version 1.1.1 allow to specify a fallback handler. A gnosis safe fallback handler is a contract which handles all functions that is unknown to the safe, this feature is meant to provide a great flexibility for the safe user. The safe in particular says \"If I see something unknown, then I just let the fallback handler deal with it.\"\n\n    **Example**: If you want to take a uniswap flash loan using your gnosis safe, you'll have to create a fallback handler contract with the callback function `uniswapV2Call()`. When you decide to take a flash loan using your safe, you'll send a call to `swap()` in the uniswap contract. The uniswap contract will then reach out to your safe contract asking to call `uniswapV2Call()`, but `uniswapV2Call()` isn't actually implemented in the safe contract itself, so your safe will reach out to the fallback handler you created, set as the safe's fallback handler and ask it to handle the `uniswapV2Call()` TX coming from uniswap.\n\n    **Setting a fallback handler**: To set a fallback handler for your safe, you'll have to call the function [`setFallbackHandler()`](https://github.com/safe-global/safe-contracts/blob/b140318af6581e499506b11128a892e3f7a52aeb/contracts/base/FallbackManager.sol#L44) which you can find it's logic in [FallbackManager.sol](https://github.com/safe-global/safe-contracts/blob/main/contracts/base/FallbackManager.sol)\n\n2.  **Gnosis safe guards**: A gnosis guard is a contract that acts as a transaction guard which allows the owner of the safe to limit the contracts and functions that may be called by the multisig owners of the safe. ReNFT has created it's own gnosis guard contract, which is [Guard.sol](https://github.com/re-nft/smart-contracts/blob/main/src/policies/Guard.sol).\n\n    **Example utility**: When you ask reNFT to create a rental safe for you by calling [deployRentalSafe()](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L138) in [Factory.sol](https://github.com/re-nft/smart-contracts/blob/main/src/policies/Factory.sol), reNFT creates a rental safe for you and automatically installs it's own guard contract on it. Everytime you send a call from your gnosis safe, this call has to first pass through that guard. If you're for example, trying to move a NFT token you rented using `transferFrom()`, it'll prevent you from doing so. When it intercepts the transaction you're trying to send, it checks for a [list of function signatures](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L195) that can be malicious, for example it checks if you're trying to enable/disable a module it has not authorized. It checks if you're trying to change the guard contract address itself, It also checks if you're trying to transfer or approve a rented NFT or ERC1155 token using the most common functions like `approve()`, `safeTransferFrom()`, `transferFrom()`, `setApprovalForAll()`. This guard acts as the single and most important defense line against rented ERC721/1155 token theft.\n\n***\n\n### The Vulnerability & Exploitation Steps\n\n***\n\nWhile the gnosis guard checks for a comprehensive list of potentially malicious function calls, it doesn't have any validation or checks for the `address` parameter of the function `setFallbackHandler(address handler)`, which is the function used by the rental safe owner to set a fallback handler his safe. This is super dangerous because it allows an attacker to hijack ANY ERC721 or ERC1155 token he rents by following these steps:\n\n1.  Sets the fallback handler address of the safe to be the address of the token he rented which he wants to hijack, let's say it's an ERC721 token.\n\n2.  Sends a `transferFrom(from, to, tokenId)` call to the gnosis safe contract while supplying the following parameters:\n    1.  `from` -> the address of the rental safe holding the token.\n    2.  `to` -> the address of the attacker himself.\n    3.  `tokenId` -> the ID of the token he wants to hijack.\n\n3.  The gnosis safe contract doesn't have the function `transferFrom()` implemented, so it'll [reach out and send a call to](https://github.com/safe-global/safe-contracts/blob/b140318af6581e499506b11128a892e3f7a52aeb/contracts/base/FallbackManager.sol#L78) the fallback handler address which is the address of the rented token contract and forward the calldata gnosis received from the attacker's call to the rented token contract.\n\n4.  Since it's the gnosis rental safe talking to the the rented token contract, and since the rental safe is the owner of the NFT, the ERC721 rented token contract will happily make the transfer and send the token to the attacker.\n\n5.  Token is hijacked, and the lender of the token won't be able to get it back or get the funds he's supposed to receive from the rental process.\n\n***\n\n### Proof of concept\n\n***\n\nTo run the PoC, you'll need to do the following:\n\n1.  You'll need to add the following two files to the test/ folder:\n    1.  `SetupExploit.sol` -> Sets up everything from seaport, gnosis, reNFT contracts\n    2.  `Exploit.sol` -> The actual exploit PoC which relies on `SetupExploit.sol` as a base.\n2.  You'll need to run this command\n    `forge test --match-contract Exploit --match-test test_ERC721_1155_Exploit -vvv`\n\n*Note: All of my 7 PoCs throughout my reports include the `SetupExploit.sol`. Please do not rely on the previous `SetupExploit.sol` file if you already had one in the tests/ folder. In some PoCs, there are slight modifications done in that file to properly set up the test infrastructure for the exploit*\n\n**The files:**\n\n<details>\n<summary><b>SetupExploit.sol</b></summary>\n<br>\n\n    // SPDX-License-Identifier: BUSL-1.1\n    pragma solidity ^0.8.20;\n\n    import {\n        ConsiderationItem,\n        OfferItem,\n        OrderParameters,\n        OrderComponents,\n        Order,\n        AdvancedOrder,\n        ItemType,\n        ItemType as SeaportItemType,\n        CriteriaResolver,\n        OrderType as SeaportOrderType,\n        Fulfillment,\n        FulfillmentComponent\n    } from \"@seaport-types/lib/ConsiderationStructs.sol\";\n    import {\n        AdvancedOrderLib,\n        ConsiderationItemLib,\n        FulfillmentComponentLib,\n        FulfillmentLib,\n        OfferItemLib,\n        OrderComponentsLib,\n        OrderLib,\n        OrderParametersLib,\n        SeaportArrays,\n        ZoneParametersLib\n    } from \"@seaport-sol/SeaportSol.sol\";\n\n    import {\n        OrderMetadata,\n        OrderType,\n        OrderFulfillment,\n        RentPayload,\n        RentalOrder,\n        Item,\n        SettleTo,\n        ItemType as RentalItemType\n    } from \"@src/libraries/RentalStructs.sol\";\n\n    import {ECDSA} from \"@openzeppelin-contracts/utils/cryptography/ECDSA.sol\";\n    import {OrderMetadata, OrderType, Hook} from \"@src/libraries/RentalStructs.sol\";\n    import {Vm} from \"@forge-std/Vm.sol\";\n    import {Assertions} from \"@test/utils/Assertions.sol\";\n    import {Constants} from \"@test/utils/Constants.sol\";\n    import {LibString} from \"@solady/utils/LibString.sol\";\n    import {SafeL2} from \"@safe-contracts/SafeL2.sol\";\n    import {BaseExternal} from \"@test/fixtures/external/BaseExternal.sol\";\n    import {Create2Deployer} from \"@src/Create2Deployer.sol\";\n    import {Kernel, Actions} from \"@src/Kernel.sol\";\n    import {Storage} from \"@src/modules/Storage.sol\";\n    import {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\";\n    import {Create} from \"@src/policies/Create.sol\";\n    import {Stop} from \"@src/policies/Stop.sol\";\n    import {Factory} from \"@src/policies/Factory.sol\";\n    import {Admin} from \"@src/policies/Admin.sol\";\n    import {Guard} from \"@src/policies/Guard.sol\";\n    import {toRole} from \"@src/libraries/KernelUtils.sol\";\n    import {Proxy} from \"@src/proxy/Proxy.sol\";\n    import {Events} from \"@src/libraries/Events.sol\";\n\n    import {ProtocolAccount} from \"@test/utils/Types.sol\";\n    import {MockERC20} from \"@test/mocks/tokens/standard/MockERC20.sol\";\n    import {MockERC721} from \"@test/mocks/tokens/standard/MockERC721.sol\";\n    import {MockERC1155} from \"@test/mocks/tokens/standard/MockERC1155.sol\";\n    import {SafeUtils} from \"@test/utils/GnosisSafeUtils.sol\";\n    import {Enum} from \"@safe-contracts/common/Enum.sol\";\n    import {ISafe} from \"@src/interfaces/ISafe.sol\";\n\n\n    // Deploys all V3 protocol contracts\n    contract Protocol is BaseExternal {\n        // Kernel\n        Kernel public kernel;\n\n        // Modules\n        Storage public STORE;\n        PaymentEscrow public ESCRW;\n\n        // Module implementation addresses\n        Storage public storageImplementation;\n        PaymentEscrow public paymentEscrowImplementation;\n\n        // Policies\n        Create public create;\n        Stop public stop;\n        Factory public factory;\n        Admin public admin;\n        Guard public guard;\n\n        // Protocol accounts\n        Vm.Wallet public rentalSigner;\n        Vm.Wallet public deployer;\n\n        // protocol constants\n        bytes12 public protocolVersion;\n        bytes32 public salt;\n\n        function _deployKernel() internal {\n            // abi encode the kernel bytecode and constructor arguments\n            bytes memory kernelInitCode = abi.encodePacked(\n                type(Kernel).creationCode,\n                abi.encode(deployer.addr, deployer.addr)\n            );\n\n            // Deploy kernel contract\n            vm.prank(deployer.addr);\n            kernel = Kernel(create2Deployer.deploy(salt, kernelInitCode));\n\n            // label the contract\n            vm.label(address(kernel), \"kernel\");\n        }\n\n        function _deployStorageModule() internal {\n            // abi encode the storage bytecode and constructor arguments\n            // for the implementation contract\n            bytes memory storageImplementationInitCode = abi.encodePacked(\n                type(Storage).creationCode,\n                abi.encode(address(0))\n            );\n\n            // Deploy storage implementation contract\n            vm.prank(deployer.addr);\n            storageImplementation = Storage(\n                create2Deployer.deploy(salt, storageImplementationInitCode)\n            );\n\n            // abi encode the storage bytecode and initialization arguments\n            // for the proxy contract\n            bytes memory storageProxyInitCode = abi.encodePacked(\n                type(Proxy).creationCode,\n                abi.encode(\n                    address(storageImplementation),\n                    abi.encodeWithSelector(\n                        Storage.MODULE_PROXY_INSTANTIATION.selector,\n                        address(kernel)\n                    )\n                )\n            );\n\n            // Deploy storage proxy contract\n            vm.prank(deployer.addr);\n            STORE = Storage(create2Deployer.deploy(salt, storageProxyInitCode));\n\n            // label the contracts\n            vm.label(address(STORE), \"STORE\");\n            vm.label(address(storageImplementation), \"STORE_IMPLEMENTATION\");\n        }\n\n        function _deployPaymentEscrowModule() internal {\n            // abi encode the payment escrow bytecode and constructor arguments\n            // for the implementation contract\n            bytes memory paymentEscrowImplementationInitCode = abi.encodePacked(\n                type(PaymentEscrow).creationCode,\n                abi.encode(address(0))\n            );\n\n            // Deploy payment escrow implementation contract\n            vm.prank(deployer.addr);\n            paymentEscrowImplementation = PaymentEscrow(\n                create2Deployer.deploy(salt, paymentEscrowImplementationInitCode)\n            );\n\n            // abi encode the payment escrow bytecode and initialization arguments\n            // for the proxy contract\n            bytes memory paymentEscrowProxyInitCode = abi.encodePacked(\n                type(Proxy).creationCode,\n                abi.encode(\n                    address(paymentEscrowImplementation),\n                    abi.encodeWithSelector(\n                        PaymentEscrow.MODULE_PROXY_INSTANTIATION.selector,\n                        address(kernel)\n                    )\n                )\n            );\n\n            // Deploy payment escrow contract\n            vm.prank(deployer.addr);\n            ESCRW = PaymentEscrow(create2Deployer.deploy(salt, paymentEscrowProxyInitCode));\n\n            // label the contracts\n            vm.label(address(ESCRW), \"ESCRW\");\n            vm.label(address(paymentEscrowImplementation), \"ESCRW_IMPLEMENTATION\");\n        }\n\n        function _deployCreatePolicy() internal {\n            // abi encode the create policy bytecode and constructor arguments\n            bytes memory createInitCode = abi.encodePacked(\n                type(Create).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy create rental policy contract\n            vm.prank(deployer.addr);\n            create = Create(create2Deployer.deploy(salt, createInitCode));\n\n            // label the contract\n            vm.label(address(create), \"CreatePolicy\");\n        }\n\n        function _deployStopPolicy() internal {\n            // abi encode the stop policy bytecode and constructor arguments\n            bytes memory stopInitCode = abi.encodePacked(\n                type(Stop).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy stop rental policy contract\n            vm.prank(deployer.addr);\n            stop = Stop(create2Deployer.deploy(salt, stopInitCode));\n\n            // label the contract\n            vm.label(address(stop), \"StopPolicy\");\n        }\n\n        function _deployAdminPolicy() internal {\n            // abi encode the admin policy bytecode and constructor arguments\n            bytes memory adminInitCode = abi.encodePacked(\n                type(Admin).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy admin policy contract\n            vm.prank(deployer.addr);\n            admin = Admin(create2Deployer.deploy(salt, adminInitCode));\n\n            // label the contract\n            vm.label(address(admin), \"AdminPolicy\");\n        }\n\n        function _deployGuardPolicy() internal {\n            // abi encode the guard policy bytecode and constructor arguments\n            bytes memory guardInitCode = abi.encodePacked(\n                type(Guard).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy guard policy contract\n            vm.prank(deployer.addr);\n            guard = Guard(create2Deployer.deploy(salt, guardInitCode));\n\n            // label the contract\n            vm.label(address(guard), \"GuardPolicy\");\n        }\n\n        function _deployFactoryPolicy() internal {\n            // abi encode the factory policy bytecode and constructor arguments\n            bytes memory factoryInitCode = abi.encodePacked(\n                type(Factory).creationCode,\n                abi.encode(\n                    address(kernel),\n                    address(stop),\n                    address(guard),\n                    address(tokenCallbackHandler),\n                    address(safeProxyFactory),\n                    address(safeSingleton)\n                )\n            );\n\n            // Deploy factory policy contract\n            vm.prank(deployer.addr);\n            factory = Factory(create2Deployer.deploy(salt, factoryInitCode));\n\n            // label the contract\n            vm.label(address(factory), \"FactoryPolicy\");\n        }\n\n        function _setupKernel() internal {\n            // Start impersonating the deployer\n            vm.startPrank(deployer.addr);\n\n            // Install modules\n            kernel.executeAction(Actions.InstallModule, address(STORE));\n            kernel.executeAction(Actions.InstallModule, address(ESCRW));\n\n            // Approve policies\n            kernel.executeAction(Actions.ActivatePolicy, address(create));\n            kernel.executeAction(Actions.ActivatePolicy, address(stop));\n            kernel.executeAction(Actions.ActivatePolicy, address(factory));\n            kernel.executeAction(Actions.ActivatePolicy, address(guard));\n            kernel.executeAction(Actions.ActivatePolicy, address(admin));\n\n            // Grant `seaport` role to seaport protocol\n            kernel.grantRole(toRole(\"SEAPORT\"), address(seaport));\n\n            // Grant `signer` role to the protocol signer to sign off on create payloads\n            kernel.grantRole(toRole(\"CREATE_SIGNER\"), rentalSigner.addr);\n\n            // Grant 'admin_admin` role to the address which can conduct admin operations on the protocol\n            kernel.grantRole(toRole(\"ADMIN_ADMIN\"), deployer.addr);\n\n            // Grant 'guard_admin` role to the address which can toggle hooks\n            kernel.grantRole(toRole(\"GUARD_ADMIN\"), deployer.addr);\n\n            // Grant `stop_admin` role to the address which can skim funds from the payment escrow\n            kernel.grantRole(toRole(\"STOP_ADMIN\"), deployer.addr);\n\n            // Stop impersonating the deployer\n            vm.stopPrank();\n        }\n\n        function setUp() public virtual override {\n            // setup dependencies\n            super.setUp();\n\n            // create the rental signer address and private key\n            rentalSigner = vm.createWallet(\"rentalSigner\");\n\n            // create the deployer address and private key\n            deployer = vm.createWallet(\"deployer\");\n\n            // contract salts (using 0x000000000000000000000100 to represent a version 1.0.0 of each contract)\n            protocolVersion = 0x000000000000000000000100;\n            salt = create2Deployer.generateSaltWithSender(deployer.addr, protocolVersion);\n\n            // deploy kernel\n            _deployKernel();\n\n            // Deploy payment escrow\n            _deployPaymentEscrowModule();\n\n            // Deploy rental storage\n            _deployStorageModule();\n\n            // deploy create policy\n            _deployCreatePolicy();\n\n            // deploy stop policy\n            _deployStopPolicy();\n\n            // deploy admin policy\n            _deployAdminPolicy();\n\n            // Deploy guard policy\n            _deployGuardPolicy();\n\n            // deploy rental factory\n            _deployFactoryPolicy();\n\n            // intialize the kernel\n            _setupKernel();\n        }\n    }\n\n\n    // Creates test accounts to interact with the V3 protocol\n    // Borrowed from test/fixtures/protocol/AccountCreator\n    contract AccountCreator is Protocol {\n        // Protocol accounts for testing\n        ProtocolAccount public alice;\n        ProtocolAccount public bob;\n        ProtocolAccount public carol;\n        ProtocolAccount public dan;\n        ProtocolAccount public eve;\n        ProtocolAccount public attacker;\n\n        // Mock tokens for testing\n        MockERC20[] public erc20s;\n        MockERC721[] public erc721s;\n        MockERC1155[] public erc1155s;\n\n        function setUp() public virtual override {\n            super.setUp();\n\n            // deploy 3 erc20 tokens, 3 erc721 tokens, and 3 erc1155 tokens\n            _deployTokens(3);\n\n            // instantiate all wallets and deploy rental safes for each\n            alice = _fundWalletAndDeployRentalSafe(\"alice\");\n            bob = _fundWalletAndDeployRentalSafe(\"bob\");\n            carol = _fundWalletAndDeployRentalSafe(\"carol\");\n            dan = _fundWalletAndDeployRentalSafe(\"dan\");\n            eve = _fundWalletAndDeployRentalSafe(\"eve\");\n            attacker = _fundWalletAndDeployRentalSafe(\"attacker\");\n\n\n\n        }\n\n        function _deployTokens(uint256 numTokens) internal {\n            for (uint256 i; i < numTokens; i++) {\n                _deployErc20Token();\n                _deployErc721Token();\n                _deployErc1155Token();\n            }\n        }\n\n        function _deployErc20Token() internal returns (uint256 i) {\n            // save the token's index\n            i = erc20s.length;\n\n            // deploy the mock token\n            MockERC20 token = new MockERC20();\n\n            // push the token to the array of mocks\n            erc20s.push(token);\n\n            // set the token label with the index\n            vm.label(address(token), string.concat(\"MERC20_\", LibString.toString(i)));\n        }\n\n        function _deployErc721Token() internal returns (uint256 i) {\n            // save the token's index\n            i = erc721s.length;\n\n            // deploy the mock token\n            MockERC721 token = new MockERC721();\n\n            // push the token to the array of mocks\n            erc721s.push(token);\n\n            // set the token label with the index\n            vm.label(address(token), string.concat(\"MERC721_\", LibString.toString(i)));\n        }\n\n        function _deployErc1155Token() internal returns (uint256 i) {\n            // save the token's index\n            i = erc1155s.length;\n\n            // deploy the mock token\n            MockERC1155 token = new MockERC1155();\n\n            // push the token to the array of mocks\n            erc1155s.push(token);\n\n            // set the token label with the index\n            vm.label(address(token), string.concat(\"MERC1155_\", LibString.toString(i)));\n        }\n\n        function _deployRentalSafe(\n            address owner,\n            string memory name\n        ) internal returns (address safe) {\n            // Deploy a 1/1 rental safe\n            address[] memory owners = new address[](1);\n            owners[0] = owner;\n            safe = factory.deployRentalSafe(owners, 1);\n\n\n\n        }\n\n        function _fundWalletAndDeployRentalSafe(\n            string memory name\n        ) internal returns (ProtocolAccount memory account) {\n            // create a wallet with a address, public key, and private key\n            Vm.Wallet memory wallet = vm.createWallet(name);\n\n            // deploy a rental safe for the address\n            address rentalSafe = _deployRentalSafe(wallet.addr, name);\n\n            // fund the wallet with ether, all erc20s, and approve the conduit for erc20s, erc721s, erc1155s\n            _allocateTokensAndApprovals(wallet.addr, 10000);\n\n            // create an account\n            account = ProtocolAccount({\n                addr: wallet.addr,\n                safe: SafeL2(payable(rentalSafe)),\n                publicKeyX: wallet.publicKeyX,\n                publicKeyY: wallet.publicKeyY,\n                privateKey: wallet.privateKey\n            });\n\n        }\n\n        function _allocateTokensAndApprovals(address to, uint128 amount) internal {\n            // deal ether to the recipient\n            vm.deal(to, amount);\n\n            // mint all erc20 tokens to the recipient\n            for (uint256 i = 0; i < erc20s.length; ++i) {\n                erc20s[i].mint(to, amount);\n            }\n\n            // set token approvals\n            _setApprovals(to);\n        }\n\n        function _setApprovals(address owner) internal {\n            // impersonate the owner address\n            vm.startPrank(owner);\n\n            // set all approvals for erc20 tokens\n            for (uint256 i = 0; i < erc20s.length; ++i) {\n                erc20s[i].approve(address(conduit), type(uint256).max);\n            }\n\n            // set all approvals for erc721 tokens\n            for (uint256 i = 0; i < erc721s.length; ++i) {\n                erc721s[i].setApprovalForAll(address(conduit), true);\n            }\n\n            // set all approvals for erc1155 tokens\n            for (uint256 i = 0; i < erc1155s.length; ++i) {\n                erc1155s[i].setApprovalForAll(address(conduit), true);\n            }\n\n            // stop impersonating\n            vm.stopPrank();\n        }\n    }\n\n\n\n    interface ERC1155TokenReceiver {\n\n        function onERC1155Received(\n            address _operator,\n            address _from,\n            uint256 _id,\n            uint256 _value,\n            bytes calldata _data\n        ) external returns (bytes4);\n\n        function onERC1155BatchReceived(\n            address _operator,\n            address _from,\n            uint256[] calldata _ids,\n            uint256[] calldata _values,\n            bytes calldata _data\n        ) external returns (bytes4);\n    }\n\n    interface ERC721TokenReceiver {\n        function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4);\n    }\n\n    interface IERC165 {\n        function supportsInterface(bytes4 interfaceId) external view returns (bool);\n    }\n\n\n    /**\n    * Borrowed from gnosis safe smart contracts\n    * @title Default Callback Handler - Handles supported tokens' callbacks, allowing Safes receiving these tokens.\n    * @author Richard Meissner - @rmeissner\n    */\n    contract TokenCallbackHandler is ERC1155TokenReceiver, ERC721TokenReceiver, IERC165 {\n        /**\n        * @notice Handles ERC1155 Token callback.\n        * return Standardized onERC1155Received return value.\n        */\n        function onERC1155Received(address, address, uint256, uint256, bytes calldata) external pure override returns (bytes4) {\n            return 0xf23a6e61;\n        }\n\n        /**\n        * @notice Handles ERC1155 Token batch callback.\n        * return Standardized onERC1155BatchReceived return value.\n        */\n        function onERC1155BatchReceived(\n            address,\n            address,\n            uint256[] calldata,\n            uint256[] calldata,\n            bytes calldata\n        ) external pure override returns (bytes4) {\n            return 0xbc197c81;\n        }\n\n        /**\n        * @notice Handles ERC721 Token callback.\n        *  return Standardized onERC721Received return value.\n        */\n        function onERC721Received(address, address, uint256, bytes calldata) external pure override returns (bytes4) {\n            return 0x150b7a02;\n        }\n\n        /**\n        * @notice Handles ERC777 Token callback.\n        * return nothing (not standardized)\n        */\n        function tokensReceived(address, address, address, uint256, bytes calldata, bytes calldata) external pure {\n            // We implement this for completeness, doesn't really have any value\n        }\n\n        /**\n        * @notice Implements ERC165 interface support for ERC1155TokenReceiver, ERC721TokenReceiver and IERC165.\n        * @param interfaceId Id of the interface.\n        * @return if the interface is supported.\n        */\n        function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\n            return\n                interfaceId == type(ERC1155TokenReceiver).interfaceId ||\n                interfaceId == type(ERC721TokenReceiver).interfaceId ||\n                interfaceId == type(IERC165).interfaceId;\n        }\n\n    }\n\n\n\n    // Sets up logic in the test engine related to order creation\n    // Borrowed from test/fixtures/engine/OrderCreator\n    contract OrderCreator is AccountCreator {\n        using OfferItemLib for OfferItem;\n        using ConsiderationItemLib for ConsiderationItem;\n        using OrderComponentsLib for OrderComponents;\n        using OrderLib for Order;\n        using ECDSA for bytes32;\n\n        // defines a config for a standard order component\n        string constant STANDARD_ORDER_COMPONENTS = \"standard_order_components\";\n\n        struct OrderToCreate {\n            ProtocolAccount offerer;\n            OfferItem[] offerItems;\n            ConsiderationItem[] considerationItems;\n            OrderMetadata metadata;\n        }\n\n        // keeps track of tokens used during a test\n        uint256[] usedOfferERC721s;\n        uint256[] usedOfferERC1155s;\n\n        uint256[] usedConsiderationERC721s;\n        uint256[] usedConsiderationERC1155s;\n\n        // components of an order\n        OrderToCreate orderToCreate;\n\n        function setUp() public virtual override {\n            super.setUp();\n\n            // Define a standard OrderComponents struct which is ready for\n            // use with the Create Policy and the protocol conduit contract\n            OrderComponentsLib\n                .empty()\n                .withOrderType(SeaportOrderType.FULL_RESTRICTED)\n                .withZone(address(create))\n                .withStartTime(block.timestamp)\n                .withEndTime(block.timestamp + 100)\n                .withSalt(123456789)\n                .withConduitKey(conduitKey)\n                .saveDefault(STANDARD_ORDER_COMPONENTS);\n\n            // for each test token, create a storage slot\n            for (uint256 i = 0; i < erc721s.length; i++) {\n                usedOfferERC721s.push();\n                usedConsiderationERC721s.push();\n\n                usedOfferERC1155s.push();\n                usedConsiderationERC1155s.push();\n            }\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                                Order Creation                               //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        // creates an order based on the provided context. The defaults on this order\n        // are good for most test cases.\n        function createOrder(\n            ProtocolAccount memory offerer,\n            OrderType orderType,\n            uint256 erc721Offers,\n            uint256 erc1155Offers,\n            uint256 erc20Offers,\n            uint256 erc721Considerations,\n            uint256 erc1155Considerations,\n            uint256 erc20Considerations\n        ) internal {\n            // require that the number of offer items or consideration items\n            // dont exceed the number of test tokens\n            require(\n                erc721Offers <= erc721s.length &&\n                    erc721Offers <= erc1155s.length &&\n                    erc20Offers <= erc20s.length,\n                \"TEST: too many offer items defined\"\n            );\n            require(\n                erc721Considerations <= erc721s.length &&\n                    erc1155Considerations <= erc1155s.length &&\n                    erc20Considerations <= erc20s.length,\n                \"TEST: too many consideration items defined\"\n            );\n\n            // create the offerer\n            _createOfferer(offerer);\n\n            // add the offer items\n            _createOfferItems(erc721Offers, erc1155Offers, erc20Offers);\n\n            // create the consideration items\n            _createConsiderationItems(\n                erc721Considerations,\n                erc1155Considerations,\n                erc20Considerations\n            );\n\n            // Create order metadata\n            _createOrderMetadata(orderType);\n        }\n\n        // Creates an offerer on the order to create\n        function _createOfferer(ProtocolAccount memory offerer) private {\n            orderToCreate.offerer = offerer;\n        }\n\n        // Creates offer items which are good for most tests\n        function _createOfferItems(\n            uint256 erc721Offers,\n            uint256 erc1155Offers,\n            uint256 erc20Offers\n        ) private {\n            // generate the ERC721 offer items\n            for (uint256 i = 0; i < erc721Offers; ++i) {\n                // create the offer item\n                orderToCreate.offerItems.push(\n                    OfferItemLib\n                        .empty()\n                        .withItemType(ItemType.ERC721)\n                        .withToken(address(erc721s[i]))\n                        .withIdentifierOrCriteria(usedOfferERC721s[i])\n                        .withStartAmount(1)\n                        .withEndAmount(1)\n                );\n\n                // mint an erc721 to the offerer\n                erc721s[i].mint(orderToCreate.offerer.addr);\n\n                // update the used token so it cannot be used again in the same test\n                usedOfferERC721s[i]++;\n            }\n\n            // generate the ERC1155 offer items\n            for (uint256 i = 0; i < erc1155Offers; ++i) {\n                // create the offer item\n                orderToCreate.offerItems.push(\n                    OfferItemLib\n                        .empty()\n                        .withItemType(ItemType.ERC1155)\n                        .withToken(address(erc1155s[i]))\n                        .withIdentifierOrCriteria(usedOfferERC1155s[i])\n                        .withStartAmount(100)\n                        .withEndAmount(100)\n                );\n\n                // mint an erc1155 to the offerer\n                erc1155s[i].mint(orderToCreate.offerer.addr, 100);\n\n                // update the used token so it cannot be used again in the same test\n                usedOfferERC1155s[i]++;\n            }\n\n            // generate the ERC20 offer items\n            for (uint256 i = 0; i < erc20O",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2024-01-renft",
  "Code": [
    {
      "filename": "contracts/base/FallbackManager.sol",
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport {SelfAuthorized} from \"../common/SelfAuthorized.sol\";\nimport {IFallbackManager} from \"../interfaces/IFallbackManager.sol\";\n\n/**\n * @title Fallback Manager - A contract managing fallback calls made to this contract\n * @author Richard Meissner - @rmeissner\n */\nabstract contract FallbackManager is SelfAuthorized, IFallbackManager {\n    // keccak256(\"fallback_manager.handler.address\")\n    bytes32 internal constant FALLBACK_HANDLER_STORAGE_SLOT = 0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d5;\n\n    /**\n     *  @notice Internal function to set the fallback handler.\n     *  @param handler contract to handle fallback calls.\n     */\n    function internalSetFallbackHandler(address handler) internal {\n        /*\n            If a fallback handler is set to self, then the following attack vector is opened:\n            Imagine we have a function like this:\n            function withdraw() internal authorized {\n                withdrawalAddress.call.value(address(this).balance)(\"\");\n            }\n\n            If the fallback method is triggered, the fallback handler appends the msg.sender address to the calldata and calls the fallback handler.\n            A potential attacker could call a Safe with the 3 bytes signature of a withdraw function. Since 3 bytes do not create a valid signature,\n            the call would end in a fallback handler. Since it appends the msg.sender address to the calldata, the attacker could craft an address \n            where the first 3 bytes of the previous calldata + the first byte of the address make up a valid function signature. The subsequent call would result in unsanctioned access to Safe's internal protected methods.\n            For some reason, solidity matches the first 4 bytes of the calldata to a function signature, regardless if more data follow these 4 bytes.\n        */\n        if (handler == address(this)) revertWithError(\"GS400\");\n\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            sstore(FALLBACK_HANDLER_STORAGE_SLOT, handler)\n        }\n        /* solhint-enable no-inline-assembly */\n    }\n\n    // @inheritdoc IFallbackManager\n    function setFallbackHandler(address handler) public override authorized {\n        internalSetFallbackHandler(handler);\n        emit ChangedFallbackHandler(handler);\n    }\n\n    // @notice Forwards all calls to the fallback handler if set. Returns 0 if no handler is set.\n    // @dev Appends the non-padded caller address to the calldata to be optionally used in the handler\n    //      The handler can make us of `HandlerContext.sol` to extract the address.\n    //      This is done because in the next call frame the `msg.sender` will be FallbackManager's address\n    //      and having the original caller address may enable additional verification scenarios.\n    // solhint-disable-next-line payable-fallback,no-complex-fallback\n    fallback() external {\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            // When compiled with the optimizer, the compiler relies on a certain assumptions on how the\n            // memory is used, therefore we need to guarantee memory safety (keeping the free memory point 0x40 slot intact,\n            // not going beyond the scratch space, etc)\n            // Solidity docs: https://docs.soliditylang.org/en/latest/assembly.html#memory-safety\n\n            let handler := sload(FALLBACK_HANDLER_STORAGE_SLOT)\n\n            if iszero(handler) {\n                return(0, 0)\n            }\n\n            let ptr := mload(0x40)\n            calldatacopy(ptr, 0, calldatasize())\n\n            // The msg.sender address is shifted to the left by 12 bytes to remove the padding\n            // Then the address without padding is stored right after the calldata\n            mstore(add(ptr, calldatasize()), shl(96, caller()))\n\n            // Add 20 bytes for the address appended add the end\n            let success := call(gas(), handler, 0, ptr, add(calldatasize(), 20), 0, 0)\n\n            returndatacopy(ptr, 0, returndatasize())\n            if iszero(success) {\n                revert(ptr, returndatasize())\n            }\n            return(ptr, returndatasize())\n        }\n        /* solhint-enable no-inline-assembly */\n    }\n}"
    },
    {
      "filename": "src/policies/Factory.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {SafeL2} from \"@safe-contracts/SafeL2.sol\";\nimport {SafeProxyFactory} from \"@safe-contracts/proxies/SafeProxyFactory.sol\";\nimport {TokenCallbackHandler} from \"@safe-contracts/handler/TokenCallbackHandler.sol\";\n\nimport {ISafe} from \"@src/interfaces/ISafe.sol\";\n\nimport {Kernel, Policy, Permissions, Keycode} from \"@src/Kernel.sol\";\nimport {toKeycode} from \"@src/libraries/KernelUtils.sol\";\nimport {Errors} from \"@src/libraries/Errors.sol\";\nimport {Events} from \"@src/libraries/Events.sol\";\nimport {Storage} from \"@src/modules/Storage.sol\";\nimport {Stop} from \"@src/policies/Stop.sol\";\nimport {Guard} from \"@src/policies/Guard.sol\";\n\n/**\n * @title Factory\n * @notice Acts as an interface for all behavior related to deploying rental safes.\n */\ncontract Factory is Policy {\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Policy Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    // Modules that the policy depends on.\n    Storage public STORE;\n\n    // policies.\n    Stop public immutable stopPolicy;\n    Guard public immutable guardPolicy;\n\n    // External contracts.\n    TokenCallbackHandler public immutable fallbackHandler;\n    SafeProxyFactory public immutable safeProxyFactory;\n    SafeL2 public immutable safeSingleton;\n\n    /**\n     * @dev Instantiate this contract as a policy.\n     *\n     * @param kernel_           Address of the kernel contract.\n     * @param stopPolicy_       Address of the stop policy.\n     * @param guardPolicy_      Address of the guard policy.\n     * @param fallbackHandler_  Gnosis safe fallback handler address.\n     * @param safeProxyFactory_ Gnosis safe proxy factory address.\n     * @param safeSingleton_    Gnosis safe logic contract address.\n     */\n    constructor(\n        Kernel kernel_,\n        Stop stopPolicy_,\n        Guard guardPolicy_,\n        TokenCallbackHandler fallbackHandler_,\n        SafeProxyFactory safeProxyFactory_,\n        SafeL2 safeSingleton_\n    ) Policy(kernel_) {\n        stopPolicy = stopPolicy_;\n        guardPolicy = guardPolicy_;\n        fallbackHandler = fallbackHandler_;\n        safeProxyFactory = safeProxyFactory_;\n        safeSingleton = safeSingleton_;\n    }\n\n    /**\n     * @notice Upon policy activation, configures the modules that the policy depends on.\n     *         If a module is ever upgraded that this policy depends on, the kernel will\n     *         call this function again to ensure this policy has the current address\n     *         of the module.\n     *\n     * @return dependencies Array of keycodes which represent modules that\n     *                      this policy depends on.\n     */\n    function configureDependencies()\n        external\n        override\n        onlyKernel\n        returns (Keycode[] memory dependencies)\n    {\n        dependencies = new Keycode[](1);\n\n        dependencies[0] = toKeycode(\"STORE\");\n        STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n    }\n\n    /**\n     * @notice Upon policy activation, permissions are requested from the kernel to access\n     *         particular keycode <> function selector pairs. Once these permissions are\n     *         granted, they do not change and can only be revoked when the policy is\n     *         deactivated by the kernel.\n     *\n     * @return requests Array of keycode <> function selector pairs which represent\n     *                  permissions for the policy.\n     */\n    function requestPermissions()\n        external\n        view\n        override\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {\n        requests = new Permissions[](1);\n        requests[0] = Permissions(toKeycode(\"STORE\"), STORE.addRentalSafe.selector);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            External Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Initializes a rental safe by setting it up with the stop policy and\n     *         rental guard during deployment.\n     *\n     *          Warning: This function assumes the invariant that delegate call will be\n     *          disabled or restricted by the guard policy. If delegate call were to be\n     *          freely allowed, then a safe could call this function after deployment\n     *          and change the module/guard contacts which would allow transferring\n     *          of rented assets out of the safe.\n     *\n     * @param _stopPolicy  Address of the stop policy to add as a module to the safe.\n     * @param _guardPolicy Address of the guard policy to add as a guard on the safe.\n     */\n    function initializeRentalSafe(address _stopPolicy, address _guardPolicy) external {\n        // Enable the module.\n        ISafe(address(this)).enableModule(_stopPolicy);\n\n        // Set the guard.\n        ISafe(address(this)).setGuard(_guardPolicy);\n    }\n\n    /**\n     * @notice Deploys and initializes a rental safe.\n     *\n     * @param owners    Array of owner addresses which will have the ability to sign\n     *                  transactions for the safe.\n     * @param threshold Number of signatures required to executed a transaction\n     *                  on the safe.\n     */\n    function deployRentalSafe(\n        address[] calldata owners,\n        uint256 threshold\n    ) external returns (address safe) {\n        // Require that the threshold is valid.\n        if (threshold == 0 || threshold > owners.length) {\n            revert Errors.FactoryPolicy_InvalidSafeThreshold(threshold, owners.length);\n        }\n\n        // Delegate call from the safe so that the rental manager module can be enabled\n        // right after the safe is deployed.\n        bytes memory data = abi.encodeCall(\n            Factory.initializeRentalSafe,\n            (address(stopPolicy), address(guardPolicy))\n        );\n\n        // Create gnosis initializer payload.\n        bytes memory initializerPayload = abi.encodeCall(\n            ISafe.setup,\n            (\n                // owners array.\n                owners,\n                // number of signatures needed to execute transactions.\n                threshold,\n                // Address to direct the payload to.\n                address(this),\n                // Encoded call to execute.\n                data,\n                // Fallback manager address.\n                address(fallbackHandler),\n                // Payment token.\n                address(0),\n                // Payment amount.\n                0,\n                // Payment receiver\n                payable(address(0))\n            )\n        );\n\n        // Deploy a safe proxy using initializer values for the Safe.setup() call\n        // with a salt nonce that is unique to each chain to guarantee cross-chain\n        // unique safe addresses.\n        safe = address(\n            safeProxyFactory.createProxyWithNonce(\n                address(safeSingleton),\n                initializerPayload,\n                uint256(keccak256(abi.encode(STORE.totalSafes() + 1, block.chainid)))\n            )\n        );\n\n        // Store the deployed safe.\n        STORE.addRentalSafe(safe);\n\n        // Emit the event.\n        emit Events.RentalSafeDeployment(safe, owners, threshold);\n    }\n}"
    },
    {
      "filename": "contracts/base/FallbackManager.sol",
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport {SelfAuthorized} from \"../common/SelfAuthorized.sol\";\nimport {IFallbackManager} from \"../interfaces/IFallbackManager.sol\";\n\n/**\n * @title Fallback Manager - A contract managing fallback calls made to this contract\n * @author Richard Meissner - @rmeissner\n */\nabstract contract FallbackManager is SelfAuthorized, IFallbackManager {\n    // keccak256(\"fallback_manager.handler.address\")\n    bytes32 internal constant FALLBACK_HANDLER_STORAGE_SLOT = 0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d5;\n\n    /**\n     *  @notice Internal function to set the fallback handler.\n     *  @param handler contract to handle fallback calls.\n     */\n    function internalSetFallbackHandler(address handler) internal {\n        /*\n            If a fallback handler is set to self, then the following attack vector is opened:\n            Imagine we have a function like this:\n            function withdraw() internal authorized {\n                withdrawalAddress.call.value(address(this).balance)(\"\");\n            }\n\n            If the fallback method is triggered, the fallback handler appends the msg.sender address to the calldata and calls the fallback handler.\n            A potential attacker could call a Safe with the 3 bytes signature of a withdraw function. Since 3 bytes do not create a valid signature,\n            the call would end in a fallback handler. Since it appends the msg.sender address to the calldata, the attacker could craft an address \n            where the first 3 bytes of the previous calldata + the first byte of the address make up a valid function signature. The subsequent call would result in unsanctioned access to Safe's internal protected methods.\n            For some reason, solidity matches the first 4 bytes of the calldata to a function signature, regardless if more data follow these 4 bytes.\n        */\n        if (handler == address(this)) revertWithError(\"GS400\");\n\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            sstore(FALLBACK_HANDLER_STORAGE_SLOT, handler)\n        }\n        /* solhint-enable no-inline-assembly */\n    }\n\n    // @inheritdoc IFallbackManager\n    function setFallbackHandler(address handler) public override authorized {\n        internalSetFallbackHandler(handler);\n        emit ChangedFallbackHandler(handler);\n    }\n\n    // @notice Forwards all calls to the fallback handler if set. Returns 0 if no handler is set.\n    // @dev Appends the non-padded caller address to the calldata to be optionally used in the handler\n    //      The handler can make us of `HandlerContext.sol` to extract the address.\n    //      This is done because in the next call frame the `msg.sender` will be FallbackManager's address\n    //      and having the original caller address may enable additional verification scenarios.\n    // solhint-disable-next-line payable-fallback,no-complex-fallback\n    fallback() external {\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            // When compiled with the optimizer, the compiler relies on a certain assumptions on how the\n            // memory is used, therefore we need to guarantee memory safety (keeping the free memory point 0x40 slot intact,\n            // not going beyond the scratch space, etc)\n            // Solidity docs: https://docs.soliditylang.org/en/latest/assembly.html#memory-safety\n\n            let handler := sload(FALLBACK_HANDLER_STORAGE_SLOT)\n\n            if iszero(handler) {\n                return(0, 0)\n            }\n\n            let ptr := mload(0x40)\n            calldatacopy(ptr, 0, calldatasize())\n\n            // The msg.sender address is shifted to the left by 12 bytes to remove the padding\n            // Then the address without padding is stored right after the calldata\n            mstore(add(ptr, calldatasize()), shl(96, caller()))\n\n            // Add 20 bytes for the address appended add the end\n            let success := call(gas(), handler, 0, ptr, add(calldatasize(), 20), 0, 0)\n\n            returndatacopy(ptr, 0, returndatasize())\n            if iszero(success) {\n                revert(ptr, returndatasize())\n            }\n            return(ptr, returndatasize())\n        }\n        /* solhint-enable no-inline-assembly */\n    }\n}"
    }
  ]
}