{
  "Title": "M-3: ConvexSpell/CurveSpell.openPositionFarm will revert in some cases",
  "Content": "# Issue M-3: ConvexSpell/CurveSpell.openPositionFarm will revert in some cases \n\nSource: https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/60 \n\n## Found by \nnobody2018\n\nBefore calling `ICurvePool#add_liquidity` to deposit tokens, each token needs to be approved to the pool. If the approved amount is smaller than the parameters passed into `ICurvePool#add_liquidity`, it will cause `erc20.transferFrom` revert inside the function. In this way, `openPositionFarm` will also revert.\n\nIn previous contest, [[#47](https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/47)](https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/47) was not fixed correctly. **This issue is still exist**.\n\n## Vulnerability Detail\n\nThe fix for this issue from this contest is as following:\n\n```solidity\nFile: blueberry-core\\contracts\\spell\\CurveSpell.sol\n098:         // 2. Borrow specific amounts\n099:         uint256 borrowBalance = _doBorrow(\n100:             param.borrowToken,\n101:             param.borrowAmount\n102:         );\n103: \n104:         // 3. Add liquidity on curve\n105:         address borrowToken = param.borrowToken;\n106:         _ensureApprove(param.borrowToken, pool, borrowBalance);\n107:         if (tokens.length == 2) {\n108:             uint256[2] memory suppliedAmts;\n109:             for (uint256 i = 0; i < 2; i++) {\n                     //this 'if' check is the fix from the previous contest\n110:->               if (tokens[i] == borrowToken) {\n111:                     suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n112:                         address(this)\n113:                     );\n114:                     break;\n115:                 }\n116:             }\n117:             ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n118:         } else if (tokens.length == 3) {\n```\n\n**The key to this issue is that `borrowBalance` may be smaller than `IERC20Upgradeable(borrowToken).balanceOf(address(this))`**. For simplicity, assume that CurveSpell supports an lptoken which contains two tokens : A and B.\n\n**Bob transferred 1wei of A and B to the CurveSpell contract**. Alice opens a position by calling `BlueBerryBank#execute`, and the flow is as follows:\n\n1.  enter `CurveSpell#openPositionFarm`.\n2.  call `_doLend` to deposit isolated collaterals.\n3.  call `_doBorrow` to borrow 100e18 A token. borrowBalance = 100e18.\n4.  `A.approve(pool, 100e18)`.\n5.  `suppliedAmts[0] = A.balance(address(this)) = 100e18+1wei`, `suppliedAmts[1] = 0`.\n6.  call `ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint)`, then revert because the approved amount is not enough.\n\nTherefore, no one can successfully open a position.\n\nOf course, bob can also transfer 1wei of `borrowToken` to contract by front-running `openPositionFarm` for a specific user or all users.\n\nIn ConvexSpell, the issue lies in [[the same code](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/spell/ConvexSpell.sol#L110-L144)](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/spell/ConvexSpell.sol#L110-L144) as in previous games.\n\n## Impact\n\n`ConvexSpell/CurveSpell.openPositionFarm` will revert due to this issue.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/spell/CurveSpell.sol#L99-L140\n\nhttps://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/spell/ConvexSpell.sol#L110-L144\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n**The following fix is for CurveSpell, but please don't forget ConvexSpell**.\n\nTwo ways for fix it:\n\n```fix\n--- a/blueberry-core/contracts/spell/CurveSpell.sol\n+++ b/blueberry-core/contracts/spell/CurveSpell.sol\n@@ -108,9 +108,7 @@ contract CurveSpell is BasicSpell {\n             uint256[2] memory suppliedAmts;\n             for (uint256 i = 0; i < 2; i++) {\n                 if (tokens[i] == borrowToken) {\n-                    suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n-                        address(this)\n-                    );\n+                    suppliedAmts[i] = borrowBalance;\n                     break;\n                 }\n             }\n@@ -119,9 +117,7 @@ contract CurveSpell is BasicSpell {\n             uint256[3] memory suppliedAmts;\n             for (uint256 i = 0; i < 3; i++) {\n                 if (tokens[i] == borrowToken) {\n-                    suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n-                        address(this)\n-                    );\n+                    suppliedAmts[i] = borrowBalance;\n                     break;\n                 }\n             }\n@@ -130,9 +126,7 @@ contract CurveSpell is BasicSpell {\n             uint256[4] memory suppliedAmts;\n             for (uint256 i = 0; i < 4; i++) {\n                 if (tokens[i] == borrowToken) {\n-                    suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n-                        address(this)\n-                    );\n+                    suppliedAmts[i] = borrowBalance;\n                     break;\n                 }\n             }\n```\n\n```fix\n--- a/blueberry-core/contracts/spell/CurveSpell.sol\n+++ b/blueberry-core/contracts/spell/CurveSpell.sol\n@@ -103,7 +103,8 @@ contract CurveSpell is BasicSpell {\n\n         // 3. Add liquidity on curve\n         address borrowToken = param.borrowToken;\n-        _ensureApprove(param.borrowToken, pool, borrowBalance);\n+        require(borrowBalance <= IERC20Upgradeable(borrowToken).balanceOf(address(this)), \"impossible\");\n+        _ensureApprove(param.borrowToken, pool, IERC20Upgradeable(borrowToken).balanceOf(address(this)));\n         if (tokens.length == 2) {\n             uint256[2] memory suppliedAmts;\n             for (uint256 i = 0; i < 2; i++) {\n```\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**0xyPhilic** commented:\n> invalid because the borrowAmount can't change mid function execution\n\n**darkart** commented:\n>  If already approven its up to Developrs to chose if they will implement it\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/104",
  "Code": [
    {
      "filename": "blueberry-core/contracts/spell/ConvexSpell.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"./BasicSpell.sol\";\nimport \"../interfaces/ICurveOracle.sol\";\nimport \"../interfaces/IWConvexPools.sol\";\nimport \"../interfaces/curve/ICurvePool.sol\";\nimport \"../libraries/Paraswap/PSwapLib.sol\";\n\n/// @title ConvexSpell\n/// @author BlueberryProtocol\n/// @notice This contract serves as the factory for defining how the Blueberry Protocol \n///         interacts with Convex pools. It handles strategies, interactions with external contracts, \n///         and facilitates operations related to liquidity provision.\ncontract ConvexSpell is BasicSpell {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    /*//////////////////////////////////////////////////////////////////////////\n                                   PUBLIC STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Address of the Wrapped Convex Pools\n    IWConvexPools public wConvexPools;\n    /// @dev address of CurveOracle to retrieve pool information\n    ICurveOracle public crvOracle;\n    /// @dev address of CVX token\n    address public CVX;\n\n    /// @dev paraswap AugustusSwapper address for token swaps\n    address public augustusSwapper;\n    /// @dev paraswap TokenTransferProxy address for efficient token transfers\n    address public tokenTransferProxy;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n        \n    /// @notice Initializes the ConvexSpell contract with required parameters.\n    /// @param bank_ Address of the bank contract.\n    /// @param werc20_ Address of the wrapped ERC20 contract.\n    /// @param weth_ Address of the wrapped Ethereum contract.\n    /// @param wConvexPools_ Address of the wrapped Convex pools contract.\n    /// @param crvOracle_ Address of the Curve Oracle contract.\n    /// @param augustusSwapper_ Address of the paraswap AugustusSwapper.\n    /// @param tokenTransferProxy_ Address of the paraswap TokenTransferProxy.\n    function initialize(\n        IBank bank_,\n        address werc20_,\n        address weth_,\n        address wConvexPools_,\n        address crvOracle_,\n        address augustusSwapper_,\n        address tokenTransferProxy_\n    ) external initializer {\n        __BasicSpell_init(bank_, werc20_, weth_);\n        if (wConvexPools_ == address(0) || crvOracle_ == address(0))\n            revert Errors.ZERO_ADDRESS();\n\n        wConvexPools = IWConvexPools(wConvexPools_);\n        CVX = address(wConvexPools.CVX());\n        crvOracle = ICurveOracle(crvOracle_);\n        IWConvexPools(wConvexPools_).setApprovalForAll(address(bank_), true);\n\n        augustusSwapper = augustusSwapper_;\n        tokenTransferProxy = tokenTransferProxy_;\n    }\n\n    /// @notice Adds a new strategy to the spell.\n    /// @param crvLp Address of the Curve LP token for the strategy.\n    /// @param minPosSize Minimum position size in USD for the strategy (with 1e18 precision).\n    /// @param maxPosSize Maximum position size in USD for the strategy (with 1e18 precision).\n    function addStrategy(\n        address crvLp,\n        uint256 minPosSize,\n        uint256 maxPosSize\n    ) external onlyOwner {\n        _addStrategy(crvLp, minPosSize, maxPosSize);\n    }\n\n    /// @notice Adds liquidity to a Curve pool with two underlying tokens and stakes in Curve gauge.\n    /// @param param Struct containing all required parameters for opening a position.\n    /// @param minLPMint Minimum LP tokens expected to mint for slippage control.\n    function openPositionFarm(\n        OpenPosParam calldata param,\n        uint256 minLPMint\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        Strategy memory strategy = strategies[param.strategyId];\n        (address lpToken, , , , , ) = wConvexPools.getPoolInfoFromPoolId(\n            param.farmingPoolId\n        );\n        if (strategy.vault != lpToken) revert Errors.INCORRECT_LP(lpToken);\n\n        /// 1. Deposit isolated collaterals on Blueberry Money Market\n        _doLend(param.collToken, param.collAmount);\n\n        /// 2. Borrow specific amounts\n        uint256 borrowBalance = _doBorrow(\n            param.borrowToken,\n            param.borrowAmount\n        );\n\n        /// 3. Add liquidity on curve, get crvLp\n        (address pool, address[] memory tokens, ) = crvOracle.getPoolInfo(\n            lpToken\n        );\n        _ensureApprove(param.borrowToken, pool, borrowBalance);\n        if (tokens.length == 2) {\n            uint256[2] memory suppliedAmts;\n            for (uint256 i; i != 2; ++i) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        } else if (tokens.length == 3) {\n            uint256[3] memory suppliedAmts;\n            for (uint256 i; i != 3; ++i) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        } else {\n            uint256[4] memory suppliedAmts;\n            for (uint256 i; i != 4; ++i) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        }\n\n        /// 4. Validate MAX LTV\n        _validateMaxLTV(param.strategyId);\n\n        /// 5. Validate Max Pos Size\n        _validatePosSize(param.strategyId);\n        /// 6. Take out existing collateral and burn\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collateralSize > 0) {\n            (uint256 pid, ) = wConvexPools.decodeId(pos.collId);\n            if (param.farmingPoolId != pid)\n                revert Errors.INCORRECT_PID(param.farmingPoolId);\n            if (pos.collToken != address(wConvexPools))\n                revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n            bank.takeCollateral(pos.collateralSize);\n            (address[] memory rewardTokens, ) = wConvexPools.burn(pos.collId, pos.collateralSize);\n            // distribute multiple rewards to users\n            uint256 tokensLength = rewardTokens.length;\n            for (uint256 i; i != tokensLength; ++i) {\n                _doRefundRewards(rewardTokens[i]);\n            }\n        }\n\n        /// 7. Deposit on Convex Pool, Put wrapped collateral tokens on Blueberry Bank\n        uint256 lpAmount = IERC20Upgradeable(lpToken).balanceOf(address(this));\n        _ensureApprove(lpToken, address(wConvexPools), lpAmount);\n        uint256 id = wConvexPools.mint(param.farmingPoolId, lpAmount);\n        bank.putCollateral(address(wConvexPools), id, lpAmount);\n    }\n\n    /// @notice Closes an existing liquidity position, unstakes from Curve gauge, and swaps rewards.\n    /// @param param Struct containing all required parameters for closing a position.\n    /// @param expectedRewards List of expected reward amounts for each token.\n    /// @param swapDatas Swap data for each reward token.\n    function closePositionFarm(\n        ClosePosParam calldata param,\n        uint256[] calldata expectedRewards,\n        bytes[] calldata swapDatas\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        address crvLp = strategies[param.strategyId].vault;\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collToken != address(wConvexPools))\n            revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n        if (wConvexPools.getUnderlyingToken(pos.collId) != crvLp)\n            revert Errors.INCORRECT_UNDERLYING(crvLp);\n\n        uint256 amountPosRemove = param.amountPosRemove;\n\n        /// 1. Take out collateral - Burn wrapped tokens, receive crv lp tokens and harvest CRV\n        bank.takeCollateral(amountPosRemove);\n        (address[] memory rewardTokens, ) = wConvexPools.burn(\n            pos.collId,\n            amountPosRemove\n        );\n\n        /// 2. Swap rewards tokens to debt token\n        _sellRewards(rewardTokens, expectedRewards, swapDatas);\n\n        /// 3. Remove liquidity\n        _removeLiquidity(param, pos, crvLp, amountPosRemove);\n\n        /// 4. Withdraw isolated collateral from Bank\n        _doWithdraw(param.collToken, param.amountShareWithdraw);\n\n        /// 5. Repay\n        {\n            /// Compute repay amount if MAX_INT is supplied (max debt)\n            uint256 amountRepay = param.amountRepay;\n            if (amountRepay == type(uint256).max) {\n                amountRepay = bank.currentPositionDebt(bank.POSITION_ID());\n            }\n            _doRepay(param.borrowToken, amountRepay);\n        }\n\n        _validateMaxLTV(param.strategyId);\n\n        /// 6. Refund\n        _doRefund(param.borrowToken);\n        _doRefund(param.collToken);\n        _doRefund(CVX);\n    }\n\n    /// @dev Removes liquidity from a Curve pool for a given position.\n    /// @param param Contains data required to close the position.\n    /// @param pos Data structure representing the current bank position.\n    /// @param crvLp Address of the Curve LP token.\n    /// @param amountPosRemove Amount of LP tokens to be removed from the pool. \n    ///        If set to max, will remove all available LP tokens.\n    function _removeLiquidity(\n        ClosePosParam memory param,\n        IBank.Position memory pos,\n        address crvLp,\n        uint256 amountPosRemove\n    ) internal {\n        (address pool, address[] memory tokens, ) = crvOracle.getPoolInfo(\n            crvLp\n        );\n\n        if (amountPosRemove == type(uint256).max) {\n            amountPosRemove = IERC20Upgradeable(crvLp).balanceOf(address(this));\n        }\n\n        int128 tokenIndex;\n        uint256 tokensLength = tokens.length;\n        for (uint256 i; i != tokensLength; ++i) {\n            if (tokens[i] == pos.debtToken) {\n                tokenIndex = int128(uint128(i));\n                break;\n            }\n        }\n\n        /// Removes liquidity from the Curve pool for the specified token.\n        ICurvePool(pool).remove_liquidity_one_coin(\n            amountPosRemove,\n            int128(tokenIndex),\n            param.amountOutMin\n        );\n    }\n\n    /// @dev Internal function Sells the accumulated reward tokens.\n    /// @param rewardTokens An array of addresses of the reward tokens to be sold.\n    /// @param expectedRewards Array containing the expected amounts of each reward token.\n    /// @param swapDatas Data required for performing the swaps.\n    function _sellRewards(\n        address[] memory rewardTokens,\n        uint[] calldata expectedRewards,\n        bytes[] calldata swapDatas\n    ) internal {\n        uint256 tokensLength = rewardTokens.length;\n        for (uint256 i; i != tokensLength; ++i) {\n            address sellToken = rewardTokens[i];\n\n            /// Apply any potential fees on the reward.\n            _doCutRewardsFee(sellToken);\n\n            uint expectedReward = expectedRewards[i];\n            /// If the expected reward is zero, skip to the next token.\n            if (expectedReward == 0) continue;\n            /// Swap the reward token for another desired token. If the swap fails, revert with an error.\n            if (\n                !PSwapLib.swap(\n                    augustusSwapper,\n                    tokenTransferProxy,\n                    sellToken,\n                    expectedReward,\n                    swapDatas[i]\n                )\n            ) revert Errors.SWAP_FAILED(sellToken);\n            /// Refund any leftover (dust) amounts after the swap to the contract owner\n            _doRefund(sellToken);\n        }\n    }\n}"
    },
    {
      "filename": "blueberry-core/contracts/spell/CurveSpell.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./BasicSpell.sol\";\nimport \"../interfaces/ICurveOracle.sol\";\nimport \"../interfaces/IWCurveGauge.sol\";\nimport \"../interfaces/curve/ICurvePool.sol\";\nimport \"../libraries/Paraswap/PSwapLib.sol\";\n\n/**\n * @title CurveSpell\n * @author BlueberryProtocol\n * @notice CurveSpell is the factory contract that\n * defines how Blueberry Protocol interacts with Curve pools\n */\ncontract CurveSpell is BasicSpell {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @dev address of Wrapped Curve Gauge\n    IWCurveGauge public wCurveGauge;\n    /// @dev address of CurveOracle\n    ICurveOracle public crvOracle;\n    /// @dev address of CRV token\n    address public CRV;\n\n    /// @dev paraswap AugustusSwapper address\n    address public augustusSwapper;\n    /// @dev paraswap TokenTransferProxy address\n    address public tokenTransferProxy;\n\n    function initialize(\n        IBank bank_,\n        address werc20_,\n        address weth_,\n        address wCurveGauge_,\n        address crvOracle_,\n        address augustusSwapper_,\n        address tokenTransferProxy_\n    ) external initializer {\n        __BasicSpell_init(bank_, werc20_, weth_);\n        if (wCurveGauge_ == address(0) || crvOracle_ == address(0))\n            revert Errors.ZERO_ADDRESS();\n\n        wCurveGauge = IWCurveGauge(wCurveGauge_);\n        CRV = address(wCurveGauge.CRV());\n        crvOracle = ICurveOracle(crvOracle_);\n        IWCurveGauge(wCurveGauge_).setApprovalForAll(address(bank_), true);\n\n        augustusSwapper = augustusSwapper_;\n        tokenTransferProxy = tokenTransferProxy_;\n    }\n\n    /**\n     * @notice Add strategy to the spell\n     * @param crvLp Address of crv lp token for given strategy\n     * @param minPosSize, USD price of minimum position size for given strategy, based 1e18\n     * @param maxPosSize, USD price of maximum position size for given strategy, based 1e18\n     */\n    function addStrategy(\n        address crvLp,\n        uint256 minPosSize,\n        uint256 maxPosSize\n    ) external onlyOwner {\n        _addStrategy(crvLp, minPosSize, maxPosSize);\n    }\n\n    /**\n     * @notice Add liquidity to Curve pool with 2 underlying tokens, with staking to Curve gauge\n     * @param minLPMint Desired LP token amount (slippage control)\n     */\n    function openPositionFarm(\n        OpenPosParam calldata param,\n        uint256 minLPMint\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        address lp = strategies[param.strategyId].vault;\n        if (wCurveGauge.getLpFromGaugeId(param.farmingPoolId) != lp)\n            revert Errors.INCORRECT_LP(lp);\n        (address pool, address[] memory tokens, ) = crvOracle.getPoolInfo(lp);\n\n        // 1. Deposit isolated collaterals on Blueberry Money Market\n        _doLend(param.collToken, param.collAmount);\n\n        // 2. Borrow specific amounts\n        uint256 borrowBalance = _doBorrow(\n            param.borrowToken,\n            param.borrowAmount\n        );\n\n        // 3. Add liquidity on curve\n        address borrowToken = param.borrowToken;\n        _ensureApprove(param.borrowToken, pool, borrowBalance);\n        if (tokens.length == 2) {\n            uint256[2] memory suppliedAmts;\n            for (uint256 i = 0; i < 2; i++) {\n                if (tokens[i] == borrowToken) {\n                    suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                        address(this)\n                    );\n                    break;\n                }\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        } else if (tokens.length == 3) {\n            uint256[3] memory suppliedAmts;\n            for (uint256 i = 0; i < 3; i++) {\n                if (tokens[i] == borrowToken) {\n                    suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                        address(this)\n                    );\n                    break;\n                }\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        } else if (tokens.length == 4) {\n            uint256[4] memory suppliedAmts;\n            for (uint256 i = 0; i < 4; i++) {\n                if (tokens[i] == borrowToken) {\n                    suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                        address(this)\n                    );\n                    break;\n                }\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        }\n\n        // 4. Validate MAX LTV\n        _validateMaxLTV(param.strategyId);\n\n        // 5. Validate Max Pos Size\n        _validatePosSize(param.strategyId);\n\n        // 6. Take out collateral and burn\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collateralSize > 0) {\n            (uint256 decodedGid, ) = wCurveGauge.decodeId(pos.collId);\n            if (param.farmingPoolId != decodedGid)\n                revert Errors.INCORRECT_PID(param.farmingPoolId);\n            if (pos.collToken != address(wCurveGauge))\n                revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n            bank.takeCollateral(pos.collateralSize);\n            wCurveGauge.burn(pos.collId, pos.collateralSize);\n            _doRefundRewards(CRV);\n        }\n\n        // 7. Deposit on Curve Gauge, Put wrapped collateral tokens on Blueberry Bank\n        uint256 lpAmount = IERC20Upgradeable(lp).balanceOf(address(this));\n        _ensureApprove(lp, address(wCurveGauge), lpAmount);\n        uint256 id = wCurveGauge.mint(param.farmingPoolId, lpAmount);\n        bank.putCollateral(address(wCurveGauge), id, lpAmount);\n    }\n\n    function closePositionFarm(\n        ClosePosParam memory param,\n        uint256[] calldata amounts,\n        bytes[] calldata swapDatas,\n        bool isKilled,\n        uint256 deadline\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        if (block.timestamp > deadline) revert Errors.EXPIRED(deadline);\n\n        address crvLp = strategies[param.strategyId].vault;\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collToken != address(wCurveGauge))\n            revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n        if (wCurveGauge.getUnderlyingToken(pos.collId) != crvLp)\n            revert Errors.INCORRECT_UNDERLYING(crvLp);\n\n        // 1. Take out collateral - Burn wrapped tokens, receive crv lp tokens and harvest CRV\n        bank.takeCollateral(param.amountPosRemove);\n        wCurveGauge.burn(pos.collId, param.amountPosRemove);\n\n        {\n            // 2. Swap rewards tokens to debt token\n            _swapOnParaswap(CRV, amounts[0], swapDatas[0]);\n        }\n\n        {\n            address[] memory tokens;\n            {\n                address pool;\n                (pool, tokens, ) = crvOracle.getPoolInfo(crvLp);\n\n                // 3. Calculate actual amount to remove\n                uint256 amountPosRemove = param.amountPosRemove;\n                if (amountPosRemove == type(uint256).max) {\n                    amountPosRemove = IERC20Upgradeable(crvLp).balanceOf(\n                        address(this)\n                    );\n                }\n\n                // 4. Remove liquidity\n                _removeLiquidity(\n                    param,\n                    isKilled,\n                    pool,\n                    tokens,\n                    pos,\n                    amountPosRemove\n                );\n            }\n\n            if (isKilled) {\n                uint256 len = tokens.length;\n                for (uint256 i; i != len; ++i) {\n                    if (tokens[i] != pos.debtToken) {\n                        _swapOnParaswap(\n                            tokens[i],\n                            amounts[i + 1],\n                            swapDatas[i + 1]\n                        );\n                    }\n                }\n            }\n        }\n\n        // 5. Withdraw isolated collateral from Bank\n        _doWithdraw(param.collToken, param.amountShareWithdraw);\n\n        // 6. Repay\n        {\n            // Compute repay amount if MAX_INT is supplied (max debt)\n            uint256 amountRepay = param.amountRepay;\n            if (amountRepay == type(uint256).max) {\n                amountRepay = bank.currentPositionDebt(bank.POSITION_ID());\n            }\n            _doRepay(param.borrowToken, amountRepay);\n        }\n\n        _validateMaxLTV(param.strategyId);\n\n        // 7. Refund\n        _doRefund(param.borrowToken);\n        _doRefund(param.collToken);\n        _doRefund(CRV);\n    }\n\n    function _removeLiquidity(\n        ClosePosParam memory param,\n        bool isKilled,\n        address pool,\n        address[] memory tokens,\n        IBank.Position memory pos,\n        uint256 amountPosRemove\n    ) internal {\n        uint256 tokenIndex;\n        {\n            uint256 len = tokens.length;\n            for (uint256 i; i != len; ++i) {\n                if (tokens[i] == pos.debtToken) {\n                    tokenIndex = i;\n                    break;\n                }\n            }\n        }\n\n        if (isKilled) {\n            uint256 len = tokens.length;\n            if (len == 2) {\n                uint256[2] memory minOuts;\n                ICurvePool(pool).remove_liquidity(amountPosRemove, minOuts);\n            } else if (len == 3) {\n                uint256[3] memory minOuts;\n                ICurvePool(pool).remove_liquidity(amountPosRemove, minOuts);\n            } else if (len == 4) {\n                uint256[4] memory minOuts;\n                ICurvePool(pool).remove_liquidity(amountPosRemove, minOuts);\n            } else {\n                revert(\"Invalid pool length\");\n            }\n        } else {\n            ICurvePool(pool).remove_liquidity_one_coin(\n                amountPosRemove,\n                int128(uint128(tokenIndex)),\n                param.amountOutMin\n            );\n        }\n    }\n\n    function _swapOnParaswap(\n        address token,\n        uint256 amount,\n        bytes calldata swapData\n    ) internal {\n        if (amount == 0) return;\n        if (\n            !PSwapLib.swap(\n                augustusSwapper,\n                tokenTransferProxy,\n                token,\n                amount,\n                swapData\n            )\n        ) revert Errors.SWAP_FAILED(token);\n\n        // Refund rest amount to owner\n        _doRefund(token);\n    }\n}"
    },
    {
      "filename": "blueberry-core/contracts/spell/ConvexSpell.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"./BasicSpell.sol\";\nimport \"../interfaces/ICurveOracle.sol\";\nimport \"../interfaces/IWConvexPools.sol\";\nimport \"../interfaces/curve/ICurvePool.sol\";\nimport \"../libraries/Paraswap/PSwapLib.sol\";\n\n/// @title ConvexSpell\n/// @author BlueberryProtocol\n/// @notice This contract serves as the factory for defining how the Blueberry Protocol \n///         interacts with Convex pools. It handles strategies, interactions with external contracts, \n///         and facilitates operations related to liquidity provision.\ncontract ConvexSpell is BasicSpell {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    /*//////////////////////////////////////////////////////////////////////////\n                                   PUBLIC STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Address of the Wrapped Convex Pools\n    IWConvexPools public wConvexPools;\n    /// @dev address of CurveOracle to retrieve pool information\n    ICurveOracle public crvOracle;\n    /// @dev address of CVX token\n    address public CVX;\n\n    /// @dev paraswap AugustusSwapper address for token swaps\n    address public augustusSwapper;\n    /// @dev paraswap TokenTransferProxy address for efficient token transfers\n    address public tokenTransferProxy;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n        \n    /// @notice Initializes the ConvexSpell contract with required parameters.\n    /// @param bank_ Address of the bank contract.\n    /// @param werc20_ Address of the wrapped ERC20 contract.\n    /// @param weth_ Address of the wrapped Ethereum contract.\n    /// @param wConvexPools_ Address of the wrapped Convex pools contract.\n    /// @param crvOracle_ Address of the Curve Oracle contract.\n    /// @param augustusSwapper_ Address of the paraswap AugustusSwapper.\n    /// @param tokenTransferProxy_ Address of the paraswap TokenTransferProxy.\n    function initialize(\n        IBank bank_,\n        address werc20_,\n        address weth_,\n        address wConvexPools_,\n        address crvOracle_,\n        address augustusSwapper_,\n        address tokenTransferProxy_\n    ) external initializer {\n        __BasicSpell_init(bank_, werc20_, weth_);\n        if (wConvexPools_ == address(0) || crvOracle_ == address(0))\n            revert Errors.ZERO_ADDRESS();\n\n        wConvexPools = IWConvexPools(wConvexPools_);\n        CVX = address(wConvexPools.CVX());\n        crvOracle = ICurveOracle(crvOracle_);\n        IWConvexPools(wConvexPools_).setApprovalForAll(address(bank_), true);\n\n        augustusSwapper = augustusSwapper_;\n        tokenTransferProxy = tokenTransferProxy_;\n    }\n\n    /// @notice Adds a new strategy to the spell.\n    /// @param crvLp Address of the Curve LP token for the strategy.\n    /// @param minPosSize Minimum position size in USD for the strategy (with 1e18 precision).\n    /// @param maxPosSize Maximum position size in USD for the strategy (with 1e18 precision).\n    function addStrategy(\n        address crvLp,\n        uint256 minPosSize,\n        uint256 maxPosSize\n    ) external onlyOwner {\n        _addStrategy(crvLp, minPosSize, maxPosSize);\n    }\n\n    /// @notice Adds liquidity to a Curve pool with two underlying tokens and stakes in Curve gauge.\n    /// @param param Struct containing all required parameters for opening a position.\n    /// @param minLPMint Minimum LP tokens expected to mint for slippage control.\n    function openPositionFarm(\n        OpenPosParam calldata param,\n        uint256 minLPMint\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        Strategy memory strategy = strategies[param.strategyId];\n        (address lpToken, , , , , ) = wConvexPools.getPoolInfoFromPoolId(\n            param.farmingPoolId\n        );\n        if (strategy.vault != lpToken) revert Errors.INCORRECT_LP(lpToken);\n\n        /// 1. Deposit isolated collaterals on Blueberry Money Market\n        _doLend(param.collToken, param.collAmount);\n\n        /// 2. Borrow specific amounts\n        uint256 borrowBalance = _doBorrow(\n            param.borrowToken,\n            param.borrowAmount\n        );\n\n        /// 3. Add liquidity on curve, get crvLp\n        (address pool, address[] memory tokens, ) = crvOracle.getPoolInfo(\n            lpToken\n        );\n        _ensureApprove(param.borrowToken, pool, borrowBalance);\n        if (tokens.length == 2) {\n            uint256[2] memory suppliedAmts;\n            for (uint256 i; i != 2; ++i) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        } else if (tokens.length == 3) {\n            uint256[3] memory suppliedAmts;\n            for (uint256 i; i != 3; ++i) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        } else {\n            uint256[4] memory suppliedAmts;\n            for (uint256 i; i != 4; ++i) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        }\n\n        /// 4. Validate MAX LTV\n        _validateMaxLTV(param.strategyId);\n\n        /// 5. Validate Max Pos Size\n        _validatePosSize(param.strategyId);\n        /// 6. Take out existing collateral and burn\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collateralSize > 0) {\n            (uint256 pid, ) = wConvexPools.decodeId(pos.collId);\n            if (param.farmingPoolId != pid)\n                revert Errors.INCORRECT_PID(param.farmingPoolId);\n            if (pos.collToken != address(wConvexPools))\n                revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n            bank.takeCollateral(pos.collateralSize);\n            (address[] memory rewardTokens, ) = wConvexPools.burn(pos.collId, pos.collateralSize);\n            // distribute multiple rewards to users\n            uint256 tokensLength = rewardTokens.length;\n            for (uint256 i; i != tokensLength; ++i) {\n                _doRefundRewards(rewardTokens[i]);\n            }\n        }\n\n        /// 7. Deposit on Convex Pool, Put wrapped collateral tokens on Blueberry Bank\n        uint256 lpAmount = IERC20Upgradeable(lpToken).balanceOf(address(this));\n        _ensureApprove(lpToken, address(wConvexPools), lpAmount);\n        uint256 id = wConvexPools.mint(param.farmingPoolId, lpAmount);\n        bank.putCollateral(address(wConvexPools), id, lpAmount);\n    }\n\n    /// @notice Closes an existing liquidity position, unstakes from Curve gauge, and swaps rewards.\n    /// @param param Struct containing all required parameters for closing a position.\n    /// @param expectedRewards List of expected reward amounts for each token.\n    /// @param swapDatas Swap data for each reward token.\n    function closePositionFarm(\n        ClosePosParam calldata param,\n        uint256[] calldata expectedRewards,\n        bytes[] calldata swapDatas\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        address crvLp = strategies[param.strategyId].vault;\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collToken != address(wConvexPools))\n            revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n        if (wConvexPools.getUnderlyingToken(pos.collId) != crvLp)\n            revert Errors.INCORRECT_UNDERLYING(crvLp);\n\n        uint256 amountPosRemove = param.amountPosRemove;\n\n        /// 1. Take out collateral - Burn wrapped tokens, receive crv lp tokens and harvest CRV\n        bank.takeCollateral(amountPosRemove);\n        (address[] memory rewardTokens, ) = wConvexPools.burn(\n            pos.collId,\n            amountPosRemove\n        );\n\n        /// 2. Swap rewards tokens to debt token\n        _sellRewards(rewardTokens, expectedRewards, swapDatas);\n\n        /// 3. Remove liquidity\n        _removeLiquidity(param, pos, crvLp, amountPosRemove);\n\n        /// 4. Withdraw isolated collateral from Bank\n        _doWithdraw(param.collToken, param.amountShareWithdraw);\n\n        /// 5. Repay\n        {\n            /// Comput"
    }
  ]
}