{
  "Title": "[H-27] Lack of a return value handing in `ArbitrumBranchBridgeAgent._performCall()` could cause users' deposit to be locked in contract",
  "Content": "\nIn `ArbitrumBranchBridgeAgent`, the `_performCall()` is overridden to directly call `RootBridgeAgent.anyExecute()` instead of performing an ``AnyCall`` cross-chain transaction, as `RootBridgeAgent` is also in Arbitrum. However, unlike ``AnyCall``, `ArbitrumBranchBridgeAgent._performCall()` is missing the handling of a return value for `anyExecute()`.\n\n<https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/ArbitrumBranchBridgeAgent.sol#L143>\n\n```Solidity\n function _performCall(bytes memory _callData) internal override {\n        IRootBridgeAgent(rootBridgeAgentAddress).anyExecute(_callData);\n    }\n```\n\nThat is undesirable, as `RootBridgeAgent.anyExecute()` has a try/catch that prevents the revert from bubbling up. Instead, it expects `ArbitrumBranchBridgeAgent._performCall()` to revert when `success == false`, which is currently missing.\n\n<https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L1068-L1074>\n\n```Solidity\n            try RootBridgeAgentExecutor(bridgeAgentExecutorAddress).executeSignedWithDeposit(\n                address(userAccount), localRouterAddress, data, fromChainId\n            ) returns (bool, bytes memory res) {\n                (success, result) = (true, res);\n            } catch (bytes memory reason) {\n                result = reason;\n            }\n```\n\n### Impact\n\nWithout handling the scenario when `RootBridgeAgent.anyExecute()` returns false, `ArbitrumBranchBridgeAgent._performCall()` will continue the execution, even for failed calls and not revert due to the try/catch in `RootBridgeAgent.anyExecute()`.\n\nIn the worst case, users could lose their bridged deposit when they use `ArbitrumBranchBridgeAgent.callOutSignedAndBridge()` to interact with dApps and encountered failed calls.\n\nWhen failed calls to dApps occur, `ArbitrumBranchBridgeAgent.callOutSignedAndBridge()` is expected to revert the entire transaction and reverse the bridging of the deposit. However, due to the issue with `_performCall()`, the bridged deposit will not be reverted, thus locking up user funds in the contract. Furthermore, `RootBridgeAgent.anyExecute()` will mark the deposit transaction as executed in `executionHistory[]`, preventing any `retryDeposit()` or `retrieveDeposit()` attempts to recover the funds.\n\n### Proof of Concept\n\nAdd the following `MockContract` and test case to `ArbitrumBranchTest.t.sol` and run the test case:\n\n```Solidity\n    contract MockContract is Test {\n        function test() external {\n            require(false);\n        }\n    } \n\n    function testPeakboltArbCallOutWithDeposit() public {\n        //Set up\n        testAddLocalTokenArbitrum();\n\n        // deploy mock contract to call using multicall\n        MockContract mockContract = new MockContract();\n\n        //Prepare data\n        address outputToken;\n        uint256 amountOut;\n        uint256 depositOut;\n        bytes memory packedData;\n\n        {\n            outputToken = newArbitrumAssetGlobalAddress;\n            amountOut = 100 ether;\n            depositOut = 50 ether;\n\n            Multicall2.Call[] memory calls = new Multicall2.Call[](1);\n\n            //prepare for a call to MockContract.test(), which will revert\n            calls[0] = Multicall2.Call({target: address(mockContract), callData: abi.encodeWithSignature(\"test()\")});\n    \n            //Output Params\n            OutputParams memory outputParams = OutputParams(address(this), outputToken, amountOut, depositOut);\n\n            //toChain\n            uint24 toChain = rootChainId;\n\n            //RLP Encode Calldata\n            bytes memory data = abi.encode(calls, outputParams, toChain);\n\n            //Pack FuncId\n            packedData = abi.encodePacked(bytes1(0x02), data);\n        }\n\n        //Get some gas.\n        hevm.deal(address(this), 1 ether);\n\n        //Mint Underlying Token.\n        arbitrumNativeToken.mint(address(this), 100 ether);\n\n        //Approve spend by router\n        arbitrumNativeToken.approve(address(localPortAddress), 100 ether);\n\n        //Prepare deposit info\n        DepositInput memory depositInput = DepositInput({\n            hToken: address(newArbitrumAssetGlobalAddress),\n            token: address(arbitrumNativeToken),\n            amount: 100 ether,\n            deposit: 100 ether,\n            toChain: rootChainId\n        });\n\n        //Mock messaging layer fees\n        hevm.mockCall(\n            address(localAnyCongfig),\n            abi.encodeWithSignature(\"calcSrcFees(address,uint256,uint256)\", address(0), 0, 100),\n            abi.encode(0)\n        );\n\n        console2.log(\"Initial User Balance: %d\", arbitrumNativeToken.balanceOf(address(this)));\n\n        //Call Deposit function\n        arbitrumMulticallBridgeAgent.callOutSignedAndBridge{value: 1 ether}(packedData, depositInput, 0.5 ether);\n\n        // This shows that deposit entry is successfully created\n        testCreateDepositSingle(\n            arbitrumMulticallBridgeAgent,\n            uint32(1),\n            address(this),\n            address(newArbitrumAssetGlobalAddress),\n            address(arbitrumNativeToken),\n            100 ether,\n            100 ether,\n            1 ether,\n            0.5 ether\n        );\n\n        // The following shows that the user deposited to the LocalPort, but it is not deposited/bridged to the user account\n        console2.log(\"LocalPort Balance (expected):\", uint256(50 ether));\n        console2.log(\"LocalPort Balance (actual):\", MockERC20(arbitrumNativeToken).balanceOf(address(localPortAddress)));\n        //require(MockERC20(arbitrumNativeToken).balanceOf(address(localPortAddress)) == 50 ether, \"LocalPort should have 50 tokens\");\n\n        console2.log(\"User Balance: (expected)\", uint256(50 ether));\n        console2.log(\"User Balance: (actual)\", MockERC20(arbitrumNativeToken).balanceOf(address(this)));\n        //require(MockERC20(arbitrumNativeToken).balanceOf(address(this)) == 50 ether, \"User should have 50 tokens\");\n\n        console2.log(\"User Global Balance: (expected)\", uint256(50 ether));\n        console2.log(\"User Global Balance: (actual)\", MockERC20(newArbitrumAssetGlobalAddress).balanceOf(address(this)));\n        //require(MockERC20(newArbitrumAssetGlobalAddress).balanceOf(address(this)) == 50 ether, \"User should have 50 global tokens\");\n\n        // retryDeposit() will fail as well as the transaction is marked executed in executionHistory\n        uint32 depositNonce = arbitrumMulticallBridgeAgent.depositNonce() - 1;\n        hevm.deal(address(this), 1 ether);\n        //hevm.expectRevert(abi.encodeWithSignature(\"GasErrorOrRepeatedTx()\"));\n        arbitrumMulticallBridgeAgent.retryDeposit{value: 1 ether}(true, depositNonce, \"\", 0.5 ether, rootChainId);\n\n    }\n```\n\n### Recommended Mitigation Steps\n\nHandle the return value of `anyExecute()` in `_performCall()` and revert on `success == false`.\n\n**[0xBugsy (Maia) confirmed](https://github.com/code-423n4/2023-05-maia-findings/issues/266#issuecomment-1632542251)**\n\n**[0xLightt (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/266#issuecomment-1709931154):**\n > Addressed [here](https://github.com/Maia-DAO/eco-c4-contest/tree/266).\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/ulysses-omnichain/ArbitrumBranchBridgeAgent.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {WETH9} from \"./interfaces/IWETH9.sol\";\n\nimport {AnycallFlags} from \"./lib/AnycallFlags.sol\";\nimport {IAnycallProxy} from \"./interfaces/IAnycallProxy.sol\";\nimport {IAnycallConfig} from \"./interfaces/IAnycallConfig.sol\";\nimport {IAnycallExecutor} from \"./interfaces/IAnycallExecutor.sol\";\n\nimport {ERC20hTokenBranch as ERC20hToken} from \"./token/ERC20hTokenBranch.sol\";\nimport {IBranchRouter as IRouter} from \"./interfaces/IBranchRouter.sol\";\nimport {IArbitrumBranchPort as IArbPort} from \"./interfaces/IArbitrumBranchPort.sol\";\nimport {IRootBridgeAgent} from \"./interfaces/IRootBridgeAgent.sol\";\n\nimport {\n    IBranchBridgeAgent,\n    IApp,\n    Deposit,\n    DepositStatus,\n    DepositInput,\n    DepositMultipleInput,\n    DepositParams,\n    DepositMultipleParams,\n    SettlementParams,\n    SettlementMultipleParams\n} from \"./interfaces/IBranchBridgeAgent.sol\";\n\nimport {BranchBridgeAgent} from \"./BranchBridgeAgent.sol\";\nimport {BranchBridgeAgentExecutor, DeployBranchBridgeAgentExecutor} from \"./BranchBridgeAgentExecutor.sol\";\n\nlibrary DeployArbitrumBranchBridgeAgent {\n    function deploy(\n        WETH9 _wrappedNativeToken,\n        uint256 _localChainId,\n        address _daoAddress,\n        address _localAnyCallAddress,\n        address _localAnyCallExecutorAddress,\n        address _localPortAddress,\n        address _localRouterAddress\n    ) external returns (ArbitrumBranchBridgeAgent) {\n        return new ArbitrumBranchBridgeAgent(\n            _wrappedNativeToken,\n            _localChainId,\n            _daoAddress,\n            _localAnyCallAddress,\n            _localAnyCallExecutorAddress,\n            _localPortAddress,\n            _localRouterAddress\n        );\n    }\n}\n\n/**\n * @title  Manages bridging transactions between root and Arbitrum branch\n * @author MaiaDAO\n * @notice This contract is used for interfacing with Users/Routers acting as a middleman\n *         to access Anycall cross-chain messaging and Port communication for asset management\n *         connecting Arbitrum Branch Chain contracts and the root omnichain environment.\n * @dev    Execution gas from remote interactions is managed by `RootBridgeAgent` contract.\n */\ncontract ArbitrumBranchBridgeAgent is BranchBridgeAgent {\n    using SafeTransferLib for address;\n    using SafeTransferLib for ERC20;\n\n    constructor(\n        WETH9 _wrappedNativeToken,\n        uint256 _localChainId,\n        address _rootBridgeAgentAddress,\n        address _localAnyCallAddress,\n        address _localAnyCallExecutorAddress,\n        address _localRouterAddress,\n        address _localPortAddress\n    )\n        BranchBridgeAgent(\n            _wrappedNativeToken,\n            _localChainId,\n            _localChainId,\n            _rootBridgeAgentAddress,\n            _localAnyCallAddress,\n            _localAnyCallExecutorAddress,\n            _localRouterAddress,\n            _localPortAddress\n        )\n    {}\n\n    /*///////////////////////////////////////////////////////////////\n                    LOCAL USER EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function to deposit a single asset to the local Port.\n     *   @param underlyingAddress address of the underlying asset to be deposited.\n     *   @param amount amount to be deposited.\n     *\n     */\n    function depositToPort(address underlyingAddress, uint256 amount) external payable lock {\n        IArbPort(localPortAddress).depositToPort(\n            msg.sender, msg.sender, underlyingAddress, _normalizeDecimals(amount, ERC20(underlyingAddress).decimals())\n        );\n    }\n\n    /**\n     * @notice Function to withdraw a single asset to the local Port.\n     *   @param localAddress local hToken to be withdrawn.\n     *   @param amount amount to be withdrawn.\n     *\n     */\n    function withdrawFromPort(address localAddress, uint256 amount) external payable lock {\n        IArbPort(localPortAddress).withdrawFromPort(msg.sender, msg.sender, localAddress, amount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Internal function to move gas to RootBridgeAgent for remote chain execution.\n     *   @param _gasToBridgeOut amount of gas to be deposited.\n     */\n    function _depositGas(uint128 _gasToBridgeOut) internal override {\n        address(wrappedNativeToken).safeTransfer(rootBridgeAgentAddress, _gasToBridgeOut);\n    }\n\n    /**\n     * @notice Reverts the current transaction with a \"no enough budget\" message.\n     * @dev This function is used to revert the current transaction with a \"no enough budget\" message.\n     */\n    function _forceRevert() internal pure override {\n        revert GasErrorOrRepeatedTx();\n    }\n\n    /**\n     * @notice Internal function performs call to AnycallProxy Contract for cross-chain messaging.\n     *   @param _callData bytes of the call to be sent to the AnycallProxy.\n     */\n    function _performCall(bytes memory _callData) internal override {\n        IRootBridgeAgent(rootBridgeAgentAddress).anyExecute(_callData);\n    }\n\n    /**\n     * @notice Internal that clears gas allocated for usage with remote request\n     */\n    function _gasSwapIn(bytes memory gasData) internal override returns (uint256 gasAmount) {\n        //Gas already provided by Root Bridge Agent\n    }\n\n    /**\n     * @notice Internal function to pay for execution gas. Overwritten Gas is processed by Root Bridge Agent contract - `depositedGas` is used to pay for execution and `gasToBridgeOut`is cleared to recipient.\n     */\n    function _payExecutionGas(address _recipient, uint256) internal override {\n        //Get gas remaining\n        uint256 gasRemaining = wrappedNativeToken.balanceOf(address(this));\n\n        if (gasRemaining > 0) {\n            //Unwrap Gas\n            wrappedNativeToken.withdraw(gasRemaining);\n\n            //Transfer gas remaining to recipient\n            SafeTransferLib.safeTransferETH(_recipient, gasRemaining);\n        }\n\n        delete(remoteCallDepositedGas);\n    }\n\n    /**\n     * @notice Internal function to pay for fallback gas. Overwritten no cross-chain messaging fallback between Arbitrum Branch Bridge Agent and Root Bridge Agent.\n     */\n    function _payFallbackGas(uint32, uint256) internal override {\n        //Cross-chain messaging + Fallback is managed by the Root Bridge Agent\n    }\n\n    /**\n     * @notice Internal function to deposit gas to the AnycallProxy. Cross-chain messaging + Gas is managed by the Root Bridge Agent\n     */\n    function _replenishGas(uint256) internal override {}\n\n    /// @notice Verifies the caller is the Anycall Executor. Internal function used in modifier to reduce contract bytesize.\n    function _requiresExecutor() internal view override {\n        if (msg.sender != rootBridgeAgentAddress) revert AnycallUnauthorizedCaller();\n    }\n\n    /// @notice Verifies enough gas is deposited to pay for an eventual fallback call. Reuse to reduce contract bytesize.\n    function _requiresFallbackGas() internal view override {\n        //Cross-chain messaging + Fallback is managed by the Root Bridge Agent\n    }\n\n    /// @notice Verifies enough gas is deposited to pay for an eventual fallback call.\n    function _requiresFallbackGas(uint256) internal view override {\n        //Cross-chain messaging + Fallback is managed by the Root Bridge Agent\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error GasErrorOrRepeatedTx();\n}"
    },
    {
      "filename": "src/ulysses-omnichain/RootBridgeAgent.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {WETH9} from \"./interfaces/IWETH9.sol\";\nimport {IUniswapV3Pool} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\n\nimport {AnycallFlags} from \"./lib/AnycallFlags.sol\";\n\nimport {IAnycallProxy} from \"./interfaces/IAnycallProxy.sol\";\nimport {IAnycallConfig} from \"./interfaces/IAnycallConfig.sol\";\nimport {IAnycallExecutor} from \"./interfaces/IAnycallExecutor.sol\";\n\nimport {IApp, IRootBridgeAgent} from \"./interfaces/IRootBridgeAgent.sol\";\nimport {IBranchBridgeAgent} from \"./interfaces/IBranchBridgeAgent.sol\";\nimport {IERC20hTokenRoot} from \"./interfaces/IERC20hTokenRoot.sol\";\nimport {IRootPort as IPort} from \"./interfaces/IRootPort.sol\";\nimport {IRootRouter as IRouter} from \"./interfaces/IRootRouter.sol\";\n\nimport {VirtualAccount} from \"./VirtualAccount.sol\";\nimport {\n    IRootBridgeAgent,\n    DepositParams,\n    DepositMultipleParams,\n    Settlement,\n    SettlementStatus,\n    SettlementParams,\n    SettlementMultipleParams,\n    UserFeeInfo,\n    SwapCallbackData\n} from \"./interfaces/IRootBridgeAgent.sol\";\n\nimport {DeployRootBridgeAgentExecutor, RootBridgeAgentExecutor} from \"./RootBridgeAgentExecutor.sol\";\n\n/// @title Library for Cross Chain Deposit Parameters Validation.\nlibrary CheckParamsLib {\n    /**\n     * @notice Function to check cross-chain deposit parameters and verify deposits made on branch chain are valid.\n     * @param _localPortAddress Address of local Port.\n     * @param _dParams Cross Chain swap parameters.\n     * @param _fromChain Chain ID of the chain where the deposit was made.\n     * @dev Local hToken must be recognized and address must match underlying if exists otherwise only local hToken is checked.\n     *\n     */\n    function checkParams(address _localPortAddress, DepositParams memory _dParams, uint24 _fromChain)\n        internal\n        view\n        returns (bool)\n    {\n        if (\n            (_dParams.amount < _dParams.deposit) //Deposit can't be greater than amount.\n                || (_dParams.amount > 0 && !IPort(_localPortAddress).isLocalToken(_dParams.hToken, _fromChain)) //Check local exists.\n                || (_dParams.deposit > 0 && !IPort(_localPortAddress).isUnderlyingToken(_dParams.token, _fromChain)) //Check underlying exists.\n        ) {\n            return false;\n        }\n        return true;\n    }\n}\n\n/// @title Library for Root Bridge Agent Deployment.\nlibrary DeployRootBridgeAgent {\n    function deploy(\n        WETH9 _wrappedNativeToken,\n        uint24 _localChainId,\n        address _daoAddress,\n        address _localAnyCallAddress,\n        address _localAnyCallExecutorAddress,\n        address _localPortAddress,\n        address _localRouterAddress\n    ) external returns (RootBridgeAgent) {\n        return new RootBridgeAgent(\n            _wrappedNativeToken,\n            _localChainId,\n            _daoAddress,\n            _localAnyCallAddress,\n            _localAnyCallExecutorAddress,\n            _localPortAddress,\n            _localRouterAddress\n        );\n    }\n}\n\n/// @title  Root Bridge Agent Contract\ncontract RootBridgeAgent is IRootBridgeAgent {\n    using SafeTransferLib for address;\n    using SafeCastLib for uint256;\n\n    /*///////////////////////////////////////////////////////////////\n                            ENCODING CONSTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// AnyExec Consts\n\n    uint8 internal constant PARAMS_START = 1;\n\n    uint8 internal constant PARAMS_START_SIGNED = 21;\n\n    uint8 internal constant PARAMS_ADDRESS_SIZE = 20;\n\n    uint8 internal constant PARAMS_GAS_IN = 32;\n\n    uint8 internal constant PARAMS_GAS_OUT = 16;\n\n    /// BridgeIn Consts\n\n    uint8 internal constant PARAMS_TKN_START = 5;\n\n    uint8 internal constant PARAMS_AMT_OFFSET = 64;\n\n    uint8 internal constant PARAMS_DEPOSIT_OFFSET = 96;\n\n    /*///////////////////////////////////////////////////////////////\n                        ROOT BRIDGE AGENT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Local Chain Id\n    uint24 public immutable localChainId;\n\n    /// @notice Local Wrapped Native Token\n    WETH9 public immutable wrappedNativeToken;\n\n    /// @notice Bridge Agent Factory Address.\n    address public immutable factoryAddress;\n\n    /// @notice Address of DAO.\n    address public immutable daoAddress;\n\n    /// @notice Local Core Root Router Address\n    address public immutable localRouterAddress;\n\n    /// @notice Address for Local Port Address where funds deposited from this chain are stored.\n    address public immutable localPortAddress;\n\n    /// @notice Local Anycall Address\n    address public immutable localAnyCallAddress;\n\n    /// @notice Local Anyexec Address\n    address public immutable localAnyCallExecutorAddress;\n\n    /// @notice Address of Root Bridge Agent Executor.\n    address public immutable bridgeAgentExecutorAddress;\n\n    /*///////////////////////////////////////////////////////////////\n                    BRANCH BRIDGE AGENTS STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Chain -> Branch Bridge Agent Address. For N chains, each Root Bridge Agent Address has M =< N Branch Bridge Agent Address.\n    mapping(uint256 => address) public getBranchBridgeAgent;\n\n    /// @notice If true, bridge agent manager has allowed for a new given branch bridge agent to be synced/added.\n    mapping(uint256 => bool) public isBranchBridgeAgentAllowed;\n\n    /*///////////////////////////////////////////////////////////////\n                        SETTLEMENTS STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Deposit nonce used for identifying transaction.\n    uint32 public settlementNonce;\n\n    /// @notice Mapping from Settlement nonce to Deposit Struct.\n    mapping(uint32 => Settlement) public getSettlement;\n\n    /*///////////////////////////////////////////////////////////////\n                            EXECUTOR STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice If true, bridge agent has already served a request with this nonce from  a given chain. Chain -> Nonce -> Bool\n    mapping(uint256 => mapping(uint32 => bool)) public executionHistory;\n\n    /*///////////////////////////////////////////////////////////////\n                        GAS MANAGEMENT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant MIN_FALLBACK_RESERVE = 155_000; // 100_000 for anycall + 55_000 for fallback\n    uint256 internal constant MIN_EXECUTION_OVERHEAD = 155_000; // 100_000 for anycall + 30_000 Pre 1st Gas Checkpoint Execution + 25_000 Post last Gas Checkpoint Execution\n\n    uint256 public initialGas;\n    UserFeeInfo public userFeeInfo;\n\n    /*///////////////////////////////////////////////////////////////\n                        DAO STATE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public accumulatedFees;\n\n    /**\n     * @notice Constructor for Bridge Agent.\n     *     @param _wrappedNativeToken Local Wrapped Native Token.\n     *     @param _daoAddress Address of DAO.\n     *     @param _localChainId Local Chain Id.\n     *     @param _localAnyCallAddress Local Anycall Address.\n     *     @param _localPortAddress Local Port Address.\n     *     @param _localRouterAddress Local Port Address.\n     */\n    constructor(\n        WETH9 _wrappedNativeToken,\n        uint24 _localChainId,\n        address _daoAddress,\n        address _localAnyCallAddress,\n        address _localAnyCallExecutorAddress,\n        address _localPortAddress,\n        address _localRouterAddress\n    ) {\n        require(address(_wrappedNativeToken) != address(0), \"Wrapped native token cannot be zero address\");\n        require(_daoAddress != address(0), \"DAO cannot be zero address\");\n        require(_localAnyCallAddress != address(0), \"Anycall Address cannot be zero address\");\n        require(_localAnyCallExecutorAddress != address(0), \"Anycall Executor Address cannot be zero address\");\n        require(_localPortAddress != address(0), \"Port Address cannot be zero address\");\n        require(_localRouterAddress != address(0), \"Router Address cannot be zero address\");\n\n        wrappedNativeToken = _wrappedNativeToken;\n        factoryAddress = msg.sender;\n        daoAddress = _daoAddress;\n        localChainId = _localChainId;\n        localAnyCallAddress = _localAnyCallAddress;\n        localPortAddress = _localPortAddress;\n        localRouterAddress = _localRouterAddress;\n        bridgeAgentExecutorAddress = DeployRootBridgeAgentExecutor.deploy(address(this));\n        localAnyCallExecutorAddress = _localAnyCallExecutorAddress;\n        settlementNonce = 1;\n        accumulatedFees = 1; //Avoid paying 20k gas in first `payExecutionGas` making MIN_EXECUTION_OVERHEAD constant.\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        VIEW EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootBridgeAgent\n    function getSettlementEntry(uint32 _settlementNonce) external view returns (Settlement memory) {\n        return getSettlement[_settlementNonce];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        USER EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootBridgeAgent\n    function retrySettlement(uint32 _settlementNonce, uint128 _remoteExecutionGas) external payable {\n        //Update User Gas available.\n        if (initialGas == 0) {\n            userFeeInfo.depositedGas = uint128(msg.value);\n            userFeeInfo.gasToBridgeOut = _remoteExecutionGas;\n        }\n        //Clear Settlement with updated gas.\n        _retrySettlement(_settlementNonce);\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function redeemSettlement(uint32 _depositNonce) external lock {\n        //Get deposit owner.\n        address depositOwner = getSettlement[_depositNonce].owner;\n\n        //Update Deposit\n        if (getSettlement[_depositNonce].status != SettlementStatus.Failed || depositOwner == address(0)) {\n            revert SettlementRedeemUnavailable();\n        } else if (\n            msg.sender != depositOwner && msg.sender != address(IPort(localPortAddress).getUserAccount(depositOwner))\n        ) {\n            revert NotSettlementOwner();\n        }\n        _redeemSettlement(_depositNonce);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    ROOT ROUTER EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootBridgeAgent\n    function callOut(address _recipient, bytes memory _data, uint24 _toChain) external payable lock requiresRouter {\n        //Encode Data for call.\n        bytes memory data =\n            abi.encodePacked(bytes1(0x00), _recipient, settlementNonce++, _data, _manageGasOut(_toChain));\n\n        //Perform Call to clear hToken balance on destination branch chain.\n        _performCall(data, _toChain);\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function callOutAndBridge(\n        address _owner,\n        address _recipient,\n        bytes memory _data,\n        address _globalAddress,\n        uint256 _amount,\n        uint256 _deposit,\n        uint24 _toChain\n    ) external payable lock requiresRouter {\n        //Get destination Local Address from Global Address.\n        address localAddress = IPort(localPortAddress).getLocalTokenFromGlobal(_globalAddress, _toChain);\n\n        //Get destination Underlying Address from Local Address.\n        address underlyingAddress = IPort(localPortAddress).getUnderlyingTokenFromLocal(localAddress, _toChain);\n\n        //Check if valid assets\n        if (localAddress == address(0) || (underlyingAddress == address(0) && _deposit > 0)) {\n            revert InvalidInputParams();\n        }\n\n        //Prepare data for call\n        bytes memory data = abi.encodePacked(\n            bytes1(0x01),\n            _recipient,\n            settlementNonce,\n            localAddress,\n            underlyingAddress,\n            _amount,\n            _deposit,\n            _data,\n            _manageGasOut(_toChain)\n        );\n\n        //Update State to reflect bridgeOut\n        _updateStateOnBridgeOut(\n            msg.sender, _globalAddress, localAddress, underlyingAddress, _amount, _deposit, _toChain\n        );\n\n        //Create Settlement\n        _createSettlement(_owner, _recipient, localAddress, underlyingAddress, _amount, _deposit, data, _toChain);\n\n        //Perform Call to clear hToken balance on destination branch chain and perform call.\n        _performCall(data, _toChain);\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function callOutAndBridgeMultiple(\n        address _owner,\n        address _recipient,\n        bytes memory _data,\n        address[] memory _globalAddresses,\n        uint256[] memory _amounts,\n        uint256[] memory _deposits,\n        uint24 _toChain\n    ) external payable lock requiresRouter {\n        address[] memory hTokens = new address[](_globalAddresses.length);\n        address[] memory tokens = new address[](_globalAddresses.length);\n        for (uint256 i = 0; i < _globalAddresses.length;) {\n            //Populate Addresses for Settlement\n            hTokens[i] = IPort(localPortAddress).getLocalTokenFromGlobal(_globalAddresses[i], _toChain);\n            tokens[i] = IPort(localPortAddress).getUnderlyingTokenFromLocal(hTokens[i], _toChain);\n\n            if (hTokens[i] == address(0) || (tokens[i] == address(0) && _deposits[i] > 0)) revert InvalidInputParams();\n\n            _updateStateOnBridgeOut(\n                msg.sender, _globalAddresses[i], hTokens[i], tokens[i], _amounts[i], _deposits[i], _toChain\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        //Prepare data for call with settlement of multiple assets\n        bytes memory data = abi.encodePacked(\n            bytes1(0x02),\n            _recipient,\n            uint8(hTokens.length),\n            settlementNonce,\n            hTokens,\n            tokens,\n            _amounts,\n            _deposits,\n            _data,\n            _manageGasOut(_toChain)\n        );\n\n        //Create Settlement Balance\n        _createMultipleSettlement(_owner, _recipient, hTokens, tokens, _amounts, _deposits, data, _toChain);\n\n        //Perform Call to destination Branch Chain.\n        _performCall(data, _toChain);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    TOKEN MANAGEMENT EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootBridgeAgent\n    function bridgeIn(address _recipient, DepositParams memory _dParams, uint24 _fromChain)\n        public\n        requiresAgentExecutor\n    {\n        //Check Deposit info from Cross Chain Parameters.\n        if (!CheckParamsLib.checkParams(localPortAddress, _dParams, _fromChain)) {\n            revert InvalidInputParams();\n        }\n\n        //Get global address\n        address globalAddress = IPort(localPortAddress).getGlobalTokenFromLocal(_dParams.hToken, _fromChain);\n\n        //Check if valid asset\n        if (globalAddress == address(0)) revert InvalidInputParams();\n\n        //Move hTokens from Branch to Root + Mint Sufficient hTokens to match new port deposit\n        IPort(localPortAddress).bridgeToRoot(_recipient, globalAddress, _dParams.amount, _dParams.deposit, _fromChain);\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function bridgeInMultiple(address _recipient, DepositMultipleParams memory _dParams, uint24 _fromChain)\n        external\n        requiresAgentExecutor\n    {\n        for (uint256 i = 0; i < _dParams.hTokens.length;) {\n            bridgeIn(\n                _recipient,\n                DepositParams({\n                    hToken: _dParams.hTokens[i],\n                    token: _dParams.tokens[i],\n                    amount: _dParams.amounts[i],\n                    deposit: _dParams.deposits[i],\n                    toChain: _dParams.toChain,\n                    depositNonce: 0\n                }),\n                _fromChain\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    TOKEN MANAGEMENT INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Updates the token balance state by moving assets from root omnichain environment to branch chain, when a user wants to bridge out tokens from the root bridge agent chain.\n     *     @param _sender address of the sender.\n     *     @param _globalAddress address of the global token.\n     *     @param _localAddress address of the local token.\n     *     @param _underlyingAddress address of the underlying token.\n     *     @param _amount amount of hTokens to be bridged out.\n     *     @param _deposit amount of underlying tokens to be bridged out.\n     *     @param _toChain chain to bridge to.\n     */\n    function _updateStateOnBridgeOut(\n        address _sender,\n        address _globalAddress,\n        address _localAddress,\n        address _underlyingAddress,\n        uint256 _amount,\n        uint256 _deposit,\n        uint24 _toChain\n    ) internal {\n        if (_amount - _deposit > 0) {\n            //Move output hTokens from Root to Branch\n            if (_localAddress == address(0)) revert UnrecognizedLocalAddress();\n            _globalAddress.safeTransferFrom(_sender, localPortAddress, _amount - _deposit);\n        }\n\n        if (_deposit > 0) {\n            //Verify there is enough balance to clear native tokens if needed\n            if (_underlyingAddress == address(0)) revert UnrecognizedUnderlyingAddress();\n            if (IERC20hTokenRoot(_globalAddress).getTokenBalance(_toChain) < _deposit) {\n                revert InsufficientBalanceForSettlement();\n            }\n            IPort(localPortAddress).burn(_sender, _globalAddress, _deposit, _toChain);\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                SETTLEMENT INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function to store a Settlement instance. Settlement should be reopened if fallback occurs.\n     *    @param _owner settlement owner address.\n     *    @param _recipient destination chain reciever address.\n     *    @param _hToken deposited global token address.\n     *    @param _token deposited global token address.\n     *    @param _amount amounts of total hTokens + Tokens output.\n     *    @param _deposit amount of underlying / native token to output.\n     *    @param _callData calldata to execute on destination Router.\n     *    @param _toChain Destination chain identificator.\n     *\n     */\n    function _createSettlement(\n        address _owner,\n        address _recipient,\n        address _hToken,\n        address _token,\n        uint256 _amount,\n        uint256 _deposit,\n        bytes memory _callData,\n        uint24 _toChain\n    ) internal {\n        //Cast to Dynamic\n        address[] memory hTokens = new address[](1);\n        hTokens[0] = _hToken;\n        address[] memory tokens = new address[](1);\n        tokens[0] = _token;\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = _amount;\n        uint256[] memory deposits = new uint256[](1);\n        deposits[0] = _deposit;\n\n        //Call createSettlement\n        _createMultipleSettlement(_owner, _recipient, hTokens, tokens, amounts, deposits, _callData, _toChain);\n    }\n\n    /**\n     * @notice Function to create a settlemment. Settlement should be reopened if fallback occurs.\n     *    @param _owner settlement owner address.\n     *    @param _recipient destination chain reciever address.\n     *    @param _hTokens deposited global token addresses.\n     *    @param _tokens deposited global token addresses.\n     *    @param _amounts amounts of total hTokens + Tokens output.\n     *    @param _deposits amount of underlying / native tokens to output.\n     *    @param _callData calldata to execute on destination Router.\n     *    @param _toChain Destination chain identificator.\n     *\n     *\n     */\n    function _createMultipleSettlement(\n        address _owner,\n        address _recipient,\n        address[] memory _hTokens,\n        address[] memory _tokens,\n        uint256[] memory _amounts,\n        uint256[] memory _deposits,\n        bytes memory _callData,\n        uint24 _toChain\n    ) internal {\n        // Update State\n        getSettlement[_getAndIncrementSettlementNonce()] = Settlement({\n            owner: _owner,\n            recipient: _recipient,\n            hTokens: _hTokens,\n            tokens: _tokens,\n            amounts: _amounts,\n            deposits: _deposits,\n            callData: _callData,\n            toChain: _toChain,\n            status: SettlementStatus.Success,\n            gasToBridgeOut: userFeeInfo.gasToBridgeOut\n        });\n    }\n\n    /**\n     * @notice Function to retry a user's Settlement balance with a new amount of gas to bridge out of Root Bridge Agent's Omnichain Environment.\n     *    @param _settlementNonce Identifier for token settlement.\n     *\n     */\n    function _retrySettlement(uint32 _settlementNonce) internal returns (bool) {\n        //Get Settlement\n        Settlement memory settlement = getSettlement[_settlementNonce];\n\n        //Check if Settlement hasn't been redeemed.\n        if (settlement.owner == address(0)) return false;\n\n        //abi encodePacked\n        bytes memory newGas = abi.encodePacked(_manageGasOut(settlement.toChain));\n\n        //overwrite last 16bytes of callData\n        for (uint256 i = 0; i < newGas.length;) {\n            settlement.callData[settlement.callData.length - 16 + i] = newGas[i];\n            unchecked {\n                ++i;\n            }\n        }\n\n        Settlement storage settlementReference = getSettlement[_settlementNonce];\n\n        //Update Gas To Bridge Out\n        settlementReference.gasToBridgeOut = userFeeInfo.gasToBridgeOut;\n\n        //Set Settlement Calldata to send to Branch Chain\n        settlementReference.callData = settlement.callData;\n\n        //Update Settlement Staus\n        settlementReference.status = SettlementStatus.Success;\n\n        //Retry call with additional gas\n        _performCall(settlement.callData, settlement.toChain);\n\n        //Retry Success\n        return true;\n    }\n\n    /**\n     * @notice Function to retry a user's Settlement balance.\n     *     @param _settlementNonce Identifier for token settlement.\n     *\n     */\n    function _redeemSettlement(uint32 _settlementNonce) internal {\n        // Get storage reference\n        Settlement storage settlement = getSettlement[_settlementNonce];\n\n        //Clear Global hTokens To Recipient on Root Chain cancelling Settlement to Branch\n        for (uint256 i = 0; i < settlement.hTokens.length;) {\n            //Check if asset\n            if (settlement.hTokens[i] != address(0)) {\n                //Move hTokens from Branch to Root + Mint Sufficient hTokens to match new port deposit\n                IPort(localPortAddress).bridgeToRoot(\n                    msg.sender,\n                    IPort(localPortAddress).getGlobalTokenFromLocal(settlement.hTokens[i], settlement.toChain),\n                    settlement.amounts[i],\n                    settlement.deposits[i],\n                    settlement.toChain\n                );\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Delete Settlement\n        delete getSettlement[_settlementNonce];\n    }\n\n    /**\n     * @notice Function to reopen a user's Settlement balance as pending and thus retryable by users. Called upon anyFallback of triggered by Branch Bridge Agent.\n     *     @param _settlementNonce Identifier for token settlement.\n     *\n     */\n    function _reopenSettlemment(uint32 _settlementNonce) internal {\n        //Update Deposit\n        getSettlement[_settlementNonce].status = SettlementStatus.Failed;\n    }\n\n    /**\n     * @notice Function that returns Deposit nonce and increments nonce counter.\n     *\n     */\n    function _getAndIncrementSettlementNonce() internal returns (uint32) {\n        return settlementNonce++;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    GAS SWAP INTERNAL FUNCTIONS\n    ///////////////////////////////////////////////////"
    }
  ]
}