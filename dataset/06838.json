{
  "Title": "[H-08] Staking, unstaking and rebalanceToWeight can be sandwiched (Mainly rETH deposit)",
  "Content": "\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L63-L101> <br>\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/Reth.sol#L228-L245> <br>\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/Reth.sol#L170-L183> <br>\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/WstEth.sol#L56-L66> <br>\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L108-L128> <br>\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/SfrxEth.sol#L74-L75>\n\n### Impact\n\nrETH derivative can be bought through uniswap if the deposit contract is not open.\n\nWhile a maxSlippage variable is set, the price of rETH on uniswap is the spot price and is only determined during the transaction opening sandwich opportunity for MEV researchers as long as the slippage stays below maxSlippage.\n\nThis is also true for WstETH (on withdraw) and frxETH (on deposit and withdraw) that go through a curve pool when unstaking (and staking for frxETH). While the curve pool has much more liquidity and the assumed price is a 1 - 1 ratio for WstETH and frxETH seem to be using a twap price before applying the slippage, these attacks are less likely to happen so I will only describe rETH.\n\n### Proof of Concept\n\nWhile the current rETH derivative contract uses uniswapv3 0,05% pool, I'll be using the uniswapv2 formula (<https://amm-calculator.vercel.app/>) to make this example simplier, in both case sandwiching is possible.\n\nDefault slippage is set to 1% on rETH contract at deployment. (see: <https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/Reth.sol#L44>)\n\nLet's take a pool of 10,000 rETH for 10,695 eth (same ratio is on the univ3 0,05% pool on the 26th of march).\n\nUser wants to stake 100ETH, a third of it will be staked through rETH according to a 1/3 weight for each derivative.\n\nBundle:\n\nTX1:\n\nResearcher swap 100 ETH in for 92.63 rETH<br>\nnew pool balance: 9907.36 rETH - 10795 ETH\n\nTX2:\n\nUser stake his ETH, the rocketPool deposit contract is close so the deposit function takes the current spot price of the pool and then applies 1% slippage to it to get minOut.\n\nCurrent ratio: eth = 0.9177 rETH<br>\nETH to swap for reth: 33.3333\\~<br>\nSo minOut -> 33.3333 &ast; 0.9177 &ast; 0.99 = 30.284 rETH\n\n(see: <https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/Reth.sol#L170-L183>)\n\nContract swap 33.3333 ETH for 30.498 rETH (slippage of 0.61% so below 1% and received more than minOut)\n\nNew pool balance: 9876.86 rETH - 10828.33 ETH\n\nTX3:\n\nResearcher swap back the 92.63 rETH in for 100.61\\~ ETH<br>\nnew pool balance: 9969.49 rETH - 10727.72 ETH\n\nResearcher made 0.61\\~ ETH of profit, could be more as we only applied a 0,61% slippage but we can go as far as 1% in the current rETH contract.\n\nUniv3 pool would could even worse as Researcher with a lot of liquidity could be able to drain one side (liquidity is very concentrated), add liquidity in a tight range execute the stake and then remove liquidity and swap back.\n\n### Recommended Mitigation Steps\n\nThe rETH price should be determined using the TWAP price and users should be able to input minOut in the stake, unstake and rebalanceToWeight function.\n\n**[Picodes (judge) increased severity to High](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/142#issuecomment-1518578752)**\n\n**[Asymmetry mitigated](https://github.com/code-423n4/2023-05-asymmetry-mitigation-contest#mitigations-to-be-reviewed):**\n> Using Chainlink to get price instead of poolPrice.<br>\n\n**Status:** Mitigation confirmed with comments. Full details in reports from [d3e4](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/35), [adriro](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/29), and [0x52](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/12).\n\n\n\n***\n\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-03-asymmetry",
  "Code": [
    {
      "filename": "contracts/SafEth/SafEth.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"../interfaces/uniswap/ISwapRouter.sol\";\nimport \"../interfaces/lido/IWStETH.sol\";\nimport \"../interfaces/lido/IstETH.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./SafEthStorage.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\n/// @title Contract that mints/burns and provides owner functions for safETH\n/// @author Asymmetry Finance\ncontract SafEth is\n    Initializable,\n    ERC20Upgradeable,\n    OwnableUpgradeable,\n    SafEthStorage\n{\n    event ChangeMinAmount(uint256 indexed minAmount);\n    event ChangeMaxAmount(uint256 indexed maxAmount);\n    event StakingPaused(bool indexed paused);\n    event UnstakingPaused(bool indexed paused);\n    event SetMaxSlippage(uint256 indexed index, uint256 slippage);\n    event Staked(address indexed recipient, uint ethIn, uint safEthOut);\n    event Unstaked(address indexed recipient, uint ethOut, uint safEthIn);\n    event WeightChange(uint indexed index, uint weight);\n    event DerivativeAdded(\n        address indexed contractAddress,\n        uint weight,\n        uint index\n    );\n    event Rebalanced();\n\n    // As recommended by https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n        @notice - Function to initialize values for the contracts\n        @dev - This replaces the constructor for upgradeable contracts\n        @param _tokenName - name of erc20\n        @param _tokenSymbol - symbol of erc20\n    */\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol\n    ) external initializer {\n        ERC20Upgradeable.__ERC20_init(_tokenName, _tokenSymbol);\n        _transferOwnership(msg.sender);\n        minAmount = 5 * 10 ** 17; // initializing with .5 ETH as minimum\n        maxAmount = 200 * 10 ** 18; // initializing with 200 ETH as maximum\n    }\n\n    /**\n        @notice - Stake your ETH into safETH\n        @dev - Deposits into each derivative based on its weight\n        @dev - Mints safEth in a redeemable value which equals to the correct percentage of the total staked value\n    */\n    function stake() external payable {\n        require(pauseStaking == false, \"staking is paused\");\n        require(msg.value >= minAmount, \"amount too low\");\n        require(msg.value <= maxAmount, \"amount too high\");\n\n        uint256 underlyingValue = 0;\n\n        // Getting underlying value in terms of ETH for each derivative\n        for (uint i = 0; i < derivativeCount; i++)\n            underlyingValue +=\n                (derivatives[i].ethPerDerivative(derivatives[i].balance()) *\n                    derivatives[i].balance()) /\n                10 ** 18;\n\n        uint256 totalSupply = totalSupply();\n        uint256 preDepositPrice; // Price of safETH in regards to ETH\n        if (totalSupply == 0)\n            preDepositPrice = 10 ** 18; // initializes with a price of 1\n        else preDepositPrice = (10 ** 18 * underlyingValue) / totalSupply;\n\n        uint256 totalStakeValueEth = 0; // total amount of derivatives worth of ETH in system\n        for (uint i = 0; i < derivativeCount; i++) {\n            uint256 weight = weights[i];\n            IDerivative derivative = derivatives[i];\n            if (weight == 0) continue;\n            uint256 ethAmount = (msg.value * weight) / totalWeight;\n\n            // This is slightly less than ethAmount because slippage\n            uint256 depositAmount = derivative.deposit{value: ethAmount}();\n            uint derivativeReceivedEthValue = (derivative.ethPerDerivative(\n                depositAmount\n            ) * depositAmount) / 10 ** 18;\n            totalStakeValueEth += derivativeReceivedEthValue;\n        }\n        // mintAmount represents a percentage of the total assets in the system\n        uint256 mintAmount = (totalStakeValueEth * 10 ** 18) / preDepositPrice;\n        _mint(msg.sender, mintAmount);\n        emit Staked(msg.sender, msg.value, mintAmount);\n    }\n\n    /**\n        @notice - Unstake your safETH into ETH\n        @dev - unstakes a percentage of safEth based on its total value\n        @param _safEthAmount - amount of safETH to unstake into ETH\n    */\n    function unstake(uint256 _safEthAmount) external {\n        require(pauseUnstaking == false, \"unstaking is paused\");\n        uint256 safEthTotalSupply = totalSupply();\n        uint256 ethAmountBefore = address(this).balance;\n\n        for (uint256 i = 0; i < derivativeCount; i++) {\n            // withdraw a percentage of each asset based on the amount of safETH\n            uint256 derivativeAmount = (derivatives[i].balance() *\n                _safEthAmount) / safEthTotalSupply;\n            if (derivativeAmount == 0) continue; // if derivative empty ignore\n            derivatives[i].withdraw(derivativeAmount);\n        }\n        _burn(msg.sender, _safEthAmount);\n        uint256 ethAmountAfter = address(this).balance;\n        uint256 ethAmountToWithdraw = ethAmountAfter - ethAmountBefore;\n        // solhint-disable-next-line\n        (bool sent, ) = address(msg.sender).call{value: ethAmountToWithdraw}(\n            \"\"\n        );\n        require(sent, \"Failed to send Ether\");\n        emit Unstaked(msg.sender, ethAmountToWithdraw, _safEthAmount);\n    }\n\n    /**\n        @notice - Rebalance each derivative to resemble the weight set for it\n        @dev - Withdraws all derivative and re-deposit them to have the correct weights\n        @dev - Depending on the balance of the derivative this could cause bad slippage\n        @dev - If weights are updated then it will slowly change over time to the correct weight distribution\n        @dev - Probably not going to be used often, if at all\n    */\n    function rebalanceToWeights() external onlyOwner {\n        uint256 ethAmountBefore = address(this).balance;\n        for (uint i = 0; i < derivativeCount; i++) {\n            if (derivatives[i].balance() > 0)\n                derivatives[i].withdraw(derivatives[i].balance());\n        }\n        uint256 ethAmountAfter = address(this).balance;\n        uint256 ethAmountToRebalance = ethAmountAfter - ethAmountBefore;\n\n        for (uint i = 0; i < derivativeCount; i++) {\n            if (weights[i] == 0 || ethAmountToRebalance == 0) continue;\n            uint256 ethAmount = (ethAmountToRebalance * weights[i]) /\n                totalWeight;\n            // Price will change due to slippage\n            derivatives[i].deposit{value: ethAmount}();\n        }\n        emit Rebalanced();\n    }\n\n    /**\n        @notice - Adds new derivative to the index fund\n        @dev - Weights are only in regards to each other, total weight changes with this function\n        @dev - If you want exact weights either do the math off chain or reset all existing derivates to the weights you want\n        @dev - Weights are approximate as it will slowly change as people stake\n        @param _derivativeIndex - index of the derivative you want to update the weight\n        @param _weight - new weight for this derivative.\n    */\n    function adjustWeight(\n        uint256 _derivativeIndex,\n        uint256 _weight\n    ) external onlyOwner {\n        weights[_derivativeIndex] = _weight;\n        uint256 localTotalWeight = 0;\n        for (uint256 i = 0; i < derivativeCount; i++)\n            localTotalWeight += weights[i];\n        totalWeight = localTotalWeight;\n        emit WeightChange(_derivativeIndex, _weight);\n    }\n\n    /**\n        @notice - Adds new derivative to the index fund\n        @param _contractAddress - Address of the derivative contract launched by AF\n        @param _weight - new weight for this derivative. \n    */\n    function addDerivative(\n        address _contractAddress,\n        uint256 _weight\n    ) external onlyOwner {\n        derivatives[derivativeCount] = IDerivative(_contractAddress);\n        weights[derivativeCount] = _weight;\n        derivativeCount++;\n\n        uint256 localTotalWeight = 0;\n        for (uint256 i = 0; i < derivativeCount; i++)\n            localTotalWeight += weights[i];\n        totalWeight = localTotalWeight;\n        emit DerivativeAdded(_contractAddress, _weight, derivativeCount);\n    }\n\n    /**\n        @notice - Sets the max slippage for a certain derivative index\n        @param _derivativeIndex - index of the derivative you want to update the slippage\n        @param _slippage - new slippage amount in wei\n    */\n    function setMaxSlippage(\n        uint _derivativeIndex,\n        uint _slippage\n    ) external onlyOwner {\n        derivatives[_derivativeIndex].setMaxSlippage(_slippage);\n        emit SetMaxSlippage(_derivativeIndex, _slippage);\n    }\n\n    /**\n        @notice - Sets the minimum amount a user is allowed to stake\n        @param _minAmount - amount to set as minimum stake value\n    */\n    function setMinAmount(uint256 _minAmount) external onlyOwner {\n        minAmount = _minAmount;\n        emit ChangeMinAmount(minAmount);\n    }\n\n    /**\n        @notice - Owner only function that sets the maximum amount a user is allowed to stake\n        @param _maxAmount - amount to set as maximum stake value\n    */\n    function setMaxAmount(uint256 _maxAmount) external onlyOwner {\n        maxAmount = _maxAmount;\n        emit ChangeMaxAmount(maxAmount);\n    }\n\n    /**\n        @notice - Owner only function that Enables/Disables the stake function\n        @param _pause - true disables staking / false enables staking\n    */\n    function setPauseStaking(bool _pause) external onlyOwner {\n        pauseStaking = _pause;\n        emit StakingPaused(pauseStaking);\n    }\n\n    /**\n        @notice - Owner only function that enables/disables the unstake function\n        @param _pause - true disables unstaking / false enables unstaking\n    */\n    function setPauseUnstaking(bool _pause) external onlyOwner {\n        pauseUnstaking = _pause;\n        emit UnstakingPaused(pauseUnstaking);\n    }\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/SafEth/derivatives/Reth.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"../../interfaces/IDerivative.sol\";\nimport \"../../interfaces/frax/IsFrxEth.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../interfaces/rocketpool/RocketStorageInterface.sol\";\nimport \"../../interfaces/rocketpool/RocketTokenRETHInterface.sol\";\nimport \"../../interfaces/rocketpool/RocketDepositPoolInterface.sol\";\nimport \"../../interfaces/rocketpool/RocketDAOProtocolSettingsDepositInterface.sol\";\nimport \"../../interfaces/IWETH.sol\";\nimport \"../../interfaces/uniswap/ISwapRouter.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"../../interfaces/uniswap/IUniswapV3Factory.sol\";\nimport \"../../interfaces/uniswap/IUniswapV3Pool.sol\";\n\n/// @title Derivative contract for rETH\n/// @author Asymmetry Finance\ncontract Reth is IDerivative, Initializable, OwnableUpgradeable {\n    address public constant ROCKET_STORAGE_ADDRESS =\n        0x1d8f8f00cfa6758d7bE78336684788Fb0ee0Fa46;\n    address public constant W_ETH_ADDRESS =\n        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant UNISWAP_ROUTER =\n        0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45;\n    address public constant UNI_V3_FACTORY =\n        0x1F98431c8aD98523631AE4a59f267346ea31F984;\n\n    uint256 public maxSlippage;\n\n    // As recommended by https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n        @notice - Function to initialize values for the contracts\n        @dev - This replaces the constructor for upgradeable contracts\n        @param _owner - owner of the contract which handles stake/unstake\n    */\n    function initialize(address _owner) external initializer {\n        _transferOwnership(_owner);\n        maxSlippage = (1 * 10 ** 16); // 1%\n    }\n\n    /**\n        @notice - Return derivative name\n    */\n    function name() public pure returns (string memory) {\n        return \"RocketPool\";\n    }\n\n    /**\n        @notice - Owner only function to set max slippage for derivative\n        @param _slippage - new slippage amount in wei\n    */\n    function setMaxSlippage(uint256 _slippage) external onlyOwner {\n        maxSlippage = _slippage;\n    }\n\n    /**\n        @notice - Get rETH address\n        @dev - per RocketPool Docs query addresses each time it is used\n     */\n    function rethAddress() private view returns (address) {\n        return\n            RocketStorageInterface(ROCKET_STORAGE_ADDRESS).getAddress(\n                keccak256(\n                    abi.encodePacked(\"contract.address\", \"rocketTokenRETH\")\n                )\n            );\n    }\n\n    /**\n        @notice - Swap tokens through Uniswap\n        @param _tokenIn - token to swap from\n        @param _tokenOut - token to swap to\n        @param _poolFee - pool fee for particular swap\n        @param _amountIn - amount of token to swap from\n        @param _minOut - minimum amount of token to receive (slippage)\n     */\n    function swapExactInputSingleHop(\n        address _tokenIn,\n        address _tokenOut,\n        uint24 _poolFee,\n        uint256 _amountIn,\n        uint256 _minOut\n    ) private returns (uint256 amountOut) {\n        IERC20(_tokenIn).approve(UNISWAP_ROUTER, _amountIn);\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter\n            .ExactInputSingleParams({\n                tokenIn: _tokenIn,\n                tokenOut: _tokenOut,\n                fee: _poolFee,\n                recipient: address(this),\n                amountIn: _amountIn,\n                amountOutMinimum: _minOut,\n                sqrtPriceLimitX96: 0\n            });\n        amountOut = ISwapRouter(UNISWAP_ROUTER).exactInputSingle(params);\n    }\n\n    /**\n        @notice - Convert derivative into ETH\n     */\n    function withdraw(uint256 amount) external onlyOwner {\n        RocketTokenRETHInterface(rethAddress()).burn(amount);\n        // solhint-disable-next-line\n        (bool sent, ) = address(msg.sender).call{value: address(this).balance}(\n            \"\"\n        );\n        require(sent, \"Failed to send Ether\");\n    }\n\n    /**\n        @notice - Check whether or not rETH deposit pool has room users amount\n        @param _amount - amount that will be deposited\n     */\n    function poolCanDeposit(uint256 _amount) private view returns (bool) {\n        address rocketDepositPoolAddress = RocketStorageInterface(\n            ROCKET_STORAGE_ADDRESS\n        ).getAddress(\n                keccak256(\n                    abi.encodePacked(\"contract.address\", \"rocketDepositPool\")\n                )\n            );\n        RocketDepositPoolInterface rocketDepositPool = RocketDepositPoolInterface(\n                rocketDepositPoolAddress\n            );\n\n        address rocketProtocolSettingsAddress = RocketStorageInterface(\n            ROCKET_STORAGE_ADDRESS\n        ).getAddress(\n                keccak256(\n                    abi.encodePacked(\n                        \"contract.address\",\n                        \"rocketDAOProtocolSettingsDeposit\"\n                    )\n                )\n            );\n        RocketDAOProtocolSettingsDepositInterface rocketDAOProtocolSettingsDeposit = RocketDAOProtocolSettingsDepositInterface(\n                rocketProtocolSettingsAddress\n            );\n\n        return\n            rocketDepositPool.getBalance() + _amount <=\n            rocketDAOProtocolSettingsDeposit.getMaximumDepositPoolSize() &&\n            _amount >= rocketDAOProtocolSettingsDeposit.getMinimumDeposit();\n    }\n\n    /**\n        @notice - Deposit into derivative\n        @dev - will either get rETH on exchange or deposit into contract depending on availability\n     */\n    function deposit() external payable onlyOwner returns (uint256) {\n        // Per RocketPool Docs query addresses each time it is used\n        address rocketDepositPoolAddress = RocketStorageInterface(\n            ROCKET_STORAGE_ADDRESS\n        ).getAddress(\n                keccak256(\n                    abi.encodePacked(\"contract.address\", \"rocketDepositPool\")\n                )\n            );\n\n        RocketDepositPoolInterface rocketDepositPool = RocketDepositPoolInterface(\n                rocketDepositPoolAddress\n            );\n\n        if (!poolCanDeposit(msg.value)) {\n            uint rethPerEth = (10 ** 36) / poolPrice();\n\n            uint256 minOut = ((((rethPerEth * msg.value) / 10 ** 18) *\n                ((10 ** 18 - maxSlippage))) / 10 ** 18);\n\n            IWETH(W_ETH_ADDRESS).deposit{value: msg.value}();\n            uint256 amountSwapped = swapExactInputSingleHop(\n                W_ETH_ADDRESS,\n                rethAddress(),\n                500,\n                msg.value,\n                minOut\n            );\n\n            return amountSwapped;\n        } else {\n            address rocketTokenRETHAddress = RocketStorageInterface(\n                ROCKET_STORAGE_ADDRESS\n            ).getAddress(\n                    keccak256(\n                        abi.encodePacked(\"contract.address\", \"rocketTokenRETH\")\n                    )\n                );\n            RocketTokenRETHInterface rocketTokenRETH = RocketTokenRETHInterface(\n                rocketTokenRETHAddress\n            );\n            uint256 rethBalance1 = rocketTokenRETH.balanceOf(address(this));\n            rocketDepositPool.deposit{value: msg.value}();\n            uint256 rethBalance2 = rocketTokenRETH.balanceOf(address(this));\n            require(rethBalance2 > rethBalance1, \"No rETH was minted\");\n            uint256 rethMinted = rethBalance2 - rethBalance1;\n            return (rethMinted);\n        }\n    }\n\n    /**\n        @notice - Get price of derivative in terms of ETH\n        @dev - we need to pass amount so that it gets price from the same source that it buys or mints the rEth\n        @param _amount - amount to check for ETH price\n     */\n    function ethPerDerivative(uint256 _amount) public view returns (uint256) {\n        if (poolCanDeposit(_amount))\n            return\n                RocketTokenRETHInterface(rethAddress()).getEthValue(10 ** 18);\n        else return (poolPrice() * 10 ** 18) / (10 ** 18);\n    }\n\n    /**\n        @notice - Total derivative balance\n     */\n    function balance() public view returns (uint256) {\n        return IERC20(rethAddress()).balanceOf(address(this));\n    }\n\n    /**\n        @notice - Price of derivative in liquidity pool\n     */\n    function poolPrice() private view returns (uint256) {\n        address rocketTokenRETHAddress = RocketStorageInterface(\n            ROCKET_STORAGE_ADDRESS\n        ).getAddress(\n                keccak256(\n                    abi.encodePacked(\"contract.address\", \"rocketTokenRETH\")\n                )\n            );\n        IUniswapV3Factory factory = IUniswapV3Factory(UNI_V3_FACTORY);\n        IUniswapV3Pool pool = IUniswapV3Pool(\n            factory.getPool(rocketTokenRETHAddress, W_ETH_ADDRESS, 500)\n        );\n        (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();\n        return (sqrtPriceX96 * (uint(sqrtPriceX96)) * (1e18)) >> (96 * 2);\n    }\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/SafEth/derivatives/Reth.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"../../interfaces/IDerivative.sol\";\nimport \"../../interfaces/frax/IsFrxEth.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../interfaces/rocketpool/RocketStorageInterface.sol\";\nimport \"../../interfaces/rocketpool/RocketTokenRETHInterface.sol\";\nimport \"../../interfaces/rocketpool/RocketDepositPoolInterface.sol\";\nimport \"../../interfaces/rocketpool/RocketDAOProtocolSettingsDepositInterface.sol\";\nimport \"../../interfaces/IWETH.sol\";\nimport \"../../interfaces/uniswap/ISwapRouter.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"../../interfaces/uniswap/IUniswapV3Factory.sol\";\nimport \"../../interfaces/uniswap/IUniswapV3Pool.sol\";\n\n/// @title Derivative contract for rETH\n/// @author Asymmetry Finance\ncontract Reth is IDerivative, Initializable, OwnableUpgradeable {\n    address public constant ROCKET_STORAGE_ADDRESS =\n        0x1d8f8f00cfa6758d7bE78336684788Fb0ee0Fa46;\n    address public constant W_ETH_ADDRESS =\n        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant UNISWAP_ROUTER =\n        0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45;\n    address public constant UNI_V3_FACTORY =\n        0x1F98431c8aD98523631AE4a59f267346ea31F984;\n\n    uint256 public maxSlippage;\n\n    // As recommended by https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n        @notice - Function to initialize values for the contracts\n        @dev - This replaces the constructor for upgradeable contracts\n        @param _owner - owner of the contract which handles stake/unstake\n    */\n    function initialize(address _owner) external initializer {\n        _transferOwnership(_owner);\n        maxSlippage = (1 * 10 ** 16); // 1%\n    }\n\n    /**\n        @notice - Return derivative name\n    */\n    function name() public pure returns (string memory) {\n        return \"RocketPool\";\n    }\n\n    /**\n        @notice - Owner only function to set max slippage for derivative\n        @param _slippage - new slippage amount in wei\n    */\n    function setMaxSlippage(uint256 _slippage) external onlyOwner {\n        maxSlippage = _slippage;\n    }\n\n    /**\n        @notice - Get rETH address\n        @dev - per RocketPool Docs query addresses each time it is used\n     */\n    function rethAddress() private view returns (address) {\n        return\n            RocketStorageInterface(ROCKET_STORAGE_ADDRESS).getAddress(\n                keccak256(\n                    abi.encodePacked(\"contract.address\", \"rocketTokenRETH\")\n                )\n            );\n    }\n\n    /**\n        @notice - Swap tokens through Uniswap\n        @param _tokenIn - token to swap from\n        @param _tokenOut - token to swap to\n        @param _poolFee - pool fee for particular swap\n        @param _amountIn - amount of token to swap from\n        @param _minOut - minimum amount of token to receive (slippage)\n     */\n    function swapExactInputSingleHop(\n        address _tokenIn,\n        address _tokenOut,\n        uint24 _poolFee,\n        uint256 _amountIn,\n        uint256 _minOut\n    ) private returns (uint256 amountOut) {\n        IERC20(_tokenIn).approve(UNISWAP_ROUTER, _amountIn);\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter\n            .ExactInputSingleParams({\n                tokenIn: _tokenIn,\n                tokenOut: _tokenOut,\n                fee: _poolFee,\n                recipient: address(this),\n                amountIn: _amountIn,\n                amountOutMinimum: _minOut,\n                sqrtPriceLimitX96: 0\n            });\n        amountOut = ISwapRouter(UNISWAP_ROUTER).exactInputSingle(params);\n    }\n\n    /**\n        @notice - Convert derivative into ETH\n     */\n    function withdraw(uint256 amount) external onlyOwner {\n        RocketTokenRETHInterface(rethAddress()).burn(amount);\n        // solhint-disable-next-line\n        (bool sent, ) = address(msg.sender).call{value: address(this).balance}(\n            \"\"\n        );\n        require(sent, \"Failed to send Ether\");\n    }\n\n    /**\n        @notice - Check whether or not rETH deposit pool has room users amount\n        @param _amount - amount that will be deposited\n     */\n    function poolCanDeposit(uint256 _amount) private view returns (bool) {\n        address rocketDepositPoolAddress = RocketStorageInterface(\n            ROCKET_STORAGE_ADDRESS\n        ).getAddress(\n                keccak256(\n                    abi.encodePacked(\"contract.address\", \"rocketDepositPool\")\n                )\n            );\n        RocketDepositPoolInterface rocketDepositPool = RocketDepositPoolInterface(\n                rocketDepositPoolAddress\n            );\n\n        address rocketProtocolSettingsAddress = RocketStorageInterface(\n            ROCKET_STORAGE_ADDRESS\n        ).getAddress(\n                keccak256(\n                    abi.encodePacked(\n                        \"contract.address\",\n                        \"rocketDAOProtocolSettingsDeposit\"\n                    )\n                )\n            );\n        RocketDAOProtocolSettingsDepositInterface rocketDAOProtocolSettingsDeposit = RocketDAOProtocolSettingsDepositInterface(\n                rocketProtocolSettingsAddress\n            );\n\n        return\n            rocketDepositPool.getBalance() + _amount <=\n            rocketDAOProtocolSettingsDeposit.getMaximumDepositPoolSize() &&\n            _amount >= rocketDAOProtocolSettingsDeposit.getMinimumDeposit();\n    }\n\n    /**\n        @notice - Deposit into derivative\n        @dev - will either get rETH on exchange or deposit into contract depending on availability\n     */\n    function deposit() external payable onlyOwner returns (uint256) {\n        // Per RocketPool Docs query addresses each time it is used\n        address rocketDepositPoolAddress = RocketStorageInterface(\n            ROCKET_STORAGE_ADDRESS\n        ).getAddress(\n                keccak256(\n                    abi.encodePacked(\"contract.address\", \"rocketDepositPool\")\n                )\n            );\n\n        RocketDepositPoolInterface rocketDepositPool = RocketDepositPoolInterface(\n                rocketDepositPoolAddress\n            );\n\n        if (!poolCanDeposit(msg.value)) {\n            uint rethPerEth = (10 ** 36) / poolPrice();\n\n            uint256 minOut = ((((rethPerEth * msg.value) / 10 ** 18) *\n                ((10 ** 18 - maxSlippage))) / 10 ** 18);\n\n            IWETH(W_ETH_ADDRESS).deposit{value: msg.value}();\n            uint256 amountSwapped = swapExactInputSingleHop(\n                W_ETH_ADDRESS,\n                rethAddress(),\n                500,\n                msg.value,\n                minOut\n            );\n\n            return amountSwapped;\n        } else {\n            address rocketTokenRETHAddress = RocketStorageInterface(\n                ROCKET_STORAGE_ADDRESS\n            ).getAddress(\n                    keccak256(\n                        abi.encodePacked(\"contract.address\", \"rocketTokenRETH\")\n                    )\n                );\n            RocketTokenRETHInterface rocketTokenRETH = RocketTokenRETHInterface(\n                rocketTokenRETHAddress\n            );\n            uint256 rethBalance1 = rocketTokenRETH.balanceOf(address(this));\n            rocketDepositPool.deposit{value: msg.value}();\n            uint256 rethBalance2 = rocketTokenRETH.balanceOf(address(this));\n            require(rethBalance2 > rethBalance1, \"No rETH was minted\");\n            uint256 rethMinted = rethBalance2 - rethBalance1;\n            return (rethMinted);\n        }\n    }\n\n    /**\n        @notice - Get price of derivative in terms of ETH\n        @dev - we need to pass amount so that it gets price from the same source that it buys or mints the rEth\n        @param _amount - amount to check for ETH price\n     */\n    function ethPerDerivative(uint256 _amount) public view returns (uint256) {\n        if (poolCanDeposit(_amount))\n            return\n                RocketTokenRETHInterface(rethAddress()).getEthValue(10 ** 18);\n        else return (poolPrice() * 10 ** 18) / (10 ** 18);\n    }\n\n    /**\n        @notice - Total derivative balance\n     */\n    function balance() public view returns (uint256) {\n        return IERC20(rethAddress()).balanceOf(address(this));\n    }\n\n    /**\n        @notice - Price of derivative in liquidity pool\n     */\n    function poolPrice() private view returns (uint256) {\n        address rocketTokenRETHAddress = RocketStorageInterface(\n            ROCKET_STORAGE_ADDRESS\n        ).getAddress(\n                keccak256(\n                    abi.encodePacked(\"contract.address\", \"rocketTokenRETH\")\n                )\n            );\n        IUniswapV3Factory factory = IUniswapV3Factory(UNI_V3_FACTORY);\n        IUniswapV3Pool pool = IUniswapV3Pool(\n            factory.getPool(rocketTokenRETHAddress, W_ETH_ADDRESS, 500)\n        );\n        (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();\n        return (sqrtPriceX96 * (uint(sqrtPriceX96)) * (1e18)) >> (96 * 2);\n    }\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/SafEth/derivatives/WstEth.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"../../interfaces/IDerivative.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../interfaces/curve/IStEthEthPool.sol\";\nimport \"../../interfaces/lido/IWStETH.sol\";\n\n/// @title Derivative contract for wstETH\n/// @author Asymmetry Finance\ncontract WstEth is IDerivative, Initializable, OwnableUpgradeable {\n    address public constant WST_ETH =\n        0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;\n    address public constant LIDO_CRV_POOL =\n        0xDC24316b9AE028F1497c275EB9192a3Ea0f67022;\n    address public constant STETH_TOKEN =\n        0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;\n\n    uint256 public maxSlippage;\n\n    // As recommended by https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n        @notice - Function to initialize values for the contracts\n        @dev - This replaces the constructor for upgradeable contracts\n        @param _owner - owner of the contract which handles stake/unstake\n    */\n    function initialize(address _owner) external initializer {\n        _transferOwnership(_owner);\n        maxSlippage = (1 * 10 ** 16); // 1%\n    }\n\n    /**\n        @notice - Return derivative name\n    */\n    function name() public pure returns (string memory) {\n        return \"Lido\";\n    }\n\n    /**\n        @notice - Owner only function to set max slippage for derivative\n    */\n    function setMaxSlippage(uint256 _slippage) external onlyOwner {\n        maxSlippage = _slippage;\n    }\n\n    /**\n        @notice - Owner only function to Convert derivative into ETH\n        @dev - Owner is set to SafEth contract\n     */\n    function withdraw(uint256 _amount) external onlyOwner {\n        IWStETH(WST_ETH).unwrap(_amount);\n        uint256 stEthBal = IERC20(STETH_TOKEN).balanceOf(address(this));\n        IERC20(STETH_TOKEN).approve(LIDO_CRV_POOL, stEthBal);\n        uint256 minOut = (stEthBal * (10 ** 18 - maxSlippage)) / 10 ** 18;\n        IStEthEthPool(LIDO_CRV_POOL).exchange(1, 0, stEthBal, minOut);\n        // solhint-disable-next-line\n        (bool sent, ) = address(msg.sender).call{value: address(this).balance}(\n            \"\"\n        );\n        require(sent, \"Failed to send Ether\");\n    }\n\n    /**\n        @notice - Owner only function to Deposit ETH into derivative\n        @dev - Owner is set to SafEth contract\n     */\n    function deposit() external payable onlyOwner returns (uint256) {\n        uint256 wstEthBalancePre = IWStETH(WST_ETH).balanceOf(address(this));\n        // solhint-disable-next-line\n        (bool sent, ) = WST_ETH.call{value: msg.value}(\"\");\n        require(sent, \"Failed to send Ether\");\n        uint256 wstEthBalancePost = IWStETH(WST_ETH).balanceOf(address(this));\n        uint256 wstEthAmount = wstEthBalancePost - wstEthBalancePre;\n        return (wstEthAmount);\n    }\n\n    /**\n        @notice - Get price of derivative in terms of ETH\n     */\n    function ethPerDerivative(uint256 _amount) public view returns (uint256) {\n        return IWStETH(WST_ETH).getStETHByWstETH(10 ** 18);\n    }\n\n    /**\n        @notice - Total derivative balance\n     */\n    function balance() public view returns (uint256) {\n        return IERC20(WST_ETH).balanceOf(address(this));\n    }\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/SafEth/SafEth.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"../interfaces/uniswap/ISwapRouter.sol\";\nimport \"../interfaces/lido/IWStETH.sol\";\nimport \"../interfaces/lido/IstETH.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./SafEthStorage.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\n/// @title Contract that mints/burns and provides owner functions for safETH\n/// @author Asymmetry Finance\ncontract SafEth is\n    Initializable,\n    ERC20Upgradeable,\n    OwnableUpgradeable,\n    SafEthStorage\n{\n    event ChangeMinAmount(uint256 indexed minAmount);\n    event ChangeMaxAmount(uint256 indexed m"
    }
  ]
}