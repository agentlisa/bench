{
  "Title": "[M-04] The quorumVotes can be bypassed",
  "Content": "\nThis vulnerability allows for the minting and auctioning of an art piece that has not met the required quorum. It enables malicious voters to influence outcomes with fewer votes than what is stipulated by the protocol. This undermines a key invariant of the protocol:\n\n        An art piece that has not met quorum cannot be dropped.\n\n<https://github.com/code-423n4/2023-12-revolutionprotocol/blob/08ff070da420e95d7c7ddf9d068cbf54433101c4/README.md?plain=1#L291>\n\n### Proof of Concept\n\nThe `quorumVotes` for an art piece are calculated at its creation as a fraction of the `totalVotesSupply`, which depends on the total supply of `erc20VotingToken` and `erc721VotingToken`:\n\n        (quorumVotesBPS * newPiece.totalVotesSupply) / 10_000.\n\n```javascript\nFile: src/CultureIndex.sol\n209:     function createPiece(\n210:         ArtPieceMetadata calldata metadata,\n211:         CreatorBps[] calldata creatorArray\n212:     ) public returns (uint256) {\n213:         uint256 creatorArrayLength = validateCreatorsArray(creatorArray);\n214: \n215:         // Validate the media type and associated data\n216:         validateMediaType(metadata);\n217: \n218:         uint256 pieceId = _currentPieceId++;\n219: \n220:         /// @dev Insert the new piece into the max heap\n221:         maxHeap.insert(pieceId, 0);\n222: \n223:         ArtPiece storage newPiece = pieces[pieceId];\n224: \n225:         newPiece.pieceId = pieceId;\n226:         newPiece.totalVotesSupply = _calculateVoteWeight(\n227:             erc20VotingToken.totalSupply(),\n228:             erc721VotingToken.totalSupply()\n229:         );\n230:         newPiece.totalERC20Supply = erc20VotingToken.totalSupply();\n231:         newPiece.metadata = metadata;\n232:         newPiece.sponsor = msg.sender;\n233:         newPiece.creationBlock = block.number;\n234:         newPiece.quorumVotes = (quorumVotesBPS * newPiece.totalVotesSupply) / 10_000;\n```\n\n<https://github.com/code-423n4/2023-12-revolutionprotocol/blob/08ff070da420e95d7c7ddf9d068cbf54433101c4/packages/revolution/src/CultureIndex.sol#L209-L234>\n\nThe `totalVotesSupply` is calculated using total supply of `erc20VotingToken` and `erc721VotingToken` at the time the piece is created. It intends to calculate all the voting power that can vote for this art piece.\n\n```javascript\nFile: src/CultureIndex.sol\n284:     function _calculateVoteWeight(uint256 erc20Balance, uint256 erc721Balance) internal view returns (uint256) {\n285:         return erc20Balance + (erc721Balance * erc721VotingTokenWeight * 1e18);\n286:     }\n```\n\n<https://github.com/code-423n4/2023-12-revolutionprotocol/blob/08ff070da420e95d7c7ddf9d068cbf54433101c4/packages/revolution/src/CultureIndex.sol#L284-L286>\n\nThe vulnerability arises because the `totalVotesSupply` is computed based on the token supplies at the time of art piece creation. However, due to the block-based clock mode in the vote checkpoint, the total supplies of `erc20VotingToken` and `erc721VotingToken` can increase within the same block, resulting in an underestimation of `totalVotesSupply` and consequently, `quorumVotes`.\n\n```javascript\nFile: src/base/VotesUpgradeable.sol\n85:     /**\n86:      * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based\n87:      * checkpoints (and voting), in which case {CLOCK_MODE} should be overridden as well to match.\n88:      */\n89:     function clock() public view virtual returns (uint48) {\n90:         return Time.blockNumber();\n91:     }\n```\n\n<https://github.com/code-423n4/2023-12-revolutionprotocol/blob/08ff070da420e95d7c7ddf9d068cbf54433101c4/packages/revolution/src/base/VotesUpgradeable.sol#L85-L91>\n\nPossible attack scenarios include:\n\n*   A voter back-running the createPiece transaction and purchasing governance tokens in the same block, thereby artificially lowering the quorumVotes.\n*   A creator front-running a significant token purchase or auction settlement, leading to a similar underestimation of quorumVotes.\n\nPOC: This POC demonstrates the first case when a voter back-run the `createPiece` transaction to understate the `totalVotesSupply` and `quorumVotes`.\n\n*   Navigate to : `cd packages/revolution`\n*   Create a test file `test/BypassQuorum.t.sol`\n*   Execute `forge test -vvvvv --match-path test/BypassQuorum.t.sol --match-test testBypassquorumVotes`\n\n<details>\n\n```javascript\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.22;\n\nimport { Test } from \"forge-std/Test.sol\";\nimport {console} from \"forge-std/console.sol\";\nimport { AuctionHouseTest } from \"./auction/AuctionHouse.t.sol\";\nimport { IERC20TokenEmitter } from \"../../src/interfaces/IERC20TokenEmitter.sol\";\n\ncontract POCTest is AuctionHouseTest {\n\n    function testBypassquorumVotes() public {\n\n        uint256 verbId0 = createDefaultArtPiece();\n\n        (,,,,uint256 creationBlock ,uint256 quorumVotes,,uint256 totalVotesSupply)= cultureIndex.pieces(0);\n        console.log(\"creationBlock: \", creationBlock); // creationBlock:  1\n        console.log(\"quorumVotes: \", quorumVotes); // quorumVotes:  0\n        console.log(\"totalVotesSupply: \", totalVotesSupply); // totalVotesSupply:  0\n\n        // Voter back-run the createPiece transaction and buy vote tokens in the same block, the supply is not reflected in the piece info and the quorum is understated at 0\n        uint256 buyAmount = 100 ether;\n        vm.deal(address(21), buyAmount);\n\n        address[] memory recipients = new address[](1);\n        recipients[0] = address(1);\n\n        uint256[] memory bps = new uint256[](1);\n        bps[0] = 10_000;\n        vm.stopPrank();\n\n        vm.prank(address(21));\n        erc20TokenEmitter.buyToken{ value: buyAmount }(\n            recipients,\n            bps,\n            IERC20TokenEmitter.ProtocolRewardAddresses({\n                builder: address(0),\n                purchaseReferral: address(0),\n                deployer: address(0)\n            })\n        );\n\n        console.log(\"Should be quorum: \", cultureIndex.quorumVotes()); // Should be quorum:  1940052234587701020\n\n    }\n}\n\n```\n</details>\n\n### Recommended Mitigation Steps\n\nWhen the piece is created, only store the `creationBlock`. The quorum should not be stored. It should be calculated directly using `VotesUpgradeable.getPastTotalSupply`, this will return the value at the end of the corresponding block.\n\nIt ensures that `quorumVotes` accurately reflects the voting power at the end of the block in which the art piece was created, thereby mitigating the risk of quorum bypass through token supply manipulation within the same block.\n\n```diff\n    function dropTopVotedPiece() public nonReentrant returns (ArtPiece memory) {\n        require(msg.sender == dropperAdmin, \"Only dropper can drop pieces\");\n\n        ICultureIndex.ArtPiece memory piece = getTopVotedPiece();\n-       require(totalVoteWeights[piece.pieceId] >= piece.quorumVotes, \"Does not meet quorum votes to be dropped.\");\n+       uint256 totalVotesSupply = _calculateVoteWeight(\n+               erc20VotingToken.getPastTotalSupply(piece.creationBlock),\n+               erc721VotingToken.getPastTotalSupply(piece.creationBlock)\n+            );\n+       uint256 quorumVotes = (quorumVotesBPS * totalVotesSupply) / 10_000;\n+       require(totalVoteWeights[piece.pieceId] >= quorumVotes, \"Does not meet quorum votes to be dropped.\");\n```\n\n\n**[rocketman-21 (Revolution) confirmed](https://github.com/code-423n4/2023-12-revolutionprotocol-findings/issues/409#issuecomment-1877907571)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-12-revolutionprotocol",
  "Code": [
    {
      "filename": "README.md?plain=1",
      "content": "# Repo setup\n\n\n- [ ] Optional / nice to have: pre-record a high-level overview of your protocol (not just specific smart contract functions). This saves wardens a lot of time wading through documentation.\n\n- [ ] Remove any part of this template that's not relevant to the final version of the README (e.g. instructions in brackets and italic)\n- [ ] Delete this checklist and all text above the line below when you're ready.\n\n---\n\n# Revolution audit details\n\n- Total Prize Pool: $36,500 USDC\n  - HM awards: $24,250 USDC\n  - Analysis awards: $1,250 USDC\n  - QA awards: $750 USDC\n  - Bot Race awards: $2,250 USDC\n  - Gas awards: $1,500 USDC\n  - Judge awards: $3,600 USDC\n  - Lookout awards: $2,400 USDC\n  - Scout awards: $500 USD\n- Join [C4 Discord](https://discord.gg/code4rena) to register\n- Submit findings [using the C4 form](https://code4rena.com/2023-12-revolution-protocol/submit)\n- [Read our guidelines for more details](https://docs.code4rena.com/roles/wardens)\n- Starts December 13, 20:00 UTC\n- Ends December 21, 20:00 UTC\n\n## Automated Findings\n\nThe 4naly3er report can be found [here](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/4naly3er-report.md).\n\nAutomated findings output for the audit can be found [here](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/bot-report.md) within 24 hours of audit opening.\n\n_Note for C4 wardens: Anything included in this `Automated Findings / Publicly Known Issues` section is considered a publicly known issue and is ineligible for awards._\n\n### Publicly Known Issues\n\nThe AuctionHouse will fail to create a new auction if the CultureIndex is empty. Not too worried about this.\n\nVerbsToken mint can fail if the top voted piece in the CultureIndex has not met quorum. Potential attack vector here.\n\nIf you create the VRGDA with shoddy parameters you can get bad outputs and errors. Will add checks on the deployer/manager contract to ensure valid params.\n\n# the Revolution protocol ‚åê‚ó®-‚ó®\n\nRevolution is a set of contracts that improve on [Nouns DAO](https://github.com/nounsDAO/nouns-monorepo). Nouns is a generative avatar collective that auctions off one ERC721, every day, forever. 100% of the proceeds of each auction (the winning bid) go into a shared treasury, and owning an NFT gets you 1 vote over the treasury.\n\n<img width=\"377\" alt=\"noun\" src=\"https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/readme-img/noun.png\">\n\nCompared to Nouns, Revolution seeks to make governance token ownership more accessible to creators and builders, and balance the scales between culture and capital while committing to a constant governance inflation schedule.\n\nThe ultimate goal of Revolution is fair ownership distribution over a community movement where anyone can earn decision making power over the energy of the movement. If this excites you, [build with us](mailto:rocketman@collective.xyz).\n\n# Developer guide\n\n## Setup\n\n```\ngit clone https://github.com/code-423n4/2023-12-revolutionprotocol.git && cd 2023-12-revolutionprotocol\n```\n\n#### Node.js and pnpm\n\n```\nnpm install -g pnpm\n```\n\n#### Turbo\n\n```\nnpm install turbo --global\n```\n\n#### Foundry\n\n[Installation guide](https://book.getfoundry.sh/getting-started/installation)\n\n## Install dependencies\n\n```\npnpm install\n```\n\n## Run tests\n\nRun tests for both Protocol Rewards and Revolution Contracts\n\n```\nturbo run test\n```\n\nRun tests in dev mode for a package w/gas logs\n\n```\ncd packages/revolution && pnpm run dev\n```\n\n## Gas reports\n\nGas reports are located in [gas-reports](https://github.com/code-423n4/2023-12-revolutionprotocol/tree/main/gas-reports)\n\nRun the tests with and generate a gas report.\n\n```\ncd packages/revolution && pnpm run write-gas-report\n```\n\nGas optimizations around the CultureIndex `createPiece` and `vote` functionality, the [MaxHeap](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/MaxHeap.sol) and [`buyToken`](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/ERC20TokenEmitter.sol) should be prioritized.\n\n## Slither\n\n#### Revolution contracts\n\n```\ncd packages/revolution && slither src --solc-remaps \"ds-test/=node_modules/ds-test/src/,forge-std/=node_modules/forge-std/src/,@openzeppelin/contracts/=node_modules/@openzeppelin/contracts/,@openzeppelin/contracts-upgradeable/=node_modules/@openzeppelin/contracts-upgradeable,solmate=node_modules/solmate/src,@collectivexyz/protocol-rewards/src/=node_modules/@collectivexyz/protocol-rewards/src/\" --checklist --show-ignored-findings --filter-paths \"@openzeppelin|ERC721|Votes.sol\" --config-file=\"../../.github/config/slither.config.json\"\n```\n\n#### Protocol rewards\n\n```\ncd packages/protocol-rewards && slither src --solc-remaps \"ds-test/=../../node_modules/ds-test/src/,forge-std/=../../node_modules/forge-std/src/,@openzeppelin/contracts/=../../node_modules/@openzeppelin/contracts/,@openzeppelin/contracts-upgradeable/=../../node_modules/@openzeppelin/contracts-upgradeable,solmate=../../node_modules/solmate/src\" --checklist --show-ignored-findings --filter-paths \"@openzeppelin\"\n```\n\n# revolution overview\n\nInstead of [auctioning](https://nouns.wtf/) off a generative PFP like Nouns, anyone can upload art pieces to the [CultureIndex](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/CultureIndex.sol) contract, and the community votes on their favorite art pieces.\n\nThe top piece is auctioned off every day as an ERC721 [VerbsToken](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/VerbsToken.sol) via the [AuctionHouse](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/AuctionHouse.sol).\n\nThe auction proceeds are split with the creator(s) of the art piece, and the rest is sent to the owner of the auction contract. The winner of the auction receives an ERC721 of the art piece. The creator receives an amount of ERC20 governance tokens and a share of the winning bid.\n\nThe ERC20 tokens the creator receives is calculated by the [ERC20TokenEmitter](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/ERC20TokenEmitter.sol). Both the ERC721 and the ERC20 governance token have voting power to vote on art pieces in the **CultureIndex**.\n\n# relevant contracts\n\n## CultureIndex\n\n[**CultureIndex.sol**](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/CultureIndex.sol) is a directory of uploaded art pieces that anyone can add media to. Owners of an ERC721 or ERC20 can vote weighted by their balance on any given art piece.\n\n<img width=\"817\" alt=\"culture index\" src=\"https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/readme-img/culture-index.png\">\n\nThe art piece votes data is stored in [**MaxHeap.sol**](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/MaxHeap.sol), a heap datastructure that enables efficient lookups of the highest voted art piece.\n\nThe contract has a function called **dropTopVotedPiece**, only callable by the owner, which pops (removes) the top voted item from the **MaxHeap** and returns it.\n\n## VerbsToken\n\n[**VerbsToken.sol**](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/VerbsToken.sol) is a fork of the [NounsToken](https://github.com/nounsDAO/nouns-monorepo/blob/master/packages/nouns-contracts/contracts/NounsToken.sol) contract. **VerbsToken** owns the **CultureIndex**. When calling **mint()** on the **VerbsToken**, the contract calls **dropTopVotedPiece** on **CultureIndex**, and creates an ERC721 with metadata based on the dropped art piece data from the **CultureIndex**.\n\n## AuctionHouse\n\n[**AuctionHouse.sol**](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/AuctionHouse.sol) is a fork of the [NounsAuctionHouse](https://github.com/nounsDAO/nouns-monorepo/blob/master/packages/nouns-contracts/contracts/NounsAuctionHouse.sol) contract, that mints **VerbsToken**s. Additionally, the **AuctionHouse** splits auction proceeds (the winning bid) with the creator(s) of the art piece that is minted.\n\n<img width=\"882\" alt=\"Screenshot 2023-12-06 at 11 25 27 AM\" src=\"https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/readme-img/vrb-auction.png\">\n\n### Creator payment\n\nThe **creatorRateBps** defines the proportion (in basis points) of the auction proceeds that is reserved for the creator(s) of the art piece, called the _creator's share_.\n\n```\ncreator_share = (msg.value * creatorRateBps) / 10_000\n```\n\nThe **entropyRateBps** defines the proportion of the _creator's share_ that is sent to the creator directly in ether.\n\n```\ndirect creator payment = (creator_share * entropyRateBps) / 10_000\n```\n\nThe remaining amount of the _creator's share_ is sent to the [ERC20TokenEmitter](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/ERC20TokenEmitter.sol) contract's **buyToken** function to buy the creator ERC20 governance tokens, according to a linear token emission schedule.\n\n## ERC20TokenEmitter\n\n**[ERC20TokenEmitter.sol](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/ERC20TokenEmitter.sol)** is a linear [VRGDA](https://www.paradigm.xyz/2022/08/vrgda) that mints an ERC20 token when the payable **buyToken** function is called, and enables anyone to purchase the ERC20 governance token at any time. A portion of value spent on buying the ERC20 tokens is paid to creators and to a protocol rewards contract.\n\n### Creator payment\n\nThe ERC20TokenEmitter has a **creatorRateBps** and **entropyRateBps** that function the same as the **AuctionHouse** contract's. Whenever a **buyToken** purchase of governance tokens is made, a **creatorRateBps** portion of the proceeds is reserved for the **creatorsAddress** set in the contract, with direct payment calculated according to the **entropyRateBps**.\n\n### Protocol rewards\n\nA fixed percentage of the value sent to the **buyToken** function is paid to the **TokenEmitterRewards** contract. The rewards setup is modeled after Zora's _fixed_ [protocol rewards](https://github.com/ourzora/zora-protocol/tree/main/packages/protocol-rewards). The key difference is that instead of a _fixed_ amount of ETH being split between the builder, referrer, deployer, and architect, the **TokenEmitterRewards** system splits a percentage of the value to relevant parties.\n\n## VRGDA\n\nThe ERC20TokenEmitter utilizes a VRGDA to emit ERC20 tokens at a predictable rate. You can read more about VRGDA's [here](https://www.paradigm.xyz/2022/08/vrgda), and view the implementation for selling NFTs [here](https://github.com/transmissions11/VRGDAs). Basically, a VRGDA contract dynamically adjusts the price of a token to adhere to a specific issuance schedule. If the emission is ahead of schedule, the price increases exponentially. If it is behind schedule, the price of each token decreases by some constant decay rate.\n\n<img width=\"903\" alt=\"Screenshot 2023-12-05 at 8 31 54 PM\" src=\"https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/readme-img/vrgda.png\">\n\nYou can read more about the implementation on [Paradigm's site](https://www.paradigm.xyz/2022/08/vrgda). Additional information located in the Additional Context section of the README.\n\n## Links\n\n- **Previous Nouns DAO audits:**\n- [NounsDAOV2](https://github.com/code-423n4/2022-08-nounsdao)\n- [NounsDAOV3 (fork)](https://github.com/code-423n4/2023-07-nounsdao)\n- **Twitter:**\n  [@collectivexyz](https://twitter.com/collectivexyz) and [@vrbsdao](https://twitter.com/vrbsdao)\n\n# Scope\n\n_List all files in scope in the table below (along with hyperlinks) -- and feel free to add notes here to emphasize areas of focus._\n\nThe ERC20TokenEmitter and flow of action from CultureIndex `drop` -> VerbsToken `mint` -> AuctionHouse `createAuction` are likely the most complex and prone to attack.\n\n| Contract | Purpose | Libraries used |  External contract calls\n| ----------- | ----------- | ----------- | ----------- |\n| [MaxHeap.sol](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/MaxHeap.sol) | Implements a [MaxHeap](https://www.geeksforgeeks.org/introduction-to-max-heap-data-structure/) data structure for O(1) max value retrieval | [`@openzeppelin/contracts`](https://openzeppelin.com/contracts/) |  |\n| [CultureIndex.sol](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/CultureIndex.sol) | Creation and weighted token voting of community art pieces | [`@openzeppelin/contracts`](https://openzeppelin.com/contracts/) [`ERC20VotesUpgradeable`](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/base/erc20/ERC20VotesUpgradeable.sol) [`ERC721CheckpointableUpgradeable`](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/base/ERC721CheckpointableUpgradeable.sol) | [`ERC721CheckpointableUpgradeable`](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/base/ERC721CheckpointableUpgradeable.sol) / [`ERC20VotesUpgradeable`](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/base/erc20/ERC20VotesUpgradeable.sol) / [`MaxHeap`](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/MaxHeap.sol) |\n| [NontransferableERC20Votes.sol](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/NontransferableERC20Votes.sol) | A nontransferable ERC20 Votes token | [`@openzeppelin/contracts`](https://openzeppelin.com/contracts/) [`ERC20VotesUpgradeable`](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/base/erc20/ERC20VotesUpgradeable.sol) |  |\n| [ERC20TokenEmitter.sol](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/ERC20TokenEmitter.sol) | Continuous linear VRGDA for purchasing ERC20 tokens with ether | [`@openzeppelin/contracts`](https://openzeppelin.com/contracts/) [`SignedWadMath`](https://github.com/transmissions11/solmate/blob/main/src/utils/SignedWadMath.sol)  | [`NontransferableERC20Votes`](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/NontransferableERC20Votes.sol) / [`TokenEmitterRewards`](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/protocol-rewards/src/abstract/TokenEmitter/TokenEmitterRewards.sol) / [`VRGDAC`](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/libs/VRGDAC.sol) |\n| [AuctionHouse.sol](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/AuctionHouse.sol) | AuctionHouse for selling ERC721s and paying creators | [`@openzeppelin/contracts-upgradeable`](https://openzeppelin.com/contracts/)| [`ERCTokenEmitter`](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/ERC20TokenEmitter.sol) / [`VerbsToken`](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/VerbsToken.sol) | |\n| [VerbsToken.sol](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/VerbsToken.sol) | The ERC721 that mints from the top *CultureIndex* art piece | [`@openzeppelin/contracts`](https://openzeppelin.com/contracts/) [`ERC721CheckpointableUpgradeable`](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/base/ERC721CheckpointableUpgradeable.sol) | [`CultureIndex`](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/CultureIndex.sol) |\n| [libs/VRGDAC.sol](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/libs/VRGDAC.sol) | The continuous linear VRGDA used for ERC20 token emission | [`SignedWadMath`](https://github.com/transmissions11/solmate/blob/main/src/utils/SignedWadMath.sol) ||  |\n||\n| [TokenEmitterRewards.sol](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/protocol-rewards/src/abstract/TokenEmitter/TokenEmitterRewards.sol) | Compute rewards and deposit for the *TokenEmitter* |  | |\n| [RewardSplits.sol](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/protocol-rewards/src/abstract/RewardSplits.sol) | Compute and deposit rewards based on splits |  | [`RevolutionProtocolRewards`](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/protocol-rewards/src/RevolutionProtocolRewards.sol) |\n\n\n### Protocol rewards SLOC\n\n| Type | File                                          | Logic Contracts | Interfaces | Lines   | nLines  | nSLOC  | Comment Lines | Complex. Score | Capabilities                                  |\n| ---- | --------------------------------------------- | --------------- | ---------- | ------- | ------- | ------ | ------------- | -------------- | --------------------------------------------- |\n| üé®   | abstract/TokenEmitter/TokenEmitterRewards.sol | 1               | \\*\\*\\*\\*   | 22      | 17      | 12     | 1             | 11             | **<abbr title='Payable Functions'>üí∞</abbr>** |\n| üé®   | abstract/RewardSplits.sol                     | 1               | \\*\\*\\*\\*   | 93      | 88      | 64     | 7             | 33             | **<abbr title='Payable Functions'>üí∞</abbr>** |\n| üé®   | **Totals**                                    | **2**           | \\*\\*\\*\\*   | **115** | **105** | **76** | **8**         | **44**         | **<abbr title='Payable Functions'>üí∞</abbr>** |\n\n### Revolution contracts SLOC\n\n| Type | File   | Logic Contracts | Interfaces | Lines | nLines | nSLOC | Comment Lines | Complex. Score | Capabilities |\n| ---- | ------ | --------------- | ---------- | ----- | ------ | ----- | ------------- | -------------- | ------------ | \n| üìù | CultureIndex.sol | 1 | **** | 547 | 516 | 224 | 197 | 215 | **<abbr title='Payable Functions'>üí∞</abbr><abbr title='Uses Hash-Functions'>üßÆ</abbr><abbr title='Handles Signatures: ecrecover'>üîñ</abbr>** |\n| üìù | MaxHeap.sol | 1 | **** | 185 | 185 | 88 | 66 | 68 | **<abbr title='Payable Functions'>üí∞</abbr>** |\n| üìù | VerbsToken.sol | 1 | **** | 332 | 324 | 139 | 125 | 125 | **<abbr title='Payable Functions'>üí∞</abbr><abbr title='TryCatch Blocks'>‚ôªÔ∏è</abbr>** |\n| üìù | AuctionHouse.sol | 1 | **** | 434 | 428 | 201 | 147 | 192 | **<abbr title='Uses Assembly'>üñ•</abbr><abbr title='Payable Functions'>üí∞</abbr><abbr title='Initiates ETH Value Transfer'>üì§</abbr><abbr title='TryCatch Blocks'>‚ôªÔ∏è</abbr>** |\n| üìù | ERC20TokenEmitter.sol | 1 | **** | 314 | 304 | 150 | 102 | 155 | **<abbr title='Payable Functions'>üí∞</abbr>** |\n| üìù | NontransferableERC20Votes.sol | 1 | **** | 158 | 151 | 56 | 71 | 48 | **<abbr title='Payable Functions'>üí∞</abbr>** |\n| üìù | libs/VRGDAC.sol | 1 | **** | 97 | 97 | 61 | 21 | 34 | **<abbr title='Unchecked Blocks'>Œ£</abbr>** |\n| üìù | **Totals** | **7** | **** | **2067**  | **2005** | **919** | **729** | **837** | **<abbr title='Uses Assembly'>üñ•</abbr><abbr title='Payable Functions'>üí∞</abbr><abbr title='Initiates ETH Value Transfer'>üì§</abbr><abbr title='Uses Hash-Functions'>üßÆ</abbr><abbr title='Handles Signatures: ecrecover'>üîñ</abbr><abbr title='TryCatch Blocks'>‚ôªÔ∏è</abbr><abbr title='Unchecked Blocks'>Œ£</abbr>** |\n\n## Out of scope\n\nAll the contracts not mentioned in scope including all test files.\n\nAny issues or improvements on how we integrate with the out of scope contracts is in scope.\n\n## Main invariants\n\n(properties that should NEVER EVER be broken).\n\nOnly the RevolutionBuilder instance should be able to initialize the 7 in-scope contracts in the revolution-contracts package. Only the initialized owner should be able to upgrade (via [UUPS](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/libs/proxy/UUPS.sol)) the CultureIndex, MaxHeap, Descriptor, and AuctionHouse, VerbsToken contracts.\n\n### NontransferableERC20Votes\n\n- Only the owner should be able to directly mint tokens.\n\n- Tokens cannot be transferred between addresses (except to mint by the owner). This includes direct transfers, transfers from, and any other mechanisms that might move tokens between different addresses.\n\n- No address should be able to approve another address to spend tokens on its behalf, as there should be no transfer of tokens.\n\n- Only authorized entities (owner) should be able to mint new tokens. Minted tokens should correctly increase the recipient's balance and the total supply.\n\n- Voting power and delegation work as intended according to [Votes](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/governance/utils/Votes.sol) without enabling any form of transferability.\n\n### Creator payments\n\n- The ERC20TokenEmitter and AuctionHouse should always pay creators (ETH or ERC20) in accordance with the creatorRateBps and entropyRateBps calculation.\n\n- The AuctionHouse should always pay only creator(s) of the CultureIndex art piece being auctioned and the owner.\n\n- The ERC20TokenEmitter should always pay the `creatorsAddress`.\n\n- ETH and ERC20 transfer functions are secure and protected with reentrancy checks / math errors.\n\n### CultureIndex\n\n- Anything uploaded to the CultureIndex should always be mintable by the VerbsToken contract and not disrupt the VerbsToken contract in any way.\n\n- The voting weights calculated must be solely based on the ERC721 and ERC20 balance of the account that casts the vote.\n\n- Accounts should not be able to vote more than once on the same art piece with the same ERC721 token in the CultureIndex.\n\n- Accounts can not vote twice on the same art piece.\n\n- `voteWithSig` signatures should only be valid for a one-time use.\n\n- Only snapshotted (at art piece creation block) vote weights should be able to update the total vote weight of the art piece. eg: If you received votes after snapshot date on the art piece, you should have 0 votes.\n\n- CultureIndex and MaxHeap, must be resilient to DoS attacks that could significantly hinder voting, art creation, or auction processes.\n\n- An art piece that has not met quorum cannot be dropped.\n\n### VerbsToken\n\n- VerbsToken should only mint art pieces from the CultureIndex.\n\n- VerbsToken should always mint the top voted art piece in the CultureIndex.\n\n### AuctionHouse\n\n- AuctionHouse should only auction off tokens from the VerbsToken.\n- The owner of the auction should always receive it's share of ether (minus creatorRateBps share).\n\n### MaxHeap\n\n- The MaxHeap should always maintain the property of being a binary tree in which the value in each internal node is greater than or equal to the values in the children of that node.\n\n### VRGDA\n\n- The VRGDAC should always exponentially increase the price of tokens if the supply is ahead of schedule.\n\n### ERC20TokenEmitter\n\n- The treasury and creatorsAddress should not be able to buy tokens.\n\n- The distribution of ERC20 governance tokens should be in accordance with the defined linear emission schedule.\n\n- The ERC20TokenEmitter should always pay protocol rewards assuming enough ETH was paid to the buyToken function.\n\n- The treasury should always receive it's share of ether (minus creatorRateBps and protocol rewards share).\n\n# Additional Context\n\n### VRGDAC\n\nThe Token Emitter utilizes a continuous VRGDA ([VRGDAC.sol](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/libs/VRGDAC.sol)) to facilitate ERC20 token purchases. Given an amount of ether to pay, it will return the number of tokens to sell (`YtoX`), and given an amount of tokens to buy, will return the cost (`XtoY`) where X is the ERC20 token and Y is ether. The original VRGDAC implementation is [here](https://gist.github.com/transmissions11/485a6e2deb89236202bd2f59796262fd).\n\nIn order to get the amount of tokens to emit given a payment of ether (`YtoX` in [VRGDAC.sol](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/libs/VRGDAC.sol)), we first take the integral of the linear VRGDA pricing function [p(x)](https://www.paradigm.xyz/2022/08/vrgda).\n\n<img width=\"487\" alt=\"Screenshot 2023-12-05 at 9 21 59 PM\" src=\"https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/readme-img/vrgda-c-integral.png\">\n\nThen - we can get the cost of a specific number of tokens (`XtoY` in [VRGDAC.sol](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/libs/VRGDAC.sol)) by doing `p_integral(x_start+x_bought) - p_integral(x_start)` where `x_start` is the current supply of the ERC20 and `x_bought` is the amount of tokens you wish to purchase.\n\nWe can then solve for `x_bought` using a handy python [solver](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/script/solve.py) to find `YtoX`, allowing us to pass in an amount of ether and receive an amount of tokens to sell.\n\n<img width=\"1727\" alt=\"Screenshot 2023-12-05 at 8 34 22 PM\" src=\"https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/readme-img/vrgdac-graph.png\">\n\nThe green line is the pricing function p(x) for a linear VRGDA. The red line is the integral of p(x), and the purple line signifies the amount of ERC20 tokens you'd receive given a payment in ether (YtoX). The relevant functions and integrals for the VRGDAC are available here: https://www.desmos.com/calculator/im67z1tate.\n\n## Attack ideas (Where to look for bugs)\n\nCompared to Nouns DAO, complexity arises from the auction of community created/voted art, and direct payments to creators. So - focusing on ways in which the `CultureIndex` -> `VerbsToken` -> `AuctionHouse` flow can be attacked, or DOS'd to prevent community intent from manifesting is a good start. Additionally, exploring creator governance token accumulation attack vectors is a solid start.\n\n### Where to start\n\nBegin by examining the access control and permissions for contracts that make up the art piece to AuctionHouse flow, such as the CultureIndex. It‚Äôs essential to ensure that access is tightly constrained and locked down to prevent unauthorized or malicious activities. Next, ensure the logic and flow of the system does not have any gaps or unexpected edge cases. This step is foundational to the system‚Äôs security and continued operation. Also, review the ERC20TokenEmitter contract's ownership and permissions to prevent governance takeover.\n\n### [CultureIndex](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/CultureIndex.sol) attacks\n\nChecking that the CultureIndex or the MaxHeap can not be DOS'd where voting or creating art becomes prohibitively expensive, within a reasonable attack cost (~50 ETH). Keep in mind the CultureIndex can be reset by the VerbsToken to potentially relieve some pressure.\n\nEnsuring nothing uploaded to CultureIndex could break or otherwise disrupt the minting functionality of the VerbsToken.\n\nAny replay attacks on `voteWithSig` signatures.\n\n### [AuctionHouse](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/AuctionHouse.sol) attacks\n\nEnsuring gas passed to the settleAndCreateNewAuction functions or other nefarious interactions with AuctionSettlement cannot brick/pause the auction.\n\nEnsuring anything submitted to the CultureIndex cannot brick the auction by being minted. Look for large numbers of creators on art pieces as a potential attack vector.\n\nEnsuring anything nefarious in the minting functionality of the VerbsToken contract cannot brick the auction.\n\n### [ERC20TokenEmitter](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/ERC20TokenEmitter.sol) attacks\n\nAnother large distinction from Nouns is that there are 2 classes of governance shares, the ERC721 auction item (VerbsToken) and the nontransferable ERC20. These two tokens are used to vote on the CultureIndex and choose the next auction item, and in the future will be used to govern a DAO with a treasury. It is essential to explore potential ways in which the ERC20 emission from the ERC20TokenEmitter can be exploited to gain an outsized governance share.\n\n### Creator rate attacks\n\nThe system is further complicated by the creator payments on both the AuctionHouse and the ERC20TokenEmitter. The DAO is able to unilaterally set both the `creatorRateBps` and `entropyRateBps` on both the Auction and ERC20TokenEmitter. The CultureIndex voting setup and quorum determins the creator(s) paid as part of the Auction. The DAO can set the `creatorsAddress` on the ERC20TokenEmitter. Given creators will be paid directly, ensure malicious creator contracts or a large number of creators cannot disrupt the system by eg: bricking the auction.\n\n## Tokens used on launch and anticipated to interact with.\n\n### ERC20\n\nUSDC, and the [NontransferableERC20Votes](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/NontransferableERC20Votes.sol)\n\n### ERC721\n\n[VerbsToken](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/VerbsToken.sol)\n\n## Blockchains\n\nEthereum\n\n## Trusted roles\n\n- Trusted roles (e.g. operators, slashers, pausers, etc.), the privileges they hold, and any conditions under which privilege escalation is expected/allowable\n\n[RevolutionBuilder](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/builder/RevolutionBuilder.sol) manages upgrades and deployments for the set of 7 contracts in the scope. Only the RevolutionBuilder instance should be able to initialize the 7 contracts in the revolution-contracts package scope. Privilege escalation is not allowed, everything should be managed by the RevolutionBuilder contract.\n\nVerbsToken has a descriptor, minter, and CultureIndex. The minter is assumed to be always set to the AuctionHouse contract, and should have complete and sole control over the token minting functionality.\n\nCultureIndex has a `dropperAdmin` address set on initialize that has exclusive and locked control of dropping pieces from the CultureIndex. \n\nMaxHeap has an `admin` address set on initialize that has exclusive and locked control of updating the MaxHeap data structure.\n\nVerbsDAOLogicV1 (outside scope) is assumed to be the owner of all contracts (CultureIndex, MaxHeap, Descriptor, ERC20TokenEmitter, NontransferableERC20Votes, and VerbsToken) and is able to upgrade via [UUPS](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/libs/proxy/UUPS.sol) the CultureIndex, MaxHeap, Descriptor, AuctionHouse, and VerbsToken.\n\n## DOS\n\nMinimum duration after which we would consider a DOS finding to be valid?\n\nDOS on CultureIndex: 20m\n\n## EIP conformity\n\n- [VerbsToken](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/VerbsToken.sol): Should comply with `ERC721`\n- [NontransferableERC20Votes](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/NontransferableERC20Votes.sol): Should comply with `ERC20`\n\n## Scoping Details\n\n```\n- If you have a public code repo, please share it here: https://github.com/code-423n4/2023-12-revolutionprotocol/tree/main/packages/revolution, https://github.com/code-423n4/2023-12-revolutionprotocol/tree/main/packages/protocol-rewards\n- How many contracts are in scope?: 9\n- Total SLoC for these contracts?: 1000\n- How many external imports are there?: 14\n- How many separate interfaces and struct definitions are there for the contracts within scope?: 13\n- Does most of your code generally use composition or inheritance?: Inheritance\n- How many external calls?: 4\n- What is the overall line coverage percentage provided by your tests?: 88\n- Is this an upgrade of an existing system?:\n\nTrue - We're upgrading Nouns DAO so that the auction item is a piece of community created art, voted on by the community. Additionally, we are issuing an ERC20 governance token to the creator and splitting the auction proceeds with the creator of the art.\n\n- Check all that apply (e.g. timelock, NFT, AMM, ERC20, rollups, etc.): NFT, Uses L2, ERC-20 Token\n- Is there a need to understand a separate part of the codebase / get context in order to audit this part of the protocol?: RevolutionBuilder for a look at the deployment and upgrade lifecycle\n- Please describe required context:\n- Does it use an oracle?: No\n- Describe any novel or unique curve logic or mathematical models your code uses: We use a continuous VRGDA function, built by Paradigm (https://www.paradigm.xyz/2022/08/vrgda). It enables a"
    }
  ]
}