{
  "Title": "M-4: Liquidation shouldn't be used to close positions that were fully-collateralized prior to collateral requirement changes",
  "Content": "# Issue M-4: Liquidation shouldn't be used to close positions that were fully-collateralized prior to collateral requirement changes \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/179 \n\n## Found by \nIllIllI\n\n## Summary\n\nThere are various factors associated with minimum collateral requirements, and if a position falls below them, the position is liquidated.\n\n## Vulnerability Detail\n\nIf the position was over-collateralized and in profit prior to the change in the minimums, and the minimum is increased, the position is liquidated.\n\n\n## Impact\n\nLiquidation gives all funds to the pool, giving nothing back to the user\n\n\n## Code Snippet\n\nA position becomes liquidatable once it falls below the [changeable](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/config/Config.sol#L231-L233) collateral requirements:\n```solidity\n// File: gmx-synthetics/contracts/position/PositionUtils.sol : PositionUtils.isPositionLiquidatable()   #1\n\n377            if (shouldValidateMinCollateralUsd) {\n378 @>             cache.minCollateralUsd = dataStore.getUint(Keys.MIN_COLLATERAL_USD).toInt256();\n379                if (cache.remainingCollateralUsd < cache.minCollateralUsd) {\n380                    return true;\n381                }\n382            }\n383    \n384            if (cache.remainingCollateralUsd <= 0) {\n385                return true;\n386            }\n387    \n388:           // validate if (remaining collateral) / position.size is less than the min collateral factor (max leverage exceeded)\n```\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/position/PositionUtils.sol#L368-L388\n\nLiquidations give [everything](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/position/DecreasePositionCollateralUtils.sol#L347-L358) to the pool, and nothing to the position's account\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nClose the position with a market order, rather than liquidating it, if the user was previously above the minimum with the old factor\n\n\n\n\n## Discussion\n\n**xvi10**\n\nthe min collateral requirements should not be changed unless it is an emergency requirement\n\nthis setting should eventually be removed from the Config contract\n\n**IllIllI000**\n\n@xvi10, while it may be for emergency use, if it does end up being used, isnâ€™t the current behavior incorrect? Should this be a no-fix?\n\n**xvi10**\n\nyes, updated to confirmed\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/config/Config.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"../data/DataStore.sol\";\nimport \"../data/Keys.sol\";\nimport \"../role/RoleModule.sol\";\nimport \"../event/EventEmitter.sol\";\nimport \"../utils/BasicMulticall.sol\";\n\n// @title Config\ncontract Config is ReentrancyGuard, RoleModule, BasicMulticall {\n    using EventUtils for EventUtils.AddressItems;\n    using EventUtils for EventUtils.UintItems;\n    using EventUtils for EventUtils.IntItems;\n    using EventUtils for EventUtils.BoolItems;\n    using EventUtils for EventUtils.Bytes32Items;\n    using EventUtils for EventUtils.BytesItems;\n    using EventUtils for EventUtils.StringItems;\n\n    uint256 public constant MAX_FEE_FACTOR = 5 * Precision.FLOAT_PRECISION / 100; // 5%\n\n    DataStore public immutable dataStore;\n    EventEmitter public immutable eventEmitter;\n\n    // @dev the base keys that can be set\n    mapping (bytes32 => bool) public allowedBaseKeys;\n\n    error InvalidBaseKey(bytes32 baseKey);\n    error InvalidFeeFactor(bytes32 baseKey, uint256 value);\n    error InvalidFactor(bytes32 baseKey, uint256 value);\n\n    constructor(\n        RoleStore _roleStore,\n        DataStore _dataStore,\n        EventEmitter _eventEmitter\n    ) RoleModule(_roleStore) {\n        dataStore = _dataStore;\n        eventEmitter = _eventEmitter;\n\n        _initAllowedBaseKeys();\n    }\n\n    // @dev set a bool value\n    // @param baseKey the base key of the value to set\n    // @param data the additional data to be combined with the base key\n    // @param value the bool value\n    function setBool(bytes32 baseKey, bytes memory data, bool value) external onlyConfigKeeper nonReentrant {\n        _validateKey(baseKey);\n\n        bytes32 fullKey = keccak256(bytes.concat(baseKey, data));\n\n        dataStore.setBool(fullKey, value);\n\n        EventUtils.EventLogData memory eventData;\n\n        eventData.bytes32Items.initItems(1);\n        eventData.bytes32Items.setItem(0, \"baseKey\", baseKey);\n\n        eventData.bytesItems.initItems(1);\n        eventData.bytesItems.setItem(0, \"data\", data);\n\n        eventData.boolItems.initItems(1);\n        eventData.boolItems.setItem(0, \"value\", value);\n\n        eventEmitter.emitEventLog1(\n            \"SetBool\",\n            baseKey,\n            eventData\n        );\n    }\n\n    // @dev set an address value\n    // @param baseKey the base key of the value to set\n    // @param data the additional data to be combined with the base key\n    // @param value the address value\n    function setAddress(bytes32 baseKey, bytes memory data, address value) external onlyConfigKeeper nonReentrant {\n        _validateKey(baseKey);\n\n        bytes32 fullKey = keccak256(bytes.concat(baseKey, data));\n\n        dataStore.setAddress(fullKey, value);\n\n        EventUtils.EventLogData memory eventData;\n\n        eventData.bytes32Items.initItems(1);\n        eventData.bytes32Items.setItem(0, \"baseKey\", baseKey);\n\n        eventData.bytesItems.initItems(1);\n        eventData.bytesItems.setItem(0, \"data\", data);\n\n        eventData.addressItems.initItems(1);\n        eventData.addressItems.setItem(0, \"value\", value);\n\n        eventEmitter.emitEventLog1(\n            \"SetAddress\",\n            baseKey,\n            eventData\n        );\n    }\n\n    // @dev set a bytes32 value\n    // @param baseKey the base key of the value to set\n    // @param data the additional data to be combined with the base key\n    // @param value the bytes32 value\n    function setBytes32(bytes32 baseKey, bytes memory data, bytes32 value) external onlyConfigKeeper nonReentrant {\n        _validateKey(baseKey);\n\n        bytes32 fullKey = keccak256(bytes.concat(baseKey, data));\n\n        dataStore.setBytes32(fullKey, value);\n\n        EventUtils.EventLogData memory eventData;\n\n        eventData.bytes32Items.initItems(2);\n        eventData.bytes32Items.setItem(0, \"baseKey\", baseKey);\n        eventData.bytes32Items.setItem(1, \"value\", value);\n\n        eventData.bytesItems.initItems(1);\n        eventData.bytesItems.setItem(0, \"data\", data);\n\n        eventEmitter.emitEventLog1(\n            \"SetBytes32\",\n            baseKey,\n            eventData\n        );\n    }\n\n    // @dev set a uint256 value\n    // @param basekey the base key of the value to set\n    // @param data the additional data to be combined with the base key\n    // @param value the uint256 value\n    function setUint(bytes32 baseKey, bytes memory data, uint256 value) external onlyConfigKeeper nonReentrant {\n        _validateKey(baseKey);\n\n        bytes32 fullKey = keccak256(bytes.concat(baseKey, data));\n\n        _validateRange(baseKey, value);\n\n        dataStore.setUint(fullKey, value);\n\n        EventUtils.EventLogData memory eventData;\n\n        eventData.bytes32Items.initItems(1);\n        eventData.bytes32Items.setItem(0, \"baseKey\", baseKey);\n\n        eventData.bytesItems.initItems(1);\n        eventData.bytesItems.setItem(0, \"data\", data);\n\n        eventData.uintItems.initItems(1);\n        eventData.uintItems.setItem(0, \"value\", value);\n\n        eventEmitter.emitEventLog1(\n            \"SetUint\",\n            baseKey,\n            eventData\n        );\n    }\n\n    // @dev set an int256 value\n    // @param basekey the base key of the value to set\n    // @param data the additional data to be combined with the base key\n    // @param value the int256 value\n    function setInt(bytes32 baseKey, bytes memory data, int256 value) external onlyConfigKeeper nonReentrant {\n        _validateKey(baseKey);\n\n        bytes32 fullKey = keccak256(bytes.concat(baseKey, data));\n\n        dataStore.setInt(fullKey, value);\n\n        EventUtils.EventLogData memory eventData;\n\n        eventData.bytes32Items.initItems(1);\n        eventData.bytes32Items.setItem(0, \"baseKey\", baseKey);\n\n        eventData.bytesItems.initItems(1);\n        eventData.bytesItems.setItem(0, \"data\", data);\n\n        eventData.intItems.initItems(1);\n        eventData.intItems.setItem(0, \"value\", value);\n\n        eventEmitter.emitEventLog1(\n            \"SetInt\",\n            baseKey,\n            eventData\n        );\n    }\n\n    // @dev initialize the allowed base keys\n    function _initAllowedBaseKeys() internal {\n        allowedBaseKeys[Keys.IS_MARKET_DISABLED] = true;\n\n        allowedBaseKeys[Keys.CREATE_DEPOSIT_FEATURE_DISABLED] = true;\n        allowedBaseKeys[Keys.CANCEL_DEPOSIT_FEATURE_DISABLED] = true;\n        allowedBaseKeys[Keys.EXECUTE_DEPOSIT_FEATURE_DISABLED] = true;\n\n        allowedBaseKeys[Keys.CREATE_WITHDRAWAL_FEATURE_DISABLED] = true;\n        allowedBaseKeys[Keys.CANCEL_WITHDRAWAL_FEATURE_DISABLED] = true;\n        allowedBaseKeys[Keys.EXECUTE_WITHDRAWAL_FEATURE_DISABLED] = true;\n\n        allowedBaseKeys[Keys.CREATE_ORDER_FEATURE_DISABLED] = true;\n        allowedBaseKeys[Keys.EXECUTE_ORDER_FEATURE_DISABLED] = true;\n        allowedBaseKeys[Keys.EXECUTE_ADL_FEATURE_DISABLED] = true;\n        allowedBaseKeys[Keys.UPDATE_ORDER_FEATURE_DISABLED] = true;\n        allowedBaseKeys[Keys.CANCEL_ORDER_FEATURE_DISABLED] = true;\n\n        allowedBaseKeys[Keys.MIN_ORACLE_BLOCK_CONFIRMATIONS] = true;\n        allowedBaseKeys[Keys.MAX_ORACLE_PRICE_AGE] = true;\n        allowedBaseKeys[Keys.POSITION_FEE_RECEIVER_FACTOR] = true;\n        allowedBaseKeys[Keys.SWAP_FEE_RECEIVER_FACTOR] = true;\n        allowedBaseKeys[Keys.BORROWING_FEE_RECEIVER_FACTOR] = true;\n\n        allowedBaseKeys[Keys.ESTIMATED_GAS_FEE_BASE_AMOUNT] = true;\n        allowedBaseKeys[Keys.ESTIMATED_GAS_FEE_MULTIPLIER_FACTOR] = true;\n\n        allowedBaseKeys[Keys.EXECUTION_GAS_FEE_BASE_AMOUNT] = true;\n        allowedBaseKeys[Keys.EXECUTION_GAS_FEE_MULTIPLIER_FACTOR] = true;\n\n        allowedBaseKeys[Keys.DEPOSIT_GAS_LIMIT] = true;\n        allowedBaseKeys[Keys.WITHDRAWAL_GAS_LIMIT] = true;\n        allowedBaseKeys[Keys.SINGLE_SWAP_GAS_LIMIT] = true;\n        allowedBaseKeys[Keys.INCREASE_ORDER_GAS_LIMIT] = true;\n        allowedBaseKeys[Keys.DECREASE_ORDER_GAS_LIMIT] = true;\n        allowedBaseKeys[Keys.SWAP_ORDER_GAS_LIMIT] = true;\n        allowedBaseKeys[Keys.TOKEN_TRANSFER_GAS_LIMIT] = true;\n        allowedBaseKeys[Keys.NATIVE_TOKEN_TRANSFER_GAS_LIMIT] = true;\n\n        allowedBaseKeys[Keys.REQUEST_EXPIRATION_BLOCK_AGE] = true;\n        allowedBaseKeys[Keys.MIN_COLLATERAL_FACTOR] = true;\n        allowedBaseKeys[Keys.MIN_COLLATERAL_FACTOR_FOR_OPEN_INTEREST_MULTIPLIER] = true;\n        allowedBaseKeys[Keys.MIN_COLLATERAL_USD] = true;\n\n        allowedBaseKeys[Keys.VIRTUAL_TOKEN_ID] = true;\n        allowedBaseKeys[Keys.VIRTUAL_MARKET_ID] = true;\n        allowedBaseKeys[Keys.VIRTUAL_INVENTORY_FOR_SWAPS] = true;\n        allowedBaseKeys[Keys.VIRTUAL_INVENTORY_FOR_POSITIONS] = true;\n        allowedBaseKeys[Keys.THRESHOLD_POSITION_IMPACT_FACTOR_FOR_VIRTUAL_INVENTORY] = true;\n        allowedBaseKeys[Keys.THRESHOLD_SWAP_IMPACT_FACTOR_FOR_VIRTUAL_INVENTORY] = true;\n\n        allowedBaseKeys[Keys.POSITION_IMPACT_FACTOR] = true;\n        allowedBaseKeys[Keys.POSITION_IMPACT_EXPONENT_FACTOR] = true;\n        allowedBaseKeys[Keys.MAX_POSITION_IMPACT_FACTOR] = true;\n        allowedBaseKeys[Keys.POSITION_FEE_FACTOR] = true;\n\n        allowedBaseKeys[Keys.SWAP_IMPACT_FACTOR] = true;\n        allowedBaseKeys[Keys.SWAP_IMPACT_EXPONENT_FACTOR] = true;\n        allowedBaseKeys[Keys.SWAP_FEE_FACTOR] = true;\n\n        allowedBaseKeys[Keys.ORACLE_TYPE] = true;\n\n        allowedBaseKeys[Keys.RESERVE_FACTOR] = true;\n        allowedBaseKeys[Keys.MAX_PNL_FACTOR] = true;\n        allowedBaseKeys[Keys.MAX_PNL_FACTOR_FOR_WITHDRAWALS] = true;\n        allowedBaseKeys[Keys.FUNDING_FACTOR] = true;\n        allowedBaseKeys[Keys.BORROWING_FACTOR] = true;\n    }\n\n    // @dev validate that the baseKey is allowed to be used\n    // @param baseKey the base key to validate\n    function _validateKey(bytes32 baseKey) internal view {\n        if (!allowedBaseKeys[baseKey]) {\n            revert InvalidBaseKey(baseKey);\n        }\n    }\n\n    // @dev validate that the value is within the allowed range\n    // @param baseKey the base key for the value\n    // @param value the value to be set\n    function _validateRange(bytes32 baseKey, uint256 value) internal pure {\n        if (\n            baseKey == Keys.SWAP_FEE_FACTOR ||\n            baseKey == Keys.POSITION_FEE_FACTOR\n        ) {\n            revert InvalidFeeFactor(baseKey, value);\n        }\n\n        if (\n            baseKey == Keys.POSITION_FEE_RECEIVER_FACTOR ||\n            baseKey == Keys.SWAP_FEE_RECEIVER_FACTOR ||\n            baseKey == Keys.BORROWING_FEE_RECEIVER_FACTOR ||\n            baseKey == Keys.MIN_COLLATERAL_FACTOR ||\n            baseKey == Keys.RESERVE_FACTOR ||\n            baseKey == Keys.MAX_PNL_FACTOR ||\n            baseKey == Keys.MAX_PNL_FACTOR_FOR_WITHDRAWALS ||\n            baseKey == Keys.FUNDING_FACTOR ||\n            baseKey == Keys.BORROWING_FACTOR\n        ) {\n            revert InvalidFactor(baseKey, value);\n        }\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/position/PositionUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"../utils/Precision.sol\";\n\nimport \"./Position.sol\";\n\nimport \"../data/DataStore.sol\";\nimport \"../data/Keys.sol\";\n\nimport \"../pricing/PositionPricingUtils.sol\";\nimport \"../order/BaseOrderUtils.sol\";\nimport \"../referral/ReferralEventUtils.sol\";\n\n// @title PositionUtils\n// @dev Library for position functions\nlibrary PositionUtils {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using Price for Price.Props;\n    using Position for Position.Props;\n    using Order for Order.Props;\n\n    // @dev UpdatePositionParams struct used in increasePosition to avoid\n    // stack too deep errors\n    //\n    // @param market the values of the trading market\n    // @param order the decrease position order\n    // @param position the order's position\n    // @param positionKey the key of the order's position\n    // @param collateral the collateralToken of the position\n    // @param collateralDeltaAmount the amount of collateralToken deposited\n    struct UpdatePositionParams {\n        BaseOrderUtils.ExecuteOrderParamsContracts contracts;\n        Market.Props market;\n        Order.Props order;\n        bytes32 orderKey;\n        Position.Props position;\n        bytes32 positionKey;\n    }\n\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param oracle Oracle\n    // @param referralStorage IReferralStorage\n    struct UpdatePositionParamsContracts {\n        DataStore dataStore;\n        EventEmitter eventEmitter;\n        Oracle oracle;\n        SwapHandler swapHandler;\n        IReferralStorage referralStorage;\n    }\n\n    struct WillPositionCollateralBeSufficientValues {\n        uint256 positionSizeInUsd;\n        uint256 positionCollateralAmount;\n        int256 positionPnlUsd;\n        int256 realizedPnlUsd;\n        int256 openInterestDelta;\n    }\n\n    struct DecreasePositionCollateralValuesOutput {\n        address outputToken;\n        uint256 outputAmount;\n        address secondaryOutputToken;\n        uint256 secondaryOutputAmount;\n    }\n\n    // @dev ProcessCollateralValues struct used to contain the values in processCollateral\n    // @param executionPrice the order execution price\n    // @param remainingCollateralAmount the remaining collateral amount of the position\n    // @param outputAmount the output amount\n    // @param positionPnlUsd the pnl of the position in USD\n    // @param pnlAmountForPool the pnl for the pool in token amount\n    // @param pnlAmountForUser the pnl for the user in token amount\n    // @param sizeDeltaInTokens the change in position size in tokens\n    // @param priceImpactAmount the price impact in tokens\n    struct DecreasePositionCollateralValues {\n        address pnlTokenForPool;\n        uint256 executionPrice;\n        int256 remainingCollateralAmount;\n        int256 positionPnlUsd;\n        int256 pnlAmountForPool;\n        uint256 pnlAmountForUser;\n        uint256 sizeDeltaInTokens;\n        int256 priceImpactAmount;\n        uint256 priceImpactDiffUsd;\n        uint256 priceImpactDiffAmount;\n        DecreasePositionCollateralValuesOutput output;\n    }\n\n    // @dev DecreasePositionCache struct used in decreasePosition to\n    // avoid stack too deep errors\n    // @param prices the prices of the tokens in the market\n    // @param pnlToken the token that the pnl for the user is in, for long positions\n    // this is the market.longToken, for short positions this is the market.shortToken\n    // @param pnlTokenPrice the price of the pnlToken\n    // @param initialCollateralAmount the initial collateral amount\n    // @param nextPositionSizeInUsd the new position size in USD\n    // @param nextPositionBorrowingFactor the new position borrowing factor\n    struct DecreasePositionCache {\n        MarketUtils.MarketPrices prices;\n        int256 estimatedPositionPnlUsd;\n        int256 estimatedRealizedPnlUsd;\n        int256 estimatedRemainingPnlUsd;\n        address pnlToken;\n        Price.Props pnlTokenPrice;\n        uint256 initialCollateralAmount;\n        uint256 nextPositionSizeInUsd;\n        uint256 nextPositionBorrowingFactor;\n    }\n\n\n    struct GetPositionPnlUsdCache {\n        int256 positionValue;\n        int256 totalPositionPnl;\n        address pnlToken;\n        uint256 poolTokenAmount;\n        uint256 poolTokenPrice;\n        uint256 poolTokenUsd;\n        int256 poolPnl;\n        int256 cappedPoolPnl;\n        uint256 sizeDeltaInTokens;\n        int256 positionPnlUsd;\n    }\n\n    // @dev IsPositionLiquidatableCache struct used in isPositionLiquidatable\n    // to avoid stack too deep errors\n    // @param positionPnlUsd the position's pnl in USD\n    // @param minCollateralFactor the min collateral factor\n    // @param collateralUsd the position's collateral in USD\n    // @param priceImpactUsd the price impact of closing the position in USD\n    // @param minCollateralUsd the minimum allowed collateral in USD\n    // @param remainingCollateralUsd the remaining position collateral in USD\n    struct IsPositionLiquidatableCache {\n        int256 positionPnlUsd;\n        uint256 minCollateralFactor;\n        uint256 collateralUsd;\n        int256 priceImpactUsd;\n        int256 minCollateralUsd;\n        int256 minCollateralUsdForLeverage;\n        int256 remainingCollateralUsd;\n    }\n\n    error LiquidatablePosition();\n    error EmptyPosition(uint256 sizeInUsd, uint256 sizeInTokens, uint256 collateralAmount);\n\n    // @dev get the position pnl in USD\n    //\n    // for long positions, pnl is calculated as:\n    // (position.sizeInTokens * indexTokenPrice) - position.sizeInUsd\n    // if position.sizeInTokens is larger for long positions, the position will have\n    // larger profits and smaller losses for the same changes in token price\n    //\n    // for short positions, pnl is calculated as:\n    // position.sizeInUsd -  (position.sizeInTokens * indexTokenPrice)\n    // if position.sizeInTokens is smaller for long positions, the position will have\n    // larger profits and smaller losses for the same changes in token price\n    //\n    // @param position the position values\n    // @param sizeDeltaUsd the change in position size\n    // @param indexTokenPrice the price of the index token\n    //\n    // @return (positionPnlUsd, sizeDeltaInTokens)\n    function getPositionPnlUsd(\n        DataStore dataStore,\n        Market.Props memory market,\n        MarketUtils.MarketPrices memory prices,\n        Position.Props memory position,\n        uint256 indexTokenPrice,\n        uint256 sizeDeltaUsd\n    ) public view returns (int256, uint256) {\n        GetPositionPnlUsdCache memory cache;\n\n        // position.sizeInUsd is the cost of the tokens, positionValue is the current worth of the tokens\n        cache.positionValue = (position.sizeInTokens() * indexTokenPrice).toInt256();\n        cache.totalPositionPnl = position.isLong() ? cache.positionValue - position.sizeInUsd().toInt256() : position.sizeInUsd().toInt256() - cache.positionValue;\n\n        if (cache.totalPositionPnl > 0) {\n            cache.pnlToken = position.isLong() ? market.longToken : market.shortToken;\n            cache.poolTokenAmount = MarketUtils.getPoolAmount(dataStore, market.marketToken, cache.pnlToken);\n            cache.poolTokenPrice = position.isLong() ? prices.longTokenPrice.min : prices.shortTokenPrice.min;\n            cache.poolTokenUsd = cache.poolTokenAmount * cache.poolTokenPrice;\n            cache.poolPnl = MarketUtils.getPnl(\n                dataStore,\n                market.marketToken,\n                market.longToken,\n                market.shortToken,\n                indexTokenPrice,\n                position.isLong(),\n                true\n            );\n\n            cache.cappedPoolPnl = MarketUtils.getCappedPnl(\n                dataStore,\n                market.marketToken,\n                position.isLong(),\n                cache.poolPnl,\n                cache.poolTokenUsd,\n                Keys.MAX_PNL_FACTOR_FOR_TRADERS\n            );\n\n            if (cache.cappedPoolPnl != cache.poolPnl && cache.cappedPoolPnl > 0 && cache.poolPnl > 0) {\n                // divide by WEI_PRECISION to reduce the risk of overflow\n                cache.totalPositionPnl = cache.totalPositionPnl * (cache.cappedPoolPnl / Precision.WEI_PRECISION.toInt256()) / (cache.poolPnl / Precision.WEI_PRECISION.toInt256());\n            }\n        }\n\n        cache.sizeDeltaInTokens;\n\n        if (position.sizeInUsd() == sizeDeltaUsd) {\n            cache.sizeDeltaInTokens = position.sizeInTokens();\n        } else {\n            if (position.isLong()) {\n                cache.sizeDeltaInTokens = Calc.roundUpDivision(position.sizeInTokens() * sizeDeltaUsd, position.sizeInUsd());\n            } else {\n                cache.sizeDeltaInTokens = position.sizeInTokens() * sizeDeltaUsd / position.sizeInUsd();\n            }\n        }\n\n        cache.positionPnlUsd = cache.totalPositionPnl * cache.sizeDeltaInTokens.toInt256() / position.sizeInTokens().toInt256();\n\n        return (cache.positionPnlUsd, cache.sizeDeltaInTokens);\n    }\n\n    // @dev convert sizeDeltaUsd to sizeDeltaInTokens\n    // @param sizeInUsd the position size in USD\n    // @param sizeInTokens the position size in tokens\n    // @param sizeDeltaUsd the position size change in USD\n    // @return the size delta in tokens\n    function getSizeDeltaInTokens(uint256 sizeInUsd, uint256 sizeInTokens, uint256 sizeDeltaUsd) internal pure returns (uint256) {\n        return sizeInTokens * sizeDeltaUsd / sizeInUsd;\n    }\n\n    // @dev get the key for a position\n    // @param account the position's account\n    // @param market the position's market\n    // @param collateralToken the position's collateralToken\n    // @param isLong whether the position is long or short\n    // @return the position key\n    function getPositionKey(address account, address market, address collateralToken, bool isLong) internal pure returns (bytes32) {\n        bytes32 key = keccak256(abi.encode(account, market, collateralToken, isLong));\n        return key;\n    }\n\n    // @dev validate that a position is not empty\n    // @param position the position values\n    function validateNonEmptyPosition(Position.Props memory position) internal pure {\n        if (position.sizeInUsd() == 0 || position.sizeInTokens() == 0 || position.collateralAmount() == 0) {\n            revert EmptyPosition(position.sizeInUsd(), position.sizeInTokens(), position.collateralAmount());\n        }\n    }\n\n    // @dev check if a position is valid\n    // @param dataStore DataStore\n    // @param referralStorage IReferralStorage\n    // @param position the position values\n    // @param market the market values\n    // @param prices the prices of the tokens in the market\n    // @param shouldValidateMinCollateralUsd whether min collateral usd needs to be validated\n    // validation is skipped for decrease position to prevent reverts in case the order size\n    // is just slightly smaller than the position size\n    // in decrease position, the remaining collateral is estimated at the start, and the order\n    // size is updated to match the position size if the remaining collateral will be less than\n    // the min collateral usd\n    // since this is an estimate, there may be edge cases where there is a small remaining position size\n    // and small amount of collateral remaining\n    // validation is skipped for this case as it is preferred for the order to be executed\n    // since the small amount of collateral remaining only impacts the potential payment of liquidation\n    // keepers\n    function validatePosition(\n        DataStore dataStore,\n        IReferralStorage referralStorage,\n        Position.Props memory position,\n        Market.Props memory market,\n        MarketUtils.MarketPrices memory prices,\n        bool shouldValidateMinCollateralUsd\n    ) public view {\n        validateNonEmptyPosition(position);\n\n        if (isPositionLiquidatable(\n            dataStore,\n            referralStorage,\n            position,\n            market,\n            prices,\n            shouldValidateMinCollateralUsd\n        )) {\n            revert LiquidatablePosition();\n        }\n    }\n\n    // @dev check if a position is liquidatable\n    // @param dataStore DataStore\n    // @param referralStorage IReferralStorage\n    // @param position the position values\n    // @param market the market values\n    // @param prices the prices of the tokens in the market\n    function isPositionLiquidatable(\n        DataStore dataStore,\n        IReferralStorage referralStorage,\n        Position.Props memory position,\n        Market.Props memory market,\n        MarketUtils.MarketPrices memory prices,\n        bool shouldValidateMinCollateralUsd\n    ) public view returns (bool) {\n        IsPositionLiquidatableCache memory cache;\n\n        (cache.positionPnlUsd, ) = getPositionPnlUsd(\n            dataStore,\n            market,\n            prices,\n            position,\n            prices.indexTokenPrice.pickPriceForPnl(position.isLong(), false),\n            position.sizeInUsd()\n        );\n\n        cache.minCollateralFactor = MarketUtils.getMinCollateralFactor(dataStore, market.marketToken);\n\n        Price.Props memory collateralTokenPrice = MarketUtils.getCachedTokenPrice(\n            position.collateralToken(),\n            market,\n            prices\n        );\n\n        cache.collateralUsd = position.collateralAmount() * collateralTokenPrice.min;\n\n        cache.priceImpactUsd = PositionPricingUtils.getPriceImpactUsd(\n            PositionPricingUtils.GetPriceImpactUsdParams(\n                dataStore,\n                market.marketToken,\n                market.indexToken,\n                market.longToken,\n                market.shortToken,\n                -position.sizeInUsd().toInt256(),\n                position.isLong()\n            )\n        );\n\n        // even if there is a large positive price impact, positions that would be liquidated\n        // if the positive price impact is reduced should not be allowed to be created\n        // as they would be easily liquidated if the price impact changes\n        // cap the priceImpactUsd to zero to prevent these positions from being created\n        if (cache.priceImpactUsd > 0) {\n            cache.priceImpactUsd = 0;\n        } else {\n            uint256 maxPriceImpactFactor = MarketUtils.getMaxPositionImpactFactorForLiquidations(\n                dataStore,\n                market.marketToken\n            );\n\n            // if there is a large build up of open interest and a sudden large price movement\n            // it may result in a large imbalance between longs and shorts\n            // this could result in very large price impact temporarily\n            // cap the max negative price impact to prevent cascading liquidations\n            int256 maxNegativePriceImpactUsd = -Precision.applyFactor(position.sizeInUsd(), maxPriceImpactFactor).toInt256();\n            if (cache.priceImpactUsd < maxNegativePriceImpactUsd) {\n                cache.priceImpactUsd = maxNegativePriceImpactUsd;\n            }\n        }\n\n        PositionPricingUtils.PositionFees memory fees = PositionPricingUtils.getPositionFees(\n            dataStore,\n            referralStorage,\n            position,\n            collateralTokenPrice,\n            market.longToken,\n            market.shortToken,\n            position.sizeInUsd()\n        );\n\n        cache.remainingCollateralUsd = cache.collateralUsd.toInt256() + cache.positionPnlUsd + cache.priceImpactUsd - fees.totalNetCostUsd.toInt256();\n\n        if (shouldValidateMinCollateralUsd) {\n            cache.minCollateralUsd = dataStore.getUint(Keys.MIN_COLLATERAL_USD).toInt256();\n            if (cache.remainingCollateralUsd < cache.minCollateralUsd) {\n                return true;\n            }\n        }\n\n        if (cache.remainingCollateralUsd <= 0) {\n            return true;\n        }\n\n        // validate if (remaining collateral) / position.size is less than the min collateral factor (max leverage exceeded)\n        cache.minCollateralUsdForLeverage = Precision.applyFactor(position.sizeInUsd(), cache.minCollateralFactor).toInt256();\n        if (cache.remainingCollateralUsd < cache.minCollateralUsdForLeverage) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function willPositionCollateralBeSufficient(\n        DataStore dataStore,\n        Market.Props memory market,\n        MarketUtils.MarketPrices memory prices,\n        address collateralToken,\n        bool isLong,\n        WillPositionCollateralBeSufficientValues memory values\n    ) public view returns (bool, int256) {\n        Price.Props memory collateralTokenPrice = MarketUtils.getCachedTokenPrice(\n            collateralToken,\n            market,\n            prices\n        );\n\n        uint256 minCollateralFactor = MarketUtils.getMinCollateralFactorForOpenInterest(\n            dataStore,\n            market.marketToken,\n            market.longToken,\n            market.shortToken,\n            values.openInterestDelta,\n            isLong\n        );\n\n        int256 remainingCollateralUsd = values.positionCollateralAmount.toInt256() * collateralTokenPrice.min.toInt256();\n\n        remainingCollateralUsd += values.positionPnlUsd;\n\n        if (values.realizedPnlUsd < 0) {\n            remainingCollateralUsd = remainingCollateralUsd + values.realizedPnlUsd;\n        }\n\n        if (remainingCollateralUsd < 0) {\n            return (false, remainingCollateralUsd);\n        }\n\n        int256 minCollateralUsdForLeverage = Precision.applyFactor(values.positionSizeInUsd, minCollateralFactor).toInt256();\n        bool willBeSufficient = remainingCollateralUsd >= minCollateralUsdForLeverage;\n\n        return (willBeSufficient, remainingCollateralUsd);\n    }\n\n    function updateFundingAndBorrowingState(\n        PositionUtils.UpdatePositionParams memory params,\n        MarketUtils.MarketPrices memory prices\n    ) internal {\n        // update the funding amount per size for the market\n        MarketUtils.updateFundingAmountPerSize(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.market,\n            prices\n        );\n\n        // update the cumulative borrowing factor for the market\n        MarketUtils.updateCumulativeBorrowingFactor(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.market,\n            prices,\n            params.order.isLong()\n        );\n    }\n\n    function updateTotalBorrowing(\n        PositionUtils.UpdatePositionParams memory params,\n        uint256 nextPositionSizeInUsd,\n        uint256 nextPositionBorrowingFactor\n    ) internal {\n        MarketUtils.updateTotalBorrowing(\n            params.contracts.dataStore,\n            params.market.marketToken,\n            params.position.isLong(),\n            params.position.borrowingFactor(),\n            params.position.sizeInUsd(),\n            nextPositionSizeInUsd,\n            nextPositionBorrowingFactor\n        );\n    }\n\n    function incrementClaimableFundingAmount(\n        PositionUtils.UpdatePositionParams memory params,\n        PositionPricingUtils.PositionFees memory fees\n    ) internal {\n        // if the position has negative funding fees, distribute it to allow it to be claimable\n        if (fees.funding.claimableLongTokenAmount > 0) {\n            MarketUtils.incrementClaimableFundingAmount(\n                params.contracts.dataStore,\n                params.contracts.eventEmitter,\n                params.market.marketToken,\n                params.market.longToken,\n                params.order.receiver(),\n                fees.funding.claimableLongTokenAmount\n            );\n        }\n\n        if (fees.funding.claimableShortTokenAmount > 0) {\n            MarketUtils.incrementClaimableFundingAmount(\n                params.contracts.dataStore,\n                params.contracts.eventEmitter,\n                params.market.marketToken,\n                params.market.shortToken,\n                params.order.receiver(),\n                fees.funding.claimableShortTokenAmount\n            );\n        }\n    }\n\n    function updateOpenInterest(\n        PositionUtils.UpdatePositionParams memory params,\n        int256 sizeDeltaUsd,\n        int256 sizeDeltaInTokens\n    ) internal {\n        if (sizeDeltaUsd != 0) {\n            MarketUtils.applyDeltaToOpenInterest(\n                params.contracts.dataStore,\n                params.contracts.eventEmitter,\n                params.market.marketToken,\n                params.market.indexToken,\n                params.position.collateralToken(),\n                params.position.isLong(),\n                sizeDeltaUsd\n            );\n\n            MarketUtils.applyDeltaToOpenInterestInTokens(\n                params.contracts.dataStore,\n                params.contracts.eventEmitter,\n                params.position.market(),\n                params.position.collateralToken(),\n                params.position.isLong(),\n                sizeDeltaInTokens\n            );\n        }\n    }\n\n    function handleReferral(\n        PositionUtils.UpdatePositionParams memory params,\n        PositionPricingUtils.PositionFees memory fees\n    ) internal {\n        ReferralUtils.incrementAffiliateReward(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.position.market(),\n            params.position.collateralToken(),\n            fees.referral.affiliate,\n            params.position.account(),\n            fees.referral.affiliateRewardAmount\n        );\n\n        if (fees.referral.traderDiscountAmount > 0) {\n            ReferralEventUtils.emitTraderReferralDiscountApplied(\n                params.contracts.eventEmitter,\n                params.position.market(),\n                params.position.collateralToken(),\n                params.position.account(),\n                fees.referral.traderDiscountAmount"
    }
  ]
}