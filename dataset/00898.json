{
  "Title": "M-5: `depositFromNotional` function is payable, which means that it should accept Ether, but in reality will revert 100% when msg.value > 0",
  "Content": "# Issue M-5: `depositFromNotional` function is payable, which means that it should accept Ether, but in reality will revert 100% when msg.value > 0 \n\nSource: https://github.com/sherlock-audit/2023-10-notional-judging/issues/51 \n\n## Found by \nAuditorPraise, Vagner\n## Summary\nThe function `depositFromNotional` used in `BaseStrategyVault.sol` is payable, which means that it should accept Ether, but in reality it will revert every time when msg.value is > than 0 in any of existing strategy.\n## Vulnerability Detail\n`depositFromNotional` is a function used in `BaseStrategyVault.sol` for every strategy, to deposit from notional to a specific strategy. As you can see this function has the `payable` keyword\n https://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/common/BaseStrategyVault.sol#L166-L173\nwhich means that it is expected to be used along with msg.value being > than 0. This function would call `_depositFromNotional` which is different on any strategy used, but let's take the most simple case, since all of them will be the same in the end, the case of `CrossCurrencyVault.sol`. In `CrossCurrencyVault.sol` , `_depositFromNotional`  would later call `_executeTrade`\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/CrossCurrencyVault.sol#L184 \nwhich would use the `TradeHandler` library as can be seen here \nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/common/BaseStrategyVault.sol#L124\nIf we look into the `TradeHandler` library, `_executeTrade` would delegatecall into the implementation of `TradingModule.sol` to `executeTrade` function, as can be seen here \nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/trading/TradeHandler.sol#L41-L42\nIf we look into the `executeTrade` function in `TradingModule.sol` we can see that this function does not have the payable, keyword, which mean that it will not accept msg.value >  than 0 \nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/trading/TradingModule.sol#L169-L193\nThe big and important thing to know about delegate call is that, msg.sender and msg.value will always be kept when you delegate call, so the problem that arise here is the fact that , the calls made to `depositFromNotional`  with msg.value > 0 , would always revert when it gets to this delegatecall, in every strategy, since the function that it delegates to , doesn't have the `payable` keyword, and since msg.value is always kept trough the delegate calls, the call would just revert. This would be the case for all the strategies since they all uses `_executeTrade` or `_executeTradeWithDynamicSlippage` in a way or another, so every payable function that would use any of these 2 functions from the `TradeHandler.sol` library would revert all the time, if msg.value is > 0.\n## Impact\nImpact is a high one, since strategy using pools that need to interact with Ether would be useless and the whole functionality would be broken.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/trading/TradeHandler.sol#L18-L45\n## Tool used\n\nManual Review\n\n## Recommendation\nThere are multiple solution to this, the easiest one is to make the function `executeTrade` in `TradingModule.sol` payable, so the delegate call would not revert when msg.value is greater than 0, or if you don't intend to use ether with `depositFromNotional`, remove the `payable` keyword. It is important to take special care in those delegate calls since they are used multiple times in the codebase, and could mess up functionalities when msg.value is intended to be used.\n\n\n\n## Discussion\n\n**jeffywu**\n\nTrade Handler is executed in a delegate call context, I don't really follow this issue.\n\n**VagnerAndrei26**\n\nEscalate\nI want to escalate this issue and explain it a bit better so it can be understood. The core of this issue stands at the base of how `delegatecall` works. The big difference between normal `call` and `delegatecall` is , as I said , `msg.sender` and `msg.value` are kept within the call. Here is the source code of EVM \n```solidity\nFile: core\\vm\\contract.go\n134: func (c *Contract) AsDelegate() *Contract {\n135: \t// NOTE: caller must, at all times be a contract. It should never happen\n136: \t// that caller is something other than a Contract.\n137: \tparent := c.caller.(*Contract)\n138: \tc.CallerAddress = parent.CallerAddress\n139: \tc.value = parent.value\n140: \n141: \treturn c\n142: }\n```\nbasically what this means is that, anytime when you have a function that is payable, and implicitly has `msg.value` > 0 , that `msg.value` will always be passed in a `delegatecall`. In the case of normal `call` you can choose if you want to pass some value by using `{ value: }`, after calling the function in a contract, but for `delegatecall` you can't choose, so what will happen is that, any time you do a `delegatecall` inside a function that has payable and where `msg.value` is > 0, that value is always passed in that `delegatecall` and if the function called does not have the `payable` keyword, the transaction will always revert, the same as when you are trying to do a simple `call` to a contract without having a `receive` function or `payable` keyword on a function. So in our case, because `_executeTrade ` or `_executeTradeWithDynamicSlippage ` does not have the `payable` keyword, any call on `depositFromNotional ` with `msg.value` > 0 , would revert all the time, making the vaults in the cases where ETH is used useless.\nAlso issue #8 is not a duplicate of this, since it would fall more to this duplicate rule of sherlock which states \n![image](https://github.com/sherlock-audit/2023-10-notional-judging/assets/111457602/b4e57106-6bf7-4fd1-9669-0ccf1b6b6d5c)\nsince the report identifies the core issue, which is lacking the `payable` keyword but doesn't correctly identifies the reason behind that being an issue or the impact.\n\n**sherlock-admin2**\n\n > Escalate\n> I want to escalate this issue and explain it a bit better so it can be understood. The core of this issue stands at the base of how `delegatecall` works. The big difference between normal `call` and `delegatecall` is , as I said , `msg.sender` and `msg.value` are kept within the call. Here is the source code of EVM \n> ```solidity\n> File: core\\vm\\contract.go\n> 134: func (c *Contract) AsDelegate() *Contract {\n> 135: \t// NOTE: caller must, at all times be a contract. It should never happen\n> 136: \t// that caller is something other than a Contract.\n> 137: \tparent := c.caller.(*Contract)\n> 138: \tc.CallerAddress = parent.CallerAddress\n> 139: \tc.value = parent.value\n> 140: \n> 141: \treturn c\n> 142: }\n> ```\n> basically what this means is that, anytime when you have a function that is payable, and implicitly has `msg.value` > 0 , that `msg.value` will always be passed in a `delegatecall`. In the case of normal `call` you can choose if you want to pass some value by using `{ value: }`, after calling the function in a contract, but for `delegatecall` you can't choose, so what will happen is that, any time you do a `delegatecall` inside a function that has payable and where `msg.value` is > 0, that value is always passed in that `delegatecall` and if the function called does not have the `payable` keyword, the transaction will always revert, the same as when you are trying to do a simple `call` to a contract without having a `receive` function or `payable` keyword on a function. So in our case, because `_executeTrade ` or `_executeTradeWithDynamicSlippage ` does not have the `payable` keyword, any call on `depositFromNotional ` with `msg.value` > 0 , would revert all the time, making the vaults in the cases where ETH is used useless.\n> Also issue #8 is not a duplicate of this, since it would fall more to this duplicate rule of sherlock which states \n> ![image](https://github.com/sherlock-audit/2023-10-notional-judging/assets/111457602/b4e57106-6bf7-4fd1-9669-0ccf1b6b6d5c)\n> since the report identifies the core issue, which is lacking the `payable` keyword but doesn't correctly identifies the reason behind that being an issue or the impact.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**AuditorPraise**\n\n> Escalate I want to escalate this issue and explain it a bit better so it can be understood. The core of this issue stands at the base of how `delegatecall` works. The big difference between normal `call` and `delegatecall` is , as I said , `msg.sender` and `msg.value` are kept within the call. Here is the source code of EVM\n> \n> ```solidity\n> File: core\\vm\\contract.go\n> 134: func (c *Contract) AsDelegate() *Contract {\n> 135: \t// NOTE: caller must, at all times be a contract. It should never happen\n> 136: \t// that caller is something other than a Contract.\n> 137: \tparent := c.caller.(*Contract)\n> 138: \tc.CallerAddress = parent.CallerAddress\n> 139: \tc.value = parent.value\n> 140: \n> 141: \treturn c\n> 142: }\n> ```\n> \n> basically what this means is that, anytime when you have a function that is payable, and implicitly has `msg.value` > 0 , that `msg.value` will always be passed in a `delegatecall`. In the case of normal `call` you can choose if you want to pass some value by using `{ value: }`, after calling the function in a contract, but for `delegatecall` you can't choose, so what will happen is that, any time you do a `delegatecall` inside a function that has payable and where `msg.value` is > 0, that value is always passed in that `delegatecall` and if the function called does not have the `payable` keyword, the transaction will always revert, the same as when you are trying to do a simple `call` to a contract without having a `receive` function or `payable` keyword on a function. So in our case, because `_executeTrade ` or `_executeTradeWithDynamicSlippage ` does not have the `payable` keyword, any call on `depositFromNotional ` with `msg.value` > 0 , would revert all the time, making the vaults in the cases where ETH is used useless. Also issue #8 is not a duplicate of this, since it would fall more to this duplicate rule of sherlock which states ![image](https://private-user-images.githubusercontent.com/111457602/287818052-b4e57106-6bf7-4fd1-9669-0ccf1b6b6d5c.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTEiLCJleHAiOjE3MDE3OTk0NTQsIm5iZiI6MTcwMTc5OTE1NCwicGF0aCI6Ii8xMTE0NTc2MDIvMjg3ODE4MDUyLWI0ZTU3MTA2LTZiZjctNGZkMS05NjY5LTBjY2YxYjZiNmQ1Yy5wbmc_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBSVdOSllBWDRDU1ZFSDUzQSUyRjIwMjMxMjA1JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDIzMTIwNVQxNzU5MTRaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT04NzkwMDRhNGJjMjEwZDhiMDMyY2I0NTIwYjJhZjE0YWVjNWIwMjJkN2RkMTAwYjkwZWNmOGEyYTI4MDUzNDJjJlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCZhY3Rvcl9pZD0wJmtleV9pZD0wJnJlcG9faWQ9MCJ9.PBnCsygUXOuIu1feHTc1KAik9tM5Dhu6c_Uhnd5fuck) since the report identifies the core issue, which is lacking the `payable` keyword but doesn't correctly identifies the reason behind that being an issue or the impact.\n\nLoL, how is #8  a low? Because i didn't use the same exact words you used when describing your issue? \n#8  's  summary: The vaults will be executing trades on external exchanges via TradingModule.executeTrade() and TradingModule.executeTradeWithDynamicSlippage() and ETH could be among the tokens to trade for primary token BUT the tradingModule.executeTrade() and TradingModule.executeTradeWithDynamicSlippage() lack the payable keyword.\n\nIts vulnerability detail: tradingModule.executeTrade() and TradingModule.executeTradeWithDynamicSlippage() won't be able to receive ETH (Whenever ETH is sell token) because they lack the payable keyword.\n\nThis can cause reverts in some of the key functions of the vaults like:\n\ndepositFromNotional()\nredeemFromNotional()\nreinvestReward()\n\n\nAnd its impact:  vaults will be unable to execute trades on external exchanges via the trading module whenever ETH is the sell Token`\n\nHow are they different?\n#8  's impact is clearly described and i don't see how it's different from your described impact because they're both implying the same thing\nAnyways thanks for escalating sir\n\n**VagnerAndrei26**\n\n> > Escalate I want to escalate this issue and explain it a bit better so it can be understood. The core of this issue stands at the base of how `delegatecall` works. The big difference between normal `call` and `delegatecall` is , as I said , `msg.sender` and `msg.value` are kept within the call. Here is the source code of EVM\n> > ```solidity\n> > File: core\\vm\\contract.go\n> > 134: func (c *Contract) AsDelegate() *Contract {\n> > 135: \t// NOTE: caller must, at all times be a contract. It should never happen\n> > 136: \t// that caller is something other than a Contract.\n> > 137: \tparent := c.caller.(*Contract)\n> > 138: \tc.CallerAddress = parent.CallerAddress\n> > 139: \tc.value = parent.value\n> > 140: \n> > 141: \treturn c\n> > 142: }\n> > ```\n> > \n> > \n> >     \n> >       \n> >     \n> > \n> >       \n> >     \n> > \n> >     \n> >   \n> > basically what this means is that, anytime when you have a function that is payable, and implicitly has `msg.value` > 0 , that `msg.value` will always be passed in a `delegatecall`. In the case of normal `call` you can choose if you want to pass some value by using `{ value: }`, after calling the function in a contract, but for `delegatecall` you can't choose, so what will happen is that, any time you do a `delegatecall` inside a function that has payable and where `msg.value` is > 0, that value is always passed in that `delegatecall` and if the function called does not have the `payable` keyword, the transaction will always revert, the same as when you are trying to do a simple `call` to a contract without having a `receive` function or `payable` keyword on a function. So in our case, because `_executeTrade ` or `_executeTradeWithDynamicSlippage ` does not have the `payable` keyword, any call on `depositFromNotional ` with `msg.value` > 0 , would revert all the time, making the vaults in the cases where ETH is used useless. Also issue #8 is not a duplicate of this, since it would fall more to this duplicate rule of sherlock which states ![image](https://private-user-images.githubusercontent.com/111457602/287818052-b4e57106-6bf7-4fd1-9669-0ccf1b6b6d5c.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTEiLCJleHAiOjE3MDE3OTk0NTQsIm5iZiI6MTcwMTc5OTE1NCwicGF0aCI6Ii8xMTE0NTc2MDIvMjg3ODE4MDUyLWI0ZTU3MTA2LTZiZjctNGZkMS05NjY5LTBjY2YxYjZiNmQ1Yy5wbmc_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBSVdOSllBWDRDU1ZFSDUzQSUyRjIwMjMxMjA1JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDIzMTIwNVQxNzU5MTRaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT04NzkwMDRhNGJjMjEwZDhiMDMyY2I0NTIwYjJhZjE0YWVjNWIwMjJkN2RkMTAwYjkwZWNmOGEyYTI4MDUzNDJjJlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCZhY3Rvcl9pZD0wJmtleV9pZD0wJnJlcG9faWQ9MCJ9.PBnCsygUXOuIu1feHTc1KAik9tM5Dhu6c_Uhnd5fuck) since the report identifies the core issue, which is lacking the `payable` keyword but doesn't correctly identifies the reason behind that being an issue or the impact.\n> \n> LoL, how is #6 a low? Because i didn't use the same exact words you used when describing your issue? #6 's summary: The vaults will be executing trades on external exchanges via TradingModule.executeTrade() and TradingModule.executeTradeWithDynamicSlippage() and ETH could be among the tokens to trade for primary token BUT the tradingModule.executeTrade() and TradingModule.executeTradeWithDynamicSlippage() lack the payable keyword.\n> \n> Its vulnerability detail: tradingModule.executeTrade() and TradingModule.executeTradeWithDynamicSlippage() won't be able to receive ETH (Whenever ETH is sell token) because they lack the payable keyword.\n> \n> This can cause reverts in some of the key functions of the vaults like:\n> \n> depositFromNotional() redeemFromNotional() reinvestReward()\n> \n> And its impact: vaults will be unable to execute trades on external exchanges via the trading module whenever ETH is the sell Token`\n> \n> How are they different? #6 's impact is clearly described and i don't see how it's different from your described impact because they're both implying the same thing Anyways thanks for escalating sir\n\nHey, I didn't say that it was a low personally, I said that it is not a duplicate of this, and should be considered as the duplicate rule stated, if it is kept as a duplicate. The big difference is that the report failed to find the real problem of this whole issue, the `delegatecall`. The main important aspect of this issue is the fact that those functions, that were also specified #8, are used in a `delegatecall` and not in a normal call, if it were done in a normal call, this would have not be a problem since you can select if you want to transfer `msg.value` with the call or not. Also the report speaks about  `redeemFromNotional` and `reinvestReward` having the same issue, but that is not correct since they are not payable, so no `msg.value` is expected to be used when calling those, the only real function affected by this issue is `depositFromNotional`. Also in the report it is also talking about `TradingModule` not being able to receive ether which is not a problem again, since the main usage of `TradingModule` is to be used more as an implementation, where calls could be delegated to. That's the reasons behind my arguments, the only thing which the report accurate is the fact the those function lacks the `payable` keyword, but fails to explain the real problem behind, or why is that a problem in the current code.\n\n**AuditorPraise**\n\n> > > Escalate I want to escalate this issue and explain it a bit better so it can be understood. The core of this issue stands at the base of how `delegatecall` works. The big difference between normal `call` and `delegatecall` is , as I said , `msg.sender` and `msg.value` are kept within the call. Here is the source code of EVM\n> > > ```solidity\n> > > File: core\\vm\\contract.go\n> > > 134: func (c *Contract) AsDelegate() *Contract {\n> > > 135: \t// NOTE: caller must, at all times be a contract. It should never happen\n> > > 136: \t// that caller is something other than a Contract.\n> > > 137: \tparent := c.caller.(*Contract)\n> > > 138: \tc.CallerAddress = parent.CallerAddress\n> > > 139: \tc.value = parent.value\n> > > 140: \n> > > 141: \treturn c\n> > > 142: }\n> > > ```\n> > > \n> > > \n> > >     \n> > >       \n> > >     \n> > > \n> > >       \n> > >     \n> > > \n> > >     \n> > >   \n> > > basically what this means is that, anytime when you have a function that is payable, and implicitly has `msg.value` > 0 , that `msg.value` will always be passed in a `delegatecall`. In the case of normal `call` you can choose if you want to pass some value by using `{ value: }`, after calling the function in a contract, but for `delegatecall` you can't choose, so what will happen is that, any time you do a `delegatecall` inside a function that has payable and where `msg.value` is > 0, that value is always passed in that `delegatecall` and if the function called does not have the `payable` keyword, the transaction will always revert, the same as when you are trying to do a simple `call` to a contract without having a `receive` function or `payable` keyword on a function. So in our case, because `_executeTrade ` or `_executeTradeWithDynamicSlippage ` does not have the `payable` keyword, any call on `depositFromNotional ` with `msg.value` > 0 , would revert all the time, making the vaults in the cases where ETH is used useless. Also issue #8 is not a duplicate of this, since it would fall more to this duplicate rule of sherlock which states ![image](https://private-user-images.githubusercontent.com/111457602/287818052-b4e57106-6bf7-4fd1-9669-0ccf1b6b6d5c.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTEiLCJleHAiOjE3MDE3OTk0NTQsIm5iZiI6MTcwMTc5OTE1NCwicGF0aCI6Ii8xMTE0NTc2MDIvMjg3ODE4MDUyLWI0ZTU3MTA2LTZiZjctNGZkMS05NjY5LTBjY2YxYjZiNmQ1Yy5wbmc_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBSVdOSllBWDRDU1ZFSDUzQSUyRjIwMjMxMjA1JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDIzMTIwNVQxNzU5MTRaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT04NzkwMDRhNGJjMjEwZDhiMDMyY2I0NTIwYjJhZjE0YWVjNWIwMjJkN2RkMTAwYjkwZWNmOGEyYTI4MDUzNDJjJlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCZhY3Rvcl9pZD0wJmtleV9pZD0wJnJlcG9faWQ9MCJ9.PBnCsygUXOuIu1feHTc1KAik9tM5Dhu6c_Uhnd5fuck) since the report identifies the core issue, which is lacking the `payable` keyword but doesn't correctly identifies the reason behind that being an issue or the impact.\n> > \n> > \n> > LoL, how is #6 a low? Because i didn't use the same exact words you used when describing your issue? #6 's summary: The vaults will be executing trades on external exchanges via TradingModule.executeTrade() and TradingModule.executeTradeWithDynamicSlippage() and ETH could be among the tokens to trade for primary token BUT the tradingModule.executeTrade() and TradingModule.executeTradeWithDynamicSlippage() lack the payable keyword.\n> > Its vulnerability detail: tradingModule.executeTrade() and TradingModule.executeTradeWithDynamicSlippage() won't be able to receive ETH (Whenever ETH is sell token) because they lack the payable keyword.\n> > This can cause reverts in some of the key functions of the vaults like:\n> > depositFromNotional() redeemFromNotional() reinvestReward()\n> > And its impact: vaults will be unable to execute trades on external exchanges via the trading module whenever ETH is the sell Token`\n> > How are they different? #6 's impact is clearly described and i don't see how it's different from your described impact because they're both implying the same thing Anyways thanks for escalating sir\n> \n> Hey, I didn't say that it was a low personally, I said that it is not a duplicate of this, and should be considered as the duplicate rule stated, if it is kept as a duplicate. The big difference is that the report failed to find the real problem of this whole issue, the `delegatecall`. The main important aspect of this issue is the fact that those functions, that were also specified #8, are used in a `delegatecall` and not in a normal call, if it were done in a normal call, this would have not be a problem since you can select if you want to transfer `msg.value` with the call or not. Also the report speaks about `redeemFromNotional` and `reinvestReward` having the same issue, but that is not correct since they are not payable, so no `msg.value` is expected to be used when calling those, the only real function affected by this issue is `depositFromNotional`. Also in the report it is also talking about `TradingModule` not being able to receive ether which is not a problem again, since the main usage of `TradingModule` is to be used more as an implementation, where calls could be delegated to. That's the reasons behind my arguments, the only thing which the report accurate is the fact the those function lacks the `payable` keyword, but fails to explain the real problem behind, or why is that a problem in the current code.\n\nThe `delegateCall` is not the main issue bro. The lack of a payable keyword on the tradingModule.executeTrade() and TradingModule.executeTradeWithDynamicSlippage() is the main issue. \nBecause pools that need to interact with Ether would be useless due to the missing `payable` keyword on those external functions that are supposed to interact with ETH(i.e,  tradingModule.executeTrade() and TradingModule.executeTradeWithDynamicSlippage()) and the whole functionality would be broken.\n\nMsg.value will always be > 0 whenever the token being transferred is ETH\n\n**nevillehuang**\n\nHi @VagnerAndrei26 @AuditorPraise can any of you provide me a coded test file proving the issue? Imo if it is 100% going to revert, should be easy enough to proof it, appreciate your assistance. \n\n**VagnerAndrei26**\n\n> Hi @VagnerAndrei26 @AuditorPraise can any of you provide me a coded test file proving the issue? Imo if it is 100% going to revert, should be easy enough to proof it, appreciate your assistance.\n\nYeah I can, I can show a simpler implementation of 2 contracts doing some delegatecalls, I am 100% sure on this issue, because I got paid for it multiple times already and it got confirmed in other contest too. Will provide the simple example later today, after I get home.\n\n**AuditorPraise**\n\nHello bro @nevillehuang, i just wrote a quick implementation of 2 contracts doing some delegatecalls on remix.\njust copy and paste on remix \n```solidity\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity =0.8.18;\n\n/**\n * @hypothesis\n * @dev just for research.\n */\nimport \"hardhat/console.sol\";\n\ncontract ContractA {\n    receive() external payable {}\n    address public contractBAddress;\n\n    event EtherTransferred(address indexed from, address indexed to, uint256 amount);\n\n    constructor(address _contractBAddress) {\n        contractBAddress = _contractBAddress;\n    }\n\n    function delegateCallToContractB(uint256 amount) payable external {\n        // Use delegatecall to execute the transferEther function in ContractB\n        (bool success, ) = payable(contractBAddress).delegatecall(\n            abi.encodeWithSignature(\"transferEther(address,uint256)\", msg.sender, amount)\n        );\n\n        require(success, \"Delegate call to ContractB failed\");\n\n        console.log(\"trf was successful\");\n    }\n}\n\ncontract ContractB {\n    receive() external payable {}\n\n    function transferEther(address recipient, uint256 amount) \n    external {\n        //@audit-issue the delegate call from contract A fails without the payable keyword here\n\n       \n    }\n}\n```\nSo this is supposed to show the issue we are talking about.\nwhen contractB.transferEther()'s function has the `payable` keyword the delegate call from contract A succeeds BUT when its not there it reverts.\n\nThe code above should revert, then add the `payable` keyword to contractB.transferEther() you'll see that contractA.delegateCallToContractB() succeeds.\n\nHere's an article that may be of help with sending Ether on remix [How do you send Ether as a function to a contract using Remix?](https://ethereum.stackexchange.com/questions/46107/how-do-you-send-ether-as-a-function-to-a-contract-using-remix)\n\n**shealtielanz**\n\nThe 2 reports are duplicates IMO, as the root issues is stated in both of them, and their mitigations solves the issues well.\n\n**nevillehuang**\n\n@jeffywu Is there a foundry test revolving this issue that shows it will not revert if u pass in a msg.value? I am really surprised if this is true that a test would not have caught this.\n\nSince the PoC provided is not protocol specific, I will have to double check before making any final comment.\n\n**VagnerAndrei26**\n\n> @jeffywu Is there a foundry test revolving this issue that shows it will not revert if u pass in a msg.value? I am really surprised if this is true that a test would not have caught this.\n> \n> Since the PoC provided is not protocol specific, I will have to double check before making any final comment.\n\nThe example provided from @AuditorPraise is good, it is pretty similar to what I wanted to present. The bases of this issue is simple, if you have a `delegatecall` inside a `payable` function, the function which you `delegatecall` to needs to have payable also, otherwise it reverts anytime when `msg.value` > 0.\n\n**Czar102**\n\nAwaiting a protocol-specific PoC @VagnerAndrei26 and a comment from @jeffywu.\n\n**VagnerAndrei26**\n\n> Awaiting a protocol-specific PoC @VagnerAndrei26 and a comment from @jeffywu.\n\nHey @Czar102 it was kinda hard to do it, because of the complex codebase and test, but here is the protocol specific POC.\nWhat I did was modifying this specific test https://github.com/sherlock-audit/2023-10-notional-VagnerAndrei26/blob/ebaf16143f4d71d84affb69258bcf00c375628d3/leveraged-vaults/tests/BaseAcceptanceTest.sol#L173-L190\nby setting the `isETH` to true firstly, and giving the ETH to the `NOTIONAL` address instead of the `vault` itself. After that I was calling the `depositFromNotional` with a specific value, which reverts all the time when it gets to `executeTrade`.  The modifications would look like this\n```solidity\n    function enterVaultBypass(\n        address account,\n        uint256 depositAmount,\n        uint256 maturity,\n        bytes memory data\n    ) internal virtual returns (uint256 vaultShares) {\n        vm.prank(address(NOTIONAL));\n        deal(address(NOTIONAL), depositAmount);\n        vaultShares = vault.depositFromNotional{value : depositAmount}(account, depositAmount, maturity, data);\n        totalVaultShares[maturity] += vaultShares;\n        totalVaultSharesAllMaturities += vaultShares;\n    }\n```\nand here is the trace logs, as you can see it revert at executeTrade, as I expected and explained in the report\n```\nRunning 1 test for tests/CrossCurrency/testCrossCurrencyVault.t.sol:TestCrossCurrency_ETH_WSTETH\n[FAIL. Reason: TradeFailed(); counterexample: calldata=0xde6f757a00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 args=[0, 0]] test_EnterVault(uint256,uint256) (runs: 0, μ: 0, ~: 0)\nLogs:\n  Bound Result 0\n  Bound Result 1000000000000000\n\nTraces:\n  [66058] TestCrossCurrency_ETH_WSTETH::test_EnterVault(0, 0)\n    ├─ [0] VM::addr(97821013814920132828181473597319662187411378784436296118592727588725089953873 [9.782e76]) [staticcall]\n    │   └─ ← account: [0x359e534d4C79745c3c0A0BC80d80cfAe9e82699e]\n    ├─ [0] VM::label(account: [0x359e534d4C79745c3c0A0BC80d80cfAe9e82699e], \"account\")\n    │   └─ ← ()\n    ├─ [0] console::log(\"Bound Result\", 0) [staticcall]\n    │   └─ ← ()\n    ├─ [0] console::log(\"Bound Result\", 1000000000000000 [1e15]) [staticcall]\n    │   └─ ← ()\n    ├─ [0] VM::prank(0x1344A36A1B56144C3Bc62E7757377D288fDE0369)\n    │   └─ ← ()\n    ├─ [0] VM::deal(0x1344A36A1B56144C3Bc62E7757377D288fDE0369, 1000000000000000 [1e15])\n    │   └─ ← ()\n    ├─ [26272] nBeaconProxy::depositFromNotional{value: 1000000000000000}(account: [0x359e534d4C79745c3c0A0BC80d80cfAe9e82699e], 1000000000000000 [1e15], 1099511627775 [1.099e12], 0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000200000000000000000000000006eb2dc694eb516b16dc9fbc678c60052bbdd7d80)\n    │   ├─ [2308] nUpgradeableBeacon::implementation() [staticcall]\n    │   │   └─ ← CrossCurrencyVault: [0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f]\n    │   ├─ [16104] CrossCurrencyVault::depositFromNotional(account: [0x359e534d4C79745c3c0A0BC80d80cfAe9e82699e], 1000000000000000 [1e15], 1099511627775 [1.099e12], 0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000200000000000000000000000006eb2dc694eb516b16dc9fbc678c60052bbdd7d80) [delegatecall]\n    │   │   ├─ [2335] 0xBf6B9c5608D520469d8c4BD1E24F850497AF0Bb8::getImplementation() [staticcall]\n    │   │   │   └─ ← 0x0000000000000000000000002de2b1eecf5bab0add9147ebbb999395238d30a5\n    │   │   ├─ [213] 0x2De2B1Eecf5bab0adD9147ebBb999395238d30a5::executeTrade(7, (0, 0x0000000000000000000000000000000000000000, 0x5979D7b546E38E414F7E9822514be443A4800529, 1000000000000000 [1e15], 0, 1699104713 [1.699e9], 0x0000000000000000000000006eb2dc694eb516b16dc9fbc678c60052bbdd7d80)) [delegatecall]\n    │   │   │   └─ ← EvmError: Revert\n    │   │   └─ ← TradeFailed()\n    │   └─ ← TradeFailed()\n    └─ ← TradeFailed()\n\nTest result: FAILED. 0 passed; 1 failed; 0 skipped; finished in 712.96ms\n\nRan 1 test suites: 0 tests passed, 1 failed, 0 skipped (1 total tests)\n\nFailing tests:\nEncountered 1 failing test in tests/CrossCurrency/testCrossCurrencyVault.t.sol:TestCrossCurrency_ETH_WSTETH\n[FAIL. Reason: TradeFailed(); counterexample: calldata=0xde6f757a000000000000000000000000000000000000000000000000000",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/119",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/common/BaseStrategyVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\nimport {Token, TokenType} from \"../../global/Types.sol\";\nimport {Deployments} from \"../../global/Deployments.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {IStrategyVault} from \"../../../interfaces/notional/IStrategyVault.sol\";\nimport {NotionalProxy} from \"../../../interfaces/notional/NotionalProxy.sol\";\nimport {ITradingModule, Trade} from \"../../../interfaces/trading/ITradingModule.sol\";\nimport {IERC20} from \"../../../interfaces/IERC20.sol\";\nimport {TokenUtils} from \"../../utils/TokenUtils.sol\";\nimport {TradeHandler} from \"../../trading/TradeHandler.sol\";\nimport {nProxy} from \"../../proxy/nProxy.sol\";\n\nabstract contract BaseStrategyVault is Initializable, IStrategyVault, AccessControlUpgradeable {\n    using TokenUtils for IERC20;\n    using TradeHandler for Trade;\n\n    bytes32 public constant EMERGENCY_EXIT_ROLE = keccak256(\"EMERGENCY_EXIT_ROLE\");\n    bytes32 public constant REWARD_REINVESTMENT_ROLE = keccak256(\"REWARD_REINVESTMENT_ROLE\");\n    bytes32 public constant STATIC_SLIPPAGE_TRADING_ROLE = keccak256(\"STATIC_SLIPPAGE_TRADING_ROLE\");\n\n    /// @notice Hardcoded on the implementation contract during deployment\n    NotionalProxy public immutable NOTIONAL;\n    ITradingModule public immutable TRADING_MODULE;\n    uint8 constant internal INTERNAL_TOKEN_DECIMALS = 8;\n\n    // Borrowing Currency ID the vault is configured with\n    uint16 private _BORROW_CURRENCY_ID;\n    // True if the underlying is ETH\n    bool private _UNDERLYING_IS_ETH;\n    // Address of the underlying token\n    IERC20 private _UNDERLYING_TOKEN;\n    // NOTE: end of first storage slot here\n\n    // Name of the vault\n    string private _NAME;\n\n\n    /**************************************************************************/\n    /* Global Modifiers, Constructor and Initializer                          */\n    /**************************************************************************/\n    modifier onlyNotional() {\n        require(msg.sender == address(NOTIONAL), \"Unauthorized\");\n        _;\n    }\n\n    modifier onlyNotionalOwner() {\n        require(msg.sender == address(NOTIONAL.owner()), \"Unauthorized\");\n        _;\n    }\n    \n    /// @notice Set the NOTIONAL address on deployment\n    constructor(NotionalProxy notional_, ITradingModule tradingModule_) initializer {\n        // Make sure we are using the correct Deployments lib\n        uint256 chainId = 42161;\n        //assembly { chainId := chainid() }\n        require(Deployments.CHAIN_ID == chainId);\n\n        NOTIONAL = notional_;\n        TRADING_MODULE = tradingModule_;\n    }\n\n    /// @notice Override this method and revert if the contract should not receive ETH.\n    /// Upgradeable proxies must have this implemented on the proxy for transfer calls\n    /// succeed (use nProxy for this).\n    receive() external virtual payable {\n        // Allow ETH transfers to succeed\n    }\n\n    /// @notice All strategy vaults MUST implement 8 decimal precision\n    function decimals() public override pure returns (uint8) {\n        return INTERNAL_TOKEN_DECIMALS;\n    }\n\n    function name() external override view returns (string memory) {\n        return _NAME;\n    }\n\n    function strategy() external virtual view returns (bytes4);\n\n    function _borrowCurrencyId() internal view returns (uint16) {\n        return _BORROW_CURRENCY_ID;\n    }\n\n    function _underlyingToken() internal view returns (IERC20) {\n        return _UNDERLYING_TOKEN;\n    }\n\n    function _isUnderlyingETH() internal view returns (bool) {\n        return _UNDERLYING_IS_ETH;\n    }\n\n    /// @notice Can only be called once during initialization\n    function __INIT_VAULT(\n        string memory name_,\n        uint16 borrowCurrencyId_\n    ) internal onlyInitializing {\n        _NAME = name_;\n        _BORROW_CURRENCY_ID = borrowCurrencyId_;\n\n        address underlyingAddress = _getNotionalUnderlyingToken(borrowCurrencyId_);\n        _UNDERLYING_TOKEN = IERC20(underlyingAddress);\n        _UNDERLYING_IS_ETH = underlyingAddress == address(0);\n        _setupRole(DEFAULT_ADMIN_ROLE, NOTIONAL.owner());\n    }\n\n    function _getNotionalUnderlyingToken(uint16 currencyId) internal view returns (address) {\n        (Token memory assetToken, Token memory underlyingToken) = NOTIONAL.getCurrency(currencyId);\n\n        return assetToken.tokenType == TokenType.NonMintable ?\n            assetToken.tokenAddress : underlyingToken.tokenAddress;\n    }\n\n    /// @notice Can be used to delegate call to the TradingModule's implementation in order to execute\n    /// a trade.\n    function _executeTrade(\n        uint16 dexId,\n        Trade memory trade\n    ) internal returns (uint256 amountSold, uint256 amountBought) {\n        return trade._executeTrade(dexId, TRADING_MODULE);\n    }\n\n    /**************************************************************************/\n    /* Virtual Methods Requiring Implementation                               */\n    /**************************************************************************/\n    function convertStrategyToUnderlying(\n        address account,\n        uint256 vaultShares,\n        uint256 maturity\n    ) public view virtual returns (int256 underlyingValue);\n\n    function getExchangeRate(uint256 maturity) external virtual view returns (int256);\n    \n    // Vaults need to implement these two methods\n    function _depositFromNotional(\n        address account,\n        uint256 deposit,\n        uint256 maturity,\n        bytes calldata data\n    ) internal virtual returns (uint256 vaultSharesMinted);\n\n    function _redeemFromNotional(\n        address account,\n        uint256 vaultShares,\n        uint256 maturity,\n        bytes calldata data\n    ) internal virtual returns (uint256 tokensFromRedeem);\n\n    function _convertVaultSharesToPrimeMaturity(\n        address /* account */,\n        uint256 /* vaultShares */,\n        uint256 /* maturity */\n    ) internal virtual returns (uint256 /* primeVaultShares */) {\n        revert();\n    }\n\n    function _checkReentrancyContext() internal virtual;\n\n    /**************************************************************************/\n    /* Default External Method Implementations                                */\n    /**************************************************************************/\n    function depositFromNotional(\n        address account,\n        uint256 deposit,\n        uint256 maturity,\n        bytes calldata data\n    ) external payable onlyNotional returns (uint256 vaultSharesMinted) {\n        return _depositFromNotional(account, deposit, maturity, data);\n    }\n\n    function redeemFromNotional(\n        address account,\n        address receiver,\n        uint256 vaultShares,\n        uint256 maturity,\n        uint256 underlyingToRepayDebt,\n        bytes calldata data\n    ) external onlyNotional returns (uint256 transferToReceiver) {\n        uint256 borrowedCurrencyAmount = _redeemFromNotional(account, vaultShares, maturity, data);\n\n        uint256 transferToNotional;\n        if (account == address(this) || borrowedCurrencyAmount <= underlyingToRepayDebt) {\n            // It may be the case that insufficient tokens were redeemed to repay the debt. If this\n            // happens the Notional will attempt to recover the shortfall from the account directly.\n            // This can happen if an account wants to reduce their leverage by paying off debt but\n            // does not want to sell strategy tokens to do so.\n            // The other situation would be that the vault is calling redemption to deleverage or\n            // settle. In that case all tokens go back to Notional.\n            transferToNotional = borrowedCurrencyAmount;\n        } else {\n            transferToNotional = underlyingToRepayDebt;\n            unchecked { transferToReceiver = borrowedCurrencyAmount - underlyingToRepayDebt; }\n        }\n\n        if (_UNDERLYING_IS_ETH) {\n            if (transferToReceiver > 0) payable(receiver).transfer(transferToReceiver);\n            if (transferToNotional > 0) payable(address(NOTIONAL)).transfer(transferToNotional);\n        } else {\n            if (transferToReceiver > 0) _UNDERLYING_TOKEN.checkTransfer(receiver, transferToReceiver);\n            if (transferToNotional > 0) _UNDERLYING_TOKEN.checkTransfer(address(NOTIONAL), transferToNotional);\n        }\n    }\n\n    function convertVaultSharesToPrimeMaturity(\n        address account,\n        uint256 vaultShares,\n        uint256 maturity\n    ) external onlyNotional returns (uint256 primeVaultShares) { \n        require(maturity != Constants.PRIME_CASH_VAULT_MATURITY);\n        return _convertVaultSharesToPrimeMaturity(account, vaultShares, maturity);\n    }\n\n    function deleverageAccount(\n        address account,\n        address vault,\n        address liquidator,\n        uint16 currencyIndex,\n        int256 depositUnderlyingInternal\n    ) external payable returns (uint256 vaultSharesFromLiquidation, int256 depositAmountPrimeCash) {\n        require(msg.sender == liquidator);\n        _checkReentrancyContext();\n        return NOTIONAL.deleverageAccount{value: msg.value}(\n            account, vault, liquidator, currencyIndex, depositUnderlyingInternal\n        );\n    }\n\n    function _canUseStaticSlippage() internal view returns (bool) {\n        return hasRole(STATIC_SLIPPAGE_TRADING_ROLE, msg.sender);\n    }\n\n    // Storage gap for future potential upgrades\n    uint256[45] private __gap;\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/CrossCurrencyVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {NotionalProxy} from \"../../interfaces/notional/NotionalProxy.sol\";\nimport {IWrappedfCashFactory} from \"../../interfaces/notional/IWrappedfCashFactory.sol\";\nimport {IWrappedfCashComplete as IWrappedfCash} from \"../../interfaces/notional/IWrappedfCash.sol\";\nimport {WETH9} from \"../../interfaces/WETH9.sol\";\n\nimport {BaseStrategyVault} from \"./common/BaseStrategyVault.sol\";\nimport {IERC20, TokenUtils} from \"../utils/TokenUtils.sol\";\nimport {TypeConvert} from \"../global/TypeConvert.sol\";\nimport {Token, TokenType} from \"../global/Types.sol\";\nimport {Constants} from \"../global/Constants.sol\";\nimport {ITradingModule, DexId, TradeType, Trade} from \"../../interfaces/trading/ITradingModule.sol\";\n\n/**\n * @notice This vault borrows in one currency, trades it to a different currency\n * and lends on Notional in that currency.\n */\ncontract CrossCurrencyVault is BaseStrategyVault {\n    using TypeConvert for uint256;\n\n    struct DepositParams {\n        // Minimum purchase amount of the lend underlying token, this is\n        // based on the deposit + borrowed amount and must be set to a non-zero\n        // value to establish a slippage limit.\n        uint256 minPurchaseAmount;\n        // Minimum final vault shares to receive\n        uint256 minVaultShares;\n        // ID of the desired DEX to trade on, _depositFromNotional will always trade\n        // using an EXACT_IN_SINGLE trade which is supported by all DEXes\n        uint16 dexId;\n        // Exchange data depending on the selected dexId\n        bytes exchangeData;\n    }\n\n    struct RedeemParams {\n        // Minimum purchase amount of the borrow underlying token, this is\n        // based on the amount of lend underlying received and must be set to a non-zero\n        // value to establish a slippage limit.\n        uint256 minPurchaseAmount;\n        // ID of the desired DEX to trade on, _depositFromNotional will always trade\n        // using an EXACT_IN_SINGLE trade which is supported by all DEXes\n        uint16 dexId;\n        // Exchange data depending on the selected dexId\n        bytes exchangeData;\n    }\n\n    IWrappedfCashFactory immutable WRAPPED_FCASH_FACTORY;\n    WETH9 immutable WETH;\n\n    uint16 public LEND_CURRENCY_ID;\n    IERC20 public LEND_UNDERLYING_TOKEN;\n    uint8 public LEND_DECIMALS;\n    uint8 public BORROW_DECIMALS;\n    bool public LEND_ETH;\n    // NOTE: 1 byte left in first storage slot here\n\n    constructor(\n        NotionalProxy notional_,\n        ITradingModule tradingModule_,\n        IWrappedfCashFactory factory,\n        WETH9 weth\n    ) BaseStrategyVault(notional_, tradingModule_) {\n        WRAPPED_FCASH_FACTORY = factory;\n        WETH = weth;\n    }\n\n    function strategy() external override pure returns (bytes4) {\n        return bytes4(keccak256(\"CrossCurrencyVault\"));\n    }\n\n    function initialize(\n        string memory name_,\n        uint16 borrowCurrencyId_,\n        uint16 lendCurrencyId_\n    ) external initializer {\n        __INIT_VAULT(name_, borrowCurrencyId_);\n\n        LEND_CURRENCY_ID = lendCurrencyId_;\n        (/* */, Token memory underlyingToken) = NOTIONAL.getCurrency(lendCurrencyId_);\n\n        LEND_ETH = underlyingToken.tokenType == TokenType.Ether;\n        IERC20 tokenAddress = IERC20(underlyingToken.tokenAddress);\n        LEND_UNDERLYING_TOKEN = tokenAddress;\n        LEND_DECIMALS = TokenUtils.getDecimals(address(tokenAddress));\n        BORROW_DECIMALS = TokenUtils.getDecimals(address(_underlyingToken()));\n    }\n\n    /// @notice Returns the wrapped fCash address which is created using CREATE2. It may be the case that\n    /// the wrapped fCash contract for a given maturity has not yet been deployed which would cause the\n    /// initial deposit for a maturity to revert in this contract. However, deployment of wrapped fCash\n    /// contracts is permissionless so likely some bot will be used to ensure the wrappers are deployed\n    /// before they are used.\n    function getWrappedFCashAddress(uint256 maturity) public view returns (IWrappedfCash) {\n        require(maturity < Constants.PRIME_CASH_VAULT_MATURITY);\n        return IWrappedfCash(WRAPPED_FCASH_FACTORY.computeAddress(LEND_CURRENCY_ID, uint40(maturity)));\n    }\n\n    /**\n     * @notice Converts the amount of fCash the vault holds into underlying denomination for the\n     * borrow currency.\n     * @param vaultShares each strategy token is equivalent to 1 unit of fCash or 1 unit of PrimeCash\n     * @param maturity the maturity of the fCash\n     * @return underlyingValue the value of the lent fCash in terms of the borrowed currency\n     */\n    function convertStrategyToUnderlying(\n        address /* account */,\n        uint256 vaultShares,\n        uint256 maturity\n    ) public override view returns (int256 underlyingValue) {\n        int256 pvExternalUnderlying;\n        if (maturity == Constants.PRIME_CASH_VAULT_MATURITY) {\n            // For Prime Cash the vaultShares will represent a pCash balance and we convert that\n            // to underlying value via Notional.\n            pvExternalUnderlying = NOTIONAL.convertCashBalanceToExternal(\n                LEND_CURRENCY_ID,\n                vaultShares.toInt(),\n                true\n            );\n        } else {\n            // For fCash we use the fCash wrapper to convert the fCash balance to PV. The fCash\n            // wrapper uses an internal Notional TWAP oracle to get the present value, this is\n            // the same TWAP oracle that is used in Notional to calculate regular portfolio\n            // collateralization.\n            pvExternalUnderlying = getWrappedFCashAddress(maturity).convertToAssets(vaultShares).toInt();\n        }\n\n        // Returns the oracle price between the lend and borrow tokens.\n        IERC20 underlyingToken = _underlyingToken();\n        (int256 rate, int256 rateDecimals) = TRADING_MODULE.getOraclePrice(\n            address(LEND_UNDERLYING_TOKEN), address(underlyingToken)\n        );\n        int256 borrowPrecision = int256(10**BORROW_DECIMALS);\n        int256 lendPrecision = int256(10**LEND_DECIMALS);\n\n        // Convert this back to the borrow currency, external precision\n        // (pv (lend decimals) * borrowDecimals * rate) / (rateDecimals * lendDecimals)\n        return (pvExternalUnderlying * borrowPrecision * rate) /\n            (rateDecimals * lendPrecision);\n    }\n\n    /// @notice Returns the current value of 1 vault share at the given maturity, used for the\n    /// user interface to collect historical values.\n    function getExchangeRate(uint256 maturity) public view override returns (int256) {\n        // This will revert for fCash maturities if the wrapper is not deployed but for simplicity in the\n        // implementation we will accept that this is ok. This method is used for the UI and in practice the\n        // historical fCash prices are accessible via other means.\n        return convertStrategyToUnderlying(address(0), uint256(Constants.INTERNAL_TOKEN_PRECISION), maturity);\n    }\n\n    /**\n     * @notice Will receive a deposit from Notional in underlying tokens of the borrowed currency.\n     * Needs to first trade that deposit into the lend currency and then lend it to fCash on the\n     * corresponding maturity.\n     * @param depositUnderlyingExternal amount of tokens deposited in the borrow currency\n     * @param maturity the maturity that was borrowed at, will also be the maturity that is lent to\n     * @param data DepositParams\n     * @return vaultShares the amount of strategy tokens (fCash lent) generated\n     */\n    function _depositFromNotional(\n        address /* account */,\n        uint256 depositUnderlyingExternal,\n        uint256 maturity,\n        bytes calldata data\n    ) internal override returns (uint256 vaultShares) {\n        if (depositUnderlyingExternal == 0) return 0;\n\n        IERC20 lendToken = LEND_UNDERLYING_TOKEN;\n        DepositParams memory params = abi.decode(data, (DepositParams));\n        Trade memory trade = Trade({\n            tradeType: TradeType.EXACT_IN_SINGLE,\n            sellToken: address(_underlyingToken()),\n            buyToken: address(lendToken),\n            amount: depositUnderlyingExternal,\n            limit: params.minPurchaseAmount,\n            deadline: block.timestamp,\n            exchangeData: params.exchangeData\n        });\n\n        // Executes a trade on the given Dex, the vault must have permissions set for\n        // each dex and token it wants to sell. Each vault will only have permissions to\n        // buy and sell the lend and borrow underlying tokens via specific dexes.\n        (/* */, uint256 lendUnderlyingTokens) = _executeTrade(params.dexId, trade);\n        bool isETH = LEND_ETH;\n\n        if (maturity == Constants.PRIME_CASH_VAULT_MATURITY) {\n            // Lend variable\n            vaultShares = _depositToPrimeCash(isETH, lendUnderlyingTokens);\n        } else {\n            // Lending fixed, the fCash wrapper uses WETH instead of ETH.\n            IWrappedfCash wfCash = getWrappedFCashAddress(maturity);\n            if (isETH) {\n                WETH.deposit{value: lendUnderlyingTokens}();\n                IERC20(address(WETH)).approve(address(wfCash), lendUnderlyingTokens);\n            } else {\n                lendToken.approve(address(wfCash), lendUnderlyingTokens);\n            }\n            vaultShares = wfCash.deposit(lendUnderlyingTokens, address(this));\n        }\n\n        // Slippage check against lending\n        require(params.minVaultShares <= vaultShares, \"Slippage: Vault Shares\");\n    }\n\n    /**\n     * @notice Withdraws lent fCash from Notional (by selling it prior to maturity or withdrawing post maturity),\n     * and trades it all back to the borrowed currency.\n     * @param vaultShares the amount of fCash to redeem\n     * @param maturity the maturity of the fCash\n     * @param data RedeemParams\n     * @return borrowedCurrencyAmount the amount of borrowed currency raised by the redemption\n     */\n    function _redeemFromNotional(\n        address /* account */,\n        uint256 vaultShares,\n        uint256 maturity,\n        bytes calldata data\n    ) internal override returns (uint256 borrowedCurrencyAmount) {\n        if (vaultShares == 0) return 0;\n        RedeemParams memory params = abi.decode(data, (RedeemParams));\n\n        address lendToken = address(LEND_UNDERLYING_TOKEN);\n        bool isETH = LEND_ETH;\n\n        uint256 balanceBefore = TokenUtils.tokenBalance(lendToken);\n        if (maturity == Constants.PRIME_CASH_VAULT_MATURITY) {\n            // It should never be possible that this contract has a negative cash balance\n            require(vaultShares <= type(uint88).max);\n\n            // Withdraws vault shares to underlying, will revert if the vault shares is\n            // greater than the \n            NOTIONAL.withdraw(LEND_CURRENCY_ID, uint88(vaultShares), true);\n        } else {\n            _redeemfCash(isETH, maturity, vaultShares);\n        }\n        uint256 balanceAfter = TokenUtils.tokenBalance(lendToken);\n        \n        // Trade back to borrow currency for repayment\n        Trade memory trade = Trade({\n            tradeType: TradeType.EXACT_IN_SINGLE,\n            sellToken: lendToken,\n            buyToken: address(_underlyingToken()),\n            amount: balanceAfter - balanceBefore,\n            // minPurchaseAmount sets a slippage limit on both the fCash and the trade\n            // from the lend currency back to the borrowed currency.\n            limit: params.minPurchaseAmount,\n            deadline: block.timestamp,\n            exchangeData: params.exchangeData\n        });\n\n        (/* */, borrowedCurrencyAmount) = _executeTrade(params.dexId, trade);\n    }\n\n    /// @notice Called by Notional during settlement for an account. The account will withdraw settled fCash\n    /// to underlying from the fCash wrapper and deposit back into Notional as Prime Cash. Vault shares in\n    /// the prime cash maturity are 1-1 with prime cash units.\n    /// @notice vaultShares the amount of fCash vault shares the account holds at maturity\n    /// @notice maturity the fCash maturity that is being settled\n    /// @return primeVaultShares the amount of prime cash deposited for this account\n    function _convertVaultSharesToPrimeMaturity(\n        address /* account */,\n        uint256 vaultShares,\n        uint256 maturity\n    ) internal override returns (uint256 primeVaultShares) { \n        bool isETH = LEND_ETH;\n        address lendToken = address(LEND_UNDERLYING_TOKEN);\n\n        uint256 balanceBefore = TokenUtils.tokenBalance(lendToken);\n        _redeemfCash(isETH, maturity, vaultShares);\n        uint256 balanceAfter = TokenUtils.tokenBalance(lendToken);\n\n        primeVaultShares = _depositToPrimeCash(isETH, balanceAfter - balanceBefore);\n    }\n\n    /// @notice Redeems fCash from the wrapper. If it is prior to maturity, the wrapper will sell the fCash\n    /// on Notional. Post maturity, the fCash wrapper will return the matured balance.\n    function _redeemfCash(bool isETH, uint256 maturity, uint256 vaultShares) private {\n        IWrappedfCash wfCash = getWrappedFCashAddress(maturity);\n        uint256 assets = wfCash.redeem(vaultShares, address(this), address(this));\n\n        if (isETH) WETH.withdraw(assets);\n    }\n\n    /// @notice Deposits some balance of tokens onto Notional to be lent as prime cash.\n    function _depositToPrimeCash(bool isETH, uint256 lendUnderlyingTokens) private returns (uint256) {\n        // Lending variable\n        if (!isETH) LEND_UNDERLYING_TOKEN.approve(address(NOTIONAL), lendUnderlyingTokens);\n        return NOTIONAL.depositUnderlyingToken{value: isETH ? lendUnderlyingTokens : 0}(\n            address(this),\n            LEND_CURRENCY_ID,\n            lendUnderlyingTokens\n        );\n    }\n\n    /// @notice No read only re-entrancy is possible for liquidations in Notional. This is because it only\n    /// uses .transfer() so there is no loss of control during ETH transfers. Also, the TWAP oracle used to\n    /// value fCash does not change within a single block. Prime Cash values also cannot be manipulated via\n    /// donation because Notional maintains its own internal accounting of the balance for each token.\n    function _checkReentrancyContext() internal override {}\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/common/BaseStrategyVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\nimport {Token, TokenType} from \"../../global/Types.sol\";\nimport {Deployments} from \"../../global/Deployments.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {IStrategyVault} from \"../../../interfaces/notional/IStrategyVault.sol\";\nimport {NotionalProxy} from \"../../../interfaces/notional/NotionalProxy.sol\";\nimport {ITradingModule, Trade} from \"../../../interfaces/trading/ITradingModule.sol\";\nimport {IERC20} from \"../../../interfaces/IERC20.sol\";\nimport {TokenUtils} from \"../../utils/TokenUtils.sol\";\nimport {TradeHandler} from \"../../trading/TradeHandler.sol\";\nimport {nProxy} from \"../../proxy/nProxy.sol\";\n\nabstract contract BaseStrategyVault is Initializable, IStrategyVault, AccessControlUpgradeable {\n    using TokenUtils for IERC20;\n    using TradeHandler for Trade;\n\n    bytes32 public constant EMERGENCY_EXIT_ROLE = keccak256(\"EMERGENCY_EXIT_ROLE\");\n    bytes32 public constant REWARD_REINVESTMENT_ROLE = keccak256(\"REWARD_REINVESTMENT_ROLE\");\n    bytes32 public constant STATIC_SLIPPAGE_TRADING_ROLE = keccak256(\"STATIC_SLIPPAGE_TRADING_ROLE\");\n\n    /// @notice Hardcoded on the implementation contract during deployment\n    NotionalProxy public immutable NOTIONAL;\n    ITradingModule public immutable TRADING_MODULE;\n    uint8 constant internal INTERNAL_TOKEN_DECIMALS = 8;\n\n    // Borrowing Currency ID the vault is configured with\n    uint16 private _BORROW_CURRENCY_ID;\n    // True if the underlying is ETH\n    bool private _UNDERLYING_IS_ETH;\n    // Address of the underlying token\n    IERC20 private _UNDERLYING_TOKEN;\n    // NOTE: end of first storage slot here\n\n    // Name of the vault\n    string private _NAME;\n\n\n    /**************************************************************************/\n    /* Global Modifiers, Constructor and Initializer                          */\n    /**************************************************************************/\n    modifier onlyNotional() {\n        require(msg.sender == address(NOTIONAL), \"Unauthorized\");\n        _;\n    }\n\n    modifier onlyNotionalOwner() {\n        require(msg.sender == address(NOTIONAL.owner()), \"Unauthorized\");\n        _;\n    }\n    \n    /// @notice Set the NOTIONAL address on deployment\n    constructor(NotionalProxy notional_, ITradingModule tradingModule_) initializer {\n        // Make sure we are using the correct Deployments lib\n        uint256 chainId = 42161;\n        //assembly { chainId := chainid() }\n        require(Deployments.CHAIN_ID == chainId);\n\n        NOTIONAL = notional_;\n        TRADING_MODULE = tradingModule_;\n    }\n\n    /// @notice Override this method and revert if the contract should not receive ETH.\n    /// Upgradeable proxies must have this implemented on the proxy for transfer calls\n    /// succeed (use nProxy for this).\n    receive() external virtual payable {\n        // Allow ETH transfers to succeed\n    }\n\n    /// @notice All strategy vaults MUST implement 8 decimal precision\n    function decimals() public override pure returns (uint8) {\n        return INTERNAL_TOKEN_DECIMALS;\n    }\n\n    function name() external override view returns (string memory) {\n        return _NAME;\n    }\n\n    function strategy() external virtual view returns (bytes4);\n\n    function _borrowCurrencyId() internal view returns (uint16) {\n        return _BORROW_CURRENCY_ID;\n    }\n\n    function _underlyingToken() internal view returns (IERC20) {\n        return _UNDERLYING_TOKEN;\n    }\n\n    function _isUnderlyingETH() internal view returns (bool) {\n        return _UNDERLYING_IS_ETH;\n    }\n\n    /// @notice Can only be called once during initialization\n    function __INIT_VAULT(\n        string memory name_,\n        uint16 borrowCurrencyId_\n    ) internal onlyInitializing {\n        _NAME = name_;\n        _BORROW_CURRENCY_ID = borrowCurrencyId_;\n\n        address underlyingAddress = _getNotionalUnderlyingToken(borrowCurrencyId_);\n        _UNDERLYING_TOKEN = IERC20(underlyingAddress);\n        _UNDERLYING_IS_ETH = underlyingAddress == address(0);\n        _setupRole(DEFAULT_ADMIN_ROLE, NOTIONAL.owner());\n    }\n\n    function _getNotionalUnderlyingToken(uint16 currencyId) internal view returns (address) {\n        (Token memory assetToken, Token memory underlyingToken) = NOTIONAL.getCurrency(currencyId);\n\n        return assetToken.tokenType == TokenType.NonMintable ?\n            assetToken.tokenAddress : underlyingToken.tokenAddress;\n    }\n\n    /// @notice Can be used to delegate call to the TradingModule's implementation in order to execute\n    /// a trade.\n    function _executeTrade(\n        uint16 dexId,\n        Trade memory trade\n    ) internal returns (uint256 amountSold, uint256 amountBought) {\n        return trade._executeTrade(dexId, TRADING_MODULE);\n    }\n\n    /**************************************************************************/\n    /* Virtual Methods Requiring Implementation                               */\n    /**************************************************************************/\n    function convertStrategyToUnderlying(\n        address account,\n        uint256 vaultShares,\n        uint256 maturity\n    ) public view virtual returns (int256 underlyingValue);\n\n    function getExchangeRate(uint256 maturity) external virtual view returns (int256);\n    \n    // Vaults need to implement these two methods\n    function _depositFromNotional(\n        address account,\n        uint256 deposit,\n        uint256 maturity,\n        bytes calldata data\n    ) internal virtual returns (uint256 vaultSharesMinted);\n\n    function _redeemFromNotional(\n        address account,\n        uint256 vaultShares,\n        uint256 maturity,\n        bytes calldata data\n    ) internal virtual returns (uint256 tokensFromRedeem);\n\n    function _convertVaultSharesToPrimeMaturity(\n        address /* account */,\n        uint256 /* vaultShares */,\n        uint256 /* maturity */\n    ) internal virtual returns (uint256 /* primeVaultShares */) {\n        revert();\n    }\n\n    function _checkReentrancyContext() internal virtual;\n\n    /**************************************************************************/\n    /* Default External Method Implementations                                */\n    /**************************************************************************/\n    function depositFromNotional(\n        address account,\n        uint256 deposit,\n        uint256 maturity,\n        bytes calldata data\n    ) external payable onlyNotional returns (uint256 vaultSharesMinted) {\n        return _depositFromNotional(account, deposit, maturity, data);\n    }\n\n    function redeemFromNotional(\n        address account,\n        address receiver,\n        uint256 vaultShares,\n        uint256 maturity,\n        uint256 underlyingToRepayDebt,\n        bytes calldata data\n    ) external onlyNotional returns (uint256 transferToReceiver) {\n        uint256 borrowedCurrencyAmount = _redeemFromNotional(account, vaultShares, maturity, data);\n\n        uint256 transferToNotional;\n        if (account == address(this) || borrowedCurrencyAmount <= underlyingToRepayDebt) {\n            // It may be the case that insufficient tokens were redeemed to repay the debt. If this\n            // happens the Notional will attempt to recover the shortfall from the account directly.\n            // This can happen if an account wants to reduce their leverage by paying off debt but\n            // does not want to sell strategy tokens to do so.\n            // The other situation would be that the vault is calling redemption to deleverage or\n            // settle. In that case all tokens go back to Notional.\n            transferToNotional = borrowedCurrencyAmount;\n        } else {\n            transferToNotional = underlyingToRepayDebt;\n            unchecked { transferToReceiver = borrowedCurrencyAmount - underlyingToRepayDebt; }\n        }\n\n        if (_UNDERLYING_IS_ETH) {\n            if (transferToReceiver > 0) payable(receiver).transfer(transferToReceiver);\n            if (transferToNotional > 0) payable(address(NOTIONAL)).transfer(transferToNotional);\n        } else {\n            if (transferToReceiver > 0) _UNDERLYING_TOKEN.checkTransfer(receiver, transferToReceiver);\n            if (transferToNotional > 0) _UNDERLYING_TOKEN.checkTransfer(address(NOTIONAL), transferToNotional);\n        }\n    }\n\n    function convertVaultSharesToPrimeMaturity(\n        address account,\n        uint256 vaultShares,\n        uint256 maturity\n    ) external onlyNotional returns (uint256 primeVaultShares) { \n        require(maturity != Constant"
    }
  ]
}