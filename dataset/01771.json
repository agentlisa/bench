{
  "Title": "3S-LENFT-L05 protocol/Lending/TokenOracle.sol: possibility of oracle prices rounding to zero",
  "Content": "#### Description\nOn [line 56](https://github.com/leNFT/contracts/blob/master/contracts/protocol/Lending/TokenOracle.sol#L56) of the TokenOracle: `return uint256(price) * (PRICE_PRECISION / feedPrecision);` there is a possibility that `(PRICE_PRECISION / feedPrecision)` rounds down to zero, leading to a returned price of 0 eth per token.\nAt the moment this should not happen, since `PRICE_PRECISION = 1e18` and `feedPrecision = 10 ** priceFeed.decimals()`, with the current chainlink AggregatorV3Interface's decimals being set to 8.\nThere is, however, the possibility that the returned decimals change in a future update, or that the team changes the PRICE_PRECISION in a future version or the protocol.\n\n#### Recommendation\nChanging line 56 to `return (uint256(price) * PRICE_PRECISION) / feedPrecision;` is safer, since if the multiplication ever overflowed, there would be an error (and the team could solve the problem by setting a new oracle with a different PRICE_PRECISION). The issue of overflow is also a lot less likely, since a uint256s can store values up to around 1.16e+77.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/protocol/Lending/TokenOracle.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.19;\n\nimport {AggregatorV3Interface} from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport {ITokenOracle} from \"../../interfaces/ITokenOracle.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title TokenOracle\n/// @author leNFT\n/// @notice A contract that provides the ETH price for a given token based on a data feed or previously set price\n/// @dev This contract implements the ITokenOracle interface and inherits from Ownable contract\n/// @dev The contract uses Chainlink's AggregatorV3Interface to get token prices from data feeds\n/// @dev The contract also defines a constant PRICE_PRECISION which is used to convert prices to the appropriate precision\ncontract TokenOracle is ITokenOracle, Ownable {\n    uint256 internal constant PRICE_PRECISION = 1e18;\n    mapping(address => uint256) private _tokenPrices;\n    mapping(address => address) private _priceFeeds;\n\n    /// @notice Check if a token is supported by the oracle (has a data feed or a previously set price)\n    /// @param token The address of the token to check\n    /// @return true if the token is supported, false otherwise\n    function isTokenSupported(\n        address token\n    ) external view override returns (bool) {\n        return _isTokenSupported(token);\n    }\n\n    /// @notice Internal function to check if a token is supported by the oracle\n    /// @param token The address of the token to check\n    /// @return true if the token is supported, false otherwise\n    function _isTokenSupported(address token) internal view returns (bool) {\n        return _priceFeeds[token] != address(0) || _tokenPrices[token] != 0;\n    }\n\n    /// @notice Get the ETH price of a token\n    /// @param token The address of the token to get the price for\n    /// @return The ETH price of the token\n    /// @dev If a data feed is available, the price is returned from the data feed\n    /// @dev If there's no data feed we return the previously set price on the mapping _tokenPrices[] set by the function setTokenETHPrice()\n    function getTokenETHPrice(\n        address token\n    ) external view override returns (uint256, uint256) {\n        // Make sure the token price is available in the contract\n        require(_isTokenSupported(token), \"TO:GTEP:TOKEN_NOT_SUPPORTED\");\n\n        // If a data feed is available return price from it\n        if (_priceFeeds[token] != address(0)) {\n            AggregatorV3Interface priceFeed = AggregatorV3Interface(\n                _priceFeeds[token]\n            );\n\n            uint256 feedPrecision = 10 ** priceFeed.decimals();\n\n            (, int price, , , ) = priceFeed.latestRoundData();\n\n            return (\n                (uint256(price) * PRICE_PRECISION) / feedPrecision,\n                PRICE_PRECISION\n            );\n        }\n\n        // If there's no data feed we return the previously set price\n        return (_tokenPrices[token], PRICE_PRECISION);\n    }\n\n    /// @notice Set a data feed for a token\n    /// @param token The address of the token to add a data feed for\n    /// @param priceFeed The address of the Chainlink price feed for the token\n    /// @dev Data feeds should return the price of the token in relation to ETH (e.g. 1 ETH = 1620.15597772 USDC)\n    function setTokenETHDataFeed(\n        address token,\n        address priceFeed\n    ) external override onlyOwner {\n        _priceFeeds[token] = priceFeed;\n    }\n\n    /// @notice Set the ETH price for a token\n    /// @param token The address of the token to set the price for\n    /// @param price The ETH price of the token\n    function setTokenETHPrice(\n        address token,\n        uint256 price\n    ) external override onlyOwner {\n        _tokenPrices[token] = price;\n    }\n}"
    }
  ]
}