{
  "Title": "[N-06] Relayer can choose amount of gas when calling function in meta-transactions",
  "Content": "\nThe `LensHub` contract supports the relaying of calls for several functions using a supplied signature. For example, users can provide a `signature` alongside the usual parameters in `setProfileMetadataURIWithSig()` for a relayer to call the function on his behalf:\n\n[LensHub.sol#L119-L123](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/LensHub.sol#L119-L123)\n\n```solidity\n    function setProfileMetadataURIWithSig(\n        uint256 profileId,\n        string calldata metadataURI,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(signature.signer, profileId) {\n```\n\nHowever, the parameters above do not include a gas parameter, which means the relayer can specify any gas amount. \n\nIf the provided gas amount is insufficient, the entire transaction will revert. However, if the function exhibits different behaviour depending on the supplied gas (which might occur in modules), a relayer could potentially influence the outcome of the call by manipulating the gas amount.\n\n### Recommendation\n\nFor all functions used for meta-transactions, consider adding a `gas` parameter that allows users to specify the gas amount the function should be called with. This `gas` parameter should be included in the hash digest when verifying the user's signature.\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-07-lens-findings/issues/168#issuecomment-1704408187):**\n > Also note among the downgraded findings that were considered in scoring:<br>\n> - [#138](https://github.com/code-423n4/2023-07-lens-findings/issues/138): `transactionExecutor` is incorrectly set to relayer instead of signer in `setFollowModuleWithSig()`\n> - [#139](https://github.com/code-423n4/2023-07-lens-findings/issues/139): Precomputed `LENS_HUB_CACHED_POLYGON_DOMAIN_SEPARATOR` will become incorrect if Polygon hard forks\n> \n> Overall outstanding work!\n\n**[donosonaumczuk (Lens) commented](https://github.com/code-423n4/2023-07-lens-findings/issues/168#issuecomment-1832635699):**\n> [L-06] Does not make sense, you can always add checks for things that your business logic does not allow, but what is the point? A mirror cannot initialize a publication action, and that's part of the core business logic, so no extra checks needed.<br>\n> [N-06] That is perfectly fine and fair! This is not an issue.\n\n**[donosonaumczuk (Lens) commented](https://github.com/code-423n4/2023-07-lens-findings/issues/168#issuecomment-1847520365):**\n> [L-05] This is by design. Also \"switching back to a previous config might potentially give the previous owner the ability to steal the profile\" is invalid, as delegated executors have only rights over social operations (e.g. post, comment, follow, etc) but not over asset operations (e.g. approve, transferFrom, etc).\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-07-lens",
  "Code": [
    {
      "filename": "contracts/LensHub.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\n// Interfaces\nimport {ILensProtocol} from 'contracts/interfaces/ILensProtocol.sol';\nimport {IFollowNFT} from 'contracts/interfaces/IFollowNFT.sol';\n\n// Constants\nimport {Types} from 'contracts/libraries/constants/Types.sol';\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\n\n// Lens Hub Components\nimport {LensHubStorage} from 'contracts/base/LensHubStorage.sol';\nimport {LensImplGetters} from 'contracts/base/LensImplGetters.sol';\nimport {LensGovernable} from 'contracts/base/LensGovernable.sol';\nimport {LensProfiles} from 'contracts/base/LensProfiles.sol';\nimport {LensHubEventHooks} from 'contracts/base/LensHubEventHooks.sol';\n\n// Libraries\nimport {ActionLib} from 'contracts/libraries/ActionLib.sol';\nimport {LegacyCollectLib} from 'contracts/libraries/LegacyCollectLib.sol';\nimport {FollowLib} from 'contracts/libraries/FollowLib.sol';\nimport {MetaTxLib} from 'contracts/libraries/MetaTxLib.sol';\nimport {ProfileLib} from 'contracts/libraries/ProfileLib.sol';\nimport {PublicationLib} from 'contracts/libraries/PublicationLib.sol';\nimport {StorageLib} from 'contracts/libraries/StorageLib.sol';\nimport {ValidationLib} from 'contracts/libraries/ValidationLib.sol';\n\n// Lens Migrations V1 to V2\nimport {LensV2Migration} from 'contracts/misc/LensV2Migration.sol';\n\n/**\n * @title LensHub\n * @author Lens Protocol\n *\n * @notice This is the main entry point of the Lens Protocol. It contains governance functionality as well as\n * publishing and profile interaction functionality.\n *\n * NOTE: The Lens Protocol is unique in that frontend operators need to track a potentially overwhelming\n * number of NFT contracts and interactions at once. For that reason, we've made two quirky design decisions:\n *      1. Both Follow & Collect NFTs invoke a LensHub callback on transfer with the sole purpose of emitting an event.\n *      2. Almost every event in the protocol emits the current block timestamp, reducing the need to fetch it manually.\n */\ncontract LensHub is\n    LensProfiles,\n    LensGovernable,\n    LensV2Migration,\n    LensImplGetters,\n    LensHubEventHooks,\n    LensHubStorage,\n    ILensProtocol\n{\n    modifier onlyProfileOwnerOrDelegatedExecutor(address expectedOwnerOrDelegatedExecutor, uint256 profileId) {\n        ValidationLib.validateAddressIsProfileOwnerOrDelegatedExecutor(expectedOwnerOrDelegatedExecutor, profileId);\n        _;\n    }\n\n    modifier whenPublishingEnabled() {\n        if (StorageLib.getState() != Types.ProtocolState.Unpaused) {\n            revert Errors.PublishingPaused();\n        }\n        _;\n    }\n\n    constructor(\n        address moduleGlobals,\n        address followNFTImpl,\n        address collectNFTImpl, // We still pass the deprecated CollectNFTImpl for legacy Collects to work\n        address lensHandlesAddress,\n        address tokenHandleRegistryAddress,\n        address legacyFeeFollowModule,\n        address legacyProfileFollowModule,\n        address newFeeFollowModule,\n        uint256 tokenGuardianCooldown\n    )\n        LensProfiles(moduleGlobals, tokenGuardianCooldown)\n        LensV2Migration(\n            legacyFeeFollowModule,\n            legacyProfileFollowModule,\n            newFeeFollowModule,\n            lensHandlesAddress,\n            tokenHandleRegistryAddress\n        )\n        LensImplGetters(followNFTImpl, collectNFTImpl)\n    {}\n\n    /// @inheritdoc ILensProtocol\n    function createProfile(Types.CreateProfileParams calldata createProfileParams)\n        external\n        override\n        whenNotPaused\n        returns (uint256)\n    {\n        ValidationLib.validateProfileCreatorWhitelisted(msg.sender);\n        unchecked {\n            uint256 profileId = ++_profileCounter;\n            _mint(createProfileParams.to, profileId);\n            ProfileLib.createProfile(createProfileParams, profileId);\n            return profileId;\n        }\n    }\n\n    ///////////////////////////////////////////\n    ///        PROFILE OWNER FUNCTIONS      ///\n    ///////////////////////////////////////////\n\n    /// @inheritdoc ILensProtocol\n    function setProfileMetadataURI(uint256 profileId, string calldata metadataURI)\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, profileId)\n    {\n        ProfileLib.setProfileMetadataURI(profileId, metadataURI);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setProfileMetadataURIWithSig(\n        uint256 profileId,\n        string calldata metadataURI,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(signature.signer, profileId) {\n        MetaTxLib.validateSetProfileMetadataURISignature(signature, profileId, metadataURI);\n        ProfileLib.setProfileMetadataURI(profileId, metadataURI);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setFollowModule(\n        uint256 profileId,\n        address followModule,\n        bytes calldata followModuleInitData\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(msg.sender, profileId) {\n        ProfileLib.setFollowModule(profileId, followModule, followModuleInitData);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setFollowModuleWithSig(\n        uint256 profileId,\n        address followModule,\n        bytes calldata followModuleInitData,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(signature.signer, profileId) {\n        MetaTxLib.validateSetFollowModuleSignature(signature, profileId, followModule, followModuleInitData);\n        ProfileLib.setFollowModule(profileId, followModule, followModuleInitData);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function changeDelegatedExecutorsConfig(\n        uint256 delegatorProfileId,\n        address[] calldata delegatedExecutors,\n        bool[] calldata approvals,\n        uint64 configNumber,\n        bool switchToGivenConfig\n    ) external override whenNotPaused onlyProfileOwner(msg.sender, delegatorProfileId) {\n        ProfileLib.changeGivenDelegatedExecutorsConfig(\n            delegatorProfileId,\n            delegatedExecutors,\n            approvals,\n            configNumber,\n            switchToGivenConfig\n        );\n    }\n\n    function changeDelegatedExecutorsConfig(\n        uint256 delegatorProfileId,\n        address[] calldata delegatedExecutors,\n        bool[] calldata approvals\n    ) external override whenNotPaused onlyProfileOwner(msg.sender, delegatorProfileId) {\n        ProfileLib.changeDelegatedExecutorsConfig(delegatorProfileId, delegatedExecutors, approvals);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function changeDelegatedExecutorsConfigWithSig(\n        uint256 delegatorProfileId,\n        address[] calldata delegatedExecutors,\n        bool[] calldata approvals,\n        uint64 configNumber,\n        bool switchToGivenConfig,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwner(signature.signer, delegatorProfileId) {\n        MetaTxLib.validateChangeDelegatedExecutorsConfigSignature(\n            signature,\n            delegatorProfileId,\n            delegatedExecutors,\n            approvals,\n            configNumber,\n            switchToGivenConfig\n        );\n        ProfileLib.changeGivenDelegatedExecutorsConfig(\n            delegatorProfileId,\n            delegatedExecutors,\n            approvals,\n            configNumber,\n            switchToGivenConfig\n        );\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setProfileImageURI(uint256 profileId, string calldata imageURI)\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, profileId)\n    {\n        ProfileLib.setProfileImageURI(profileId, imageURI);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setProfileImageURIWithSig(\n        uint256 profileId,\n        string calldata imageURI,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(signature.signer, profileId) {\n        MetaTxLib.validateSetProfileImageURISignature(signature, profileId, imageURI);\n        ProfileLib.setProfileImageURI(profileId, imageURI);\n    }\n\n    ////////////////////////////////////////\n    ///        PUBLISHING FUNCTIONS      ///\n    ////////////////////////////////////////\n\n    /// @inheritdoc ILensProtocol\n    function post(Types.PostParams calldata postParams)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, postParams.profileId)\n        returns (uint256)\n    {\n        return PublicationLib.post({postParams: postParams, transactionExecutor: msg.sender});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function postWithSig(Types.PostParams calldata postParams, Types.EIP712Signature calldata signature)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, postParams.profileId)\n        returns (uint256)\n    {\n        MetaTxLib.validatePostSignature(signature, postParams);\n        return PublicationLib.post({postParams: postParams, transactionExecutor: signature.signer});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function comment(Types.CommentParams calldata commentParams)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, commentParams.profileId)\n        returns (uint256)\n    {\n        return PublicationLib.comment({commentParams: commentParams, transactionExecutor: msg.sender});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function commentWithSig(Types.CommentParams calldata commentParams, Types.EIP712Signature calldata signature)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, commentParams.profileId)\n        returns (uint256)\n    {\n        MetaTxLib.validateCommentSignature(signature, commentParams);\n        return PublicationLib.comment({commentParams: commentParams, transactionExecutor: signature.signer});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function mirror(Types.MirrorParams calldata mirrorParams)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, mirrorParams.profileId)\n        returns (uint256)\n    {\n        return PublicationLib.mirror({mirrorParams: mirrorParams, transactionExecutor: msg.sender});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function mirrorWithSig(Types.MirrorParams calldata mirrorParams, Types.EIP712Signature calldata signature)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, mirrorParams.profileId)\n        returns (uint256)\n    {\n        MetaTxLib.validateMirrorSignature(signature, mirrorParams);\n        return PublicationLib.mirror({mirrorParams: mirrorParams, transactionExecutor: signature.signer});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function quote(Types.QuoteParams calldata quoteParams)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, quoteParams.profileId)\n        returns (uint256)\n    {\n        return PublicationLib.quote({quoteParams: quoteParams, transactionExecutor: msg.sender});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function quoteWithSig(Types.QuoteParams calldata quoteParams, Types.EIP712Signature calldata signature)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, quoteParams.profileId)\n        returns (uint256)\n    {\n        MetaTxLib.validateQuoteSignature(signature, quoteParams);\n        return PublicationLib.quote({quoteParams: quoteParams, transactionExecutor: signature.signer});\n    }\n\n    /////////////////////////////////////////////////\n    ///        PROFILE INTERACTION FUNCTIONS      ///\n    /////////////////////////////////////////////////\n\n    /// @inheritdoc ILensProtocol\n    function follow(\n        uint256 followerProfileId,\n        uint256[] calldata idsOfProfilesToFollow,\n        uint256[] calldata followTokenIds,\n        bytes[] calldata datas\n    )\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, followerProfileId)\n        returns (uint256[] memory)\n    {\n        return\n            FollowLib.follow({\n                followerProfileId: followerProfileId,\n                idsOfProfilesToFollow: idsOfProfilesToFollow,\n                followTokenIds: followTokenIds,\n                followModuleDatas: datas,\n                transactionExecutor: msg.sender\n            });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function followWithSig(\n        uint256 followerProfileId,\n        uint256[] calldata idsOfProfilesToFollow,\n        uint256[] calldata followTokenIds,\n        bytes[] calldata datas,\n        Types.EIP712Signature calldata signature\n    )\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, followerProfileId)\n        returns (uint256[] memory)\n    {\n        MetaTxLib.validateFollowSignature(signature, followerProfileId, idsOfProfilesToFollow, followTokenIds, datas);\n        return\n            FollowLib.follow({\n                followerProfileId: followerProfileId,\n                idsOfProfilesToFollow: idsOfProfilesToFollow,\n                followTokenIds: followTokenIds,\n                followModuleDatas: datas,\n                transactionExecutor: signature.signer\n            });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function unfollow(uint256 unfollowerProfileId, uint256[] calldata idsOfProfilesToUnfollow)\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, unfollowerProfileId)\n    {\n        FollowLib.unfollow({\n            unfollowerProfileId: unfollowerProfileId,\n            idsOfProfilesToUnfollow: idsOfProfilesToUnfollow,\n            transactionExecutor: msg.sender\n        });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function unfollowWithSig(\n        uint256 unfollowerProfileId,\n        uint256[] calldata idsOfProfilesToUnfollow,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(signature.signer, unfollowerProfileId) {\n        MetaTxLib.validateUnfollowSignature(signature, unfollowerProfileId, idsOfProfilesToUnfollow);\n\n        FollowLib.unfollow({\n            unfollowerProfileId: unfollowerProfileId,\n            idsOfProfilesToUnfollow: idsOfProfilesToUnfollow,\n            transactionExecutor: signature.signer\n        });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setBlockStatus(\n        uint256 byProfileId,\n        uint256[] calldata idsOfProfilesToSetBlockStatus,\n        bool[] calldata blockStatus\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(msg.sender, byProfileId) {\n        return ProfileLib.setBlockStatus(byProfileId, idsOfProfilesToSetBlockStatus, blockStatus);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setBlockStatusWithSig(\n        uint256 byProfileId,\n        uint256[] calldata idsOfProfilesToSetBlockStatus,\n        bool[] calldata blockStatus,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(signature.signer, byProfileId) {\n        MetaTxLib.validateSetBlockStatusSignature(signature, byProfileId, idsOfProfilesToSetBlockStatus, blockStatus);\n        return ProfileLib.setBlockStatus(byProfileId, idsOfProfilesToSetBlockStatus, blockStatus);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function collect(Types.CollectParams calldata collectParams)\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, collectParams.collectorProfileId)\n        returns (uint256)\n    {\n        return\n            LegacyCollectLib.collect({\n                collectParams: collectParams,\n                transactionExecutor: msg.sender,\n                collectorProfileOwner: ownerOf(collectParams.collectorProfileId),\n                collectNFTImpl: this.getCollectNFTImpl()\n            });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function collectWithSig(Types.CollectParams calldata collectParams, Types.EIP712Signature calldata signature)\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, collectParams.collectorProfileId)\n        returns (uint256)\n    {\n        MetaTxLib.validateLegacyCollectSignature(signature, collectParams);\n        return\n            LegacyCollectLib.collect({\n                collectParams: collectParams,\n                transactionExecutor: signature.signer,\n                collectorProfileOwner: ownerOf(collectParams.collectorProfileId),\n                collectNFTImpl: this.getCollectNFTImpl()\n            });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function act(Types.PublicationActionParams calldata publicationActionParams)\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, publicationActionParams.actorProfileId)\n        returns (bytes memory)\n    {\n        return\n            ActionLib.act({\n                publicationActionParams: publicationActionParams,\n                transactionExecutor: msg.sender,\n                actorProfileOwner: ownerOf(publicationActionParams.actorProfileId)\n            });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function actWithSig(\n        Types.PublicationActionParams calldata publicationActionParams,\n        Types.EIP712Signature calldata signature\n    )\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, publicationActionParams.actorProfileId)\n        returns (bytes memory)\n    {\n        MetaTxLib.validateActSignature(signature, publicationActionParams);\n        return\n            ActionLib.act({\n                publicationActionParams: publicationActionParams,\n                transactionExecutor: signature.signer,\n                actorProfileOwner: ownerOf(publicationActionParams.actorProfileId)\n            });\n    }\n\n    ///////////////////////////////////////////\n    ///        EXTERNAL VIEW FUNCTIONS      ///\n    ///////////////////////////////////////////\n\n    /// @inheritdoc ILensProtocol\n    function isFollowing(uint256 followerProfileId, uint256 followedProfileId) external view returns (bool) {\n        address followNFT = _profiles[followedProfileId].followNFT;\n        return followNFT != address(0) && IFollowNFT(followNFT).isFollowing(followerProfileId);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function isDelegatedExecutorApproved(\n        uint256 delegatorProfileId,\n        address delegatedExecutor,\n        uint64 configNumber\n    ) external view returns (bool) {\n        return StorageLib.getDelegatedExecutorsConfig(delegatorProfileId).isApproved[configNumber][delegatedExecutor];\n    }\n\n    /// @inheritdoc ILensProtocol\n    function isDelegatedExecutorApproved(uint256 delegatorProfileId, address delegatedExecutor)\n        external\n        view\n        returns (bool)\n    {\n        return ProfileLib.isExecutorApproved(delegatorProfileId, delegatedExecutor);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getDelegatedExecutorsConfigNumber(uint256 delegatorProfileId) external view returns (uint64) {\n        return StorageLib.getDelegatedExecutorsConfig(delegatorProfileId).configNumber;\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getDelegatedExecutorsPrevConfigNumber(uint256 delegatorProfileId) external view returns (uint64) {\n        return StorageLib.getDelegatedExecutorsConfig(delegatorProfileId).prevConfigNumber;\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getDelegatedExecutorsMaxConfigNumberSet(uint256 delegatorProfileId) external view returns (uint64) {\n        return StorageLib.getDelegatedExecutorsConfig(delegatorProfileId).maxConfigNumberSet;\n    }\n\n    /// @inheritdoc ILensProtocol\n    function isBlocked(uint256 profileId, uint256 byProfileId) external view returns (bool) {\n        return _blockedStatus[byProfileId][profileId];\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getContentURI(uint256 profileId, uint256 pubId) external view override returns (string memory) {\n        // This function is used by the Collect NFTs' tokenURI function.\n        return PublicationLib.getContentURI(profileId, pubId);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getProfile(uint256 profileId) external view override returns (Types.Profile memory) {\n        return _profiles[profileId];\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getPublication(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (Types.Publication memory)\n    {\n        return _publications[profileId][pubId];\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getPublicationType(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (Types.PublicationType)\n    {\n        return PublicationLib.getPublicationType(profileId, pubId);\n    }\n\n    function getActionModuleById(uint256 id) external view override returns (address) {\n        return _actionModules[id];\n    }\n}"
    }
  ]
}