{
  "Title": "[G-06] Unchecking arithmetics operations that can't underflow/overflow",
  "Content": "<h2 id=\"g-06-unchecking-arithmetics-operations-that-cant-underflowoverflow\" style=\"position:relative;\"><a href=\"#g-06-unchecking-arithmetics-operations-that-cant-underflowoverflow\" aria-label=\"g 06 unchecking arithmetics operations that cant underflowoverflow permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[G-06] Unchecking arithmetics operations that can’t underflow/overflow</h2>\n<p>Solidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers. When an overflow or an underflow isn’t possible (as an example, when a comparison is made before the arithmetic operation), some gas can be saved by using an <code>unchecked</code> block: <a href=\"https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic\">https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic</a></p>\n<p>Consider wrapping with an <code>unchecked</code> block here (around <strong>25 gas saved</strong> per instance):</p>\n<ul>\n<li>File: <a href=\"https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/actions/automated/MIMOAutoAction.sol#L97-L101\">MIMOAutoAction.sol</a></li>\n</ul>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"52\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter\" aria-hidden=\"true\"></span><span class=\"grvsc-source\"><span class=\"mtk7\">097</span><span class=\"mtk1\">:     </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">swapResultValue</span><span class=\"mtk1\"> &gt;= </span><span class=\"mtk12\">rebalanceValue</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter\" aria-hidden=\"true\"></span><span class=\"grvsc-source\"><span class=\"mtk7\">098</span><span class=\"mtk1\">:       </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk4\">true</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter\" aria-hidden=\"true\"></span><span class=\"grvsc-source\"><span class=\"mtk7\">099</span><span class=\"mtk1\">:     }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter\" aria-hidden=\"true\"></span><span class=\"grvsc-source\"><span class=\"mtk7\">100</span><span class=\"mtk1\">: </span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"97\"></span><span class=\"grvsc-source\"><span class=\"mtk7\">101</span><span class=\"mtk1\">:     </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">vaultVariation</span><span class=\"mtk1\"> = (</span><span class=\"mtk12\">rebalanceValue</span><span class=\"mtk1\"> - </span><span class=\"mtk12\">swapResultValue</span><span class=\"mtk1\">).</span><span class=\"mtk11\">wadDiv</span><span class=\"mtk1\">(</span><span class=\"mtk12\">rebalanceValue</span><span class=\"mtk1\">); </span></span></span></code></pre>\n<ul>\n<li>File: <a href=\"https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/actions/managed/MIMOManagedAction.sol#L120-L124\">MIMOManagedAction.sol</a></li>\n</ul>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"53\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter\" aria-hidden=\"true\"></span><span class=\"grvsc-source\"><span class=\"mtk7\">120</span><span class=\"mtk1\">:     </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">swapResultValue</span><span class=\"mtk1\"> &gt;= </span><span class=\"mtk12\">rebalanceValue</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter\" aria-hidden=\"true\"></span><span class=\"grvsc-source\"><span class=\"mtk7\">121</span><span class=\"mtk1\">:       </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk4\">true</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter\" aria-hidden=\"true\"></span><span class=\"grvsc-source\"><span class=\"mtk7\">122</span><span class=\"mtk1\">:     }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter\" aria-hidden=\"true\"></span><span class=\"grvsc-source\"><span class=\"mtk7\">123</span><span class=\"mtk1\">: </span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"120\"></span><span class=\"grvsc-source\"><span class=\"mtk7\">124</span><span class=\"mtk1\">:     </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">vaultVariation</span><span class=\"mtk1\"> = (</span><span class=\"mtk12\">rebalanceValue</span><span class=\"mtk1\"> - </span><span class=\"mtk12\">swapResultValue</span><span class=\"mtk1\">).</span><span class=\"mtk11\">wadDiv</span><span class=\"mtk1\">(</span><span class=\"mtk12\">rebalanceValue</span><span class=\"mtk1\">); </span></span></span></code></pre>\n<ul>\n<li>File: <a href=\"https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/actions/MIMOLeverage.sol#L132-L133\">MIMOLeverage.sol</a></li>\n</ul>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"54\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter\" aria-hidden=\"true\"></span><span class=\"grvsc-source\"><span class=\"mtk7\">132</span><span class=\"mtk1\">:     </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">collateralBalanceAfter</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk12\">flashloanRepayAmount</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"132\"></span><span class=\"grvsc-source\"><span class=\"mtk7\">133</span><span class=\"mtk1\">:       </span><span class=\"mtk12\">token</span><span class=\"mtk1\">.</span><span class=\"mtk11\">safeIncreaseAllowance</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk12\">core</span><span class=\"mtk1\">), </span><span class=\"mtk12\">collateralBalanceAfter</span><span class=\"mtk1\"> - </span><span class=\"mtk12\">flashloanRepayAmount</span><span class=\"mtk1\">); </span></span></span></code></pre>\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-08-mimo-august-2022-contest",
  "Code": [
    {
      "filename": "contracts/actions/automated/MIMOAutoAction.sol",
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\nimport \"./interfaces/IMIMOAutoAction.sol\";\nimport \"../../core/interfaces/IAddressProvider.sol\";\nimport { CustomErrors } from \"../../libraries/CustomErrors.sol\";\nimport \"../../libraries/WadRayMath.sol\";\n\ncontract MIMOAutoAction is IMIMOAutoAction {\n  using WadRayMath for uint256;\n\n  IAddressProvider public immutable a;\n  IMIMOProxyRegistry public immutable proxyRegistry;\n\n  mapping(uint256 => AutomatedVault) internal _automatedVaults;\n  mapping(uint256 => uint256) internal _operationTracker;\n\n  constructor(IAddressProvider _a, IMIMOProxyRegistry _proxyRegistry) {\n    if (address(_a) == address(0) || address(_proxyRegistry) == address(0)) {\n      revert CustomErrors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    a = _a;\n    proxyRegistry = _proxyRegistry;\n  }\n\n  /**\n    @notice Sets a vault automation parameters\n    @dev Can only be called by vault owner\n    @param vaultId Vault id of the vault to be automated\n    @param autoParams AutomatedVault struct containing all automation parameters\n   */\n  function setAutomation(uint256 vaultId, AutomatedVault calldata autoParams) external override {\n    address vaultOwner = a.vaultsData().vaultOwner(vaultId);\n    address mimoProxy = address(proxyRegistry.getCurrentProxy(msg.sender));\n\n    if (mimoProxy != vaultOwner && vaultOwner != msg.sender) {\n      revert CustomErrors.CALLER_NOT_VAULT_OWNER(mimoProxy, vaultOwner);\n    }\n\n    uint256 toVaultMcr = a.config().collateralMinCollateralRatio(autoParams.toCollateral);\n    uint256 maxVarFee = (autoParams.targetRatio.wadDiv(toVaultMcr + autoParams.mcrBuffer) + WadRayMath.WAD).wadDiv(\n      autoParams.targetRatio\n    );\n\n    if (autoParams.varFee >= maxVarFee) {\n      revert CustomErrors.VARIABLE_FEE_TOO_HIGH(maxVarFee, autoParams.varFee);\n    }\n\n    _automatedVaults[vaultId] = autoParams;\n\n    emit AutomationSet(vaultId, autoParams);\n  }\n\n  /**\n    @return AutomatedVault struct of a specific vault id\n   */\n  function getAutomatedVault(uint256 vaultId) external view override returns (AutomatedVault memory) {\n    return _automatedVaults[vaultId];\n  }\n\n  /**\n    @return Timestamp of the last performed operation\n   */\n  function getOperationTracker(uint256 vaultId) external view override returns (uint256) {\n    return _operationTracker[vaultId];\n  }\n\n  /**\n    @notice Helper function calculating a vault's net value and LTV ratio\n    @param vaultId Vault id of the vault for which to return info\n    @return vaultRatio Vault collateral value / vault debt\n    @return vaultState VaultState struct of the target vault\n   */\n  function _getVaultStats(uint256 vaultId) internal view returns (uint256 vaultRatio, VaultState memory vaultState) {\n    IAddressProvider _a = a;\n    IVaultsDataProvider vaultsData = _a.vaultsData();\n    IPriceFeed priceFeed = _a.priceFeed();\n\n    uint256 collateralBalance = vaultsData.vaultCollateralBalance(vaultId);\n    address collateralType = vaultsData.vaultCollateralType(vaultId);\n    uint256 collateralValue = priceFeed.convertFrom(collateralType, collateralBalance);\n    uint256 vaultDebt = vaultsData.vaultDebt(vaultId);\n    vaultRatio = vaultDebt == 0 ? type(uint256).max : collateralValue.wadDiv(vaultDebt);\n\n    vaultState = VaultState({ collateralType: collateralType, collateralValue: collateralValue, vaultDebt: vaultDebt });\n  }\n\n  /**\n    @notice Helper function determining if a vault value variation is within vault's management parameters\n    @return True if value change is below allowedVariation and false if it is above\n   */\n  function _isVaultVariationAllowed(\n    AutomatedVault memory autoVault,\n    uint256 rebalanceValue,\n    uint256 swapResultValue\n  ) internal pure returns (bool) {\n    if (swapResultValue >= rebalanceValue) {\n      return true;\n    }\n\n    uint256 vaultVariation = (rebalanceValue - swapResultValue).wadDiv(rebalanceValue);\n\n    if (vaultVariation > autoVault.allowedVariation) {\n      return false;\n    }\n\n    return true;\n  }\n}"
    },
    {
      "filename": "contracts/actions/managed/MIMOManagedAction.sol",
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\nimport \"./interfaces/IMIMOManagedAction.sol\";\nimport { CustomErrors } from \"../../libraries/CustomErrors.sol\";\nimport \"../../core/interfaces/IAddressProvider.sol\";\nimport \"../../libraries/WadRayMath.sol\";\n\ncontract MIMOManagedAction is IMIMOManagedAction {\n  using WadRayMath for uint256;\n\n  IAddressProvider public immutable a;\n  IMIMOProxyRegistry public immutable proxyRegistry;\n\n  mapping(uint256 => ManagedVault) internal _managedVaults;\n  mapping(uint256 => uint256) internal _operationTracker;\n  mapping(address => bool) internal _managers;\n\n  constructor(IAddressProvider _a, IMIMOProxyRegistry _proxyRegistry) {\n    if (address(_a) == address(0) || address(_proxyRegistry) == address(0)) {\n      revert CustomErrors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    a = _a;\n    proxyRegistry = _proxyRegistry;\n  }\n\n  /**\n    @notice Sets a vault management parameters\n    @dev Can only be called by vault owner and can only appoint whitelisting managers as manger\n    @param vaultId Vault id of the vault to be put under management\n    @param mgtParams ManagedVault struct containing all management parameters\n   */\n  function setManagement(uint256 vaultId, ManagedVault calldata mgtParams) external override {\n    address vaultOwner = a.vaultsData().vaultOwner(vaultId);\n    address mimoProxy = address(proxyRegistry.getCurrentProxy(msg.sender));\n\n    if (mimoProxy != vaultOwner && vaultOwner != msg.sender) {\n      revert CustomErrors.CALLER_NOT_VAULT_OWNER(mimoProxy, vaultOwner);\n    }\n    if (!_managers[mgtParams.manager]) {\n      revert CustomErrors.MANAGER_NOT_LISTED();\n    }\n\n    _managedVaults[vaultId] = mgtParams;\n\n    emit ManagementSet(vaultId, mgtParams);\n  }\n\n  /**\n    @notice Whitelists or removes a manager\n    @dev Can only be called by protocol manager\n    @param manager Manager address\n    @param isManager Bool value indicating if an address is allowed to manage user vaults or not\n   */\n  function setManager(address manager, bool isManager) external override {\n    IAccessController controller = a.controller();\n\n    if (!controller.hasRole(controller.MANAGER_ROLE(), msg.sender)) {\n      revert CustomErrors.CALLER_NOT_PROTOCOL_MANAGER();\n    }\n\n    _managers[manager] = isManager;\n\n    emit ManagerSet(manager, isManager);\n  }\n\n  /**\n    @return ManagedVault struct of a specific vault id\n   */\n  function getManagedVault(uint256 vaultId) external view override returns (ManagedVault memory) {\n    return _managedVaults[vaultId];\n  }\n\n  /**\n    @return Timestamp of the last performed operation\n   */\n  function getOperationTracker(uint256 vaultId) external view override returns (uint256) {\n    return _operationTracker[vaultId];\n  }\n\n  /**\n    @return Bool value indicating if an address is allowed to manage user vaults or not\n   */\n  function getManager(address manager) external view override returns (bool) {\n    return _managers[manager];\n  }\n\n  /**\n    @notice Helper function calculating LTV ratio\n    @return Vault collateral value / vault debt\n   */\n  function _getVaultRatio(uint256 vaultId) internal view returns (uint256) {\n    IAddressProvider _a = a;\n    IVaultsDataProvider vaultsData = _a.vaultsData();\n    IPriceFeed priceFeed = _a.priceFeed();\n\n    uint256 collateralBalance = vaultsData.vaultCollateralBalance(vaultId);\n    address collateralType = vaultsData.vaultCollateralType(vaultId);\n    uint256 collateralValue = priceFeed.convertFrom(collateralType, collateralBalance);\n    uint256 vaultDebt = vaultsData.vaultDebt(vaultId);\n\n    if (vaultDebt == 0) {\n      return (type(uint256).max);\n    }\n\n    uint256 vaultRatio = collateralValue.wadDiv(vaultDebt);\n\n    return (vaultRatio);\n  }\n\n  /**\n    @notice Helper function determining if a vault value variation is within vault's management parameters\n    @return True if value change is below allowedVariation and false if it is above\n   */\n  function _isVaultVariationAllowed(\n    ManagedVault memory managedVault,\n    uint256 rebalanceValue,\n    uint256 swapResultValue\n  ) internal pure returns (bool) {\n    if (swapResultValue >= rebalanceValue) {\n      return true;\n    }\n\n    uint256 vaultVariation = (rebalanceValue - swapResultValue).wadDiv(rebalanceValue);\n\n    if (vaultVariation > managedVault.allowedVariation) {\n      return false;\n    }\n\n    return true;\n  }\n}"
    },
    {
      "filename": "contracts/actions/MIMOLeverage.sol",
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\nimport \"./MIMOFlashloan.sol\";\nimport \"./MIMOSwap.sol\";\nimport \"./interfaces/IMIMOLeverage.sol\";\nimport \"../core/interfaces/IVaultsCore.sol\";\nimport \"../proxy/interfaces/IMIMOProxy.sol\";\n\n/**\n  @title A SuperVault V2 action contract that can be used to leverage collateral on the MIMO protocol\n  @notice Should only be accessed through a MIMOProxy delegateCall\n */\ncontract MIMOLeverage is MIMOFlashloan, MIMOSwap, IMIMOLeverage {\n  using SafeERC20 for IERC20;\n\n  IMIMOProxyRegistry public immutable proxyRegistry;\n\n  /**\n    @param _a The addressProvider for the MIMO protocol\n    @param _dexAP The dexAddressProvider for the MIMO protocol\n    @param _lendingPool The AAVE lending pool used for flashloans\n    @param _proxyRegistry The MIMOProxyRegistry used to verify access control\n   */\n  constructor(\n    IAddressProvider _a,\n    IDexAddressProvider _dexAP,\n    IPool _lendingPool,\n    IMIMOProxyRegistry _proxyRegistry\n  ) MIMOFlashloan(_lendingPool) MIMOSwap(_a, _dexAP) {\n    if (address(_proxyRegistry) == address(0)) {\n      revert CustomErrors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    proxyRegistry = _proxyRegistry;\n  }\n\n  /**\n    @notice Leverage an asset using a flashloan to balance collateral\n    @notice Vault must have been created though a MIMOProxy\n    @dev Should be called by MIMOProxy through a delegatecall \n    @dev Uses an AAVE V3 flashLoan that will call executeOperation\n    @param _calldata Bytes containing depositAmount, stablex swapAmount, struct FlashloanDat data and struc SwapData\n   */\n  function executeAction(bytes calldata _calldata) external override {\n    (uint256 depositAmount, uint256 swapAmount, FlashLoanData memory flData, SwapData memory swapData) = abi.decode(\n      _calldata,\n      (uint256, uint256, FlashLoanData, SwapData)\n    );\n\n    if (depositAmount > 0) {\n      IERC20(flData.asset).safeTransferFrom(msg.sender, address(this), depositAmount);\n    }\n\n    bytes memory params = abi.encode(msg.sender, swapAmount, swapData);\n\n    _takeFlashLoan(flData, params);\n  }\n\n  /**\n    @notice Executes a leverage operation after taking a flashloan \n    @dev Integrates with AAVE V3 flashLoans\n    @param assets Address array with one element corresponding to the address of the leveraged asset\n    @param amounts Uint array with one element corresponding to the amount of the leveraged asset\n    @param premiums Uint array with one element corresponding to the flashLoan fees\n    @param initiator Initiator of the flashloan; can only be MIMOProxy owner\n    @param params Bytes sent by this contract containing MIMOProxy owner, stablex swap amount and swap data\n   */\n  function executeOperation(\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address initiator,\n    bytes calldata params\n  ) external override returns (bool) {\n    (address owner, uint256 swapAmount, SwapData memory swapData) = abi.decode(params, (address, uint256, SwapData));\n    IMIMOProxy mimoProxy = IMIMOProxy(proxyRegistry.getCurrentProxy(owner));\n\n    if (initiator != address(mimoProxy)) {\n      revert CustomErrors.INITIATOR_NOT_AUTHORIZED(initiator, address(mimoProxy));\n    }\n    if (msg.sender != address(lendingPool)) {\n      revert CustomErrors.CALLER_NOT_LENDING_POOL(msg.sender, address(lendingPool));\n    }\n\n    IERC20 asset = IERC20(assets[0]);\n    asset.safeTransfer(address(mimoProxy), amounts[0]);\n    uint256 flashloanRepayAmount = amounts[0] + premiums[0];\n\n    IMIMOProxy(mimoProxy).execute(\n      address(this),\n      abi.encodeWithSignature(\n        \"leverageOperation(address,uint256,uint256,(uint256,bytes))\",\n        asset,\n        swapAmount,\n        flashloanRepayAmount,\n        swapData\n      )\n    );\n\n    asset.safeIncreaseAllowance(address(lendingPool), flashloanRepayAmount);\n\n    return true;\n  }\n\n  /**\n    @notice Used by executeOperation through MIMOProxy callback to perform leverage logic within MIMOProxy context\n    @param token ERC20 token to leverage\n    @param swapAmount Stablex swap amount\n    @param flashloanRepayAmount Amount to be repaid for the flashloan\n    @param swapData SwapData passed from the flashloan call\n   */\n  function leverageOperation(\n    IERC20 token,\n    uint256 swapAmount,\n    uint256 flashloanRepayAmount,\n    SwapData calldata swapData\n  ) external override {\n    IVaultsCore core = a.core();\n    uint256 collateralBalanceBefore = token.balanceOf(address(this));\n\n    token.safeIncreaseAllowance(address(core), collateralBalanceBefore);\n    core.depositAndBorrow(address(token), collateralBalanceBefore, swapAmount);\n\n    IERC20 stablex = IERC20(a.stablex());\n\n    _aggregatorSwap(stablex, swapAmount, swapData);\n\n    uint256 collateralBalanceAfter = token.balanceOf(address(this));\n\n    require(collateralBalanceAfter >= flashloanRepayAmount, Errors.CANNOT_REPAY_FLASHLOAN);\n\n    if (collateralBalanceAfter > flashloanRepayAmount) {\n      token.safeIncreaseAllowance(address(core), collateralBalanceAfter - flashloanRepayAmount);\n      core.deposit(address(token), collateralBalanceAfter - flashloanRepayAmount);\n    }\n\n    token.safeTransfer(msg.sender, flashloanRepayAmount);\n  }\n}"
    }
  ]
}