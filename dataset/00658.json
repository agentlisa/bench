{
  "Title": "ChainlinkOracle fails to return WBTC price, pools with WBTC are not supported",
  "Content": "##### Description\n\n`oracle.getUSDPrice(wbtc)` returns the error `\"token not supported\"`\nAs the result, it is impossible to add Curve pools with WBTC.\n\nBut, Conic mentions pools with WBTC in tests:\nhttps://github.com/ConicFinance/protocol/blob/7a66d26ef84f93059a811a189655e17c11d95f5c/test/ConicTest.sol#L39\n```\n...\naddress internal constant REN_BTC = 0x9305...895B;\naddress internal constant BBTC = 0x071c...8F4b;\n...\n```\n\nAlso, there are many Curve pools with WBTC, some of them supported by Convex as well. \nBTC is a reserved denomination with the address: `0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB`\n- https://github.com/smartcontractkit/chainlink/blob/55c7baa1181aaa04026b4a1043117596c4e31e5a/contracts/src/v0.8/Denominations.sol#L7\n\nSo WBTC price feed can be received only by:\n```\nWBTC = 0x514910771AF9Ca656af840dff83E8264EcF986CA\nBTC = 0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB\nwbtcbtc = _feedRegistry.getFeed(WBTC, BTC)\n```\nIt will be WBTC/BTC price; then it must be adjusted to BTC/USD price:\n```\nBTC = 0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB\nUSD = address(840)\nbtcusd = _feedRegistry.getFeed(WBTC, BTC)\n```\n\n##### Recommendation\n\nWe recommend implementing additional calculations in `ChainlinkOracle._getPrice()` and `ChainlinkOracle.isTokenSupported()` in order to support Curve Pools with WBTC.\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "test/ConicTest.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\n// import \"forge-std/Test.sol\";\nimport \"../lib/forge-std/src/Test.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"../contracts/Controller.sol\";\nimport \"../contracts/adapters/CurveAdapter.sol\";\nimport \"../interfaces/pools/IConicPool.sol\";\nimport \"../interfaces/access/IGovernanceProxy.sol\";\nimport \"../contracts/ConicEthPool.sol\";\nimport \"../contracts/CurveHandler.sol\";\nimport \"../contracts/CurveRegistryCache.sol\";\nimport \"../contracts/ConicPool.sol\";\nimport \"../contracts/RewardManager.sol\";\nimport \"../contracts/ConvexHandler.sol\";\nimport \"../contracts/CurveRegistryCache.sol\";\nimport \"../contracts/tokenomics/InflationManager.sol\";\nimport \"../contracts/tokenomics/CNCLockerV2.sol\";\nimport \"../contracts/tokenomics/CNCToken.sol\";\nimport \"../contracts/tokenomics/LpTokenStaker.sol\";\nimport \"../contracts/tokenomics/CNCMintingRebalancingRewardsHandler.sol\";\nimport \"../contracts/oracles/GenericOracle.sol\";\nimport \"../contracts/oracles/CurveLPOracle.sol\";\nimport \"../contracts/oracles/ChainlinkOracle.sol\";\nimport \"../contracts/oracles/CrvUsdOracle.sol\";\nimport \"../contracts/testing/MockErc20.sol\";\nimport \"../interfaces/pools/IConicPool.sol\";\n\nlibrary CurvePools {\n    address internal constant TRI_POOL = 0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7;\n    address internal constant STETH_ETH_POOL = 0xDC24316b9AE028F1497c275EB9192a3Ea0f67022;\n    address internal constant FRXETH_ETH_POOL = 0xa1F8A6807c402E4A15ef4EBa36528A3FED24E577;\n    address internal constant CBETH_ETH_POOL = 0x5FAE7E604FC3e24fd43A72867ceBaC94c65b404A;\n    address internal constant RETH_ETH_POOL = 0x0f3159811670c117c372428D4E69AC32325e4D0F;\n    address internal constant FRAX_3CRV = 0xd632f22692FaC7611d2AA1C0D552930D43CAEd3B;\n    address internal constant REN_BTC = 0x93054188d876f558f4a66B2EF1d97d16eDf0895B;\n    address internal constant BBTC = 0x071c661B4DeefB59E2a3DdB20Db036821eeE8F4b;\n    address internal constant MIM_3CRV = 0x5a6A4D54456819380173272A5E8E9B9904BdF41B;\n    address internal constant CNC_ETH = 0x838af967537350D2C44ABB8c010E49E32673ab94;\n    address internal constant FRAX_BP = 0xDcEF968d416a41Cdac0ED8702fAC8128A64241A2;\n    address internal constant GUSD_FRAX_BP = 0x4e43151b78b5fbb16298C1161fcbF7531d5F8D93;\n    address internal constant EURT_3CRV = 0x9838eCcC42659FA8AA7daF2aD134b53984c9427b;\n    address internal constant BUSD_FRAX_BP = 0x8fdb0bB9365a46B145Db80D0B1C5C5e979C84190;\n    address internal constant SUSD_DAI_USDT_USDC = 0xA5407eAE9Ba41422680e2e00537571bcC53efBfD;\n    address internal constant CRVUSD_USDT = 0x390f3595bCa2Df7d23783dFd126427CCeb997BF4;\n    address internal constant CRVUSD_USDC = 0x4DEcE678ceceb27446b35C672dC7d61F30bAD69E;\n    address internal constant CRVUSD_USDP = 0xCa978A0528116DDA3cbA9ACD3e68bc6191CA53D0;\n    address internal constant CRVUSD_TUSD = 0x34D655069F4cAc1547E4C8cA284FfFF5ad4A8db0;\n    address internal constant CRVUSD_FRAX = 0x0CD6f267b2086bea681E922E19D40512511BE538;\n    address internal constant FRAX_USDP = 0xaE34574AC03A15cd58A92DC79De7B1A0800F1CE3;\n}\n\nlibrary Tokens {\n    address internal constant ETH = address(0);\n    address internal constant WBTC = address(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);\n    address internal constant DAI = address(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n    address internal constant TRI_CRV = address(0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490);\n    address internal constant WETH = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    address internal constant USDT = address(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n    address internal constant CRV = address(0xD533a949740bb3306d119CC777fa900bA034cd52);\n    address internal constant USDC = address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n    address internal constant ST_ETH = address(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84);\n    address internal constant CVX = address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);\n    address internal constant SETH = address(0x5e74C9036fb86BD7eCdcb084a0673EFc32eA31cb);\n    address internal constant TRI_POOL_LP = address(0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490);\n    address internal constant STETH_ETH_LP = address(0x06325440D014e39736583c165C2963BA99fAf14E);\n    address internal constant MIM_3CRV_LP = address(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\n    address internal constant BBTC_LP = address(0x410e3E86ef427e30B9235497143881f717d93c2A);\n    address internal constant MIM_UST_LP = address(0x55A8a39bc9694714E2874c1ce77aa1E599461E18);\n    address internal constant FRAX_3CRV_LP = address(0xd632f22692FaC7611d2AA1C0D552930D43CAEd3B);\n    address internal constant CNC = address(0x9aE380F0272E2162340a5bB646c354271c0F5cFC);\n    address internal constant EURT_3CRV_LP = address(0x3b6831c0077a1e44ED0a21841C3bC4dC11bCE833);\n    address internal constant FRAX = address(0x853d955aCEf822Db058eb8505911ED77F175b99e);\n    address internal constant CRV_USD = address(0xf939E0A03FB07F59A73314E73794Be0E57ac1b4E);\n    address internal constant CBETH_ETH_LP = address(0x5b6C539b224014A09B3388e51CaAA8e354c959C8);\n    address internal constant RETH_ETH_LP = address(0x6c38cE8984a890F5e46e6dF6117C26b3F1EcfC9C);\n    address internal constant CBETH = address(0xBe9895146f7AF43049ca1c1AE358B0541Ea49704);\n    address internal constant RETH = address(0xae78736Cd615f374D3085123A210448E74Fc6393);\n    address internal constant CRVUSD = address(0xf939E0A03FB07F59A73314E73794Be0E57ac1b4E);\n}\n\nlibrary ConvexPid {\n    uint256 internal constant TRI_POOL = 9;\n    uint256 internal constant MIM_UST = 52;\n    uint256 internal constant CVXCRV = 41;\n    uint256 internal constant STETH_ETH_POOL = 25;\n    uint256 internal constant FRAX_3CRV = 32;\n    uint256 internal constant BBTC = 19;\n    uint256 internal constant MIM_3CRV = 40;\n    uint256 internal constant EURT_3CRV = 55;\n}\n\nlibrary MainnetAddresses {\n    address internal constant LP_TOKEN_STAKER = 0xeC037423A61B634BFc490dcc215236349999ca3d;\n    address internal constant CNC = 0x9aE380F0272E2162340a5bB646c354271c0F5cFC;\n    address internal constant MULTISIG = 0xB27DC5f8286f063F11491c8f349053cB37718bea;\n    address internal constant CNC_MINTING_REWARDS_HANDLER =\n        0x017F5f86dF6aA8D5B3c01E47E410D66f356A94A6;\n    address internal constant EMERGENCY_MINTER = 0xd12843bB5f174c8B01b7Fc09DB7D40d4102ABaf6;\n    address internal constant GOVERNANCE_PROXY = 0xCb7c67bDde9F7aF0667E8d82bb87F1432Bd1d902;\n    address internal constant INFLATION_MANAGER = 0xf4A364d6B513158dC880d0e8DA6Ae65B9688FD7B;\n    address internal constant CONTROLLER = 0x013A3Da6591d3427F164862793ab4e388F9B587e;\n    address internal constant CNC_DISTRIBUTOR = 0x74eA6D777a4aEC782EBA0AcAE61142AAc69D3E2F;\n    address internal constant CURVE_TRICRYPTO_FACTORY_HANDLER =\n        0x9335BF643C455478F8BE40fA20B5164b90215B80;\n    address internal constant CURVE_TRICRYPTO_FACTORY_HANDLER_2 =\n        0x30a4249C42be05215b6063691949710592859697;\n    address internal constant CONVEX_BOOSTER = 0xF403C135812408BFbE8713b5A23a04b3D48AAE31;\n}\n\ncontract ConicTest is Test {\n    using stdJson for string;\n    using stdStorage for StdStorage;\n\n    CNCToken public _cnc;\n\n    bytes32 constant LOCKER_V2_MERKLE_ROOT =\n        0x1fb27a93b1597fb63a71400761fa335d34875bc82ed5d1e2182cbb0a966049a7;\n\n    address public bb8 = makeAddr(\"bb8\"); // 0xE2Fca394F3a28F1717EFAB57339540306F303f6f\n    address public r2 = makeAddr(\"r2\"); // 0x2A71967CF1d84B413bb804418b54407822914D80\n    address public c3po = makeAddr(\"c3po\"); // 0x6763367385beC272a5BA2C1Fb3e7FCd36485e4FD\n\n    uint256 internal mainnetFork;\n\n    bool internal _isFork;\n\n    function setUp() public virtual {\n        string memory MAINNET_RPC_URL = vm.envString(\"MAINNET_RPC_URL\");\n        mainnetFork = vm.createFork(MAINNET_RPC_URL, 17_478_718);\n    }\n\n    function _setFork(uint256 forkId) internal {\n        _isFork = true;\n        vm.selectFork(forkId);\n        vm.mockCall(\n            MainnetAddresses.CURVE_TRICRYPTO_FACTORY_HANDLER,\n            abi.encodeWithSignature(\"is_registered(address)\"),\n            abi.encode(false)\n        );\n        vm.mockCall(\n            MainnetAddresses.CURVE_TRICRYPTO_FACTORY_HANDLER_2,\n            abi.encodeWithSignature(\"is_registered(address)\"),\n            abi.encode(false)\n        );\n    }\n\n    function _getCNCToken() internal returns (CNCToken) {\n        if (_isFork) {\n            return CNCToken(MainnetAddresses.CNC);\n        }\n        if (address(_cnc) == address(0)) {\n            _cnc = new CNCToken();\n        }\n        return _cnc;\n    }\n\n    function _createRegistryCache() internal returns (ICurveRegistryCache) {\n        ICurveRegistryCache registryCache = new CurveRegistryCache();\n        if (_isFork) {\n            registryCache.initPool(CurvePools.STETH_ETH_POOL);\n            registryCache.initPool(CurvePools.FRAX_3CRV);\n            registryCache.initPool(CurvePools.TRI_POOL);\n            registryCache.initPool(CurvePools.REN_BTC);\n            registryCache.initPool(CurvePools.MIM_3CRV);\n            registryCache.initPool(CurvePools.FRAX_BP);\n            registryCache.initPool(CurvePools.EURT_3CRV);\n            registryCache.initPool(CurvePools.BUSD_FRAX_BP);\n            registryCache.initPool(CurvePools.SUSD_DAI_USDT_USDC);\n            registryCache.initPool(CurvePools.CNC_ETH);\n            registryCache.initPool(CurvePools.RETH_ETH_POOL);\n            registryCache.initPool(CurvePools.CBETH_ETH_POOL);\n            registryCache.initPool(CurvePools.CRVUSD_USDT);\n            registryCache.initPool(CurvePools.CRVUSD_USDC);\n            registryCache.initPool(CurvePools.CRVUSD_USDP);\n            registryCache.initPool(CurvePools.CRVUSD_TUSD);\n            registryCache.initPool(CurvePools.CRVUSD_FRAX);\n            registryCache.initPool(CurvePools.FRAX_USDP);\n        }\n        return registryCache;\n    }\n\n    function _createController(\n        CNCToken cnc,\n        ICurveRegistryCache registryCache\n    ) internal returns (Controller) {\n        Controller controller = new Controller(address(cnc), address(registryCache));\n        return controller;\n    }\n\n    function _createAndInitializeController() internal returns (Controller) {\n        CNCToken cnc = _getCNCToken();\n        Controller controller = _createController(cnc, _createRegistryCache());\n        controller.setCurveHandler(address(new CurveHandler(address(controller))));\n        controller.setConvexHandler(address(new ConvexHandler(address(controller))));\n        InflationManager inflationManager = _createInflationManager(controller);\n        _createLpTokenStaker(inflationManager, cnc);\n        CurveLPOracle curveLpOracle = _createCurveLpOracle(controller);\n        GenericOracle genericOracle = _createGenericOracle(address(curveLpOracle));\n        controller.setPriceOracle(address(genericOracle));\n        controller.setDefaultPoolAdapter(address(_createCurveAdapter(controller)));\n\n        // Adding crvUSD Custom oracle\n        CrvUsdOracle crvUsdOracle = new CrvUsdOracle(address(genericOracle));\n        genericOracle.setCustomOracle(Tokens.CRV_USD, address(crvUsdOracle));\n\n        return controller;\n    }\n\n    function _createCurveLpOracle(Controller controller) internal returns (CurveLPOracle) {\n        return new CurveLPOracle(address(controller));\n    }\n\n    function _createCurveAdapter(Controller controller) internal returns (IPoolAdapter) {\n        return new CurveAdapter(controller);\n    }\n\n    function _createInflationManager(Controller controller) internal returns (InflationManager) {\n        InflationManager inflationManager = new InflationManager(address(controller));\n        controller.setInflationManager(address(inflationManager));\n        return inflationManager;\n    }\n\n    function _createRebalancingRewardsHandler(\n        Controller controller\n    ) internal returns (CNCMintingRebalancingRewardsHandler) {\n        CNCToken cnc = CNCToken(controller.cncToken());\n        CNCMintingRebalancingRewardsHandler rebalancingRewardsHandler = new CNCMintingRebalancingRewardsHandler(\n                controller,\n                cnc,\n                ICNCMintingRebalancingRewardsHandler(address(0))\n            );\n\n        if (_isFork) {\n            vm.prank(MainnetAddresses.LP_TOKEN_STAKER);\n        }\n        cnc.addMinter(address(rebalancingRewardsHandler));\n        controller.setAllowedMultipleDepositsWithdraws(address(rebalancingRewardsHandler), true);\n        return rebalancingRewardsHandler;\n    }\n\n    function _createLpTokenStaker(\n        InflationManager inflationManager,\n        CNCToken cnc\n    ) internal returns (LpTokenStaker) {\n        IController controller = inflationManager.controller();\n        LpTokenStaker lpTokenStaker = new LpTokenStaker(address(controller), cnc);\n        if (_isFork) {\n            vm.prank(MainnetAddresses.LP_TOKEN_STAKER);\n        }\n        cnc.addMinter(address(lpTokenStaker));\n        controller.initialize(address(lpTokenStaker));\n        return lpTokenStaker;\n    }\n\n    function _createLockerV2(Controller controller) internal returns (CNCLockerV2) {\n        address crv = Tokens.CRV;\n        address cvx = Tokens.CVX;\n        if (!_isFork) {\n            crv = address(new MockErc20(18));\n            cvx = address(new MockErc20(18));\n        }\n        CNCLockerV2 locker = new CNCLockerV2(\n            address(controller),\n            controller.cncToken(),\n            MainnetAddresses.MULTISIG,\n            crv,\n            cvx,\n            LOCKER_V2_MERKLE_ROOT\n        );\n        return locker;\n    }\n\n    function _createGenericOracle(address curveLPOracle) internal returns (GenericOracle) {\n        GenericOracle genericOracle = new GenericOracle();\n        IOracle chainlinkOracle = new ChainlinkOracle();\n        genericOracle.initialize(curveLPOracle, address(chainlinkOracle));\n        return genericOracle;\n    }\n\n    function _createConicPool(\n        Controller controller,\n        CNCMintingRebalancingRewardsHandler rebalancingRewardsHandler,\n        CNCLockerV2 locker,\n        address underlying,\n        string memory name,\n        string memory symbol,\n        bool isETH\n    ) internal returns (IConicPool) {\n        RewardManager rewardManager = new RewardManager(\n            address(controller),\n            underlying,\n            address(locker)\n        );\n        IConicPool pool;\n        if (isETH) {\n            pool = new ConicEthPool(\n                underlying,\n                rewardManager,\n                address(controller),\n                name,\n                symbol,\n                Tokens.CVX,\n                Tokens.CRV\n            );\n            payable(address(pool)).transfer(1 ether);\n        } else {\n            pool = new ConicPool(\n                underlying,\n                rewardManager,\n                address(controller),\n                name,\n                symbol,\n                Tokens.CVX,\n                Tokens.CRV\n            );\n        }\n        rewardManager.initialize(address(pool));\n        controller.addPool(address(pool));\n        controller.inflationManager().addPoolRebalancingRewardHandler(\n            address(pool),\n            address(rebalancingRewardsHandler)\n        );\n        controller.inflationManager().updatePoolWeights();\n        return pool;\n    }\n\n    function setTokenBalance(address who, address token, uint256 amt) internal {\n        bytes4 sel = IERC20(token).balanceOf.selector;\n        stdstore.target(token).sig(sel).with_key(who).checked_write(amt);\n    }\n\n    function assertContains(address[] memory a, address b) internal {\n        for (uint256 i; i < a.length; i++) {\n            if (a[i] == b) {\n                return;\n            }\n        }\n        emit log(\"Error: a does not contain b [address[]]\");\n        emit log_named_array(\"      Left\", a);\n        emit log_named_address(\"     Right\", b);\n        fail();\n    }\n\n    function assertNotContains(address[] memory a, address b) internal {\n        for (uint256 i; i < a.length; i++) {\n            if (a[i] == b) {\n                emit log(\"Error: a contains b [address[]]\");\n                emit log_named_array(\"      Left\", a);\n                emit log_named_address(\"     Right\", b);\n                fail();\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/src/v0.8/Denominations.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary Denominations {\n  address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n  address public constant BTC = 0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB;\n\n  // Fiat currencies follow https://en.wikipedia.org/wiki/ISO_4217\n  address public constant USD = address(840);\n  address public constant GBP = address(826);\n  address public constant EUR = address(978);\n  address public constant JPY = address(392);\n  address public constant KRW = address(410);\n  address public constant CNY = address(156);\n  address public constant AUD = address(36);\n  address public constant CAD = address(124);\n  address public constant CHF = address(756);\n  address public constant ARS = address(32);\n  address public constant PHP = address(608);\n  address public constant NZD = address(554);\n  address public constant SGD = address(702);\n  address public constant NGN = address(566);\n  address public constant ZAR = address(710);\n  address public constant RUB = address(643);\n  address public constant INR = address(356);\n  address public constant BRL = address(986);\n}"
    }
  ]
}