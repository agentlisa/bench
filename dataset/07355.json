{
  "Title": "[M-08] User fund loss because function purchaseLiquidationAuctionNFT() takes extra liquidation penalty when userâ€™s last collateral is liquidated, (set wrong value for maxDebtCached when isLastCollateral is true)",
  "Content": "# Lines of code\n\nhttps://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L264-L294\n\n\n# Vulnerability details\n\n## Impact\nFunction `purchaseLiquidationAuctionNFT()` purchases a liquidation auction with the controller's papr token. the liquidator pays the papr amount which is equal to price of the auction and receives the auctioned  NFT. contract would transfer paid papr and  pay borrower debt and if there is extra papr left it would be transferred to the user. for extra papr that is not required for brining user debt under max debt, contract gets liquidation penalty but in some cases (when the auctioned NFT is user's last collateral) contract take penalty from all of the transferred papr and not just the extra. so users would lose funds in those situations because of this and the fund could be big because the penalty is 10% of the price of the auction and in most cases user would lose 10% of his debt (the value of the NFT).\n\n## Proof of Concept\nThis is `purchaseLiquidationAuctionNFT()` code:\n```\n    function purchaseLiquidationAuctionNFT(\n        Auction calldata auction,\n        uint256 maxPrice,\n        address sendTo,\n        ReservoirOracleUnderwriter.OracleInfo calldata oracleInfo\n    ) external override {\n        uint256 collateralValueCached = underwritePriceForCollateral(\n            auction.auctionAssetContract, ReservoirOracleUnderwriter.PriceKind.TWAP, oracleInfo\n        ) * _vaultInfo[auction.nftOwner][auction.auctionAssetContract].count;\n        bool isLastCollateral = collateralValueCached == 0;\n\n        uint256 debtCached = _vaultInfo[auction.nftOwner][auction.auctionAssetContract].debt;\n        uint256 maxDebtCached = isLastCollateral ? debtCached : _maxDebt(collateralValueCached, updateTarget());\n        /// anything above what is needed to bring this vault under maxDebt is considered excess\n        uint256 neededToSaveVault = maxDebtCached > debtCached ? 0 : debtCached - maxDebtCached;\n        uint256 price = _purchaseNFTAndUpdateVaultIfNeeded(auction, maxPrice, sendTo);\n        uint256 excess = price > neededToSaveVault ? price - neededToSaveVault : 0;\n        uint256 remaining;\n\n        if (excess > 0) {\n            remaining = _handleExcess(excess, neededToSaveVault, debtCached, auction);\n        } else {\n            _reduceDebt(auction.nftOwner, auction.auctionAssetContract, address(this), price);\n            remaining = debtCached - price;\n        }\n\n        if (isLastCollateral && remaining != 0) {\n            /// there will be debt left with no NFTs, set it to 0\n            _reduceDebtWithoutBurn(auction.nftOwner, auction.auctionAssetContract, remaining);\n        }\n    }\n```\nAs you can see when `collateralValueCached` is 0 and user has no more collaterals left then the value of `isLastCollateral` set as true. and when `isLastCollateral` is true the value of `maxDebtCached` set as `debtCached` (line `maxDebtCached = isLastCollateral ? debtCached : _maxDebt(collateralValueCached, updateTarget());`) and the value of the `neededToSaveVault` would be 0 (line `neededToSaveVault = maxDebtCached > debtCached ? 0 : debtCached - maxDebtCached`) and the `excess` would be equal to `price` (in the line `excess = price > neededToSaveVault ? price - neededToSaveVault : 0`) so all the papr paid by liquidator would considered as excess and contract would get liquidation penalty out of that. so: in current implementation in last collateral liquidation all of the paid papr by liquidator would be considered excess:\n1. user has no NFT left.\n2. debtCached is 100.\n3. collateralValueCached  is 0 and isLastCollateral is true.\n4. maxDebtCached would be as debtCached which is 100.\n5. neededToSaveVault would be debtCached - maxDebtCached which is 0.\n6. excess would equal to price and code would take penalty out of all the price amount.\n\ncode wants to take penalty from what borrower is going to receive(other than the required amount for extra debt), but in the current implementation when it is last NFT code took fee from all of the payment. these are the steps shows how issue would harm the borrower and borrower would lose funds: (of course user debt would be set to 0 in the end, but if price was higher than user debt user won't receive the extra amount)\n1. user debt is 900 and price of auction is 1000 and user has no NFT left.\n2. some one pays 1000 Papr and buys the auctioned token, now user would receive 0 amount because the penalty would be 1000 * 10% = 100 and the debt is 900.\n3. but penalty should be (1000-900) * 10% = 10 and user should have received 90 token.\n\nso users would receive less amount when their last NFT is liquidated and the price is higher than debt. users would lose 10% of the their intitled fund. most users can use one token as collateral so the bug can happen most of the time.\n\n## Tools Used\nVIM\n\n## Recommended Mitigation Steps\nthe code should be like this:\n```\nuint256 maxDebtCached = isLastCollateral ? 0: _maxDebt(collateralValueCached, updateTarget());\n```",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-12-papr-contest",
  "Code": [
    {
      "filename": "src/PaprController.sol",
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.17;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC721, ERC721TokenReceiver} from \"solmate/tokens/ERC721.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {INFTEDA, NFTEDAStarterIncentive} from \"./NFTEDA/extensions/NFTEDAStarterIncentive.sol\";\nimport {Ownable2Step} from \"openzeppelin-contracts/access/Ownable2Step.sol\";\nimport {Multicallable} from \"solady/utils/Multicallable.sol\";\n\nimport {PaprToken} from \"./PaprToken.sol\";\nimport {UniswapOracleFundingRateController} from \"./UniswapOracleFundingRateController.sol\";\nimport {ReservoirOracleUnderwriter} from \"./ReservoirOracleUnderwriter.sol\";\nimport {IPaprController} from \"./interfaces/IPaprController.sol\";\nimport {UniswapHelpers} from \"./libraries/UniswapHelpers.sol\";\n\ncontract PaprController is\n    IPaprController,\n    UniswapOracleFundingRateController,\n    ERC721TokenReceiver,\n    Multicallable,\n    Ownable2Step,\n    ReservoirOracleUnderwriter,\n    NFTEDAStarterIncentive\n{\n    using SafeTransferLib for ERC20;\n\n    /// @dev what 1 = 100% is in basis points (bips)\n    uint256 public constant BIPS_ONE = 1e4;\n\n    bool public override liquidationsLocked;\n\n    /// @inheritdoc IPaprController\n    bool public immutable override token0IsUnderlying;\n\n    /// @inheritdoc IPaprController\n    uint256 public immutable override maxLTV;\n\n    /// @inheritdoc IPaprController\n    uint256 public immutable override liquidationAuctionMinSpacing = 2 days;\n\n    /// @inheritdoc IPaprController\n    uint256 public immutable override perPeriodAuctionDecayWAD = 0.7e18;\n\n    /// @inheritdoc IPaprController\n    uint256 public immutable override auctionDecayPeriod = 1 days;\n\n    /// @inheritdoc IPaprController\n    uint256 public immutable override auctionStartPriceMultiplier = 3;\n\n    /// @inheritdoc IPaprController\n    /// @dev Set to 10%\n    uint256 public immutable override liquidationPenaltyBips = 1000;\n\n    /// @inheritdoc IPaprController\n    mapping(ERC721 => mapping(uint256 => address)) public override collateralOwner;\n\n    /// @inheritdoc IPaprController\n    mapping(address => bool) public override isAllowed;\n\n    /// @dev account => asset => vaultInfo\n    mapping(address => mapping(ERC721 => IPaprController.VaultInfo)) private _vaultInfo;\n\n    /// @dev does not validate args\n    /// e.g. does not check whether underlying or oracleSigner are address(0)\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256 _maxLTV,\n        uint256 indexMarkRatioMax,\n        uint256 indexMarkRatioMin,\n        ERC20 underlying,\n        address oracleSigner\n    )\n        NFTEDAStarterIncentive(1e17)\n        UniswapOracleFundingRateController(underlying, new PaprToken(name, symbol), indexMarkRatioMax, indexMarkRatioMin)\n        ReservoirOracleUnderwriter(oracleSigner, address(underlying))\n    {\n        maxLTV = _maxLTV;\n        token0IsUnderlying = address(underlying) < address(papr);\n        uint256 underlyingONE = 10 ** underlying.decimals();\n        uint160 initSqrtRatio;\n\n        // initialize the pool at 1:1\n        if (token0IsUnderlying) {\n            initSqrtRatio = UniswapHelpers.oneToOneSqrtRatio(underlyingONE, 10 ** 18);\n        } else {\n            initSqrtRatio = UniswapHelpers.oneToOneSqrtRatio(10 ** 18, underlyingONE);\n        }\n\n        address _pool = UniswapHelpers.deployAndInitPool(address(underlying), address(papr), 10000, initSqrtRatio);\n\n        _init(underlyingONE, _pool);\n    }\n\n    /// @inheritdoc IPaprController\n    function addCollateral(IPaprController.Collateral[] calldata collateralArr) external override {\n        for (uint256 i = 0; i < collateralArr.length;) {\n            _addCollateralToVault(msg.sender, collateralArr[i]);\n            collateralArr[i].addr.transferFrom(msg.sender, address(this), collateralArr[i].id);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @inheritdoc IPaprController\n    function removeCollateral(\n        address sendTo,\n        IPaprController.Collateral[] calldata collateralArr,\n        ReservoirOracleUnderwriter.OracleInfo calldata oracleInfo\n    ) external override {\n        uint256 cachedTarget = updateTarget();\n        uint256 oraclePrice;\n        ERC721 collateralAddr;\n\n        for (uint256 i = 0; i < collateralArr.length;) {\n            if (i == 0) {\n                collateralAddr = collateralArr[i].addr;\n                oraclePrice =\n                    underwritePriceForCollateral(collateralAddr, ReservoirOracleUnderwriter.PriceKind.LOWER, oracleInfo);\n            } else {\n                if (collateralAddr != collateralArr[i].addr) {\n                    revert CollateralAddressesDoNotMatch();\n                }\n            }\n\n            _removeCollateral(sendTo, collateralArr[i], oraclePrice, cachedTarget);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @inheritdoc IPaprController\n    function increaseDebt(\n        address mintTo,\n        ERC721 asset,\n        uint256 amount,\n        ReservoirOracleUnderwriter.OracleInfo calldata oracleInfo\n    ) external override {\n        _increaseDebt({account: msg.sender, asset: asset, mintTo: mintTo, amount: amount, oracleInfo: oracleInfo});\n    }\n\n    /// @inheritdoc IPaprController\n    function reduceDebt(address account, ERC721 asset, uint256 amount) external override {\n        _reduceDebt({account: account, asset: asset, burnFrom: msg.sender, amount: amount});\n    }\n\n    /// @notice Handler for safeTransferFrom of an NFT\n    /// @dev Should be preferred to `addCollateral` if only one NFT is being added\n    /// to avoid approval call and save gas\n    /// @param from the current owner of the nft\n    /// @param _id the id of the NFT\n    /// @param data encoded IPaprController.OnERC721ReceivedArgs\n    /// @return selector indicating succesful receiving of the NFT\n    function onERC721Received(address from, address, uint256 _id, bytes calldata data)\n        external\n        override\n        returns (bytes4)\n    {\n        IPaprController.OnERC721ReceivedArgs memory request = abi.decode(data, (IPaprController.OnERC721ReceivedArgs));\n\n        IPaprController.Collateral memory collateral = IPaprController.Collateral(ERC721(msg.sender), _id);\n\n        _addCollateralToVault(from, collateral);\n\n        if (request.swapParams.minOut > 0) {\n            _increaseDebtAndSell(from, request.proceedsTo, ERC721(msg.sender), request.swapParams, request.oracleInfo);\n        } else if (request.debt > 0) {\n            _increaseDebt(from, collateral.addr, request.proceedsTo, request.debt, request.oracleInfo);\n        }\n\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n\n    /// CONVENIENCE SWAP FUNCTIONS ///\n\n    /// @inheritdoc IPaprController\n    function increaseDebtAndSell(\n        address proceedsTo,\n        ERC721 collateralAsset,\n        IPaprController.SwapParams calldata params,\n        ReservoirOracleUnderwriter.OracleInfo calldata oracleInfo\n    ) external override returns (uint256 amountOut) {\n        bool hasFee = params.swapFeeBips != 0;\n\n        (amountOut,) = UniswapHelpers.swap(\n            pool,\n            hasFee ? address(this) : proceedsTo,\n            !token0IsUnderlying,\n            params.amount,\n            params.minOut,\n            params.sqrtPriceLimitX96,\n            abi.encode(msg.sender, collateralAsset, oracleInfo)\n        );\n\n        if (hasFee) {\n            uint256 fee = amountOut * params.swapFeeBips / BIPS_ONE;\n            underlying.transfer(params.swapFeeTo, fee);\n            underlying.transfer(proceedsTo, amountOut - fee);\n        }\n    }\n\n    /// @inheritdoc IPaprController\n    function buyAndReduceDebt(address account, ERC721 collateralAsset, IPaprController.SwapParams calldata params)\n        external\n        override\n        returns (uint256)\n    {\n        bool hasFee = params.swapFeeBips != 0;\n\n        (uint256 amountOut, uint256 amountIn) = UniswapHelpers.swap(\n            pool,\n            account,\n            token0IsUnderlying,\n            params.amount,\n            params.minOut,\n            params.sqrtPriceLimitX96,\n            abi.encode(msg.sender)\n        );\n\n        if (hasFee) {\n            underlying.transfer(params.swapFeeTo, amountIn * params.swapFeeBips / BIPS_ONE);\n        }\n\n        _reduceDebt({account: account, asset: collateralAsset, burnFrom: msg.sender, amount: amountOut});\n\n        return amountOut;\n    }\n\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata _data) external {\n        if (msg.sender != address(pool)) {\n            revert(\"wrong caller\");\n        }\n\n        bool isUnderlyingIn;\n        uint256 amountToPay;\n        if (amount0Delta > 0) {\n            amountToPay = uint256(amount0Delta);\n            isUnderlyingIn = token0IsUnderlying;\n        } else {\n            require(amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n\n            amountToPay = uint256(amount1Delta);\n            isUnderlyingIn = !(token0IsUnderlying);\n        }\n\n        if (isUnderlyingIn) {\n            address payer = abi.decode(_data, (address));\n            underlying.safeTransferFrom(payer, msg.sender, amountToPay);\n        } else {\n            (address account, ERC721 asset, ReservoirOracleUnderwriter.OracleInfo memory oracleInfo) =\n                abi.decode(_data, (address, ERC721, ReservoirOracleUnderwriter.OracleInfo));\n            _increaseDebt(account, asset, msg.sender, amountToPay, oracleInfo);\n        }\n    }\n\n    /// LIQUIDATION AUCTION FUNCTIONS ///\n\n    /// @inheritdoc IPaprController\n    function purchaseLiquidationAuctionNFT(\n        Auction calldata auction,\n        uint256 maxPrice,\n        address sendTo,\n        ReservoirOracleUnderwriter.OracleInfo calldata oracleInfo\n    ) external override {\n        uint256 collateralValueCached = underwritePriceForCollateral(\n            auction.auctionAssetContract, ReservoirOracleUnderwriter.PriceKind.TWAP, oracleInfo\n        ) * _vaultInfo[auction.nftOwner][auction.auctionAssetContract].count;\n        bool isLastCollateral = collateralValueCached == 0;\n\n        uint256 debtCached = _vaultInfo[auction.nftOwner][auction.auctionAssetContract].debt;\n        uint256 maxDebtCached = isLastCollateral ? debtCached : _maxDebt(collateralValueCached, updateTarget());\n        /// anything above what is needed to bring this vault under maxDebt is considered excess\n        uint256 neededToSaveVault = maxDebtCached > debtCached ? 0 : debtCached - maxDebtCached;\n        uint256 price = _purchaseNFTAndUpdateVaultIfNeeded(auction, maxPrice, sendTo);\n        uint256 excess = price > neededToSaveVault ? price - neededToSaveVault : 0;\n        uint256 remaining;\n\n        if (excess > 0) {\n            remaining = _handleExcess(excess, neededToSaveVault, debtCached, auction);\n        } else {\n            _reduceDebt(auction.nftOwner, auction.auctionAssetContract, address(this), price);\n            remaining = debtCached - price;\n        }\n\n        if (isLastCollateral && remaining != 0) {\n            /// there will be debt left with no NFTs, set it to 0\n            _reduceDebtWithoutBurn(auction.nftOwner, auction.auctionAssetContract, remaining);\n        }\n    }\n\n    /// @inheritdoc IPaprController\n    function startLiquidationAuction(\n        address account,\n        IPaprController.Collateral calldata collateral,\n        ReservoirOracleUnderwriter.OracleInfo calldata oracleInfo\n    ) external override returns (INFTEDA.Auction memory auction) {\n        if (liquidationsLocked) {\n            revert LiquidationsLocked();\n        }\n\n        uint256 cachedTarget = updateTarget();\n\n        IPaprController.VaultInfo storage info = _vaultInfo[account][collateral.addr];\n\n        // check collateral belongs to account\n        if (collateralOwner[collateral.addr][collateral.id] != account) {\n            revert IPaprController.InvalidCollateralAccountPair();\n        }\n\n        uint256 oraclePrice =\n            underwritePriceForCollateral(collateral.addr, ReservoirOracleUnderwriter.PriceKind.TWAP, oracleInfo);\n        if (info.debt < _maxDebt(oraclePrice * info.count, cachedTarget)) {\n            revert IPaprController.NotLiquidatable();\n        }\n\n        if (block.timestamp - info.latestAuctionStartTime < liquidationAuctionMinSpacing) {\n            revert IPaprController.MinAuctionSpacing();\n        }\n\n        info.latestAuctionStartTime = uint40(block.timestamp);\n        info.count -= 1;\n\n        emit RemoveCollateral(account, collateral.addr, collateral.id);\n\n        delete collateralOwner[collateral.addr][collateral.id];\n\n        _startAuction(\n            auction = Auction({\n                nftOwner: account,\n                auctionAssetID: collateral.id,\n                auctionAssetContract: collateral.addr,\n                perPeriodDecayPercentWad: perPeriodAuctionDecayWAD,\n                secondsInPeriod: auctionDecayPeriod,\n                // start price is frozen price * auctionStartPriceMultiplier,\n                // converted to papr value at the current contract price\n                startPrice: (oraclePrice * auctionStartPriceMultiplier) * FixedPointMathLib.WAD / cachedTarget,\n                paymentAsset: papr\n            })\n        );\n    }\n\n    /// OWNER FUNCTIONS ///\n\n    /// @inheritdoc IPaprController\n    function setPool(address _pool) external override onlyOwner {\n        _setPool(_pool);\n    }\n\n    /// @inheritdoc IPaprController\n    function setFundingPeriod(uint256 _fundingPeriod) external override onlyOwner {\n        _setFundingPeriod(_fundingPeriod);\n    }\n\n    /// @inheritdoc IPaprController\n    function setLiquidationsLocked(bool locked) external override onlyOwner {\n        liquidationsLocked = locked;\n    }\n\n    /// @inheritdoc IPaprController\n    function setAllowedCollateral(IPaprController.CollateralAllowedConfig[] calldata collateralConfigs)\n        external\n        override\n        onlyOwner\n    {\n        for (uint256 i = 0; i < collateralConfigs.length;) {\n            if (collateralConfigs[i].collateral == address(0)) revert IPaprController.InvalidCollateral();\n\n            isAllowed[collateralConfigs[i].collateral] = collateralConfigs[i].allowed;\n            emit AllowCollateral(collateralConfigs[i].collateral, collateralConfigs[i].allowed);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @inheritdoc IPaprController\n    function sendPaprFromAuctionFees(address to, uint256 amount) external override onlyOwner {\n        papr.safeTransferFrom(address(this), to, amount);\n    }\n\n    function burnPaprFromAuctionFees(uint256 amount) external override onlyOwner {\n        PaprToken(address(papr)).burn(address(this), amount);\n    }\n\n    /// VIEW FUNCTIONS ///\n\n    /// @inheritdoc IPaprController\n    function maxDebt(uint256 totalCollateraValue) external view override returns (uint256) {\n        if (_lastUpdated == block.timestamp) {\n            return _maxDebt(totalCollateraValue, _target);\n        }\n\n        return _maxDebt(totalCollateraValue, newTarget());\n    }\n\n    /// @inheritdoc IPaprController\n    function vaultInfo(address account, ERC721 asset)\n        external\n        view\n        override\n        returns (IPaprController.VaultInfo memory)\n    {\n        return _vaultInfo[account][asset];\n    }\n\n    /// INTERNAL NON-VIEW ///\n\n    function _addCollateralToVault(address account, IPaprController.Collateral memory collateral) internal {\n        if (!isAllowed[address(collateral.addr)]) {\n            revert IPaprController.InvalidCollateral();\n        }\n\n        collateralOwner[collateral.addr][collateral.id] = account;\n        _vaultInfo[account][collateral.addr].count += 1;\n\n        emit AddCollateral(account, collateral.addr, collateral.id);\n    }\n\n    function _removeCollateral(\n        address sendTo,\n        IPaprController.Collateral calldata collateral,\n        uint256 oraclePrice,\n        uint256 cachedTarget\n    ) internal {\n        if (collateralOwner[collateral.addr][collateral.id] != msg.sender) {\n            revert IPaprController.OnlyCollateralOwner();\n        }\n\n        delete collateralOwner[collateral.addr][collateral.id];\n\n        uint16 newCount;\n        unchecked {\n            newCount = _vaultInfo[msg.sender][collateral.addr].count - 1;\n            _vaultInfo[msg.sender][collateral.addr].count = newCount;\n        }\n\n        // allows for onReceive hook to sell and repay debt before the\n        // debt check below\n        collateral.addr.safeTransferFrom(address(this), sendTo, collateral.id);\n\n        uint256 debt = _vaultInfo[msg.sender][collateral.addr].debt;\n        uint256 max = _maxDebt(oraclePrice * newCount, cachedTarget);\n\n        if (debt > max) {\n            revert IPaprController.ExceedsMaxDebt(debt, max);\n        }\n\n        emit RemoveCollateral(msg.sender, collateral.addr, collateral.id);\n    }\n\n    function _increaseDebt(\n        address account,\n        ERC721 asset,\n        address mintTo,\n        uint256 amount,\n        ReservoirOracleUnderwriter.OracleInfo memory oracleInfo\n    ) internal {\n        uint256 cachedTarget = updateTarget();\n\n        uint256 newDebt = _vaultInfo[account][asset].debt + amount;\n        uint256 oraclePrice =\n            underwritePriceForCollateral(asset, ReservoirOracleUnderwriter.PriceKind.LOWER, oracleInfo);\n\n        uint256 max = _maxDebt(_vaultInfo[account][asset].count * oraclePrice, cachedTarget);\n\n        if (newDebt > max) revert IPaprController.ExceedsMaxDebt(newDebt, max);\n\n        if (newDebt >= 1 << 200) revert IPaprController.DebtAmountExceedsUint200();\n\n        _vaultInfo[account][asset].debt = uint200(newDebt);\n        PaprToken(address(papr)).mint(mintTo, amount);\n\n        emit IncreaseDebt(account, asset, amount);\n    }\n\n    function _reduceDebt(address account, ERC721 asset, address burnFrom, uint256 amount) internal {\n        _reduceDebtWithoutBurn(account, asset, amount);\n        PaprToken(address(papr)).burn(burnFrom, amount);\n    }\n\n    function _reduceDebtWithoutBurn(address account, ERC721 asset, uint256 amount) internal {\n        _vaultInfo[account][asset].debt = uint200(_vaultInfo[account][asset].debt - amount);\n        emit ReduceDebt(account, asset, amount);\n    }\n\n    /// same as increaseDebtAndSell but takes args in memory\n    /// to work with onERC721Received\n    function _increaseDebtAndSell(\n        address account,\n        address proceedsTo,\n        ERC721 collateralAsset,\n        IPaprController.SwapParams memory params,\n        ReservoirOracleUnderwriter.OracleInfo memory oracleInfo\n    ) internal returns (uint256 amountOut) {\n        bool hasFee = params.swapFeeBips != 0;\n\n        (amountOut,) = UniswapHelpers.swap(\n            pool,\n            hasFee ? address(this) : proceedsTo,\n            !token0IsUnderlying,\n            params.amount,\n            params.minOut,\n            params.sqrtPriceLimitX96,\n            abi.encode(account, collateralAsset, oracleInfo)\n        );\n\n        if (hasFee) {\n            uint256 fee = amountOut * params.swapFeeBips / BIPS_ONE;\n            underlying.transfer(params.swapFeeTo, fee);\n            underlying.transfer(proceedsTo, amountOut - fee);\n        }\n    }\n\n    function _purchaseNFTAndUpdateVaultIfNeeded(Auction calldata auction, uint256 maxPrice, address sendTo)\n        internal\n        returns (uint256)\n    {\n        (uint256 startTime, uint256 price) = _purchaseNFT(auction, maxPrice, sendTo);\n\n        if (startTime == _vaultInfo[auction.nftOwner][auction.auctionAssetContract].latestAuctionStartTime) {\n            _vaultInfo[auction.nftOwner][auction.auctionAssetContract].latestAuctionStartTime = 0;\n        }\n\n        return price;\n    }\n\n    function _handleExcess(uint256 excess, uint256 neededToSaveVault, uint256 debtCached, Auction calldata auction)\n        internal\n        returns (uint256 remaining)\n    {\n        uint256 fee = excess * liquidationPenaltyBips / BIPS_ONE;\n        uint256 credit = excess - fee;\n        uint256 totalOwed = credit + neededToSaveVault;\n\n        PaprToken(address(papr)).burn(address(this), fee);\n\n        if (totalOwed > debtCached) {\n            // we owe them more papr than they have in debt\n            // so we pay down debt and send them the rest\n            _reduceDebt(auction.nftOwner, auction.auctionAssetContract, address(this), debtCached);\n            papr.transfer(auction.nftOwner, totalOwed - debtCached);\n        } else {\n            // reduce vault debt\n            _reduceDebt(auction.nftOwner, auction.auctionAssetContract, address(this), totalOwed);\n            remaining = debtCached - totalOwed;\n        }\n    }\n\n    /// INTERNAL VIEW ///\n\n    function _maxDebt(uint256 totalCollateraValue, uint256 cachedTarget) internal view returns (uint256) {\n        uint256 maxLoanUnderlying = totalCollateraValue * maxLTV;\n        return maxLoanUnderlying / cachedTarget;\n    }\n}"
    }
  ]
}