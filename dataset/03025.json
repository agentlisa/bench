{
  "Title": "M-11: Delisted assets can still be deposited and borrowed against by accounts that already have them",
  "Content": "# Issue M-11: Delisted assets can still be deposited and borrowed against by accounts that already have them  \nSource: https://github.com/sherlock-audit/2022-08-sentiment-judging/tree/main/154-M \n## Found by \n0x52, Kumpa, devtooligan, WATCHPUG\n\n## Summary\n\nDelisting an asset does not prevent accounts, that already contain the asset from depositing more. It blocks the deposit function but users can sidestep but sending tokens directly to their account\n\n## Vulnerability Detail\n\nAccountManger.sol#deposit attempts to block deposits from assets that are not on the list of supported collateral. When calculating the health of the account, the total balance of the account address is considered. An account that already has the asset on it's assets list doesn't need to use AccountManger.sol#deposit because they can transfer the tokens directly to the account contract. This means that these account can continue to add to and use delisted assets as collateral.\n\n## Impact\n\nOne of two scenarios depending on actions taken by the protocol. If the asset is delisted from accountManager.sol and the oracle is removed then all users with loans taken against the asset will likely be immediately liquidated, which is highly unfair to users. If the asset is just delisted from accountManager.sol then existing users that already have the asset would be able to continue using the asset to take loans. If the reason an asset is being delisted is to prevent a vulnerability then the exploit would still be able to happen due to these accounts sidestepping deposit restrictions.\n\n## Code Snippet\n\n[AccountManager.sol#L162-L172](https://github.com/sentimentxyz/protocol/blob/4e45871e4540df0f189f6c89deb8d34f24930120/src/core/AccountManager.sol#L162-L172)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCalculations for account health should be split into two distinct categories. When calculating the health of a position post-action, unsupported assets should not be considered in the total value of the account. When calculating the health of a position for liquidation, all assets on the asset list should be considered. This prevent any new borrowing against a delisted asset but doesn't risk all affected users being liquidated unfairly.\n\n## Sentiment Team\nFixed as recommended. PR [here](https://github.com/sentimentxyz/oracle/pull/44).\n\n## Lead Senior Watson\nConfirmed fix. \n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/1",
  "Code": [
    {
      "filename": "src/core/AccountManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {Errors} from \"../utils/Errors.sol\";\nimport {Helpers} from \"../utils/Helpers.sol\";\nimport {Pausable} from \"../utils/Pausable.sol\";\nimport {IERC20} from \"../interface/tokens/IERC20.sol\";\nimport {ILToken} from \"../interface/tokens/ILToken.sol\";\nimport {IAccount} from \"../interface/core/IAccount.sol\";\nimport {IRegistry} from \"../interface/core/IRegistry.sol\";\nimport {IRiskEngine} from \"../interface/core/IRiskEngine.sol\";\nimport {IAccountFactory} from \"../interface/core/IAccountFactory.sol\";\nimport {IAccountManager} from \"../interface/core/IAccountManager.sol\";\nimport {IControllerFacade} from \"controller/core/IControllerFacade.sol\";\n\n/**\n    @title Account Manager\n    @notice Sentiment Account Manager,\n        All account interactions go via the account manager\n*/\ncontract AccountManager is Pausable, IAccountManager {\n    using Helpers for address;\n\n    /* -------------------------------------------------------------------------- */\n    /*                               STATE_VARIABLES                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Utility variable to indicate if contract is initialized\n    bool private initialized;\n\n    /// @notice Registry\n    IRegistry public registry;\n\n    /// @notice Risk Engine\n    IRiskEngine public riskEngine;\n\n    /// @notice Controller Facade\n    IControllerFacade public controller;\n\n    /// @notice Account Factory\n    IAccountFactory public accountFactory;\n\n    /// @notice List of inactive accounts per user\n    mapping(address => address[]) public inactiveAccountsOf;\n\n    /// @notice Mapping of collateral enabled tokens\n    mapping(address => bool) public isCollateralAllowed;\n\n    /* -------------------------------------------------------------------------- */\n    /*                              CUSTOM MODIFIERS                              */\n    /* -------------------------------------------------------------------------- */\n\n    modifier onlyOwner(address account) {\n        if (registry.ownerFor(account) != msg.sender)\n            revert Errors.AccountOwnerOnly();\n        _;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             EXTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Initializes contract\n        @dev Can only be invoked once\n        @param _registry Address of Registry\n    */\n    function init(IRegistry _registry) external {\n        if (initialized) revert Errors.ContractAlreadyInitialized();\n        initialized = true;\n        initPausable(msg.sender);\n        registry = _registry;\n    }\n\n    /// @notice Initializes external dependencies\n    function initDep() external adminOnly {\n        riskEngine = IRiskEngine(registry.getAddress('RISK_ENGINE'));\n        controller = IControllerFacade(registry.getAddress('CONTROLLER'));\n        accountFactory =\n            IAccountFactory(registry.getAddress('ACCOUNT_FACTORY'));\n    }\n\n    /**\n        @notice Opens a new account for a user\n        @dev Creates a new account if there are no inactive accounts otherwise\n            reuses an already inactive account\n            Emits AccountAssigned(account, owner) event\n        @param owner Owner of the newly opened account\n    */\n    function openAccount(address owner) external whenNotPaused {\n        if (owner == address(0)) revert Errors.ZeroAddress();\n        address account;\n        uint length = inactiveAccountsOf[owner].length;\n        if (length == 0) {\n            account = accountFactory.create(address(this));\n            IAccount(account).init(address(this));\n            registry.addAccount(account, owner);\n        } else {\n            account = inactiveAccountsOf[owner][length - 1];\n            inactiveAccountsOf[owner].pop();\n            registry.updateAccount(account, owner);\n        }\n        IAccount(account).activate();\n        emit AccountAssigned(account, owner);\n    }\n\n    /**\n        @notice Closes a specified account for a user\n        @dev Account can only be closed when the account has no debt\n            Emits AccountClosed(account, owner) event\n        @param _account Address of account to be closed\n    */\n    function closeAccount(address _account) public onlyOwner(_account) {\n        IAccount account = IAccount(_account);\n        if (account.activationBlock() == block.number)\n            revert Errors.AccountDeactivationFailure();\n        if (!account.hasNoDebt()) revert Errors.OutstandingDebt();\n        account.deactivate();\n        registry.closeAccount(_account);\n        inactiveAccountsOf[msg.sender].push(_account);\n        account.sweepTo(msg.sender);\n        emit AccountClosed(_account, msg.sender);\n    }\n\n    /**\n        @notice Transfers Eth from owner to account\n        @param account Address of account\n    */\n    function depositEth(address account)\n        external\n        payable\n        whenNotPaused\n        onlyOwner(account)\n    {\n        account.safeTransferEth(msg.value);\n    }\n\n    /**\n        @notice Transfers Eth from the account to owner\n        @dev Eth can only be withdrawn if the account remains healthy\n            after withdrawal\n        @param account Address of account\n        @param amt Amount of Eth to withdraw\n    */\n    function withdrawEth(address account, uint amt)\n        external\n        onlyOwner(account)\n    {\n        if(!riskEngine.isWithdrawAllowed(account, address(0), amt))\n            revert Errors.RiskThresholdBreached();\n        account.withdrawEth(msg.sender, amt);\n    }\n\n    /**\n        @notice Transfers a specified amount of token from the owner\n            to the account\n        @dev Token must be accepted as collateral by the protocol\n        @param account Address of account\n        @param token Address of token\n        @param amt Amount of token to deposit\n    */\n    function deposit(address account, address token, uint amt)\n        external\n        whenNotPaused\n        onlyOwner(account)\n    {\n        if (!isCollateralAllowed[token])\n            revert Errors.CollateralTypeRestricted();\n        if (IAccount(account).hasAsset(token) == false)\n            IAccount(account).addAsset(token);\n        token.safeTransferFrom(msg.sender, account, amt);\n    }\n\n    /**\n        @notice Transfers a specified amount of token from the account\n            to the owner of the account\n        @dev Amount of token can only be withdrawn if the account remains healthy\n            after withdrawal\n        @param account Address of account\n        @param token Address of token\n        @param amt Amount of token to withdraw\n    */\n    function withdraw(address account, address token, uint amt)\n        external\n        onlyOwner(account)\n    {\n        if (!riskEngine.isWithdrawAllowed(account, token, amt))\n            revert Errors.RiskThresholdBreached();\n        account.withdraw(msg.sender, token, amt);\n        if (token.balanceOf(account) == 0)\n            IAccount(account).removeAsset(token);\n    }\n\n    /**\n        @notice Transfers a specified amount of token from the LP to the account\n        @dev Specified token must have a LP\n            Account must remain healthy after the borrow, otherwise tx is reverted\n            Emits Borrow(account, msg.sender, token, amount) event\n        @param account Address of account\n        @param token Address of token\n        @param amt Amount of token to borrow\n    */\n    function borrow(address account, address token, uint amt)\n        external\n        whenNotPaused\n        onlyOwner(account)\n    {\n        if (registry.LTokenFor(token) == address(0))\n            revert Errors.LTokenUnavailable();\n        if (!riskEngine.isBorrowAllowed(account, token, amt))\n            revert Errors.RiskThresholdBreached();\n        if (IAccount(account).hasAsset(token) == false)\n            IAccount(account).addAsset(token);\n        if (ILToken(registry.LTokenFor(token)).lendTo(account, amt))\n            IAccount(account).addBorrow(token);\n        emit Borrow(account, msg.sender, token, amt);\n    }\n\n    /**\n        @notice Transfers a specified amount of token from the account to the LP\n        @dev Specified token must have a LP\n            Emits Repay(account, msg.sender, token, amount) event\n        @param account Address of account\n        @param token Address of token\n        @param amt Amount of token to borrow\n    */\n    function repay(address account, address token, uint amt)\n        public\n        onlyOwner(account)\n    {\n        ILToken LToken = ILToken(registry.LTokenFor(token));\n        if (address(LToken) == address(0))\n            revert Errors.LTokenUnavailable();\n        LToken.updateState();\n        if (amt == type(uint256).max) amt = LToken.getBorrowBalance(account);\n        account.withdraw(address(LToken), token, amt);\n        if (LToken.collectFrom(account, amt))\n            IAccount(account).removeBorrow(token);\n        if (IERC20(token).balanceOf(account) == 0)\n            IAccount(account).removeAsset(token);\n        emit Repay(account, msg.sender, token, amt);\n    }\n\n    /**\n        @notice Liquidates an account\n        @dev Account can only be liquidated when it's unhealthy\n            Emits AccountLiquidated(account, owner) event\n        @param account Address of account\n    */\n    function liquidate(address account) external {\n        if (riskEngine.isAccountHealthy(account))\n            revert Errors.AccountNotLiquidatable();\n        _liquidate(account);\n        emit AccountLiquidated(account, registry.ownerFor(account));\n    }\n\n    /**\n        @notice Gives a spender approval to spend a given amount of token from\n            the account\n        @dev Spender must have a controller in controller facade\n        @param account Address of account\n        @param token Address of token\n        @param spender Address of spender\n        @param amt Amount of token\n    */\n    function approve(\n        address account,\n        address token,\n        address spender,\n        uint amt\n    )\n        external\n        onlyOwner(account)\n    {\n        if(address(controller.controllerFor(spender)) == address(0))\n            revert Errors.FunctionCallRestricted();\n        account.safeApprove(token, spender, amt);\n    }\n\n    /**\n        @notice A general function that allows the owner to perform specific interactions\n            with external protocols for their account\n        @dev Target must have a controller in controller facade\n        @param account Address of account\n        @param target Address of contract to transact with\n        @param amt Amount of Eth to send to the target contract\n        @param data Encoded sig + params of the function to transact with in the\n            target contract\n    */\n    function exec(\n        address account,\n        address target,\n        uint amt,\n        bytes calldata data\n    )\n        external\n        onlyOwner(account)\n    {\n        bool isAllowed;\n        address[] memory tokensIn;\n        address[] memory tokensOut;\n        (isAllowed, tokensIn, tokensOut) =\n            controller.canCall(target, (amt > 0), data);\n        if (!isAllowed) revert Errors.FunctionCallRestricted();\n        _updateTokensIn(account, tokensIn);\n        (bool success,) = IAccount(account).exec(target, amt, data);\n        if (!success)\n            revert Errors.AccountInteractionFailure(account, target, amt, data);\n        _updateTokensOut(account, tokensOut);\n        if (!riskEngine.isAccountHealthy(account))\n            revert Errors.RiskThresholdBreached();\n    }\n\n    /**\n        @notice Settles an account by repaying all the loans\n        @param account Address of account\n    */\n    function settle(address account) external onlyOwner(account) {\n        address[] memory borrows = IAccount(account).getBorrows();\n        for (uint i; i < borrows.length; i++) {\n            uint balance;\n            if (borrows[i] == address(0)) balance = account.balance;\n            else balance = borrows[i].balanceOf(account);\n            if ( balance > 0 ) repay(account, borrows[i], type(uint).max);\n        }\n    }\n\n    /**\n        @notice Fetches inactive accounts of a user\n        @param user Address of user\n        @return address[] List of inactive accounts\n    */\n    function getInactiveAccountsOf(\n        address user\n    )\n        external\n        view\n        returns (address[] memory)\n    {\n        return inactiveAccountsOf[user];\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             Internal Functions                             */\n    /* -------------------------------------------------------------------------- */\n\n    function _updateTokensIn(address account, address[] memory tokensIn)\n        internal\n    {\n        uint tokensInLen = tokensIn.length;\n        for(uint i; i < tokensInLen; ++i) {\n            if (IAccount(account).hasAsset(tokensIn[i]) == false)\n                IAccount(account).addAsset(tokensIn[i]);\n        }\n    }\n\n    function _updateTokensOut(address account, address[] memory tokensOut)\n        internal\n    {\n        uint tokensOutLen = tokensOut.length;\n        for(uint i; i < tokensOutLen; ++i) {\n            if (tokensOut[i].balanceOf(account) == 0)\n                IAccount(account).removeAsset(tokensOut[i]);\n        }\n    }\n\n    function _liquidate(address _account) internal {\n        IAccount account = IAccount(_account);\n        address[] memory accountBorrows = account.getBorrows();\n        uint borrowLen = accountBorrows.length;\n\n        ILToken LToken;\n        uint amt;\n\n        for(uint i; i < borrowLen; ++i) {\n            address token = accountBorrows[i];\n            LToken = ILToken(registry.LTokenFor(token));\n            LToken.updateState();\n            amt = LToken.getBorrowBalance(_account);\n            token.safeTransferFrom(msg.sender, address(LToken), amt);\n            LToken.collectFrom(_account, amt);\n            account.removeBorrow(token);\n        }\n        account.sweepTo(msg.sender);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                               ADMIN FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Toggle collateral status of a token\n        @param token Address of token\n    */\n    function toggleCollateralStatus(address token) external adminOnly {\n        isCollateralAllowed[token] = !isCollateralAllowed[token];\n    }\n}"
    }
  ]
}