{
  "Title": "[M-04] requireNextActiveMultisig will always return the first enabled multisig which increases the probability of stuck minipools",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MultisigManager.sol#L80-L91\n\n\n# Vulnerability details\n\n\nFor every created minipool a multisig address is set to continue validator interactions.\n\nEvery minipool multisig address get assigned by calling `requireNextActiveMultisig`.\n\nThis function always return the first enabled multisig address.\n\nIn case the specific address is disabled all created minipools will be stuck with this address which increase the probability of also funds being stuck.\n\n## Impact\nProbability of funds being stuck increases if `requireNextActiveMultisig` always return the same address.\n\n## Proof of Concept\nhttps://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MultisigManager.sol#L80-L91\n\n## Tools Used\nManual review\n\n## Recommended Mitigation Steps\nUse a strategy like [round robin](https://en.wikipedia.org/wiki/Round-robin_item_allocation) to assign next active multisig to minipool\n\nSomething like this :\n\n```solidity\nprivate uint nextMultisigAddressIdx;\n\nfunction requireNextActiveMultisig() external view returns (address) {\n    uint256 total = getUint(keccak256(\"multisig.count\"));\n    address addr;\n    bool enabled;\n\n    uint256 i = nextMultisigAddressIdx; // cache last used\n    if (nextMultisigAddressIdx==total) {\n        i = 0;\n    }\n\n    for (; i < total; i++) {\n        (addr, enabled) = getMultisig(i);\n        if (enabled) {\n            nextMultisigAddressIdx = i+1;\n            return addr;\n        }\n    }\n    \n    revert NoEnabledMultisigFound();\n}\n```",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-12-gogopool-contest",
  "Code": [
    {
      "filename": "contracts/contract/MultisigManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport \"./Base.sol\";\nimport {Storage} from \"./Storage.sol\";\n\n/*\n\tData Storage Schema\n\tmultisig.count = Starts at 0 and counts up by 1 after an addr is added.\n\n\tmultisig.index<address> = <index> + 1 of multisigAddress\n\tmultisig.item<index>.address = C-chain address used as primary key\n\tmultisig.item<index>.enabled = bool\n*/\n\n/// @title Multisig address creation and management for the protocol\ncontract MultisigManager is Base {\n\terror MultisigAlreadyRegistered();\n\terror MultisigNotFound();\n\terror MultisigLimitReached();\n\terror NoEnabledMultisigFound();\n\n\tevent DisabledMultisig(address indexed multisig, address actor);\n\tevent EnabledMultisig(address indexed multisig, address actor);\n\tevent RegisteredMultisig(address indexed multisig, address actor);\n\n\tuint256 public constant MULTISIG_LIMIT = 10;\n\n\tconstructor(Storage storageAddress) Base(storageAddress) {\n\t\tversion = 1;\n\t}\n\n\t/// @notice Register a multisig. Defaults to disabled when first registered.\n\t/// @param addr Address of the multisig that is being registered\n\tfunction registerMultisig(address addr) external onlyGuardian {\n\t\tint256 multisigIndex = getIndexOf(addr);\n\t\tif (multisigIndex != -1) {\n\t\t\trevert MultisigAlreadyRegistered();\n\t\t}\n\t\tuint256 index = getUint(keccak256(\"multisig.count\"));\n\t\tif (index >= MULTISIG_LIMIT) {\n\t\t\trevert MultisigLimitReached();\n\t\t}\n\n\t\tsetAddress(keccak256(abi.encodePacked(\"multisig.item\", index, \".address\")), addr);\n\n\t\t// The index is stored 1 greater than the actual value. The 1 is subtracted in getIndexOf().\n\t\tsetUint(keccak256(abi.encodePacked(\"multisig.index\", addr)), index + 1);\n\t\taddUint(keccak256(\"multisig.count\"), 1);\n\t\temit RegisteredMultisig(addr, msg.sender);\n\t}\n\n\t/// @notice Enabling a registered multisig\n\t/// @param addr Address of the multisig that is being enabled\n\tfunction enableMultisig(address addr) external onlyGuardian {\n\t\tint256 multisigIndex = getIndexOf(addr);\n\t\tif (multisigIndex == -1) {\n\t\t\trevert MultisigNotFound();\n\t\t}\n\n\t\tsetBool(keccak256(abi.encodePacked(\"multisig.item\", multisigIndex, \".enabled\")), true);\n\t\temit EnabledMultisig(addr, msg.sender);\n\t}\n\n\t/// @notice Disabling a registered multisig\n\t/// @param addr Address of the multisig that is being disabled\n\t/// @dev this will prevent the multisig from completing validations. The minipool will need to be manually reassigned to a new multisig\n\tfunction disableMultisig(address addr) external guardianOrSpecificRegisteredContract(\"Ocyticus\", msg.sender) {\n\t\tint256 multisigIndex = getIndexOf(addr);\n\t\tif (multisigIndex == -1) {\n\t\t\trevert MultisigNotFound();\n\t\t}\n\n\t\tsetBool(keccak256(abi.encodePacked(\"multisig.item\", multisigIndex, \".enabled\")), false);\n\t\temit DisabledMultisig(addr, msg.sender);\n\t}\n\n\t/// @notice Gets the next registered and enabled Multisig, revert if none found\n\t/// @dev There will never be more than 10 total multisigs. If we grow beyond that we will redesign this contract.\n\tfunction requireNextActiveMultisig() external view returns (address) {\n\t\tuint256 total = getUint(keccak256(\"multisig.count\"));\n\t\taddress addr;\n\t\tbool enabled;\n\t\tfor (uint256 i = 0; i < total; i++) {\n\t\t\t(addr, enabled) = getMultisig(i);\n\t\t\tif (enabled) {\n\t\t\t\treturn addr;\n\t\t\t}\n\t\t}\n\t\trevert NoEnabledMultisigFound();\n\t}\n\n\t/// @notice The index of a multisig. Returns -1 if the multisig is not found\n\t/// @param addr Address of the multisig that is being searched for\n\t/// @return The index for the given multisig\n\tfunction getIndexOf(address addr) public view returns (int256) {\n\t\treturn int256(getUint(keccak256(abi.encodePacked(\"multisig.index\", addr)))) - 1;\n\t}\n\n\t/// @notice Get the total count of the multisigs in the protocol\n\t/// @return Count of all multisigs\n\tfunction getCount() public view returns (uint256) {\n\t\treturn getUint(keccak256(\"multisig.count\"));\n\t}\n\n\t/// @notice Gets the multisig information using the multisig's index\n\t/// @param index Index of the multisig\n\t/// @return addr and enabled. The address and the enabled status of the multisig\n\tfunction getMultisig(uint256 index) public view returns (address addr, bool enabled) {\n\t\taddr = getAddress(keccak256(abi.encodePacked(\"multisig.item\", index, \".address\")));\n\t\tenabled = (addr != address(0)) && getBool(keccak256(abi.encodePacked(\"multisig.item\", index, \".enabled\")));\n\t}\n}"
    }
  ]
}