{
  "Title": "Spelling mistakes",
  "Content": "##### Description\nSome texts have spelling mistakes:\n1) `SYBMOL` -> `SYMBOL` (bad input param)\n   https://github.com/1inch/solidity-utils/blob/eec6b523860af5215a8dd196fe3aff3a4d252fc9/contracts/libraries/UniERC20.sol#L62\n2) `signuture` -> `signature`\n   https://github.com/1inch/limit-order-protocol/blob/d8437885744543e3f057e84e1b0a05c4c211c553/contracts/OrderRFQMixin.sol#L98\n\n##### Recommendation\nWe recommend correcting them.\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/libraries/UniERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./RevertReasonForwarder.sol\";\nimport \"./SafeERC20.sol\";\nimport \"./StringUtil.sol\";\n\nlibrary UniERC20 {\n    using SafeERC20 for IERC20;\n\n    error ApproveCalledOnETH();\n    error NotEnoughValue();\n    error FromIsNotSender();\n    error ToIsNotThis();\n    error ERC20OperationFailed();\n\n    IERC20 private constant _ETH_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n    IERC20 private constant _ZERO_ADDRESS = IERC20(address(0));\n\n    function isETH(IERC20 token) internal pure returns (bool) {\n        return (token == _ZERO_ADDRESS || token == _ETH_ADDRESS);\n    }\n\n    function uniBalanceOf(IERC20 token, address account) internal view returns (uint256) {\n        if (isETH(token)) {\n            return account.balance;\n        } else {\n            return token.balanceOf(account);\n        }\n    }\n\n    function uniTransfer(IERC20 token, address payable to, uint256 amount) internal {\n        if (amount > 0) {\n            if (isETH(token)) {\n                to.transfer(amount);\n            } else {\n                token.safeTransfer(to, amount);\n            }\n        }\n    }\n\n    function uniTransferFrom(IERC20 token, address payable from, address to, uint256 amount) internal {\n        if (amount > 0) {\n            if (isETH(token)) {\n                if (msg.value < amount) revert NotEnoughValue();\n                if (from != msg.sender) revert FromIsNotSender();\n                if (to != address(this)) revert ToIsNotThis();\n                if (msg.value > amount) {\n                    // Return remainder if exist\n                    unchecked { from.transfer(msg.value - amount); }\n                }\n            } else {\n                token.safeTransferFrom(from, to, amount);\n            }\n        }\n    }\n\n    function uniSymbol(IERC20 token) internal view returns(string memory) {\n        return _uniDecode(token, \"symbol()\", \"SYBMOL()\");\n    }\n\n    function uniName(IERC20 token) internal view returns(string memory) {\n        return _uniDecode(token, \"name()\", \"NAME()\");\n    }\n\n    function uniApprove(IERC20 token, address to, uint256 amount) internal {\n        if (isETH(token)) revert ApproveCalledOnETH();\n\n        token.forceApprove(to, amount);\n    }\n\n    function _uniDecode(IERC20 token, string memory lowerCaseSignature, string memory upperCaseSignature) private view returns(string memory) {\n        if (isETH(token)) {\n            return \"ETH\";\n        }\n\n        (bool success, bytes memory data) = address(token).staticcall{ gas: 20000 }(\n            abi.encodeWithSignature(lowerCaseSignature)\n        );\n        if (!success) {\n            (success, data) = address(token).staticcall{ gas: 20000 }(\n                abi.encodeWithSignature(upperCaseSignature)\n            );\n        }\n\n        if (success && data.length >= 96) {\n            (uint256 offset, uint256 len) = abi.decode(data, (uint256, uint256));\n            if (offset == 0x20 && len > 0 && len <= 256) {\n                return abi.decode(data, (string));\n            }\n        }\n\n        if (success && data.length == 32) {\n            uint256 len = 0;\n            while (len < data.length && data[len] >= 0x20 && data[len] <= 0x7E) {\n                len++;\n            }\n\n            if (len > 0) {\n                assembly { // solhint-disable-line no-inline-assembly\n                    mstore(data, len)\n                }\n                return string(data);\n            }\n        }\n\n        return StringUtil.toHex(address(token));\n    }\n}"
    },
    {
      "filename": "contracts/OrderRFQMixin.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\nimport { EIP712 } from \"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@1inch/solidity-utils/contracts/interfaces/IWETH.sol\";\nimport \"@1inch/solidity-utils/contracts/libraries/SafeERC20.sol\";\n\nimport \"./helpers/AmountCalculator.sol\";\nimport \"./libraries/Errors.sol\";\nimport \"./OrderRFQLib.sol\";\n\n/// @title RFQ Limit Order mixin\nabstract contract OrderRFQMixin is EIP712, AmountCalculator {\n    using SafeERC20 for IERC20;\n    using OrderRFQLib for OrderRFQLib.OrderRFQ;\n\n    error RFQZeroTargetIsForbidden();\n    error RFQPrivateOrder();\n    error RFQBadSignature();\n    error OrderExpired();\n    error MakingAmountExceeded();\n    error TakingAmountExceeded();\n    error RFQSwapWithZeroAmount();\n    error InvalidatedOrder();\n    error ETHTransferFailed();\n\n    /**\n     * @notice Emitted when RFQ gets filled\n     * @param orderHash Hash of the order\n     * @param makingAmount Amount of the maker asset that was transferred from maker to taker\n     */\n    event OrderFilledRFQ(\n        bytes32 orderHash,\n        uint256 makingAmount\n    );\n\n    IWETH private immutable _WETH;  // solhint-disable-line var-name-mixedcase\n    mapping(address => mapping(uint256 => uint256)) private _invalidator;\n\n    constructor(IWETH weth) {\n        _WETH = weth;\n    }\n\n    /**\n     * @notice Returns bitmask for double-spend invalidators based on lowest byte of order.info and filled quotes\n     * @param maker Maker address\n     * @param slot Slot number to return bitmask for\n     * @return result Each bit represents whether corresponding was already invalidated\n     */\n    function invalidatorForOrderRFQ(address maker, uint256 slot) external view returns(uint256 /* result */) {\n        return _invalidator[maker][slot];\n    }\n\n    /**\n     * @notice Cancels order's quote\n     * @param orderInfo Order info (only order id in lowest 64 bits is used)\n     */\n    function cancelOrderRFQ(uint256 orderInfo) external {\n        _invalidateOrder(msg.sender, orderInfo, 0);\n    }\n\n    /// @notice Cancels multiple order's quotes\n    function cancelOrderRFQ(uint256 orderInfo, uint256 additionalMask) public {\n        _invalidateOrder(msg.sender, orderInfo, additionalMask);\n    }\n\n    /**\n     * @notice Fills order's quote, fully or partially (whichever is possible)\n     * @param order Order quote to fill\n     * @param signature Signature to confirm quote ownership\n     * @param flagsAndAmount Fill configuration flags with amount packed in one slot\n     * @return filledMakingAmount Actual amount transferred from maker to taker\n     * @return filledTakingAmount Actual amount transferred from taker to maker\n     * @return orderHash Hash of the filled order\n     */\n    function fillOrderRFQ(\n        OrderRFQLib.OrderRFQ memory order,\n        bytes calldata signature,\n        uint256 flagsAndAmount\n    ) external payable returns(uint256 /* filledMakingAmount */, uint256 /* filledTakingAmount */, bytes32 /* orderHash */) {\n        return fillOrderRFQTo(order, signature, flagsAndAmount, msg.sender);\n    }\n\n    uint256 constant private _MAKER_AMOUNT_FLAG = 1 << 255;\n    uint256 constant private _SIGNER_SMART_CONTRACT_HINT = 1 << 254;\n    uint256 constant private _IS_VALID_SIGNATURE_65_BYTES = 1 << 253;\n    uint256 constant private _UNWRAP_WETH_FLAG = 1 << 252;\n    uint256 constant private _AMOUNT_MASK = ~(\n        _MAKER_AMOUNT_FLAG |\n        _SIGNER_SMART_CONTRACT_HINT |\n        _IS_VALID_SIGNATURE_65_BYTES |\n        _UNWRAP_WETH_FLAG\n    );\n\n    /**\n     * @notice Fills order's quote, fully or partially, with compact signuture\n     * @param order Order quote to fill\n     * @param r R component of signature\n     * @param vs VS component of signature\n     * @param flagsAndAmount Fill configuration flags with amount packed in one slot\n     * - Bits 0-252 contain the amount to fill\n     * - Bit 253 is used to indicate whether signature is 64-bit (0) or 65-bit (1)\n     * - Bit 254 is used to indicate whether smart contract (1) signed the order or not (0)\n     * - Bit 255 is used to indicate whether maker (1) or taker amount (0) is given in the amount parameter\n     * @return filledMakingAmount Actual amount transferred from maker to taker\n     * @return filledTakingAmount Actual amount transferred from taker to maker\n     * @return orderHash Hash of the filled order\n     */\n    function fillOrderRFQCompact(\n        OrderRFQLib.OrderRFQ memory order,\n        bytes32 r,\n        bytes32 vs,\n        uint256 flagsAndAmount\n    ) external payable returns(uint256 filledMakingAmount, uint256 filledTakingAmount, bytes32 orderHash) {\n        orderHash = order.hash(_domainSeparatorV4());\n        if (flagsAndAmount & _SIGNER_SMART_CONTRACT_HINT != 0) {\n            if (flagsAndAmount & _IS_VALID_SIGNATURE_65_BYTES != 0) {\n                if (!ECDSA.isValidSignature65(order.maker, orderHash, r, vs)) revert RFQBadSignature();\n            } else {\n                if (!ECDSA.isValidSignature(order.maker, orderHash, r, vs)) revert RFQBadSignature();\n            }\n        } else {\n            if(!ECDSA.recoverOrIsValidSignature(order.maker, orderHash, r, vs)) revert RFQBadSignature();\n        }\n\n        (filledMakingAmount, filledTakingAmount) = _fillOrderRFQTo(order, flagsAndAmount, msg.sender);\n        emit OrderFilledRFQ(orderHash, filledMakingAmount);\n    }\n\n    /**\n     * @notice Fills Same as `fillOrderRFQ` but calls permit first.\n     * It allows to approve token spending and make a swap in one transaction.\n     * Also allows to specify funds destination instead of `msg.sender`\n     * @param order Order quote to fill\n     * @param signature Signature to confirm quote ownership\n     * @param flagsAndAmount Fill configuration flags with amount packed in one slot\n     * @param target Address that will receive swap funds\n     * @param permit Should consist of abiencoded token address and encoded `IERC20Permit.permit` call.\n     * @return filledMakingAmount Actual amount transferred from maker to taker\n     * @return filledTakingAmount Actual amount transferred from taker to maker\n     * @return orderHash Hash of the filled order\n     * @dev See tests for examples\n     */\n    function fillOrderRFQToWithPermit(\n        OrderRFQLib.OrderRFQ memory order,\n        bytes calldata signature,\n        uint256 flagsAndAmount,\n        address target,\n        bytes calldata permit\n    ) external returns(uint256 /* filledMakingAmount */, uint256 /* filledTakingAmount */, bytes32 /* orderHash */) {\n        IERC20(order.takerAsset).safePermit(permit);\n        return fillOrderRFQTo(order, signature, flagsAndAmount, target);\n    }\n\n    /**\n     * @notice Same as `fillOrderRFQ` but allows to specify funds destination instead of `msg.sender`\n     * @param order Order quote to fill\n     * @param signature Signature to confirm quote ownership\n     * @param flagsAndAmount Fill configuration flags with amount packed in one slot\n     * @param target Address that will receive swap funds\n     * @return filledMakingAmount Actual amount transferred from maker to taker\n     * @return filledTakingAmount Actual amount transferred from taker to maker\n     * @return orderHash Hash of the filled order\n     */\n    function fillOrderRFQTo(\n        OrderRFQLib.OrderRFQ memory order,\n        bytes calldata signature,\n        uint256 flagsAndAmount,\n        address target\n    ) public payable returns(uint256 filledMakingAmount, uint256 filledTakingAmount, bytes32 orderHash) {\n        orderHash = order.hash(_domainSeparatorV4());\n        if (flagsAndAmount & _SIGNER_SMART_CONTRACT_HINT != 0) {\n            if (flagsAndAmount & _IS_VALID_SIGNATURE_65_BYTES != 0 && signature.length != 65) revert RFQBadSignature();\n            if (!ECDSA.isValidSignature(order.maker, orderHash, signature)) revert RFQBadSignature();\n        } else {\n            if(!ECDSA.recoverOrIsValidSignature(order.maker, orderHash, signature)) revert RFQBadSignature();\n        }\n        (filledMakingAmount, filledTakingAmount) = _fillOrderRFQTo(order, flagsAndAmount, target);\n        emit OrderFilledRFQ(orderHash, filledMakingAmount);\n    }\n\n    function _fillOrderRFQTo(\n        OrderRFQLib.OrderRFQ memory order,\n        uint256 flagsAndAmount,\n        address target\n    ) private returns(uint256 makingAmount, uint256 takingAmount) {\n        if (target == address(0)) revert RFQZeroTargetIsForbidden();\n\n        address maker = order.maker;\n\n        // Validate order\n        if (order.allowedSender != address(0) && order.allowedSender != msg.sender) revert RFQPrivateOrder();\n\n        {  // Stack too deep\n            uint256 info = order.info;\n            // Check time expiration\n            uint256 expiration = uint128(info) >> 64;\n            if (expiration != 0 && block.timestamp > expiration) revert OrderExpired(); // solhint-disable-line not-rely-on-time\n            _invalidateOrder(maker, info, 0);\n        }\n\n        {  // Stack too deep\n            uint256 orderMakingAmount = order.makingAmount;\n            uint256 orderTakingAmount = order.takingAmount;\n            uint256 amount = flagsAndAmount & _AMOUNT_MASK;\n            // Compute partial fill if needed\n            if (amount == 0) {\n                // zero amount means whole order\n                makingAmount = orderMakingAmount;\n                takingAmount = orderTakingAmount;\n            }\n            else if (flagsAndAmount & _MAKER_AMOUNT_FLAG != 0) {\n                if (amount > orderMakingAmount) revert MakingAmountExceeded();\n                makingAmount = amount;\n                takingAmount = getTakingAmount(orderMakingAmount, orderTakingAmount, makingAmount);\n            }\n            else {\n                if (amount > orderTakingAmount) revert TakingAmountExceeded();\n                takingAmount = amount;\n                makingAmount = getMakingAmount(orderMakingAmount, orderTakingAmount, takingAmount);\n            }\n        }\n\n        if (makingAmount == 0 || takingAmount == 0) revert RFQSwapWithZeroAmount();\n\n        // Maker => Taker\n        if (order.makerAsset == address(_WETH) && flagsAndAmount & _UNWRAP_WETH_FLAG != 0) {\n            _WETH.transferFrom(maker, address(this), makingAmount);\n            _WETH.withdraw(makingAmount);\n            (bool success, ) = target.call{value: makingAmount}(\"\");  // solhint-disable-line avoid-low-level-calls\n            if (!success) revert ETHTransferFailed();\n        } else {\n            IERC20(order.makerAsset).safeTransferFrom(maker, target, makingAmount);\n        }\n\n        // Taker => Maker\n        if (order.takerAsset == address(_WETH) && msg.value > 0) {\n            if (msg.value != takingAmount) revert InvalidMsgValue();\n            _WETH.deposit{ value: takingAmount }();\n            _WETH.transfer(maker, takingAmount);\n        } else {\n            if (msg.value != 0) revert InvalidMsgValue();\n            IERC20(order.takerAsset).safeTransferFrom(msg.sender, maker, takingAmount);\n        }\n    }\n\n    function _invalidateOrder(address maker, uint256 orderInfo, uint256 additionalMask) private {\n        uint256 invalidatorSlot = uint64(orderInfo) >> 8;\n        uint256 invalidatorBits = (1 << uint8(orderInfo)) | additionalMask;\n        mapping(uint256 => uint256) storage invalidatorStorage = _invalidator[maker];\n        uint256 invalidator = invalidatorStorage[invalidatorSlot];\n        if (invalidator & invalidatorBits != 0) revert InvalidatedOrder();\n        invalidatorStorage[invalidatorSlot] = invalidator | invalidatorBits;\n    }\n}"
    }
  ]
}