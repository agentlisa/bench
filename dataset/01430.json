{
  "Title": "The same signature can be used in different `distribution` implementation causing that the caller who owns the signature, can distribute on unauthorized implementations",
  "Content": "# The same signature can be used in different `distribution` implementation causing that the caller who owns the signature, can distribute on unauthorized implementations\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-08-sparkn/blob/0f139b2dc53905700dd29a01451b330f829653e9/src/ProxyFactory.sol#L159\">https://github.com/Cyfrin/2023-08-sparkn/blob/0f139b2dc53905700dd29a01451b330f829653e9/src/ProxyFactory.sol#L159</a>\n\n\n## Summary\n\nThe same signature can be used in different `distribute` implementations causing that the caller who owns the signature, to distribute on unauthorized implementations.\n\n## Vulnerability Details\n\nThe [ProxyFactory::setContest()](https://github.com/Cyfrin/2023-08-sparkn/blob/0f139b2dc53905700dd29a01451b330f829653e9/src/ProxyFactory.sol#L105) function helps to configure a `closeTime` to specific `organizer`, `contestId` and `implementation`.\n\n```solidity\nFile: ProxyFactory.sol\n105:     function setContest(address organizer, bytes32 contestId, uint256 closeTime, address implementation)\n106:         public\n107:         onlyOwner\n...\n...\n113:         bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n114:         if (saltToCloseTime[salt] != 0) revert ProxyFactory__ContestIsAlreadyRegistered();\n115:         saltToCloseTime[salt] = closeTime;\n```\n\nThe caller who owns the signature, can distributes to winners using the [deployProxyAndDistributeBySignature()](https://github.com/Cyfrin/2023-08-sparkn/blob/0f139b2dc53905700dd29a01451b330f829653e9/src/ProxyFactory.sol#L152) function. The problem is that the hash in the code line ([#159](https://github.com/Cyfrin/2023-08-sparkn/blob/0f139b2dc53905700dd29a01451b330f829653e9/src/ProxyFactory.sol#L159)) does not consider the `implementation` parameter. \n\n```solidity\nFile: ProxyFactory.sol\n152:     function deployProxyAndDistributeBySignature(\n153:         address organizer,\n154:         bytes32 contestId,\n155:         address implementation,\n156:         bytes calldata signature,\n157:         bytes calldata data\n158:     ) public returns (address) {\n159:         bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(contestId, data)));\n160:         if (ECDSA.recover(digest, signature) != organizer) revert ProxyFactory__InvalidSignature();\n161:         bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n162:         if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n163:         if (saltToCloseTime[salt] > block.timestamp) revert ProxyFactory__ContestIsNotClosed();\n164:         address proxy = _deployProxy(organizer, contestId, implementation);\n165:         _distribute(proxy, data);\n166:         return proxy;\n167:     }\n```\n\nFor some reason, there could be a different `distribution` implementation to the same `contestId`. Then the caller who owns the signature can distribute even if the organizer does not authorize a signature to the new implementation.\n\nI created a test where the caller who owns a signature can distribute to new `distribute implementation` using the same signature. Test steps:\n\n1. Owner setContest using the implementation `address(distributor)`\n2. Organizer creates a signature.\n3. Caller distributes prizes using the signature.\n4. For some reason there is a new distributor implementation. The Owner set the new distributor for the same `contestId`.\n5. The caller can distribute prizes using the same signature created in the step 2 in different distributor implementation.\n\n```solidity\n// test/integration/ProxyFactoryTest.t.sol:ProxyFactoryTest\n// $ forge test --match-test \"testSignatureCanBeUsedToNewImplementation\" -vvv\n//\n    function testSignatureCanBeUsedToNewImplementation() public {\n        address organizer = TEST_SIGNER;\n        bytes32 contestId = keccak256(abi.encode(\"Jason\", \"001\"));\n        //\n        // 1. Owner setContest using address(distributor)\n        vm.startPrank(factoryAdmin);\n        proxyFactory.setContest(organizer, contestId, block.timestamp + 8 days, address(distributor));\n        vm.stopPrank();\n        bytes32 salt = keccak256(abi.encode(organizer, contestId, address(distributor)));\n        address proxyAddress = proxyFactory.getProxyAddress(salt, address(distributor));\n        vm.startPrank(sponsor);\n        MockERC20(jpycv2Address).transfer(proxyAddress, 10000 ether);\n        vm.stopPrank();\n        assertEq(MockERC20(jpycv2Address).balanceOf(proxyAddress), 10000 ether);\n        // before\n        assertEq(MockERC20(jpycv2Address).balanceOf(user1), 0 ether);\n        assertEq(MockERC20(jpycv2Address).balanceOf(stadiumAddress), 0 ether);\n        //\n        // 2. Organizer creates a signature\n        (bytes32 digest, bytes memory sendingData, bytes memory signature) = createSignatureByASigner(TEST_SIGNER_KEY);\n        assertEq(ECDSA.recover(digest, signature), TEST_SIGNER);\n        vm.warp(8.01 days);\n        //\n        // 3. Caller distributes prizes using the signature\n        proxyFactory.deployProxyAndDistributeBySignature(\n            TEST_SIGNER, contestId, address(distributor), signature, sendingData\n        );\n        // after\n        assertEq(MockERC20(jpycv2Address).balanceOf(user1), 9500 ether);\n        assertEq(MockERC20(jpycv2Address).balanceOf(stadiumAddress), 500 ether);\n        //\n        // 4. For some reason there is a new distributor implementation.\n        // The Owner set the new distributor for the same contestId\n        Distributor new_distributor = new Distributor(address(proxyFactory), stadiumAddress);\n        vm.startPrank(factoryAdmin);\n        proxyFactory.setContest(organizer, contestId, block.timestamp + 8 days, address(new_distributor));\n        vm.stopPrank();\n        bytes32 newDistributorSalt = keccak256(abi.encode(organizer, contestId, address(new_distributor)));\n        address proxyNewDistributorAddress = proxyFactory.getProxyAddress(newDistributorSalt, address(new_distributor));\n        vm.startPrank(sponsor);\n        MockERC20(jpycv2Address).transfer(proxyNewDistributorAddress, 10000 ether);\n        vm.stopPrank();\n        //\n        // 5. The caller can distribute prizes using the same signature in different distributor implementation\n        vm.warp(20 days);\n        proxyFactory.deployProxyAndDistributeBySignature(\n            TEST_SIGNER, contestId, address(new_distributor), signature, sendingData\n        );\n    }\n```\n\n## Impact\n\nThe caller who owns the signature, can distribute the prizes for a new distribution implementation using the same signature which was created for an old implementation. \nThe `organizer` must create a new signature if there is a new implementation for the same `contestId`. The authorized signature is for one distribution implementation not for the future distribution implementations.\n\n## Tools used\n\nManual review\n\n## Recommendations\n\nInclude the `distribution implementation` in the [signature hash](https://github.com/Cyfrin/2023-08-sparkn/blob/main/src/ProxyFactory.sol#L159).\n\n```diff\n    function deployProxyAndDistributeBySignature(\n        address organizer,\n        bytes32 contestId,\n        address implementation,\n        bytes calldata signature,\n        bytes calldata data\n    ) public returns (address) {\n--      bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(contestId, data)));\n++      bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(contestId, implementation, data)));\n```",
  "Impact": "HIGH",
  "Source": "https://www.codehawks.com/contests/cllcnja1h0001lc08z7w0orxx",
  "Code": [
    {
      "filename": "src/ProxyFactory.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n// Layout of Contract:\n// version\n// imports\n// errors\n// interfaces, libraries, contracts\n// Type declarations\n// State variables\n// Events\n// Modifiers\n// Functions\n\n// Layout of Functions:\n// constructor\n// receive function (if exists)\n// fallback function (if exists)\n// external\n// public\n// internal\n// private\n// view & pure functions\n\npragma solidity 0.8.18;\n\nimport {Ownable} from \"openzeppelin/access/Ownable.sol\";\nimport {ECDSA} from \"openzeppelin/utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"openzeppelin/utils/cryptography/EIP712.sol\";\nimport {Proxy} from \"./Proxy.sol\";\n\n/**\n * @title ProxyFactory contract\n * @notice This contract is the main entry point for users to use SPARKN's contracts.\n * @notice It will be used to deploy proxy contracts for every contest in SPARKN.\n * @dev This contract is the factory contract which will be used to deploy proxy contracts.\n */\ncontract ProxyFactory is Ownable, EIP712 {\n    //////////////////////\n    /////// Error ////////\n    //////////////////////\n    error ProxyFactory__NoEmptyArray();\n    error ProxyFactory__NoZeroAddress();\n    error ProxyFactory__CloseTimeNotInRange();\n    error ProxyFactory__InvalidSignature();\n    error ProxyFactory__ContestIsAlreadyRegistered();\n    error ProxyFactory__ContestIsNotClosed();\n    error ProxyFactory__ContestIsNotRegistered();\n    error ProxyFactory__ContestIsNotExpired();\n    error ProxyFactory__DelegateCallFailed();\n    error ProxyFactory__ProxyAddressCannotBeZero();\n\n    /////////////////////\n    /////// Event ///////\n    /////////////////////\n    event SetContest(\n        address indexed organizer, bytes32 indexed contestId, uint256 closeTime, address indexed implementation\n    );\n    event Distributed(address indexed proxy, bytes data);\n\n    ////////////////////////////////\n    /////// State Variables ////////\n    ////////////////////////////////\n    // contest distribution expiration\n    uint256 public constant EXPIRATION_TIME = 7 days;\n    uint256 public constant MAX_CONTEST_PERIOD = 28 days;\n\n    /// @notice record contest close time by salt\n    /// @dev The contest doesn't exist when value is 0\n    mapping(bytes32 => uint256) public saltToCloseTime;\n    /// @dev record whitelisted tokens\n    mapping(address => bool) public whitelistedTokens;\n\n    ////////////////////////////\n    /////// Constructor ////////\n    ////////////////////////////\n    /**\n     * @notice The constructor will set the whitelist tokens. e.g. USDC, JPYCv1, JPYCv2, USDT, DAI\n     * @notice the array is not supposed to be so long because only major tokens will get listed\n     * @param _whitelistedTokens The tokens array to get whitelisted\n     */\n    constructor(address[] memory _whitelistedTokens) EIP712(\"ProxyFactory\", \"1\") Ownable() {\n        if (_whitelistedTokens.length == 0) revert ProxyFactory__NoEmptyArray();\n        for (uint256 i; i < _whitelistedTokens.length;) {\n            if (_whitelistedTokens[i] == address(0)) revert ProxyFactory__NoZeroAddress();\n            whitelistedTokens[_whitelistedTokens[i]] = true;\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    ////////////////////////////////////////////\n    /////// External & Public functions ////////\n    ////////////////////////////////////////////\n    /**\n     * @notice Only owner can set contest's properties\n     * @notice close time must be less than 28 days from now\n     * @dev Set contest close time, implementation address, organizer, contest id\n     * @dev only owner can call this function\n     * @param organizer The owner of the contest\n     * @param contestId The contest id\n     * @param closeTime The contest close time\n     * @param implementation The implementation address\n     */\n    function setContest(address organizer, bytes32 contestId, uint256 closeTime, address implementation)\n        public\n        onlyOwner\n    {\n        if (organizer == address(0) || implementation == address(0)) revert ProxyFactory__NoZeroAddress();\n        if (closeTime > block.timestamp + MAX_CONTEST_PERIOD || closeTime < block.timestamp) {\n            revert ProxyFactory__CloseTimeNotInRange();\n        }\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] != 0) revert ProxyFactory__ContestIsAlreadyRegistered();\n        saltToCloseTime[salt] = closeTime;\n        emit SetContest(organizer, contestId, closeTime, implementation);\n    }\n\n    /**\n     * @notice deploy proxy contract and distribute winner's prize\n     * @dev the caller can only control his own contest\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param data The prize distribution data\n     * @return The proxy address\n     */\n    function deployProxyAndDistribute(bytes32 contestId, address implementation, bytes calldata data)\n        public\n        returns (address)\n    {\n        bytes32 salt = _calculateSalt(msg.sender, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        // can set close time to current time and end it immediately if organizer wish\n        if (saltToCloseTime[salt] > block.timestamp) revert ProxyFactory__ContestIsNotClosed();\n        address proxy = _deployProxy(msg.sender, contestId, implementation);\n        _distribute(proxy, data);\n        return proxy;\n    }\n\n    /**\n     * @notice deploy proxy contract and distribute prize on behalf of organizer\n     * @dev the caller can only control his own contest\n     * @dev It uess EIP712 to verify the signature to avoid replay attacks\n     * @dev front run is allowed because it will only help the tx sender\n     * @param organizer The organizer of the contest\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param signature The signature from organizer\n     * @param data The prize distribution data\n     * @return proxy The proxy address\n     */\n    function deployProxyAndDistributeBySignature(\n        address organizer,\n        bytes32 contestId,\n        address implementation,\n        bytes calldata signature,\n        bytes calldata data\n    ) public returns (address) {\n        bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(contestId, data)));\n        if (ECDSA.recover(digest, signature) != organizer) revert ProxyFactory__InvalidSignature();\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        if (saltToCloseTime[salt] > block.timestamp) revert ProxyFactory__ContestIsNotClosed();\n        address proxy = _deployProxy(organizer, contestId, implementation);\n        _distribute(proxy, data);\n        return proxy;\n    }\n\n    /**\n     * @notice deploy proxy contract and distribute prize on behalf of organizer by owner\n     * @notice This can only be called after contest is expired\n     * @dev the caller must be owner\n     * @param organizer The organizer of the contest\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param data The prize distribution data\n     * @return proxy The proxy address\n     */\n    function deployProxyAndDistributeByOwner(\n        address organizer,\n        bytes32 contestId,\n        address implementation,\n        bytes calldata data\n    ) public onlyOwner returns (address) {\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        if (saltToCloseTime[salt] + EXPIRATION_TIME > block.timestamp) revert ProxyFactory__ContestIsNotExpired();\n        // require(saltToCloseTime[salt] == 0, \"Contest is not registered\");\n        // require(saltToCloseTime[salt] < block.timestamp + EXPIRATION_TIME, \"Contest is not expired\");\n        address proxy = _deployProxy(organizer, contestId, implementation);\n        _distribute(proxy, data);\n        return proxy;\n    }\n\n    /**\n     * @notice Owner can rescue funds if token is stuck after the deployment and contest is over for a while\n     * @dev only owner can call this function and it is supposed not to be called often\n     * @dev fee sent to stadium address is included in the logic contract\n     * @param proxy The proxy address\n     * @param organizer The contest organizer\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param data The prize distribution calling data\n     */\n    function distributeByOwner(\n        address proxy,\n        address organizer,\n        bytes32 contestId,\n        address implementation,\n        bytes calldata data\n    ) public onlyOwner {\n        if (proxy == address(0)) revert ProxyFactory__ProxyAddressCannotBeZero();\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        // distribute only when it exists and expired\n        if (saltToCloseTime[salt] + EXPIRATION_TIME > block.timestamp) revert ProxyFactory__ContestIsNotExpired();\n        _distribute(proxy, data);\n    }\n\n    /// @notice This address can be used to send ERC20 tokens before deployment of proxy\n    /// @dev Calculate the proxy address using salt and implementation address\n    /// @param salt The salt\n    /// @param implementation The implementation address\n    /// @return proxy The calculated proxy address\n    function getProxyAddress(bytes32 salt, address implementation) public view returns (address proxy) {\n        bytes memory code = abi.encodePacked(type(Proxy).creationCode, uint256(uint160(implementation)));\n        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, keccak256(code)));\n        proxy = address(uint160(uint256(hash)));\n    }\n\n    ///////////////////////////////////\n    /////// Internal functions ////////\n    ///////////////////////////////////\n    /// @dev Deploy proxy and return the proxy address\n    /// @dev This is an internal function\n    /// @param organizer The contest organizer\n    /// @param contestId The contest id\n    /// @param implementation The implementation address\n    function _deployProxy(address organizer, bytes32 contestId, address implementation) internal returns (address) {\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        address proxy = address(new Proxy{salt: salt}(implementation));\n        return proxy;\n    }\n\n    /// @dev The internal function to be used to call proxy to distribute prizes to the winners\n    /// @dev the data passed in should be the calling data of the distributing logic\n    /// @param proxy The proxy address\n    /// @param data The prize distribution data\n    function _distribute(address proxy, bytes calldata data) internal {\n        (bool success,) = proxy.call(data);\n        if (!success) revert ProxyFactory__DelegateCallFailed();\n        emit Distributed(proxy, data);\n    }\n\n    /// @dev Calculate salt using contest organizer address and contestId, implementation address\n    /// @dev This is an internal function\n    /// @param organizer The contest organizer\n    /// @param contestId The contest id\n    /// @param implementation The implementation address\n    function _calculateSalt(address organizer, bytes32 contestId, address implementation)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encode(organizer, contestId, implementation));\n    }\n}"
    },
    {
      "filename": "src/ProxyFactory.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n// Layout of Contract:\n// version\n// imports\n// errors\n// interfaces, libraries, contracts\n// Type declarations\n// State variables\n// Events\n// Modifiers\n// Functions\n\n// Layout of Functions:\n// constructor\n// receive function (if exists)\n// fallback function (if exists)\n// external\n// public\n// internal\n// private\n// view & pure functions\n\npragma solidity 0.8.18;\n\nimport {Ownable} from \"openzeppelin/access/Ownable.sol\";\nimport {ECDSA} from \"openzeppelin/utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"openzeppelin/utils/cryptography/EIP712.sol\";\nimport {Proxy} from \"./Proxy.sol\";\n\n/**\n * @title ProxyFactory contract\n * @notice This contract is the main entry point for users to use SPARKN's contracts.\n * @notice It will be used to deploy proxy contracts for every contest in SPARKN.\n * @dev This contract is the factory contract which will be used to deploy proxy contracts.\n */\ncontract ProxyFactory is Ownable, EIP712 {\n    //////////////////////\n    /////// Error ////////\n    //////////////////////\n    error ProxyFactory__NoEmptyArray();\n    error ProxyFactory__NoZeroAddress();\n    error ProxyFactory__CloseTimeNotInRange();\n    error ProxyFactory__InvalidSignature();\n    error ProxyFactory__ContestIsAlreadyRegistered();\n    error ProxyFactory__ContestIsNotClosed();\n    error ProxyFactory__ContestIsNotRegistered();\n    error ProxyFactory__ContestIsNotExpired();\n    error ProxyFactory__DelegateCallFailed();\n    error ProxyFactory__ProxyAddressCannotBeZero();\n\n    /////////////////////\n    /////// Event ///////\n    /////////////////////\n    event SetContest(\n        address indexed organizer, bytes32 indexed contestId, uint256 closeTime, address indexed implementation\n    );\n    event Distributed(address indexed proxy, bytes data);\n\n    ////////////////////////////////\n    /////// State Variables ////////\n    ////////////////////////////////\n    // contest distribution expiration\n    uint256 public constant EXPIRATION_TIME = 7 days;\n    uint256 public constant MAX_CONTEST_PERIOD = 28 days;\n\n    /// @notice record contest close time by salt\n    /// @dev The contest doesn't exist when value is 0\n    mapping(bytes32 => uint256) public saltToCloseTime;\n    /// @dev record whitelisted tokens\n    mapping(address => bool) public whitelistedTokens;\n\n    ////////////////////////////\n    /////// Constructor ////////\n    ////////////////////////////\n    /**\n     * @notice The constructor will set the whitelist tokens. e.g. USDC, JPYCv1, JPYCv2, USDT, DAI\n     * @notice the array is not supposed to be so long because only major tokens will get listed\n     * @param _whitelistedTokens The tokens array to get whitelisted\n     */\n    constructor(address[] memory _whitelistedTokens) EIP712(\"ProxyFactory\", \"1\") Ownable() {\n        if (_whitelistedTokens.length == 0) revert ProxyFactory__NoEmptyArray();\n        for (uint256 i; i < _whitelistedTokens.length;) {\n            if (_whitelistedTokens[i] == address(0)) revert ProxyFactory__NoZeroAddress();\n            whitelistedTokens[_whitelistedTokens[i]] = true;\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    ////////////////////////////////////////////\n    /////// External & Public functions ////////\n    ////////////////////////////////////////////\n    /**\n     * @notice Only owner can set contest's properties\n     * @notice close time must be less than 28 days from now\n     * @dev Set contest close time, implementation address, organizer, contest id\n     * @dev only owner can call this function\n     * @param organizer The owner of the contest\n     * @param contestId The contest id\n     * @param closeTime The contest close time\n     * @param implementation The implementation address\n     */\n    function setContest(address organizer, bytes32 contestId, uint256 closeTime, address implementation)\n        public\n        onlyOwner\n    {\n        if (organizer == address(0) || implementation == address(0)) revert ProxyFactory__NoZeroAddress();\n        if (closeTime > block.timestamp + MAX_CONTEST_PERIOD || closeTime < block.timestamp) {\n            revert ProxyFactory__CloseTimeNotInRange();\n        }\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] != 0) revert ProxyFactory__ContestIsAlreadyRegistered();\n        saltToCloseTime[salt] = closeTime;\n        emit SetContest(organizer, contestId, closeTime, implementation);\n    }\n\n    /**\n     * @notice deploy proxy contract and distribute winner's prize\n     * @dev the caller can only control his own contest\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param data The prize distribution data\n     * @return The proxy address\n     */\n    function deployProxyAndDistribute(bytes32 contestId, address implementation, bytes calldata data)\n        public\n        returns (address)\n    {\n        bytes32 salt = _calculateSalt(msg.sender, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        // can set close time to current time and end it immediately if organizer wish\n        if (saltToCloseTime[salt] > block.timestamp) revert ProxyFactory__ContestIsNotClosed();\n        address proxy = _deployProxy(msg.sender, contestId, implementation);\n        _distribute(proxy, data);\n        return proxy;\n    }\n\n    /**\n     * @notice deploy proxy contract and distribute prize on behalf of organizer\n     * @dev the caller can only control his own contest\n     * @dev It uess EIP712 to verify the signature to avoid replay attacks\n     * @dev front run is allowed because it will only help the tx sender\n     * @param organizer The organizer of the contest\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param signature The signature from organizer\n     * @param data The prize distribution data\n     * @return proxy The proxy address\n     */\n    function deployProxyAndDistributeBySignature(\n        address organizer,\n        bytes32 contestId,\n        address implementation,\n        bytes calldata signature,\n        bytes calldata data\n    ) public returns (address) {\n        bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(contestId, data)));\n        if (ECDSA.recover(digest, signature) != organizer) revert ProxyFactory__InvalidSignature();\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        if (saltToCloseTime[salt] > block.timestamp) revert ProxyFactory__ContestIsNotClosed();\n        address proxy = _deployProxy(organizer, contestId, implementation);\n        _distribute(proxy, data);\n        return proxy;\n    }\n\n    /**\n     * @notice deploy proxy contract and distribute prize on behalf of organizer by owner\n     * @notice This can only be called after contest is expired\n     * @dev the caller must be owner\n     * @param organizer The organizer of the contest\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param data The prize distribution data\n     * @return proxy The proxy address\n     */\n    function deployProxyAndDistributeByOwner(\n        address organizer,\n        bytes32 contestId,\n        address implementation,\n        bytes calldata data\n    ) public onlyOwner returns (address) {\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        if (saltToCloseTime[salt] + EXPIRATION_TIME > block.timestamp) revert ProxyFactory__ContestIsNotExpired();\n        // require(saltToCloseTime[salt] == 0, \"Contest is not registered\");\n        // require(saltToCloseTime[salt] < block.timestamp + EXPIRATION_TIME, \"Contest is not expired\");\n        address proxy = _deployProxy(organizer, contestId, implementation);\n        _distribute(proxy, data);\n        return proxy;\n    }\n\n    /**\n     * @notice Owner can rescue funds if token is stuck after the deployment and contest is over for a while\n     * @dev only owner can call this function and it is supposed not to be called often\n     * @dev fee sent to stadium address is included in the logic contract\n     * @param proxy The proxy address\n     * @param organizer The contest organizer\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param data The prize distribution calling data\n     */\n    function distributeByOwner(\n        address proxy,\n        address organizer,\n        bytes32 contestId,\n        address implementation,\n        bytes calldata data\n    ) public onlyOwner {\n        if (proxy == address(0)) revert ProxyFactory__ProxyAddressCannotBeZero();\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        // distribute only when it exists and expired\n        if (saltToCloseTime[salt] + EXPIRATION_TIME > block.timestamp) revert ProxyFactory__ContestIsNotExpired();\n        _distribute(proxy, data);\n    }\n\n    /// @notice This address can be used to send ERC20 tokens before deployment of proxy\n    /// @dev Calculate the proxy address using salt and implementation address\n    /// @param salt The salt\n    /// @param implementation The implementation address\n    /// @return proxy The calculated proxy address\n    function getProxyAddress(bytes32 salt, address implementation) public view returns (address proxy) {\n        bytes memory code = abi.encodePacked(type(Proxy).creationCode, uint256(uint160(implementation)));\n        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, keccak256(code)));\n        proxy = address(uint160(uint256(hash)));\n    }\n\n    ///////////////////////////////////\n    /////// Internal functions ////////\n    ///////////////////////////////////\n    /// @dev Deploy proxy and return the proxy address\n    /// @dev This is an internal function\n    /// @param organizer The contest organizer\n    /// @param contestId The contest id\n    /// @param implementation The implementation address\n    function _deployProxy(address organizer, bytes32 contestId, address implementation) internal returns (address) {\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        address proxy = address(new Proxy{salt: salt}(implementation));\n        return proxy;\n    }\n\n    /// @dev The internal function to be used to call proxy to distribute prizes to the winners\n    /// @dev the data passed in should be the calling data of the distributing logic\n    /// @param proxy The proxy address\n    /// @param data The prize distribution data\n    function _distribute(address proxy, bytes calldata data) internal {\n        (bool success,) = proxy.call(data);\n        if (!success) revert ProxyFactory__DelegateCallFailed();\n        emit Distributed(proxy, data);\n    }\n\n    /// @dev Calculate salt using contest organizer address and contestId, implementation address\n    /// @dev This is an internal function\n    /// @param organizer The contest organizer\n    /// @param contestId The contest id\n    /// @param implementation The implementation address\n    function _calculateSalt(address organizer, bytes32 contestId, address implementation)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encode(organizer, contestId, implementation));\n    }\n}"
    },
    {
      "filename": "src/ProxyFactory.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n// Layout of Contract:\n// version\n// imports\n// errors\n// interfaces, libraries, contracts\n// Type declarations\n// State variables\n// Events\n// Modifiers\n// Functions\n\n// Layout of Functions:\n// constructor\n// receive function (if exists)\n// fallback function (if exists)\n// external\n// public\n// internal\n// private\n// view & pure functions\n\npragma solidity 0.8.18;\n\nimport {Ownable} from \"openzeppelin/access/Ownable.sol\";\nimport {ECDSA} from \"openzeppelin/utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"openzeppelin/utils/cryptography/EIP712.sol\";\nimport {Proxy} from \"./Proxy.sol\";\n\n/**\n * @title ProxyFactory contract\n * @notice This contract is the main entry point for users to use SPARKN's contracts.\n * @notice It will be used to deploy proxy contracts for every contest in SPARKN.\n * @dev This contract is the factory contract which will be used to deploy proxy contracts.\n */\ncontract ProxyFactory is Ownable, EIP712 {\n    //////////////////////\n    /////// Error ////////\n    //////////////////////\n    error ProxyFactory__NoEmptyArray();\n    error ProxyFactory__NoZeroAddress();\n    error ProxyFactory__CloseTimeNotInRange();\n    error ProxyFactory__InvalidSignature();\n    error ProxyFactory__ContestIsAlreadyRegistered();\n    error ProxyFactory__ContestIsNotClosed();\n    error ProxyFactory__ContestIsNotRegistered();\n    error ProxyFactory__ContestIsNotExpired();\n    error ProxyFactory__DelegateCallFailed();\n    error ProxyFactory__ProxyAddressCannotBeZero();\n\n    /////////////////////\n    /////// Event ///////\n    /////////////////////\n    event SetContest(\n        address indexed organizer, bytes32 indexed contestId, uint256 closeTime, address indexed implementation\n    );\n    event Distributed(address indexed proxy, bytes data);\n\n    ////////////////////////////////\n    /////// State Variables ////////\n    ////////////////////////////////\n    // contest distribution expiration\n    uint256 public constant EXPIRATION_TIME = 7 days;\n    uint256 public constant MAX_CONTEST_PERIOD = 28 days;\n\n    /// @notice record contest close time by salt\n    /// @dev The contest doesn't exist when value is 0\n    mapping(bytes32 => uint256) public saltToCloseTime;\n    /// @dev record whitelisted tokens\n    mapping(address => bool) public whitelistedTokens;\n\n    ////////////////////////////\n    /////// Constructor ////////\n    ////////////////////////////\n    /**\n     * @notice The constructor will set the whitelist tokens. e.g. USDC, JPYCv1, JPYCv2, USDT, DAI\n     * @notice the array is not supposed to be so long because only major tokens will get listed\n     * @param _whitelistedTokens The tokens array to get whitelisted\n     */\n    constructor(address[] memory _whitelistedTokens) EIP712(\"ProxyFactory\", \"1\") Ownable() {\n        if (_whitelistedTokens.length == 0) revert ProxyFactory__NoEmptyArray();\n        for (uint256 i; i < _whitelistedTokens.length;) {\n            if (_whitelistedTokens[i] == address(0)) revert ProxyFactory__NoZeroAddress();\n            whitelistedTokens[_whitelistedTokens[i]] = true;\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    ////////////////////////////////////////////\n    /////// External & Public functions ////////\n    ////////////////////////////////////////////\n    /**\n     * @notice Only owner can set contest's properties\n     * @notice close time must be less than 28 days from now\n     * @dev Set contest close time, implementation address, organizer, contest id\n     * @dev only owner can call this function\n     * @param organizer The owner of the contest\n     * @param contestId The contest id\n     * @param closeTime The contest close time\n     * @param implementation The implementation address\n     */\n    function setContest(address organizer, bytes32 contestId, uint256 closeTime, address implementation)\n        public\n        onlyOwner\n    {\n        if (organizer == address(0) || implementation == address(0)) revert ProxyFactory__NoZeroAddress();\n        if (closeTime > block.timestamp + MAX_CONTEST_PERIOD || closeTime < block.timestamp) {\n            revert ProxyFactory__CloseTimeNotInRange();\n        }\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] != 0) revert ProxyFactory__ContestIsAlreadyRegistered();\n        saltToCloseTime[salt] = closeTime;\n        emit SetContest(organizer, contestId, closeTime, implementation);\n    }\n\n    /**\n     * @notice deploy proxy contract and distribute winner's prize\n     * @dev the caller can only control his own contest\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param data The prize distribution data\n     * @return The proxy address\n     */\n    function deployProxyAndDistribute(bytes32 contestId, address implementation, bytes calldata data)\n        public\n        returns (address)\n    {\n        bytes32 salt = _calculateSalt(msg.sender, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        // can set close time to current time and end it immediately if organizer wish\n        if (saltToCloseTime[salt] > block.timestamp) revert ProxyFactory__ContestIsNotClosed();\n        address proxy = _deployProxy(msg.sender, contestId, implementation);\n        _distribute(proxy, data);\n        return proxy;\n    }\n\n    /**\n     * @notice deploy proxy contract and distribute prize on behalf of organizer\n     * @dev the caller can only control his own contest\n     * @dev It uess EIP712 to verify the signature to avoid replay attacks\n     * @dev front run is allowed because it will only help the tx sender\n     * @param organizer The organizer of the contest\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param signature The signature from organizer\n     * @param data The prize distribution data\n     * @return proxy The proxy address\n     */\n    function deployProxyAndDistributeBySignature(\n        address organizer,\n        bytes32 contestId,\n        address implementation,\n        bytes calldata signature,\n        bytes calldata data\n    ) public returns (address) {\n        bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(contestId, data)));\n        if (ECDSA.recover(digest, signature) != organizer) revert ProxyFactory__InvalidSignature();\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        if (saltToCloseTime[salt] > block.timestamp) revert ProxyFactory__ContestIsNotClosed();\n        address proxy = _deployProxy(organizer, contestId, implementation);\n        _distribute(proxy, data);\n        return proxy;\n    }\n\n    /**\n     * @notice deploy proxy contract and distribute prize on behalf of organizer by owner\n     * @notice This can only be called after contest is expired\n     * @dev the caller must be owner\n     * @param organizer The organizer of the contest\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param data The prize distribution data\n     * @return proxy The proxy address\n     */\n    function deployProxyAndDistributeByOwner(\n        address organizer,\n        bytes32 contestId,\n        address implementation,\n        bytes calldata data\n    ) public onlyOwner returns (address) {\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        if (saltToCloseTime[salt] + EXPIRATION_TIME > block.timestamp) revert ProxyFactory__ContestIsNotExpired();\n        // require(saltToCloseTime[salt] == 0, \"Contest is not registered\");\n        // require(saltToCloseTime[salt] < block.timestamp + EXPIRATION_TIME, \"Contest is not expired\");\n        address proxy = _deployProxy(organizer, contestId, implementation);\n        _distribute(proxy, data);\n        return proxy;\n    }\n\n    /**\n     * @notice Owner can rescue funds if token is stuck after the deployment and contest is over for a while\n     * @dev only owner can call this function and it is supposed not to be called often\n     * @dev fee sent to stadium address is included in the logic contract\n     * @param proxy The proxy address\n     * @param organizer The contest organizer\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param data The prize distribution calling data\n     */\n    function distributeByOwner(\n        address proxy,\n        address organizer,\n        bytes32 contestId,\n        address implementation,\n        bytes calldata data\n    ) public onlyOwner {\n        if (proxy == address(0)) revert ProxyFactory__ProxyAddressCannotBeZero();\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        // distribute only when it exists and expired\n        if (saltToCloseTime[salt] + EXPIRATION_TIME > block.timestamp) revert ProxyFactory__ContestIsNotExpired();\n        _distribute(proxy, data);\n    }\n\n    /// @notice This address can be used to send ERC20 tokens before deployment of proxy\n    /// @dev Calculate the proxy address using salt and implementation address\n    /// @param salt The salt\n    /// @param implementation The implementation address\n    /// @return proxy The calculated proxy a"
    }
  ]
}