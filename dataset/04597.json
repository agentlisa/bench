{
  "Title": "Unbounded loops",
  "Content": "Functions [`addTokenGrant`](https://github.com/kikinteractive/kin-token/blob/3ed3a383b9304274ec22f41769716cadb854727f/contracts/KinTokenSale.sol#L148) and [`deleteTokenGrant`](https://github.com/kikinteractive/kin-token/blob/3ed3a383b9304274ec22f41769716cadb854727f/contracts/KinTokenSale.sol#L165) in `KinTokenSale` both iterate over the entire `tokenGrantees` storage array. If a large number of `tokenGrantees` is added, then a call to either function may end up requiring more gas than the block gas limit, making it impossible to add or remove any grantees. (See [Gas Limit and Loops](http://solidity.readthedocs.io/en/latest/security-considerations.html#gas-limit-and-loops) in the Solidity documentation.)\n\n\nConsider adding a `MAX_TOKEN_GRANTEES` constant, set to a value which ensures that both `addTokenGrant` and `deleteTokenGrant` can execute without consuming the entire block gas limit. Enforce in all calls to `addTokenGrant` that the total number of `tokenGrantees` is less than `MAX_TOKEN_GRANTEES`.\n\n\nAdditionally, the loop in [`addTokenGrant`](https://github.com/kikinteractive/kin-token/blob/3ed3a383b9304274ec22f41769716cadb854727f/contracts/KinTokenSale.sol#L148) is not needed, since there will never be a grantee address for which [the previous check](https://github.com/kikinteractive/kin-token/blob/3ed3a383b9304274ec22f41769716cadb854727f/contracts/KinTokenSale.sol#L153) succeeds.\n\n\n***Update:** Fixed in [this commit](https://github.com/kikinteractive/kin-token/pull/4/commits/77ac3eb20b2905be0df7d4626c95ecbf25d5534c)*.\\_\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/KinTokenSale.sol",
      "content": "pragma solidity ^0.4.15;\n\nimport './SafeMath.sol';\nimport './Ownable.sol';\nimport './TokenHolder.sol';\nimport './KinToken.sol';\nimport './VestingTrustee.sol';\n\n/// @title Kin token sale contract.\ncontract KinTokenSale is Ownable, TokenHolder {\n    using SafeMath for uint256;\n\n    // External parties:\n\n    // KIN token contract.\n    KinToken public kin;\n\n    // Vesting contract for pre-sale participants.\n    VestingTrustee public trustee;\n\n    // Received funds are forwarded to this address.\n    address public fundingRecipient;\n\n    // Kin token decimals.\n    // Using same decimal value as ETH (makes ETH-KIN conversion much easier).\n    // This is the same as in Kin token contract.\n    uint256 public constant TOKEN_DECIMALS = 10 ** 18;\n\n    // Maximum number of tokens in circulation: 10 trillion.\n    uint256 public constant MAX_TOKENS = 10 ** 13 * TOKEN_DECIMALS;\n\n    // Maximum tokens offered in the sale.\n    uint256 public constant MAX_TOKENS_SOLD = 512192121951 * TOKEN_DECIMALS;\n\n    // Wei to 1 USD ratio.\n    //\n    // TODO update to the real ETH price before sale launch.\n    uint256 public constant WEI_PER_USD = uint256(1 ether) / 360;\n\n    // KIN to 1 USD ratio,\n    // such MAX_TOKENS_SOLD * KIN_PER_USD is the $75M cap.\n    uint256 public constant KIN_PER_USD = 6829 * TOKEN_DECIMALS;\n\n    // KIN to 1 wei ratio.\n    uint256 public constant KIN_PER_WEI = KIN_PER_USD / WEI_PER_USD;\n\n    // Sale start, end blocks (time ranges)\n    uint256 public constant SALE_DURATION = 14 days;\n    uint256 public startTime;\n    uint256 public endTime;\n\n    // Amount of tokens sold until now in the sale.\n    uint256 public tokensSold = 0;\n\n    // Participation caps, according to KYC tiers.\n    uint256 public constant TIER_1_CAP = 100000 * WEI_PER_USD;\n    uint256 public constant TIER_2_CAP = uint256(-1); // Maximum uint256 value\n\n    // Accumulated amount each participant have contributed so far.\n    mapping (address => uint256) public participationHistory;\n\n    // Maximum amount that each particular is allowed to contribute (in WEI).\n    mapping (address => uint256) public participationCaps;\n\n    // Maximum amount ANYBODY is currently allowed to contribute.\n    uint256 public hardParticipationCap = 5000 * WEI_PER_USD;\n\n    // Vesting information for special addresses:\n    struct TokenGrant {\n        uint256 value;\n        uint256 startOffset;\n        uint256 cliffOffset;\n        uint256 endOffset;\n        uint256 installmentLength;\n        uint8 percentVested;\n    }\n\n    address[] public tokenGrantees;\n    mapping (address => TokenGrant) public tokenGrants;\n    uint256 public lastGrantedIndex = 0;\n    uint256 public constant GRANT_BATCH_SIZE = 10;\n\n    // Post-TDE multisig addresses.\n    //\n    // TODO: add real addresses here.\n    address public constant KIN_FOUNDATION_ADDRESS = 0xa8F769B88d6D74FB2Bd3912F6793F75625228baF;\n    address public constant KIK_ADDRESS = 0x7a029DC995f87B5cA060975b9A8A1b4bdB33cDC5;\n\n    event TokensIssued(address indexed _to, uint256 _tokens);\n\n    /// @dev Reverts if called when not during sale.\n    modifier onlyDuringSale() {\n        if (tokensSold >= MAX_TOKENS_SOLD || now < startTime || now >= endTime) {\n            revert();\n        }\n\n        _;\n    }\n\n    /// @dev Reverts if called before sale ends.\n    modifier onlyAfterSale() {\n        if (!(tokensSold >= MAX_TOKENS_SOLD || now >= endTime)) {\n            revert();\n        }\n\n        _;\n    }\n\n    /// @dev Constructor that initializes the sale conditions.\n    /// @param _fundingRecipient address The address of the funding recipient.\n    /// @param _startTime uint256 The start time of the token sale.\n    function KinTokenSale(address _fundingRecipient, uint256 _startTime) {\n        require(_fundingRecipient != address(0));\n        require(_startTime > now);\n\n        // Deploy new KinToken contract.\n        kin = new KinToken();\n\n        // Deploy new VestingTrustee contract.\n        trustee = new VestingTrustee(kin);\n\n        fundingRecipient = _fundingRecipient;\n        startTime = _startTime;\n        endTime = startTime + SALE_DURATION;\n\n        // Initialize special vesting grants.\n        initTokenGrants();\n    }\n\n    /// @dev Initialize token grants.\n    ///\n    /// TODO: add real values here.\n    function initTokenGrants() private onlyOwner {\n        // Issue the remaining 60% to Kin Foundation's multisig wallet. In a few days, after the token sale is\n        // finalized, these tokens will be loaded into the KinVestingTrustee smart contract, according to the white\n        // paper. Please note, that this is implied by setting a 0% vesting percent.\n        tokenGrantees.push(KIN_FOUNDATION_ADDRESS);\n        tokenGrants[KIN_FOUNDATION_ADDRESS] = TokenGrant(60 * 100000000000 * TOKEN_DECIMALS, 0, 0, 3 years, 1 days, 0);\n\n        // Kik, 30%\n        tokenGrantees.push(KIK_ADDRESS);\n        tokenGrants[KIK_ADDRESS] = TokenGrant(30 * 100000000000 * TOKEN_DECIMALS, 0, 0, 120 weeks, 12 weeks, 100);\n    }\n\n    /// @dev Adds a Kin token vesting grant.\n    /// @param _grantee address The address of the token grantee. Can be granted only once.\n    /// @param _value uint256 The value of the grant.\n    function addTokenGrant(address _grantee, uint256 _value) external onlyOwner {\n        require(_grantee != address(0));\n        require(_value > 0);\n\n        // Verify the grant doesn't already exist.\n        require(tokenGrants[_grantee].value == 0);\n        for (uint i = 0; i < tokenGrantees.length; i++) {\n            require(tokenGrantees[i] != _grantee);\n        }\n\n        // Add grant and add to grantee list.\n        tokenGrantees.push(_grantee);\n        tokenGrants[_grantee] = TokenGrant(_value, 0, 1 years, 1 years, 1 days, 50);\n    }\n\n    /// @dev Deletes a Kin token grant.\n    /// @param _grantee address The address of the token grantee.\n    function deleteTokenGrant(address _grantee) external onlyOwner {\n        require(_grantee != address(0));\n\n        // Delete the grant from the keys array.\n        for (uint i = 0; i < tokenGrantees.length; i++) {\n            if (tokenGrantees[i] == _grantee) {\n                delete tokenGrantees[i];\n\n                break;\n            }\n        }\n\n        // Delete the grant from the mapping.\n        delete tokenGrants[_grantee];\n    }\n\n    /// @dev Add a list of participants to a capped participation tier.\n    /// @param _participants address[] The list of participant addresses.\n    /// @param _cap uint256 The cap amount (in ETH).\n    function setParticipationCap(address[] _participants, uint256 _cap) private onlyOwner {\n        for (uint i = 0; i < _participants.length; i++) {\n            participationCaps[_participants[i]] = _cap;\n        }\n    }\n\n    /// @dev Add a list of participants to cap tier #1.\n    /// @param _participants address[] The list of participant addresses.\n    function setTier1Participants(address[] _participants) external onlyOwner {\n        setParticipationCap(_participants, TIER_1_CAP);\n    }\n\n    /// @dev Add a list of participants to tier #2.\n    /// @param _participants address[] The list of participant addresses.\n    function setTier2Participants(address[] _participants) external onlyOwner {\n        setParticipationCap(_participants, TIER_2_CAP);\n    }\n\n    /// @dev Set hard participation cap for all participants.\n    /// @param _cap uint256 The hard cap amount.\n    function setHardParticipationCap(uint256 _cap) external onlyOwner {\n        require(_cap > 0);\n\n        hardParticipationCap = _cap;\n    }\n\n    /// @dev Fallback function that will delegate the request to create().\n    function () external payable onlyDuringSale {\n        create(msg.sender);\n    }\n\n    /// @dev Create and sell tokens to the caller.\n    /// @param _recipient address The address of the recipient receiving the tokens.\n    function create(address _recipient) public payable onlyDuringSale {\n        require(_recipient != address(0));\n\n        // Enforce participation cap (in Wei received).\n        uint256 weiAlreadyParticipated = participationHistory[msg.sender];\n        uint256 participationCap = SafeMath.min256(participationCaps[msg.sender], hardParticipationCap);\n        uint256 cappedWeiReceived = SafeMath.min256(msg.value, participationCap.sub(weiAlreadyParticipated));\n        require(cappedWeiReceived > 0);\n\n        // Accept funds and transfer to funding recipient.\n        uint256 weiLeftInSale = MAX_TOKENS_SOLD.sub(tokensSold).div(KIN_PER_WEI);\n        uint256 weiToParticipate = SafeMath.min256(cappedWeiReceived, weiLeftInSale);\n        participationHistory[msg.sender] = weiAlreadyParticipated.add(weiToParticipate);\n        fundingRecipient.transfer(weiToParticipate);\n\n        // Issue tokens and transfer to recipient.\n        uint256 tokensLeftInSale = MAX_TOKENS_SOLD.sub(tokensSold);\n        uint256 tokensToIssue = weiToParticipate.mul(KIN_PER_WEI);\n        if (tokensLeftInSale.sub(tokensToIssue) < KIN_PER_WEI) {\n            // If purchase would cause less than KIN_PER_WEI tokens left then nobody could ever buy them.\n            // So, gift them to the last buyer.\n            tokensToIssue = tokensLeftInSale;\n        }\n        tokensSold = tokensSold.add(tokensToIssue);\n        issueTokens(_recipient, tokensToIssue);\n\n        // Partial refund if full participation not possible\n        // e.g. due to cap being reached.\n        uint256 refund = msg.value.sub(weiToParticipate);\n        if (refund > 0) {\n            msg.sender.transfer(refund);\n        }\n    }\n\n    /// @dev Finalizes the token sale event, by stopping token minting.\n    function finalize() external onlyAfterSale onlyOwner {\n        if (!kin.isMinting()) {\n            revert();\n        }\n\n        require(lastGrantedIndex == tokenGrantees.length);\n\n        // Finish minting.\n        kin.endMinting();\n    }\n\n    /// @dev Grants pre-configured token grants in batches. When the method is called, it'll resume from the last grant,\n    /// from its previous run, and will finish either after granting GRANT_BATCH_SIZE grants or finishing the whole list\n    /// of grants.\n    function grantTokens() external onlyAfterSale onlyOwner {\n        uint endIndex = SafeMath.min256(tokenGrantees.length, lastGrantedIndex + GRANT_BATCH_SIZE);\n        for (uint i = lastGrantedIndex; i < endIndex; i++) {\n            address grantee = tokenGrantees[i];\n\n            // Calculate how many tokens have been granted, vested, and issued such that: granted = vested + issued.\n            TokenGrant memory tokenGrant = tokenGrants[grantee];\n            uint256 tokensGranted = tokenGrant.value.mul(tokensSold).div(MAX_TOKENS_SOLD);\n            uint256 tokensVested = tokensGranted.mul(tokenGrant.percentVested).div(100);\n            uint256 tokensIssued = tokensGranted.sub(tokensVested);\n\n            // Transfer issued tokens that have yet to be transferred to grantee.\n            if (tokensIssued > 0) {\n                issueTokens(grantee, tokensIssued);\n            }\n\n            // Transfer vested tokens that have yet to be transferred to vesting trustee, and initialize grant.\n            if (tokensVested > 0) {\n                issueTokens(trustee, tokensVested);\n                trustee.grant(grantee, tokensVested, now.add(tokenGrant.startOffset), now.add(tokenGrant.cliffOffset),\n                    now.add(tokenGrant.endOffset), tokenGrant.installmentLength, true);\n            }\n\n            lastGrantedIndex++;\n        }\n    }\n\n    /// @dev Issues tokens for the recipient.\n    /// @param _recipient address The address of the recipient.\n    /// @param _tokens uint256 The amount of tokens to issue.\n    function issueTokens(address _recipient, uint256 _tokens) private {\n        // Request Kin token contract to mint the requested tokens for the buyer.\n        kin.mint(_recipient, _tokens);\n\n        TokensIssued(_recipient, _tokens);\n    }\n\n    /// @dev Requests to transfer control of the Kin token contract to a new owner.\n    /// @param _newOwnerCandidate address The address to transfer ownership to.\n    ///\n    /// NOTE:\n    ///   1. The new owner will need to call Kin token contract's acceptOwnership directly in order to accept the ownership.\n    ///   2. Calling this method during the token sale will prevent the token sale to continue, since only the owner of\n    ///      the Kin token contract can issue new tokens.\n    function requestKinTokenOwnershipTransfer(address _newOwnerCandidate) external onlyOwner {\n        kin.requestOwnershipTransfer(_newOwnerCandidate);\n    }\n\n    /// @dev Accepts new ownership on behalf of the Kin token contract.\n    // This can be used by the sale contract itself to claim back ownership of the Kin token contract.\n    function acceptKinTokenOwnership() external onlyOwner {\n        kin.acceptOwnership();\n    }\n\n    /// @dev Requests to transfer control of the VestingTrustee contract to a new owner.\n    /// @param _newOwnerCandidate address The address to transfer ownership to.\n    ///\n    /// NOTE:\n    ///   1. The new owner will need to call VestingTrustee's acceptOwnership directly in order to accept the ownership.\n    ///   2. Calling this method during the token sale will prevent the token sale from finalizaing, since only the owner\n    ///      of the VestingTrustee contract can issue new token grants.\n    function requestVestingTrusteeOwnershipTransfer(address _newOwnerCandidate) external onlyOwner {\n        trustee.requestOwnershipTransfer(_newOwnerCandidate);\n    }\n\n    /// @dev Accepts new ownership on behalf of the VestingTrustee contract.\n    /// This can be used by the token sale contract itself to claim back ownership of the VestingTrustee contract.\n    function acceptVestingTrusteeOwnership() external onlyOwner {\n        trustee.acceptOwnership();\n    }\n}"
    },
    {
      "filename": "contracts/KinTokenSale.sol",
      "content": "pragma solidity ^0.4.15;\n\nimport './SafeMath.sol';\nimport './Ownable.sol';\nimport './TokenHolder.sol';\nimport './KinToken.sol';\nimport './VestingTrustee.sol';\n\n/// @title Kin token sale contract.\ncontract KinTokenSale is Ownable, TokenHolder {\n    using SafeMath for uint256;\n\n    // External parties:\n\n    // KIN token contract.\n    KinToken public kin;\n\n    // Vesting contract for pre-sale participants.\n    VestingTrustee public trustee;\n\n    // Received funds are forwarded to this address.\n    address public fundingRecipient;\n\n    // Kin token decimals.\n    // Using same decimal value as ETH (makes ETH-KIN conversion much easier).\n    // This is the same as in Kin token contract.\n    uint256 public constant TOKEN_DECIMALS = 10 ** 18;\n\n    // Maximum number of tokens in circulation: 10 trillion.\n    uint256 public constant MAX_TOKENS = 10 ** 13 * TOKEN_DECIMALS;\n\n    // Maximum tokens offered in the sale.\n    uint256 public constant MAX_TOKENS_SOLD = 512192121951 * TOKEN_DECIMALS;\n\n    // Wei to 1 USD ratio.\n    //\n    // TODO update to the real ETH price before sale launch.\n    uint256 public constant WEI_PER_USD = uint256(1 ether) / 360;\n\n    // KIN to 1 USD ratio,\n    // such MAX_TOKENS_SOLD * KIN_PER_USD is the $75M cap.\n    uint256 public constant KIN_PER_USD = 6829 * TOKEN_DECIMALS;\n\n    // KIN to 1 wei ratio.\n    uint256 public constant KIN_PER_WEI = KIN_PER_USD / WEI_PER_USD;\n\n    // Sale start, end blocks (time ranges)\n    uint256 public constant SALE_DURATION = 14 days;\n    uint256 public startTime;\n    uint256 public endTime;\n\n    // Amount of tokens sold until now in the sale.\n    uint256 public tokensSold = 0;\n\n    // Participation caps, according to KYC tiers.\n    uint256 public constant TIER_1_CAP = 100000 * WEI_PER_USD;\n    uint256 public constant TIER_2_CAP = uint256(-1); // Maximum uint256 value\n\n    // Accumulated amount each participant have contributed so far.\n    mapping (address => uint256) public participationHistory;\n\n    // Maximum amount that each particular is allowed to contribute (in WEI).\n    mapping (address => uint256) public participationCaps;\n\n    // Maximum amount ANYBODY is currently allowed to contribute.\n    uint256 public hardParticipationCap = 5000 * WEI_PER_USD;\n\n    // Vesting information for special addresses:\n    struct TokenGrant {\n        uint256 value;\n        uint256 startOffset;\n        uint256 cliffOffset;\n        uint256 endOffset;\n        uint256 installmentLength;\n        uint8 percentVested;\n    }\n\n    address[] public tokenGrantees;\n    mapping (address => TokenGrant) public tokenGrants;\n    uint256 public lastGrantedIndex = 0;\n    uint256 public constant GRANT_BATCH_SIZE = 10;\n\n    // Post-TDE multisig addresses.\n    //\n    // TODO: add real addresses here.\n    address public constant KIN_FOUNDATION_ADDRESS = 0xa8F769B88d6D74FB2Bd3912F6793F75625228baF;\n    address public constant KIK_ADDRESS = 0x7a029DC995f87B5cA060975b9A8A1b4bdB33cDC5;\n\n    event TokensIssued(address indexed _to, uint256 _tokens);\n\n    /// @dev Reverts if called when not during sale.\n    modifier onlyDuringSale() {\n        if (tokensSold >= MAX_TOKENS_SOLD || now < startTime || now >= endTime) {\n            revert();\n        }\n\n        _;\n    }\n\n    /// @dev Reverts if called before sale ends.\n    modifier onlyAfterSale() {\n        if (!(tokensSold >= MAX_TOKENS_SOLD || now >= endTime)) {\n            revert();\n        }\n\n        _;\n    }\n\n    /// @dev Constructor that initializes the sale conditions.\n    /// @param _fundingRecipient address The address of the funding recipient.\n    /// @param _startTime uint256 The start time of the token sale.\n    function KinTokenSale(address _fundingRecipient, uint256 _startTime) {\n        require(_fundingRecipient != address(0));\n        require(_startTime > now);\n\n        // Deploy new KinToken contract.\n        kin = new KinToken();\n\n        // Deploy new VestingTrustee contract.\n        trustee = new VestingTrustee(kin);\n\n        fundingRecipient = _fundingRecipient;\n        startTime = _startTime;\n        endTime = startTime + SALE_DURATION;\n\n        // Initialize special vesting grants.\n        initTokenGrants();\n    }\n\n    /// @dev Initialize token grants.\n    ///\n    /// TODO: add real values here.\n    function initTokenGrants() private onlyOwner {\n        // Issue the remaining 60% to Kin Foundation's multisig wallet. In a few days, after the token sale is\n        // finalized, these tokens will be loaded into the KinVestingTrustee smart contract, according to the white\n        // paper. Please note, that this is implied by setting a 0% vesting percent.\n        tokenGrantees.push(KIN_FOUNDATION_ADDRESS);\n        tokenGrants[KIN_FOUNDATION_ADDRESS] = TokenGrant(60 * 100000000000 * TOKEN_DECIMALS, 0, 0, 3 years, 1 days, 0);\n\n        // Kik, 30%\n        tokenGrantees.push(KIK_ADDRESS);\n        tokenGrants[KIK_ADDRESS] = TokenGrant(30 * 100000000000 * TOKEN_DECIMALS, 0, 0, 120 weeks, 12 weeks, 100);\n    }\n\n    /// @dev Adds a Kin token vesting grant.\n    /// @param _grantee address The address of the token grantee. Can be granted only once.\n    /// @param _value uint256 The value of the grant.\n    function addTokenGrant(address _grantee, uint256 _value) external onlyOwner {\n        require(_grantee != address(0));\n        require(_value > 0);\n\n        // Verify the grant doesn't already exist.\n        require(tokenGrants[_grantee].value == 0);\n        for (uint i = 0; i < tokenGrantees.length; i++) {\n            require(tokenGrantees[i] != _grantee);\n        }\n\n        // Add grant and add to grantee list.\n        tokenGrantees.push(_grantee);\n        tokenGrants[_grantee] = TokenGrant(_value, 0, 1 years, 1 years, 1 days, 50);\n    }\n\n    /// @dev Deletes a Kin token grant.\n    /// @param _grantee address The address of the token grantee.\n    function deleteTokenGrant(address _grantee) external onlyOwner {\n        require(_grantee != address(0));\n\n        // Delete the grant from the keys array.\n        for (uint i = 0; i < tokenGrantees.length; i++) {\n            if (tokenGrantees[i] == _grantee) {\n                delete tokenGrantees[i];\n\n                break;\n            }\n        }\n\n        // Delete the grant from the mapping.\n        delete tokenGrants[_grantee];\n    }\n\n    /// @dev Add a list of participants to a capped participation tier.\n    /// @param _participants address[] The list of participant addresses.\n    /// @param _cap uint256 The cap amount (in ETH).\n    function setParticipationCap(address[] _participants, uint256 _cap) private onlyOwner {\n        for (uint i = 0; i < _participants.length; i++) {\n            participationCaps[_participants[i]] = _cap;\n        }\n    }\n\n    /// @dev Add a list of participants to cap tier #1.\n    /// @param _participants address[] The list of participant addresses.\n    function setTier1Participants(address[] _participants) external onlyOwner {\n        setParticipationCap(_participants, TIER_1_CAP);\n    }\n\n    /// @dev Add a list of participants to tier #2.\n    /// @param _participants address[] The list of participant addresses.\n    function setTier2Participants(address[] _participants) external onlyOwner {\n        setParticipationCap(_participants, TIER_2_CAP);\n    }\n\n    /// @dev Set hard participation cap for all participants.\n    /// @param _cap uint256 The hard cap amount.\n    function setHardParticipationCap(uint256 _cap) external onlyOwner {\n        require(_cap > 0);\n\n        hardParticipationCap = _cap;\n    }\n\n    /// @dev Fallback function that will delegate the request to create().\n    function () external payable onlyDuringSale {\n        create(msg.sender);\n    }\n\n    /// @dev Create and sell tokens to the caller.\n    /// @param _recipient address The address of the recipient receiving the tokens.\n    function create(address _recipient) public payable onlyDuringSale {\n        require(_recipient != address(0));\n\n        // Enforce participation cap (in Wei received).\n        uint256 weiAlreadyParticipated = participationHistory[msg.sender];\n        uint256 participationCap = SafeMath.min256(participationCaps[msg.sender], hardParticipationCap);\n        uint256 cappedWeiReceived = SafeMath.min256(msg.value, participationCap.sub(weiAlreadyParticipated));\n        require(cappedWeiReceived > 0);\n\n        // Accept funds and transfer to funding recipient.\n        uint256 weiLeftInSale = MAX_TOKENS_SOLD.sub(tokensSold).div(KIN_PER_WEI);\n        uint256 weiToParticipate = SafeMath.min256(cappedWeiReceived, weiLeftInSale);\n        participationHistory[msg.sender] = weiAlreadyParticipated.add(weiToParticipate);\n        fundingRecipient.transfer(weiToParticipate);\n\n        // Issue tokens and transfer to recipient.\n        uint256 tokensLeftInSale = MAX_TOKENS_SOLD.sub(tokensSold);\n        uint256 tokensToIssue = weiToParticipate.mul(KIN_PER_WEI);\n        if (tokensLeftInSale.sub(tokensToIssue) < KIN_PER_WEI) {\n            // If purchase would cause less than KIN_PER_WEI tokens left then nobody could ever buy them.\n            // So, gift them to the last buyer.\n            tokensToIssue = tokensLeftInSale;\n        }\n        tokensSold = tokensSold.add(tokensToIssue);\n        issueTokens(_recipient, tokensToIssue);\n\n        // Partial refund if full participation not possible\n        // e.g. due to cap being reached.\n        uint256 refund = msg.value.sub(weiToParticipate);\n        if (refund > 0) {\n            msg.sender.transfer(refund);\n        }\n    }\n\n    /// @dev Finalizes the token sale event, by stopping token minting.\n    function finalize() external onlyAfterSale onlyOwner {\n        if (!kin.isMinting()) {\n            revert();\n        }\n\n        require(lastGrantedIndex == tokenGrantees.length);\n\n        // Finish minting.\n        kin.endMinting();\n    }\n\n    /// @dev Grants pre-configured token grants in batches. When the method is called, it'll resume from the last grant,\n    /// from its previous run, and will finish either after granting GRANT_BATCH_SIZE grants or finishing the whole list\n    /// of grants.\n    function grantTokens() external onlyAfterSale onlyOwner {\n        uint endIndex = SafeMath.min256(tokenGrantees.length, lastGrantedIndex + GRANT_BATCH_SIZE);\n        for (uint i = lastGrantedIndex; i < endIndex; i++) {\n            address grantee = tokenGrantees[i];\n\n            // Calculate how many tokens have been granted, vested, and issued such that: granted = vested + issued.\n            TokenGrant memory tokenGrant = tokenGrants[grantee];\n            uint256 tokensGranted = tokenGrant.value.mul(tokensSold).div(MAX_TOKENS_SOLD);\n            uint256 tokensVested = tokensGranted.mul(tokenGrant.percentVested).div(100);\n            uint256 tokensIssued = tokensGranted.sub(tokensVested);\n\n            // Transfer issued tokens that have yet to be transferred to grantee.\n            if (tokensIssued > 0) {\n                issueTokens(grantee, tokensIssued);\n            }\n\n            // Transfer vested tokens that have yet to be transferred to vesting trustee, and initialize grant.\n            if (tokensVested > 0) {\n                issueTokens(trustee, tokensVested);\n                trustee.grant(grantee, tokensVested, now.add(tokenGrant.startOffset), now.add(tokenGrant.cliffOffset),\n                    now.add(tokenGrant.endOffset), tokenGrant.installmentLength, true);\n            }\n\n            lastGrantedIndex++;\n        }\n    }\n\n    /// @dev Issues tokens for the recipient.\n    /// @param _recipient address The address of the recipient.\n    /// @param _tokens uint256 The amount of tokens to issue.\n    function issueTokens(address _recipient, uint256 _tokens) private {\n        // Request Kin token contract to mint the requested tokens for the buyer.\n        kin.mint(_recipient, _tokens);\n\n        TokensIssued(_recipient, _tokens);\n    }\n\n    /// @dev Requests to transfer control of the Kin token contract to a new owner.\n    /// @param _newOwnerCandidate address The address to transfer ownership to.\n    ///\n    /// NOTE:\n    ///   1. The new owner will need to call Kin token contract's acceptOwnership directly in order to accept the ownership.\n    ///   2. Calling this method during the token sale will prevent the token sale to continue, since only the owner of\n    ///      the Kin token contract can issue new tokens.\n    function requestKinTokenOwnershipTransfer(address _newOwnerCandidate) external onlyOwner {\n        kin.requestOwnershipTransfer(_newOwnerCandidate);\n    }\n\n    /// @dev Accepts new ownership on behalf of the Kin token contract.\n    // This can be used by the sale contract itself to claim back ownership of the Kin token contract.\n    function acceptKinTokenOwnership() external onlyOwner {\n        kin.acceptOwnership();\n    }\n\n    /// @dev Requests to transfer control of the VestingTrustee contract to a new owner.\n    /// @param _newOwnerCandidate address The address to transfer ownership to.\n    ///\n    /// NOTE:\n    ///   1. The new owner will need to call VestingTrustee's acceptOwnership directly in order to accept the ownership.\n    ///   2. Calling this method during the token sale will prevent the token sale from finalizaing, since only the owner\n    ///      of the VestingTrustee contract can issue new token grants.\n    function requestVestingTrusteeOwnershipTransfer(address _newOwnerCandidate) external onlyOwner {\n        trustee.requestOwnershipTransfer(_newOwnerCandidate);\n    }\n\n    /// @dev Accepts new ownership on behalf of the VestingTrustee contract.\n    /// This can be used by the token sale contract itself to claim back ownership of the VestingTrustee contract.\n    function acceptVestingTrusteeOwnership() external onlyOwner {\n        trustee.acceptOwnership();\n    }\n}"
    }
  ]
}