{
  "Title": "M-1: `rebalanceLite` should provide a slippage protection",
  "Content": "# Issue M-1: `rebalanceLite` should provide a slippage protection \n\nSource: https://github.com/sherlock-audit/2023-01-uxd-judging/issues/429 \n\n## Found by \nHollaDieWaldfee, hansfriese\n\n## Summary\nUsers can lose funds while rebalancing.\n\n## Vulnerability Detail\nThe protocol provides two kinds of rebalancing functions - `rebalance()` and `rebalanceLite()`.\nWhile the function `rebalance()` is protected from an unintended slippage because the caller can specify `amountOutMinimum`, `rebalanceLite()` does not have this protection.\nThis makes the user vulnerable to unintended slippage due to various scenarios.\n```solidity\nPerpDepository.sol\n597:     function rebalanceLite(\n598:         uint256 amount,\n599:         int8 polarity,\n600:         uint160 sqrtPriceLimitX96,\n601:         address account\n602:     ) external nonReentrant returns (uint256, uint256) {\n603:         if (polarity == -1) {\n604:             return\n605:                 _rebalanceNegativePnlLite(amount, sqrtPriceLimitX96, account);\n606:         } else if (polarity == 1) {\n607:             // disable rebalancing positive PnL\n608:             revert PositivePnlRebalanceDisabled(msg.sender);\n609:             // return _rebalancePositivePnlLite(amount, sqrtPriceLimitX96, account);\n610:         } else {\n611:             revert InvalidRebalance(polarity);\n612:         }\n613:     }\n614:\n615:     function _rebalanceNegativePnlLite(\n616:         uint256 amount,\n617:         uint160 sqrtPriceLimitX96,\n618:         address account\n619:     ) private returns (uint256, uint256) {\n620:         uint256 normalizedAmount = amount.fromDecimalToDecimal(\n621:             ERC20(quoteToken).decimals(),\n622:             18\n623:         );\n624:\n625:         _checkNegativePnl(normalizedAmount);\n626:         IERC20(quoteToken).transferFrom(account, address(this), amount);\n627:         IERC20(quoteToken).approve(address(vault), amount);\n628:         vault.deposit(quoteToken, amount);\n629:\n630:         bool isShort = false;\n631:         bool amountIsInput = true;\n632:         (uint256 baseAmount, uint256 quoteAmount) = _placePerpOrder(\n633:             normalizedAmount,\n634:             isShort,\n635:             amountIsInput,\n636:             sqrtPriceLimitX96\n637:         );\n638:         vault.withdraw(assetToken, baseAmount);\n639:         IERC20(assetToken).transfer(account, baseAmount);\n640:\n641:         emit Rebalanced(baseAmount, quoteAmount, 0);\n642:\n643:         return (baseAmount, quoteAmount);\n644:     }\n```\nEspecially, according to the communication with the PERP dev team, it is possible for the Perp's ClearingHouse to fill the position partially when the price limit is specified (`sqrtPriceLimitX96`).\nIt is also commented in the Perp contract comments [here](https://github.com/perpetual-protocol/perp-curie-contract/blob/27ea8e2c4be37d1dd58c1eed3b3cc269d398a091/contracts/ClearingHouse.sol#L63).\n```solidity\n63:     /// @param sqrtPriceLimitX96 tx will fill until it reaches this price but WON'T REVERT\n64:     struct InternalOpenPositionParams {\n65:         address trader;\n66:         address baseToken;\n67:         bool isBaseToQuote;\n68:         bool isExactInput;\n69:         bool isClose;\n70:         uint256 amount;\n71:         uint160 sqrtPriceLimitX96;\n72:     }\n```\nSo it is possible that the order is not placed to the full amount.\nAs we can see in the #L626~#L628, the UXD protocol grabs the quote token of `amount` and deposits to the Perp's vault.\nAnd the unused amount will remain in the Perp vault while this is supposed to be returned to the user who called this rebalance function.\n\n## Impact\nUsers can lose funds while lite rebalancing.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L597\n\n## Tool used\nManual Review\n\n## Recommendation\nAdd a protection parameter to the function `rebalanceLite()` so that the user can specify the minimum out amount.\n\n## Discussion\n\n**WarTech9**\n\nThe caller can specify the target price using the `sqrtPriceLimitX96` parameter to the `rebalanceLite` function. This offers slippage protection.\n\n\n**hansfriese**\n\nEscalate for 10 USDC\n\nI suggest the judge and the sponsor read this issue carefully again.\nThe key problem is that the Perp protocol can partially fill the position, especially when the `sqrtPriceLimitX96 ` is specified.\n(This is related to how Uniswap works, check [here](https://jeiwan.net/posts/public-bug-report-uniswap-swaprouter/))\nSo it is possible that the order is not placed to the full amount and the remaining amount should be returned to the user.\nI admit that my explanation sounded vague because I mentioned slippage.\nI mean, the protocol should return the remaining value or allow the user to explicitly specify the minimum output amount.\nPlease check the screenshot of the chat I had with the Perp team.\nThey confirmed it is possible that the order is not filled to the full amount when the `sqrtPriceLimitX96 ` is specified.\n\n![screenshot_47](https://user-images.githubusercontent.com/45533148/216356589-8b3751ad-8731-401b-853f-dbb93512a80c.png)\n![screenshot_48](https://user-images.githubusercontent.com/45533148/216356592-e752dc2e-26cb-42d1-bf5e-e4c91c3928fe.png)\n\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> I suggest the judge and the sponsor read this issue carefully again.\n> The key problem is that the Perp protocol can partially fill the position, especially when the `sqrtPriceLimitX96 ` is specified.\n> (This is related to how Uniswap works, check [here](https://jeiwan.net/posts/public-bug-report-uniswap-swaprouter/))\n> So it is possible that the order is not placed to the full amount and the remaining amount should be returned to the user.\n> I admit that my explanation sounded vague because I mentioned slippage.\n> I mean, the protocol should return the remaining value or allow the user to explicitly specify the minimum output amount.\n> Please check the screenshot of the chat I had with the Perp team.\n> They confirmed it is possible that the order is not filled to the full amount when the `sqrtPriceLimitX96 ` is specified.\n> \n> ![screenshot_47](https://user-images.githubusercontent.com/45533148/216356589-8b3751ad-8731-401b-853f-dbb93512a80c.png)\n> ![screenshot_48](https://user-images.githubusercontent.com/45533148/216356592-e752dc2e-26cb-42d1-bf5e-e4c91c3928fe.png)\n> \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**WarTech9**\n\nWith the updated comments I agree there is a valid issue here. If the requested amount is not filled completely in the Perp order, we should only transfer from the user the amount returned from the `_placePerpOrder()` call. \n\n**hrishibhat**\n\nEscalation accepted. \n\nAs pointed out in the Escalation that there is the possibility of partial order fills when sqrtPriceLimitX96 is specified. \n\n**sherlock-admin**\n\n> Escalation accepted. \n> \n> As pointed out in the Escalation that there is the possibility of partial order fills when sqrtPriceLimitX96 is specified. \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/33",
  "Code": [
    {
      "filename": "contracts/ClearingHouse.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport { AddressUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport { SafeMathUpgradeable } from \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport { SignedSafeMathUpgradeable } from \"@openzeppelin/contracts-upgradeable/math/SignedSafeMathUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { IUniswapV3Pool } from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport { IUniswapV3MintCallback } from \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3MintCallback.sol\";\nimport { IUniswapV3SwapCallback } from \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\";\nimport { FullMath } from \"@uniswap/v3-core/contracts/libraries/FullMath.sol\";\nimport { PerpSafeCast } from \"./lib/PerpSafeCast.sol\";\nimport { PerpMath } from \"./lib/PerpMath.sol\";\nimport { SettlementTokenMath } from \"./lib/SettlementTokenMath.sol\";\nimport { Funding } from \"./lib/Funding.sol\";\nimport { OwnerPausable } from \"./base/OwnerPausable.sol\";\nimport { IERC20Metadata } from \"./interface/IERC20Metadata.sol\";\nimport { IVault } from \"./interface/IVault.sol\";\nimport { IExchange } from \"./interface/IExchange.sol\";\nimport { IOrderBook } from \"./interface/IOrderBook.sol\";\nimport { IIndexPrice } from \"./interface/IIndexPrice.sol\";\nimport { IClearingHouseConfig } from \"./interface/IClearingHouseConfig.sol\";\nimport { IAccountBalance } from \"./interface/IAccountBalance.sol\";\nimport { IInsuranceFund } from \"./interface/IInsuranceFund.sol\";\nimport { IBaseToken } from \"./interface/IBaseToken.sol\";\nimport { IIndexPrice } from \"./interface/IIndexPrice.sol\";\nimport { IDelegateApproval } from \"./interface/IDelegateApproval.sol\";\nimport { BaseRelayRecipient } from \"./gsn/BaseRelayRecipient.sol\";\nimport { ClearingHouseStorageV2 } from \"./storage/ClearingHouseStorage.sol\";\nimport { BlockContext } from \"./base/BlockContext.sol\";\nimport { IClearingHouse } from \"./interface/IClearingHouse.sol\";\nimport { AccountMarket } from \"./lib/AccountMarket.sol\";\nimport { OpenOrder } from \"./lib/OpenOrder.sol\";\n\n// never inherit any new stateful contract. never change the orders of parent stateful contracts\ncontract ClearingHouse is\n    IUniswapV3MintCallback,\n    IUniswapV3SwapCallback,\n    IClearingHouse,\n    BlockContext,\n    ReentrancyGuardUpgradeable,\n    OwnerPausable,\n    BaseRelayRecipient,\n    ClearingHouseStorageV2\n{\n    using AddressUpgradeable for address;\n    using SafeMathUpgradeable for uint256;\n    using SignedSafeMathUpgradeable for int256;\n    using PerpSafeCast for uint256;\n    using PerpSafeCast for uint128;\n    using PerpSafeCast for int256;\n    using PerpMath for uint256;\n    using PerpMath for uint160;\n    using PerpMath for uint128;\n    using PerpMath for int256;\n    using SettlementTokenMath for int256;\n\n    //\n    // STRUCT\n    //\n\n    /// @param sqrtPriceLimitX96 tx will fill until it reaches this price but WON'T REVERT\n    struct InternalOpenPositionParams {\n        address trader;\n        address baseToken;\n        bool isBaseToQuote;\n        bool isExactInput;\n        bool isClose;\n        uint256 amount;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct InternalCheckSlippageParams {\n        bool isBaseToQuote;\n        bool isExactInput;\n        uint256 base;\n        uint256 quote;\n        uint256 oppositeAmountBound;\n    }\n\n    //\n    // MODIFIER\n    //\n\n    modifier checkDeadline(uint256 deadline) {\n        // transaction expires\n        require(_blockTimestamp() <= deadline, \"CH_TE\");\n        _;\n    }\n\n    //\n    // EXTERNAL NON-VIEW\n    //\n\n    /// @dev this function is public for testing\n    // solhint-disable-next-line func-order\n    function initialize(\n        address clearingHouseConfigArg,\n        address vaultArg,\n        address quoteTokenArg,\n        address uniV3FactoryArg,\n        address exchangeArg,\n        address accountBalanceArg,\n        address insuranceFundArg\n    ) public initializer {\n        // CH_VANC: Vault address is not contract\n        _isContract(vaultArg, \"CH_VANC\");\n        // CH_QANC: QuoteToken address is not contract\n        _isContract(quoteTokenArg, \"CH_QANC\");\n        // CH_QDN18: QuoteToken decimals is not 18\n        require(IERC20Metadata(quoteTokenArg).decimals() == 18, \"CH_QDN18\");\n        // CH_UANC: UniV3Factory address is not contract\n        _isContract(uniV3FactoryArg, \"CH_UANC\");\n        // ClearingHouseConfig address is not contract\n        _isContract(clearingHouseConfigArg, \"CH_CCNC\");\n        // AccountBalance is not contract\n        _isContract(accountBalanceArg, \"CH_ABNC\");\n        // CH_ENC: Exchange is not contract\n        _isContract(exchangeArg, \"CH_ENC\");\n        // CH_IFANC: InsuranceFund address is not contract\n        _isContract(insuranceFundArg, \"CH_IFANC\");\n\n        address orderBookArg = IExchange(exchangeArg).getOrderBook();\n        // orderBook is not contract\n        _isContract(orderBookArg, \"CH_OBNC\");\n\n        __ReentrancyGuard_init();\n        __OwnerPausable_init();\n\n        _clearingHouseConfig = clearingHouseConfigArg;\n        _vault = vaultArg;\n        _quoteToken = quoteTokenArg;\n        _uniswapV3Factory = uniV3FactoryArg;\n        _exchange = exchangeArg;\n        _orderBook = orderBookArg;\n        _accountBalance = accountBalanceArg;\n        _insuranceFund = insuranceFundArg;\n\n        _settlementTokenDecimals = IVault(_vault).decimals();\n    }\n\n    /// @dev remove to reduce bytecode size, might add back when we need it\n    // // solhint-disable-next-line func-order\n    // function setTrustedForwarder(address trustedForwarderArg) external onlyOwner {\n    //     // CH_TFNC: TrustedForwarder is not contract\n    //     require(trustedForwarderArg.isContract(), \"CH_TFNC\");\n    //     // TrustedForwarderUpdated event is emitted in BaseRelayRecipient\n    //     _setTrustedForwarder(trustedForwarderArg);\n    // }\n\n    function setDelegateApproval(address delegateApprovalArg) external onlyOwner {\n        // CH_DANC: DelegateApproval is not contract\n        require(delegateApprovalArg.isContract(), \"CH_DANC\");\n        _delegateApproval = delegateApprovalArg;\n        emit DelegateApprovalChanged(delegateApprovalArg);\n    }\n\n    /// @inheritdoc IClearingHouse\n    function addLiquidity(AddLiquidityParams calldata params)\n        external\n        override\n        whenNotPaused\n        nonReentrant\n        checkDeadline(params.deadline)\n        returns (AddLiquidityResponse memory)\n    {\n        // input requirement checks:\n        //   baseToken: in Exchange.settleFunding()\n        //   base & quote: in LiquidityAmounts.getLiquidityForAmounts() -> FullMath.mulDiv()\n        //   lowerTick & upperTick: in UniswapV3Pool._modifyPosition()\n        //   minBase, minQuote & deadline: here\n\n        _checkMarketOpen(params.baseToken);\n\n        // This condition is to prevent the intentional bad debt attack through price manipulation.\n        // CH_OMPS: Over the maximum price spread\n        require(!IExchange(_exchange).isOverPriceSpread(params.baseToken), \"CH_OMPS\");\n\n        // CH_DUTB: Disable useTakerBalance\n        require(!params.useTakerBalance, \"CH_DUTB\");\n\n        address trader = _msgSender();\n        // register token if it's the first time\n        _registerBaseToken(trader, params.baseToken);\n\n        // must settle funding first\n        Funding.Growth memory fundingGrowthGlobal = _settleFunding(trader, params.baseToken);\n\n        // note that we no longer check available tokens here because CH will always auto-mint in UniswapV3MintCallback\n        IOrderBook.AddLiquidityResponse memory response =\n            IOrderBook(_orderBook).addLiquidity(\n                IOrderBook.AddLiquidityParams({\n                    trader: trader,\n                    baseToken: params.baseToken,\n                    base: params.base,\n                    quote: params.quote,\n                    lowerTick: params.lowerTick,\n                    upperTick: params.upperTick,\n                    fundingGrowthGlobal: fundingGrowthGlobal\n                })\n            );\n\n        _checkSlippageAfterLiquidityChange(response.base, params.minBase, response.quote, params.minQuote);\n\n        // if !useTakerBalance, takerBalance won't change, only need to collects fee to oweRealizedPnl\n        if (params.useTakerBalance) {\n            bool isBaseAdded = response.base != 0;\n\n            // can't add liquidity within range from take position\n            require(isBaseAdded != (response.quote != 0), \"CH_CALWRFTP\");\n\n            AccountMarket.Info memory accountMarketInfo =\n                IAccountBalance(_accountBalance).getAccountInfo(trader, params.baseToken);\n\n            // the signs of removedPositionSize and removedOpenNotional are always the opposite.\n            int256 removedPositionSize;\n            int256 removedOpenNotional;\n            if (isBaseAdded) {\n                // taker base not enough\n                require(accountMarketInfo.takerPositionSize >= response.base.toInt256(), \"CH_TBNE\");\n\n                removedPositionSize = response.base.neg256();\n\n                // move quote debt from taker to maker:\n                // takerOpenNotional(-) * removedPositionSize(-) / takerPositionSize(+)\n\n                // overflow inspection:\n                // Assume collateral is 2.406159692E28 and index price is 1e-18\n                // takerOpenNotional ~= 10 * 2.406159692E28 = 2.406159692E29 --> x\n                // takerPositionSize ~= takerOpenNotional/index price = x * 1e18 = 2.4061597E38\n                // max of removedPositionSize = takerPositionSize = 2.4061597E38\n                // (takerOpenNotional * removedPositionSize) < 2^255\n                // 2.406159692E29 ^2 * 1e18 < 2^255\n                removedOpenNotional = accountMarketInfo.takerOpenNotional.mul(removedPositionSize).div(\n                    accountMarketInfo.takerPositionSize\n                );\n            } else {\n                // taker quote not enough\n                require(accountMarketInfo.takerOpenNotional >= response.quote.toInt256(), \"CH_TQNE\");\n\n                removedOpenNotional = response.quote.neg256();\n\n                // move base debt from taker to maker:\n                // takerPositionSize(-) * removedOpenNotional(-) / takerOpenNotional(+)\n                // overflow inspection: same as above\n                removedPositionSize = accountMarketInfo.takerPositionSize.mul(removedOpenNotional).div(\n                    accountMarketInfo.takerOpenNotional\n                );\n            }\n\n            // update orderDebt to record the cost of this order\n            IOrderBook(_orderBook).updateOrderDebt(\n                OpenOrder.calcOrderKey(trader, params.baseToken, params.lowerTick, params.upperTick),\n                removedPositionSize,\n                removedOpenNotional\n            );\n\n            // update takerBalances as we're using takerBalances to provide liquidity\n            (, int256 takerOpenNotional) =\n                IAccountBalance(_accountBalance).modifyTakerBalance(\n                    trader,\n                    params.baseToken,\n                    removedPositionSize,\n                    removedOpenNotional\n                );\n\n            uint256 sqrtPrice = _getSqrtMarkX96(params.baseToken);\n            _emitPositionChanged(\n                trader,\n                params.baseToken,\n                removedPositionSize, // exchangedPositionSize\n                removedOpenNotional, // exchangedPositionNotional\n                0, // fee\n                takerOpenNotional, // openNotional\n                0, // realizedPnl\n                sqrtPrice // sqrtPriceAfterX96\n            );\n        }\n\n        // fees always have to be collected to owedRealizedPnl, as long as there is a change in liquidity\n        _modifyOwedRealizedPnl(trader, response.fee.toInt256());\n\n        // after token balances are updated, we can check if there is enough free collateral\n        _requireEnoughFreeCollateral(trader);\n\n        _emitLiquidityChanged(\n            trader,\n            params.baseToken,\n            _quoteToken,\n            params.lowerTick,\n            params.upperTick,\n            response.base.toInt256(),\n            response.quote.toInt256(),\n            response.liquidity.toInt128(),\n            response.fee\n        );\n\n        return\n            AddLiquidityResponse({\n                base: response.base,\n                quote: response.quote,\n                fee: response.fee,\n                liquidity: response.liquidity\n            });\n    }\n\n    /// @inheritdoc IClearingHouse\n    function removeLiquidity(RemoveLiquidityParams calldata params)\n        external\n        override\n        whenNotPaused\n        nonReentrant\n        checkDeadline(params.deadline)\n        returns (RemoveLiquidityResponse memory)\n    {\n        // input requirement checks:\n        //   baseToken: in Exchange.settleFunding()\n        //   lowerTick & upperTick: in UniswapV3Pool._modifyPosition()\n        //   liquidity: in LiquidityMath.addDelta()\n        //   minBase, minQuote & deadline: here\n\n        // CH_MP: Market paused\n        require(!IBaseToken(params.baseToken).isPaused(), \"CH_MP\");\n\n        address trader = _msgSender();\n\n        // must settle funding first\n        _settleFunding(trader, params.baseToken);\n\n        IOrderBook.RemoveLiquidityResponse memory response =\n            _removeLiquidity(\n                IOrderBook.RemoveLiquidityParams({\n                    maker: trader,\n                    baseToken: params.baseToken,\n                    lowerTick: params.lowerTick,\n                    upperTick: params.upperTick,\n                    liquidity: params.liquidity\n                })\n            );\n\n        _checkSlippageAfterLiquidityChange(response.base, params.minBase, response.quote, params.minQuote);\n\n        _modifyPositionAndRealizePnl(\n            trader,\n            params.baseToken,\n            response.takerBase, // exchangedPositionSize\n            response.takerQuote, // exchangedPositionNotional\n            response.fee, // makerFee\n            0 //takerFee\n        );\n\n        _emitLiquidityChanged(\n            trader,\n            params.baseToken,\n            _quoteToken,\n            params.lowerTick,\n            params.upperTick,\n            response.base.neg256(),\n            response.quote.neg256(),\n            params.liquidity.neg128(),\n            response.fee\n        );\n\n        return RemoveLiquidityResponse({ quote: response.quote, base: response.base, fee: response.fee });\n    }\n\n    /// @inheritdoc IClearingHouse\n    function settleAllFunding(address trader) external override {\n        // only vault or trader\n        // vault must check msg.sender == trader when calling settleAllFunding\n        require(_msgSender() == _vault || _msgSender() == trader, \"CH_OVOT\");\n\n        address[] memory baseTokens = IAccountBalance(_accountBalance).getBaseTokens(trader);\n        uint256 baseTokenLength = baseTokens.length;\n        for (uint256 i = 0; i < baseTokenLength; i++) {\n            _settleFunding(trader, baseTokens[i]);\n        }\n    }\n\n    /// @inheritdoc IClearingHouse\n    function openPosition(OpenPositionParams memory params)\n        external\n        override\n        whenNotPaused\n        nonReentrant\n        checkDeadline(params.deadline)\n        returns (uint256 base, uint256 quote)\n    {\n        // openPosition() is already published, returned types remain the same (without fee)\n        (base, quote, ) = _openPositionFor(_msgSender(), params);\n        return (base, quote);\n    }\n\n    /// @inheritdoc IClearingHouse\n    function openPositionFor(address trader, OpenPositionParams memory params)\n        external\n        override\n        whenNotPaused\n        nonReentrant\n        checkDeadline(params.deadline)\n        returns (\n            uint256 base,\n            uint256 quote,\n            uint256 fee\n        )\n    {\n        // CH_SHNAOPT: Sender Has No Approval to Open Position for Trader\n        require(IDelegateApproval(_delegateApproval).canOpenPositionFor(trader, _msgSender()), \"CH_SHNAOPT\");\n\n        return _openPositionFor(trader, params);\n    }\n\n    /// @inheritdoc IClearingHouse\n    function closePosition(ClosePositionParams calldata params)\n        external\n        override\n        whenNotPaused\n        nonReentrant\n        checkDeadline(params.deadline)\n        returns (uint256 base, uint256 quote)\n    {\n        // input requirement checks:\n        //   baseToken: in Exchange.settleFunding()\n        //   sqrtPriceLimitX96: X (this is not for slippage protection)\n        //   oppositeAmountBound: in _checkSlippage()\n        //   deadline: here\n        //   referralCode: X\n\n        _checkMarketOpen(params.baseToken);\n\n        address trader = _msgSender();\n\n        // must settle funding first\n        _settleFunding(trader, params.baseToken);\n\n        int256 positionSize = _getTakerPositionSafe(trader, params.baseToken);\n\n        // old position is long. when closing, it's baseToQuote && exactInput (sell exact base)\n        // old position is short. when closing, it's quoteToBase && exactOutput (buy exact base back)\n        bool isBaseToQuote = positionSize > 0;\n\n        IExchange.SwapResponse memory response =\n            _openPosition(\n                InternalOpenPositionParams({\n                    trader: trader,\n                    baseToken: params.baseToken,\n                    isBaseToQuote: isBaseToQuote,\n                    isExactInput: isBaseToQuote,\n                    isClose: true,\n                    amount: positionSize.abs(),\n                    sqrtPriceLimitX96: params.sqrtPriceLimitX96\n                })\n            );\n\n        _checkSlippage(\n            InternalCheckSlippageParams({\n                isBaseToQuote: isBaseToQuote,\n                isExactInput: isBaseToQuote,\n                base: response.base,\n                quote: response.quote,\n                oppositeAmountBound: _getOppositeAmount(params.oppositeAmountBound, response.isPartialClose)\n            })\n        );\n\n        _referredPositionChanged(params.referralCode);\n\n        return (response.base, response.quote);\n    }\n\n    /// @inheritdoc IClearingHouse\n    function liquidate(\n        address trader,\n        address baseToken,\n        int256 positionSize\n    ) external override whenNotPaused nonReentrant {\n        _liquidate(trader, baseToken, positionSize);\n    }\n\n    /// @inheritdoc IClearingHouse\n    function liquidate(address trader, address baseToken) external override whenNotPaused nonReentrant {\n        // positionSizeToBeLiquidated = 0 means liquidating as much as possible\n        _liquidate(trader, baseToken, 0);\n    }\n\n    /// @inheritdoc IClearingHouse\n    function cancelExcessOrders(\n        address maker,\n        address baseToken,\n        bytes32[] calldata orderIds\n    ) external override whenNotPaused nonReentrant {\n        // input requirement checks:\n        //   maker: in _cancelExcessOrders()\n        //   baseToken: in Exchange.settleFunding()\n        //   orderIds: in OrderBook.removeLiquidityByIds()\n\n        _cancelExcessOrders(maker, baseToken, orderIds);\n    }\n\n    /// @inheritdoc IClearingHouse\n    function cancelAllExcessOrders(address maker, address baseToken) external override whenNotPaused nonReentrant {\n        // input requirement checks:\n        //   maker: in _cancelExcessOrders()\n        //   baseToken: in Exchange.settleFunding()\n        //   orderIds: in OrderBook.removeLiquidityByIds()\n\n        _cancelExcessOrders(maker, baseToken, _getOpenOrderIds(maker, baseToken));\n    }\n\n    /// @inheritdoc IClearingHouse\n    function quitMarket(address trader, address baseToken) external override returns (uint256 base, uint256 quote) {\n        // CH_MNC: Market not closed\n        require(IBaseToken(baseToken).isClosed(), \"CH_MNC\");\n\n        _settleFunding(trader, baseToken);\n\n        bytes32[] memory orderIds = _getOpenOrderIds(trader, baseToken);\n\n        // remove all orders in internal function\n        if (orderIds.length > 0) {\n            _removeAllLiquidity(trader, baseToken, orderIds);\n        }\n\n        int256 positionSize = _getTakerPosition(trader, baseToken);\n\n        // if position is 0, no need to do settlement accounting\n        if (positionSize == 0) {\n            return (0, 0);\n        }\n\n        (int256 positionNotional, int256 openNotional, int256 realizedPnl, uint256 closedPrice) =\n            IAccountBalance(_accountBalance).settlePositionInClosedMarket(trader, baseToken);\n\n        emit PositionClosed(trader, baseToken, positionSize, positionNotional, openNotional, realizedPnl, closedPrice);\n\n        _settleBadDebt(trader);\n\n        return (positionSize.abs(), positionNotional.abs());\n    }\n\n    /// @inheritdoc IUniswapV3MintCallback\n    /// @dev namings here follow Uniswap's convention\n    function uniswapV3MintCallback(\n        uint256 amount0Owed,\n        uint256 amount1Owed,\n        bytes calldata data\n    ) external override {\n        // input requirement checks:\n        //   amount0Owed: here\n        //   amount1Owed: here\n        //   data: X\n\n        // For caller validation purposes it would be more efficient and more reliable to use\n        // \"msg.sender\" instead of \"_msgSender()\" as contracts never call each other through GSN.\n        // not orderbook\n        require(msg.sender == _orderBook, \"CH_NOB\");\n\n        IOrderBook.MintCallbackData memory callbackData = abi.decode(data, (IOrderBook.MintCallbackData));\n\n        if (amount0Owed > 0) {\n            address token = IUniswapV3Pool(callbackData.pool).token0();\n            _requireTransfer(token, callbackData.pool, amount0Owed);\n        }\n        if (amount1Owed > 0) {\n            address token = IUniswapV3Pool(callbackData.pool).token1();\n            _requireTransfer(token, callbackData.pool, amount1Owed);\n        }\n    }\n\n    /// @inheritdoc IUniswapV3SwapCallback\n    /// @dev namings here follow Uniswap's convention\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external override {\n        // input requirement checks:\n        //   amount0Delta: here\n        //   amount1Delta: here\n        //   data: X\n        // For caller validation purposes it would be more efficient and more reliable to use\n        // \"msg.sender\" instead of \"_msgSender()\" as contracts never call each other through GSN.\n        require(msg.sender == _exchange, \"CH_OE\");\n\n        // swaps entirely within 0-liquidity regions are not supported -> 0 swap is forbidden\n        // CH_F0S: forbidden 0 swap\n        require((amount0Delta > 0 && amount1Delta < 0) || (amount0Delta < 0 && amount1Delta > 0), \"CH_F0S\");\n\n        IExchange.SwapCallbackData memory callbackData = abi.decode(data, (IExchange.SwapCallbackData));\n        IUniswapV3Pool uniswapV3Pool = IUniswapV3Pool(callbackData.pool);\n\n        // amount0Delta & amount1Delta are guaranteed to be positive when being the amount to be paid\n        (address token, uint256 amountToPay) =\n            amount0Delta > 0\n                ? (uniswapV3Pool.token0(), uint256(amount0Delta))\n                : (uniswapV3Pool.token1(), uint256(amount1Delta));\n\n        // swap\n        _requireTransfer(token, callbackData.pool, amountToPay);\n    }\n\n    //\n    // EXTERNAL VIEW\n    //\n\n    /// @inheritdoc IClearingHouse\n    function getQuoteToken() external view override returns (address) {\n        return _quoteToken;\n    }\n\n    /// @inheritdoc IClearingHouse\n    function getUniswapV3Factory() external view override returns (address) {\n        return _uniswapV3Factory;\n    }\n\n    /// @inheritdoc IClearingHouse\n    function getClearingHouseConfig() external view override returns (address) {\n        return _clearingHouseConfig;\n    }\n\n    /// @inheritdoc IClearingHouse\n    function getVault() external view override returns (address) {\n        return _vault;\n    }\n\n    /// @inheritdoc IClearingHouse\n    function getExchange() external view override returns (address) {\n        return _exchange;\n    }\n\n    /// @inheritdoc IClearingHouse\n    function getOrderBook() external view override returns (address) {\n        return _orderBook;\n    }\n\n    /// @inheritdoc IClearingHouse\n    function getAccountBalance() external view override returns (address) {\n        return _accountBalance;\n    }\n\n    /// @inheritdoc IClearingHouse\n    function getInsuranceFund() external view override returns (address) {\n        return _insuranceFund;\n    }\n\n    /// @inheritdoc IClearingHouse\n    function getDelegateApproval() external view override returns (address) {\n        return _delegateApproval;\n    }\n\n    /// @inheritdoc IClearingHouse\n    function getAccountValue(address trader) public view override returns (int256) {\n        return IVault(_vault).getAccountValue(trader).parseSettlementToken(_settlementTokenDecimals);\n    }\n\n    //\n    // INTERNAL NON-VIEW\n    //\n\n    function _requireTransfer(\n        address token,\n        address to,\n        uint256 amount\n    ) internal {\n        // CH_TF: Transfer failed\n        require(IERC20Metadata(token).transfer(to, amount), \"CH_TF\");\n    }\n\n    function _liquidate(\n        address trader,\n        address baseToken,\n        int256 positionSizeToBeLiquidated\n    ) internal {\n        _checkMarketOpen(baseToken);\n\n        // CH_CLWTISO: cannot liquidate when there is still order\n        require(!IAccountBalance(_accountBalance).hasOrder(trader), \"CH_CLWTISO\");\n\n        // CH_EAV: enough account value\n        require(_isLiquidatable(trader), \"CH_EAV\");\n\n        int256 positionSize = _getTakerPositionSafe(trader, baseToken);\n\n        // CH_WLD: wrong liquidation direction\n        require(positionSize.mul(positionSizeToBeLiquidated) >= 0, \"CH_WLD\");\n\n        address liquidator = _msgSender();\n\n        _registerBaseToken(liquidator, baseToken);\n\n        // must settle funding first\n        _settleFunding(trader, baseToken);\n        _settleFunding(liquidator, baseToken);\n\n        int256 accountValue = getAccountValue(trader);\n\n        // trader's position is closed at index price and pnl realized\n        (int256 liquidatedPositionSize, int256 liquidatedPositionNotional) =\n            _getLiquidatedPositionSizeAndNotional(trader, baseToken, accountValue, positionSizeToBeLiquidated);\n        _modifyPositionAndRealizePnl(trader, baseToken, liquidatedPositionSize, liquidatedPositionNotional, 0, 0);\n\n        // trader pays liquidation penalty\n        uint256 liquidationPenalty = liquidatedPositionNotional.abs().mulRatio(_getLiquidationPenaltyRatio());\n        _modifyOwedRealizedPnl(trader, liquidationPenalty.neg256());\n\n        address insuranceFund = _insuranceFund;\n\n        // if there is bad debt, liquidation fees all go to liquidator; otherwise, split between liquidator & IF\n        uint256 liquidationFeeToLiquidator = liquidationPenalty.div(2);\n        uint256 liquidationFeeToIF;\n        if (accountValue < 0) {\n            liquidationFeeToLiquidator = liquidationPenalty;\n        } else {\n            liquidationFeeToIF = liquidationPenalty.sub(liquidationFeeToLiquidator);\n            _modifyOwedRealizedPnl(insuranceFund, liquidationFeeToIF.toInt256());\n        }\n\n        // assume there is no longer any unsettled bad debt in the system\n        // (so that true IF capacity = accountValue(IF) + USDC.balanceOf(IF))\n        // if trader's account value becomes negative, the amount is the bad debt IF must have enough capacity to cover\n        {\n            int256 accountValueAfterLiquidationX10_18 = getAccountValue(trader);\n\n            if (accountValueAfterLiquidationX10_18 < 0) {\n                int256 insuranceFundCapacityX10_18 =\n                    IInsuranceFund(insuranceFund).getInsuranceFundCapacity().parseSettlementToken(\n                        _settlementTokenDecimals\n                    );\n\n                // CH_IIC: insufficient insuranceFund capacity\n                require(insuranceFundCapacityX10_18 >= accountValueAfterLiquidationX10_18.neg256(), \"CH_IIC\");\n            }\n        }\n\n        // liquidator opens a position with liquidationFeeToLiquidator as a discount\n        // liquidator's openNotional = -liquidatedPositionNotional + liquidationFeeToLiquidator\n        int256 liquidatorExchangedPositionSize = liquidatedPositionSize.neg256();\n        int256 liquidatorExchangedPositionNotional =\n            liquidatedPositionNotional.neg256().add(liquidationFeeToLiquidator.toInt256());\n        // note that this function will realize pnl if it's reducing liquidator's existing position size\n        _modifyPositionAndRealizePnl(\n            liquidator,\n            baseToken,\n            liquidatorExchangedPositionSize, // exchangedPositionSize\n            liquidatorExchangedPositionNotional, // exchangedPositionNotional\n            0, // makerFee\n            0 // takerFee\n        );\n\n        _requireEnoughFreeCollateral(liquidator);\n\n        emit PositionLiquidated(\n            trader,\n            baseToken,\n            liquidatedPositionNotional.abs(), // positionNotional\n            liquidatedPositionSize.abs(), // positionSize\n            liquidationPenalty,\n            liquidator\n        );\n\n        _settleBadDebt(trader);\n    }\n\n    /// @dev Calculate how much profit/loss we should realize,\n    ///      The profit/loss is calculated by exchangedPositionSize/exchangedPositionNotional amount\n    ///      and existing taker's base/quote amount.\n    function _modifyPositionAndRealizePnl(\n        address trader,\n        address baseToken,\n        int256 exchangedPositionSize,\n        int256 exchangedPositionNotional,\n        uint256 makerFee,\n        uint256 takerFee\n    ) internal {\n        int256 realizedPnl;\n        if (exchangedPositionSize != 0) {\n            realizedPnl = IExchange(_exchange).getPnlToBeRealized(\n                IExchange.RealizePnlParams({\n                    trader: trader,\n                    baseToken: baseToken,\n                    base: exchangedPositionSize,\n                    quote: exchangedPositionNotional\n                })\n            );\n        }\n\n        // realizedPnl is realized here\n        // will deregister baseToken if there is no position\n        _settleBalanceAndDeregister(\n            trader,\n            baseToken,\n            exchangedPositionSize, // takerBase\n            exchangedPositionNotional, // takerQuote\n            realizedPnl,\n            makerFee.toInt256()\n        );\n\n        _emitPositionChanged(\n            trader,\n            baseToken,\n            exchangedPositionSize,\n            exchangedPositionNotional,\n            takerFee, // fee\n            _getTakerOpenNotional(trader, baseToken), // openNotional\n            realizedPnl,\n            _getSqrtMarkX96(baseToken) // sqrtPriceAfterX96: no swap, so market price didn't change\n        );\n    }\n\n    /// @dev only cancel open orders if there are not enough free collateral with mmRatio\n    /// or account is able to being liquidated.\n    function _cancelExcessOrders(\n        address maker,\n        address baseToken,\n        bytes32[] memory orderIds\n    ) internal {\n        _checkMarketOpen(baseToken);\n\n        if (orderIds.length == 0) {\n            return;\n        }\n\n        // CH_NEXO: not excess orders\n        require(\n            (_getFreeCollateralByRatio(maker, IClearingHouseConfig(_clearingHouseConfig).getMmRatio()) < 0) ||\n                _isLiquidatable(maker),\n            \"CH_NEXO\"\n        );\n\n        // must settle funding first\n        _settleFunding(maker, baseToken);\n\n        // remove all orders in internal function\n        _removeAllLiquidity(maker, baseToken, orderIds);\n    }\n\n    function _removeAllLiquidity(\n        address maker,\n        address baseToken,\n        bytes32[] memory orderIds\n    ) internal {\n        IOrderBook.RemoveLiquidityResponse memory removeLiquidityResponse;\n\n        uint256 length = orderIds.length;\n        for (uint256 i = 0; i < length; i++) {\n            OpenOrder.Info memory order = IOrderBook(_orderBook).getOpenOrderById(orderIds[i]);\n\n            // CH_ONBM: order is not belongs to this maker\n            require(\n                OpenOrder.calcOrderKey(maker, baseToken, order.lowerTick, order.upperTick) == orderIds[i],\n                \"CH_ONBM\"\n            );\n\n            IOrderBook.RemoveLiquidityResponse memory response =\n                _removeLiquidity(\n                    IOrderBook.RemoveLiquidityParams({\n                        maker: maker,\n                        baseToken: baseToken,\n                        lowerTick: order.lowerTick,\n                        upperTick: order.upperTick,\n                        liquidity: order.liqui"
    }
  ]
}