{
  "Title": "[H02] Test are not following contracts logic",
  "Content": "The code base presents tests in the [protocol/test](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/test) directory.\n\n\nAlmost all modules (except for the `Governance` contracts along with all libraries) have unit tests under their respective folders and the execution shows that all test pass.\n\n\nHowever, some of the tests are not following the logic of the contracts implementation and are not testing appropriate conditions that should revert contract calls.\n\n\nOne example is the [`ReserveSwapper` test file](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/test/reserve/ReserveSwapper.test.js).  \n\n[According to the contract implementation](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/reserve/ReserveSwapper.sol#L75-L78), the `swap` function of the `ReserveSwapper` contract should revert whenever the `ESD` token address is used either as a `takerToken` or `makerToken`.\n\n\nHowever, [in the corresponding test of this function](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/test/reserve/ReserveSwapper.test.js#L118) , the [`ESD` address](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/test/reserve/ReserveSwapper.test.js#L19) is passed as parameter and the function doesn’t revert in this case.\n\n\nThe test passes only because the `ESD` address hasn’t been set in the `Registry` contract at test execution time, so the [line 75](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/reserve/ReserveSwapper.sol#L75) is comparing the passed input address with the zero address.\n\n\nIn this specific case, the test that actually sets the `ESD` address in the `Registry` contract is the [`ReserveComptroller` test suite](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/test/reserve/ReserveComptroller.test.js).\n\n\nThis is considered a major shortcoming in the project, as there is no way to determine if the current implementation matches the system’s expected behavior.\n\n\nConsider being careful when coding tests to validate the expected behavior even on edge cases.\n\n\n***Update**: Fixed on [pull request 16](https://github.com/emptysetsquad/emptyset/pull/16/commits/90d70f56e08eab744ed505669980543abf599bba).*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/src/reserve/ReserveSwapper.sol",
      "content": "/*\n    Copyright 2021 Empty Set Squad <emptysetsquad@protonmail.com>\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport \"../Interfaces.sol\";\nimport \"./ReserveComptroller.sol\";\nimport \"./ReserveState.sol\";\n\n/**\n * @title ReserveSwapper\n * @notice Logic for managing outstanding limit orders, allow the reserve to swap its held tokens\n */\ncontract ReserveSwapper is ReentrancyGuard, ReserveComptroller {\n    using SafeMath for uint256;\n    using Decimal for Decimal.D256;\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Emitted when `amount` of the `makerToken`-`takerToken` order is registered with price `price`\n     */\n    event OrderRegistered(address indexed makerToken, address indexed takerToken, uint256 price, uint256 amount);\n\n    /**\n     * @notice Emitted when the reserve pays `takerAmount` of `takerToken` in exchange for `makerAmount` of `makerToken`\n     */\n    event Swap(address indexed makerToken, address indexed takerToken, uint256 takerAmount, uint256 makerAmount);\n\n    /**\n     * @notice Sets the `price` and `amount` of the specified `makerToken`-`takerToken` order\n     * @dev Owner only - governance hook\n     *      uint256(-1) indicates an unlimited order amount\n     * @param makerToken Token that the reserve wishes to sell\n     * @param takerToken Token that the reserve wishes to buy\n     * @param price Price as a ratio of takerAmount:makerAmount times 10^18\n     * @param amount Amount to decrement in ESD\n     */\n    function registerOrder(address makerToken, address takerToken, uint256 price, uint256 amount) external onlyOwner {\n        _updateOrder(makerToken, takerToken, price, amount);\n\n        emit OrderRegistered(makerToken, takerToken, price, amount);\n    }\n\n    /**\n     * @notice Purchases `makerToken` from the reserve in exchange for `takerAmount` of `takerToken`\n     * @dev Non-reentrant\n     *      Uses the state-defined price for the `makerToken`-`takerToken` order\n     *      Maker and taker tokens must be different\n     *      Cannot swap ESD\n     *      uint256(-1) indicates an unlimited order amount\n     * @param makerToken Token that the caller wishes to buy\n     * @param takerToken Token that the caller wishes to sell\n     * @param takerAmount Amount of takerToken to sell\n     */\n    function swap(address makerToken, address takerToken, uint256 takerAmount) external nonReentrant {\n        address dollar = registry().dollar();\n        require(makerToken != dollar, \"ReserveSwapper: unsupported token\");\n        require(takerToken != dollar, \"ReserveSwapper: unsupported token\");\n        require(makerToken != takerToken, \"ReserveSwapper: tokens equal\");\n\n        ReserveTypes.Order memory order = order(makerToken, takerToken);\n        uint256 makerAmount = Decimal.from(takerAmount).div(order.price, \"ReserveSwapper: no order\").asUint256();\n\n        if (order.amount != uint256(-1))\n            _decrementOrderAmount(makerToken, takerToken, makerAmount, \"ReserveSwapper: insufficient amount\");\n\n        _transferFrom(takerToken, msg.sender, address(this), takerAmount);\n        _transfer(makerToken, msg.sender, makerAmount);\n\n        emit Swap(makerToken, takerToken, takerAmount, makerAmount);\n    }\n}"
    },
    {
      "filename": "protocol/test/reserve/ReserveSwapper.test.js",
      "content": "const { accounts, contract } = require('@openzeppelin/test-environment');\n\nconst { BN, expectEvent, expectRevert } = require('@openzeppelin/test-helpers');\nconst { expect } = require('chai');\n\nconst MockToken = contract.fromArtifact('MockToken');\nconst Registry = contract.fromArtifact('Registry');\nconst MockReserveSwapper = contract.fromArtifact('MockReserveSwapper');\n\nconst ONE_BIP = new BN(10).pow(new BN(14));\nconst ONE_UNIT = ONE_BIP.mul(new BN(10000));\nconst MAX_256 = new BN(2).pow(new BN(256)).sub(new BN(1));\n\ndescribe('ReserveSwapper', function () {\n  const [ ownerAddress, userAddress ] = accounts;\n\n  beforeEach(async function () {\n    this.registry = await Registry.new({from: ownerAddress});\n    this.tokenA = await MockToken.new(\"Empty Set Dollar\", \"ESD\", 18, {from: ownerAddress});\n    this.tokenB = await MockToken.new(\"USD//C\", \"USDC\", 6, {from: ownerAddress});\n    this.swapper = await MockReserveSwapper.new({from: ownerAddress});\n    await this.swapper.takeOwnership({from: ownerAddress});\n    await this.swapper.setRegistry(this.registry.address, {from: ownerAddress});\n  });\n\n  describe('registerOrder', function () {\n    describe('basic set', function () {\n      beforeEach(async function () {\n        this.result = await this.swapper.registerOrder(\n          this.tokenA.address,\n          this.tokenB.address,\n          ONE_BIP.mul(new BN(10000)),\n          ONE_BIP.mul(new BN(10000)).mul(new BN(1000)),\n          {from: ownerAddress});\n        this.txHash = this.result.tx;\n      });\n\n      it('lists order', async function () {\n        const order = await this.swapper.order(this.tokenA.address, this.tokenB.address);\n        expect(order.price.value).to.be.bignumber.equal(ONE_BIP.mul(new BN(10000)));\n        expect(order.amount).to.be.bignumber.equal(ONE_UNIT.mul(new BN(1000)));\n      });\n\n      it('emits OrderRegistered event', async function () {\n        const event = await expectEvent.inTransaction(this.txHash, MockReserveSwapper, 'OrderRegistered', {\n          makerToken: this.tokenA.address,\n          takerToken: this.tokenB.address,\n        });\n\n        expect(event.args.price).to.be.bignumber.equal(ONE_BIP.mul(new BN(10000)));\n        expect(event.args.amount).to.be.bignumber.equal(ONE_UNIT.mul(new BN(1000)));\n      });\n    });\n\n    describe('reset', function () {\n      beforeEach(async function () {\n        await this.swapper.registerOrder(\n          this.tokenA.address,\n          this.tokenB.address,\n          ONE_BIP.mul(new BN(10000)),\n          ONE_UNIT.mul(new BN(1000)),\n          {from: ownerAddress});\n        this.result = await this.swapper.registerOrder(\n          this.tokenA.address,\n          this.tokenB.address,\n          ONE_BIP.mul(new BN(11000)),\n          ONE_UNIT.mul(new BN(2000)),\n          {from: ownerAddress});\n        this.txHash = this.result.tx;\n      });\n\n      it('lists order', async function () {\n        const order = await this.swapper.order(this.tokenA.address, this.tokenB.address);\n        expect(order.price.value).to.be.bignumber.equal(ONE_BIP.mul(new BN(11000)));\n        expect(order.amount).to.be.bignumber.equal(ONE_UNIT.mul(new BN(2000)));\n      });\n\n      it('emits OrderRegistered event', async function () {\n        const event = await expectEvent.inTransaction(this.txHash, MockReserveSwapper, 'OrderRegistered', {\n          makerToken: this.tokenA.address,\n          takerToken: this.tokenB.address,\n        });\n\n        expect(event.args.price).to.be.bignumber.equal(ONE_BIP.mul(new BN(11000)));\n        expect(event.args.amount).to.be.bignumber.equal(ONE_UNIT.mul(new BN(2000)));\n      });\n    });\n\n    describe('not owner', function () {\n      it('reverts', async function () {\n        await expectRevert(this.swapper.registerOrder(\n          this.tokenA.address,\n          this.tokenB.address,\n          ONE_BIP.mul(new BN(10000)),\n          ONE_UNIT.mul(new BN(1000)),\n          {from: userAddress}), \"Implementation: not owner\");\n      });\n    });\n  });\n\n  describe('swap', function () {\n    beforeEach(async function () {\n      await this.swapper.registerOrder(\n        this.tokenB.address,\n        this.tokenA.address,\n        ONE_BIP.mul(new BN(11000)),\n        ONE_UNIT.mul(new BN(1000)),\n        {from: ownerAddress});\n      await this.tokenA.mint(userAddress, ONE_UNIT.mul(new BN(100000)));\n      await this.tokenA.approve(this.swapper.address, ONE_UNIT.mul(new BN(100000)), {from: userAddress});\n      await this.tokenB.mint(this.swapper.address, ONE_UNIT.mul(new BN(100000)));\n    });\n\n    describe('simple swap', function () {\n      beforeEach(async function () {\n        this.result = await this.swapper.swap(\n          this.tokenB.address,\n          this.tokenA.address,\n          ONE_UNIT.mul(new BN(1100)),\n          {from: userAddress});\n        this.txHash = this.result.tx;\n      });\n\n      it('performs swap', async function () {\n        expect(await this.tokenB.balanceOf(userAddress)).to.be.bignumber.equal(ONE_UNIT.mul(new BN(1000)));\n        expect(await this.tokenB.balanceOf(this.swapper.address)).to.be.bignumber.equal(ONE_UNIT.mul(new BN(99000)));\n        expect(await this.tokenA.balanceOf(userAddress)).to.be.bignumber.equal(ONE_UNIT.mul(new BN(98900)));\n        expect(await this.tokenA.balanceOf(this.swapper.address)).to.be.bignumber.equal(ONE_UNIT.mul(new BN(1100)));\n\n        const order = await this.swapper.order(this.tokenB.address, this.tokenA.address);\n        expect(order.price.value).to.be.bignumber.equal(ONE_BIP.mul(new BN(11000)));\n        expect(order.amount).to.be.bignumber.equal(ONE_UNIT.mul(new BN(0)));\n      });\n\n      it('emits Swap event', async function () {\n        const event = await expectEvent.inTransaction(this.txHash, MockReserveSwapper, 'Swap', {\n          makerToken: this.tokenB.address,\n          takerToken: this.tokenA.address,\n        });\n\n        expect(event.args.takerAmount).to.be.bignumber.equal(ONE_UNIT.mul(new BN(1100)));\n        expect(event.args.makerAmount).to.be.bignumber.equal(ONE_UNIT.mul(new BN(1000)));\n      });\n    });\n\n    describe('above amount limit', function () {\n      it('reverts', async function () {\n        await expectRevert(this.swapper.swap(\n          this.tokenB.address,\n          this.tokenA.address,\n          ONE_UNIT.mul(new BN(1200)),\n          {from: userAddress}), \"ReserveSwapper: insufficient amount\");\n      });\n    });\n\n    describe('aggr above amount limit', function () {\n      beforeEach(async function () {\n        await this.swapper.swap(\n          this.tokenB.address,\n          this.tokenA.address,\n          ONE_UNIT.mul(new BN(600)),\n          {from: userAddress});\n      });\n\n      it('displays', async function () {\n        const order = await this.swapper.order(this.tokenB.address, this.tokenA.address);\n        expect(order.price.value).to.be.bignumber.equal(ONE_BIP.mul(new BN(11000)));\n        expect(order.amount).to.be.bignumber.equal(new BN(\"454545454545454545455\"));\n      });\n\n      it('reverts', async function () {\n        await expectRevert(this.swapper.swap(\n          this.tokenB.address,\n          this.tokenA.address,\n          ONE_UNIT.mul(new BN(600)),\n          {from: userAddress}), \"ReserveSwapper: insufficient amount\");\n      });\n    });\n\n    describe('infinite amount', function () {\n      beforeEach(async function () {\n        await this.swapper.registerOrder(\n          this.tokenB.address,\n          this.tokenA.address,\n          ONE_BIP.mul(new BN(11000)),\n          MAX_256,\n          {from: ownerAddress});\n        await this.swapper.swap(\n          this.tokenB.address,\n          this.tokenA.address,\n          ONE_UNIT.mul(new BN(1100)),\n          {from: userAddress});\n      });\n\n      it('displays', async function () {\n        const order = await this.swapper.order(this.tokenB.address, this.tokenA.address);\n        expect(order.price.value).to.be.bignumber.equal(ONE_BIP.mul(new BN(11000)));\n        expect(order.amount).to.be.bignumber.equal(MAX_256);\n      });\n    });\n  });\n});"
    },
    {
      "filename": "protocol/contracts/src/reserve/ReserveSwapper.sol",
      "content": "/*\n    Copyright 2021 Empty Set Squad <emptysetsquad@protonmail.com>\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport \"../Interfaces.sol\";\nimport \"./ReserveComptroller.sol\";\nimport \"./ReserveState.sol\";\n\n/**\n * @title ReserveSwapper\n * @notice Logic for managing outstanding limit orders, allow the reserve to swap its held tokens\n */\ncontract ReserveSwapper is ReentrancyGuard, ReserveComptroller {\n    using SafeMath for uint256;\n    using Decimal for Decimal.D256;\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Emitted when `amount` of the `makerToken`-`takerToken` order is registered with price `price`\n     */\n    event OrderRegistered(address indexed makerToken, address indexed takerToken, uint256 price, uint256 amount);\n\n    /**\n     * @notice Emitted when the reserve pays `takerAmount` of `takerToken` in exchange for `makerAmount` of `makerToken`\n     */\n    event Swap(address indexed makerToken, address indexed takerToken, uint256 takerAmount, uint256 makerAmount);\n\n    /**\n     * @notice Sets the `price` and `amount` of the specified `makerToken`-`takerToken` order\n     * @dev Owner only - governance hook\n     *      uint256(-1) indicates an unlimited order amount\n     * @param makerToken Token that the reserve wishes to sell\n     * @param takerToken Token that the reserve wishes to buy\n     * @param price Price as a ratio of takerAmount:makerAmount times 10^18\n     * @param amount Amount to decrement in ESD\n     */\n    function registerOrder(address makerToken, address takerToken, uint256 price, uint256 amount) external onlyOwner {\n        _updateOrder(makerToken, takerToken, price, amount);\n\n        emit OrderRegistered(makerToken, takerToken, price, amount);\n    }\n\n    /**\n     * @notice Purchases `makerToken` from the reserve in exchange for `takerAmount` of `takerToken`\n     * @dev Non-reentrant\n     *      Uses the state-defined price for the `makerToken`-`takerToken` order\n     *      Maker and taker tokens must be different\n     *      Cannot swap ESD\n     *      uint256(-1) indicates an unlimited order amount\n     * @param makerToken Token that the caller wishes to buy\n     * @param takerToken Token that the caller wishes to sell\n     * @param takerAmount Amount of takerToken to sell\n     */\n    function swap(address makerToken, address takerToken, uint256 takerAmount) external nonReentrant {\n        address dollar = registry().dollar();\n        require(makerToken != dollar, \"ReserveSwapper: unsupported token\");\n        require(takerToken != dollar, \"ReserveSwapper: unsupported token\");\n        require(makerToken != takerToken, \"ReserveSwapper: tokens equal\");\n\n        ReserveTypes.Order memory order = order(makerToken, takerToken);\n        uint256 makerAmount = Decimal.from(takerAmount).div(order.price, \"ReserveSwapper: no order\").asUint256();\n\n        if (order.amount != uint256(-1))\n            _decrementOrderAmount(makerToken, takerToken, makerAmount, \"ReserveSwapper: insufficient amount\");\n\n        _transferFrom(takerToken, msg.sender, address(this), takerAmount);\n        _transfer(makerToken, msg.sender, makerAmount);\n\n        emit Swap(makerToken, takerToken, takerAmount, makerAmount);\n    }\n}"
    }
  ]
}