{
  "Title": "[G-03] State variables can be packed into fewer storage slots",
  "Content": "The EVM works with 32 byte words. Variables less than 32 bytes can be declared next to eachother in storage and this will pack the values together into a single 32 byte storage slot (if the values combined are <= 32 bytes). If the variables packed together are retrieved together in functions, we will effectively save ~2000 gas with every subsequent SLOAD for that storage slot. This is due to us incurring a `Gwarmaccess (100 gas)` versus a `Gcoldsload (2100 gas)`.\n\nTotal Instances: `5`\n\nEstimated Gas Saved: `11 (slots) * 2000 = 22000`\n\n<details>\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/miner/EUSDMiningIncentives.sol#L38-L57\n\n### Pack `finishAt`, `updatedAt`, `extraRatio`, `preUSDExtraRatio`, `biddingFeeRatio`, and `isEUSDBuyoutAllowed` into one storage slot to save 4 SLOTs (~8000 gas)\n\n*Note: `finishAt` and `updatedAt` hold timestamps, and therefore, a `unit` type of `uint40` should be big enough to hold those values. `extraRatio`, `preUSDExtraRatio`, and `biddingFeeRatio` are all enforced to have a max upper bounds and can be reduced to a lower `uint` type that can hold those max values (see Diff below).*\n```solidity\nFile: contracts/lybra/miner/EUSDMiningIncentives.sol\n38:    uint256 public finishAt;\n39:    // Minimum of last updated time and reward finish time\n40:    uint256 public updatedAt;\n41:    // Reward to be paid out per second\n42:    uint256 public rewardRatio;\n43:    // Sum of (reward ratio * dt * 1e18 / total supply)\n44:    uint256 public rewardPerTokenStored;\n45:    // User address => rewardPerTokenStored\n46:    mapping(address => uint256) public userRewardPerTokenPaid;\n47:    // User address => rewards to be claimed\n48:    mapping(address => uint256) public rewards;\n49:    mapping(address => uint256) public userUpdatedAt;\n50:    uint256 public extraRatio = 50 * 1e18;\n51:    uint256 public peUSDExtraRatio = 10 * 1e18;\n52:    uint256 public biddingFeeRatio = 3000;\n53:    address public ethlbrStakePool;\n54:    address public ethlbrLpToken;\n55:    AggregatorV3Interface internal etherPriceFeed;\n56:    AggregatorV3Interface internal lbrPriceFeed;\n57:    bool public isEUSDBuyoutAllowed = true;\n```\n```diff\ndiff --git a/lybra/miner/EUSDMiningIncentives.sol b/lybra/miner/EUSDMiningIncentives.sol\nindex e6c57c8..173fc87 100644\n--- a/lybra/miner/EUSDMiningIncentives.sol\n+++ b/lybra/miner/EUSDMiningIncentives.sol\n@@ -34,26 +34,26 @@ contract EUSDMiningIncentives is Ownable {\n\n     // Duration of rewards to be paid out (in seconds)\n     uint256 public duration = 2_592_000;\n-    // Timestamp of when the rewards finish\n-    uint256 public finishAt;\n-    // Minimum of last updated time and reward finish time\n-    uint256 public updatedAt;\n     // Reward to be paid out per second\n     uint256 public rewardRatio;\n     // Sum of (reward ratio * dt * 1e18 / total supply)\n     uint256 public rewardPerTokenStored;\n+    address public ethlbrStakePool;\n+    address public ethlbrLpToken;\n+    AggregatorV3Interface internal etherPriceFeed;\n+    AggregatorV3Interface internal lbrPriceFeed;\n     // User address => rewardPerTokenStored\n     mapping(address => uint256) public userRewardPerTokenPaid;\n     // User address => rewards to be claimed\n     mapping(address => uint256) public rewards;\n     mapping(address => uint256) public userUpdatedAt;\n-    uint256 public extraRatio = 50 * 1e18;\n-    uint256 public peUSDExtraRatio = 10 * 1e18;\n-    uint256 public biddingFeeRatio = 3000;\n-    address public ethlbrStakePool;\n-    address public ethlbrLpToken;\n-    AggregatorV3Interface internal etherPriceFeed;\n-    AggregatorV3Interface internal lbrPriceFeed;\n+    uint72 public extraRatio = 50 * 1e18;\n+    uint72 public peUSDExtraRatio = 10 * 1e18;\n+    uint16 public biddingFeeRatio = 3000;\n+    // Timestamp of when the rewards finish\n+    uint40 public finishAt;\n+    // Minimum of last updated time and reward finish time\n+    uint40 public updatedAt;\n     bool public isEUSDBuyoutAllowed = true;\n\n     event ClaimReward(address indexed user, uint256 amount, uint256 time);\n@@ -71,7 +71,7 @@ contract EUSDMiningIncentives is Ownable {\n\n     modifier updateReward(address _account) {\n         rewardPerTokenStored = rewardPerToken();\n-        updatedAt = lastTimeRewardApplicable();\n+        updatedAt = uint40(lastTimeRewardApplicable());\n\n         if (_account != address(0)) {\n             rewards[_account] = earned(_account);\n@@ -99,17 +99,17 @@ contract EUSDMiningIncentives is Ownable {\n\n     function setBiddingCost(uint256 _biddingRatio) external onlyOwner {\n         require(_biddingRatio <= 8000, \"BCE\");\n-        biddingFeeRatio = _biddingRatio;\n+        biddingFeeRatio = uint16(_biddingRatio);\n     }\n\n     function setExtraRatio(uint256 ratio) external onlyOwner {\n         require(ratio <= 1e20, \"BCE\");\n-        extraRatio = ratio;\n+        extraRatio = uint72(ratio);\n     }\n\n     function setPeUSDExtraRatio(uint256 ratio) external onlyOwner {\n         require(ratio <= 1e20, \"BCE\");\n-        peUSDExtraRatio = ratio;\n+        peUSDExtraRatio = uint72(ratio);\n     }\n\n     function setBoost(address _boost) external onlyOwner {\n@@ -236,8 +236,8 @@ contract EUSDMiningIncentives is Ownable {\n\n         require(rewardRatio > 0, \"reward ratio = 0\");\n\n-        finishAt = block.timestamp + duration;\n-        updatedAt = block.timestamp;\n+        finishAt = uint40(block.timestamp + duration);\n+        updatedAt = uint40(block.timestamp);\n         emit NotifyRewardChanged(amount, block.timestamp);\n     }\n```\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/configuration/LybraConfigurator.sol#L49-L61\n\n### Pack `redemptionFee`, `flashLoanFee`, `maxStableRatio`, `curvePool`, and `premiumTradingEnabled` into one storage slot to save 3 SLOTs (~6000 gas)\n\n*Note: `redemptionFee`, `flashLoanFee`, and `maxStableRatio` are all enforced to have a max upper bounds and can each fit into a type `uint16`.*\n```solidity\nFile: contracts/lybra/configuration/LybraConfigurator.sol\n49:    uint256 public redemptionFee = 50;\n50:    IGovernanceTimelock public GovernanceTimelock;\n51:\n52:    IeUSDMiningIncentives public eUSDMiningIncentives;\n53:    IProtocolRewardsPool public lybraProtocolRewardsPool;\n54:    IEUSD public EUSD;\n55:    IEUSD public peUSD;\n56:    uint256 public flashloanFee = 500;\n57:    // Limiting the maximum percentage of eUSD that can be cross-chain transferred to L2 in relation to the total supply.\n58:    uint256 maxStableRatio = 5_000;\n59:    address public stableToken;\n60:    ICurvePool public curvePool;\n61:    bool public premiumTradingEnabled;\n```\n```diff\ndiff --git a/lybra/configuration/LybraConfigurator.sol b/lybra/configuration/LybraConfigurator.sol\nindex c36e452..1cdc773 100644\n--- a/lybra/configuration/LybraConfigurator.sol\n+++ b/lybra/configuration/LybraConfigurator.sol\n@@ -46,18 +46,18 @@ contract Configurator {\n     mapping(address => bool) redemptionProvider;\n     mapping(address => bool) public tokenMiner;\n\n-    uint256 public redemptionFee = 50;\n     IGovernanceTimelock public GovernanceTimelock;\n\n     IeUSDMiningIncentives public eUSDMiningIncentives;\n     IProtocolRewardsPool public lybraProtocolRewardsPool;\n     IEUSD public EUSD;\n     IEUSD public peUSD;\n-    uint256 public flashloanFee = 500;\n     // Limiting the maximum percentage of eUSD that can be cross-chain transferred to L2 in relation to the total supply.\n-    uint256 maxStableRatio = 5_000;\n     address public stableToken;\n     ICurvePool public curvePool;\n+    uint16 public redemptionFee = 50;\n+    uint16 public flashloanFee = 500;\n+    uint16 maxStableRatio = 5_000;\n     bool public premiumTradingEnabled;\n\n     event RedemptionFeeChanged(uint256 newSlippage);\n@@ -185,7 +185,7 @@ contract Configurator {\n      */\n     function setRedemptionFee(uint256 newFee) external checkRole(TIMELOCK) {\n         require(newFee <= 500, \"Max Redemption Fee is 5%\");\n-        redemptionFee = newFee;\n+        redemptionFee = uint16(newFee);\n         emit RedemptionFeeChanged(newFee);\n     }\n\n@@ -245,7 +245,7 @@ contract Configurator {\n      */\n     function setMaxStableRatio(uint256 _ratio) external checkRole(TIMELOCK) {\n         require(_ratio <= 10_000, \"The maximum value is 10000\");\n-        maxStableRatio = _ratio;\n+        maxStableRatio = uint16(_ratio);\n     }\n\n     /// @notice Update the flashloan fee percentage, only available to the manager of the contract\n@@ -253,7 +253,7 @@ contract Configurator {\n     function setFlashloanFee(uint256 fee) external checkRole(TIMELOCK) {\n         if (fee > 10_000) revert('EL');\n         emit FlashloanFeeUpdated(fee);\n-        flashloanFee = fee;\n+        flashloanFee = uint16(fee);\n     }\n```\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/miner/ProtocolRewardsPool.sol#L27-L41\n\n### Pack `LBR` and `grabFeeRatio` into one storage slot to save 1 SLOT (~2000 gas)\n\n*Note: `grabFeeRatio` has a max upper bound, and therefore, its `uint` size can be reduced to a lower size so that it can be packed with an address (160 bits).*\n```solidity\nFile: contracts/lybra/miner/ProtocolRewardsPool.sol\n27:    IesLBR public LBR;\n28:    IesLBRBoost public esLBRBoost;\n29:\n30:    // Sum of (reward ratio * dt * 1e18 / total supply)\n31:    uint public rewardPerTokenStored;\n32:    // User address => rewardPerTokenStored\n33:    mapping(address => uint) public userRewardPerTokenPaid;\n34:    // User address => rewards to be claimed\n35:    mapping(address => uint) public rewards;\n36:    mapping(address => uint) public time2fullRedemption;\n37:    mapping(address => uint) public unstakeRatio;\n38:    mapping(address => uint) public lastWithdrawTime;\n39:    uint256 immutable exitCycle = 90 days;\n40:    uint256 public grabableAmount;\n41:    uint256 public grabFeeRatio = 3000;\n```\n```diff\ndiff --git a/lybra/miner/ProtocolRewardsPool.sol b/lybra/miner/ProtocolRewardsPool.sol\nindex 8fc83d6..738d7cd 100644\n--- a/lybra/miner/ProtocolRewardsPool.sol\n+++ b/lybra/miner/ProtocolRewardsPool.sol\n@@ -25,6 +25,7 @@ contract ProtocolRewardsPool is Ownable {\n     Iconfigurator public immutable configurator;\n     IesLBR public esLBR;\n     IesLBR public LBR;\n+    uint16 public grabFeeRatio = 3000;\n     IesLBRBoost public esLBRBoost;\n\n     // Sum of (reward ratio * dt * 1e18 / total supply)\n@@ -38,7 +39,6 @@ contract ProtocolRewardsPool is Ownable {\n     mapping(address => uint) public lastWithdrawTime;\n     uint256 immutable exitCycle = 90 days;\n     uint256 public grabableAmount;\n-    uint256 public grabFeeRatio = 3000;\n     event Restake(address indexed user, uint256 amount, uint256 time);\n     event StakeLBR(address indexed user, uint256 amount, uint256 time);\n     event UnstakeLBR(address indexed user, uint256 amount, uint256 time);\n@@ -57,7 +57,7 @@ contract ProtocolRewardsPool is Ownable {\n\n     function setGrabCost(uint256 _ratio) external onlyOwner {\n         require(_ratio <= 8000, \"BCE\");\n-        grabFeeRatio = _ratio;\n+        grabFeeRatio = uint16(_ratio);\n     }\n```\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/miner/stakerewardV2pool.sol#L20-L27\n\n### Pack `esLBRBoost`, `finishAt`, and `updatedAt` into one storage slot to save 2 SLOTs (~4000 gas)\n\n*Note: The `uint` type for `finishAt` and `updatedAt` can be reduced since these variables hold timestamps.*\n```solidity\nFile: contracts/lybra/miner/stakerewardV2Pool.sol\n20:    IesLBRBoost public esLBRBoost;\n21:\n22:\n23:    // Duration of rewards to be paid out (in seconds)\n24:    uint256 public duration = 2_592_000;\n25:    // Timestamp of when the rewards finish\n26:    uint256 public finishAt;\n27:    // Minimum of last updated time and reward finish time\n28:    uint256 public updatedAt;\n```\n```diff\ndiff --git a/lybra/miner/stakerewardV2pool.sol b/lybra/miner/stakerewardV2pool.sol\nindex 4c264dc..88b02e2 100644\n--- a/lybra/miner/stakerewardV2pool.sol\n+++ b/lybra/miner/stakerewardV2pool.sol\n@@ -18,13 +18,13 @@ contract StakingRewardsV2 is Ownable {\n     IERC20 public immutable stakingToken;\n     IesLBR public immutable rewardsToken;\n     IesLBRBoost public esLBRBoost;\n+    // Timestamp of when the rewards finish\n+    uint48 public finishAt;\n+    // Minimum of last updated time and reward finish time\n+    uint48 public updatedAt;\n\n     // Duration of rewards to be paid out (in seconds)\n     uint256 public duration = 2_592_000;\n-    // Timestamp of when the rewards finish\n-    uint256 public finishAt;\n-    // Minimum of last updated time and reward finish time\n-    uint256 public updatedAt;\n     // Reward to be paid out per second\n     uint256 public rewardRatio;\n     // Sum of (reward ratio * dt * 1e18 / total supply)\n@@ -55,7 +55,7 @@ contract StakingRewardsV2 is Ownable {\n     // Update user's claimable reward data and record the timestamp.\n     modifier updateReward(address _account) {\n         rewardPerTokenStored = rewardPerToken();\n-        updatedAt = lastTimeRewardApplicable();\n+        updatedAt = uint48(lastTimeRewardApplicable());\n\n         if (_account != address(0)) {\n             rewards[_account] = earned(_account);\n@@ -139,8 +139,8 @@ contract StakingRewardsV2 is Ownable {\n\n         require(rewardRatio > 0, \"reward ratio = 0\");\n\n-        finishAt = block.timestamp + duration;\n-        updatedAt = block.timestamp;\n+        finishAt = uint48(block.timestamp + duration);\n+        updatedAt = uint48(block.timestamp);\n         emit NotifyRewardChanged(_amount, block.timestamp);\n     }\n```\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/pools/LybraStETHVault.sol#L14\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/pools/base/LybraEUSDVaultBase.sol#L25\n\n*Note: This can only be done by rearranging so that the inherited storage slot is correct.*\n\n### Reduce `uint` types for `lidoRebaseTime` and `lastReportTime` and pack into a single storage slot to save 1 SLOT (~2000 gas)\n\n*Note: `LybraStEthVault` inherits from `LybraEUSDVaultBase` and therefore we can reduce the `uint` types for the above variables and reorganize the storage layout in `LybraEUSDVaultBase` in order to pack the variables together into one slot.*\n```solidity\nFile: contracts/lybra/pools/LybraStETHVault.sol\n14:    uint256 public lidoRebaseTime = 12 hours;\n```\n```solidity\nFile: contracts/lybra/pools/base/LybraEUSDVaultBase.sol\n25:    uint256 public lastReportTime;\n```\n```diff\ndiff --git a/lybra/pools/LybraStETHVault.sol b/lybra/pools/LybraStETHVault.sol\nindex 3f20843..863fa57 100644\n--- a/lybra/pools/LybraStETHVault.sol\n+++ b/lybra/pools/LybraStETHVault.sol\n@@ -11,7 +11,7 @@ interface Ilido {\n\n contract LybraStETHDepositVault is LybraEUSDVaultBase {\n     // Currently, the official rebase time for Lido is between 12PM to 13PM UTC.\n-    uint256 public lidoRebaseTime = 12 hours;\n+    uint128 public lidoRebaseTime = 12 hours;\n\n     // stETH = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84\n     // oracle = 0x4c517D4e2C851CA76d7eC94B805269Df0f2201De\n@@ -24,7 +24,7 @@ contract LybraStETHDepositVault is LybraEUSDVaultBase {\n      */\n     function setLidoRebaseTime(uint256 _time) external {\n         require(configurator.hasRole(keccak256(\"ADMIN\"), msg.sender), \"not authorized\");\n-        lidoRebaseTime = _time;\n+        lidoRebaseTime = uint128(_time);\n     }\n\n     /**\n@@ -89,7 +89,7 @@ contract LybraStETHDepositVault is LybraEUSDVaultBase {\n             emit FeeDistribution(address(configurator), payAmount, block.timestamp);\n         }\n\n-        lastReportTime = block.timestamp;\n+        lastReportTime = uint128(block.timestamp);\n         collateralAsset.transfer(msg.sender, realAmount);\n         emit LSDValueCaptured(realAmount, payAmount, getDutchAuctionDiscountPrice(), block.timestamp);\n     }\n```\n```diff\ndiff --git a/lybra/pools/base/LybraEUSDVaultBase.sol b/lybra/pools/base/LybraEUSDVaultBase.sol\nindex 7a8c439..204c34b 100644\n--- a/lybra/pools/base/LybraEUSDVaultBase.sol\n+++ b/lybra/pools/base/LybraEUSDVaultBase.sol\n@@ -22,7 +22,6 @@ abstract contract LybraEUSDVaultBase {\n     IPriceFeed immutable etherOracle;\n\n     uint256 public totalDepositedAsset;\n-    uint256 public lastReportTime;\n     uint256 public poolTotalEUSDCirculation;\n\n     mapping(address => uint256) public depositedAsset;\n@@ -30,6 +29,7 @@ abstract contract LybraEUSDVaultBase {\n     uint8 immutable vaultType = 0;\n     uint256 public feeStored;\n     mapping(address => uint256) depositedTime;\n+    uint128 public lastReportTime;\n\n     event DepositEther(address indexed onBehalfOf, address asset, uint256 etherAmount, uint256 assetAmount, uint256 timestamp);\n\n@@ -294,7 +294,7 @@ abstract contract LybraEUSDVaultBase {\n\n     function _saveReport() internal {\n         feeStored += _newFee();\n-        lastReportTime = block.timestamp;\n+        lastReportTime = uint128(block.timestamp);\n     }\n```\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-06-lybra",
  "Code": [
    {
      "filename": "contracts/lybra/miner/EUSDMiningIncentives.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n/**\n * @title tokenMiner is a stripped down version of Synthetix StakingRewards.sol, to reward esLBR to EUSD minters.\n * Differences from the original contract,\n * - Get `totalStaked` from totalSupply() in contract EUSD.\n * - Get `stakedOf(user)` from getBorrowedOf(user) in contract EUSD.\n * - When an address borrowed EUSD amount changes, call the refreshReward method to update rewards to be claimed.\n */\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/IesLBR.sol\";\nimport \"../interfaces/IEUSD.sol\";\nimport \"../interfaces/ILybra.sol\";\nimport \"../interfaces/Iconfigurator.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\ninterface IesLBRBoost {\n    function getUserBoost(\n        address user,\n        uint256 userUpdatedAt,\n        uint256 finishAt\n    ) external view returns (uint256);\n}\n\ncontract EUSDMiningIncentives is Ownable {\n    Iconfigurator public immutable configurator;\n    IesLBRBoost public esLBRBoost;\n    IEUSD public immutable EUSD;\n    address public esLBR;\n    address public LBR;\n    address[] public pools;\n\n    // Duration of rewards to be paid out (in seconds)\n    uint256 public duration = 2_592_000;\n    // Timestamp of when the rewards finish\n    uint256 public finishAt;\n    // Minimum of last updated time and reward finish time\n    uint256 public updatedAt;\n    // Reward to be paid out per second\n    uint256 public rewardRatio;\n    // Sum of (reward ratio * dt * 1e18 / total supply)\n    uint256 public rewardPerTokenStored;\n    // User address => rewardPerTokenStored\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    // User address => rewards to be claimed\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) public userUpdatedAt;\n    uint256 public extraRatio = 50 * 1e18;\n    uint256 public peUSDExtraRatio = 10 * 1e18;\n    uint256 public biddingFeeRatio = 3000;\n    address public ethlbrStakePool;\n    address public ethlbrLpToken;\n    AggregatorV3Interface internal etherPriceFeed;\n    AggregatorV3Interface internal lbrPriceFeed;\n    bool public isEUSDBuyoutAllowed = true;\n\n    event ClaimReward(address indexed user, uint256 amount, uint256 time);\n    event ClaimedOtherEarnings(address indexed user, address indexed Victim, uint256 buyAmount, uint256 biddingFee, bool useEUSD, uint256 time);\n    event NotifyRewardChanged(uint256 addAmount, uint256 time);\n\n    //etherOracle = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419\n    constructor(address _config, address _boost, address _etherOracle, address _lbrOracle) {\n        configurator = Iconfigurator(_config);\n        esLBRBoost = IesLBRBoost(_boost);\n        EUSD = IEUSD(configurator.getEUSDAddress());\n        etherPriceFeed = AggregatorV3Interface(_etherOracle);\n        lbrPriceFeed = AggregatorV3Interface(_lbrOracle);\n    }\n\n    modifier updateReward(address _account) {\n        rewardPerTokenStored = rewardPerToken();\n        updatedAt = lastTimeRewardApplicable();\n\n        if (_account != address(0)) {\n            rewards[_account] = earned(_account);\n            userRewardPerTokenPaid[_account] = rewardPerTokenStored;\n            userUpdatedAt[_account] = block.timestamp;\n        }\n        _;\n    }\n\n    function setToken(address _lbr, address _eslbr) external onlyOwner {\n        LBR = _lbr;\n        esLBR = _eslbr;\n    }\n\n    function setLBROracle(address _lbrOracle) external onlyOwner {\n        lbrPriceFeed = AggregatorV3Interface(_lbrOracle);\n    }\n\n    function setPools(address[] memory _pools) external onlyOwner {\n        for (uint i = 0; i < _pools.length; i++) {\n            require(configurator.mintVault(_pools[i]), \"NOT_VAULT\");\n        }\n        pools = _pools;\n    }\n\n    function setBiddingCost(uint256 _biddingRatio) external onlyOwner {\n        require(_biddingRatio <= 8000, \"BCE\");\n        biddingFeeRatio = _biddingRatio;\n    }\n\n    function setExtraRatio(uint256 ratio) external onlyOwner {\n        require(ratio <= 1e20, \"BCE\");\n        extraRatio = ratio;\n    }\n\n    function setPeUSDExtraRatio(uint256 ratio) external onlyOwner {\n        require(ratio <= 1e20, \"BCE\");\n        peUSDExtraRatio = ratio;\n    }\n\n    function setBoost(address _boost) external onlyOwner {\n        esLBRBoost = IesLBRBoost(_boost);\n    }\n\n    function setRewardsDuration(uint256 _duration) external onlyOwner {\n        require(finishAt < block.timestamp, \"reward duration not finished\");\n        duration = _duration;\n    }\n\n    function setEthlbrStakeInfo(address _pool, address _lp) external onlyOwner {\n        ethlbrStakePool = _pool;\n        ethlbrLpToken = _lp;\n    }\n    function setEUSDBuyoutAllowed(bool _bool) external onlyOwner {\n        isEUSDBuyoutAllowed = _bool;\n    }\n\n    function totalStaked() internal view returns (uint256) {\n        return EUSD.totalSupply();\n    }\n\n    function stakedOf(address user) public view returns (uint256) {\n        uint256 amount;\n        for (uint i = 0; i < pools.length; i++) {\n            ILybra pool = ILybra(pools[i]);\n            uint borrowed = pool.getBorrowedOf(user);\n            if (pool.getVaultType() == 1) {\n                borrowed = borrowed * (1e20 + peUSDExtraRatio) / 1e20;\n            }\n            amount += borrowed;\n        }\n        return amount;\n    }\n\n    function stakedLBRLpValue(address user) public view returns (uint256) {\n        uint256 totalLp = IEUSD(ethlbrLpToken).totalSupply();\n        (, int etherPrice, , , ) = etherPriceFeed.latestRoundData();\n        (, int lbrPrice, , , ) = lbrPriceFeed.latestRoundData();\n        uint256 etherInLp = (IEUSD(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).balanceOf(ethlbrLpToken) * uint(etherPrice)) / 1e8;\n        uint256 lbrInLp = (IEUSD(LBR).balanceOf(ethlbrLpToken) * uint(lbrPrice)) / 1e8;\n        uint256 userStaked = IEUSD(ethlbrStakePool).balanceOf(user);\n        return (userStaked * (lbrInLp + etherInLp)) / totalLp;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return _min(finishAt, block.timestamp);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalStaked() == 0) {\n            return rewardPerTokenStored;\n        }\n\n        return rewardPerTokenStored + (rewardRatio * (lastTimeRewardApplicable() - updatedAt) * 1e18) / totalStaked();\n    }\n\n    /**\n     * @notice Update user's claimable reward data and record the timestamp.\n     */\n    function refreshReward(address _account) external updateReward(_account) {}\n\n    function getBoost(address _account) public view returns (uint256) {\n        uint256 redemptionBoost;\n        if (configurator.isRedemptionProvider(_account)) {\n            redemptionBoost = extraRatio;\n        }\n        return 100 * 1e18 + redemptionBoost + esLBRBoost.getUserBoost(_account, userUpdatedAt[_account], finishAt);\n    }\n\n    function earned(address _account) public view returns (uint256) {\n        return ((stakedOf(_account) * getBoost(_account) * (rewardPerToken() - userRewardPerTokenPaid[_account])) / 1e38) + rewards[_account];\n    }\n\n    function isOtherEarningsClaimable(address user) public view returns (bool) {\n        return (stakedLBRLpValue(user) * 10000) / stakedOf(user) < 500;\n    }\n\n    function getReward() external updateReward(msg.sender) {\n        require(!isOtherEarningsClaimable(msg.sender), \"Insufficient DLP, unable to claim rewards\");\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            IesLBR(esLBR).mint(msg.sender, reward);\n            emit ClaimReward(msg.sender, reward, block.timestamp);\n        }\n    }\n\n    function purchaseOtherEarnings(address user, bool useEUSD) external updateReward(user) {\n        require(isOtherEarningsClaimable(user), \"The rewards of the user cannot be bought out\");\n        if(useEUSD) {\n            require(isEUSDBuyoutAllowed, \"The purchase using EUSD is not permitted.\");\n        }\n        uint256 reward = rewards[user];\n        if (reward > 0) {\n            rewards[user] = 0;\n            uint256 biddingFee = (reward * biddingFeeRatio) / 10000;\n            if(useEUSD) {\n                (, int lbrPrice, , , ) = lbrPriceFeed.latestRoundData();\n                biddingFee = biddingFee * uint256(lbrPrice) / 1e8;\n                bool success = EUSD.transferFrom(msg.sender, address(configurator), biddingFee);\n                require(success, \"TF\");\n                try configurator.distributeRewards() {} catch {}\n            } else {\n                IesLBR(LBR).burn(msg.sender, biddingFee);\n            }\n            IesLBR(esLBR).mint(msg.sender, reward);\n\n            emit ClaimedOtherEarnings(msg.sender, user, reward, biddingFee, useEUSD, block.timestamp);\n        }\n    }\n\n    function notifyRewardAmount(\n        uint256 amount\n    ) external onlyOwner updateReward(address(0)) {\n        require(amount > 0, \"amount = 0\");\n        if (block.timestamp >= finishAt) {\n            rewardRatio = amount / duration;\n        } else {\n            uint256 remainingRewards = (finishAt - block.timestamp) * rewardRatio;\n            rewardRatio = (amount + remainingRewards) / duration;\n        }\n\n        require(rewardRatio > 0, \"reward ratio = 0\");\n\n        finishAt = block.timestamp + duration;\n        updatedAt = block.timestamp;\n        emit NotifyRewardChanged(amount, block.timestamp);\n    }\n\n    function _min(uint256 x, uint256 y) private pure returns (uint256) {\n        return x <= y ? x : y;\n    }\n}"
    },
    {
      "filename": "contracts/lybra/configuration/LybraConfigurator.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**\n * @title Lybra Protocol V2 Configurator Contract\n * @dev The Configurator contract is used to set various parameters and control functionalities of the Lybra Protocol. It is based on OpenZeppelin's Proxy and AccessControl libraries, allowing the DAO to control contract upgrades. There are three types of governance roles:\n * * DAO: A time-locked contract initiated by esLBR voting, with a minimum effective period of 14 days. After the vote is passed, only the developer can execute the action.\n * * TIMELOCK: A time-locked contract controlled by the developer, with a minimum effective period of 2 days.\n * * ADMIN: A multisignature account controlled by the developer.\n * All setting functions have three levels of calling permissions:\n * * onlyRole(DAO): Only callable by the DAO for governance purposes.\n * * checkRole(TIMELOCK): Callable by both the DAO and the TIMELOCK contract.\n * * checkRole(ADMIN): Callable by all governance roles.\n */\n\npragma solidity ^0.8.17;\n\nimport \"../interfaces/IGovernanceTimelock.sol\";\nimport \"../interfaces/IEUSD.sol\";\n\ninterface IProtocolRewardsPool {\n    function notifyRewardAmount(uint256 amount, uint256 tokenType) external;\n}\n\ninterface IeUSDMiningIncentives {\n    function refreshReward(address user) external;\n}\n\ninterface IVault {\n    function vaultType() external view returns (uint8);\n}\n\ninterface ICurvePool{\n    function get_dy_underlying(int128 i, int128 j, uint256 dx) external view returns (uint256);\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy) external returns(uint256);\n}\n\ncontract Configurator {\n    mapping(address => bool) public mintVault;\n    mapping(address => uint256) public mintVaultMaxSupply;\n    mapping(address => bool) public vaultMintPaused;\n    mapping(address => bool) public vaultBurnPaused;\n    mapping(address => uint256) vaultSafeCollateralRatio;\n    mapping(address => uint256) vaultBadCollateralRatio;\n    mapping(address => uint256) public vaultMintFeeApy;\n    mapping(address => uint256) public vaultKeeperRatio;\n    mapping(address => bool) redemptionProvider;\n    mapping(address => bool) public tokenMiner;\n\n    uint256 public redemptionFee = 50;\n    IGovernanceTimelock public GovernanceTimelock;\n\n    IeUSDMiningIncentives public eUSDMiningIncentives;\n    IProtocolRewardsPool public lybraProtocolRewardsPool;\n    IEUSD public EUSD;\n    IEUSD public peUSD;\n    uint256 public flashloanFee = 500;\n    // Limiting the maximum percentage of eUSD that can be cross-chain transferred to L2 in relation to the total supply.\n    uint256 maxStableRatio = 5_000;\n    address public stableToken;\n    ICurvePool public curvePool;\n    bool public premiumTradingEnabled;\n\n    event RedemptionFeeChanged(uint256 newSlippage);\n    event SafeCollateralRatioChanged(address indexed pool, uint256 newRatio);\n    event RedemptionProvider(address indexed user, bool status);\n    event ProtocolRewardsPoolChanged(address indexed pool, uint256 timestamp);\n    event EUSDMiningIncentivesChanged(address indexed pool, uint256 timestamp);\n    event BorrowApyChanged(address indexed pool, uint256 newApy);\n    event KeeperRatioChanged(address indexed pool, uint256 newSlippage);\n    event tokenMinerChanges(address indexed pool, bool status);\n\n    /// @notice Emitted when the fees for flash loaning a token have been updated\n    /// @param fee The new fee for this token as a percentage and multiplied by 100 to avoid decimals (for example, 10% is 10_00)\n    event FlashloanFeeUpdated(uint256 fee);\n\n    bytes32 public constant DAO = keccak256(\"DAO\");\n    bytes32 public constant TIMELOCK = keccak256(\"TIMELOCK\");\n    bytes32 public constant ADMIN = keccak256(\"ADMIN\");\n\n    constructor(address _dao, address _curvePool) {\n        GovernanceTimelock = IGovernanceTimelock(_dao);\n        curvePool = ICurvePool(_curvePool);\n    }\n\n    modifier onlyRole(bytes32 role) {\n        GovernanceTimelock.checkOnlyRole(role, msg.sender);\n        _;\n    }\n\n    modifier checkRole(bytes32 role) {\n        GovernanceTimelock.checkRole(role, msg.sender);\n        _;\n    }\n\n    /**\n     * @notice Initializes the eUSD and peUSD address. This function can only be executed once.\n     */\n    function initToken(address _eusd, address _peusd) external onlyRole(DAO) {\n        if (address(EUSD) == address(0)) EUSD = IEUSD(_eusd);\n        if (address(peUSD) == address(0)) peUSD = IEUSD(_peusd);\n    }\n\n    /**\n     * @notice Controls the activation of a specific eUSD vault.\n     * @param pool The address of the asset pool.\n     * @param isActive A boolean indicating whether to activate or deactivate the vault.\n     * @dev This function can only be called by the DAO.\n     */\n    function setMintVault(address pool, bool isActive) external onlyRole(DAO) {\n        mintVault[pool] = isActive;\n    }\n\n    /**\n     * @notice Controls the minting limit of eUSD for an asset pool.\n     * @param pool The address of the asset pool.\n     * @param maxSupply The maximum amount of eUSD that can be minted for the asset pool.\n     * @dev This function can only be called by the DAO.\n     */\n    function setMintVaultMaxSupply(address pool, uint256 maxSupply) external onlyRole(DAO) {\n        mintVaultMaxSupply[pool] = maxSupply;\n    }\n\n    /**\n     * @notice  badCollateralRatio can be decided by DAO,starts at 130%\n     */\n    function setBadCollateralRatio(address pool, uint256 newRatio) external onlyRole(DAO) {\n        require(newRatio >= 130 * 1e18 && newRatio <= 150 * 1e18 && newRatio <= vaultSafeCollateralRatio[pool] + 1e19, \"LNA\");\n        vaultBadCollateralRatio[pool] = newRatio;\n        emit SafeCollateralRatioChanged(pool, newRatio);\n    }\n\n    /**\n     * @notice Sets the address of the protocol rewards pool.\n     * @param addr The new address of the protocol rewards pool.\n     * @dev This function can only be called by accounts with TIMELOCK or higher privilege.\n     */\n    function setProtocolRewardsPool(address addr) external checkRole(TIMELOCK) {\n        lybraProtocolRewardsPool = IProtocolRewardsPool(addr);\n        emit ProtocolRewardsPoolChanged(addr, block.timestamp);\n    }\n\n    /**\n     * @notice Sets the address of the eUSDMiningIncentives pool.\n     * @param addr The new address of the eUSDMiningIncentives pool.\n     * @dev This function can only be called by accounts with TIMELOCK or higher privilege.\n     */\n    function setEUSDMiningIncentives(address addr) external checkRole(TIMELOCK) {\n        eUSDMiningIncentives = IeUSDMiningIncentives(addr);\n        emit EUSDMiningIncentivesChanged(addr, block.timestamp);\n    }\n\n    /**\n     * @notice Enables or disables the repayment functionality for a asset pool.\n     * @param pool The address of the pool.\n     * @param isActive Boolean value indicating whether repayment is active or paused.\n     * @dev This function can only be called by accounts with TIMELOCK or higher privilege.\n     */\n    function setvaultBurnPaused(address pool, bool isActive) external checkRole(TIMELOCK) {\n        vaultBurnPaused[pool] = isActive;\n    }\n\n    /**\n     * @notice Sets the status of premium trading.\n     * @param isActive Boolean value indicating whether premium trading is enabled or disabled.\n     * @dev This function can only be called by accounts with TIMELOCK or higher privilege.\n     */\n    function setPremiumTradingEnabled(bool isActive) external checkRole(TIMELOCK) {\n        premiumTradingEnabled = isActive;\n    }\n\n    /**\n     * @notice Enables or disables the mint functionality for a asset pool.\n     * @param pool The address of the pool.\n     * @param isActive Boolean value indicating whether minting is active or paused.\n     * @dev This function can only be called by accounts with ADMIN or higher privilege.\n     */\n    function setvaultMintPaused(address pool, bool isActive) external checkRole(ADMIN) {\n        vaultMintPaused[pool] = isActive;\n    }\n\n    /**\n     * @notice Sets the redemption fee.\n     * @param newFee The new fee to be set.\n     * @notice The fee cannot exceed 5%.\n     */\n    function setRedemptionFee(uint256 newFee) external checkRole(TIMELOCK) {\n        require(newFee <= 500, \"Max Redemption Fee is 5%\");\n        redemptionFee = newFee;\n        emit RedemptionFeeChanged(newFee);\n    }\n\n    /**\n     * @notice  safeCollateralRatio can be decided by TIMELOCK.\n     * The eUSD vault requires a minimum safe collateral rate of 160%,\n     * On the other hand, the PeUSD vault requires a safe collateral rate at least 10% higher\n     * than the liquidation collateral rate, providing an additional buffer to protect against liquidation risks.\n     */\n    function setSafeCollateralRatio(address pool, uint256 newRatio) external checkRole(TIMELOCK) {\n        if(IVault(pool).vaultType() == 0) {\n            require(newRatio >= 160 * 1e18, \"eUSD vault safe collateralRatio should more than 160%\");\n        } else {\n            require(newRatio >= vaultBadCollateralRatio[pool] + 1e19, \"PeUSD vault safe collateralRatio should more than bad collateralRatio\");\n        }\n        vaultSafeCollateralRatio[pool] = newRatio;\n        emit SafeCollateralRatioChanged(pool, newRatio);\n    }\n\n    /**\n     * @notice  Set the borrowing annual percentage yield (APY) for a asset pool.\n     * @param pool The address of the pool to set the borrowing APY for.\n     * @param newApy The new borrowing APY to set, limited to a maximum of 2%.\n     */\n    function setBorrowApy(address pool, uint256 newApy) external checkRole(TIMELOCK) {\n        require(newApy <= 200, \"Borrow APY cannot exceed 2%\");\n        vaultMintFeeApy[pool] = newApy;\n        emit BorrowApyChanged(pool, newApy);\n    }\n\n    /**\n     * @notice Set the reward ratio for the liquidator after liquidation.\n     * @param pool The address of the pool to set the reward ratio for.\n     * @param newRatio The new reward ratio to set, limited to a maximum of 5%.\n     */\n    function setKeeperRatio(address pool,uint256 newRatio) external checkRole(TIMELOCK) {\n        require(newRatio <= 5, \"Max Keeper reward is 5%\");\n        vaultKeeperRatio[pool] = newRatio;\n        emit KeeperRatioChanged(pool, newRatio);\n    }\n\n    /**\n     * @notice Sets the mining permission for the esLBR&LBR mining pool.\n     * @param _contracts An array of addresses representing the contracts.\n     * @param _bools An array of booleans indicating whether mining is allowed for each contract.\n     */\n    function setTokenMiner(address[] calldata _contracts, bool[] calldata _bools) external checkRole(TIMELOCK) {\n        for (uint256 i = 0; i < _contracts.length; i++) {\n            tokenMiner[_contracts[i]] = _bools[i];\n            emit tokenMinerChanges(_contracts[i], _bools[i]);\n        }\n    }\n\n    /**\n     * dev Sets the maximum percentage share for PeUSD.\n     * @param _ratio The ratio in basis points (1/10_000). The maximum value is 10_000.\n     */\n    function setMaxStableRatio(uint256 _ratio) external checkRole(TIMELOCK) {\n        require(_ratio <= 10_000, \"The maximum value is 10000\");\n        maxStableRatio = _ratio;\n    }\n\n    /// @notice Update the flashloan fee percentage, only available to the manager of the contract\n    /// @param fee The fee percentage for eUSD, multiplied by 100 (for example, 10% is 1000)\n    function setFlashloanFee(uint256 fee) external checkRole(TIMELOCK) {\n        if (fee > 10_000) revert('EL');\n        emit FlashloanFeeUpdated(fee);\n        flashloanFee = fee;\n    }\n\n    /// @notice Sets the address of the stablecoin used for rewards distribution.\n    /// @param _token The address of the stablecoin token.\n    function setProtocolRewardsToken(address _token) external checkRole(TIMELOCK) {\n        stableToken = _token;\n    }\n\n    /**\n     * @notice User chooses to become a Redemption Provider\n     */\n    function becomeRedemptionProvider(bool _bool) external {\n        eUSDMiningIncentives.refreshReward(msg.sender);\n        redemptionProvider[msg.sender] = _bool;\n        emit RedemptionProvider(msg.sender, _bool);\n    }\n\n    /**\n     * @dev Updates the mining data for the user's eUSD mining incentives.\n     */\n    function refreshMintReward(address user) external {\n        eUSDMiningIncentives.refreshReward(user);\n    }\n    \n    /**\n     * @notice Distributes rewards to the LybraProtocolRewardsPool based on the available balance of eUSD.\n     * If the balance is greater than 1e21, the distribution process is triggered.\n     * If premiumTradingEnabled is false or the price of the trading pair (0, 2) on the Curve pool is less than or equal to 1005000, eUSD rewards are directly transferred to the LybraProtocolRewardsPool.\n     * Otherwise, a controlled premium trading is performed by exchanging eUSD for the third token in the trading pair on the Curve pool, using a calculated amount to maintain a premium.\n     * The resulting token amount is transferred to the LybraProtocolRewardsPool.\n     * @dev The protocol rewards amount is notified to the LybraProtocolRewardsPool for proper reward allocation.\n     */\n    function distributeRewards() external {\n        uint256 peUSDBalance = peUSD.balanceOf(address(this));\n        if(peUSDBalance >= 1e21) {\n            peUSD.transfer(address(lybraProtocolRewardsPool), peUSDBalance);\n            lybraProtocolRewardsPool.notifyRewardAmount(peUSDBalance, 2);\n        }\n        uint256 balance = EUSD.balanceOf(address(this));\n        if (balance > 1e21) {\n            uint256 price = curvePool.get_dy_underlying(0, 2, 1e18);\n            if(!premiumTradingEnabled || price <= 1005000) {\n                EUSD.transfer(address(lybraProtocolRewardsPool), balance);\n                lybraProtocolRewardsPool.notifyRewardAmount(balance, 0);\n            } else {\n                EUSD.approve(address(curvePool), balance);\n                uint256 amount = curvePool.exchange_underlying(0, 2, balance, balance * price * 998 / 1e21);\n                IEUSD(stableToken).transfer(address(lybraProtocolRewardsPool), amount);\n                lybraProtocolRewardsPool.notifyRewardAmount(amount, 1);\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the address of the eUSD token.\n     * @return The address of the eUSD token.\n     */\n    function getEUSDAddress() external view returns (address) {\n        return address(EUSD);\n    }\n\n    /**\n     * @dev Returns the address of the Lybra protocol rewards pool.\n     * @return The address of the Lybra protocol rewards pool.\n     */\n    function getProtocolRewardsPool() external view returns (address) {\n        return address(lybraProtocolRewardsPool);\n    }\n\n    /**\n     * @dev Returns the safe collateral ratio for a asset pool.\n     * @param pool The address of the pool to check.\n     * @return The safe collateral ratio for the specified pool.\n     */\n    function getSafeCollateralRatio(\n        address pool\n    ) external view returns (uint256) {\n        if (vaultSafeCollateralRatio[pool] == 0) return 160 * 1e18;\n        return vaultSafeCollateralRatio[pool];\n    }\n\n    function getBadCollateralRatio(address pool) external view returns(uint256) {\n        if(vaultBadCollateralRatio[pool] == 0) return vaultSafeCollateralRatio[pool] - 1e19;\n        return vaultBadCollateralRatio[pool];\n    }\n\n    /**\n     * @dev Checks if a user is a redemption provider.\n     * @param user The address of the user to check.\n     * @return True if the user is a redemption provider, false otherwise.\n     */\n    function isRedemptionProvider(address user) external view returns (bool) {\n        return redemptionProvider[user];\n    }\n\n    /**\n     * @dev Return the maximum quantity of PeUSD that can be minted by using eUSD.\n     * @return The maximum quantity of PeUSD that can be minted through eUSD.\n     */\n    function getEUSDMaxLocked() external view returns (uint256) {\n        return (EUSD.totalSupply() * maxStableRatio) / 10_000;\n    }\n\n    function hasRole(bytes32 role, address caller) external view returns (bool) {\n        return GovernanceTimelock.checkRole(role, caller);\n    }\n}"
    },
    {
      "filename": "contracts/lybra/miner/ProtocolRewardsPool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n/**\n * @title ProtocolRewardsPool is a derivative version of Synthetix StakingRewards.sol, distributing Protocol revenue to esLBR stakers.\n * Converting esLBR to LBR.\n * Differences from the original contract,\n * - Get `totalStaked` from totalSupply() in contract esLBR.\n * - Get `stakedOf(user)` from balanceOf(user) in contract esLBR.\n * - When an address esLBR balance changes, call the refreshReward method to update rewards to be claimed.\n */\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../interfaces/IEUSD.sol\";\nimport \"../interfaces/Iconfigurator.sol\";\nimport \"../interfaces/IesLBR.sol\";\n\ninterface IesLBRBoost {\n    function getUnlockTime(\n        address user\n    ) external view returns (uint256 unlockTime);\n}\n\ncontract ProtocolRewardsPool is Ownable {\n    Iconfigurator public immutable configurator;\n    IesLBR public esLBR;\n    IesLBR public LBR;\n    IesLBRBoost public esLBRBoost;\n\n    // Sum of (reward ratio * dt * 1e18 / total supply)\n    uint public rewardPerTokenStored;\n    // User address => rewardPerTokenStored\n    mapping(address => uint) public userRewardPerTokenPaid;\n    // User address => rewards to be claimed\n    mapping(address => uint) public rewards;\n    mapping(address => uint) public time2fullRedemption;\n    mapping(address => uint) public unstakeRatio;\n    mapping(address => uint) public lastWithdrawTime;\n    uint256 immutable exitCycle = 90 days;\n    uint256 public grabableAmount;\n    uint256 public grabFeeRatio = 3000;\n    event Restake(address indexed user, uint256 amount, uint256 time);\n    event StakeLBR(address indexed user, uint256 amount, uint256 time);\n    event UnstakeLBR(address indexed user, uint256 amount, uint256 time);\n    event WithdrawLBR(address indexed user, uint256 amount, uint256 time);\n    event ClaimReward(address indexed user, uint256 eUSDAmount, address token, uint256 tokenAmount, uint256 time);\n\n    constructor(address _config) {\n        configurator = Iconfigurator(_config);\n    }\n\n    function setTokenAddress(address _eslbr, address _lbr, address _boost) external onlyOwner {\n        esLBR = IesLBR(_eslbr);\n        LBR = IesLBR(_lbr);\n        esLBRBoost = IesLBRBoost(_boost);\n    }\n\n    function setGrabCost(uint256 _ratio) external onlyOwner {\n        require(_ratio <= 8000, \"BCE\");\n        grabFeeRatio = _ratio;\n    }\n\n    // Total staked\n    function totalStaked() internal view returns (uint256) {\n        return esLBR.totalSupply();\n    }\n\n    // User address => esLBR balance\n    function stakedOf(address staker) internal view returns (uint256) {\n        return esLBR.balanceOf(staker);\n    }\n\n    function stake(uint256 amount) external {\n        LBR.burn(msg.sender, amount);\n        esLBR.mint(msg.sender, amount);\n        emit StakeLBR(msg.sender, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Unlocks esLBR and converts it to LBR.\n     * @param amount The amount to convert.\n     * Requirements:\n     * The current time must be greater than the unlock time retrieved from the boost contract for the user.\n     * Effects:\n     * Resets the user's vesting data, entering a new vesting period, when converting to LBR.\n     */\n    function unstake(uint256 amount) external {\n        require(block.timestamp >= esLBRBoost.getUnlockTime(msg.sender), \"Your lock-in period has not ended. You can't convert your esLBR now.\");\n        esLBR.burn(msg.sender, amount);\n        withdraw(msg.sender);\n        uint256 total = amount;\n        if (time2fullRedemption[msg.sender] > block.timestamp) {\n            total += unstakeRatio[msg.sender] * (time2fullRedemption[msg.sender] - block.timestamp);\n        }\n        unstakeRatio[msg.sender] = total / exitCycle;\n        time2fullRedemption[msg.sender] = block.timestamp + exitCycle;\n        emit UnstakeLBR(msg.sender, amount, block.timestamp);\n    }\n\n    function withdraw(address user) public {\n        uint256 amount = getClaimAbleLBR(user);\n        if (amount > 0) {\n            LBR.mint(user, amount);\n        }\n        lastWithdrawTime[user] = block.timestamp;\n        emit WithdrawLBR(user, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Redeems and converts the ESLBR being claimed in advance,\n     * with the lost portion being recorded in the contract and available for others to purchase in LBR at a certain ratio.\n     */\n    function unlockPrematurely() external {\n        require(block.timestamp + exitCycle - 3 days > time2fullRedemption[msg.sender], \"ENW\");\n        uint256 burnAmount = getReservedLBRForVesting(msg.sender) - getPreUnlockableAmount(msg.sender);\n        uint256 amount = getPreUnlockableAmount(msg.sender) + getClaimAbleLBR(msg.sender);\n        if (amount > 0) {\n            LBR.mint(msg.sender, amount);\n        }\n        unstakeRatio[msg.sender] = 0;\n        time2fullRedemption[msg.sender] = 0;\n        grabableAmount += burnAmount;\n    }\n\n    /**\n     * @dev Purchase the accumulated amount of pre-claimed lost ESLBR in the contract using LBR.\n     * @param amount The amount of ESLBR to be purchased.\n     * Requirements:\n     * The amount must be greater than 0.\n     */\n    function grabEsLBR(uint256 amount) external {\n        require(amount > 0, \"QMG\");\n        grabableAmount -= amount;\n        LBR.burn(msg.sender, (amount * grabFeeRatio) / 10000);\n        esLBR.mint(msg.sender, amount);\n    }\n\n    /**\n     * @dev Convert unredeemed and converting ESLBR tokens back to LBR.\n     */\n    function reStake() external {\n        uint256 amount = getReservedLBRForVesting(msg.sender) + getClaimAbleLBR(msg.sender);\n        esLBR.mint(msg.sender, amount);\n        unstakeRatio[msg.sender] = 0;\n        time2fullRedemption[msg.sender] = 0;\n        emit Restake(msg.sender, amount, block.timestamp);\n    }\n\n    function getPreUnlockableAmount(address user) public view returns (uint256 amount) {\n        uint256 a = getReservedLBRForVesting(user);\n        if (a == 0) return 0;\n        amount = (a * (75e18 - ((time2fullRedemption[user] - block.timestamp) * 70e18) / (exitCycle / 1 days - 3) / 1 days)) / 100e18;\n    }\n\n    function getClaimAbleLBR(address user) public view returns (uint256 amount) {\n        if (time2fullRedemption[user] > lastWithdrawTime[user]) {\n            amount = block.timestamp > time2fullRedemption[user] ? unstakeRatio[user] * (time2fullRedemption[user] - lastWithdrawTime[user]) : unstakeRatio[user] * (block.timestamp - lastWithdrawTime[user]);\n        }\n    }\n\n    function getReservedLBRForVesting(address user) public view returns (uint256 amount) {\n        if (time2fullRedemption[user] > block.timestamp) {\n            amount = unstakeRatio[user] * (time2fullRedemption[user] - block.timestamp);\n        }\n    }\n\n    function earned(address _account) public view returns (uint) {\n        return ((stakedOf(_account) * (rewardPerTokenStored - userRewardPerTokenPaid[_account])) / 1e18) + rewards[_account];\n    }\n\n    function getClaimAbleUSD(address user) external view returns (uint256 amount) {\n        amount = IEUSD(configurator.getEUSDAddress()).getMintedEUSDByShares(earned(user));\n    }\n\n    /**\n     * @dev Call this"
    }
  ]
}