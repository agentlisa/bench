{
  "Title": "Canonical NTT chain ID should be fetched directly from Wormhole or mapped accordingly",
  "Content": "Currently, the immutable `chainId` variable is assigned the value passed to the `NttManager` [constructor](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/NttManager/NttManager.sol#L26-L32\n) by the deployer:\n\n```solidity\nconstructor(\n    address _token,\n    Mode _mode,\n    uint16 _chainId,\n    uint64 _rateLimitDuration\n) NttManagerState(_token, _mode, _chainId, _rateLimitDuration) {}\n```\n\nHowever, no validation is performed to ensure that the chain identifier provided is as expected. Since this is intended to be the Wormhole chain ID, it should be validated against the value returned by the Wormhole contract. Otherwise, if the chain identifier does not match the Wormhole chain identifier, given the understanding that the ID is not necessarily required to be the Wormhole chain ID, then this state should be included within the `WormholeTransceiver` payload [published](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/Transceiver/WormholeTransceiver/WormholeTransceiverState.sol#L80) to Wormhole since it will differ from the emitter chain included in the VAA.\n\nIf it is decided to make the Wormhole chain ID the canonical chain ID, different Transceiver implementations should map to the corresponding chain ID representations within their logic. As such, the Wormhole address should be passed to the constructor of the NTT Manager, querying the chain ID directly from the Wormhole Core Bridge instead of taking an arbitrary value in the constructor as described above.\n\n**Wormhole Foundation:** We have elected not to fetch the chain id directly from the core bridge in order to make this less opinionated. This will be documented and the mapping of chain ids can be implemented when required.\n\n**Cyfrin:** Acknowledged.\n\n\\clearpage",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "evm/src/NttManager/NttManager.sol",
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity >=0.8.8 <0.9.0;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\n\nimport \"wormhole-solidity-sdk/Utils.sol\";\nimport \"wormhole-solidity-sdk/libraries/BytesParsing.sol\";\n\nimport \"../libraries/RateLimiter.sol\";\n\nimport \"../interfaces/INttManager.sol\";\nimport \"../interfaces/INttManagerEvents.sol\";\nimport \"../interfaces/INTTToken.sol\";\nimport \"../interfaces/ITransceiver.sol\";\n\nimport {NttManagerState} from \"./NttManagerState.sol\";\n\ncontract NttManager is INttManager, NttManagerState {\n    using BytesParsing for bytes;\n    using SafeERC20 for IERC20;\n    using TrimmedAmountLib for uint256;\n    using TrimmedAmountLib for TrimmedAmount;\n\n    constructor(\n        address _token,\n        Mode _mode,\n        uint16 _chainId,\n        uint64 _rateLimitDuration,\n        bool _skipRateLimiting\n    ) NttManagerState(_token, _mode, _chainId, _rateLimitDuration, _skipRateLimiting) {}\n\n    // ==================== External Interface ===============================================\n\n    /// @inheritdoc INttManager\n    function transfer(\n        uint256 amount,\n        uint16 recipientChain,\n        bytes32 recipient\n    ) external payable nonReentrant whenNotPaused returns (uint64) {\n        return _transferEntryPoint(amount, recipientChain, recipient, false, new bytes(1));\n    }\n\n    /// @inheritdoc INttManager\n    function transfer(\n        uint256 amount,\n        uint16 recipientChain,\n        bytes32 recipient,\n        bool shouldQueue,\n        bytes memory transceiverInstructions\n    ) external payable nonReentrant whenNotPaused returns (uint64) {\n        return _transferEntryPoint(\n            amount, recipientChain, recipient, shouldQueue, transceiverInstructions\n        );\n    }\n\n    /// @inheritdoc INttManager\n    function quoteDeliveryPrice(\n        uint16 recipientChain,\n        TransceiverStructs.TransceiverInstruction[] memory transceiverInstructions,\n        address[] memory enabledTransceivers\n    ) public view returns (uint256[] memory, uint256) {\n        uint256 numEnabledTransceivers = enabledTransceivers.length;\n        mapping(address => TransceiverInfo) storage transceiverInfos = _getTransceiverInfosStorage();\n\n        uint256[] memory priceQuotes = new uint256[](numEnabledTransceivers);\n        uint256 totalPriceQuote = 0;\n        for (uint256 i = 0; i < numEnabledTransceivers; i++) {\n            address transceiverAddr = enabledTransceivers[i];\n            uint8 registeredTransceiverIndex = transceiverInfos[transceiverAddr].index;\n            uint256 transceiverPriceQuote = ITransceiver(transceiverAddr).quoteDeliveryPrice(\n                recipientChain, transceiverInstructions[registeredTransceiverIndex]\n            );\n            priceQuotes[i] = transceiverPriceQuote;\n            totalPriceQuote += transceiverPriceQuote;\n        }\n        return (priceQuotes, totalPriceQuote);\n    }\n\n    /// @inheritdoc INttManager\n    function attestationReceived(\n        uint16 sourceChainId,\n        bytes32 sourceNttManagerAddress,\n        TransceiverStructs.NttManagerMessage memory payload\n    ) external onlyTransceiver {\n        _verifyPeer(sourceChainId, sourceNttManagerAddress);\n\n        bytes32 nttManagerMessageHash =\n            TransceiverStructs.nttManagerMessageDigest(sourceChainId, payload);\n\n        // set the attested flag for this transceiver.\n        // NOTE: Attestation is idempotent (bitwise or 1), but we revert\n        // anyway to ensure that the client does not continue to initiate calls\n        // to receive the same message through the same transceiver.\n        if (\n            transceiverAttestedToMessage(\n                nttManagerMessageHash, _getTransceiverInfosStorage()[msg.sender].index\n            )\n        ) {\n            revert TransceiverAlreadyAttestedToMessage(nttManagerMessageHash);\n        }\n        _setTransceiverAttestedToMessage(nttManagerMessageHash, msg.sender);\n\n        if (isMessageApproved(nttManagerMessageHash)) {\n            executeMsg(sourceChainId, sourceNttManagerAddress, payload);\n        }\n    }\n\n    /// @inheritdoc INttManager\n    function executeMsg(\n        uint16 sourceChainId,\n        bytes32 sourceNttManagerAddress,\n        TransceiverStructs.NttManagerMessage memory message\n    ) public {\n        // verify chain has not forked\n        checkFork(evmChainId);\n\n        bytes32 digest = TransceiverStructs.nttManagerMessageDigest(sourceChainId, message);\n\n        if (!isMessageApproved(digest)) {\n            revert MessageNotApproved(digest);\n        }\n\n        bool msgAlreadyExecuted = _replayProtect(digest);\n        if (msgAlreadyExecuted) {\n            // end execution early to mitigate the possibility of race conditions from transceivers\n            // attempting to deliver the same message when (threshold < number of transceiver messages)\n            // notify client (off-chain process) so they don't attempt redundant msg delivery\n            emit MessageAlreadyExecuted(sourceNttManagerAddress, digest);\n            return;\n        }\n\n        TransceiverStructs.NativeTokenTransfer memory nativeTokenTransfer =\n            TransceiverStructs.parseNativeTokenTransfer(message.payload);\n\n        // verify that the destination chain is valid\n        if (nativeTokenTransfer.toChain != chainId) {\n            revert InvalidTargetChain(nativeTokenTransfer.toChain, chainId);\n        }\n        TrimmedAmount memory nativeTransferAmount =\n            (nativeTokenTransfer.amount.untrim(tokenDecimals_)).trim(tokenDecimals_, tokenDecimals_);\n\n        address transferRecipient = fromWormholeFormat(nativeTokenTransfer.to);\n\n        {\n            // Check inbound rate limits\n            bool isRateLimited = _isInboundAmountRateLimited(nativeTransferAmount, sourceChainId);\n            if (isRateLimited) {\n                // queue up the transfer\n                _enqueueInboundTransfer(digest, nativeTransferAmount, transferRecipient);\n\n                // end execution early\n                return;\n            }\n        }\n\n        // consume the amount for the inbound rate limit\n        _consumeInboundAmount(nativeTransferAmount, sourceChainId);\n        // When receiving a transfer, we refill the outbound rate limit\n        // by the same amount (we call this \"backflow\")\n        _backfillOutboundAmount(nativeTransferAmount);\n\n        _mintOrUnlockToRecipient(digest, transferRecipient, nativeTransferAmount);\n    }\n\n    /// @inheritdoc INttManager\n    function completeInboundQueuedTransfer(bytes32 digest) external nonReentrant whenNotPaused {\n        // find the message in the queue\n        InboundQueuedTransfer memory queuedTransfer = getInboundQueuedTransfer(digest);\n        if (queuedTransfer.txTimestamp == 0) {\n            revert InboundQueuedTransferNotFound(digest);\n        }\n\n        // check that > RATE_LIMIT_DURATION has elapsed\n        if (block.timestamp - queuedTransfer.txTimestamp < rateLimitDuration) {\n            revert InboundQueuedTransferStillQueued(digest, queuedTransfer.txTimestamp);\n        }\n\n        // remove transfer from the queue\n        delete _getInboundQueueStorage()[digest];\n\n        // run it through the mint/unlock logic\n        _mintOrUnlockToRecipient(digest, queuedTransfer.recipient, queuedTransfer.amount);\n    }\n\n    /// @inheritdoc INttManager\n    function completeOutboundQueuedTransfer(uint64 messageSequence)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n        returns (uint64)\n    {\n        // find the message in the queue\n        OutboundQueuedTransfer memory queuedTransfer = _getOutboundQueueStorage()[messageSequence];\n        if (queuedTransfer.txTimestamp == 0) {\n            revert OutboundQueuedTransferNotFound(messageSequence);\n        }\n\n        // check that > RATE_LIMIT_DURATION has elapsed\n        if (block.timestamp - queuedTransfer.txTimestamp < rateLimitDuration) {\n            revert OutboundQueuedTransferStillQueued(messageSequence, queuedTransfer.txTimestamp);\n        }\n\n        // remove transfer from the queue\n        delete _getOutboundQueueStorage()[messageSequence];\n\n        // run it through the transfer logic and skip the rate limit\n        return _transfer(\n            messageSequence,\n            queuedTransfer.amount,\n            queuedTransfer.recipientChain,\n            queuedTransfer.recipient,\n            queuedTransfer.sender,\n            queuedTransfer.transceiverInstructions\n        );\n    }\n\n    // ==================== Internal Business Logic =========================================\n\n    function _sendMessageToTransceivers(\n        uint16 recipientChain,\n        uint256[] memory priceQuotes,\n        TransceiverStructs.TransceiverInstruction[] memory transceiverInstructions,\n        address[] memory enabledTransceivers,\n        bytes memory nttManagerMessage\n    ) internal {\n        uint256 numEnabledTransceivers = enabledTransceivers.length;\n        mapping(address => TransceiverInfo) storage transceiverInfos = _getTransceiverInfosStorage();\n        bytes32 peerAddress = _getPeersStorage()[recipientChain].peerAddress;\n        // call into transceiver contracts to send the message\n        for (uint256 i = 0; i < numEnabledTransceivers; i++) {\n            address transceiverAddr = enabledTransceivers[i];\n            // send it to the recipient nttManager based on the chain\n            ITransceiver(transceiverAddr).sendMessage{value: priceQuotes[i]}(\n                recipientChain,\n                transceiverInstructions[transceiverInfos[transceiverAddr].index],\n                nttManagerMessage,\n                peerAddress\n            );\n        }\n    }\n\n    function _transferEntryPoint(\n        uint256 amount,\n        uint16 recipientChain,\n        bytes32 recipient,\n        bool shouldQueue,\n        bytes memory transceiverInstructions\n    ) internal returns (uint64) {\n        if (amount == 0) {\n            revert ZeroAmount();\n        }\n\n        if (recipient == bytes32(0)) {\n            revert InvalidRecipient();\n        }\n\n        {\n            // Lock/burn tokens before checking rate limits\n            // use transferFrom to pull tokens from the user and lock them\n            // query own token balance before transfer\n            uint256 balanceBefore = _getTokenBalanceOf(token, address(this));\n\n            // transfer tokens\n            IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n\n            // query own token balance after transfer\n            uint256 balanceAfter = _getTokenBalanceOf(token, address(this));\n\n            // correct amount for potential transfer fees\n            amount = balanceAfter - balanceBefore;\n            if (mode == Mode.BURNING) {\n                {\n                    // NOTE: We don't account for burn fees in this code path.\n                    // We verify that the user's change in balance is equal to the amount that's burned.\n                    // Accounting for burn fees can be non-trivial, since there\n                    // is no standard way to account for the fee if the fee amount\n                    // is taken out of the burn amount.\n                    // For example, if there's a fee of 1 which is taken out of the\n                    // amount, then burning 20 tokens would result in a transfer of only 19 tokens.\n                    // However, the difference in the user's balance would only show 20.\n                    // Since there is no standard way to query for burn fee amounts with burnable tokens,\n                    // and NTT would be used on a per-token basis, implementing this functionality\n                    // is left to integrating projects who may need to account for burn fees on their tokens.\n                    ERC20Burnable(token).burn(amount);\n\n                    // tokens held by the contract after the operation should be the same as before\n                    uint256 balanceAfterBurn = _getTokenBalanceOf(token, address(this));\n                    if (balanceBefore != balanceAfterBurn) {\n                        revert BurnAmountDifferentThanBalanceDiff(balanceBefore, balanceAfterBurn);\n                    }\n                }\n            }\n        }\n\n        // trim amount after burning to ensure transfer amount matches (amount - fee)\n        TrimmedAmount memory trimmedAmount = _trimTransferAmount(amount, recipientChain);\n        TrimmedAmount memory internalAmount = trimmedAmount.shift(tokenDecimals_);\n\n        // get the sequence for this transfer\n        uint64 sequence = _useMessageSequence();\n\n        {\n            // now check rate limits\n            bool isAmountRateLimited = _isOutboundAmountRateLimited(internalAmount);\n            if (!shouldQueue && isAmountRateLimited) {\n                revert NotEnoughCapacity(getCurrentOutboundCapacity(), amount);\n            }\n            if (shouldQueue && isAmountRateLimited) {\n                // emit an event to notify the user that the transfer is rate limited\n                emit OutboundTransferRateLimited(\n                    msg.sender, sequence, amount, getCurrentOutboundCapacity()\n                );\n\n                // queue up and return\n                _enqueueOutboundTransfer(\n                    sequence,\n                    trimmedAmount,\n                    recipientChain,\n                    recipient,\n                    msg.sender,\n                    transceiverInstructions\n                );\n\n                // refund price quote back to sender\n                _refundToSender(msg.value);\n\n                // return the sequence in the queue\n                return sequence;\n            }\n        }\n\n        // otherwise, consume the outbound amount\n        _consumeOutboundAmount(internalAmount);\n        // When sending a transfer, we refill the inbound rate limit for\n        // that chain by the same amount (we call this \"backflow\")\n        _backfillInboundAmount(internalAmount, recipientChain);\n\n        return _transfer(\n            sequence, trimmedAmount, recipientChain, recipient, msg.sender, transceiverInstructions\n        );\n    }\n\n    function _transfer(\n        uint64 sequence,\n        TrimmedAmount memory amount,\n        uint16 recipientChain,\n        bytes32 recipient,\n        address sender,\n        bytes memory transceiverInstructions\n    ) internal returns (uint64 msgSequence) {\n        // cache enabled transceivers to avoid multiple storage reads\n        address[] memory enabledTransceivers = _getEnabledTransceiversStorage();\n\n        TransceiverStructs.TransceiverInstruction[] memory instructions = TransceiverStructs\n            .parseTransceiverInstructions(transceiverInstructions, enabledTransceivers.length);\n\n        (uint256[] memory priceQuotes, uint256 totalPriceQuote) =\n            quoteDeliveryPrice(recipientChain, instructions, enabledTransceivers);\n        {\n            // check up front that msg.value will cover the delivery price\n            if (msg.value < totalPriceQuote) {\n                revert DeliveryPaymentTooLow(totalPriceQuote, msg.value);\n            }\n\n            // refund user extra excess value from msg.value\n            uint256 excessValue = msg.value - totalPriceQuote;\n            if (excessValue > 0) {\n                _refundToSender(excessValue);\n            }\n        }\n\n        // push it on the stack again to avoid a stack too deep error\n        uint64 seq = sequence;\n\n        TransceiverStructs.NativeTokenTransfer memory ntt = TransceiverStructs.NativeTokenTransfer(\n            amount, toWormholeFormat(token), recipient, recipientChain\n        );\n\n        // construct the NttManagerMessage payload\n        bytes memory encodedNttManagerPayload = TransceiverStructs.encodeNttManagerMessage(\n            TransceiverStructs.NttManagerMessage(\n                seq, toWormholeFormat(sender), TransceiverStructs.encodeNativeTokenTransfer(ntt)\n            )\n        );\n\n        // send the message\n        _sendMessageToTransceivers(\n            recipientChain, priceQuotes, instructions, enabledTransceivers, encodedNttManagerPayload\n        );\n\n        // push it on the stack again to avoid a stack too deep error\n        TrimmedAmount memory amt = amount;\n        uint16 destinationChain = recipientChain;\n\n        emit TransferSent(\n            recipient, amt.untrim(tokenDecimals_), totalPriceQuote, destinationChain, seq\n        );\n\n        // return the sequence number\n        return sequence;\n    }\n\n    function _mintOrUnlockToRecipient(\n        bytes32 digest,\n        address recipient,\n        TrimmedAmount memory amount\n    ) internal {\n        // calculate proper amount of tokens to unlock/mint to recipient\n        // untrim the amount\n        uint256 untrimmedAmount = amount.untrim(tokenDecimals_);\n\n        emit TransferRedeemed(digest);\n\n        if (mode == Mode.LOCKING) {\n            // unlock tokens to the specified recipient\n            IERC20(token).safeTransfer(recipient, untrimmedAmount);\n        } else if (mode == Mode.BURNING) {\n            // mint tokens to the specified recipient\n            INTTToken(token).mint(recipient, untrimmedAmount);\n        } else {\n            revert InvalidMode(uint8(mode));\n        }\n    }\n\n    /// @inheritdoc INttManager\n    function tokenDecimals() public view override(INttManager, RateLimiter) returns (uint8) {\n        return tokenDecimals_;\n    }\n\n    // ==================== Internal Helpers ===============================================\n\n    function _refundToSender(uint256 refundAmount) internal {\n        // refund the price quote back to sender\n        (bool refundSuccessful,) = payable(msg.sender).call{value: refundAmount}(\"\");\n\n        // check success\n        if (!refundSuccessful) {\n            revert RefundFailed(refundAmount);\n        }\n    }\n\n    function _trimTransferAmount(\n        uint256 amount,\n        uint16 toChain\n    ) internal view returns (TrimmedAmount memory) {\n        uint8 toDecimals = _getPeersStorage()[toChain].tokenDecimals;\n\n        if (toDecimals == 0) {\n            revert InvalidPeerDecimals();\n        }\n\n        TrimmedAmount memory trimmedAmount;\n        {\n            trimmedAmount = amount.trim(tokenDecimals_, toDecimals);\n            // don't deposit dust that can not be bridged due to the decimal shift\n            uint256 newAmount = trimmedAmount.untrim(tokenDecimals_);\n            if (amount != newAmount) {\n                revert TransferAmountHasDust(amount, amount - newAmount);\n            }\n        }\n\n        return trimmedAmount;\n    }\n\n    function _getTokenBalanceOf(\n        address tokenAddr,\n        address accountAddr\n    ) internal view returns (uint256) {\n        (, bytes memory queriedBalance) =\n            tokenAddr.staticcall(abi.encodeWithSelector(IERC20.balanceOf.selector, accountAddr));\n        return abi.decode(queriedBalance, (uint256));\n    }\n}"
    },
    {
      "filename": "evm/src/Transceiver/WormholeTransceiver/WormholeTransceiverState.sol",
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity >=0.8.8 <0.9.0;\n\nimport \"wormhole-solidity-sdk/WormholeRelayerSDK.sol\";\nimport \"wormhole-solidity-sdk/libraries/BytesParsing.sol\";\nimport \"wormhole-solidity-sdk/interfaces/IWormhole.sol\";\n\nimport \"../../libraries/TransceiverHelpers.sol\";\nimport \"../../libraries/TransceiverStructs.sol\";\n\nimport \"../../interfaces/IWormholeTransceiver.sol\";\nimport \"../../interfaces/IWormholeTransceiverState.sol\";\nimport \"../../interfaces/ISpecialRelayer.sol\";\nimport \"../../interfaces/INttManager.sol\";\n\nimport \"../Transceiver.sol\";\n\nabstract contract WormholeTransceiverState is IWormholeTransceiverState, Transceiver {\n    using BytesParsing for bytes;\n\n    // ==================== Immutables ===============================================\n    uint8 public immutable consistencyLevel;\n    IWormhole public immutable wormhole;\n    IWormholeRelayer public immutable wormholeRelayer;\n    ISpecialRelayer public immutable specialRelayer;\n    uint256 immutable wormholeTransceiver_evmChainId;\n    uint256 public immutable gasLimit;\n\n    // ==================== Constants ================================================\n\n    /// @dev Prefix for all TransceiverMessage payloads\n    ///      This is 0x99'E''W''H'\n    /// @notice Magic string (constant value set by messaging provider) that idenfies the payload as an transceiver-emitted payload.\n    ///         Note that this is not a security critical field. It's meant to be used by messaging providers to identify which messages are Transceiver-related.\n    bytes4 constant WH_TRANSCEIVER_PAYLOAD_PREFIX = 0x9945FF10;\n\n    /// @dev Prefix for all Wormhole transceiver initialisation payloads\n    ///      This is bytes4(keccak256(\"WormholeTransceiverInit\"))\n    bytes4 constant WH_TRANSCEIVER_INIT_PREFIX = 0x9c23bd3b;\n\n    /// @dev Prefix for all Wormhole peer registration payloads\n    ///      This is bytes4(keccak256(\"WormholePeerRegistration\"))\n    bytes4 constant WH_PEER_REGISTRATION_PREFIX = 0x18fc67c2;\n\n    constructor(\n        address nttManager,\n        address wormholeCoreBridge,\n        address wormholeRelayerAddr,\n        address specialRelayerAddr,\n        uint8 _consistencyLevel,\n        uint256 _gasLimit\n    ) Transceiver(nttManager) {\n        wormhole = IWormhole(wormholeCoreBridge);\n        wormholeRelayer = IWormholeRelayer(wormholeRelayerAddr);\n        specialRelayer = ISpecialRelayer(specialRelayerAddr);\n        wormholeTransceiver_evmChainId = block.chainid;\n        consistencyLevel = _consistencyLevel;\n        gasLimit = _gasLimit;\n    }\n\n    enum RelayingType {\n        Standard,\n        Special,\n        Manual\n    }\n\n    function _initialize() internal override {\n        super._initialize();\n        _initializeTransceiver();\n    }\n\n    function _initializeTransceiver() internal {\n        TransceiverStructs.TransceiverInit memory init = TransceiverStructs.TransceiverInit({\n            transceiverIdentifier: WH_TRANSCEIVER_INIT_PREFIX,\n            nttManagerAddress: toWormholeFormat(nttManager),\n            nttManagerMode: INttManager(nttManager).getMode(),\n            tokenAddress: toWormholeFormat(nttManagerToken),\n            tokenDecimals: INttManager(nttManager).tokenDecimals()\n        });\n        wormhole.publishMessage(0, TransceiverStructs.encodeTransceiverInit(init), consistencyLevel);\n    }\n\n    function _checkImmutables() internal view override {\n        super._checkImmutables();\n        assert(this.wormhole() == wormhole);\n        assert(this.wormholeRelayer() == wormholeRelayer);\n        assert(this.specialRelayer() == specialRelayer);\n        assert(this.consistencyLevel() == consistencyLevel);\n    }\n\n    // =============== Storage ===============================================\n\n    bytes32 private constant WORMHOLE_CONSUMED_VAAS_SLOT =\n        bytes32(uint256(keccak256(\"whTransceiver.consumedVAAs\")) - 1);\n\n    bytes32 private constant WORMHOLE_PEERS_SLOT =\n        bytes32(uint256(keccak256(\"whTransceiver.peers\")) - 1);\n\n    bytes32 private constant WORMHOLE_RELAYING_ENABLED_CHAINS_SLOT =\n        bytes32(uint256(keccak256(\"whTransceiver.relayingEnabledChains\")) - 1);\n\n    bytes32 private constant SPECIAL_RELAYING_ENABLED_CHAINS_SLOT =\n        bytes32(uint256(keccak256(\"whTransceiver.specialRelayingEnabledChains\")) - 1);\n\n    bytes32 private constant WORMHOLE_EVM_CHAIN_IDS =\n        bytes32(uint256(keccak256(\"whTransceiver.evmChainIds\")) - 1);\n\n    // =============== Storage Setters/Getters ========================================\n\n    function _getWormholeConsumedVAAsStorage()\n        internal\n        pure\n        returns (mapping(bytes32 => bool) storage $)\n    {\n        uint256 slot = uint256(WORMHOLE_CONSUMED_VAAS_SLOT);\n        assembly (\"memory-safe\") {\n            $.slot := slot\n        }\n    }\n\n    function _getWormholePeersStorage()\n        internal\n        pure\n        returns (mapping(uint16 => bytes32) storage $)\n    {\n        uint256 slot = uint256(WORMHOLE_PEERS_SLOT);\n        assembly (\"memory-safe\") {\n            $.slot := slot\n        }\n    }\n\n    function _getWormholeRelayingEnabledChainsStorage()\n        internal\n        pure\n        returns (mapping(uint16 => uint256) storage $)\n    {\n        uint256 slot = uint256(WORMHOLE_RELAYING_ENABLED_CHAINS_SLOT);\n        assembly (\"memory-safe\") {\n            $.slot := slot\n        }\n    }\n\n    function _getSpecialRelayingEnabledChainsStorage()\n        internal\n        pure\n        returns (mapping(uint16 => uint256) storage $)\n    {\n        uint256 slot = uint256(SPECIAL_RELAYING_ENABLED_CHAINS_SLOT);\n        assembly (\"memory-safe\") {\n            $.slot := slot\n        }\n    }\n\n    function _getWormholeEvmChainIdsStorage()\n        internal\n        pure\n        returns (mapping(uint16 => uint256) storage $)\n    {\n        uint256 slot = uint256(WORMHOLE_EVM_CHAIN_IDS);\n        assembly (\"memory-safe\") {\n            $.slot := slot\n        }\n    }\n\n    // =============== Public Getters ======================================================\n\n    /// @inheritdoc IWormholeTransceiverState\n    function isVAAConsumed(bytes32 hash) public view returns (bool) {\n        return _getWormholeConsumedVAAsStorage()[hash];\n    }\n\n    /// @inheritdoc IWormholeTransceiverState\n    function getWormholePeer(uint16 chainId) public view returns (bytes32) {\n        return _getWormholePeersStorage()[chainId];\n    }\n\n    /// @inheritdoc IWormholeTransceiverState\n    function isWormholeRelayingEnabled(uint16 chainId) public view returns (bool) {\n        return toBool(_getWormholeRelayingEnabledChainsStorage()[chainId]);\n    }\n\n    /// @inheritdoc IWormholeTransceiverState\n    function isSpecialRelayingEnabled(uint16 chainId) public view returns (bool) {\n        return toBool(_getSpecialRelayingEnabledChainsStorage()[chainId]);\n    }\n\n    /// @inheritdoc IWormholeTransceiverState\n    function isWormholeEvmChain(uint16 chainId) public view returns (bool) {\n        return toBool(_getWormholeEvmChainIdsStorage()[chainId]);\n    }\n\n    // =============== Admin ===============================================================\n\n    /// @inheritdoc IWormholeTransceiverState\n    function setWormholePeer(uint16 peerChainId, bytes32 peerContract) external onlyOwner {\n        if (peerChainId == 0) {\n            revert InvalidWormholeChainIdZero();\n        }\n        if (peerContract == bytes32(0)) {\n            revert InvalidWormholePeerZeroAddress();\n        }\n\n        bytes32 oldPeerContract = _getWormholePeersStorage()[peerChainId];\n\n        // We don't want to allow updating a peer since this adds complexity in the accountant\n        // If the owner makes a mistake with peer registration they should deploy a new Wormhole\n        // transceiver and register this new transceiver with the NttManager\n        if (oldPeerContract != bytes32(0)) {\n            revert PeerAlreadySet(peerChainId, oldPeerContract);\n        }\n\n        _getWormholePeersStorage()[peerChainId] = peerContract;\n\n        // Publish a message for this transceiver registration\n        TransceiverStructs.TransceiverRegistration memory registration = TransceiverStructs\n            .TransceiverRegistration({\n            transceiverIdentifier: WH_PEER_REGISTRATION_PREFIX,\n            transceiverChainId: peerChainId,\n            transceiverAddress: peerContract\n        });\n        wormhole.publishMessage(\n            0, TransceiverStructs.encodeTransceiverRegistration(registration), consistencyLevel\n        );\n\n        emit SetWormholePeer(peerChainId, peerContract);\n    }\n\n    /// @inheritdoc IWormholeTransceiverState\n    function setIsWormholeEvmChain(uint16 chainId) external onlyOwner {\n        if (chainId == 0) {\n            revert InvalidWormholeChainIdZero();\n        }\n        _getWormholeEvmChainIdsStorage()[chainId] = TRUE;\n\n        emit SetIsWormholeEvmChain(chainId);\n    }\n\n    /// @inheritdoc IWormholeTransceiverState\n    function setIsWormholeRelayingEnabled(uint16 chainId, bool isEnabled) external onlyOwner {\n        if (chainId == 0) {\n            revert InvalidWormholeChainIdZero();\n        }\n        _getWormholeRelayingEnabledChainsStorage()[chainId] = toWord(isEnabled);\n\n        emit SetIsWormholeRelayingEnabled(chainId, isEnabled);\n    }\n\n    /// @inheritdoc IWormholeTransceiverState\n    function setIsSpecialRelayingEnabled(uint16 chainId, bool isEnabled) external onlyOwner {\n        if (chainId == 0) {\n            revert InvalidWormholeChainIdZero();\n        }\n        _getSpecialRelayingEnabledChainsStorage()[chainId] = toWord(isEnabled);\n\n        emit SetIsSpecialRelayingEnabled(chainId, isEnabled);\n    }\n\n    // ============= Internal ===============================================================\n\n    function _checkInvalidRelayingConfig(uint16 chainId) internal view returns (bool) {\n        return isWormholeRelayingEnabled(chainId) && !isWormholeEvmChain(chainId);\n    }\n\n    function _shouldRelayViaStandardRelaying(uint16 chainId) internal view returns (bool) {\n        return isWormholeRelayingEnabled(chainId) && isWormholeEvmChain(chainId);\n    }\n\n    function _setVAAConsumed(bytes32 hash) internal {\n        _getWormholeConsumedVAAsStorage()[hash] = true;\n    }\n\n    // =============== MODIFIERS ===============================================\n\n    modifier onlyRelayer() {\n        if (msg.sender != address(wormholeRelayer)) {\n            revert CallerNotRelayer(msg.sender);\n        }\n        _;\n    }\n}"
    }
  ]
}