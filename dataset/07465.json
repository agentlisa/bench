{
  "Title": "[M-05] Pair price may be manipulated by direct transfers",
  "Content": "\n<https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L391> <br><https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L479-L480> <br><https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L384>\n\nAn attacker may manipulate the price of a pair by transferring tokens directly to the pair. Since the `Pair` contract exposes the `price` function, it maybe be used as a price oracle in third-party integrations. Manipulating the price of a pair may allow an attacker to steal funds from such integrations.\n\n### Proof of Concept\n\nThe `Pair` contract is a pool of two tokens, a base token and a fractional token. Its main purpose is to allow users to swap the tokens at a fair price. Since the price is calculated based on the reserves of a pair, it can only be changed in two cases:\n\n1.  when initial liquidity is added: the first liquidity provider sets the price of a pool ([Pair.sol#L85-L97](https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L85-L97)); other liquidity providers cannot change the price ([Pair.sol#L421-L423](https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L421-L423));\n2.  during trades: trading adds and removes tokens from a pool, ensuring the K constant invariant is respected ([Pair.sol#L194-L204](https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L194-L204), [Pair.sol#L161-L173](https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L161-L173)).\n\nHowever, the Pair contract calculates the price using the current token balances of the contract ([Pair.sol#L379-L385](https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L379-L385), [Pair.sol#L477-L481](https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L477-L481)):\n\n```solidity\nfunction baseTokenReserves() public view returns (uint256) {\n    return _baseTokenReserves();\n}\n\nfunction _baseTokenReserves() internal view returns (uint256) {\n    return baseToken == address(0)\n        ? address(this).balance - msg.value // subtract the msg.value if the base token is ETH\n        : ERC20(baseToken).balanceOf(address(this));\n}\n\nfunction fractionalTokenReserves() public view returns (uint256) {\n    return balanceOf[address(this)];\n}\n```\n\nThis allows an attacker to change the price of a pool and skip the K constant invariant check that's enforced on new liquidity ([Pair.sol#L421-L423](https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L421-L423)).\n\n### Recommended Mitigation Steps\n\nConsider tracking pair's reserves internally, using state variables, similarly to how Uniswap V2 does that:\n\n*   [UniswapV2Pair.sol#L22-L23](https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L22-L23):\n\n```solidity\nuint112 private reserve0;           // uses single storage slot, accessible via getReserves\nuint112 private reserve1;           // uses single storage slot, accessible via getReserves\n```\n\n*   [UniswapV2Pair.sol#L38-L42](https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L38-L42):\n\n```solidity\nfunction getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {\n    _reserve0 = reserve0;\n    _reserve1 = reserve1;\n    _blockTimestampLast = blockTimestampLast;\n}\n```\n\n*   [UniswapV2Pair.sol#L38-L42](https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L38-L42):\n\n```solidity\n// update reserves and, on the first call per block, price accumulators\nfunction _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {\n    require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'UniswapV2: OVERFLOW');\n    uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n    uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n    if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n        // * never overflows, and + overflow is desired\n        price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\n        price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\n    }\n    reserve0 = uint112(balance0);\n    reserve1 = uint112(balance1);\n    blockTimestampLast = blockTimestamp;\n    emit Sync(reserve0, reserve1);\n}\n```\n\n**[minhquanym (warden) commented](https://github.com/code-423n4/2022-12-caviar-findings/issues/383#issuecomment-1385868751):**\n > @berndartmueller - The recommendation suggested that it should follow Uniswap V2 and add internal state balance. However, Uniswap V2 also has function `sync()` allowing to sync `reserve0` and `reserve1` to current token balance of contract. It means if this is an issue, it will also be an issue after UniV2 (by direct transfers and call `sync()` immediately). Please correct me if I missed something here\n> https://github.com/Uniswap/v2-core/blob/ee547b17853e71ed4e0101ccfd52e70d5acded58/contracts/UniswapV2Pair.sol#L198  \n\n**[berndartmueller (judge) commented](https://github.com/code-423n4/2022-12-caviar-findings/issues/383#issuecomment-1396635210):**\n > @minhquanym - The specific issue demonstrated in this submission is exposing the `Pair.price` function, which is easily manipulatable by direct transfers and thus vulnerable as a price oracle. Uniswap V2, in comparison, uses the concept of a cumulative price weighted by the amount of time this price existed (see https://docs.uniswap.org/contracts/v2/concepts/core-concepts/oracles for more details).\n\n**[outdoteth (Caviar) acknowledged](https://github.com/code-423n4/2022-12-caviar-findings/issues/383#event-8321057436)**\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-12-caviar-contest",
  "Code": [
    {
      "filename": "src/Pair.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"solmate/tokens/ERC20.sol\";\nimport \"solmate/tokens/ERC721.sol\";\nimport \"solmate/utils/MerkleProofLib.sol\";\nimport \"solmate/utils/SafeTransferLib.sol\";\nimport \"openzeppelin/utils/math/Math.sol\";\n\nimport \"./LpToken.sol\";\nimport \"./Caviar.sol\";\n\n/// @title Pair\n/// @author out.eth (@outdoteth)\n/// @notice A pair of an NFT and a base token that can be used to create and trade fractionalized NFTs.\ncontract Pair is ERC20, ERC721TokenReceiver {\n    using SafeTransferLib for address;\n    using SafeTransferLib for ERC20;\n\n    uint256 public constant ONE = 1e18;\n    uint256 public constant CLOSE_GRACE_PERIOD = 7 days;\n\n    address public immutable nft;\n    address public immutable baseToken; // address(0) for ETH\n    bytes32 public immutable merkleRoot;\n    LpToken public immutable lpToken;\n    Caviar public immutable caviar;\n    uint256 public closeTimestamp;\n\n    event Add(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 lpTokenAmount);\n    event Remove(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 lpTokenAmount);\n    event Buy(uint256 inputAmount, uint256 outputAmount);\n    event Sell(uint256 inputAmount, uint256 outputAmount);\n    event Wrap(uint256[] tokenIds);\n    event Unwrap(uint256[] tokenIds);\n    event Close(uint256 closeTimestamp);\n    event Withdraw(uint256 tokenId);\n\n    constructor(\n        address _nft,\n        address _baseToken,\n        bytes32 _merkleRoot,\n        string memory pairSymbol,\n        string memory nftName,\n        string memory nftSymbol\n    ) ERC20(string.concat(nftName, \" fractional token\"), string.concat(\"f\", nftSymbol), 18) {\n        nft = _nft;\n        baseToken = _baseToken; // use address(0) for native ETH\n        merkleRoot = _merkleRoot;\n        lpToken = new LpToken(pairSymbol);\n        caviar = Caviar(msg.sender);\n    }\n\n    // ************************ //\n    //      Core AMM logic      //\n    // ***********************  //\n\n    /// @notice Adds liquidity to the pair.\n    /// @param baseTokenAmount The amount of base tokens to add.\n    /// @param fractionalTokenAmount The amount of fractional tokens to add.\n    /// @param minLpTokenAmount The minimum amount of LP tokens to mint.\n    /// @return lpTokenAmount The amount of LP tokens minted.\n    function add(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 minLpTokenAmount)\n        public\n        payable\n        returns (uint256 lpTokenAmount)\n    {\n        // *** Checks *** //\n\n        // check the token amount inputs are not zero\n        require(baseTokenAmount > 0 && fractionalTokenAmount > 0, \"Input token amount is zero\");\n\n        // check that correct eth input was sent - if the baseToken equals address(0) then native ETH is used\n        require(baseToken == address(0) ? msg.value == baseTokenAmount : msg.value == 0, \"Invalid ether input\");\n\n        // calculate the lp token shares to mint\n        lpTokenAmount = addQuote(baseTokenAmount, fractionalTokenAmount);\n\n        // check that the amount of lp tokens outputted is greater than the min amount\n        require(lpTokenAmount >= minLpTokenAmount, \"Slippage: lp token amount out\");\n\n        // *** Effects *** //\n\n        // transfer fractional tokens in\n        _transferFrom(msg.sender, address(this), fractionalTokenAmount);\n\n        // *** Interactions *** //\n\n        // mint lp tokens to sender\n        lpToken.mint(msg.sender, lpTokenAmount);\n\n        // transfer base tokens in if the base token is not ETH\n        if (baseToken != address(0)) {\n            // transfer base tokens in\n            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), baseTokenAmount);\n        }\n\n        emit Add(baseTokenAmount, fractionalTokenAmount, lpTokenAmount);\n    }\n\n    /// @notice Removes liquidity from the pair.\n    /// @param lpTokenAmount The amount of LP tokens to burn.\n    /// @param minBaseTokenOutputAmount The minimum amount of base tokens to receive.\n    /// @param minFractionalTokenOutputAmount The minimum amount of fractional tokens to receive.\n    /// @return baseTokenOutputAmount The amount of base tokens received.\n    /// @return fractionalTokenOutputAmount The amount of fractional tokens received.\n    function remove(uint256 lpTokenAmount, uint256 minBaseTokenOutputAmount, uint256 minFractionalTokenOutputAmount)\n        public\n        returns (uint256 baseTokenOutputAmount, uint256 fractionalTokenOutputAmount)\n    {\n        // *** Checks *** //\n\n        // calculate the output amounts\n        (baseTokenOutputAmount, fractionalTokenOutputAmount) = removeQuote(lpTokenAmount);\n\n        // check that the base token output amount is greater than the min amount\n        require(baseTokenOutputAmount >= minBaseTokenOutputAmount, \"Slippage: base token amount out\");\n\n        // check that the fractional token output amount is greater than the min amount\n        require(fractionalTokenOutputAmount >= minFractionalTokenOutputAmount, \"Slippage: fractional token out\");\n\n        // *** Effects *** //\n\n        // transfer fractional tokens to sender\n        _transferFrom(address(this), msg.sender, fractionalTokenOutputAmount);\n\n        // *** Interactions *** //\n\n        // burn lp tokens from sender\n        lpToken.burn(msg.sender, lpTokenAmount);\n\n        if (baseToken == address(0)) {\n            // if base token is native ETH then send ether to sender\n            msg.sender.safeTransferETH(baseTokenOutputAmount);\n        } else {\n            // transfer base tokens to sender\n            ERC20(baseToken).safeTransfer(msg.sender, baseTokenOutputAmount);\n        }\n\n        emit Remove(baseTokenOutputAmount, fractionalTokenOutputAmount, lpTokenAmount);\n    }\n\n    /// @notice Buys fractional tokens from the pair.\n    /// @param outputAmount The amount of fractional tokens to buy.\n    /// @param maxInputAmount The maximum amount of base tokens to spend.\n    /// @return inputAmount The amount of base tokens spent.\n    function buy(uint256 outputAmount, uint256 maxInputAmount) public payable returns (uint256 inputAmount) {\n        // *** Checks *** //\n\n        // check that correct eth input was sent - if the baseToken equals address(0) then native ETH is used\n        require(baseToken == address(0) ? msg.value == maxInputAmount : msg.value == 0, \"Invalid ether input\");\n\n        // calculate required input amount using xyk invariant\n        inputAmount = buyQuote(outputAmount);\n\n        // check that the required amount of base tokens is less than the max amount\n        require(inputAmount <= maxInputAmount, \"Slippage: amount in\");\n\n        // *** Effects *** //\n\n        // transfer fractional tokens to sender\n        _transferFrom(address(this), msg.sender, outputAmount);\n\n        // *** Interactions *** //\n\n        if (baseToken == address(0)) {\n            // refund surplus eth\n            uint256 refundAmount = maxInputAmount - inputAmount;\n            if (refundAmount > 0) msg.sender.safeTransferETH(refundAmount);\n        } else {\n            // transfer base tokens in\n            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), inputAmount);\n        }\n\n        emit Buy(inputAmount, outputAmount);\n    }\n\n    /// @notice Sells fractional tokens to the pair.\n    /// @param inputAmount The amount of fractional tokens to sell.\n    /// @param minOutputAmount The minimum amount of base tokens to receive.\n    /// @return outputAmount The amount of base tokens received.\n    function sell(uint256 inputAmount, uint256 minOutputAmount) public returns (uint256 outputAmount) {\n        // *** Checks *** //\n\n        // calculate output amount using xyk invariant\n        outputAmount = sellQuote(inputAmount);\n\n        // check that the outputted amount of fractional tokens is greater than the min amount\n        require(outputAmount >= minOutputAmount, \"Slippage: amount out\");\n\n        // *** Effects *** //\n\n        // transfer fractional tokens from sender\n        _transferFrom(msg.sender, address(this), inputAmount);\n\n        // *** Interactions *** //\n\n        if (baseToken == address(0)) {\n            // transfer ether out\n            msg.sender.safeTransferETH(outputAmount);\n        } else {\n            // transfer base tokens out\n            ERC20(baseToken).safeTransfer(msg.sender, outputAmount);\n        }\n\n        emit Sell(inputAmount, outputAmount);\n    }\n\n    // ******************** //\n    //      Wrap logic      //\n    // ******************** //\n\n    /// @notice Wraps NFTs into fractional tokens.\n    /// @param tokenIds The ids of the NFTs to wrap.\n    /// @param proofs The merkle proofs for the NFTs proving that they can be used in the pair.\n    /// @return fractionalTokenAmount The amount of fractional tokens minted.\n    function wrap(uint256[] calldata tokenIds, bytes32[][] calldata proofs)\n        public\n        returns (uint256 fractionalTokenAmount)\n    {\n        // *** Checks *** //\n\n        // check that wrapping is not closed\n        require(closeTimestamp == 0, \"Wrap: closed\");\n\n        // check the tokens exist in the merkle root\n        _validateTokenIds(tokenIds, proofs);\n\n        // *** Effects *** //\n\n        // mint fractional tokens to sender\n        fractionalTokenAmount = tokenIds.length * ONE;\n        _mint(msg.sender, fractionalTokenAmount);\n\n        // *** Interactions *** //\n\n        // transfer nfts from sender\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n        }\n\n        emit Wrap(tokenIds);\n    }\n\n    /// @notice Unwraps fractional tokens into NFTs.\n    /// @param tokenIds The ids of the NFTs to unwrap.\n    /// @return fractionalTokenAmount The amount of fractional tokens burned.\n    function unwrap(uint256[] calldata tokenIds) public returns (uint256 fractionalTokenAmount) {\n        // *** Effects *** //\n\n        // burn fractional tokens from sender\n        fractionalTokenAmount = tokenIds.length * ONE;\n        _burn(msg.sender, fractionalTokenAmount);\n\n        // *** Interactions *** //\n\n        // transfer nfts to sender\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ERC721(nft).safeTransferFrom(address(this), msg.sender, tokenIds[i]);\n        }\n\n        emit Unwrap(tokenIds);\n    }\n\n    // *********************** //\n    //      NFT AMM logic      //\n    // *********************** //\n\n    /// @notice nftAdd Adds liquidity to the pair using NFTs.\n    /// @param baseTokenAmount The amount of base tokens to add.\n    /// @param tokenIds The ids of the NFTs to add.\n    /// @param minLpTokenAmount The minimum amount of lp tokens to receive.\n    /// @param proofs The merkle proofs for the NFTs.\n    /// @return lpTokenAmount The amount of lp tokens minted.\n    function nftAdd(\n        uint256 baseTokenAmount,\n        uint256[] calldata tokenIds,\n        uint256 minLpTokenAmount,\n        bytes32[][] calldata proofs\n    ) public payable returns (uint256 lpTokenAmount) {\n        // wrap the incoming NFTs into fractional tokens\n        uint256 fractionalTokenAmount = wrap(tokenIds, proofs);\n\n        // add liquidity using the fractional tokens and base tokens\n        lpTokenAmount = add(baseTokenAmount, fractionalTokenAmount, minLpTokenAmount);\n    }\n\n    /// @notice Removes liquidity from the pair using NFTs.\n    /// @param lpTokenAmount The amount of lp tokens to remove.\n    /// @param minBaseTokenOutputAmount The minimum amount of base tokens to receive.\n    /// @param tokenIds The ids of the NFTs to remove.\n    /// @return baseTokenOutputAmount The amount of base tokens received.\n    /// @return fractionalTokenOutputAmount The amount of fractional tokens received.\n    function nftRemove(uint256 lpTokenAmount, uint256 minBaseTokenOutputAmount, uint256[] calldata tokenIds)\n        public\n        returns (uint256 baseTokenOutputAmount, uint256 fractionalTokenOutputAmount)\n    {\n        // remove liquidity and send fractional tokens and base tokens to sender\n        (baseTokenOutputAmount, fractionalTokenOutputAmount) =\n            remove(lpTokenAmount, minBaseTokenOutputAmount, tokenIds.length * ONE);\n\n        // unwrap the fractional tokens into NFTs and send to sender\n        unwrap(tokenIds);\n    }\n\n    /// @notice Buys NFTs from the pair using base tokens.\n    /// @param tokenIds The ids of the NFTs to buy.\n    /// @param maxInputAmount The maximum amount of base tokens to spend.\n    /// @return inputAmount The amount of base tokens spent.\n    function nftBuy(uint256[] calldata tokenIds, uint256 maxInputAmount) public payable returns (uint256 inputAmount) {\n        // buy fractional tokens using base tokens\n        inputAmount = buy(tokenIds.length * ONE, maxInputAmount);\n\n        // unwrap the fractional tokens into NFTs and send to sender\n        unwrap(tokenIds);\n    }\n\n    /// @notice Sells NFTs to the pair for base tokens.\n    /// @param tokenIds The ids of the NFTs to sell.\n    /// @param minOutputAmount The minimum amount of base tokens to receive.\n    /// @param proofs The merkle proofs for the NFTs.\n    /// @return outputAmount The amount of base tokens received.\n    function nftSell(uint256[] calldata tokenIds, uint256 minOutputAmount, bytes32[][] calldata proofs)\n        public\n        returns (uint256 outputAmount)\n    {\n        // wrap the incoming NFTs into fractional tokens\n        uint256 inputAmount = wrap(tokenIds, proofs);\n\n        // sell fractional tokens for base tokens\n        outputAmount = sell(inputAmount, minOutputAmount);\n    }\n\n    // ****************************** //\n    //      Emergency exit logic      //\n    // ****************************** //\n\n    /// @notice Closes the pair to new wraps.\n    /// @dev Can only be called by the caviar owner. This is used as an emergency exit in case\n    ///      the caviar owner suspects that the pair has been compromised.\n    function close() public {\n        // check that the sender is the caviar owner\n        require(caviar.owner() == msg.sender, \"Close: not owner\");\n\n        // set the close timestamp with a grace period\n        closeTimestamp = block.timestamp + CLOSE_GRACE_PERIOD;\n\n        // remove the pair from the Caviar contract\n        caviar.destroy(nft, baseToken, merkleRoot);\n\n        emit Close(closeTimestamp);\n    }\n\n    /// @notice Withdraws a particular NFT from the pair.\n    /// @dev Can only be called by the caviar owner after the close grace period has passed. This\n    ///      is used to auction off the NFTs in the pair in case NFTs get stuck due to liquidity\n    ///      imbalances. Proceeds from the auction should be distributed pro rata to fractional\n    ///      token holders. See documentation for more details.\n    function withdraw(uint256 tokenId) public {\n        // check that the sender is the caviar owner\n        require(caviar.owner() == msg.sender, \"Withdraw: not owner\");\n\n        // check that the close period has been set\n        require(closeTimestamp != 0, \"Withdraw not initiated\");\n\n        // check that the close grace period has passed\n        require(block.timestamp >= closeTimestamp, \"Not withdrawable yet\");\n\n        // transfer the nft to the caviar owner\n        ERC721(nft).safeTransferFrom(address(this), msg.sender, tokenId);\n\n        emit Withdraw(tokenId);\n    }\n\n    // ***************** //\n    //      Getters      //\n    // ***************** //\n\n    function baseTokenReserves() public view returns (uint256) {\n        return _baseTokenReserves();\n    }\n\n    function fractionalTokenReserves() public view returns (uint256) {\n        return balanceOf[address(this)];\n    }\n\n    /// @notice The current price of one fractional token in base tokens with 18 decimals of precision.\n    /// @dev Calculated by dividing the base token reserves by the fractional token reserves.\n    /// @return price The price of one fractional token in base tokens * 1e18.\n    function price() public view returns (uint256) {\n        return (_baseTokenReserves() * ONE) / fractionalTokenReserves();\n    }\n\n    /// @notice The amount of base tokens required to buy a given amount of fractional tokens.\n    /// @dev Calculated using the xyk invariant and a 30bps fee.\n    /// @param outputAmount The amount of fractional tokens to buy.\n    /// @return inputAmount The amount of base tokens required.\n    function buyQuote(uint256 outputAmount) public view returns (uint256) {\n        return (outputAmount * 1000 * baseTokenReserves()) / ((fractionalTokenReserves() - outputAmount) * 997);\n    }\n\n    /// @notice The amount of base tokens received for selling a given amount of fractional tokens.\n    /// @dev Calculated using the xyk invariant and a 30bps fee.\n    /// @param inputAmount The amount of fractional tokens to sell.\n    /// @return outputAmount The amount of base tokens received.\n    function sellQuote(uint256 inputAmount) public view returns (uint256) {\n        uint256 inputAmountWithFee = inputAmount * 997;\n        return (inputAmountWithFee * baseTokenReserves()) / ((fractionalTokenReserves() * 1000) + inputAmountWithFee);\n    }\n\n    /// @notice The amount of lp tokens received for adding a given amount of base tokens and fractional tokens.\n    /// @dev Calculated as a share of existing deposits. If there are no existing deposits, then initializes to\n    ///      sqrt(baseTokenAmount * fractionalTokenAmount).\n    /// @param baseTokenAmount The amount of base tokens to add.\n    /// @param fractionalTokenAmount The amount of fractional tokens to add.\n    /// @return lpTokenAmount The amount of lp tokens received.\n    function addQuote(uint256 baseTokenAmount, uint256 fractionalTokenAmount) public view returns (uint256) {\n        uint256 lpTokenSupply = lpToken.totalSupply();\n        if (lpTokenSupply > 0) {\n            // calculate amount of lp tokens as a fraction of existing reserves\n            uint256 baseTokenShare = (baseTokenAmount * lpTokenSupply) / baseTokenReserves();\n            uint256 fractionalTokenShare = (fractionalTokenAmount * lpTokenSupply) / fractionalTokenReserves();\n            return Math.min(baseTokenShare, fractionalTokenShare);\n        } else {\n            // if there is no liquidity then init\n            return Math.sqrt(baseTokenAmount * fractionalTokenAmount);\n        }\n    }\n\n    /// @notice The amount of base tokens and fractional tokens received for burning a given amount of lp tokens.\n    /// @dev Calculated as a share of existing deposits.\n    /// @param lpTokenAmount The amount of lp tokens to burn.\n    /// @return baseTokenAmount The amount of base tokens received.\n    /// @return fractionalTokenAmount The amount of fractional tokens received.\n    function removeQuote(uint256 lpTokenAmount) public view returns (uint256, uint256) {\n        uint256 lpTokenSupply = lpToken.totalSupply();\n        uint256 baseTokenOutputAmount = (baseTokenReserves() * lpTokenAmount) / lpTokenSupply;\n        uint256 fractionalTokenOutputAmount = (fractionalTokenReserves() * lpTokenAmount) / lpTokenSupply;\n\n        return (baseTokenOutputAmount, fractionalTokenOutputAmount);\n    }\n\n    // ************************ //\n    //      Internal utils      //\n    // ************************ //\n\n    function _transferFrom(address from, address to, uint256 amount) internal returns (bool) {\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /// @dev Validates that the given tokenIds are valid for the contract's merkle root. Reverts\n    ///      if any of the tokenId proofs are invalid.\n    function _validateTokenIds(uint256[] calldata tokenIds, bytes32[][] calldata proofs) internal view {\n        // if merkle root is not set then all tokens are valid\n        if (merkleRoot == bytes23(0)) return;\n\n        // validate merkle proofs against merkle root\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            bool isValid = MerkleProofLib.verify(proofs[i], merkleRoot, keccak256(abi.encodePacked(tokenIds[i])));\n            require(isValid, \"Invalid merkle proof\");\n        }\n    }\n\n    /// @dev Returns the current base token reserves. If the base token is ETH then it ignores\n    ///      the msg.value that is being sent in the current call context - this is to ensure the\n    ///      xyk math is correct in the buy() and add() functions.\n    function _baseTokenReserves() internal view returns (uint256) {\n        return baseToken == address(0)\n            ? address(this).balance - msg.value // subtract the msg.value if the base token is ETH\n            : ERC20(baseToken).balanceOf(address(this));\n    }\n}"
    },
    {
      "filename": "src/Pair.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"solmate/tokens/ERC20.sol\";\nimport \"solmate/tokens/ERC721.sol\";\nimport \"solmate/utils/MerkleProofLib.sol\";\nimport \"solmate/utils/SafeTransferLib.sol\";\nimport \"openzeppelin/utils/math/Math.sol\";\n\nimport \"./LpToken.sol\";\nimport \"./Caviar.sol\";\n\n/// @title Pair\n/// @author out.eth (@outdoteth)\n/// @notice A pair of an NFT and a base token that can be used to create and trade fractionalized NFTs.\ncontract Pair is ERC20, ERC721TokenReceiver {\n    using SafeTransferLib for address;\n    using SafeTransferLib for ERC20;\n\n    uint256 public constant ONE = 1e18;\n    uint256 public constant CLOSE_GRACE_PERIOD = 7 days;\n\n    address public immutable nft;\n    address public immutable baseToken; // address(0) for ETH\n    bytes32 public immutable merkleRoot;\n    LpToken public immutable lpToken;\n    Caviar public immutable caviar;\n    uint256 public closeTimestamp;\n\n    event Add(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 lpTokenAmount);\n    event Remove(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 lpTokenAmount);\n    event Buy(uint256 inputAmount, uint256 outputAmount);\n    event Sell(uint256 inputAmount, uint256 outputAmount);\n    event Wrap(uint256[] tokenIds);\n    event Unwrap(uint256[] tokenIds);\n    event Close(uint256 closeTimestamp);\n    event Withdraw(uint256 tokenId);\n\n    constructor(\n        address _nft,\n        address _baseToken,\n        bytes32 _merkleRoot,\n        string memory pairSymbol,\n        string memory nftName,\n        string memory nftSymbol\n    ) ERC20(string.concat(nftName, \" fractional token\"), string.concat(\"f\", nftSymbol), 18) {\n        nft = _nft;\n        baseToken = _baseToken; // use address(0) for native ETH\n        merkleRoot = _merkleRoot;\n        lpToken = new LpToken(pairSymbol);\n        caviar = Caviar(msg.sender);\n    }\n\n    // ************************ //\n    //      Core AMM logic      //\n    // ***********************  //\n\n    /// @notice Adds liquidity to the pair.\n    /// @param baseTokenAmount The amount of base tokens to add.\n    /// @param fractionalTokenAmount The amount of fractional tokens to add.\n    /// @param minLpTokenAmount The minimum amount of LP tokens to mint.\n    /// @return lpTokenAmount The amount of LP tokens minted.\n    function add(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 minLpTokenAmount)\n        public\n        payable\n        returns (uint256 lpTokenAmount)\n    {\n        // *** Checks *** //\n\n        // check the token amount inputs are not zero\n        require(baseTokenAmount > 0 && fractionalTokenAmount > 0, \"Input token amount is zero\");\n\n        // check that correct eth input was sent - if the baseToken equals address(0) then native ETH is used\n        require(baseToken == address(0) ? msg.value == baseTokenAmount : msg.value == 0, \"Invalid ether input\");\n\n        // calculate the lp token shares to mint\n        lpTokenAmount = addQuote(baseTokenAmount, fractionalTokenAmount);\n\n        // check that the amount of lp tokens outputted is greater than the min amount\n        require(lpTokenAmount >= minLpTokenAmount, \"Slippage: lp token amount out\");\n\n        // *** Effects *** //\n\n        // transfer fractional tokens in\n        _transferFrom(msg.sender, address(this), fractionalTokenAmount);\n\n        // *** Interactions *** //\n\n        // mint lp tokens to sender\n        lpToken.mint(msg.sender, lpTokenAmount);\n\n        // transfer base tokens in if the base token is not ETH\n        if (baseToken != address(0)) {\n            // transfer base tokens in\n            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), baseTokenAmount);\n        }\n\n        emit Add(baseTokenAmount, fractionalTokenAmount, lpTokenAmount);\n    }\n\n    /// @notice Removes liquidity from the pair.\n    /// @param lpTokenAmount The amount of LP tokens to burn.\n    /// @param minBaseTokenOutputAmount The minimum amount of base tokens to receive.\n    /// @param minFractionalTokenOutputAmount The minimum amount of fractional tokens to receive.\n    /// @return baseTokenOutputAmount The amount of base tokens received.\n    /// @return fractionalTokenOutputAmount The amount of fractional tokens received.\n    function remove(uint256 lpTokenAmount, uint256 minBaseTokenOutputAmount, uint256 minFractionalTokenOutputAmount)\n        public\n        returns (uint256 baseTokenOutputAmount, uint256 fractionalTokenOutputAmount)\n    {\n        // *** Checks *** //\n\n        // calculate the output amounts\n        (baseTokenOutputAmount, fractionalTokenOutputAmount) = removeQuote(lpTokenAmount);\n\n        // check that the base token output amount is greater than the min amount\n        require(baseTokenOutputAmount >= minBaseTokenOutputAmount, \"Slippage: base token amount out\");\n\n        // check that the fractional token output amount is greater than the min amount\n        require(fractionalTokenOutputAmount >= minFractionalTokenOutputAmount, \"Slippage: fractional token out\");\n\n        // *** Effects *** //\n\n        // transfer fractional tokens to sender\n        _transferFrom(address(this), msg.sender, fractionalTokenOutputAmount);\n\n        // *** Interactions *** //\n\n        // burn lp tokens from sender\n        lpToken.burn(msg.sender, lpTokenAmount);\n\n        if (baseToken == address(0)) {\n            // if base token is native ETH then send ether to sender\n            msg.sender.safeTransferETH(baseTokenOutputAmount);\n        } else {\n            // transfer base tokens to sender\n            ERC20(baseToken).safeTransfer(msg.sender, baseTokenOutputAmount);\n        }\n\n        emit Remove(baseTokenOutputAmount, fractionalTokenOutputAmount, lpTokenAmount);\n    }\n\n    /// @notice Buys fractional tokens from the pair.\n    /// @param outputAmount The amount of fractional tokens to buy.\n    /// @param maxInputAmount The maximum amount of base tokens to spend.\n    /// @return inputAmount The amount of base tokens spent.\n    function buy(uint256 outputAmount, uint256 maxInputAmount) public payable returns (uint256 inputAmount) {\n        // *** Checks *** //\n\n        // check that correct eth input was sent - if the baseToken equals address(0) then native ETH is used\n        require(baseToken == address(0) ? msg.value == maxInputAmount : msg.value == 0, \"Invalid ether input\");\n\n        // calculate required input amount using xyk invariant\n        inputAmount = buyQuote(outputAmount);\n\n        // check that the required amount of base tokens is less than the max amount\n        require(inputAmount <= maxInputAmount, \"Slippage: amount in\");\n\n        // *** Effects *** //\n\n        // transfer fractional tokens to sender\n        _transferFrom(address(this), msg.sender, outputAmount);\n\n        // *** Interactions *** //\n\n        if (baseToken == address(0)) {\n            // refund surplus eth\n            uint256 refundAmount = maxInputAmount - inputAmount;\n            if (refundAmount > 0) msg.sender.safeTransferETH(refundAmount);\n        } else {\n            // transfer base tokens in\n            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), inputAmount);\n        }\n\n        emit Buy(inputAmount, outputAmount);\n    }\n\n    /// @notice Sells fractional tokens to the pair.\n    /// @param inputAmount The amount of fractional tokens to sell.\n    /// @param minOutputAmount The minimum amount of base tokens to receive.\n    /// @return outputAmount The amount of base tokens received.\n    function sell(uint256 inputAmount, uint256 minOutputAmount) public returns (uint256 outputAmount) {\n        // *** Checks *** //\n\n        // calculate output amount using xyk invariant\n        outputAmount = sellQuote(inputAmount);\n\n        // check that the outputted amount of fractional tokens is greater than the min amount\n        require(outputAmount >= minOutputAmount, \"Slippage: amount out\");\n\n        // *** Effects *** //\n\n        // transfer fractional tokens from sender\n        _transferFrom(msg.sender, address(this), inputAmount);\n\n        // *** Interactions *** //\n\n        if (baseToken == address(0)) {\n            // transfer ether out\n            msg.sender.safeTransferETH(outputAmount);\n        } else {\n            // transfer base tokens out\n            ERC20(baseToken).safeTransfer(msg.sender, outputAmount);\n        }\n\n        emit Sell(inputAmount, outputAmount);\n    }\n\n    // ******************** //\n    //      Wrap logic      //\n    // ******************** //\n\n    /// @notice Wraps NFTs into fractional tokens.\n    /// @param tokenIds The ids of the NFTs to wrap.\n    /// @param proofs The merkle proofs for the NFTs proving that they can be used in the pair.\n    /// @return fractionalTokenAmount The amount of fractional tokens minted.\n    function wrap(uint256[] calldata tokenIds, bytes32[][] calldata proofs)\n        public\n        returns (uint256 fractionalTokenAmount)\n    {\n        // *** Checks *** //\n\n        // check that wrapping is not closed\n        require(closeTimestamp == 0, \"Wrap: closed\");\n\n        // check the tokens exist in the merkle root\n        _validateTokenIds(tokenIds, proofs);\n\n        // *** Effects *** //\n\n        // mint fractional tokens to sender\n        fractionalTokenAmount = tokenIds.length * ONE;\n        _mint(msg.sender, fractionalTokenAmount);\n\n        // *** Interactions *** //\n\n        // transfer nfts from sender\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n        }\n\n        emit Wrap(tokenIds);\n    }\n\n    /// @notice Unwraps fractional tokens into NFTs.\n    /// @param tokenIds The ids of the NFTs to unwrap.\n    /// @return fractionalTokenAmount The amount of fractional tokens burned.\n    function unwrap(uint256[] calldata tokenIds) public returns (uint256 fractionalTokenAmount) {\n        // *** Effects *** //\n\n        // burn fractional tokens from sender\n        fractionalTokenAmount = tokenIds.length * ONE;\n        _burn(msg.sender, fractionalTokenAmount);\n\n        // *** Interactions *** //\n\n        // transfer nfts to sender\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ERC721(nft).safeTransferFrom(address(this), msg.sender, tokenIds[i]);\n        }\n\n        emit Unwrap(tokenIds);\n    }\n\n    // *********************** //\n    //      NFT AMM logic      //\n    // *********************** //\n\n    /// @notice nftAdd Adds liquidity to the pair using NFTs.\n    /// @param baseTokenAmount The amount of base tokens to add.\n    /// @param tokenIds The ids of the NFTs to add.\n    /// @param minLpTokenAmount The minimum amount of lp tokens to receive.\n    /// @param proofs The merkle proofs for the NFTs.\n    /// @return lpTokenAmount The amount of lp tokens minted.\n    function nftAdd(\n        uint256 baseTokenAmount,\n        uint256[] calldata tokenIds,\n        uint256 minLpTokenAmount,\n        bytes32[][] calldata proofs\n    ) public payable returns (uint256 lpTokenAmount) {\n        // wrap the incoming NFTs into fractional tokens\n        uint256 fractionalTokenAmount = wrap(tokenIds, proofs);\n\n        // add liquidity using the fractional tokens and base tokens\n        lpTokenAmount = add(baseTokenAmount, fractionalTokenAmount, minLpTokenAmount);\n    }\n\n    /// @notice Removes liquidity from the pair using NFTs.\n    /// @param lpTokenAmount The amount of lp tokens to remove.\n    /// @param minBaseTokenOutputAmount The minimum amount of base tokens to receive.\n    /// @param tokenIds The ids of the NFTs to remove.\n    /// @return baseTokenOutputAmount The amount of base tokens received.\n    /// @return fractionalTokenOutputAmount The amount of fractional tokens received.\n    function nftRemove(uint256 lpTokenAmount, uint256 minBaseTokenOutputAmount, uint256[] calldata tokenIds)\n        public\n        returns (uint256 baseTokenOutputAmount, uint256 fractionalTokenOutputAmount)\n    {\n        // remove liquidity and send fractional tokens and base tokens to sender\n        (baseTokenOutputAmount, fractionalTok"
    }
  ]
}