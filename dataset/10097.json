{
  "Title": "[H-01] Prevent execution with invalid signatures",
  "Content": "_Submitted by gpersoon_\n\n#### Impact\nSuppose one of the supplied `addrs\\[i]` to the constructor of `Identity.sol` happens to be 0 ( by accident).\n\nIn that case: `privileges\\[0] = 1`\n\nNow suppose you call `execute()` with an invalid signature, then `recoverAddrImpl` will return a value of 0 and thus signer=0.\nIf you then check \"`privileges\\[signer] !=0`\"  this will be true and anyone can perform any transaction.\n\nThis is clearly an unwanted situation.\n\n#### Proof of Concept\n  - [`Identity.sol#L23` L30](https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/Identity.sol#L23-L30)\n  - [`Identity.sol#L97` L98](https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/Identity.sol#L97-L98)\n\n#### Recommended Mitigation Steps\nIn the constructor of `Identity.sol`, add in the for loop the following:\n\n```solidity\nrequire (addrs\\[i] !=0,\"Zero not allowed\");\n```\n\n**[Ivshti (Ambire) confirmed](https://github.com/code-423n4/2021-10-ambire-findings/issues/13#issuecomment-946844237):**\n\n**[Ivshti (Ambire) patched](https://github.com/code-423n4/2021-10-ambire-findings/issues/13#issuecomment-946894869):**\n > resolved in https://github.com/AmbireTech/adex-protocol-eth/commit/08d050676773fcdf7ec1c4eb53d51820b7e42534\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-10-ambire-findings/issues/13#issuecomment-948088151):**\n > This seems to be the risk of having `erecover` returning zero, any invalid signature ends up being usable from any address to execute arbitrary logic.\n>\n> Mitigation can be achieved by either reverting when about to return address(0), which the sponsor has used for mitigation\n>\n> The other mitigation is to ensure that an account with address(0) cannot have privileges set to 1\n>\n> I believe mitigation from sponsor to be sufficient, however I'd recommend adding a check against having address(0) in the constructor for Identity.sol just to be sure\n>\n\n**[Ivshti (Ambire) commented](https://github.com/code-423n4/2021-10-ambire-findings/issues/13#issuecomment-948276331):**\n > @GalloDeSballo an extra check is superfluous IMO, not only cause the revert on 0 in SIgnatureValidatorV2 guarantees that this is fixed, but also because it has to be in three places: constructor, setAddrPrivilege and the account creation system in `js/IdentityProxyDeploy` which rolls out bytecode that `sstores` privileges directly\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2021-10-ambire",
  "Code": [
    {
      "filename": "contracts/Identity.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.7;\n\nimport \"./libs/SignatureValidatorV2.sol\";\n\ncontract Identity {\n\tmapping (address => bytes32) public privileges;\n\t// The next allowed nonce\n\tuint public nonce = 0;\n\n\t// Events\n\tevent LogPrivilegeChanged(address indexed addr, bytes32 priv);\n\tevent LogErr(address indexed to, uint value, bytes data, bytes returnData); // only used in tryCatch\n\n\t// Transaction structure\n\t// we handle replay protection separately by requiring (address(this), chainID, nonce) as part of the sig\n\tstruct Transaction {\n\t\taddress to;\n\t\tuint value;\n\t\tbytes data;\n\t}\n\n\tconstructor(address[] memory addrs) {\n\t\tuint len = addrs.length;\n\t\tfor (uint i=0; i<len; i++) {\n\t\t\t// @TODO should we allow setting to any arb value here?\n\t\t\tprivileges[addrs[i]] = bytes32(uint(1));\n\t\t\temit LogPrivilegeChanged(addrs[i], bytes32(uint(1)));\n\t\t}\n\t}\n\n\t// This contract can accept ETH without calldata\n\treceive() external payable {}\n\n\t// This contract can accept ETH with calldata\n\t// However, to support EIP 721 and EIP 1155, we need to respond to those methods with their own method signature\n\tfallback() external payable {\n\t\tbytes4 method = msg.sig;\n\t\tif (\n\t\t\tmethod == 0x150b7a02 // bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))\n\t\t\t\t|| method == 0xf23a6e61 // bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))\n\t\t\t\t|| method == 0xbc197c81 // bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))\n\t\t) {\n\t\t\t// Copy back the method\n\t\t\t// solhint-disable-next-line no-inline-assembly\n\t\t\tassembly {\n\t\t\t\tcalldatacopy(0, 0, 0x04)\n\t\t\t\treturn (0, 0x20)\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction setAddrPrivilege(address addr, bytes32 priv)\n\t\texternal\n\t{\n\t\trequire(msg.sender == address(this), 'ONLY_IDENTITY_CAN_CALL');\n\t\t// Anti-bricking measure: if the privileges slot is used for special data (not 0x01),\n\t\t// don't allow to set it to true\n\t\tif (privileges[addr] != bytes32(0) && privileges[addr] != bytes32(uint(1)))\n\t\t\trequire(priv != bytes32(uint(1)), 'UNSETTING_SPECIAL_DATA');\n\t\tprivileges[addr] = priv;\n\t\temit LogPrivilegeChanged(addr, priv);\n\t}\n\n\tfunction tipMiner(uint amount)\n\t\texternal\n\t{\n\t\trequire(msg.sender == address(this), 'ONLY_IDENTITY_CAN_CALL');\n\t\t// See https://docs.flashbots.net/flashbots-auction/searchers/advanced/coinbase-payment/#managing-payments-to-coinbaseaddress-when-it-is-a-contract\n\t\t// generally this contract is reentrancy proof cause of the nonce\n\t\texecuteCall(block.coinbase, amount, new bytes(0));\n\t}\n\n\tfunction tryCatch(address to, uint value, bytes calldata data)\n\t\texternal\n\t{\n\t\trequire(msg.sender == address(this), 'ONLY_IDENTITY_CAN_CALL');\n\t\t(bool success, bytes memory returnData) = to.call{value: value, gas: gasleft()}(data);\n\t\tif (!success) emit LogErr(to, value, data, returnData);\n\t}\n\n\n\t// WARNING: if the signature of this is changed, we have to change IdentityFactory\n\tfunction execute(Transaction[] calldata txns, bytes calldata signature)\n\t\texternal\n\t{\n\t\trequire(txns.length > 0, 'MUST_PASS_TX');\n\t\t// If we use the naive abi.encode(txn) and have a field of type `bytes`,\n\t\t// there is a discrepancy between ethereumjs-abi and solidity\n\t\t// @TODO check if this is resolved\n\t\tuint currentNonce = nonce;\n\t\t// NOTE: abi.encode is safer than abi.encodePacked in terms of collision safety\n\t\tbytes32 hash = keccak256(abi.encode(address(this), block.chainid, currentNonce, txns));\n\t\t// We have to increment before execution cause it protects from reentrancies\n\t\tnonce = currentNonce + 1;\n\n\t\taddress signer = SignatureValidator.recoverAddrImpl(hash, signature, true);\n\t\trequire(privileges[signer] != bytes32(0), 'INSUFFICIENT_PRIVILEGE');\n\t\tuint len = txns.length;\n\t\tfor (uint i=0; i<len; i++) {\n\t\t\tTransaction memory txn = txns[i];\n\t\t\texecuteCall(txn.to, txn.value, txn.data);\n\t\t}\n\t\t// The actual anti-bricking mechanism - do not allow a signer to drop their own priviledges\n\t\trequire(privileges[signer] != bytes32(0), 'PRIVILEGE_NOT_DOWNGRADED');\n\t}\n\n\t// no need for nonce management here cause we're not dealing with sigs\n\tfunction executeBySender(Transaction[] calldata txns) external {\n\t\trequire(txns.length > 0, 'MUST_PASS_TX');\n\t\trequire(privileges[msg.sender] != bytes32(0), 'INSUFFICIENT_PRIVILEGE');\n\t\tuint len = txns.length;\n\t\tfor (uint i=0; i<len; i++) {\n\t\t\tTransaction memory txn = txns[i];\n\t\t\texecuteCall(txn.to, txn.value, txn.data);\n\t\t}\n\t\t// again, anti-bricking\n\t\trequire(privileges[msg.sender] != bytes32(0), 'PRIVILEGE_NOT_DOWNGRADED');\n\t}\n\n\t// we shouldn't use address.call(), cause: https://github.com/ethereum/solidity/issues/2884\n\t// copied from https://github.com/uport-project/uport-identity/blob/develop/contracts/Proxy.sol\n\t// there's also\n\t// https://github.com/gnosis/MultiSigWallet/commit/e1b25e8632ca28e9e9e09c81bd20bf33fdb405ce\n\t// https://github.com/austintgriffith/bouncer-proxy/blob/master/BouncerProxy/BouncerProxy.sol\n\t// https://github.com/gnosis/safe-contracts/blob/7e2eeb3328bb2ae85c36bc11ea6afc14baeb663c/contracts/base/Executor.sol\n\tfunction executeCall(address to, uint256 value, bytes memory data)\n\t\tinternal\n\t{\n\t\tassembly {\n\t\t\tlet result := call(gas(), to, value, add(data, 0x20), mload(data), 0, 0)\n\n\t\t\tswitch result case 0 {\n\t\t\t\tlet size := returndatasize()\n\t\t\t\tlet ptr := mload(0x40)\n\t\t\t\treturndatacopy(ptr, 0, size)\n\t\t\t\trevert(ptr, size)\n\t\t\t}\n\t\t\tdefault {}\n\t\t}\n\t\t// A single call consumes around 477 more gas with the pure solidity version, for whatever reason\n\t\t//(bool success, bytes memory returnData) = to.call{value: value, gas: gasleft()}(data);\n\t\t//if (!success) revert(string(data));\n\t}\n\n\t// EIP 1271 implementation\n\t// see https://eips.ethereum.org/EIPS/eip-1271\n\tfunction isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4) {\n\t\tif (privileges[SignatureValidator.recoverAddr(hash, signature)] != bytes32(0)) {\n\t\t\t// bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\n\t\t\treturn 0x1626ba7e;\n\t\t} else {\n\t\t\treturn 0xffffffff;\n\t\t}\n\t}\n\n\t// EIP 1155 implementation\n\t// we pretty much only need to signal that we support the interface for 165, but for 1155 we also need the fallback function\n\tfunction supportsInterface(bytes4 interfaceID) external pure returns (bool) {\n\t\treturn\n\t\t\tinterfaceID == 0x01ffc9a7 ||    // ERC-165 support (i.e. `bytes4(keccak256('supportsInterface(bytes4)'))`).\n\t\t\tinterfaceID == 0x4e2312e0;      // ERC-1155 `ERC1155TokenReceiver` support (i.e. `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\")) ^ bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`).\n\t}\n}"
    },
    {
      "filename": "contracts/Identity.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.7;\n\nimport \"./libs/SignatureValidatorV2.sol\";\n\ncontract Identity {\n\tmapping (address => bytes32) public privileges;\n\t// The next allowed nonce\n\tuint public nonce = 0;\n\n\t// Events\n\tevent LogPrivilegeChanged(address indexed addr, bytes32 priv);\n\tevent LogErr(address indexed to, uint value, bytes data, bytes returnData); // only used in tryCatch\n\n\t// Transaction structure\n\t// we handle replay protection separately by requiring (address(this), chainID, nonce) as part of the sig\n\tstruct Transaction {\n\t\taddress to;\n\t\tuint value;\n\t\tbytes data;\n\t}\n\n\tconstructor(address[] memory addrs) {\n\t\tuint len = addrs.length;\n\t\tfor (uint i=0; i<len; i++) {\n\t\t\t// @TODO should we allow setting to any arb value here?\n\t\t\tprivileges[addrs[i]] = bytes32(uint(1));\n\t\t\temit LogPrivilegeChanged(addrs[i], bytes32(uint(1)));\n\t\t}\n\t}\n\n\t// This contract can accept ETH without calldata\n\treceive() external payable {}\n\n\t// This contract can accept ETH with calldata\n\t// However, to support EIP 721 and EIP 1155, we need to respond to those methods with their own method signature\n\tfallback() external payable {\n\t\tbytes4 method = msg.sig;\n\t\tif (\n\t\t\tmethod == 0x150b7a02 // bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))\n\t\t\t\t|| method == 0xf23a6e61 // bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))\n\t\t\t\t|| method == 0xbc197c81 // bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))\n\t\t) {\n\t\t\t// Copy back the method\n\t\t\t// solhint-disable-next-line no-inline-assembly\n\t\t\tassembly {\n\t\t\t\tcalldatacopy(0, 0, 0x04)\n\t\t\t\treturn (0, 0x20)\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction setAddrPrivilege(address addr, bytes32 priv)\n\t\texternal\n\t{\n\t\trequire(msg.sender == address(this), 'ONLY_IDENTITY_CAN_CALL');\n\t\t// Anti-bricking measure: if the privileges slot is used for special data (not 0x01),\n\t\t// don't allow to set it to true\n\t\tif (privileges[addr] != bytes32(0) && privileges[addr] != bytes32(uint(1)))\n\t\t\trequire(priv != bytes32(uint(1)), 'UNSETTING_SPECIAL_DATA');\n\t\tprivileges[addr] = priv;\n\t\temit LogPrivilegeChanged(addr, priv);\n\t}\n\n\tfunction tipMiner(uint amount)\n\t\texternal\n\t{\n\t\trequire(msg.sender == address(this), 'ONLY_IDENTITY_CAN_CALL');\n\t\t// See https://docs.flashbots.net/flashbots-auction/searchers/advanced/coinbase-payment/#managing-payments-to-coinbaseaddress-when-it-is-a-contract\n\t\t// generally this contract is reentrancy proof cause of the nonce\n\t\texecuteCall(block.coinbase, amount, new bytes(0));\n\t}\n\n\tfunction tryCatch(address to, uint value, bytes calldata data)\n\t\texternal\n\t{\n\t\trequire(msg.sender == address(this), 'ONLY_IDENTITY_CAN_CALL');\n\t\t(bool success, bytes memory returnData) = to.call{value: value, gas: gasleft()}(data);\n\t\tif (!success) emit LogErr(to, value, data, returnData);\n\t}\n\n\n\t// WARNING: if the signature of this is changed, we have to change IdentityFactory\n\tfunction execute(Transaction[] calldata txns, bytes calldata signature)\n\t\texternal\n\t{\n\t\trequire(txns.length > 0, 'MUST_PASS_TX');\n\t\t// If we use the naive abi.encode(txn) and have a field of type `bytes`,\n\t\t// there is a discrepancy between ethereumjs-abi and solidity\n\t\t// @TODO check if this is resolved\n\t\tuint currentNonce = nonce;\n\t\t// NOTE: abi.encode is safer than abi.encodePacked in terms of collision safety\n\t\tbytes32 hash = keccak256(abi.encode(address(this), block.chainid, currentNonce, txns));\n\t\t// We have to increment before execution cause it protects from reentrancies\n\t\tnonce = currentNonce + 1;\n\n\t\taddress signer = SignatureValidator.recoverAddrImpl(hash, signature, true);\n\t\trequire(privileges[signer] != bytes32(0), 'INSUFFICIENT_PRIVILEGE');\n\t\tuint len = txns.length;\n\t\tfor (uint i=0; i<len; i++) {\n\t\t\tTransaction memory txn = txns[i];\n\t\t\texecuteCall(txn.to, txn.value, txn.data);\n\t\t}\n\t\t// The actual anti-bricking mechanism - do not allow a signer to drop their own priviledges\n\t\trequire(privileges[signer] != bytes32(0), 'PRIVILEGE_NOT_DOWNGRADED');\n\t}\n\n\t// no need for nonce management here cause we're not dealing with sigs\n\tfunction executeBySender(Transaction[] calldata txns) external {\n\t\trequire(txns.length > 0, 'MUST_PASS_TX');\n\t\trequire(privileges[msg.sender] != bytes32(0), 'INSUFFICIENT_PRIVILEGE');\n\t\tuint len = txns.length;\n\t\tfor (uint i=0; i<len; i++) {\n\t\t\tTransaction memory txn = txns[i];\n\t\t\texecuteCall(txn.to, txn.value, txn.data);\n\t\t}\n\t\t// again, anti-bricking\n\t\trequire(privileges[msg.sender] != bytes32(0), 'PRIVILEGE_NOT_DOWNGRADED');\n\t}\n\n\t// we shouldn't use address.call(), cause: https://github.com/ethereum/solidity/issues/2884\n\t// copied from https://github.com/uport-project/uport-identity/blob/develop/contracts/Proxy.sol\n\t// there's also\n\t// https://github.com/gnosis/MultiSigWallet/commit/e1b25e8632ca28e9e9e09c81bd20bf33fdb405ce\n\t// https://github.com/austintgriffith/bouncer-proxy/blob/master/BouncerProxy/BouncerProxy.sol\n\t// https://github.com/gnosis/safe-contracts/blob/7e2eeb3328bb2ae85c36bc11ea6afc14baeb663c/contracts/base/Executor.sol\n\tfunction executeCall(address to, uint256 value, bytes memory data)\n\t\tinternal\n\t{\n\t\tassembly {\n\t\t\tlet result := call(gas(), to, value, add(data, 0x20), mload(data), 0, 0)\n\n\t\t\tswitch result case 0 {\n\t\t\t\tlet size := returndatasize()\n\t\t\t\tlet ptr := mload(0x40)\n\t\t\t\treturndatacopy(ptr, 0, size)\n\t\t\t\trevert(ptr, size)\n\t\t\t}\n\t\t\tdefault {}\n\t\t}\n\t\t// A single call consumes around 477 more gas with the pure solidity version, for whatever reason\n\t\t//(bool success, bytes memory returnData) = to.call{value: value, gas: gasleft()}(data);\n\t\t//if (!success) revert(string(data));\n\t}\n\n\t// EIP 1271 implementation\n\t// see https://eips.ethereum.org/EIPS/eip-1271\n\tfunction isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4) {\n\t\tif (privileges[SignatureValidator.recoverAddr(hash, signature)] != bytes32(0)) {\n\t\t\t// bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\n\t\t\treturn 0x1626ba7e;\n\t\t} else {\n\t\t\treturn 0xffffffff;\n\t\t}\n\t}\n\n\t// EIP 1155 implementation\n\t// we pretty much only need to signal that we support the interface for 165, but for 1155 we also need the fallback function\n\tfunction supportsInterface(bytes4 interfaceID) external pure returns (bool) {\n\t\treturn\n\t\t\tinterfaceID == 0x01ffc9a7 ||    // ERC-165 support (i.e. `bytes4(keccak256('supportsInterface(bytes4)'))`).\n\t\t\tinterfaceID == 0x4e2312e0;      // ERC-1155 `ERC1155TokenReceiver` support (i.e. `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\")) ^ bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`).\n\t}\n}"
    }
  ]
}