{
  "Title": "[N-05] Missing event for critical parameter change",
  "Content": "\n*There are 2 instances of this issue:*\n```solidity\nFile: smart-contracts/ConvexCurveLPVault.sol   #1\n\n37      function setConfiguration(address _lpToken, uint256 _poolId) external onlyAdmin {\n38        require(internalAssetToken == address(0), Errors.VT_INVALID_CONFIGURATION);\n39    \n40        convexBooster = 0xF403C135812408BFbE8713b5A23a04b3D48AAE31;\n41        curveLPToken = _lpToken;\n42        convexPoolId = _poolId;\n43        SturdyInternalAsset _interalToken = new SturdyInternalAsset(\n44          string(abi.encodePacked('Sturdy ', IERC20Detailed(_lpToken).symbol())),\n45          string(abi.encodePacked('c', IERC20Detailed(_lpToken).symbol())),\n46          IERC20Detailed(_lpToken).decimals()\n47        );\n48        internalAssetToken = address(_interalToken);\n49:     }\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L37-L49\n\n```solidity\nFile: smart-contracts/YieldManager.sol   #2\n\n64      function setExchangeToken(address _token) external onlyAdmin {\n65        require(_token != address(0), Errors.VT_INVALID_CONFIGURATION);\n66        _exchangeToken = _token;\n67:     }\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L64-L67\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-05-sturdy",
  "Code": [
    {
      "filename": "smart-contracts/ConvexCurveLPVault.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {GeneralVault} from '../../GeneralVault.sol';\nimport {IERC20} from '../../../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {SafeERC20} from '../../../../dependencies/openzeppelin/contracts/SafeERC20.sol';\nimport {IERC20Detailed} from '../../../../dependencies/openzeppelin/contracts/IERC20Detailed.sol';\nimport {IConvexBooster} from '../../../../interfaces/IConvexBooster.sol';\nimport {IConvexBaseRewardPool} from '../../../../interfaces/IConvexBaseRewardPool.sol';\nimport {TransferHelper} from '../../../libraries/helpers/TransferHelper.sol';\nimport {Errors} from '../../../libraries/helpers/Errors.sol';\nimport {SturdyInternalAsset} from '../../../tokenization/SturdyInternalAsset.sol';\n\ninterface IRewards {\n  function rewardToken() external view returns (address);\n}\n\n/**\n * @title ConvexCurveLPVault\n * @notice Curve LP Token Vault by using Convex on Ethereum\n * @author Sturdy\n **/\ncontract ConvexCurveLPVault is GeneralVault {\n  using SafeERC20 for IERC20;\n\n  address public convexBooster;\n  address internal curveLPToken;\n  address internal internalAssetToken;\n  uint256 internal convexPoolId;\n\n  /**\n   * @dev The function to set parameters related to convex/curve\n   * @param _lpToken The address of Curve LP Token which will be used in vault\n   * @param _poolId  The convex pool Id for Curve LP Token\n   */\n  function setConfiguration(address _lpToken, uint256 _poolId) external onlyAdmin {\n    require(internalAssetToken == address(0), Errors.VT_INVALID_CONFIGURATION);\n\n    convexBooster = 0xF403C135812408BFbE8713b5A23a04b3D48AAE31;\n    curveLPToken = _lpToken;\n    convexPoolId = _poolId;\n    SturdyInternalAsset _interalToken = new SturdyInternalAsset(\n      string(abi.encodePacked('Sturdy ', IERC20Detailed(_lpToken).symbol())),\n      string(abi.encodePacked('c', IERC20Detailed(_lpToken).symbol())),\n      IERC20Detailed(_lpToken).decimals()\n    );\n    internalAssetToken = address(_interalToken);\n  }\n\n  /**\n   * @dev The function to get internal asset address\n   */\n  function getInternalAsset() external view returns (address) {\n    return internalAssetToken;\n  }\n\n  /**\n   * @dev The function to get rewards token address\n   */\n  function getBaseRewardPool() internal view returns (address) {\n    IConvexBooster.PoolInfo memory poolInfo = IConvexBooster(convexBooster).poolInfo(convexPoolId);\n    return poolInfo.crvRewards;\n  }\n\n  /**\n   * @dev The function to send rewards to YieldManager & Treasury\n   * @param _asset The rewards token address\n   */\n  function _transferYield(address _asset) internal {\n    require(_asset != address(0), Errors.VT_PROCESS_YIELD_INVALID);\n    uint256 yieldAmount = IERC20(_asset).balanceOf(address(this));\n\n    // transfer to treasury\n    if (_vaultFee > 0) {\n      uint256 treasuryAmount = _processTreasury(_asset, yieldAmount);\n      yieldAmount = yieldAmount.sub(treasuryAmount);\n    }\n\n    // transfer to yieldManager\n    address yieldManager = _addressesProvider.getAddress('YIELD_MANAGER');\n    TransferHelper.safeTransfer(_asset, yieldManager, yieldAmount);\n\n    emit ProcessYield(_asset, yieldAmount);\n  }\n\n  function processYield() external override onlyAdmin {\n    // Claim Rewards(CRV, CVX, Extra incentive tokens)\n    address baseRewardPool = getBaseRewardPool();\n    IConvexBaseRewardPool(baseRewardPool).getReward();\n\n    // Transfer CRV to YieldManager\n    address _token = _addressesProvider.getAddress('CRV');\n    address _tokenFromConvex = IConvexBaseRewardPool(baseRewardPool).rewardToken();\n    require(_token == _tokenFromConvex, Errors.VT_INVALID_CONFIGURATION);\n    _transferYield(_token);\n\n    // Transfer CVX to YieldManager\n    _token = _addressesProvider.getAddress('CVX');\n    _tokenFromConvex = IConvexBooster(convexBooster).minter();\n    require(_token == _tokenFromConvex, Errors.VT_INVALID_CONFIGURATION);\n    _transferYield(_token);\n\n    // Transfer extra incentive token to YieldManager\n    uint256 extraRewardsLength = IConvexBaseRewardPool(baseRewardPool).extraRewardsLength();\n    for (uint256 i = 0; i < extraRewardsLength; i++) {\n      address _extraReward = IConvexBaseRewardPool(baseRewardPool).extraRewards(i);\n      address _rewardToken = IRewards(_extraReward).rewardToken();\n      _transferYield(_rewardToken);\n    }\n  }\n\n  /**\n   * @dev Get yield amount based on strategy\n   */\n  function getYieldAmount() external view returns (uint256) {\n    return _getYieldAmount(internalAssetToken);\n  }\n\n  /**\n   * @dev Get price per share based on yield strategy\n   */\n  function pricePerShare() external view override returns (uint256) {\n    uint256 decimals = IERC20Detailed(internalAssetToken).decimals();\n    return 10**decimals;\n  }\n\n  /**\n   * @dev Deposit to yield pool based on strategy and mint internal asset\n   */\n  function _depositToYieldPool(address _asset, uint256 _amount)\n    internal\n    override\n    returns (address, uint256)\n  {\n    // receive Curve LP Token from user\n    require(_asset == curveLPToken, Errors.VT_COLLATERAL_DEPOSIT_INVALID);\n    TransferHelper.safeTransferFrom(curveLPToken, msg.sender, address(this), _amount);\n\n    // deposit Curve LP Token to Convex\n    IERC20(curveLPToken).safeApprove(convexBooster, _amount);\n    IConvexBooster(convexBooster).deposit(convexPoolId, _amount, true);\n\n    // mint\n    SturdyInternalAsset(internalAssetToken).mint(address(this), _amount);\n    IERC20(internalAssetToken).safeApprove(address(_addressesProvider.getLendingPool()), _amount);\n\n    return (internalAssetToken, _amount);\n  }\n\n  /**\n   * @dev Get Withdrawal amount of Curve LP Token based on strategy\n   */\n  function _getWithdrawalAmount(address _asset, uint256 _amount)\n    internal\n    view\n    override\n    returns (address, uint256)\n  {\n    // In this vault, return same amount of asset.\n    return (internalAssetToken, _amount);\n  }\n\n  function _withdraw(uint256 _amount, address _to) internal returns (uint256) {\n    // Withdraw from Convex\n    address baseRewardPool = getBaseRewardPool();\n    IConvexBaseRewardPool(baseRewardPool).withdrawAndUnwrap(_amount, true);\n\n    // Deliver Curve LP Token\n    TransferHelper.safeTransfer(curveLPToken, _to, _amount);\n\n    // Burn\n    SturdyInternalAsset(internalAssetToken).burn(address(this), _amount);\n\n    return _amount;\n  }\n\n  function withdrawOnLiquidation(address _asset, uint256 _amount)\n    external\n    override\n    returns (uint256)\n  {\n    require(_asset == curveLPToken, Errors.LP_LIQUIDATION_CALL_FAILED);\n    require(msg.sender == _addressesProvider.getLendingPool(), Errors.LP_LIQUIDATION_CALL_FAILED);\n\n    return _withdraw(_amount, msg.sender);\n  }\n\n  /**\n   * @dev Withdraw from yield pool based on strategy and deliver asset\n   */\n  function _withdrawFromYieldPool(\n    address _asset,\n    uint256 _amount,\n    address _to\n  ) internal override returns (uint256) {\n    require(_asset == curveLPToken, Errors.VT_COLLATERAL_WITHDRAW_INVALID);\n\n    return _withdraw(_amount, _to);\n  }\n\n  /**\n   * @dev Move some yield(CRV) to treasury\n   */\n  function _processTreasury(address _asset, uint256 _yieldAmount) internal returns (uint256) {\n    uint256 treasuryAmount = _yieldAmount.percentMul(_vaultFee);\n    IERC20(_asset).safeTransfer(_treasuryAddress, treasuryAmount);\n    return treasuryAmount;\n  }\n}"
    },
    {
      "filename": "smart-contracts/YieldManager.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {Errors} from '../libraries/helpers/Errors.sol';\nimport {VersionedInitializable} from '../../protocol/libraries/sturdy-upgradeability/VersionedInitializable.sol';\nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol';\nimport {ILendingPool} from '../../interfaces/ILendingPool.sol';\nimport {IPriceOracleGetter} from '../../interfaces/IPriceOracleGetter.sol';\nimport {ISwapRouter} from '../../interfaces/ISwapRouter.sol';\nimport {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {IERC20Detailed} from '../../dependencies/openzeppelin/contracts/IERC20Detailed.sol';\nimport {Ownable} from '../../dependencies/openzeppelin/contracts/Ownable.sol';\nimport {PercentageMath} from '../libraries/math/PercentageMath.sol';\nimport {SafeMath} from '../../dependencies/openzeppelin/contracts/SafeMath.sol';\nimport {TransferHelper} from '../libraries/helpers/TransferHelper.sol';\nimport {UniswapAdapter} from '../libraries/swap/UniswapAdapter.sol';\nimport {CurveswapAdapter} from '../libraries/swap/CurveswapAdapter.sol';\n\n/**\n * @title YieldManager\n * @notice yield distributor by swapping from assets to stable coin\n * @author Sturdy\n **/\n\ncontract YieldManager is VersionedInitializable, Ownable {\n  using SafeMath for uint256;\n  using PercentageMath for uint256;\n\n  struct AssetYield {\n    address asset;\n    uint256 amount;\n  }\n\n  // the list of the available reserves, structured as a mapping for gas savings reasons\n  mapping(uint256 => address) internal _assetsList;\n  uint256 internal _assetsCount;\n\n  ILendingPoolAddressesProvider internal _addressesProvider;\n\n  uint256 public constant VAULT_REVISION = 0x1;\n\n  address public _exchangeToken;\n\n  // tokenIn -> tokenOut -> Curve Pool Address\n  mapping(address => mapping(address => address)) internal _curvePools;\n\n  uint256 public constant UNISWAP_FEE = 10000; // 1%\n  uint256 public constant SLIPPAGE = 500; // 5%\n\n  modifier onlyAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  /**\n   * @dev Function is invoked by the proxy contract when the Vault contract is deployed.\n   * @param _provider The address of the provider\n   **/\n  function initialize(ILendingPoolAddressesProvider _provider) public initializer {\n    _addressesProvider = _provider;\n  }\n\n  function setExchangeToken(address _token) external onlyAdmin {\n    require(_token != address(0), Errors.VT_INVALID_CONFIGURATION);\n    _exchangeToken = _token;\n  }\n\n  function getRevision() internal pure override returns (uint256) {\n    return VAULT_REVISION;\n  }\n\n  function registerAsset(address _asset) external onlyAdmin {\n    _assetsList[_assetsCount] = _asset;\n    _assetsCount = _assetsCount + 1;\n  }\n\n  function getAssetCount() external view returns (uint256) {\n    return _assetsCount;\n  }\n\n  function getAssetInfo(uint256 _index) external view returns (address) {\n    return _assetsList[_index];\n  }\n\n  /**\n   * @dev Function to set Curve Pool address for the swap\n   * @param _tokenIn The address of token being exchanged\n   * @param _tokenOut The address of token being received\n   * @param _pool The address of the Curve pool to use for the swap\n   */\n  function setCurvePool(\n    address _tokenIn,\n    address _tokenOut,\n    address _pool\n  ) external onlyAdmin {\n    require(_pool != address(0), Errors.VT_INVALID_CONFIGURATION);\n    _curvePools[_tokenIn][_tokenOut] = _pool;\n  }\n\n  /**\n   * @dev Function to get Curve Pool address for the swap\n   * @param _tokenIn The address of token being sent\n   * @param _tokenOut The address of token being received\n   */\n  function getCurvePool(address _tokenIn, address _tokenOut) external view returns (address) {\n    return _curvePools[_tokenIn][_tokenOut];\n  }\n\n  /**\n   * @dev Distribute the yield of assets to suppliers.\n   *      1. convert asset to exchange token(for now it's USDC) via Uniswap\n   *      2. convert exchange token to other stables via Curve\n   *      3. deposit to pool for suppliers\n   * @param _offset assets array's start offset.\n   * @param _count assets array's count when perform distribution.\n   **/\n  function distributeYield(uint256 _offset, uint256 _count) external onlyAdmin {\n    // 1. convert from asset to exchange token via uniswap\n    for (uint256 i = 0; i < _count; i++) {\n      address asset = _assetsList[_offset + i];\n      require(asset != address(0), Errors.UL_INVALID_INDEX);\n      uint256 _amount = IERC20Detailed(asset).balanceOf(address(this));\n      _convertAssetToExchangeToken(asset, _amount);\n    }\n    uint256 exchangedAmount = IERC20Detailed(_exchangeToken).balanceOf(address(this));\n\n    // 2. convert from exchange token to other stable assets via curve swap\n    AssetYield[] memory assetYields = _getAssetYields(exchangedAmount);\n    for (uint256 i = 0; i < assetYields.length; i++) {\n      if (assetYields[i].amount > 0) {\n        uint256 _amount = _convertToStableCoin(assetYields[i].asset, assetYields[i].amount);\n        // 3. deposit Yield to pool for suppliers\n        _depositYield(assetYields[i].asset, _amount);\n      }\n    }\n  }\n\n  /**\n   * @dev Get the list of asset and asset's yield amount\n   **/\n  function _getAssetYields(uint256 _totalYieldAmount) internal view returns (AssetYield[] memory) {\n    // Get total borrowing asset volume and volumes and assets\n    (\n      uint256 totalVolume,\n      uint256[] memory volumes,\n      address[] memory assets,\n      uint256 length\n    ) = ILendingPool(_addressesProvider.getLendingPool()).getBorrowingAssetAndVolumes();\n\n    if (totalVolume == 0) return new AssetYield[](0);\n\n    AssetYield[] memory assetYields = new AssetYield[](length);\n    uint256 extraYieldAmount = _totalYieldAmount;\n\n    for (uint256 i = 0; i < length; i++) {\n      assetYields[i].asset = assets[i];\n      if (i != length - 1) {\n        // Distribute yieldAmount based on percent of asset volume\n        assetYields[i].amount = _totalYieldAmount.percentMul(\n          volumes[i].mul(PercentageMath.PERCENTAGE_FACTOR).div(totalVolume)\n        );\n        extraYieldAmount = extraYieldAmount.sub(assetYields[i].amount);\n      } else {\n        // without calculation, set remained extra amount\n        assetYields[i].amount = extraYieldAmount;\n      }\n    }\n\n    return assetYields;\n  }\n\n  /**\n   * @dev Convert asset to exchange token via Uniswap\n   * @param asset The address of asset being exchanged\n   * @param amount The amount of asset being exchanged\n   */\n  function _convertAssetToExchangeToken(address asset, uint256 amount) internal {\n    UniswapAdapter.swapExactTokensForTokens(\n      _addressesProvider,\n      asset,\n      _exchangeToken,\n      amount,\n      UNISWAP_FEE,\n      SLIPPAGE\n    );\n  }\n\n  /**\n   * @dev The function to convert from exchange token to stable coin via Curve\n   * @param _tokenOut The address of stable coin\n   * @param _amount The amount of exchange token being sent\n   * @return receivedAmount The amount of stable coin converted\n   */\n  function _convertToStableCoin(address _tokenOut, uint256 _amount)\n    internal\n    returns (uint256 receivedAmount)\n  {\n    if (_tokenOut == _exchangeToken) {\n      return _amount;\n    }\n    address _pool = _curvePools[_exchangeToken][_tokenOut];\n    require(_pool != address(0), Errors.VT_INVALID_CONFIGURATION);\n    receivedAmount = CurveswapAdapter.swapExactTokensForTokens(\n      _addressesProvider,\n      _pool,\n      _exchangeToken,\n      _tokenOut,\n      _amount,\n      SLIPPAGE\n    );\n  }\n\n  /**\n   * @dev The function to deposit yield to pool for suppliers\n   * @param _asset The address of yield asset\n   * @param _amount The mount of asset\n   */\n  function _depositYield(address _asset, uint256 _amount) internal {\n    address _lendingPool = _addressesProvider.getLendingPool();\n    IERC20(_asset).approve(_lendingPool, _amount);\n    ILendingPool(_lendingPool).depositYield(_asset, _amount);\n  }\n}"
    }
  ]
}