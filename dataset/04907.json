{
  "Title": "[M-12] Invocation delays are not honoured when protocol unpauses",
  "Content": "\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L78> \n\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L258>\n\n***Context:*** The protocol has `pause()` and [unpause()](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L78) functions inside `EssentialContract.sol` which are tracked throughout the protocol via the modifiers [whenPaused](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L53) and [whenNotPaused](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L58).\n\n***Issue:*** Various delays and time lapses throughout the protocol ignore the effect of such pauses. The example in focus being that of `processMessage()` which does not take into account the pause duration while [checking invocationDelay and invocationExtraDelay](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L233-L258). One impact of this is that it allows a non-preferred executor to front run a preferredExecutor, after an unpause.\n\n```js\n  File: contracts/bridge/Bridge.sol\n\n  233: @--->            (uint256 invocationDelay, uint256 invocationExtraDelay) = getInvocationDelays();\n  234:          \n  235:                  if (!isMessageProven) {\n  236:                      if (!_proveSignalReceived(signalService, msgHash, _message.srcChainId, _proof)) {\n  237:                          revert B_NOT_RECEIVED();\n  238:                      }\n  239:          \n  240:                      receivedAt = uint64(block.timestamp);\n  241:          \n  242:                      if (invocationDelay != 0) {\n  243:                          proofReceipt[msgHash] = ProofReceipt({\n  244:                              receivedAt: receivedAt,\n  245:                              preferredExecutor: _message.gasLimit == 0 ? _message.destOwner : msg.sender\n  246:                          });\n  247:                      }\n  248:                  }\n  249:          \n  250:                  if (invocationDelay != 0 && msg.sender != proofReceipt[msgHash].preferredExecutor) {\n  251:                      // If msg.sender is not the one that proved the message, then there\n  252:                      // is an extra delay.\n  253:                      unchecked {\n  254:                          invocationDelay += invocationExtraDelay;\n  255:                      }\n  256:                  }\n  257:          \n  258: @--->            if (block.timestamp >= invocationDelay + receivedAt) {\n```\n\n### Description & Impact\n\nConsider the following flow:\n\n*   Assumption: `invocationDelay = 60 minutes` and `invocationExtraDelay = 30 minutes`.\n*   A message is sent.\n*   First call to `processMessage()` occurred at `t` where it was proven by Bob i.e. its `receivedAt = t`. Bob is marked as the `preferredExecutor`.\n*   Preferred executor should be able to call `processMessage()` at `t+60` while a non-preferred executor should be able to call it only at `t+90` due to the code logic on [L250](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L250).\n*   At `t+55`, protocol is paused.\n*   At `t+100`, protocol is unpaused.\n*   ***Impact:*** The 30-minute time window advantage which the preferred executor had over the non-preferred one is now lost to him. [L258](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L258) now considers the invocation delays to have passed and hence the non-preferred executor can immediately call `processMessage()` by front-running Bob and hence pocketing the reward of `message.fee` on [L98](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L298).\n\n```js\n  File: contracts/bridge/Bridge.sol\n\n  293:                      // Refund the processing fee\n  294:                      if (msg.sender == refundTo) {\n  295:                          refundTo.sendEther(_message.fee + refundAmount);\n  296:                      } else {\n  297:                          // If sender is another address, reward it and refund the rest\n  298: @--->                    msg.sender.sendEther(_message.fee);\n  299:                          refundTo.sendEther(refundAmount);\n  300:                      }\n```\n\nSimilar behaviour where the paused time is ignored by the protocol can be witnessed in:\n\n*   [recallMessage()](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L187-L189) which similarly uses `invocationDelay`. However, no `invocationExtraDelay` is used there.\n*   [TimelockTokenPool.sol](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol) for:\n\n```js\n        // If non-zero, indicates the start time for the recipient to receive\n        // tokens, subject to an unlocking schedule.\n        uint64 grantStart;\n        // If non-zero, indicates the time after which the token to be received\n        // will be actually non-zero\n        uint64 grantCliff;\n        // If non-zero, specifies the total seconds required for the recipient\n        // to fully own all granted tokens.\n        uint32 grantPeriod;\n        // If non-zero, indicates the start time for the recipient to unlock\n        // tokens.\n        uint64 unlockStart;\n        // If non-zero, indicates the time after which the unlock will be\n        // actually non-zero\n        uint64 unlockCliff;\n        // If non-zero, specifies the total seconds required for the recipient\n        // to fully unlock all owned tokens.\n        uint32 unlockPeriod;\n```\n\n*   [TaikoData.sol](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol) for:\n\n```js\n        // The max period in seconds that a blob can be reused for DA.\n        uint24 blobExpiry;\n```\n\n### Recommended Mitigation Steps\n\nIntroduce a new variable which keeps track of how much time has already been spent in the valid wait window before a pause happened. Also track the last unpause timestamp (similar to how it is done in [pauseProving()](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L111) and [unpausing](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L124) mechanisms).\nAlso refer my other recommendation under the report titled: *\"Incorrect calculations for cooldownWindow and provingWindow could cause a state transition to spend more than expected time in these windows\"*. That will help fix the issue without any further leaks.\n\n**[dantaik (Taiko) confirmed and commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/170#issuecomment-2032338122):**\n > This is a valid bug report, fixing in https://github.com/taikoxyz/taiko-mono/pull/16612\n >\n > TimelockTokenPool.sol will not have a similar fix as the risk is very managable. Blob caching/sharing is disabled, so no fix for it as well.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-03-taiko",
  "Code": [
    {
      "filename": "packages/protocol/contracts/common/EssentialContract.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport \"./AddressResolver.sol\";\n\n/// @title EssentialContract\n/// @custom:security-contact security@taiko.xyz\nabstract contract EssentialContract is UUPSUpgradeable, Ownable2StepUpgradeable, AddressResolver {\n    uint8 private constant _FALSE = 1;\n\n    uint8 private constant _TRUE = 2;\n\n    /// @dev The slot in transient storage of the reentry lock. This is the keccak256 hash\n    /// of \"ownerUUPS.reentry_slot\"\n    bytes32 private constant _REENTRY_SLOT =\n        0xa5054f728453d3dbe953bdc43e4d0cb97e662ea32d7958190f3dc2da31d9721a;\n\n    /// @dev Slot 1.\n    uint8 private __reentry;\n\n    uint8 private __paused;\n\n    uint256[49] private __gap;\n\n    /// @notice Emitted when the contract is paused.\n    /// @param account The account that paused the contract.\n    event Paused(address account);\n\n    /// @notice Emitted when the contract is unpaused.\n    /// @param account The account that unpaused the contract.\n    event Unpaused(address account);\n\n    error REENTRANT_CALL();\n    error INVALID_PAUSE_STATUS();\n    error ZERO_ADDR_MANAGER();\n\n    /// @dev Modifier that ensures the caller is the owner or resolved address of a given name.\n    /// @param _name The name to check against.\n    modifier onlyFromOwnerOrNamed(bytes32 _name) {\n        if (msg.sender != owner() && msg.sender != resolve(_name, true)) revert RESOLVER_DENIED();\n        _;\n    }\n\n    modifier nonReentrant() {\n        if (_loadReentryLock() == _TRUE) revert REENTRANT_CALL();\n        _storeReentryLock(_TRUE);\n        _;\n        _storeReentryLock(_FALSE);\n    }\n\n    modifier whenPaused() {\n        if (!paused()) revert INVALID_PAUSE_STATUS();\n        _;\n    }\n\n    modifier whenNotPaused() {\n        if (paused()) revert INVALID_PAUSE_STATUS();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Pauses the contract.\n    function pause() public virtual whenNotPaused {\n        __paused = _TRUE;\n        emit Paused(msg.sender);\n        // We call the authorize function here to avoid:\n        // Warning (5740): Unreachable code.\n        _authorizePause(msg.sender);\n    }\n\n    /// @notice Unpauses the contract.\n    function unpause() public virtual whenPaused {\n        __paused = _FALSE;\n        emit Unpaused(msg.sender);\n        // We call the authorize function here to avoid:\n        // Warning (5740): Unreachable code.\n        _authorizePause(msg.sender);\n    }\n\n    /// @notice Returns true if the contract is paused, and false otherwise.\n    /// @return True if paused, false otherwise.\n    function paused() public view returns (bool) {\n        return __paused == _TRUE;\n    }\n\n    /// @notice Initializes the contract.\n    /// @param _owner The owner of this contract. msg.sender will be used if this value is zero.\n    /// @param _addressManager The address of the {AddressManager} contract.\n    function __Essential_init(\n        address _owner,\n        address _addressManager\n    )\n        internal\n        virtual\n        onlyInitializing\n    {\n        __Essential_init(_owner);\n\n        if (_addressManager == address(0)) revert ZERO_ADDR_MANAGER();\n        __AddressResolver_init(_addressManager);\n    }\n\n    function __Essential_init(address _owner) internal virtual {\n        _transferOwnership(_owner == address(0) ? msg.sender : _owner);\n        __paused = _FALSE;\n    }\n\n    function _authorizeUpgrade(address) internal virtual override onlyOwner { }\n\n    function _authorizePause(address) internal virtual onlyOwner { }\n\n    // Stores the reentry lock\n    function _storeReentryLock(uint8 _reentry) internal virtual {\n        if (block.chainid == 1) {\n            assembly {\n                tstore(_REENTRY_SLOT, _reentry)\n            }\n        } else {\n            __reentry = _reentry;\n        }\n    }\n\n    // Loads the reentry lock\n    function _loadReentryLock() internal view virtual returns (uint8 reentry_) {\n        if (block.chainid == 1) {\n            assembly {\n                reentry_ := tload(_REENTRY_SLOT)\n            }\n        } else {\n            reentry_ = __reentry;\n        }\n    }\n\n    function _inNonReentrant() internal view returns (bool) {\n        return _loadReentryLock() == _TRUE;\n    }\n}"
    },
    {
      "filename": "packages/protocol/contracts/bridge/Bridge.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../common/EssentialContract.sol\";\nimport \"../libs/LibAddress.sol\";\nimport \"../signal/ISignalService.sol\";\nimport \"../thirdparty/nomad-xyz/ExcessivelySafeCall.sol\";\nimport \"./IBridge.sol\";\n\n/// @title Bridge\n/// @notice See the documentation for {IBridge}.\n/// @dev Labeled in AddressResolver as \"bridge\". Additionally, the code hash for the same address on\n/// L1 and L2 may be different.\n/// @custom:security-contact security@taiko.xyz\ncontract Bridge is EssentialContract, IBridge {\n    using Address for address;\n    using LibAddress for address;\n    using LibAddress for address payable;\n\n    /// @dev The slot in transient storage of the call context. This is the keccak256 hash\n    /// of \"bridge.ctx_slot\"\n    bytes32 private constant _CTX_SLOT =\n        0xe4ece82196de19aabe639620d7f716c433d1348f96ce727c9989a982dbadc2b9;\n\n    /// @dev Place holder value when not using transient storage\n    uint256 internal constant PLACEHOLDER = type(uint256).max;\n\n    /// @notice The next message ID.\n    /// @dev Slot 1.\n    uint128 public nextMessageId;\n\n    /// @notice Mapping to store the status of a message from its hash.\n    /// @dev Slot 2.\n    mapping(bytes32 msgHash => Status status) public messageStatus;\n\n    /// @dev Slots 3, 4, and 5.\n    Context private __ctx;\n\n    /// @notice Mapping to store banned addresses.\n    /// @dev Slot 6.\n    mapping(address addr => bool banned) public addressBanned;\n\n    /// @notice Mapping to store the proof receipt of a message from its hash.\n    /// @dev Slot 7.\n    mapping(bytes32 msgHash => ProofReceipt receipt) public proofReceipt;\n\n    uint256[43] private __gap;\n\n    error B_INVALID_CHAINID();\n    error B_INVALID_CONTEXT();\n    error B_INVALID_GAS_LIMIT();\n    error B_INVALID_STATUS();\n    error B_INVALID_USER();\n    error B_INVALID_VALUE();\n    error B_MESSAGE_NOT_SENT();\n    error B_NON_RETRIABLE();\n    error B_NOT_FAILED();\n    error B_NOT_RECEIVED();\n    error B_PERMISSION_DENIED();\n    error B_STATUS_MISMATCH();\n    error B_INVOCATION_TOO_EARLY();\n\n    modifier sameChain(uint64 _chainId) {\n        if (_chainId != block.chainid) revert B_INVALID_CHAINID();\n        _;\n    }\n\n    /// @notice Function to receive Ether.\n    receive() external payable { }\n\n    /// @notice Initializes the contract.\n    /// @param _owner The owner of this contract. msg.sender will be used if this value is zero.\n    /// @param _addressManager The address of the {AddressManager} contract.\n    function init(address _owner, address _addressManager) external initializer {\n        __Essential_init(_owner, _addressManager);\n    }\n\n    /// @notice Suspend or unsuspend invocation for a list of messages.\n    /// @param _msgHashes The array of msgHashes to be suspended.\n    /// @param _suspend True if suspend, false if unsuspend.\n    function suspendMessages(\n        bytes32[] calldata _msgHashes,\n        bool _suspend\n    )\n        external\n        onlyFromOwnerOrNamed(\"bridge_watchdog\")\n    {\n        uint64 _timestamp = _suspend ? type(uint64).max : uint64(block.timestamp);\n        for (uint256 i; i < _msgHashes.length; ++i) {\n            bytes32 msgHash = _msgHashes[i];\n            proofReceipt[msgHash].receivedAt = _timestamp;\n            emit MessageSuspended(msgHash, _suspend);\n        }\n    }\n\n    /// @notice Ban or unban an address. A banned addresses will not be invoked upon\n    /// with message calls.\n    /// @param _addr The address to ban or unban.\n    /// @param _ban True if ban, false if unban.\n    function banAddress(\n        address _addr,\n        bool _ban\n    )\n        external\n        onlyFromOwnerOrNamed(\"bridge_watchdog\")\n        nonReentrant\n    {\n        if (addressBanned[_addr] == _ban) revert B_INVALID_STATUS();\n        addressBanned[_addr] = _ban;\n        emit AddressBanned(_addr, _ban);\n    }\n\n    /// @inheritdoc IBridge\n    function sendMessage(Message calldata _message)\n        external\n        payable\n        override\n        nonReentrant\n        whenNotPaused\n        returns (bytes32 msgHash_, Message memory message_)\n    {\n        // Ensure the message owner is not null.\n        if (_message.srcOwner == address(0) || _message.destOwner == address(0)) {\n            revert B_INVALID_USER();\n        }\n\n        // Check if the destination chain is enabled.\n        (bool destChainEnabled,) = isDestChainEnabled(_message.destChainId);\n\n        // Verify destination chain and to address.\n        if (!destChainEnabled) revert B_INVALID_CHAINID();\n        if (_message.destChainId == block.chainid) {\n            revert B_INVALID_CHAINID();\n        }\n\n        // Ensure the sent value matches the expected amount.\n        uint256 expectedAmount = _message.value + _message.fee;\n        if (expectedAmount != msg.value) revert B_INVALID_VALUE();\n\n        message_ = _message;\n\n        // Configure message details and send signal to indicate message sending.\n        message_.id = nextMessageId++;\n        message_.from = msg.sender;\n        message_.srcChainId = uint64(block.chainid);\n\n        msgHash_ = hashMessage(message_);\n\n        ISignalService(resolve(\"signal_service\", false)).sendSignal(msgHash_);\n        emit MessageSent(msgHash_, message_);\n    }\n\n    /// @inheritdoc IBridge\n    function recallMessage(\n        Message calldata _message,\n        bytes calldata _proof\n    )\n        external\n        nonReentrant\n        whenNotPaused\n        sameChain(_message.srcChainId)\n    {\n        bytes32 msgHash = hashMessage(_message);\n\n        if (messageStatus[msgHash] != Status.NEW) revert B_STATUS_MISMATCH();\n\n        uint64 receivedAt = proofReceipt[msgHash].receivedAt;\n        bool isMessageProven = receivedAt != 0;\n\n        if (!isMessageProven) {\n            address signalService = resolve(\"signal_service\", false);\n\n            if (!ISignalService(signalService).isSignalSent(address(this), msgHash)) {\n                revert B_MESSAGE_NOT_SENT();\n            }\n\n            bytes32 failureSignal = signalForFailedMessage(msgHash);\n            if (!_proveSignalReceived(signalService, failureSignal, _message.destChainId, _proof)) {\n                revert B_NOT_FAILED();\n            }\n\n            receivedAt = uint64(block.timestamp);\n            proofReceipt[msgHash].receivedAt = receivedAt;\n        }\n\n        (uint256 invocationDelay,) = getInvocationDelays();\n\n        if (block.timestamp >= invocationDelay + receivedAt) {\n            delete proofReceipt[msgHash];\n            messageStatus[msgHash] = Status.RECALLED;\n\n            // Execute the recall logic based on the contract's support for the\n            // IRecallableSender interface\n            if (_message.from.supportsInterface(type(IRecallableSender).interfaceId)) {\n                _storeContext(msgHash, address(this), _message.srcChainId);\n\n                // Perform recall\n                IRecallableSender(_message.from).onMessageRecalled{ value: _message.value }(\n                    _message, msgHash\n                );\n\n                // Must reset the context after the message call\n                _resetContext();\n            } else {\n                _message.srcOwner.sendEther(_message.value);\n            }\n            emit MessageRecalled(msgHash);\n        } else if (!isMessageProven) {\n            emit MessageReceived(msgHash, _message, true);\n        } else {\n            revert B_INVOCATION_TOO_EARLY();\n        }\n    }\n\n    /// @inheritdoc IBridge\n    function processMessage(\n        Message calldata _message,\n        bytes calldata _proof\n    )\n        external\n        nonReentrant\n        whenNotPaused\n        sameChain(_message.destChainId)\n    {\n        bytes32 msgHash = hashMessage(_message);\n        if (messageStatus[msgHash] != Status.NEW) revert B_STATUS_MISMATCH();\n\n        address signalService = resolve(\"signal_service\", false);\n        uint64 receivedAt = proofReceipt[msgHash].receivedAt;\n        bool isMessageProven = receivedAt != 0;\n\n        (uint256 invocationDelay, uint256 invocationExtraDelay) = getInvocationDelays();\n\n        if (!isMessageProven) {\n            if (!_proveSignalReceived(signalService, msgHash, _message.srcChainId, _proof)) {\n                revert B_NOT_RECEIVED();\n            }\n\n            receivedAt = uint64(block.timestamp);\n\n            if (invocationDelay != 0) {\n                proofReceipt[msgHash] = ProofReceipt({\n                    receivedAt: receivedAt,\n                    preferredExecutor: _message.gasLimit == 0 ? _message.destOwner : msg.sender\n                });\n            }\n        }\n\n        if (invocationDelay != 0 && msg.sender != proofReceipt[msgHash].preferredExecutor) {\n            // If msg.sender is not the one that proved the message, then there\n            // is an extra delay.\n            unchecked {\n                invocationDelay += invocationExtraDelay;\n            }\n        }\n\n        if (block.timestamp >= invocationDelay + receivedAt) {\n            // If the gas limit is set to zero, only the owner can process the message.\n            if (_message.gasLimit == 0 && msg.sender != _message.destOwner) {\n                revert B_PERMISSION_DENIED();\n            }\n\n            delete proofReceipt[msgHash];\n\n            uint256 refundAmount;\n\n            // Process message differently based on the target address\n            if (\n                _message.to == address(0) || _message.to == address(this)\n                    || _message.to == signalService || addressBanned[_message.to]\n            ) {\n                // Handle special addresses that don't require actual invocation but\n                // mark message as DONE\n                refundAmount = _message.value;\n                _updateMessageStatus(msgHash, Status.DONE);\n            } else {\n                // Use the specified message gas limit if called by the owner, else\n                // use remaining gas\n                uint256 gasLimit = msg.sender == _message.destOwner ? gasleft() : _message.gasLimit;\n\n                if (_invokeMessageCall(_message, msgHash, gasLimit)) {\n                    _updateMessageStatus(msgHash, Status.DONE);\n                } else {\n                    _updateMessageStatus(msgHash, Status.RETRIABLE);\n                }\n            }\n\n            // Determine the refund recipient\n            address refundTo =\n                _message.refundTo == address(0) ? _message.destOwner : _message.refundTo;\n\n            // Refund the processing fee\n            if (msg.sender == refundTo) {\n                refundTo.sendEther(_message.fee + refundAmount);\n            } else {\n                // If sender is another address, reward it and refund the rest\n                msg.sender.sendEther(_message.fee);\n                refundTo.sendEther(refundAmount);\n            }\n            emit MessageExecuted(msgHash);\n        } else if (!isMessageProven) {\n            emit MessageReceived(msgHash, _message, false);\n        } else {\n            revert B_INVOCATION_TOO_EARLY();\n        }\n    }\n\n    /// @inheritdoc IBridge\n    function retryMessage(\n        Message calldata _message,\n        bool _isLastAttempt\n    )\n        external\n        nonReentrant\n        whenNotPaused\n        sameChain(_message.destChainId)\n    {\n        // If the gasLimit is set to 0 or isLastAttempt is true, the caller must\n        // be the message.destOwner.\n        if (_message.gasLimit == 0 || _isLastAttempt) {\n            if (msg.sender != _message.destOwner) revert B_PERMISSION_DENIED();\n        }\n\n        bytes32 msgHash = hashMessage(_message);\n        if (messageStatus[msgHash] != Status.RETRIABLE) {\n            revert B_NON_RETRIABLE();\n        }\n\n        // Attempt to invoke the messageCall.\n        if (_invokeMessageCall(_message, msgHash, gasleft())) {\n            _updateMessageStatus(msgHash, Status.DONE);\n        } else if (_isLastAttempt) {\n            _updateMessageStatus(msgHash, Status.FAILED);\n        }\n        emit MessageRetried(msgHash);\n    }\n\n    /// @inheritdoc IBridge\n    function isMessageSent(Message calldata _message) public view returns (bool) {\n        if (_message.srcChainId != block.chainid) return false;\n        return ISignalService(resolve(\"signal_service\", false)).isSignalSent({\n            _app: address(this),\n            _signal: hashMessage(_message)\n        });\n    }\n\n    /// @notice Checks if a msgHash has failed on its destination chain.\n    /// @param _message The message.\n    /// @param _proof The merkle inclusion proof.\n    /// @return true if the message has failed, false otherwise.\n    function proveMessageFailed(\n        Message calldata _message,\n        bytes calldata _proof\n    )\n        public\n        view\n        returns (bool)\n    {\n        if (_message.srcChainId != block.chainid) return false;\n\n        return _proveSignalReceived(\n            resolve(\"signal_service\", false),\n            signalForFailedMessage(hashMessage(_message)),\n            _message.destChainId,\n            _proof\n        );\n    }\n\n    /// @notice Checks if a msgHash has failed on its destination chain.\n    /// @param _message The message.\n    /// @param _proof The merkle inclusion proof.\n    /// @return true if the message has failed, false otherwise.\n    function proveMessageReceived(\n        Message calldata _message,\n        bytes calldata _proof\n    )\n        public\n        view\n        returns (bool)\n    {\n        if (_message.destChainId != block.chainid) return false;\n        return _proveSignalReceived(\n            resolve(\"signal_service\", false), hashMessage(_message), _message.srcChainId, _proof\n        );\n    }\n\n    /// @notice Checks if the destination chain is enabled.\n    /// @param _chainId The destination chain ID.\n    /// @return enabled_ True if the destination chain is enabled.\n    /// @return destBridge_ The bridge of the destination chain.\n    function isDestChainEnabled(uint64 _chainId)\n        public\n        view\n        returns (bool enabled_, address destBridge_)\n    {\n        destBridge_ = resolve(_chainId, \"bridge\", true);\n        enabled_ = destBridge_ != address(0);\n    }\n\n    /// @notice Gets the current context.\n    /// @inheritdoc IBridge\n    function context() public view returns (Context memory ctx_) {\n        ctx_ = _loadContext();\n        if (ctx_.msgHash == 0 || ctx_.msgHash == bytes32(PLACEHOLDER)) {\n            revert B_INVALID_CONTEXT();\n        }\n    }\n\n    /// @notice Returns invocation delay values.\n    /// @dev Bridge contract deployed on L1 shall use a non-zero value for better\n    /// security.\n    /// @return invocationDelay_ The minimal delay in second before a message can be executed since\n    /// and the time it was received on the this chain.\n    /// @return invocationExtraDelay_ The extra delay in second (to be added to invocationDelay) if\n    /// the transactor is not the preferredExecutor who proved this message.\n    function getInvocationDelays()\n        public\n        view\n        virtual\n        returns (uint256 invocationDelay_, uint256 invocationExtraDelay_)\n    {\n        if (\n            block.chainid == 1 // Ethereum mainnet\n        ) {\n            // For Taiko mainnet\n            // 384 seconds = 6.4 minutes = one ethereum epoch\n            return (1 hours, 384 seconds);\n        } else if (\n            block.chainid == 2 // Ropsten\n                || block.chainid == 4 // Rinkeby\n                || block.chainid == 5 // Goerli\n                || block.chainid == 42 // Kovan\n                || block.chainid == 17_000 // Holesky\n                || block.chainid == 11_155_111 // Sepolia\n        ) {\n            // For all Taiko public testnets\n            return (30 minutes, 384 seconds);\n        } else if (block.chainid >= 32_300 && block.chainid <= 32_400) {\n            // For all Taiko internal devnets\n            return (5 minutes, 384 seconds);\n        } else {\n            // This is a Taiko L2 chain where no deleys are applied.\n            return (0, 0);\n        }\n    }\n\n    /// @inheritdoc IBridge\n    function hashMessage(Message memory _message) public pure returns (bytes32) {\n        return keccak256(abi.encode(\"TAIKO_MESSAGE\", _message));\n    }\n\n    /// @notice Returns a signal representing a failed/recalled message.\n    /// @param _msgHash The message hash.\n    /// @return The failed representation of it as bytes32.\n    function signalForFailedMessage(bytes32 _msgHash) public pure returns (bytes32) {\n        return _msgHash ^ bytes32(uint256(Status.FAILED));\n    }\n\n    /// @notice Checks if the given address can pause and unpause the bridge.\n    function _authorizePause(address)\n        internal\n        view\n        virtual\n        override\n        onlyFromOwnerOrNamed(\"bridge_pauser\")\n    { }\n\n    /// @notice Invokes a call message on the Bridge.\n    /// @param _message The call message to be invoked.\n    /// @param _msgHash The hash of the message.\n    /// @param _gasLimit The gas limit for the message call.\n    /// @return success_ A boolean value indicating whether the message call was\n    /// successful.\n    /// @dev This function updates the context in the state before and after the\n    /// message call.\n    function _invokeMessageCall(\n        Message calldata _message,\n        bytes32 _msgHash,\n        uint256 _gasLimit\n    )\n        private\n        returns (bool success_)\n    {\n        if (_gasLimit == 0) revert B_INVALID_GAS_LIMIT();\n        assert(_message.from != address(this));\n\n        _storeContext(_msgHash, _message.from, _message.srcChainId);\n\n        if (\n            _message.data.length >= 4 // msg can be empty\n                && bytes4(_message.data) != IMessageInvocable.onMessageInvocation.selector\n                && _message.to.isContract()\n        ) {\n            success_ = false;\n        } else {\n            (success_,) = ExcessivelySafeCall.excessivelySafeCall(\n                _message.to,\n                _gasLimit,\n                _message.value,\n                64, // return max 64 bytes\n                _message.data\n            );\n        }\n\n        // Must reset the context after the message call\n        _resetContext();\n    }\n\n    /// @notice Updates the status of a bridge message.\n    /// @dev If the new status is different from the current status in the\n    /// mapping, the status is updated and an event is emitted.\n    /// @param _msgHash The hash of the message.\n    /// @param _status The new status of the message.\n    function _updateMessageStatus(bytes32 _msgHash, Status _status) private {\n        if (messageStatus[_msgHash] == _status) return;\n\n        messageStatus[_msgHash] = _status;\n        emit MessageStatusChanged(_msgHash, _status);\n\n        if (_status == Status.FAILED) {\n            ISignalService(resolve(\"signal_service\", false)).sendSignal(\n                signalForFailedMessage(_msgHash)\n            );\n        }\n    }\n\n    /// @notice Resets the call context\n    function _resetContext() private {\n        if (block.chainid == 1) {\n            _storeContext(bytes32(0), address(0), uint64(0));\n        } else {\n            _storeContext(bytes32(PLACEHOLDER), address(uint160(PLACEHOLDER)), uint64(PLACEHOLDER));\n        }\n    }\n\n    /// @notice Stores the call context\n    /// @param _msgHash The message hash.\n    /// @param _from The sender's address.\n    /// @param _srcChainId The source chain ID.\n    function _storeContext(bytes32 _msgHash, address _from, uint64 _srcChainId) private {\n        if (block.chainid == 1) {\n            assembly {\n                tstore(_CTX_SLOT, _msgHash)\n                tstore(add(_CTX_SLOT, 1), _from)\n                tstore(add(_CTX_SLOT, 2), _srcChainId)\n            }\n        } else {\n            __ctx = Context(_msgHash, _from, _srcChainId);\n        }\n    }\n\n    /// @notice Loads and returns the call context.\n    /// @return ctx_ The call context.\n    function _loadContext() private view returns (Context memory) {\n        if (block.chainid == 1) {\n            bytes32 msgHash;\n            address from;\n            uint64 srcChainId;\n            assembly {\n                msgHash := tload(_CTX_SLOT)\n                from := tload(add(_CTX_SLOT, 1))\n                srcChainId := tload(add(_CTX_SLOT, 2))\n            }\n            return Context(msgHash, from, srcChainId);\n        } else {\n            return __ctx;\n        }\n    }\n\n    /// @notice Checks if the signal was received.\n    /// @param _signalService The signal service address.\n    /// @param _signal The signal.\n    /// @param _chainId The ID of the chain the signal is stored on.\n    /// @param _proof The merkle inclusion proof.\n    /// @return success_ True if the message was received.\n    function _proveSignalReceived(\n        address _signalService,\n        bytes32 _signal,\n        uint64 _chainId,\n        bytes calldata _proof\n    )\n        private\n        view\n        returns (bool success_)\n    {\n        bytes memory data = abi.encodeCall(\n            ISignalService.proveSignalReceived,\n            (_chainId, resolve(_chainId, \"bridge\", false), _signal, _proof)\n        );\n        (success_,) = _signalService.staticcall(data);\n    }\n}"
    },
    {
      "filename": "packages/protocol/contracts/common/EssentialContract.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport \"./AddressResolver.sol\";\n\n/// @title EssentialContract\n/// @custom:security-contact security@taiko.xyz\nabstract contract EssentialContract is UUPSUpgradeable, Ownable2StepUpgradeable, AddressResolver {\n    uint8 private constant _FALSE = 1;\n\n    uint8 private constant _TRUE = 2;\n\n    /// @dev The slot in transient storage of the reentry lock. This is the keccak256 hash\n    /// of \"ownerUUPS.reentry_slot\"\n    bytes32 private constant _REENTRY_SLOT =\n        0xa5054f728453d3dbe953bdc43e4d0cb97e662ea32d7958190f3dc2da31d9721a;\n\n    /// @dev Slot 1.\n    uint8 private __reentry;\n\n    uint8 private __paused;\n\n    uint256[49] private __gap;\n\n    /// @notice Emitted when the contract is paused.\n    /// @param account The account that paused the contract.\n    event Paused(address account);\n\n    /// @notice Emitted when the contract is unpaused.\n    /// @param account The account that unpaused the contract.\n    event Unpaused(address account);\n\n    error REENTRANT_CALL();\n    error INVALID_PAUSE_STATUS();\n    error ZERO_ADDR_MANAGER();\n\n    /// @dev Modifier that ensures the caller is the owner or resolved address of a given name.\n    /// @param _name The name to check against.\n    modifier onlyFromOwnerOrNamed(bytes32 _name) {\n        if (msg.sender != owner() && msg.sender != resolve(_name, true)) revert RESOLVER_DENIED();\n        _;\n    }\n\n    modifier nonReentrant() {\n        if (_loadReentryLock() == _TRUE) revert REENTRANT_CALL();\n        _storeReentryLock(_TRUE);\n        _;\n        _storeReentryLock(_FALSE);\n    }\n\n    modifier whenPaused() {\n        if (!paused()) revert INVALID_PAUSE_STATUS();\n        _;\n    }\n\n    modifier whenNotPaused() {\n        if (paused()) revert INVALID_PAUSE_STATUS();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Pauses the contract.\n    function pause() public virtual whenNotPaused {\n        __paused = _TRUE;\n        emit Paused(msg.sender);\n        // We call the authorize function here to avoid:\n        // Warning (5740): Unreachable code.\n        _authorizePause(msg.sender);\n    }\n\n    /// @notice Unpauses the contract.\n    function unpause() public virtual whenPaused {\n        __paused = _FALSE;\n        emit Unpaused(msg.sender);\n        // We call the authorize function here to avoid:\n        // Warning (5740): Unreachable code.\n        _authorizePause(msg.sender);\n    }\n\n    /// @notice Returns true if the contract is paused, and false otherwise.\n    /// @return True if paused, false otherwise.\n    function paused() public view returns (bool) {\n        return __paused == _TRUE;\n    }\n\n    /// @notice Initializes the contract.\n    /// @param _owner The owner of this contract. msg.sender will be used if this value is zero.\n    /// @param _addressManager The address of the {AddressManager} contract.\n    function __Essential_init(\n        address _owner,\n        address _addressManager\n    )\n        internal\n        virtual\n        onlyInitializing\n    {\n        __Essential_init(_owner);\n\n        if (_addressManager == address(0)) revert ZERO_ADDR_MANAGER();\n        __AddressResolver_init(_addressManager);\n    }\n\n    function __Essential_init(address _owner) internal virtual {\n        _transferOwnership(_owner == address(0) ? msg.sender : _owner);\n        __paused = _FALSE;\n    }\n\n    function _authorizeUpgrade(address) internal virtual override onlyOwner { }\n\n    function _authorizePause(address) internal virtual onlyOwner { }\n\n    // Stores the reentry lock\n    function _storeReentryLock(uint8 _reentry) internal virtual {\n        if (block.chainid == 1) {\n            assembly {\n                tstore(_REENTRY_SLOT, _reentry)\n            }\n        } else {\n            __reentry = _reentry;\n        }\n    }\n\n    // Loads the reentry lock\n    function _loadReentryLock() internal view virtual returns (uint8 reentry_) {\n        if (block.chainid == 1) {\n            assembly {\n                reentry_ := tload(_REENTRY_SLOT)\n            }\n        } else {\n            reentry_ = __reentry;\n        }\n    }\n\n    function _inNonReentrant() internal view returns (bool) {\n        return _loadReentryLock() == _TRUE;\n    }\n}"
    },
    {
      "filename": "packages/protocol/contracts/bridge/Bridge.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../common/EssentialContract.sol\";\nimport \"../libs/LibAddress.sol\";\nimport \"../signal/ISignalService.sol\";\nimport \"../thirdparty/nomad-xyz/ExcessivelySafeCall.sol\";\nimport \"./IBridge.sol\";\n\n/// @title Bridge\n/// @notice See the documentation for {IBridge}.\n/// @dev Labeled in AddressResolver as \"bridge\". Additionally, the code hash for the same address on\n/// L1 and L2 may be different.\n/// @custom:security-contact security@taiko.xyz\ncontract Bridge is EssentialContract, IBridge {\n    using Address for address;\n    using LibAddress for address;\n    using LibAddress for address payable;\n\n    /// @dev The slot in transient storage of the call context. This is the keccak256 hash\n    /// of \"bridge.ctx_slot\"\n    bytes32 private constant _CTX_SLOT =\n        0xe4ece82196de19aabe639620d7f716c433d1348f96ce727c9989a982dbadc2b9;\n\n    /// @dev Place holder value when not using transient storage\n    uint256 internal constant PLACEHOLDER = type(uint256).max;\n\n    /// @notice The next message ID.\n    /// @dev Slot 1.\n    uint128 public nextMessageId;\n\n    /// @notice Mapping to store the status of a message from its hash.\n    /// @dev Slot 2.\n    mapping(bytes32 msgHash => Status status) public messageStatus;\n\n    /// @dev Slots 3, 4, and 5.\n    Context private __ctx;\n\n    /// @notice Mapping to store banned addresses.\n    /// @dev Slot 6.\n    mapping(address addr => bool banned) public addressBanned;\n\n    /// @notice Mapping to store the proof receipt of a message from its hash.\n    /// @dev Slot 7.\n    mapping(bytes32 msgHash => ProofReceipt receipt) public proofReceipt;\n\n    uint256[43] private __gap;\n\n    error B_INVALID_CHAINID();\n    error B_INVALID_CONTEXT();\n    error B_INVALID_GAS_LIMIT();\n    error B_INVALID_STATUS();\n    error B_INVALID_USER();\n    error B_INVALID_VALUE();\n    error B_MESSAGE_NOT_SENT();\n    error B_NON_RETRIABLE();\n    error B_NOT_FAILED();\n    error B_NOT_RECEIVED();\n    error B_PERMISSION_DENIED();\n    error B_STATUS_MISMATCH();\n    error B_INVOCATION_TOO_EARLY();\n\n    modifier sameChain(uint64 _chainId) {\n        if (_chainId != block.chainid) revert B_INVALID_CHAINID();\n        _;\n    }\n\n    /// @notice Function to receive Ether.\n    receive() external payable { }\n\n    /// @notice Initializes the contract.\n    /// @param _owner The owner of this contract. msg.sender will be used if this value is zero.\n    /// @param _addressManager The address of the {AddressManager} contract.\n    function init(address _owner, address _ad"
    }
  ]
}