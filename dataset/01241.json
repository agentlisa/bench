{
  "Title": "Combining shorts can incorrectly reset the shorts flag",
  "Content": "# Combining shorts can incorrectly reset the shorts flag\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/ShortRecordFacet.sol#L117\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/ShortRecordFacet.sol#L117</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibShortRecord.sol#L298\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibShortRecord.sol#L298</a>\n\n\n## Summary\nThe protocol allows users to combine multiple short positions into one as long as the combined short stays above the primary collateral ratio. The function is also able to reset an active flag from any of the combined shorts if the final ratio is above the primaryLiquidationCR.\n\nThe issue is that the combineShorts function does not call updateErcDebt, which is called in every other function that is able to reset a shorts flag. This means that if the debt is outdated the final combined short could incorrectly reset the flag putting the position on a healthy ratio when it really isnâ€™t. This would also mean that it will have to be reflagged and go through the timer again before it can be liquidated.\n\n## Vulnerability Details\nThe combine shorts function merges all short records into the short at position id[0]. Focusing on the debt aspect it adds up the total debt and calculates the ercDebtSocialized of all positions except for the first.\n\n```solidity\n      {\n      uint88 currentShortCollateral = currentShort.collateral;\n      uint88 currentShortErcDebt = currentShort.ercDebt;\n      collateral += currentShortCollateral;\n      ercDebt += currentShortErcDebt;\n      yield += currentShortCollateral.mul(currentShort.zethYieldRate);\n      ercDebtSocialized += currentShortErcDebt.mul(currentShort.ercDebtRate);\n      }\n```\n\nIt then merges this total to the first position using the merge function and this will give us the combined short.\n\n```solidity\n// Merge all short records into the short at position id[0]\n        firstShort.merge(ercDebt, ercDebtSocialized, collateral, yield, c.shortUpdatedAt);\n```\n\nFinally we check if the position had an active flag and if it did, we check if the new combined short is in a healthy enough state to reset the flag, if not the whole function reverts.\n\n```solidity\n        // If at least one short was flagged, ensure resulting c-ratio > primaryLiquidationCR\n        if (c.shortFlagExists) {\n            if (\n                firstShort.getCollateralRatioSpotPrice(\n                    LibOracle.getSavedOrSpotOraclePrice(_asset)\n                ) < LibAsset.primaryLiquidationCR(_asset)\n            ) revert Errors.InsufficientCollateral();\n            // Resulting combined short has sufficient c-ratio to remove flag\n            firstShort.resetFlag();\n        }\n```\n\nAs you can see the updateErcDebt function is not called anywhere in the function meaning the flag could be reset with outdated values.\n\n## Impact\nA short could have its flag incorrectly reset and reset the timer. This is not good for the protocol as it will have a unhealthy short for a longer time.\n\n## Tools Used\n- Manual analysis\n- Foundry\n\n## Recommendations\nCall updateErcDebt on the short once it is combined in the combineShorts function to ensure the collateral ratio is calculated with the most up to date values.\n\n```solidity\n    function combineShorts(address asset, uint8[] memory ids)\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, msg.sender, ids[0])\n    {\n        // Initial code\n\n        // Merge all short records into the short at position id[0]\n        firstShort.merge(ercDebt, ercDebtSocialized, collateral, yield, c.shortUpdatedAt);\n\n        firstShort.updateErcDebt(asset); // update debt here before checking flag\n\n        // If at least one short was flagged, ensure resulting c-ratio > primaryLiquidationCR\n        if (c.shortFlagExists) {\n            if (\n                firstShort.getCollateralRatioSpotPrice(\n                    LibOracle.getSavedOrSpotOraclePrice(_asset)\n                ) < LibAsset.primaryLiquidationCR(_asset)\n            ) revert Errors.InsufficientCollateral();\n            // Resulting combined short has sufficient c-ratio to remove flag\n            firstShort.resetFlag();\n        }\n        emit Events.CombineShorts(asset, msg.sender, ids);\n    }\n```",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clm871gl00001mp081mzjdlwc",
  "Code": [
    {
      "filename": "contracts/facets/ShortRecordFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U80, U88} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {STypes, MTypes} from \"contracts/libraries/DataTypes.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract ShortRecordFacet is Modifiers {\n    using LibShortRecord for STypes.ShortRecord;\n    using U256 for uint256;\n    using U80 for uint80;\n    using U88 for uint88;\n\n    address private immutable cusd;\n\n    constructor(address _cusd) {\n        cusd = _cusd;\n    }\n\n    /**\n     * @notice Increases collateral of an active short\n     *\n     * @param asset The market that will be impacted\n     * @param id Id of short\n     * @param amount Eth amount to increase collateral by\n     *\n     */\n\n    function increaseCollateral(address asset, uint8 id, uint88 amount)\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, msg.sender, id)\n    {\n        STypes.Asset storage Asset = s.asset[asset];\n        uint256 vault = Asset.vault;\n        STypes.Vault storage Vault = s.vault[vault];\n        STypes.VaultUser storage VaultUser = s.vaultUser[vault][msg.sender];\n        if (VaultUser.ethEscrowed < amount) revert Errors.InsufficientETHEscrowed();\n\n        STypes.ShortRecord storage short = s.shortRecords[asset][msg.sender][id];\n        short.updateErcDebt(asset);\n        uint256 yield = short.collateral.mul(short.zethYieldRate);\n        short.collateral += amount;\n\n        uint256 cRatio = short.getCollateralRatio(asset);\n        if (cRatio >= Constants.CRATIO_MAX) revert Errors.CollateralHigherThanMax();\n\n        //@dev reset flag info if new cratio is above primaryLiquidationCR\n        if (cRatio >= LibAsset.primaryLiquidationCR(asset)) {\n            short.resetFlag();\n        }\n\n        yield += amount.mul(Vault.zethYieldRate);\n        short.zethYieldRate = yield.divU80(short.collateral);\n\n        VaultUser.ethEscrowed -= amount;\n        Vault.zethCollateral += amount;\n        Asset.zethCollateral += amount;\n        emit Events.IncreaseCollateral(asset, msg.sender, id, amount);\n    }\n\n    /**\n     * @notice Decrease collateral of an active short\n     * @dev Cannot decrease below initial margin\n     *\n     * @param asset The market that will be impacted\n     * @param id Id of short\n     * @param amount Eth amount to decrease collateral by\n     *\n     */\n\n    function decreaseCollateral(address asset, uint8 id, uint88 amount)\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, msg.sender, id)\n    {\n        STypes.ShortRecord storage short = s.shortRecords[asset][msg.sender][id];\n        short.updateErcDebt(asset);\n        if (amount > short.collateral) revert Errors.InsufficientCollateral();\n\n        short.collateral -= amount;\n\n        uint256 cRatio = short.getCollateralRatio(asset);\n        if (cRatio < LibAsset.initialMargin(asset)) {\n            revert Errors.CollateralLowerThanMin();\n        }\n\n        uint256 vault = s.asset[asset].vault;\n        s.vaultUser[vault][msg.sender].ethEscrowed += amount;\n\n        LibShortRecord.disburseCollateral(\n            asset, msg.sender, amount, short.zethYieldRate, short.updatedAt\n        );\n        emit Events.DecreaseCollateral(asset, msg.sender, id, amount);\n    }\n\n    /**\n     * @notice Combine active shorts into one short\n     * @dev If any shorts are flagged the resulting short must have c-ratio > primaryLiquidationCR\n     *\n     * @param asset The market that will be impacted\n     * @param ids Array of short ids to be combined\n     *\n     */\n\n    function combineShorts(address asset, uint8[] memory ids)\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, msg.sender, ids[0])\n    {\n        if (ids.length < 2) revert Errors.InsufficientNumberOfShorts();\n        // First short in the array\n        STypes.ShortRecord storage firstShort = s.shortRecords[asset][msg.sender][ids[0]];\n        // @dev Load initial short elements in struct to avoid stack too deep\n        MTypes.CombineShorts memory c;\n        c.shortFlagExists = firstShort.flaggerId != 0;\n        c.shortUpdatedAt = firstShort.updatedAt;\n\n        address _asset = asset;\n        uint88 collateral;\n        uint88 ercDebt;\n        uint256 yield;\n        uint256 ercDebtSocialized;\n        for (uint256 i = ids.length - 1; i > 0; i--) {\n            uint8 _id = ids[i];\n            _onlyValidShortRecord(_asset, msg.sender, _id);\n            STypes.ShortRecord storage currentShort =\n                s.shortRecords[_asset][msg.sender][_id];\n            // See if there is at least one flagged short\n            if (!c.shortFlagExists) {\n                if (currentShort.flaggerId != 0) {\n                    c.shortFlagExists = true;\n                }\n            }\n\n            //@dev Take latest time when combining shorts (prevent flash loan)\n            if (currentShort.updatedAt > c.shortUpdatedAt) {\n                c.shortUpdatedAt = currentShort.updatedAt;\n            }\n\n            {\n                uint88 currentShortCollateral = currentShort.collateral;\n                uint88 currentShortErcDebt = currentShort.ercDebt;\n                collateral += currentShortCollateral;\n                ercDebt += currentShortErcDebt;\n                yield += currentShortCollateral.mul(currentShort.zethYieldRate);\n                ercDebtSocialized += currentShortErcDebt.mul(currentShort.ercDebtRate);\n            }\n\n            if (currentShort.tokenId != 0) {\n                //@dev First short needs to have NFT so there isn't a need to burn and re-mint\n                if (firstShort.tokenId == 0) {\n                    revert Errors.FirstShortMustBeNFT();\n                }\n\n                LibShortRecord.burnNFT(currentShort.tokenId);\n            }\n\n            // Cancel this short and combine with short in ids[0]\n            LibShortRecord.deleteShortRecord(_asset, msg.sender, _id);\n        }\n\n        // Merge all short records into the short at position id[0]\n        firstShort.merge(ercDebt, ercDebtSocialized, collateral, yield, c.shortUpdatedAt);\n\n        // If at least one short was flagged, ensure resulting c-ratio > primaryLiquidationCR\n        if (c.shortFlagExists) {\n            if (\n                firstShort.getCollateralRatioSpotPrice(\n                    LibOracle.getSavedOrSpotOraclePrice(_asset)\n                ) < LibAsset.primaryLiquidationCR(_asset)\n            ) revert Errors.InsufficientCollateral();\n            // Resulting combined short has sufficient c-ratio to remove flag\n            firstShort.resetFlag();\n        }\n        emit Events.CombineShorts(asset, msg.sender, ids);\n    }\n}"
    },
    {
      "filename": "contracts/libraries/LibShortRecord.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U88, U80} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {STypes, SR} from \"contracts/libraries/DataTypes.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {AppStorage, appStorage} from \"contracts/libraries/AppStorage.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\nlibrary LibShortRecord {\n    using U256 for uint256;\n    using U88 for uint88;\n    using U80 for uint80;\n\n    function getCollateralRatio(STypes.ShortRecord memory short, address asset)\n        internal\n        view\n        returns (uint256 cRatio)\n    {\n        return short.collateral.div(short.ercDebt.mul(LibOracle.getPrice(asset)));\n    }\n\n    function getCollateralRatioSpotPrice(\n        STypes.ShortRecord memory short,\n        uint256 oraclePrice\n    ) internal pure returns (uint256 cRatio) {\n        return short.collateral.div(short.ercDebt.mul(oraclePrice));\n    }\n\n    /**\n     * @notice Returns number of active shortRecords\n     *\n     * @param asset The market that will be impacted\n     * @param shorter Shorter address\n     *\n     * @return shortRecordCount\n     */\n    function getShortRecordCount(address asset, address shorter)\n        internal\n        view\n        returns (uint256 shortRecordCount)\n    {\n        AppStorage storage s = appStorage();\n\n        // Retrieve first non-HEAD short\n        uint8 id = s.shortRecords[asset][shorter][Constants.HEAD].nextId;\n        if (id <= Constants.HEAD) {\n            return 0;\n        }\n\n        while (true) {\n            shortRecordCount++;\n            // One short of one shorter in this order book\n            STypes.ShortRecord storage currentShort = s.shortRecords[asset][shorter][id];\n            // Move to next short unless this is the last one\n            if (currentShort.nextId > Constants.HEAD) {\n                id = currentShort.nextId;\n            } else {\n                return shortRecordCount;\n            }\n        }\n    }\n\n    function createShortRecord(\n        address asset,\n        address shorter,\n        SR status,\n        uint88 collateral,\n        uint88 ercAmount,\n        uint64 ercDebtRate,\n        uint80 zethYieldRate,\n        uint40 tokenId\n    ) internal returns (uint8 id) {\n        AppStorage storage s = appStorage();\n\n        // ensure the tokenId can be downcasted to 40 bits\n        if (tokenId > type(uint40).max) revert Errors.InvalidTokenId();\n\n        uint8 nextId;\n        (id, nextId) = setShortRecordIds(asset, shorter);\n\n        if (id <= Constants.SHORT_MAX_ID) {\n            s.shortRecords[asset][shorter][id] = STypes.ShortRecord({\n                prevId: Constants.HEAD,\n                id: id,\n                nextId: nextId,\n                status: status,\n                collateral: collateral,\n                ercDebt: ercAmount,\n                ercDebtRate: ercDebtRate,\n                zethYieldRate: zethYieldRate,\n                flaggerId: 0,\n                tokenId: tokenId,\n                updatedAt: LibOrders.getOffsetTimeHours()\n            });\n            emit Events.CreateShortRecord(asset, shorter, id);\n        } else {\n            // All shortRecordIds used, combine into max shortRecordId\n            id = Constants.SHORT_MAX_ID;\n            fillShortRecord(\n                asset,\n                shorter,\n                id,\n                status,\n                collateral,\n                ercAmount,\n                ercDebtRate,\n                zethYieldRate\n            );\n        }\n    }\n\n    function transferShortRecord(\n        address asset,\n        address from,\n        address to,\n        uint40 tokenId,\n        STypes.NFT memory nft\n    ) internal {\n        AppStorage storage s = appStorage();\n        STypes.ShortRecord storage short = s.shortRecords[asset][from][nft.shortRecordId];\n        if (short.status == SR.Cancelled) revert Errors.OriginalShortRecordCancelled();\n        if (short.flaggerId != 0) revert Errors.CannotTransferFlaggedShort();\n\n        deleteShortRecord(asset, from, nft.shortRecordId);\n\n        uint8 id = createShortRecord(\n            asset,\n            to,\n            SR.FullyFilled,\n            short.collateral,\n            short.ercDebt,\n            short.ercDebtRate,\n            short.zethYieldRate,\n            tokenId\n        );\n\n        if (id == Constants.SHORT_MAX_ID) {\n            revert Errors.ReceiverExceededShortRecordLimit();\n        }\n\n        s.nftMapping[tokenId].owner = to;\n        s.nftMapping[tokenId].shortRecordId = id;\n    }\n\n    function fillShortRecord(\n        address asset,\n        address shorter,\n        uint8 shortId,\n        SR status,\n        uint88 collateral,\n        uint88 ercAmount,\n        uint256 ercDebtRate,\n        uint256 zethYieldRate\n    ) internal {\n        AppStorage storage s = appStorage();\n\n        uint256 ercDebtSocialized = ercAmount.mul(ercDebtRate);\n        uint256 yield = collateral.mul(zethYieldRate);\n\n        STypes.ShortRecord storage short = s.shortRecords[asset][shorter][shortId];\n        if (short.status == SR.Cancelled) {\n            short.ercDebt = short.collateral = 0;\n        }\n\n        short.status = status;\n        LibShortRecord.merge(\n            short,\n            ercAmount,\n            ercDebtSocialized,\n            collateral,\n            yield,\n            LibOrders.getOffsetTimeHours()\n        );\n    }\n\n    function deleteShortRecord(address asset, address shorter, uint8 id) internal {\n        AppStorage storage s = appStorage();\n\n        STypes.ShortRecord storage shortRecord = s.shortRecords[asset][shorter][id];\n        // Because of the onlyValidShortRecord modifier, only cancelShort can pass SR.Cancelled\n        // Don't recycle shortRecord id 254 so it can be used for all overflow uint8 ids\n        if (shortRecord.status != SR.PartialFill && id < Constants.SHORT_MAX_ID) {\n            // remove the links of ID in the market\n            // @dev (ID) is exiting, [ID] is inserted\n            // BEFORE: PREV <-> (ID) <-> NEXT\n            // AFTER : PREV <----------> NEXT\n            s.shortRecords[asset][shorter][shortRecord.prevId].nextId = shortRecord.nextId;\n            if (shortRecord.nextId != Constants.HEAD) {\n                s.shortRecords[asset][shorter][shortRecord.nextId].prevId =\n                    shortRecord.prevId;\n            }\n            // Make reuseable for future short records\n            uint8 prevHEAD = s.shortRecords[asset][shorter][Constants.HEAD].prevId;\n            s.shortRecords[asset][shorter][Constants.HEAD].prevId = id;\n            // Move the cancelled ID behind HEAD to re-use it\n            // note: C_IDs (cancelled ids) only need to point back (set prevId, can retain nextId)\n            // BEFORE: .. C_ID2 <- C_ID1 <--------- HEAD <-> ... [ID]\n            // AFTER1: .. C_ID2 <- C_ID1 <- [ID] <- HEAD <-> ...\n            if (prevHEAD > Constants.HEAD) {\n                shortRecord.prevId = prevHEAD;\n            } else {\n                // if this is the first ID cancelled\n                // HEAD.prevId needs to be HEAD\n                // and one of the cancelled id.prevID should point to HEAD\n                // BEFORE: HEAD <--------- HEAD <-> ... [ID]\n                // AFTER1: HEAD <- [ID] <- HEAD <-> ...\n                shortRecord.prevId = Constants.HEAD;\n            }\n\n            //Event for delete SR is emitted here and not at the top level because\n            //SR may be cancelled, but there might tied to an active short order\n            //The code above is hit when that SR id is ready for reuse\n            emit Events.DeleteShortRecord(asset, shorter, id);\n        }\n\n        shortRecord.status = SR.Cancelled;\n    }\n\n    function setShortRecordIds(address asset, address shorter)\n        private\n        returns (uint8 id, uint8 nextId)\n    {\n        AppStorage storage s = appStorage();\n\n        STypes.ShortRecord storage guard = s.shortRecords[asset][shorter][Constants.HEAD];\n        STypes.AssetUser storage AssetUser = s.assetUser[asset][shorter];\n        // Initialize HEAD in case of first short createShortRecord\n        if (AssetUser.shortRecordId == 0) {\n            AssetUser.shortRecordId = Constants.SHORT_STARTING_ID;\n            guard.prevId = Constants.HEAD;\n            guard.nextId = Constants.HEAD;\n        }\n        // BEFORE: HEAD <-> .. <-> PREV <--------------> NEXT\n        // AFTER1: HEAD <-> .. <-> PREV <-> (NEW ID) <-> NEXT\n        // place created short next to HEAD\n        nextId = guard.nextId;\n        uint8 canceledId = guard.prevId;\n        // @dev (ID) is exiting, [ID] is inserted\n        // in this case, the protocol re-uses (ID) and moves it to [ID]\n        // check if a previously closed short exists\n        if (canceledId > Constants.HEAD) {\n            // BEFORE: CancelledID <- (ID) <- HEAD <-> .. <-> PREV <----------> NEXT\n            // AFTER1: CancelledID <--------- HEAD <-> .. <-> PREV <-> [ID] <-> NEXT\n            uint8 prevCanceledId = s.shortRecords[asset][shorter][canceledId].prevId;\n            if (prevCanceledId > Constants.HEAD) {\n                guard.prevId = prevCanceledId;\n            } else {\n                // BEFORE: HEAD <- (ID) <- HEAD <-> .. <-> PREV <----------> NEXT\n                // AFTER1: HEAD <--------- HEAD <-> .. <-> PREV <-> [ID] <-> NEXT\n                guard.prevId = Constants.HEAD;\n            }\n            // re-use the previous order's id\n            id = canceledId;\n        } else {\n            // BEFORE: HEAD <-> .. <-> PREV <--------------> NEXT\n            // AFTER1: HEAD <-> .. <-> PREV <-> (NEW ID) <-> NEXT\n            // otherwise just increment to a new short record id\n            // and the short record grows in height/size\n            id = AssetUser.shortRecordId;\n            // Avoids overflow revert, prevents DOS on uint8\n            if (id < type(uint8).max) {\n                AssetUser.shortRecordId += 1;\n            } else {\n                // If max id reached, match into max shortRecordId\n                return (id, nextId);\n            }\n        }\n\n        if (nextId > Constants.HEAD) {\n            s.shortRecords[asset][shorter][nextId].prevId = id;\n        }\n        guard.nextId = id;\n    }\n\n    function updateErcDebt(address asset, address shorter, uint8 shortId) internal {\n        AppStorage storage s = appStorage();\n\n        STypes.ShortRecord storage short = s.shortRecords[asset][shorter][shortId];\n\n        // Distribute ercDebt\n        uint64 ercDebtRate = s.asset[asset].ercDebtRate;\n        uint88 ercDebt = short.ercDebt.mulU88(ercDebtRate - short.ercDebtRate);\n\n        if (ercDebt > 0) {\n            short.ercDebt += ercDebt;\n            short.ercDebtRate = ercDebtRate;\n        }\n    }\n\n    function updateErcDebt(STypes.ShortRecord storage short, address asset) internal {\n        AppStorage storage s = appStorage();\n\n        // Distribute ercDebt\n        uint64 ercDebtRate = s.asset[asset].ercDebtRate;\n        uint88 ercDebt = short.ercDebt.mulU88(ercDebtRate - short.ercDebtRate);\n\n        if (ercDebt > 0) {\n            short.ercDebt += ercDebt;\n            short.ercDebtRate = ercDebtRate;\n        }\n    }\n\n    function merge(\n        STypes.ShortRecord storage short,\n        uint88 ercDebt,\n        uint256 ercDebtSocialized,\n        uint88 collateral,\n        uint256 yield,\n        uint24 creationTime\n    ) internal {\n        // Resolve ercDebt\n        ercDebtSocialized += short.ercDebt.mul(short.ercDebtRate);\n        short.ercDebt += ercDebt;\n        short.ercDebtRate = ercDebtSocialized.divU64(short.ercDebt);\n        // Resolve zethCollateral\n        yield += short.collateral.mul(short.zethYieldRate);\n        short.collateral += collateral;\n        short.zethYieldRate = yield.divU80(short.collateral);\n        // Assign updatedAt\n        short.updatedAt = creationTime;\n    }\n\n    function disburseCollateral(\n        address asset,\n        address shorter,\n        uint88 collateral,\n        uint256 zethYieldRate,\n        uint24 updatedAt\n    ) internal {\n        AppStorage storage s = appStorage();\n\n        STypes.Asset storage Asset = s.asset[asset];\n        uint256 vault = Asset.vault;\n        STypes.Vault storage Vault = s.vault[vault];\n\n        Vault.zethCollateral -= collateral;\n        Asset.zethCollateral -= collateral;\n        // Distribute yield\n        uint88 yield = collateral.mulU88(Vault.zethYieldRate - zethYieldRate);\n        if (yield > 0) {\n            /*\n            @dev If somebody exits a short, gets margin called, decreases their collateral before YIELD_DELAY_HOURS duration is up,\n            they lose their yield to the TAPP\n            */\n            bool isNotRecentlyModified =\n                LibOrders.getOffsetTimeHours() - updatedAt > Constants.YIELD_DELAY_HOURS;\n            if (isNotRecentlyModified) {\n                s.vaultUser[vault][shorter].ethEscrowed += yield;\n            } else {\n                s.vaultUser[vault][address(this)].ethEscrowed += yield;\n            }\n        }\n    }\n\n    function burnNFT(uint256 tokenId) internal {\n        //@dev No need to check downcast tokenId because it is handled in function that calls burnNFT\n        AppStorage storage s = appStorage();\n        STypes.NFT storage nft = s.nftMapping[tokenId];\n        if (nft.owner == address(0)) revert Errors.NotMinted();\n        address asset = s.assetMapping[nft.assetId];\n        STypes.ShortRecord storage short =\n            s.shortRecords[asset][nft.owner][nft.shortRecordId];\n        delete s.nftMapping[tokenId];\n        delete s.getApproved[tokenId];\n        delete short.tokenId;\n        emit Events.Transfer(nft.owner, address(0), tokenId);\n    }\n\n    function setFlagger(\n        STypes.ShortRecord storage short,\n        address cusd,\n        uint16 flaggerHint\n    ) internal {\n        AppStorage storage s = appStorage();\n        STypes.AssetUser storage flagStorage = s.assetUser[cusd][msg.sender];\n\n        //@dev Whenever a new flagger flags, use the flaggerIdCounter.\n        if (flagStorage.g_flaggerId == 0) {\n            address flaggerToReplace = s.flagMapping[flaggerHint];\n\n            uint256 timeDiff = flaggerToReplace != address(0)\n                ? LibOrders.getOffsetTimeHours()\n                    - s.assetUser[cusd][flaggerToReplace].g_updatedAt\n                : 0;\n            //@dev re-use an inactive flaggerId\n            if (timeDiff > LibAsset.firstLiquidationTime(cusd)) {\n                delete s.assetUser[cusd][flaggerToReplace].g_flaggerId;\n                short.flaggerId = flagStorage.g_flaggerId = flaggerHint;\n            } else if (s.flaggerIdCounter < type(uint16).max) {\n                //@dev generate brand new flaggerId\n                short.flaggerId = flagStorage.g_flaggerId = s.flaggerIdCounter;\n                s.flaggerIdCounter++;\n            } else {\n                revert Errors.InvalidFlaggerHint();\n            }\n            s.flagMapping[short.flaggerId] = msg.sender;\n        } else {\n            //@dev re-use flaggerId if flagger has an existing one\n            short.flaggerId = flagStorage.g_flaggerId;\n        }\n        short.updatedAt = flagStorage.g_updatedAt = LibOrders.getOffsetTimeHours();\n    }\n\n    //@dev reset flag info if new cratio is above primaryLiquidationCR\n    function maybeResetFlag(STypes.ShortRecord storage short, address asset) internal {\n        if (short.flaggerId != 0) {\n            if (\n                LibShortRecord.getCollateralRatio(short, asset)\n                    >= LibAsset.primaryLiquidationCR(asset)\n            ) {\n                LibShortRecord.resetFlag(short);\n            }\n        }\n    }\n\n    function resetFlag(STypes.ShortRecord storage shortRecord) internal {\n        delete shortRecord.flaggerId;\n        shortRecord.updatedAt = LibOrders.getOffsetTimeHours();\n    }\n}"
    }
  ]
}