{
  "Title": "Incorrect rewards distribution",
  "Content": "##### Description\nSome of the rewards will be blocked on the contract if they were deposited to the empty gauge (when totalSupply == 0) https://github.com/curvefi/stableswap-ng/blob/8c78731ed43c22e6bcdcb5d39b0a7d02f8cb0386/contracts/main/LiquidityGauge.vy#L318 This happens because `last_update` will be updated nevertheless totalSupply is zero. This finding is classified as HIGH severity since the reward distributor will block some rewards on the contract without a possibility ti retrieve them.\n\n##### Recommendation\nWe recommend updating `last_update` only if totalSupply > 0.\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/main/LiquidityGauge.vy",
      "content": "# @version 0.3.9\n\n\"\"\"\n@title LiquidityGaugeV6\n@author Curve.Fi\n@license Copyright (c) Curve.Fi, 2020-2023 - all rights reserved\n@notice Implementation contract for use with Curve Factory\n@dev Differs from v5.0.0 in that it uses create_from_blueprint to deploy Gauges\n\"\"\"\nfrom vyper.interfaces import ERC20\n\nimplements: ERC20\n\n\ninterface CRV20:\n    def future_epoch_time_write() -> uint256: nonpayable\n    def rate() -> uint256: view\n\ninterface Controller:\n    def checkpoint_gauge(addr: address): nonpayable\n    def gauge_relative_weight(addr: address, time: uint256) -> uint256: view\n\ninterface ERC20Extended:\n    def symbol() -> String[32]: view\n\ninterface ERC1271:\n    def isValidSignature(_hash: bytes32, _signature: Bytes[65]) -> bytes32: view\n\ninterface Factory:\n    def admin() -> address: view\n\ninterface Minter:\n    def minted(user: address, gauge: address) -> uint256: view\n\ninterface VotingEscrow:\n    def user_point_epoch(addr: address) -> uint256: view\n    def user_point_history__ts(addr: address, epoch: uint256) -> uint256: view\n\ninterface VotingEscrowBoost:\n    def adjusted_balance_of(_account: address) -> uint256: view\n\n\nevent Deposit:\n    provider: indexed(address)\n    value: uint256\n\nevent Withdraw:\n    provider: indexed(address)\n    value: uint256\n\nevent UpdateLiquidityLimit:\n    user: indexed(address)\n    original_balance: uint256\n    original_supply: uint256\n    working_balance: uint256\n    working_supply: uint256\n\nevent CommitOwnership:\n    admin: address\n\nevent ApplyOwnership:\n    admin: address\n\nevent Transfer:\n    _from: indexed(address)\n    _to: indexed(address)\n    _value: uint256\n\nevent Approval:\n    _owner: indexed(address)\n    _spender: indexed(address)\n    _value: uint256\n\n\nstruct Reward:\n    token: address\n    distributor: address\n    period_finish: uint256\n    rate: uint256\n    last_update: uint256\n    integral: uint256\n\n\nMAX_REWARDS: constant(uint256) = 8\nTOKENLESS_PRODUCTION: constant(uint256) = 40\nWEEK: constant(uint256) = 604800\n\n# keccak256(\"isValidSignature(bytes32,bytes)\")[:4] << 224\nVERSION: constant(String[8]) = \"v6.0.0\"  # <- updated from v5.0.0 (adds `create_from_blueprint` pattern)\n\nEIP712_TYPEHASH: constant(bytes32) = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\nEIP2612_TYPEHASH: constant(bytes32) = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\n\nVERSION_HASH: constant(bytes32) = keccak256(VERSION)\nNAME_HASH: immutable(bytes32)\nCACHED_CHAIN_ID: immutable(uint256)\nsalt: public(immutable(bytes32))\nCACHED_DOMAIN_SEPARATOR: immutable(bytes32)\n\nCRV: constant(address) = 0xD533a949740bb3306d119CC777fa900bA034cd52\nGAUGE_CONTROLLER: constant(address) = 0x2F50D538606Fa9EDD2B11E2446BEb18C9D5846bB\nMINTER: constant(address) = 0xd061D61a4d941c39E5453435B6345Dc261C2fcE0\nVEBOOST_PROXY: constant(address) = 0x8E0c00ed546602fD9927DF742bbAbF726D5B0d16\nVOTING_ESCROW: constant(address) = 0x5f3b5DfEb7B28CDbD7FAba78963EE202a494e2A2\n\n\n# ERC20\nbalanceOf: public(HashMap[address, uint256])\ntotalSupply: public(uint256)\nallowance: public(HashMap[address, HashMap[address, uint256]])\n\nname: public(String[64])\nsymbol: public(String[40])\n\n# ERC2612\nnonces: public(HashMap[address, uint256])\n\n# Gauge\nfactory: public(address)\nlp_token: public(address)\n\nis_killed: public(bool)\n\n# [future_epoch_time uint40][inflation_rate uint216]\ninflation_params: uint256\n\n# For tracking external rewards\nreward_count: public(uint256)\nreward_data: public(HashMap[address, Reward])\n\n# claimant -> default reward receiver\nrewards_receiver: public(HashMap[address, address])\n\n# reward token -> claiming address -> integral\nreward_integral_for: public(HashMap[address, HashMap[address, uint256]])\n\n# user -> [uint128 claimable amount][uint128 claimed amount]\nclaim_data: HashMap[address, HashMap[address, uint256]]\n\nworking_balances: public(HashMap[address, uint256])\nworking_supply: public(uint256)\n\n# 1e18 * ∫(rate(t) / totalSupply(t) dt) from (last_action) till checkpoint\nintegrate_inv_supply_of: public(HashMap[address, uint256])\nintegrate_checkpoint_of: public(HashMap[address, uint256])\n\n# ∫(balance * rate(t) / totalSupply(t) dt) from 0 till checkpoint\n# Units: rate * t = already number of coins per address to issue\nintegrate_fraction: public(HashMap[address, uint256])\n\n# The goal is to be able to calculate ∫(rate * balance / totalSupply dt) from 0 till checkpoint\n# All values are kept in units of being multiplied by 1e18\nperiod: public(int128)\n\n# array of reward tokens\nreward_tokens: public(address[MAX_REWARDS])\n\nperiod_timestamp: public(uint256[100000000000000000000000000000])\n# 1e18 * ∫(rate(t) / totalSupply(t) dt) from 0 till checkpoint\nintegrate_inv_supply: public(uint256[100000000000000000000000000000])  # bump epoch when rate() changes\n\n\n@external\ndef __init__(_lp_token: address):\n    \"\"\"\n    @notice Contract constructor\n    @param _lp_token Liquidity Pool contract address\n    \"\"\"\n    assert self.lp_token == empty(address)\n\n    self.lp_token = _lp_token\n    self.factory = msg.sender\n\n    symbol: String[32] = ERC20Extended(_lp_token).symbol()\n    name: String[64] = concat(\"Curve.fi \", symbol, \" Gauge Deposit\")\n\n    self.name = name\n    self.symbol = concat(symbol, \"-gauge\")\n\n    self.period_timestamp[0] = block.timestamp\n    self.inflation_params = (\n        (CRV20(CRV).future_epoch_time_write() << 216)\n        + CRV20(CRV).rate()\n    )\n\n    NAME_HASH = keccak256(name)\n    salt = block.prevhash\n    CACHED_CHAIN_ID = chain.id\n    CACHED_DOMAIN_SEPARATOR = keccak256(\n        _abi_encode(\n            EIP712_TYPEHASH,\n            NAME_HASH,\n            VERSION_HASH,\n            chain.id,\n            self,\n            salt,\n        )\n    )\n\n\n# Internal Functions\n\n@view\n@internal\ndef _domain_separator() -> bytes32:\n    if chain.id != CACHED_CHAIN_ID:\n        return keccak256(\n            _abi_encode(\n                EIP712_TYPEHASH,\n                NAME_HASH,\n                VERSION_HASH,\n                chain.id,\n                self,\n                salt,\n            )\n        )\n    return CACHED_DOMAIN_SEPARATOR\n\n\n@internal\ndef _checkpoint(addr: address):\n    \"\"\"\n    @notice Checkpoint for a user\n    @dev Updates the CRV emissions a user is entitled to receive\n    @param addr User address\n    \"\"\"\n    _period: int128 = self.period\n    _period_time: uint256 = self.period_timestamp[_period]\n    _integrate_inv_supply: uint256 = self.integrate_inv_supply[_period]\n\n    inflation_params: uint256 = self.inflation_params\n    rate: uint256 = inflation_params % 2 ** 216\n    prev_future_epoch: uint256 = inflation_params >> 216\n    new_rate: uint256 = rate\n\n    if prev_future_epoch >= _period_time:\n        new_rate = CRV20(CRV).rate()\n        self.inflation_params = (CRV20(CRV).future_epoch_time_write() << 216) + new_rate\n\n    if self.is_killed:\n        # Stop distributing inflation as soon as killed\n        rate = 0\n        new_rate = 0  # prevent distribution when crossing epochs\n\n    # Update integral of 1/supply\n    if block.timestamp > _period_time:\n        _working_supply: uint256 = self.working_supply\n        Controller(GAUGE_CONTROLLER).checkpoint_gauge(self)\n        prev_week_time: uint256 = _period_time\n        week_time: uint256 = min((_period_time + WEEK) / WEEK * WEEK, block.timestamp)\n\n        for i in range(500):\n            dt: uint256 = week_time - prev_week_time\n            w: uint256 = Controller(GAUGE_CONTROLLER).gauge_relative_weight(self, prev_week_time / WEEK * WEEK)\n\n            if _working_supply > 0:\n                if prev_future_epoch >= prev_week_time and prev_future_epoch < week_time:\n                    # If we went across one or multiple epochs, apply the rate\n                    # of the first epoch until it ends, and then the rate of\n                    # the last epoch.\n                    # If more than one epoch is crossed - the gauge gets less,\n                    # but that'd meen it wasn't called for more than 1 year\n                    _integrate_inv_supply += rate * w * (prev_future_epoch - prev_week_time) / _working_supply\n                    rate = new_rate\n                    _integrate_inv_supply += rate * w * (week_time - prev_future_epoch) / _working_supply\n                else:\n                    _integrate_inv_supply += rate * w * dt / _working_supply\n                # On precisions of the calculation\n                # rate ~= 10e18\n                # last_weight > 0.01 * 1e18 = 1e16 (if pool weight is 1%)\n                # _working_supply ~= TVL * 1e18 ~= 1e26 ($100M for example)\n                # The largest loss is at dt = 1\n                # Loss is 1e-9 - acceptable\n\n            if week_time == block.timestamp:\n                break\n            prev_week_time = week_time\n            week_time = min(week_time + WEEK, block.timestamp)\n\n    _period += 1\n    self.period = _period\n    self.period_timestamp[_period] = block.timestamp\n    self.integrate_inv_supply[_period] = _integrate_inv_supply\n\n    # Update user-specific integrals\n    _working_balance: uint256 = self.working_balances[addr]\n    self.integrate_fraction[addr] += _working_balance * (_integrate_inv_supply - self.integrate_inv_supply_of[addr]) / 10 ** 18\n    self.integrate_inv_supply_of[addr] = _integrate_inv_supply\n    self.integrate_checkpoint_of[addr] = block.timestamp\n\n\n@internal\ndef _checkpoint_rewards(_user: address, _total_supply: uint256, _claim: bool, _receiver: address):\n    \"\"\"\n    @notice Claim pending rewards and checkpoint rewards for a user\n    \"\"\"\n    user_balance: uint256 = 0\n    receiver: address = _receiver\n    if _user != empty(address):\n        user_balance = self.balanceOf[_user]\n        if _claim and _receiver == empty(address):\n            # if receiver is not explicitly declared, check if a default receiver is set\n            receiver = self.rewards_receiver[_user]\n            if receiver == empty(address):\n                # if no default receiver is set, direct claims to the user\n                receiver = _user\n\n    reward_count: uint256 = self.reward_count\n    for i in range(MAX_REWARDS):\n        if i == reward_count:\n            break\n        token: address = self.reward_tokens[i]\n\n        integral: uint256 = self.reward_data[token].integral\n        last_update: uint256 = min(block.timestamp, self.reward_data[token].period_finish)\n        duration: uint256 = last_update - self.reward_data[token].last_update\n        if duration != 0:\n            self.reward_data[token].last_update = last_update\n            if _total_supply != 0:\n                integral += duration * self.reward_data[token].rate * 10**18 / _total_supply\n                self.reward_data[token].integral = integral\n\n        if _user != empty(address):\n            integral_for: uint256 = self.reward_integral_for[token][_user]\n            new_claimable: uint256 = 0\n\n            if integral_for < integral:\n                self.reward_integral_for[token][_user] = integral\n                new_claimable = user_balance * (integral - integral_for) / 10**18\n\n            claim_data: uint256 = self.claim_data[_user][token]\n            total_claimable: uint256 = (claim_data >> 128) + new_claimable\n            if total_claimable > 0:\n                total_claimed: uint256 = claim_data % 2**128\n                if _claim:\n                    response: Bytes[32] = raw_call(\n                        token,\n                        _abi_encode(\n                            receiver,\n                            total_claimable,\n                            method_id=method_id(\"transfer(address,uint256)\")\n                        ),\n                        max_outsize=32,\n                    )\n                    if len(response) != 0:\n                        assert convert(response, bool)\n                    self.claim_data[_user][token] = total_claimed + total_claimable\n                elif new_claimable > 0:\n                    self.claim_data[_user][token] = total_claimed + (total_claimable << 128)\n\n\n@internal\ndef _update_liquidity_limit(addr: address, l: uint256, L: uint256):\n    \"\"\"\n    @notice Calculate limits which depend on the amount of CRV token per-user.\n            Effectively it calculates working balances to apply amplification\n            of CRV production by CRV\n    @param addr User address\n    @param l User's amount of liquidity (LP tokens)\n    @param L Total amount of liquidity (LP tokens)\n    \"\"\"\n    # To be called after totalSupply is updated\n    voting_balance: uint256 = VotingEscrowBoost(VEBOOST_PROXY).adjusted_balance_of(addr)\n    voting_total: uint256 = ERC20(VOTING_ESCROW).totalSupply()\n\n    lim: uint256 = l * TOKENLESS_PRODUCTION / 100\n    if voting_total > 0:\n        lim += L * voting_balance / voting_total * (100 - TOKENLESS_PRODUCTION) / 100\n\n    lim = min(l, lim)\n    old_bal: uint256 = self.working_balances[addr]\n    self.working_balances[addr] = lim\n    _working_supply: uint256 = self.working_supply + lim - old_bal\n    self.working_supply = _working_supply\n\n    log UpdateLiquidityLimit(addr, l, L, lim, _working_supply)\n\n\n@internal\ndef _transfer(_from: address, _to: address, _value: uint256):\n    \"\"\"\n    @notice Transfer tokens as well as checkpoint users\n    \"\"\"\n    self._checkpoint(_from)\n    self._checkpoint(_to)\n\n    if _value != 0:\n        total_supply: uint256 = self.totalSupply\n        is_rewards: bool = self.reward_count != 0\n        if is_rewards:\n            self._checkpoint_rewards(_from, total_supply, False, empty(address))\n        new_balance: uint256 = self.balanceOf[_from] - _value\n        self.balanceOf[_from] = new_balance\n        self._update_liquidity_limit(_from, new_balance, total_supply)\n\n        if is_rewards:\n            self._checkpoint_rewards(_to, total_supply, False, empty(address))\n        new_balance = self.balanceOf[_to] + _value\n        self.balanceOf[_to] = new_balance\n        self._update_liquidity_limit(_to, new_balance, total_supply)\n\n    log Transfer(_from, _to, _value)\n\n\n# External User Facing Functions\n\n\n@external\n@nonreentrant('lock')\ndef deposit(_value: uint256, _addr: address = msg.sender, _claim_rewards: bool = False):\n    \"\"\"\n    @notice Deposit `_value` LP tokens\n    @dev Depositting also claims pending reward tokens\n    @param _value Number of tokens to deposit\n    @param _addr Address to deposit for\n    \"\"\"\n\n    self._checkpoint(_addr)\n\n    if _value != 0:\n        is_rewards: bool = self.reward_count != 0\n        total_supply: uint256 = self.totalSupply\n        if is_rewards:\n            self._checkpoint_rewards(_addr, total_supply, _claim_rewards, empty(address))\n\n        total_supply += _value\n        new_balance: uint256 = self.balanceOf[_addr] + _value\n        self.balanceOf[_addr] = new_balance\n        self.totalSupply = total_supply\n\n        self._update_liquidity_limit(_addr, new_balance, total_supply)\n\n        ERC20(self.lp_token).transferFrom(msg.sender, self, _value)\n\n    log Deposit(_addr, _value)\n    log Transfer(empty(address), _addr, _value)\n\n\n@external\n@nonreentrant('lock')\ndef withdraw(_value: uint256, _claim_rewards: bool = False):\n    \"\"\"\n    @notice Withdraw `_value` LP tokens\n    @dev Withdrawing also claims pending reward tokens\n    @param _value Number of tokens to withdraw\n    \"\"\"\n    self._checkpoint(msg.sender)\n\n    if _value != 0:\n        is_rewards: bool = self.reward_count != 0\n        total_supply: uint256 = self.totalSupply\n        if is_rewards:\n            self._checkpoint_rewards(msg.sender, total_supply, _claim_rewards, empty(address))\n\n        total_supply -= _value\n        new_balance: uint256 = self.balanceOf[msg.sender] - _value\n        self.balanceOf[msg.sender] = new_balance\n        self.totalSupply = total_supply\n\n        self._update_liquidity_limit(msg.sender, new_balance, total_supply)\n\n        ERC20(self.lp_token).transfer(msg.sender, _value)\n\n    log Withdraw(msg.sender, _value)\n    log Transfer(msg.sender, empty(address), _value)\n\n\n@external\n@nonreentrant('lock')\ndef claim_rewards(_addr: address = msg.sender, _receiver: address = empty(address)):\n    \"\"\"\n    @notice Claim available reward tokens for `_addr`\n    @param _addr Address to claim for\n    @param _receiver Address to transfer rewards to - if set to\n                     empty(address), uses the default reward receiver\n                     for the caller\n    \"\"\"\n    if _receiver != empty(address):\n        assert _addr == msg.sender  # dev: cannot redirect when claiming for another user\n    self._checkpoint_rewards(_addr, self.totalSupply, True, _receiver)\n\n\n@external\n@nonreentrant('lock')\ndef transferFrom(_from: address, _to :address, _value: uint256) -> bool:\n    \"\"\"\n     @notice Transfer tokens from one address to another.\n     @dev Transferring claims pending reward tokens for the sender and receiver\n     @param _from address The address which you want to send tokens from\n     @param _to address The address which you want to transfer to\n     @param _value uint256 the amount of tokens to be transferred\n    \"\"\"\n    _allowance: uint256 = self.allowance[_from][msg.sender]\n    if _allowance != max_value(uint256):\n        self.allowance[_from][msg.sender] = _allowance - _value\n\n    self._transfer(_from, _to, _value)\n\n    return True\n\n\n@external\n@nonreentrant('lock')\ndef transfer(_to: address, _value: uint256) -> bool:\n    \"\"\"\n    @notice Transfer token for a specified address\n    @dev Transferring claims pending reward tokens for the sender and receiver\n    @param _to The address to transfer to.\n    @param _value The amount to be transferred.\n    \"\"\"\n    self._transfer(msg.sender, _to, _value)\n\n    return True\n\n\n@external\ndef approve(_spender : address, _value : uint256) -> bool:\n    \"\"\"\n    @notice Approve the passed address to transfer the specified amount of\n            tokens on behalf of msg.sender\n    @dev Beware that changing an allowance via this method brings the risk\n         that someone may use both the old and new allowance by unfortunate\n         transaction ordering. This may be mitigated with the use of\n         {incraseAllowance} and {decreaseAllowance}.\n         https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    @param _spender The address which will transfer the funds\n    @param _value The amount of tokens that may be transferred\n    @return bool success\n    \"\"\"\n    self.allowance[msg.sender][_spender] = _value\n    log Approval(msg.sender, _spender, _value)\n\n    return True\n\n\n@external\ndef permit(\n    _owner: address,\n    _spender: address,\n    _value: uint256,\n    _deadline: uint256,\n    _v: uint8,\n    _r: bytes32,\n    _s: bytes32\n) -> bool:\n    \"\"\"\n    @notice Approves spender by owner's signature to expend owner's tokens.\n        See https://eips.ethereum.org/EIPS/eip-2612.\n    @dev Inspired by https://github.com/yearn/yearn-vaults/blob/main/contracts/Vault.vy#L753-L793\n    @dev Supports smart contract wallets which implement ERC1271\n        https://eips.ethereum.org/EIPS/eip-1271\n    @param _owner The address which is a source of funds and has signed the Permit.\n    @param _spender The address which is allowed to spend the funds.\n    @param _value The amount of tokens to be spent.\n    @param _deadline The timestamp after which the Permit is no longer valid.\n    @param _v The bytes[64] of the valid secp256k1 signature of permit by owner\n    @param _r The bytes[0:32] of the valid secp256k1 signature of permit by owner\n    @param _s The bytes[32:64] of the valid secp256k1 signature of permit by owner\n    @return True, if transaction completes successfully\n    \"\"\"\n    assert _owner != empty(address)  # dev: invalid owner\n    assert block.timestamp <= _deadline  # dev: permit expired\n\n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(\n            b\"\\x19\\x01\",\n            self._domain_separator(),\n            keccak256(\n                _abi_encode(\n                    EIP2612_TYPEHASH, _owner, _spender, _value, nonce, _deadline\n                )\n            ),\n        )\n    )\n    assert ecrecover(digest, _v, _r, _s) == _owner  # dev: invalid signature\n\n    self.allowance[_owner][_spender] = _value\n    self.nonces[_owner] = nonce + 1\n\n    log Approval(_owner, _spender, _value)\n    return True\n\n\n@external\ndef increaseAllowance(_spender: address, _added_value: uint256) -> bool:\n    \"\"\"\n    @notice Increase the allowance granted to `_spender` by the caller\n    @dev This is alternative to {approve} that can be used as a mitigation for\n         the potential race condition\n    @param _spender The address which will transfer the funds\n    @param _added_value The amount of to increase the allowance\n    @return bool success\n    \"\"\"\n    allowance: uint256 = self.allowance[msg.sender][_spender] + _added_value\n    self.allowance[msg.sender][_spender] = allowance\n\n    log Approval(msg.sender, _spender, allowance)\n\n    return True\n\n\n@external\ndef decreaseAllowance(_spender: address, _subtracted_value: uint256) -> bool:\n    \"\"\"\n    @notice Decrease the allowance granted to `_spender` by the caller\n    @dev This is alternative to {approve} that can be used as a mitigation for\n         the potential race condition\n    @param _spender The address which will transfer the funds\n    @param _subtracted_value The amount of to decrease the allowance\n    @return bool success\n    \"\"\"\n    allowance: uint256 = self.allowance[msg.sender][_spender] - _subtracted_value\n    self.allowance[msg.sender][_spender] = allowance\n\n    log Approval(msg.sender, _spender, allowance)\n\n    return True\n\n\n@external\ndef user_checkpoint(addr: address) -> bool:\n    \"\"\"\n    @notice Record a checkpoint for `addr`\n    @param addr User address\n    @return bool success\n    \"\"\"\n    assert msg.sender in [addr, MINTER]  # dev: unauthorized\n    self._checkpoint(addr)\n    self._update_liquidity_limit(addr, self.balanceOf[addr], self.totalSupply)\n    return True\n\n\n@external\ndef set_rewards_receiver(_receiver: address):\n    \"\"\"\n    @notice Set the default reward receiver for the caller.\n    @dev When set to empty(address), rewards are sent to the caller\n    @param _receiver Receiver address for any rewards claimed via `claim_rewards`\n    \"\"\"\n    self.rewards_receiver[msg.sender] = _receiver\n\n\n@external\ndef kick(addr: address):\n    \"\"\"\n    @notice Kick `addr` for abusing their boost\n    @dev Only if either they had another voting event, or their voting escrow lock expired\n    @param addr Address to kick\n    \"\"\"\n    t_last: uint256 = self.integrate_checkpoint_of[addr]\n    t_ve: uint256 = VotingEscrow(VOTING_ESCROW).user_point_history__ts(\n        addr, VotingEscrow(VOTING_ESCROW).user_point_epoch(addr)\n    )\n    _balance: uint256 = self.balanceOf[addr]\n\n    assert ERC20(VOTING_ESCROW).balanceOf(addr) == 0 or t_ve > t_last # dev: kick not allowed\n    assert self.working_balances[addr] > _balance * TOKENLESS_PRODUCTION / 100  # dev: kick not needed\n\n    self._checkpoint(addr)\n    self._update_liquidity_limit(addr, self.balanceOf[addr], self.totalSupply)\n\n\n# Administrative Functions\n\n\n@external\n@nonreentrant(\"lock\")\ndef deposit_reward_token(_reward_token: address, _amount: uint256):\n    \"\"\"\n    @notice Deposit a reward token for distribution\n    @param _reward_token The reward token being deposited\n    @param _amount The amount of `_reward_token` being deposited\n    \"\"\"\n    assert msg.sender == self.reward_data[_reward_token].distributor\n\n    self._checkpoint_rewards(empty(address), self.totalSupply, False, empty(address))\n\n    response: Bytes[32] = raw_call(\n        _reward_token,\n        _abi_encode(\n            msg.sender, self, _amount, method_id=method_id(\"transferFrom(address,address,uint256)\")\n        ),\n        max_outsize=32,\n    )\n    if len(response) != 0:\n        assert convert(response, bool)\n\n    period_finish: uint256 = self.reward_data[_reward_token].period_finish\n    if block.timestamp >= period_finish:\n        self.reward_data[_reward_token].rate = _amount / WEEK\n    else:\n        remaining: uint256 = period_finish - block.timestamp\n        leftover: uint256 = remaining * self.reward_data[_reward_token].rate\n        self.reward_data[_reward_token].rate = (_amount + leftover) / WEEK\n\n    self.reward_data[_reward_token].last_update = block.timestamp\n    self.reward_data[_reward_token].period_finish = block.timestamp + WEEK\n\n\n@external\ndef add_reward(_reward_token: address, _distributor: address):\n    \"\"\"\n    @notice Add additional rewards to be distributed to stakers\n    @param _reward_token The token to add as an additional reward\n    @param _distributor Address permitted to fund this contract with the reward token\n    \"\"\"\n    assert msg.sender == Factory(self.factory).admin()  # dev: only owner\n\n    reward_count: uint256 = self.reward_count\n    assert reward_count < MAX_REWARDS\n    assert self.reward_data[_reward_token].distributor == empty(address)\n\n    self.reward_data[_reward_token].distributor = _distributor\n    self.reward_tokens[reward_count] = _reward_token\n    self.reward_count = reward_count + 1\n\n\n@external\ndef set_reward_distributor(_reward_token: address, _distributor: address):\n    \"\"\"\n    @notice Reassign the reward distributor for a reward token\n    @param _reward_token The reward token to reassign distribution rights to\n    @param _distributor The address of the new distributor\n    \"\"\"\n    current_distributor: address = self.reward_data[_reward_token].distributor\n\n    assert msg.sender == current_distributor or msg.sender == Factory(self.factory).admin()\n    assert current_distributor != empty(address)\n    assert _distributor != empty(address)\n\n    self.reward_data[_reward_token].distributor = _distributor\n\n\n@external\ndef set_killed(_is_killed: bool):\n    \"\"\"\n    @notice Set the killed status for this contract\n    @dev When killed, the gauge always yields a rate of 0 and so cannot mint CRV\n    @param _is_killed Killed status to set\n    \"\"\"\n    assert msg.sender == Factory(self.factory).admin()  # dev: only owner\n\n    self.is_killed = _is_killed\n\n\n# View Methods\n\n\n@view\n@external\ndef claimed_reward(_addr: address, _token: address) -> uint256:\n    \"\"\"\n    @notice Get the number of already-claimed reward tokens for a user\n    @param _addr Account to get reward amount for\n    @param _token Token to get reward amount for\n    @return uint256 Total amount of `_token` already claimed by `_addr`\n    \"\"\"\n    return self.claim_data[_addr][_token] % 2**128\n\n\n@view\n@external\ndef claimable_reward(_user: address, _reward_token: address) -> uint256:\n    \"\"\"\n    @notice Get the number of claimable reward tokens for a user\n    @param _user Account to get reward amount for\n    @param _reward_token Token to get reward amount for\n    @return uint256 Claimable reward token amount\n    \"\"\"\n    integral: uint256 = self.reward_data[_reward_token].integral\n    total_supply: uint256 = self.totalSupply\n    if total_supply != 0:\n        last_update: uint256 = min(block.timestamp, self.reward_data[_reward_token].period_finish)\n        duration: uint256 = last_update - self.reward_data[_reward_token].last_update\n        integral += (duration * self.reward_data[_reward_token].rate * 10**18 / total_supply)\n\n    integral_for: uint256 = self.reward_integral_for[_reward_token][_user]\n    new_claimable: uint256 = self.balanceOf[_user] * (integral - integral_for) / 10**18\n\n    return (self.claim_data[_user][_reward_token] >> 128) + new_claimable\n\n\n@external\ndef claimable_tokens(addr: address) -> uint256:\n    \"\"\"\n    @notice Get the number of claimable tokens per user\n    @dev This function should be manually changed to \"view\" in the ABI\n    @return uint256 number of claimable tokens per user\n    \"\"\"\n    self._checkpoint(addr)\n    return self.integrate_fraction[addr] - Minter(MINTER).minted(addr, self)\n\n\n@view\n@external\ndef integrate_checkpoint() -> uint256:\n    \"\"\"\n    @notice Get the timestamp of the last checkpoint\n    \"\"\"\n    return self.period_timestamp[self.period]\n\n\n@view\n@external\ndef future_epoch_time() -> uint256:\n    \"\"\"\n    @notice Get the locally stored CRV future epoch start time\n    \"\"\"\n    return self.inflation_params >> 216\n\n\n@view\n@external\ndef inflation_rate() -> uint256:\n    \"\"\"\n    @notice Get the locally stored CRV inflation rate\n    \"\"\"\n    return self.inflation_params % 2 ** 216\n\n\n@view\n@external\ndef decimals() -> uint256:\n    \"\"\"\n    @notice Get the number of decimals for this token\n    @dev Implemented as a view method to reduce gas costs\n    @return uint256 decimal places\n    \"\"\"\n    return 18\n\n\n@view\n@external\ndef version() -> String[8]:\n    \"\"\"\n    @notice Get the version of this gauge contract\n    \"\"\"\n    return VERSION\n\n\n@view\n@external\ndef DOMAIN_SEPARATOR() -> bytes32:\n    \"\"\"\n    @notice EIP712 domain separator.\n    \"\"\"\n    return self._domain_separator()"
    }
  ]
}