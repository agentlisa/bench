{
  "Title": "[M-05] Yield source does not correctly calculate share conversions",
  "Content": "_Submitted by IllIllI_\n\n> The aTokensâ€™ value is pegged to the value of the corresponding supplied asset at a 1:1 ratio and can be safely stored, transferred or traded. All yield collected by the aTokens' reserves are distributed to aToken holders directly by continuously increasing their wallet balance.\n\n<https://docs.aave.com/developers/tokens/atoken>\n\n### Impact\n\nIncorrect share conversions lead to incorrect pricing of assets and loss of principal. aTokens are rebasing tokens, which means that holders of the token have their `balanceof()` increase over time, but each token is still redeemable for exactly one underlying asset. Any formula that does not return one out for one in is incorrect.\n\n### Proof of Concept\n\n```solidity\nFile: contracts/AaveV3YieldSource.sol   #X\n\n352     /**\n353      * @notice Calculates the number of shares that should be minted or burnt when a user deposit or withdraw.\n354      * @param _tokens Amount of asset tokens\n355      * @return Number of shares.\n356      */\n357     function _tokenToShares(uint256 _tokens) internal view returns (uint256) {\n358       uint256 _supply = totalSupply();\n359   \n360       // shares = (tokens * totalShares) / yieldSourceATokenTotalSupply\n361       return _supply == 0 ? _tokens : _tokens.mul(_supply).div(aToken.balanceOf(address(this)));\n362     }\n363   \n364     /**\n365      * @notice Calculates the number of asset tokens a user has in the yield source.\n366      * @param _shares Amount of shares\n367      * @return Number of asset tokens.\n368      */\n369     function _sharesToToken(uint256 _shares) internal view returns (uint256) {\n370       uint256 _supply = totalSupply();\n371   \n372       // tokens = (shares * yieldSourceATokenTotalSupply) / totalShares\n373       return _supply == 0 ? _shares : _shares.mul(aToken.balanceOf(address(this))).div(_supply);\n374     }\n```\n\n[AaveV3YieldSource.sol#L352-L374](https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L352-L374)<br>\n\nThe above code is used for both `supplyTokenTo()` and `redeemToken()` and does not return one for one. Consider the following chain of events:\n\n1.  There are no deposits yet\n2.  Alice deposits one wBTC, getting back a AaveV3YieldSource share, while the yield source gets the aToken\n3.  Some time later a total of one extra wBTC worth of aToken is generated as yield and is in the `balanceOf(this)`\n4.  Alice attempts to withdraw her one share but gets zero wBTC, because `(tokens{1} * totalSupply(){1}) / aToken.balanceOf(this){2}` is zero\n\n### Recommended Mitigation Steps\n\nThere does not need to be a conversion function - one share must always equal one token.\n\n**[PierrickGT (PoolTogether) acknowledged and commented](https://github.com/code-423n4/2022-04-pooltogether-findings/issues/86#issuecomment-1117743522):**\n > This is a plausible but unlikely scenario since it assumes that only Alice has deposited into the yield source and that the interest rate is so high that 1 more wBTC is now in the yield source.<br>\n> Also, the calculation is wrong since 1 wBTC would represent 1 ether or `1000000000000000000` wei. So the actual calculation would return `(1000000000000000000 * 1000000000000000000) / 2000000000000000000 = 500000000000000000` wei or 0.5 wBTC.\n> \n> We also periodically capture the interest accumulated in the yield source by calling the PrizeFlush contract: [pooltogether/PrizeFlush.sol#L105](https://github.com/pooltogether/v4-periphery/blob/8cc717af440aa23e41e0f24d699647320efd7b04/contracts/PrizeFlush.sol#L105).<br>\n> The capture of the interest happens here: [pooltogether/PrizeSplitStrategy.sol#L51](https://github.com/pooltogether/v4-core/blob/e6f2d9ddb303cc4fb1a64582b12ba3e9df85e21c/contracts/prize-strategy/PrizeSplitStrategy.sol#L51).\n> \n> For these reasons, I've acknowledged the issue but we won't change how shares are calculated.\n\n**[Justin Goro (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-04-pooltogether-findings/issues/86#issuecomment-1131030455):**\n > Downgraded severity as this is more of a value leakage situation, especially given the unlikely edge case of an ERC20 token that sets decimals to 0 and uses low base values.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-04-pooltogether",
  "Code": [
    {
      "filename": "contracts/AaveV3YieldSource.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.10;\n\nimport { IAToken } from \"@aave/core-v3/contracts/interfaces/IAToken.sol\";\nimport { IPool } from \"@aave/core-v3/contracts/interfaces/IPool.sol\";\nimport { IPoolAddressesProvider } from \"@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol\";\nimport { IPoolAddressesProviderRegistry } from \"@aave/core-v3/contracts/interfaces/IPoolAddressesProviderRegistry.sol\";\nimport { IRewardsController } from \"@aave/periphery-v3/contracts/rewards/interfaces/IRewardsController.sol\";\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport { Manageable, Ownable } from \"@pooltogether/owner-manager-contracts/contracts/Manageable.sol\";\nimport { IYieldSource } from \"@pooltogether/yield-source-interface/contracts/IYieldSource.sol\";\n\n/**\n * @title Aave V3 Yield Source contract, implementing PoolTogether's generic yield source interface.\n * @dev This contract inherits from the ERC20 implementation to keep track of users deposits.\n * @notice Yield Source for a PoolTogether prize pool that generates yield by depositing into Aave V3.\n */\ncontract AaveV3YieldSource is ERC20, IYieldSource, Manageable, ReentrancyGuard {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n  /* ============ Events ============ */\n\n  /**\n   * @notice Emitted when the yield source is initialized.\n   * @param aToken Aave aToken address\n   * @param rewardsController Aave rewardsController address\n   * @param poolAddressesProviderRegistry Aave poolAddressesProviderRegistry address\n   * @param name Token name for the underlying ERC20 shares\n   * @param symbol Token symbol for the underlying ERC20 shares\n   * @param decimals Number of decimals the shares (inhereted ERC20) will have. Same as underlying asset to ensure sane exchange rates for shares.\n   * @param owner Owner of this contract\n   */\n  event AaveV3YieldSourceInitialized(\n    IAToken indexed aToken,\n    IRewardsController rewardsController,\n    IPoolAddressesProviderRegistry poolAddressesProviderRegistry,\n    string name,\n    string symbol,\n    uint8 decimals,\n    address owner\n  );\n\n  /**\n   * @notice Emitted when asset tokens are supplied to the yield source.\n   * @param from Address that supplied the tokens\n   * @param shares Amount of shares minted to the user\n   * @param amount Amount of tokens supplied\n   * @param to Address that received the shares\n   */\n  event SuppliedTokenTo(address indexed from, uint256 shares, uint256 amount, address indexed to);\n\n  /**\n   * @notice Emitted when asset tokens are redeemed from the yield source.\n   * @param from Address who redeemed the tokens\n   * @param shares Amount of shares burnt\n   * @param amount Amount of tokens redeemed\n   */\n  event RedeemedToken(address indexed from, uint256 shares, uint256 amount);\n\n  /**\n   * @notice Emitted when Aave rewards have been claimed.\n   * @param from Address who claimed the rewards\n   * @param to Address that received the rewards\n   * @param rewardsList List of addresses of the reward tokens\n   * @param claimedAmounts List that contains the claimed amount per reward token\n   */\n  event Claimed(\n    address indexed from,\n    address indexed to,\n    address[] rewardsList,\n    uint256[] claimedAmounts\n  );\n\n  /**\n   * @notice Emitted when decreasing allowance of ERC20 tokens other than yield source's aToken.\n   * @param from Address of the caller\n   * @param spender Address of the spender\n   * @param amount Amount of `token` to decrease allowance by\n   * @param token Address of the ERC20 token to decrease allowance for\n   */\n  event DecreasedERC20Allowance(\n    address indexed from,\n    address indexed spender,\n    uint256 amount,\n    IERC20 indexed token\n  );\n\n  /**\n   * @notice Emitted when increasing allowance of ERC20 tokens other than yield source's aToken.\n   * @param from Address of the caller\n   * @param spender Address of the spender\n   * @param amount Amount of `token` to increase allowance by\n   * @param token Address of the ERC20 token to increase allowance for\n   */\n  event IncreasedERC20Allowance(\n    address indexed from,\n    address indexed spender,\n    uint256 amount,\n    IERC20 indexed token\n  );\n\n  /**\n   * @notice Emitted when ERC20 tokens other than yield source's aToken are withdrawn from the yield source.\n   * @param from Address of the caller\n   * @param to Address of the recipient\n   * @param amount Amount of `token` transferred\n   * @param token Address of the ERC20 token transferred\n   */\n  event TransferredERC20(\n    address indexed from,\n    address indexed to,\n    uint256 amount,\n    IERC20 indexed token\n  );\n\n  /* ============ Variables ============ */\n\n  /// @notice Yield-bearing Aave aToken address.\n  IAToken public aToken;\n\n  /// @notice Aave RewardsController address.\n  IRewardsController public rewardsController;\n\n  /// @notice Aave poolAddressesProviderRegistry address.\n  IPoolAddressesProviderRegistry public poolAddressesProviderRegistry;\n\n  /// @notice ERC20 token decimals.\n  uint8 private immutable _decimals;\n\n  /**\n   * @dev Aave genesis market PoolAddressesProvider's ID.\n   * @dev This variable could evolve in the future if we decide to support other markets.\n   */\n  uint256 private constant ADDRESSES_PROVIDER_ID = uint256(0);\n\n  /// @dev PoolTogether's Aave Referral Code\n  uint16 private constant REFERRAL_CODE = uint16(188);\n\n  /* ============ Constructor ============ */\n\n  /**\n   * @notice Initializes the yield source with Aave aToken.\n   * @param _aToken Aave aToken address\n   * @param _rewardsController Aave rewardsController address\n   * @param _poolAddressesProviderRegistry Aave poolAddressesProviderRegistry address\n   * @param _name Token name for the underlying ERC20 shares\n   * @param _symbol Token symbol for the underlying ERC20 shares\n   * @param decimals_ Number of decimals the shares (inhereted ERC20) will have. Same as underlying asset to ensure sane exchange rates for shares.\n   * @param _owner Owner of this contract\n   */\n  constructor(\n    IAToken _aToken,\n    IRewardsController _rewardsController,\n    IPoolAddressesProviderRegistry _poolAddressesProviderRegistry,\n    string memory _name,\n    string memory _symbol,\n    uint8 decimals_,\n    address _owner\n  ) Ownable(_owner) ERC20(_name, _symbol) ReentrancyGuard() {\n    require(address(_aToken) != address(0), \"AaveV3YS/aToken-not-zero-address\");\n    aToken = _aToken;\n\n    require(address(_rewardsController) != address(0), \"AaveV3YS/RC-not-zero-address\");\n    rewardsController = _rewardsController;\n\n    require(address(_poolAddressesProviderRegistry) != address(0), \"AaveV3YS/PR-not-zero-address\");\n    poolAddressesProviderRegistry = _poolAddressesProviderRegistry;\n\n    require(_owner != address(0), \"AaveV3YS/owner-not-zero-address\");\n\n    require(decimals_ > 0, \"AaveV3YS/decimals-gt-zero\");\n    _decimals = decimals_;\n\n    // Approve once for max amount\n    IERC20(_tokenAddress()).safeApprove(address(_pool()), type(uint256).max);\n\n    emit AaveV3YieldSourceInitialized(\n      _aToken,\n      _rewardsController,\n      _poolAddressesProviderRegistry,\n      _name,\n      _symbol,\n      decimals_,\n      _owner\n    );\n  }\n\n  /* ============ External Functions ============ */\n\n  /**\n   * @notice Returns user total balance (in asset tokens). This includes their deposit and interest.\n   * @param _user Address of the user to get balance of token for\n   * @return The underlying balance of asset tokens.\n   */\n  function balanceOfToken(address _user) external override returns (uint256) {\n    return _sharesToToken(balanceOf(_user));\n  }\n\n  /**\n   * @notice Returns the ERC20 asset token used for deposits.\n   * @return The ERC20 asset token address.\n   */\n  function depositToken() public view override returns (address) {\n    return _tokenAddress();\n  }\n\n  /**\n   * @notice Returns the Yield Source ERC20 token decimals.\n   * @dev This value should be equal to the decimals of the token used to deposit into the pool.\n   * @return The number of decimals.\n   */\n  function decimals() public view virtual override returns (uint8) {\n    return _decimals;\n  }\n\n  /**\n   * @notice Supplies asset tokens to the yield source.\n   * @dev Shares corresponding to the number of tokens supplied are minted to the user's balance.\n   * @dev Asset tokens are supplied to the yield source, then deposited into Aave.\n   * @param _depositAmount The amount of asset tokens to be supplied\n   * @param _to The user whose balance will receive the tokens\n   */\n  function supplyTokenTo(uint256 _depositAmount, address _to) external override nonReentrant {\n    uint256 _shares = _tokenToShares(_depositAmount);\n    require(_shares > 0, \"AaveV3YS/shares-gt-zero\");\n\n    address _underlyingAssetAddress = _tokenAddress();\n    IERC20(_underlyingAssetAddress).safeTransferFrom(msg.sender, address(this), _depositAmount);\n    _pool().supply(_underlyingAssetAddress, _depositAmount, address(this), REFERRAL_CODE);\n\n    _mint(_to, _shares);\n\n    emit SuppliedTokenTo(msg.sender, _shares, _depositAmount, _to);\n  }\n\n  /**\n   * @notice Redeems asset tokens from the yield source.\n   * @dev Shares corresponding to the number of tokens withdrawn are burnt from the user's balance.\n   * @dev Asset tokens are withdrawn from Aave, then transferred from the yield source to the user's wallet.\n   * @param _redeemAmount The amount of asset tokens to be redeemed\n   * @return The actual amount of asset tokens that were redeemed.\n   */\n  function redeemToken(uint256 _redeemAmount) external override nonReentrant returns (uint256) {\n    address _underlyingAssetAddress = _tokenAddress();\n    IERC20 _assetToken = IERC20(_underlyingAssetAddress);\n\n    uint256 _shares = _tokenToShares(_redeemAmount);\n    _burn(msg.sender, _shares);\n\n    uint256 _beforeBalance = _assetToken.balanceOf(address(this));\n    _pool().withdraw(_underlyingAssetAddress, _redeemAmount, address(this));\n    uint256 _afterBalance = _assetToken.balanceOf(address(this));\n\n    uint256 _balanceDiff = _afterBalance.sub(_beforeBalance);\n    _assetToken.safeTransfer(msg.sender, _balanceDiff);\n\n    emit RedeemedToken(msg.sender, _shares, _redeemAmount);\n    return _balanceDiff;\n  }\n\n  /**\n   * @notice Claims the accrued rewards for the aToken, accumulating any pending rewards.\n   * @dev Only callable by the owner or manager.\n   * @param _to Address where the claimed rewards will be sent\n   * @return True if operation was successful.\n   */\n  function claimRewards(address _to) external onlyManagerOrOwner returns (bool) {\n    require(_to != address(0), \"AaveV3YS/payee-not-zero-address\");\n\n    address[] memory _assets = new address[](1);\n    _assets[0] = address(aToken);\n\n    (address[] memory _rewardsList, uint256[] memory _claimedAmounts) = rewardsController\n      .claimAllRewards(_assets, _to);\n\n    emit Claimed(msg.sender, _to, _rewardsList, _claimedAmounts);\n    return true;\n  }\n\n  /**\n   * @notice Decrease allowance of ERC20 tokens other than the aTokens held by this contract.\n   * @dev This function is only callable by the owner or asset manager.\n   * @dev Current allowance should be computed off-chain to avoid any underflow.\n   * @param _token Address of the ERC20 token to decrease allowance for\n   * @param _spender Address of the spender of the tokens\n   * @param _amount Amount of tokens to decrease allowance by\n   */\n  function decreaseERC20Allowance(\n    IERC20 _token,\n    address _spender,\n    uint256 _amount\n  ) external onlyManagerOrOwner {\n    _requireNotAToken(address(_token));\n    _token.safeDecreaseAllowance(_spender, _amount);\n    emit DecreasedERC20Allowance(msg.sender, _spender, _amount, _token);\n  }\n\n  /**\n   * @notice Increase allowance of ERC20 tokens other than the aTokens held by this contract.\n   * @dev This function is only callable by the owner or asset manager.\n   * @dev Allows another contract or address to withdraw funds from the yield source.\n   * @dev Current allowance should be computed off-chain to avoid any overflow.\n   * @param _token Address of the ERC20 token to increase allowance for\n   * @param _spender Address of the spender of the tokens\n   * @param _amount Amount of tokens to increase allowance by\n   */\n  function increaseERC20Allowance(\n    IERC20 _token,\n    address _spender,\n    uint256 _amount\n  ) external onlyManagerOrOwner {\n    _requireNotAToken(address(_token));\n    _token.safeIncreaseAllowance(_spender, _amount);\n    emit IncreasedERC20Allowance(msg.sender, _spender, _amount, _token);\n  }\n\n  /**\n   * @notice Transfer ERC20 tokens other than the aTokens held by this contract to the recipient address.\n   * @dev This function is only callable by the owner or asset manager.\n   * @param _token Address of the ERC20 token to transfer\n   * @param _to Address of the recipient of the tokens\n   * @param _amount Amount of tokens to transfer\n   */\n  function transferERC20(\n    IERC20 _token,\n    address _to,\n    uint256 _amount\n  ) external onlyManagerOrOwner {\n    require(address(_token) != address(aToken), \"AaveV3YS/forbid-aToken-transfer\");\n    _token.safeTransfer(_to, _amount);\n    emit TransferredERC20(msg.sender, _to, _amount, _token);\n  }\n\n  /* ============ Internal Functions ============ */\n\n  /**\n   * @notice Check that the token address passed is not the aToken address.\n   * @param _token Address of the ERC20 token to check\n   */\n  function _requireNotAToken(address _token) internal view {\n    require(_token != address(aToken), \"AaveV3YS/forbid-aToken-allowance\");\n  }\n\n  /**\n   * @notice Calculates the number of shares that should be minted or burnt when a user deposit or withdraw.\n   * @param _tokens Amount of asset tokens\n   * @return Number of shares.\n   */\n  function _tokenToShares(uint256 _tokens) internal view returns (uint256) {\n    uint256 _supply = totalSupply();\n\n    // shares = (tokens * totalShares) / yieldSourceATokenTotalSupply\n    return _supply == 0 ? _tokens : _tokens.mul(_supply).div(aToken.balanceOf(address(this)));\n  }\n\n  /**\n   * @notice Calculates the number of asset tokens a user has in the yield source.\n   * @param _shares Amount of shares\n   * @return Number of asset tokens.\n   */\n  function _sharesToToken(uint256 _shares) internal view returns (uint256) {\n    uint256 _supply = totalSupply();\n\n    // tokens = (shares * yieldSourceATokenTotalSupply) / totalShares\n    return _supply == 0 ? _shares : _shares.mul(aToken.balanceOf(address(this))).div(_supply);\n  }\n\n  /**\n   * @notice Returns the underlying asset token address.\n   * @return Underlying asset token address.\n   */\n  function _tokenAddress() internal view returns (address) {\n    return aToken.UNDERLYING_ASSET_ADDRESS();\n  }\n\n  /**\n   * @notice Retrieves Aave PoolAddressesProvider address.\n   * @return A reference to PoolAddressesProvider interface.\n   */\n  function _poolProvider() internal view returns (IPoolAddressesProvider) {\n    return\n      IPoolAddressesProvider(\n        poolAddressesProviderRegistry.getAddressesProvidersList()[ADDRESSES_PROVIDER_ID]\n      );\n  }\n\n  /**\n   * @notice Retrieves Aave Pool address.\n   * @return A reference to Pool interface.\n   */\n  function _pool() internal view returns (IPool) {\n    return IPool(_poolProvider().getPool());\n  }\n}"
    },
    {
      "filename": "contracts/PrizeFlush.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.6;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@pooltogether/owner-manager-contracts/contracts/Manageable.sol\";\n\nimport \"./interfaces/IPrizeFlush.sol\";\n\n/**\n * @title  PoolTogether V4 PrizeFlush\n * @author PoolTogether Inc Team\n * @notice The PrizeFlush contract helps capture interest from the PrizePool and move collected funds\n           to a designated PrizeDistributor contract. When deployed, the destination, reserve and strategy\n           addresses are set and used as static parameters during every \"flush\" execution. The parameters can be\n           reset by the Owner if necessary.\n */\ncontract PrizeFlush is IPrizeFlush, Manageable {\n    /**\n     * @notice Destination address for captured interest.\n     * @dev Should be set to the PrizeDistributor address.\n     */\n    address internal destination;\n\n    /// @notice Reserve address.\n    IReserve internal reserve;\n\n    /// @notice Strategy address.\n    IStrategy internal strategy;\n\n    /**\n     * @notice Emitted when contract has been deployed.\n     * @param destination Destination address\n     * @param reserve Strategy address\n     * @param strategy Reserve address\n     *\n     */\n    event Deployed(\n        address indexed destination,\n        IReserve indexed reserve,\n        IStrategy indexed strategy\n    );\n\n    /* ============ Constructor ============ */\n\n    /**\n     * @notice Deploy Prize Flush.\n     * @param _owner Prize Flush owner address\n     * @param _destination Destination address\n     * @param _strategy Strategy address\n     * @param _reserve Reserve address\n     *\n     */\n    constructor(\n        address _owner,\n        address _destination,\n        IStrategy _strategy,\n        IReserve _reserve\n    ) Ownable(_owner) {\n        _setDestination(_destination);\n        _setReserve(_reserve);\n        _setStrategy(_strategy);\n\n        emit Deployed(_destination, _reserve, _strategy);\n    }\n\n    /* ============ External Functions ============ */\n\n    /// @inheritdoc IPrizeFlush\n    function getDestination() external view override returns (address) {\n        return destination;\n    }\n\n    /// @inheritdoc IPrizeFlush\n    function getReserve() external view override returns (IReserve) {\n        return reserve;\n    }\n\n    /// @inheritdoc IPrizeFlush\n    function getStrategy() external view override returns (IStrategy) {\n        return strategy;\n    }\n\n    /// @inheritdoc IPrizeFlush\n    function setDestination(address _destination) external override onlyOwner returns (address) {\n        _setDestination(_destination);\n        emit DestinationSet(_destination);\n        return _destination;\n    }\n\n    /// @inheritdoc IPrizeFlush\n    function setReserve(IReserve _reserve) external override onlyOwner returns (IReserve) {\n        _setReserve(_reserve);\n        emit ReserveSet(_reserve);\n        return _reserve;\n    }\n\n    /// @inheritdoc IPrizeFlush\n    function setStrategy(IStrategy _strategy) external override onlyOwner returns (IStrategy) {\n        _setStrategy(_strategy);\n        emit StrategySet(_strategy);\n        return _strategy;\n    }\n\n    /// @inheritdoc IPrizeFlush\n    function flush() external override onlyManagerOrOwner returns (bool) {\n        // Captures interest from PrizePool and distributes funds using a PrizeSplitStrategy.\n        strategy.distribute();\n\n        // After funds are distributed using PrizeSplitStrategy we EXPECT funds to be located in the Reserve.\n        IReserve _reserve = reserve;\n        IERC20 _token = _reserve.getToken();\n        uint256 _amount = _token.balanceOf(address(_reserve));\n\n        // IF the tokens were succesfully moved to the Reserve, now move them to the destination (PrizeDistributor) address.\n        if (_amount > 0) {\n            address _destination = destination;\n\n            // Create checkpoint and transfers new total balance to PrizeDistributor\n            _reserve.withdrawTo(_destination, _amount);\n\n            emit Flushed(_destination, _amount);\n            return true;\n        }\n\n        return false;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * @notice Set global destination variable.\n     * @dev `_destination` cannot be the zero address.\n     * @param _destination Destination address\n     */\n    function _setDestination(address _destination) internal {\n        require(_destination != address(0), \"Flush/destination-not-zero-address\");\n        destination = _destination;\n    }\n\n    /**\n     * @notice Set global reserve variable.\n     * @dev `_reserve` cannot be the zero address.\n     * @param _reserve Reserve address\n     */\n    function _setReserve(IReserve _reserve) internal {\n        require(address(_reserve) != address(0), \"Flush/reserve-not-zero-address\");\n        reserve = _reserve;\n    }\n\n    /**\n     * @notice Set global strategy variable.\n     * @dev `_strategy` cannot be the zero address.\n     * @param _strategy Strategy address\n     */\n    function _setStrategy(IStrategy _strategy) internal {\n        require(address(_strategy) != address(0), \"Flush/strategy-not-zero-address\");\n        strategy = _strategy;\n    }\n}"
    },
    {
      "filename": "contracts/prize-strategy/PrizeSplitStrategy.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.6;\n\nimport \"./PrizeSplit.sol\";\nimport \"../interfaces/IStrategy.sol\";\nimport \"../interfaces/IPrizePool.sol\";\n\n/**\n  * @title  PoolTogether V4 PrizeSplitStrategy\n  * @author PoolTogether Inc Team\n  * @notice Captures PrizePool interest for PrizeReserve and additional PrizeSplit recipients.\n            The PrizeSplitStrategy will have at minimum a single PrizeSplit with 100% of the captured\n            interest transfered to the PrizeReserve. Additional PrizeSplits can be added, depending on\n            the deployers requirements (i.e. percentage to charity). In contrast to previous PoolTogether\n            iterations, interest can be captured independent of a new Draw. Ideally (to save gas) interest\n            is only captured when also distributing the captured prize(s) to applicable Prize Distributor(s).\n*/\ncontract PrizeSplitStrategy is PrizeSplit, IStrategy {\n    /**\n     * @notice PrizePool address\n     */\n    IPrizePool internal immutable prizePool;\n\n    /**\n     * @notice Deployed Event\n     * @param owner Contract owner\n     * @param prizePool Linked PrizePool contract\n     */\n    event Deployed(address indexed owner, IPrizePool prizePool);\n\n    /* ============ Constructor ============ */\n\n    /**\n     * @notice Deploy the PrizeSplitStrategy smart contract.\n     * @param _owner     Owner address\n     * @param _prizePool PrizePool address\n     */\n    constructor(address _owner, IPrizePool _prizePool) Ownable(_owner) {\n        require(\n            address(_prizePool) != address(0),\n            \"PrizeSplitStrategy/prize-pool-not-zero-address\"\n        );\n        prizePool = _prizePool;\n        emit Deployed(_owner, _prizePool);\n    }\n\n    /* ============ External Functions ============ */\n\n    /// @inheritdoc IStrategy\n    function distribute() external override returns (uint256) {\n        uint256 prize = prizePool.captureAwardBalance();\n\n        if (prize == 0) return 0;\n\n        uint256 prizeRemaining = _distributePrizeSplits(prize);\n\n        emit Distributed(prize - prizeRemaining);\n\n        return prize;\n    }\n\n    /// @inheritdoc IPrizeSplit\n    function getPrizePool() external view override returns (IPrizePool) {\n        return prizePool;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * @notice Award ticket tokens to prize split recipient.\n     * @dev Award ticket tokens to prize split recipient via the linked PrizePool contract.\n     * @param _to Recipient of minted tokens.\n     * @param _amount Amount of minted tokens.\n     */\n    function _awardPrizeSplitAmount(address _to, uint256 _amount) internal override {\n        IControlledToken _ticket = prizePool.getTicket();\n        prizePool.award(_to, _amount);\n        emit PrizeSplitAwarded(_to, _amount, _ticket);\n    }\n}"
    }
  ]
}