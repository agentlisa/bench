{
  "Title": "M-4: Malicious user can frontrun withdrawals from Insurance Fund to significantly decrease value of shares",
  "Content": "# Issue M-4: Malicious user can frontrun withdrawals from Insurance Fund to significantly decrease value of shares \n\nSource: https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/72 \n\n## Found by \n0xDjango, Delvir0, carrotsmuggler, dirk\\_y, lil.eth, rogue-lion-0619\n## Summary\nWhen a user withdraws from the insurance fund, the value of their shares is calculated based on the balance of vUSD in the fund. Another user could deliberately frontrun (or frontrun by chance) the withdrawal with a call to `settleBadDebt` to significantly reduce the vUSD returned from the withdrawal with the same number of shares.\n\n## Vulnerability Detail\nWhen a user wants to withdraw from the insurance pool they have to go through a 2 step withdrawal process. First they need to unbond their shares, and then they have to wait for the pre-determined unbonding period before they can withdraw the vUSD their shares are worth by calling `withdraw`.\n\nWhen a user calls `withdraw` the amount of vUSD to redeem is calculated as:\n\n```solidity\namount = balance() * shares / totalSupply();\n```\n\nwhere `balance()` is the balance of vUSD in the contract and `totalSupply()` is the total supply of share tokens. Therefore, if the balance of vUSD in the contract were to decrease, then the amount of vUSD redeemed from the same number of shares would decrease as a result.\n\nThis occurs when a trader's bad debt is settled when calling `settleBadDebt` in `MarginAccount.sol` as this calls `insuranceFund.seizeBadDebt` under the hood, which in turn calls `settlePendingObligation` which transfers vUSD out of the insurance fund to the margin account:\n\n```solidity\nvusd.safeTransfer(marginAccount, toTransfer);\n```\n\nThe result is now that the balance of vUSD in the insurance fund is lower and thus the shares are worth less vUSD as a consequence.\n\n## Impact\nA user withdrawing from the insurance fund could receive significantly less (potentially 0) vUSD when finalising their withdrawal.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/InsuranceFund.sol#L215\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/InsuranceFund.sol#L259-L261\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/InsuranceFund.sol#L153-L161\n\n## Tool used\nManual Review\n\n## Recommendation\nOne option would be to include a slippage parameter on the `withdraw` and `withdrawFor` methods so that the user redeeming shares can specify the minimum amount of vUSD they would accept for their shares.\n\nWhen depositing into the insurance fund, the number of shares to mint is actually calculated based on the total value of the pool (value of vUSD and all other collateral assets). Therefore, the withdraw logic could also use `_totalPoolValue` instead of `balance()` to get a \"true\" value per share, however this could lead to withdrawals failing while assets are up for auction. Assuming all the assets are expected to be sold within the short 2 hour auction duration, this is probably the better solution given the pricing is more accurate, but it depends if users would accept failed withdrawals for short periods of time.\n\n\n\n## Discussion\n\n**asquare08**\n\nWithdrawals done after `settleBadDebt` and before the end of the auction of the seized collateral, will receive less USDC as compared to withdrawals done after the auction has ended.\nHowever, a user deliberately cannot front run all withdrawals with `settleBadDebt` as it will required generating bad debt first. Hence, the severity can be changed to `low`\n\n**ctf-sec**\n\nEmm worth checking the duplicate as well, the duplicate highlights the total supply can be inflated to make user mint less share as well\n\nroot cause is the totalSupply() can be inflated by transferring asset directly\n\nfor example duplicate #144, #224\n\nrecommend maintaining high severity\n\n**ctf-sec**\n\nComment from senior Watson\n\nTotal supply can be inflated by donation but that would distribute the funds to other users in the pool making this a bigger loss than any kind of gain. \n\nAssuming they owned the entire pool, which the only way to make donating profitable, the victim wouldn't lose any value because the donated assets would be auctioned.\n\nWhen burning, donation of other assets doesn't affect the amount of vUSD received.\n\nBest case I see for this is medium since there is potential for withdraws to be frontrun by calls to settle bad debt. Since there is no way to create bad debt arbitrarily it would be dependent on bad debt already existing but being unclaimed:\n\n\n\n**asquare08**\n\nagree with the above commnet\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/72",
  "Code": [
    {
      "filename": "hubble-protocol/contracts/InsuranceFund.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport { VanillaGovernable } from \"./legos/Governable.sol\";\nimport { IRegistry, IOracle, IMarginAccount, ERC20Detailed, IInsuranceFund } from \"./Interfaces.sol\";\n\n/**\n * @title The Insurance Fund acts as a backstop for the protocol. Since you can take leverage on Hubble, there is a chance that the protocol will be undercollateralized in the event of a rapid market movement. The insurance fund is used to cover any shortfalls.\n*/\ncontract InsuranceFund is VanillaGovernable, ERC20Upgradeable, IInsuranceFund {\n    using SafeERC20 for IERC20;\n\n    uint8 constant DECIMALS = 6;\n    uint constant PRECISION = 10 ** DECIMALS;\n\n    IERC20 public vusd;\n    address public marginAccount;\n    address public marginAccountHelper;\n    IOracle public oracle;\n    uint public pendingObligation;\n    uint public startPriceMultiplier;\n    uint public auctionDuration;\n\n    struct UnbondInfo {\n        uint shares;\n        uint unbondTime;\n    }\n\n    struct Auction {\n        uint startPrice;\n        uint startedAt;\n        uint expiryTime;\n    }\n\n    /// @notice token to auction mapping\n    mapping(address => Auction) public auctions;\n\n    mapping(address => UnbondInfo) public unbond;\n    uint256 public withdrawPeriod;\n    uint256 public unbondPeriod;\n    uint256 public unbondRoundOff;\n\n    uint256[50] private __gap;\n\n    event FundsAdded(address indexed insurer, uint amount, uint timestamp);\n    event Unbonded(address indexed trader, uint256 unbondAmount, uint256 unbondTime, uint timestamp);\n    event FundsWithdrawn(address indexed insurer, uint amount, uint timestamp);\n    event BadDebtAccumulated(uint amount, uint timestamp);\n\n    modifier onlyMarginAccount() {\n        require(_msgSender() == address(marginAccount), \"IF.only_margin_account\");\n        _;\n    }\n\n    modifier onlyMarginAccountHelper() {\n        require(_msgSender() == marginAccountHelper, \"IF.only_margin_account_helper\");\n        _;\n    }\n\n    function initialize(address _governance) external initializer {\n        __ERC20_init(\"Hubble-Insurance-Fund\", \"HIF\");\n        _setGovernace(_governance);\n\n        unbondPeriod = 2 days;\n        withdrawPeriod = 1 days;\n        unbondRoundOff = 1 days;\n        startPriceMultiplier = 1050000; // 1.05\n        auctionDuration = 2 hours;\n    }\n\n    /**\n     * @notice deposit vusd to the insurance fund\n     * @param amount amount to deposit\n    */\n    function deposit(uint amount) external {\n        depositFor(_msgSender(), amount);\n    }\n\n    /**\n     * @notice Deposit to the insurance fund on behalf of another address\n     * @param to address to deposit for\n    */\n    function depositFor(address to, uint amount) override public {\n        settlePendingObligation();\n        // we want to protect new LPs, when the insurance fund is in deficit\n        require(pendingObligation == 0, \"IF.deposit.pending_obligations\");\n\n        uint _pool = _totalPoolValue();\n        uint _totalSupply = totalSupply();\n        uint vusdBalance = balance();\n        if (_totalSupply == 0 && vusdBalance > 0) { // trading fee accumulated while there were no IF LPs\n            vusd.safeTransfer(governance(), vusdBalance);\n            _pool = 0;\n        }\n\n        vusd.safeTransferFrom(_msgSender(), address(this), amount);\n        uint shares = 0;\n        if (_pool == 0) {\n            shares = amount;\n        } else {\n            shares = amount * _totalSupply / _pool;\n        }\n        _mint(to, shares);\n        emit FundsAdded(to, amount, _blockTimestamp());\n    }\n\n    /**\n     * @notice Begin the withdrawal process\n    */\n    function unbondShares(uint shares) external {\n        address usr = _msgSender();\n        require(shares <= balanceOf(usr), \"unbonding_too_much\");\n        uint _now = _blockTimestamp();\n        uint unbondTime = ((_now + unbondPeriod) / unbondRoundOff) * unbondRoundOff;\n        unbond[usr] = UnbondInfo(shares, unbondTime);\n        emit Unbonded(usr, shares, unbondTime, _now);\n    }\n\n    /**\n     * @notice Withdraw funds after unbonding period is over\n    */\n    function withdraw(uint shares) external {\n        address user = _msgSender();\n        _withdrawFor(user, shares, user);\n    }\n\n    /**\n     * @notice Priviliged withdraw function used by the MarginAccountHelper to unwrap the tokens before sending it to the user\n    */\n    function withdrawFor(address user, uint shares) override external onlyMarginAccountHelper returns (uint) {\n        return _withdrawFor(user, shares, marginAccountHelper);\n    }\n\n    /**\n     * @notice Margin Account contract calls this function to seize bad debt\n    */\n    function seizeBadDebt(uint amount) override external onlyMarginAccount {\n        pendingObligation += amount;\n        emit BadDebtAccumulated(amount, block.timestamp);\n        settlePendingObligation();\n    }\n\n    /**\n     * @notice Sometimes the insurance fund may be in deficit and there might not be enough vusd to settle the obligation.\n     * Using this function obligation can be settled with future fees.\n    */\n    function settlePendingObligation() public {\n        if (pendingObligation > 0) {\n            uint toTransfer = Math.min(vusd.balanceOf(address(this)), pendingObligation);\n            if (toTransfer > 0) {\n                pendingObligation -= toTransfer;\n                vusd.safeTransfer(marginAccount, toTransfer);\n            }\n        }\n    }\n\n    /**\n     * @notice Insurance fund starts an auction for assets seized from a bad debt settlement\n     * @param token token to auction\n    */\n    function startAuction(address token) override external onlyMarginAccount {\n        if(!_isAuctionOngoing(auctions[token].startedAt, auctions[token].expiryTime)) {\n            uint currentPrice = uint(oracle.getUnderlyingPrice(token));\n            uint currentTimestamp = _blockTimestamp();\n            auctions[token] = Auction(\n                currentPrice * startPriceMultiplier / PRECISION,\n                currentTimestamp,\n                currentTimestamp + auctionDuration\n            );\n        }\n    }\n\n    /**\n    * @notice buy collateral from ongoing auction at current auction price\n    * @param token token to buy\n    * @param amount amount to buy\n    */\n    function buyCollateralFromAuction(address token, uint amount) override external {\n        Auction memory auction = auctions[token];\n        // validate auction\n        require(_isAuctionOngoing(auction.startedAt, auction.expiryTime), \"IF.no_ongoing_auction\");\n\n        // transfer funds\n        uint vusdToTransfer = _calcVusdAmountForAuction(auction, token, amount);\n        address buyer = _msgSender();\n        vusd.safeTransferFrom(buyer, address(this), vusdToTransfer);\n        IERC20(token).safeTransfer(buyer, amount); // will revert if there wasn't enough amount as requested\n\n        // close auction if no collateral left\n        if (IERC20(token).balanceOf(address(this)) == 0) {\n            auctions[token].startedAt = 0;\n        }\n    }\n\n    /* ****************** */\n    /*      Internal      */\n    /* ****************** */\n\n    function _withdrawFor(address user, uint shares, address to) internal returns (uint amount) {\n        // Checks\n        require(unbond[user].shares >= shares, \"withdrawing_more_than_unbond\");\n        uint _now = _blockTimestamp();\n        require(_now >= unbond[user].unbondTime, \"still_unbonding\");\n        require(!_hasWithdrawPeriodElapsed(_now, unbond[user].unbondTime), \"withdraw_period_over\");\n\n        // Effects\n        settlePendingObligation();\n        require(pendingObligation == 0, \"IF.withdraw.pending_obligations\");\n        amount = balance() * shares / totalSupply();\n        unchecked { unbond[user].shares -= shares; }\n        _burn(user, shares);\n\n        // Interactions\n        vusd.safeTransfer(to, amount);\n        emit FundsWithdrawn(user, amount, _now);\n    }\n\n    /* ****************** */\n    /*        View        */\n    /* ****************** */\n\n    /**\n    * @notice Just a vanity function\n    * @return The hUSD amount backing each Insurance Fund share\n    */\n    function pricePerShare() external view returns (uint) {\n        uint _totalSupply = totalSupply();\n        uint _balance = balance();\n        _balance -= Math.min(_balance, pendingObligation);\n        if (_totalSupply == 0 || _balance == 0) {\n            return PRECISION;\n        }\n        return _balance * PRECISION / _totalSupply;\n    }\n\n    function getAuctionPrice(address token) external view returns (uint) {\n        Auction memory auction = auctions[token];\n        if (_isAuctionOngoing(auction.startedAt, auction.expiryTime)) {\n            return _getAuctionPrice(auction);\n        }\n        return 0;\n    }\n\n    function calcVusdAmountForAuction(address token, uint amount) override external view returns(uint) {\n        Auction memory auction = auctions[token];\n        return _calcVusdAmountForAuction(auction, token, amount);\n    }\n\n    function isAuctionOngoing(address token) external view returns (bool) {\n        return _isAuctionOngoing(auctions[token].startedAt, auctions[token].expiryTime);\n    }\n\n    function balance() public view returns (uint) {\n        return vusd.balanceOf(address(this));\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return DECIMALS;\n    }\n\n    function _blockTimestamp() internal view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    /* ****************** */\n    /*   Internal View    */\n    /* ****************** */\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) override internal view {\n        if (from == address(0) || to == address(0)) return; // gas optimisation for _mint and _burn\n        if (!_hasWithdrawPeriodElapsed(_blockTimestamp(), unbond[from].unbondTime)) {\n            require(amount <= balanceOf(from) - unbond[from].shares, \"shares_are_unbonding\");\n        }\n    }\n\n    function _hasWithdrawPeriodElapsed(uint _now, uint _unbondTime) internal view returns (bool) {\n        return _now > (_unbondTime + withdrawPeriod);\n    }\n\n    function _getAuctionPrice(Auction memory auction) internal view returns (uint) {\n        uint diff = auction.startPrice * (_blockTimestamp() - auction.startedAt) / auctionDuration;\n        return auction.startPrice - diff;\n    }\n\n    function _isAuctionOngoing(uint startedAt, uint expiryTime) internal view returns (bool) {\n        if (startedAt == 0) return false;\n        uint currentTimestamp = _blockTimestamp();\n        return startedAt <= currentTimestamp && currentTimestamp <= expiryTime;\n    }\n\n    function _calcVusdAmountForAuction(Auction memory auction, address token, uint amount) internal view returns(uint) {\n        uint price = _getAuctionPrice(auction);\n        uint _decimals = ERC20Detailed(token).decimals();  // will fail if .decimals() is not defined on the contract\n        return amount * price / 10 ** _decimals;\n    }\n\n    function _totalPoolValue() internal view returns (uint totalBalance) {\n        IMarginAccount.Collateral[] memory assets = IMarginAccount(marginAccount).supportedAssets();\n\n        for (uint i; i < assets.length; i++) {\n            uint _balance = IERC20(address(assets[i].token)).balanceOf(address(this));\n            if (_balance == 0) continue;\n\n            uint numerator = _balance * uint(oracle.getUnderlyingPrice(address(assets[i].token)));\n            uint denomDecimals = assets[i].decimals;\n\n            totalBalance += (numerator / 10 ** denomDecimals);\n        }\n    }\n\n    /* ****************** */\n    /*   onlyGovernance   */\n    /* ****************** */\n\n    function syncDeps(address _registry) public onlyGovernance {\n        IRegistry registry = IRegistry(_registry);\n        vusd = IERC20(registry.vusd());\n        marginAccount = registry.marginAccount();\n        oracle = IOracle(registry.oracle());\n        marginAccountHelper = registry.marginAccountHelper();\n    }\n}"
    },
    {
      "filename": "hubble-protocol/contracts/InsuranceFund.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport { VanillaGovernable } from \"./legos/Governable.sol\";\nimport { IRegistry, IOracle, IMarginAccount, ERC20Detailed, IInsuranceFund } from \"./Interfaces.sol\";\n\n/**\n * @title The Insurance Fund acts as a backstop for the protocol. Since you can take leverage on Hubble, there is a chance that the protocol will be undercollateralized in the event of a rapid market movement. The insurance fund is used to cover any shortfalls.\n*/\ncontract InsuranceFund is VanillaGovernable, ERC20Upgradeable, IInsuranceFund {\n    using SafeERC20 for IERC20;\n\n    uint8 constant DECIMALS = 6;\n    uint constant PRECISION = 10 ** DECIMALS;\n\n    IERC20 public vusd;\n    address public marginAccount;\n    address public marginAccountHelper;\n    IOracle public oracle;\n    uint public pendingObligation;\n    uint public startPriceMultiplier;\n    uint public auctionDuration;\n\n    struct UnbondInfo {\n        uint shares;\n        uint unbondTime;\n    }\n\n    struct Auction {\n        uint startPrice;\n        uint startedAt;\n        uint expiryTime;\n    }\n\n    /// @notice token to auction mapping\n    mapping(address => Auction) public auctions;\n\n    mapping(address => UnbondInfo) public unbond;\n    uint256 public withdrawPeriod;\n    uint256 public unbondPeriod;\n    uint256 public unbondRoundOff;\n\n    uint256[50] private __gap;\n\n    event FundsAdded(address indexed insurer, uint amount, uint timestamp);\n    event Unbonded(address indexed trader, uint256 unbondAmount, uint256 unbondTime, uint timestamp);\n    event FundsWithdrawn(address indexed insurer, uint amount, uint timestamp);\n    event BadDebtAccumulated(uint amount, uint timestamp);\n\n    modifier onlyMarginAccount() {\n        require(_msgSender() == address(marginAccount), \"IF.only_margin_account\");\n        _;\n    }\n\n    modifier onlyMarginAccountHelper() {\n        require(_msgSender() == marginAccountHelper, \"IF.only_margin_account_helper\");\n        _;\n    }\n\n    function initialize(address _governance) external initializer {\n        __ERC20_init(\"Hubble-Insurance-Fund\", \"HIF\");\n        _setGovernace(_governance);\n\n        unbondPeriod = 2 days;\n        withdrawPeriod = 1 days;\n        unbondRoundOff = 1 days;\n        startPriceMultiplier = 1050000; // 1.05\n        auctionDuration = 2 hours;\n    }\n\n    /**\n     * @notice deposit vusd to the insurance fund\n     * @param amount amount to deposit\n    */\n    function deposit(uint amount) external {\n        depositFor(_msgSender(), amount);\n    }\n\n    /**\n     * @notice Deposit to the insurance fund on behalf of another address\n     * @param to address to deposit for\n    */\n    function depositFor(address to, uint amount) override public {\n        settlePendingObligation();\n        // we want to protect new LPs, when the insurance fund is in deficit\n        require(pendingObligation == 0, \"IF.deposit.pending_obligations\");\n\n        uint _pool = _totalPoolValue();\n        uint _totalSupply = totalSupply();\n        uint vusdBalance = balance();\n        if (_totalSupply == 0 && vusdBalance > 0) { // trading fee accumulated while there were no IF LPs\n            vusd.safeTransfer(governance(), vusdBalance);\n            _pool = 0;\n        }\n\n        vusd.safeTransferFrom(_msgSender(), address(this), amount);\n        uint shares = 0;\n        if (_pool == 0) {\n            shares = amount;\n        } else {\n            shares = amount * _totalSupply / _pool;\n        }\n        _mint(to, shares);\n        emit FundsAdded(to, amount, _blockTimestamp());\n    }\n\n    /**\n     * @notice Begin the withdrawal process\n    */\n    function unbondShares(uint shares) external {\n        address usr = _msgSender();\n        require(shares <= balanceOf(usr), \"unbonding_too_much\");\n        uint _now = _blockTimestamp();\n        uint unbondTime = ((_now + unbondPeriod) / unbondRoundOff) * unbondRoundOff;\n        unbond[usr] = UnbondInfo(shares, unbondTime);\n        emit Unbonded(usr, shares, unbondTime, _now);\n    }\n\n    /**\n     * @notice Withdraw funds after unbonding period is over\n    */\n    function withdraw(uint shares) external {\n        address user = _msgSender();\n        _withdrawFor(user, shares, user);\n    }\n\n    /**\n     * @notice Priviliged withdraw function used by the MarginAccountHelper to unwrap the tokens before sending it to the user\n    */\n    function withdrawFor(address user, uint shares) override external onlyMarginAccountHelper returns (uint) {\n        return _withdrawFor(user, shares, marginAccountHelper);\n    }\n\n    /**\n     * @notice Margin Account contract calls this function to seize bad debt\n    */\n    function seizeBadDebt(uint amount) override external onlyMarginAccount {\n        pendingObligation += amount;\n        emit BadDebtAccumulated(amount, block.timestamp);\n        settlePendingObligation();\n    }\n\n    /**\n     * @notice Sometimes the insurance fund may be in deficit and there might not be enough vusd to settle the obligation.\n     * Using this function obligation can be settled with future fees.\n    */\n    function settlePendingObligation() public {\n        if (pendingObligation > 0) {\n            uint toTransfer = Math.min(vusd.balanceOf(address(this)), pendingObligation);\n            if (toTransfer > 0) {\n                pendingObligation -= toTransfer;\n                vusd.safeTransfer(marginAccount, toTransfer);\n            }\n        }\n    }\n\n    /**\n     * @notice Insurance fund starts an auction for assets seized from a bad debt settlement\n     * @param token token to auction\n    */\n    function startAuction(address token) override external onlyMarginAccount {\n        if(!_isAuctionOngoing(auctions[token].startedAt, auctions[token].expiryTime)) {\n            uint currentPrice = uint(oracle.getUnderlyingPrice(token));\n            uint currentTimestamp = _blockTimestamp();\n            auctions[token] = Auction(\n                currentPrice * startPriceMultiplier / PRECISION,\n                currentTimestamp,\n                currentTimestamp + auctionDuration\n            );\n        }\n    }\n\n    /**\n    * @notice buy collateral from ongoing auction at current auction price\n    * @param token token to buy\n    * @param amount amount to buy\n    */\n    function buyCollateralFromAuction(address token, uint amount) override external {\n        Auction memory auction = auctions[token];\n        // validate auction\n        require(_isAuctionOngoing(auction.startedAt, auction.expiryTime), \"IF.no_ongoing_auction\");\n\n        // transfer funds\n        uint vusdToTransfer = _calcVusdAmountForAuction(auction, token, amount);\n        address buyer = _msgSender();\n        vusd.safeTransferFrom(buyer, address(this), vusdToTransfer);\n        IERC20(token).safeTransfer(buyer, amount); // will revert if there wasn't enough amount as requested\n\n        // close auction if no collateral left\n        if (IERC20(token).balanceOf(address(this)) == 0) {\n            auctions[token].startedAt = 0;\n        }\n    }\n\n    /* ****************** */\n    /*      Internal      */\n    /* ****************** */\n\n    function _withdrawFor(address user, uint shares, address to) internal returns (uint amount) {\n        // Checks\n        require(unbond[user].shares >= shares, \"withdrawing_more_than_unbond\");\n        uint _now = _blockTimestamp();\n        require(_now >= unbond[user].unbondTime, \"still_unbonding\");\n        require(!_hasWithdrawPeriodElapsed(_now, unbond[user].unbondTime), \"withdraw_period_over\");\n\n        // Effects\n        settlePendingObligation();\n        require(pendingObligation == 0, \"IF.withdraw.pending_obligations\");\n        amount = balance() * shares / totalSupply();\n        unchecked { unbond[user].shares -= shares; }\n        _burn(user, shares);\n\n        // Interactions\n        vusd.safeTransfer(to, amount);\n        emit FundsWithdrawn(user, amount, _now);\n    }\n\n    /* ****************** */\n    /*        View        */\n    /* ****************** */\n\n    /**\n    * @notice Just a vanity function\n    * @return The hUSD amount backing each Insurance Fund share\n    */\n    function pricePerShare() external view returns (uint) {\n        uint _totalSupply = totalSupply();\n        uint _balance = balance();\n        _balance -= Math.min(_balance, pendingObligation);\n        if (_totalSupply == 0 || _balance == 0) {\n            return PRECISION;\n        }\n        return _balance * PRECISION / _totalSupply;\n    }\n\n    function getAuctionPrice(address token) external view returns (uint) {\n        Auction memory auction = auctions[token];\n        if (_isAuctionOngoing(auction.startedAt, auction.expiryTime)) {\n            return _getAuctionPrice(auction);\n        }\n        return 0;\n    }\n\n    function calcVusdAmountForAuction(address token, uint amount) override external view returns(uint) {\n        Auction memory auction = auctions[token];\n        return _calcVusdAmountForAuction(auction, token, amount);\n    }\n\n    function isAuctionOngoing(address token) external view returns (bool) {\n        return _isAuctionOngoing(auctions[token].startedAt, auctions[token].expiryTime);\n    }\n\n    function balance() public view returns (uint) {\n        return vusd.balanceOf(address(this));\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return DECIMALS;\n    }\n\n    function _blockTimestamp() internal view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    /* ****************** */\n    /*   Internal View    */\n    /* ****************** */\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) override internal view {\n        if (from == address(0) || to == address(0)) return; // gas optimisation for _mint and _burn\n        if (!_hasWithdrawPeriodElapsed(_blockTimestamp(), unbond[from].unbondTime)) {\n            require(amount <= balanceOf(from) - unbond[from].shares, \"shares_are_unbonding\");\n        }\n    }\n\n    function _hasWithdrawPeriodElapsed(uint _now, uint _unbondTime) internal view returns (bool) {\n        return _now > (_unbondTime + withdrawPeriod);\n    }\n\n    function _getAuctionPrice(Auction memory auction) internal view returns (uint) {\n        uint diff = auction.startPrice * (_blockTimestamp() - auction.startedAt) / auctionDuration;\n        return auction.startPrice - diff;\n    }\n\n    function _isAuctionOngoing(uint startedAt, uint expiryTime) internal view returns (bool) {\n        if (startedAt == 0) return false;\n        uint currentTimestamp = _blockTimestamp();\n        return startedAt <= currentTimestamp && currentTimestamp <= expiryTime;\n    }\n\n    function _calcVusdAmountForAuction(Auction memory auction, address token, uint amount) internal view returns(uint) {\n        uint price = _getAuctionPrice(auction);\n        uint _decimals = ERC20Detailed(token).decimals();  // will fail if .decimals() is not defined on the contract\n        return amount * price / 10 ** _decimals;\n    }\n\n    function _totalPoolValue() internal view returns (uint totalBalance) {\n        IMarginAccount.Collateral[] memory assets = IMarginAccount(marginAccount).supportedAssets();\n\n        for (uint i; i < assets.length; i++) {\n            uint _balance = IERC20(address(assets[i].token)).balanceOf(address(this));\n            if (_balance == 0) continue;\n\n            uint numerator = _balance * uint(oracle.getUnderlyingPrice(address(assets[i].token)));\n            uint denomDecimals = assets[i].decimals;\n\n            totalBalance += (numerator / 10 ** denomDecimals);\n        }\n    }\n\n    /* ****************** */\n    /*   onlyGovernance   */\n    /* ****************** */\n\n    function syncDeps(address _registry) public onlyGovernance {\n        IRegistry registry = IRegistry(_registry);\n        vusd = IERC20(registry.vusd());\n        marginAccount = registry.marginAccount();\n        oracle = IOracle(registry.oracle());\n        marginAccountHelper = registry.marginAccountHelper();\n    }\n}"
    },
    {
      "filename": "hubble-protocol/contracts/InsuranceFund.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport { VanillaGovernable } from \"./legos/Governable.sol\";\nimport { IRegistry, IOracle, IMarginAccount, ERC20Detailed, IInsuranceFund } from \"./Interfaces.sol\";\n\n/**\n * @title The Insurance Fund acts as a backstop for the protocol. Since you can take leverage on Hubble, there is a chance that the protocol will be undercollateralized in the event of a rapid market movement. The insurance fund is used to cover any shortfalls.\n*/\ncontract InsuranceFund is VanillaGovernable, ERC20Upgradeable, IInsuranceFund {\n    using SafeERC20 for IERC20;\n\n    uint8 constant DECIMALS = 6;\n    uint constant PRECISION = 10 ** DECIMALS;\n\n    IERC20 public vusd;\n    address public marginAccount;\n    address public marginAccountHelper;\n    IOracle public oracle;\n    uint public pendingObligation;\n    uint public startPriceMultiplier;\n    uint public auctionDuration;\n\n    struct UnbondInfo {\n        uint shares;\n        uint unbondTime;\n    }\n\n    struct Auction {\n        uint startPrice;\n        uint startedAt;\n        uint expiryTime;\n    }\n\n    /// @notice token to auction mapping\n    mapping(address => Auction) public auctions;\n\n    mapping(address => UnbondInfo) public unbond;\n    uint256 public withdrawPeriod;\n    uint256 public unbondPeriod;\n    uint256 public unbondRoundOff;\n\n    uint256[50] private __gap;\n\n    event FundsAdded(address indexed insurer, uint amount, uint timestamp);\n    event Unbonded(address indexed trader, uint256 unbondAmount, uint256 unbondTime, uint timestamp);\n    event FundsWithdrawn(address indexed insurer, uint amount, uint timestamp);\n    event BadDebtAccumulated(uint amount, uint timestamp);\n\n    modifier onlyMarginAccount() {\n        require(_msgSender() == address(marginAccount), \"IF.only_margin_account\");\n        _;\n    }\n\n    modifier onlyMarginAccountHelper() {\n        require(_msgSender() == marginAccountHelper, \"IF.only_margin_account_helper\");\n        _;\n    }\n\n    function initialize(address _governance) external initializer {\n        __ERC20_init(\"Hubble-Insurance-Fund\", \"HIF\");\n        _setGovernace(_governance);\n\n        unbondPeriod = 2 days;\n        withdrawPeriod = 1 days;\n        unbondRoundOff = 1 days;\n        startPriceMultiplier = 1050000; // 1.05\n        auctionDuration = 2 hours;\n    }\n\n    /**\n     * @notice deposit vusd to the insurance fund\n     * @param amount amount to deposit\n    */\n    function deposit(uint amount) external {\n        depositFor(_msgSender(), amount);\n    }\n\n    /**\n     * @notice Deposit to the insurance fund on behalf of another address\n     * @param to address to deposit for\n    */\n    function depositFor(address to, uint amount) override public {\n        settlePendingObligation();\n        // we want to protect new LPs, when the insurance fund is in deficit\n        require(pendingObligation == 0, \"IF.deposit.pending_obligations\");\n\n        uint _pool = _totalPoolValue();\n        uint _totalSupply = totalSupply();\n        uint vusdBalance = balance();\n        if (_totalSupply == 0 && vusdBalance > 0) { // trading fee accumulated while there were no IF LPs\n            vusd.safeTransfer(governance(), vusdBalance);\n            _pool = 0;\n        }\n\n        vusd.safeTransferFrom(_msgSender(), address(this), amount);\n        uint shares = 0;\n        if (_pool == 0) {\n            shares = amount;\n        } else {\n            shares = amount * _totalSupply / _pool;\n        }\n        _mint(to, shares);\n        emit FundsAdded(to, amount, _blockTimestamp());\n    }\n\n    /**\n     * @notice Begin the withdrawal process\n    */\n    function unbondShares(uint shares) external {\n        address usr = _msgSender();\n        require(shares <= balanceOf(usr), \"unbonding_too_much\");\n        uint _now = _blockTimestamp();\n        uint unbondTime = ((_now + unbondPeriod) / unbondRoundOff) * unbondRoundOff;\n        unbond[usr] = UnbondInfo(shares, unbondTime);\n        emit Unbonded(usr, shares, unbondTime, _now);\n    }\n\n    /**\n     * @notice Withdraw funds after unbonding period is over\n    */\n    function withdraw(uint shares) external {\n        address user = _msgSender();\n        _withdrawFor(user, shares, user);\n    }\n\n    /**\n     * @notice Priviliged withdraw function used by the MarginAccountHelper to unwrap the tokens before sending it to the user\n    */\n    function withdrawFor(address user, uint shares) override external onlyMarginAccountHelper returns (uint) {\n        return _withdrawFor(user, shares, marginAccountHelper);\n    }\n\n    /**\n     * @notice Margin Account contract calls this function to seize bad debt\n    */\n    function seizeBadDebt(uint amount) override external onlyMarginAccount {\n        pendingObligation += amount;\n        emit BadDebtAccumulated(amount, block.timestamp);\n        settlePendingObligation();\n    }\n\n    /**\n     * @notice Sometimes the insurance fund may be in deficit and there might not be enough vusd to settle the obligation.\n     * Using this function obligation can be settled with future fees.\n    */\n    function settlePendingObligation() public {\n        if (pendingObligation > 0) {\n            uint toTransfer = Math.min(vusd.balanceOf(address(this)), pendingObligation);\n            if (toTransfer > 0) {\n                pendingObligation -= toTransfer;\n                vusd.safeTransfer(marginAccount, toTransfer);\n            }\n        }\n    }\n\n    /**\n     * @notice Insurance fund starts an auction for assets seized from a bad debt settlement\n     * @param token token to auction\n    */\n    function startAuction(address token) override external onlyMarginAccount {\n        if(!_isAuctionOngoing(auctions[token].startedAt, auctions[token].expiryTime)) {\n            uint currentPrice = uint(oracle.getUnderlyingPrice(token));\n            uint currentTimestamp = _blockTimestamp();\n            auctions[token] = Auction(\n                currentPrice * startPriceMultiplier / PRECISION,\n                currentTimestamp,\n                currentTimestamp + auctionDuration\n            );\n        }\n    }\n\n    /**\n    * @notice buy collateral from ongoing auction at current auction price\n    * @param token token to buy\n    * @param amount amount to buy\n    */\n    function buyCollateralFromAuction(address token, uint amount) override external {\n        Auction memory auction = auctions[token];\n        // validate auction\n        require(_isAuctionOngoing(auction.startedAt, auction.expiryTime), \"IF.no_ongoing_auction\");\n\n        // transfer funds\n        uint vusdToTransfer = _calcVusdAmountForAuction(auction, token, amount);\n        address buyer = _msgSender();\n        vusd.safeTransferFrom(buyer, address(this), vusdToTransfer);\n        IERC20(token).safeTransfer(buyer, amount); // will revert if there wasn't enough amount as requested\n\n        // close auction if no collateral left\n        if (IERC20(token).balanceOf(address(this)) == 0) {\n            auctions[token].startedAt = 0;\n        }\n    }\n\n    /* ****************** */\n    /*      Internal      */\n    /* ****************** */\n\n    function _withdrawFor(address user, uint shares, address to) internal returns (uint amount) {\n        // Checks\n        require(unbond[user].shares >= shares, \"withdrawing_more_than_unbond\");\n        uint _now = _blockTimestamp();\n        require(_now >= unbond[user].unbondTime, \"still_unbonding\");\n        require(!_hasWithdrawPeriodElapsed(_now, unbond[user].unbondTime), \"withdraw_period_over\");\n\n        // Effects\n        settlePendingObligation();\n        require(pendingObligation == 0, \"IF.withdraw.pending_obligations\");\n        amount = balance() * shares / totalSupply();\n        unchecked { unbond[user].shares -= shares; }\n        _burn(user, shares);\n\n        // Interactions\n        vusd.safeTransfer(to, amount);\n        emit FundsWithdrawn(user, amount, _now);\n    }\n\n    /* ****************** */\n    /*"
    }
  ]
}