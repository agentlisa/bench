{
  "Title": "[G-05] Calculations should be memoized rather than re-calculating them",
  "Content": "\nIn computing, memoization, or memoisation, is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls to pure functions and returning the cached result when the same inputs occur again.\n\n*There is 1 instance of this issue.*\n\nMemoize `keccak256(_data)` computation: \n\nhttps://github.com/code-423n4/2023-10-brahma/blob/main/contracts/src/core/TransactionValidator.sol#L166\n\n```solidity\nfile: contracts/src/core/TransactionValidator.sol\n\n149:    function _isConsoleBeingOverriden(\n150:        address _from,\n151:        address _to,\n152:        uint256 _value,\n153:        bytes memory _data,\n154:        Enum.Operation _operation\n155:    ) internal pure returns (bool) {\n.\n.\n.\n165:        if (_from == _to && _value == 0 && _operation == Enum.Operation.Call) {\n166:            if (SafeHelper._GUARD_REMOVAL_CALLDATA_HASH == keccak256(_data)) {  //@audit memoize keccak256(_data) calculation\n167:                return true;\n168:            } else if (SafeHelper._FALLBACK_REMOVAL_CALLDATA_HASH == keccak256(_data)) {\n169:                return true;\n170:            }\n171:        }\n172:\n173:        return false;\n174:    }\n```\n\nIn the `_isConsoleBeingOverriden()` function above, the computation `keccak256(_data)` in some scenarios would be computed twice. We could save gas used in the subsequent computation if we memoize the computation. We could cache the result of the calculation the first time in a variable and use the variable in place of the subsequent calculations, so that in scenarios where the `keccak256(_data)` computation would be calculated, we would have a reduced gas cost for the computation to just a stack read. The diff below shows how the code could be refactored:\n\n```diff\ndiff --git a/contracts/src/core/TransactionValidator.sol b/contracts/src/core/TransactionValidator.sol\nindex f31fe06..f02cc78 100644\n--- a/contracts/src/core/TransactionValidator.sol\n+++ b/contracts/src/core/TransactionValidator.sol\n@@ -163,9 +163,10 @@ contract TransactionValidator is AddressProviderService {\n          * In case these conditions are met, the guard is being removed, return true\n          */\n         if (_from == _to && _value == 0 && _operation == Enum.Operation.Call) {\n-            if (SafeHelper._GUARD_REMOVAL_CALLDATA_HASH == keccak256(_data)) {\n+            bytes32 datahash = keccak256(_data);\n+            if (SafeHelper._GUARD_REMOVAL_CALLDATA_HASH == datahash) {\n                 return true;\n-            } else if (SafeHelper._FALLBACK_REMOVAL_CALLDATA_HASH == keccak256(_data)) {\n+            } else if (SafeHelper._FALLBACK_REMOVAL_CALLDATA_HASH == datahash) {\n                 return true;\n             }\n         }\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-10-brahma",
  "Code": [
    {
      "filename": "contracts/src/core/TransactionValidator.sol",
      "content": "/// SPDX-License-Identifier: BUSL-1.1\n\n/// Copyright (C) 2023 Brahma.fi\n\npragma solidity 0.8.19;\n\nimport {IGnosisSafe, Enum} from \"interfaces/external/IGnosisSafe.sol\";\nimport {PolicyValidator} from \"src/core/PolicyValidator.sol\";\nimport {SafeHelper} from \"src/libraries/SafeHelper.sol\";\nimport {AddressProviderService} from \"src/core/AddressProviderService.sol\";\nimport {WalletRegistry} from \"src/core/registries/WalletRegistry.sol\";\n\n/**\n * @title TransactionValidator\n * @author Brahma.fi\n * @notice Allows validation of transactions pre and post execution\n */\ncontract TransactionValidator is AddressProviderService {\n    error TxnUnAuthorized();\n    error InvalidGuard();\n    error InvalidFallbackHandler();\n    error InvalidModule();\n\n    /**\n     * @notice datatype for safe transaction params\n     * @param from address of safe\n     * @param to target address\n     * @param value txn value\n     * @param data txn callData\n     * @param operation type of operation\n     * @param safeTxGas gas that should be used for safe txn\n     * @param baseGas gas cost independent of txn cost\n     * @param gasPrice gas price in current block\n     * @param gasToken address of token used for gas\n     * @param refundReceiver address of receiver of gas payment\n     * @param signatures user signatures appended with validation signature\n     * @param msgSender address of msg.sender of original txn\n     */\n    struct SafeTransactionParams {\n        Enum.Operation operation;\n        address from;\n        address to;\n        address payable refundReceiver;\n        address gasToken;\n        address msgSender;\n        uint256 value;\n        uint256 safeTxGas;\n        uint256 baseGas;\n        uint256 gasPrice;\n        bytes data;\n        bytes signatures;\n    }\n\n    constructor(address _addressProvider) AddressProviderService(_addressProvider) {}\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   CONSOLE GUARD HOOKS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n    /**\n     * @notice Validates a txn on guard before execution, for Brahma console accounts\n     * @dev checks for possible console overrides and then performs policy validation\n     * @param txParams params of transaction\n     */\n    function validatePreTransactionOverridable(SafeTransactionParams memory txParams) external view {\n        // Check if guard or fallback handler is being removed, if yes, skip policy validation\n        if (_isConsoleBeingOverriden(txParams.from, txParams.to, txParams.value, txParams.data, txParams.operation)) {\n            return;\n        }\n\n        // Validate policy otherwise\n        _validatePolicySignature(\n            txParams.from, txParams.to, txParams.value, txParams.data, txParams.operation, txParams.signatures\n        );\n    }\n\n    /* solhint-disable no-empty-blocks */\n    /**\n     * @notice Provides on-chain guarantees on security critical expected states of a Brhma console account\n     * @dev Empty hook available for future use\n     */\n    function validatePostTransactionOverridable(bytes32, /*txHash */ bool, /*success */ address /*console */ )\n        external\n        view\n    {}\n    /* solhint-enable no-empty-blocks */\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   SUBACCOUNT GUARD HOOKS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n    /**\n     * @notice Validates a txn on guard before execution, for subAccounts\n     * @dev calls policy validator to check if policy signature is valid\n     * @param txParams params of transaction\n     */\n    function validatePreTransaction(SafeTransactionParams memory txParams) external view {\n        _validatePolicySignature(\n            txParams.from, txParams.to, txParams.value, txParams.data, txParams.operation, txParams.signatures\n        );\n    }\n\n    /**\n     * @notice Provides on-chain guarantees on security critical expected states of subAccount for guard\n     * @param subAccount address of subAccount to validate\n     */\n    function validatePostTransaction(bytes32, /*txHash */ bool, /*success */ address subAccount) external view {\n        _checkSubAccountSecurityConfig(subAccount);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   EXECUTOR PLUGIN GUARD HOOKS              */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n    /**\n     * @notice Validates a module txn before execution\n     * @dev calls policy validator to check if policy signature is valid\n     * @param from address of safe\n     * @param transactionStructHash transaction struct hash\n     * @param signatures user signatures appended with validation signature\n     */\n    function validatePreExecutorTransaction(\n        address, /*msgSender */\n        address from,\n        bytes32 transactionStructHash,\n        bytes memory signatures\n    ) external view {\n        _validatePolicySignature(from, transactionStructHash, signatures);\n    }\n\n    /**\n     * @notice Provides on-chain guarantees on security critical expected states of subAccount for executor plugin\n     * @param subAccount address of subAccount to validate\n     */\n    function validatePostExecutorTransaction(address, /*msgSender */ address subAccount) external view {\n        _checkSubAccountSecurityConfig(subAccount);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   INTERNAL METHODS                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n    /**\n     * @notice Provides guarantees that the guard and fallback handler can always be removed by the console\n     * @dev This ensures that, if a `ConsoleAccount` wishes to override policy checks, to change the guard or fallback handler, it can do so without any external intervention\n     * @param _from address of sender\n     * @param _to target address\n     * @param _value txn value\n     * @param _data txn callData\n     * @param _operation type of operation\n     * @return isGuardBeingRemoved\n     */\n    function _isConsoleBeingOverriden(\n        address _from,\n        address _to,\n        uint256 _value,\n        bytes memory _data,\n        Enum.Operation _operation\n    ) internal pure returns (bool) {\n        /**\n         * Following conditions validate if the transaction aims to remove guard or fallback handler on Safe\n         *         from == to (safe sending txn to itself)\n         *         value == 0\n         *         data == abi.encodeCall(IGnosisSafe.setGuard, (address(0))) || abi.encodeCall(IGnosisSafe.setFallbackHandler, (address(0)))\n         *         operation == Enum.Operation.Call\n         *\n         * In case these conditions are met, the guard is being removed, return true\n         */\n        if (_from == _to && _value == 0 && _operation == Enum.Operation.Call) {\n            if (SafeHelper._GUARD_REMOVAL_CALLDATA_HASH == keccak256(_data)) {\n                return true;\n            } else if (SafeHelper._FALLBACK_REMOVAL_CALLDATA_HASH == keccak256(_data)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * @notice Internal helper to validate the module, guard and fallback handler for a subaccount\n     * @dev Ensures that guard has not been disabled/updated and the owner console as a module has not been disabled\n     * @param _subAccount address of subAccount\n     */\n    function _checkSubAccountSecurityConfig(address _subAccount) internal view {\n        address guard = SafeHelper._getGuard(_subAccount);\n        address fallbackHandler = SafeHelper._getFallbackHandler(_subAccount);\n\n        // Ensure guard has not been disabled\n        if (guard != AddressProviderService._getAuthorizedAddress(_SAFE_MODERATOR_HASH)) revert InvalidGuard();\n\n        // Ensure fallback handler has not been altered\n        if (fallbackHandler != AddressProviderService._getAuthorizedAddress(_CONSOLE_FALLBACK_HANDLER_HASH)) {\n            revert InvalidFallbackHandler();\n        }\n\n        address ownerConsole =\n            WalletRegistry(AddressProviderService._getRegistry(_WALLET_REGISTRY_HASH)).subAccountToWallet(_subAccount);\n\n        // Ensure owner console as a module has not been disabled\n        if (!IGnosisSafe(_subAccount).isModuleEnabled(ownerConsole)) revert InvalidModule();\n    }\n\n    /**\n     * @notice Internal helper to validate policy signature for a safe txn\n     * @dev Calls policy validator to check if policy signature is valid\n     * @param _from address of safe\n     * @param _to target address\n     * @param _value txn value\n     * @param _data txn callData\n     * @param _operation type of operation\n     * @param _signatures user signatures appended with validation signature\n     */\n    function _validatePolicySignature(\n        address _from,\n        address _to,\n        uint256 _value,\n        bytes memory _data,\n        Enum.Operation _operation,\n        bytes memory _signatures\n    ) internal view {\n        if (\n            !PolicyValidator(AddressProviderService._getAuthorizedAddress(_POLICY_VALIDATOR_HASH)).isPolicySignatureValid(\n                _from, _to, _value, _data, _operation, _signatures\n            )\n        ) {\n            revert TxnUnAuthorized();\n        }\n    }\n\n    /**\n     * @notice Internal helper to validate policy signature for a module txn\n     * @dev Calls policy validator to check if policy signature is valid\n     * @param _from address of safe\n     * @param _transactionStructHash transaction struct hash\n     * @param _signatures user signatures appended with validation signature\n     */\n    function _validatePolicySignature(address _from, bytes32 _transactionStructHash, bytes memory _signatures)\n        internal\n        view\n    {\n        if (\n            !PolicyValidator(AddressProviderService._getAuthorizedAddress(_POLICY_VALIDATOR_HASH)).isPolicySignatureValid(\n                _from, _transactionStructHash, _signatures\n            )\n        ) {\n            revert TxnUnAuthorized();\n        }\n    }\n}"
    }
  ]
}