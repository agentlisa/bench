{
  "Title": "[07] Protocol's reward vesting logic could unfairly make users liquidatable",
  "Content": "\nTake a look [here](https://github.com/code-423n4/2024-04-dyad/blob/4a987e536576139793a1c04690336d06c93fca90/src/staking/KerosineDenominator.sol#L17-L23).\n\n```solidity\n  function denominator() external view returns (uint) {\n    // @dev: We subtract all the Kerosene in the multi-sig.\n    //       We are aware that this is not a great solution. That is\n    //       why we can switch out Denominator contracts.\n    return kerosine.totalSupply() - kerosine.balanceOf(MAINNET_OWNER);\n  }\n}\n```\n\nWe can see that the final price that's gotten for kerosene is dependent on this; however, the multi sig's balance is not always going to be constant. That's to say in a case where there is a need to reward users for staking, the multi sig must send out tokens for this.\n\nUndergoing this action, however, can directly cause some positions that were narrowly afloat to become immediately liquidatable. This is cause the higher this denominator is, the lower the price returned from [here](https://github.com/code-423n4/2024-04-dyad/blob/4a987e536576139793a1c04690336d06c93fca90/src/core/Vault.kerosine.unbounded.sol#L65-L67).\n\n```solidity\n      uint numerator   = tvl - dyad.totalSupply();\n      uint denominator = kerosineDenominator.denominator();\n      return numerator * 1e8 / denominator;\n```\n\n### Impact\n\nBorderline medium low, submitted as low as there is a little bit of dependency on the admin having to transfer out tokens.\n\n### Recommended Mitigation Steps\n\nConsider making the denominator independent of the multi sig.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-04-dyad",
  "Code": [
    {
      "filename": "src/staking/KerosineDenominator.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.17;\n\nimport {Parameters} from \"../params/Parameters.sol\";\nimport {Kerosine} from \"../staking/Kerosine.sol\";\n\ncontract KerosineDenominator is Parameters {\n\n  Kerosine public kerosine;\n\n  constructor(\n    Kerosine _kerosine\n  ) {\n    kerosine = _kerosine;\n  }\n\n  function denominator() external view returns (uint) {\n    // @dev: We subtract all the Kerosene in the multi-sig.\n    //       We are aware that this is not a great solution. That is\n    //       why we can switch out Denominator contracts.\n    return kerosine.totalSupply() - kerosine.balanceOf(MAINNET_OWNER);\n  } \n}"
    },
    {
      "filename": "src/core/Vault.kerosine.unbounded.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.17;\n\nimport {KerosineVault}        from \"./Vault.kerosine.sol\";\nimport {IVaultManager}        from \"../interfaces/IVaultManager.sol\";\nimport {Vault}                from \"./Vault.sol\";\nimport {Dyad}                 from \"./Dyad.sol\";\nimport {KerosineManager}      from \"./KerosineManager.sol\";\nimport {BoundedKerosineVault} from \"./Vault.kerosine.bounded.sol\";\nimport {KerosineDenominator}  from \"../staking/KerosineDenominator.sol\";\n\nimport {ERC20}           from \"@solmate/src/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"@solmate/src/utils/SafeTransferLib.sol\";\n\ncontract UnboundedKerosineVault is KerosineVault {\n  using SafeTransferLib for ERC20;\n\n  Dyad                 public immutable dyad;\n  KerosineDenominator  public kerosineDenominator;\n\n  constructor(\n      IVaultManager   _vaultManager,\n      ERC20           _asset, \n      Dyad            _dyad, \n      KerosineManager _kerosineManager\n  ) KerosineVault(_vaultManager, _asset, _kerosineManager) {\n      dyad = _dyad;\n  }\n\n  function withdraw(\n    uint    id,\n    address to,\n    uint    amount\n  ) \n    external \n      onlyVaultManager\n  {\n    id2asset[id] -= amount;\n    asset.safeTransfer(to, amount); \n    emit Withdraw(id, to, amount);\n  }\n\n  function setDenominator(KerosineDenominator _kerosineDenominator) \n    external \n      onlyOwner\n  {\n    kerosineDenominator = _kerosineDenominator;\n  }\n\n  function assetPrice() \n    public \n    view \n    override\n    returns (uint) {\n      uint tvl;\n      address[] memory vaults = kerosineManager.getVaults();\n      uint numberOfVaults = vaults.length;\n      for (uint i = 0; i < numberOfVaults; i++) {\n        Vault vault = Vault(vaults[i]);\n        tvl += vault.asset().balanceOf(address(vault)) \n                * vault.assetPrice() * 1e18\n                / (10**vault.asset().decimals()) \n                / (10**vault.oracle().decimals());\n      }\n      uint numerator   = tvl - dyad.totalSupply();\n      uint denominator = kerosineDenominator.denominator();\n      return numerator * 1e8 / denominator;\n  }\n}"
    }
  ]
}