{
  "Title": "M-4: Loss of option token from Teller and reward from OTLM if L2 sequencer goes down",
  "Content": "# Issue M-4: Loss of option token from Teller and reward from OTLM if L2 sequencer goes down \n\nSource: https://github.com/sherlock-audit/2023-06-bond-judging/issues/82 \n\n## Found by \nctf\\_sec, qandisa\n## Summary\n\nLoss of option token from Teller and reward from OTLM if L2 sequencer goes down\n\n## Vulnerability Detail\n\nIn the current implementation, if the option token expires, the user is not able to [exerise the option at strike price](https://github.com/sherlock-audit/2023-06-bond/blob/fce1809f83728561dc75078d41ead6d60e15d065/options/src/fixed-strike/FixedStrikeOptionTeller.sol#L336)\n\n```solidity\n    // Validate that option token is not expired\n        if (uint48(block.timestamp) >= expiry) revert Teller_OptionExpired(expiry);\n```\n\nif the option token expires, the user lose rewards from OTLM as well when [claim the reward](https://github.com/sherlock-audit/2023-06-bond/blob/fce1809f83728561dc75078d41ead6d60e15d065/options/src/fixed-strike/liquidity-mining/OTLM.sol#L496)\n\n```solidity\n    function _claimRewards() internal returns (uint256) {\n        // Claims all outstanding rewards for the user across epochs\n        // If there are unclaimed rewards from epochs where the option token has expired, the rewards are lost\n\n        // Get the last epoch claimed by the user\n        uint48 userLastEpoch = lastEpochClaimed[msg.sender];\n\n```\n\nand\n\n```solidity\n    // If the option token has expired, then the rewards are zero\n        if (uint256(optionToken.expiry()) < block.timestamp) return 0;\n```\n\nAnd in the onchain context, the protocol intends to deploy the contract in arbitrum and optimsim\n\n```solidity\nQ: On what chains are the smart contracts going to be deployed?\nMainnet, Arbitrum, Optimism\n```\n\nHowever, If Arbitrum and optimism layer 2 network, the sequencer is in charge of process the transaction\n\nFor example, the recent optimism bedrock upgrade cause the sequencer not able to process transaction for a hew hours\n\nhttps://cryptopotato.com/optimism-bedrock-upgrade-release-date-revealed/\n\n> Bedrock Upgrade\nAccording to the official announcement, the upgrade will require 2-4 hours of downtime for OP Mainnet, during which there will be downtime at the chain and infrastructure level while the old sequencer is spun down and the Bedrock sequencer starts up.\n\n> Transactions, deposits, and withdrawals will also remain unavailable for the duration, and the chain will not be progressing. While the read access across most OP Mainnet nodes will stay online, users may encounter a slight decrease in performance during the migration process.\n\nIn Arbitrum\n\nhttps://thedefiant.io/arbitrum-outage-2\n\n> Arbitrum Goes Down Citing Sequencer Problems\nLayer 2 Arbitrum suffers 10 hour outage.\n\nand\n\nhttps://beincrypto.com/arbitrum-sequencer-bug-causes-temporary-transaction-pause/\n\n> Ethereum layer-2 (L2) scaling solution Arbitrum stopped processing transactions on June 7 because its sequencer faced a bug in the batch poster. The incident only lasted for an hour.\n\nIf the option expires during the sequencer down time, the user basically have worthless option token because they cannot exercise the option at strike price\n\nthe user would lose his reward as option token from OTLM.sol, which defeats the purpose of use OTLM to incentive user to provide liquidity \n\n## Impact\n\nLoss of option token from Teller and reward from OTLM if L2 sequencer goes down\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-bond/blob/fce1809f83728561dc75078d41ead6d60e15d065/options/src/fixed-strike/FixedStrikeOptionTeller.sol#L336\n\nhttps://github.com/sherlock-audit/2023-06-bond/blob/fce1809f83728561dc75078d41ead6d60e15d065/options/src/fixed-strike/liquidity-mining/OTLM.sol#L496\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nchainlink has a sequencer up feed\n\nhttps://docs.chain.link/data-feeds/l2-sequencer-feeds\n\nconsider integrate the up time feed and give user extra time to exercise token and claim option token reward if the sequencer goes down\n\n\n\n## Discussion\n\n**Oighty**\n\nAcknowledge this issue. Generally, we expect option token durations to be over a week+ duration so users will have a lot of time to exercise. Observed sequencer outages have been measured in hours. Therefore, we view the overall risk to the user as low. However, we will keep this in mind and explore how much complexity it would add to account for this on L2s.\n\n**ctf-sec**\n\nOk! Thanks!\n\n#24 is not a duplicate of this issue, the sequencer check for price should be done in Bond Oracle and it is out of scope in this audit.\n\n**ctf-sec**\n\nPast similar finding: https://github.com/sherlock-audit/2023-03-Y2K-judging/issues/422\n\n**ctf-sec**\n\nThe report has \"won't fix\" tag, assume the sponsor acknowledge the report.\n\n**Oighty**\n\nYep, acknowledge the issue, but we don't plan on implementing a fix for this.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/99",
  "Code": [
    {
      "filename": "options/src/fixed-strike/FixedStrikeOptionTeller.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {ClonesWithImmutableArgs} from \"src/lib/clones/ClonesWithImmutableArgs.sol\";\n\nimport {IFixedStrikeOptionTeller, IOptionTeller} from \"src/interfaces/IFixedStrikeOptionTeller.sol\";\nimport {FixedStrikeOptionToken} from \"src/fixed-strike/FixedStrikeOptionToken.sol\";\n\nimport {TransferHelper} from \"src/lib/TransferHelper.sol\";\nimport {FullMath} from \"src/lib/FullMath.sol\";\n\n/// @title Fixed Strike Option Teller\n/// @notice Fixed Strike Option Teller Contract\n/// @dev Option Teller contracts handle the deployment, creation, and exercise of option tokens.\n///      Option Tokens are ERC20 tokens that represent the right to buy (call) or sell (put) a fixed\n///      amount of an asset (payout token) for an amount of another asset (quote token) between two\n///      timestamps (eligible and expiry). Option Tokens are denominated in units of the payout token\n///      and are created at a 1:1 ratio for the amount of payout tokens to buy or sell.\n///      The amount of quote tokens required to exercise (call) or collateralize (put) an option token\n///      is called the strike price. Strike prices are denominated in units of the quote token.\n///      The Fixed Strike Option Teller implementation creates option tokens that have a fixed strike\n///      price that is set at the time of creation.\n///\n///      In order to create option tokens, an issuer must deploy the specific token configuration on\n///      the teller, and then provide collateral to the teller to mint option tokens. The collateral is\n///      required to guarantee that the option tokens can be exercised. The collateral required depends on\n///      the option type. For call options, the collateral required is an amount of payout tokens equivalent\n///      to the amount of option tokens being minted. For put options, the collateral required is an amount\n///      of quote tokens equivalent to the amount of option tokens being minted multipled by the strike price.\n///      As the name \"option\" suggests, the holder of an option token has the right, but not the obligation,\n///      to exercise the option token within the eligible time window. If the option token is not exercised,\n///      the designated \"receiver\" of the option token exercise proceeds can reclaim the collateral after\n///      the expiry timestamp. If an option token is exercised, the holder receives the collateral and the\n///      receiver receives the exercise proceeds.\n///\n/// @author Bond Protocol\ncontract FixedStrikeOptionTeller is IFixedStrikeOptionTeller, Auth, ReentrancyGuard {\n    using TransferHelper for ERC20;\n    using FullMath for uint256;\n    using ClonesWithImmutableArgs for address;\n\n    /* ========== ERRORS ========== */\n\n    error Teller_NotAuthorized();\n    error Teller_TokenDoesNotExist(bytes32 optionHash);\n    error Teller_UnsupportedToken(address token);\n    error Teller_InvalidParams(uint256 index, bytes value);\n    error Teller_OptionExpired(uint48 expiry);\n    error Teller_NotEligible(uint48 eligible);\n    error Teller_NotExpired(uint48 expiry);\n    error Teller_PriceOutOfBounds();\n\n    /* ========== EVENTS ========== */\n    event WroteOption(uint256 indexed id, address indexed referrer, uint256 amount, uint256 payout);\n    event OptionTokenCreated(\n        FixedStrikeOptionToken optionToken,\n        ERC20 indexed payoutToken,\n        ERC20 quoteToken,\n        uint48 eligible,\n        uint48 indexed expiry,\n        address indexed receiver,\n        bool call,\n        uint256 strikePrice\n    );\n\n    /* ========== STATE VARIABLES ========== */\n\n    /// @notice Fee paid to protocol when options are exercised in basis points (3 decimal places).\n    uint48 public protocolFee;\n\n    /// @notice Base value used to scale fees. 1e5 = 100%\n    uint48 public constant FEE_DECIMALS = 1e5; // one percent equals 1000.\n\n    /// @notice FixedStrikeOptionToken reference implementation (deployed on creation to clone from)\n    FixedStrikeOptionToken public immutable optionTokenImplementation;\n\n    /// @notice Minimum duration an option must be eligible to exercise (in seconds)\n    uint48 public minOptionDuration;\n\n    /// @notice Fees earned by protocol, by token\n    mapping(ERC20 => uint256) public fees;\n\n    /// @notice Fixed strike option tokens (hash of parameters to address)\n    mapping(bytes32 => FixedStrikeOptionToken) public optionTokens;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /// @param guardian_    Address of the guardian for Auth\n    /// @param authority_   Address of the authority for Auth\n    constructor(address guardian_, Authority authority_) Auth(guardian_, authority_) {\n        // Explicitly setting protocol fee to zero initially\n        protocolFee = 0;\n\n        // Set minimum option duration initially to 1 day (the absolute minimum given timestamp rounding)\n        minOptionDuration = uint48(1 days);\n\n        // Deploy option token implementation that clones proxy to\n        optionTokenImplementation = new FixedStrikeOptionToken();\n    }\n\n    /* ========== CREATE OPTION TOKENS ========== */\n\n    /// @inheritdoc IFixedStrikeOptionTeller\n    function deploy(\n        ERC20 payoutToken_,\n        ERC20 quoteToken_,\n        uint48 eligible_,\n        uint48 expiry_,\n        address receiver_,\n        bool call_,\n        uint256 strikePrice_\n    ) external override nonReentrant returns (FixedStrikeOptionToken) {\n        // If eligible is zero, use current timestamp\n        if (eligible_ == 0) eligible_ = uint48(block.timestamp);\n\n        // Eligible and Expiry are rounded to the nearest day at 0000 UTC (in seconds) since\n        // option tokens are only unique to a day, not a specific timestamp.\n        eligible_ = uint48(eligible_ / 1 days) * 1 days;\n        expiry_ = uint48(expiry_ / 1 days) * 1 days;\n\n        // Revert if eligible is in the past, we do this to avoid duplicates tokens with the same parameters otherwise\n        // Truncate block.timestamp to the nearest day for comparison\n        if (eligible_ < uint48(block.timestamp / 1 days) * 1 days)\n            revert Teller_InvalidParams(2, abi.encodePacked(eligible_));\n\n        // Revert if the difference between eligible and expiry is less than min duration or eligible is after expiry\n        // Don't need to check expiry against current timestamp since eligible is already checked\n        if (eligible_ > expiry_ || expiry_ - eligible_ < minOptionDuration)\n            revert Teller_InvalidParams(3, abi.encodePacked(expiry_));\n\n        // Revert if any addresses are zero or the tokens are not contracts\n        if (address(payoutToken_) == address(0) || address(payoutToken_).code.length == 0)\n            revert Teller_InvalidParams(0, abi.encodePacked(payoutToken_));\n        if (address(quoteToken_) == address(0) || address(quoteToken_).code.length == 0)\n            revert Teller_InvalidParams(1, abi.encodePacked(quoteToken_));\n        if (receiver_ == address(0)) revert Teller_InvalidParams(4, abi.encodePacked(receiver_));\n\n        // Revert if strike price is zero or out of bounds\n        int8 priceDecimals = _getPriceDecimals(strikePrice_, quoteToken_.decimals()); // @audit determine if this external call to provided quote token is an issue\n        if (strikePrice_ == 0 || priceDecimals > int8(9) || priceDecimals < int8(-9))\n            revert Teller_InvalidParams(6, abi.encodePacked(strikePrice_));\n\n        // Create option token if one doesn't already exist\n        // Timestamps are truncated above to give canonical version of hash\n        bytes32 optionHash = _getOptionTokenHash(\n            payoutToken_,\n            quoteToken_,\n            eligible_,\n            expiry_,\n            receiver_,\n            call_,\n            strikePrice_\n        );\n\n        FixedStrikeOptionToken optionToken = optionTokens[optionHash];\n\n        // If option token doesn't exist, deploy it\n        if (address(optionToken) == address(0)) {\n            optionToken = _deploy(\n                payoutToken_,\n                quoteToken_,\n                eligible_,\n                expiry_,\n                receiver_,\n                call_,\n                strikePrice_\n            );\n\n            // Set the domain separator for the option token on creation to save gas on permit approvals\n            optionToken.updateDomainSeparator();\n\n            // Store option token against computed hash\n            optionTokens[optionHash] = optionToken;\n\n            // Emit event\n            emit OptionTokenCreated(\n                optionToken,\n                payoutToken_,\n                quoteToken_,\n                eligible_,\n                expiry_,\n                receiver_,\n                call_,\n                strikePrice_\n            );\n        }\n        return optionToken;\n    }\n\n    function _deploy(\n        ERC20 payoutToken_,\n        ERC20 quoteToken_,\n        uint48 eligible_,\n        uint48 expiry_,\n        address receiver_,\n        bool call_,\n        uint256 strikePrice_\n    ) internal returns (FixedStrikeOptionToken) {\n        // All data has been validated prior to entering this function\n        // Option token does not exist yet\n\n        // Get name and symbol for option token\n        (bytes32 name, bytes32 symbol) = _getNameAndSymbol(\n            payoutToken_,\n            quoteToken_,\n            expiry_,\n            call_,\n            strikePrice_\n        );\n\n        // Deploy option token\n        return\n            FixedStrikeOptionToken(\n                address(optionTokenImplementation).clone(\n                    abi.encodePacked(\n                        name,\n                        symbol,\n                        uint8(payoutToken_.decimals()),\n                        payoutToken_,\n                        quoteToken_,\n                        eligible_,\n                        expiry_,\n                        receiver_,\n                        call_,\n                        address(this),\n                        strikePrice_\n                    )\n                )\n            );\n    }\n\n    /// @inheritdoc IFixedStrikeOptionTeller\n    function create(\n        FixedStrikeOptionToken optionToken_,\n        uint256 amount_\n    ) external override nonReentrant {\n        // Load option parameters\n        (\n            ERC20 payoutToken,\n            ERC20 quoteToken,\n            uint48 eligible,\n            uint48 expiry,\n            address receiver,\n            bool call,\n            uint256 strikePrice\n        ) = optionToken_.getOptionParameters();\n\n        // Retrieve the internally stored option token with this configuration\n        // Reverts internally if token doesn't exist\n        FixedStrikeOptionToken optionToken = getOptionToken(\n            payoutToken,\n            quoteToken,\n            eligible,\n            expiry,\n            receiver,\n            call,\n            strikePrice\n        );\n\n        // Revert if provided token address does not match stored token address\n        if (optionToken_ != optionToken) revert Teller_UnsupportedToken(address(optionToken_));\n\n        // Revert if expiry is in the past\n        if (uint256(expiry) < block.timestamp) revert Teller_OptionExpired(expiry);\n\n        // Transfer in collateral\n        // If call option, transfer in payout tokens equivalent to the amount of option tokens being issued\n        // If put option, transfer in quote tokens equivalent to the amount of option tokens being issued * strike price\n        if (call) {\n            // Transfer payout tokens from user\n            // Check that amount received is not less than amount expected\n            // Handles edge cases like fee-on-transfer tokens (which are not supported)\n            uint256 startBalance = payoutToken.balanceOf(address(this));\n            payoutToken.safeTransferFrom(msg.sender, address(this), amount_);\n            uint256 endBalance = payoutToken.balanceOf(address(this));\n            if (endBalance < startBalance + amount_)\n                revert Teller_UnsupportedToken(address(payoutToken));\n        } else {\n            // Calculate amount of quote tokens required to mint\n            uint256 quoteAmount = amount_.mulDiv(strikePrice, 10 ** payoutToken.decimals());\n\n            // Transfer quote tokens from user\n            // Check that amount received is not less than amount expected\n            // Handles edge cases like fee-on-transfer tokens (which are not supported)\n            uint256 startBalance = quoteToken.balanceOf(address(this));\n            quoteToken.safeTransferFrom(msg.sender, address(this), quoteAmount);\n            uint256 endBalance = quoteToken.balanceOf(address(this));\n            if (endBalance < startBalance + quoteAmount)\n                revert Teller_UnsupportedToken(address(quoteToken));\n        }\n\n        // Mint new option tokens to sender\n        optionToken.mint(msg.sender, amount_);\n    }\n\n    /* ========== EXERCISE OPTION TOKENS ========== */\n\n    /// @inheritdoc IFixedStrikeOptionTeller\n    function exercise(\n        FixedStrikeOptionToken optionToken_,\n        uint256 amount_\n    ) external override nonReentrant {\n        // Load option parameters\n        (\n            ERC20 payoutToken,\n            ERC20 quoteToken,\n            uint48 eligible,\n            uint48 expiry,\n            address receiver,\n            bool call,\n            uint256 strikePrice\n        ) = optionToken_.getOptionParameters();\n\n        // Retrieve the internally stored option token with this configuration\n        // Reverts internally if token doesn't exist\n        FixedStrikeOptionToken optionToken = getOptionToken(\n            payoutToken,\n            quoteToken,\n            eligible,\n            expiry,\n            receiver,\n            call,\n            strikePrice\n        );\n\n        // Revert if token does not match stored token\n        if (optionToken_ != optionToken) revert Teller_UnsupportedToken(address(optionToken_));\n\n        // Validate that option token is eligible to be exercised\n        if (uint48(block.timestamp) < eligible) revert Teller_NotEligible(eligible);\n\n        // Validate that option token is not expired\n        if (uint48(block.timestamp) >= expiry) revert Teller_OptionExpired(expiry);\n\n        // Calculate amount of quote tokens equivalent to amount at strike price\n        uint256 quoteAmount = amount_.mulDiv(strikePrice, 10 ** payoutToken.decimals());\n\n        // If not receiver, require payment\n        if (msg.sender != receiver) {\n            // If call, transfer in quote tokens equivalent to the amount of option tokens being exercised * strike price\n            // If put, transfer in payout tokens equivalent to the amount of option tokens being exercised\n            if (call) {\n                // Calculate protocol fee\n                uint256 fee = (quoteAmount * protocolFee) / FEE_DECIMALS;\n                fees[quoteToken] += fee;\n\n                // Transfer proceeds from user\n                // Check balances before and after transfer to ensure that the correct amount was transferred\n                // @audit this does enable potential malicious option tokens that can't be exercised\n                // However, we view it as a \"buyer beware\" situation that can handled on the front-end\n                uint256 startBalance = quoteToken.balanceOf(address(this));\n                quoteToken.safeTransferFrom(msg.sender, address(this), quoteAmount);\n                uint256 endBalance = quoteToken.balanceOf(address(this));\n                if (endBalance < startBalance + quoteAmount)\n                    revert Teller_UnsupportedToken(address(quoteToken));\n\n                // Transfer proceeds minus fee to receiver\n                quoteToken.safeTransfer(receiver, quoteAmount - fee);\n            } else {\n                // Calculate protocol fee (in payout tokens)\n                uint256 fee = (amount_ * protocolFee) / FEE_DECIMALS;\n                fees[payoutToken] += fee;\n\n                // Transfer proceeds from user\n                // Check balances before and after transfer to ensure that the correct amount was transferred\n                // @audit this does enable potential malicious option tokens that can't be exercised\n                // However, we view it as a \"buyer beware\" situation that can handled on the front-end\n                uint256 startBalance = payoutToken.balanceOf(address(this));\n                payoutToken.safeTransferFrom(msg.sender, address(this), amount_);\n                uint256 endBalance = payoutToken.balanceOf(address(this));\n                if (endBalance < startBalance + amount_)\n                    revert Teller_UnsupportedToken(address(payoutToken));\n\n                // Transfer proceeds minus fee to receiver\n                payoutToken.safeTransfer(receiver, amount_ - fee);\n            }\n        }\n\n        // Burn option tokens\n        optionToken.burn(msg.sender, amount_);\n\n        if (call) {\n            // Transfer payout tokens to user\n            payoutToken.safeTransfer(msg.sender, amount_);\n        } else {\n            // Transfer quote tokens to user\n            quoteToken.safeTransfer(msg.sender, quoteAmount);\n        }\n    }\n\n    /// @inheritdoc IFixedStrikeOptionTeller\n    function reclaim(FixedStrikeOptionToken optionToken_) external override nonReentrant {\n        // Load option parameters\n        (\n            ERC20 payoutToken,\n            ERC20 quoteToken,\n            uint48 eligible,\n            uint48 expiry,\n            address receiver,\n            bool call,\n            uint256 strikePrice\n        ) = optionToken_.getOptionParameters();\n\n        // Retrieve the internally stored option token with this configuration\n        // Reverts internally if token doesn't exist\n        FixedStrikeOptionToken optionToken = getOptionToken(\n            payoutToken,\n            quoteToken,\n            eligible,\n            expiry,\n            receiver,\n            call,\n            strikePrice\n        );\n\n        // Revert if token does not match stored token\n        if (optionToken_ != optionToken) revert Teller_UnsupportedToken(address(optionToken_));\n\n        // Revert if not expired\n        if (uint48(block.timestamp) < expiry) revert Teller_NotExpired(expiry);\n\n        // Revert if caller is not receiver\n        if (msg.sender != receiver) revert Teller_NotAuthorized();\n\n        // Transfer remaining collateral to receiver\n        uint256 amount = optionToken.totalSupply();\n        if (call) {\n            payoutToken.safeTransfer(receiver, amount);\n        } else {\n            // Calculate amount of quote tokens equivalent to amount at strike price\n            uint256 quoteAmount = amount.mulDiv(strikePrice, 10 ** payoutToken.decimals());\n            quoteToken.safeTransfer(receiver, quoteAmount);\n        }\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /// @inheritdoc IFixedStrikeOptionTeller\n    function exerciseCost(\n        FixedStrikeOptionToken optionToken_,\n        uint256 amount_\n    ) external view returns (ERC20, uint256) {\n        // Load option parameters\n        (\n            ERC20 payoutToken,\n            ERC20 quoteToken,\n            uint48 eligible,\n            uint48 expiry,\n            address receiver,\n            bool call,\n            uint256 strikePrice\n        ) = optionToken_.getOptionParameters();\n\n        // Retrieve the internally stored option token with this configuration\n        // Reverts internally if token doesn't exist\n        FixedStrikeOptionToken optionToken = getOptionToken(\n            payoutToken,\n            quoteToken,\n            eligible,\n            expiry,\n            receiver,\n            call,\n            strikePrice\n        );\n\n        // Revert if token does not match stored token\n        if (optionToken_ != optionToken) revert Teller_UnsupportedToken(address(optionToken_));\n\n        // If option is a call, calculate quote tokens required to exercise\n        // If option is a put, exercise cost is the same as the option token amount in payout tokens\n        if (call) {\n            return (quoteToken, amount_.mulDiv(strikePrice, 10 ** payoutToken.decimals()));\n        } else {\n            return (payoutToken, amount_);\n        }\n    }\n\n    /// @inheritdoc IFixedStrikeOptionTeller\n    function getOptionToken(\n        ERC20 payoutToken_,\n        ERC20 quoteToken_,\n        uint48 eligible_,\n        uint48 expiry_,\n        address receiver_,\n        bool call_,\n        uint256 strikePrice_\n    ) public view returns (FixedStrikeOptionToken) {\n        // Eligible and Expiry are rounded to the nearest day at 0000 UTC (in seconds) since\n        // option tokens are only unique to a day, not a specific timestamp.\n        uint48 eligible = uint48(eligible_ / 1 days) * 1 days;\n        uint48 expiry = uint48(expiry_ / 1 days) * 1 days;\n\n        // Calculate a hash from the normalized inputs\n        bytes32 optionHash = _getOptionTokenHash(\n            payoutToken_,\n            quoteToken_,\n            eligible,\n            expiry,\n            receiver_,\n            call_,\n            strikePrice_\n        );\n\n        FixedStrikeOptionToken optionToken = optionTokens[optionHash];\n\n        // Revert if token does not exist\n        if (address(optionToken) == address(0)) revert Teller_TokenDoesNotExist(optionHash);\n\n        return optionToken;\n    }\n\n    /// @inheritdoc IFixedStrikeOptionTeller\n    function getOptionTokenHash(\n        ERC20 payoutToken_,\n        ERC20 quoteToken_,\n        uint48 eligible_,\n        uint48 expiry_,\n        address receiver_,\n        bool call_,\n        uint256 strikePrice_\n    ) external pure returns (bytes32) {\n        // Eligible and Expiry are rounded to the nearest day at 0000 UTC (in seconds) since\n        // option tokens are only unique to a day, not a specific timestamp.\n        uint48 eligible = uint48(eligible_ / 1 days) * 1 days;\n        uint48 expiry = uint48(expiry_ / 1 days) * 1 days;\n\n        return\n            _getOptionTokenHash(\n                payoutToken_,\n                quoteToken_,\n                eligible,\n                expiry,\n                receiver_,\n                call_,\n                strikePrice_\n            );\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function _getOptionTokenHash(\n        ERC20 payoutToken_,\n        ERC20 quoteToken_,\n        uint48 eligible_,\n        uint48 expiry_,\n        address receiver_,\n        bool call_,\n        uint256 strikePrice_\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    payoutToken_,\n                    quoteToken_,\n                    eligible_,\n                    expiry_,\n                    receiver_,\n                    call_,\n                    strikePrice_\n                )\n            );\n    }\n\n    /// @notice Derive name and symbol of option token\n    function _getNameAndSymbol(\n        ERC20 payoutToken_,\n        ERC20 quoteToken_,\n        uint256 expiry_,\n        bool call_,\n        uint256 strikePrice_\n    ) internal view returns (bytes32, bytes32) {\n        // Examples\n        // WETH call option expiring on 2100-01-01 with strike price of 10_010.50 DAI would be formatted as:\n        // Name: \"WETH/DAI C 1.001e4 2100-01-01\"\n        // Symbol: \"WETH/DAI-C-21000101\"\n        //\n        // WETH put option expiring on 2100-01-01 with strike price of 10.546 DAI would be formatted as:\n        // Name: \"WETH/DAI P 1.054e1 2100-01-01\"\n        // Symbol: \"WETH/DAI-P-21000101\"\n\n        // Get the date format from the expiry timestamp.\n        // Convert a number of days into a human-readable date, courtesy of BokkyPooBah.\n        // Source: https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary/blob/master/contracts/BokkyPooBahsDateTimeLibrary.sol\n        string memory yearStr;\n        string memory monthStr;\n        string memory dayStr;\n        {\n            int256 __days = int256(expiry_ / 1 days);\n\n            int256 num1 = __days + 68569 + 2440588; // 2440588 = OFFSET19700101\n            int256 num2 = (4 * num1) / 146097;\n            num1 = num1 - (146097 * num2 + 3) / 4;\n            int256 _year = (4000 * (num1 + 1)) / 1461001;\n            num1 = num1 - (1461 * _year) / 4 + 31;\n            int256 _month = (80 * num1) / 2447;\n            int256 _day = num1 - (2447 * _month) / 80;\n            num1 = _month / 11;\n            _month = _month + 2 - 12 * num1;\n            _year = 100 * (num2 - 49) + _year + num1;\n\n            yearStr = _uint2str(uint256(_year) % 10000);\n            monthStr = uint256(_month) < 10\n                ? string(abi.encodePacked(\"0\", _uint2str(uint256(_month))))\n                : _uint2str(uint256(_month));\n            dayStr = uint256(_day) < 10\n                ? string(abi.encodePacked(\"0\", _uint2str(uint256(_day))))\n                : _uint2str(uint256(_day));\n        }\n\n        // Format token symbols\n        // Symbols longer than 5 characters are truncated, min length would be 1 if tokens have no symbols, max length is 11\n        bytes memory tokenSymbols;\n        {\n            bytes memory payoutSymbol = bytes(payoutToken_.symbol());\n            if (payoutSymbol.length > 5) payoutSymbol = abi.encodePacked(bytes5(payoutSymbol));\n            bytes memory quoteSymbol = bytes(quoteToken_.symbol());\n            if (quoteSymbol.length > 5) quoteSymbol = abi.encodePacked(bytes5(quoteSymbol));\n\n            tokenSymbols = abi.encodePacked(payoutSymbol, \"/\", quoteSymbol);\n        }\n\n        // Format option type\n        bytes1 callPut = call_ ? bytes1(\"C\") : bytes1(\"P\");\n\n        // Format strike price\n        // Strike price is formatted as scientific notation to 3 significant figures\n        // Will either be 7 or 8 bytes, e.g. 1.056e1 (7) or 9.745e-2 (8)\n        bytes memory strike = _getScientificNotation(strikePrice_, quoteToken_.decimals());\n\n        // Construct name/symbol strings.\n\n        // Name is formatted as \"payoutSymbol/quoteSymbol callPut strikePrice expiry\" with the following constraints: // Name and symbol can each be at most 32 bytes since it is stored as a bytes32\n        // quoteSymbol - 5 bytes\n        // \" \" - 1 byte\n        // callPut - 1 byte\n        // \" \" - 1 byte\n        // strikePrice - 7 or 8 bytes, scientific notation to 3 significant figures, e.g. 1.056e1 (7) or 9.745e-2 (8)\n        // \" \" - 1 byte\n        // expiry - 8 bytes, YYYYMMDD\n        // Total is 30 or 31 bytes\n\n        // Symbol is formatted as \"payoutSymbol/quoteSymbol-callPut-expiry\" with the following constraints:\n        // payoutSymbol - 5 bytes\n        // \"/\" - 1 byte\n        // quoteSymbol - 5 bytes\n        // \"-\" - 1 byte\n        // callPut - 1 byte\n        // \"-\" - 1 byte\n        // expiry - 8 bytes, YYYYMMDD\n        // Total is 22 bytes\n\n        bytes32 name = bytes32(\n            abi.encodePacked(\n                tokenSymbols,\n                \" \",\n                callPut,\n                \" \",\n                strike,\n                \" \",\n                yearStr,\n                monthStr,\n                dayStr\n            )\n        );\n        bytes32 symbol = bytes32(\n            abi.encodePacked(tokenSymbols, \"-\", callPut, \"-\", yearStr, monthStr, dayStr)\n        );\n\n        return (name, symbol);\n    }\n\n    /// @notice Helper function to calculate number of price decimals in the provided price\n    /// @param price_   The price to calculate the number of decimals for\n    /// @return         The number of decimals\n    function _getPriceDecimals(uint256 price_, uint8 tokenDecimals_) internal pure returns (int8) {\n        int8 decimals;\n        while (price_ >= 10) {\n            price_ = price_ / 10;\n            decimals++;\n        }\n\n        // Subtract the stated decimals from the calculated decimals to get the relative price decimals.\n        // Required to do it this way vs. normalizing at the beginning since price decimals can be negative.\n        return decimals - int8(tokenDecimals_);\n    }\n\n    /// @notice Helper function to format a uint256 into scientific notation to 3 significant figures\n    /// @param price_           The price to format\n    /// @param tokenDecimals_   The number of decimals in the token\n    function _getScientificNotation(\n        uint256 price_,\n        uint8 tokenDecimals_\n    ) internal pure returns (bytes memory) {\n        // Get a bytes representation of the price in scientific notation to 3 significant figures.\n        // 1. Get the number of price decimals\n        int8 priceDecimals = _getPriceDecimals(price_, tokenDecimals_);\n\n        // If priceDecimals are >= 10 or <= -10, then it will be too large to fit in the byte limit\n        // However, this is already checked when an option token is deployed\n\n        // 2. Get a string of the price decimals and exponent figure\n        uint256 decimals = priceDecimals < 0\n            ? uint256(uint8(-priceDecimals))\n            : uint256(uint8(priceDecimals));\n        bytes memory decStr = bytes.concat(\"e\", bytes(_uint2str(decimals)));\n\n        // 3. Get a string of the leading digits with decimal point\n        uint8 priceMagnitude = uint8(int8(tokenDecimals_) + priceDecimals);\n        uint256 digits = price_ / (10 ** (priceMagnitude < 3 ? 0 : priceMagnitude - 3));\n        bytes memory digitStr = bytes(_uint2str(digits));\n        uint256 len = bytes(digitStr).length;\n        bytes memory leadingStr = bytes.concat(digitStr[0], \".\");\n        for (uint256 i = 1; i < len; ++i) {\n            leadingStr = bytes.concat(leadingStr, digitStr[i]);\n        }\n\n        // 4. Combine and return\n        // The bytes string should be at most 8 bytes (e.g. 1.056e-1)\n        return bytes.concat(leadingStr, decStr);\n    }\n\n    // Some fancy math to convert a uint into a string, courtesy of Provable Things.\n    // Updated to work with solc 0.8.0.\n    // https://github.com/provable-things/ethereum-api/blob/master/provableAPI_0.6.sol\n    function _uint2str(uint256 _i) internal pure returns (string memory) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint256 j = _i;\n        uint256 len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint256 k = len;\n        while (_i != 0) {\n            k = k - 1;\n            uint8 temp = (48 + uint8(_i - (_i / 10) * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n\n    /* ========== ADMIN & FEES ========== */\n\n    /// @inheritdoc IOptionTeller\n    function setMinOptionDuration(uint48 duration_) external override requiresAuth {\n        // Must be a minimum of 1 day due to timestamp rounding\n        if (duration_ < uint48(1 days)) revert Teller_InvalidParams(0, abi.encodePacked(duration_));\n        minOptionDuration = duration_;\n    }\n\n    /// @inheritdoc IOptionTeller\n    function setProtocolFee(uint48 fee_) external override requiresAuth {\n        if (fee_ > 5e3) revert Teller_InvalidParams(0, abi.encodePacked(fee_)); // 5% max\n        protocolFee = fee_;\n    }\n\n    /// @inheritdoc IOptionTeller\n    function claimFees(\n        ERC20[] memory tokens_,\n        address to_\n    ) external override nonReentrant requiresAuth {\n        uint256 len = tokens_.length;\n        for (uint256 i; i < len; ++i) {\n            ERC20 token = tokens_[i];\n            uint256 send = fees[token];\n\n            if (send != 0) {\n                fees[token] = 0;\n                token.safeTransfer(to_, send);\n            }\n        }\n    }\n}"
    },
    {
      "filename": "options/src/fixed-strike/liquidity-mining/OTLM.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {IBondOracle} from \"src/interfaces/IBondOracle.sol\";\nimport {IAllowlist} from \"src/interfaces/IAllowlist.sol\";\n\nimport {FixedStrikeOptionToken} from \"src/fixed-strike/FixedStrikeOptionToken.sol\";\nimport {IFixedStrikeOptionTeller} from \"src/interfaces/IFixedStrikeOptionTeller.sol\";\nimport {TransferHelper} from \"src/lib/TransferHelper.sol\";\n\n/// @dev The purpose of Option Token Liquidity Mining is to allow the protocol to\n///      re-capture some of the value from liquidity mining rewards when LPs realize profit.\n///      Additionally, it can cap the amount of sell pressure on a protocols token in a down\n///      market by limiting the profitability of exercising option tokens to above the strike price.\n///\n///      The OTLM contract implements a version of this using fixed strike"
    }
  ]
}