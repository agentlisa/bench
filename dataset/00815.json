{
  "Title": "Missing docstrings",
  "Content": "Throughout the [codebase](https://github.com/across-protocol/contracts-v2/tree/c01d48cdb2e72812b6b9780fe215d44faced50ba), there are several parts that do not have docstrings. In particular:\n\n\n* `AdapterInterface.sol`, [lines 13-20](https://github.com/across-protocol/contracts-v2/blob/c01d48cdb2e72812b6b9780fe215d44faced50ba/contracts/interfaces/AdapterInterface.sol#L13-L20): The interface functions are undocumented.\n* `Arbitrum_Adapter.sol`, [lines 9-54](https://github.com/across-protocol/contracts-v2/blob/c01d48cdb2e72812b6b9780fe215d44faced50ba/contracts/chain-adapters/Arbitrum_Adapter.sol#L9-L54): The `ArbitrumL1InboxLike` and `ArbitrumL1ERC20GatewayLike` interfaces and their functions are undocumented.\n* `LpTokenFactoryInterface.sol`, [lines 4-5](https://github.com/across-protocol/contracts-v2/blob/c01d48cdb2e72812b6b9780fe215d44faced50ba/contracts/interfaces/LpTokenFactoryInterface.sol#L4-L5): The interface and its functions are undocumented.\n* `Optimism_Adapter.sol`, [lines 15-16](https://github.com/across-protocol/contracts-v2/blob/c01d48cdb2e72812b6b9780fe215d44faced50ba/contracts/chain-adapters/Optimism_Adapter.sol#L15-L16): The `SynthetixBridgeToOptimism` interface and its function are undocumented.\n* `Polygon_Adapter.sol`, [lines 10-30](https://github.com/across-protocol/contracts-v2/blob/c01d48cdb2e72812b6b9780fe215d44faced50ba/contracts/chain-adapters/Polygon_Adapter.sol#L10): The `IRootChainManager`, `IFxStateSender`, and `DepositManager` interfaces and their functions are undocumented.\n* `Polygon_SpokePool.sol`, [line 11](https://github.com/across-protocol/contracts-v2/blob/c01d48cdb2e72812b6b9780fe215d44faced50ba/contracts/Polygon_SpokePool.sol#L11): The `processMessageFromRoot` function is undocumented.\n* `SpokePool.sol`, [lines 169-196](https://github.com/across-protocol/contracts-v2/blob/c01d48cdb2e72812b6b9780fe215d44faced50ba/contracts/SpokePool.sol#L169-L196): The `RelayExecution`, `RelayExecutionInfo`, and `DepositUpdate` structs have undocumented members.\n* `Succinct_SpokePool.sol`, [line 39](https://github.com/across-protocol/contracts-v2/blob/c01d48cdb2e72812b6b9780fe215d44faced50ba/contracts/Succinct_SpokePool.sol#L39): The `initialize` function has no docstring.\n* `Succinct_SpokePool.sol`, [line 57](https://github.com/across-protocol/contracts-v2/blob/c01d48cdb2e72812b6b9780fe215d44faced50ba/contracts/Succinct_SpokePool.sol#L57): The `handleTelepathy` function has no docstring.\n* `WETH9Interface.sol`, [lines 4-11](https://github.com/across-protocol/contracts-v2/blob/c01d48cdb2e72812b6b9780fe215d44faced50ba/contracts/interfaces/WETH9Interface.sol#L4-L11): The interface and its functions are undocumented.\n* `ZkSync_Adapter.sol`, [lines 13-30](https://github.com/across-protocol/contracts-v2/blob/c01d48cdb2e72812b6b9780fe215d44faced50ba/contracts/chain-adapters/ZkSync_Adapter.sol#L13): The `ZkSyncLike` and `ZkBridgeLike` interfaces and their functions are undocumented.\n* `ZkSync_SpokePool.sol`, [lines 6-12](https://github.com/across-protocol/contracts-v2/blob/c01d48cdb2e72812b6b9780fe215d44faced50ba/contracts/ZkSync_SpokePool.sol#L6-L12): The `ZkBridgeLike` interface and its function are undocumented.\n\n\nConsider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/develop/natspec-format.html) (NatSpec).\n\n\n***Update:** Resolved in [pull request #253](https://github.com/across-protocol/contracts-v2/pull/253) at commit [5d1090a](https://github.com/across-protocol/contracts-v2/commit/5d1090af104968c39c0623050316875022cf043b), [pull request #242](https://github.com/across-protocol/contracts-v2/pull/242) at commit [4a8fe1c](https://github.com/across-protocol/contracts-v2/commit/4a8fe1c1fed7004885f6a0fa43da6cab693e9e6d), and [pull request #269](https://github.com/across-protocol/contracts-v2/pull/269) at commit [146f2f2](https://github.com/across-protocol/contracts-v2/commit/146f2f20b81cf519d3623a5565d99fc2f3338099).*\n\n\n*The `ZkSync_Adapter.sol` and `ZkSync_SpokePool.sol` contracts were not changed. The UMA team stated:*\n\n\n\n> *All suggested comments are implemented except for zkSync contracts which were out of this audit's scope and are still in progress and not live.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/interfaces/AdapterInterface.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n/**\n * @notice Sends cross chain messages and tokens to contracts on a specific L2 network.\n */\n\ninterface AdapterInterface {\n    event MessageRelayed(address target, bytes message);\n\n    event TokensRelayed(address l1Token, address l2Token, uint256 amount, address to);\n\n    function relayMessage(address target, bytes calldata message) external payable;\n\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable;\n}"
    },
    {
      "filename": "contracts/chain-adapters/Arbitrum_Adapter.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"../interfaces/AdapterInterface.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ninterface ArbitrumL1InboxLike {\n    function createRetryableTicket(\n        address destAddr,\n        uint256 arbTxCallValue,\n        uint256 maxSubmissionCost,\n        address submissionRefundAddress,\n        address valueRefundAddress,\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    function unsafeCreateRetryableTicket(\n        address destAddr,\n        uint256 arbTxCallValue,\n        uint256 maxSubmissionCost,\n        address submissionRefundAddress,\n        address valueRefundAddress,\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        bytes calldata data\n    ) external payable returns (uint256);\n}\n\ninterface ArbitrumL1ERC20GatewayLike {\n    function outboundTransfer(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) external payable returns (bytes memory);\n\n    function outboundTransferCustomRefund(\n        address _token,\n        address _refundTo,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) external payable returns (bytes memory);\n\n    function getGateway(address _token) external view returns (address);\n}\n\n/**\n * @notice Contract containing logic to send messages from L1 to Arbitrum.\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Arbitrum_Adapter is AdapterInterface {\n    using SafeERC20 for IERC20;\n\n    // Amount of ETH allocated to pay for the base submission fee. The base submission fee is a parameter unique to\n    // retryable transactions; the user is charged the base submission fee to cover the storage costs of keeping their\n    // ticketâ€™s calldata in the retry buffer. (current base submission fee is queryable via\n    // ArbRetryableTx.getSubmissionPrice). ArbRetryableTicket precompile interface exists at L2 address\n    // 0x000000000000000000000000000000000000006E.\n    uint256 public constant l2MaxSubmissionCost = 0.01e18;\n\n    // L2 Gas price bid for immediate L2 execution attempt (queryable via standard eth*gasPrice RPC)\n    uint256 public constant l2GasPrice = 5e9; // 5 gWei\n\n    uint32 public constant RELAY_TOKENS_L2_GAS_LIMIT = 300_000;\n    uint32 public constant RELAY_MESSAGE_L2_GAS_LIMIT = 2_000_000;\n\n    // This address on L2 receives extra ETH that is left over after relaying a message via the inbox.\n    address public constant l2RefundL2Address = 0x428AB2BA90Eba0a4Be7aF34C9Ac451ab061AC010;\n\n    ArbitrumL1InboxLike public immutable l1Inbox;\n\n    ArbitrumL1ERC20GatewayLike public immutable l1ERC20GatewayRouter;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1ArbitrumInbox Inbox helper contract to send messages to Arbitrum.\n     * @param _l1ERC20GatewayRouter ERC20 gateway router contract to send tokens to Arbitrum.\n     */\n    constructor(ArbitrumL1InboxLike _l1ArbitrumInbox, ArbitrumL1ERC20GatewayLike _l1ERC20GatewayRouter) {\n        l1Inbox = _l1ArbitrumInbox;\n        l1ERC20GatewayRouter = _l1ERC20GatewayRouter;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Arbitrum.\n     * @notice This contract must hold at least getL1CallValue() amount of ETH to send a message via the Inbox\n     * successfully, or the message will get stuck.\n     * @param target Contract on Arbitrum that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes memory message) external payable override {\n        uint256 requiredL1CallValue = _contractHasSufficientEthBalance(RELAY_MESSAGE_L2_GAS_LIMIT);\n\n        l1Inbox.createRetryableTicket{ value: requiredL1CallValue }(\n            target, // destAddr destination L2 contract address\n            0, // l2CallValue call value for retryable L2 message\n            l2MaxSubmissionCost, // maxSubmissionCost Max gas deducted from user's L2 balance to cover base fee\n            l2RefundL2Address, // excessFeeRefundAddress maxgas * gasprice - execution cost gets credited here on L2\n            l2RefundL2Address, // callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\n            RELAY_MESSAGE_L2_GAS_LIMIT, // maxGas Max gas deducted from user's L2 balance to cover L2 execution\n            l2GasPrice, // gasPriceBid price bid for L2 execution\n            message // data ABI encoded data of L2 message\n        );\n\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Arbitrum.\n     * @notice This contract must hold at least getL1CallValue() amount of ETH to send a message via the Inbox\n     * successfully, or the message will get stuck.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token, // l2Token is unused for Arbitrum.\n        uint256 amount,\n        address to\n    ) external payable override {\n        uint256 requiredL1CallValue = _contractHasSufficientEthBalance(RELAY_TOKENS_L2_GAS_LIMIT);\n\n        // Approve the gateway, not the router, to spend the hub pool's balance. The gateway, which is different\n        // per L1 token, will temporarily escrow the tokens to be bridged and pull them from this contract.\n        address erc20Gateway = l1ERC20GatewayRouter.getGateway(l1Token);\n        IERC20(l1Token).safeIncreaseAllowance(erc20Gateway, amount);\n\n        // `outboundTransfer` expects that the caller includes a bytes message as the last param that includes the\n        // maxSubmissionCost to use when creating an L2 retryable ticket: https://github.com/OffchainLabs/arbitrum/blob/e98d14873dd77513b569771f47b5e05b72402c5e/packages/arb-bridge-peripherals/contracts/tokenbridge/ethereum/gateway/L1GatewayRouter.sol#L232\n        bytes memory data = abi.encode(l2MaxSubmissionCost, \"\");\n\n        // Note: Legacy routers don't have the outboundTransferCustomRefund method, so default to using\n        // outboundTransfer(). Legacy routers are used for the following tokens that are currently enabled:\n        // - DAI: the implementation of `outboundTransfer` at the current DAI custom gateway\n        //        (https://etherscan.io/address/0xD3B5b60020504bc3489D6949d545893982BA3011#writeContract) sets the\n        //        sender as the refund address so the aliased HubPool should receive excess funds. Implementation here:\n        //        https://github.com/makerdao/arbitrum-dai-bridge/blob/11a80385e2622968069c34d401b3d54a59060e87/contracts/l1/L1DaiGateway.sol#L109\n        if (l1Token == 0x6B175474E89094C44Da98b954EedeAC495271d0F) {\n            // This means that the excess ETH to pay for the L2 transaction will be sent to the aliased\n            // contract address on L2, which we'd have to retrieve via a custom adapter, the Arbitrum_RescueAdapter.\n            // To do so, in a single transaction: 1) setCrossChainContracts to Arbitrum_RescueAdapter, 2) relayMessage\n            // with function data = abi.encode(amountToRescue), 3) setCrossChainContracts back to this adapter.\n            l1ERC20GatewayRouter.outboundTransfer{ value: requiredL1CallValue }(\n                l1Token,\n                to,\n                amount,\n                RELAY_TOKENS_L2_GAS_LIMIT,\n                l2GasPrice,\n                data\n            );\n        } else {\n            l1ERC20GatewayRouter.outboundTransferCustomRefund{ value: requiredL1CallValue }(\n                l1Token,\n                l2RefundL2Address,\n                to,\n                amount,\n                RELAY_TOKENS_L2_GAS_LIMIT,\n                l2GasPrice,\n                data\n            );\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n\n    /**\n     * @notice Returns required amount of ETH to send a message via the Inbox.\n     * @return amount of ETH that this contract needs to hold in order for relayMessage to succeed.\n     */\n    function getL1CallValue(uint32 l2GasLimit) public pure returns (uint256) {\n        return l2MaxSubmissionCost + l2GasPrice * l2GasLimit;\n    }\n\n    function _contractHasSufficientEthBalance(uint32 l2GasLimit) internal view returns (uint256 requiredL1CallValue) {\n        requiredL1CallValue = getL1CallValue(l2GasLimit);\n        require(address(this).balance >= requiredL1CallValue, \"Insufficient ETH balance\");\n    }\n}"
    },
    {
      "filename": "contracts/interfaces/LpTokenFactoryInterface.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\ninterface LpTokenFactoryInterface {\n    function createLpToken(address l1Token) external returns (address);\n}"
    },
    {
      "filename": "contracts/chain-adapters/Optimism_Adapter.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"../interfaces/AdapterInterface.sol\";\nimport \"../interfaces/WETH9Interface.sol\";\n\n// @dev Use local modified CrossDomainEnabled contract instead of one exported by eth-optimism because we need\n// this contract's state variables to be `immutable` because of the delegateCall call.\nimport \"./CrossDomainEnabled.sol\";\nimport \"@eth-optimism/contracts/L1/messaging/IL1StandardBridge.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ninterface SynthetixBridgeToOptimism is IL1StandardBridge {\n    function depositTo(address to, uint256 amount) external;\n}\n\n/**\n * @notice Contract containing logic to send messages from L1 to Optimism.\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Optimism_Adapter is CrossDomainEnabled, AdapterInterface {\n    using SafeERC20 for IERC20;\n    uint32 public immutable l2GasLimit = 2_000_000;\n\n    WETH9Interface public immutable l1Weth;\n\n    IL1StandardBridge public immutable l1StandardBridge;\n\n    // Optimism has the ability to support \"custom\" bridges. These bridges are not supported by the canonical bridge\n    // and so we need to store the address of the custom token and the associated bridge. In the event we want to\n    // support a new token that is not supported by Optimism, we can add a new custom bridge for it and re-deploy the\n    // adapter. A full list of custom optimism tokens and their associated bridges can be found here:\n    // https://github.com/ethereum-optimism/ethereum-optimism.github.io/blob/master/optimism.tokenlist.json\n    address public immutable dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address public immutable daiOptimismBridge = 0x10E6593CDda8c58a1d0f14C5164B376352a55f2F;\n    address public immutable snx = 0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F;\n    address public immutable snxOptimismBridge = 0x39Ea01a0298C315d149a490E34B59Dbf2EC7e48F;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1Weth WETH address on L1.\n     * @param _crossDomainMessenger XDomainMessenger Optimism system contract.\n     * @param _l1StandardBridge Standard bridge contract.\n     */\n    constructor(\n        WETH9Interface _l1Weth,\n        address _crossDomainMessenger,\n        IL1StandardBridge _l1StandardBridge\n    ) CrossDomainEnabled(_crossDomainMessenger) {\n        l1Weth = _l1Weth;\n        l1StandardBridge = _l1StandardBridge;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Optimism.\n     * @param target Contract on Optimism that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes calldata message) external payable override {\n        sendCrossDomainMessage(target, uint32(l2GasLimit), message);\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Optimism.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        // If the l1Token is weth then unwrap it to ETH then send the ETH to the standard bridge.\n        if (l1Token == address(l1Weth)) {\n            l1Weth.withdraw(amount);\n            l1StandardBridge.depositETHTo{ value: amount }(to, l2GasLimit, \"\");\n        } else {\n            address bridgeToUse = address(l1StandardBridge);\n\n            // Check if the L1 token requires a custom bridge. If so, use that bridge over the standard bridge.\n            if (l1Token == dai) bridgeToUse = daiOptimismBridge; // 1. DAI\n            if (l1Token == snx) bridgeToUse = snxOptimismBridge; // 2. SNX\n\n            IERC20(l1Token).safeIncreaseAllowance(bridgeToUse, amount);\n            if (l1Token == snx) SynthetixBridgeToOptimism(bridgeToUse).depositTo(to, amount);\n            else IL1StandardBridge(bridgeToUse).depositERC20To(l1Token, l2Token, to, amount, l2GasLimit, \"\");\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n}"
    },
    {
      "filename": "contracts/chain-adapters/Polygon_Adapter.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"../interfaces/AdapterInterface.sol\";\nimport \"../interfaces/WETH9Interface.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ninterface IRootChainManager {\n    function depositEtherFor(address user) external payable;\n\n    function depositFor(\n        address user,\n        address rootToken,\n        bytes calldata depositData\n    ) external;\n}\n\ninterface IFxStateSender {\n    function sendMessageToChild(address _receiver, bytes calldata _data) external;\n}\n\ninterface DepositManager {\n    function depositERC20ForUser(\n        address token,\n        address user,\n        uint256 amount\n    ) external;\n}\n\n/**\n * @notice Sends cross chain messages Polygon L2 network.\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract Polygon_Adapter is AdapterInterface {\n    using SafeERC20 for IERC20;\n    IRootChainManager public immutable rootChainManager;\n    IFxStateSender public immutable fxStateSender;\n    DepositManager public immutable depositManager;\n    address public immutable erc20Predicate;\n    address public immutable l1Matic;\n    WETH9Interface public immutable l1Weth;\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _rootChainManager RootChainManager Polygon system contract to deposit tokens over the PoS bridge.\n     * @param _fxStateSender FxStateSender Polygon system contract to send arbitrary messages to L2.\n     * @param _depositManager DepositManager Polygon system contract to deposit tokens over the Plasma bridge (Matic).\n     * @param _erc20Predicate ERC20Predicate Polygon system contract to approve when depositing to the PoS bridge.\n     * @param _l1Matic matic address on l1.\n     * @param _l1Weth WETH address on L1.\n     */\n    constructor(\n        IRootChainManager _rootChainManager,\n        IFxStateSender _fxStateSender,\n        DepositManager _depositManager,\n        address _erc20Predicate,\n        address _l1Matic,\n        WETH9Interface _l1Weth\n    ) {\n        rootChainManager = _rootChainManager;\n        fxStateSender = _fxStateSender;\n        depositManager = _depositManager;\n        erc20Predicate = _erc20Predicate;\n        l1Matic = _l1Matic;\n        l1Weth = _l1Weth;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on Polygon.\n     * @param target Contract on Polygon that will receive message.\n     * @param message Data to send to target.\n     */\n\n    function relayMessage(address target, bytes calldata message) external payable override {\n        fxStateSender.sendMessageToChild(target, message);\n        emit MessageRelayed(target, message);\n    }\n\n    /**\n     * @notice Bridge tokens to Polygon.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token,\n        uint256 amount,\n        address to\n    ) external payable override {\n        // If the l1Token is weth then unwrap it to ETH then send the ETH to the standard bridge.\n        if (l1Token == address(l1Weth)) {\n            l1Weth.withdraw(amount);\n            rootChainManager.depositEtherFor{ value: amount }(to);\n        } else if (l1Token == l1Matic) {\n            IERC20(l1Token).safeIncreaseAllowance(address(depositManager), amount);\n            depositManager.depositERC20ForUser(l1Token, to, amount);\n        } else {\n            IERC20(l1Token).safeIncreaseAllowance(erc20Predicate, amount);\n            rootChainManager.depositFor(to, l1Token, abi.encode(amount));\n        }\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n    }\n}"
    },
    {
      "filename": "contracts/Polygon_SpokePool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"./SpokePool.sol\";\nimport \"./PolygonTokenBridger.sol\";\nimport \"./interfaces/WETH9Interface.sol\";\nimport \"./SpokePoolInterface.sol\";\n\n// IFxMessageProcessor represents interface to process messages.\ninterface IFxMessageProcessor {\n    function processMessageFromRoot(\n        uint256 stateId,\n        address rootMessageSender,\n        bytes calldata data\n    ) external;\n}\n\n/**\n * @notice Polygon specific SpokePool.\n */\ncontract Polygon_SpokePool is IFxMessageProcessor, SpokePool {\n    using SafeERC20Upgradeable for PolygonIERC20Upgradeable;\n\n    // Address of FxChild which sends and receives messages to and from L1.\n    address public fxChild;\n\n    // Contract deployed on L1 and L2 processes all cross-chain transfers between this contract and the the HubPool.\n    // Required because bridging tokens from Polygon to Ethereum has special constraints.\n    PolygonTokenBridger public polygonTokenBridger;\n\n    // Internal variable that only flips temporarily to true upon receiving messages from L1. Used to authenticate that\n    // the caller is the fxChild AND that the fxChild called processMessageFromRoot\n    bool private callValidated;\n\n    event PolygonTokensBridged(address indexed token, address indexed receiver, uint256 amount);\n    event SetFxChild(address indexed newFxChild);\n    event SetPolygonTokenBridger(address indexed polygonTokenBridger);\n\n    // Note: validating calls this way ensures that strange calls coming from the fxChild won't be misinterpreted.\n    // Put differently, just checking that msg.sender == fxChild is not sufficient.\n    // All calls that have admin privileges must be fired from within the processMessageFromRoot method that's gone\n    // through validation where the sender is checked and the root (mainnet) sender is also validated.\n    // This modifier sets the callValidated variable so this condition can be checked in _requireAdminSender().\n    modifier validateInternalCalls() {\n        // Make sure callValidated is set to True only once at beginning of processMessageFromRoot, which prevents\n        // processMessageFromRoot from being re-entered.\n        require(!callValidated, \"callValidated already set\");\n\n        // This sets a variable indicating that we're now inside a validated call.\n        // Note: this is used by other methods to ensure that this call has been validated by this method and is not\n        // spoofed. See\n        callValidated = true;\n\n        _;\n\n        // Reset callValidated to false to disallow admin calls after this method exits.\n        callValidated = false;\n    }\n\n    /**\n     * @notice Construct the Polygon SpokePool.\n     * @param _initialDepositId Starting deposit ID. Set to 0 unless this is a re-deployment in order to mitigate\n     * relay hash collisions.\n     * @param _polygonTokenBridger Token routing contract that sends tokens from here to HubPool. Changeable by Admin.\n     * @param _crossDomainAdmin Cross domain admin to set. Can be changed by admin.\n     * @param _hubPool Hub pool address to set. Can be changed by admin.\n     * @param _wmaticAddress Replaces wrappedNativeToken for this network since MATIC is the native currency on polygon.\n     * @param _fxChild FxChild contract, changeable by Admin.\n     */\n    function initialize(\n        uint32 _initialDepositId,\n        PolygonTokenBridger _polygonTokenBridger,\n        address _crossDomainAdmin,\n        address _hubPool,\n        address _wmaticAddress, // Note: wmatic is used here since it is the token sent via msg.value on polygon.\n        address _fxChild\n    ) public initializer {\n        callValidated = false;\n        __SpokePool_init(_initialDepositId, _crossDomainAdmin, _hubPool, _wmaticAddress);\n        polygonTokenBridger = _polygonTokenBridger;\n        //slither-disable-next-line missing-zero-check\n        fxChild = _fxChild;\n    }\n\n    /********************************************************\n     *    POLYGON-SPECIFIC CROSS-CHAIN ADMIN FUNCTIONS     *\n     ********************************************************/\n\n    /**\n     * @notice Change FxChild address. Callable only by admin via processMessageFromRoot.\n     * @param newFxChild New FxChild.\n     */\n    function setFxChild(address newFxChild) public onlyAdmin nonReentrant {\n        //slither-disable-next-line missing-zero-check\n        fxChild = newFxChild;\n        emit SetFxChild(newFxChild);\n    }\n\n    /**\n     * @notice Change polygonTokenBridger address. Callable only by admin via processMessageFromRoot.\n     * @param newPolygonTokenBridger New Polygon Token Bridger contract.\n     */\n    function setPolygonTokenBridger(address payable newPolygonTokenBridger) public onlyAdmin nonReentrant {\n        polygonTokenBridger = PolygonTokenBridger(newPolygonTokenBridger);\n        emit SetPolygonTokenBridger(address(newPolygonTokenBridger));\n    }\n\n    /**\n     * @notice Called by FxChild upon receiving L1 message that targets this contract. Performs an additional check\n     * that the L1 caller was the expected cross domain admin, and then delegate calls.\n     * @notice Polygon bridge only executes this external function on the target Polygon contract when relaying\n     * messages from L1, so all functions on this SpokePool are expected to originate via this call.\n     * @dev stateId value isn't used because it isn't relevant for this method. It doesn't care what state sync\n     * triggered this call.\n     * @param rootMessageSender Original L1 sender of data.\n     * @param data ABI encoded function call to execute on this contract.\n     */\n    function processMessageFromRoot(\n        uint256, /*stateId*/\n        address rootMessageSender,\n        bytes calldata data\n    ) public validateInternalCalls {\n        // Validation logic.\n        require(msg.sender == fxChild, \"Not from fxChild\");\n        require(rootMessageSender == crossDomainAdmin, \"Not from mainnet admin\");\n\n        // This uses delegatecall to take the information in the message and process it as a function call on this contract.\n        /// This is a safe delegatecall because its made to address(this) so there is no risk of delegating to a\n        /// selfdestruct().\n        //slither-disable-start low-level-calls\n        /// @custom:oz-upgrades-unsafe-allow delegatecall\n        (bool success, ) = address(this).delegatecall(data);\n        //slither-disable-end low-level-calls\n        require(success, \"delegatecall failed\");\n    }\n\n    /**\n     * @notice Allows the caller to trigger the wrapping of any unwrapped matic tokens.\n     * @dev Matic sends via L1 -> L2 bridging actions don't call into the contract receiving the tokens, so wrapping\n     * must be done via a separate transaction.\n     */\n    function wrap() public nonReentrant {\n        _wrap();\n    }\n\n    /**\n     * @notice Executes a relayer refund leaf stored as part of a root bundle. Will send the relayer the amount they\n     * sent to the recipient plus a relayer fee.\n     * @dev this is only overridden to wrap any matic the contract holds before running.\n     * @param rootBundleId Unique ID of root bundle containing relayer refund root that this leaf is contained in.\n     * @param relayerRefundLeaf Contains all data necessary to reconstruct leaf contained in root bundle and to\n     * refund relayer. This data structure is explained in detail in the SpokePoolInterface.\n     * @param proof Inclusion proof for this leaf in relayer refund root in root bundle.\n     */\n    function executeRelayerRefundLeaf(\n        uint32 rootBundleId,\n        SpokePoolInterface.RelayerRefundLeaf memory relayerRefundLeaf,\n        bytes32[] memory proof\n    ) public override nonReentrant {\n        _wrap();\n        _executeRelayerRefundLeaf(rootBundleId, relayerRefundLeaf, proof);\n    }\n\n    /**\n     * @notice Executes a slow relay leaf stored as part of a root bundle. Will send the full amount remaining in the\n     * relay to the recipient, less fees.\n     * @dev This function assumes that the relay's destination chain ID is the current chain ID, which prevents\n     * the caller from executing a slow relay intended for another chain on this chain. This is only overridden to call\n     * wrap before running the function.\n     * @param depositor Depositor on origin chain who set this chain as the destination chain.\n     * @param recipient Specified recipient on this chain.\n     * @param destinationToken Token to send to recipient. Should be mapped to the origin token, origin chain ID\n     * and this chain ID via a mapping on the HubPool.\n     * @param amount Full size of the deposit.\n     * @param originChainId Chain of SpokePool where deposit originated.\n     * @param realizedLpFeePct Fee % based on L1 HubPool utilization at deposit quote time. Deterministic based on\n     * quote time.\n     * @param relayerFeePct Original fee % to keep as relayer set by depositor.\n     * @param depositId Unique deposit ID on origin spoke pool.\n     * @param rootBundleId Unique ID of root bundle containing slow relay root that this leaf is contained in.\n     * @param proof Inclusion proof for this leaf in slow relay root in root bundle.\n     */\n    function executeSlowRelayLeaf(\n        address depositor,\n        address recipient,\n        address destinationToken,\n        uint256 amount,\n        uint256 originChainId,\n        int64 realizedLpFeePct,\n        int64 relayerFeePct,\n        uint32 depositId,\n        uint32 rootBundleId,\n        bytes memory message,\n        int256 payoutAdjustment,\n        bytes32[] memory proof\n    ) public virtual override nonReentrant {\n        _wrap();\n        _executeSlowRelayLeaf(\n            depositor,\n            recipient,\n            destinationToken,\n            amount,\n            originChainId,\n            chainId(),\n            realizedLpFeePct,\n            relayerFeePct,\n            depositId,\n            rootBundleId,\n            message,\n            payoutAdjustment,\n            proof\n        );\n    }\n\n    /**************************************\n     *        INTERNAL FUNCTIONS          *\n     **************************************/\n\n    function _bridgeTokensToHubPool(RelayerRefundLeaf memory relayerRefundLeaf) internal override {\n        PolygonIERC20Upgradeable(relayerRefundLeaf.l2TokenAddress).safeIncreaseAllowance(\n            address(polygonTokenBridger),\n            relayerRefundLeaf.amountToReturn\n        );\n\n        // Note: WrappedNativeToken is WMATIC on matic, so this tells the tokenbridger that this is an unwrappable native token.\n        polygonTokenBridger.send(\n            PolygonIERC20Upgradeable(relayerRefundLeaf.l2TokenAddress),\n            relayerRefundLeaf.amountToReturn\n        );\n\n        emit PolygonTokensBridged(relayerRefundLeaf.l2TokenAddress, address(this), relayerRefundLeaf.amountToReturn);\n    }\n\n    function _wrap() internal {\n        uint256 balance = address(this).balance;\n        //slither-disable-next-line arbitrary-send-eth\n        if (balance > 0) wrappedNativeToken.deposit{ value: balance }();\n    }\n\n    // @dev: This contract will trigger admin functions internally via the `processMessageFromRoot`, which is why\n    // the `callValidated` check is made below  and why we use the `validateInternalCalls` modifier on\n    // `processMessageFromRoot`. This prevents calling the admin functions from any other method besides\n    // `processMessageFromRoot`.\n    function _requireAdminSender() internal view override {\n        require(callValidated, \"Must call processMessageFromRoot\");\n    }\n}"
    },
    {
      "filename": "contracts/SpokePool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"./MerkleLib.sol\";\nimport \"./interfaces/WETH9Interface.sol\";\nimport \"./SpokePoolInterface.sol\";\nimport \"./upgradeable/MultiCallerUpgradeable.sol\";\nimport \"./upgradeable/EIP712CrossChainUpgradeable.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\n\n// This interface is expected to be implemented by any contract that expects to recieve messages from the SpokePool.\ninterface AcrossMessageHandler {\n    function handleAcrossMessage(\n        address tokenSent,\n        uint256 amount,\n        bytes memory message\n    ) external;\n}\n\n/**\n * @title SpokePool\n * @notice Base contract deployed on source and destination chains enabling depositors to transfer assets from source to\n * destination. Deposit orders are fulfilled by off-chain relayers who also interact with this contract. Deposited\n * tokens are locked on the source chain and relayers send the recipient the desired token currency and amount\n * on the destination chain. Locked source chain tokens are later sent over the canonical token bridge to L1 HubPool.\n * Relayers are refunded with destination tokens out of this contract after another off-chain actor, a \"data worker\",\n * submits a proof that the relayer correctly submitted a relay on this SpokePool.\n */\nabstract contract SpokePool is\n    SpokePoolInterface,\n    UUPSUpgradeable,\n    ReentrancyGuardUpgradeable,\n    MultiCallerUpgradeable,\n    EIP712CrossChainUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeabl"
    }
  ]
}