{
  "Title": "[Lâ€‘01]  Use of `msg.value` in functions available to batches",
  "Content": "\nThe contract extends `BoringBatchable`, which warns to ensure `msg.value` isn't able to be used in a batchable call. `MIMOVaultActions.depositETH()` and `MIMOVaultActions.depositETHAndBorrow()` both use `msg.value` but aren't currently exploitable due to the fact that it has to be executed by the owner or an envoy, needs to be allow-listed, and even then the functions would require latent funds.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: /contracts/proxy/MIMOProxy.sol\n\n54:    function execute(address target, bytes calldata data) public payable override returns (bytes memory response) {\n\n```\n\n<https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/proxy/MIMOProxy.sol#L54>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-08-mimo",
  "Code": [
    {
      "filename": "contracts/proxy/MIMOProxy.sol",
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport \"../libraries/BoringBatchable.sol\";\nimport \"./interfaces/IMIMOProxy.sol\";\nimport { CustomErrors } from \"../libraries/CustomErrors.sol\";\n\n/// @title MIMOProxy\n/// @notice Used as a proxy to access VaultsCore from a user or a rebalancer\ncontract MIMOProxy is IMIMOProxy, Initializable, BoringBatchable {\n  /// PUBLIC STORAGE ///\n\n  /// @inheritdoc IMIMOProxy\n  address public override owner;\n\n  /// @inheritdoc IMIMOProxy\n  uint256 public override minGasReserve;\n\n  /// INTERNAL STORAGE ///\n\n  /// @notice Maps envoys to target contracts to function selectors to boolean flags.\n  mapping(address => mapping(address => mapping(bytes4 => bool))) internal _permissions;\n\n  /// CONSTRUCTOR ///\n\n  /// @inheritdoc IMIMOProxy\n  function initialize() external initializer {\n    minGasReserve = 5_000;\n    owner = msg.sender;\n    emit TransferOwnership(address(0), msg.sender);\n  }\n\n  /// FALLBACK FUNCTION ///\n\n  /// @dev Called when Ether is sent and the call data is empty.\n  receive() external payable {}\n\n  /// PUBLIC CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxy\n  function getPermission(\n    address envoy,\n    address target,\n    bytes4 selector\n  ) external view override returns (bool) {\n    return _permissions[envoy][target][selector];\n  }\n\n  /// PUBLIC NON-CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxy\n  function execute(address target, bytes calldata data) public payable override returns (bytes memory response) {\n    // Check that the caller is either the owner or an envoy.\n    if (owner != msg.sender) {\n      bytes4 selector;\n      assembly {\n        selector := calldataload(data.offset)\n      }\n      if (!_permissions[msg.sender][target][selector]) {\n        revert CustomErrors.EXECUTION_NOT_AUTHORIZED(owner, msg.sender, target, selector);\n      }\n    }\n\n    // Check that the target is a valid contract.\n    if (target.code.length == 0) {\n      revert CustomErrors.TARGET_INVALID(target);\n    }\n\n    // Save the owner address in memory. This local variable cannot be modified during the DELEGATECALL.\n    address owner_ = owner;\n\n    // Reserve some gas to ensure that the function has enough to finish the execution.\n    uint256 stipend = gasleft() - minGasReserve;\n\n    // Delegate call to the target contract.\n    bool success;\n    (success, response) = target.delegatecall{ gas: stipend }(data);\n\n    // Check that the owner has not been changed.\n    if (owner_ != owner) {\n      revert CustomErrors.OWNER_CHANGED(owner_, owner);\n    }\n\n    // Log the execution.\n    emit Execute(target, data, response);\n\n    // Check if the call was successful or not.\n    if (!success) {\n      // If there is return data, the call reverted with a reason or a custom error.\n      if (response.length > 0) {\n        assembly {\n          let returndata_size := mload(response)\n          revert(add(32, response), returndata_size)\n        }\n      } else {\n        revert CustomErrors.EXECUTION_REVERTED();\n      }\n    }\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function setPermission(\n    address envoy,\n    address target,\n    bytes4 selector,\n    bool permission\n  ) public override {\n    if (owner != msg.sender) {\n      revert CustomErrors.NOT_OWNER(owner, msg.sender);\n    }\n    _permissions[envoy][target][selector] = permission;\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function transferOwnership(address newOwner) external override {\n    address oldOwner = owner;\n    if (oldOwner != msg.sender) {\n      revert CustomErrors.NOT_OWNER(oldOwner, msg.sender);\n    }\n    owner = newOwner;\n    emit TransferOwnership(oldOwner, newOwner);\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function multicall(address[] calldata targets, bytes[] calldata data) external override returns (bytes[] memory) {\n    if (msg.sender != owner) {\n      revert CustomErrors.NOT_OWNER(owner, msg.sender);\n    }\n    bytes[] memory results = new bytes[](data.length);\n    for (uint256 i = 0; i < targets.length; i++) {\n      (bool success, bytes memory response) = targets[i].call(data[i]);\n      if (!success) {\n        if (response.length > 0) {\n          assembly {\n            let returndata_size := mload(response)\n            revert(add(32, response), returndata_size)\n          }\n        } else {\n          revert CustomErrors.LOW_LEVEL_CALL_FAILED();\n        }\n      }\n      results[i] = response;\n    }\n    return results;\n  }\n}"
    }
  ]
}