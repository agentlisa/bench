{
  "Title": "[H-07] Shelter `claimed` mapping is set with `_to` address and not `msg.sender`",
  "Content": "_Submitted by 0xliumin, also found by cmichel, leastwood, and pauliax_\n\nAny user can withdraw all the funds from the shelter. This is done by calling withdraw repeatedly until all funds are drained. You only need to have a small share.\n\nEven if the `claimed` mapping was checked, there would still be a vulnerability. This is because the `claimed` mapping is updated with the `_to` address, not the `msg.sender` address.\n\n### Recommended Mitigation Steps\n\nRemediation is to change the `_to` to `msg.sender`.<br>\n[Shelter.sol#L55](https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/Shelter.sol#L55)\n\n**[leekt (Concur) confirmed](https://github.com/code-423n4/2022-02-concur-findings/issues/103)**\n\n**[Alex the Entreprenerd (judge) increased severity to High and commented](https://github.com/code-423n4/2022-02-concur-findings/issues/103#issuecomment-1102697656):**\n > Am marking this as a unique finding as this one shows another issue with the Shelter withdraw function.\n> \n> Because this also allows for draining of all rewards, am raising to High Severity.\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-02-concur-finance-contest",
  "Code": [
    {
      "filename": "contracts/Shelter.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IShelter } from \"./interfaces/IShelter.sol\";\nimport { IShelterClient } from \"./interfaces/IShelterClient.sol\";\n\ncontract Shelter is IShelter {\n    using SafeERC20 for IERC20;\n\n    IShelterClient public immutable client;\n\n    uint256 public constant GRACE_PERIOD = 1 weeks;\n\n    mapping(IERC20 => mapping(address => bool)) public override claimed;\n\n    mapping(IERC20 => uint256) public activated;\n\n    mapping(IERC20 => uint256) public savedTokens;\n\n    modifier onlyClient {\n        require(msg.sender == address(client), \"!client\");\n        _;\n    }\n\n    constructor(IShelterClient _client){\n        client = _client;\n    }\n\n    function donate(IERC20 _token, uint256 _amount) external {\n        require(activated[_token] != 0, \"!activated\");\n        savedTokens[_token] += _amount;\n        _token.safeTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    function activate(IERC20 _token) external override onlyClient {\n        activated[_token] = block.timestamp;\n        savedTokens[_token] = _token.balanceOf(address(this));\n        emit ShelterActivated(_token);\n    }\n\n    function deactivate(IERC20 _token) external override onlyClient {\n        require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD > block.timestamp, \"too late\");\n        activated[_token] = 0;\n        savedTokens[_token] = 0;\n        _token.safeTransfer(msg.sender, _token.balanceOf(address(this)));\n        emit ShelterDeactivated(_token);\n    }\n\n    function withdraw(IERC20 _token, address _to) external override {\n        require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD < block.timestamp, \"shelter not activated\");\n        uint256 amount = savedTokens[_token] * client.shareOf(_token, msg.sender) / client.totalShare(_token);\n        claimed[_token][_to] = true;\n        emit ExitShelter(_token, msg.sender, _to, amount);\n        _token.safeTransfer(_to, amount);\n    }\n}"
    }
  ]
}