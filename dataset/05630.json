{
  "Title": "[M-02] `SubAccount` operator can steal funds via the gas refund mechanism",
  "Content": "\nThe `SubAccount` operator can steal funds from the SubAccount Gnosis Safe via the Gnosis Safe gas refund mechanism, since the trusted validator signatures do not include the following parameters that are included in the `Safe.sol` `execTransaction` function:\n- `uint256 safeTxGas`\n- `uint256 baseGas`\n- `uint256 gasPrice`\n- `address gasToken`\n- `address payable refundReceiver`\n\nThis allows the operator to call `execTransaction` with these parameters set to send all the Ether or a chosen ERC-20 token held in the SubAccount Gnosis Safe to the operator's address.\n\n### Proof of Concept\n\nOne of the operators, who is an owner on the SubAccount Gnosis Safe, calls `execTransaction` on the Gnosis Safe with valid `to`, `value`, `data`, `operation`, and `signatures` parameters which is allowed by the current policy configured on the SubAccount, and therefore the trusted validator will also sign.\n\nHowever, the operator will also populate `execTransaction` function parameters related to gas refunds (`safeTxGas, baseGas, gasPrice, gasToken` and `refundReceiver`), to values that transfer to themselves Ether or ERC-20 tokens held in the SubAccount Gnosis Safe.\n\nThe transaction is executed, and in the `handlePayment` [function call](<https://github.com/safe-global/safe-contracts/blob/main/contracts/Safe.sol#L229>) within the Gnosis Safe execution, the Ether or ERC-20 tokens will be transferred to the address the operator specified in the `refundReceiver` parameter.\n\n### Recommended Mitigation Steps\n\nInclude the `safeTxGas, baseGas, gasPrice, gasToken and refundReceiver` parameters of the transaction in the trusted validated signature that is [verified](<https://github.com/code-423n4/2023-10-brahma/blob/main/contracts/src/core/PolicyValidator.sol#L54>).\n\n### Assessed type\n\nInvalid Validation\n\n**[0xad1onchain (Brahma) confirmed via duplicate Issue #484](https://github.com/code-423n4/2023-10-brahma-findings/issues/484#issuecomment-1779575632)**\n\n**[0xsomeone (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-10-brahma-findings/issues/298#issuecomment-1786228029):**\n > The Warden has demonstrated a potential avenue via which the `SafeModerator` security checks in relation to the interaction performed can be \"bypassed\". Effectively, operators of the sub-account can extract any funds held by the sub-account by taking advantage of the gas refund mechanism. \n> \n> Given that the price-per-gas unit can be arbitrarily specified, a minuscule waste of gas can result in a significant amount of funds being extracted. This particular avenue also bypasses the `SafeModerator` security checks.\n> \n> As such, the Warden has showcased a way to actively affect funds within a sub-account that is not intended behaviour by the Sponsor. \n\n**[0xad1onchain (Brahma) commented](https://github.com/code-423n4/2023-10-brahma-findings/issues/298#issuecomment-1817756724):**\n> Fixed, added missing params to transaction validation struct.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-brahma",
  "Code": [
    {
      "filename": "contracts/Safe.sol",
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport {ITransactionGuard, GuardManager} from \"./base/GuardManager.sol\";\nimport {ModuleManager} from \"./base/ModuleManager.sol\";\nimport {OwnerManager} from \"./base/OwnerManager.sol\";\nimport {FallbackManager} from \"./base/FallbackManager.sol\";\nimport {NativeCurrencyPaymentFallback} from \"./common/NativeCurrencyPaymentFallback.sol\";\nimport {Singleton} from \"./common/Singleton.sol\";\nimport {SignatureDecoder} from \"./common/SignatureDecoder.sol\";\nimport {SecuredTokenTransfer} from \"./common/SecuredTokenTransfer.sol\";\nimport {StorageAccessible} from \"./common/StorageAccessible.sol\";\nimport {Enum} from \"./libraries/Enum.sol\";\nimport {ISignatureValidator, ISignatureValidatorConstants} from \"./interfaces/ISignatureValidator.sol\";\nimport {SafeMath} from \"./external/SafeMath.sol\";\nimport {ISafe} from \"./interfaces/ISafe.sol\";\n\n/**\n * @title Safe - A multisignature wallet with support for confirmations using signed messages based on EIP-712.\n * @dev Most important concepts:\n *      - Threshold: Number of required confirmations for a Safe transaction.\n *      - Owners: List of addresses that control the Safe. They are the only ones that can add/remove owners, change the threshold and\n *        approve transactions. Managed in `OwnerManager`.\n *      - Transaction Hash: Hash of a transaction is calculated using the EIP-712 typed structured data hashing scheme.\n *      - Nonce: Each transaction should have a different nonce to prevent replay attacks.\n *      - Signature: A valid signature of an owner of the Safe for a transaction hash.\n *      - Guards: Guards are contracts that can execute pre- and post- transaction checks. There are two types of guards:\n *          1. Transaction Guard: managed in `GuardManager` for transactions executed with `execTransaction`.\n *          2. Module Guard: managed in `ModuleManager` for transactions executed with `execTransactionFromModule`\n *      - Modules: Modules are contracts that can be used to extend the write functionality of a Safe. Managed in `ModuleManager`.\n *      - Fallback: Fallback handler is a contract that can provide additional read-only functional for Safe. Managed in `FallbackManager`.\n *      Note: This version of the implementation contract doesn't emit events for the sake of gas efficiency and therefore requires a tracing node for indexing/\n *      For the events-based implementation see `SafeL2.sol`.\n * @author Stefan George - @Georgi87\n * @author Richard Meissner - @rmeissner\n */\ncontract Safe is\n    Singleton,\n    NativeCurrencyPaymentFallback,\n    ModuleManager,\n    GuardManager,\n    OwnerManager,\n    SignatureDecoder,\n    SecuredTokenTransfer,\n    ISignatureValidatorConstants,\n    FallbackManager,\n    StorageAccessible,\n    ISafe\n{\n    using SafeMath for uint256;\n\n    string public constant override VERSION = \"1.4.1\";\n\n    // keccak256(\n    //     \"EIP712Domain(uint256 chainId,address verifyingContract)\"\n    // );\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n    // keccak256(\n    //     \"SafeTx(address to,uint256 value,bytes data,uint8 operation,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\n    // );\n    bytes32 private constant SAFE_TX_TYPEHASH = 0xbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d8;\n\n    uint256 public override nonce;\n    bytes32 private _deprecatedDomainSeparator;\n    // Mapping to keep track of all message hashes that have been approved by ALL REQUIRED owners\n    mapping(bytes32 => uint256) public override signedMessages;\n    // Mapping to keep track of all hashes (message or transaction) that have been approved by ANY owners\n    mapping(address => mapping(bytes32 => uint256)) public override approvedHashes;\n\n    // This constructor ensures that this contract can only be used as a singleton for Proxy contracts\n    constructor() {\n        /**\n         * By setting the threshold it is not possible to call setup anymore,\n         * so we create a Safe with 0 owners and threshold 1.\n         * This is an unusable Safe, perfect for the singleton\n         */\n        threshold = 1;\n    }\n\n    /**\n     * @inheritdoc ISafe\n     */\n    function setup(\n        address[] calldata _owners,\n        uint256 _threshold,\n        address to,\n        bytes calldata data,\n        address fallbackHandler,\n        address paymentToken,\n        uint256 payment,\n        address payable paymentReceiver\n    ) external override {\n        // setupOwners checks if the Threshold is already set, therefore preventing that this method is called twice\n        setupOwners(_owners, _threshold);\n        if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler);\n        // As setupOwners can only be called if the contract has not been initialized we don't need a check for setupModules\n        setupModules(to, data);\n\n        if (payment > 0) {\n            // To avoid running into issues with EIP-170 we reuse the handlePayment function (to avoid adjusting code of that has been verified we do not adjust the method itself)\n            // baseGas = 0, gasPrice = 1 and gas = payment => amount = (payment + 0) * 1 = payment\n            handlePayment(payment, 0, 1, paymentToken, paymentReceiver);\n        }\n        emit SafeSetup(msg.sender, _owners, _threshold, to, fallbackHandler);\n    }\n\n    /**\n     * @inheritdoc ISafe\n     */\n    function execTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures\n    ) public payable virtual override returns (bool success) {\n        bytes32 txHash;\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            txHash = getTransactionHash( // Transaction info\n                to,\n                value,\n                data,\n                operation,\n                safeTxGas,\n                // Payment info\n                baseGas,\n                gasPrice,\n                gasToken,\n                refundReceiver,\n                // Signature info\n                // We use the post-increment here, so the current nonce value is used and incremented afterwards.\n                nonce++\n            );\n            checkSignatures(txHash, signatures);\n        }\n        address guard = getGuard();\n        {\n            if (guard != address(0)) {\n                ITransactionGuard(guard).checkTransaction(\n                    // Transaction info\n                    to,\n                    value,\n                    data,\n                    operation,\n                    safeTxGas,\n                    // Payment info\n                    baseGas,\n                    gasPrice,\n                    gasToken,\n                    refundReceiver,\n                    // Signature info\n                    signatures,\n                    msg.sender\n                );\n            }\n        }\n\n        // We require some gas to emit the events (at least 2500) after the execution and some to perform code until the execution (500)\n        // We also include the 1/64 in the check that is not send along with a call to counteract potential shortings because of EIP-150\n        if (gasleft() < ((safeTxGas * 64) / 63).max(safeTxGas + 2500) + 500) revertWithError(\"GS010\");\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            uint256 gasUsed = gasleft();\n            // If the gasPrice is 0 we assume that nearly all available gas can be used (it is always more than safeTxGas)\n            // We only subtract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than safeTxGas\n            success = execute(to, value, data, operation, gasPrice == 0 ? (gasleft() - 2500) : safeTxGas);\n            gasUsed = gasUsed.sub(gasleft());\n            // If no safeTxGas and no gasPrice was set (e.g. both are 0), then the internal tx is required to be successful\n            // This makes it possible to use `estimateGas` without issues, as it searches for the minimum gas where the tx doesn't revert\n            if (!success && safeTxGas == 0 && gasPrice == 0) revertWithError(\"GS013\");\n            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\n            uint256 payment = 0;\n            if (gasPrice > 0) {\n                payment = handlePayment(gasUsed, baseGas, gasPrice, gasToken, refundReceiver);\n            }\n            if (success) emit ExecutionSuccess(txHash, payment);\n            else emit ExecutionFailure(txHash, payment);\n        }\n        {\n            if (guard != address(0)) {\n                ITransactionGuard(guard).checkAfterExecution(txHash, success);\n            }\n        }\n    }\n\n    /**\n     * @notice Handles the payment for a Safe transaction.\n     * @param gasUsed Gas used by the Safe transaction.\n     * @param baseGas Gas costs that are independent of the transaction execution (e.g. base transaction fee, signature check, payment of the refund).\n     * @param gasPrice Gas price that should be used for the payment calculation.\n     * @param gasToken Token address (or 0 if ETH) that is used for the payment.\n     * @return payment The amount of payment made in the specified token.\n     */\n    function handlePayment(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver\n    ) private returns (uint256 payment) {\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n        if (gasToken == address(0)) {\n            // For native tokens, we will only adjust the gas price to not be higher than the actually used gas price\n            payment = gasUsed.add(baseGas).mul(gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            (bool refundSuccess, ) = receiver.call{value: payment}(\"\");\n            if (!refundSuccess) revertWithError(\"GS011\");\n        } else {\n            payment = gasUsed.add(baseGas).mul(gasPrice);\n            if (!transferToken(gasToken, receiver, payment)) revertWithError(\"GS012\");\n        }\n    }\n\n    /**\n     * @notice Checks whether the contract signature is valid. Reverts otherwise.\n     * @dev This is extracted to a separate function for better compatibility with Certora's prover.\n     *      More info here: https://github.com/safe-global/safe-smart-account/pull/661\n     * @param owner Address of the owner used to sign the message\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param signatures Signature data that should be verified.\n     * @param offset Offset to the start of the contract signature in the signatures byte array\n     */\n    function checkContractSignature(address owner, bytes32 dataHash, bytes memory signatures, uint256 offset) internal view {\n        // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\n        if (offset.add(32) > signatures.length) revertWithError(\"GS022\");\n\n        // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\n        uint256 contractSignatureLen;\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            contractSignatureLen := mload(add(add(signatures, offset), 0x20))\n        }\n        /* solhint-enable no-inline-assembly */\n        if (offset.add(32).add(contractSignatureLen) > signatures.length) revertWithError(\"GS023\");\n\n        // Check signature\n        bytes memory contractSignature;\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\n            contractSignature := add(add(signatures, offset), 0x20)\n        }\n        /* solhint-enable no-inline-assembly */\n\n        if (ISignatureValidator(owner).isValidSignature(dataHash, contractSignature) != EIP1271_MAGIC_VALUE) revertWithError(\"GS024\");\n    }\n\n    /**\n     * @inheritdoc ISafe\n     */\n    function checkSignatures(bytes32 dataHash, bytes memory signatures) public view override {\n        // Load threshold to avoid multiple storage loads\n        uint256 _threshold = threshold;\n        // Check that a threshold is set\n        if (_threshold == 0) revertWithError(\"GS001\");\n        checkNSignatures(msg.sender, dataHash, signatures, _threshold);\n    }\n\n    /**\n     * @inheritdoc ISafe\n     */\n    function checkNSignatures(\n        address executor,\n        bytes32 dataHash,\n        bytes memory signatures,\n        uint256 requiredSignatures\n    ) public view override {\n        // Check that the provided signature data is not too short\n        if (signatures.length < requiredSignatures.mul(65)) revertWithError(\"GS020\");\n        // There cannot be an owner with address 0.\n        address lastOwner = address(0);\n        address currentOwner;\n        uint256 v; // Implicit conversion from uint8 to uint256 will be done for v received from signatureSplit(...).\n        bytes32 r;\n        bytes32 s;\n        uint256 i;\n        for (i = 0; i < requiredSignatures; i++) {\n            (v, r, s) = signatureSplit(signatures, i);\n            if (v == 0) {\n                // If v is 0 then it is a contract signature\n                // When handling contract signatures the address of the contract is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n\n                // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes\n                // This check is not completely accurate, since it is possible that more signatures than the threshold are send.\n                // Here we only check that the pointer is not pointing inside the part that is being processed\n                if (uint256(s) < requiredSignatures.mul(65)) revertWithError(\"GS021\");\n\n                // The contract signature check is extracted to a separate function for better compatibility with formal verification\n                // A quote from the Certora team:\n                // \"The assembly code broke the pointer analysis, which switched the prover in failsafe mode, where it is (a) much slower and (b) computes different hashes than in the normal mode.\"\n                // More info here: https://github.com/safe-global/safe-smart-account/pull/661\n                checkContractSignature(currentOwner, dataHash, signatures, uint256(s));\n            } else if (v == 1) {\n                // If v is 1 then it is an approved hash\n                // When handling approved hashes the address of the approver is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n                // Hashes are automatically approved by the sender of the message or when they have been pre-approved via a separate transaction\n                if (executor != currentOwner && approvedHashes[currentOwner][dataHash] == 0) revertWithError(\"GS025\");\n            } else if (v > 30) {\n                // If v > 30 then default va (27,28) has been adjusted for eth_sign flow\n                // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n                currentOwner = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), uint8(v - 4), r, s);\n            } else {\n                // Default is the ecrecover flow with the provided data hash\n                // Use ecrecover with the messageHash for EOA signatures\n                currentOwner = ecrecover(dataHash, uint8(v), r, s);\n            }\n            if (currentOwner <= lastOwner || owners[currentOwner] == address(0) || currentOwner == SENTINEL_OWNERS)\n                revertWithError(\"GS026\");\n            lastOwner = currentOwner;\n        }\n    }\n\n    /**\n     * @notice Checks whether the signature provided is valid for the provided hash. Reverts otherwise.\n     *         The `data` parameter is completely ignored during signature verification.\n     * @dev This function is provided for compatibility with previous versions.\n     *      Use `checkSignatures(bytes32,bytes)` instead.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash).\n     * @param data **IGNORED** The data pre-image.\n     * @param signatures Signature data that should be verified.\n     *                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\n     */\n    function checkSignatures(bytes32 dataHash, bytes calldata data, bytes memory signatures) external view {\n        data;\n        checkSignatures(dataHash, signatures);\n    }\n\n    /**\n     * @notice Checks whether the signature provided is valid for the provided hash. Reverts otherwise.\n     *         The `data` parameter is completely ignored during signature verification.\n     * @dev This function is provided for compatibility with previous versions.\n     *      Use `checkNSignatures(address,bytes32,bytes,uint256)` instead.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param data **IGNORED** The data pre-image.\n     * @param signatures Signature data that should be verified.\n     *                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\n     * @param requiredSignatures Amount of required valid signatures.\n     */\n    function checkNSignatures(bytes32 dataHash, bytes calldata data, bytes memory signatures, uint256 requiredSignatures) external view {\n        data;\n        checkNSignatures(msg.sender, dataHash, signatures, requiredSignatures);\n    }\n\n    /**\n     * @inheritdoc ISafe\n     */\n    function approveHash(bytes32 hashToApprove) external override {\n        if (owners[msg.sender] == address(0)) revertWithError(\"GS030\");\n        approvedHashes[msg.sender][hashToApprove] = 1;\n        emit ApproveHash(hashToApprove, msg.sender);\n    }\n\n    /**\n     * @inheritdoc ISafe\n     */\n    function domainSeparator() public view override returns (bytes32) {\n        uint256 chainId;\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            chainId := chainid()\n        }\n        /* solhint-enable no-inline-assembly */\n\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, chainId, this));\n    }\n\n    /**\n     * @notice Returns the pre-image of the transaction hash (see getTransactionHash).\n     * @param to Destination address.\n     * @param value Ether value.\n     * @param data Data payload.\n     * @param operation Operation type.\n     * @param safeTxGas Gas that should be used for the safe transaction.\n     * @param baseGas Gas costs for that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\n     * @param gasPrice Maximum gas price that should be used for this transaction.\n     * @param gasToken Token address (or 0 if ETH) that is used for the payment.\n     * @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n     * @param _nonce Transaction nonce.\n     * @return Transaction hash bytes.\n     */\n    function encodeTransactionData(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) private view returns (bytes memory) {\n        bytes32 safeTxHash = keccak256(\n            abi.encode(\n                SAFE_TX_TYPEHASH,\n                to,\n                value,\n                keccak256(data),\n                operation,\n                safeTxGas,\n                baseGas,\n                gasPrice,\n                gasToken,\n                refundReceiver,\n                _nonce\n            )\n        );\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeTxHash);\n    }\n\n    /**\n     * @inheritdoc ISafe\n     */\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) public view override returns (bytes32) {\n        return keccak256(encodeTransactionData(to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce));\n    }\n}"
    },
    {
      "filename": "contracts/src/core/PolicyValidator.sol",
      "content": "/// SPDX-License-Identifier: BUSL-1.1\n\n/// Copyright (C) 2023 Brahma.fi\n\npragma solidity 0.8.19;\n\nimport {SignatureCheckerLib} from \"solady/utils/SignatureCheckerLib.sol\";\nimport {EIP712} from \"solady/utils/EIP712.sol\";\nimport {AddressProviderService} from \"src/core/AddressProviderService.sol\";\nimport {PolicyRegistry} from \"src/core/registries/PolicyRegistry.sol\";\nimport {TypeHashHelper} from \"src/libraries/TypeHashHelper.sol\";\nimport {IGnosisSafe, Enum} from \"interfaces/external/IGnosisSafe.sol\";\n\n/**\n * @title PolicyValidator\n * @author Brahma.fi\n * @notice Responsible for validating policy signatures for safe transactions\n */\ncontract PolicyValidator is AddressProviderService, EIP712 {\n    error InvalidSignature();\n    error NoPolicyCommit();\n    error TxnExpired(uint32 expiryEpoch);\n    error InvalidSignatures();\n\n    /// @notice EIP712 domain name\n    string private constant _NAME = \"PolicyValidator\";\n    /// @notice EIP712 domain version\n    string private constant _VERSION = \"1.0\";\n\n    constructor(address _addressProvider) AddressProviderService(_addressProvider) {}\n\n    /**\n     * @notice generates digest and validates signature against policies for safe transaction\n     * @dev The TRUSTED_VALIDATOR is expected to sign EIP712 digest generated from the following struct:\n     * TypeHashHelper.Validation, where -\n     *  txnDigest = EIP712 digest generated from struct: TypeHashHelper.Transaction\n     *  policyHash = policy commit hash of the safe account\n     *  expiryEpoch = expiry timestamp\n     *\n     * @dev signatures = abi.encodePacked(safeSignature, validatorSignature, validatorSignatureLength, expiryEpoch)\n     *  safeSignature = safe owners signatures (arbitrary bytes length)\n     *  validatorSignature = EIP 712 digest signature (arbitrary bytes length)\n     *  validatorSignatureLength = length of `validatorSignature` (4 bytes)\n     *  expiryEpoch = expiry timestamp (4 bytes)\n     *\n     * @param account address of account to validate txn for\n     * @param to target address\n     * @param value txn value\n     * @param data txn callData\n     * @param operation type of operation\n     * @param signatures user signatures appended with validation signature\n     * @return isSignatureValid boolean\n     */\n    function isPolicySignatureValid(\n        address account,\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        bytes calldata signatures\n    ) external view returns (bool) {\n        // Get nonce from safe\n        uint256 nonce = IGnosisSafe(account).nonce();\n\n        // Build transaction struct hash\n        bytes32 transactionStructHash = TypeHashHelper._buildTransactionStructHash(\n            TypeHashHelper.Transaction({\n                to: to,\n                value: value,\n                data: data,\n                operation: uint8(operation),\n                account: account,\n                executor: address(0),\n                nonce: nonce\n            })\n        );\n\n        // Validate signature\n        return isPolicySignatureValid(account, transactionStructHash, signatures);\n    }\n\n    /**\n     * @notice generates digest and validates signature against policies for module execution\n     * @dev signatures = abi.encodePacked(validatorSignature, validatorSignatureLength, expiryEpoch)\n     *      validatorSignature = EIP 712 digest signed by `TRUSTED_VALIDATOR`(arbitrary bytes length)\n     *      validatorSignatureLength = length of `validatorSignature` (4 bytes)\n     *      expiryEpoch = expiry timestamp (4 bytes)\n     *  Here,\n     *  The `TRUSTED_VALIDATOR` is expected to sign the EIP 712 digest generated from following struct:\n     *  TypeHashHelper.Validation -\n     *      txnDigest = EIP712 digest generated from struct: TypeHashHelper.Transaction, with valid executor\n     *      policyHash = policy commit hash of the safe account\n     *      expiryEpoch = expiry timestamp\n     *\n     * @param account address of account to validate txn for\n     * @param transactionStructHash execution digest from ExecutorPlugin\n     * @param signatures user signatures appended with validation signature\n     * @return isSignatureValid boolean\n     */\n    function isPolicySignatureValid(address account, bytes32 transactionStructHash, bytes calldata signatures)\n        public\n        view\n        returns (bool)\n    {\n        // Get policy hash from registry\n        bytes32 policyHash =\n            PolicyRegistry(AddressProviderService._getRegistry(_POLICY_REGISTRY_HASH)).commitments(account);\n        if (policyHash == bytes32(0)) {\n            revert NoPolicyCommit();\n        }\n\n        // Get expiry epoch and validator signature from signatures\n        (uint32 expiryEpoch, bytes memory validatorSignature) = _decompileSignatures(signatures);\n\n        // Ensure transaction has not expired\n        if (expiryEpoch < uint32(block.timestamp)) {\n            revert TxnExpired(expiryEpoch);\n        }\n\n        // Build validation struct hash\n        bytes32 validationStructHash = TypeHashHelper._buildValidationStructHash(\n            TypeHashHelper.Validation({\n                transactionStructHash: transactionStructHash,\n                policyHash: policyHash,\n                expiryEpoch: expiryEpoch\n            })\n        );\n\n        // Build EIP712 digest with validation struct hash\n        bytes32 txnValidityDigest = _hashTypedData(validationStructHash);\n\n        address trustedValidator = AddressProviderService._getAuthorizedAddress(_TRUSTED_VALIDATOR_HASH);\n\n        // Empty Signature check for EOA signer\n        if (trustedValidator.code.length == 0 && validatorSignature.length == 0) {\n            // TrustedValidator is an EOA and no trustedValidator signature is provided\n            revert InvalidSignature();\n        }\n\n        // Validate signature\n        return SignatureCheckerLib.isValidSignatureNow(trustedValidator, txnValidityDigest, validatorSignature);\n    }\n\n    /**\n     * @notice Internal helper to extract validity signature from overall safe transaction signature\n     * @dev _signatures = abi.encodePacked(safeSignature, validatorSignature, validatorSignatureLength, expiryEpoch)\n     *  safeSignature = safe owners signatures (arbitrary bytes length)\n     *  validatorSignature = EIP 712 digest signed (arbitrary bytes length)\n     *  validatorSignatureLength = length of `validatorSignature` (4 bytes)\n     *  expiryEpoch = expiry timestamp (4 bytes)\n     *\n     * @param _signatures packed transaction signature\n     * @return expiryEpoch extracted expiry epoch signed by brahma backend\n     * @return validatorSignature extracted validity signature\n     */\n    function _decompileSignatures(bytes calldata _signatures)\n        internal\n        pure\n        returns (uint32 expiryEpoch, bytes memory validatorSignature)\n    {\n        uint256 length = _signatures.length;\n        if (length < 8) revert InvalidSignatures();\n\n        uint32 sigLength = uint32(bytes4(_signatures[length - 8:length - 4]));\n        expiryEpoch = uint32(bytes4(_signatures[length - 4:length]));\n        validatorSignature = _signatures[length - 8 - sigLength:length - 8];\n    }\n\n    /**\n     * @notice Internal helper to get EIP712 domain name and version\n     * @return name domainName\n     * @return version domainVersion\n     */\n    function _domainNameAndVersion() internal pure override returns (string memory name, string memory version) {\n        return (_NAME, _VERSION);\n    }\n}"
    }
  ]
}