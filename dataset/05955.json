{
  "Title": "[12] Reference to non-existent documentation",
  "Content": "\nThe references to IVotingEscrow are misleading because there is no IVotingEscrow anywhere in the codebase.  This makes it difficult to trust comments in the codebase, let alone find the referenced documentation that may enlighten the developer or auditor.\n\nExamples: \n\n- [https://github.com/code-423n4/2023-08-verwa/blob/a693b4db05b9e202816346a6f9cada94f28a2698/src/VotingEscrow.sol#L267](https://github.com/code-423n4/2023-08-verwa/blob/a693b4db05b9e202816346a6f9cada94f28a2698/src/VotingEscrow.sol#L267)\n- [https://github.com/code-423n4/2023-08-verwa/blob/a693b4db05b9e202816346a6f9cada94f28a2698/src/VotingEscrow.sol#L2](https://github.com/code-423n4/2023-08-verwa/blob/a693b4db05b9e202816346a6f9cada94f28a2698/src/VotingEscrow.sol#L267)86\n- [https://github.com/code-423n4/2023-08-verwa/blob/a693b4db05b9e202816346a6f9cada94f28a2698/src/VotingEscrow.sol#L](https://github.com/code-423n4/2023-08-verwa/blob/a693b4db05b9e202816346a6f9cada94f28a2698/src/VotingEscrow.sol#L267)325\n- [https://github.com/code-423n4/2023-08-verwa/blob/a693b4db05b9e202816346a6f9cada94f28a2698/src/VotingEscrow.sol#L355](https://github.com/code-423n4/2023-08-verwa/blob/a693b4db05b9e202816346a6f9cada94f28a2698/src/VotingEscrow.sol#L355)\n- [https://github.com/code-423n4/2023-08-verwa/blob/a693b4db05b9e202816346a6f9cada94f28a2698/src/VotingEscrow.sol#L472](https://github.com/code-423n4/2023-08-verwa/blob/a693b4db05b9e202816346a6f9cada94f28a2698/src/VotingEscrow.sol#L472)[https://github.com/code-423n4/2023-08-verwa/blob/a693b4db05b9e202816346a6f9cada94f28a2698/src/VotingEscrow.sol#L486](https://github.com/code-423n4/2023-08-verwa/blob/a693b4db05b9e202816346a6f9cada94f28a2698/src/VotingEscrow.sol#L486)\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-08-verwa",
  "Code": [
    {
      "filename": "src/VotingEscrow.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.16;\n\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/// @title  VotingEscrow\n/// @author Curve Finance (MIT) - original concept and implementation in Vyper\n///           (see https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy)\n///         mStable (AGPL) - forking Curve's Vyper contract and porting to Solidity\n///           (see https://github.com/mstable/mStable-contracts/blob/master/contracts/governance/IncentivisedVotingLockup.sol)\n///         FIAT DAO (AGPL) - https://github.com/code-423n4/2022-08-fiatdao/blob/main/contracts/VotingEscrow.sol\n///         mkt.market (AGPL) - This version\n/// @notice Plain Curve VotingEscrow mechanics with following adjustments:\n///            1) Delegation of lock and voting power\n///            2) Reduced pointHistory array size and, as a result, lifetime of the contract\n///            3) Removed public deposit_for and Aragon compatibility (no use case)\n///            4) Use native token (CANTO) instead of an ERC20 token as the underlying asset\n///            5) Lock time is fixed to 5 years, every action resets it\ncontract VotingEscrow is ReentrancyGuard {\n    // Shared Events\n    event Deposit(address indexed provider, uint256 value, uint256 locktime, LockAction indexed action, uint256 ts);\n    event Withdraw(address indexed provider, uint256 value, LockAction indexed action, uint256 ts);\n    event Unlock();\n\n    // Voting token\n    string public name;\n    string public symbol;\n    uint256 public decimals = 18;\n\n    // Shared global state\n    uint256 public constant WEEK = 7 days;\n    uint256 public constant LOCKTIME = 1825 days;\n    uint256 public constant MULTIPLIER = 10**18;\n\n    // Lock state\n    uint256 public globalEpoch;\n    Point[1000000000000000000] public pointHistory; // 1e9 * userPointHistory-length, so sufficient for 1e9 users\n    mapping(address => Point[1000000000]) public userPointHistory;\n    mapping(address => uint256) public userPointEpoch;\n    mapping(uint256 => int128) public slopeChanges;\n    mapping(address => LockedBalance) public locked;\n\n    // Structs\n    struct Point {\n        int128 bias;\n        int128 slope;\n        uint256 ts;\n        uint256 blk;\n    }\n    struct LockedBalance {\n        int128 amount;\n        uint256 end;\n        int128 delegated;\n        address delegatee;\n    }\n\n    // Miscellaneous\n    enum LockAction {\n        CREATE,\n        INCREASE_AMOUNT,\n        INCREASE_AMOUNT_AND_DELEGATION,\n        INCREASE_TIME,\n        WITHDRAW,\n        QUIT,\n        DELEGATE,\n        UNDELEGATE\n    }\n\n    /// @notice Initializes state\n    /// @param _name The name of the voting token\n    /// @param _symbol The symbol of the voting token\n    constructor(string memory _name, string memory _symbol) {\n        pointHistory[0] = Point({bias: int128(0), slope: int128(0), ts: block.timestamp, blk: block.number});\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n    ///       LOCK MANAGEMENT       ///\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n\n    /// @notice Returns a user's lock expiration\n    /// @param _addr The address of the user\n    /// @return Expiration of the user's lock\n    function lockEnd(address _addr) external view returns (uint256) {\n        return locked[_addr].end;\n    }\n\n    /// @notice Returns the last available user point for a user\n    /// @param _addr User address\n    /// @return bias i.e. y\n    /// @return slope i.e. linear gradient\n    /// @return ts i.e. time point was logged\n    function getLastUserPoint(address _addr)\n        external\n        view\n        returns (\n            int128 bias,\n            int128 slope,\n            uint256 ts\n        )\n    {\n        uint256 uepoch = userPointEpoch[_addr];\n        if (uepoch == 0) {\n            return (0, 0, 0);\n        }\n        Point memory point = userPointHistory[_addr][uepoch];\n        return (point.bias, point.slope, point.ts);\n    }\n\n    /// @notice Records a checkpoint of both individual and global slope\n    /// @param _addr User address, or address(0) for only global\n    /// @param _oldLocked Old amount that user had locked, or null for global\n    /// @param _newLocked new amount that user has locked, or null for global\n    function _checkpoint(\n        address _addr,\n        LockedBalance memory _oldLocked,\n        LockedBalance memory _newLocked\n    ) internal {\n        Point memory userOldPoint;\n        Point memory userNewPoint;\n        int128 oldSlopeDelta = 0;\n        int128 newSlopeDelta = 0;\n        uint256 epoch = globalEpoch;\n\n        if (_addr != address(0)) {\n            // Calculate slopes and biases\n            // Kept at zero when they have to\n            if (_oldLocked.end > block.timestamp && _oldLocked.delegated > 0) {\n                userOldPoint.slope = _oldLocked.delegated / int128(int256(LOCKTIME));\n                userOldPoint.bias = userOldPoint.slope * int128(int256(_oldLocked.end - block.timestamp));\n            }\n            if (_newLocked.end > block.timestamp && _newLocked.delegated > 0) {\n                userNewPoint.slope = _newLocked.delegated / int128(int256(LOCKTIME));\n                userNewPoint.bias = userNewPoint.slope * int128(int256(_newLocked.end - block.timestamp));\n            }\n\n            // Moved from bottom final if statement to resolve stack too deep err\n            // start {\n            // Now handle user history\n            uint256 uEpoch = userPointEpoch[_addr];\n            if (uEpoch == 0) {\n                userPointHistory[_addr][uEpoch + 1] = userOldPoint;\n            }\n\n            userPointEpoch[_addr] = uEpoch + 1;\n            userNewPoint.ts = block.timestamp;\n            userNewPoint.blk = block.number;\n            userPointHistory[_addr][uEpoch + 1] = userNewPoint;\n\n            // } end\n\n            // Read values of scheduled changes in the slope\n            // oldLocked.end can be in the past and in the future\n            // newLocked.end can ONLY by in the FUTURE unless everything expired: than zeros\n            oldSlopeDelta = slopeChanges[_oldLocked.end];\n            if (_newLocked.end != 0) {\n                if (_newLocked.end == _oldLocked.end) {\n                    newSlopeDelta = oldSlopeDelta;\n                } else {\n                    newSlopeDelta = slopeChanges[_newLocked.end];\n                }\n            }\n        }\n\n        Point memory lastPoint = Point({bias: 0, slope: 0, ts: block.timestamp, blk: block.number});\n        if (epoch > 0) {\n            lastPoint = pointHistory[epoch];\n        }\n        uint256 lastCheckpoint = lastPoint.ts;\n\n        // initialLastPoint is used for extrapolation to calculate block number\n        // (approximately, for *At methods) and save them\n        // as we cannot figure that out exactly from inside the contract\n        Point memory initialLastPoint = Point({bias: 0, slope: 0, ts: lastPoint.ts, blk: lastPoint.blk});\n        uint256 blockSlope = 0; // dblock/dt\n        if (block.timestamp > lastPoint.ts) {\n            blockSlope = (MULTIPLIER * (block.number - lastPoint.blk)) / (block.timestamp - lastPoint.ts);\n        }\n        // If last point is already recorded in this block, slope=0\n        // But that's ok b/c we know the block in such case\n\n        // Go over weeks to fill history and calculate what the current point is\n        uint256 iterativeTime = _floorToWeek(lastCheckpoint);\n        for (uint256 i = 0; i < 255; i++) {\n            // Hopefully it won't happen that this won't get used in 5 years!\n            // If it does, users will be able to withdraw but vote weight will be broken\n            iterativeTime = iterativeTime + WEEK;\n            int128 dSlope = 0;\n            if (iterativeTime > block.timestamp) {\n                iterativeTime = block.timestamp;\n            } else {\n                dSlope = slopeChanges[iterativeTime];\n            }\n            int128 biasDelta = lastPoint.slope * int128(int256((iterativeTime - lastCheckpoint)));\n            lastPoint.bias = lastPoint.bias - biasDelta;\n            lastPoint.slope = lastPoint.slope + dSlope;\n            // This can happen\n            if (lastPoint.bias < 0) {\n                lastPoint.bias = 0;\n            }\n            // This cannot happen - just in case\n            if (lastPoint.slope < 0) {\n                lastPoint.slope = 0;\n            }\n            lastCheckpoint = iterativeTime;\n            lastPoint.ts = iterativeTime;\n            lastPoint.blk = initialLastPoint.blk + (blockSlope * (iterativeTime - initialLastPoint.ts)) / MULTIPLIER;\n\n            // when epoch is incremented, we either push here or after slopes updated below\n            epoch = epoch + 1;\n            if (iterativeTime == block.timestamp) {\n                lastPoint.blk = block.number;\n                break;\n            } else {\n                pointHistory[epoch] = lastPoint;\n            }\n        }\n\n        globalEpoch = epoch;\n        // Now pointHistory is filled until t=now\n\n        if (_addr != address(0)) {\n            // If last point was in this block, the slope change has been applied already\n            // But in such case we have 0 slope(s)\n            lastPoint.slope = lastPoint.slope + userNewPoint.slope - userOldPoint.slope;\n            lastPoint.bias = lastPoint.bias + userNewPoint.bias - userOldPoint.bias;\n            if (lastPoint.slope < 0) {\n                lastPoint.slope = 0;\n            }\n            if (lastPoint.bias < 0) {\n                lastPoint.bias = 0;\n            }\n        }\n\n        // Record the changed point into history\n        pointHistory[epoch] = lastPoint;\n\n        if (_addr != address(0)) {\n            // Schedule the slope changes (slope is going down)\n            // We subtract new_user_slope from [new_locked.end]\n            // and add old_user_slope to [old_locked.end]\n            if (_oldLocked.end > block.timestamp) {\n                // oldSlopeDelta was <something> - userOldPoint.slope, so we cancel that\n                oldSlopeDelta = oldSlopeDelta + userOldPoint.slope;\n                if (_newLocked.end == _oldLocked.end) {\n                    oldSlopeDelta = oldSlopeDelta - userNewPoint.slope; // It was a new deposit, not extension\n                }\n                slopeChanges[_oldLocked.end] = oldSlopeDelta;\n            }\n            if (_newLocked.end > block.timestamp) {\n                if (_newLocked.end > _oldLocked.end) {\n                    newSlopeDelta = newSlopeDelta - userNewPoint.slope; // old slope disappeared at this point\n                    slopeChanges[_newLocked.end] = newSlopeDelta;\n                }\n                // else: we recorded it already in oldSlopeDelta\n            }\n        }\n    }\n\n    /// @notice Public function to trigger global checkpoint\n    function checkpoint() external {\n        LockedBalance memory empty;\n        _checkpoint(address(0), empty, empty);\n    }\n\n    // See IVotingEscrow for documentation\n    function createLock(uint256 _value) external payable nonReentrant {\n        uint256 unlock_time = _floorToWeek(block.timestamp + LOCKTIME); // Locktime is rounded down to weeks\n        LockedBalance memory locked_ = locked[msg.sender];\n        // Validate inputs\n        require(_value > 0, \"Only non zero amount\");\n        require(msg.value == _value, \"Invalid value\");\n        require(locked_.amount == 0, \"Lock exists\");\n        // Update lock and voting power (checkpoint)\n        locked_.amount += int128(int256(_value));\n        locked_.end = unlock_time;\n        locked_.delegated += int128(int256(_value));\n        locked_.delegatee = msg.sender;\n        locked[msg.sender] = locked_;\n        _checkpoint(msg.sender, LockedBalance(0, 0, 0, address(0)), locked_);\n\n        emit Deposit(msg.sender, _value, unlock_time, LockAction.CREATE, block.timestamp);\n    }\n\n    // See IVotingEscrow for documentation\n    // @dev A lock is active until both lock.amount==0 and lock.end<=block.timestamp\n    function increaseAmount(uint256 _value) external payable nonReentrant {\n        LockedBalance memory locked_ = locked[msg.sender];\n        // Validate inputs\n        require(_value > 0, \"Only non zero amount\");\n        require(msg.value == _value, \"Invalid value\");\n        require(locked_.amount > 0, \"No lock\");\n        require(locked_.end > block.timestamp, \"Lock expired\");\n        // Update lock\n        address delegatee = locked_.delegatee;\n        uint256 unlockTime = locked_.end;\n        LockAction action = LockAction.INCREASE_AMOUNT;\n        LockedBalance memory newLocked = _copyLock(locked_);\n        newLocked.amount += int128(int256(_value));\n        newLocked.end = _floorToWeek(block.timestamp + LOCKTIME);\n        if (delegatee == msg.sender) {\n            // Undelegated lock\n            action = LockAction.INCREASE_AMOUNT_AND_DELEGATION;\n            newLocked.delegated += int128(int256(_value));\n            locked[msg.sender] = newLocked;\n            _checkpoint(msg.sender, locked_, newLocked);\n        } else {\n            // Delegated lock, update sender's lock first\n            locked[msg.sender] = newLocked;\n            _checkpoint(msg.sender, locked_, newLocked);\n            // Then, update delegatee's lock and voting power (checkpoint)\n            locked_ = locked[delegatee];\n            require(locked_.amount > 0, \"Delegatee has no lock\");\n            require(locked_.end > block.timestamp, \"Delegatee lock expired\");\n            newLocked = _copyLock(locked_);\n            newLocked.delegated += int128(int256(_value));\n            locked[delegatee] = newLocked;\n            _checkpoint(delegatee, locked_, newLocked);\n            emit Deposit(delegatee, _value, newLocked.end, LockAction.DELEGATE, block.timestamp);\n        }\n        emit Deposit(msg.sender, _value, unlockTime, action, block.timestamp);\n    }\n\n    // See IVotingEscrow for documentation\n    function withdraw() external nonReentrant {\n        LockedBalance memory locked_ = locked[msg.sender];\n        // Validate inputs\n        require(locked_.amount > 0, \"No lock\");\n        require(locked_.end <= block.timestamp, \"Lock not expired\");\n        require(locked_.delegatee == msg.sender, \"Lock delegated\");\n        // Update lock\n        uint256 amountToSend = uint256(uint128(locked_.amount));\n        LockedBalance memory newLocked = _copyLock(locked_);\n        newLocked.amount = 0;\n        newLocked.end = 0;\n        newLocked.delegated -= int128(int256(amountToSend));\n        newLocked.delegatee = address(0);\n        locked[msg.sender] = newLocked;\n        newLocked.delegated = 0;\n        // oldLocked can have either expired <= timestamp or zero end\n        // currentLock has only 0 end\n        // Both can have >= 0 amount\n        _checkpoint(msg.sender, locked_, newLocked);\n        // Send back deposited tokens\n        (bool success, ) = msg.sender.call{value: amountToSend}(\"\");\n        require(success, \"Failed to send CANTO\");\n        emit Withdraw(msg.sender, amountToSend, LockAction.WITHDRAW, block.timestamp);\n    }\n\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n    ///         DELEGATION         ///\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n\n    // See IVotingEscrow for documentation\n    function delegate(address _addr) external nonReentrant {\n        LockedBalance memory locked_ = locked[msg.sender];\n        // Validate inputs\n        require(locked_.amount > 0, \"No lock\");\n        require(locked_.delegatee != _addr, \"Already delegated\");\n        // Update locks\n        int128 value = locked_.amount;\n        address delegatee = locked_.delegatee;\n        LockedBalance memory fromLocked;\n        LockedBalance memory toLocked;\n        locked_.delegatee = _addr;\n        if (delegatee == msg.sender) {\n            // Delegate\n            fromLocked = locked_;\n            toLocked = locked[_addr];\n        } else if (_addr == msg.sender) {\n            // Undelegate\n            fromLocked = locked[delegatee];\n            toLocked = locked_;\n        } else {\n            // Re-delegate\n            fromLocked = locked[delegatee];\n            toLocked = locked[_addr];\n            // Update owner lock if not involved in delegation\n            locked[msg.sender] = locked_;\n        }\n        require(toLocked.amount > 0, \"Delegatee has no lock\");\n        require(toLocked.end > block.timestamp, \"Delegatee lock expired\");\n        require(toLocked.end >= fromLocked.end, \"Only delegate to longer lock\");\n        _delegate(delegatee, fromLocked, value, LockAction.UNDELEGATE);\n        _delegate(_addr, toLocked, value, LockAction.DELEGATE);\n    }\n\n    // Delegates from/to lock and voting power\n    function _delegate(\n        address addr,\n        LockedBalance memory _locked,\n        int128 value,\n        LockAction action\n    ) internal {\n        LockedBalance memory newLocked = _copyLock(_locked);\n        if (action == LockAction.DELEGATE) {\n            newLocked.delegated += value;\n            emit Deposit(addr, uint256(int256(value)), newLocked.end, action, block.timestamp);\n        } else {\n            newLocked.delegated -= value;\n            emit Withdraw(addr, uint256(int256(value)), action, block.timestamp);\n        }\n        locked[addr] = newLocked;\n        if (newLocked.amount > 0) {\n            // Only if lock (from lock) hasn't been withdrawn/quitted\n            _checkpoint(addr, _locked, newLocked);\n        }\n    }\n\n    // Creates a copy of a lock\n    function _copyLock(LockedBalance memory _locked) internal pure returns (LockedBalance memory) {\n        return\n            LockedBalance({\n                amount: _locked.amount,\n                end: _locked.end,\n                delegatee: _locked.delegatee,\n                delegated: _locked.delegated\n            });\n    }\n\n    // @dev Floors a timestamp to the nearest weekly increment\n    // @param _t Timestamp to floor\n    function _floorToWeek(uint256 _t) internal pure returns (uint256) {\n        return (_t / WEEK) * WEEK;\n    }\n\n    // @dev Uses binarysearch to find the most recent point history preceeding block\n    // @param _block Find the most recent point history before this block\n    // @param _maxEpoch Do not search pointHistories past this index\n    function _findBlockEpoch(uint256 _block, uint256 _maxEpoch) internal view returns (uint256) {\n        // Binary search\n        uint256 min = 0;\n        uint256 max = _maxEpoch;\n        // Will be always enough for 128-bit numbers\n        for (uint256 i = 0; i < 128; i++) {\n            if (min >= max) break;\n            uint256 mid = (min + max + 1) / 2;\n            if (pointHistory[mid].blk <= _block) {\n                min = mid;\n            } else {\n                max = mid - 1;\n            }\n        }\n        return min;\n    }\n\n    // @dev Uses binarysearch to find the most recent user point history preceeding block\n    // @param _addr User for which to search\n    // @param _block Find the most recent point history before this block\n    function _findUserBlockEpoch(address _addr, uint256 _block) internal view returns (uint256) {\n        uint256 min = 0;\n        uint256 max = userPointEpoch[_addr];\n        for (uint256 i = 0; i < 128; i++) {\n            if (min >= max) {\n                break;\n            }\n            uint256 mid = (min + max + 1) / 2;\n            if (userPointHistory[_addr][mid].blk <= _block) {\n                min = mid;\n            } else {\n                max = mid - 1;\n            }\n        }\n        return min;\n    }\n\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n    ///            GETTERS         ///\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n\n    // See IVotingEscrow for documentation\n    function balanceOf(address _owner) public view returns (uint256) {\n        uint256 epoch = userPointEpoch[_owner];\n        if (epoch == 0) {\n            return 0;\n        }\n        Point memory lastPoint = userPointHistory[_owner][epoch];\n        lastPoint.bias = lastPoint.bias - (lastPoint.slope * int128(int256(block.timestamp - lastPoint.ts)));\n        if (lastPoint.bias < 0) {\n            lastPoint.bias = 0;\n        }\n        return uint256(uint128(lastPoint.bias));\n    }\n\n    // See IVotingEscrow for documentation\n    function balanceOfAt(address _owner, uint256 _blockNumber) public view returns (uint256) {\n        require(_blockNumber <= block.number, \"Only past block number\");\n\n        // Get most recent user Point to block\n        uint256 userEpoch = _findUserBlockEpoch(_owner, _blockNumber);\n        if (userEpoch == 0) {\n            return 0;\n        }\n        Point memory upoint = userPointHistory[_owner][userEpoch];\n\n        // Get most recent global Point to block\n        uint256 maxEpoch = globalEpoch;\n        uint256 epoch = _findBlockEpoch(_blockNumber, maxEpoch);\n        Point memory point0 = pointHistory[epoch];\n\n        // Calculate delta (block & time) between user Point and target block\n        // Allowing us to calculate the average seconds per block between\n        // the two points\n        uint256 dBlock = 0;\n        uint256 dTime = 0;\n        if (epoch < maxEpoch) {\n            Point memory point1 = pointHistory[epoch + 1];\n            dBlock = point1.blk - point0.blk;\n            dTime = point1.ts - point0.ts;\n        } else {\n            dBlock = block.number - point0.blk;\n            dTime = block.timestamp - point0.ts;\n        }\n        // (Deterministically) Estimate the time at which block _blockNumber was mined\n        uint256 blockTime = point0.ts;\n        if (dBlock != 0) {\n            blockTime = blockTime + ((dTime * (_blockNumber - point0.blk)) / dBlock);\n        }\n        // Current Bias = most recent bias - (slope * time since update)\n        upoint.bias = upoint.bias - (upoint.slope * int128(int256(blockTime - upoint.ts)));\n        if (upoint.bias >= 0) {\n            return uint256(uint128(upoint.bias));\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice Calculate total supply of voting power at a given time _t\n    /// @param _point Most recent point before time _t\n    /// @param _t Time at which to calculate supply\n    /// @return totalSupply at given point in time\n    function _supplyAt(Point memory _point, uint256 _t) internal view returns (uint256) {\n        Point memory lastPoint = _point;\n        // Floor the timestamp to weekly interval\n        uint256 iterativeTime = _floorToWeek(lastPoint.ts);\n        // Iterate through all weeks between _point & _t to account for slope changes\n        for (uint256 i = 0; i < 255; i++) {\n            iterativeTime = iterativeTime + WEEK;\n            int128 dSlope = 0;\n            // If week end is after timestamp, then truncate & leave dSlope to 0\n            if (iterativeTime > _t) {\n                iterativeTime = _t;\n            }\n            // else get most recent slope change\n            else {\n                dSlope = slopeChanges[iterativeTime];\n            }\n\n            lastPoint.bias = lastPoint.bias - (lastPoint.slope * int128(int256(iterativeTime - lastPoint.ts)));\n            if (iterativeTime == _t) {\n                break;\n            }\n            lastPoint.slope = lastPoint.slope + dSlope;\n            lastPoint.ts = iterativeTime;\n        }\n\n        if (lastPoint.bias < 0) {\n            lastPoint.bias = 0;\n        }\n        return uint256(uint128(lastPoint.bias));\n    }\n\n    // See IVotingEscrow for documentation\n    function totalSupply() public view returns (uint256) {\n        uint256 epoch_ = globalEpoch;\n        Point memory lastPoint = pointHistory[epoch_];\n        return _supplyAt(lastPoint, block.timestamp);\n    }\n\n    // See IVotingEscrow for documentation\n    function totalSupplyAt(uint256 _blockNumber) public view returns (uint256) {\n        require(_blockNumber <= block.number, \"Only past block number\");\n\n        uint256 epoch = globalEpoch;\n        uint256 targetEpoch = _findBlockEpoch(_blockNumber, epoch);\n\n        Point memory point = pointHistory[targetEpoch];\n\n        // If point.blk > _blockNumber that means we got the initial epoch & contract did not yet exist\n        if (point.blk > _blockNumber) {\n            return 0;\n        }\n\n        uint256 dTime = 0;\n        if (targetEpoch < epoch) {\n            Point memory pointNext = pointHistory[targetEpoch + 1];\n            if (point.blk != pointNext.blk) {\n                dTime = ((_blockNumber - point.blk) * (pointNext.ts - point.ts)) / (pointNext.blk - point.blk);\n            }\n        } else if (point.blk != block.number) {\n            dTime = ((_blockNumber - point.blk) * (block.timestamp - point.ts)) / (block.number - point.blk);\n        }\n        // Now dTime contains info on how far are we beyond point\n        return _supplyAt(point, point.ts + dTime);\n    }\n}"
    },
    {
      "filename": "src/VotingEscrow.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.16;\n\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/// @title  VotingEscrow\n/// @author Curve Finance (MIT) - original concept and implementation in Vyper\n///           (see https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy)\n///         mStable (AGPL) - forking Curve's Vyper contract and porting to Solidity\n///           (see https://github.com/mstable/mStable-contracts/blob/master/contracts/governance/IncentivisedVotingLockup.sol)\n///         FIAT DAO (AGPL) - https://github.com/code-423n4/2022-08-fiatdao/blob/main/contracts/VotingEscrow.sol\n///         mkt.market (AGPL) - This version\n/// @notice Plain Curve VotingEscrow mechanics with following adjustments:\n///            1) Delegation of lock and voting power\n///            2) Reduced pointHistory array size and, as a result, lifetime of the contract\n///            3) Removed public deposit_for and Aragon compatibility (no use case)\n///            4) Use native token (CANTO) instead of an ERC20 token as the underlying asset\n///            5) Lock time is fixed to 5 years, every action resets it\ncontract VotingEscrow is ReentrancyGuard {\n    // Shared Events\n    event Deposit(address indexed provider, uint256 value, uint256 locktime, LockAction indexed action, uint256 ts);\n    event Withdraw(address indexed provider, uint256 value, LockAction indexed action, uint256 ts);\n    event Unlock();\n\n    // Voting token\n    string public name;\n    string public symbol;\n    uint256 public decimals = 18;\n\n    // Shared global state\n    uint256 public constant WEEK = 7 days;\n    uint256 public constant LOCKTIME = 1825 days;\n    uint256 public constant MULTIPLIER = 10**18;\n\n    // Lock state\n    uint256 public globalEpoch;\n    Point[1000000000000000000] public pointHistory; // 1e9 * userPointHistory-length, so sufficient for 1e9 users\n    mapping(address => Point[1000000000]) public userPointHistory;\n    mapping(address => uint256) public userPointEpoch;\n    mapping(uint256 => int128) public slopeChanges;\n    mapping(address => LockedBalance) public locked;\n\n    // Structs\n    struct Point {\n        int128 bias;\n        int128 slope;\n        uint256 ts;\n        uint256 blk;\n    }\n    struct LockedBalance {\n        int128 amount;\n        uint256 end;\n        int128 delegated;\n        address delegatee;\n    }\n\n    // Miscellaneous\n    enum LockAction {\n        CREATE,\n        INCREASE_AMOUNT,\n        INCREASE_AMOUNT_AND_DELEGATION,\n        INCREASE_TIME,\n        WITHDRAW,\n        QUIT,\n        DELEGATE,\n        UNDELEGATE\n    }\n\n    /// @notice Initializes state\n    /// @param _name The name of the voting token\n    /// @param _symbol The symbol of the voting token\n    constructor(string memory _name, string memory _symbol) {\n        pointHistory[0] = Point({bias: int128(0), slope: int128(0), ts: block.timestamp, blk: block.number});\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n    ///       LOCK MANAGEMENT       ///\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n\n    /// @notice Returns a user's lock expiration\n    /// @param _addr The address of the user\n    /// @return Expiration of the user's lock\n    function lockEnd(address _addr) external view returns (uint256) {\n        return locked[_addr].end;\n    }\n\n    /// @notice Returns the last available user point for a user\n    /// @param _addr User address\n    /// @return bias i.e. y\n    /// @return slope i.e. linear gradient\n    /// @return ts i.e. time point was logged\n    function getLastUserPoint(address _addr)\n        external\n        view\n        returns (\n            int128 bias,\n            int128 slope,\n            uint256 ts\n        )\n    {\n        uint256 uepoch = userPointEpoch[_addr];\n        if (uepoch == 0) {\n            return (0, 0, 0);\n        }\n        Point memory point = userPointHistory[_addr][uepoch];\n        return (point.bias, point.slope, point.ts);\n    }\n\n    /// @notice Records a checkpoint of both individual and global slope\n    /// @param _addr User address, or address(0) for only global\n    /// @param _oldLocked Old amount that user had locked, or null for global\n    /// @param _newLocked new amount that user has locked, or null for global\n    function _checkpoint(\n        address _addr,\n        LockedBalance memory _oldLocked,\n        LockedBalance memory _newLocked\n    ) internal {\n        Point memory userOldPoint;\n        Point memory userNewPoint;\n        int128 oldSlopeDelta = 0;\n        int128 newSlopeDelta = 0;\n        uint256 epoch = globalEpoch;\n\n        if (_addr != address(0)) {\n            // Calculate slopes and biases\n            // Kept at zero when they have to\n            if (_oldLocked.end > block.timestamp && _oldLocked.delegated > 0) {\n                userOldPoint.slope = _oldLocked.delegated / int128(int256(LOCKTIME));\n                userOldPoint.bias = userOldPoint.slope * int128(int256(_oldLocked.end - block.timestamp));\n            }\n            if (_newLocked.end > block.timestamp && _newLocked.delegated > 0) {\n                userNewPoint.slope = _newLocked.delegated / int128(int256(LOCKTIME));\n                userNewPoint.bias = userNewPoint.slope * int128(int256(_newLocked.end - block.timestamp));\n            }\n\n            // Moved from bottom final if statement to resolve stack too deep err\n            // start {\n            // Now handle user history\n            uint256 uEpoch = userPointEpoch[_addr];\n            if (uEpoch == 0) {\n                userPointHistory[_addr][uEpoch + 1] = userOldPoint;\n            }\n\n            userPointEpoch[_addr] = uEpoch + 1;\n            userNewPoint.ts = block.timestamp;\n            userNewPoint.blk = block.number;\n            userPointHistory[_addr][uEpoch + 1] = userNewPoint;\n\n            // } end\n\n            // Read values of scheduled changes in the slope\n            // oldLocked.end can be in the past and in the future\n            // newLocked.end can ONLY by in the FUTURE unless everything expired: than zeros\n            oldSlopeDelta = slopeChanges[_oldLocked.end];\n            if (_newLocked.end != 0) {\n                if (_newLocked.end == _oldLocked.end) {\n                    newSlopeDelta = oldSlopeDelta;\n                } else {\n                    newSlopeDelta = slopeChanges[_newLocked.end];\n                }\n            }\n        }\n\n        Point memory lastPoint = Point({bias: 0, slope: 0, ts: block.timestamp, blk: block.number});\n        if (epoch > 0) {\n            lastPoint = pointHistory[epoch];\n        }\n        uint256 lastCheckpoint = lastPoint.ts;\n\n        // initialLastPoint is used for extrapolation to calculate block number\n        // (approximately, for *At methods) and save them\n        // as we cannot figure that out exactly from inside the contract\n        Point memory initialLastPoint = Point({bias: 0, slope: 0, ts: lastPoint.ts, blk: lastPoint.blk});\n        uint256 blockSlope = 0; // dblock/dt\n        if (block.timestamp > lastPoint.ts) {\n            blockSlope = (MULTIPLIER * (block.number - lastPoint.blk)) / (block.timestamp - lastPoint.ts);\n        }\n        // If last point is already recorded in this block, slope=0\n        // But that's ok b/c we know the block in such case\n\n        // Go over weeks to fill history and calculate what the current point is\n        uint256 iterativeTime = _floorToWeek(lastCheckpoint);\n        for (uint256 i = 0; i < 255; i++) {\n            // Hopefully it won't happen that this won't get used in 5 years!\n            // If it does, users will be able to withdraw but vote weight will be broken\n            iterativeTime = iterativeTime + WEEK;\n            int128 dSlope = 0;\n            if (iterativeTime > block.timestamp) {\n                iterativeTime = block.timestamp;\n            } else {\n                dSlope = slopeChanges[iterativeTime];\n            }\n            int128 biasDelta = lastPoint.slope * int128(int256((iterativeTime - lastCheckpoint)));\n            last"
    }
  ]
}