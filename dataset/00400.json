{
  "Title": "M-8: Attackers can sandwich their own trades up to the price bands",
  "Content": "# Issue M-8: Attackers can sandwich their own trades up to the price bands \n\nSource: https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/119 \n\n## Found by \nIllIllI, santipu\\_\n## Summary\n\nMalicious users can sandwich their own SpotHedgeBaseMaker trades up to the price band cap\n\n\n## Vulnerability Detail\n\nThe SpotHedgeBaseMaker allows one to settle trades against a UniswapV3 pool. The assumption is that the pool prices tokens properly, and any imbalance in the pool is reflected in the price paid/amount received by the trader interacting with the SpotHedgeBaseMaker. This assumption is incorrect, because an attacker can sandwich their own trade, taking value out of the Perpetual system.\n\nThe attacker would get a large flash loan, imbalance the pool, use the ClearingHouse to settle and opening trade, then re-balance the pool, all in the same transaction. \n\n\n## Impact\n\nFor example, assume the actual exchange rate is $4,000/1WEth, and the attacker is able to skew it such that the exchange rate temporarily becomes $1/1WEth. The attacker opening a short of 1Eth means that the SpotHedgeBaseMaker ends up going long 1Eth, and hedges that long by swapping 1WEth for $1. The attacker ends up using ~1 in margin to open the short. After the attacker unwinds the skew, they've gained ~1WEth (~$4k) from the rebalance, and they can abandon the perp account worth -$4k.\n\nIn reality, the attacker won't be able to skew the exchange rate by quite that much, because there's a price band [check](https://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/clearingHouse/ClearingHouse.sol#L331) at the end of the trade, ensuring that the price gotten on the trade is roughly equivalent to the oracle's price. The test [comments](https://github.com/sherlock-audit/2024-02-perpetual/blob/02f17e70a23da5d71364268ccf7ed9ee7cedf428/perp-contract-v3/test/orderGatewayV2/OrderGatewayV2.settleOrder.int.t.sol#L1271) indicate that the bands are anticipated to be +/- 10%. If the price bands are set to zero (the swap price must be the oracle price), then the SpotHedgeBaseMaker won't be usable at all, since uniswap charges a fee for every trade. If the bands are widened to be just wide enough to accommodate the fee, then other parts of the system, such as the OracleMaker won't work properly (see other submitted issue). Therefore, either _some_ value will be extractable, or parts of the protocol will be broken.\n\nBecause of these restrictions/limitations I've submitted this as a Medium.\n\n\n## Code Snippet\n\nThe SpotHedgeBaseMaker doesn't require that the [sender](https://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/clearingHouse/ClearingHouse.sol#L281) be the [Gateway/GatewayV2](https://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/clearingHouse/ClearingHouse.sol#L231-L232), so anyone can execute it directly from the ClearingHouse:\n```solidity\n// File: src/maker/SpotHedgeBaseMaker.sol : SpotHedgeBaseMaker.isValidSender()   #1\n\n514        function isValidSender(address) external pure override returns (bool) {\n515            return true;\n516:       }\n```\nhttps://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/maker/SpotHedgeBaseMaker.sol#L504-L526\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nRequire that SpotHedgeBaseMaker be executed by a relayer\n\n\n\n## Discussion\n\n**42bchen**\n\n```\n// ETH oracle 100, spot 100 (100 ETH, 10000 USDC) assume no fee, full range v3 liquidity\n// user flashLoan buy ETH -> spot 400 (50 ETH, 20000 USDC), user borrow 10000 USDC to swap, get 50 ETH\n// user open short position on SHBM\n// - SHBM sell 1 ETH -> (51 ETH,19607.84 USDC) -> get 392.16 USDC\n// - user openNotional 392.16 USDC, SHBM openNotional -392.16 USDC\n// user sell 50 ETH to pool (101 ETH, 9,900.99 USDC), get 9706.85 USDC\n// result:\n// - user profit: -10000 (borrow debt) + 292.16 (system profit) + 9706.85 (from selling ETH) = -1\n// - SHBM profit: 392.16 (sell ETH) + -292.16 (system profit) = 100\n// user didn't has profit\n```\n\nthe user profit in the system does not reflect the real profit in the whole attack operation; the attacker needs some cost to push the price.\nOur spotHedgeMaker is hedged, and our system total pnl = 0\n\n**IllIllI000**\n\n@42bchen can you take a look at this test case? I believe it shows that sandwiching can be profitable as long as there's enough of a price difference between the pyth price and the uniswap price (note that it's not trading against the OracleMaker - only against the SHBM). Change `spotPoolFee` to be `100` in SpotHedgeBaseMakerForkSetup.sol, then add this test as perp-contract-v3/test/spotHedgeMaker/Sandwich.sol\n```solidity\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\n// forge test --match-test testSandwich -vv\n\nimport \"forge-std/Test.sol\";\nimport \"../spotHedgeMaker/SpotHedgeBaseMakerForkSetup.sol\";\nimport { OracleMaker } from \"../../src/maker/OracleMaker.sol\";\nimport \"../../src/common/LibFormatter.sol\";\nimport { SignedMath } from \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\n\ncontract priceDivergence is SpotHedgeBaseMakerForkSetup {\n\n    using LibFormatter for int256;\n    using LibFormatter for uint256;\n    using SignedMath for int256;\n\n    address public exploiter = makeAddr(\"Exploiter\");\n    OracleMaker public oracle_maker;\n\n    function setUp() public override {\n        super.setUp();\n        oracle_maker = new OracleMaker();\n        _enableInitialize(address(oracle_maker));\n        oracle_maker.initialize(marketId, \"OM\", \"OM\", address(addressManager), priceFeedId, 1e18);\n        config.registerMaker(marketId, address(oracle_maker));\n        config.setFundingConfig(marketId, 0.005e18, 1.3e18, address(oracle_maker));\n        config.setMaxBorrowingFeeRate(marketId, 10000000000, 10000000000);\n        oracle_maker.setMaxSpreadRatio(0.1 ether);\n        oracle_maker.setValidSender(exploiter,true);\n        pyth = IPyth(0xff1a0f4744e8582DF1aE09D5611b887B6a12925C);\n        _mockPythPrice(2000,0);\n    }\n\n    function testSandwich() public {\n       // deposit 2k collateral as margin for exploiter\n       _deposit(marketId, exploiter, 2_000e6);\n\n       // deposit 2000 base tokens ($4M) to the HSBM\n       vm.startPrank(makerLp);\n       deal(address(baseToken), makerLp, 2000e9, true);\n       baseToken.approve(address(maker), type(uint256).max);\n       maker.deposit(2000e9);\n       vm.stopPrank();\n\n       // exploiter has 43 base tokens ($86K)\n       deal(address(baseToken), exploiter, 43e9, true);\n\n       // exploiter balances at the start\n       uint256 baseBalanceStart = baseToken.balanceOf(exploiter);\n       console.log(\"exploiter initial values (margin, collateral, base)\");\n       console.logInt(vault.getMargin(marketId,address(exploiter)).formatDecimals(INTERNAL_DECIMALS,collateralToken.decimals()));\n       console.log(collateralToken.balanceOf(exploiter));\n       console.log(baseBalanceStart);\n\n       // the price gapped ~7% within the last 60 seconds, and nobody has updated the pyth price,\n       // but the uniswap pool has already adjusted\n       int64 oldPrice = 2000 * 93 / 100;\n       _mockPythPrice(oldPrice,0);\n\n       // first stage: skew in favor of collateral token\n       vm.startPrank(exploiter);\n       baseToken.approve(address(uniswapV3Router), type(uint256).max);\n       uniswapV3Router.exactInput(\n           ISwapRouter.ExactInputParams({\n               path: uniswapV3B2QPath,\n               recipient: exploiter,\n               deadline: block.timestamp,\n               amountIn: baseToken.balanceOf(exploiter),\n               amountOutMinimum: 0\n           })\n        );\n\n        // second stage: open short position on SHBM\n        (int256 pbT, int256 pqT) = clearingHouse.openPosition(\n            IClearingHouse.OpenPositionParams({\n                marketId: marketId,\n                maker: address(maker),\n                isBaseToQuote: true,\n                isExactInput: true,\n                amount: 2e18,\n                oppositeAmountBound: 1,\n                deadline: block.timestamp,\n                makerData: \"\"\n            })\n        );\n\n        // third stage: swap back to fix the skew\n        collateralToken.approve(address(uniswapV3Router), type(uint256).max);\n        uniswapV3Router.exactInput(\n                ISwapRouter.ExactInputParams({\n                    path: uniswapV3Q2BPath,\n                    recipient: exploiter,\n                    deadline: block.timestamp,\n                    amountIn: collateralToken.balanceOf(exploiter),\n                    amountOutMinimum: 0\n                })\n            );\n\n       console.log(\"exploiter ending values (margin, collateral, base)\");\n       uint256 baseBalanceFinish = baseToken.balanceOf(exploiter);\n       console.logInt(vault.getMargin(marketId,address(exploiter)).formatDecimals(INTERNAL_DECIMALS,collateralToken.decimals()));\n       console.log(collateralToken.balanceOf(exploiter));\n       console.log(baseBalanceFinish);\n\n       // gain is for more than one ETH, which is enough to abandon the collateral in the vault\n       console.log(\"Gain:\", baseBalanceFinish - baseBalanceStart);\n\n       vm.stopPrank();\n    }\n}\n```\n\noutput:\n```text\nLogs:\n  exploiter initial values (margin, collateral, base)\n  2000000000\n  0\n  43000000000\n  exploiter ending values (margin, collateral, base)\n  2000000000\n  0\n  44018525544\n  Gain: 1018525544\n```\n\n**paco0x**\n\n@IllIllI000 thanks for your POC scripts. After carefully analyzing the numbers in this test case, I believe that the exploiter's profit is caused by bad debt under the assumption of deviation in pyth prices in 60s (7% in this case). \n\nIn this test, the exploiter's actual source of income is that he increased his buying power by using a stale price for opening position. He short 2 ETH with avg price 964, this position passed the IM ratio check since the price is 1860 instead of 2000 in contract. And he'll be in bad debt after the price updated to 2000 in the contract. The SHBM is always hedged and does not lose money.\n\nTo mitigate the price deviation issue, we're currently using a permissioned keeper to settle user's orders with makers, but seems users can still open position directly with SHBM to bypass the keeper. And if the price deviation issue exists, there'll be a room to intentionally generate bad debt and make profit, just like in this test case.\n\nSo I agree this issue is valid, but under the price deviation assumption. If you have any other idea that can bypass this assumption, I would agree to elevate the severity level of this issue.\n\nThe initial idea to solve this issue is: \n1. use a relayer to settle orders with SHBM\n2. impose some restrictions on the average price of open positions, in order to prevent avg price from deviating too much from the oracle.\n\nThanks a lot for you great work!\n\n**paco0x**\n\n> @IllIllI000 thanks for your POC scripts. After carefully analyzing the numbers in this test case, I believe that the exploiter's profit is caused by bad debt under the assumption of deviation in pyth prices in 60s (7% in this case).\n> \n> In this test, the exploiter's actual source of income is that he increased his buying power by using a stale price for opening position. He short 2 ETH with avg price 964, this position passed the IM ratio check since the price is 1860 instead of 2000 in contract. And he'll be in bad debt after the price updated to 2000 in the contract. The SHBM is always hedged and does not lose money.\n> \n> To mitigate the price deviation issue, we're currently using a permissioned keeper to settle user's orders with makers, but seems users can still open position directly with SHBM to bypass the keeper. And if the price deviation issue exists, there'll be a room to intentionally generate bad debt and make profit, just like in this test case.\n> \n> So I agree this issue is valid, but under the price deviation assumption. If you have any other idea that can bypass this assumption, I would agree to elevate the severity level of this issue.\n> \n> The initial idea to solve this issue is:\n> \n> 1. use a relayer to settle orders with SHBM\n> 2. impose some restrictions on the average price of open positions, in order to prevent avg price from deviating too much from the oracle.\n> \n> Thanks a lot for you great work!\n\nAnother thing to add on, in this test case, we didn't set the price band in `Config` contract. If we add a price band of 20% in the `setUp` like:\n\n```\n config.setPriceBandRatio(marketId, 0.2e18);\n```\n\nThe exploiter cannot open his position since the trade price deviates too much from oracle price. The difficulty of this attack will significantly increase with a effective price band.\n\n**IllIllI000**\n\nthanks @paco0x in [this](https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/128) issue, I point out that the price bands can be bypassed via sandwich as well, by using different pyth prices. Please let me know your thoughts on that one as well, there, since it's currently marked as a duplicate of one that is marked as sponsor-disputed.\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/perpetual-protocol/perp-contract-v3/pull/19\n\n\n**nirohgo**\n\nEscalate\n\nShould be invalid:  \nA. The POC presented is highly unlikely for serveral reasons:\n1. For it to work, the pool in question needs to have low liquidity. the pool is initialized with $200,000(collateral)/100Eth(base) in SpotHedgeBaseMakerForkSetup line 81/82. If you add just one zero to each (representing a more likely liquidity of $2M) the attack doesn't hold because of reduced slippage. For reference, currently on UniV3 on optimism Eth/USDT has 2M and Eth/USDC has 10M.\n2. The fee tier was changed to 100 (0.01%) which again, in highly unlikely since this rate is used only for stable pairs. change to 3000 and the attack doesn't hold.\n3. The POC scenario of a price drop of 7% within 60 seconds with no onchain update of the Pyth contract is also highly unlikely as such price shifts are rare and likely to draw an immediate update as many protocols can be affected.\n\nB.  Even if all the above conditions hold, the profit calculation is wrong: The exploiter in the example deposited $2000 collateral and is left with an unrealized PnL of -$1790 at the end (add these lines at the end to see):\n```solidity\nint256 on = vault.getOpenNotional(marketId,exploiter).formatDecimals(INTERNAL_DECIMALS,collateralToken.decimals());\n int256 unrePnl = vault.getUnrealizedPnl(marketId, exploiter, uint256(uint64(oldPrice)) * (10**18));\nconsole.logInt(on);\nconsole.logInt(unrePnl);\n``` \nwhich means if they \"abandon the perp\" as the finding suggests they are out $2000 and have gained nothing. \nThe original finding scenario is even more unrealistic (even if we disregard the price band check) because the amount required to drop the price from $4000 to $1 for a univ3 pair with reasonable liquidity will make the exploit non-profitable due to the Uni trading fees.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> Should be invalid:  \n> A. The POC presented is highly unlikely for serveral reasons:\n> 1. For it to work, the pool in question needs to have low liquidity. the pool is initialized with $200,000(collateral)/100Eth(base) in SpotHedgeBaseMakerForkSetup line 81/82. If you add just one zero to each (representing a more likely liquidity of $2M) the attack doesn't hold because of reduced slippage. For reference, currently on UniV3 on optimism Eth/USDT has 2M and Eth/USDC has 10M.\n> 2. The fee tier was changed to 100 (0.01%) which again, in highly unlikely since this rate is used only for stable pairs. change to 3000 and the attack doesn't hold.\n> 3. The POC scenario of a price drop of 7% within 60 seconds with no onchain update of the Pyth contract is also highly unlikely as such price shifts are rare and likely to draw an immediate update as many protocols can be affected.\n> \n> B.  Even if all the above conditions hold, the profit calculation is wrong: The exploiter in the example deposited $2000 collateral and is left with an unrealized PnL of -$1790 at the end (add these lines at the end to see):\n> ```solidity\n> int256 on = vault.getOpenNotional(marketId,exploiter).formatDecimals(INTERNAL_DECIMALS,collateralToken.decimals());\n>  int256 unrePnl = vault.getUnrealizedPnl(marketId, exploiter, uint256(uint64(oldPrice)) * (10**18));\n> console.logInt(on);\n> console.logInt(unrePnl);\n> ``` \n> which means if they \"abandon the perp\" as the finding suggests they are out $2000 and have gained nothing. \n> The original finding scenario is even more unrealistic (even if we disregard the price band check) because the amount required to drop the price from $4000 to $1 for a univ3 pair with reasonable liquidity will make the exploit non-profitable due to the Uni trading fees.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**IllIllI000**\n\nLogically, if a sandwich can be shown to be profitable with one specific set of numbers with no mistakes and feasible settings, then other combinations are also possible, and it's not my job to show every single possible combination - one suffices to show that there's a security risk here, where a sandwich can cause bad debt to occur. The sponsor confirmed the numbers themselves - they didn't just take my word for it. The escalating watson also misunderstood the POC, because the profit is the extra 0.018525544 Eth gained from swapping back after the sandwich, not anything in the perp account, which will be abandoned\n\n**nirohgo**\n\n> The escalating watson also misunderstood the POC, because the profit is the extra 0.018525544 Eth gained from swapping back after the sandwich, not anything in the perp account, which will be abandoned\n\nI understood the POC, it's just that the POC output states gains are 1.018525544Eth so I thought you forgot about the abandoned amount.\n\n\n> Logically, if a sandwich can be shown to be profitable with one specific set of numbers with no mistakes and feasible settings, then other combinations are also possible, and it's not my job to show every single possible combination - one suffices to show that there's a security risk here, where a sandwich can cause bad debt to occur.\n\nMy point is that these setting are not feasible. As mentioned, pool fee of 100 is only used with stable pairs. Since collateral is USDT this means a pair with some other USD pegged token. This means much lower uniswap slippage than in the POC (even with the given liquidity) and much smaller chance of there being a 7% price drop within 60 seconds that doesn't get published onchain. (Actually I don't think a futures market on a pair of two USD pegged stables is even a thing)\n\n**IllIllI000**\n\nWETH/USDC on OP has a 0.05% fee https://info.uniswap.org/pools#/optimism/pools/0x85149247691df622eaf1a8bd0cafd40bc45154a9\nChanging the unit test to use 44e9 base tokens instead of 43e9, and a 7.2% drop instead of 7.0% results in the test still passing with a profit with a 0.05% fee instead of the 0.01% one you say is not feasible\n\n**nevillehuang**\n\n@IllIllI000 I believe based on the impact of profit you have shown and the constrained scenario required to execute this attack, medium severity is more appropriate\n\n**nirohgo**\n\nHi @nevillehuang , I still think it's a low. The new scenario the watson proposed generates around $2 profit in the black swanish event of a 7.2% price drop within 60 seconds (that is not reported on chain). I Dont think it qualifies even as a medium.\n\n**IllIllI000**\n\nThe _risk-free_ profit is ~[$67](https://duckduckgo.com/?q=0.018525544+eth+to+usd&ia=cryptocurrency) with an investment of only 1 Eth, which is ~2%. The POC only used 1Eth, but much larger amounts can be used instead\n\n**nirohgo**\n\n> The _risk-free_ profit is ~[$67](https://duckduckgo.com/?q=0.018525544+eth+to+usd&ia=cryptocurrency) with an investment of only 1 Eth, which is ~2%. The POC only used 1Eth, but much larger amounts can be used instead\n\nNot really - $67 was the original POC scenario which we're establish is not feasible. Under the new one you provided: \"Changing the unit test to use 44e9 base tokens instead of 43e9, and a 7.2% drop instead of 7.0% results in the test still passing with a profit with a 0.05% fee instead of the 0.01% one you say is not feasible\" the \"gains\" are only 1.001184143 which leaves around $2 after the abandoned position. (again, that too is only possible under an extremely rare event)\n\n**IllIllI000**\n\nOk, yes, it's ~[$4](https://duckduckgo.com/?q=0.001184143+eth+to+usd&ia=cryptocurrency) with the specific POC and the updated fee, my mistake in copying the old value. However, like I said this is on a base of 1 eth, and this is a risk free attack that can be larger depending on how much capital is available to the attacker\n\n**nirohgo**\n\nYes, but that too, only when there's a 7.2% price drop within 60 seconds that wasn't reported to pyth onchain. I mean, how often does that happen?\n\n**IllIllI000**\n\nThe sponsor is fixing the issue, so it's not a risk they're willing to take. I think at this point we should let the judge decide\n\n**nevillehuang**\n\n@IllIllI000 I believe this is borderline medium/high. Do you have an example of a token (I suppose any non-weird token) that this has occured for a pyth oracle return value (maybe we could check their [dashboards](https://pyth.network/price-feeds))? If not I believe given the relatively uncommon occurence of this, medium severity seems appropriate\n\n**IllIllI000**\n\nI spent quite a bit of time trying to provide an example. Some issues I'm facing are that none of the Pyth web interfaces let you do range queries, so I have to manually fetch prices one-by-one in order to find an example. Etherscan also doesn't help because _all_ updates are done via a single contract, and it doesn't let me filter transaction-internal function calls by parameter, so it's another manual process. Even if I were to spend the hours digging through to find an example, the head of judging may have some other requirement that I need to search for, just like after countering nirohgo's complaints there's this new request, so I'd rather not spend more time searching for something that may or may not convince the head of judging, and just wait to hear what they ask for. The sponsor found the finding to be [valuable](https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/119#issuecomment-2029396462), the POC shows a risk-free profit, and the add-on submission shows a way to counter the price band protections. I agree that the specific POC I provided depends on a gap occurring\n\n**WangSecurity**\n\n@IllIllI000 From the comments above it's not clear for me: the attack has specific external conditions and state to occur or the restrictions are low? Can you elaborate a bit on what are prerequisites and constaints for this issue to happen? Thank you in advance!\n\n**IllIllI000**\n\n@WangSecurity I've tried again today to find other combinations of margin, collateral, leverage, and sandwich size, but since it's a manual process of trial and error of all of these parameters, as well as a bit of fuzzing, and I wasn't able to get anywhere useful. Given that, you can consider the external condition to be that there is a large gap (7%) for the attacker to make a profit. Any smaller gap just creates a loss for the LP which is supposed to be hedged and not have losses, but the attacker loses more.\n\n**WangSecurity**\n\nTherefore, based on the comment above, I believe medium severity is appropriate here. Thank you for all the help and work on this issue. Since the escalation proposes it should be invalid, planning to reject the escalation, but downgrade it to medium.\n\nIf you have any other inputs/comments on this, would be glad to hear.\n\n**Evert0x**\n\nResult:\nMedium\nHas Duplicates\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [nirohgo](https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/119/#issuecomment-2041334421): rejected\n\n**sherlock-admin3**\n\nThe Lead Senior Watson signed off on the fix.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/219",
  "Code": [
    {
      "filename": "perp-contract-v3/src/clearingHouse/ClearingHouse.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { FixedPointMathLib } from \"solady/src/utils/FixedPointMathLib.sol\";\nimport { IAddressManager } from \"../addressManager/IAddressManager.sol\";\nimport { AddressResolverUpgradeable } from \"../addressResolver/AddressResolverUpgradeable.sol\";\nimport { LibAddressResolver } from \"../addressResolver/LibAddressResolver.sol\";\nimport { IAddressManager } from \"../addressManager/IAddressManager.sol\";\nimport { LibFormatter } from \"../common/LibFormatter.sol\";\nimport { LibPosition } from \"../vault/LibPosition.sol\";\nimport { LibError } from \"../common/LibError.sol\";\nimport { INTERNAL_DECIMALS, WAD } from \"../common/LibConstant.sol\";\nimport { IMarginProfile, MarginRequirementType } from \"../vault/IMarginProfile.sol\";\nimport { Config } from \"../config/Config.sol\";\nimport { IMaker } from \"../maker/IMaker.sol\";\nimport { AuthorizationUpgradeable } from \"../authorization/AuthorizationUpgradeable.sol\";\nimport { IClearingHouse } from \"./IClearingHouse.sol\";\nimport { IVault } from \"../vault/IVault.sol\";\nimport { PositionChangedReason } from \"../vault/PositionChangedReason.sol\";\nimport { LibLiquidation, MaintenanceMarginProfile, LiquidationResult } from \"./LibLiquidation.sol\";\n\ncontract ClearingHouse is\n    IClearingHouse,\n    AuthorizationUpgradeable,\n    AddressResolverUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20 for IERC20Metadata;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using FixedPointMathLib for uint256;\n    using FixedPointMathLib for int256;\n    using LibFormatter for uint256;\n    using LibAddressResolver for IAddressManager;\n    using LibLiquidation for MaintenanceMarginProfile;\n\n    //\n    // STRUCT\n    //\n\n    struct OpenPositionResult {\n        int256 base;\n        int256 quote;\n        bool isTakerReducing;\n        bool isMakerReducing;\n    }\n\n    struct EmitLiquidatedEventParams {\n        uint256 marketId;\n        address liquidator;\n        address trader;\n        int256 positionSizeDelta;\n        int256 positionNotionalDelta;\n        uint256 price;\n        uint256 penalty;\n        uint256 liquidationFeeToLiquidator;\n        uint256 liquidationFeeToProtocol;\n    }\n\n    struct CheckMarginRequirementParams {\n        IVault vault;\n        uint256 marketId;\n        address trader;\n        uint256 price;\n        bool isReducing;\n    }\n\n    //\n    // MODIFIER\n    //\n    modifier nonZero(uint256 amount) {\n        if (amount == 0) revert LibError.ZeroAmount();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address addressManager) external initializer {\n        __AddressResolver_init(addressManager);\n        __Authorization_init();\n        __ReentrancyGuard_init();\n    }\n\n    /// @inheritdoc IClearingHouse\n    function openPosition(OpenPositionParams calldata params) external returns (int256, int256) {\n        return _openPositionFor(_sender(), params);\n    }\n\n    /// @inheritdoc IClearingHouse\n    function openPositionFor(OpenPositionForParams calldata params) external returns (int256, int256) {\n        _checkIsSenderAuthorizedBy(params.taker);\n        _chargeRelayFee(params.taker, params.takerRelayFee, params.maker, params.makerRelayFee);\n        return\n            _openPositionFor(\n                params.taker,\n                IClearingHouse.OpenPositionParams({\n                    marketId: params.marketId,\n                    maker: params.maker,\n                    isBaseToQuote: params.isBaseToQuote,\n                    isExactInput: params.isExactInput,\n                    amount: params.amount,\n                    oppositeAmountBound: params.oppositeAmountBound,\n                    deadline: params.deadline,\n                    makerData: params.makerData\n                })\n            );\n    }\n\n    /// @inheritdoc IClearingHouse\n    function quoteOpenPosition(OpenPositionParams calldata params) external returns (int256, int256) {\n        address taker = _sender();\n        uint256 price = _getPrice(params.marketId);\n\n        IVault vault = _getVault();\n        OpenPositionResult memory result = _openPosition(vault, taker, params, PositionChangedReason.Trade);\n\n        // Only check maker's margin is sufficient for filling order\n        _checkMarginRequirement(\n            CheckMarginRequirementParams({\n                vault: vault,\n                marketId: params.marketId,\n                trader: params.maker,\n                price: price,\n                isReducing: result.isMakerReducing\n            })\n        );\n\n        revert LibError.QuoteResult(result.base, result.quote);\n    }\n\n    /// @inheritdoc IClearingHouse\n    function closePosition(ClosePositionParams calldata params) external returns (int256, int256) {\n        return _closePositionFor(_sender(), params);\n    }\n\n    /// @inheritdoc IClearingHouse\n    function closePositionFor(ClosePositionForParams calldata params) external returns (int256, int256) {\n        _checkIsSenderAuthorizedBy(params.taker);\n        _chargeRelayFee(params.taker, params.takerRelayFee, params.maker, params.makerRelayFee);\n        return\n            _closePositionFor(\n                params.taker,\n                IClearingHouse.ClosePositionParams({\n                    marketId: params.marketId,\n                    maker: params.maker,\n                    oppositeAmountBound: params.oppositeAmountBound,\n                    deadline: params.deadline,\n                    makerData: params.makerData\n                })\n            );\n    }\n\n    /// @inheritdoc IClearingHouse\n    function liquidate(\n        LiquidatePositionParams calldata params\n    ) external nonZero(params.positionSize) returns (int256, int256) {\n        // We don't allow liquidating whitelisted makers for now until we implement safety mechanism\n        // For spot-hedged base maker, it needs to implement rebalance once it got liquidated\n        if (_isWhitelistedMaker(params.marketId, params.trader)) {\n            revert LibError.CannotLiquidateWhitelistedMaker();\n        }\n\n        // calculate how much size can be liquidated, and how much open notional will be reduced correspondingly\n        address liquidator = _sender();\n        MaintenanceMarginProfile memory mmProfile = _getMaintenanceMarginProfile(\n            params.marketId,\n            params.trader,\n            _getPrice(params.marketId)\n        );\n        LiquidationResult memory result = mmProfile.getLiquidationResult(params.positionSize);\n        if (result.liquidatedPositionSizeDelta == 0) revert LibError.NotLiquidatable(params.marketId, params.trader);\n\n        // settle to vault, pay out liquidation fee to liquidator and protocol\n        IVault vault = _getVault();\n        int256 liquidatorPositionSizeBefore = vault.getPositionSize(params.marketId, liquidator);\n        vault.settlePosition(\n            IVault.SettlePositionParams({\n                marketId: params.marketId,\n                taker: params.trader,\n                maker: liquidator,\n                takerPositionSize: result.liquidatedPositionSizeDelta,\n                takerOpenNotional: result.liquidatedPositionNotionalDelta,\n                reason: PositionChangedReason.Liquidate\n            })\n        );\n        vault.transferMargin(params.marketId, params.trader, liquidator, result.feeToLiquidator);\n        vault.transferMargin(params.marketId, params.trader, address(this), result.feeToProtocol);\n\n        // always check margin in the end\n        _checkMarginRequirement(\n            CheckMarginRequirementParams({\n                vault: vault,\n                marketId: params.marketId,\n                trader: liquidator,\n                price: mmProfile.price,\n                isReducing: LibPosition.isReduceOnly(\n                    liquidatorPositionSizeBefore,\n                    vault.getPositionSize(params.marketId, liquidator)\n                )\n            })\n        );\n        _emitLiquidatedEvent(\n            EmitLiquidatedEventParams({\n                marketId: params.marketId,\n                liquidator: liquidator,\n                trader: params.trader,\n                positionSizeDelta: result.liquidatedPositionSizeDelta,\n                positionNotionalDelta: result.liquidatedPositionNotionalDelta,\n                price: mmProfile.price,\n                penalty: result.penalty,\n                liquidationFeeToLiquidator: result.feeToLiquidator,\n                liquidationFeeToProtocol: result.feeToProtocol\n            })\n        );\n        return (result.liquidatedPositionSizeDelta, result.liquidatedPositionNotionalDelta);\n    }\n\n    /// @dev in the beginning it only open for orderGateway & orderGatewayV2 to be authorized\n    /// @inheritdoc AuthorizationUpgradeable\n    function setAuthorization(address authorized, bool isAuthorized_) public override {\n        IAddressManager addressManager = getAddressManager();\n        if (\n            isAuthorized_ &&\n            authorized != address(addressManager.getOrderGateway()) &&\n            authorized != address(addressManager.getOrderGatewayV2())\n        ) {\n            revert LibError.NotWhitelistedAuthorization();\n        }\n        super.setAuthorization(authorized, isAuthorized_);\n    }\n\n    //\n    // EXTERNAL VIEW\n    //\n\n    /// @dev in order to throw decode error instead of panic, it must be in external call (or contract creation)\n    /// @inheritdoc IClearingHouse\n    function decodeMakerOrder(bytes calldata encoded) external pure returns (MakerOrder memory) {\n        return abi.decode(encoded, (MakerOrder));\n    }\n\n    /// @inheritdoc IClearingHouse\n    function isLiquidatable(uint256 marketId, address trader, uint256 price) external view returns (bool) {\n        return _getLiquidatablePositionSize(marketId, trader, price) != 0;\n    }\n\n    /// @inheritdoc IClearingHouse\n    function getLiquidatablePositionSize(\n        uint256 marketId,\n        address trader,\n        uint256 price\n    ) external view returns (int256) {\n        return _getLiquidatablePositionSize(marketId, trader, price);\n    }\n\n    //\n    // INTERNAL NON-VIEW\n    //\n\n    function _openPosition(\n        IVault vault,\n        address taker,\n        OpenPositionParams memory params,\n        PositionChangedReason reason\n    ) internal nonZero(params.amount) returns (OpenPositionResult memory) {\n        if (block.timestamp > params.deadline) revert LibError.DeadlineExceeded();\n\n        // the amount maker is going to filled. could be base or quote based on taker's isExactInput & isBaseToQuote\n        // currently only open whitelisted maker for callback. other maker must conforms the MakerOrder to quote price\n        uint256 oppositeAmount;\n        bytes memory callbackData;\n        bool hasMakerCallback = _isWhitelistedMaker(params.marketId, params.maker);\n        if (hasMakerCallback) {\n            if (!IMaker(params.maker).isValidSender(msg.sender)) revert LibError.InvalidSender(msg.sender);\n            (oppositeAmount, callbackData) = IMaker(params.maker).fillOrder(\n                params.isBaseToQuote,\n                params.isExactInput,\n                params.amount,\n                params.makerData\n            );\n        } else {\n            // Note that params.maker here could be arbitrary account, so we do allow arbitrary account\n            // to set arbitrary price when fillOrder.\n            // However, we also check margin requirements with oracle price for both taker and maker after openPosition\n            // FIXME: this is not enough, see OrderGatewayV2SettleOrderIntTest.test_SettleOrder_AtExtremePrice()\n            _checkIsSenderAuthorizedBy(params.maker);\n            try this.decodeMakerOrder(params.makerData) returns (MakerOrder memory makerOrder) {\n                oppositeAmount = makerOrder.amount;\n            } catch (bytes memory) {\n                revert LibError.InvalidMakerData();\n            }\n            if (oppositeAmount == 0) revert LibError.InvalidMakerData();\n        }\n\n        // cache position size before mutation in order to detect whether it's reducing position.\n        // caller has more flexibility to react - eg. give it lower margin requirement if it's reducing\n        // NOTE: we assume IMaker.fillOrder() won't change any position state\n        int256 takerPositionSizeBefore = vault.getPositionSize(params.marketId, taker);\n        int256 makerPositionSizeBefore = vault.getPositionSize(params.marketId, params.maker);\n        OpenPositionResult memory result;\n        if (params.isExactInput) {\n            _checkExactInputSlippage(oppositeAmount, params.oppositeAmountBound);\n            if (params.isBaseToQuote) {\n                // exactInput(base) to quote, B2Q base- quote+\n                result.base = -params.amount.toInt256();\n                result.quote = oppositeAmount.toInt256();\n            } else {\n                // exactInput(quote) to base, Q2B base+ quote-\n                result.base = oppositeAmount.toInt256();\n                result.quote = -params.amount.toInt256();\n            }\n        } else {\n            _checkExactOutputSlippage(oppositeAmount, params.oppositeAmountBound);\n            if (params.isBaseToQuote) {\n                // base to exactOutput(quote), B2Q base- quote+\n                result.base = -oppositeAmount.toInt256();\n                result.quote = params.amount.toInt256();\n            } else {\n                // quote to exactOutput(base), Q2B base+ quote-\n                result.base = params.amount.toInt256();\n                result.quote = -oppositeAmount.toInt256();\n            }\n        }\n        _checkPriceBand(params.marketId, result.quote.abs().divWad(result.base.abs()));\n\n        result.isTakerReducing = LibPosition.isReduceOnly(\n            takerPositionSizeBefore,\n            takerPositionSizeBefore + result.base\n        );\n        result.isMakerReducing = LibPosition.isReduceOnly(\n            makerPositionSizeBefore,\n            makerPositionSizeBefore - result.base\n        );\n        vault.settlePosition(\n            IVault.SettlePositionParams({\n                marketId: params.marketId,\n                taker: taker,\n                maker: params.maker,\n                takerPositionSize: result.base,\n                takerOpenNotional: result.quote,\n                reason: reason\n            })\n        );\n\n        if (hasMakerCallback) {\n            IMaker(params.maker).fillOrderCallback(callbackData);\n        }\n        return result;\n    }\n\n    function _openPositionFor(address taker, OpenPositionParams memory params) internal returns (int256, int256) {\n        uint256 marketId = params.marketId;\n        uint256 price = _getPrice(marketId);\n\n        IVault vault = _getVault();\n        OpenPositionResult memory result = _openPosition(vault, taker, params, PositionChangedReason.Trade);\n\n        _checkMarginRequirement(\n            CheckMarginRequirementParams({\n                vault: vault,\n                marketId: marketId,\n                trader: taker,\n                price: price,\n                isReducing: result.isTakerReducing\n            })\n        );\n        _checkMarginRequirement(\n            CheckMarginRequirementParams({\n                vault: vault,\n                marketId: marketId,\n                trader: params.maker,\n                price: price,\n                isReducing: result.isMakerReducing\n            })\n        );\n\n        return (result.base, result.quote);\n    }\n\n    function _closePositionFor(address taker, ClosePositionParams memory params) internal returns (int256, int256) {\n        uint256 marketId = params.marketId;\n        uint256 price = _getPrice(marketId);\n        IVault vault = _getVault();\n        int256 positionSize = vault.getPositionSize(marketId, taker);\n        bool isBaseToQuote = positionSize > 0;\n        OpenPositionParams memory openPositionParams = OpenPositionParams({\n            marketId: marketId,\n            maker: params.maker,\n            isBaseToQuote: isBaseToQuote,\n            isExactInput: isBaseToQuote,\n            amount: positionSize.abs(),\n            oppositeAmountBound: params.oppositeAmountBound,\n            deadline: params.deadline,\n            makerData: params.makerData\n        });\n        OpenPositionResult memory result = _openPosition(vault, taker, openPositionParams, PositionChangedReason.Trade);\n\n        _checkMarginRequirement(\n            CheckMarginRequirementParams({\n                vault: vault,\n                marketId: marketId,\n                trader: taker,\n                price: price,\n                isReducing: result.isTakerReducing\n            })\n        );\n        _checkMarginRequirement(\n            CheckMarginRequirementParams({\n                vault: vault,\n                marketId: marketId,\n                trader: params.maker,\n                price: price,\n                isReducing: result.isMakerReducing\n            })\n        );\n\n        return (result.base, result.quote);\n    }\n\n    /// @dev caller must ensure sender is already authorized by taker. we won't check sender's auth here because relay\n    /// fee only comes from open/closePositionFor which already checked taker's auth\n    function _chargeRelayFee(address taker, uint256 takerRelayFee, address maker, uint256 makerRelayFee) internal {\n        IVault vault = _getVault();\n        if (takerRelayFee > 0) {\n            _checkRelayFee(taker, takerRelayFee);\n            vault.transferFund(taker, msg.sender, takerRelayFee);\n        }\n        if (makerRelayFee > 0) {\n            _checkIsSenderAuthorizedBy(maker);\n            _checkRelayFee(maker, makerRelayFee);\n            vault.transferFund(maker, msg.sender, makerRelayFee);\n        }\n    }\n\n    /// @dev extract to a function for mitigating stack too deep error\n    function _emitLiquidatedEvent(EmitLiquidatedEventParams memory params) internal {\n        emit Liquidated(\n            params.marketId,\n            params.liquidator,\n            params.trader,\n            params.positionSizeDelta,\n            params.positionNotionalDelta,\n            params.price,\n            params.penalty,\n            params.liquidationFeeToLiquidator,\n            params.liquidationFeeToProtocol\n        );\n    }\n\n    //\n    // INTERNAL VIEW\n    //\n\n    /// @notice trade price must be within the price band, which is the oracle price +/- priceBandRatio\n    function _checkPriceBand(uint256 marketId, uint256 tradePrice) internal view {\n        IAddressManager addressManager = getAddressManager();\n        Config config = addressManager.getConfig();\n        uint256 priceBandRatio = config.getPriceBandRatio(marketId);\n        if (priceBandRatio == 0) {\n            return;\n        }\n        bytes32 priceFeedId = config.getPriceFeedId(marketId);\n        (uint256 oraclePrice, ) = addressManager.getPythOracleAdapter().getPrice(priceFeedId);\n        uint256 upperPrice = oraclePrice.mulWad(WAD + priceBandRatio);\n        uint256 lowerPrice = oraclePrice.mulWad(WAD - priceBandRatio);\n        if (upperPrice < tradePrice || tradePrice < lowerPrice) {\n            revert LibError.PriceOutOfBound(tradePrice, lowerPrice, upperPrice);\n        }\n    }\n\n    function _checkIsSenderAuthorizedBy(address onBehalf) internal view {\n        if (!isAuthorized(onBehalf, msg.sender)) revert LibError.AuthorizerNotAllow(onBehalf, msg.sender);\n    }\n\n    function _checkRelayFee(address trader, uint256 relayFee) internal view {\n        Config config = getAddressManager().getConfig();\n        uint256 maxRelayFee = config.getMaxRelayFee();\n        if (relayFee > maxRelayFee) revert LibError.ExcessiveRelayFee(trader, msg.sender, relayFee, maxRelayFee);\n    }\n\n    function _checkMarginRequirement(CheckMarginRequirementParams memory params) internal view {\n        // When increasing position:\n        //   tradableCollateral(imRatio) must >= 0\n        // When reducing position:\n        //   tradableCollateral(mmRatio) must >= 0\n        // When closing position:\n        //   tradableCollateral(*) must >= 0 (*: it doesn't matter what ratio we put in because there are no positions remaining after close)\n        IVault vault = params.vault;\n        uint256 marketId = params.marketId;\n        address trader = params.trader;\n        uint256 price = params.price;\n        if (params.isReducing) {\n            // Reducing, Closing positions can share the same logic for now.\n            int256 freeCollateralForReducingPosition = vault.getFreeCollateralForTrade(\n                marketId,\n                trader,\n                price,\n                MarginRequirementType.MAINTENANCE\n            );\n            if (freeCollateralForReducingPosition < 0) {\n                revert LibError.NotEnoughFreeCollateral(marketId, trader);\n            }\n            return;\n        }\n\n        // is NOT reducing\n        // Note that freeCollateralForOpen = tradableCollateral(imRatio)\n        int256 freeCollateralForIncreasingPosition = vault.getFreeCollateralForTrade(\n            marketId,\n            trader,\n            price,\n            MarginRequirementType.INITIAL\n        );\n        if (freeCollateralForIncreasingPosition < 0) {\n            revert LibError.NotEnoughFreeCollateral(marketId, trader);\n        }\n    }\n\n    function _getVault() internal view returns (IVault) {\n        return getAddressManager().getVault();\n    }\n\n    function _getPrice(uint256 marketId) internal view returns (uint256) {\n        IAddressManager addressManager = getAddressManager();\n        (uint256 price, ) = addressManager.getPythOracleAdapter().getPrice(\n            addressManager.getConfig().getPriceFeedId(marketId)\n        );\n        return price;\n    }\n\n    function _isWhitelistedMaker(uint256 marketId, address trader) internal view returns (bool) {\n        return getAddressManager().getConfig().isWhitelistedMaker(marketId, trader);\n    }\n\n    function _getLiquidatablePositionSize(\n        uint256 marketId,\n        address trader,\n        uint256 price\n    ) internal view returns (int256) {\n        MaintenanceMarginProfile memory mmProfile = _getMaintenanceMarginProfile(marketId, trader, price);\n        return mmProfile.getLiquidatablePositionSize();\n    }\n\n    function _getMaintenanceMarginProfile(\n        uint256 marketId,\n        address trader,\n        uint256 price\n    ) internal view returns (MaintenanceMarginProfile memory) {\n        IAddressManager addressManager = getAddressManager();\n        IVault vault = addressManager.getVault();\n        int256 positionSize = vault.getPositionSize(marketId, trader);\n        int256 openNotional = vault.getOpenNotional(marketId, trader);\n        int256 maintenanceMarginRequirement = vault\n            .getMarginRequirement(marketId, trader, MarginRequirementType.MAINTENANCE)\n            .toInt256();\n        int256 accountValue = vault.getAccountValue(marketId, trader, price);\n\n        Config config = addressManager.getConfig();\n        uint256 liquidationFeeRatio = config.getLiquidationFeeRatio(marketId);\n        uint256 liquidationPenaltyRatio = config.getLiquidationPenaltyRatio(marketId);\n        return\n            MaintenanceMarginProfile({\n                price: price,\n                positionSize: positionSize,\n                openNotional: openNotional,\n                maintenanceMarginRequirement: maintenanceMarginRequirement,\n                accountValue: accountValue,\n                liquidationFeeRatio: liquidationFeeRatio,\n                liquidationPenaltyRatio: liquidationPenaltyRatio\n            });\n    }\n\n    //\n    // INTERNAL PURE\n    //\n    function _checkExactInputSlippage(uint256 actual, uint256 target) internal pure {\n        // want more output as possible, so we set a lower bound of output\n        if (actual < target) {\n            revert LibError.InsufficientOutputAmount(actual, target);\n        }\n    }\n\n    function _checkExactOutputSlippage(uint256 actual, uint256 target) internal pure {\n        // want less input as possible, so we set a upper bound of input\n        if (actual > target) {\n            revert LibError.ExcessiveInputAmount(actual, target);\n        }\n    }\n}"
    },
    {
      "filename": "perp-contract-v3/src/clearingHouse/ClearingHouse.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { FixedPointMathLib } from \"solady/src/utils/FixedPointMathLib.sol\";\nimport { IAddressManager } from \"../addressManager/IAddressManager.sol\";\nimport { AddressResolverUpgradeable } from \"../addressResolver/AddressResolverUpgradeable.sol\";\nimport { LibAddressResolver } from \"../addressResolver/LibAddressResolver.sol\";\nimport { IAddressManager } from \"../addressManager/IAddressManager.sol\";\nimport { LibFormatter } from \"../common/LibFormatter.sol\";\nimport { LibPosition } from \"../vault/LibPosition.sol\";\nimport { LibError } from \"../common/LibError.sol\";\nimport { INTERNAL_DECIMALS, WAD } from \"../common/LibConstant.sol\";\nimport { IMarginProfile, MarginRequirementType } from \"../vault/IMarginProfile.sol\";\nimport { Config } from \"../config/Config.sol\";\nimport { IMaker } from \"../maker/IMaker.sol\";\nimport { AuthorizationUpgradeable } from \"../authorization/AuthorizationUpgradeable.sol\";\nimport { IClearingHouse } from \"./IClearingHouse.sol\";\nimport { IVault } from \"../vault/IVault.sol\";\nimport { PositionChangedReason } from \"../vault/PositionChangedReason.sol\";\nimport { LibLiquidation, MaintenanceMarginProfile, LiquidationResult } from \"./LibLiquidation.sol\";\n\ncontract ClearingHouse is\n    IClearingHouse,\n    AuthorizationUpgradeable,\n    AddressResolverUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20 for IERC20Metadata;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using FixedPointMathLib for uint256;\n    using FixedPointMathLib for int256;\n    using LibFormatter for uint256;\n    using LibAddressResolver for IAddressManager;\n    using LibLiquidation for MaintenanceMarginProfile;\n\n    //\n    // STRUCT\n    //\n\n    struct OpenPositionResult {\n        int256 base;\n        int256 quote;\n        bool isTakerReducing;\n        bool isMakerReducing;\n    }\n\n    struct EmitLiquidatedEventParams {\n        uint256 marketId;\n        address liquidator;\n        address trader;\n        int256 positionSizeDelta;\n        int256 positionNotionalDelta;\n        uint256 price;\n        uint256 penalty;\n        uint256 liquidationFeeToLiquidator;\n        uint256 liquidationFeeToProtocol;\n    }\n\n    struct CheckMarginRequirementParams {\n        IVault vault;\n        uint256 marketId;\n        address trader;\n        uint256 price;\n        bool isReducing;\n    }\n\n    //\n    // MODIFIER\n    //\n    modifier nonZero(uint256 amount) {\n        if (amount == 0) revert LibError.ZeroAmount();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address addressManager) external initializer {\n        __AddressResolver_init(addressManager);\n        __Authorization_init();\n        __ReentrancyGuard_init();\n    }\n\n    /// @inheritdoc IClearingHouse\n    function openPosition(OpenPositionParams calldata params) external returns (int256, int256) {\n        return _openPositionFor(_sender(), params);\n    }\n\n    /// @inheritdoc IClearingHouse\n    function openPositionFor(OpenPositionForParams calldata params) external returns (int256, int256) {\n        _checkIsSenderAuthorizedBy(params.taker);\n        _chargeRelayFee(params.taker, params.takerRelayFee, params.maker, params.makerRelayFee);\n        return\n            _openPositionFor(\n                params.taker,\n                IClearingHouse.OpenPositionParams({\n                    marketId: params.marketId,\n                    maker: params.maker,\n                    isBaseToQuote: params.isBaseToQuote,\n                    isExactInput: params.isExactInput,\n                    amount: params.amount,\n                    oppositeAmountBound: params.oppositeAmountBound,\n                    deadline: params.deadline,\n                    makerData: params.makerData\n                })\n            );\n    }\n\n    /// @inheritdoc IClearingHouse\n    function quoteOpenPosition(OpenPositionParams calldata params) external returns (int256, int256) {\n        address taker = _sender();\n        uint256 price = _getPrice(params.marketId);\n\n        IVault vault = _getVault();\n        OpenPositionResult memory result = _openPosition(vault, taker, params, PositionChangedReason.Trade);\n\n        // Only check maker's margin is sufficient for filling order\n        _checkMarginRequirement(\n            CheckMarginRequirementParams({\n                vault: vault,\n                marketId: params.marketId,\n                trader: params.maker,\n                price: price,\n                isReducing: result.isMakerReducing\n            })\n        );\n\n        revert LibError.QuoteResult(result.base, result.quote);\n    }\n\n    /// @inheritdoc IClearingHouse\n    function closePosition(ClosePositionParams calldata params) external returns (int256, int256) {\n        return _closePositionFor(_sender(), params);\n    }\n\n    /// @inheritdoc IClearingHouse\n    function closePositionFor(ClosePositionForParams calldata params) external returns (int256, int256) {\n        _checkIsSenderAuthorizedBy(params.taker);\n        _chargeRelayFee(params.taker, params.takerRelayFee, params.maker, params.makerRelayFee);\n        return\n            _closePositionFor(\n                params.taker,\n                IClearingHouse.ClosePositionParams({\n                    marketId: params.marketId,\n                    maker: params.maker,\n                    oppositeAmountBound: params.oppositeAmountBound,\n                    deadline: params.deadline,\n                    makerData: params.makerData\n                })\n            );\n    }\n\n    /// @inheritdoc IClearingHouse\n    function liquidate(\n        LiquidatePositionParams calldata params\n    ) external nonZero(params.positionSize) returns (int256, int256) {\n        // We don't allow liquidating whitelisted makers for now until we implement safety mechanism\n        // For spot-hedged base maker, it needs to implement rebalance once it got liquidated\n        if (_isWhitelistedMaker(params.marketId, params.trader)) {\n            revert LibError.CannotLiquidateWhitelistedMaker();\n        }\n\n        // calculate how much size can be liquidated, and how much open notional will be reduced correspondingly\n        address liquidator = _sender();\n        MaintenanceMarginProfile memory mmProfile = _getMaintenanceMarginProfile(\n            params.marketId,\n            params.trader,\n            _getPrice(params.marketId)\n        );\n        LiquidationResult memory result = mmProfile.getLiquidationResult(params.positionSize);\n        if (result.liquidatedPositionSizeDelta == 0) revert LibError.NotLiquidatable(params.marketId, params.trader);\n\n        // settle to vault, pay out liquidation fee to liquidator and protocol\n        IVault vault = _getVault();\n        int256 liquidatorPositionSizeBefore = vault.getPositionSize(params.marketId, liquidator);\n        vault.settlePosition(\n            IVault.SettlePositionParams({\n                marketId: params.marketId,\n                taker: params.trader,\n                maker: liquidator,\n                takerPositionSize: result.liquidatedPositionSizeDelta,\n                takerOpenNotional: result.liquidatedPositionNotionalDelta,\n                reason: PositionChangedReason.Liquidate\n            })\n        );\n        vault.transferMargin(params.marketId, params.trader, liquidator, result.feeToLiquidator);\n        vault.transferMargin(params.marketId, params.trader, address(this), result.feeToProtocol);\n\n        // always check margin in the end\n        _checkMarginRequirement(\n            CheckMarginRequirementParams({\n                vault: vault,\n                marketId: params.marketId,\n                trader: liquidator,\n                price: mmProfile.price,\n                isReducing: LibPosition.isReduceOn"
    }
  ]
}