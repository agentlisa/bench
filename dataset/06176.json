{
  "Title": "[G-01] Multiple address mappings can be combined into a single mapping of an address to a struct, where appropriate",
  "Content": "\nWe can combine multiple mappings below into structs. We can then pack the structs by modifying the uint type for the values. This will result in cheaper storage reads since multiple mappings are accessed in functions and those values are now occupying the same storage slot, meaning the slot will become warm after the first `SLOAD`. In addition, when writing to and reading from the struct values, we will avoid a `Gsset (20000 gas)` and `Gcoldsload (2100 gas)`, since multiple struct values are now occupying the same slot.\n\n### `RemoteAddressValidator.sol`: \n\nStruct can be used for `remoteAddressHashes` and `remoteAddresses` since they are using same `string` as key. Also both mapping always used together in a same functions like `addTrustedAddress()` and `removeTrustedAddress()`. So `struct` is more efficient than `mapping`. As per gas tests, this will save `21018 GAS`.\n\nhttps://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/its/remote-address-validator/RemoteAddressValidator.sol#L15-L16\n\n```diff\nFILE: 2023-07-axelar/contracts/its/remote-address-validator/RemoteAddressValidator.sol\n\n- 15: mapping(string => bytes32) public remoteAddressHashes;\n- 16: mapping(string => string) public remoteAddresses;\n\n+ struct RemoteAddressData {\n+    bytes32 addressHash;\n+    string addressString;\n+ }\n\n+ mapping(string => RemoteAddressData) public remoteAddressData;\n```\n\n```diff\nFILE: Breadcrumbs2023-07-axelar/contracts/its/remote-address-validator/RemoteAddressValidator.sol\n\n15: mapping(string => bytes32) public remoteAddressHashes;\n16: mapping(string => string) public remoteAddresses;\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-07-axelar",
  "Code": [
    {
      "filename": "contracts/its/remote-address-validator/RemoteAddressValidator.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport { IRemoteAddressValidator } from '../interfaces/IRemoteAddressValidator.sol';\nimport { AddressToString } from '../../gmp-sdk/util/AddressString.sol';\nimport { Upgradable } from '../../gmp-sdk/upgradable/Upgradable.sol';\n\n/**\n * @title RemoteAddressValidator\n * @dev Manages and validates remote addresses, keeps track of addresses supported by the Axelar gateway contract\n */\ncontract RemoteAddressValidator is IRemoteAddressValidator, Upgradable {\n    using AddressToString for address;\n\n    mapping(string => bytes32) public remoteAddressHashes;\n    mapping(string => string) public remoteAddresses;\n    address public immutable interchainTokenServiceAddress;\n    bytes32 public immutable interchainTokenServiceAddressHash;\n    mapping(string => bool) public supportedByGateway;\n\n    bytes32 private constant CONTRACT_ID = keccak256('remote-address-validator');\n\n    /**\n     * @dev Constructs the RemoteAddressValidator contract, both array parameters must be equal in length\n     * @param _interchainTokenServiceAddress Address of the interchain token service\n     */\n    constructor(address _interchainTokenServiceAddress) {\n        if (_interchainTokenServiceAddress == address(0)) revert ZeroAddress();\n        interchainTokenServiceAddress = _interchainTokenServiceAddress;\n        interchainTokenServiceAddressHash = keccak256(bytes(_lowerCase(interchainTokenServiceAddress.toString())));\n    }\n\n    /**\n     * @notice Getter for the contract id.\n     */\n    function contractId() external pure returns (bytes32) {\n        return CONTRACT_ID;\n    }\n\n    function _setup(bytes calldata params) internal override {\n        (string[] memory trustedChainNames, string[] memory trustedAddresses) = abi.decode(params, (string[], string[]));\n        uint256 length = trustedChainNames.length;\n        if (length != trustedAddresses.length) revert LengthMismatch();\n        for (uint256 i; i < length; ++i) {\n            addTrustedAddress(trustedChainNames[i], trustedAddresses[i]);\n        }\n    }\n\n    /**\n     * @dev Converts a string to lower case\n     * @param s Input string to be converted\n     * @return string lowercase version of the input string\n     */\n    function _lowerCase(string memory s) internal pure returns (string memory) {\n        uint256 length = bytes(s).length;\n        for (uint256 i; i < length; i++) {\n            uint8 b = uint8(bytes(s)[i]);\n            if ((b >= 65) && (b <= 70)) bytes(s)[i] = bytes1(b + uint8(32));\n        }\n        return s;\n    }\n\n    /**\n     * @dev Validates that the sender is a valid interchain token service address\n     * @param sourceChain Source chain of the transaction\n     * @param sourceAddress Source address of the transaction\n     * @return bool true if the sender is validated, false otherwise\n     */\n    function validateSender(string calldata sourceChain, string calldata sourceAddress) external view returns (bool) {\n        string memory sourceAddressLC = _lowerCase(sourceAddress);\n        bytes32 sourceAddressHash = keccak256(bytes(sourceAddressLC));\n        if (sourceAddressHash == interchainTokenServiceAddressHash) {\n            return true;\n        }\n        return sourceAddressHash == remoteAddressHashes[sourceChain];\n    }\n\n    /**\n     * @dev Adds a trusted interchain token service address for the specified chain\n     * @param chain Chain name of the interchain token service\n     * @param addr Interchain token service address to be added\n     */\n    function addTrustedAddress(string memory chain, string memory addr) public onlyOwner {\n        if (bytes(chain).length == 0) revert ZeroStringLength();\n        if (bytes(addr).length == 0) revert ZeroStringLength();\n        remoteAddressHashes[chain] = keccak256(bytes(_lowerCase(addr)));\n        remoteAddresses[chain] = addr;\n        emit TrustedAddressAdded(chain, addr);\n    }\n\n    /**\n     * @dev Removes a trusted interchain token service address\n     * @param chain Chain name of the interchain token service to be removed\n     */\n    function removeTrustedAddress(string calldata chain) external onlyOwner {\n        if (bytes(chain).length == 0) revert ZeroStringLength();\n        remoteAddressHashes[chain] = bytes32(0);\n        remoteAddresses[chain] = '';\n        emit TrustedAddressRemoved(chain);\n    }\n\n    /**\n     * @dev Adds chains that are supported by the Axelar gateway\n     * @param chainNames List of chain names to be added as supported\n     */\n    function addGatewaySupportedChains(string[] calldata chainNames) external onlyOwner {\n        uint256 length = chainNames.length;\n        for (uint256 i; i < length; ++i) {\n            string calldata chainName = chainNames[i];\n            supportedByGateway[chainName] = true;\n            emit GatewaySupportedChainAdded(chainName);\n        }\n    }\n\n    /**\n     * @dev Removes chains that are no longer supported by the Axelar gateway\n     * @param chainNames List of chain names to be removed as supported\n     */\n    function removeGatewaySupportedChains(string[] calldata chainNames) external onlyOwner {\n        uint256 length = chainNames.length;\n        for (uint256 i; i < length; ++i) {\n            string calldata chainName = chainNames[i];\n            supportedByGateway[chainName] = false;\n            emit GatewaySupportedChainRemoved(chainName);\n        }\n    }\n\n    /**\n     * @dev Fetches the interchain token service address for the specified chain\n     * @param chainName Name of the chain\n     * @return remoteAddress Interchain token service address for the specified chain\n     */\n    function getRemoteAddress(string calldata chainName) external view returns (string memory remoteAddress) {\n        remoteAddress = remoteAddresses[chainName];\n        if (bytes(remoteAddress).length == 0) {\n            remoteAddress = interchainTokenServiceAddress.toString();\n        }\n    }\n}"
    }
  ]
}