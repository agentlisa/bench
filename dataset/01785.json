{
  "Title": "3S-LENFT-N13 Throughout codebase: multiple comments fixes",
  "Content": "#### Description\nThere are some typos or missing natspec comments throughout codebase\n\n#### Suggestion\n**WETHGateway**\n- missing natspec comment in [constructor](https://github.com/leNFT/contracts/blob/bb8708ab9ab319f64ef3a45aa549d95755e2afaf/contracts/protocol/WETHGateway.sol#L41-L42)\n- typo in [natspec comment](https://github.com/leNFT/contracts/blob/bb8708ab9ab319f64ef3a45aa549d95755e2afaf/contracts/protocol/WETHGateway.sol#L49)\n- missing [natspec comment](https://github.com/leNFT/contracts/blob/bb8708ab9ab319f64ef3a45aa549d95755e2afaf/contracts/protocol/WETHGateway.sol#L74-L80) for variable genesisNFTid\n\n**VotingEscrow**\n- typo in [natspec comment](https://github.com/leNFT/contracts/blob/master/contracts/protocol/VotingEscrow.sol#L39): \"calimable\" -> \"claimable\"",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/protocol/WETHGateway.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.19;\n\nimport {IWETH} from \"../interfaces/IWETH.sol\";\nimport {ILendingMarket} from \"../interfaces/ILendingMarket.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {ILoanCenter} from \"../interfaces/ILoanCenter.sol\";\nimport {IBribes} from \"../interfaces/IBribes.sol\";\nimport {ISwapRouter} from \"../interfaces/ISwapRouter.sol\";\nimport {ITradingPool} from \"../interfaces/ITradingPool.sol\";\nimport {IERC4626} from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {Trustus} from \"./Trustus/Trustus.sol\";\nimport {IAddressProvider} from \"../interfaces/IAddressProvider.sol\";\nimport {ERC721Holder} from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\n\n/// @title WETHGateway Contract\n/// @author leNFT\n/// @notice This contract is the proxy for ETH interactions with the leNFT protocol\n/// @dev Interacts with the WETH in order to wrap and unwrap ETH\ncontract WETHGateway is ReentrancyGuard, ERC721Holder {\n    IAddressProvider private immutable _addressProvider;\n    IWETH private immutable _weth;\n\n    modifier lendingPoolETH(address lendingPool) {\n        _requireLendingPoolETH(lendingPool);\n        _;\n    }\n\n    modifier loanPoolETH(uint256 loanId) {\n        _requireLoanPoolETH(loanId);\n        _;\n    }\n\n    modifier tradingPoolETH(address tradingPool) {\n        _requireTradingPoolETH(tradingPool);\n        _;\n    }\n\n    /// @notice Constructor for the WETHGateway contract\n    /// @param addressProvider The address of the addressProvider contract\n    constructor(IAddressProvider addressProvider, IWETH weth) {\n        _addressProvider = addressProvider;\n        _weth = weth;\n    }\n\n    /// @notice Deposit ETH in a wETH lending pool\n    /// @param lendingPool Lending pool to deposit intoto\n    function depositLendingPool(\n        address lendingPool\n    ) external payable lendingPoolETH(lendingPool) nonReentrant {\n        // Deposit and approve WETH\n        _weth.deposit{value: msg.value}();\n        _weth.approve(lendingPool, msg.value);\n\n        IERC4626(lendingPool).deposit(msg.value, msg.sender);\n    }\n\n    /// @notice Withdraw ETH from a WETH lending pool\n    /// @param lendingPool Lending pool to withdraw from\n    /// @param amount Amount of ETH to be withdrawn\n    function withdrawLendingPool(\n        address lendingPool,\n        uint256 amount\n    ) external lendingPoolETH(lendingPool) nonReentrant {\n        IERC4626(lendingPool).withdraw(amount, address(this), msg.sender);\n        _weth.withdraw(amount);\n\n        (bool sent, ) = msg.sender.call{value: amount}(\"\");\n        require(sent, \"ETHG:WLP:ETH_TRANSFER_FAILED\");\n    }\n\n    /// @notice Borrow ETH from a WETH lending pool while an NFT as collateral\n    /// @dev NFT approval needs to be given to the LoanCenter contract\n    /// @param amount Amount of ETH to be borrowed\n    /// @param nftAddress Address of the NFT collateral\n    /// @param nftTokenIds Token ids of the NFT(s) collateral\n    /// @param request ID of the collateral price request sent by the trusted server\n    /// @param packet Signed collateral price request sent by the trusted server\n    function borrow(\n        uint256 amount,\n        address nftAddress,\n        uint256[] calldata nftTokenIds,\n        uint256 genesisNFTId,\n        bytes32 request,\n        Trustus.TrustusPacket calldata packet\n    ) external nonReentrant {\n        ILendingMarket market = ILendingMarket(\n            _addressProvider.getLendingMarket()\n        );\n\n        // Transfer the collateral to the WETH Gateway\n        for (uint256 i = 0; i < nftTokenIds.length; i++) {\n            IERC721(nftAddress).safeTransferFrom(\n                msg.sender,\n                address(this),\n                nftTokenIds[i]\n            );\n\n            // Approve the collateral to be moved by the market\n            IERC721(nftAddress).approve(address(market), nftTokenIds[i]);\n        }\n\n        market.borrow(\n            msg.sender,\n            address(_weth),\n            amount,\n            nftAddress,\n            nftTokenIds,\n            genesisNFTId,\n            request,\n            packet\n        );\n\n        // Make sure enough ETH was received\n        assert(_weth.balanceOf(address(this)) == amount);\n\n        _weth.withdraw(amount);\n\n        (bool sent, ) = msg.sender.call{value: amount}(\"\");\n        require(sent, \"ETHG:B:ETH_TRANSFER_FAILED\");\n    }\n\n    /// @notice Repay an an active loan with ETH\n    /// @param loanId The ID of the loan to be paid\n    function repay(uint256 loanId) external payable nonReentrant {\n        ILoanCenter loanCenter = ILoanCenter(_addressProvider.getLoanCenter());\n        address pool = loanCenter.getLoanLendingPool(loanId);\n\n        ILendingMarket market = ILendingMarket(\n            _addressProvider.getLendingMarket()\n        );\n\n        require(\n            IERC4626(pool).asset() == address(_weth),\n            \"ETHG:R:UNDERLYING_NOT_WETH\"\n        );\n\n        // If we are repaying an auctioned loan we also need to pay the auctineer fee\n        uint256 auctioneerFee;\n        if (loanCenter.getLoanState(loanId) == DataTypes.LoanState.Auctioned) {\n            auctioneerFee = loanCenter.getLoanAuctioneerFee(loanId);\n            require(auctioneerFee < msg.value, \"ETHG:R:NO_AUCTIONEER_FEE\");\n            _weth.approve(address(market), auctioneerFee);\n        }\n\n        // Deposit and approve WETH\n        _weth.deposit{value: msg.value}();\n        _weth.approve(pool, msg.value - auctioneerFee);\n\n        // Repay loan\n        market.repay(loanId, msg.value - auctioneerFee);\n    }\n\n    /// @notice Deposit ETH and/or NFTs into a trading pool to provide liquidity\n    /// @param pool The trading pool address\n    /// @param lpType The type of LP\n    /// @param nftIds Token ids of the NFTs to deposit\n    /// @param initialPrice The initial price of the liquidity provider tokens\n    /// @param curve The curve used to calculate the price of the LP tokens\n    /// @param delta The minimum price change to update the curve\n    /// @param fee The fee charged on trades in the pool\n    function depositTradingPool(\n        address pool,\n        DataTypes.LPType lpType,\n        uint256[] calldata nftIds,\n        uint256 initialPrice,\n        address curve,\n        uint256 delta,\n        uint256 fee\n    ) external payable tradingPoolETH(pool) nonReentrant {\n        // Transfer the NFTs to the WETH Gateway and approve them for use\n        IERC721 tradingPoolNFT = IERC721(ITradingPool(pool).getNFT());\n        if (nftIds.length > 0) {\n            for (uint i = 0; i < nftIds.length; i++) {\n                tradingPoolNFT.safeTransferFrom(\n                    msg.sender,\n                    address(this),\n                    nftIds[i]\n                );\n            }\n            tradingPoolNFT.setApprovalForAll(pool, true);\n        }\n\n        // Deposit and approve WETH\n        if (msg.value > 0) {\n            _weth.deposit{value: msg.value}();\n            _weth.approve(pool, msg.value);\n        }\n\n        ITradingPool(pool).addLiquidity(\n            msg.sender,\n            lpType,\n            nftIds,\n            msg.value,\n            initialPrice,\n            curve,\n            delta,\n            fee\n        );\n    }\n\n    /// @notice Withdraw liquidity from a trading pool\n    /// @param pool The trading pool address\n    /// @param lpId The ID of the liquidity provider tokens to withdraw\n    function withdrawTradingPool(\n        address pool,\n        uint256 lpId\n    ) external tradingPoolETH(pool) nonReentrant {\n        // Send LP NFT to this contract\n        IERC721(pool).safeTransferFrom(msg.sender, address(this), lpId);\n\n        // Get LP info so we can send the correct amounts back\n        DataTypes.LiquidityPair memory lp = ITradingPool(pool).getLP(lpId);\n\n        // Remove liquidity\n        ITradingPool(pool).removeLiquidity(lpId);\n\n        // Send NFTs back to the user\n        IERC721 tradingPoolNFT = IERC721(ITradingPool(pool).getNFT());\n        for (uint i = 0; i < lp.nftIds.length; i++) {\n            tradingPoolNFT.safeTransferFrom(\n                address(this),\n                msg.sender,\n                lp.nftIds[i]\n            );\n        }\n\n        // Send ETH back to the user\n        _weth.withdraw(lp.tokenAmount);\n\n        (bool sent, ) = msg.sender.call{value: lp.tokenAmount}(\"\");\n        require(sent, \"ETHG:WTP:ETH_TRANSFER_FAILED\");\n    }\n\n    /// @notice Withdraws liquidity from a trading pool for a batch of liquidity pairs.\n    /// @param pool The address of the trading pool.\n    /// @param lpIds The array of liquidity pair ids to withdraw.\n    function withdrawBatchTradingPool(\n        address pool,\n        uint256[] calldata lpIds\n    ) external tradingPoolETH(pool) nonReentrant {\n        uint256 totalAmount;\n        uint256[][] memory nftIds = new uint256[][](lpIds.length);\n\n        // Send LP NFTs to this contract\n        for (uint i = 0; i < lpIds.length; i++) {\n            IERC721(pool).safeTransferFrom(msg.sender, address(this), lpIds[i]);\n\n            // Get LP info so we can send the correct amounts back\n            DataTypes.LiquidityPair memory lp = ITradingPool(pool).getLP(\n                lpIds[i]\n            );\n\n            // Add up the total amount of ETH to withdraw\n            totalAmount += lp.tokenAmount;\n\n            // Add up the total amount of NFTs to withdraw\n            nftIds[i] = lp.nftIds;\n        }\n\n        // Remove liquidity in batch\n        ITradingPool(pool).removeLiquidityBatch(lpIds);\n\n        // Send NFTs back to the user\n        IERC721 tradingPoolNFT = IERC721(ITradingPool(pool).getNFT());\n        for (uint a = 0; a < nftIds.length; a++) {\n            for (uint b = 0; b < nftIds[a].length; b++) {\n                tradingPoolNFT.safeTransferFrom(\n                    address(this),\n                    msg.sender,\n                    nftIds[a][b]\n                );\n            }\n        }\n\n        // Send ETH back to the user\n        _weth.withdraw(totalAmount);\n\n        (bool sent, ) = msg.sender.call{value: totalAmount}(\"\");\n        require(sent, \"ETHG:WBTP:ETH_TRANSFER_FAILED\");\n    }\n\n    /// @notice Buys NFT from a trading pool by depositing WETH and specifying the NFT ids and maximum price to pay.\n    /// @param pool The address of the trading pool.\n    /// @param nftIds The array of NFT ids to buy.\n    /// @param maximumPrice The maximum amount of ETH to pay for the purchase.\n    function buy(\n        address pool,\n        uint256[] calldata nftIds,\n        uint256 maximumPrice\n    ) external payable tradingPoolETH(pool) nonReentrant {\n        require(msg.value == maximumPrice, \"ETHG:B:VALUE_NOT_MAXIMUM_PRICE\");\n\n        // Deposit and approve WETH\n        _weth.deposit{value: msg.value}();\n        _weth.approve(pool, msg.value);\n\n        uint256 finalPrice = ITradingPool(pool).buy(\n            msg.sender,\n            nftIds,\n            maximumPrice\n        );\n\n        // Send ETH back to the user\n        if (msg.value > finalPrice) {\n            _weth.withdraw(msg.value - finalPrice);\n\n            (bool sent, ) = msg.sender.call{value: msg.value - finalPrice}(\"\");\n            require(sent, \"ETHG:B:ETH_TRANSFER_FAILED\");\n        }\n    }\n\n    /// @notice Sells NFTs against a pool's liquidity pairs, specifying the NFT ids, liquidity pairs, and minimum price expected.\n    /// @param pool The address of the trading pool.\n    /// @param nftIds The array of NFT ids to sell.\n    /// @param liquidityPairs The array of liquidity pair to sell the NFTs against.\n    /// @param minimumPrice The minimum amount of ETH to receive for the sale.\n    function sell(\n        address pool,\n        uint256[] calldata nftIds,\n        uint256[] calldata liquidityPairs,\n        uint256 minimumPrice\n    ) external tradingPoolETH(pool) nonReentrant {\n        // Send NFTs to this contract and approve them for pool use\n        IERC721 tradingPoolNFT = IERC721(ITradingPool(pool).getNFT());\n        for (uint i = 0; i < nftIds.length; i++) {\n            tradingPoolNFT.safeTransferFrom(\n                msg.sender,\n                address(this),\n                nftIds[i]\n            );\n        }\n        tradingPoolNFT.setApprovalForAll(pool, true);\n\n        // Sell NFTs\n        uint256 finalPrice = ITradingPool(pool).sell(\n            address(this),\n            nftIds,\n            liquidityPairs,\n            minimumPrice\n        );\n\n        // Send ETH back to the user\n        _weth.withdraw(finalPrice);\n\n        (bool sent, ) = msg.sender.call{value: finalPrice}(\"\");\n        require(sent, \"ETHG:S:ETH_TRANSFER_FAILED\");\n    }\n\n    /// @notice Swaps NFTs between two trading pools, with one pool acting as the buyer and the other as the seller.\n    /// @param buyPool The address of the buying trading pool.\n    /// @param sellPool The address of the selling trading pool.\n    /// @param buyNftIds The array of NFT ids to buy.\n    /// @param maximumBuyPrice The maximum amount of ETH to pay for the purchase.\n    /// @param sellNftIds The array of NFT ids to sell.\n    /// @param sellLps The array of liquidity pair to sell the NFTs against.\n    /// @param minimumSellPrice The minimum amount of ETH to receive for the sale.\n    function swap(\n        address buyPool,\n        address sellPool,\n        uint256[] calldata buyNftIds,\n        uint256 maximumBuyPrice,\n        uint256[] calldata sellNftIds,\n        uint256[] calldata sellLps,\n        uint256 minimumSellPrice\n    ) external payable nonReentrant {\n        ISwapRouter swapRouter = ISwapRouter(_addressProvider.getSwapRouter());\n\n        require(\n            ITradingPool(buyPool).getToken() == address(_weth),\n            \"ETHG:S:BUY_UNDERLYING_NOT_WETH\"\n        );\n        require(\n            ITradingPool(sellPool).getToken() == address(_weth),\n            \"ETHG:S:SELL_UNDERLYING_NOT_WETH\"\n        );\n\n        // Make sure the msg.value covers the swap\n        if (maximumBuyPrice > minimumSellPrice) {\n            require(\n                msg.value == maximumBuyPrice - minimumSellPrice,\n                \"ETHG:S:INVALID_VALUE\"\n            );\n\n            // Deposit and approve WETH\n            _weth.deposit{value: msg.value}();\n            _weth.approve(address(swapRouter), msg.value);\n        }\n\n        // avoid stack too deep\n        {\n            // Send NFTs to this contract and approve them for pool use\n            IERC721 sellPoolNFT = IERC721(ITradingPool(sellPool).getNFT());\n            for (uint i = 0; i < sellNftIds.length; i++) {\n                sellPoolNFT.safeTransferFrom(\n                    msg.sender,\n                    address(this),\n                    sellNftIds[i]\n                );\n            }\n            sellPoolNFT.setApprovalForAll(sellPool, true);\n        }\n\n        // Swap\n        uint256 returnedAmount = swapRouter.swap(\n            buyPool,\n            sellPool,\n            buyNftIds,\n            maximumBuyPrice,\n            sellNftIds,\n            sellLps,\n            minimumSellPrice\n        );\n\n        // Send NFTs back to the user\n        IERC721 buyPoolNFT = IERC721(ITradingPool(buyPool).getNFT());\n        for (uint i = 0; i < buyNftIds.length; i++) {\n            buyPoolNFT.safeTransferFrom(\n                address(this),\n                msg.sender,\n                buyNftIds[i]\n            );\n        }\n\n        // Send ETH back to the user\n        if (returnedAmount > 0) {\n            _weth.withdraw(returnedAmount);\n            (bool sent, ) = msg.sender.call{value: returnedAmount}(\"\");\n            require(sent, \"ETHG:S:ETH_TRANSFER_FAILED\");\n        }\n    }\n\n    /// @notice Deposits ETH into the bribe contract to be used for bribing.\n    /// @dev Bribe is applied to the next epoch\n    /// @param gauge The address of the gauge to bribe.\n    function depositBribe(address gauge) external payable nonReentrant {\n        address bribes = _addressProvider.getBribes();\n        _weth.deposit{value: msg.value}();\n        _weth.approve(bribes, msg.value);\n        IBribes(bribes).depositBribe(\n            msg.sender,\n            address(_weth),\n            gauge,\n            msg.value\n        );\n    }\n\n    /// @notice Liquidates a loan.\n    /// @param loanId The id of the loan to liquidate.\n    /// @param request The request id of the loan to liquidate.\n    /// @param packet The Trustus packet of the loan to liquidate.\n    function createLiquidationAuction(\n        uint256 loanId,\n        bytes32 request,\n        Trustus.TrustusPacket calldata packet\n    ) external payable loanPoolETH(loanId) nonReentrant {\n        address lendingMarket = _addressProvider.getLendingMarket();\n\n        // Deposit and approve WETH\n        _weth.deposit{value: msg.value}();\n        _weth.approve(lendingMarket, msg.value);\n\n        // Create auction\n        ILendingMarket(lendingMarket).createLiquidationAuction(\n            msg.sender,\n            loanId,\n            msg.value,\n            request,\n            packet\n        );\n    }\n\n    /// @notice Bids on a liquidation auction.\n    /// @param loanId The id of the loan to bid on.\n    function bidLiquidationAuction(\n        uint256 loanId\n    ) external payable loanPoolETH(loanId) nonReentrant {\n        address lendingMarket = _addressProvider.getLendingMarket();\n        // Deposit and approve WETH\n        _weth.deposit{value: msg.value}();\n        _weth.approve(lendingMarket, msg.value);\n\n        // Bid on auction\n        ILendingMarket(lendingMarket).bidLiquidationAuction(\n            msg.sender,\n            loanId,\n            msg.value\n        );\n    }\n\n    function _requireLendingPoolETH(address lendingPool) internal view {\n        require(\n            IERC4626(lendingPool).asset() == address(_weth),\n            \"ETHG:UNDERLYING_NOT_WETH\"\n        );\n    }\n\n    function _requireLoanPoolETH(uint256 loanId) internal view {\n        // Make sure the loan pool asset is WETH\n        require(\n            IERC4626(\n                ILoanCenter(_addressProvider.getLoanCenter())\n                    .getLoanLendingPool(loanId)\n            ).asset() == address(_weth),\n            \"ETHG:UNDERLYING_NOT_WETH\"\n        );\n    }\n\n    function _requireTradingPoolETH(address tradingPool) internal view {\n        require(\n            ITradingPool(tradingPool).getToken() == address(_weth),\n            \"ETHG:UNDERLYING_NOT_WETH\"\n        );\n    }\n\n    // Receive ETH function: Intended to receive ETH from WETH contract\n    receive() external payable {\n        require(msg.sender == address(_weth), \"ETHG:RECEIVE:NOT_WETH\");\n    }\n\n    /**\n     * @dev Revert fallback calls\n     */\n    fallback() external payable {\n        revert(\"ETHG:F:INVALID_CALL\");\n    }\n}"
    },
    {
      "filename": "contracts/protocol/WETHGateway.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.19;\n\nimport {IWETH} from \"../interfaces/IWETH.sol\";\nimport {ILendingMarket} from \"../interfaces/ILendingMarket.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {ILoanCenter} from \"../interfaces/ILoanCenter.sol\";\nimport {IBribes} from \"../interfaces/IBribes.sol\";\nimport {ISwapRouter} from \"../interfaces/ISwapRouter.sol\";\nimport {ITradingPool} from \"../interfaces/ITradingPool.sol\";\nimport {IERC4626} from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {Trustus} from \"./Trustus/Trustus.sol\";\nimport {IAddressProvider} from \"../interfaces/IAddressProvider.sol\";\nimport {ERC721Holder} from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\n\n/// @title WETHGateway Contract\n/// @author leNFT\n/// @notice This contract is the proxy for ETH interactions with the leNFT protocol\n/// @dev Interacts with the WETH in order to wrap and unwrap ETH\ncontract WETHGateway is ReentrancyGuard, ERC721Holder {\n    IAddressProvider private immutable _addressProvider;\n    IWETH private immutable _weth;\n\n    modifier lendingPoolETH(address lendingPool) {\n        _requireLendingPoolETH(lendingPool);\n        _;\n    }\n\n    modifier loanPoolETH(uint256 loanId) {\n        _requireLoanPoolETH(loanId);\n        _;\n    }\n\n    modifier tradingPoolETH(address tradingPool) {\n        _requireTradingPoolETH(tradingPool);\n        _;\n    }\n\n    /// @notice Constructor for the WETHGateway contract\n    /// @param addressProvider The address of the addressProvider contract\n    constructor(IAddressProvider addressProvider, IWETH weth) {\n        _addressProvider = addressProvider;\n        _weth = weth;\n    }\n\n    /// @notice Deposit ETH in a wETH lending pool\n    /// @param lendingPool Lending pool to deposit intoto\n    function depositLendingPool(\n        address lendingPool\n    ) external payable lendingPoolETH(lendingPool) nonReentrant {\n        // Deposit and approve WETH\n        _weth.deposit{value: msg.value}();\n        _weth.approve(lendingPool, msg.value);\n\n        IERC4626(lendingPool).deposit(msg.value, msg.sender);\n    }\n\n    /// @notice Withdraw ETH from a WETH lending pool\n    /// @param lendingPool Lending pool to withdraw from\n    /// @param amount Amount of ETH to be withdrawn\n    function withdrawLendingPool(\n        address lendingPool,\n        uint256 amount\n    ) external lendingPoolETH(lendingPool) nonReentrant {\n        IERC4626(lendingPool).withdraw(amount, address(this), msg.sender);\n        _weth.withdraw(amount);\n\n        (bool sent, ) = msg.sender.call{value: amount}(\"\");\n        require(sent, \"ETHG:WLP:ETH_TRANSFER_FAILED\");\n    }\n\n    /// @notice Borrow ETH from a WETH lending pool while an NFT as collateral\n    /// @dev NFT approval needs to be given to the LoanCenter contract\n    /// @param amount Amount of ETH to be borrowed\n    /// @param nftAddress Address of the NFT collateral\n    /// @param nftTokenIds Token ids of the NFT(s) collateral\n    /// @param request ID of the collateral price request sent by the trusted server\n    /// @param packet Signed collateral price request sent by the trusted server\n    function borrow(\n        uint256 amount,\n        address nftAddress,\n        uint256[] calldata nftTokenIds,\n        uint256 genesisNFTId,\n        bytes32 request,\n        Trustus.TrustusPacket calldata packet\n    ) external nonReentrant {\n        ILendingMarket market = ILendingMarket(\n            _addressProvider.getLendingMarket()\n        );\n\n        // Transfer the collateral to the WETH Gateway\n        for (uint256 i = 0; i < nftTokenIds.length; i++) {\n            IERC721(nftAddress).safeTransferFrom(\n                msg.sender,\n                address(this),\n                nftTokenIds[i]\n            );\n\n            // Approve the collateral to be moved by the market\n            IERC721(nftAddress).approve(address(market), nftTokenIds[i]);\n        }\n\n        market.borrow(\n            msg.sender,\n            address(_weth),\n            amount,\n            nftAddress,\n            nftTokenIds,\n            genesisNFTId,\n            request,\n            packet\n        );\n\n        // Make sure enough ETH was received\n        assert(_weth.balanceOf(address(this)) == amount);\n\n        _weth.withdraw(amount);\n\n        (bool sent, ) = msg.sender.call{value: amount}(\"\");\n        require(sent, \"ETHG:B:ETH_TRANSFER_FAILED\");\n    }\n\n    /// @notice Repay an an active loan with ETH\n    /// @param loanId The ID of the loan to be paid\n    function repay(uint256 loanId) external payable nonReentrant {\n        ILoanCenter loanCenter = ILoanCenter(_addressProvider.getLoanCenter());\n        address pool = loanCenter.getLoanLendingPool(loanId);\n\n        ILendingMarket market = ILendingMarket(\n            _addressProvider.getLendingMarket()\n        );\n\n        require(\n            IERC4626(pool).asset() == address(_weth),\n            \"ETHG:R:UNDERLYING_NOT_WETH\"\n        );\n\n        // If we are repaying an auctioned loan we also need to pay the auctineer fee\n        uint256 auctioneerFee;\n        if (loanCenter.getLoanState(loanId) == DataTypes.LoanState.Auctioned) {\n            auctioneerFee = loanCenter.getLoanAuctioneerFee(loanId);\n            require(auctioneerFee < msg.value, \"ETHG:R:NO_AUCTIONEER_FEE\");\n            _weth.approve(address(market), auctioneerFee);\n        }\n\n        // Deposit and approve WETH\n        _weth.deposit{value: msg.value}();\n        _weth.approve(pool, msg.value - auctioneerFee);\n\n        // Repay loan\n        market.repay(loanId, msg.value - auctioneerFee);\n    }\n\n    /// @notice Deposit ETH and/or NFTs into a trading pool to provide liquidity\n    /// @param pool The trading pool address\n    /// @param lpType The type of LP\n    /// @param nftIds Token ids of the NFTs to deposit\n    /// @param initialPrice The initial price of the liquidity provider tokens\n    /// @param curve The curve used to calculate the price of the LP tokens\n    /// @param delta The minimum price change to update the curve\n    /// @param fee The fee charged on trades in the pool\n    function depositTradingPool(\n        address pool,\n        DataTypes.LPType lpType,\n        uint256[] calldata nftIds,\n        uint256 initialPrice,\n        address curve,\n        uint256 delta,\n        uint256 fee\n    ) external payable tradingPoolETH(pool) nonReentrant {\n        // Transfer the NFTs to the WETH Gateway and approve them for use\n        IERC721 tradingPoolNFT = IERC721(ITradingPool(pool).getNFT());\n        if (nftIds.length > 0) {\n            for (uint i = 0; i < nftIds.length; i++) {\n                tradingPoolNFT.safeTransferFrom(\n                    msg.sender,\n                    address(this),\n                    nftIds[i]\n                );\n            }\n            tradingPoolNFT.setApprovalForAll(pool, true);\n        }\n\n        // Deposit and approve WETH\n        if (msg.value > 0) {\n            _weth.deposit{value: msg.value}();\n            _weth.approve(pool, msg.value);\n        }\n\n        ITradingPool(pool).addLiquidity(\n            msg.sender,\n            lpType,\n            nftIds,\n            msg.value,\n            initialPrice,\n            curve,\n            delta,\n            fee\n        );\n    }\n\n    /// @notice Withdraw liquidity from a trading pool\n    /// @param pool The trading pool address\n    /// @param lpId The ID of the liquidity provider tokens to withdraw\n    function withdrawTradingPool(\n        address pool,\n        uint256 lpId\n    ) external tradingPoolETH(pool) nonReentrant {\n        // Send LP NFT to this contract\n        IERC721(pool).safeTransferFrom(msg.sender, address(this), lpId);\n\n        // Get LP info so we can send the correct amounts back\n        DataTypes.LiquidityPair memory lp = ITradingPool(pool).getLP(lpId);\n\n        // Remove liquidity\n        ITradingPool(pool).removeLiquidity(lpId);\n\n        // Send NFTs back to the user\n        IERC721 tradingPoolNFT = IERC721(ITradingPool(pool).getNFT());\n        for (uint i = 0; i < lp.nftIds.length; i++) {\n            tradingPoolNFT.safeTransferFrom(\n                address(this),\n                msg.sender,\n                lp.nftIds[i]\n            );\n        }\n\n        // Send ETH back to the user\n        _weth.withdraw(lp.tokenAmount);\n\n        (bool sent, ) = msg.sender.call{value: lp.tokenAmount}(\"\");\n        require(sent, \"ETHG:WTP:ETH_TRANSFER_FAILED\");\n    }\n\n    /// @notice Withdraws liquidity from a trading pool for a batch of liquidity pairs.\n    /// @param pool The address of the trading pool.\n    /// @param lpIds The array of liquidity pair ids to withdraw.\n    function withdrawBatchTradingPool(\n        address pool,\n        uint256[] calldata lpIds\n    ) external tradingPoolETH(pool) nonReentrant {\n        uint256 totalAmount;\n        uint256[][] memory nftIds = new uint256[][](lpIds.length);\n\n        // Send LP NFTs to this contract\n        for (uint i = 0; i < lpIds.length; i++) {\n            IERC721(pool).safeTransferFrom(msg.sender, address(this), lpIds[i]);\n\n            // Get LP info so we can send the correct amounts back\n            DataTypes.LiquidityPair memory lp = ITradingPool(pool).getLP(\n                lpIds[i]\n            );\n\n            // Add up the total amount of ETH to withdraw\n            totalAmount += lp.tokenAmount;\n\n            // Add up the total amount of NFTs to withdraw\n            nftIds[i] = lp.nftIds;\n        }\n\n        // Remove liquidity in batch\n        ITradingPool(pool).removeLiquidityBatch(lpIds);\n\n        // Send NFTs back to the user\n        IERC721 tradingPoolNFT = IERC721(ITradingPool(pool).getNFT());\n        for (uint a = 0; a < nftIds.length; a++) {\n            for (uint b = 0; b < nftIds[a].length; b++) {\n                tradingPoolNFT.safeTransferFrom(\n                    address(this),\n                    msg.sender,\n                    nftIds[a][b]\n                );\n            }\n        }\n\n        // Send ETH back to the user\n        _weth.withdraw(totalAmount);\n\n        (bool sent, ) = msg.sender.call{value: totalAmount}(\"\");\n        require(sent, \"ETHG:WBTP:ETH_TRANSFER_FAILED\");\n    }\n\n    /// @notice Buys NFT from a trading pool by depositing WETH and specifying the NFT ids and maximum price to pay.\n    /// @param pool The address of the trading pool.\n    /// @param nftIds The array of NFT ids to buy.\n    /// @param maximumPrice The maximum amount of ETH to pay for the purchase.\n    function buy(\n        address pool,\n        uint256[] calldata nftIds,\n        uint256 maximumPrice\n    ) external payable tradingPoolETH(pool) nonReentrant {\n        require(msg.value == maximumPrice, \"ETHG:B:VALUE_NOT_MAXIMUM_PRICE\");\n\n        // Deposit and approve WETH\n        _weth.deposit{value: msg.value}();\n        _weth.approve(pool, msg.value);\n\n        uint256 finalPrice = ITradingPool(pool).buy(\n            msg.sender,\n            nftIds,\n            maximumPrice\n        );\n\n        // Send ETH back to the user\n        if (msg.value > finalPrice) {\n            _weth.withdraw(msg.value - finalPrice);\n\n            (bool sent, ) = msg.sender.call{value: msg.value - finalPrice}(\"\");\n            require(sent, \"ETHG:B:ETH_TRANSFER_FAILED\");\n        }\n    }\n\n    /// @notice Sells NFTs against a pool's liquidity pairs, specifying the NFT ids, liquidity pairs, and minimum price expected.\n    /// @param pool The address of the trading pool.\n    /// @param nftIds The array of NFT ids to sell.\n    /// @param liquidityPairs The array of liquidity pair to sell the NFTs against.\n    /// @param minimumPrice The minimum amount of ETH to receive for the sale.\n    function sell(\n        address pool,\n        uint256[] calldata nftIds,\n        uint256[] calldata liquidityPairs,\n        uint256 minimumPrice\n    ) external tradingPoolETH(pool) nonReentrant {\n        // Send NFTs to this contract and approve them for pool use\n        IERC721 tradingPoolNFT = IERC721(ITradingPool(pool).getNFT());\n        for (uint i = 0; i < nftIds.length; i++) {\n            tradingPoolNFT.safeTransferFrom(\n                msg.sender,\n                address(this),\n                nftIds[i]\n            );\n        }\n        tradingPoolNFT.setApprovalForAll(pool, true);\n\n        // Sell NFTs\n        uint256 finalPrice = ITradingPool(pool).sell(\n            address(this),\n            nftIds,\n            liquidityPairs,\n            minimumPrice\n        );\n\n        // Send ETH back to the user\n        _weth.withdraw(finalPrice);\n\n        (bool sent, ) = msg.sender.call{value: finalPrice}(\"\");\n        require(sent, \"ETHG:S:ETH_TRANSFER_FAILED\");\n    }\n\n    /// @notice Swaps NFTs between two trading pools, with one pool acting as the buyer and the other as the seller.\n    /// @param buyPool The address of the buying trading pool.\n    /// @param sellPool The address of the selling trading pool.\n    /// @param buyNftIds The array of NFT ids to buy.\n    /// @param maximumBuyPrice The maximum amount of ETH to pay for the purchase.\n    /// @param sellNftIds The array of NFT ids to sell.\n    /// @param sellLps The array of liquidity pair to sell the NFTs against.\n    /// @param minimumSellPrice The minimum amount of ETH to receive for the sale.\n    function swap(\n        address buyPool,\n        address sellPool,\n        uint256[] calldata buyNftIds,\n        uint256 maximumBuyPrice,\n        uint256[] calldata sellNftIds,\n        uint256[] calldata sellLps,\n        uint256 minimumSellPrice\n    ) external payable nonReentrant {\n        ISwapRouter swapRouter = ISwapRouter(_addressProvider.getSwapRouter());\n\n        require(\n            ITradingPool(buyPool).getToken() == address(_weth),\n            \"ETHG:S:BUY_UNDERLYING_NOT_WETH\"\n        );\n        require(\n            ITradingPool(sellPool).getToken() == address(_weth),\n            \"ETHG:S:SELL_UNDERLYING_NOT_"
    }
  ]
}