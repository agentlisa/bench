{
  "Title": "[G-04] State variables can be packed into fewer storage slots",
  "Content": "\nIf variables occupying the same slot are both written the same function or by the constructor, avoids a separate Gsset (20000 gas). Reads of the variables can also be cheaper\n\n*There are 3 instances of this issue:*\n\n```solidity\nFile: convex-platform/contracts/contracts/CrvDepositor.sol   #1\n\n/// @audit Variable ordering with 5 slots instead of the current 6:\n uint256(32):lockIncentive, uint256(32):incentiveCrv, uint256(32):unlockTime, address(20):feeManager, bool(1):cooldown, address(20):daoOperator\n29:       uint256 public lockIncentive = 10; //incentive to users who spend gas to lock crvBpt\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/CrvDepositor.sol#L29>\n\n```solidity\nFile: convex-platform/contracts/contracts/ExtraRewardStashV3.sol   #2\n\n/// @audit Variable ordering with 9 slots instead of the current 10:\n uint256(32):pid, mapping(32):historicalRewards, mapping(32):tokenInfo, address[](32):tokenList, address(20):operator, bool(1):hasRedirected, bool(1):hasCurveRewards, address(20):staker, address(20):gauge, address(20):rewardFactory, address(20):rewardHook\n33:       uint256 public pid;\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ExtraRewardStashV3.sol#L33>\n\n```solidity\nFile: convex-platform/contracts/contracts/Booster.sol   #3\n\n/// @audit Variable ordering with 18 slots instead of the current 19:\n uint256(32):lockIncentive, uint256(32):stakerIncentive, uint256(32):earmarkIncentive, uint256(32):platformFee, mapping(32):feeTokens, user-defined[](32):poolInfo, mapping(32):gaugeMap, address(20):owner, bool(1):isShutdown, address(20):feeManager, address(20):poolManager, address(20):rewardFactory, address(20):stashFactory, address(20):tokenFactory, address(20):rewardArbitrator, address(20):voteDelegate, address(20):treasury, address(20):stakerRewards, address(20):lockRewards\n26:       uint256 public lockIncentive = 825; //incentive to crv stakers\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/Booster.sol#L26>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-05-aura",
  "Code": [
    {
      "filename": "convex-platform/contracts/contracts/CrvDepositor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./Interfaces.sol\";\nimport \"@openzeppelin/contracts-0.6/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-0.6/utils/Address.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol\";\n\n\n/**\n * @title   CrvDepositor\n * @author  ConvexFinance\n * @notice  This is the entry point for CRV > cvxCRV wrapping. It accepts CRV, sends to 'staler'\n *          for depositing into Curves VotingEscrow, and then mints cvxCRV at 1:1 via the 'minter' (cCrv) minus\n *          the lockIncentive (initially 1%) which is used to basically compensate users who call the `lock` function on Curves\n *          system (larger depositors would likely want to lock).\n */\ncontract CrvDepositor{\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address public immutable crvBpt;\n    address public immutable escrow;\n    uint256 private constant MAXTIME = 1 * 364 * 86400;\n    uint256 private constant WEEK = 7 * 86400;\n\n    uint256 public lockIncentive = 10; //incentive to users who spend gas to lock crvBpt\n    uint256 public constant FEE_DENOMINATOR = 10000;\n\n    address public feeManager;\n    address public daoOperator;\n    address public immutable staker;\n    address public immutable minter;\n    uint256 public incentiveCrv = 0;\n    uint256 public unlockTime;\n\n    bool public cooldown;\n\n    /**\n     * @param _staker   CVX VoterProxy (0x989AEb4d175e16225E39E87d0D97A3360524AD80)\n     * @param _minter   cvxCRV token (0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7)\n     * @param _crvBpt   crvBPT for veCRV deposits\n     * @param _escrow   CRV VotingEscrow (0x5f3b5DfEb7B28CDbD7FAba78963EE202a494e2A2)\n     */\n    constructor(\n        address _staker,\n        address _minter,\n        address _crvBpt,\n        address _escrow,\n        address _daoOperator\n    ) public {\n        staker = _staker;\n        minter = _minter;\n        crvBpt = _crvBpt;\n        escrow = _escrow;\n        feeManager = msg.sender;\n        daoOperator = _daoOperator;\n    }\n\n    function setFeeManager(address _feeManager) external {\n        require(msg.sender == feeManager, \"!auth\");\n        feeManager = _feeManager;\n    }\n\n    function setDaoOperator(address _daoOperator) external {\n        require(msg.sender == daoOperator, \"!auth\");\n        daoOperator = _daoOperator;\n    }\n\n    function setFees(uint256 _lockIncentive) external{\n        require(msg.sender==feeManager, \"!auth\");\n\n        if(_lockIncentive >= 0 && _lockIncentive <= 30){\n            lockIncentive = _lockIncentive;\n       }\n    }\n\n    function setCooldown(bool _cooldown) external {\n      require(msg.sender == daoOperator, \"!auth\");\n      cooldown = _cooldown;\n    }\n\n    /**\n     * @notice Called once to deposit the balance of CRV in this contract to the VotingEscrow\n     */\n    function initialLock() external{\n        require(!cooldown, \"cooldown\");\n        require(msg.sender==feeManager, \"!auth\");\n\n        uint256 vecrv = IERC20(escrow).balanceOf(staker);\n        if(vecrv == 0){\n            uint256 unlockAt = block.timestamp + MAXTIME;\n            uint256 unlockInWeeks = (unlockAt/WEEK)*WEEK;\n\n            //release old lock if exists\n            IStaker(staker).release();\n            //create new lock\n            uint256 crvBalanceStaker = IERC20(crvBpt).balanceOf(staker);\n            IStaker(staker).createLock(crvBalanceStaker, unlockAt);\n            unlockTime = unlockInWeeks;\n        }\n    }\n\n    //lock curve\n    function _lockCurve() internal {\n        if(cooldown) {\n          return;\n        }\n\n        uint256 crvBalance = IERC20(crvBpt).balanceOf(address(this));\n        if(crvBalance > 0){\n            IERC20(crvBpt).safeTransfer(staker, crvBalance);\n        }\n        \n        //increase ammount\n        uint256 crvBalanceStaker = IERC20(crvBpt).balanceOf(staker);\n        if(crvBalanceStaker == 0){\n            return;\n        }\n        \n        //increase amount\n        IStaker(staker).increaseAmount(crvBalanceStaker);\n        \n\n        uint256 unlockAt = block.timestamp + MAXTIME;\n        uint256 unlockInWeeks = (unlockAt/WEEK)*WEEK;\n\n        //increase time too if over 2 week buffer\n        if(unlockInWeeks.sub(unlockTime) > 2){\n            IStaker(staker).increaseTime(unlockAt);\n            unlockTime = unlockInWeeks;\n        }\n    }\n\n    /**\n     * @notice Locks the balance of CRV, and gives out an incentive to the caller\n     */\n    function lockCurve() external {\n        require(!cooldown, \"cooldown\");\n        _lockCurve();\n\n        //mint incentives\n        if(incentiveCrv > 0){\n            ITokenMinter(minter).mint(msg.sender,incentiveCrv);\n            incentiveCrv = 0;\n        }\n    }\n\n    /**\n     * @notice Deposit crvBpt for cvxCrv on behalf of another user\n     * @dev    See depositFor(address, uint256, bool, address) \n     */\n    function deposit(uint256 _amount, bool _lock, address _stakeAddress) public {\n        depositFor(msg.sender, _amount, _lock, _stakeAddress);\n    }\n\n    /**\n     * @notice Deposit crvBpt for cvxCrv\n     * @dev    Can locking immediately or defer locking to someone else by paying a fee.\n     *         while users can choose to lock or defer, this is mostly in place so that\n     *         the cvx reward contract isnt costly to claim rewards.\n     * @param _amount        Units of CRV to deposit\n     * @param _lock          Lock now? or pay ~1% to the locker\n     * @param _stakeAddress  Stake in cvxCrv staking?\n     */\n    function depositFor(address to, uint256 _amount, bool _lock, address _stakeAddress) public {\n        require(_amount > 0,\"!>0\");\n        \n        if(_lock){\n            //lock immediately, transfer directly to staker to skip an erc20 transfer\n            IERC20(crvBpt).safeTransferFrom(msg.sender, staker, _amount);\n            _lockCurve();\n            if(incentiveCrv > 0){\n                //add the incentive tokens here so they can be staked together\n                _amount = _amount.add(incentiveCrv);\n                incentiveCrv = 0;\n            }\n        }else{\n            //move tokens here\n            IERC20(crvBpt).safeTransferFrom(msg.sender, address(this), _amount);\n            //defer lock cost to another user\n            uint256 callIncentive = _amount.mul(lockIncentive).div(FEE_DENOMINATOR);\n            _amount = _amount.sub(callIncentive);\n\n            //add to a pool for lock caller\n            incentiveCrv = incentiveCrv.add(callIncentive);\n        }\n\n        bool depositOnly = _stakeAddress == address(0);\n        if(depositOnly){\n            //mint for to\n            ITokenMinter(minter).mint(to,_amount);\n        }else{\n            //mint here \n            ITokenMinter(minter).mint(address(this),_amount);\n            //stake for to\n            IERC20(minter).safeApprove(_stakeAddress,0);\n            IERC20(minter).safeApprove(_stakeAddress,_amount);\n            IRewards(_stakeAddress).stakeFor(to,_amount);\n        }\n    }\n\n    function deposit(uint256 _amount, bool _lock) external {\n        deposit(_amount,_lock,address(0));\n    }\n\n    function depositAll(bool _lock, address _stakeAddress) external{\n        uint256 crvBal = IERC20(crvBpt).balanceOf(msg.sender);\n        deposit(crvBal,_lock,_stakeAddress);\n    }\n}"
    },
    {
      "filename": "convex-platform/contracts/contracts/ExtraRewardStashV3.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./Interfaces.sol\";\nimport \"./interfaces/IRewardHook.sol\";\nimport \"@openzeppelin/contracts-0.6/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-0.6/utils/Address.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol\";\n\n\n/**\n * @title   ExtraRewardStashV3\n * @author  ConvexFinance\n * @notice  ExtraRewardStash for pools added to the Booster to handle extra rewards\n *          that aren't CRV that can be claimed from a gauge.\n *          - v3.0: Support for curve gauge reward redirect\n *            The Booster contract has a function called setGaugeRedirect. This function calls set_rewards_receiver\n *            On the Curve Guage. This tells the Gauge where to send rewards. The Booster crafts the calldata for this\n *            transaction and then calls execute on the VoterProxy which executes this transaction on the Curve Gauge\n *          - v3.1: Support for arbitrary token rewards outside of gauge rewards add \n *            reward hook to pull rewards during claims\n *          - v3.2: Move constuctor to init function for proxy creation\n */\ncontract ExtraRewardStashV3 {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address public immutable crv;\n    uint256 private constant maxRewards = 8;\n\n    uint256 public pid;\n    address public operator;\n    address public staker;\n    address public gauge;\n    address public rewardFactory;\n   \n    mapping(address => uint256) public historicalRewards;\n    bool public hasRedirected;\n    bool public hasCurveRewards;\n\n    struct TokenInfo {\n        address token;\n        address rewardAddress;\n    }\n\n    //use mapping+array so that we dont have to loop check each time setToken is called\n    mapping(address => TokenInfo) public tokenInfo;\n    address[] public tokenList;\n\n    //address to call for reward pulls\n    address public rewardHook;\n  \n    /**\n     * @param _crv CRV token address\n     */\n    constructor(address _crv) public {\n      crv = _crv;\n    }\n\n    /**\n     * @param _pid        Pool ID\n     * @param _operator   Operator (Booster)\n     * @param _staker     Staker (VoterProxy)\n     * @param _gauge      Gauge\n     * @param _rFactory   Reward factory\n     */\n    function initialize(uint256 _pid, address _operator, address _staker, address _gauge, address _rFactory) external {\n        require(gauge == address(0),\"!init\");\n        pid = _pid;\n        operator = _operator;\n        staker = _staker;\n        gauge = _gauge;\n        rewardFactory = _rFactory;\n    }\n\n    function getName() external pure returns (string memory) {\n        return \"ExtraRewardStashV3.2\";\n    }\n\n    function tokenCount() external view returns (uint256){\n        return tokenList.length;\n    }\n\n    /**\n     * @notice  Claim rewards from the gauge\n     * @dev     The Stash's claimRewards function calls claimRewards on the Booster contract\n     *          which calls claimRewards on the VoterProxy which calls claim_rewards on the gauge\n     *          If a RewardHook is set onRewardClaim is also called on that\n     *          Called by Booster earmarkRewards\n     *          Guage rewards are sent directly to this stash even though the Curve method claim_rewards\n     *          is being called by the VoterProxy. This is because Curves guages have the ability to redirect\n     *          rewards to somewhere other than msg.sender. This is setup in Booster setGaugeRedirect\n     */\n    function claimRewards() external returns (bool) {\n        require(msg.sender == operator, \"!operator\");\n\n        //this is updateable from v2 gauges now so must check each time.\n        checkForNewRewardTokens();\n\n        //make sure we're redirected\n        if(!hasRedirected){\n            IDeposit(operator).setGaugeRedirect(pid);\n            hasRedirected = true;\n        }\n\n        if(hasCurveRewards){\n            //claim rewards on gauge for staker\n            //using reward_receiver so all rewards will be moved to this stash\n            IDeposit(operator).claimRewards(pid,gauge);\n        }\n\n        //hook for reward pulls\n        if(rewardHook != address(0)){\n            try IRewardHook(rewardHook).onRewardClaim(){\n            }catch{}\n        }\n        return true;\n    }\n   \n\n    //check if gauge rewards have changed\n    function checkForNewRewardTokens() internal {\n        for(uint256 i = 0; i < maxRewards; i++){\n            address token = ICurveGauge(gauge).reward_tokens(i);\n            if (token == address(0)) {\n                break;\n            }\n            if(!hasCurveRewards){\n                hasCurveRewards = true;\n            }\n            setToken(token);\n        }\n    }\n\n    //register an extra reward token to be handled\n    // (any new incentive that is not directly on curve gauges)\n    function setExtraReward(address _token) external{\n        //owner of booster can set extra rewards\n        require(IDeposit(operator).owner() == msg.sender, \"!owner\");\n        setToken(_token);\n    }\n\n    function setRewardHook(address _hook) external{\n        //owner of booster can set reward hook\n        require(IDeposit(operator).owner() == msg.sender, \"!owner\");\n        rewardHook = _hook;\n    }\n\n\n    /**\n     * @notice  Add a reward token to the token list so it can be claimed\n     * @dev     For each token that is added as a claimable reward a VirtualRewardsPool\n     *          is deployed to handle virtual distribution of tokens \n     */\n    function setToken(address _token) internal {\n        TokenInfo storage t = tokenInfo[_token];\n\n        if(t.token == address(0)){\n            //set token address\n            t.token = _token;\n\n            //check if crv\n            if(_token != crv){\n                //create new reward contract (for NON-crv tokens only)\n                (,,,address mainRewardContract,,) = IDeposit(operator).poolInfo(pid);\n                address rewardContract = IRewardFactory(rewardFactory).CreateTokenRewards(\n                    _token,\n                    mainRewardContract,\n                    address(this));\n                \n                t.rewardAddress = rewardContract;\n            }\n            //add token to list of known rewards\n            tokenList.push(_token);\n        }\n    }\n\n    //pull assigned tokens from staker to stash\n    function stashRewards() external pure returns(bool){\n\n        //after depositing/withdrawing, extra incentive tokens are claimed\n        //but from v3 this is default to off, and this stash is the reward receiver too.\n\n        return true;\n    }\n\n    /**\n     * @notice  Distribute rewards\n     * @dev     Send all CRV to the Booster contract and send all extra token\n     *          rewards to the rewardContract VirtualRewardsPool\n     *          Called by Booster earmarkRewards\n     */\n    function processStash() external returns(bool){\n        require(msg.sender == operator, \"!operator\");\n\n        uint256 tCount = tokenList.length;\n        for(uint i=0; i < tCount; i++){\n            TokenInfo storage t = tokenInfo[tokenList[i]];\n            address token = t.token;\n            if(token == address(0)) continue;\n            \n            uint256 amount = IERC20(token).balanceOf(address(this));\n            if (amount > 0) {\n                historicalRewards[token] = historicalRewards[token].add(amount);\n                if(token == crv){\n                    //if crv, send back to booster to distribute\n                    IERC20(token).safeTransfer(operator, amount);\n                    continue;\n                }\n            \t//add to reward contract\n            \taddress rewards = t.rewardAddress;\n            \tif(rewards == address(0)) continue;\n            \tIERC20(token).safeTransfer(rewards, amount);\n            \tIRewards(rewards).queueNewRewards(amount);\n            }\n        }\n        return true;\n    }\n\n}"
    },
    {
      "filename": "convex-platform/contracts/contracts/Booster.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./Interfaces.sol\";\nimport \"@openzeppelin/contracts-0.6/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-0.6/utils/Address.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol\";\n\n/**\n * @title   Booster\n * @author  ConvexFinance\n * @notice  Main deposit contract; keeps track of pool info & user deposits; distributes rewards.\n * @dev     They say all paths lead to Rome, and the cvxBooster is no different. This is where it all goes down.\n *          It is responsible for tracking all the pools, it collects rewards from all pools and redirects it.\n */\ncontract Booster{\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address public immutable crv;\n    address public immutable voteOwnership;\n    address public immutable voteParameter;\n\n    uint256 public lockIncentive = 825; //incentive to crv stakers\n    uint256 public stakerIncentive = 825; //incentive to native token stakers\n    uint256 public earmarkIncentive = 50; //incentive to users who spend gas to make calls\n    uint256 public platformFee = 0; //possible fee to build treasury\n    uint256 public constant MaxFees = 2500;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n\n    address public owner;\n    address public feeManager;\n    address public poolManager;\n    address public immutable staker;\n    address public immutable minter;\n    address public rewardFactory;\n    address public stashFactory;\n    address public tokenFactory;\n    address public rewardArbitrator;\n    address public voteDelegate;\n    address public treasury;\n    address public stakerRewards; //cvx rewards\n    address public lockRewards; //cvxCrv rewards(crv)\n\n    mapping(address => FeeDistro) public feeTokens;\n    struct FeeDistro {\n        address distro;\n        address rewards;\n        bool active;\n    }\n\n    bool public isShutdown;\n\n    struct PoolInfo {\n        address lptoken;\n        address token;\n        address gauge;\n        address crvRewards;\n        address stash;\n        bool shutdown;\n    }\n\n    //index(pid) -> pool\n    PoolInfo[] public poolInfo;\n    mapping(address => bool) public gaugeMap;\n\n    event Deposited(address indexed user, uint256 indexed poolid, uint256 amount);\n    event Withdrawn(address indexed user, uint256 indexed poolid, uint256 amount);\n\n    event PoolAdded(address lpToken, address gauge, address token, address rewardPool, address stash, uint256 pid);\n    event PoolShutdown(uint256 poolId);\n\n    event OwnerUpdated(address newOwner);\n    event FeeManagerUpdated(address newFeeManager);\n    event PoolManagerUpdated(address newPoolManager);\n    event FactoriesUpdated(address rewardFactory, address stashFactory, address tokenFactory);\n    event ArbitratorUpdated(address newArbitrator);\n    event VoteDelegateUpdated(address newVoteDelegate);\n    event RewardContractsUpdated(address lockRewards, address stakerRewards);\n    event FeesUpdated(uint256 lockIncentive, uint256 stakerIncentive, uint256 earmarkIncentive, uint256 platformFee);\n    event TreasuryUpdated(address newTreasury);\n    event FeeInfoUpdated(address feeDistro, address lockFees, address feeToken);\n    event FeeInfoChanged(address feeDistro, bool active);\n\n    /**\n     * @dev Constructor doing what constructors do. It is noteworthy that\n     *      a lot of basic config is set to 0 - expecting subsequent calls to setFeeInfo etc.\n     * @param _staker                 VoterProxy (locks the crv and adds to all gauges)\n     * @param _minter                 CVX token, or the thing that mints it\n     * @param _crv                    CRV\n     * @param _voteOwnership          Address of the Curve DAO responsible for ownership stuff\n     * @param _voteParameter          Address of the Curve DAO responsible for param updates\n     */\n    constructor(\n        address _staker,\n        address _minter,\n        address _crv,\n        address _voteOwnership,\n        address _voteParameter\n    ) public {\n        staker = _staker;\n        minter = _minter;\n        crv = _crv;\n        voteOwnership = _voteOwnership;\n        voteParameter = _voteParameter;\n        isShutdown = false;\n\n        owner = msg.sender;\n        voteDelegate = msg.sender;\n        feeManager = msg.sender;\n        poolManager = msg.sender;\n        treasury = address(0);\n\n        emit OwnerUpdated(msg.sender);\n        emit VoteDelegateUpdated(msg.sender);\n        emit FeeManagerUpdated(msg.sender);\n        emit PoolManagerUpdated(msg.sender);\n    }\n\n\n    /// SETTER SECTION ///\n\n    /**\n     * @notice Owner is responsible for setting initial config, updating vote delegate and shutting system\n     */\n    function setOwner(address _owner) external {\n        require(msg.sender == owner, \"!auth\");\n        owner = _owner;\n\n        emit OwnerUpdated(_owner);\n    }\n\n    /**\n     * @notice Fee Manager can update the fees (lockIncentive, stakeIncentive, earmarkIncentive, platformFee)\n     */\n    function setFeeManager(address _feeM) external {\n        require(msg.sender == feeManager, \"!auth\");\n        feeManager = _feeM;\n\n        emit FeeManagerUpdated(_feeM);\n    }\n\n    /**\n     * @notice Pool manager is responsible for adding new pools\n     */\n    function setPoolManager(address _poolM) external {\n        require(msg.sender == poolManager, \"!auth\");\n        poolManager = _poolM;\n\n        emit PoolManagerUpdated(_poolM);\n    }\n\n    /**\n     * @notice Factories are used when deploying new pools. Only the stash factory is mutable after init\n     */\n    function setFactories(address _rfactory, address _sfactory, address _tfactory) external {\n        require(msg.sender == owner, \"!auth\");\n\n        //stash factory should be considered more safe to change\n        //updating may be required to handle new types of gauges\n        stashFactory = _sfactory;\n\n        //reward factory only allow this to be called once even if owner\n        //removes ability to inject malicious staking contracts\n        //token factory can also be immutable\n        if(rewardFactory == address(0)){\n            rewardFactory = _rfactory;\n            tokenFactory = _tfactory;\n\n            emit FactoriesUpdated(_rfactory, _sfactory, _tfactory);\n        } else {\n            emit FactoriesUpdated(address(0), _sfactory, address(0));\n        }\n    }\n\n    /**\n     * @notice Arbitrator handles tokens that are used as secondary rewards across multiple pools\n     */\n    function setArbitrator(address _arb) external {\n        require(msg.sender==owner, \"!auth\");\n        rewardArbitrator = _arb;\n\n        emit ArbitratorUpdated(_arb);\n    }\n\n    /**\n     * @notice Vote Delegate has the rights to cast votes on the VoterProxy via the Booster\n     */\n    function setVoteDelegate(address _voteDelegate) external {\n        require(msg.sender==voteDelegate, \"!auth\");\n        voteDelegate = _voteDelegate;\n\n        emit VoteDelegateUpdated(_voteDelegate);\n    }\n\n    /**\n     * @notice Only called once, to set the addresses of cvxCrv (lockRewards) and cvx staking (stakerRewards)\n     */\n    function setRewardContracts(address _rewards, address _stakerRewards) external {\n        require(msg.sender == owner, \"!auth\");\n        \n        //reward contracts are immutable or else the owner\n        //has a means to redeploy and mint cvx via rewardClaimed()\n        if(lockRewards == address(0)){\n            lockRewards = _rewards;\n            stakerRewards = _stakerRewards;\n            emit RewardContractsUpdated(_rewards, _stakerRewards);\n        }\n    }\n\n    /**\n     * @notice Set reward token and claim contract\n     * @dev    This creates a secondary (VirtualRewardsPool) rewards contract for the vcxCrv staking contract\n     */\n    function setFeeInfo(address _feeToken, address _feeDistro) external {\n        require(msg.sender == owner, \"!auth\");\n        require(!isShutdown, \"shutdown\");\n        require(lockRewards != address(0) && rewardFactory != address(0), \"!initialised\");\n\n        require(_feeToken != address(0) && _feeDistro != address(0), \"!addresses\");\n        require(IFeeDistributor(_feeDistro).getTokenTimeCursor(_feeToken) > 0, \"!distro\");\n\n        if(feeTokens[_feeToken].distro == address(0)){\n            require(!gaugeMap[_feeToken], \"!token\");\n\n            // Distributed directly\n            if(_feeToken == crv){\n                feeTokens[crv] = FeeDistro({\n                    distro: _feeDistro,\n                    rewards: lockRewards,\n                    active: true\n                });\n                emit FeeInfoUpdated(_feeDistro, lockRewards, crv);\n            } else {\n                //create a new reward contract for the new token\n                address rewards = IRewardFactory(rewardFactory).CreateTokenRewards(_feeToken, lockRewards, address(this));\n                feeTokens[_feeToken] = FeeDistro({\n                    distro: _feeDistro,\n                    rewards: rewards,\n                    active: true\n                });\n                emit FeeInfoUpdated(_feeDistro, rewards, _feeToken);\n            }\n        } else {\n            feeTokens[_feeToken].distro = _feeDistro;\n            emit FeeInfoUpdated(_feeDistro, address(0), _feeToken);\n        }\n    }\n\n    /**\n     * @notice Allows turning off or on for fee distro\n     */\n    function updateFeeInfo(address _feeToken, bool _active) external {\n        require(msg.sender==owner, \"!auth\");\n\n        require(feeTokens[_feeToken].distro != address(0), \"Fee doesn't exist\");\n\n        feeTokens[_feeToken].active = _active;\n\n        emit FeeInfoChanged(_feeToken, _active);\n    }\n\n    /**\n     * @notice Fee manager can set all the relevant fees\n     * @param _lockFees     % for cvxCrv stakers where 1% == 100\n     * @param _stakerFees   % for CVX stakers where 1% == 100\n     * @param _callerFees   % for whoever calls the claim where 1% == 100\n     * @param _platform     % for \"treasury\" or vlCVX where 1% == 100\n     */\n    function setFees(uint256 _lockFees, uint256 _stakerFees, uint256 _callerFees, uint256 _platform) external{\n        require(msg.sender==feeManager, \"!auth\");\n\n        uint256 total = _lockFees.add(_stakerFees).add(_callerFees).add(_platform);\n        require(total <= MaxFees, \">MaxFees\");\n\n        require(_lockFees >= 300 && _lockFees <= 1500, \"!lockFees\");\n        require(_stakerFees >= 300 && _stakerFees <= 1500, \"!stakerFees\");\n        require(_callerFees >= 10 && _callerFees <= 100, \"!callerFees\");\n        require(_platform <= 200, \"!platform\");\n\n        lockIncentive = _lockFees;\n        stakerIncentive = _stakerFees;\n        earmarkIncentive = _callerFees;\n        platformFee = _platform;\n\n        emit FeesUpdated(_lockFees, _stakerFees, _callerFees, _platform);\n    }\n\n    /**\n     * @notice Set the address of the treasury (i.e. vlCVX)\n     */\n    function setTreasury(address _treasury) external {\n        require(msg.sender==feeManager, \"!auth\");\n        treasury = _treasury;\n\n        emit TreasuryUpdated(_treasury);\n    }\n\n    /// END SETTER SECTION ///\n\n\n    function poolLength() external view returns (uint256) {\n        return poolInfo.length;\n    }\n\n    /**\n     * @notice Called by the PoolManager (i.e. PoolManagerProxy) to add a new pool - creates all the required\n     *         contracts (DepositToken, RewardPool, Stash) and then adds to the list!\n     */\n    function addPool(address _lptoken, address _gauge, uint256 _stashVersion) external returns(bool){\n        require(msg.sender==poolManager && !isShutdown, \"!add\");\n        require(_gauge != address(0) && _lptoken != address(0),\"!param\");\n        require(feeTokens[_gauge].distro == address(0), \"!gauge\");\n\n        //the next pool's pid\n        uint256 pid = poolInfo.length;\n\n        //create a tokenized deposit\n        address token = ITokenFactory(tokenFactory).CreateDepositToken(_lptoken);\n        //create a reward contract for crv rewards\n        address newRewardPool = IRewardFactory(rewardFactory).CreateCrvRewards(pid,token,_lptoken);\n        //create a stash to handle extra incentives\n        address stash = IStashFactory(stashFactory).CreateStash(pid,_gauge,staker,_stashVersion);\n\n        //add the new pool\n        poolInfo.push(\n            PoolInfo({\n                lptoken: _lptoken,\n                token: token,\n                gauge: _gauge,\n                crvRewards: newRewardPool,\n                stash: stash,\n                shutdown: false\n            })\n        );\n        gaugeMap[_gauge] = true;\n        //give stashes access to rewardfactory and voteproxy\n        //   voteproxy so it can grab the incentive tokens off the contract after claiming rewards\n        //   reward factory so that stashes can make new extra reward contracts if a new incentive is added to the gauge\n        if(stash != address(0)){\n            poolInfo[pid].stash = stash;\n            IStaker(staker).setStashAccess(stash,true);\n            IRewardFactory(rewardFactory).setAccess(stash,true);\n        }\n\n        emit PoolAdded(_lptoken, _gauge, token, newRewardPool, stash, pid);\n        return true;\n    }\n\n    /**\n     * @notice Shuts down the pool by withdrawing everything from the gauge to here (can later be\n     *         claimed from depositors by using the withdraw fn) and marking it as shut down\n     */\n    function shutdownPool(uint256 _pid) external returns(bool){\n        require(msg.sender==poolManager, \"!auth\");\n        PoolInfo storage pool = poolInfo[_pid];\n\n        //withdraw from gauge\n        try IStaker(staker).withdrawAll(pool.lptoken,pool.gauge){\n        }catch{}\n\n        pool.shutdown = true;\n        gaugeMap[pool.gauge] = false;\n\n        emit PoolShutdown(_pid);\n        return true;\n    }\n\n    /**\n     * @notice Shuts down the WHOLE SYSTEM by withdrawing all the LP tokens ot here and then allowing\n     *         for subsequent withdrawal by any depositors.\n     */\n    function shutdownSystem() external{\n        require(msg.sender == owner, \"!auth\");\n        isShutdown = true;\n\n        for(uint i=0; i < poolInfo.length; i++){\n            PoolInfo storage pool = poolInfo[i];\n            if (pool.shutdown) continue;\n\n            address token = pool.lptoken;\n            address gauge = pool.gauge;\n\n            //withdraw from gauge\n            try IStaker(staker).withdrawAll(token,gauge){\n                pool.shutdown = true;\n            }catch{}\n        }\n    }\n\n    /**\n     * @notice  Deposits an \"_amount\" to a given gauge (specified by _pid), mints a `DepositToken`\n     *          and subsequently stakes that on Convex BaseRewardPool\n     */\n    function deposit(uint256 _pid, uint256 _amount, bool _stake) public returns(bool){\n        require(!isShutdown,\"shutdown\");\n        PoolInfo storage pool = poolInfo[_pid];\n        require(pool.shutdown == false, \"pool is closed\");\n\n        //send to proxy to stake\n        address lptoken = pool.lptoken;\n        IERC20(lptoken).safeTransferFrom(msg.sender, staker, _amount);\n\n        //stake\n        address gauge = pool.gauge;\n        require(gauge != address(0),\"!gauge setting\");\n        IStaker(staker).deposit(lptoken,gauge);\n\n        //some gauges claim rewards when depositing, stash them in a seperate contract until next claim\n        address stash = pool.stash;\n        if(stash != address(0)){\n            IStash(stash).stashRewards();\n        }\n\n        address token = pool.token;\n        if(_stake){\n            //mint here and send to rewards on user behalf\n            ITokenMinter(token).mint(address(this),_amount);\n            address rewardContract = pool.crvRewards;\n            IERC20(token).safeApprove(rewardContract,0);\n            IERC20(token).safeApprove(rewardContract,_amount);\n            IRewards(rewardContract).stakeFor(msg.sender,_amount);\n        }else{\n            //add user balance directly\n            ITokenMinter(token).mint(msg.sender,_amount);\n        }\n\n        \n        emit Deposited(msg.sender, _pid, _amount);\n        return true;\n    }\n\n    /**\n     * @notice  Deposits all a senders balance to a given gauge (specified by _pid), mints a `DepositToken`\n     *          and subsequently stakes that on Convex BaseRewardPool\n     */\n    function depositAll(uint256 _pid, bool _stake) external returns(bool){\n        address lptoken = poolInfo[_pid].lptoken;\n        uint256 balance = IERC20(lptoken).balanceOf(msg.sender);\n        deposit(_pid,balance,_stake);\n        return true;\n    }\n\n    /**\n     * @notice  Withdraws LP tokens from a given PID (& user).\n     *          1. Burn the cvxLP balance from \"_from\" (implicit balance check)\n     *          2. If pool !shutdown.. withdraw from gauge\n     *          3. If stash, stash rewards\n     *          4. Transfer out the LP tokens\n     */\n    function _withdraw(uint256 _pid, uint256 _amount, address _from, address _to) internal {\n        PoolInfo storage pool = poolInfo[_pid];\n        address lptoken = pool.lptoken;\n        address gauge = pool.gauge;\n\n        //remove lp balance\n        address token = pool.token;\n        ITokenMinter(token).burn(_from,_amount);\n\n        //pull from gauge if not shutdown\n        // if shutdown tokens will be in this contract\n        if (!pool.shutdown) {\n            IStaker(staker).withdraw(lptoken,gauge, _amount);\n        }\n\n        //some gauges claim rewards when withdrawing, stash them in a seperate contract until next claim\n        //do not call if shutdown"
    }
  ]
}