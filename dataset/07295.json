{
  "Title": "[G-02] The result of a function call should be cached rather than re-calling the function",
  "Content": "\n### WithdrawProxy.sol.claim(): Results of VAULT() and asset() should be cached (Saves 434 gas)\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/WithdrawProxy.sol#L240-L287\n\n**Gas benchmarks**\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 4651    | 15745   | 16576 | 22114 |\n| After  | 4854    | 15311   | 16073 | 21304 |\n\n```solidity\nFile: /src/WithdrawProxy.sol\n240:  function claim() public {\n\n247:    if (PublicVault(VAULT()).getCurrentEpoch() < CLAIMABLE_EPOCH()) {\n248:      revert InvalidState(InvalidStates.PROCESS_EPOCH_NOT_COMPLETE);\n249:    }\n\n255:    uint256 balance = ERC20(asset()).balanceOf(address(this)) -\n\n258:    if (balance < s.expected) {\n259:      PublicVault(VAULT()).decreaseYIntercept(\n260:        (s.expected - balance).mulWadDown(1e18 - s.withdrawRatio)\n261:      );\n262:    } else {\n263:      PublicVault(VAULT()).increaseYIntercept(\n264:        (balance - s.expected).mulWadDown(1e18 - s.withdrawRatio)\n265:      );\n266:    }\n\n268:    if (s.withdrawRatio == uint256(0)) {\n269:      ERC20(asset()).safeTransfer(VAULT(), balance);\n270:    } else {\n271:      transferAmount = uint256(s.withdrawRatio).mulDivDown(\n272:        balance,\n273:        10**ERC20(asset()).decimals()\n274:      );\n\n280:      if (balance > 0) {\n281:        ERC20(asset()).safeTransfer(VAULT(), balance);\n282:      }\n283:    }\n284:    s.finalAuctionEnd = 0;\n\n286:    emit Claimed(address(this), transferAmount, VAULT(), balance);\n287:  }\n```\n\n```diff\ndiff --git a/src/WithdrawProxy.sol b/src/WithdrawProxy.sol\nindex 9906ec7..abe0255 100644\n--- a/src/WithdrawProxy.sol\n+++ b/src/WithdrawProxy.sol\n@@ -243,8 +243,10 @@ contract WithdrawProxy is ERC4626Cloned, WithdrawVaultBase {\n     if (s.finalAuctionEnd == 0) {\n       revert InvalidState(InvalidStates.CANT_CLAIM);\n     }\n+    address _vault = VAULT();\n+    address _asset = asset();\n\n-    if (PublicVault(VAULT()).getCurrentEpoch() < CLAIMABLE_EPOCH()) {\n+    if (PublicVault(_vault).getCurrentEpoch() < CLAIMABLE_EPOCH()) {\n       revert InvalidState(InvalidStates.PROCESS_EPOCH_NOT_COMPLETE);\n     }\n     if (block.timestamp < s.finalAuctionEnd) {\n@@ -252,25 +254,25 @@ contract WithdrawProxy is ERC4626Cloned, WithdrawVaultBase {\n     }\n\n     uint256 transferAmount = 0;\n-    uint256 balance = ERC20(asset()).balanceOf(address(this)) -\n+    uint256 balance = ERC20(_asset).balanceOf(address(this)) -\n       s.withdrawReserveReceived; // will never underflow because withdrawReserveReceived is always increased by the transfer amount from the PublicVault\n\n     if (balance < s.expected) {\n-      PublicVault(VAULT()).decreaseYIntercept(\n+      PublicVault(_vault).decreaseYIntercept(\n         (s.expected - balance).mulWadDown(1e18 - s.withdrawRatio)\n       );\n     } else {\n-      PublicVault(VAULT()).increaseYIntercept(\n+      PublicVault(_vault).increaseYIntercept(\n         (balance - s.expected).mulWadDown(1e18 - s.withdrawRatio)\n       );\n     }\n\n     if (s.withdrawRatio == uint256(0)) {\n-      ERC20(asset()).safeTransfer(VAULT(), balance);\n+      ERC20(_asset).safeTransfer(_vault, balance);\n     } else {\n       transferAmount = uint256(s.withdrawRatio).mulDivDown(\n         balance,\n-        10**ERC20(asset()).decimals()\n+        10**ERC20(_asset).decimals()\n       );\n\n       unchecked {\n@@ -278,12 +280,12 @@ contract WithdrawProxy is ERC4626Cloned, WithdrawVaultBase {\n       }\n\n       if (balance > 0) {\n-        ERC20(asset()).safeTransfer(VAULT(), balance);\n+        ERC20(_asset).safeTransfer(_vault, balance);\n       }\n     }\n     s.finalAuctionEnd = 0;\n\n-    emit Claimed(address(this), transferAmount, VAULT(), balance);\n+    emit Claimed(address(this), transferAmount, _vault, balance);\n   }\n\n```\n\n### WithdrawProxy.sol.drain(): Result of asset() should be cached\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/WithdrawProxy.sol#L289-L300\n\n**Saves  177 Gas on average**\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 7268    | 16214   | 16214 | 25160 |\n| After  | 7091    | 16037   | 16037 | 24983 |\n\n```solidity\nFile: /src/WithdrawProxy.sol\n289:  function drain(uint256 amount, address withdrawProxy)\n\n293: {\n294:    uint256 balance = ERC20(asset()).balanceOf(address(this));\n295:    if (amount > balance) {\n296:      amount = balance;\n297:    }\n298:    ERC20(asset()).safeTransfer(withdrawProxy, amount);\n299:    return amount;\n300:  }\n```\n\n```diff\ndiff --git a/src/WithdrawProxy.sol b/src/WithdrawProxy.sol\nindex 9906ec7..03ea25f 100644\n--- a/src/WithdrawProxy.sol\n+++ b/src/WithdrawProxy.sol\n@@ -291,11 +291,12 @@ contract WithdrawProxy is ERC4626Cloned, WithdrawVaultBase {\n     onlyVault\n     returns (uint256)\n   {\n-    uint256 balance = ERC20(asset()).balanceOf(address(this));\n+    address _asset = asset();\n+    uint256 balance = ERC20(_asset).balanceOf(address(this));\n     if (amount > balance) {\n       amount = balance;\n     }\n-    ERC20(asset()).safeTransfer(withdrawProxy, amount);\n+    ERC20(_asset).safeTransfer(withdrawProxy, amount);\n     return amount;\n   }\n\n```\n\n### PublicVault.sol.minDepositAmount(): ERC20(asset()).decimals() should be cached rather than call it twice\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L96-L108\n\n```solidity\nFile: /src/PublicVault.sol\n96:  function minDepositAmount()\n97:    public\n98:    view\n99:    virtual\n100:    override(ERC4626Cloned)\n101:    returns (uint256)\n102:  {\n103:    if (ERC20(asset()).decimals() == uint8(18)) { //@audit: Initial call\n104:      return 100 gwei;\n105:    } else {\n106:      return 10**(ERC20(asset()).decimals() - 1);//@audit: second call\n107:    }\n108:  }\n```\n\n```diff\ndiff --git a/src/PublicVault.sol b/src/PublicVault.sol\nindex 16247ce..c52356e 100644\n--- a/src/PublicVault.sol\n+++ b/src/PublicVault.sol\n@@ -100,10 +100,11 @@ contract PublicVault is VaultImplementation, IPublicVault, ERC4626Cloned {\n     override(ERC4626Cloned)\n     returns (uint256)\n   {\n-    if (ERC20(asset()).decimals() == uint8(18)) {\n+    uint8 _assetDecimals = ERC20(asset()).decimals();\n+    if (_assetDecimals== uint8(18)) {\n       return 100 gwei;\n     } else {\n-      return 10**(ERC20(asset()).decimals() - 1);\n+      return 10**(_assetDecimals - 1);\n     }\n   }\n```\n\n### PublicVault.sol.\\_deployWithdrawProxyIfNotDeployed(): ROUTER() should be cached\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L216-L231\n\n```solidity\nFile: /src/PublicVault.sol\n\n219:    if (s.epochData[epoch].withdrawProxy == address(0)) {\n220:      s.epochData[epoch].withdrawProxy = ClonesWithImmutableArgs.clone(\n221:        IAstariaRouter(ROUTER()).BEACON_PROXY_IMPLEMENTATION(),//@audit: 1st call\n222:        abi.encodePacked(\n223:          address(ROUTER()), // router is the beacon //@audit: 2nd call\n```\n\n```diff\ndiff --git a/src/PublicVault.sol b/src/PublicVault.sol\nindex 16247ce..39b7be6 100644\n--- a/src/PublicVault.sol\n+++ b/src/PublicVault.sol\n@@ -217,10 +217,11 @@ contract PublicVault is VaultImplementation, IPublicVault, ERC4626Cloned {\n     internal\n   {\n     if (s.epochData[epoch].withdrawProxy == address(0)) {\n+      IAstariaRouter _router = ROUTER();\n       s.epochData[epoch].withdrawProxy = ClonesWithImmutableArgs.clone(\n-        IAstariaRouter(ROUTER()).BEACON_PROXY_IMPLEMENTATION(),\n+        IAstariaRouter(_router).BEACON_PROXY_IMPLEMENTATION(),\n         abi.encodePacked(\n-          address(ROUTER()), // router is the beacon\n+          address(_router), // router is the beacon\n           uint8(IAstariaRouter.ImplementationType.WithdrawProxy),\n           asset(), // token\n           address(this), // vault\n```\n\n### PublicVault.sol.processEpoch(): totalAssets() should be cached\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L322-L326\n\n```solidity\nFile: /src/PublicVault.sol\n322:        if (totalAssets() > expected) { //@audit: Initial call\n323:          s.withdrawReserve = (totalAssets() - expected)//@audit: 2nd call\n324:            .mulWadDown(s.liquidationWithdrawRatio)\n325:            .safeCastTo88();\n326:        } else {\n```\n\n```diff\ndiff --git a/src/PublicVault.sol b/src/PublicVault.sol\nindex 16247ce..4f5f6b8 100644\n--- a/src/PublicVault.sol\n+++ b/src/PublicVault.sol\n@@ -317,10 +317,10 @@ contract PublicVault is VaultImplementation, IPublicVault, ERC4626Cloned {\n\n       currentWithdrawProxy.setWithdrawRatio(s.liquidationWithdrawRatio);\n       uint256 expected = currentWithdrawProxy.getExpected();\n-\n-      unchecked {\n-        if (totalAssets() > expected) {\n-          s.withdrawReserve = (totalAssets() - expected)\n+      uint256 _totalAssets = totalAssets();\n+      unchecked {\n+        if (_totalAssets > expected) {\n+          s.withdrawReserve = (_totalAssets - expected)\n             .mulWadDown(s.liquidationWithdrawRatio)\n             .safeCastTo88();\n         } else {\n@@ -330,7 +330,7 @@ contract PublicVault is VaultImplementation, IPublicVault, ERC4626Cloned {\n       _setYIntercept(\n         s,\n         s.yIntercept -\n-          totalAssets().mulDivDown(s.liquidationWithdrawRatio, 1e18)\n+           _totalAssets.mulDivDown(s.liquidationWithdrawRatio, 1e18)\n       );\n       // burn the tokens of the LPs withdrawing\n       _burn(address(this), proxySupply);\n```\n\n### PublicVault.sol.transferWithdrawReserve(): Result of asset() should be cached\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L359-L411\n\n```solidity\nFile: /src/PublicVault.sol\n359:  function transferWithdrawReserve() public {\n\n371:    if (currentWithdrawProxy != address(0)) {\n372:      uint256 withdrawBalance = ERC20(asset()).balanceOf(address(this)); //@audit: Initial call\n\n384:      ERC20(asset()).safeTransfer(currentWithdrawProxy, withdrawBalance);//@audit: second call\n```\n\n### PublicVault.sol.\\_handleStrategistInterestReward(): VAULT_FEE() should be cached\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L597-L609\n\n```solidity\nFile: /src/PublicVault.sol\n602:    if (VAULT_FEE() != uint256(0)) {\n603:      uint256 x = (amount > interestOwing) ? interestOwing : amount;\n604:      uint256 fee = x.mulDivDown(VAULT_FEE(), 10000);\n```\n\n```diff\ndiff --git a/src/PublicVault.sol b/src/PublicVault.sol\nindex 16247ce..c5ceb07 100644\n--- a/src/PublicVault.sol\n+++ b/src/PublicVault.sol\n@@ -599,9 +599,10 @@ contract PublicVault is VaultImplementation, IPublicVault, ERC4626Cloned {\n     uint256 interestOwing,\n     uint256 amount\n   ) internal virtual {\n-    if (VAULT_FEE() != uint256(0)) {\n+    uint256 _vault_fee = VAULT_FEE();\n+    if (_vault_fee != uint256(0)) {\n       uint256 x = (amount > interestOwing) ? interestOwing : amount;\n-      uint256 fee = x.mulDivDown(VAULT_FEE(), 10000);\n+      uint256 fee = x.mulDivDown(_vault_fee, 10000);\n\n```\n\n### VaultImplementation.sol.buyoutLien(): ROUTER() should be cached\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L313-L351\n\n```solidity\nFile: /src/VaultImplementation.sol\n322:    LienToken lienToken = LienToken(address(ROUTER().LIEN_TOKEN())); //@audit: Initial access\n\n334:    ERC20(asset()).safeApprove(address(ROUTER().TRANSFER_PROXY()), buyout);//@audit: 2nd access\n\n343:            lien: ROUTER().validateCommitment({ //@audit: 3rd access\n```\n\n```diff\ndiff --git a/src/VaultImplementation.sol b/src/VaultImplementation.sol\nindex b5ff5d7..659db03 100644\n--- a/src/VaultImplementation.sol\n+++ b/src/VaultImplementation.sol\n@@ -319,7 +319,8 @@ abstract contract VaultImplementation is\n     whenNotPaused\n     returns (ILienToken.Stack[] memory, ILienToken.Stack memory)\n   {\n-    LienToken lienToken = LienToken(address(ROUTER().LIEN_TOKEN()));\n+    IAstariaRouter _ROUTER = ROUTER();\n+    LienToken lienToken = LienToken(address(_ROUTER.LIEN_TOKEN()));\n\n     (uint256 owed, uint256 buyout) = lienToken.getBuyout(stack[position]);\n\n@@ -331,7 +332,7 @@ abstract contract VaultImplementation is\n\n     _validateCommitment(incomingTerms, recipient());\n\n-    ERC20(asset()).safeApprove(address(ROUTER().TRANSFER_PROXY()), buyout);\n+    ERC20(asset()).safeApprove(address(_ROUTER.TRANSFER_PROXY()), buyout);\n\n     return\n       lienToken.buyoutLien(\n@@ -340,7 +341,7 @@ abstract contract VaultImplementation is\n           encumber: ILienToken.LienActionEncumber({\n             amount: owed,\n             receiver: recipient(),\n-            lien: ROUTER().validateCommitment({\n+            lien: _ROUTER.validateCommitment({\n               commitment: incomingTerms,\n               timeToSecondEpochEnd: _timeToSecondEndIfPublic()\n             }),\n```\n\n### VaultImplementation.sol.buyoutLien(): asset() should be cached\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L326-L334\n\n```solidity\nFile: /src/VaultImplementation.sol\n326:    if (buyout > ERC20(asset()).balanceOf(address(this))) { //@audit: asset() Initial call\n\n334:    ERC20(asset()).safeApprove(address(ROUTER().TRANSFER_PROXY()), buyout);//@audit: asset() 2nd call\n```\n\n```diff\ndiff --git a/src/VaultImplementation.sol b/src/VaultImplementation.sol\nindex b5ff5d7..e003f4e 100644\n--- a/src/VaultImplementation.sol\n+++ b/src/VaultImplementation.sol\n@@ -322,8 +322,8 @@ abstract contract VaultImplementation is\n     LienToken lienToken = LienToken(address(ROUTER().LIEN_TOKEN()));\n\n     (uint256 owed, uint256 buyout) = lienToken.getBuyout(stack[position]);\n-\n-    if (buyout > ERC20(asset()).balanceOf(address(this))) {\n+    ERC20 _asset = ERC20(asset());\n+    if (buyout > _asset.balanceOf(address(this))) {\n       revert IVaultImplementation.InvalidRequest(\n         InvalidRequestReason.INSUFFICIENT_FUNDS\n       );\n@@ -331,7 +331,7 @@ abstract contract VaultImplementation is\n\n     _validateCommitment(incomingTerms, recipient());\n\n-    ERC20(asset()).safeApprove(address(ROUTER().TRANSFER_PROXY()), buyout);\n+    _asset.safeApprove(address(ROUTER().TRANSFER_PROXY()), buyout);\n\n     return\n       lienToken.buyoutLien(\n```\n\n### VaultImplementation.sol.\\_handleProtocolFee(): ROUTER() should be cached (happy path)\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L397-L409\n\n```solidity\nFile: /src/VaultImplementation.sol\n397:  function _handleProtocolFee(uint256 amount) internal returns (uint256) {\n398:    address feeTo = ROUTER().feeTo();\n399:    bool feeOn = feeTo != address(0);\n400:    if (feeOn) {\n401:      uint256 fee = ROUTER().getProtocolFee(amount);\n```\n\n```diff\ndiff --git a/src/VaultImplementation.sol b/src/VaultImplementation.sol\nindex b5ff5d7..41ea5ee 100644\n--- a/src/VaultImplementation.sol\n+++ b/src/VaultImplementation.sol\n@@ -395,10 +395,11 @@ abstract contract VaultImplementation is\n   }\n\n   function _handleProtocolFee(uint256 amount) internal returns (uint256) {\n-    address feeTo = ROUTER().feeTo();\n+    IAstariaRouter _ROUTER = ROUTER();\n+    address feeTo = _ROUTER.feeTo();\n     bool feeOn = feeTo != address(0);\n     if (feeOn) {\n-      uint256 fee = ROUTER().getProtocolFee(amount);\n+      uint256 fee = _ROUTER.getProtocolFee(amount);\n\n       unchecked {\n         amount -= fee;\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-01-astaria",
  "Code": [
    {
      "filename": "src/WithdrawProxy.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**                                                     \n*  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗ \n* ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n* ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n* ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n* ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n* ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n*\n* Astaria Labs, Inc\n*/\n\npragma solidity =0.8.17;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\nimport {ERC4626Cloned} from \"gpl/ERC4626-Cloned.sol\";\nimport {WithdrawVaultBase} from \"core/WithdrawVaultBase.sol\";\nimport {IWithdrawProxy} from \"core/interfaces/IWithdrawProxy.sol\";\nimport {PublicVault} from \"core/PublicVault.sol\";\nimport {IERC20Metadata} from \"core/interfaces/IERC20Metadata.sol\";\nimport {IERC4626} from \"core/interfaces/IERC4626.sol\";\n\n/**\n * @title WithdrawProxy\n * @notice This contract collects funds for liquidity providers who are exiting. When a liquidity provider is the first\n * in an epoch to mark that they would like to withdraw their funds, a WithdrawProxy for the liquidity provider's\n * PublicVault is deployed to collect loan repayments until the end of the next epoch. Users are minted WithdrawTokens\n * according to their balance in the protocol which are redeemable 1:1 for the underlying PublicVault asset by the end\n * of the next epoch.\n *\n */\n\ncontract WithdrawProxy is ERC4626Cloned, WithdrawVaultBase {\n  using SafeTransferLib for ERC20;\n  using FixedPointMathLib for uint256;\n  using SafeCastLib for uint256;\n\n  event Claimed(\n    address withdrawProxy,\n    uint256 withdrawProxyAmount,\n    address publicVault,\n    uint256 publicVaultAmount\n  );\n\n  uint256 private constant WITHDRAW_PROXY_SLOT =\n    uint256(keccak256(\"xyz.astaria.WithdrawProxy.storage.location\")) - 1;\n\n  struct WPStorage {\n    uint88 withdrawRatio;\n    uint88 expected; // The sum of the remaining debt (amountOwed) accrued against the NFT at the timestamp when it is liquidated. yIntercept (virtual assets) of a PublicVault are not modified on liquidation, only once an auction is completed.\n    uint40 finalAuctionEnd; // when this is deleted, we know the final auction is over\n    uint256 withdrawReserveReceived; // amount received from PublicVault. The WETH balance of this contract - withdrawReserveReceived = amount received from liquidations.\n  }\n\n  enum InvalidStates {\n    PROCESS_EPOCH_NOT_COMPLETE,\n    FINAL_AUCTION_NOT_OVER,\n    NOT_CLAIMED,\n    CANT_CLAIM\n  }\n  error InvalidState(InvalidStates);\n\n  function minDepositAmount()\n    public\n    view\n    virtual\n    override(ERC4626Cloned)\n    returns (uint256)\n  {\n    return 0;\n  }\n\n  function decimals() public pure override returns (uint8) {\n    return 18;\n  }\n\n  function asset()\n    public\n    pure\n    override(ERC4626Cloned, WithdrawVaultBase)\n    returns (address)\n  {\n    return super.asset();\n  }\n\n  function totalAssets()\n    public\n    view\n    override(ERC4626Cloned, IERC4626)\n    returns (uint256)\n  {\n    return ERC20(asset()).balanceOf(address(this));\n  }\n\n  /**\n   * @notice Public view function to return the name of this WithdrawProxy.\n   * @return The name of this WithdrawProxy.\n   */\n  function name()\n    public\n    view\n    override(IERC20Metadata, WithdrawVaultBase)\n    returns (string memory)\n  {\n    return\n      string(abi.encodePacked(\"AST-WithdrawVault-\", ERC20(asset()).symbol()));\n  }\n\n  /**\n   * @notice Public view function to return the symbol of this WithdrawProxy.\n   * @return The symbol of this WithdrawProxy.\n   */\n  function symbol()\n    public\n    view\n    override(IERC20Metadata, WithdrawVaultBase)\n    returns (string memory)\n  {\n    return\n      string(abi.encodePacked(\"AST-W\", VAULT(), \"-\", ERC20(asset()).symbol()));\n  }\n\n  /**\n   * @notice Mints WithdrawTokens for withdrawing liquidity providers, redeemable by the end of the next epoch.\n   * @param receiver The receiver of the Withdraw Tokens.\n   * @param shares The number of shares to mint.\n   */\n  function mint(uint256 shares, address receiver)\n    public\n    virtual\n    override(ERC4626Cloned, IERC4626)\n    returns (uint256 assets)\n  {\n    require(msg.sender == VAULT(), \"only vault can mint\");\n    _mint(receiver, shares);\n    return shares;\n  }\n\n  function deposit(uint256 assets, address receiver)\n    public\n    virtual\n    override(ERC4626Cloned, IERC4626)\n    returns (uint256 shares)\n  {\n    revert NotSupported();\n  }\n\n  modifier onlyWhenNoActiveAuction() {\n    WPStorage storage s = _loadSlot();\n    // If auction funds have been collected to the WithdrawProxy\n    // but the PublicVault hasn't claimed its share, too much money will be sent to LPs\n    if (s.finalAuctionEnd != 0) {\n      // if finalAuctionEnd is 0, no auctions were added\n      revert InvalidState(InvalidStates.NOT_CLAIMED);\n    }\n    _;\n  }\n\n  function withdraw(\n    uint256 assets,\n    address receiver,\n    address owner\n  )\n    public\n    virtual\n    override(ERC4626Cloned, IERC4626)\n    onlyWhenNoActiveAuction\n    returns (uint256 shares)\n  {\n    return super.withdraw(assets, receiver, owner);\n  }\n\n  /**\n   * @notice Redeem funds collected in the WithdrawProxy.\n   * @param shares The number of WithdrawToken shares to redeem.\n   * @param receiver The receiver of the underlying asset.\n   * @param owner The owner of the WithdrawTokens.\n   * @return assets The amount of the underlying asset redeemed.\n   */\n  function redeem(\n    uint256 shares,\n    address receiver,\n    address owner\n  )\n    public\n    virtual\n    override(ERC4626Cloned, IERC4626)\n    onlyWhenNoActiveAuction\n    returns (uint256 assets)\n  {\n    return super.redeem(shares, receiver, owner);\n  }\n\n  function supportsInterface(bytes4 interfaceId)\n    external\n    view\n    virtual\n    returns (bool)\n  {\n    return interfaceId == type(IWithdrawProxy).interfaceId;\n  }\n\n  function _loadSlot() internal pure returns (WPStorage storage s) {\n    uint256 slot = WITHDRAW_PROXY_SLOT;\n\n    assembly {\n      s.slot := slot\n    }\n  }\n\n  function getFinalAuctionEnd() public view returns (uint256) {\n    WPStorage storage s = _loadSlot();\n    return s.finalAuctionEnd;\n  }\n\n  function getWithdrawRatio() public view returns (uint256) {\n    WPStorage storage s = _loadSlot();\n    return s.withdrawRatio;\n  }\n\n  function getExpected() public view returns (uint256) {\n    WPStorage storage s = _loadSlot();\n    return s.expected;\n  }\n\n  modifier onlyVault() {\n    require(msg.sender == VAULT(), \"only vault can call\");\n    _;\n  }\n\n  function increaseWithdrawReserveReceived(uint256 amount) external onlyVault {\n    WPStorage storage s = _loadSlot();\n    s.withdrawReserveReceived += amount;\n  }\n\n  function claim() public {\n    WPStorage storage s = _loadSlot();\n\n    if (s.finalAuctionEnd == 0) {\n      revert InvalidState(InvalidStates.CANT_CLAIM);\n    }\n\n    if (PublicVault(VAULT()).getCurrentEpoch() < CLAIMABLE_EPOCH()) {\n      revert InvalidState(InvalidStates.PROCESS_EPOCH_NOT_COMPLETE);\n    }\n    if (block.timestamp < s.finalAuctionEnd) {\n      revert InvalidState(InvalidStates.FINAL_AUCTION_NOT_OVER);\n    }\n\n    uint256 transferAmount = 0;\n    uint256 balance = ERC20(asset()).balanceOf(address(this)) -\n      s.withdrawReserveReceived; // will never underflow because withdrawReserveReceived is always increased by the transfer amount from the PublicVault\n\n    if (balance < s.expected) {\n      PublicVault(VAULT()).decreaseYIntercept(\n        (s.expected - balance).mulWadDown(1e18 - s.withdrawRatio)\n      );\n    } else {\n      PublicVault(VAULT()).increaseYIntercept(\n        (balance - s.expected).mulWadDown(1e18 - s.withdrawRatio)\n      );\n    }\n\n    if (s.withdrawRatio == uint256(0)) {\n      ERC20(asset()).safeTransfer(VAULT(), balance);\n    } else {\n      transferAmount = uint256(s.withdrawRatio).mulDivDown(\n        balance,\n        10**ERC20(asset()).decimals()\n      );\n\n      unchecked {\n        balance -= transferAmount;\n      }\n\n      if (balance > 0) {\n        ERC20(asset()).safeTransfer(VAULT(), balance);\n      }\n    }\n    s.finalAuctionEnd = 0;\n\n    emit Claimed(address(this), transferAmount, VAULT(), balance);\n  }\n\n  function drain(uint256 amount, address withdrawProxy)\n    public\n    onlyVault\n    returns (uint256)\n  {\n    uint256 balance = ERC20(asset()).balanceOf(address(this));\n    if (amount > balance) {\n      amount = balance;\n    }\n    ERC20(asset()).safeTransfer(withdrawProxy, amount);\n    return amount;\n  }\n\n  function setWithdrawRatio(uint256 liquidationWithdrawRatio) public onlyVault {\n    _loadSlot().withdrawRatio = liquidationWithdrawRatio.safeCastTo88();\n  }\n\n  function handleNewLiquidation(\n    uint256 newLienExpectedValue,\n    uint256 finalAuctionDelta\n  ) public onlyVault {\n    WPStorage storage s = _loadSlot();\n\n    unchecked {\n      s.expected += newLienExpectedValue.safeCastTo88();\n      uint40 auctionEnd = (block.timestamp + finalAuctionDelta).safeCastTo40();\n      if (auctionEnd > s.finalAuctionEnd) s.finalAuctionEnd = auctionEnd;\n    }\n  }\n}"
    },
    {
      "filename": "src/WithdrawProxy.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**                                                     \n*  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗ \n* ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n* ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n* ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n* ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n* ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n*\n* Astaria Labs, Inc\n*/\n\npragma solidity =0.8.17;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\nimport {ERC4626Cloned} from \"gpl/ERC4626-Cloned.sol\";\nimport {WithdrawVaultBase} from \"core/WithdrawVaultBase.sol\";\nimport {IWithdrawProxy} from \"core/interfaces/IWithdrawProxy.sol\";\nimport {PublicVault} from \"core/PublicVault.sol\";\nimport {IERC20Metadata} from \"core/interfaces/IERC20Metadata.sol\";\nimport {IERC4626} from \"core/interfaces/IERC4626.sol\";\n\n/**\n * @title WithdrawProxy\n * @notice This contract collects funds for liquidity providers who are exiting. When a liquidity provider is the first\n * in an epoch to mark that they would like to withdraw their funds, a WithdrawProxy for the liquidity provider's\n * PublicVault is deployed to collect loan repayments until the end of the next epoch. Users are minted WithdrawTokens\n * according to their balance in the protocol which are redeemable 1:1 for the underlying PublicVault asset by the end\n * of the next epoch.\n *\n */\n\ncontract WithdrawProxy is ERC4626Cloned, WithdrawVaultBase {\n  using SafeTransferLib for ERC20;\n  using FixedPointMathLib for uint256;\n  using SafeCastLib for uint256;\n\n  event Claimed(\n    address withdrawProxy,\n    uint256 withdrawProxyAmount,\n    address publicVault,\n    uint256 publicVaultAmount\n  );\n\n  uint256 private constant WITHDRAW_PROXY_SLOT =\n    uint256(keccak256(\"xyz.astaria.WithdrawProxy.storage.location\")) - 1;\n\n  struct WPStorage {\n    uint88 withdrawRatio;\n    uint88 expected; // The sum of the remaining debt (amountOwed) accrued against the NFT at the timestamp when it is liquidated. yIntercept (virtual assets) of a PublicVault are not modified on liquidation, only once an auction is completed.\n    uint40 finalAuctionEnd; // when this is deleted, we know the final auction is over\n    uint256 withdrawReserveReceived; // amount received from PublicVault. The WETH balance of this contract - withdrawReserveReceived = amount received from liquidations.\n  }\n\n  enum InvalidStates {\n    PROCESS_EPOCH_NOT_COMPLETE,\n    FINAL_AUCTION_NOT_OVER,\n    NOT_CLAIMED,\n    CANT_CLAIM\n  }\n  error InvalidState(InvalidStates);\n\n  function minDepositAmount()\n    public\n    view\n    virtual\n    override(ERC4626Cloned)\n    returns (uint256)\n  {\n    return 0;\n  }\n\n  function decimals() public pure override returns (uint8) {\n    return 18;\n  }\n\n  function asset()\n    public\n    pure\n    override(ERC4626Cloned, WithdrawVaultBase)\n    returns (address)\n  {\n    return super.asset();\n  }\n\n  function totalAssets()\n    public\n    view\n    override(ERC4626Cloned, IERC4626)\n    returns (uint256)\n  {\n    return ERC20(asset()).balanceOf(address(this));\n  }\n\n  /**\n   * @notice Public view function to return the name of this WithdrawProxy.\n   * @return The name of this WithdrawProxy.\n   */\n  function name()\n    public\n    view\n    override(IERC20Metadata, WithdrawVaultBase)\n    returns (string memory)\n  {\n    return\n      string(abi.encodePacked(\"AST-WithdrawVault-\", ERC20(asset()).symbol()));\n  }\n\n  /**\n   * @notice Public view function to return the symbol of this WithdrawProxy.\n   * @return The symbol of this WithdrawProxy.\n   */\n  function symbol()\n    public\n    view\n    override(IERC20Metadata, WithdrawVaultBase)\n    returns (string memory)\n  {\n    return\n      string(abi.encodePacked(\"AST-W\", VAULT(), \"-\", ERC20(asset()).symbol()));\n  }\n\n  /**\n   * @notice Mints WithdrawTokens for withdrawing liquidity providers, redeemable by the end of the next epoch.\n   * @param receiver The receiver of the Withdraw Tokens.\n   * @param shares The number of shares to mint.\n   */\n  function mint(uint256 shares, address receiver)\n    public\n    virtual\n    override(ERC4626Cloned, IERC4626)\n    returns (uint256 assets)\n  {\n    require(msg.sender == VAULT(), \"only vault can mint\");\n    _mint(receiver, shares);\n    return shares;\n  }\n\n  function deposit(uint256 assets, address receiver)\n    public\n    virtual\n    override(ERC4626Cloned, IERC4626)\n    returns (uint256 shares)\n  {\n    revert NotSupported();\n  }\n\n  modifier onlyWhenNoActiveAuction() {\n    WPStorage storage s = _loadSlot();\n    // If auction funds have been collected to the WithdrawProxy\n    // but the PublicVault hasn't claimed its share, too much money will be sent to LPs\n    if (s.finalAuctionEnd != 0) {\n      // if finalAuctionEnd is 0, no auctions were added\n      revert InvalidState(InvalidStates.NOT_CLAIMED);\n    }\n    _;\n  }\n\n  function withdraw(\n    uint256 assets,\n    address receiver,\n    address owner\n  )\n    public\n    virtual\n    override(ERC4626Cloned, IERC4626)\n    onlyWhenNoActiveAuction\n    returns (uint256 shares)\n  {\n    return super.withdraw(assets, receiver, owner);\n  }\n\n  /**\n   * @notice Redeem funds collected in the WithdrawProxy.\n   * @param shares The number of WithdrawToken shares to redeem.\n   * @param receiver The receiver of the underlying asset.\n   * @param owner The owner of the WithdrawTokens.\n   * @return assets The amount of the underlying asset redeemed.\n   */\n  function redeem(\n    uint256 shares,\n    address receiver,\n    address owner\n  )\n    public\n    virtual\n    override(ERC4626Cloned, IERC4626)\n    onlyWhenNoActiveAuction\n    returns (uint256 assets)\n  {\n    return super.redeem(shares, receiver, owner);\n  }\n\n  function supportsInterface(bytes4 interfaceId)\n    external\n    view\n    virtual\n    returns (bool)\n  {\n    return interfaceId == type(IWithdrawProxy).interfaceId;\n  }\n\n  function _loadSlot() internal pure returns (WPStorage storage s) {\n    uint256 slot = WITHDRAW_PROXY_SLOT;\n\n    assembly {\n      s.slot := slot\n    }\n  }\n\n  function getFinalAuctionEnd() public view returns (uint256) {\n    WPStorage storage s = _loadSlot();\n    return s.finalAuctionEnd;\n  }\n\n  function getWithdrawRatio() public view returns (uint256) {\n    WPStorage storage s = _loadSlot();\n    return s.withdrawRatio;\n  }\n\n  function getExpected() public view returns (uint256) {\n    WPStorage storage s = _loadSlot();\n    return s.expected;\n  }\n\n  modifier onlyVault() {\n    require(msg.sender == VAULT(), \"only vault can call\");\n    _;\n  }\n\n  function increaseWithdrawReserveReceived(uint256 amount) external onlyVault {\n    WPStorage storage s = _loadSlot();\n    s.withdrawReserveReceived += amount;\n  }\n\n  function claim() public {\n    WPStorage storage s = _loadSlot();\n\n    if (s.finalAuctionEnd == 0) {\n      revert InvalidState(InvalidStates.CANT_CLAIM);\n    }\n\n    if (PublicVault(VAULT()).getCurrentEpoch() < CLAIMABLE_EPOCH()) {\n      revert InvalidState(InvalidStates.PROCESS_EPOCH_NOT_COMPLETE);\n    }\n    if (block.timestamp < s.finalAuctionEnd) {\n      revert InvalidState(InvalidStates.FINAL_AUCTION_NOT_OVER);\n    }\n\n    uint256 transferAmount = 0;\n    uint256 balance = ERC20(asset()).balanceOf(address(this)) -\n      s.withdrawReserveReceived; // will never underflow because withdrawReserveReceived is always increased by the transfer amount from the PublicVault\n\n    if (balance < s.expected) {\n      PublicVault(VAULT()).decreaseYIntercept(\n        (s.expected - balance).mulWadDown(1e18 - s.withdrawRatio)\n      );\n    } else {\n      PublicVault(VAULT()).increaseYIntercept(\n        (balance - s.expected).mulWadDown(1e18 - s.withdrawRatio)\n      );\n    }\n\n    if (s.withdrawRatio == uint256(0)) {\n      ERC20(asset()).safeTransfer(VAULT(), balance);\n    } else {\n      transferAmount = uint256(s.withdrawRatio).mulDivDown(\n        balance,\n        10**ERC20(asset()).decimals()\n      );\n\n      unchecked {\n        balance -= transferAmount;\n      }\n\n      if (balance > 0) {\n        ERC20(asset()).safeTransfer(VAULT(), balance);\n      }\n    }\n    s.finalAuctionEnd = 0;\n\n    emit Claimed(address(this), transferAmount, VAULT(), balance);\n  }\n\n  function drain(uint256 amount, address withdrawProxy)\n    public\n    onlyVault\n    returns (uint256)\n  {\n    uint256 balance = ERC20(asset()).balanceOf(address(this));\n    if (amount > balance) {\n      amount = balance;\n    }\n    ERC20(asset()).safeTransfer(withdrawProxy, amount);\n    return amount;\n  }\n\n  function setWithdrawRatio(uint256 liquidationWithdrawRatio) public onlyVault {\n    _loadSlot().withdrawRatio = liquidationWithdrawRatio.safeCastTo88();\n  }\n\n  function handleNewLiquidation(\n    uint256 newLienExpectedValue,\n    uint256 finalAuctionDelta\n  ) public onlyVault {\n    WPStorage storage s = _loadSlot();\n\n    unchecked {\n      s.expected += newLienExpectedValue.safeCastTo88();\n      uint40 auctionEnd = (block.timestamp + finalAuctionDelta).safeCastTo40();\n      if (auctionEnd > s.finalAuctionEnd) s.finalAuctionEnd = auctionEnd;\n    }\n  }\n}"
    },
    {
      "filename": "src/PublicVault.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**\n *  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗\n * ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n * ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n * ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n * ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n * ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n *\n * Astaria Labs, Inc\n */\n\npragma solidity =0.8.17;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC4626} from \"solmate/mixins/ERC4626.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\n\nimport {IERC165} from \"core/interfaces/IERC165.sol\";\nimport {ERC4626Cloned} from \"gpl/ERC4626-Cloned.sol\";\nimport {IERC4626} from \"core/interfaces/IERC4626.sol\";\nimport {IERC20} from \"core/interfaces/IERC20.sol\";\nimport {IERC20Metadata} from \"core/interfaces/IERC20Metadata.sol\";\nimport {ERC20Cloned} from \"gpl/ERC20-Cloned.sol\";\nimport {\n  ClonesWithImmutableArgs\n} from \"clones-with-immutable-args/ClonesWithImmutableArgs.sol\";\n\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\n\nimport {VaultImplementation} from \"core/VaultImplementation.sol\";\nimport {WithdrawProxy} from \"core/WithdrawProxy.sol\";\n\nimport {Math} from \"core/utils/Math.sol\";\nimport {IPublicVault} from \"core/interfaces/IPublicVault.sol\";\nimport {IAstariaVaultBase} from \"core/interfaces/IAstariaVaultBase.sol\";\nimport {AstariaVaultBase} from \"core/AstariaVaultBase.sol\";\n\n/*\n * @title PublicVault\n * @author androolloyd\n * @notice\n */\ncontract PublicVault is VaultImplementation, IPublicVault, ERC4626Cloned {\n  using FixedPointMathLib for uint256;\n  using SafeTransferLib for ERC20;\n  using SafeCastLib for uint256;\n\n  uint256 private constant PUBLIC_VAULT_SLOT =\n    uint256(keccak256(\"xyz.astaria.PublicVault.storage.location\")) - 1;\n\n  function asset()\n    public\n    pure\n    virtual\n    override(IAstariaVaultBase, AstariaVaultBase, ERC4626Cloned)\n    returns (address)\n  {\n    return super.asset();\n  }\n\n  function decimals()\n    public\n    pure\n    virtual\n    override(IERC20Metadata)\n    returns (uint8)\n  {\n    return 18;\n  }\n\n  function name()\n    public\n    view\n    virtual\n    override(IERC20Metadata, VaultImplementation)\n    returns (string memory)\n  {\n    return string(abi.encodePacked(\"AST-Vault-\", ERC20(asset()).symbol()));\n  }\n\n  function symbol()\n    public\n    view\n    virtual\n    override(IERC20Metadata, VaultImplementation)\n    returns (string memory)\n  {\n    return string(abi.encodePacked(\"AST-V-\", ERC20(asset()).symbol()));\n  }\n\n  function minDepositAmount()\n    public\n    view\n    virtual\n    override(ERC4626Cloned)\n    returns (uint256)\n  {\n    if (ERC20(asset()).decimals() == uint8(18)) {\n      return 100 gwei;\n    } else {\n      return 10**(ERC20(asset()).decimals() - 1);\n    }\n  }\n\n  /**\n   * @notice Signal a withdrawal of funds (redeeming for underlying asset) in the next epoch.\n   * @param shares The number of VaultToken shares to redeem.\n   * @param receiver The receiver of the WithdrawTokens (and eventual underlying asset)\n   * @param owner The owner of the VaultTokens.\n   * @return assets The amount of the underlying asset redeemed.\n   */\n  function redeem(\n    uint256 shares,\n    address receiver,\n    address owner\n  ) public virtual override(ERC4626Cloned) returns (uint256 assets) {\n    VaultData storage s = _loadStorageSlot();\n    assets = _redeemFutureEpoch(s, shares, receiver, owner, s.currentEpoch);\n  }\n\n  function withdraw(\n    uint256 assets,\n    address receiver,\n    address owner\n  ) public virtual override(ERC4626Cloned) returns (uint256 shares) {\n    shares = previewWithdraw(assets);\n\n    VaultData storage s = _loadStorageSlot();\n\n    _redeemFutureEpoch(s, shares, receiver, owner, s.currentEpoch);\n  }\n\n  function redeemFutureEpoch(\n    uint256 shares,\n    address receiver,\n    address owner,\n    uint64 epoch\n  ) public virtual returns (uint256 assets) {\n    return\n      _redeemFutureEpoch(_loadStorageSlot(), shares, receiver, owner, epoch);\n  }\n\n  function _redeemFutureEpoch(\n    VaultData storage s,\n    uint256 shares,\n    address receiver,\n    address owner,\n    uint64 epoch\n  ) internal virtual returns (uint256 assets) {\n    // check to ensure that the requested epoch is not in the past\n\n    ERC20Data storage es = _loadERC20Slot();\n\n    if (msg.sender != owner) {\n      uint256 allowed = es.allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n      if (allowed != type(uint256).max) {\n        es.allowance[owner][msg.sender] = allowed - shares;\n      }\n    }\n\n    if (epoch < s.currentEpoch) {\n      revert InvalidState(InvalidStates.EPOCH_TOO_LOW);\n    }\n    require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n    // check for rounding error since we round down in previewRedeem.\n\n    //this will underflow if not enough balance\n    es.balanceOf[owner] -= shares;\n\n    // Cannot overflow because the sum of all user\n    // balances can't exceed the max uint256 value.\n    unchecked {\n      es.balanceOf[address(this)] += shares;\n    }\n\n    emit Transfer(owner, address(this), shares);\n    // Deploy WithdrawProxy if no WithdrawProxy exists for the specified epoch\n    _deployWithdrawProxyIfNotDeployed(s, epoch);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n    // WithdrawProxy shares are minted 1:1 with PublicVault shares\n    WithdrawProxy(s.epochData[epoch].withdrawProxy).mint(shares, receiver);\n  }\n\n  function getWithdrawProxy(uint64 epoch) public view returns (WithdrawProxy) {\n    return WithdrawProxy(_loadStorageSlot().epochData[epoch].withdrawProxy);\n  }\n\n  function getCurrentEpoch() public view returns (uint64) {\n    return _loadStorageSlot().currentEpoch;\n  }\n\n  function getSlope() public view returns (uint256) {\n    return uint256(_loadStorageSlot().slope);\n  }\n\n  function getWithdrawReserve() public view returns (uint256) {\n    return uint256(_loadStorageSlot().withdrawReserve);\n  }\n\n  function getLiquidationWithdrawRatio() public view returns (uint256) {\n    return uint256(_loadStorageSlot().liquidationWithdrawRatio);\n  }\n\n  function getYIntercept() public view returns (uint256) {\n    return uint256(_loadStorageSlot().yIntercept);\n  }\n\n  function _deployWithdrawProxyIfNotDeployed(VaultData storage s, uint64 epoch)\n    internal\n  {\n    if (s.epochData[epoch].withdrawProxy == address(0)) {\n      s.epochData[epoch].withdrawProxy = ClonesWithImmutableArgs.clone(\n        IAstariaRouter(ROUTER()).BEACON_PROXY_IMPLEMENTATION(),\n        abi.encodePacked(\n          address(ROUTER()), // router is the beacon\n          uint8(IAstariaRouter.ImplementationType.WithdrawProxy),\n          asset(), // token\n          address(this), // vault\n          epoch + 1 // claimable epoch\n        )\n      );\n    }\n  }\n\n  function mint(uint256 shares, address receiver)\n    public\n    override(ERC4626Cloned)\n    whenNotPaused\n    returns (uint256)\n  {\n    VIData storage s = _loadVISlot();\n    if (s.allowListEnabled) {\n      require(s.allowList[receiver]);\n    }\n    return super.mint(shares, receiver);\n  }\n\n  /**\n   * @notice Deposit funds into the PublicVault.\n   * @param amount The amount of funds to deposit.\n   * @param receiver The receiver of the resulting VaultToken shares.\n   */\n  function deposit(uint256 amount, address receiver)\n    public\n    override(ERC4626Cloned)\n    whenNotPaused\n    returns (uint256)\n  {\n    VIData storage s = _loadVISlot();\n    if (s.allowListEnabled) {\n      require(s.allowList[receiver]);\n    }\n\n    uint256 assets = totalAssets();\n\n    return super.deposit(amount, receiver);\n  }\n\n  /**\n   * @notice Retrieve the domain separator.\n   * @return The domain separator.\n   */\n  function computeDomainSeparator() internal view override returns (bytes32) {\n    return super.domainSeparator();\n  }\n\n  function processEpoch() public {\n    // check to make sure epoch is over\n    if (timeToEpochEnd() > 0) {\n      revert InvalidState(InvalidStates.EPOCH_NOT_OVER);\n    }\n    VaultData storage s = _loadStorageSlot();\n\n    if (s.withdrawReserve > 0) {\n      revert InvalidState(InvalidStates.WITHDRAW_RESERVE_NOT_ZERO);\n    }\n\n    WithdrawProxy currentWithdrawProxy = WithdrawProxy(\n      s.epochData[s.currentEpoch].withdrawProxy\n    );\n\n    // split funds from previous WithdrawProxy with PublicVault if hasn't been already\n    if (s.currentEpoch != 0) {\n      WithdrawProxy previousWithdrawProxy = WithdrawProxy(\n        s.epochData[s.currentEpoch - 1].withdrawProxy\n      );\n      if (\n        address(previousWithdrawProxy) != address(0) &&\n        previousWithdrawProxy.getFinalAuctionEnd() != 0\n      ) {\n        previousWithdrawProxy.claim();\n      }\n    }\n\n    if (s.epochData[s.currentEpoch].liensOpenForEpoch > 0) {\n      revert InvalidState(InvalidStates.LIENS_OPEN_FOR_EPOCH_NOT_ZERO);\n    }\n\n    // reset liquidationWithdrawRatio to prepare for re calcualtion\n    s.liquidationWithdrawRatio = 0;\n\n    // check if there are LPs withdrawing this epoch\n    if ((address(currentWithdrawProxy) != address(0))) {\n      uint256 proxySupply = currentWithdrawProxy.totalSupply();\n\n      s.liquidationWithdrawRatio = proxySupply\n        .mulDivDown(1e18, totalSupply())\n        .safeCastTo88();\n\n      currentWithdrawProxy.setWithdrawRatio(s.liquidationWithdrawRatio);\n      uint256 expected = currentWithdrawProxy.getExpected();\n\n      unchecked {\n        if (totalAssets() > expected) {\n          s.withdrawReserve = (totalAssets() - expected)\n            .mulWadDown(s.liquidationWithdrawRatio)\n            .safeCastTo88();\n        } else {\n          s.withdrawReserve = 0;\n        }\n      }\n      _setYIntercept(\n        s,\n        s.yIntercept -\n          totalAssets().mulDivDown(s.liquidationWithdrawRatio, 1e18)\n      );\n      // burn the tokens of the LPs withdrawing\n      _burn(address(this), proxySupply);\n    }\n\n    // increment epoch\n    unchecked {\n      s.currentEpoch++;\n    }\n  }\n\n  function supportsInterface(bytes4 interfaceId)\n    public\n    pure\n    override(IERC165)\n    returns (bool)\n  {\n    return\n      interfaceId == type(IPublicVault).interfaceId ||\n      interfaceId == type(ERC4626Cloned).interfaceId ||\n      interfaceId == type(ERC4626).interfaceId ||\n      interfaceId == type(ERC20).interfaceId ||\n      interfaceId == type(IERC165).interfaceId;\n  }\n\n  function transferWithdrawReserve() public {\n    VaultData storage s = _loadStorageSlot();\n\n    if (s.currentEpoch == uint64(0)) {\n      return;\n    }\n\n    address currentWithdrawProxy = s\n      .epochData[s.currentEpoch - 1]\n      .withdrawProxy;\n    // prevents transfer to a non-existent WithdrawProxy\n    // withdrawProxies are indexed by the epoch where they're deployed\n    if (currentWithdrawProxy != address(0)) {\n      uint256 withdrawBalance = ERC20(asset()).balanceOf(address(this));\n\n      // prevent transfer of more assets then are available\n      if (s.withdrawReserve <= withdrawBalance) {\n        withdrawBalance = s.withdrawReserve;\n        s.withdrawReserve = 0;\n      } else {\n        unchecked {\n          s.withdrawReserve -= withdrawBalance.safeCastTo88();\n        }\n      }\n\n      ERC20(asset()).safeTransfer(currentWithdrawProxy, withdrawBalance);\n      WithdrawProxy(currentWithdrawProxy).increaseWithdrawReserveReceived(\n        withdrawBalance\n      );\n      emit WithdrawReserveTransferred(withdrawBalance);\n    }\n\n    address withdrawProxy = s.epochData[s.currentEpoch].withdrawProxy;\n    if (\n      s.withdrawReserve > 0 &&\n      timeToEpochEnd() == 0 &&\n      withdrawProxy != address(0)\n    ) {\n      address currentWithdrawProxy = s\n        .epochData[s.currentEpoch - 1]\n        .withdrawProxy;\n      uint256 drainBalance = WithdrawProxy(withdrawProxy).drain(\n        s.withdrawReserve,\n        s.epochData[s.currentEpoch - 1].withdrawProxy\n      );\n      unchecked {\n        s.withdrawReserve -= drainBalance.safeCastTo88();\n      }\n      WithdrawProxy(currentWithdrawProxy).increaseWithdrawReserveReceived(\n        drainBalance\n      );\n    }\n  }\n\n  function _beforeCommitToLien(IAstariaRouter.Commitment calldata params)\n    internal\n    virtual\n    override(VaultImplementation)\n  {\n    VaultData storage s = _loadStorageSlot();\n\n    if (s.withdrawReserve > uint256(0)) {\n      transferWithdrawReserve();\n    }\n    if (timeToEpochEnd() == uint256(0)) {\n      processEpoch();\n    }\n  }\n\n  function _loadStorageSlot() internal pure returns (VaultData storage s) {\n    uint256 slot = PUBLIC_VAULT_SLOT;\n    assembly {\n      s.slot := slot\n    }\n  }\n\n  /**\n   * @dev Hook for updating the slope of the PublicVault after a LienToken is issued.\n   * @param lienId The ID of the lien.\n   */\n  function _afterCommitToLien(\n    uint40 lienEnd,\n    uint256 lienId,\n    uint256 lienSlope\n  ) internal virtual override {\n    VaultData storage s = _loadStorageSlot();\n\n    // increment slope for the new lien\n    _accrue(s);\n    unchecked {\n      uint48 newSlope = s.slope + lienSlope.safeCastTo48();\n      _setSlope(s, newSlope);\n    }\n\n    uint64 epoch = getLienEpoch(lienEnd);\n\n    _increaseOpenLiens(s, epoch);\n    emit LienOpen(lienId, epoch);\n  }\n\n  event SlopeUpdated(uint48 newSlope);\n\n  function accrue() public returns (uint256) {\n    return _accrue(_loadStorageSlot());\n  }\n\n  function _accrue(VaultData storage s) internal returns (uint256) {\n    unchecked {\n      s.yIntercept = (_totalAssets(s)).safeCastTo88();\n      s.last = block.timestamp.safeCastTo40();\n    }\n    emit YInterceptChanged(s.yIntercept);\n\n    return s.yIntercept;\n  }\n\n  /**\n   * @notice Computes the implied value of this PublicVault. This includes interest payments that have not yet been made.\n   * @return The implied value for this PublicVault.\n   */\n  function totalAssets()\n    public\n    view\n    virtual\n    override(ERC4626Cloned)\n    returns (uint256)\n  {\n    VaultData storage s = _loadStorageSlot();\n    return _totalAssets(s);\n  }\n\n  function _totalAssets(VaultData storage s) internal view returns (uint256) {\n    uint256 delta_t = block.timestamp - s.last;\n    return uint256(s.slope).mulDivDown(delta_t, 1) + uint256(s.yIntercept);\n  }\n\n  function totalSupply()\n    public\n    view\n    virtual\n    override(IERC20, ERC20Cloned)\n    returns (uint256)"
    }
  ]
}