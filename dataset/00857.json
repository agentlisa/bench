{
  "Title": "H-2: Adversary can permanently brick auctions due to precision error in Auction#_computeTotalRewards",
  "Content": "# Issue H-2: Adversary can permanently brick auctions due to precision error in Auction#_computeTotalRewards \n\nSource: https://github.com/sherlock-audit/2023-09-nounsbuilder-judging/issues/251 \n\n## Found by \n0x52, Bauer, Brenzee, HHK, Kow, KupiaSec, SilentDefendersOfDeFi, coffiasd, cu5t0mPe0, dany.armstrong90, ggg\\_ttt\\_hhh, gqrp, pontifex, unforgiven, xAriextz\n## Summary\n\nWhen batch depositing to ProtocolRewards, the msg.value is expected to match the sum of the amounts array EXACTLY. The issue is that due to precision loss in Auction#_computeTotalRewards this call can be engineered to always revert which completely bricks the auction process.\n\n## Vulnerability Detail\n\n[ProtocolRewards.sol#L55-L65](https://github.com/ourzora/zora-protocol/blob/8d1fe9bdd79a552a8f74b4712451185f6aebf9a0/packages/protocol-rewards/src/ProtocolRewards.sol#L55-L65)\n\n        for (uint256 i; i < numRecipients; ) {\n            expectedTotalValue += amounts[i];\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (msg.value != expectedTotalValue) {\n            revert INVALID_DEPOSIT();\n        }\n\nWhen making a batch deposit the above method is called. As seen, the call with revert if the sum of amounts does not EXACTLY equal the msg.value.\n\n[Auction.sol#L474-L507](https://github.com/sherlock-audit/2023-09-nounsbuilder/blob/main/nouns-protocol/src/auction/Auction.sol#L474-L507)\n\n        uint256 totalBPS = _founderRewardBps + referralRewardsBPS + builderRewardsBPS;\n\n        ...\n\n        // Calulate total rewards\n        split.totalRewards = (_finalBidAmount * totalBPS) / BPS_PER_100_PERCENT;\n\n        ...\n\n        // Initialize arrays\n        split.recipients = new address[](arraySize);\n        split.amounts = new uint256[](arraySize);\n        split.reasons = new bytes4[](arraySize);\n\n        // Set builder reward\n        split.recipients[0] = builderRecipient;\n        split.amounts[0] = (_finalBidAmount * builderRewardsBPS) / BPS_PER_100_PERCENT;\n\n        // Set referral reward\n        split.recipients[1] = _currentBidRefferal != address(0) ? _currentBidRefferal : builderRecipient;\n        split.amounts[1] = (_finalBidAmount * referralRewardsBPS) / BPS_PER_100_PERCENT;\n\n        // Set founder reward if enabled\n        if (hasFounderReward) {\n            split.recipients[2] = founderReward.recipient;\n            split.amounts[2] = (_finalBidAmount * _founderRewardBps) / BPS_PER_100_PERCENT;\n        }\n\nThe sum of the percentages are used to determine the totalRewards. Meanwhile, the amounts are determined using the broken out percentages of each. This leads to unequal precision loss, which can cause totalRewards to be off by a single wei which cause the batch deposit to revert and the auction to be bricked. Take the following example:\n\nAssume a referral reward of 5% (500) and a builder reward of 5% (500) for a total of 10% (1000). To brick the contract the adversary can engineer their bid with specific final digits. In this example, take a bid ending in 19. \n\n    split.totalRewards = (19 * 1,000) / 100,000 = 190,000 / 100,000 = 1\n\n    split.amounts[0] = (19 * 500) / 100,000 = 95,000 / 100,000 = 0\n    split.amounts[1] = (19 * 500) / 100,000 = 95,000 / 100,000 = 0\n\nHere we can see that the sum of amounts is not equal to totalRewards and the batch deposit will revert. \n\n[Auction.sol#L270-L273](https://github.com/sherlock-audit/2023-09-nounsbuilder/blob/main/nouns-protocol/src/auction/Auction.sol#L270-L273)\n\n    if (split.totalRewards != 0) {\n        // Deposit rewards\n        rewardsManager.depositBatch{ value: split.totalRewards }(split.recipients, split.amounts, split.reasons, \"\");\n    }\n\nThe depositBatch call is placed in the very important _settleAuction function. This results in auctions that are permanently broken and can never be settled.\n\n## Impact\n\nAuctions are completely bricked\n\n## Code Snippet\n\n[Auction.sol#L244-L289](https://github.com/sherlock-audit/2023-09-nounsbuilder/blob/main/nouns-protocol/src/auction/Auction.sol#L244-L289)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nInstead of setting totalRewards with the sum of the percentages, increment it by each fee calculated. This way they will always match no matter what.\n\n\n\n## Discussion\n\n**nevillehuang**\n\nContrary to #103 which only affects bidding, this causes a complete DoS of settlement of auctions, forcing the DAO to possibly have to redeploy to resolve the issue and continue auctions, so I believe high severity is fair.\n\n**neokry**\n\nFixed here: https://github.com/ourzora/nouns-protocol/pull/123\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/111",
  "Code": [
    {
      "filename": "packages/protocol-rewards/src/ProtocolRewards.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {Enjoy} from \"../_imagine/Enjoy.sol\";\nimport {EIP712} from \"./lib/EIP712.sol\";\nimport {IProtocolRewards} from \"./interfaces/IProtocolRewards.sol\";\n\n/// @title ProtocolRewards\n/// @notice Manager of deposits & withdrawals for protocol rewards\ncontract ProtocolRewards is Enjoy, IProtocolRewards, EIP712 {\n    /// @notice The EIP-712 typehash for gasless withdraws\n    bytes32 public constant WITHDRAW_TYPEHASH = keccak256(\"Withdraw(address from,address to,uint256 amount,uint256 nonce,uint256 deadline)\");\n\n    /// @notice An account's balance\n    mapping(address => uint256) public balanceOf;\n\n    /// @notice An account's nonce for gasless withdraws\n    mapping(address => uint256) public nonces;\n\n    constructor() payable EIP712(\"ProtocolRewards\", \"1\") {}\n\n    /// @notice The total amount of ETH held in the contract\n    function totalSupply() external view returns (uint256) {\n        return address(this).balance;\n    }\n\n    /// @notice Generic function to deposit ETH for a recipient, with an optional comment\n    /// @param to Address to deposit to\n    /// @param to Reason system reason for deposit (used for indexing)\n    /// @param comment Optional comment as reason for deposit\n    function deposit(address to, bytes4 reason, string calldata comment) external payable {\n        if (to == address(0)) {\n            revert ADDRESS_ZERO();\n        }\n\n        balanceOf[to] += msg.value;\n\n        emit Deposit(msg.sender, to, reason, msg.value, comment);\n    }\n\n    /// @notice Generic function to deposit ETH for multiple recipients, with an optional comment\n    /// @param recipients recipients to send the amount to, array aligns with amounts\n    /// @param amounts amounts to send to each recipient, array aligns with recipients\n    /// @param reasons optional bytes4 hash for indexing\n    /// @param comment Optional comment to include with mint\n    function depositBatch(address[] calldata recipients, uint256[] calldata amounts, bytes4[] calldata reasons, string calldata comment) external payable {\n        uint256 numRecipients = recipients.length;\n\n        if (numRecipients != amounts.length || numRecipients != reasons.length) {\n            revert ARRAY_LENGTH_MISMATCH();\n        }\n\n        uint256 expectedTotalValue;\n\n        for (uint256 i; i < numRecipients; ) {\n            expectedTotalValue += amounts[i];\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (msg.value != expectedTotalValue) {\n            revert INVALID_DEPOSIT();\n        }\n\n        address currentRecipient;\n        uint256 currentAmount;\n\n        for (uint256 i; i < numRecipients; ) {\n            currentRecipient = recipients[i];\n            currentAmount = amounts[i];\n\n            if (currentRecipient == address(0)) {\n                revert ADDRESS_ZERO();\n            }\n\n            balanceOf[currentRecipient] += currentAmount;\n\n            emit Deposit(msg.sender, currentRecipient, reasons[i], currentAmount, comment);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Used by Zora ERC-721 & ERC-1155 contracts to deposit protocol rewards\n    /// @param creator Creator for NFT rewards\n    /// @param creatorReward Creator reward amount\n    /// @param createReferral Creator referral\n    /// @param createReferralReward Creator referral reward\n    /// @param mintReferral Mint referral user\n    /// @param mintReferralReward Mint referral amount\n    /// @param firstMinter First minter reward\n    /// @param firstMinterReward First minter reward amount\n    /// @param zora ZORA recipient\n    /// @param zoraReward ZORA amount\n    function depositRewards(\n        address creator,\n        uint256 creatorReward,\n        address createReferral,\n        uint256 createReferralReward,\n        address mintReferral,\n        uint256 mintReferralReward,\n        address firstMinter,\n        uint256 firstMinterReward,\n        address zora,\n        uint256 zoraReward\n    ) external payable {\n        if (msg.value != (creatorReward + createReferralReward + mintReferralReward + firstMinterReward + zoraReward)) {\n            revert INVALID_DEPOSIT();\n        }\n\n        unchecked {\n            if (creator != address(0)) {\n                balanceOf[creator] += creatorReward;\n            }\n            if (createReferral != address(0)) {\n                balanceOf[createReferral] += createReferralReward;\n            }\n            if (mintReferral != address(0)) {\n                balanceOf[mintReferral] += mintReferralReward;\n            }\n            if (firstMinter != address(0)) {\n                balanceOf[firstMinter] += firstMinterReward;\n            }\n            if (zora != address(0)) {\n                balanceOf[zora] += zoraReward;\n            }\n        }\n\n        emit RewardsDeposit(\n            creator,\n            createReferral,\n            mintReferral,\n            firstMinter,\n            zora,\n            msg.sender,\n            creatorReward,\n            createReferralReward,\n            mintReferralReward,\n            firstMinterReward,\n            zoraReward\n        );\n    }\n\n    /// @notice Withdraw protocol rewards\n    /// @param to Withdraws from msg.sender to this address\n    /// @param amount Amount to withdraw (0 for total balance)\n    function withdraw(address to, uint256 amount) external {\n        if (to == address(0)) {\n            revert ADDRESS_ZERO();\n        }\n\n        address owner = msg.sender;\n\n        if (amount > balanceOf[owner]) {\n            revert INVALID_WITHDRAW();\n        }\n\n        if (amount == 0) {\n            amount = balanceOf[owner];\n        }\n\n        balanceOf[owner] -= amount;\n\n        emit Withdraw(owner, to, amount);\n\n        (bool success, ) = to.call{value: amount}(\"\");\n\n        if (!success) {\n            revert TRANSFER_FAILED();\n        }\n    }\n\n    /// @notice Withdraw rewards on behalf of an address\n    /// @param to The address to withdraw for\n    /// @param amount The amount to withdraw (0 for total balance)\n    function withdrawFor(address to, uint256 amount) external {\n        if (to == address(0)) {\n            revert ADDRESS_ZERO();\n        }\n\n        if (amount > balanceOf[to]) {\n            revert INVALID_WITHDRAW();\n        }\n\n        if (amount == 0) {\n            amount = balanceOf[to];\n        }\n\n        balanceOf[to] -= amount;\n\n        emit Withdraw(to, to, amount);\n\n        (bool success, ) = to.call{value: amount}(\"\");\n\n        if (!success) {\n            revert TRANSFER_FAILED();\n        }\n    }\n\n    /// @notice Execute a withdraw of protocol rewards via signature\n    /// @param from Withdraw from this address\n    /// @param to Withdraw to this address\n    /// @param amount Amount to withdraw (0 for total balance)\n    /// @param deadline Deadline for the signature to be valid\n    /// @param v V component of signature\n    /// @param r R component of signature\n    /// @param s S component of signature\n    function withdrawWithSig(address from, address to, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external {\n        if (block.timestamp > deadline) {\n            revert SIGNATURE_DEADLINE_EXPIRED();\n        }\n\n        bytes32 withdrawHash;\n\n        unchecked {\n            withdrawHash = keccak256(abi.encode(WITHDRAW_TYPEHASH, from, to, amount, nonces[from]++, deadline));\n        }\n\n        bytes32 digest = _hashTypedDataV4(withdrawHash);\n\n        address recoveredAddress = ecrecover(digest, v, r, s);\n\n        if (recoveredAddress == address(0) || recoveredAddress != from) {\n            revert INVALID_SIGNATURE();\n        }\n\n        if (to == address(0)) {\n            revert ADDRESS_ZERO();\n        }\n\n        if (amount > balanceOf[from]) {\n            revert INVALID_WITHDRAW();\n        }\n\n        if (amount == 0) {\n            amount = balanceOf[from];\n        }\n\n        balanceOf[from] -= amount;\n\n        emit Withdraw(from, to, amount);\n\n        (bool success, ) = to.call{value: amount}(\"\");\n\n        if (!success) {\n            revert TRANSFER_FAILED();\n        }\n    }\n}"
    },
    {
      "filename": "nouns-protocol/src/auction/Auction.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { UUPS } from \"../lib/proxy/UUPS.sol\";\nimport { Ownable } from \"../lib/utils/Ownable.sol\";\nimport { ReentrancyGuard } from \"../lib/utils/ReentrancyGuard.sol\";\nimport { Pausable } from \"../lib/utils/Pausable.sol\";\nimport { SafeCast } from \"../lib/utils/SafeCast.sol\";\n\nimport { AuctionStorageV1 } from \"./storage/AuctionStorageV1.sol\";\nimport { Token } from \"../token/Token.sol\";\nimport { AuctionStorageV2 } from \"./storage/AuctionStorageV2.sol\";\nimport { Manager } from \"../manager/Manager.sol\";\nimport { IAuction } from \"./IAuction.sol\";\nimport { IWETH } from \"../lib/interfaces/IWETH.sol\";\nimport { IProtocolRewards } from \"../lib/interfaces/IProtocolRewards.sol\";\n\nimport { VersionedContract } from \"../VersionedContract.sol\";\n\n/// @title Auction\n/// @author Rohan Kulkarni & Neokry\n/// @notice A DAO's auction house\n/// @custom:repo github.com/ourzora/nouns-protocol\n/// Modified from:\n/// - NounsAuctionHouse.sol commit 2cbe6c7 - licensed under the BSD-3-Clause license.\n/// - Zora V3 ReserveAuctionCoreEth module commit 795aeca - licensed under the GPL-3.0 license.\ncontract Auction is IAuction, VersionedContract, UUPS, Ownable, ReentrancyGuard, Pausable, AuctionStorageV1, AuctionStorageV2 {\n    ///                                                          ///\n    ///                          CONSTANTS                       ///\n    ///                                                          ///\n\n    /// @notice The basis points for 100%\n    uint256 private constant BPS_PER_100_PERCENT = 10_000;\n\n    /// @notice The maximum rewards percentage\n    uint256 private constant MAX_FOUNDER_REWARD_BPS = 3_000;\n\n    ///                                                          ///\n    ///                          IMMUTABLES                      ///\n    ///                                                          ///\n\n    /// @notice Iniital time buffer for auction bids\n    uint40 private immutable INITIAL_TIME_BUFFER = 5 minutes;\n\n    /// @notice Min bid increment BPS\n    uint8 private immutable INITIAL_MIN_BID_INCREMENT_PERCENT = 10;\n\n    /// @notice The address of WETH\n    address private immutable WETH;\n\n    /// @notice The contract upgrade manager\n    Manager private immutable manager;\n\n    /// @notice The rewards manager\n    IProtocolRewards private immutable rewardsManager;\n\n    /// @notice The builder reward BPS as a percent of settled auction amount\n    uint16 public immutable builderRewardsBPS;\n\n    /// @notice The referral reward BPS as a percent of settled auction amount\n    uint16 public immutable referralRewardsBPS;\n\n    ///                                                          ///\n    ///                          CONSTRUCTOR                     ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    /// @param _rewardsManager The protocol rewards manager address\n    /// @param _weth The address of WETH\n    constructor(\n        address _manager,\n        address _rewardsManager,\n        address _weth,\n        uint16 _builderRewardsBPS,\n        uint16 _referralRewardsBPS\n    ) payable initializer {\n        manager = Manager(_manager);\n        rewardsManager = IProtocolRewards(_rewardsManager);\n        WETH = _weth;\n        builderRewardsBPS = _builderRewardsBPS;\n        referralRewardsBPS = _referralRewardsBPS;\n    }\n\n    ///                                                          ///\n    ///                          INITIALIZER                     ///\n    ///                                                          ///\n\n    /// @notice Initializes a DAO's auction contract\n    /// @param _token The ERC-721 token address\n    /// @param _founder The founder responsible for starting the first auction\n    /// @param _treasury The treasury address where ETH will be sent\n    /// @param _duration The duration of each auction\n    /// @param _reservePrice The reserve price of each auction\n    /// @param _founderRewardRecipient The address to recieve founders rewards\n    /// @param _founderRewardBps The percent of rewards a founder receives in BPS for each auction\n    function initialize(\n        address _token,\n        address _founder,\n        address _treasury,\n        uint256 _duration,\n        uint256 _reservePrice,\n        address _founderRewardRecipient,\n        uint16 _founderRewardBps\n    ) external initializer {\n        // Ensure the caller is the contract manager\n        if (msg.sender != address(manager)) revert ONLY_MANAGER();\n\n        // Ensure the founder reward is not more than max\n        if (_founderRewardBps > MAX_FOUNDER_REWARD_BPS) revert INVALID_REWARDS_BPS();\n\n        // Ensure the recipient is set if the reward is greater than 0\n        if (_founderRewardBps > 0 && _founderRewardRecipient == address(0)) revert INVALID_REWARDS_RECIPIENT();\n\n        // Initialize the reentrancy guard\n        __ReentrancyGuard_init();\n\n        // Grant initial ownership to a founder\n        __Ownable_init(_founder);\n\n        // Pause the contract until the first auction\n        __Pausable_init(true);\n\n        // Store DAO's ERC-721 token\n        token = Token(_token);\n\n        // Store the auction house settings\n        settings.duration = SafeCast.toUint40(_duration);\n        settings.reservePrice = _reservePrice;\n        settings.treasury = _treasury;\n        settings.timeBuffer = INITIAL_TIME_BUFFER;\n        settings.minBidIncrement = INITIAL_MIN_BID_INCREMENT_PERCENT;\n\n        // Store the founder rewards settings\n        founderReward.recipient = _founderRewardRecipient;\n        founderReward.percentBps = _founderRewardBps;\n    }\n\n    ///                                                          ///\n    ///                          CREATE BID                      ///\n    ///                                                          ///\n\n    /// @notice Creates a bid for the current token\n    /// @param _tokenId The ERC-721 token id\n    function createBidWithReferral(uint256 _tokenId, address _referral) external payable nonReentrant {\n        currentBidReferral = _referral;\n        _createBid(_tokenId);\n    }\n\n    /// @notice Creates a bid for the current token\n    /// @param _tokenId The ERC-721 token id\n    function createBid(uint256 _tokenId) external payable nonReentrant {\n        currentBidReferral = address(0);\n        _createBid(_tokenId);\n    }\n\n    /// @notice Creates a bid for the current token\n    /// @param _tokenId The ERC-721 token id\n    function _createBid(uint256 _tokenId) private {\n        // Ensure the bid is for the current token\n        if (auction.tokenId != _tokenId) {\n            revert INVALID_TOKEN_ID();\n        }\n\n        // Ensure the auction is still active\n        if (block.timestamp >= auction.endTime) {\n            revert AUCTION_OVER();\n        }\n\n        // Cache the amount of ETH attached\n        uint256 msgValue = msg.value;\n\n        // Cache the address of the highest bidder\n        address lastHighestBidder = auction.highestBidder;\n\n        // Cache the last highest bid\n        uint256 lastHighestBid = auction.highestBid;\n\n        // Store the new highest bid\n        auction.highestBid = msgValue;\n\n        // Store the new highest bidder\n        auction.highestBidder = msg.sender;\n\n        // Used to store whether to extend the auction\n        bool extend;\n\n        // Cannot underflow as `_auction.endTime` is ensured to be greater than the current time above\n        unchecked {\n            // Compute whether the time remaining is less than the buffer\n            extend = (auction.endTime - block.timestamp) < settings.timeBuffer;\n\n            // If the auction should be extended\n            if (extend) {\n                // Update the end time with the additional time buffer\n                auction.endTime = uint40(block.timestamp + settings.timeBuffer);\n            }\n        }\n\n        // If this is the first bid:\n        if (lastHighestBidder == address(0)) {\n            // Ensure the bid meets the reserve price\n            if (msgValue < settings.reservePrice) {\n                revert RESERVE_PRICE_NOT_MET();\n            }\n\n            // Else this is a subsequent bid:\n        } else {\n            // Used to store the minimum bid required\n            uint256 minBid;\n\n            // Cannot realistically overflow\n            unchecked {\n                // Compute the minimum bid\n                minBid = lastHighestBid + ((lastHighestBid * settings.minBidIncrement) / 100);\n            }\n\n            // Ensure the incoming bid meets the minimum\n            if (msgValue < minBid) {\n                revert MINIMUM_BID_NOT_MET();\n            }\n            // Ensure that the second bid is not also zero\n            if (minBid == 0 && msgValue == 0 && lastHighestBidder != address(0)) {\n                revert MINIMUM_BID_NOT_MET();\n            }\n\n            // Refund the previous bidder\n            _handleOutgoingTransfer(lastHighestBidder, lastHighestBid);\n        }\n\n        emit AuctionBid(_tokenId, msg.sender, msgValue, extend, auction.endTime);\n    }\n\n    ///                                                          ///\n    ///                    SETTLE & CREATE AUCTION               ///\n    ///                                                          ///\n\n    /// @notice Settles the current auction and creates the next one\n    function settleCurrentAndCreateNewAuction() external nonReentrant whenNotPaused {\n        _settleAuction();\n        _createAuction();\n    }\n\n    /// @dev Settles the current auction\n    function _settleAuction() private {\n        // Get a copy of the current auction\n        Auction memory _auction = auction;\n\n        // Ensure the auction wasn't already settled\n        if (auction.settled) revert AUCTION_SETTLED();\n\n        // Ensure the auction had started\n        if (_auction.startTime == 0) revert AUCTION_NOT_STARTED();\n\n        // Ensure the auction is over\n        if (block.timestamp < _auction.endTime) revert AUCTION_ACTIVE();\n\n        // Mark the auction as settled\n        auction.settled = true;\n\n        // If a bid was placed:\n        if (_auction.highestBidder != address(0)) {\n            // Cache the amount of the highest bid\n            uint256 highestBid = _auction.highestBid;\n\n            // If the highest bid included ETH: Pay rewards and transfer remaining amount to the DAO treasury\n            if (highestBid != 0) {\n                // Calculate rewards\n                RewardSplits memory split = _computeTotalRewards(currentBidReferral, highestBid, founderReward.percentBps);\n\n                if (split.totalRewards != 0) {\n                    // Deposit rewards\n                    rewardsManager.depositBatch{ value: split.totalRewards }(split.recipients, split.amounts, split.reasons, \"\");\n                }\n\n                // Deposit remaining amount to treasury\n                _handleOutgoingTransfer(settings.treasury, highestBid - split.totalRewards);\n            }\n\n            // Transfer the token to the highest bidder\n            token.transferFrom(address(this), _auction.highestBidder, _auction.tokenId);\n\n            // Else no bid was placed:\n        } else {\n            // Burn the token\n            token.burn(_auction.tokenId);\n        }\n\n        emit AuctionSettled(_auction.tokenId, _auction.highestBidder, _auction.highestBid);\n    }\n\n    /// @dev Creates an auction for the next token\n    function _createAuction() private returns (bool) {\n        // Get the next token available for bidding\n        try token.mint() returns (uint256 tokenId) {\n            // Store the token id\n            auction.tokenId = tokenId;\n\n            // Cache the current timestamp\n            uint256 startTime = block.timestamp;\n\n            // Used to store the auction end time\n            uint256 endTime;\n\n            // Cannot realistically overflow\n            unchecked {\n                // Compute the auction end time\n                endTime = startTime + settings.duration;\n            }\n\n            // Store the auction start and end time\n            auction.startTime = uint40(startTime);\n            auction.endTime = uint40(endTime);\n\n            // Reset data from the previous auction\n            auction.highestBid = 0;\n            auction.highestBidder = address(0);\n            auction.settled = false;\n\n            // Reset referral from the previous auction\n            currentBidReferral = address(0);\n\n            emit AuctionCreated(tokenId, startTime, endTime);\n            return true;\n        } catch {\n            // Pause the contract if token minting failed\n            _pause();\n            return false;\n        }\n    }\n\n    ///                                                          ///\n    ///                             PAUSE                        ///\n    ///                                                          ///\n\n    /// @notice Unpauses the auction house\n    function unpause() external onlyOwner {\n        _unpause();\n\n        // If this is the first auction:\n        if (!settings.launched) {\n            // Mark the DAO as launched\n            settings.launched = true;\n\n            // Transfer ownership of the auction contract to the DAO\n            transferOwnership(settings.treasury);\n\n            // Transfer ownership of the token contract to the DAO\n            token.onFirstAuctionStarted();\n\n            // Start the first auction\n            if (!_createAuction()) {\n                // In cause of failure, revert.\n                revert AUCTION_CREATE_FAILED_TO_LAUNCH();\n            }\n        }\n        // Else if the contract was paused and the previous auction was settled:\n        else if (auction.settled) {\n            // Start the next auction\n            _createAuction();\n        }\n    }\n\n    /// @notice Pauses the auction house\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /// @notice Settles the latest auction when the contract is paused\n    function settleAuction() external nonReentrant whenPaused {\n        _settleAuction();\n    }\n\n    ///                                                          ///\n    ///                       AUCTION SETTINGS                   ///\n    ///                                                          ///\n\n    /// @notice The DAO treasury\n    function treasury() external view returns (address) {\n        return settings.treasury;\n    }\n\n    /// @notice The time duration of each auction\n    function duration() external view returns (uint256) {\n        return settings.duration;\n    }\n\n    /// @notice The reserve price of each auction\n    function reservePrice() external view returns (uint256) {\n        return settings.reservePrice;\n    }\n\n    /// @notice The minimum amount of time to place a bid during an active auction\n    function timeBuffer() external view returns (uint256) {\n        return settings.timeBuffer;\n    }\n\n    /// @notice The minimum percentage an incoming bid must raise the highest bid\n    function minBidIncrement() external view returns (uint256) {\n        return settings.minBidIncrement;\n    }\n\n    ///                                                          ///\n    ///                       UPDATE SETTINGS                    ///\n    ///                                                          ///\n\n    /// @notice Updates the time duration of each auction\n    /// @param _duration The new time duration\n    function setDuration(uint256 _duration) external onlyOwner whenPaused {\n        settings.duration = SafeCast.toUint40(_duration);\n\n        emit DurationUpdated(_duration);\n    }\n\n    /// @notice Updates the reserve price of each auction\n    /// @param _reservePrice The new reserve price\n    function setReservePrice(uint256 _reservePrice) external onlyOwner whenPaused {\n        settings.reservePrice = _reservePrice;\n\n        emit ReservePriceUpdated(_reservePrice);\n    }\n\n    /// @notice Updates the time buffer of each auction\n    /// @param _timeBuffer The new time buffer\n    function setTimeBuffer(uint256 _timeBuffer) external onlyOwner whenPaused {\n        settings.timeBuffer = SafeCast.toUint40(_timeBuffer);\n\n        emit TimeBufferUpdated(_timeBuffer);\n    }\n\n    /// @notice Updates the minimum bid increment of each subsequent bid\n    /// @param _percentage The new percentage\n    function setMinimumBidIncrement(uint256 _percentage) external onlyOwner whenPaused {\n        if (_percentage == 0) {\n            revert MIN_BID_INCREMENT_1_PERCENT();\n        }\n\n        settings.minBidIncrement = SafeCast.toUint8(_percentage);\n\n        emit MinBidIncrementPercentageUpdated(_percentage);\n    }\n\n    /// @notice Updates the founder reward recipent address\n    /// @param reward The new founder reward settings\n    function setFounderReward(FounderReward calldata reward) external onlyOwner whenPaused {\n        // Ensure the founder reward is not more than max\n        if (reward.percentBps > MAX_FOUNDER_REWARD_BPS) revert INVALID_REWARDS_BPS();\n\n        // Ensure the recipient is set if the reward is greater than 0\n        if (reward.percentBps > 0 && reward.recipient == address(0)) revert INVALID_REWARDS_RECIPIENT();\n\n        // Update the founder reward settings\n        founderReward = reward;\n\n        emit FounderRewardUpdated(reward);\n    }\n\n    ///                                                          ///\n    ///                       COMPUTE REWARDS UTIL               ///\n    ///                                                          ///\n\n    /// @notice Computes the total rewards for a bid\n    /// @param _currentBidRefferal The referral for the current bid\n    /// @param _finalBidAmount The final bid amount\n    /// @param _founderRewardBps The reward to be paid to the founder in BPS\n    function _computeTotalRewards(\n        address _currentBidRefferal,\n        uint256 _finalBidAmount,\n        uint256 _founderRewardBps\n    ) internal view returns (RewardSplits memory split) {\n        // Get global builder recipient from manager\n        address builderRecipient = manager.builderRewardsRecipient();\n\n        // Calculate the total rewards percentage\n        uint256 totalBPS = _founderRewardBps + referralRewardsBPS + builderRewardsBPS;\n\n        // Verify percentage is not more than 100\n        if (totalBPS >= BPS_PER_100_PERCENT) {\n            revert INVALID_REWARD_TOTAL();\n        }\n\n        // Calulate total rewards\n        split.totalRewards = (_finalBidAmount * totalBPS) / BPS_PER_100_PERCENT;\n\n        // Check if founder reward is enabled\n        bool hasFounderReward = _founderRewardBps > 0 && founderReward.recipient != address(0);\n\n        // Set array size based on if founder reward is enabled\n        uint256 arraySize = hasFounderReward ? 3 : 2;\n\n        // Initialize arrays\n        split.recipients = new address[](arraySize);\n        split.amounts = new uint256[](arraySize);\n        split.reasons = new bytes4[](arraySize);\n\n        // Set builder reward\n        split.recipients[0] = builderRecipient;\n        split.amounts[0] = (_finalBidAmount * builderRewardsBPS) / BPS_PER_100_PERCENT;\n\n        // Set referral reward\n        split.recipients[1] = _currentBidRefferal != address(0) ? _currentBidRefferal : builderRecipient;\n        split.amounts[1] = (_finalBidAmount * referralRewardsBPS) / BPS_PER_100_PERCENT;\n\n        // Set founder reward if enabled\n        if (hasFounderReward) {\n            split.recipients[2] = founderReward.recipient;\n            split.amounts[2] = (_finalBidAmount * _founderRewardBps) / BPS_PER_100_PERCENT;\n        }\n    }\n\n    ///                                                          ///\n    ///                        TRANSFER UTIL                     ///\n    ///                                                          ///\n\n    /// @notice Transfer ETH/WETH from the contract\n    /// @param _to The recipient address\n    /// @param _amount The amount transferring\n    function _handleOutgoingTransfer(address _to, uint256 _amount) private {\n        // Ensure the contract has enough ETH to transfer\n        if (address(this).balance < _amount) revert INSOLVENT();\n\n        // Used to store if the transfer succeeded\n        bool success;\n\n        assembly {\n            // Transfer ETH to the recipient\n            // Limit the call to 50,000 gas\n            success := call(50000, _to, _amount, 0, 0, 0, 0)\n        }\n\n        // If the transfer failed:\n        if (!success) {\n            // Wrap as WETH\n            IWETH(WETH).deposit{ value: _amount }();\n\n            // Transfer WETH instead\n            bool wethSuccess = IWETH(WETH).transfer(_to, _amount);\n\n            // Ensure successful transfer\n            if (!wethSuccess) {\n                revert FAILING_WETH_TRANSFER();\n            }\n        }\n    }\n\n    ///                                                          ///\n    ///                        AUCTION UPGRADE                   ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override onlyOwner whenPaused {\n        // Ensure the new implementation is registered by the Builder DAO\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}"
    },
    {
      "filename": "nouns-protocol/src/auction/Auction.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { UUPS } from \"../lib/proxy/UUPS.sol\";\nimport { Ownable } from \"../lib/utils/Ownable.sol\";\nimport { ReentrancyGuard } from \"../lib/utils/ReentrancyGuard.sol\";\nimport { Pausable } from \"../lib/utils/Pausable.sol\";\nimport { SafeCast } from \"../lib/utils/SafeCast.sol\";\n\nimport { AuctionStorageV1 } from \"./storage/AuctionStorageV1.sol\";\nimport { Token } from \"../token/Token.sol\";\nimport { AuctionStorageV2 } from \"./storage/AuctionStorageV2.sol\";\nimport { Manager } from \"../manager/Manager.sol\";\nimport { IAuction } from \"./IAuction.sol\";\nimport { IWETH } from \"../lib/interfaces/IWETH.sol\";\nimport { IProtocolRewards } from \"../lib/interfaces/IProtocolRewards.sol\";\n\nimport { VersionedContract } from \"../VersionedContract.sol\";\n\n/// @title Auction\n/// @author Rohan Kulkarni & Neokry\n/// @notice A DAO's auction house\n/// @custom:repo github.com/ourzora/nouns-protocol\n/// Modified from:\n/// - NounsAuctionHouse.sol commit 2cbe6c7 - licensed under the BSD-3-Clause license.\n/// - Zora V3 ReserveAuctionCoreEth module commit 795aeca - licensed under the GPL-3.0 license.\ncontract Auction is IAuction, VersionedContract, UUPS, Ownable, ReentrancyGuard, Pausable, AuctionStorageV1, AuctionStorageV2 {\n    ///                                                          ///\n    ///                          CONSTANTS                       ///\n    ///                                                          ///\n\n    /// @notice The basis points for 100%\n    uint256 private constant BPS_PER_100_PERCENT = 10_000;\n\n    /// @notice The maximum rewards percentage\n    uint256 private constant MAX_FOUNDER_REWARD_BPS = 3_000;\n\n    ///                                                          ///\n    ///                          IMMUTABLES                      ///\n    ///                                                          ///\n\n    /// @notice Iniital time buffer for auction bids\n    uint40 private immutable INITIAL_TIME_BUFFER = 5 minutes;\n\n    /// @notice Min bid increment BPS\n    uint8 private immutable INITIAL_MIN_BID_INCREMENT_PERCENT = 10;\n\n    /// @notice The address of WETH\n    address private immutable WETH;\n\n    /// @notice The contract upgrade manager\n    Manager private immutable manager;\n\n    /// @notice The rewards manager\n    IProtocolRewards private immutable rewardsManager;\n\n    /// @notice The builder reward BPS as a percent of settled auction amount\n    uint16 public immutable builderRewardsBPS;\n\n    /// @notice The referral reward BPS as a percent of settled auction amount\n    uint16 public immutable referralRewardsBPS;\n\n    ///                                                          ///\n    ///                          CONSTRUCTOR                     ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    /// @param _rewardsManager The protocol rewards manager address\n    /// @param _weth The address of WETH\n    constructor(\n        address _manager,\n        address _rewardsManager,"
    }
  ]
}