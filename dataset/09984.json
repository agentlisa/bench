{
  "Title": "[M-21] [ConcurRewardPool] Possible reentrancy when claiming rewards",
  "Content": "_Submitted by ShadowyNoobDev, also found by 0xw4rd3n, CertoraInc, ckksec, Czar102, defsec, Alex the Entreprenerd, Heartless, IllIllI, Jujic, kirk-baird, leastwood, pauliax, peritoflores, Randyyy, reassor, Rhynorater, Sleepy, SolidityScan, and wuwe1_\n\n[ConcurRewardPool.sol#L34](https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConcurRewardPool.sol#L34)<br>\n\nSince the reward tokens are transferred before the balances are set to 0, it is possible to perform a reentrancy attack if the reward token has some kind of call back functionality e.g. ERC777. pBTC is an ERC777 token that is currently available on Convex. A similar attack occurred with [imBTC on uniswap v1](https://zengo.com/imbtc-defi-hack-explained/).\n\n### Proof of Concept\n\n*   Preparation\n    1.  Assume that pBTC is used as extra rewards for this victim convex pool.\n    2.  A malicious user interacts with Concur through a smart contract. He follows the standard flow and has some rewards to be claimed.\n    3.  The malicious user interacts with this smart contract to register a bad `tokensToSend()` callback function through the ERC-1820 contract.\n    4.  In this `tokensToSend()` function, he calls `ConcurRewardPool.claimRewards()` n-1 more times to drain contract.\n*   Attack\n    1.  When he calls `ConcurRewardPool.claimRewards()` for the first time, the pBTC reward tokens are transferred.\n    2.  You can see from the [pBTC contract](https://etherscan.io/address/0x5228a22e72ccc52d415ecfd199f99d0665e7733b#code) on line 871 that `_callTokensToSend(from, from, recipient, amount, \"\", \"\");` is called inside the `transfer()` function.\n    3.  If you trace to the `_callTokensToSend` function definition to line 1147, you will notice that it calls `IERC777Sender(implementer).tokensToSend(operator, from, to, amount, userData, operatorData);` on line 1159.\n    4.  Since the malicious user already registered a bad `tokensToSend()` function, this function will be called thus draining majority of the pBTC rewards available on the `ConcurRewardPool` contract.\n\nYou can also find a walkthrough replicating a similar attack [here](https://medium.com/amber-group/preventing-re-entrancy-attacks-lessons-from-history-c2d96480fac3).\n\n### Recommended Mitigation Steps\n\n*   Use a nonReentrant modifier\n*   set balances to 0 first before disbursing the rewards\n\n**[ryuheimat (Concur) confirmed](https://github.com/code-423n4/2022-02-concur-findings/issues/86)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-02-concur-findings/issues/86#issuecomment-1100908724):**\n > The warden has shown how using a specific reward token can lead to reentrancy for the function `claimRewards`.\n> \n> Because the finding is contingent on a specific token that enables the exploit, I believe Medium Severity to be appropriate.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-concur-finance-contest",
  "Code": [
    {
      "filename": "contracts/ConcurRewardPool.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IConcurRewardClaim} from \"./interfaces/IConcurRewardClaim.sol\";\n\ncontract ConcurRewardPool is IConcurRewardClaim {\n    using SafeERC20 for IERC20;\n    address public immutable rewardNotifier;\n\n    mapping(address => mapping(address => uint256)) public reward;\n\n    constructor(address _notifier) {\n        rewardNotifier = _notifier;\n    }\n\n    /// @notice push reward to `_recipient`\n    /// @param _recipient reward recipient address\n    /// @param _token token to reward\n    /// @param _amount amount of tokens to allocate to `_recipient`\n    function pushReward(\n        address _recipient,\n        address _token,\n        uint256 _amount\n    ) external override {\n        require(msg.sender == rewardNotifier, \"!notifier\");\n        reward[_recipient][_token] += _amount;\n    }\n\n    /// @notice claim rewards of `msg.sender`\n    /// @param _tokens array of tokens to claim\n    function claimRewards(address[] calldata _tokens) external override {\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            uint256 getting = reward[msg.sender][_tokens[i]];\n            IERC20(_tokens[i]).safeTransfer(msg.sender, getting);\n            reward[msg.sender][_tokens[i]] = 0;\n        }\n    }\n}"
    }
  ]
}