{
  "Title": "Unnecessarily complex code",
  "Content": "The `investmentYield` and the `investmentAmount` are transferred back and forth from the vault to the same `investor` account. Instead of making [two separate transactions](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/vaults/STETHVault.sol#L81-L88), one can compare the two values and reach the final balance in one transaction.\n\n\nConsider simplifying the code for clarity and readability.\n\n\n**Update:** *Acknowledged, will not fix. Pods Finance team’s statement:*\n\n\n\n> *We actively preferred to leave the code in the back-and-forth way, so it’s easier to understand the flow of funds of the operations.*\n> \n> \n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/vaults/STETHVault.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.9;\n\nimport \"./BaseVault.sol\";\n\n/**\n * @title A Vault that use variable weekly yields to buy calls\n * @author Pods Finance\n */\ncontract STETHVault is BaseVault {\n    using SafeERC20 for IERC20Metadata;\n    using AuxMath for uint256;\n    using AuxMath for AuxMath.Fractional;\n    using DepositQueueLib for DepositQueueLib.DepositQueue;\n\n    uint8 public immutable sharePriceDecimals;\n    uint256 public lastRoundAssets;\n    AuxMath.Fractional public lastSharePrice;\n\n    /*\n     @dev investorRatio is the proportion that the weekly yield will be splitted\n     The precision of this number is set by the variable DENOMINATOR. 5000 is equivalent to 50%\n    */\n    uint256 public constant investorRatio = 5000;\n    address public immutable investor;\n\n    event StartRoundData(uint256 indexed roundId, uint256 lastRoundAssets, uint256 sharePrice);\n    event EndRoundData(\n        uint256 indexed roundId,\n        uint256 roundAccruedInterest,\n        uint256 investmentYield,\n        uint256 idleAssets\n    );\n    event SharePrice(uint256 indexed roundId, uint256 startSharePrice, uint256 endSharePrice);\n\n    constructor(\n        IConfigurationManager _configuration,\n        IERC20Metadata _asset,\n        address _investor\n    ) BaseVault(_configuration, _asset) {\n        investor = _investor;\n        sharePriceDecimals = _asset.decimals();\n    }\n\n    /**\n     * @inheritdoc ERC20\n     */\n    function name() public view override returns (string memory) {\n        return string(abi.encodePacked(_asset.symbol(), \" Volatility Vault\"));\n    }\n\n    /**\n     * @inheritdoc ERC20\n     */\n    function symbol() public view override returns (string memory) {\n        return string(abi.encodePacked(_asset.symbol(), \"vv\"));\n    }\n\n    function _afterRoundStart(uint256) internal override {\n        uint256 supply = totalSupply();\n\n        lastRoundAssets = totalAssets();\n        lastSharePrice = AuxMath.Fractional({ numerator: supply == 0 ? 0 : lastRoundAssets, denominator: supply });\n\n        uint256 sharePrice = lastSharePrice.denominator == 0 ? 0 : lastSharePrice.mulDivDown(10**sharePriceDecimals);\n        emit StartRoundData(currentRoundId, lastRoundAssets, sharePrice);\n    }\n\n    function _afterRoundEnd() internal override {\n        uint256 roundAccruedInterest = 0;\n        uint256 endSharePrice = 0;\n        uint256 investmentYield = _asset.balanceOf(investor);\n        uint256 supply = totalSupply();\n\n        if (supply != 0) {\n            roundAccruedInterest = totalAssets() - lastRoundAssets;\n            uint256 investmentAmount = (roundAccruedInterest * investorRatio) / DENOMINATOR;\n\n            // Pulls the yields from investor\n            if (investmentYield > 0) {\n                _asset.safeTransferFrom(investor, address(this), investmentYield);\n            }\n\n            if (investmentAmount > 0) {\n                _asset.safeTransfer(investor, investmentAmount);\n            }\n\n            // End Share price needs to be calculated after the transfers between investor and vault\n            endSharePrice = (totalAssets()).mulDivDown(10**sharePriceDecimals, supply);\n        }\n        uint256 startSharePrice = lastSharePrice.denominator == 0\n            ? 0\n            : lastSharePrice.mulDivDown(10**sharePriceDecimals);\n\n        emit EndRoundData(currentRoundId, roundAccruedInterest, investmentYield, totalIdleAssets());\n        emit SharePrice(currentRoundId, startSharePrice, endSharePrice);\n    }\n\n    function _beforeWithdraw(uint256 shares, uint256) internal override {\n        lastRoundAssets -= shares.mulDivDown(lastSharePrice);\n    }\n\n    /**\n     * @dev See {BaseVault-totalAssets}.\n     */\n    function totalAssets() public view override returns (uint256) {\n        return _asset.balanceOf(address(this)) - totalIdleAssets();\n    }\n\n    /**\n     * @dev Pull assets from the caller and create shares to the receiver\n     */\n    function _deposit(\n        uint256 assets,\n        uint256 shares,\n        address receiver\n    ) internal override returns (uint256 depositedAssets) {\n        _spendCap(shares);\n\n        assets = _stETHTransferFrom(msg.sender, address(this), assets);\n        depositQueue.push(DepositQueueLib.DepositEntry(receiver, assets));\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        return assets;\n    }\n\n    function _withdraw(\n        uint256 assets,\n        uint256 shares,\n        address receiver,\n        address owner\n    ) internal virtual override returns (uint256 receiverAssets, uint256 receiverShares) {\n        if (msg.sender != owner) {\n            _spendAllowance(owner, msg.sender, shares);\n        }\n\n        _burn(owner, shares);\n        _restoreCap(shares);\n\n        // Apply custom withdraw logic\n        _beforeWithdraw(shares, assets);\n\n        uint256 fee = _getFee(assets);\n        receiverAssets = assets - fee;\n        receiverShares = shares;\n\n        emit Withdraw(msg.sender, receiver, owner, receiverAssets, shares);\n\n        _asset.safeTransfer(receiver, receiverAssets);\n\n        if (fee > 0) {\n            emit FeeCollected(fee);\n            _asset.safeTransfer(controller(), fee);\n        }\n    }\n\n    /**\n     * @dev Moves `amount` of stETH from `from` to `to` using the\n     * allowance mechanism.\n     *\n     * Note that due to division rounding, not always is not possible to move\n     * the entire amount, hence transfer is attempted, returning the\n     * `effectiveAmount` transferred.\n     *\n     * For more information refer to: https://docs.lido.fi/guides/steth-integration-guide#1-wei-corner-case\n     */\n    function _stETHTransferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) internal returns (uint256 effectiveAmount) {\n        uint256 balanceBefore = _asset.balanceOf(to);\n        if (from == address(this)) {\n            _asset.safeTransfer(to, amount);\n        } else {\n            _asset.safeTransferFrom(from, to, amount);\n        }\n        return _asset.balanceOf(to) - balanceBefore;\n    }\n}"
    }
  ]
}