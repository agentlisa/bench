{
  "Title": "M-1: stETH/ETH chainlink oracle has too long of heartbeat and deviation threshold which can cause loss of funds",
  "Content": "# Issue M-1: stETH/ETH chainlink oracle has too long of heartbeat and deviation threshold which can cause loss of funds \n\nSource: https://github.com/sherlock-audit/2023-03-olympus-judging/issues/2 \n\n## Found by \n0x52\n\n## Summary\n\ngetTknOhmPrice uses the stETH/ETH chainlink oracle to calculate the current price of the OHM token. This token valuation is used to determine the amount of stETH to skim from the user resulting from oracle arb. This is problematic since stETH/ETH has a 24 hour heartbeat and a 2% deviation threshold. This deviation in price could easily cause loss of funds to the user. \n\n## Vulnerability Detail\n\n[BLVaultManagerLido.sol#L458-L473](https://github.com/sherlock-audit/2023-03-olympus/blob/main/sherlock-olympus/src/policies/BoostedLiquidity/BLVaultManagerLido.sol#L458-L473)\n\n    function getTknOhmPrice() public view override returns (uint256) {\n        // Get stETH per wstETH (18 Decimals)\n        uint256 stethPerWsteth = IWsteth(pairToken).stEthPerToken();\n\n        // Get ETH per OHM (18 Decimals)\n        uint256 ethPerOhm = _validatePrice(ohmEthPriceFeed.feed, ohmEthPriceFeed.updateThreshold);\n\n        // Get stETH per ETH (18 Decimals)\n        uint256 stethPerEth = _validatePrice(\n            stethEthPriceFeed.feed,\n            stethEthPriceFeed.updateThreshold\n        );\n\n        // Calculate wstETH per OHM (18 decimals)\n        return (ethPerOhm * 1e36) / (stethPerWsteth * stethPerEth);\n    }\n\ngetTknOhmPrice uses the stETH/ETH oracle to determine the price which as stated above has a 24 hour hearbeat and 2% deviation threshold, this means that the price can move up to 2% or 24 hours before a price update is triggered. The result is that the on-chain price could be much different than the true stETH price.\n\n[BLVaultLido.sol#L232-L240](https://github.com/sherlock-audit/2023-03-olympus/blob/main/sherlock-olympus/src/policies/BoostedLiquidity/BLVaultLido.sol#L232-L240)\n\n        uint256 wstethOhmPrice = manager.getTknOhmPrice();\n        uint256 expectedWstethAmountOut = (ohmAmountOut * wstethOhmPrice) / _OHM_DECIMALS;\n\n        // Take any arbs relative to the oracle price for the Treasury and return the rest to the owner\n        uint256 wstethToReturn = wstethAmountOut > expectedWstethAmountOut\n            ? expectedWstethAmountOut\n            : wstethAmountOut;\n        if (wstethAmountOut > wstethToReturn)\n            wsteth.safeTransfer(TRSRY(), wstethAmountOut - wstethToReturn);\n            \nThis price is used when determining how much stETH to send back to the user. Since the oracle can be up to 2% different from the true price, the user can unfairly lose part of their funds.\n\n## Impact\n\nUser will be unfairly penalized due large variance between on-chain price and asset price\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-03-olympus/blob/main/sherlock-olympus/src/policies/BoostedLiquidity/BLVaultManagerLido.sol#L440-L455\n\nhttps://github.com/sherlock-audit/2023-03-olympus/blob/main/sherlock-olympus/src/policies/BoostedLiquidity/BLVaultManagerLido.sol#L458-L473\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse the stETH/USD oracle instead because it has a 1-hour heartbeat and a 1% deviation threshold.\n\n## Discussion\n\n**0xLienid**\n\nFix Implementation: https://github.com/0xLienid/sherlock-olympus/pull/6/files\n\n**cducrest**\n\nEscalate for 10 USDC\n\nDisagree with severity, probably medium or low. The sherlock docs for high severity states: \"The vulnerability must be something that is not considered an acceptable risk by a reasonable protocol team.\" The provided fix arguably lowers the risk by 2: we go from 2% deviation threshold to 1% by changing oracle.\n\nIf having 2% deviation is unacceptable, I don't see how having 1% is acceptable.\n\nAdditionally, the user is able to notice when the price oracle deviate from the real value of the asset, and this value cannot be influenced by an attacker.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> Disagree with severity, probably medium or low. The sherlock docs for high severity states: \"The vulnerability must be something that is not considered an acceptable risk by a reasonable protocol team.\" The provided fix arguably lowers the risk by 2: we go from 2% deviation threshold to 1% by changing oracle.\n> \n> If having 2% deviation is unacceptable, I don't see how having 1% is acceptable.\n> \n> Additionally, the user is able to notice when the price oracle deviate from the real value of the asset, and this value cannot be influenced by an attacker.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**IAm0x52**\n\nEscalate for 10 USDC\n\nDisagree with the comment above. Sponsor has clearly accepted issue and has not disagreed with severity, which indicates they do not consider it an acceptable risk\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> Disagree with the comment above. Sponsor has clearly accepted issue and has not disagreed with severity, which indicates they do not consider it an acceptable risk\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted\n\nAccepting the first escalation as the severity of this impact can be considered medium based on the escalation \n\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Accepting the first escalation as the severity of this impact can be considered medium based on the escalation \n> \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/60",
  "Code": [
    {
      "filename": "sherlock-olympus/src/policies/BoostedLiquidity/BLVaultManagerLido.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// Import system dependencies\nimport {MINTRv1} from \"src/modules/MINTR/MINTR.v1.sol\";\nimport {ROLESv1, RolesConsumer} from \"src/modules/ROLES/OlympusRoles.sol\";\nimport {TRSRYv1} from \"src/modules/TRSRY/TRSRY.v1.sol\";\nimport {BLREGv1} from \"src/modules/BLREG/BLREG.v1.sol\";\nimport \"src/Kernel.sol\";\n\n// Import external dependencies\nimport {AggregatorV3Interface} from \"interfaces/AggregatorV2V3Interface.sol\";\nimport {IAuraRewardPool, IAuraMiningLib} from \"policies/BoostedLiquidity/interfaces/IAura.sol\";\nimport {JoinPoolRequest, IVault, IBasePool, IBalancerHelper} from \"policies/BoostedLiquidity/interfaces/IBalancer.sol\";\nimport {IWsteth} from \"policies/BoostedLiquidity/interfaces/ILido.sol\";\n\n// Import vault dependencies\nimport {RewardsData} from \"policies/BoostedLiquidity/interfaces/IBLVaultLido.sol\";\nimport {IBLVaultManagerLido} from \"policies/BoostedLiquidity/interfaces/IBLVaultManagerLido.sol\";\nimport {BLVaultLido} from \"policies/BoostedLiquidity/BLVaultLido.sol\";\n\n// Import libraries\nimport {ClonesWithImmutableArgs} from \"clones/ClonesWithImmutableArgs.sol\";\n\ncontract BLVaultManagerLido is Policy, IBLVaultManagerLido, RolesConsumer {\n    using ClonesWithImmutableArgs for address;\n\n    // ========= ERRORS ========= //\n\n    error BLManagerLido_AlreadyActive();\n    error BLManagerLido_AlreadyInactive();\n    error BLManagerLido_Inactive();\n    error BLManagerLido_InvalidVault();\n    error BLManagerLido_LimitViolation();\n    error BLManagerLido_InvalidLpAmount();\n    error BLManagerLido_InvalidLimit();\n    error BLManagerLido_InvalidFee();\n    error BLManagerLido_BadPriceFeed();\n    error BLManagerLido_VaultAlreadyExists();\n\n    // ========= EVENTS ========= //\n\n    event VaultDeployed(address vault, address owner, uint64 fee);\n\n    // ========= STATE VARIABLES ========= //\n\n    // Modules\n    MINTRv1 public MINTR;\n    TRSRYv1 public TRSRY;\n    BLREGv1 public BLREG;\n\n    // Tokens\n    address public ohm;\n    address public pairToken; // wstETH for this implementation\n    address public aura;\n    address public bal;\n\n    // Exchange Info\n    string public exchangeName;\n    BalancerData public balancerData;\n\n    // Aura Info\n    AuraData public auraData;\n    IAuraMiningLib public auraMiningLib;\n\n    // Oracle Info\n    OracleFeed public ohmEthPriceFeed;\n    OracleFeed public stethEthPriceFeed;\n\n    // Vault Info\n    BLVaultLido public implementation;\n    mapping(BLVaultLido => address) public vaultOwners;\n    mapping(address => BLVaultLido) public userVaults;\n\n    // Vaults State\n    uint256 public totalLp;\n    uint256 public deployedOhm;\n    uint256 public circulatingOhmBurned;\n\n    // System Configuration\n    uint256 public ohmLimit;\n    uint64 public currentFee;\n    bool public isLidoBLVaultActive;\n\n    // Constants\n    uint32 public constant MAX_FEE = 10_000; // 100%\n\n    //============================================================================================//\n    //                                      POLICY SETUP                                          //\n    //============================================================================================//\n\n    constructor(\n        Kernel kernel_,\n        TokenData memory tokenData_,\n        BalancerData memory balancerData_,\n        AuraData memory auraData_,\n        address auraMiningLib_,\n        OracleFeed memory ohmEthPriceFeed_,\n        OracleFeed memory stethEthPriceFeed_,\n        address implementation_,\n        uint256 ohmLimit_,\n        uint64 fee_\n    ) Policy(kernel_) {\n        // Set exchange name\n        {\n            exchangeName = \"Balancer\";\n        }\n\n        // Set tokens\n        {\n            ohm = tokenData_.ohm;\n            pairToken = tokenData_.pairToken;\n            aura = tokenData_.aura;\n            bal = tokenData_.bal;\n        }\n\n        // Set exchange info\n        {\n            balancerData = balancerData_;\n        }\n\n        // Set Aura Pool\n        {\n            auraData = auraData_;\n            auraMiningLib = IAuraMiningLib(auraMiningLib_);\n        }\n\n        // Set oracle info\n        {\n            ohmEthPriceFeed = ohmEthPriceFeed_;\n            stethEthPriceFeed = stethEthPriceFeed_;\n        }\n\n        // Set vault implementation\n        {\n            implementation = BLVaultLido(implementation_);\n        }\n\n        // Configure system\n        {\n            ohmLimit = ohmLimit_;\n            currentFee = fee_;\n        }\n    }\n\n    /// @inheritdoc Policy\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](4);\n        dependencies[0] = toKeycode(\"MINTR\");\n        dependencies[1] = toKeycode(\"TRSRY\");\n        dependencies[2] = toKeycode(\"BLREG\");\n        dependencies[3] = toKeycode(\"ROLES\");\n\n        MINTR = MINTRv1(getModuleAddress(dependencies[0]));\n        TRSRY = TRSRYv1(getModuleAddress(dependencies[1]));\n        BLREG = BLREGv1(getModuleAddress(dependencies[2]));\n        ROLES = ROLESv1(getModuleAddress(dependencies[3]));\n    }\n\n    /// @inheritdoc Policy\n    function requestPermissions()\n        external\n        view\n        override\n        returns (Permissions[] memory permissions)\n    {\n        Keycode mintrKeycode = MINTR.KEYCODE();\n        Keycode blregKeycode = BLREG.KEYCODE();\n\n        permissions = new Permissions[](5);\n        permissions[0] = Permissions(mintrKeycode, MINTR.mintOhm.selector);\n        permissions[1] = Permissions(mintrKeycode, MINTR.burnOhm.selector);\n        permissions[2] = Permissions(mintrKeycode, MINTR.increaseMintApproval.selector);\n        permissions[3] = Permissions(blregKeycode, BLREG.addVault.selector);\n        permissions[4] = Permissions(blregKeycode, BLREG.removeVault.selector);\n    }\n\n    //============================================================================================//\n    //                                           MODIFIERS                                        //\n    //============================================================================================//\n\n    modifier onlyWhileActive() {\n        if (!isLidoBLVaultActive) revert BLManagerLido_Inactive();\n        _;\n    }\n\n    modifier onlyVault() {\n        if (vaultOwners[BLVaultLido(msg.sender)] == address(0)) revert BLManagerLido_InvalidVault();\n        _;\n    }\n\n    //============================================================================================//\n    //                                        VAULT DEPLOYMENT                                    //\n    //============================================================================================//\n\n    /// @inheritdoc IBLVaultManagerLido\n    function deployVault() external override onlyWhileActive returns (address vault) {\n        if (address(userVaults[msg.sender]) != address(0))\n            revert BLManagerLido_VaultAlreadyExists();\n\n        // Create clone of vault implementation\n        bytes memory data = abi.encodePacked(\n            msg.sender, // Owner\n            this, // Vault Manager\n            address(TRSRY), // Treasury\n            address(MINTR), // Minter\n            ohm, // OHM\n            pairToken, // Pair Token (wstETH)\n            aura, // Aura\n            bal, // Balancer\n            balancerData.vault, // Balancer Vault\n            balancerData.liquidityPool, // Balancer Pool\n            auraData.pid, // Aura PID\n            auraData.auraBooster, // Aura Booster\n            auraData.auraRewardPool, // Aura Reward Pool\n            currentFee\n        );\n        BLVaultLido clone = BLVaultLido(address(implementation).clone(data));\n\n        // Initialize clone of vault implementation (for reentrancy state)\n        clone.initializeClone();\n\n        // Set vault owner\n        vaultOwners[clone] = msg.sender;\n        userVaults[msg.sender] = clone;\n\n        // Emit event\n        emit VaultDeployed(address(clone), msg.sender, currentFee);\n\n        // Return vault address\n        return address(clone);\n    }\n\n    //============================================================================================//\n    //                                         OHM MANAGEMENT                                     //\n    //============================================================================================//\n\n    /// @inheritdoc IBLVaultManagerLido\n    function mintOhmToVault(uint256 amount_) external override onlyWhileActive onlyVault {\n        // Check that minting will not exceed limit\n        if (deployedOhm + amount_ > ohmLimit + circulatingOhmBurned)\n            revert BLManagerLido_LimitViolation();\n\n        deployedOhm += amount_;\n\n        // Mint OHM\n        MINTR.increaseMintApproval(address(this), amount_);\n        MINTR.mintOhm(msg.sender, amount_);\n    }\n\n    /// @inheritdoc IBLVaultManagerLido\n    function burnOhmFromVault(uint256 amount_) external override onlyWhileActive onlyVault {\n        // Account for how much OHM has been deployed by the Vault system or burned from circulating supply.\n        // If we are burning more OHM than has been deployed by the system we are removing previously\n        // circulating OHM which should be tracked separately.\n        if (amount_ > deployedOhm) {\n            circulatingOhmBurned += amount_ - deployedOhm;\n            deployedOhm = 0;\n        } else {\n            deployedOhm -= amount_;\n        }\n\n        // Burn OHM\n        MINTR.burnOhm(msg.sender, amount_);\n    }\n\n    //============================================================================================//\n    //                                     VAULT STATE MANAGEMENT                                 //\n    //============================================================================================//\n\n    /// @inheritdoc IBLVaultManagerLido\n    function increaseTotalLp(uint256 amount_) external override onlyWhileActive onlyVault {\n        totalLp += amount_;\n    }\n\n    /// @inheritdoc IBLVaultManagerLido\n    function decreaseTotalLp(uint256 amount_) external override onlyWhileActive onlyVault {\n        if (amount_ > totalLp) revert BLManagerLido_InvalidLpAmount();\n        totalLp -= amount_;\n    }\n\n    //============================================================================================//\n    //                                         VIEW FUNCTIONS                                     //\n    //============================================================================================//\n\n    /// @inheritdoc IBLVaultManagerLido\n    function getLpBalance(address user_) external view override returns (uint256) {\n        if (address(userVaults[user_]) == address(0)) return 0;\n        return userVaults[user_].getLpBalance();\n    }\n\n    /// @inheritdoc IBLVaultManagerLido\n    function getUserPairShare(address user_) external view override returns (uint256) {\n        if (address(userVaults[user_]) == address(0)) return 0;\n        return userVaults[user_].getUserPairShare();\n    }\n\n    /// @inheritdoc IBLVaultManagerLido\n    function getOutstandingRewards(\n        address user_\n    ) external view override returns (RewardsData[] memory) {\n        // Get user's vault address\n        BLVaultLido vault = userVaults[user_];\n        if (address(vault) == address(0)) return new RewardsData[](0);\n\n        RewardsData[] memory rewards = vault.getOutstandingRewards();\n        return rewards;\n    }\n\n    /// @inheritdoc IBLVaultManagerLido\n    function getMaxDeposit() external view override returns (uint256) {\n        uint256 maxOhmAmount = ohmLimit + circulatingOhmBurned - deployedOhm;\n\n        // Convert max OHM mintable amount to pair token amount\n        uint256 ohmTknPrice = getOhmTknPrice();\n        uint256 maxTknAmount = (maxOhmAmount * 1e18) / ohmTknPrice;\n\n        return maxTknAmount;\n    }\n\n    /// @inheritdoc IBLVaultManagerLido\n    /// @dev    This is an external function but should only be used in a callstatic from an external\n    ///         source like the frontend.\n    function getExpectedLpAmount(uint256 amount_) external override returns (uint256 bptAmount) {\n        IBasePool pool = IBasePool(balancerData.liquidityPool);\n        IBalancerHelper balancerHelper = IBalancerHelper(balancerData.balancerHelper);\n\n        // Calculate OHM amount to mint\n        uint256 ohmTknPrice = getOhmTknPrice();\n        uint256 ohmMintAmount = (amount_ * ohmTknPrice) / 1e18;\n\n        // Build join pool request\n        address[] memory assets = new address[](2);\n        assets[0] = ohm;\n        assets[1] = pairToken;\n\n        uint256[] memory maxAmountsIn = new uint256[](2);\n        maxAmountsIn[0] = ohmMintAmount;\n        maxAmountsIn[1] = amount_;\n\n        JoinPoolRequest memory joinPoolRequest = JoinPoolRequest({\n            assets: assets,\n            maxAmountsIn: maxAmountsIn,\n            userData: abi.encode(1, maxAmountsIn, 0),\n            fromInternalBalance: false\n        });\n\n        // Join pool query\n        (bptAmount, ) = balancerHelper.queryJoin(\n            pool.getPoolId(),\n            address(this),\n            address(this),\n            joinPoolRequest\n        );\n    }\n\n    /// @inheritdoc IBLVaultManagerLido\n    function getRewardTokens() external view override returns (address[] memory) {\n        IAuraRewardPool auraPool = IAuraRewardPool(auraData.auraRewardPool);\n\n        uint256 numExtraRewards = auraPool.extraRewardsLength();\n        address[] memory rewardTokens = new address[](numExtraRewards + 2);\n        rewardTokens[0] = aura;\n        rewardTokens[1] = auraPool.rewardToken();\n        for (uint256 i; i < numExtraRewards; ) {\n            IAuraRewardPool extraRewardPool = IAuraRewardPool(auraPool.extraRewards(i));\n            rewardTokens[i + 2] = extraRewardPool.rewardToken();\n\n            unchecked {\n                ++i;\n            }\n        }\n        return rewardTokens;\n    }\n\n    /// @inheritdoc IBLVaultManagerLido\n    function getRewardRate(\n        address rewardToken_\n    ) external view override returns (uint256 rewardRate) {\n        IAuraRewardPool auraPool = IAuraRewardPool(auraData.auraRewardPool);\n\n        if (rewardToken_ == bal) {\n            // If reward token is Bal, return rewardRate from Aura Pool\n            rewardRate = auraPool.rewardRate();\n        } else if (rewardToken_ == aura) {\n            // If reward token is Aura, calculate rewardRate from AuraMiningLib\n            uint256 balRewardRate = auraPool.rewardRate();\n            rewardRate = auraMiningLib.convertCrvToCvx(balRewardRate);\n        } else {\n            uint256 numExtraRewards = auraPool.extraRewardsLength();\n            for (uint256 i; i < numExtraRewards; ) {\n                IAuraRewardPool extraRewardPool = IAuraRewardPool(auraPool.extraRewards(i));\n                if (rewardToken_ == extraRewardPool.rewardToken()) {\n                    rewardRate = extraRewardPool.rewardRate();\n                    break;\n                }\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n    }\n\n    /// @inheritdoc IBLVaultManagerLido\n    function getPoolOhmShare() public view override returns (uint256) {\n        // Cast addresses\n        IVault vault = IVault(balancerData.vault);\n        IBasePool pool = IBasePool(balancerData.liquidityPool);\n\n        // Get pool total supply\n        uint256 poolTotalSupply = pool.totalSupply();\n\n        // Get token balances in pool\n        (, uint256[] memory balances_, ) = vault.getPoolTokens(pool.getPoolId());\n\n        // Balancer pool tokens are sorted alphabetically by token address. In the case of this\n        // deployment, OHM is the first token in the pool. Therefore, the OHM balance is at index 0.\n        if (poolTotalSupply == 0) return 0;\n        else return (balances_[0] * totalLp) / poolTotalSupply;\n    }\n\n    /// @inheritdoc IBLVaultManagerLido\n    function getOhmSupplyChangeData()\n        external\n        view\n        override\n        returns (uint256 poolOhmShare, uint256 deployedOhm, uint256 circulatingOhmBurned)\n    {\n        // Net emitted is the amount of OHM that was minted to the pool but is no longer in the\n        // pool beyond what has been burned in the past. Net removed is the amount of OHM that is\n        // in the pool but wasnâ€™t minted there plus what has been burned in the past. Here we just return\n        // the data components to calculate that.\n\n        uint256 currentPoolOhmShare = getPoolOhmShare();\n        return (currentPoolOhmShare, deployedOhm, circulatingOhmBurned);\n    }\n\n    /// @inheritdoc IBLVaultManagerLido\n    function getOhmTknPrice() public view override returns (uint256) {\n        // Get stETH per wstETH (18 Decimals)\n        uint256 stethPerWsteth = IWsteth(pairToken).stEthPerToken();\n\n        // Get ETH per OHM (18 Decimals)\n        uint256 ethPerOhm = _validatePrice(ohmEthPriceFeed.feed, ohmEthPriceFeed.updateThreshold);\n\n        // Get stETH per ETH (18 Decimals)\n        uint256 stethPerEth = _validatePrice(\n            stethEthPriceFeed.feed,\n            stethEthPriceFeed.updateThreshold\n        );\n\n        // Calculate OHM per wstETH (9 decimals)\n        return (stethPerWsteth * stethPerEth) / (ethPerOhm * 1e9);\n    }\n\n    /// @inheritdoc IBLVaultManagerLido\n    function getTknOhmPrice() public view override returns (uint256) {\n        // Get stETH per wstETH (18 Decimals)\n        uint256 stethPerWsteth = IWsteth(pairToken).stEthPerToken();\n\n        // Get ETH per OHM (18 Decimals)\n        uint256 ethPerOhm = _validatePrice(ohmEthPriceFeed.feed, ohmEthPriceFeed.updateThreshold);\n\n        // Get stETH per ETH (18 Decimals)\n        uint256 stethPerEth = _validatePrice(\n            stethEthPriceFeed.feed,\n            stethEthPriceFeed.updateThreshold\n        );\n\n        // Calculate wstETH per OHM (18 decimals)\n        return (ethPerOhm * 1e36) / (stethPerWsteth * stethPerEth);\n    }\n\n    //============================================================================================//\n    //                                        ADMIN FUNCTIONS                                     //\n    //============================================================================================//\n\n    /// @inheritdoc IBLVaultManagerLido\n    function setLimit(uint256 newLimit_) external override onlyRole(\"liquidityvault_admin\") {\n        if (newLimit_ < deployedOhm) revert BLManagerLido_InvalidLimit();\n        ohmLimit = newLimit_;\n    }\n\n    /// @inheritdoc IBLVaultManagerLido\n    function setFee(uint64 newFee_) external override onlyRole(\"liquidityvault_admin\") {\n        if (newFee_ > MAX_FEE) revert BLManagerLido_InvalidFee();\n        currentFee = newFee_;\n    }\n\n    /// @inheritdoc IBLVaultManagerLido\n    function changeUpdateThresholds(\n        uint48 ohmEthUpdateThreshold_,\n        uint48 stethEthUpdateThreshold_\n    ) external onlyRole(\"liquidityvault_admin\") {\n        ohmEthPriceFeed.updateThreshold = ohmEthUpdateThreshold_;\n        stethEthPriceFeed.updateThreshold = stethEthUpdateThreshold_;\n    }\n\n    /// @inheritdoc IBLVaultManagerLido\n    function activate() external override onlyRole(\"liquidityvault_admin\") {\n        if (isLidoBLVaultActive) revert BLManagerLido_AlreadyActive();\n\n        isLidoBLVaultActive = true;\n        BLREG.addVault(address(this));\n    }\n\n    /// @inheritdoc IBLVaultManagerLido\n    function deactivate() external override onlyRole(\"liquidityvault_admin\") {\n        if (!isLidoBLVaultActive) revert BLManagerLido_AlreadyInactive();\n\n        isLidoBLVaultActive = false;\n        BLREG.removeVault(address(this));\n    }\n\n    //============================================================================================//\n    //                                      INTERNAL FUNCTIONS                                    //\n    //============================================================================================//\n\n    function _validatePrice(\n        AggregatorV3Interface priceFeed_,\n        uint48 updateThreshold_\n    ) internal view returns (uint256) {\n        // Get price data\n        (uint80 roundId, int256 priceInt, , uint256 updatedAt, uint80 answeredInRound) = priceFeed_\n            .latestRoundData();\n\n        // Validate chainlink price feed data\n        // 1. Price should be greater than 0\n        // 2. Updated at timestamp should be within the update threshold\n        // 3. Answered in round ID should be the same as round ID\n        if (\n            priceInt <= 0 ||\n            updatedAt < block.timestamp - updateThreshold_ ||\n            answeredInRound != roundId\n        ) revert BLManagerLido_BadPriceFeed();\n\n        return uint256(priceInt);\n    }\n}"
    },
    {
      "filename": "sherlock-olympus/src/policies/BoostedLiquidity/BLVaultLido.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// Import system dependencies\nimport {IBLVaultLido, RewardsData} from \"policies/BoostedLiquidity/interfaces/IBLVaultLido.sol\";\nimport {IBLVaultManagerLido} from \"policies/BoostedLiquidity/interfaces/IBLVaultManagerLido.sol\";\nimport {BLVaultManagerLido} from \"policies/BoostedLiquidity/BLVaultManagerLido.sol\";\n\n// Import external dependencies\nimport {JoinPoolRequest, ExitPoolRequest, IVault, IBasePool} from \"policies/BoostedLiquidity/interfaces/IBalancer.sol\";\nimport {IAuraBooster, IAuraRewardPool, IAuraMiningLib} from \"policies/BoostedLiquidity/interfaces/IAura.sol\";\n\n// Import types\nimport {OlympusERC20Token} from \"src/external/OlympusERC20.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\n// Import libraries\nimport {Clone} from \"clones/Clone.sol\";\nimport {TransferHelper} from \"libraries/TransferHelper.sol\";\nimport {FullMath} from \"libraries/FullMath.sol\";\n\ncontract BLVaultLido is IBLVaultLido, Clone {\n    using TransferHelper for ERC20;\n    using FullMath for uint256;\n\n    // ========= ERRORS ========= //\n\n    error BLVaultLido_AlreadyInitialized();\n    error BLVaultLido_OnlyOwner();\n    error BLVaultLido_Inactive();\n    error BLVaultLido_Reentrancy();\n    error BLVaultLido_AuraDepositFailed();\n\n    // ========= EVENTS ========= //\n\n    event Deposit(uint256 ohmAmount, uint256 wstethAmount);\n    event Withdraw(uint256 ohmAmount, uint256 wstethAmount);\n    event RewardsClaimed(address indexed rewardsToken, uint256 amount);\n\n    // ========= STATE VARIABLES ========= //\n\n    uint256 private constant _OHM_DECIMALS = 1e9;\n    uint256 private constant _WSTETH_DECIMALS = 1e18;\n\n    uint256 private _reentrancyStatus;\n\n    // ========= CONSTRUCTOR ========= //\n\n    constructor() {}\n\n    // ========= INITIALIZER ========= //\n\n    function initializeClone() external {\n        if (_reentrancyStatus != 0) revert BLVaultLido_AlreadyInitialized();\n        _reentrancyStatus = 1;\n    }\n\n    // ========= IMMUTABLE CLONE ARGS ========= //\n\n    function owner() public pure returns (address) {\n        return _getArgAddress(0);\n    }\n\n    function manager() public pure returns (BLVaultManagerLido) {\n        return BLVaultManagerLido(_getArgAddress(20));\n    }\n\n    function TRSRY() public pure returns (address) {\n        return _getArgAddress(40);\n    }\n\n    function MINTR() public pure returns (address) {\n        return _getArgAddress(60);\n    }\n\n    function ohm() public pure returns (OlympusERC20Token) {\n        return OlympusERC20Token(_getArgAddress(80));\n    }\n\n    function wsteth() public pure returns (ERC20) {\n        return ERC20(_getArgAddress(100));\n    }\n\n    function aura() public pure returns (ERC20) {\n        return ERC20(_getArgAddress(120));\n    }\n\n    function bal() public pure returns (ERC20) {\n        return ERC20(_getArgAddress(140));\n    }\n\n    function vault() public pure returns (IVault) {\n        return IVault(_getArgAddress(160));\n    }\n\n    function liquidityPool() public pure returns (IBasePool) {\n        return IBasePool(_getArgAddress(180));\n    }\n\n    function pid() public pure returns (uint256) {\n        return _getArgUint256(200);\n    }\n\n    function auraBooster() public pure returns (IAuraBooster) {\n        return IAuraBooster(_getArgAddress(232));\n    }\n\n    function auraRewardPool() public pure returns (IAuraRewardPool) {\n        return IAuraRewardPool(_getArgAddress(252));\n    }\n\n    function fee() public pure returns (uint64) {\n        return _getArgUint64(272);\n    }\n\n    // ========= MODIFIERS ========= //\n\n    modifier onlyOwner() {\n        if (msg.sender != owner()) revert BLVaultLido_OnlyOwner();\n        _;\n    }\n\n    modifier onlyWhileActive() {\n        if (!manager().isLidoBLVaultActive()) revert BLVaultLido_Inactive();\n        _;\n    }\n\n    modifier nonReentrant() {\n        if (_reentrancyStatus != 1) revert BLVaultLido_Reentrancy();\n\n        _reentrancyStatus = 2;\n\n        _;\n\n        _reentrancyStatus = 1;\n    }\n\n    //============================================================================================//\n    //                                      LIQUIDITY FUNCTIONS                                   //\n    //============================================================================================//\n\n    /// @inheritdoc IBLVaultLido\n    function deposit(\n        uint256 amount_,\n        uint256 minLpAmount_\n    ) external override onlyWhileActive onlyOwner nonReentrant returns (uint256 lpAmountOut) {\n        // Cache variables into memory\n        IBLVaultManagerLido manager = manager();\n        OlympusERC20Token ohm = ohm();\n        ERC20 wsteth = wsteth();\n        IBasePool liquidityPool = liquidityPool();\n        IAuraBooster auraBooster = auraBooster();\n\n        // Calculate OHM amount to mint\n        // getOhmTknPrice returns the amount of OHM per 1 wstETH\n        uint256 ohmWstethPrice = manager.getOhmTknPrice();\n        uint256 ohmMintAmount = (amount_ * ohmWstethPrice) / _WSTETH_DECIMALS;\n\n        // Block scope to avoid stack too deep\n        {\n            // Cache OHM-wstETH BPT before\n            uint256 bptBefore = liquidityPool.balanceOf(address(this));\n\n            // Transfer in wstETH\n            wsteth.safeTransferFrom(msg.sender, address(this), amount_);\n\n            // Mint OHM\n            manager.mintOhmToVault(ohmMintAmount);\n\n            // Join Balancer pool\n            _joinBalancerPool(ohmMintAmount, amount_, minLpAmount_);\n\n            // OHM-PAIR BPT after\n            lpAmountOut = liquidityPool.balanceOf(address(this)) - bptBefore;\n            manager.increaseTotalLp(lpAmountOut);\n\n            // Stake into Aura\n            liquidityPool.approve(address(auraBooster), lpAmountOut);\n            bool depositSuccess = auraBooster.deposit(pid(), lpAmountOut, true);\n            if (!depositSuccess) revert BLVaultLido_AuraDepositFailed();\n        }\n\n        // Return unused tokens\n        uint256 unusedOhm = ohm.balanceOf(address(this));\n        uint256 unusedWsteth = wsteth.balanceOf(address(this));\n\n        if (unusedOhm > 0) {\n            ohm.increaseAllowance(MINTR(), unusedOhm);\n            manager.burnOhmFromVault(unusedOhm);\n        }\n\n        if (unusedWsteth > 0) {\n            wsteth.safeTransfer(msg.sender, unusedWsteth);\n        }\n\n        // Emit event\n        emit Deposit(ohmMintAmount - unusedOhm, amount_ - unusedWsteth);\n\n        return lpAmountOut;\n    }\n\n    /// @inheritdoc IBLVaultLido\n    function withdraw(\n        uint256 lpAmount_,\n        uint256[] calldata minTokenAmounts_,\n        bool claim_\n    ) external override onlyWhileActive onlyOwner nonReentrant returns (uint256, uint256) {\n        // Cache variables into memory\n        OlympusERC20Token ohm = ohm();\n        ERC20 wsteth = wsteth();\n        IBLVaultManagerLido manager = manager();\n\n        // Cache OHM and wstETH balances before\n        uint256 ohmBefore = ohm.balanceOf(address(this));\n        uint256 wstethBefore = wsteth.balanceOf(address(this));\n\n        // Decrease total LP\n        manager.decreaseTotalLp(lpAmount_);\n\n        // Unstake from Aura\n        auraRewardPool().withdrawAndUnwrap(lpAmount_, claim_);\n\n        // Exit Balancer pool\n        _exitBalancerPool(lpAmount_, minTokenAmounts_);\n\n        // Calculate OHM and wstETH amounts received\n        uint256 ohmAmountOut = ohm.balanceOf(address(this)) - ohmBefore;\n        uint256 wstethAmountOut = wsteth.balanceOf(address(this)) - wstethBefore;\n\n        // Calculate oracle expected wstETH received amount\n        // getTknOhmPrice returns the amount of wstETH per 1 OHM based on the oracle price\n        uint256 wstethOhmPrice = manager.getTknOhmPrice();\n        uint256 expectedWstethAmountOut = (ohmAmountOut * wstethOhmPrice) / _OHM_DECIMALS;\n\n        // Take any arbs relative to the oracle price for the Treasury and return the rest to the owner\n        uint256 wstethToReturn = wstethAmountOut > expectedWstethAmountOut\n            ? expectedWstethAmountOut\n            : wstethAmountOut;\n        if (wstethAmountOut > wstethToReturn)\n            wsteth.safeTransfer(TRSRY(), wstethAmountOut - wstethToReturn);\n\n        // Burn OHM\n        ohm.increaseAllowance(MINTR(), ohmAmountOut);\n        manager.burnOhmFromVault(ohmAmountOut);\n\n        // Return wstETH to owner\n        wsteth.safeTransfer(msg.sender, wstethToReturn);\n\n        // Return rewards to owner\n        if (claim_) _sendRewards();\n\n        // Emit event\n        emit Withdraw(ohmAmountOut, wstethToReturn);\n\n        return (ohmAmountOut, wstethToReturn);\n    }\n\n    //============================================================================================//\n    //                                       REWARDS FUNCTIONS                                    //\n    //============================================================================================//\n\n    /// @inheritdoc IBLVaultLido\n    function claimRewards() external override onlyWhileActive onlyOwner nonReentrant {\n        // Claim rewards from Aura\n        auraRewardPool().getReward(owner(), true);\n\n        // Send rewards to owner\n        _sendRewards();\n    }\n\n    //============================================================================================//\n    //                                        VIEW FUNCTIONS                                      //\n    //============================================================================================//\n\n    /// @inheritdoc IBLVaultLido\n    function getLpBalance() public view override returns (uint256) {\n        return auraRewardPool().balanceOf(address(this));\n    }\n\n    /// @inheritdoc IBLVaultLido\n    function getUserPairShare() public view override returns (uint256) {\n        // If total supply is 0 return 0\n        if (liquidityPool().totalSupply() == 0) return 0;\n\n        // Get user's LP balance\n        uint256 userLpBalance = getLpBalance();\n\n        // Get pool balances\n        (, uint256[] memory balances, ) = vault().getPoolTokens(liquidityPool().getPoolId());\n\n        // Get user's share of the wstETH\n        uint256 userWstethShare = (userLpBalance * balances[1]) / liquidityPool().totalSupply();\n\n        // Check pool against oracle price\n        // getTknOhmPrice returns the amount of wstETH per 1 OHM based on the oracle price\n        uint256 wstethOhmPrice = manager().getTknOhmPrice();\n        uint256 userOhmShare = (userLpBalance * balances[0]) / liquidityPool().totalSupply();\n        uint256 expectedWstethShare = (userOhmShare * wstethOhmPrice) / _OHM_DECIMALS;\n\n        return userWstethShare > expectedWstethShare ? expectedWstethShare : userWstethShare;\n    }\n\n    /// @inheritdoc IBLVaultLido\n    function getOutstandingRewards() public view override returns (RewardsData[] memory) {\n        uint256 numExtraRewards = auraRewardPool().extraRewardsLength();\n        RewardsData[] memory rewards = new RewardsData[](numExtraRewards + 2);\n\n        // Get Bal reward\n        uint256 balRewards = auraRewardPool().earned(address(this));\n        rewards[0] = RewardsData({rewardToken: address(bal()), outstandingRewards: balRewards});\n\n        // Get Aura rewards\n        uint256 auraRewards = manager().auraMiningLib().convertCrvToCvx(balRewards);\n        rewards[1] = RewardsData({rewardToken: address(aura()), outstandingRewards: auraRewards});\n\n        // Get extra rewards\n        for (uint256 i; i < numExtraRewards; ) {\n            IAuraRewardPool extraRewardPool = IAuraRewardPool(auraRewardPool().extraRewards(i));\n\n            address extraRewardToken = extraRewardPool.rewardToken();\n            uint256 extraRewardAmount = extraRewardPool.earned(address(this));\n\n            rewards[i + 2] = RewardsData({\n                rewardToken: extraRewardToken,\n                outstandingRewards: extraRewardAmount\n            });\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return rewards;\n    }\n\n    //============================================================================================//\n    //                                      INTERNAL FUNCTIONS"
    }
  ]
}