{
  "Title": "[M-12] `CoreCollection.setRoyaltyVault` doesn't check `royaltyVault.royaltyAsset` against `payableToken`, resulting in potential permanent lock of `payableTokens` in royaltyVault",
  "Content": "_Submitted by rayn_\n\n<https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L185>\n\n<https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/ERC721Payable.sol#L50>\n\n<https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L31>\n\n### Impact\n\nEach CoreProxy is allowed to be associated with a RoyaltyVault, the latter which would be responsible for collecting minting fees and distributing to beneficiaries. Potential mismatch between token used in CoreProxy and RoyaltyVault might result in minting tokens being permanently stuck in RoyaltyVault.\n\n### Proof of Concept\n\nEach RoyaltyVault can only handle the `royaltyVault.royaltyAsset` token assigned upon creation, if any other kind of tokens are sent to the vault, it would get stuck inside the vault forever.\n\n        function sendToSplitter() external override {\n            ...\n            require(\n                IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,\n                \"Failed to transfer royalty Asset to splitter\"\n            );\n            ...\n            require(\n                IERC20(royaltyAsset).transfer(\n                    platformFeeRecipient,\n                    platformShare\n                ) == true,\n                \"Failed to transfer royalty Asset to platform fee recipient\"\n            );\n            ...\n        }\n\nConsidering that pairing of CoreProxy and RoyaltyVault is not necessarily handled automatically, and can sometimes be manually assigned, and further combined with the fact that once assigned, CoreProxy does not allow modifications of the pairing RoyaltyVault. We can easily conclude that if a CoreProxy is paired with an incompatible RoyaltyVault, the `payableToken` minting fees automatically transferred to RoyaltyVault by `_handlePayment` will get permanently stuck.\n\n         function setRoyaltyVault(address _royaltyVault)\n             external\n             onlyVaultUninitialized\n         {\n             ...\n             royaltyVault = _royaltyVault;\n             ...\n         }\n\n         function _handlePayment(uint256 _amount) internal {\n             address recipient = royaltyVaultInitialized()\n                 ? royaltyVault\n                 : address(this);\n             payableToken.transferFrom(msg.sender, recipient, _amount);\n             ...\n         }\n\n### Tools Used\n\nvim, ganache-cli\n\n### Recommended Mitigation Steps\n\nWhile assigning vaults to CoreProxy, check if `payableToken` is the same as `royaltyVault.royaltyAsset`\n\n         function setRoyaltyVault(address _royaltyVault)\n             external\n             onlyVaultUninitialized\n         {\n             require(\n                 payableToken == _royaltyVault.royaltyAsset(),\n                 \"CoreCollection : payableToken must be same as royaltyAsset.\"\n             );\n             ...\n             royaltyVault = _royaltyVault;\n             ...\n         }\n\n**[sofianeOuafir (Joyn) confirmed](https://github.com/code-423n4/2022-03-joyn-findings/issues/73)** \n\n**[deluca-mike (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/73#issuecomment-1153010132):**\n > Downgraded to medium because, while a more automated and validated way of assigning a compatible royalty vault would prevent this issue, in the current framework you'd need to make a user error (albeit one that is not easy to spot), to lose funds.\n\n\n\n***\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-03-joyn-contest",
  "Code": [
    {
      "filename": "core-contracts/contracts/CoreCollection.sol",
      "content": "//SPDX-License-Identifier: Unlicense\r\npragma solidity ^0.8.0;\r\n\r\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\r\nimport {ERC721Enumerable} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\r\n\r\nimport {ERC721Payable} from \"./ERC721Payable.sol\";\r\nimport {ERC721Claimable} from \"./ERC721Claimable.sol\";\r\nimport {IRoyaltyVault} from \"@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol\";\r\n\r\ncontract CoreCollection is\r\n    Ownable,\r\n    ERC721Claimable,\r\n    ERC721Enumerable,\r\n    ERC721Payable\r\n{\r\n    bool public initialized;\r\n    string private _name;\r\n    string private _symbol;\r\n    string private _baseUri;\r\n    uint256 public maxSupply;\r\n    uint256 public startingIndex;\r\n    uint256 public startingIndexBlock;\r\n    string public HASHED_PROOF = \"\";\r\n\r\n    event ClaimInitialized(bytes32 root);\r\n    event NewCollectionMeta(string name, string symbol);\r\n    event NewClaim(address claimedBy, address to, uint256 tokenId);\r\n    event StartingIndexSet(uint256 index);\r\n    event RoyaltyVaultInitialized(address royaltyVault);\r\n    event NewHashedProof(string proof);\r\n    event NewWithdrawal(address to, uint256 amount);\r\n\r\n    constructor() ERC721(\"\", \"\") {}\r\n\r\n    // ----------------- MODIFIER -----------------\r\n\r\n    modifier onlyInitialized() {\r\n        require(initialized, \"CoreCollection: Not initialized\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyUnInitialized() {\r\n        require(!initialized, \"CoreCollection: Already initialized\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyValidSupply(uint256 _maxSupply) {\r\n        require(\r\n            _maxSupply > 0,\r\n            \"CoreCollection: Max supply should be greater than 0\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier tokenExists(uint256 _tokenId) {\r\n        require(_exists(_tokenId), \"CoreCollection: Invalid token id\");\r\n        _;\r\n    }\r\n\r\n    // ----------------- EXTERNAL -----------------\r\n\r\n    /**\r\n     * @notice Initializes the collection\r\n     * @dev This method is being called from the CoreFactory contract\r\n     * @param _collectionName Name of the collection\r\n     * @param _collectionSymbol Symbol of the collection\r\n     * @param _collectionURI Base URI for the collection\r\n     * @param _maxSupply The maximum number of tokens that can be minted\r\n     * @param _mintFee The price of a token in this collection\r\n     * @param _payableToken The address of the ERC20 this collection uses to settle transactions\r\n     * @param _isForSale Whether or not tokens from this collection can be purchased. If false, tokens can only be claimed\r\n     * @param _splitFactory base URI for the collection\r\n     */\r\n    function initialize(\r\n        string memory _collectionName,\r\n        string memory _collectionSymbol,\r\n        string memory _collectionURI,\r\n        uint256 _maxSupply,\r\n        uint256 _mintFee,\r\n        address _payableToken,\r\n        bool _isForSale,\r\n        address _splitFactory\r\n    ) external onlyOwner onlyValidSupply(_maxSupply) {\r\n        _name = _collectionName;\r\n        _symbol = _collectionSymbol;\r\n        _baseUri = _collectionURI;\r\n        maxSupply = _maxSupply;\r\n        mintFee = _mintFee;\r\n        payableToken = IERC20(_payableToken);\r\n        isForSale = _isForSale;\r\n        splitFactory = _splitFactory;\r\n        initialized = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the collection owner to airdrop tokens\r\n     * @dev The Merkle tree defines for each address how much token can be claimed\r\n     * @dev This method can only be called once\r\n     * @param _root A Merkle root\r\n     */\r\n    function initializeClaims(bytes32 _root)\r\n        external\r\n        onlyOwner\r\n        onlyNotClaimableSet\r\n        onlyValidRoot(_root)\r\n    {\r\n        _setMerkelRoot(_root);\r\n        emit ClaimInitialized(_root);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the collection owner to change the collection's name and symbol\r\n     * @dev This function is only callable by the collection's owner\r\n     * @param _collectionName A collection name\r\n     * @param _collectionSymbol A collection symbol\r\n     */\r\n    function setCollectionMeta(\r\n        string memory _collectionName,\r\n        string memory _collectionSymbol\r\n    ) external onlyOwner {\r\n        _name = _collectionName;\r\n        _symbol = _collectionSymbol;\r\n        emit NewCollectionMeta(_collectionName, _collectionSymbol);\r\n    }\r\n\r\n    /**\r\n     * @notice This function is called to mint tokens from this ERC721 collection\r\n     * @dev The collection must be initialized first\r\n     * @param to Token recipient\r\n     * @param isClaim Whether the user want claim a token that has been airdropped to him or want to purchase the token\r\n     * @param claimableAmount The amount of tokens the user has been airdropped\r\n     * @param amount The amount of tokens the user wants to mint\r\n     * @param merkleProof A merkle proof. Needed to verify if the user can claim a token\r\n     */\r\n    function mintToken(\r\n        address to,\r\n        bool isClaim,\r\n        uint256 claimableAmount,\r\n        uint256 amount,\r\n        bytes32[] calldata merkleProof\r\n    ) external onlyInitialized {\r\n        require(amount > 0, \"CoreCollection: Amount should be greater than 0\");\r\n        require(\r\n            totalSupply() + amount <= maxSupply,\r\n            \"CoreCollection: Over Max Supply\"\r\n        );\r\n\r\n        if (isClaim) {\r\n            require(claimableSet(), \"CoreCollection: No claimable\");\r\n            require(\r\n                canClaim(msg.sender, claimableAmount, amount, merkleProof),\r\n                \"CoreCollection: Can't claim\"\r\n            );\r\n            _claim(msg.sender, amount);\r\n        } else {\r\n            require(isForSale, \"CoreCollection: Not for sale\");\r\n            if (mintFee > 0) {\r\n                _handlePayment(mintFee * amount);\r\n            }\r\n        }\r\n\r\n        batchMint(to, amount, isClaim);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the contract owner to withdraw the funds generated by the token sales\r\n     * @dev If a royalty vault isn't set, tokens are kept within this contract and can be withdrawn by the token owner\r\n     */\r\n    function withdraw() external onlyOwner {\r\n        uint256 amount = payableToken.balanceOf(address(this));\r\n        payableToken.transferFrom(address(this), msg.sender, amount);\r\n        emit NewWithdrawal(msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Set royalty vault address for collection\r\n     * @dev All revenue (Primary sales + royalties from secondardy sales) \r\n     * from the collection are transferred to the vault when the vault is initialized\r\n     * @param _royaltyVault The address of the royalty vault\r\n     */\r\n    function setRoyaltyVault(address _royaltyVault)\r\n        external\r\n        onlyVaultUninitialized\r\n    {\r\n        require(\r\n            msg.sender == splitFactory || msg.sender == owner(),\r\n            \"CoreCollection: Only Split Factory or owner can initialize vault.\"\r\n        );\r\n        royaltyVault = _royaltyVault;\r\n        emit RoyaltyVaultInitialized(_royaltyVault);\r\n    }\r\n\r\n    /**\r\n     * @notice Set a provenance hash\r\n     * @dev This hash is used to verify the minting ordering of a collection (Ã  la BAYC)\r\n     * This hash is generated off-chain\r\n     * @param _proof The SHA256 generated hash\r\n     */\r\n    function setHashedProof(string calldata _proof) external onlyOwner {\r\n        require(\r\n            bytes(HASHED_PROOF).length == 0,\r\n            \"CoreCollection: Hashed Proof is set\"\r\n        );\r\n\r\n        HASHED_PROOF = _proof;\r\n        emit NewHashedProof(_proof);\r\n    }\r\n\r\n    // ----------------- PUBLIC -----------------\r\n\r\n    /**\r\n     * @notice Set the mint starting index\r\n     * @dev The starting index can only be generated once\r\n     */\r\n    function setStartingIndex() public {\r\n        require(\r\n            startingIndex == 0,\r\n            \"CoreCollection: Starting index is already set\"\r\n        );\r\n\r\n        startingIndex =\r\n            (uint256(\r\n                keccak256(abi.encodePacked(\"CoreCollection\", block.number))\r\n            ) % maxSupply) +\r\n            1;\r\n        startingIndexBlock = uint256(block.number);\r\n        emit StartingIndexSet(startingIndex);\r\n    }\r\n\r\n    // ---------------- VIEW ----------------\r\n\r\n    function name() public view override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function baseURI() public view returns (string memory) {\r\n        return _baseUri;\r\n    }\r\n\r\n    function _baseURI() internal view override returns (string memory) {\r\n        return _baseUri;\r\n    }\r\n\r\n    // ---------------- PRIVATE ----------------\r\n\r\n    /**\r\n     * @notice Mint token\r\n     * @dev A starting index is calculated at the time of first mint\r\n     * returns a tokenId\r\n     * @param _to Token recipient\r\n     */\r\n    function mint(address _to) private returns (uint256 tokenId) {\r\n        if (startingIndex == 0) {\r\n            setStartingIndex();\r\n        }\r\n        tokenId = ((startingIndex + totalSupply()) % maxSupply) + 1;\r\n        _mint(_to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @notice Mint tokens in batch\r\n     * @param _to Token recipient\r\n     * @param _amount Number of tokens to include in batch\r\n     * @param _isClaim Whether the batch mint is an airdrop or not\r\n     */\r\n    function batchMint(\r\n        address _to,\r\n        uint256 _amount,\r\n        bool _isClaim\r\n    ) private {\r\n        for (uint256 i = 0; i < _amount; i++) {\r\n            uint256 tokenId = mint(_to);\r\n            if (_isClaim) {\r\n                emit NewClaim(msg.sender, _to, tokenId);\r\n            }\r\n        }\r\n    }\r\n\r\n    // ---------------- INTERNAL ----------------\r\n\r\n    /**\r\n     * @notice This hook transfers tokens sitting in the royalty vault to the split contract\r\n     * @dev The split contract is a contract that allows a team to share revenue together\r\n     * @param _from Transfer sender\r\n     * @param _to Transfer recipient\r\n     * @param _tokenId TokenId of token being transferred\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) internal virtual override {\r\n        super._beforeTokenTransfer(_from, _to, _tokenId);\r\n\r\n        if (\r\n            royaltyVault != address(0) &&\r\n            IRoyaltyVault(royaltyVault).getVaultBalance() > 0\r\n        ) {\r\n            IRoyaltyVault(royaltyVault).sendToSplitter();\r\n        }\r\n    }\r\n}"
    },
    {
      "filename": "core-contracts/contracts/ERC721Payable.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nabstract contract ERC721Payable {\n  uint256 public mintFee;\n  IERC20 public payableToken;\n  bool public isForSale;\n  address public royaltyVault;\n  address public splitFactory;\n  event NewPayment(\n    address from,\n    address to,\n    uint256 amount,\n    bool royaltyVaultPayment\n  );\n\n  // ---------------- MODIFIER ----------------\n\n  modifier onlyVaultUninitialized() {\n    require(\n      !royaltyVaultInitialized(),\n      'CoreCollection: Royalty Vault already initialized'\n    );\n    _;\n  }\n\n  modifier onlyVaultInitialized() {\n    require(\n      royaltyVaultInitialized(),\n      'CoreCollection: Royalty Vault not initialized'\n    );\n    _;\n  }\n\n  // ---------------- VIEW ----------------\n\n  function royaltyVaultInitialized() public view returns (bool) {\n    return royaltyVault != address(0);\n  }\n\n  // ---------------- INTERNAL ----------------\n\n  /**\n   * @notice Handles the transfer of ERC20 tokens when a token gets minted\n   * @dev Tokens are transferred to the Royalty Vault if the vault is set\n   * Otherwise, tokens get transferred to the ERC721 collection contract\n   * @param _amount The amount of ERC20 to be transferred\n   */\n  function _handlePayment(uint256 _amount) internal {\n    address recipient = royaltyVaultInitialized()\n      ? royaltyVault\n      : address(this);\n    payableToken.transferFrom(msg.sender, recipient, _amount);\n    emit NewPayment(msg.sender, recipient, _amount, royaltyVaultInitialized());\n  }\n}"
    },
    {
      "filename": "royalty-vault/contracts/RoyaltyVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {IRoyaltyVault} from \"../interfaces/IRoyaltyVault.sol\";\nimport {VaultStorage} from \"./VaultStorage.sol\";\nimport {ISplitter} from \"../interfaces/ISplitter.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract RoyaltyVault is VaultStorage, IRoyaltyVault, ERC165, Ownable {\n    /**** Events ****/\n    event RoyaltySentToSplitter(address indexed splitter, uint256 amount);\n    event FeeSentToPlatform(\n        address indexed platformFeeRecipient,\n        uint256 amount\n    );\n    event NewRoyaltyVaultPlatformFee(uint256 platformFee);\n    event NewRoyaltyVaultPlatformFeeRecipient(address recipient);\n\n    /**\n     * @dev Getting royaltyAsset balance of Vault.\n     */\n    function getVaultBalance() public view override returns (uint256) {\n        return IERC20(royaltyAsset).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Send accumulated royalty to splitter.\n     */\n    function sendToSplitter() external override {\n        uint256 balanceOfVault = getVaultBalance();\n\n        require(\n            balanceOfVault > 0,\n            \"Vault does not have enough royalty Asset to send\"\n        );\n        require(splitterProxy != address(0), \"Splitter is not set\");\n\n        uint256 platformShare = (balanceOfVault * platformFee) / 10000;\n        uint256 splitterShare = balanceOfVault - platformShare;\n\n        require(\n            IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,\n            \"Failed to transfer royalty Asset to splitter\"\n        );\n        require(\n            ISplitter(splitterProxy).incrementWindow(splitterShare) == true,\n            \"Failed to increment splitter window\"\n        );\n        require(\n            IERC20(royaltyAsset).transfer(\n                platformFeeRecipient,\n                platformShare\n            ) == true,\n            \"Failed to transfer royalty Asset to platform fee recipient\"\n        );\n\n        emit RoyaltySentToSplitter(splitterProxy, splitterShare);\n        emit FeeSentToPlatform(platformFeeRecipient, platformShare);\n    }\n\n    /**\n     * @dev Set Platform fee for collection contract.\n     * @param _platformFee Platform fee in scaled percentage.\n     */\n    function setPlatformFee(uint256 _platformFee) external override onlyOwner {\n        platformFee = _platformFee;\n        emit NewRoyaltyVaultPlatformFee(_platformFee);\n    }\n\n    /**\n     * @dev Set Platform fee recipient for collection.\n     * @param _platformFeeRecipient Platform fee recipient address\n     */\n    function setPlatformFeeRecipient(address _platformFeeRecipient)\n        external\n        override\n        onlyOwner\n    {\n        platformFeeRecipient = _platformFeeRecipient;\n        emit NewRoyaltyVaultPlatformFeeRecipient(_platformFeeRecipient);\n    }\n\n    /**\n     * @dev Get Splitter address of proxyVault.\n     */\n    function getSplitter() public view override returns (address) {\n        return splitterProxy;\n    }\n\n    /**\n     * @dev Checks for support of IRoyaltyVault.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(IRoyaltyVault, ERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IRoyaltyVault).interfaceId;\n    }\n}"
    }
  ]
}