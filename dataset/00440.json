{
  "Title": "M-21: Balancer using safeApprove may lead to revert.",
  "Content": "# Issue M-21: Balancer using safeApprove may lead to revert. \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/94 \n\n## Found by \nbin2chen\n## Summary\nWhen executing `Balancer._routerSwap()`, the `oz` `safeApprove` function is used to set an allowance. \nDue to the presence of the `convertRate` in the `router`, `Balancer._routerSwap()` rounds down the incoming quantity. \nThis behavior may result in the allowance not being fully use, causing a subsequent execution of `oz.safeApprove()` to revert.\n\n## Vulnerability Detail\nThe code snippet for `Balancer._routerSwap()` is as follows:\n\n\n```solidity\n    function _routerSwap(\n        uint16 _dstChainId,\n        uint256 _srcPoolId,\n        uint256 _dstPoolId,\n        uint256 _amount,\n        uint256 _slippage,\n        address payable _oft,\n        address _erc20\n    ) private {\n        bytes memory _dst = abi.encodePacked(connectedOFTs[_oft][_dstChainId].dstOft);\n@>      IERC20(_erc20).safeApprove(address(router), _amount);\n        router.swap{value: msg.value}(\n            _dstChainId,\n            _srcPoolId,\n            _dstPoolId,\n            payable(this),\n            _amount,\n            _computeMinAmount(_amount, _slippage),\n            IStargateRouterBase.lzTxObj({dstGasForCall: 0, dstNativeAmount: 0, dstNativeAddr: \"0x0\"}),\n            _dst,\n            \"0x\"\n        );\n    }\n```\nIn the above code, `SafeERC20.safeApprove()` from the `oz` library is used, but the allowance is not cleared afterward. Consequently, if the current allowance is not fully use during this transaction, a subsequent execution of `SafeERC20.safeApprove()` will revert.\n\nIs it guaranteed that `router.swap()` will fully use the allowance?\nNot necessarily. Due to the presence of `convertRate` in the implementation code, the `router` rounds down the amount, potentially leaving a remainder in the allowance.\nDAI pool convertRate = 1e12\nDAI pool: https://etherscan.io/address/0x0Faf1d2d3CED330824de3B8200fc8dc6E397850d#readContract\n\nrouter codes:\nhttps://etherscan.io/address/0x8731d54E9D02c286767d56ac03e8037C07e01e98#code\n```solidity\n    function swap(\n        uint16 _dstChainId,\n        uint256 _srcPoolId,\n        uint256 _dstPoolId,\n        address payable _refundAddress,\n        uint256 _amountLD,\n        uint256 _minAmountLD,\n        lzTxObj memory _lzTxParams,\n        bytes calldata _to,\n        bytes calldata _payload\n    ) external payable override nonReentrant {\n        require(_amountLD > 0, \"Stargate: cannot swap 0\");\n        require(_refundAddress != address(0x0), \"Stargate: _refundAddress cannot be 0x0\");\n        Pool.SwapObj memory s;\n        Pool.CreditObj memory c;\n        {\n            Pool pool = _getPool(_srcPoolId);\n            {\n@>              uint256 convertRate = pool.convertRate();\n@>              _amountLD = _amountLD.div(convertRate).mul(convertRate);\n            }\n\n            s = pool.swap(_dstChainId, _dstPoolId, msg.sender, _amountLD, _minAmountLD, true);\n            _safeTransferFrom(pool.token(), msg.sender, address(pool), _amountLD);\n            c = pool.sendCredits(_dstChainId, _dstPoolId);\n        }\n        bridge.swap{value: msg.value}(_dstChainId, _srcPoolId, _dstPoolId, _refundAddress, c, s, _lzTxParams, _to, _payload);\n    }\n```\n\n## Impact\n\nUnused allowance may lead to failure in subsequent `_routerSwap()` executions.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/TapiocaZ/contracts/Balancer.sol#L308\n## Tool used\n\nManual Review\n\n## Recommendation\n```diff\n    function _routerSwap(\n        uint16 _dstChainId,\n        uint256 _srcPoolId,\n        uint256 _dstPoolId,\n        uint256 _amount,\n        uint256 _slippage,\n        address payable _oft,\n        address _erc20\n    ) private {\n        bytes memory _dst = abi.encodePacked(connectedOFTs[_oft][_dstChainId].dstOft);\n        IERC20(_erc20).safeApprove(address(router), _amount);\n        router.swap{value: msg.value}(\n            _dstChainId,\n            _srcPoolId,\n            _dstPoolId,\n            payable(this),\n            _amount,\n            _computeMinAmount(_amount, _slippage),\n            IStargateRouterBase.lzTxObj({dstGasForCall: 0, dstNativeAmount: 0, dstNativeAddr: \"0x0\"}),\n            _dst,\n            \"0x\"\n        );\n+       IERC20(_erc20).safeApprove(address(router), 0);\n```\n\n\n\n## Discussion\n\n**maarcweiss**\n\nYeah, this might happen. We should add it. What are your thoughts on using forceApprove instead from OZ, I think pending allowances would not make a revert and it would be cleaner. Though in some places you might want to just change it to 0 after.\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid; medium(4)\n\n\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Tapioca-DAO/TapiocaZ/pull/181.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "TapiocaZ/contracts/Balancer.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {IStargateRouter, IStargateRouterBase} from \"tapioca-periph/interfaces/external/stargate/IStargateRouter.sol\";\nimport {IStargateEthVault} from \"tapioca-periph/interfaces/external/stargate/IStargateEthVault.sol\";\nimport {ITOFTVault} from \"tapioca-periph/interfaces/tapiocaz/ITOFTVault.sol\";\nimport {ITOFT} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title Balancer\n * @author TapiocaDAO\n * @notice Rebalances mTOFT by transferring underlying tokens to other layers through Stargate\n */\ncontract Balancer is Ownable {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice current OFT => chain => destination OFT\n     * @dev chain ids (https://stargateprotocol.gitbook.io/stargate/developers/chain-ids):\n     *         - Ethereum: 101\n     *         - BNB: 102\n     *         - Avalanche: 106\n     *         - Polygon: 109\n     *         - Arbitrum: 110\n     *         - Optimism: 111\n     *         - Fantom: 112\n     *         - Metis: 151\n     *     pool ids https://stargateprotocol.gitbook.io/stargate/developers/pool-ids\n     */\n    mapping(address => mapping(uint16 => OFTData)) public connectedOFTs;\n\n    struct OFTData {\n        uint256 srcPoolId;\n        uint256 dstPoolId;\n        address dstOft;\n        uint256 rebalanceable;\n    }\n\n    IStargateRouter public immutable routerETH;\n    IStargateRouter public immutable router;\n\n    address public rebalancer;\n\n    // @dev swapEth is not available on some chains\n    bool public disableEth;\n\n    event ConnectedChainUpdated(address indexed _srcOft, uint16 indexed _dstChainId, address indexed _dstOft);\n    event Rebalanced(\n        address indexed _srcOft, uint16 indexed _dstChainId, uint256 indexed _slippage, uint256 _amount, bool _isNative\n    );\n    event RebalanceAmountUpdated(\n        address indexed _srcOft, uint16 indexed _dstChainId, uint256 indexed _amount, uint256 _totalAmount\n    );\n    event ToggledSwapEth(bool indexed _old, bool indexed _new);\n    event EmergencySaved(address indexed _token, uint256 indexed _amount, bool indexed _native);\n    event RebalancerUpdated(address indexed prev, address indexed current);\n\n    error NotAuthorized();\n    error RouterNotValid();\n    error ExceedsBalance();\n    error DestinationNotValid();\n    error SlippageNotValid();\n    error FeeAmountNotSet();\n    error PoolInfoRequired();\n    error RebalanceAmountNotSet();\n    error Failed();\n    error SwapNotEnabled();\n    error AlreadyInitialized();\n    error RebalanceAmountNotValid();\n\n    modifier onlyValidDestination(address _srcOft, uint16 _dstChainId) {\n        if (connectedOFTs[_srcOft][_dstChainId].dstOft == address(0)) {\n            revert DestinationNotValid();\n        }\n        _;\n    }\n\n    modifier onlyValidSlippage(uint256 _slippage) {\n        // @dev a slippage higher than 20% shouldn't be necessary\n        if (_slippage >= 2e4) revert SlippageNotValid();\n        _;\n    }\n\n    constructor(address _routerETH, address _router, address _owner) {\n        if (_router == address(0)) revert RouterNotValid();\n        if (_routerETH == address(0)) revert RouterNotValid();\n        routerETH = IStargateRouter(_routerETH);\n        router = IStargateRouter(_router);\n\n        transferOwnership(_owner);\n        rebalancer = _owner;\n        emit RebalancerUpdated(address(0), _owner);\n    }\n\n    receive() external payable {}\n\n    /// =====================\n    /// View\n    /// =====================\n    function checker(address payable _srcOft, uint16 _dstChainId, uint256 _slippage)\n        external\n        view\n        returns (bool canExec, bytes memory execPayload)\n    {\n        bytes memory ercData;\n        {\n            if (ITOFT(_srcOft).erc20() != address(0)) {\n                ercData = abi.encode(\n                    connectedOFTs[_srcOft][_dstChainId].srcPoolId, connectedOFTs[_srcOft][_dstChainId].dstPoolId\n                );\n            }\n        }\n\n        canExec = connectedOFTs[_srcOft][_dstChainId].rebalanceable > 0;\n        execPayload = abi.encodeCall(\n            Balancer.rebalance,\n            (_srcOft, _dstChainId, _slippage, connectedOFTs[_srcOft][_dstChainId].rebalanceable, ercData)\n        );\n    }\n\n    /// =====================\n    /// Owner\n    /// =====================\n\n    /**\n     * @notice set rebalancer role\n     * @param _addr the new address\n     */\n    function setRebalancer(address _addr) external onlyOwner {\n        rebalancer = _addr;\n        emit RebalancerUpdated(rebalancer, _addr);\n    }\n\n    /**\n     * @notice toggle swap eth\n     * @param _val true/false\n     */\n    function setSwapEth(bool _val) external onlyOwner {\n        emit ToggledSwapEth(disableEth, _val);\n        disableEth = _val;\n    }\n\n    /**\n     * @notice performs a rebalance operation\n     * @dev callable only by the owner\n     * @param _srcOft the source TOFT address\n     * @param _dstChainId the destination LayerZero id\n     * @param _slippage the destination LayerZero id\n     * @param _amount the rebalanced amount\n     * @param _ercData custom send data\n     */\n    function rebalance(\n        address payable _srcOft,\n        uint16 _dstChainId,\n        uint256 _slippage,\n        uint256 _amount,\n        bytes memory _ercData\n    ) external payable onlyValidDestination(_srcOft, _dstChainId) onlyValidSlippage(_slippage) {\n        if (msg.sender != owner() || msg.sender != rebalancer) revert NotAuthorized();\n\n        if (connectedOFTs[_srcOft][_dstChainId].rebalanceable < _amount) {\n            revert RebalanceAmountNotSet();\n        }\n\n        //extract\n        ITOFT(_srcOft).extractUnderlying(_amount);\n\n        //send\n        {\n            bool _isNative = ITOFT(_srcOft).erc20() == address(0);\n            if (msg.value == 0) revert FeeAmountNotSet();\n            if (_isNative) {\n                if (disableEth) revert SwapNotEnabled();\n                _sendNative(_srcOft, _amount, _dstChainId, _slippage);\n            } else {\n                _sendToken(_srcOft, _amount, _dstChainId, _slippage, _ercData);\n            }\n\n            connectedOFTs[_srcOft][_dstChainId].rebalanceable -= _amount;\n            emit Rebalanced(_srcOft, _dstChainId, _slippage, _amount, _isNative);\n        }\n    }\n\n    /**\n     * @notice saves token/native gas from this contract\n     * @param _token the token address; `address(0)` should be passed for the Native coin\n     * @param _amount the amount to be saved\n     */\n    function emergencySaveTokens(address _token, uint256 _amount) external onlyOwner {\n        if (_token == address(0)) {\n            (bool sent,) = msg.sender.call{value: _amount}(\"\");\n            if (!sent) revert Failed();\n            emit EmergencySaved(_token, _amount, true);\n        } else {\n            IERC20(_token).safeTransfer(msg.sender, _amount);\n            emit EmergencySaved(_token, _amount, false);\n        }\n    }\n\n    /**\n     * @notice registeres mTapiocaOFT for rebalancing\n     * @param _srcOft the source TOFT address\n     * @param _dstChainId the destination LayerZero id\n     * @param _dstOft the destination TOFT address\n     * @param _ercData custom send data\n     */\n    function initConnectedOFT(address _srcOft, uint16 _dstChainId, address _dstOft, bytes memory _ercData)\n        external\n        onlyOwner\n    {\n        if (connectedOFTs[_srcOft][_dstChainId].rebalanceable > 0) {\n            revert AlreadyInitialized();\n        }\n        bool isNative = ITOFT(_srcOft).erc20() == address(0);\n        if (!isNative && _ercData.length == 0) revert PoolInfoRequired();\n\n        (uint256 _srcPoolId, uint256 _dstPoolId) = abi.decode(_ercData, (uint256, uint256));\n\n        OFTData memory oftData =\n            OFTData({srcPoolId: _srcPoolId, dstPoolId: _dstPoolId, dstOft: _dstOft, rebalanceable: 0});\n\n        connectedOFTs[_srcOft][_dstChainId] = oftData;\n        emit ConnectedChainUpdated(_srcOft, _dstChainId, _dstOft);\n    }\n\n    /**\n     * @notice assings more rebalanceable amount for TOFT\n     * @param _srcOft the source TOFT address\n     * @param _dstChainId the destination LayerZero id\n     * @param _amount the rebalanced amount\n     */\n    function addRebalanceAmount(address _srcOft, uint16 _dstChainId, uint256 _amount)\n        external\n        onlyValidDestination(_srcOft, _dstChainId)\n        onlyOwner\n    {\n        connectedOFTs[_srcOft][_dstChainId].rebalanceable += _amount;\n        uint256 totalToftSupply = ITOFTVault(ITOFT(_srcOft).vault()).viewSupply();\n        if (connectedOFTs[_srcOft][_dstChainId].rebalanceable > totalToftSupply) {\n            revert RebalanceAmountNotValid();\n        }\n        emit RebalanceAmountUpdated(_srcOft, _dstChainId, _amount, connectedOFTs[_srcOft][_dstChainId].rebalanceable);\n    }\n\n    function retryRevert(uint16 _srcChainId, bytes calldata _srcAddress, uint256 _nonce) external payable onlyOwner {\n        router.retryRevert{value: msg.value}(_srcChainId, _srcAddress, _nonce);\n    }\n\n    /// =====================\n    /// Private\n    /// =====================\n    function _sendNative(address payable _oft, uint256 _amount, uint16 _dstChainId, uint256 _slippage) private {\n        if (address(this).balance < _amount) revert ExceedsBalance();\n        uint256 valueAmount = msg.value + _amount;\n        routerETH.swapETH{value: valueAmount}(\n            _dstChainId,\n            payable(this),\n            abi.encodePacked(connectedOFTs[_oft][_dstChainId].dstOft),\n            _amount,\n            _computeMinAmount(_amount, _slippage)\n        );\n    }\n\n    function _sendToken(\n        address payable _oft,\n        uint256 _amount,\n        uint16 _dstChainId,\n        uint256 _slippage,\n        bytes memory _data\n    ) private {\n        address erc20 = ITOFT(_oft).erc20();\n        if (IERC20Metadata(erc20).balanceOf(address(this)) < _amount) {\n            revert ExceedsBalance();\n        }\n        {\n            (uint256 _srcPoolId, uint256 _dstPoolId) = abi.decode(_data, (uint256, uint256));\n            _routerSwap(_dstChainId, _srcPoolId, _dstPoolId, _amount, _slippage, _oft, erc20);\n        }\n    }\n\n    function _routerSwap(\n        uint16 _dstChainId,\n        uint256 _srcPoolId,\n        uint256 _dstPoolId,\n        uint256 _amount,\n        uint256 _slippage,\n        address payable _oft,\n        address _erc20\n    ) private {\n        bytes memory _dst = abi.encodePacked(connectedOFTs[_oft][_dstChainId].dstOft);\n        IERC20(_erc20).safeApprove(address(router), _amount);\n        router.swap{value: msg.value}(\n            _dstChainId,\n            _srcPoolId,\n            _dstPoolId,\n            payable(this),\n            _amount,\n            _computeMinAmount(_amount, _slippage),\n            IStargateRouterBase.lzTxObj({dstGasForCall: 0, dstNativeAmount: 0, dstNativeAddr: \"0x0\"}),\n            _dst,\n            \"0x\"\n        );\n    }\n\n    function _computeMinAmount(uint256 _amount, uint256 _slippage) private pure returns (uint256) {\n        return _amount - ((_amount * _slippage) / 1e5);\n    }\n}"
    }
  ]
}