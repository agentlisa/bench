{
  "Title": "[M-11] Incorrect source address decoding in RootBridgeAgent and BranchBridgeAgent's `_requiresEndpoint` breaks LayerZero communication",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/RootBridgeAgent.sol#L1212> \n\n<https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BranchBridgeAgent.sol#L943>\n\n### Vulnerability details\n\nWhen bridge agent contracts communicate through the LayerZero endpoint, the source contract encodes the `_destination` parameter of the `ILayerZeroEndpoint.send` call by concatenating the destination address (first) and the source address (second):\n\n```Solidity\n   // BranchBridgeAgent.sol:142\n   rootBridgeAgentPath = abi.encodePacked(_rootBridgeAgentAddress, address(this)); \n\n   // BranchBridgeAgent.sol:770\n   ILayerZeroEndpoint(lzEndpointAddress).send{value: msg.value}(\n            rootChainId,\n            rootBridgeAgentPath,\n            _payload,\n            payable(_refundee),\n            address(0),\n            abi.encodePacked(uint16(2), _gParams.gasLimit, _gParams.remoteBranchExecutionGas, rootBridgeAgentAddress)\n        );\n```\n\n```Solidity\n    // RootBridgeAgent.sol:1182\n    getBranchBridgeAgentPath[_branchChainId] = abi.encodePacked(_newBranchBridgeAgent, address(this));\n\n    // RootBridgeAgent.sol:823\n    ILayerZeroEndpoint(lzEndpointAddress).send{value: msg.value}(\n        _dstChainId,\n        getBranchBridgeAgentPath[_dstChainId],\n        _payload,\n        _refundee,\n        address(0),\n        abi.encodePacked(uint16(2), _gParams.gasLimit, _gParams.remoteBranchExecutionGas, callee)\n    );\n```\n\nWhen the message is received on the destination chain, the destination agent validates that the sending address is correct after decoding it from the last 20 bytes of the `_srcAddress` parameter in the `ILayerZeroReceiver.lzReceive` call:\n\n```Solidity\n    // RootBridgeAgent.sol:1212\n    if (getBranchBridgeAgent[_srcChain] != address(uint160(bytes20(_srcAddress[PARAMS_ADDRESS_SIZE:])))) {\n        revert LayerZeroUnauthorizedCaller();\n    }\n```\n\n```Solidity\n    // BranchBridgeAgent.sol:943\n    if (rootBridgeAgentAddress != address(uint160(bytes20(_srcAddress[20:])))) revert LayerZeroUnauthorizedCaller();\n```\n\nThis byte selection is incorrect, because when calls pass by actual LayerZero logic, the `_srcAddress` in `lzReceive` is not equal to the `_destination` passed to `send`.\n\nIn a real-world scenario, by looking up the last bytes of `_srcAddress`, the destination agent will always extract **its own address** instead of the remote source contract's and the validation this address maps to a valid sender on the source chain will consequently always fail.\n\n### Impact\n\nSince the faulty logic is a single entry point for communication between chains, it is also a single point of failure. This vulnerability effectively shuts down the whole branch-to-root and root-to-branch inter-chain communication.\n\nAn example high-severity impact scenario is: if after the contracts are deployed any tokens are added and bridged (i.e. out of a branch chain), these will remain permanently locked in the source chain's BranchPort as this vulnerability does not prevent the source operations from completing.\n\nThe tokens will not be recoverable because:\n- The bridged messages will revert in the destination (root) chain, failing to mint any hToken there that could later be bridged back to rescue the original assets.\n\n- The retrieve/redeem/retry logic in place for unlocking funds after remote errors would not be a viable way out because it depends on the faulty cross-chain channel too.\n\n### Proof of Concept\n\nThis vulnerability can be verified by instantiating a BranchBridgeAgent and a RootBridgeAgent contract and connecting them via [LayerZero's mock endpoint](https://layerzero.gitbook.io/docs/evm-guides/code-examples/lzendpointmock.sol).\n\nThis mock, much like the productive endpoint, inverts the order of the bytes in `_destination` and `_srcAddress` (relevant code below), effectively breaking the assumption that these are equal and enabling the reproduction of the issue:\n\n```Solidity\n    // LzEndpointMock.sol:113\n    function send(uint16 _chainId, bytes memory _path, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams) external payable override sendNonReentrant {\n        require(_path.length == 40, \"LayerZeroMock: incorrect remote address size\"); // only support evm chains\n\n        address dstAddr;\n        assembly {\n            dstAddr := mload(add(_path, 20))\n        }\n\n        // LzEndpointMock:148\n        bytes memory srcUaAddress = abi.encodePacked(msg.sender, dstAddr); // cast this address to bytes\n        bytes memory payload = _payload;\n        LZEndpointMock(lzEndpoint).receivePayload(mockChainId, srcUaAddress, dstAddr, nonce, extraGas, payload);\n    }\n```\n\nA full runnable foundry test showing the failure in an integrated scenario is below:\n\n```Solidity\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\n\nimport {BranchBridgeAgent} from \"src/BranchBridgeAgent.sol\";\nimport {RootBridgeAgent} from \"src/RootBridgeAgent.sol\";\nimport {GasParams} from \"src/interfaces/BridgeAgentStructs.sol\";\n\n// as taken from here:\n// https://github.com/LayerZero-Labs/solidity-examples/blob/main/contracts/mocks/LZEndpointMock.sol\nimport {LZEndpointMock} from \"./ulysses-omnichain/mocks/LZEndpointMock.sol\";\n\ncontract SourceAddrPoc is Test {\n    function testIncorrectValidation() public {\n        uint16 rootChainId = 9;\n        uint16 branchChainId = 10;\n\n        // simulate a real L0 bridge in between\n        LZEndpointMock rootLzEndpoint = new LZEndpointMock(rootChainId);\n        LZEndpointMock branchLzEndpoint = new LZEndpointMock(branchChainId);\n\n        RootBridgeAgent rba = new RootBridgeAgent(\n            rootChainId,             // localChainId\n            address(rootLzEndpoint), // _lzEndpointAddress\n            address(this),           // _localPortAddress\n            address(this)            // _localRouterAddress\n        );\n\n        BranchBridgeAgent bba = new BranchBridgeAgent(\n            rootChainId,               // _rootChainId\n            branchChainId,             // _localChainId\n            address(rba),              // _rootBridgeAgentAddress\n            address(branchLzEndpoint), // _lzEndpointAddress\n            address(this),             // _localRouterAddress\n            address(this)              // _localPortAddress\n        );\n\n        // BranchBridgeAgent knows already the address of RootBridgeAgent from its construction,\n        // here we tell RootBridgeAgent where BranchBridgeAgent is\n        rba.syncBranchBridgeAgent(address(bba), branchChainId);\n\n        rootLzEndpoint.setDestLzEndpoint(address(bba), address(branchLzEndpoint));\n        branchLzEndpoint.setDestLzEndpoint(address(rba), address(rootLzEndpoint));\n\n        // communication root -> branch is broken (incorrect src address validation in branch)\n        // this triggers a silently ignored \"LayerZeroUnauthorizedCaller()\" revert that can\n        // be logged with -vvvv verbose testing:\n        //\n        //  ├─ [1393] BranchBridgeAgent::lzReceiveNonBlocking(...)\n        //  │   └─ ← \"LayerZeroUnauthorizedCaller()\"\n        //  └─ ← ()\n        rba.callOut{value: 22001375000000000}(\n            payable(address(this)), // _refundee\n            address(this), // _recipient\n            branchChainId, // _dstChainId,\n            \"\", // _params\n            GasParams(1_000_000, 0) // _gParams\n        );\n\n        // communication branch -> root is broken too (incorrect src address validation in root)\n        // here, too, we have the same silently ignored error:\n        //\n        //    │   │   │   │   ├─ [3789] RootBridgeAgent::lzReceiveNonBlocking(..)\n        //    │   │   │   │   │   └─ ← \"LayerZeroUnauthorizedCaller()\"\n        //    │   │   │   │   └─ ← ()\n        bba.callOut{value: 22001155000000000}(\n            payable(address(this)), // _refundee\n            \"\", // _params\n            GasParams(1_000_000, 0) // _gParams\n        );\n    }\n}\n```\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nThe following changes fix the inter-chain integration:\n\n```diff\n    // RootBridgeAgent.sol:1204\n    modifier requiresEndpoint(address _endpoint, uint16 _srcChain, bytes calldata _srcAddress) virtual {\n        if (msg.sender != address(this)) revert LayerZeroUnauthorizedEndpoint();\n\n        if (_endpoint != getBranchBridgeAgent[localChainId]) {\n            if (_endpoint != lzEndpointAddress) revert LayerZeroUnauthorizedEndpoint();\n\n-            if (getBranchBridgeAgent[_srcChain] != address(uint160(bytes20(_srcAddress[PARAMS_ADDRESS_SIZE:])))) {\n+            if (getBranchBridgeAgent[_srcChain] != address(uint160(bytes20(_srcAddress[:PARAMS_ADDRESS_SIZE])))) {\n                revert LayerZeroUnauthorizedCaller();\n            }\n        }\n        _;\n    }\n```\n\n```diff\n    // BranchBridgeAgent.sol:936\n    function _requiresEndpoint(address _endpoint, bytes calldata _srcAddress) internal view virtual {\n        //Verify Endpoint\n        if (msg.sender != address(this)) revert LayerZeroUnauthorizedEndpoint();\n        if (_endpoint != lzEndpointAddress) revert LayerZeroUnauthorizedEndpoint();\n\n        //Verify Remote Caller\n        if (_srcAddress.length != 40) revert LayerZeroUnauthorizedCaller();\n-        if (rootBridgeAgentAddress != address(uint160(bytes20(_srcAddress[20:])))) revert LayerZeroUnauthorizedCaller();\n+        if (rootBridgeAgentAddress != address(uint160(bytes20(_srcAddress[:20])))) revert LayerZeroUnauthorizedCaller();\n    }\n```\n\nIt is also recommended to add tests for agents in an integration scenario that leverages [the LzEndpointMock.sol contract provided by the LayerZero team](https://layerzero.gitbook.io/docs/evm-guides/code-examples/lzendpointmock.sol), who [use it for their own testing](https://layerzero.gitbook.io/docs/evm-guides/code-examples/lzendpointmock.sol).\n\n### Assessed type\n\nen/de-code\n\n**[alcueca (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-09-maia-findings/issues/348#issuecomment-1780948736):**\n > From the sponsor:\n> > Although, losing assets seems possible in paper, it is certain this would ever happen in production, since the initial set up of the system namely the addition of new chains or any tokens would all fail. The only functioning branch for deposits would be the Arbitrum Branch that circumvents these checks and would not have any issues withdrawing assets. There would not be any branches in remote networks since any messages setting up the connection new branches and the root chain would fail due to the validation issue being described.\n\n**[0xLightt (Maia) confirmed](https://github.com/code-423n4/2023-09-maia-findings/issues/348#issuecomment-1787991099)**\n\n**[0xBugsy (Maia) commented](https://github.com/code-423n4/2023-09-maia-findings/issues/348#issuecomment-1807198546):**\n > Addressed [here](https://github.com/Maia-DAO/2023-09-maia-remediations/commit/4d2825cd4e73a69ad33bccaf2ceb07443f127beb).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-09-maia",
  "Code": [
    {
      "filename": "src/RootBridgeAgent.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ExcessivelySafeCall} from \"lib/ExcessivelySafeCall.sol\";\n\nimport {ILayerZeroEndpoint} from \"./interfaces/ILayerZeroEndpoint.sol\";\n\nimport {IBranchBridgeAgent} from \"./interfaces/IBranchBridgeAgent.sol\";\nimport {IERC20hTokenRoot} from \"./interfaces/IERC20hTokenRoot.sol\";\n\nimport {BridgeAgentConstants} from \"./interfaces/BridgeAgentConstants.sol\";\nimport {\n    GasParams,\n    DepositParams,\n    DepositMultipleParams,\n    ILayerZeroReceiver,\n    IRootBridgeAgent,\n    Settlement,\n    SettlementInput,\n    SettlementMultipleInput\n} from \"./interfaces/IRootBridgeAgent.sol\";\n\nimport {IRootPort as IPort} from \"./interfaces/IRootPort.sol\";\n\nimport {VirtualAccount} from \"./VirtualAccount.sol\";\nimport {DeployRootBridgeAgentExecutor, RootBridgeAgentExecutor} from \"./RootBridgeAgentExecutor.sol\";\n\n/// @title Root Bridge Agent Contract\n/// @author MaiaDAO\ncontract RootBridgeAgent is IRootBridgeAgent, BridgeAgentConstants {\n    using SafeTransferLib for address;\n    using ExcessivelySafeCall for address;\n    /*///////////////////////////////////////////////////////////////\n                        ROOT BRIDGE AGENT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Local Chain Id\n    uint16 public immutable localChainId;\n\n    /// @notice Bridge Agent Factory Address.\n    address public immutable factoryAddress;\n\n    /// @notice Local Core Root Router Address\n    address public immutable localRouterAddress;\n\n    /// @notice Local Port Address where funds deposited from this chain are stored.\n    address public immutable localPortAddress;\n\n    /// @notice Local Layer Zero Endpoint Address for cross-chain communication.\n    address public immutable lzEndpointAddress;\n\n    /// @notice Address of Root Bridge Agent Executor.\n    address public immutable bridgeAgentExecutorAddress;\n\n    /*///////////////////////////////////////////////////////////////\n                        BRANCH BRIDGE AGENTS STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Chain -> Branch Bridge Agent Address. For N chains, each Root Bridge Agent Address has M =< N Branch Bridge Agent Address.\n    mapping(uint256 chainId => address branchBridgeAgent) public getBranchBridgeAgent;\n\n    /// @notice Message Path for each connected Branch Bridge Agent as bytes for Layzer Zero interaction = localAddress + destinationAddress abi.encodePacked()\n    mapping(uint256 chainId => bytes branchBridgeAgentPath) public getBranchBridgeAgentPath;\n\n    /// @notice If true, bridge agent manager has allowed for a new given branch bridge agent to be synced/added.\n    mapping(uint256 chainId => bool allowed) public isBranchBridgeAgentAllowed;\n\n    /*///////////////////////////////////////////////////////////////\n                            SETTLEMENTS STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Deposit nonce used for identifying transaction.\n    uint32 public settlementNonce;\n\n    /// @notice Mapping from Settlement nonce to Settlement Struct.\n    mapping(uint256 nonce => Settlement settlementInfo) public getSettlement;\n\n    /*///////////////////////////////////////////////////////////////\n                            EXECUTOR STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice If true, bridge agent has already served a request with this nonce from  a given chain. Chain -> Nonce -> Bool\n    mapping(uint256 chainId => mapping(uint256 nonce => uint256 state)) public executionState;\n\n    /*///////////////////////////////////////////////////////////////\n                            REENTRANCY STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Re-entrancy lock modifier state.\n    uint256 internal _unlocked = 1;\n\n    /*///////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Constructor for Bridge Agent.\n     *     @param _localChainId Local Chain Id.\n     *     @param _lzEndpointAddress Local Layerzero Endpoint Address.\n     *     @param _localPortAddress Local Port Address.\n     *     @param _localRouterAddress Local Port Address.\n     */\n    constructor(\n        uint16 _localChainId,\n        address _lzEndpointAddress,\n        address _localPortAddress,\n        address _localRouterAddress\n    ) {\n        require(_lzEndpointAddress != address(0), \"Layerzero Enpoint Address cannot be zero address\");\n        require(_localPortAddress != address(0), \"Port Address cannot be zero address\");\n        require(_localRouterAddress != address(0), \"Router Address cannot be zero address\");\n\n        factoryAddress = msg.sender;\n        localChainId = _localChainId;\n        lzEndpointAddress = _lzEndpointAddress;\n        localPortAddress = _localPortAddress;\n        localRouterAddress = _localRouterAddress;\n        bridgeAgentExecutorAddress = DeployRootBridgeAgentExecutor.deploy(address(this));\n        settlementNonce = 1;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        FALLBACK FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    receive() external payable {}\n\n    /*///////////////////////////////////////////////////////////////\n                        VIEW EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootBridgeAgent\n    function getSettlementEntry(uint32 _settlementNonce) external view override returns (Settlement memory) {\n        return getSettlement[_settlementNonce];\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function getFeeEstimate(\n        uint256 _gasLimit,\n        uint256 _remoteBranchExecutionGas,\n        bytes calldata _payload,\n        uint16 _dstChainId\n    ) external view returns (uint256 _fee) {\n        (_fee,) = ILayerZeroEndpoint(lzEndpointAddress).estimateFees(\n            _dstChainId,\n            address(this),\n            _payload,\n            false,\n            abi.encodePacked(uint16(2), _gasLimit, _remoteBranchExecutionGas, getBranchBridgeAgent[_dstChainId])\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    ROOT ROUTER EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootBridgeAgent\n    function callOut(\n        address payable _refundee,\n        address _recipient,\n        uint16 _dstChainId,\n        bytes calldata _params,\n        GasParams calldata _gParams\n    ) external payable override lock requiresRouter {\n        //Encode Data for call.\n        bytes memory payload = abi.encodePacked(bytes1(0x00), _recipient, settlementNonce++, _params);\n\n        //Perform Call to clear hToken balance on destination branch chain.\n        _performCall(_dstChainId, _refundee, payload, _gParams);\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function callOutAndBridge(\n        address payable _refundee,\n        address _recipient,\n        uint16 _dstChainId,\n        bytes calldata _params,\n        SettlementInput calldata _sParams,\n        GasParams calldata _gParams,\n        bool _hasFallbackToggled\n    ) external payable override lock requiresRouter {\n        // Create Settlement and Perform call\n        bytes memory payload = _createSettlement(\n            settlementNonce,\n            _refundee,\n            _recipient,\n            _dstChainId,\n            _params,\n            _sParams.globalAddress,\n            _sParams.amount,\n            _sParams.deposit,\n            _hasFallbackToggled\n        );\n\n        //Perform Call.\n        _performCall(_dstChainId, _refundee, payload, _gParams);\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function callOutAndBridgeMultiple(\n        address payable _refundee,\n        address _recipient,\n        uint16 _dstChainId,\n        bytes calldata _params,\n        SettlementMultipleInput calldata _sParams,\n        GasParams calldata _gParams,\n        bool _hasFallbackToggled\n    ) external payable override lock requiresRouter {\n        // Create Settlement and Perform call\n        bytes memory payload = _createSettlementMultiple(\n            settlementNonce,\n            _refundee,\n            _recipient,\n            _dstChainId,\n            _sParams.globalAddresses,\n            _sParams.amounts,\n            _sParams.deposits,\n            _params,\n            _hasFallbackToggled\n        );\n\n        // Perform Call to destination Branch Chain.\n        _performCall(_dstChainId, _refundee, payload, _gParams);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    SETTLEMENT EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootBridgeAgent\n    function retrySettlement(\n        uint32 _settlementNonce,\n        address _recipient,\n        bytes calldata _params,\n        GasParams calldata _gParams,\n        bool _hasFallbackToggled\n    ) external payable override lock {\n        // Get storage reference\n        Settlement storage settlementReference = getSettlement[_settlementNonce];\n\n        // Check if Settlement hasn't been redeemed.\n        if (settlementReference.owner == address(0)) revert SettlementRetryUnavailable();\n\n        // Check if caller is Settlement owner\n        if (msg.sender != settlementReference.owner) {\n            if (msg.sender != address(IPort(localPortAddress).getUserAccount(settlementReference.owner))) {\n                revert NotSettlementOwner();\n            }\n        }\n\n        // Update Settlement Status\n        settlementReference.status = STATUS_SUCCESS;\n\n        // Perform Settlement Retry\n        _performRetrySettlementCall(\n            _hasFallbackToggled,\n            settlementReference.hTokens,\n            settlementReference.tokens,\n            settlementReference.amounts,\n            settlementReference.deposits,\n            _params,\n            _settlementNonce,\n            payable(settlementReference.owner),\n            _recipient,\n            settlementReference.dstChainId,\n            _gParams,\n            msg.value\n        );\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function retrieveSettlement(uint32 _settlementNonce, GasParams calldata _gParams) external payable lock {\n        //Get settlement storage reference\n        Settlement storage settlementReference = getSettlement[_settlementNonce];\n\n        // Get Settlement owner.\n        address settlementOwner = settlementReference.owner;\n\n        // Check if Settlement is Retrieve.\n        if (settlementOwner == address(0)) revert SettlementRetrieveUnavailable();\n\n        // Check Settlement Owner\n        if (msg.sender != settlementOwner) {\n            if (msg.sender != address(IPort(localPortAddress).getUserAccount(settlementOwner))) {\n                revert NotSettlementOwner();\n            }\n        }\n\n        //Encode Data for cross-chain call.\n        bytes memory payload = abi.encodePacked(bytes1(0x03), settlementOwner, _settlementNonce);\n\n        //Retrieve Deposit\n        _performCall(settlementReference.dstChainId, payable(settlementOwner), payload, _gParams);\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function redeemSettlement(uint32 _settlementNonce) external override lock {\n        // Get setttlement storage reference\n        Settlement storage settlement = getSettlement[_settlementNonce];\n\n        // Get deposit owner.\n        address settlementOwner = settlement.owner;\n\n        // Check if Settlement is redeemable.\n        if (settlement.status == STATUS_SUCCESS) revert SettlementRedeemUnavailable();\n        if (settlementOwner == address(0)) revert SettlementRedeemUnavailable();\n\n        // Check if Settlement Owner is msg.sender or msg.sender is the virtual account of the settlement owner.\n        if (msg.sender != settlementOwner) {\n            if (msg.sender != address(IPort(localPortAddress).getUserAccount(settlementOwner))) {\n                revert NotSettlementOwner();\n            }\n        }\n\n        // Clear Global hTokens To Recipient on Root Chain cancelling Settlement to Branch\n        for (uint256 i = 0; i < settlement.hTokens.length;) {\n            // Save to memory\n            address _hToken = settlement.hTokens[i];\n\n            // Check if asset\n            if (_hToken != address(0)) {\n                // Save to memory\n                uint24 _dstChainId = settlement.dstChainId;\n\n                // Move hTokens from Branch to Root + Mint Sufficient hTokens to match new port deposit\n                IPort(localPortAddress).bridgeToRoot(\n                    msg.sender,\n                    IPort(localPortAddress).getGlobalTokenFromLocal(_hToken, _dstChainId),\n                    settlement.amounts[i],\n                    settlement.deposits[i],\n                    _dstChainId\n                );\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Delete Settlement\n        delete getSettlement[_settlementNonce];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    TOKEN MANAGEMENT EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootBridgeAgent\n    function bridgeIn(address _recipient, DepositParams memory _dParams, uint256 _srcChainId)\n        public\n        override\n        requiresAgentExecutor\n    {\n        // Deposit can't be greater than amount.\n        if (_dParams.amount < _dParams.deposit) revert InvalidInputParams();\n\n        // Cache local port address\n        address _localPortAddress = localPortAddress;\n\n        // Check local exists.\n        if (_dParams.amount > 0) {\n            if (!IPort(_localPortAddress).isLocalToken(_dParams.hToken, _srcChainId)) {\n                revert InvalidInputParams();\n            }\n        }\n\n        // Check underlying exists.\n        if (_dParams.deposit > 0) {\n            if (IPort(_localPortAddress).getLocalTokenFromUnderlying(_dParams.token, _srcChainId) != _dParams.hToken) {\n                revert InvalidInputParams();\n            }\n        }\n\n        // Move hTokens from Branch to Root + Mint Sufficient hTokens to match new port deposit\n        IPort(_localPortAddress).bridgeToRoot(\n            _recipient,\n            IPort(_localPortAddress).getGlobalTokenFromLocal(_dParams.hToken, _srcChainId),\n            _dParams.amount,\n            _dParams.deposit,\n            _srcChainId\n        );\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function bridgeInMultiple(address _recipient, DepositMultipleParams calldata _dParams, uint256 _srcChainId)\n        external\n        override\n        requiresAgentExecutor\n    {\n        // Cache length\n        uint256 length = _dParams.hTokens.length;\n\n        // Check MAX_LENGTH\n        if (length > MAX_TOKENS_LENGTH) revert InvalidInputParams();\n\n        // Bridge in assets\n        for (uint256 i = 0; i < length;) {\n            bridgeIn(\n                _recipient,\n                DepositParams({\n                    hToken: _dParams.hTokens[i],\n                    token: _dParams.tokens[i],\n                    amount: _dParams.amounts[i],\n                    deposit: _dParams.deposits[i],\n                    depositNonce: 0\n                }),\n                _srcChainId\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    LAYER ZERO EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ILayerZeroReceiver\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64, bytes calldata _payload) public {\n        (bool success,) = address(this).excessivelySafeCall(\n            gasleft(),\n            150,\n            abi.encodeWithSelector(this.lzReceiveNonBlocking.selector, msg.sender, _srcChainId, _srcAddress, _payload)\n        );\n\n        if (!success) if (msg.sender == getBranchBridgeAgent[localChainId]) revert ExecutionFailure();\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function lzReceiveNonBlocking(\n        address _endpoint,\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        bytes calldata _payload\n    ) public override requiresEndpoint(_endpoint, _srcChainId, _srcAddress) {\n        // Deposit Nonce\n        uint32 nonce;\n\n        // DEPOSIT FLAG: 0 (System request / response)\n        if (_payload[0] == 0x00) {\n            // Parse deposit nonce\n            nonce = uint32(bytes4(_payload[PARAMS_START:PARAMS_TKN_START]));\n\n            // Check if tx has already been executed\n            if (executionState[_srcChainId][nonce] != STATUS_READY) {\n                revert AlreadyExecutedTransaction();\n            }\n\n            // Avoid stack too deep\n            uint16 srcChainId = _srcChainId;\n\n            // Try to execute remote request\n            // Flag 0 - RootBridgeAgentExecutor(bridgeAgentExecutorAddress).executeSystemRequest(_localRouterAddress, _payload, _srcChainId)\n            _execute(\n                nonce,\n                abi.encodeWithSelector(\n                    RootBridgeAgentExecutor.executeSystemRequest.selector, localRouterAddress, _payload, srcChainId\n                ),\n                srcChainId\n            );\n\n            // DEPOSIT FLAG: 1 (Call without Deposit)\n        } else if (_payload[0] == 0x01) {\n            // Parse Deposit Nonce\n            nonce = uint32(bytes4(_payload[PARAMS_START:PARAMS_TKN_START]));\n\n            // Check if tx has already been executed\n            if (executionState[_srcChainId][nonce] != STATUS_READY) {\n                revert AlreadyExecutedTransaction();\n            }\n\n            // Avoid stack too deep\n            uint16 srcChainId = _srcChainId;\n\n            // Try to execute remote request\n            // Flag 1 - RootBridgeAgentExecutor(bridgeAgentExecutorAddress).executeNoDeposit(localRouterAddress, payload, _srcChainId)\n            _execute(\n                nonce,\n                abi.encodeWithSelector(\n                    RootBridgeAgentExecutor.executeNoDeposit.selector, localRouterAddress, _payload, srcChainId\n                ),\n                srcChainId\n            );\n\n            // DEPOSIT FLAG: 2 (Call with Deposit)\n        } else if (_payload[0] == 0x02) {\n            //Parse Deposit Nonce\n            nonce = uint32(bytes4(_payload[PARAMS_START:PARAMS_TKN_START]));\n\n            //Check if tx has already been executed\n            if (executionState[_srcChainId][nonce] != STATUS_READY) {\n                revert AlreadyExecutedTransaction();\n            }\n\n            // Avoid stack too deep\n            uint16 srcChainId = _srcChainId;\n\n            // Try to execute remote request\n            // Flag 2 - RootBridgeAgentExecutor(bridgeAgentExecutorAddress).executeWithDeposit(localRouterAddress, _payload, _srcChainId)\n            _execute(\n                nonce,\n                abi.encodeWithSelector(\n                    RootBridgeAgentExecutor.executeWithDeposit.selector, localRouterAddress, _payload, srcChainId\n                ),\n                srcChainId\n            );\n\n            // DEPOSIT FLAG: 3 (Call with multiple asset Deposit)\n        } else if (_payload[0] == 0x03) {\n            // Parse deposit nonce\n            nonce = uint32(bytes4(_payload[2:6]));\n\n            // Check if tx has already been executed\n            if (executionState[_srcChainId][nonce] != STATUS_READY) {\n                revert AlreadyExecutedTransaction();\n            }\n\n            // Avoid stack too deep\n            uint16 srcChainId = _srcChainId;\n\n            // Try to execute remote request\n            // Flag 3 - RootBridgeAgentExecutor(bridgeAgentExecutorAddress).executeWithDepositMultiple(localRouterAddress, _payload, _srcChainId)\n            _execute(\n                nonce,\n                abi.encodeWithSelector(\n                    RootBridgeAgentExecutor.executeWithDepositMultiple.selector,\n                    localRouterAddress,\n                    _payload,\n                    srcChainId\n                ),\n                srcChainId\n            );\n\n            // DEPOSIT FLAG: 4 (Call without Deposit + msg.sender)\n        } else if (_payload[0] == 0x04) {\n            // Parse deposit nonce\n            nonce = uint32(bytes4(_payload[PARAMS_START_SIGNED:PARAMS_TKN_START_SIGNED]));\n\n            //Check if tx has already been executed\n            if (executionState[_srcChainId][nonce] != STATUS_READY) {\n                revert AlreadyExecutedTransaction();\n            }\n\n            // Get User Virtual Account\n            VirtualAccount userAccount = IPort(localPortAddress).fetchVirtualAccount(\n                address(uint160(bytes20(_payload[PARAMS_START:PARAMS_START_SIGNED])))\n            );\n\n            // Toggle Router Virtual Account use for tx execution\n            IPort(localPortAddress).toggleVirtualAccountApproved(userAccount, localRouterAddress);\n\n            // Avoid stack too deep\n            uint16 srcChainId = _srcChainId;\n\n            // Try to execute remote request\n            // Flag 4 - RootBridgeAgentExecutor(bridgeAgentExecutorAddress).executeSignedNoDeposit(address(userAccount), localRouterAddress, data, _srcChainId\n            _execute(\n                nonce,\n                abi.encodeWithSelector(\n                    RootBridgeAgentExecutor.executeSignedNoDeposit.selector,\n                    address(userAccount),\n                    localRouterAddress,\n                    _payload,\n                    srcChainId\n                ),\n                srcChainId\n            );\n\n            // Toggle Router Virtual Account use for tx execution\n            IPort(localPortAddress).toggleVirtualAccountApproved(userAccount, localRouterAddress);\n\n            //DEPOSIT FLAG: 5 (Call with Deposit + msg.sender)\n        } else if (_payload[0] & 0x7F == 0x05) {\n            // Parse deposit nonce\n            nonce = uint32(bytes4(_payload[PARAMS_START_SIGNED:PARAMS_TKN_START_SIGNED]));\n\n            //Check if tx has already been executed\n            if (executionState[_srcChainId][nonce] != STATUS_READY) {\n                revert AlreadyExecutedTransaction();\n            }\n\n            // Get User Virtual Account\n            VirtualAccount userAccount = IPort(localPortAddress).fetchVirtualAccount(\n                address(uint160(bytes20(_payload[PARAMS_START:PARAMS_START_SIGNED])))\n            );\n\n            // Toggle Router Virtual Account use for tx execution\n            IPort(localPortAddress).toggleVirtualAccountApproved(userAccount, localRouterAddress);\n\n            // Avoid stack too deep\n            uint16 srcChainId = _srcChainId;\n\n            // Try to execute remote request\n            // Flag 5 - RootBridgeAgentExecutor(bridgeAgentExecutorAddress).executeSignedWithDeposit(address(userAccount), localRouterAddress, data, _srcChainId)\n            _execute(\n                _payload[0] == 0x85,\n                nonce,\n                address(uint160(bytes20(_payload[PARAMS_START:PARAMS_START_SIGNED]))),\n                abi.encodeWithSelector(\n                    RootBridgeAgentExecutor.executeSignedWithDeposit.selector,\n                    address(userAccount),\n                    localRouterAddress,\n                    _payload,\n                    srcChainId\n                ),\n                srcChainId\n            );\n\n            // Toggle Router Virtual Account use for tx execution\n            IPort(localPortAddress).toggleVirtualAccountApproved(userAccount, localRouterAddress);\n\n            // DEPOSIT FLAG: 6 (Call with multiple asset Deposit + msg.sender)\n        } else if (_payload[0] & 0x7F == 0x06) {\n            // Parse deposit nonce\n            nonce = uint32(bytes4(_payload[PARAMS_START_SIGNED + PARAMS_START:PARAMS_START_SIGNED + PARAMS_TKN_START]));\n\n            // Check if tx has already been executed\n            if (executionState[_srcChainId][nonce] != STATUS_READY) {\n                revert AlreadyExecutedTransaction();\n            }\n\n            // Get User Virtual Account\n            VirtualAccount userAccount = IPort(localPortAddress).fetchVirtualAccount(\n                address(uint160(bytes20(_payload[PARAMS_START:PARAMS_START_SIGNED])))\n            );\n\n            // Toggle Router Virtual Account use for tx execution\n            IPort(localPortAddress).toggleVirtualAccountApproved(userAccount, localRouterAddress);\n\n            // Avoid stack too deep\n            uint16 srcChainId = _srcChainId;\n\n            // Try to execute remote request\n            // Flag 6 - RootBridgeAgentExecutor(bridgeAgentExecutorAddress).executeSignedWithDepositMultiple(address(userAccount), localRouterAddress, data, _srcChainId)\n            _execute(\n                _payload[0] == 0x86,\n                nonce,\n                address(uint160(bytes20(_payload[PARAMS_START:PARAMS_START_SIGNED]))),\n                abi.encodeWithSelector(\n                    RootBridgeAgentExecutor.executeSignedWithDepositMultiple.selector,\n                    address(userAccount),\n                    localRouterAddress,\n                    _payload,\n                    srcChainId\n                ),\n                srcChainId\n            );\n\n            // Toggle Router Virtual Account use for tx execution\n            IPort(localPortAddress).toggleVirtualAccountApproved(userAccount, localRouterAddress);\n\n            /// DEPOSIT FLAG: 7 (retrySettlement)\n        } else if (_payload[0] & 0x7F == 0x07) {\n            // Prepare Variables for decoding\n            address owner;\n            bytes memory params;\n            GasParams memory gParams;\n\n            // Decode Input\n            (nonce, owner, params, gParams) = abi.decode(_payload[PARAMS_START:], (uint32, address, bytes, GasParams));\n\n            // Get storage reference\n            Settlement storage settlementReference = getSettlement[nonce];\n\n            // Check if Settlement hasn't been redeemed.\n            if (settlementReference.owner == address(0)) revert SettlementRetryUnavailable();\n\n            // Check settlement owner\n            if (owner != settlementReference.owner) {\n                if (owner != address(IPort(localPortAddress).getUserAccount(settlementReference.owner))) {\n                    revert NotSettlementOwner();\n                }\n            }\n\n            //Update Settlement Staus\n            settlementReference.status = STATUS_SUCCESS;\n\n            //Retry settlement call with new params and gas\n            _performRetrySettlementCall(\n                _payload[0] == 0x87,\n                settlementReference.hTokens,\n                settlementReference.tokens,\n                settlementReference.amounts,\n                settlementReference.deposits,\n                params,\n                nonce,\n                payable(settlementReference.owner),\n                settlementReference.recipient,\n                settlementReference.dstChainId,\n                gParams,\n                address(this).balance\n            );\n\n            /// DEPOSIT FLAG: 8 (retrieveDeposit)\n        } else if (_payload[0] == 0x08) {\n            //Parse deposit nonce\n            nonce = uint32(bytes4(_payload[PARAMS_START_SIGNED:PARAMS_TKN_START_SIGNED]));\n\n            //Check if deposit is in retrieve mode\n            if (executionState[_srcChainId][nonce] == STATUS_DONE) {\n                revert AlreadyExecutedTransaction();\n            } else {\n                //Set settlement to retrieve mode, if not already set.\n                if (executionState[_srcChainId][nonce] == STATUS_READY) {\n                    executionState[_srcChainId][nonce] = STATUS_RETRIEVE;\n                }\n                //Trigger fallback/Retry failed fallback\n                _performFallbackCall(\n                    payable(address(uint160(bytes20(_payload[PARAMS_START:PARAMS_START_SIGNED])))), nonce, _srcChainId\n                );\n            }\n\n            //DEPOSIT FLAG: 9 (Fallback)\n        } else if (_payload[0] == 0x09) {\n            // Parse nonce\n            nonce = uint32(bytes4(_payload[PARAMS_START:PARAMS_TKN_START]));\n\n            // Reopen Settlement for redemption\n            getSettlement[nonce].status = STATUS_FAILED;\n\n            // Emit LogFallback\n            emit LogFallback(nonce, _srcChainId);\n\n            // return to prevent unnecessary emits/logic\n            return;\n\n            // Unrecognized Function Selector\n        } else {\n            revert UnknownFlag();\n        }\n\n        emit LogExecute(nonce, _srcChainId);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                DEPOSIT EXECUTION INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Internal function requests execution from Root Bridge Agent Executor Contract.\n     *   @param _depositNonce Identifier for nonce being executed.\n     *   @param _calldata Payload of message to be executed by the Root Bridge Agent Executor Contract.\n     *   @param _srcChainId Chain ID of source chain where request originates from.\n     */\n    function _execute(uint256 _depositNonce, bytes memory _calldata, uint16 _srcChainId) private {\n        //Update tx state as executed\n        executionState[_srcChainId][_depositNonce] = STATUS_DONE;\n\n        //Try to execute the remote request\n        (bool success,) = bridgeAgentExecutorAddress.call{value: address(this).balance}(_calldata);\n\n        // No fallback is requested revert allowing for retry.\n        if (!success) revert ExecutionFailure();\n    }\n\n    /**\n     * @notice Internal function requests execution from Root Bridge Agent Executor Contract.\n     *   @param _hasFallbackToggled if true, fallback on execution failure is toggled on.\n     *   @param _depositNonce Identifier for nonce being executed.\n     *   @param _refundee address to refund gas to in case of fallback being triggered.\n     *   @param _calldata Calldata to be executed by the Root Bridge Agent Executor Contract.\n     *   @param _srcChainId Chain ID of source chain where request originates from.\n     */\n    function _execute(\n        bool _hasFallbackToggled,\n        uint32 _depositNonce,\n        address _refundee,\n        bytes memory _calldata,\n        uint16 _srcChainId\n    ) private {\n        //Update tx state as executed\n        executionState[_srcChainId][_depositNonce] = STATUS_DONE;\n\n        //Try to execute the remote request\n        (bool success,) = bridgeAgentExecutorAddress.call{value: address(this).balance}(_calldata);\n\n        //Update tx state if execution failed\n        if (!success) {\n            //Read the fallback flag.\n            if (_hasFallbackToggled) {\n                // Update tx state as retrieve only\n                executionState[_srcChainId][_depositNonce] = STATUS_RETRIEVE;\n                // Perform the fallback call\n                _performFallbackCall(payable(_refundee), _depositNonce, _srcChainId);\n            } else {\n                // No fallback is requested revert allowing for retry.\n                revert ExecutionFailure();\n            }\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    LAYER ZERO INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Internal function performs call to Layer Zero Endpoint Contract for cross-chain messaging.\n     *   @param _refundee address to refund excess gas to.\n     *   @param _dstChainId Layer Zero Chain ID of destination chain.\n     *   @param _payload Payload of message to be sent to Layer Zero Endpoint Contract.\n     *   @param _gParams Gas parameters for cross-chain message execution.\n     */\n\n    function _performCall(\n        uint16 _dstChainId,\n        address payable _refundee,\n        bytes memory _payload,\n        GasParams calldata _gParams\n    ) internal {\n        // Get destination Branch Bridge Agent\n        address callee = getBranchBridgeAgent[_dstChainId];\n\n        // Check if valid destination\n        if (callee == address(0)) revert UnrecognizedBridgeAgent();\n\n        // Check if call to remote chain\n        if (_dstChainId != localChainId) {\n            //Sends message to Layerzero Enpoint\n            ILayerZeroEndpoint(lzEndpointAddress).send{value: msg.value}(\n                _dstChainId,\n                getBranchBridgeAgentPath[_dstChainId],\n                _payload,\n                _refundee,\n                address(0),\n                abi.encodePacked(uint16(2), _gP"
    }
  ]
}