{
  "Title": "H-2: Residual ETH will not be sent back to users during the minting of wfCash",
  "Content": "# Issue H-2: Residual ETH will not be sent back to users during the minting of wfCash \n\nSource: https://github.com/sherlock-audit/2023-12-notional-update-5-judging/issues/25 \n\n## Found by \neol, twicek, xiaoming90\n## Summary\n\nResidual ETH will not be sent back to users, resulting in a loss of assets.\n\n## Vulnerability Detail\n\nAt Line 67, residual ETH within the `depositUnderlyingToken` function will be sent as Native ETH back to the `msg.sender`, which is this wfCash Wrapper contract. \n\nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/wrapped-fcash/contracts/wfCashLogic.sol#L67\n\n```solidity\nFile: wfCashLogic.sol\n35:     function _mintInternal(\n..SNIP..\n60:         if (maxFCash < fCashAmount) {\n61:             // NOTE: lending at zero\n62:             uint256 fCashAmountExternal = fCashAmount * precision / uint256(Constants.INTERNAL_TOKEN_PRECISION); \n63:             require(fCashAmountExternal <= depositAmountExternal); \n64: \n65:             // NOTE: Residual (depositAmountExternal - fCashAmountExternal) will be transferred\n66:             // back to the account\n67:             NotionalV2.depositUnderlyingToken{value: msgValue}(address(this), currencyId, fCashAmountExternal);\n..SNIP..\n87:         // Residual tokens will be sent back to msg.sender, not the receiver. The msg.sender\n88:         // was used to transfer tokens in and these are any residual tokens left that were not\n89:         // lent out. Sending these tokens back to the receiver risks them getting locked on a\n90:         // contract that does not have the capability to transfer them off\n91:         _sendTokensToReceiver(token, msg.sender, isETH, balanceBefore);\n```\n\nWithin the `depositUnderlyingToken` function Line 108 below, the `returnExcessWrapped` parameter is set to `false`, which means it will not wrap the residual ETH, and that Native ETH will be sent back to the caller (wrapper contract)\n\nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/contracts-v3/contracts/external/actions/AccountAction.sol#L108\n\n```solidity\nFile: AccountAction.sol\n89:     function depositUnderlyingToken(\n90:         address account,\n91:         uint16 currencyId,\n92:         uint256 amountExternalPrecision\n93:     ) external payable nonReentrant returns (uint256) {\n..SNIP..\nFile: AccountAction.sol\n105:         int256 primeCashReceived = balanceState.depositUnderlyingToken(\n106:             msg.sender,\n107:             SafeInt256.toInt(amountExternalPrecision),\n108:             false // there should never be excess ETH here by definition\n109:         );\n```\n\nbalanceBefore = amount of WETH before the deposit, balanceAfter = amount of WETH after the deposit. \n\nWhen the `_sendTokensToReceiver` is executed, these two values are going to be the same since it is Native ETH that is sent to the wrapper instead of WETH. As a result, the Native ETH that the wrapper received is not forwarded to the users.\n\nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/wrapped-fcash/contracts/wfCashLogic.sol#L331\n\n```solidity\nFile: wfCashLogic.sol\n331:     function _sendTokensToReceiver( \n332:         IERC20 token,\n333:         address receiver,\n334:         bool isETH,\n335:         uint256 balanceBefore\n336:     ) private returns (uint256 tokensTransferred) {\n337:         uint256 balanceAfter = isETH ? WETH.balanceOf(address(this)) : token.balanceOf(address(this)); \n338:         tokensTransferred = balanceAfter - balanceBefore; \n339: \n340:         if (isETH) {\n341:             // No need to use safeTransfer for WETH since it is known to be compatible\n342:             IERC20(address(WETH)).transfer(receiver, tokensTransferred); \n343:         } else if (tokensTransferred > 0) { \n344:             token.safeTransfer(receiver, tokensTransferred); \n345:         }\n346:     }\n```\n\n## Impact\n\nLoss of assets as the residual ETH is not sent to the users.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/wrapped-fcash/contracts/wfCashLogic.sol#L67\n\nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/contracts-v3/contracts/external/actions/AccountAction.sol#L108\n\nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/wrapped-fcash/contracts/wfCashLogic.sol#L331\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIf the underlying is ETH, measure the Native ETH balance before and after the `depositUnderlyingToken` is executed. Forward any residual Native ETH to the users, if any.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid because { This is a valid findings as the watson was able to explained how excess ETH will be stuck and not sent back to user as intended; hight findings}\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/142",
  "Code": [
    {
      "filename": "wrapped-fcash/contracts/wfCashLogic.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\npragma experimental ABIEncoderV2;\n\nimport \"./wfCashBase.sol\";\nimport \"@openzeppelin-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\n\n/// @dev This implementation contract is deployed as an UpgradeableBeacon. Each BeaconProxy\n/// that uses this contract as an implementation will call initialize to set its own fCash id.\n/// That identifier will represent the fCash that this ERC20 wrapper can hold.\nabstract contract wfCashLogic is wfCashBase, ReentrancyGuardUpgradeable {\n    using SafeERC20 for IERC20;\n    // bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))\n    bytes4 internal constant ERC1155_ACCEPTED = 0xf23a6e61;\n\n    constructor(INotionalV2 _notional, WETH9 _weth) wfCashBase(_notional, _weth) {}\n\n    /***** Mint Methods *****/\n\n    /// @notice Lends deposit amount in return for fCashAmount using underlying tokens\n    /// @param depositAmountExternal amount of cash to deposit into this method\n    /// @param fCashAmount amount of fCash to purchase (lend)\n    /// @param receiver address to receive the fCash shares\n    /// @param minImpliedRate minimum annualized interest rate to lend at\n    function mintViaUnderlying(\n        uint256 depositAmountExternal,\n        uint88 fCashAmount,\n        address receiver,\n        uint32 minImpliedRate\n    ) external override {\n        (/* */, uint256 maxFCash) = getTotalFCashAvailable();\n        _mintInternal(depositAmountExternal, fCashAmount, receiver, minImpliedRate, maxFCash);\n    }\n\n    function _mintInternal(\n        uint256 depositAmountExternal,\n        uint88 fCashAmount,\n        address receiver,\n        uint32 minImpliedRate,\n        uint256 maxFCash\n    ) internal nonReentrant {\n        require(!hasMatured(), \"fCash matured\");\n        (IERC20 token, bool isETH, bool hasTransferFee, uint256 precision) = _getTokenForMintInternal();\n        uint256 balanceBefore = isETH ? WETH.balanceOf(address(this)) : token.balanceOf(address(this));\n        uint256 msgValue;\n        uint16 currencyId = getCurrencyId();\n        \n        if (isETH) {\n            // Use WETH if lending ETH. Although Notional natively supports ETH, we use WETH here for integration\n            // contracts so they only have to support ERC20 token transfers.\n            // NOTE: safeTransferFrom not required since WETH is known to be compatible\n            IERC20((address(WETH))).transferFrom(msg.sender, address(this), depositAmountExternal);\n            WETH.withdraw(depositAmountExternal);\n            msgValue = depositAmountExternal;\n        } else {\n            token.safeTransferFrom(msg.sender, address(this), depositAmountExternal);\n            depositAmountExternal = token.balanceOf(address(this)) - balanceBefore;\n        }\n\n        if (maxFCash < fCashAmount) {\n            // NOTE: lending at zero\n            uint256 fCashAmountExternal = fCashAmount * precision / uint256(Constants.INTERNAL_TOKEN_PRECISION);\n            require(fCashAmountExternal <= depositAmountExternal);\n\n            // NOTE: Residual (depositAmountExternal - fCashAmountExternal) will be transferred\n            // back to the account\n            NotionalV2.depositUnderlyingToken{value: msgValue}(address(this), currencyId, fCashAmountExternal);\n        } else if (isETH || hasTransferFee || getCashBalance() > 0) {\n            _lendLegacy(currencyId, depositAmountExternal, fCashAmount, minImpliedRate, msgValue, isETH);\n        } else {\n            // Executes a lending action on Notional. Since this lending action uses an existing cash balance\n            // prior to pulling payment, we cannot use it if there is a cash balance on the wrapper contract,\n            // it will cause existing cash balances to be minted into fCash and create a shortfall. In normal\n            // conditions, this method is more gas efficient.\n            BatchLend[] memory action = EncodeDecode.encodeLendTrade(\n                currencyId,\n                getMarketIndex(),\n                fCashAmount,\n                minImpliedRate\n            );\n            NotionalV2.batchLend(address(this), action);\n        }\n\n        // Mints ERC20 tokens for the receiver\n        _mint(receiver, fCashAmount);\n\n        // Residual tokens will be sent back to msg.sender, not the receiver. The msg.sender\n        // was used to transfer tokens in and these are any residual tokens left that were not\n        // lent out. Sending these tokens back to the receiver risks them getting locked on a\n        // contract that does not have the capability to transfer them off\n        _sendTokensToReceiver(token, msg.sender, isETH, balanceBefore);\n    }\n\n    function _lendLegacy(\n        uint16 currencyId,\n        uint256 depositAmountExternal,\n        uint88 fCashAmount,\n        uint32 minImpliedRate,\n        uint256 msgValue,\n        bool isETH\n    ) internal {\n        // If dealing in ETH, we use WETH in the wrapper instead of ETH. NotionalV2 uses\n        // ETH natively but due to pull payment requirements for batchLend, it does not support\n        // ETH. batchLend only supports ERC20 tokens. Since the wrapper is a compatibility\n        // layer, it will support WETH so integrators can deal solely in ERC20 tokens. Instead of using\n        // \"batchLend\" we will use \"batchBalanceActionWithTrades\". The difference is that \"batchLend\"\n        // is more gas efficient.\n\n        // If deposit amount external is in excess of the cost to purchase fCash amount (often the case),\n        // then we need to return the difference between postTradeCash - preTradeCash. This is done because\n        // the encoded trade does not automatically withdraw the entire cash balance in case the wrapper\n        // is holding a cash balance.\n        uint256 preTradeCash = getCashBalance();\n\n        BalanceActionWithTrades[] memory action = EncodeDecode.encodeLegacyLendTrade(\n            currencyId,\n            getMarketIndex(),\n            depositAmountExternal,\n            fCashAmount,\n            minImpliedRate\n        );\n        // Notional will return any residual ETH as the native token. When we _sendTokensToReceiver those\n        // native ETH tokens will be wrapped back to WETH.\n        NotionalV2.batchBalanceAndTradeAction{value: msgValue}(address(this), action);\n\n        uint256 postTradeCash = getCashBalance();\n\n        if (preTradeCash != postTradeCash) {\n            // If ETH, then redeem to WETH (redeemToUnderlying == false)\n            NotionalV2.withdraw(currencyId, _safeUint88(postTradeCash - preTradeCash), !isETH);\n        }\n    }\n\n    /// @notice This hook will be called every time this contract receives fCash, will validate that\n    /// this is the correct fCash and then mint the corresponding amount of wrapped fCash tokens\n    /// back to the user.\n    function onERC1155Received(\n        address /* _operator */,\n        address _from,\n        uint256 _id,\n        uint256 _value,\n        bytes calldata /* _data */\n    ) external nonReentrant returns (bytes4) {\n        uint256 fCashID = getfCashId();\n        // Only accept erc1155 transfers from NotionalV2\n        require(msg.sender == address(NotionalV2), \"Invalid\");\n        // Only accept the fcash id that corresponds to the listed currency and maturity\n        require(_id == fCashID, \"Invalid\");\n        // Protect against signed value underflows\n        require(int256(_value) > 0, \"Invalid\");\n\n        // Double check the account's position, these are not strictly necessary and add gas costs\n        // but might be good safe guards\n        AccountContext memory ac = NotionalV2.getAccountContext(address(this));\n        PortfolioAsset[] memory assets = NotionalV2.getAccountPortfolio(address(this));\n        require(ac.hasDebt == 0x00);\n        require(assets.length == 1);\n        require(EncodeDecode.encodeERC1155Id(\n                assets[0].currencyId,\n                assets[0].maturity,\n                assets[0].assetType) == fCashID\n        );\n\n        // Mint ERC20 tokens for the sender\n        _mint(_from, _value);\n\n        // This will allow the fCash to be accepted\n        return ERC1155_ACCEPTED;\n    }\n\n    /***** Redeem (Burn) Methods *****/\n\n    /// @notice Redeems tokens using custom options\n    /// @dev re-entrancy is protected on _burn\n    function redeem(uint256 amount, RedeemOpts memory opts) external override {\n        _burnInternal(msg.sender, amount, opts);\n    }\n\n    /// @notice Redeems tokens to underlying\n    /// @dev re-entrancy is protected on _burn\n    function redeemToUnderlying(\n        uint256 amount,\n        address receiver,\n        uint32 maxImpliedRate\n    ) external override {\n        _burnInternal(\n            msg.sender,\n            amount,\n            RedeemOpts({\n                redeemToUnderlying: true,\n                transferfCash: false,\n                receiver: receiver,\n                maxImpliedRate: maxImpliedRate\n            })\n        );\n    }\n\n    /// @notice This method is here only in the case where someone has transferred invalid fCash\n    /// to the contract and would prevent ERC1155 transfer hooks from succeeding. In this case the\n    /// owner can recover the invalid fCash to a designated receiver. This can only occur if the fCash\n    /// is transferred prior to contract creation.\n    function recoverInvalidfCash(uint256 fCashId, address receiver) external {\n        // Only the Notional owner can call this method\n        require(msg.sender == NotionalV2.owner());\n        // Cannot transfer the native fCash id of this wrapper\n        require(fCashId != getfCashId());\n        uint256 balance = NotionalV2.balanceOf(address(this), fCashId);\n        // There should be a positive balance before we try to transfer this\n        require(balance > 0);\n        NotionalV2.safeTransferFrom(address(this), receiver, fCashId, balance, \"\");\n        \n        // Double check that we don't incur debt\n        AccountContext memory ac = NotionalV2.getAccountContext(address(this));\n        require(ac.hasDebt == 0x00);\n    }\n\n    /// @notice Called before tokens are burned (redemption) and so we will handle\n    /// the fCash properly before and after maturity.\n    function _burnInternal(\n        address from,\n        uint256 fCashShares,\n        RedeemOpts memory opts\n    ) internal nonReentrant {\n        require(opts.receiver != address(0), \"Receiver is zero address\");\n        require(opts.redeemToUnderlying || opts.transferfCash);\n        // This will validate that the account has sufficient tokens to burn and make\n        // any relevant underlying stateful changes to balances.\n        super._burn(from, fCashShares);\n\n        if (hasMatured()) {\n            require(opts.transferfCash == false);\n            // If the fCash has matured, then we need to ensure that the account is settled\n            // and then we will transfer back the account's share of asset tokens.\n\n            // This is a noop if the account is already settled, it is cheaper to call this method than\n            // cache it in storage locally\n            NotionalV2.settleAccount(address(this));\n            uint16 currencyId = getCurrencyId();\n            uint256 primeCashClaim = _getMaturedCashValue(fCashShares);\n\n            // Transfer withdrawn tokens to the `from` address\n            _withdrawCashToAccount(currencyId, opts.receiver, _safeUint88(primeCashClaim));\n        } else if (opts.transferfCash) {\n            // If the fCash has not matured, then we can transfer it via ERC1155.\n            // NOTE: this may fail if the destination is a contract and it does not implement \n            // the `onERC1155Received` hook. If that is the case it is possible to use a regular\n            // ERC20 transfer on this contract instead.\n            NotionalV2.safeTransferFrom(\n                address(this), // Sending from this contract\n                opts.receiver, // Where to send the fCash\n                getfCashId(), // fCash identifier\n                fCashShares, // Amount of fCash to send\n                \"\"\n            );\n        } else {\n            _sellfCash(opts.receiver, fCashShares, opts.maxImpliedRate);\n        }\n    }\n\n    /// @notice After maturity, withdraw cash back to account\n    function _withdrawCashToAccount(\n        uint16 currencyId,\n        address receiver,\n        uint88 primeCashToWithdraw\n    ) private returns (uint256 tokensTransferred) {\n        (IERC20 token, bool isETH) = getToken(true);\n        uint256 balanceBefore = isETH ? WETH.balanceOf(address(this)) : token.balanceOf(address(this));\n\n        NotionalV2.withdraw(currencyId, primeCashToWithdraw, !isETH);\n\n        tokensTransferred = _sendTokensToReceiver(token, receiver, isETH, balanceBefore);\n    }\n\n    /// @dev Sells an fCash share back on the Notional AMM\n    function _sellfCash(\n        address receiver,\n        uint256 fCashToSell,\n        uint32 maxImpliedRate\n    ) private returns (uint256 tokensTransferred) {\n        (IERC20 token, bool isETH) = getToken(true);\n        uint256 balanceBefore = isETH ? WETH.balanceOf(address(this)) : token.balanceOf(address(this));\n        uint16 currencyId = getCurrencyId();\n\n        (uint256 initialCashBalance, uint256 fCashBalance) = getBalances();\n        bool hasInsufficientfCash = fCashBalance < fCashToSell;\n\n        uint256 primeCashToWithdraw;\n        if (hasInsufficientfCash) {\n            // If there is insufficient fCash, calculate how much prime cash would be purchased if the\n            // given fCash amount would be sold and that will be how much the wrapper will withdraw and\n            // send to the receiver. Since fCash always sells at a discount to underlying prior to maturity,\n            // the wrapper is guaranteed to have sufficient cash to send to the account.\n            (/* */, primeCashToWithdraw, /* */, /* */) = NotionalV2.getPrincipalFromfCashBorrow(\n                currencyId,\n                fCashToSell,\n                getMaturity(),\n                0,\n                block.timestamp\n            );\n            // If this is zero then it signifies that the trade will fail.\n            require(primeCashToWithdraw > 0, \"Redeem Failed\");\n\n            // Re-write the fCash to sell to the entire fCash balance.\n            fCashToSell = fCashBalance;\n        }\n\n        if (fCashToSell > 0) {\n            // Sells fCash on Notional AMM (via borrowing)\n            BalanceActionWithTrades[] memory action = EncodeDecode.encodeBorrowTrade(\n                currencyId,\n                getMarketIndex(),\n                _safeUint88(fCashToSell),\n                maxImpliedRate\n            );\n            NotionalV2.batchBalanceAndTradeAction(address(this), action);\n        }\n\n        uint256 postTradeCash = getCashBalance();\n\n        // If the account did not have insufficient fCash, then the amount of cash change here is what\n        // the receiver is owed. In the other case, we transfer to the receiver the total calculated amount\n        // above without modification.\n        if (!hasInsufficientfCash) primeCashToWithdraw = postTradeCash - initialCashBalance;\n        require(primeCashToWithdraw <= postTradeCash);\n\n        // Withdraw the total amount of cash and send it to the receiver\n        NotionalV2.withdraw(currencyId, _safeUint88(primeCashToWithdraw), !isETH);\n        tokensTransferred = _sendTokensToReceiver(token, receiver, isETH, balanceBefore);\n    }\n\n    function _sendTokensToReceiver(\n        IERC20 token,\n        address receiver,\n        bool isETH,\n        uint256 balanceBefore\n    ) private returns (uint256 tokensTransferred) {\n        uint256 balanceAfter = isETH ? WETH.balanceOf(address(this)) : token.balanceOf(address(this));\n        tokensTransferred = balanceAfter - balanceBefore;\n\n        if (isETH) {\n            // No need to use safeTransfer for WETH since it is known to be compatible\n            IERC20(address(WETH)).transfer(receiver, tokensTransferred);\n        } else if (tokensTransferred > 0) {\n            token.safeTransfer(receiver, tokensTransferred);\n        }\n    }\n\n    function _safeUint88(uint256 x) internal pure returns (uint88) {\n        require(x <= uint256(type(uint88).max));\n        return uint88(x);\n    }\n}"
    },
    {
      "filename": "contracts-v3/contracts/external/actions/AccountAction.sol",
      "content": "// SPDX-License-Identifier: BSUL-1.1\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport {\n    BalanceState,\n    AccountContext,\n    PortfolioAsset,\n    PrimeRate\n} from \"../../global/Types.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {LibStorage} from \"../../global/LibStorage.sol\";\nimport {SafeInt256} from \"../../math/SafeInt256.sol\";\n\nimport {Emitter} from \"../../internal/Emitter.sol\";\nimport {TransferAssets} from \"../../internal/portfolio/TransferAssets.sol\";\nimport {BalanceHandler} from \"../../internal/balances/BalanceHandler.sol\";\nimport {nTokenHandler} from \"../../internal/nToken/nTokenHandler.sol\";\nimport {PrimeRateLib} from \"../../internal/pCash/PrimeRateLib.sol\";\nimport {PrimeCashExchangeRate} from \"../../internal/pCash/PrimeCashExchangeRate.sol\";\nimport {PrimeSupplyCap} from \"../../internal/pCash/PrimeSupplyCap.sol\";\nimport {AccountContextHandler} from \"../../internal/AccountContextHandler.sol\";\n\nimport {ActionGuards} from \"./ActionGuards.sol\";\nimport {nTokenRedeemAction} from \"./nTokenRedeemAction.sol\";\nimport {SettleAssetsExternal} from \"../SettleAssetsExternal.sol\";\nimport {FreeCollateralExternal} from \"../FreeCollateralExternal.sol\";\nimport {MigrateIncentives} from \"../MigrateIncentives.sol\";\n\ncontract AccountAction is ActionGuards {\n    using BalanceHandler for BalanceState;\n    using AccountContextHandler for AccountContext;\n    using PrimeRateLib for PrimeRate;\n    using PrimeSupplyCap for PrimeRate;\n    using SafeInt256 for int256;\n\n    /// @notice A per account setting that allows it to borrow prime cash (i.e. incur negative cash)\n    /// as a result of account initiated actions. Accounts can still incur negative cash as a result of\n    /// fCash settlement regardless of this setting.\n    /// @param allowPrimeBorrow true if the account can borrow prime cash\n    /// @dev emit:AccountSettled emit:AccountContextUpdate\n    /// @dev auth:msg.sender\n    function enablePrimeBorrow(bool allowPrimeBorrow) external {\n        require(msg.sender != address(this)); // dev: no internal call\n        requireValidAccount(msg.sender);\n        (AccountContext memory accountContext, /* didSettle */) = _settleAccountIfRequired(msg.sender);\n        accountContext.allowPrimeBorrow = allowPrimeBorrow;\n        accountContext.setAccountContext(msg.sender);\n    }\n\n    /// @notice Enables a bitmap currency for msg.sender, account cannot have any assets when this call\n    /// occurs. Will revert if the account already has a bitmap currency set.\n    /// @param currencyId the currency to enable the bitmap for.\n    /// @dev emit:AccountSettled emit:AccountContextUpdate\n    /// @dev auth:msg.sender\n    function enableBitmapCurrency(uint16 currencyId) external {\n        require(msg.sender != address(this)); // dev: no internal call to enableBitmapCurrency\n        require(currencyId <= maxCurrencyId); // dev: invalid currency id\n        address account = msg.sender;\n        (AccountContext memory accountContext, /* didSettle */) = _settleAccountIfRequired(account);\n        accountContext.enableBitmapForAccount(currencyId, block.timestamp);\n        accountContext.setAccountContext(account);\n    }\n\n    /// @notice Method for manually settling an account, generally should not be called because other\n    /// methods will check if an account needs to be settled automatically. If a bitmap account has debt\n    /// and is settled via this method, the hasDebt flag will not be cleared until a free collateral check\n    /// is performed on the account.\n    /// @param account the account to settle\n    /// @dev emit:AccountSettled emit:AccountContextUpdate\n    /// @dev auth:none\n    /// @return returns true if account has been settled\n    function settleAccount(address account) external returns (bool) {\n        requireValidAccount(account);\n        (AccountContext memory accountContext, bool didSettle) = _settleAccountIfRequired(account);\n        if (didSettle) accountContext.setAccountContext(account);\n        return didSettle;\n    }\n\n    /// @notice Deposits and wraps the underlying token for a particular cToken. Does not settle assets or check free\n    /// collateral, idea is to be as gas efficient as possible during potential liquidation events.\n    /// @param account the account to deposit into\n    /// @param currencyId currency id of the asset token that wraps this underlying\n    /// @param amountExternalPrecision the amount of underlying tokens in its native decimal precision\n    /// (i.e. 18 decimals for DAI or 6 decimals for USDC). This will be converted to 8 decimals during transfer.\n    /// @return asset tokens minted and deposited to the account in internal decimals (8)\n    /// @dev emit:CashBalanceChange emit:AccountContextUpdate\n    /// @dev auth:none\n    function depositUnderlyingToken(\n        address account,\n        uint16 currencyId,\n        uint256 amountExternalPrecision\n    ) external payable nonReentrant returns (uint256) {\n        require(msg.sender != address(this)); // dev: no internal call to deposit underlying\n        // Only the account can deposit into its balance, donations are not allowed.\n        requireValidAccount(account);\n\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\n        BalanceState memory balanceState;\n        balanceState.loadBalanceState(account, currencyId, accountContext);\n\n        // NOTE: using msg.sender here allows for a different sender to deposit tokens into\n        // the specified account. This may be useful for on-demand collateral top ups from a\n        // third party.\n        int256 primeCashReceived = balanceState.depositUnderlyingToken(\n            msg.sender,\n            SafeInt256.toInt(amountExternalPrecision),\n            false // there should never be excess ETH here by definition\n        );\n\n        require(primeCashReceived > 0); // dev: asset tokens negative or zero\n\n        balanceState.finalizeNoWithdraw(account, accountContext);\n        accountContext.setAccountContext(account);\n\n        // Check the supply cap after all balances have been finalized\n        balanceState.primeRate.checkSupplyCap(currencyId);\n\n        // NOTE: no free collateral checks required for depositing\n        return primeCashReceived.toUint();\n    }\n\n    /// @notice DEPRECATED: deposits deprecated cTokens tokens as collateral into an account that\n    /// were listed prior to the migration to prime cash. Future listed tokens will not have asset\n    /// tokens and will revert in this method.\n    /// @param account the account to deposit into\n    /// @param currencyId currency id of the asset token\n    /// @param amountExternalPrecision the amount of asset tokens in its native decimal precision\n    /// (i.e. 8 decimals for cTokens).\n    /// @return asset tokens minted and deposited to the account in internal decimals (8)\n    /// @dev emit:CashBalanceChange emit:AccountContextUpdate\n    /// @dev auth:none\n    function depositAssetToken(\n        address account,\n        uint16 currencyId,\n        uint256 amountExternalPrecision\n    ) external nonReentrant returns (uint256) {\n        require(msg.sender != address(this)); // dev: no internal call to deposit asset\n        // Only the account can deposit into its balance, donations are not allowed.\n        require(msg.sender == account); // dev: unauthorized\n        requireValidAccount(account);\n\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\n        BalanceState memory balanceState;\n        balanceState.loadBalanceState(account, currencyId, accountContext);\n\n        // Int conversion overflow check done inside this method call. msg.sender\n        // is used as the account in deposit to allow for other accounts to deposit\n        // on behalf of the given account. This always does an immediate transfer\n        // and marks the net prime cash change on the balance state.\n        int256 primeCashReceived = balanceState.depositDeprecatedAssetToken(\n            account,\n            SafeInt256.toInt(amountExternalPrecision)\n        );\n\n        require(primeCashReceived > 0); // dev: asset tokens negative or zero\n\n        balanceState.finalizeNoWithdraw(account, accountContext);\n        accountContext.setAccountContext(account);\n\n        // Check the supply cap after all balances have been finalized\n        balanceState.primeRate.checkSupplyCap(currencyId);\n\n        // NOTE: no free collateral checks required for depositing\n        return primeCashReceived.toUint();\n    }\n\n    /// @notice Withdraws balances from Notional, may also redeem to underlying tokens on user request. Will settle\n    /// and do free collateral checks if required. Can only be called by msg.sender, operators who want to withdraw for\n    /// an account must do an authenticated call via ERC1155Action `safeTransferFrom` or `safeBatchTransferFrom`\n    /// @param currencyId currency id of the asset token\n    /// @param amountInternalPrecision the amount of cash balance in internal 8 decimal precision to withdraw,\n    /// this is be denominated in prime cash. If set to uint88 max, will withdraw an entire cash balance.\n    /// @param redeemToUnderlying DEPRECATED except for ETH balances. Prior to the prime cash upgrade, accounts could withdraw\n    /// cTokens directly. However, post prime cash migration this is no longer the case. If withdrawing ETH, setting redeemToUnderlying\n    /// to false will redeem ETH as WETH.\n    /// @dev emit:CashBalanceChange emit:AccountContextUpdate\n    /// @dev auth:msg.sender\n    /// @return the amount of tokens received by the account denominated in the destination token precision (if\n    // redeeming to underlying the amount will be the underlying amount received in that token's native precision)\n    function withdraw(\n        uint16 currencyId,\n        uint88 amountInternalPrecision,\n        bool redeemToUnderlying\n    ) external nonReentrant returns (uint256) {\n        if (currencyId != Constants.ETH_CURRENCY_ID) {\n            require(redeemToUnderlying, \"Deprecated: Redeem to cToken\");\n        }\n        // This happens before reading the balance state to get the most up to date cash balance\n        (AccountContext memory accountContext, /* didSettle */) = _settleAccountIfRequired(msg.sender);\n\n        BalanceState memory balanceState;\n        balanceState.loadBalanceState(msg.sender, currencyId, accountContext);\n        if (amountInternalPrecision == type(uint88).max) {\n            // if set to uint88 max, withdraw the full stored balance. This feature only\n            // works if there is a positive balance\n            require(balanceState.storedCashBalance > 0);\n            balanceState.primeCashWithdraw = balanceState.storedCashBalance.neg();\n        } else {\n            // Overflow is not possible due to uint88\n            balanceState.primeCashWithdraw = int256(amountInternalPrecision).neg();\n        }\n\n        int256 underlyingWithdrawnExternal = balanceState.finalizeWithWithdraw(\n            msg.sender, accountContext, !redeemToUnderlying\n        );\n\n        accountContext.setAccountContext(msg.sender);\n\n        if (accountContext.hasDebt != 0x00) {\n            FreeCollateralExternal.checkFreeCollateralAndRevert(msg.sender);\n        }\n\n        require(underlyingWithdrawnExternal <= 0);\n\n        // No need to check supply caps\n        return underlyingWithdrawnExternal.neg().toUint();\n    }\n\n    function withdrawViaProxy(\n        uint16 currencyId,\n        address account,\n        address receiver,\n        address spender,\n        uint88 withdrawAmountPrimeCash\n    ) external nonReentrant returns (uint256) {\n        address pCashAddress = PrimeCashExchangeRate.getCashProxyAddress(currencyId);\n        require(msg.sender == pCashAddress);\n        requireValidAccount(account);\n\n        if (account != spender) {\n            uint256 allowance = LibStorage.getPCashTransferAllowance()[account][spender][currencyId];\n            require(allowance >= withdrawAmountPrimeCash, \"Insufficient allowance\");\n            LibStorage.getPCashTransferAllowance()[account][spender][currencyId] = allowance - withdrawAmountPrimeCash;\n        }\n\n        // This happens before reading the balance state to get the most up to date cash balance\n        (AccountContext memory accountContext, /* didSettle */) = _settleAccountIfRequired(account);\n\n        BalanceState memory balanceState;\n        balanceState.loadBalanceState(account, currencyId, accountContext);\n        // Cannot withdraw more than existing balance via proxy.\n        require(withdrawAmountPrimeCash <= balanceState.storedCashBalance, \"Insufficient Balance\");\n        // Overflow is not possible due to uint88\n        balanceState.primeCashWithdraw = int256(withdrawAmountPrimeCash).neg();\n\n        // NOTE: withdraw wrapped is always set to true so that the receiver will receive WETH\n        // if ETH is being withdrawn\n        int256 underlyingWithdrawnExternal = balanceState.finalizeWithWithdrawReceiver(\n            account, receiver, accountContext, true\n        );\n\n        accountContext.setAccountContext(account);\n\n        if (accountContext.hasDebt != 0x00) {\n            FreeCollateralExternal.checkFreeCollateralAndRevert(account);\n        }\n\n        require(underlyingWithdrawnExternal <= 0);\n\n        // No need to check supply caps\n        return underlyingWithdrawnExternal.neg().toUint();\n    }\n\n    /// @notice Allows accounts to redeem nTokens into constituent assets and then absorb the assets\n    /// into their portfolio. Due to the complexity here, it is not allowed to be called during a batch trading\n    /// operation and must be done separately.\n    /// @param redeemer the address that holds the nTokens to redeem\n    /// @param currencyId the currency associated the nToken\n    /// @param tokensToRedeem_ the amount of nTokens to convert to cash\n    /// @param sellTokenAssets attempt to sell residual fCash and convert to cash\n    /// @param acceptResidualAssets if true, will place any residual fCash that could not be sold (either due to slippage\n    /// or because it was idiosyncratic) into the account's portfolio\n    /// @dev auth:msg.sender auth:ERC1155\n    /// @return total amount of asset cash redeemed\n    /// @return true or false if there were residuals that were placed into the portfolio\n    function nTokenRedeem(\n        address redeemer,\n        uint16 currencyId,\n        uint96 tokensToRedeem_,\n        bool sellTokenAssets,\n        bool acceptResidualAssets\n    ) external nonReentrant returns (int256, bool) {\n        // ERC1155 can call this method during a post transfer event\n        require(msg.sender == redeemer || msg.sender == address(this), \"Unauthorized caller\");\n        int256 tokensToRedeem = int256(tokensToRedeem_);\n\n        (AccountContext memory context, /* didSettle */) = _settleAccountIfRequired(redeemer);\n\n        BalanceState memory balance;\n        balance.loadBalanceState(redeemer, currencyId, context);\n\n        require(balance.storedNTokenBalance >= tokensToRedeem, \"Insufficient tokens\");\n        balance.netNTokenSupplyChange = tokensToRedeem.neg();\n\n        (int256 totalPrimeCash, PortfolioAsset[] memory assets) = nTokenRedeemAction.redeem(\n            redeemer, currencyId, tokensToRedeem, sellTokenAssets, acceptResidualAssets\n        );\n\n        // Set balances before transferring assets\n        balance.netCashChange = totalPrimeCash;\n        balance.finalizeNoWithdraw(redeemer, context);\n\n        // The hasResidual flag is only set to true if selling residuals has failed, checking\n        // if the length of assets is greater than zero will detect the presence of ifCash\n        // assets that have not been sold.\n        if (assets.length > 0) {\n            // This method will store assets and return the memory location of the new account\n            // context.\n            address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);\n            context = SettleAssetsExternal.placeAssetsInAccount(redeemer, nTokenAddress, context, assets);\n        }\n\n        context.setAccountContext(redeemer);\n        if (context.hasDebt != 0x00) {\n            FreeCollateralExternal.checkFreeCollateralAndRevert(redeemer);\n        }\n\n        return (totalPrimeCash, assets.length > 0);\n    }\n\n    /// @notice Settle the account if required, returning a reference to the account context. Also\n    /// returns a boolean to indicate if it did settle.\n    function _settleAccountIfRequired(address account)\n        private\n        returns"
    }
  ]
}