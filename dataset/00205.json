{
  "Title": "M-11: ZivoeYDL::distributeYield yield distribution is flash-loan manipulatable",
  "Content": "# Issue M-11: ZivoeYDL::distributeYield yield distribution is flash-loan manipulatable \n\nSource: https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/298 \n\nThe protocol has acknowledged this issue.\n\n## Found by \ncergyk\n## Summary\n\n`ZivoeYDL::distributeYield` is used to \"distributes available yield within this contract to appropriate entities\" but it relies on the tokens `totalSupply()` which can be manipulable through a flashloan.\n\n## Vulnerability Detail\n\n`ZivoeYDL::distributeYield` relies on `stZVE().totalSupply()` to distribute protocol earnings and residual earnings:\n\n[ZivoeYDL.sol#L241-L310](https://github.com/sherlock-audit/2024-03-zivoe/blob/d4111645b19a1ad3ccc899bea073b6f19be04ccd/zivoe-core-foundry/src/ZivoeYDL.sol#L241-L310)\n```solidity\n        // Distribute protocol earnings.\n...\n            else if (_recipient == IZivoeGlobals_YDL(GBL).stZVE()) {\n                uint256 splitBIPS = (\n>>                  IERC20(IZivoeGlobals_YDL(GBL).stZVE()).totalSupply() * BIPS\n                ) / (\n                    IERC20(IZivoeGlobals_YDL(GBL).stZVE()).totalSupply() + \n                    IERC20(IZivoeGlobals_YDL(GBL).vestZVE()).totalSupply()\n                );\n...\n        // Distribute residual earnings.\n...\n                else if (_recipient == IZivoeGlobals_YDL(GBL).stZVE()) {\n                    uint256 splitBIPS = (\n>>                      IERC20(IZivoeGlobals_YDL(GBL).stZVE()).totalSupply() * BIPS\n                    ) / (\n                        IERC20(IZivoeGlobals_YDL(GBL).stZVE()).totalSupply() + \n                        IERC20(IZivoeGlobals_YDL(GBL).vestZVE()).totalSupply()\n                    );\n...\n```\n\nThis can be abused by an attacker by buying then staking a very large amount of `ZVE` right before calling `ZivoeYDL::distributeYield` (a flashloan can be used) in order to game the system and collect a lot more distributed yields than he should be entitled to.\n\n### Scenario\n\n1. Attacker buys and stakes a very large amount of `ZVE` through a flashloan\n2. Attacker calls `ZivoeYDL::distributeYield`\n3. Attacker collects a very large amount of distributed yields\n4. Attacker withdraws and sells back his `ZVE` tokens effectively stealing undeserved yields\n\n## Impact\n\nA user can systematically claim a big chunk of the rewards reserved to `stZVE` and `vestZVE` in `ZivoeYDL` by using a flash loan\n\n## Code Snippet\n\n- https://github.com/sherlock-audit/2024-03-zivoe/blob/d4111645b19a1ad3ccc899bea073b6f19be04ccd/zivoe-core-foundry/src/ZivoeYDL.sol#L241-L310\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse a minimal time locking for stZVE such as it would not be possible to stake and unstake all in one block, or use past (1 block in the past) total supply to claim rewards\n\n\n\n## Discussion\n\n**pseudonaut**\n\nNot valid\n\n**sherlock-admin4**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**panprog** commented:\n> medium. The scenario presented isn't actually possible, because staking reward is deposited to be distributed over the long period of time, so the attacker won't earn anything from staking for 0 blocks. However, it still allows to manipulate the ratio of stZVE/vestZVE reward allocation, so it's possible to inflate reward to stZVE, then withdraw, but stZVE will receive inflated reward (where attacker can have a significant amount of token staked to benefit from increased yield). This is at the expense of vestZVE which will receive deflated reward.\n\n\n\n**panprog**\n\nKeeping this medium.\n\nWhile the scenario is not possible as described, it still describes a valid issue, attack vector and core reason (manipulation to inflate stZVE's share of distribution).\n\n**panprog**\n\nSponsor response:\n> there's no economically feasible way to make this occur, given restricted circulating supply (<10% circulating for a number of years, with 30% in DAO and 60% in vestZVE, slippage/fees on DEXs and likely supply lowered due to CEX trading) and it implies that user maintains amount being staked after the flash-loan (separate from whatever was used to manipulate it) and doesn't even account for other users coming in over next 30 days and diluting any additional yield earned\n\n**panprog**\n\nYou don't need a lot of ZVE to impact the reward distribution. For example, the ratio is 1% in stZVE and 99% in vestZVE. If you buy 1% of ZVE, stake it, call distributeYield, then unstake and sell back ZVE, the ratio is now 2% in stZVE, 98% in vestZVE, so a double rate for stZVE for the next 30 days. The loss for vestZVE is not large, but still loss nonetheless.\n\nKeeping this medium.\n\n**0x73696d616f**\n\nEscalate\n\nThe issue described should be invalid as it is the intended behaviour of the protocol.\nSince the user has to stake to get the rewards for some time, he would have done the regular operation for users.\nThe user is not getting more rewards for himself than any user that legitimately staked before.\nHe is just staking closer to the deadline.\nKeep in mind that the protocol is always handing out the same APR (unless not enough liquidity is available) to all stakers, so in practice other users would not even lose from this.\n\n**sherlock-admin3**\n\n> Escalate\n> \n> The issue described should be invalid as it is the intended behaviour of the protocol.\n> Since the user has to stake to get the rewards for some time, he would have done the regular operation for users.\n> The user is not getting more rewards for himself than any user that legitimately staked before.\n> He is just staking closer to the deadline.\n> Keep in mind that the protocol is always handing out the same APR (unless not enough liquidity is available) to all stakers, so in practice other users would not even lose from this.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**panprog**\n\nThe issue is that a 1-transaction inflated staked amount allows to inflate stakers distribution at the loss of vesters distribution.\n\n**WangSecurity**\n\nI'm not sure I understand how it effects the yield after we call `distributeYield`. If we take example from [this](https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/298#issuecomment-2105099742) comment:\n\nThe ratio is 1% stZVE and 99% vstZVE. The attacker stakes ZVE, so it's now 2% for stZVE, call disitrbute yield, then unstake ZVE, so it's again 1%. \n\nThe timelock to call distributeYield passes and we call it again. We firstly calculate the ratio, which will be 1% stZVE and 99% vstZVE (I think I miss something here) and then the yield is distributed. So the main question is are these inflated ratios (2% for stZVE) actually saved upon the next time we call `distributeYield`?\n\nOr the problem is that we can front-run the call to `ditributeYield` every time to get more rewards?\n\n(Sorry if silly questions, but the phrase \"double rate for stZVE for the next 30 days\" really confuses me, since the ratio is calculated right before transfering the rewards)\n\n**0x73696d616f**\n\nHey @WangSecurity, \n> The ratio is 1% stZVE and 99% vstZVE. The attacker stakes ZVE, so it's now 2% for stZVE, call disitrbute yield, then unstake ZVE, so it's again 1%.\n\n`distributeYield` is only called every 30 days. The yield during these 30 days is distributed based on a snapshot of the total supplies at the time `distributeYield` is called. This issue claims that if you take a flashloan of ZVE before calling `distributeYield` and stake, increasing the stZVE supply, the snapshot is taken, and the % of yield attributed to stZVE for the 30 days is increased. After 30 days, another `distributeYield` call happens and a snapshot is taken again, where the % is back to 1% as the flashloanee would have unstaked the stZVE by then.\n\nMy claim is that this is the intended behaviour, the flashloan does not matter here at all because the attacker has to stake to profit from this. If the attacker stakes, then he also rightfully so receives rewards for the increased supply of stZVE.\n\n**panprog**\n\n@WangSecurity \n`distributeYield` sets the rate for the next 30 days.\n\nScenario A: 1% stZVE, 99% vstZVE. `distributeYield` sets the rate for the next 30 days: stZVE get $1/second, vstZVE get $99/second.\n\nScenario B: 1% stZVE, 99% vstZVE. User acquires 1% ZVE, stakes it, calls `distributeYield`, unstakes, returns back ZVE. The rate set for the next 30 days: stZVE get $2/second, vstZVE get $98/second.\n\nIn Scenario B, stZVE stakers get double the rate they should while ZVE is released into circulation as if it was never staked. Basically, it's possible to inflate stZVE reward rate while not really staking corresponding ZVE amount.\n\n**0x73696d616f**\n\nThe design is suboptimal but it is ultimately a design choice. It can not be gamed like this issue says with a flashloan. The supposed attack is just regular user operation. I believe in these cases it is not a valid medium on Sherlock, but I leave it up to the judge.\n\n**WangSecurity**\n\nI see and understand with arguments both for and against it being the designed decision. But this in fact allows to inflate the stZVE rewards without actually staking ZVE. In the edge case, the attack can be done in one transaction and inflate the rewards in several times (even more than 2x as in the Lead Judge's example). Hence, I believe it's indeed valid, planning to reject the escalation and leave the issue as it is.\n\n**RealLTDingZhen**\n\nI agree with @0x73696d616f . It should be a design choice here, because this issue cannot be fixed in current protocol.  Even if a minimum holding interval is guaranteed, whales can still change the stZVE/vestZVE reward distribution ratio by \n\n> Attacker buys and stakes a very large amount of ZVE through a flashloan in advance\n> Attacker wait for minimum holding interval\n> Attacker calls ZivoeYDL::distributeYield\n> Attacker collects a very large amount of distributed yields\n> Attacker withdraws and sells back his ZVE tokens effectively stealing undeserved yields\n\nThe only way to fix this is to add a withdraw fee, which means a redesign of protocol core logic. So I believe this is not a contract vulnerablilty.\n\n**WangSecurity**\n\nThank you for that response! Firstly, I don't think that the mitigation is the reason to validate/invalidate the issue, moreover, the LSW provided two other mitigations. Secondly, I understand that the same can happen with regular workflow, but I believe it's still an issue, cause allows the attacker to intentionally manipulate the distribution ratio without actually staking ZVE (only for one block). Hence, my decision remains the same.\n\n**Evert0x**\n\nResult:\nMedium\nUnique\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0x73696d616f](https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/298/#issuecomment-2106284905): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/280",
  "Code": [
    {
      "filename": "zivoe-core-foundry/src/ZivoeYDL.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"./ZivoeMath.sol\";\n\nimport \"./libraries/FloorMath.sol\";\n\nimport \"../lib/openzeppelin-contracts/contracts/utils/Context.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ninterface IZivoeGlobals_YDL {\n    /// @notice Returns the address of the ZivoeDAO contract.\n    function DAO() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeITO contract.\n    function ITO() external view returns (address);\n    \n    /// @notice Returns the address of the ZivoeRewards ($zSTT) contract.\n    function stSTT() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeRewards ($zJTT) contract.\n    function stJTT() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeRewards ($ZVE) contract.\n    function stZVE() external view returns (address);\n\n    /// @notice Returns the address of the Timelock contract.\n    function TLC() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeRewardsVesting ($ZVE) vesting contract.\n    function vestZVE() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeTrancheToken ($zSTT) contract.\n    function zSTT() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeTrancheToken ($zJTT) contract.\n    function zJTT() external view returns (address);\n\n    /// @notice Returns the address of the Zivoe Laboratory.\n    function ZVL() external view returns (address);\n\n    /// @notice Returns total circulating supply of zSTT and zJTT, accounting for defaults via markdowns.\n    /// @return zSTTSupply zSTT.totalSupply() adjusted for defaults.\n    /// @return zJTTSupply zJTT.totalSupply() adjusted for defaults.\n    function adjustedSupplies() external view returns (uint256 zSTTSupply, uint256 zJTTSupply);\n\n    /// @notice Handles WEI standardization of a given asset amount (i.e. 6 decimal precision => 18 decimal precision).\n    /// @param  amount The amount of a given \"asset\".\n    /// @param  asset The asset (ERC-20) from which to standardize the amount to WEI.\n    /// @return standardizedAmount The above amount standardized to 18 decimals.\n    function standardize(uint256 amount, address asset) external view returns (uint256 standardizedAmount);\n\n    /// @notice This function will verify if a given stablecoin has been whitelisted for use throughout system.\n    /// @param  stablecoin address of the stablecoin to verify acceptance for.\n    function stablecoinWhitelist(address stablecoin) external view returns (bool);\n}\n\ninterface IZivoeRewards_YDL {\n    /// @notice Deposits a reward to this contract for distribution.\n    /// @param  _rewardsToken The asset that's being distributed.\n    /// @param  reward The amount of the _rewardsToken to deposit.\n    function depositReward(address _rewardsToken, uint256 reward) external;\n}\n\n\n\n/// @notice  This contract manages the accounting for distributing yield across multiple contracts.\n///          This contract has the following responsibilities:\n///            - Escrows yield in between distribution periods.\n///            - Manages accounting for yield distribution.\n///            - Supports modification of certain state variables for governance purposes.\n///            - Tracks historical values using EMA (exponential moving average) on 30-day basis.\ncontract ZivoeYDL is Context, ReentrancyGuard {\n\n    using SafeERC20 for IERC20;\n    using FloorMath for uint256;\n\n    // ---------------------\n    //    State Variables\n    // ---------------------\n\n    struct Recipients {\n        address[] recipients;\n        uint256[] proportion;\n    }\n\n    Recipients protocolRecipients;          /// @dev Tracks the distributions for protocol earnings.\n    Recipients residualRecipients;          /// @dev Tracks the distributions for residual earnings.\n\n    address public immutable GBL;           /// @dev The ZivoeGlobals contract.\n\n    address public distributedAsset;        /// @dev The \"stablecoin\" that will be distributed via YDL.\n\n    // Weighted moving averages.\n    uint256 public emaSTT;          /// @dev Weighted moving average for senior tranche size, a.k.a. zSTT.totalSupply().\n    uint256 public emaJTT;          /// @dev Weighted moving average for junior tranche size, a.k.a. zJTT.totalSupply().\n\n    // Indexing.\n    uint256 public distributionCounter;     /// @dev Number of calls to distributeYield().\n    uint256 public lastDistribution;        /// @dev Used for timelock constraint to call distributeYield().\n\n    // Accounting vars (governable).\n    uint256 public targetAPYBIPS = 1000;                /// @dev The target annualized yield for senior tranche.\n    uint256 public targetRatioBIPS = 22000;             /// @dev The target ratio of junior to senior tranche.\n    uint256 public protocolEarningsRateBIPS = 2000;     /// @dev The protocol earnings rate.\n\n    // Accounting vars (constant).\n    uint256 public constant daysBetweenDistributions = 30;   /// @dev Number of days between yield distributions.\n    uint256 public constant retrospectiveDistributions = 6;  /// @dev Retrospective moving average period.\n    \n    bool public unlocked;                   /// @dev Prevents contract from supporting functionality until unlocked.\n\n    uint256 private constant BIPS = 10000;\n    uint256 private constant RAY = 10 ** 27;\n\n    ZivoeMath public MATH;\n\n\n\n    // -----------------\n    //    Constructor\n    // -----------------\n\n    /// @notice Initialize the ZivoeYDL contract.\n    /// @param  _GBL The ZivoeGlobals contract.\n    /// @param  _distributedAsset The \"stablecoin\" that will be distributed via YDL.\n    constructor(address _GBL, address _distributedAsset) {\n        GBL = _GBL;\n        distributedAsset = _distributedAsset;\n        MATH = new ZivoeMath();\n    }\n\n\n\n    // ------------\n    //    Events\n    // ------------\n\n    /// @notice Emitted during returnAsset().\n    /// @param  asset The asset returned.\n    /// @param  amount The amount of \"asset\" returned to DAO.\n    event AssetReturned(address indexed asset, uint256 amount);\n\n    /// @notice Emitted during updateDistributedAsset().\n    /// @param  oldAsset The old value of distributedAsset.\n    /// @param  newAsset The new value of distributedAsset.\n    event UpdatedDistributedAsset(address indexed oldAsset, address indexed newAsset);\n\n    /// @notice Emitted during updateProtocolEarningsRateBIPS().\n    /// @param  oldValue The old value of protocolEarningsRateBIPS.\n    /// @param  newValue The new value of protocolEarningsRateBIPS.\n    event UpdatedProtocolEarningsRateBIPS(uint256 oldValue, uint256 newValue);\n\n    /// @notice Emitted during updateRecipients().\n    /// @param  recipients The new recipients to receive protocol earnings.\n    /// @param  proportion The proportion distributed across recipients.\n    event UpdatedProtocolRecipients(address[] recipients, uint256[] proportion);\n\n    /// @notice Emitted during updateRecipients().\n    /// @param  recipients The new recipients to receive residual earnings.\n    /// @param  proportion The proportion distributed across recipients.\n    event UpdatedResidualRecipients(address[] recipients, uint256[] proportion);\n\n    /// @notice Emitted during updateTargetAPYBIPS().\n    /// @param  oldValue The old value of targetAPYBIPS.\n    /// @param  newValue The new value of targetAPYBIPS.\n    event UpdatedTargetAPYBIPS(uint256 oldValue, uint256 newValue);\n\n    /// @notice Emitted during updateTargetRatioBIPS().\n    /// @param  oldValue The old value of targetRatioBIPS.\n    /// @param  newValue The new value of targetRatioBIPS.\n    event UpdatedTargetRatioBIPS(uint256 oldValue, uint256 newValue);\n\n    /// @notice Emitted during distributeYield().\n    /// @param  protocol The amount of earnings distributed to protocol earnings recipients.\n    /// @param  senior The amount of earnings distributed to the senior tranche.\n    /// @param  junior The amount of earnings distributed to the junior tranche.\n    /// @param  residual The amount of earnings distributed to residual earnings recipients.\n    event YieldDistributed(uint256[] protocol, uint256 senior, uint256 junior, uint256[] residual);\n\n    /// @notice Emitted during distributeYield().\n    /// @param  asset The \"asset\" being distributed.\n    /// @param  recipient The recipient of the distribution.\n    /// @param  amount The amount distributed.\n    event YieldDistributedSingle(address indexed asset, address indexed recipient, uint256 amount);\n\n\n\n    // ---------------\n    //    Functions\n    // ---------------\n\n    /// @notice View distribution information for protocol and residual earnings recipients.\n    /// @return protocolEarningsRecipients The destinations for protocol earnings distributions.\n    /// @return protocolEarningsProportion The proportions for protocol earnings distributions.\n    /// @return residualEarningsRecipients The destinations for residual earnings distributions.\n    /// @return residualEarningsProportion The proportions for residual earnings distributions.\n    function viewDistributions() external view returns (\n        address[] memory protocolEarningsRecipients, uint256[] memory protocolEarningsProportion, \n        address[] memory residualEarningsRecipients, uint256[] memory residualEarningsProportion\n    ) {\n        return (\n            protocolRecipients.recipients, \n            protocolRecipients.proportion, \n            residualRecipients.recipients, \n            residualRecipients.proportion\n        );\n    }\n    \n    /// @notice Distributes available yield within this contract to appropriate entities.\n    function distributeYield() external nonReentrant {\n        require(unlocked, \"ZivoeYDL::distributeYield() !unlocked\"); \n        require(\n            block.timestamp >= lastDistribution + daysBetweenDistributions * 86400, \n            \"ZivoeYDL::distributeYield() block.timestamp < lastDistribution + daysBetweenDistributions * 86400\"\n        );\n\n        // Calculate protocol earnings.\n        uint256 earnings = IERC20(distributedAsset).balanceOf(address(this));\n        uint256 protocolEarnings = protocolEarningsRateBIPS * earnings / BIPS;\n        uint256 postFeeYield = earnings.floorSub(protocolEarnings);\n\n        // Update timeline.\n        distributionCounter += 1;\n        lastDistribution = block.timestamp;\n\n        // Calculate yield distribution (trancheuse = \"slicer\" in French).\n        (\n            uint256[] memory _protocol, uint256 _seniorTranche, uint256 _juniorTranche, uint256[] memory _residual\n        ) = earningsTrancheuse(protocolEarnings, postFeeYield); \n\n        emit YieldDistributed(_protocol, _seniorTranche, _juniorTranche, _residual);\n        \n        // Update ema-based supply values.\n        (uint256 aSTT, uint256 aJTT) = IZivoeGlobals_YDL(GBL).adjustedSupplies();\n        emaSTT = MATH.ema(emaSTT, aSTT, retrospectiveDistributions.min(distributionCounter));\n        emaJTT = MATH.ema(emaJTT, aJTT, retrospectiveDistributions.min(distributionCounter));\n\n        // Distribute protocol earnings.\n        for (uint256 i = 0; i < protocolRecipients.recipients.length; i++) {\n            address _recipient = protocolRecipients.recipients[i];\n            if (_recipient == IZivoeGlobals_YDL(GBL).stSTT() ||_recipient == IZivoeGlobals_YDL(GBL).stJTT()) {\n                IERC20(distributedAsset).safeIncreaseAllowance(_recipient, _protocol[i]);\n                IZivoeRewards_YDL(_recipient).depositReward(distributedAsset, _protocol[i]);\n                emit YieldDistributedSingle(distributedAsset, _recipient, _protocol[i]);\n            }\n            else if (_recipient == IZivoeGlobals_YDL(GBL).stZVE()) {\n                uint256 splitBIPS = (\n                    IERC20(IZivoeGlobals_YDL(GBL).stZVE()).totalSupply() * BIPS\n                ) / (\n                    IERC20(IZivoeGlobals_YDL(GBL).stZVE()).totalSupply() + \n                    IERC20(IZivoeGlobals_YDL(GBL).vestZVE()).totalSupply()\n                );\n                uint stZVEAllocation = _protocol[i] * splitBIPS / BIPS;\n                uint vestZVEAllocation = _protocol[i] * (BIPS - splitBIPS) / BIPS;\n                IERC20(distributedAsset).safeIncreaseAllowance(IZivoeGlobals_YDL(GBL).stZVE(), stZVEAllocation);\n                IERC20(distributedAsset).safeIncreaseAllowance(IZivoeGlobals_YDL(GBL).vestZVE(),vestZVEAllocation);\n                IZivoeRewards_YDL(IZivoeGlobals_YDL(GBL).stZVE()).depositReward(distributedAsset, stZVEAllocation);\n                IZivoeRewards_YDL(IZivoeGlobals_YDL(GBL).vestZVE()).depositReward(distributedAsset, vestZVEAllocation);\n                emit YieldDistributedSingle(distributedAsset, IZivoeGlobals_YDL(GBL).stZVE(), stZVEAllocation);\n                emit YieldDistributedSingle(distributedAsset, IZivoeGlobals_YDL(GBL).vestZVE(), vestZVEAllocation);\n            }\n            else {\n                IERC20(distributedAsset).safeTransfer(_recipient, _protocol[i]);\n                emit YieldDistributedSingle(distributedAsset, _recipient, _protocol[i]);\n            }\n        }\n\n        // Distribute senior and junior tranche earnings.\n        IERC20(distributedAsset).safeIncreaseAllowance(IZivoeGlobals_YDL(GBL).stSTT(), _seniorTranche);\n        IERC20(distributedAsset).safeIncreaseAllowance(IZivoeGlobals_YDL(GBL).stJTT(), _juniorTranche);\n        IZivoeRewards_YDL(IZivoeGlobals_YDL(GBL).stSTT()).depositReward(distributedAsset, _seniorTranche);\n        IZivoeRewards_YDL(IZivoeGlobals_YDL(GBL).stJTT()).depositReward(distributedAsset, _juniorTranche);\n        emit YieldDistributedSingle(distributedAsset, IZivoeGlobals_YDL(GBL).stSTT(), _seniorTranche);\n        emit YieldDistributedSingle(distributedAsset, IZivoeGlobals_YDL(GBL).stJTT(), _juniorTranche);\n\n        // Distribute residual earnings.\n        for (uint256 i = 0; i < residualRecipients.recipients.length; i++) {\n            if (_residual[i] > 0) {\n                address _recipient = residualRecipients.recipients[i];\n                if (_recipient == IZivoeGlobals_YDL(GBL).stSTT() ||_recipient == IZivoeGlobals_YDL(GBL).stJTT()) {\n                    IERC20(distributedAsset).safeIncreaseAllowance(_recipient, _residual[i]);\n                    IZivoeRewards_YDL(_recipient).depositReward(distributedAsset, _residual[i]);\n                    emit YieldDistributedSingle(distributedAsset, _recipient, _protocol[i]);\n                }\n                else if (_recipient == IZivoeGlobals_YDL(GBL).stZVE()) {\n                    uint256 splitBIPS = (\n                        IERC20(IZivoeGlobals_YDL(GBL).stZVE()).totalSupply() * BIPS\n                    ) / (\n                        IERC20(IZivoeGlobals_YDL(GBL).stZVE()).totalSupply() + \n                        IERC20(IZivoeGlobals_YDL(GBL).vestZVE()).totalSupply()\n                    );\n                    uint stZVEAllocation = _residual[i] * splitBIPS / BIPS;\n                    uint vestZVEAllocation = _residual[i] * (BIPS - splitBIPS) / BIPS;\n                    IERC20(distributedAsset).safeIncreaseAllowance(IZivoeGlobals_YDL(GBL).stZVE(), stZVEAllocation);\n                    IERC20(distributedAsset).safeIncreaseAllowance(IZivoeGlobals_YDL(GBL).vestZVE(), vestZVEAllocation);\n                    IZivoeRewards_YDL(IZivoeGlobals_YDL(GBL).stZVE()).depositReward(distributedAsset, stZVEAllocation);\n                    IZivoeRewards_YDL(IZivoeGlobals_YDL(GBL).vestZVE()).depositReward(distributedAsset, vestZVEAllocation);\n                    emit YieldDistributedSingle(distributedAsset, IZivoeGlobals_YDL(GBL).stZVE(), stZVEAllocation);\n                    emit YieldDistributedSingle(distributedAsset, IZivoeGlobals_YDL(GBL).vestZVE(), vestZVEAllocation);\n                }\n                else {\n                    IERC20(distributedAsset).safeTransfer(_recipient, _residual[i]);\n                    emit YieldDistributedSingle(distributedAsset, _recipient, _residual[i]);\n                }\n            }\n        }\n    }\n\n    /// @notice Returns an asset to DAO if not distributedAsset().\n    /// @param asset The asset to return.\n    function returnAsset(address asset) external {\n        require(asset != distributedAsset, \"ZivoeYDL::returnAsset() asset == distributedAsset\");\n        emit AssetReturned(asset, IERC20(asset).balanceOf(address(this)));\n        IERC20(asset).safeTransfer(IZivoeGlobals_YDL(GBL).DAO(), IERC20(asset).balanceOf(address(this)));\n    }\n\n    /// @notice Unlocks this contract for distributions, initializes values.\n    function unlock() external {\n        require(\n            _msgSender() == IZivoeGlobals_YDL(GBL).ITO(), \n            \"ZivoeYDL::unlock() _msgSender() != IZivoeGlobals_YDL(GBL).ITO()\"\n        );\n\n        unlocked = true;\n        lastDistribution = block.timestamp + 30 days;\n\n        emaSTT = IERC20(IZivoeGlobals_YDL(GBL).zSTT()).totalSupply();\n        emaJTT = IERC20(IZivoeGlobals_YDL(GBL).zJTT()).totalSupply();\n\n        address[] memory protocolRecipientAcc = new address[](2);\n        uint256[] memory protocolRecipientAmt = new uint256[](2);\n\n        protocolRecipientAcc[0] = address(IZivoeGlobals_YDL(GBL).stZVE());\n        protocolRecipientAmt[0] = 6666;\n        protocolRecipientAcc[1] = address(IZivoeGlobals_YDL(GBL).ZVL());\n        protocolRecipientAmt[1] = 3334;\n\n        protocolRecipients = Recipients(protocolRecipientAcc, protocolRecipientAmt);\n\n        address[] memory residualRecipientAcc = new address[](2);\n        uint256[] memory residualRecipientAmt = new uint256[](2);\n\n        residualRecipientAcc[0] = address(IZivoeGlobals_YDL(GBL).stZVE());\n        residualRecipientAmt[0] = 6666;\n        residualRecipientAcc[1] = address(IZivoeGlobals_YDL(GBL).ZVL());\n        residualRecipientAmt[1] = 3334;\n\n        residualRecipients = Recipients(residualRecipientAcc, residualRecipientAmt);\n    }\n\n    /// @notice Updates the distributed asset for this particular contract.\n    /// @param  _distributedAsset The new value for distributedAsset.\n    function updateDistributedAsset(address _distributedAsset) external nonReentrant {\n        require(\n            _distributedAsset != distributedAsset, \n            \"ZivoeYDL::updateDistributedAsset() _distributedAsset == distributedAsset\"\n        );\n        require(\n            _msgSender() == IZivoeGlobals_YDL(GBL).TLC(), \n            \"ZivoeYDL::updateDistributedAsset() _msgSender() != TLC()\"\n        );\n        require(\n            IZivoeGlobals_YDL(GBL).stablecoinWhitelist(_distributedAsset),\n            \"ZivoeYDL::updateDistributedAsset() !IZivoeGlobals_YDL(GBL).stablecoinWhitelist(_distributedAsset)\"\n        );\n        emit UpdatedDistributedAsset(distributedAsset, _distributedAsset);\n        distributedAsset = _distributedAsset;\n    }\n\n    /// @notice Updates the state variable \"protocolEarningsRateBIPS\".\n    /// @param  _protocolEarningsRateBIPS The new value for protocolEarningsRateBIPS.\n    function updateProtocolEarningsRateBIPS(uint256 _protocolEarningsRateBIPS) external {\n        require(\n            _msgSender() == IZivoeGlobals_YDL(GBL).TLC(), \n            \"ZivoeYDL::updateProtocolEarningsRateBIPS() _msgSender() != TLC()\"\n        );\n        require(\n            _protocolEarningsRateBIPS <= 9000, \n            \"ZivoeYDL::updateProtocolEarningsRateBIPS() _protocolEarningsRateBIPS > 9000\"\n        );\n        emit UpdatedProtocolEarningsRateBIPS(protocolEarningsRateBIPS, _protocolEarningsRateBIPS);\n        protocolEarningsRateBIPS = _protocolEarningsRateBIPS;\n    }\n\n    /// @notice Updates the protocolRecipients or residualRecipients.\n    /// @param  recipients An array of addresses to which protocol earnings will be distributed.\n    /// @param  proportions An array of ratios relative to the recipients - in BIPS. Sum should equal to 10000.\n    /// @param  protocol Specify \"true\" to update protocol earnings, or \"false\" to update residual earnings.\n    function updateRecipients(address[] memory recipients, uint256[] memory proportions, bool protocol) external {\n        require(_msgSender() == IZivoeGlobals_YDL(GBL).TLC(), \"ZivoeYDL::updateRecipients() _msgSender() != TLC()\");\n        require(\n            recipients.length == proportions.length && recipients.length > 0, \n            \"ZivoeYDL::updateRecipients() recipients.length != proportions.length || recipients.length == 0\"\n        );\n        require(unlocked, \"ZivoeYDL::updateRecipients() !unlocked\");\n\n        uint256 proportionTotal;\n        for (uint256 i = 0; i < recipients.length; i++) {\n            proportionTotal += proportions[i];\n            require(proportions[i] > 0, \"ZivoeYDL::updateRecipients() proportions[i] == 0\");\n            require(recipients[i] != address(0), \"ZivoeYDL::updateRecipients() recipients[i] == address(0)\");\n        }\n\n        require(proportionTotal == BIPS, \"ZivoeYDL::updateRecipients() proportionTotal != BIPS (10,000)\");\n        if (protocol) {\n            emit UpdatedProtocolRecipients(recipients, proportions);\n            protocolRecipients = Recipients(recipients, proportions);\n        }\n        else {\n            emit UpdatedResidualRecipients(recipients, proportions);\n            residualRecipients = Recipients(recipients, proportions);\n        }\n    }\n\n    /// @notice Updates the state variable \"targetAPYBIPS\".\n    /// @param  _targetAPYBIPS The new value for targetAPYBIPS.\n    function updateTargetAPYBIPS(uint256 _targetAPYBIPS) external {\n        require(_msgSender() == IZivoeGlobals_YDL(GBL).TLC(), \"ZivoeYDL::updateTargetAPYBIPS() _msgSender() != TLC()\");\n        emit UpdatedTargetAPYBIPS(targetAPYBIPS, _targetAPYBIPS);\n        targetAPYBIPS = _targetAPYBIPS;\n    }\n\n    /// @notice Updates the state variable \"targetRatioBIPS\".\n    /// @param  _targetRatioBIPS The new value for targetRatioBIPS.\n    function updateTargetRatioBIPS(uint256 _targetRatioBIPS) external {\n        require(_msgSender() == IZivoeGlobals_YDL(GBL).TLC(), \"ZivoeYDL::updateTargetRatioBIPS() _msgSender() != TLC()\");\n        emit UpdatedTargetRatioBIPS(targetRatioBIPS, _targetRatioBIPS);\n        targetRatioBIPS = _targetRatioBIPS;\n    }\n\n\n\n    // ----------\n    //    Math\n    // ----------\n\n    /// @notice Calculates the distribution of yield (\"earnings\") for the four primary groups.\n    /// @param  yP Yield for the protocol.\n    /// @param  yD Yield for the remaining three groups.\n    /// @return protocol Protocol earnings.\n    /// @return senior Senior tranche earnings.\n    /// @return junior Junior tranche earnings.\n    /// @return residual Residual earnings.\n    function earningsTrancheuse(uint256 yP, uint256 yD) public view returns (\n        uint256[] memory protocol, uint256 senior, uint256 junior, uint256[] memory residual\n    ) {\n        protocol = new uint256[](protocolRecipients.recipients.length);\n        residual = new uint256[](residualRecipients.recipients.length);\n        \n        // Accounting for protocol earnings.\n        for (uint256 i = 0; i < protocolRecipients.recipients.length; i++) {\n            protocol[i] = protocolRecipients.proportion[i] * yP / BIPS;\n        }\n\n        // Accounting for senior and junior earnings.\n        uint256 _seniorProportion = MATH.seniorProportion(\n            IZivoeGlobals_YDL(GBL).standardize(yD, distributedAsset),\n            MATH.yieldTarget(emaSTT, emaJTT, targetAPYBIPS, targetRatioBIPS, daysBetweenDistributions),\n            emaSTT, emaJTT, targetAPYBIPS, targetRatioBIPS, daysBetweenDistributions\n        );\n        senior = (yD * _seniorProportion) / RAY;\n        junior = (yD * MATH.juniorProportion(emaSTT, emaJTT, _seniorProportion, targetRatioBIPS)) / RAY;\n        \n        // Handle accounting for residual earnings.\n        yD = yD.floorSub(senior + junior);\n        for (uint256 i = 0; i < residualRecipients.recipients.length; i++) {\n            residual[i] = residualRecipients.proportion[i] * yD / BIPS;\n        }\n    }\n\n}"
    },
    {
      "filename": "zivoe-core-foundry/src/ZivoeYDL.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"./ZivoeMath.sol\";\n\nimport \"./libraries/FloorMath.sol\";\n\nimport \"../lib/openzeppelin-contracts/contracts/utils/Context.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ninterface IZivoeGlobals_YDL {\n    /// @notice Returns the address of the ZivoeDAO contract.\n    function DAO() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeITO contract.\n    function ITO() external view returns (address);\n    \n    /// @notice Returns the address of the ZivoeRewards ($zSTT) contract.\n    function stSTT() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeRewards ($zJTT) contract.\n    function stJTT() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeRewards ($ZVE) contract.\n    function stZVE() external view returns (address);\n\n    /// @notice Returns the address of the Timelock contract.\n    function TLC() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeRewardsVesting ($ZVE) vesting contract.\n    function vestZVE() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeTrancheToken ($zSTT) contract.\n    function zSTT() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeTrancheToken ($zJTT) contract.\n    function zJTT() external view returns (address);\n\n    /// @notice Returns the address of the Zivoe Laboratory.\n    function ZVL() external view returns (address);\n\n    /// @notice Returns total circulating supply of zSTT and zJTT, accounting for defaults via markdowns.\n    /// @return zSTTSupply zSTT.totalSupply() adjusted for defaults.\n    /// @return zJTTSupply zJTT.totalSupply() adjusted for defaults.\n    function adjustedSupplies() external view returns (uint256 zSTTSupply, uint256 zJTTSupply);\n\n    /// @notice Handles WEI standardization of a given asset amount (i.e. 6 decimal precision => 18 decimal precision).\n    /// @param  amount The amount of a given \"asset\".\n    /// @param  asset The asset (ERC-20) from which to standardize the amount to WEI.\n    /// @return standardizedAmount The above amount standardized to 18 decimals.\n    function standardize(uint256 amount, address asset) external view returns (uint256 standardizedAmount);\n\n    /// @notice This function will verify if a given stablecoin has been whitelisted for use throughout system.\n    /// @param  stablecoin address of the stablecoin to verify acceptance for.\n    function stablecoinWhitelist(address stablecoin) external view returns (bool);\n}\n\ninterface IZivoeRewards_YDL {\n    /// @notice Deposits a reward to this contract for distribution.\n    /// @param  _rewardsToken The asset that's being distributed.\n    /// @param  reward The amount of the _rewardsToken to deposit.\n    function depositReward(address _rewardsToken, uint256 reward) external;\n}\n\n\n\n/// @notice  This contract manages the accounting for distributing yield across multiple contracts.\n///          This contract has the following responsibilities:\n///            - Escrows yield in between distribution periods.\n///            - Manages accounting for yield distribution.\n///            - Supports modification of certain state variables for governance purposes.\n///            - Tracks historical values using EMA (exponential moving average) on 30-day basis.\ncontract ZivoeYDL is Context, ReentrancyGuard {\n\n    using SafeERC20 for IERC20;\n    using FloorMath for uint256;\n\n    // ---------------------\n    //    State Variables\n    // ---------------------\n\n    struct Recipients {\n        address[] recipients;\n        uint256[] proportion;\n    }\n\n    Recipients protocolRecipients;          /// @dev Tracks the distributions for protocol earnings.\n    Recipients residualRecipients;          /// @dev Tracks the distributions for residual earnings.\n\n    address public immutable GBL;           /// @dev The ZivoeGlobals contract.\n\n    address public distributedAsset;        /// @dev The \"stablecoin\" that will be distributed via YDL.\n\n    // Weighted moving averages.\n    uint256 public emaSTT;          /// @dev Weighted moving average for senior tranche size, a.k.a. zSTT.totalSupply().\n    uint256 public emaJTT;          /// @dev Weighted moving average for junior tranche size, a.k.a. zJTT.totalSupply().\n\n    // Indexing.\n    uint256 public distributionCounter;     /// @dev Number of calls to distributeYield().\n    uint256 public lastDistribution;        /// @dev Used for timelock constraint to call distributeYield().\n\n    // Accounting vars (governable).\n    uint256 public targetAPYBIPS = 1000;                /// @dev The target annualized yield for senior tranche.\n    uint256 public targetRatioBIPS = 22000;             /// @dev The target ratio of junior to senior tranche.\n    uint256 public protocolEarningsRateBIPS = 2000;     /// @dev The protocol earnings rate.\n\n    // Accounting vars (constant).\n    uint256 public constant daysBetweenDistributions = 30;   /// @dev Number of days between yield distributions.\n    uint256 public constant retrospectiveDistributions = 6;  /// @dev Retrospective moving average period.\n    \n    bool public unlocked;                   /// @dev Prevents contract from supporting functionality until unlocked.\n\n    uint256 private constant BIPS = 10000;\n    uint256 private constant RAY = 10 ** 27;\n\n    ZivoeMath public MATH;\n\n\n\n    // -----------------\n    //    Constructor\n    // -----------------\n\n    /// @notice Initialize the ZivoeYDL contract.\n    /// @param  _GBL The ZivoeGlobals contract.\n    /// @param  _distributedAsset The \"stablecoin\" that will be distributed via YDL.\n    constructor(address _GBL, address _distributedAsset) {\n        GBL = _GBL;\n        distributedAsset = _distributedAsset;\n        MATH = new ZivoeMath();\n    }\n\n\n\n    // ------------\n    //    Events\n    // ------------\n\n    /// @notice Emitted during returnAsset().\n    /// @param  asset The asset returned.\n    /// @param  amount The amount of \"asset\" returned to DAO.\n    event AssetReturned(address indexed asset, uint256 amount);\n\n    /// @notice Emitted during updateDistributedAsset().\n    /// @param  oldAsset The old value of distributedAsset.\n    /// @param  newAsset The new value of distributedAsset.\n    event UpdatedDistributedAsset(address indexed oldAsset, address indexed newAsset);\n\n    /// @notice Emitted during updateProtocolEarningsRateBIPS().\n    /// @param  oldValue The old value of protocolEarningsRateBIPS.\n    /// @param  newValue The new value of protocolEarningsRateBIPS.\n    event UpdatedProtocolEarningsRateBIPS(uint256 oldValue, uint256 newValue);\n\n    /// @notice Emitted during updateRecipients().\n    /// @param  recipients The new recipients to receive protocol earnings.\n    /// @param  proportion The proportion distributed across recipients.\n    event UpdatedProtocolRecipients(address[] recipients, uint256[] proportion);\n\n    /// @notice Emitted during updateRecipients().\n    /// @param  recipients The new recipients to receive residual earnings.\n    /// @param  proportion The proportion distributed across recipients.\n    event UpdatedResidualRecipients(address[] recipients, uint256[] proportion);\n\n    /// @notice Emitted during updateTargetAPYBIPS().\n    /// @param  oldValue The old value of targetAPYBIPS.\n    /// @param  newValue The new value of targetAPYBIPS.\n    event UpdatedTargetAPYBIPS(uint256 oldValue, uint256 newValue);\n\n    /// @notice Emitted during updateTargetRatioBIPS().\n    /// @param  oldValue The old value of targetRatioBIPS.\n    /// @param  newValue The new value of targetRatioBIPS.\n    event UpdatedTargetRatioBIPS(uint256 oldValue, uint256 newValue);\n\n    /// @notice Emitted during distributeYield().\n    /// @param  protocol The amount of earnings distributed to protocol earnings recipients.\n    /// @param  senior The amount of earnings distributed to the senior tranche.\n    /// @param  junior The amount of earnings distributed to the junior tranche.\n    /// @param  residual The amount of earnings distributed to residual earnings recipients.\n    event YieldDistributed(uint256[] protocol, uint256 senior, uint256 junior, uint256[] residual);\n\n    /// @notice Emitted during distributeYield().\n    /// @param  asset The \"asset\" being distributed.\n    /// @param  recipient The recipient of the distribution.\n    /// @param  amount The amount distributed.\n    event YieldDistributedSingle(address indexed asset, address indexed recipient, uint25"
    }
  ]
}