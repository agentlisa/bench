{
  "Title": "[M-07] [Buyout module] Fraction price is not updated when total supply changes",
  "Content": "_Submitted by 0xA5DF_\n\nLines: <https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L118-L138>\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L156-L165>\n\n### Vulnerability details\n\nIn the buyout module when a buyout starts - the module stores the `fractionPrice`, and when a user wants to buy/sell fractions the `fractionPrice` is loaded from storage and based on that the module determines the price of the fractions.\nThe issue here is that the total supply might change between the time the buyout start till the buy/sell time, and the `fractionPrice` stored in the module might not represent the real price anymore.\n\nCurrently there are no module that mint/burn supply at the time of buyout, but considering that Fractional is an extendible platform - Fractional might add one or a user might create his own module and create a vault with it.\nAn example of an innocent module that can change the total supply - a split module, this hypothetical module may allow splitting a coin (multiplying the balance of all users by some factor, based on a vote by the holders, the same way [QuickSwap did](https://twitter.com/quickswapdex/status/1506672432907620353) at March)).\nIf that module is used in the middle of the buyout, that fraction price would still be based on the old supply.\n\n### Impact\n\n*   Buyout proposer can end up paying the entire buyout price, but ending up with only part of the vault.\n*   Users may end up buying fractions for more than they're really worth (if they're unaware of the change in total supply).\n*   Users may end up getting a lower price than intended while selling their fractions (in case of a burn).\n\n### Proof of Concept\n\nConsider the following scenario\n\n*   Alice creates a vault with a 'split' module\n*   Bob starts a buyout for the price of 1 ETH\n*   Alice runs the split modules twice (making the total supply 4 times the original supply) and then sells 25% of her fractions.\n*   Bob lost his 1 ETH and got in exchange only 25% of the fractions.\n\nHere's a test (added to the `test/Buyout.t.sol` file) demonstrating this scenario (test passes = the bug exists).\n\n```solidity\n    function testSplit_bug() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, 0, true);\n\n        // Bob proposes a buyout for 1 ether for the entire vault\n        uint buyoutPrice = 1 ether;\n        bob.buyoutModule.start{value: buyoutPrice}(vault);\n\n        // simulate a x4 split\n        // Alice is the only holder so we need to multiply only her balance x4\n        bytes memory data = abi.encodeCall(\n            Supply.mint,\n            (alice.addr, TOTAL_SUPPLY * 3)\n        );\n        address supply = baseVault.supply();\n        Vault(payable(vault)).execute(supply, data, new bytes32[](0));\n\n        // Alice now sells only 1/4 of the total supply \n        // (TOTAL_SUPPLY is now 1/4 of the actual total supply)\n        alice.buyoutModule.sellFractions(vault, TOTAL_SUPPLY);\n\n        // Alice got 1 ETH and still holds 3/4 of the vault's fractions\n        assertEq(getETHBalance(alice.addr), buyoutPrice + INITIAL_BALANCE);\n        assertEq(getFractionBalance(alice.addr), TOTAL_SUPPLY * 3);\n\n    }\n```\n\nTrying to create a proof for minting was too much time-consuming, so I just disabled the proof check in `Vault.execute` in order to simulate the split:\n\n```solidity\n        // if (!MerkleProof.verify(_proof, merkleRoot, leaf)) {\n        //     if (msg.sender != owner)\n        //         revert NotAuthorized(msg.sender, _target, selector);\n        // }\n\n```\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nCalculate fraction price at the time of buy/sell according to the current total supply:\n(Disclosure: this is based on a solution I made for a different bug).\n\n*   This can still cause an issue if a user is unaware of the new fraction price, and will be selling his fractions for less than expected. Therefore, you'd might want to revert if the total supply has changed, while adding functionality to update the lastTotalSupply - this way there's an event notifying about the fraction-price change before the user buys/sells.\n\n```diff\ndiff --git a/src/interfaces/IBuyout.sol b/src/interfaces/IBuyout.sol\nindex 0e1c9eb..79beb71 100644\n--- a/src/interfaces/IBuyout.sol\n+++ b/src/interfaces/IBuyout.sol\n@@ -20,7 +20,7 @@ struct Auction {\n     // Enum state of the buyout auction\n     State state;\n     // Price of fractional tokens\n-    uint256 fractionPrice;\n+    uint256 buyoutPrice;\n     // Balance of ether in buyout pool\n     uint256 ethBalance;\n     // Total supply recorded before a buyout started\ndiff --git a/src/modules/Buyout.sol b/src/modules/Buyout.sol\nindex 1557233..d9a6935 100644\n--- a/src/modules/Buyout.sol\n+++ b/src/modules/Buyout.sol\n@@ -63,10 +63,13 @@ contract Buyout is IBuyout, Multicall, NFTReceiver, SafeSend, SelfPermit {\n         );\n         if (id == 0) revert NotVault(_vault);\n         // Reverts if auction state is not inactive\n-        (, , State current, , , ) = this.buyoutInfo(_vault);\n+        (, , State current, , ,uint256 lastTotalSupply) = this.buyoutInfo(_vault);\n         State required = State.INACTIVE;\n         if (current != required) revert InvalidState(required, current);\n \n+        if(totalSupply != lastTotalSupply){\n+            // emit event / revert / whatever \n+        }\n         // Gets total supply of fractional tokens for the vault\n         uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);\n         // Gets total balance of fractional tokens owned by caller\n@@ -85,14 +88,14 @@ contract Buyout is IBuyout, Multicall, NFTReceiver, SafeSend, SelfPermit {\n         // @dev Reverts with division error if called with total supply of tokens\n         uint256 buyoutPrice = (msg.value * 100) /\n             (100 - ((depositAmount * 100) / totalSupply));\n-        uint256 fractionPrice = buyoutPrice / totalSupply;\n+        uint256 fractionEstimatedPrice = buyoutPrice / totalSupply;\n \n         // Sets info mapping of the vault address to auction struct\n         buyoutInfo[_vault] = Auction(\n             block.timestamp,\n             msg.sender,\n             State.LIVE,\n-            fractionPrice,\n+            buyoutPrice,\n             msg.value,\n             totalSupply\n         );\n@@ -102,7 +105,7 @@ contract Buyout is IBuyout, Multicall, NFTReceiver, SafeSend, SelfPermit {\n             msg.sender,\n             block.timestamp,\n             buyoutPrice,\n-            fractionPrice\n+            fractionEstimatedPrice\n         );\n     }\n \n@@ -115,8 +118,9 @@ contract Buyout is IBuyout, Multicall, NFTReceiver, SafeSend, SelfPermit {\n             _vault\n         );\n         if (id == 0) revert NotVault(_vault);\n-        (uint256 startTime, , State current, uint256 fractionPrice, , ) = this\n+        (uint256 startTime, , State current, uint256 buyoutPrice, ,  ) = this\n             .buyoutInfo(_vault);\n+        uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);\n         // Reverts if auction state is not live\n         State required = State.LIVE;\n         if (current != required) revert InvalidState(required, current);\n@@ -135,7 +139,7 @@ contract Buyout is IBuyout, Multicall, NFTReceiver, SafeSend, SelfPermit {\n         );\n \n         // Updates ether balance of pool\n-        uint256 ethAmount = fractionPrice * _amount;\n+        uint256 ethAmount = buyoutPrice * _amount / totalSupply;\n         buyoutInfo[_vault].ethBalance -= ethAmount;\n         // Transfers ether amount to caller\n         _sendEthOrWeth(msg.sender, ethAmount);\n@@ -153,16 +157,27 @@ contract Buyout is IBuyout, Multicall, NFTReceiver, SafeSend, SelfPermit {\n         );\n         if (id == 0) revert NotVault(_vault);\n         // Reverts if auction state is not live\n-        (uint256 startTime, , State current, uint256 fractionPrice, , ) = this\n+        (uint256 startTime, , State current, uint256 buyoutPrice, , uint256 lastTotalSupply ) = this\n             .buyoutInfo(_vault);\n+        uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);\n+        \n+        if(totalSupply != lastTotalSupply){\n+            // emit event / revert / whatever \n+        }\n+\n         State required = State.LIVE;\n         if (current != required) revert InvalidState(required, current);\n         // Reverts if current time is greater than end time of rejection period\n         uint256 endTime = startTime + REJECTION_PERIOD;\n         if (block.timestamp > endTime)\n             revert TimeExpired(block.timestamp, endTime);\n+\n+        uint256 price = (buyoutPrice * _amount) / totalSupply;\n+        if (price * totalSupply < buyoutPrice * _amount){\n+            price++;\n+        }\n         // Reverts if payment amount does not equal price of fractional amount\n-        if (msg.value != fractionPrice * _amount) revert InvalidPayment();\n+        if (msg.value != price) revert InvalidPayment();\n \n\n@@ -272,6 +287,18 @@ contract Buyout is IBuyout, Multicall, NFTReceiver, SafeSend, SelfPermit {\n         emit Cash(_vault, msg.sender, buyoutShare);\n     }\n \n+    function updateSupply(address _vault) external{\n+        (, , , uint256 buyoutPrice, , uint256 lastTotalSupply ) = this.buyoutInfo(_vault);\n+\n+        uint256 newTotalSupply = IVaultRegistry(registry).totalSupply(_vault);\n+        uint256 newEstimatedFractionPrice = buyoutPrice / newTotalSupply;\n+        if(newTotalSupply == lastTotalSupply){\n+            revert SupplyHasntChanged();\n+        }\n+        this.buyoutInfo(_vault).lastTotalSupply = newTotalSupply; \n+        emit TotalSupplyChanged(lastTotalSupply, newTotalSupply, newEstimatedFractionPrice);\n+    }\n```\n\n**[HardlyDifficult (judge) decreased severity to QA and commented](https://github.com/code-423n4/2022-07-fractional-findings/issues/337#issuecomment-1206402088):**\n > This is a valid suggestion to consider, improving robustness for future modules. Lowering risk and merging with the warden's QA report #524.\n\n**[0xA5DF (warden) commented](https://github.com/code-423n4/2022-07-fractional-findings/issues/337#issuecomment-1211824288):**\n > Reading [Fractional's docs](https://docs.fractional.art/fractional-v2-1/security#:~:text=users%20should%20only%20interact%20with%20Vaults%20that%20have%20been%20deployed%20using%20modules%20that%20they%20trust), it seems that they intend the vaults to use not only their modules, but also from other sources as long as they're trusted:\n> > Additionally, users should only interact with Vaults that have been deployed using modules that they trust, since a malicious actor could deploy a Vault with malicious modules.\n> \n> An innocent user or an attacker can be creating a split module, even getting it reviewed or audited and then creating a vault with it.\n> Users would trust the vault, and when the bug is exploited it'd be the `Bouyout` module responsibility since it's the one that contains the bug (if your platform is intended to be extendable, then you should take into account any _normal behavior_ that those extensions might have).\n\n**[HardlyDifficult (judge) increased severity to Medium and commented](https://github.com/code-423n4/2022-07-fractional-findings/issues/337#issuecomment-1212187825):**\n > Fair point. I'll reset this to Medium. Thanks\n\n**[stevennevins (Fractional) commented](https://github.com/code-423n4/2022-07-fractional-findings/issues/337#issuecomment-1227524747):**\n > Just to add, we're not certifying that the Buyout is safe in every context that it could be used in. In that statement we were trying to indicate that you can add modules outside of our curated set, but you would need to be aware of the trust assumptions with regards to both the individual module as well as their composition with others ie rapid inflationary mechanisms and a buyout.  I recognize that we could have better handled the case of fraction supply changes during a buyout but inflation was outside of our initial scope for our curated launch.  Thank you for reviewing our protocol and providing feedback it's greatly appreciated ðŸ™\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-07-fractional-v2-contest",
  "Code": [
    {
      "filename": "src/modules/Buyout.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IBuyout, Auction, State} from \"../interfaces/IBuyout.sol\";\nimport {IERC1155} from \"../interfaces/IERC1155.sol\";\nimport {ISupply} from \"../interfaces/ISupply.sol\";\nimport {ITransfer} from \"../interfaces/ITransfer.sol\";\nimport {IVault} from \"../interfaces/IVault.sol\";\nimport {IVaultRegistry, Permission} from \"../interfaces/IVaultRegistry.sol\";\nimport {Multicall} from \"../utils/Multicall.sol\";\nimport {NFTReceiver} from \"../utils/NFTReceiver.sol\";\nimport {SafeSend} from \"../utils/SafeSend.sol\";\nimport {SelfPermit} from \"../utils/SelfPermit.sol\";\n\n/// @title Buyout\n/// @author Fractional Art\n/// @notice Module contract for vaults to hold buyout pools\n/// - A fractional owner starts an auction for a vault by depositing any amount of ether and fractional tokens into a pool.\n/// - During the proposal period (2 days) users can sell their fractional tokens into the pool for ether.\n/// - During the rejection period (4 days) users can buy fractional tokens from the pool with ether.\n/// - If a pool has more than 51% of the total supply after 4 days, the buyout is successful and the proposer\n///   gains access to withdraw the underlying assets (ERC20, ERC721, and ERC1155 tokens) from the vault.\n///   Otherwise the buyout is considered unsuccessful and a new one may then begin.\n/// - NOTE: A vault may only have one active buyout at any given time.\n/// - buyoutPrice = (ethDeposit * 100) / (100 - ((fractionDeposit * 100) / totalSupply))\n/// - buyoutShare = (tokenBalance * ethBalance) / (totalSupply + tokenBalance)\ncontract Buyout is IBuyout, Multicall, NFTReceiver, SafeSend, SelfPermit {\n    /// @notice Address of VaultRegistry contract\n    address public registry;\n    /// @notice Address of Supply target contract\n    address public supply;\n    /// @notice Address of Transfer target contract\n    address public transfer;\n    /// @notice Time length of the proposal period\n    uint256 public constant PROPOSAL_PERIOD = 2 days;\n    /// @notice Time length of the rejection period\n    uint256 public constant REJECTION_PERIOD = 4 days;\n    /// @notice Mapping of vault address to auction struct\n    mapping(address => Auction) public buyoutInfo;\n\n    /// @notice Initializes registry, supply, and transfer contracts\n    constructor(\n        address _registry,\n        address _supply,\n        address _transfer\n    ) {\n        registry = _registry;\n        supply = _supply;\n        transfer = _transfer;\n    }\n\n    /// @dev Callback for receiving ether when the calldata is empty\n    receive() external payable {}\n\n    /// @notice Starts the auction for a buyout pool\n    /// @param _vault Address of the vault\n    function start(address _vault) external payable {\n        // Reverts if ether deposit amount is zero\n        if (msg.value == 0) revert ZeroDeposit();\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not inactive\n        (, , State current, , , ) = this.buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert InvalidState(required, current);\n\n        // Gets total supply of fractional tokens for the vault\n        uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);\n        // Gets total balance of fractional tokens owned by caller\n        uint256 depositAmount = IERC1155(token).balanceOf(msg.sender, id);\n\n        // Transfers fractional tokens into the buyout pool\n        IERC1155(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            id,\n            depositAmount,\n            \"\"\n        );\n\n        // Calculates price of buyout and fractions\n        // @dev Reverts with division error if called with total supply of tokens\n        uint256 buyoutPrice = (msg.value * 100) /\n            (100 - ((depositAmount * 100) / totalSupply));\n        uint256 fractionPrice = buyoutPrice / totalSupply;\n\n        // Sets info mapping of the vault address to auction struct\n        buyoutInfo[_vault] = Auction(\n            block.timestamp,\n            msg.sender,\n            State.LIVE,\n            fractionPrice,\n            msg.value,\n            totalSupply\n        );\n        // Emits event for starting auction\n        emit Start(\n            _vault,\n            msg.sender,\n            block.timestamp,\n            buyoutPrice,\n            fractionPrice\n        );\n    }\n\n    /// @notice Sells fractional tokens in exchange for ether from a pool\n    /// @param _vault Address of the vault\n    /// @param _amount Transfer amount of fractions\n    function sellFractions(address _vault, uint256 _amount) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        (uint256 startTime, , State current, uint256 fractionPrice, , ) = this\n            .buyoutInfo(_vault);\n        // Reverts if auction state is not live\n        State required = State.LIVE;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if current time is greater than end time of proposal period\n        uint256 endTime = startTime + PROPOSAL_PERIOD;\n        if (block.timestamp > endTime)\n            revert TimeExpired(block.timestamp, endTime);\n\n        // Transfers fractional tokens to pool from caller\n        IERC1155(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            id,\n            _amount,\n            \"\"\n        );\n\n        // Updates ether balance of pool\n        uint256 ethAmount = fractionPrice * _amount;\n        buyoutInfo[_vault].ethBalance -= ethAmount;\n        // Transfers ether amount to caller\n        _sendEthOrWeth(msg.sender, ethAmount);\n        // Emits event for selling fractions into pool\n        emit SellFractions(msg.sender, _amount);\n    }\n\n    /// @notice Buys fractional tokens in exchange for ether from a pool\n    /// @param _vault Address of the vault\n    /// @param _amount Transfer amount of fractions\n    function buyFractions(address _vault, uint256 _amount) external payable {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not live\n        (uint256 startTime, , State current, uint256 fractionPrice, , ) = this\n            .buyoutInfo(_vault);\n        State required = State.LIVE;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if current time is greater than end time of rejection period\n        uint256 endTime = startTime + REJECTION_PERIOD;\n        if (block.timestamp > endTime)\n            revert TimeExpired(block.timestamp, endTime);\n        // Reverts if payment amount does not equal price of fractional amount\n        if (msg.value != fractionPrice * _amount) revert InvalidPayment();\n\n        // Transfers fractional tokens to caller\n        IERC1155(token).safeTransferFrom(\n            address(this),\n            msg.sender,\n            id,\n            _amount,\n            \"\"\n        );\n        // Updates ether balance of pool\n        buyoutInfo[_vault].ethBalance += msg.value;\n        // Emits event for buying fractions from pool\n        emit BuyFractions(msg.sender, _amount);\n    }\n\n    /// @notice Ends the auction for a live buyout pool\n    /// @param _vault Address of the vault\n    /// @param _burnProof Merkle proof for burning fractional tokens\n    function end(address _vault, bytes32[] calldata _burnProof) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not live\n        (\n            uint256 startTime,\n            address proposer,\n            State current,\n            ,\n            uint256 ethBalance,\n\n        ) = this.buyoutInfo(_vault);\n        State required = State.LIVE;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if current time is less than or equal to end time of auction\n        uint256 endTime = startTime + REJECTION_PERIOD;\n        if (block.timestamp <= endTime)\n            revert TimeNotElapsed(block.timestamp, endTime);\n\n        uint256 tokenBalance = IERC1155(token).balanceOf(address(this), id);\n        // Checks totalSupply of auction pool to determine if buyout is successful or not\n        if (\n            (tokenBalance * 1000) /\n                IVaultRegistry(registry).totalSupply(_vault) >\n            500\n        ) {\n            // Initializes vault transaction\n            bytes memory data = abi.encodeCall(\n                ISupply.burn,\n                (address(this), tokenBalance)\n            );\n            // Executes burn of fractional tokens from pool\n            IVault(payable(_vault)).execute(supply, data, _burnProof);\n            // Sets buyout state to successful\n            buyoutInfo[_vault].state = State.SUCCESS;\n            // Emits event for ending successful auction\n            emit End(_vault, State.SUCCESS, proposer);\n        } else {\n            // Deletes auction info\n            delete buyoutInfo[_vault];\n            // Transfers fractions and ether back to proposer of the buyout pool\n            IERC1155(token).safeTransferFrom(\n                address(this),\n                proposer,\n                id,\n                tokenBalance,\n                \"\"\n            );\n            _sendEthOrWeth(proposer, ethBalance);\n            // Emits event for ending unsuccessful auction\n            emit End(_vault, State.INACTIVE, proposer);\n        }\n    }\n\n    /// @notice Cashes out proceeds from a successful buyout\n    /// @param _vault Address of the vault\n    /// @param _burnProof Merkle proof for burning fractional tokens\n    function cash(address _vault, bytes32[] calldata _burnProof) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not successful\n        (, , State current, , uint256 ethBalance, ) = this.buyoutInfo(_vault);\n        State required = State.SUCCESS;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if caller has a balance of zero fractional tokens\n        uint256 tokenBalance = IERC1155(token).balanceOf(msg.sender, id);\n        if (tokenBalance == 0) revert NoFractions();\n\n        // Initializes vault transaction\n        bytes memory data = abi.encodeCall(\n            ISupply.burn,\n            (msg.sender, tokenBalance)\n        );\n        // Executes burn of fractional tokens from caller\n        IVault(payable(_vault)).execute(supply, data, _burnProof);\n\n        // Transfers buyout share amount to caller based on total supply\n        uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);\n        uint256 buyoutShare = (tokenBalance * ethBalance) /\n            (totalSupply + tokenBalance);\n        _sendEthOrWeth(msg.sender, buyoutShare);\n        // Emits event for cashing out of buyout pool\n        emit Cash(_vault, msg.sender, buyoutShare);\n    }\n\n    /// @notice Terminates a vault with an inactive buyout\n    /// @param _vault Address of the vault\n    /// @param _burnProof Merkle proof for burning fractional tokens\n    function redeem(address _vault, bytes32[] calldata _burnProof) external {\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not inactive\n        (, , State current, , , ) = this.buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert InvalidState(required, current);\n\n        // Initializes vault transaction\n        uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);\n        bytes memory data = abi.encodeCall(\n            ISupply.burn,\n            (msg.sender, totalSupply)\n        );\n        // Executes burn of fractional tokens from caller\n        IVault(payable(_vault)).execute(supply, data, _burnProof);\n\n        // Sets buyout state to successful and proposer to caller\n        (buyoutInfo[_vault].state, buyoutInfo[_vault].proposer) = (\n            State.SUCCESS,\n            msg.sender\n        );\n        // Emits event for redeem underlying assets from the vault\n        emit Redeem(_vault, msg.sender);\n    }\n\n    /// @notice Withdraws an ERC-20 token from a vault\n    /// @param _vault Address of the vault\n    /// @param _token Address of the token\n    /// @param _to Address of the receiver\n    /// @param _value Transfer amount\n    /// @param _erc20TransferProof Merkle proof for transferring an ERC-20 token\n    function withdrawERC20(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _value,\n        bytes32[] calldata _erc20TransferProof\n    ) external {\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not successful\n        (, address proposer, State current, , , ) = this.buyoutInfo(_vault);\n        State required = State.SUCCESS;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if caller is not the auction winner\n        if (msg.sender != proposer) revert NotWinner();\n\n        // Initializes vault transaction\n        bytes memory data = abi.encodeCall(\n            ITransfer.ERC20Transfer,\n            (_token, _to, _value)\n        );\n        // Executes transfer of ERC721 token to caller\n        IVault(payable(_vault)).execute(transfer, data, _erc20TransferProof);\n    }\n\n    /// @notice Withdraws an ERC-721 token from a vault\n    /// @param _vault Address of the vault\n    /// @param _token Address of the token\n    /// @param _to Address of the receiver\n    /// @param _tokenId ID of the token\n    /// @param _erc721TransferProof Merkle proof for transferring an ERC-721 token\n    function withdrawERC721(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _tokenId,\n        bytes32[] calldata _erc721TransferProof\n    ) external {\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not successful\n        (, address proposer, State current, , , ) = this.buyoutInfo(_vault);\n        State required = State.SUCCESS;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if caller is not the auction winner\n        if (msg.sender != proposer) revert NotWinner();\n\n        // Initializes vault transaction\n        bytes memory data = abi.encodeCall(\n            ITransfer.ERC721TransferFrom,\n            (_token, _vault, _to, _tokenId)\n        );\n        // Executes transfer of ERC721 token to caller\n        IVault(payable(_vault)).execute(transfer, data, _erc721TransferProof);\n    }\n\n    /// @notice Withdraws an ERC-1155 token from a vault\n    /// @param _vault Address of the vault\n    /// @param _token Address of the token\n    /// @param _to Address of the receiver\n    /// @param _id ID of the token type\n    /// @param _value Transfer amount\n    /// @param _erc1155TransferProof Merkle proof for transferring an ERC-1155 token\n    function withdrawERC1155(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _id,\n        uint256 _value,\n        bytes32[] calldata _erc1155TransferProof\n    ) external {\n        // Creates local scope to avoid stack too deep\n        {\n            // Reverts if address is not a registered vault\n            (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n            if (id == 0) revert NotVault(_vault);\n            // Reverts if auction state is not successful\n            (, address proposer, State current, , , ) = this.buyoutInfo(_vault);\n            State required = State.SUCCESS;\n            if (current != required) revert InvalidState(required, current);\n            // Reverts if caller is not the auction winner\n            if (msg.sender != proposer) revert NotWinner();\n        }\n\n        // Initializes vault transaction\n        bytes memory data = abi.encodeCall(\n            ITransfer.ERC1155TransferFrom,\n            (_token, _vault, _to, _id, _value)\n        );\n        // Executes transfer of ERC1155 token to caller\n        IVault(payable(_vault)).execute(transfer, data, _erc1155TransferProof);\n    }\n\n    /// @notice Batch withdraws ERC-1155 tokens from a vault\n    /// @param _vault Address of the vault\n    /// @param _token Address of the token\n    /// @param _to Address of the receiver\n    /// @param _ids IDs of each token type\n    /// @param _values Transfer amounts per token type\n    /// @param _erc1155BatchTransferProof Merkle proof for transferring multiple ERC-1155 tokens\n    function batchWithdrawERC1155(\n        address _vault,\n        address _token,\n        address _to,\n        uint256[] calldata _ids,\n        uint256[] calldata _values,\n        bytes32[] calldata _erc1155BatchTransferProof\n    ) external {\n        // Creates local scope to avoid stack too deep\n        {\n            // Reverts if address is not a registered vault\n            (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n            if (id == 0) revert NotVault(_vault);\n            // Reverts if auction state is not successful\n            (, address proposer, State current, , , ) = this.buyoutInfo(_vault);\n            State required = State.SUCCESS;\n            if (current != required) revert InvalidState(required, current);\n            // Reverts if caller is not the auction winner\n            if (msg.sender != proposer) revert NotWinner();\n        }\n\n        // Initializes vault transaction\n        bytes memory data = abi.encodeCall(\n            ITransfer.ERC1155BatchTransferFrom,\n            (_token, _vault, _to, _ids, _values)\n        );\n        // Executes batch transfer of multiple ERC1155 tokens to caller\n        IVault(payable(_vault)).execute(\n            transfer,\n            data,\n            _erc1155BatchTransferProof\n        );\n    }\n\n    /// @notice Gets the list of leaf nodes used to generate a merkle tree\n    /// @dev Leaf nodes are hashed permissions of the merkle tree\n    /// @return nodes Hashes of leaf nodes\n    function getLeafNodes() external view returns (bytes32[] memory nodes) {\n        nodes = new bytes32[](5);\n        // Gets list of permissions from this module\n        Permission[] memory permissions = getPermissions();\n        for (uint256 i; i < permissions.length; ) {\n            // Hashes permission into leaf node\n            nodes[i] = keccak256(abi.encode(permissions[i]));\n            // Can't overflow since loop is a fixed size\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Gets the list of permissions installed on a vault\n    /// @dev Permissions consist of a module contract, target contract, and function selector\n    /// @return permissions List of vault permissions\n    function getPermissions()\n        public\n        view\n        returns (Permission[] memory permissions)\n    {\n        permissions = new Permission[](5);\n        // Burn function selector from supply contract\n        permissions[0] = Permission(\n            address(this),\n            supply,\n            ISupply(supply).burn.selector\n        );\n        // ERC20Transfer function selector from transfer contract\n        permissions[1] = Permission(\n            address(this),\n            transfer,\n            ITransfer(transfer).ERC20Transfer.selector\n        );\n        // ERC721TransferFrom function selector from transfer contract\n        permissions[2] = Permission(\n            address(this),\n            transfer,\n            ITransfer(transfer).ERC721TransferFrom.selector\n        );\n        // ERC1155TransferFrom function selector from transfer contract\n        permissions[3] = Permission(\n            address(this),\n            transfer,\n            ITransfer(transfer).ERC1155TransferFrom.selector\n        );\n        // ERC1155BatchTransferFrom function selector from transfer contract\n        permissions[4] = Permission(\n            address(this),\n            transfer,\n            ITransfer(transfer).ERC1155BatchTransferFrom.selector\n        );\n    }\n}"
    },
    {
      "filename": "src/modules/Buyout.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IBuyout, Auction, State} from \"../interfaces/IBuyout.sol\";\nimport {IERC1155} from \"../interfaces/IERC1155.sol\";\nimport {ISupply} from \"../interfaces/ISupply.sol\";\nimport {ITransfer} from \"../interfaces/ITransfer.sol\";\nimport {IVault} from \"../interfaces/IVault.sol\";\nimport {IVaultRegistry, Permission} from \"../interfaces/IVaultRegistry.sol\";\nimport {Multicall} from \"../utils/Multicall.sol\";\nimport {NFTReceiver} from \"../utils/NFTReceiver.sol\";\nimport {SafeSend} from \"../utils/SafeSend.sol\";\nimport {SelfPermit} from \"../utils/SelfPermit.sol\";\n\n/// @title Buyout\n/// @author Fractional Art\n/// @notice Module contract for vaults to hold buyout pools\n/// - A fractional owner starts an auction for a vault by depositing any amount of ether and fractional tokens into a pool.\n/// - During the proposal period (2 days) users can sell their fractional tokens into the pool for ether.\n/// - During the rejection period (4 days) users can buy fractional tokens from the pool with ether.\n/// - If a pool has more than 51% of the total supply after 4 days, the buyout is successful and the proposer\n///   gains access to withdraw the underlying assets (ERC20, ERC721, and ERC1155 tokens) from the vault.\n///   Otherwise the buyout is considered unsuccessful and a new one may then begin.\n/// - NOTE: A vault may only have one active buyout at any given time.\n/// - buyoutPrice = (ethDeposit * 100) / (100 - ((fractionDeposit * 100) / totalSupply))\n/// - buyoutShare = (tokenBalance * ethBalance) / (totalSupply + tokenBalance)\ncontract Buyout is IBuyout, Multicall, NFTReceiver, SafeSend, SelfPermit {\n    /// @notice Address of VaultRegistry contract\n    address public registry;\n    /// @notice Address of Supply target contract\n    address public supply;\n    /// @notice Address of Transfer target contract\n    address public transfer;\n    /// @notice Time length of the proposal period\n    uint256 public constant PROPOSAL_PERIOD = 2 days;\n    /// @notice Time length of the rejection period\n    uint256 public constant REJECTION_PERIOD = 4 days;\n    /// @notice Mapping of vault address to auction struct\n    mapping(address => Auction) public buyoutInfo;\n\n    /// @notice Initializes registry, supply, and transfer contracts\n    constructor(\n        address _registry,\n        address _supply,\n        address _transfer\n    ) {\n        registry = _registry;\n        supply = _supply;\n        transfer = _transfer;\n    }\n\n    /// @dev Callback for receiving ether when the calldata is empty\n    receive() external payable {}\n\n    /// @notice Starts the auction for a buyout pool\n    /// @param _vault Address of the vault\n    function start(address _vault) external payable {\n        // Reverts if ether deposit amount is zero\n        if (msg.value == 0) revert ZeroDeposit();\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not inactive\n        (, , State current, , , ) = this.buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert InvalidState(required, current);\n\n        // Gets total supply of fractional tokens for the vault\n        uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);\n        // Gets total balance of fractional tokens owned by caller\n        uint256 depositAmount = IERC1155(token).balanceOf(msg.sender, id);\n\n        // Transfers fractional tokens into the buyout pool\n        IERC1155(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            id,\n            depositAmount,\n            \"\"\n        );\n\n        // Calculates price of buyout and fractions\n        // @dev Reverts with division error if called with total supply of tokens\n        uint256 buyoutPrice = (msg.value * 100) /\n            (100 - ((depositAmount * 100) / totalSupply));\n        uint256 fractionPrice = buyoutPrice / totalSupply;\n\n        // Sets info mapping of the vault address to auction struct\n        buyoutInfo[_vault] = Auction(\n            block.timestamp,\n            msg.sender,\n            State.LIVE,\n            fractionPrice,\n            msg.value,\n            totalSupply\n        );\n        // Emits event for starting auction\n        emit Start(\n            _vault,\n            msg.sender,\n            block.timestamp,\n            buyoutPrice,\n            fractionPrice\n        );\n    }\n\n    /// @notice Sells fractional tokens in exchange for ether from a pool\n    /// @param _vault Address of the vault\n    /// @param _amount Transfer amount of fractions\n    function sellFractions(address _vault, uint256 _amount) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        (uint256 startTime, , State current, uint256 fractionPrice, , ) = this\n            .buyoutInfo(_vault);\n        // Reverts if auction state is not live\n        State required = State.LIVE;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if current time is greater than end time of proposal period\n        uint256 endTime = startTime + PROPOSAL_PERIOD;\n        if (block.timestamp > endTime)\n            revert TimeExpired(block.timestamp, endTime);\n\n        // Transfers fractional tokens to pool from caller\n        IERC1155(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            id,\n            _amount,\n            \"\"\n        );\n\n        // Updates ether balance of pool\n        uint256 ethAmount = fractionPrice * _amount;\n        buyoutInfo[_vault].ethBalance -= ethAmount;\n        // Transfers ether amount to caller\n        _sendEthOrWeth(msg.sender, ethAmount);\n        // Emits event for selling fractions into pool\n        emit SellFractions(msg.sender, _amount);\n    }\n\n    /// @notice Buys fractional tokens in exchange for ether from a pool\n    /// @param _vault Address of the vault\n    /// @param _amount Transfer amount of fractions\n    function buyFractions(address _vault, uint256 _amount) external payable {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not live\n        (uint256 startTime, , State current, uint256 fractionPrice, , ) = this\n            .buyoutInfo(_vault);\n        State required = State.LIVE;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if current time is greater than end time of rejection period\n        uint256 endTime = startTime + REJECTION_PERIOD;\n        if (block.timestamp > endTime)\n            revert TimeExpired(block.timestamp, endTime);\n        // Reverts if payment amount does not equal price of fractional amount\n        if (msg.value != fractionPrice * _amount) revert InvalidPayment();\n\n        // Transfers fractional tokens to caller\n        IERC1155(token).safeTransferFrom(\n            address(this),\n            msg.sender,\n            id,\n            _amount,\n            \"\"\n        );\n        // Updates ether balance of pool\n        buyoutInfo[_vault].ethBalance += msg.value;\n        // Emits event for buying fractions from pool\n        emit BuyFractions(msg.sender, _amount);\n    }\n\n    /// @notice Ends the auction for a live buyout pool\n    /// @param _vault Address of the vault\n    /// @param _burnProof Merkle proof for burning fractional tokens\n    function end(address _vault, bytes32[] calldata _burnProof) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not live\n        (\n            uint256 startTime,\n            address proposer,\n            State current,\n            ,\n            uint256 ethBalance,\n\n        ) = this.buyoutInfo(_vault);\n        State required = State.LIVE;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if current time is less than or equal to end time of auction\n        uint256 endTime = startTime + REJECTION_PERIOD;\n        if (block.timestamp <= endTime)\n            revert TimeNotElapsed(block.timestamp, endTime);\n\n        uint256 tokenBalance = IERC1155(token).balanceOf(address(this), id);\n        // Checks totalSupply of auction pool to determine if buyout is successful or not\n        if (\n            (tokenBalance * 1000) /\n                IVaultRegistry(registry).totalSupply(_vault) >\n            500\n        ) {\n            // Initializes vault transaction\n            bytes memory data = abi.encodeCall(\n                ISupply.burn,\n                (address(this), tokenBalance)\n            );\n            // Executes burn of fractional tokens from pool\n            IVault(payable(_vault)).execute(supply, data, _burnProof);\n            // Sets buyout state to successful\n            buyoutInfo[_vault].state = State.SUCCESS;\n            // Emits event for ending successful auction\n            emit End(_vault, State.SUCCESS, proposer);\n        } else {\n            // Deletes auction info\n            delete buyoutInfo[_vault];\n            // Transfers fractions and ether back to proposer of the buyout pool\n            IERC1155(token).safeTransferFrom(\n                address(this),\n                proposer,\n                id,\n                tokenBalance,\n                \"\"\n            );\n            _sendEthOrWeth(proposer, ethBalance);\n            // Emits event for ending unsuccessful auction\n            emit End(_vault, State.INACTIVE, proposer);\n        }\n    }\n\n    /// @notice Cashes out proceeds from a successful buyout\n    /// @param _vault Address of the vault\n    /// @param _burnProof Merkle proof for burning fractional tokens\n    function cash(address _vault, bytes32[] calldata _burnProof) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not successful\n        (, , State current, , uint256 ethBalance, ) = this.buyoutInfo(_vault);\n        State required = State.SUCCESS;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if caller has a balance of zero fractional tokens\n        uint256 tokenBalance = IERC1155(token).balanceOf(msg.sender, id);\n        if (tokenBalance == 0) revert NoFractions();\n\n        // Initializes vault transaction\n        bytes memory data = abi.encodeCall(\n            ISupply.burn,\n            (msg.sender, tokenBalance)\n        );\n        // Executes burn of fractional tokens from caller\n        IVault(payable(_vault)).execute(supply, data, _burnProof);\n\n        // Transfers buyout share amount to caller based on total supply\n        uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);\n        uint256 buyoutShare = (tokenBalance * ethBalance) /\n            (totalSupply + tokenBalance);\n        _sendEthOrWeth(msg.sender, buyoutShare);\n        // Emits event for cashing out of buyout pool\n        emit Cash(_vault, msg.sender, buyoutShare);\n    }\n\n    /// @notice Terminates a vault with an inactive buyout\n    /// @param _vault Address of the vault"
    }
  ]
}