{
  "Title": "[M-07] Removing markets from `WildcatArchController` gives lenders immunity from sanctions",
  "Content": "\nIn `WildcatSanctionsSentinel.sol`, the `createEscrow()` function checks that `msg.sender` is a registered market in the `WildcatArchController` contract:\n\n[WildcatSanctionsSentinel.sol#L95-L102](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/WildcatSanctionsSentinel.sol#L95-L102)\n\n```solidity\n  function createEscrow(\n    address borrower,\n    address account,\n    address asset\n  ) public override returns (address escrowContract) {\n    if (!IWildcatArchController(archController).isRegisteredMarket(msg.sender)) {\n      revert NotRegisteredMarket();\n    }\n```\n\nThis is meant to ensure that `createEscrow()` can only be called by markets deployed by the protocol, since they are registered using [`registerMarket()`](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/WildcatArchController.sol#L192-L197).\n\nHowever, such an implementation does not account for markets that are removed using the [`removeMarket()`](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/WildcatArchController.sol#L199-L204) function.\n\nIf a market is removed, it should still be able to operate normally as a registered market would. However, due to the check shown above, any function that calls `createEscrow()` will always revert for removed markets, namely [`nukeFromOrbit()`](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/market/WildcatMarketConfig.sol#L74-L81) and [`executeWithdrawal()`](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/market/WildcatMarketWithdrawals.sol#L123-L188) when they are called for sanctioned lenders.\n\n### Impact\n\nIf a market is removed, lenders that are sanctioned on Chainalysis cannot be blocked using `nukeFromOrbit()` since the function will always revert.\n\nThis is problematic, as sanctioned addresses will still be able to interact with the market in various ways, such as [transferring market tokens](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/market/WildcatMarketToken.sol#L64-L82), [making deposits](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/market/WildcatMarket.sol#L31-L77) or calling [`queueWithdrawal()`](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/market/WildcatMarketWithdrawals.sol#L74-L121), when they should not be able to.\n\nSanctioned lenders will also be unable to call `executeWithdrawal()` to withdraw their assets from the market into their own escrows.\n\n### Proof of Concept\n\nThe following test demonstrates how `nukeFromOrbit()` and `executeWithdrawal()` will revert for sanctioned lenders when a market is removed from the `WildcatArchController` contract:\n\n<details>\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport 'src/WildcatSanctionsSentinel.sol';\nimport 'src/WildcatArchController.sol';\nimport 'src/WildcatMarketControllerFactory.sol';\nimport 'src/interfaces/IWildcatSanctionsSentinel.sol';\n\nimport 'forge-std/Test.sol';\nimport 'test/shared/TestConstants.sol';\nimport 'test/helpers/MockERC20.sol';\n\ncontract CreateEscrowTest is Test {\n    // Wildcat contracts\n    WildcatSanctionsSentinel sentinel;\n    WildcatArchController archController;\n    WildcatMarketControllerFactory controllerFactory;\n    WildcatMarketController controller;\n    WildcatMarket market;\n    \n    // Test contracts\n    MockChainalysis chainalysis = new MockChainalysis();\n    MockERC20 asset = new MockERC20();\n\n    // Users\n    address AIKEN;\n    address DUEET;\n\n    function setUp() external {\n        // Deploy Wildcat contracts\n        archController = new WildcatArchController();\n        sentinel = new WildcatSanctionsSentinel(address(archController), address(chainalysis));\n        MarketParameterConstraints memory constraints = MarketParameterConstraints({\n            minimumDelinquencyGracePeriod: MinimumDelinquencyGracePeriod,\n            maximumDelinquencyGracePeriod: MaximumDelinquencyGracePeriod,\n            minimumReserveRatioBips: MinimumReserveRatioBips,\n            maximumReserveRatioBips: MaximumReserveRatioBips,\n            minimumDelinquencyFeeBips: MinimumDelinquencyFeeBips,\n            maximumDelinquencyFeeBips: MaximumDelinquencyFeeBips,\n            minimumWithdrawalBatchDuration: MinimumWithdrawalBatchDuration,\n            maximumWithdrawalBatchDuration: MaximumWithdrawalBatchDuration,\n            minimumAnnualInterestBips: MinimumAnnualInterestBips,\n            maximumAnnualInterestBips: MaximumAnnualInterestBips\n        });\n        controllerFactory = new WildcatMarketControllerFactory(\n            address(archController),\n            address(sentinel),\n            constraints\n        );\n\n        // Register controllerFactory in archController\n        archController.registerControllerFactory(address(controllerFactory));\n\n        // Setup Aiken and register him as borrower\n        AIKEN = makeAddr(\"AIKEN\");\n        archController.registerBorrower(AIKEN);\n\n        // Setup Dueet and give him some asset token\n        DUEET = makeAddr(\"DUEET\");\n        asset.mint(DUEET, 1000e18);\n\n        // Deploy controller and market for Aiken\n        vm.prank(AIKEN);\n        (address _controller, address _market) = controllerFactory.deployControllerAndMarket(\n            \"Market Token\",\n            \"MKT\",\n            address(asset),\n            type(uint128).max,\n            MaximumAnnualInterestBips,\n            MaximumDelinquencyFeeBips,\n            MaximumWithdrawalBatchDuration,\n            MaximumReserveRatioBips,\n            MaximumDelinquencyGracePeriod\n        );\n        controller = WildcatMarketController(_controller);\n        market = WildcatMarket(_market);\n    }\n\n    function test_removingMarketDOSCreateEscrow() public {\n        // Register Dueet as lender\n        address[] memory arr = new address[](1);\n        arr[0] = DUEET;\n        vm.prank(AIKEN);\n        controller.authorizeLenders(arr);\n\n        // Dueet becomes a lender in the market\n        vm.startPrank(DUEET);\n        asset.approve(address(market), 1000e18);\n        market.depositUpTo(1000e18);\n\n        // Queue withdrawal for Dueet\n        market.queueWithdrawal(500e18);\n        vm.stopPrank();\n\n        // Time passes until the withdrawal expires\n        skip(MaximumWithdrawalBatchDuration);\n\n        // Dueet becomes sanctioned\n        chainalysis.sanction(DUEET);\n\n        // Market get removes from archController\n        archController.removeMarket(address(market));\n\n        // nukeFromOrbit() reverts for Dueet\n        vm.expectRevert(IWildcatSanctionsSentinel.NotRegisteredMarket.selector);\n        market.nukeFromOrbit(DUEET);\n\n        // executeWithdrawal() also reverts for Dueet\n        vm.expectRevert(IWildcatSanctionsSentinel.NotRegisteredMarket.selector);\n        market.executeWithdrawal(DUEET, uint32(block.timestamp));\n    }\n}\n\ncontract MockChainalysis {\n    mapping(address => bool) public isSanctioned;\n\n    function sanction(address addr) external {\n        isSanctioned[addr] = true;\n    }\n}\n```\n\n</details>\n\n### Recommended Mitigation\n\nConsider implementing a way to track removed markets in `WildcatArchController`. For example, a new `EnumerableSet` named `_removedMarkets` could be added.\n\nThis can be used to allow removed markets to call `createEscrow()` as such:\n\n[WildcatSanctionsSentinel.sol#L95-L102](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/WildcatSanctionsSentinel.sol#L95-L102)\n\n```diff\n  function createEscrow(\n    address borrower,\n    address account,\n    address asset\n  ) public override returns (address escrowContract) {\n-   if (!IWildcatArchController(archController).isRegisteredMarket(msg.sender)) {\n+   if (!IWildcatArchController(archController).isRegisteredMarket(msg.sender) && !IWildcatArchController(archController).isRemovedMarket(msg.sender)) {\n      revert NotRegisteredMarket();\n    }\n```\n\n### Assessed type\n\nInvalid Validation\n\n**[d1ll0n (Wildcat) confirmed](https://github.com/code-423n4/2023-10-wildcat-findings/issues/498#issuecomment-1788827614)**\n\n**[laurenceday (Wildcat) commented](https://github.com/code-423n4/2023-10-wildcat-findings/issues/498#issuecomment-1803408475):**\n > Mitigated [here](https://github.com/wildcat-finance/wildcat-protocol/pull/57/commits/22c2eb6dae8fe2fe74e5c8e478cb755fbf6827f0). Removing the check altogether.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-wildcat",
  "Code": [
    {
      "filename": "src/WildcatSanctionsSentinel.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport { IChainalysisSanctionsList } from './interfaces/IChainalysisSanctionsList.sol';\nimport { IWildcatArchController } from './interfaces/IWildcatArchController.sol';\nimport { IWildcatSanctionsSentinel } from './interfaces/IWildcatSanctionsSentinel.sol';\nimport { SanctionsList } from './libraries/Chainalysis.sol';\nimport { WildcatSanctionsEscrow } from './WildcatSanctionsEscrow.sol';\n\ncontract WildcatSanctionsSentinel is IWildcatSanctionsSentinel {\n  bytes32 public constant override WildcatSanctionsEscrowInitcodeHash =\n    keccak256(type(WildcatSanctionsEscrow).creationCode);\n\n  address public immutable override chainalysisSanctionsList;\n\n  address public immutable override archController;\n\n  TmpEscrowParams public override tmpEscrowParams;\n\n  mapping(address borrower => mapping(address account => bool sanctionOverride))\n    public\n    override sanctionOverrides;\n\n  constructor(address _archController, address _chainalysisSanctionsList) {\n    archController = _archController;\n    chainalysisSanctionsList = _chainalysisSanctionsList;\n    _resetTmpEscrowParams();\n  }\n\n  function _resetTmpEscrowParams() internal {\n    tmpEscrowParams = TmpEscrowParams(address(1), address(1), address(1));\n  }\n\n  /**\n   * @dev Returns boolean indicating whether `account` is sanctioned\n   *      on Chainalysis and that status has not been overridden by\n   *      `borrower`.\n   */\n  function isSanctioned(address borrower, address account) public view override returns (bool) {\n    return\n      !sanctionOverrides[borrower][account] &&\n      IChainalysisSanctionsList(chainalysisSanctionsList).isSanctioned(account);\n  }\n\n  /**\n   * @dev Overrides the sanction status of `account` for `borrower`.\n   */\n  function overrideSanction(address account) public override {\n    sanctionOverrides[msg.sender][account] = true;\n    emit SanctionOverride(msg.sender, account);\n  }\n\n  /**\n   * @dev Removes the sanction override of `account` for `borrower`.\n   */\n  function removeSanctionOverride(address account) public override {\n    sanctionOverrides[msg.sender][account] = false;\n    emit SanctionOverrideRemoved(msg.sender, account);\n  }\n\n  /**\n   * @dev Calculate the create2 escrow address for the combination\n   *      of `borrower`, `account`, and `asset`.\n   */\n  function getEscrowAddress(\n    address borrower,\n    address account,\n    address asset\n  ) public view override returns (address escrowAddress) {\n    return\n      address(\n        uint160(\n          uint256(\n            keccak256(\n              abi.encodePacked(\n                bytes1(0xff),\n                address(this),\n                keccak256(abi.encode(borrower, account, asset)),\n                WildcatSanctionsEscrowInitcodeHash\n              )\n            )\n          )\n        )\n      );\n  }\n\n  /**\n   * @dev Creates a new WildcatSanctionsEscrow contract for `borrower`,\n   *      `account`, and `asset` or returns the existing escrow contract\n   *      if one already exists.\n   *\n   *      The escrow contract is added to the set of sanction override\n   *      addresses for `borrower` so that it can not be blocked.\n   */\n  function createEscrow(\n    address borrower,\n    address account,\n    address asset\n  ) public override returns (address escrowContract) {\n    if (!IWildcatArchController(archController).isRegisteredMarket(msg.sender)) {\n      revert NotRegisteredMarket();\n    }\n\n    escrowContract = getEscrowAddress(borrower, account, asset);\n\n    if (escrowContract.codehash != bytes32(0)) return escrowContract;\n\n    tmpEscrowParams = TmpEscrowParams(borrower, account, asset);\n\n    new WildcatSanctionsEscrow{ salt: keccak256(abi.encode(borrower, account, asset)) }();\n\n    emit NewSanctionsEscrow(borrower, account, asset);\n\n    sanctionOverrides[borrower][escrowContract] = true;\n\n    emit SanctionOverride(borrower, escrowContract);\n\n    _resetTmpEscrowParams();\n  }\n}"
    },
    {
      "filename": "src/WildcatArchController.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport { EnumerableSet } from 'openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport 'solady/auth/Ownable.sol';\nimport './libraries/MathUtils.sol';\n\ncontract WildcatArchController is Ownable {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  EnumerableSet.AddressSet internal _markets;\n  EnumerableSet.AddressSet internal _controllerFactories;\n  EnumerableSet.AddressSet internal _borrowers;\n  EnumerableSet.AddressSet internal _controllers;\n\n  error NotControllerFactory();\n  error NotController();\n\n  error BorrowerAlreadyExists();\n  error ControllerFactoryAlreadyExists();\n  error ControllerAlreadyExists();\n  error MarketAlreadyExists();\n\n  error BorrowerDoesNotExist();\n  error ControllerFactoryDoesNotExist();\n  error ControllerDoesNotExist();\n  error MarketDoesNotExist();\n\n  event MarketAdded(address indexed controller, address market);\n  event MarketRemoved(address market);\n\n  event ControllerFactoryAdded(address controllerFactory);\n  event ControllerFactoryRemoved(address controllerFactory);\n\n  event BorrowerAdded(address borrower);\n  event BorrowerRemoved(address borrower);\n\n  event ControllerAdded(address indexed controllerFactory, address controller);\n  event ControllerRemoved(address controller);\n\n  modifier onlyControllerFactory() {\n    if (!_controllerFactories.contains(msg.sender)) {\n      revert NotControllerFactory();\n    }\n    _;\n  }\n\n  modifier onlyController() {\n    if (!_controllers.contains(msg.sender)) {\n      revert NotController();\n    }\n    _;\n  }\n\n  constructor() {\n    _initializeOwner(msg.sender);\n  }\n\n  /* ========================================================================== */\n  /*                                  Borrowers                                 */\n  /* ========================================================================== */\n\n  function registerBorrower(address borrower) external onlyOwner {\n    if (!_borrowers.add(borrower)) {\n      revert BorrowerAlreadyExists();\n    }\n    emit BorrowerAdded(borrower);\n  }\n\n  function removeBorrower(address borrower) external onlyOwner {\n    if (!_borrowers.remove(borrower)) {\n      revert BorrowerDoesNotExist();\n    }\n    emit BorrowerRemoved(borrower);\n  }\n\n  function isRegisteredBorrower(address borrower) external view returns (bool) {\n    return _borrowers.contains(borrower);\n  }\n\n  function getRegisteredBorrowers() external view returns (address[] memory) {\n    return _borrowers.values();\n  }\n\n  function getRegisteredBorrowers(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _borrowers.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _borrowers.at(start + i);\n    }\n  }\n\n  function getRegisteredBorrowersCount() external view returns (uint256) {\n    return _borrowers.length();\n  }\n\n  /* ========================================================================== */\n  /*                            Controller Factories                            */\n  /* ========================================================================== */\n\n  function registerControllerFactory(address factory) external onlyOwner {\n    if (!_controllerFactories.add(factory)) {\n      revert ControllerFactoryAlreadyExists();\n    }\n    emit ControllerFactoryAdded(factory);\n  }\n\n  function removeControllerFactory(address factory) external onlyOwner {\n    if (!_controllerFactories.remove(factory)) {\n      revert ControllerFactoryDoesNotExist();\n    }\n    emit ControllerFactoryRemoved(factory);\n  }\n\n  function isRegisteredControllerFactory(address factory) external view returns (bool) {\n    return _controllerFactories.contains(factory);\n  }\n\n  function getRegisteredControllerFactories() external view returns (address[] memory) {\n    return _controllerFactories.values();\n  }\n\n  function getRegisteredControllerFactories(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _controllerFactories.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _controllerFactories.at(start + i);\n    }\n  }\n\n  function getRegisteredControllerFactoriesCount() external view returns (uint256) {\n    return _controllerFactories.length();\n  }\n\n  /* ========================================================================== */\n  /*                                 Controllers                                */\n  /* ========================================================================== */\n\n  function registerController(address controller) external onlyControllerFactory {\n    if (!_controllers.add(controller)) {\n      revert ControllerAlreadyExists();\n    }\n    emit ControllerAdded(msg.sender, controller);\n  }\n\n  function removeController(address controller) external onlyOwner {\n    if (!_controllers.remove(controller)) {\n      revert ControllerDoesNotExist();\n    }\n    emit ControllerRemoved(controller);\n  }\n\n  function isRegisteredController(address controller) external view returns (bool) {\n    return _controllers.contains(controller);\n  }\n\n  function getRegisteredControllers() external view returns (address[] memory) {\n    return _controllers.values();\n  }\n\n  function getRegisteredControllers(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _controllers.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _controllers.at(start + i);\n    }\n  }\n\n  function getRegisteredControllersCount() external view returns (uint256) {\n    return _controllers.length();\n  }\n\n  /* ========================================================================== */\n  /*                                   Markets                                   */\n  /* ========================================================================== */\n\n  function registerMarket(address market) external onlyController {\n    if (!_markets.add(market)) {\n      revert MarketAlreadyExists();\n    }\n    emit MarketAdded(msg.sender, market);\n  }\n\n  function removeMarket(address market) external onlyOwner {\n    if (!_markets.remove(market)) {\n      revert MarketDoesNotExist();\n    }\n    emit MarketRemoved(market);\n  }\n\n  function isRegisteredMarket(address market) external view returns (bool) {\n    return _markets.contains(market);\n  }\n\n  function getRegisteredMarkets() external view returns (address[] memory) {\n    return _markets.values();\n  }\n\n  function getRegisteredMarkets(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _markets.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _markets.at(start + i);\n    }\n  }\n\n  function getRegisteredMarketsCount() external view returns (uint256) {\n    return _markets.length();\n  }\n}"
    },
    {
      "filename": "src/WildcatArchController.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport { EnumerableSet } from 'openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport 'solady/auth/Ownable.sol';\nimport './libraries/MathUtils.sol';\n\ncontract WildcatArchController is Ownable {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  EnumerableSet.AddressSet internal _markets;\n  EnumerableSet.AddressSet internal _controllerFactories;\n  EnumerableSet.AddressSet internal _borrowers;\n  EnumerableSet.AddressSet internal _controllers;\n\n  error NotControllerFactory();\n  error NotController();\n\n  error BorrowerAlreadyExists();\n  error ControllerFactoryAlreadyExists();\n  error ControllerAlreadyExists();\n  error MarketAlreadyExists();\n\n  error BorrowerDoesNotExist();\n  error ControllerFactoryDoesNotExist();\n  error ControllerDoesNotExist();\n  error MarketDoesNotExist();\n\n  event MarketAdded(address indexed controller, address market);\n  event MarketRemoved(address market);\n\n  event ControllerFactoryAdded(address controllerFactory);\n  event ControllerFactoryRemoved(address controllerFactory);\n\n  event BorrowerAdded(address borrower);\n  event BorrowerRemoved(address borrower);\n\n  event ControllerAdded(address indexed controllerFactory, address controller);\n  event ControllerRemoved(address controller);\n\n  modifier onlyControllerFactory() {\n    if (!_controllerFactories.contains(msg.sender)) {\n      revert NotControllerFactory();\n    }\n    _;\n  }\n\n  modifier onlyController() {\n    if (!_controllers.contains(msg.sender)) {\n      revert NotController();\n    }\n    _;\n  }\n\n  constructor() {\n    _initializeOwner(msg.sender);\n  }\n\n  /* ========================================================================== */\n  /*                                  Borrowers                                 */\n  /* ========================================================================== */\n\n  function registerBorrower(address borrower) external onlyOwner {\n    if (!_borrowers.add(borrower)) {\n      revert BorrowerAlreadyExists();\n    }\n    emit BorrowerAdded(borrower);\n  }\n\n  function removeBorrower(address borrower) external onlyOwner {\n    if (!_borrowers.remove(borrower)) {\n      revert BorrowerDoesNotExist();\n    }\n    emit BorrowerRemoved(borrower);\n  }\n\n  function isRegisteredBorrower(address borrower) external view returns (bool) {\n    return _borrowers.contains(borrower);\n  }\n\n  function getRegisteredBorrowers() external view returns (address[] memory) {\n    return _borrowers.values();\n  }\n\n  function getRegisteredBorrowers(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _borrowers.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _borrowers.at(start + i);\n    }\n  }\n\n  function getRegisteredBorrowersCount() external view returns (uint256) {\n    return _borrowers.length();\n  }\n\n  /* ========================================================================== */\n  /*                            Controller Factories                            */\n  /* ========================================================================== */\n\n  function registerControllerFactory(address factory) external onlyOwner {\n    if (!_controllerFactories.add(factory)) {\n      revert ControllerFactoryAlreadyExists();\n    }\n    emit ControllerFactoryAdded(factory);\n  }\n\n  function removeControllerFactory(address factory) external onlyOwner {\n    if (!_controllerFactories.remove(factory)) {\n      revert ControllerFactoryDoesNotExist();\n    }\n    emit ControllerFactoryRemoved(factory);\n  }\n\n  function isRegisteredControllerFactory(address factory) external view returns (bool) {\n    return _controllerFactories.contains(factory);\n  }\n\n  function getRegisteredControllerFactories() external view returns (address[] memory) {\n    return _controllerFactories.values();\n  }\n\n  function getRegisteredControllerFactories(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _controllerFactories.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _controllerFactories.at(start + i);\n    }\n  }\n\n  function getRegisteredControllerFactoriesCount() external view returns (uint256) {\n    return _controllerFactories.length();\n  }\n\n  /* ========================================================================== */\n  /*                                 Controllers                                */\n  /* ========================================================================== */\n\n  function registerController(address controller) external onlyControllerFactory {\n    if (!_controllers.add(controller)) {\n      revert ControllerAlreadyExists();\n    }\n    emit ControllerAdded(msg.sender, controller);\n  }\n\n  function removeController(address controller) external onlyOwner {\n    if (!_controllers.remove(controller)) {\n      revert ControllerDoesNotExist();\n    }\n    emit ControllerRemoved(controller);\n  }\n\n  function isRegisteredController(address controller) external view returns (bool) {\n    return _controllers.contains(controller);\n  }\n\n  function getRegisteredControllers() external view returns (address[] memory) {\n    return _controllers.values();\n  }\n\n  function getRegisteredControllers(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _controllers.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _controllers.at(start + i);\n    }\n  }\n\n  function getRegisteredControllersCount() external view returns (uint256) {\n    return _controllers.length();\n  }\n\n  /* ========================================================================== */\n  /*                                   Markets                                   */\n  /* ========================================================================== */\n\n  function registerMarket(address market) external onlyController {\n    if (!_markets.add(market)) {\n      revert MarketAlreadyExists();\n    }\n    emit MarketAdded(msg.sender, market);\n  }\n\n  function removeMarket(address market) external onlyOwner {\n    if (!_markets.remove(market)) {\n      revert MarketDoesNotExist();\n    }\n    emit MarketRemoved(market);\n  }\n\n  function isRegisteredMarket(address market) external view returns (bool) {\n    return _markets.contains(market);\n  }\n\n  function getRegisteredMarkets() external view returns (address[] memory) {\n    return _markets.values();\n  }\n\n  function getRegisteredMarkets(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _markets.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _markets.at(start + i);\n    }\n  }\n\n  function getRegisteredMarketsCount() external view returns (uint256) {\n    return _markets.length();\n  }\n}"
    },
    {
      "filename": "src/market/WildcatMarketConfig.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport '../interfaces/IWildcatSanctionsSentinel.sol';\nimport '../libraries/FeeMath.sol';\nimport '../libraries/SafeCastLib.sol';\nimport './WildcatMarketBase.sol';\n\ncontract WildcatMarketConfig is WildcatMarketBase {\n  using SafeCastLib for uint256;\n  using BoolUtils for bool;\n\n  // ===================================================================== //\n  //                      External Config Getters                          //\n  // ===================================================================== //\n\n  /**\n   * @dev Returns the maximum amount of underlying asset that can\n   *      currently be deposited to the market.\n   */\n  function maximumDeposit() external view returns (uint256) {\n    MarketState memory state = currentState();\n    return state.maximumDeposit();\n  }\n\n  /**\n   * @dev Returns the maximum supply the market can reach via\n   *      deposits (does not apply to interest accrual).\n   */\n  function maxTotalSupply() external view returns (uint256) {\n    return _state.maxTotalSupply;\n  }\n\n  /**\n   * @dev Returns the annual interest rate earned by lenders\n   *      in bips.\n   */\n  function annualInterestBips() external view returns (uint256) {\n    return _state.annualInterestBips;\n  }\n\n  function reserveRatioBips() external view returns (uint256) {\n    return _state.reserveRatioBips;\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                                  Sanctions                                 */\n  /* -------------------------------------------------------------------------- */\n\n  /// @dev Block a sanctioned account from interacting with the market\n  ///      and transfer its balance to an escrow contract.\n  // ******************************************************************\n  //          *  |\\**/|  *          *                                *\n  //          *  \\ == /  *          *                                *\n  //          *   | b|   *          *                                *\n  //          *   | y|   *          *                                *\n  //          *   \\ e/   *          *                                *\n  //          *    \\/    *          *                                *\n  //          *          *          *                                *\n  //          *          *          *                                *\n  //          *          *  |\\**/|  *                                *\n  //          *          *  \\ == /  *         _.-^^---....,,--       *\n  //          *          *   | b|   *    _--                  --_    *\n  //          *          *   | y|   *   <                        >)  *\n  //          *          *   \\ e/   *   |         O-FAC!          |  *\n  //          *          *    \\/    *    \\._                   _./   *\n  //          *          *          *       ```--. . , ; .--'''      *\n  //          *          *          *   üí∏        | |   |            *\n  //          *          *          *          .-=||  | |=-.    üí∏   *\n  //  üí∞ü§ëüí∞ *   üòÖ    *    üòê    *    üí∏    `-=#$%&%$#=-'         *\n  //   \\|/    *   /|\\    *   /|\\    *  üå™         | ;  :|    üå™       *\n  //   /\\     * üí∞/\\ üí∞ * üí∞/\\ üí∞ *    _____.,-#%&$@%#&#~,._____    *\n  // ******************************************************************\n  function nukeFromOrbit(address accountAddress) external nonReentrant {\n    if (!IWildcatSanctionsSentinel(sentinel).isSanctioned(borrower, accountAddress)) {\n      revert BadLaunchCode();\n    }\n    MarketState memory state = _getUpdatedState();\n    _blockAccount(state, accountAddress);\n    _writeState(state);\n  }\n\n  /**\n   * @dev Unblock an account that was previously sanctioned and blocked\n   *      and has since been removed from the sanctions list or had\n   *      their sanctioned status overridden by the borrower.\n   */\n  function stunningReversal(address accountAddress) external nonReentrant {\n    Account memory account = _accounts[accountAddress];\n    if (account.approval != AuthRole.Blocked) {\n      revert AccountNotBlocked();\n    }\n\n    if (IWildcatSanctionsSentinel(sentinel).isSanctioned(borrower, accountAddress)) {\n      revert NotReversedOrStunning();\n    }\n\n    account.approval = AuthRole.Null;\n    emit AuthorizationStatusUpdated(accountAddress, account.approval);\n\n    _accounts[accountAddress] = account;\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                           External Config Setters                          */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @dev Updates an account's authorization status based on whether the controller\n   *      has it marked as approved.\n   */\n  function updateAccountAuthorization(\n    address _account,\n    bool _isAuthorized\n  ) external onlyController nonReentrant {\n    MarketState memory state = _getUpdatedState();\n    Account memory account = _getAccount(_account);\n    if (_isAuthorized) {\n      account.approval = AuthRole.DepositAndWithdraw;\n    } else {\n      account.approval = AuthRole.WithdrawOnly;\n    }\n    _accounts[_account] = account;\n    _writeState(state);\n    emit AuthorizationStatusUpdated(_account, account.approval);\n  }\n\n  /**\n   * @dev Sets the maximum total supply - this only limits deposits and\n   *      does not affect interest accrual.\n   *\n   *      Can not be set lower than current total supply.\n   */\n  function setMaxTotalSupply(uint256 _maxTotalSupply) external onlyController nonReentrant {\n    MarketState memory state = _getUpdatedState();\n\n    if (_maxTotalSupply < state.totalSupply()) {\n      revert NewMaxSupplyTooLow();\n    }\n\n    state.maxTotalSupply = _maxTotalSupply.toUint128();\n    _writeState(state);\n    emit MaxTotalSupplyUpdated(_maxTotalSupply);\n  }\n\n  /**\n   * @dev Sets the annual interest rate earned by lenders in bips.\n   */\n  function setAnnualInterestBips(uint16 _annualInterestBips) public onlyController nonReentrant {\n    MarketState memory state = _getUpdatedState();\n\n    if (_annualInterestBips > BIP) {\n      revert InterestRateTooHigh();\n    }\n\n    state.annualInterestBips = _annualInterestBips;\n    _writeState(state);\n    emit AnnualInterestBipsUpdated(_annualInterestBips);\n  }\n\n  /**\n   * @dev Adjust the market's reserve ratio.\n   *\n   *      If the new ratio is lower than the old ratio,\n   *      asserts that the market is not currently delinquent.\n   *\n   *      If the new ratio is higher than the old ratio,\n   *      asserts that the market will not become delinquent\n   *      because of the change.\n   */\n  function setReserveRatioBips(uint16 _reserveRatioBips) public onlyController nonReentrant {\n    if (_reserveRatioBips > BIP) {\n      revert ReserveRatioBipsTooHigh();\n    }\n\n    MarketState memory state = _getUpdatedState();\n\n    uint256 initialReserveRatioBips = state.reserveRatioBips;\n\n    if (_reserveRatioBips < initialReserveRatioBips) {\n      if (state.liquidityRequired() > totalAssets()) {\n        revert InsufficientReservesForOldLiquidityRatio();\n      }\n    }\n    state.reserveRatioBips = _reserveRatioBips;\n    if (_reserveRatioBips > initialReserveRatioBips) {\n      if (state.liquidityRequired() > totalAssets()) {\n        revert InsufficientReservesForNewLiquidityRatio();\n      }\n    }\n    _writeState(state);\n    emit ReserveRatioBipsUpdated(_reserveRatioBips);\n  }\n}"
    },
    {
      "filename": "src/market/WildcatMarketToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport './WildcatMarketBase.sol';\n\ncontract WildcatMarketToken is WildcatMarketBase {\n  using SafeCastLib for uint256;\n\n  /* -------------------------------------------------------------------------- */\n  /*                                ERC20 Queries                               */\n  /* -------------------------------------------------------------------------- */\n\n  mapping(address => mapping(address => uint256)) public allowance;\n\n  /// @notice Returns the normalized balance of `account` with interest.\n  function balanceOf(address account) public view virtual nonReentrantView returns (uint256) {\n    (MarketState memory state, , ) = _calculateCurrentState();\n    return state.normalizeAmount(_accounts[account].scaledBalance);\n  }\n\n  /// @notice Returns the normalized total supply with interest.\n  function totalSupply() external view virtual nonReentrantView returns (uint256) {\n    (MarketState memory state, , ) = _calculateCurrentState();\n    return state.totalSupply();\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                                ERC20 Actions                               */\n  /* -------------------------------------------------------------------------- */\n\n  function approve(address spender, uint256 amount) external virtual nonReentrant returns (bool) {\n    _approve(msg.sender, spender, amount);\n    return true;\n  }\n\n  function transfer(address to, uint256 amount) external virtual nonReentrant returns (bool) {\n    _transfer(msg.sender, to, amount);\n    return true;\n  }\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) external virtual nonReentrant returns (bool) {\n    uint256 allowed = allowance[from][msg.sender];\n\n    // Saves gas for unlimited approvals.\n    if (allowed != type(uint256).max) {\n      uint256 newAllowance = allowed - amount;\n      _approve(from, msg.sender, newAllowance);\n    }\n\n    _transfer(from, to, amount);\n\n    return true;\n  }\n\n  function _approve(address approver, address spender, uint256 amount) internal virtual {\n    allowance[approver][spender] = amount;\n    emit Approval(approver, spender, amount);\n  }\n\n  function _transfer(address from, address to, uint256 amount) internal virtual {\n    MarketState memory state = _getUpdatedState();\n    uint104 scaledAmount = state.scaleAmount(amount).toUint104();\n\n    if (scaledAmount == 0) {\n      revert NullTransferAmount();\n    }\n\n    Account memory fromAccount = _getAccount(from);\n    fromAccount.scaledBalance -= scaledAmount;\n    _accounts[from] = fromAccount;\n\n    Account memory toAccount = _getAccount(to);\n    toAccount.scaledBalance += scaledAmount;\n    _accounts[to] = toAccount;\n\n    _writeState(state);\n    emit Transfer(from, to, amount);\n  }\n}"
    },
    {
      "filename": "src/WildcatSanctionsSentinel.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport { IChainalysisSanctionsList } from './interfaces/IChainalysisSanctionsList.sol';\nimport { IWildcatArchController } from './interfaces/IWildcatArchController.sol';\nimport { IWildcatSanctionsSentinel } from './interfaces/IWildcatSanctionsSentinel.sol';\nimport { SanctionsList } from './libraries/Chainalysis.sol';\nimport { WildcatSanctionsEscrow } from './WildcatSanctionsEscrow.sol';\n\ncontract WildcatSanctionsSentinel is IWildcatSanctionsSentinel {\n  bytes32 public constant override WildcatSanctionsEscrowInitcodeHash =\n    keccak256(type(WildcatSanctionsEscrow).creationCode);\n\n  address public immutable override chainalysisSanctionsList;\n\n  address public immutable override archController;\n\n  TmpEscrowParams public override tmpEscrowParams;\n\n  mapping(address borrower => mapping(address account => bool sanctionOverride))\n    public\n    override sanctionOverrides;\n\n  constructor(address _archController, address _chainalysisSanctionsList) {\n    archController = _archController;\n    chainalysisSanctionsList = _chainalysisSanctionsList;\n    _resetTmpEscrowParams();\n  }\n\n  function _resetTmpEscrowParams() internal {\n    tmpEscrowParams = TmpEscrowParams(address(1), address(1), address(1));\n  }\n\n  /**\n   * @dev Returns boolean indicating whether `account` is sanctioned\n   *      on Chainalysis and that status has not been overridden by\n   *      `borrower`.\n   */\n  function isSanctioned(address borrower, address account) public view override returns (bool) {\n    return\n      !sanctionOverrides[borrower][account] &&\n      IChainalysisSanctionsList(chainalysisSanctionsList).isSanctioned(account);\n  }\n\n  /**\n   * @dev Overrides the sanction status of `account` for `borrower`.\n   */\n  function overrideSanction(address account) public override {\n    sanctionOverrides[msg.sender][account] = true;\n    emit SanctionOverride(msg.sender, account);\n  }\n\n  /**\n   * @dev Removes the sanction override of `account` for `borrower`.\n   */\n  function removeSanctionOverride(address account) public override {\n    sanctionOverrides[msg.sender][account] = false;\n    emit SanctionOverrideRemoved(msg.sender, account);\n  }\n\n  /**\n   * @dev Calculate the create2 escrow address for the combination\n   *      of `borrower`, `account`, and `asset`.\n   */\n  function getEscrowAddress(\n    address borrower,\n    address account,\n    address asset\n  ) public view override returns (address escrowAddress) {\n    return\n      address(\n        uint160(\n          uint256(\n            keccak256(\n              abi.encodePacked(\n                bytes1(0xff),\n                address(this),\n                keccak256(abi.encode(borrower, account, asset)),\n                WildcatSanctionsEscrowInitcodeHash\n              )\n            )\n          )\n        )\n      );\n  }\n\n  /**\n   * @dev Creates a new WildcatSanctionsEscrow contract for `borrower`,\n   *      `account`, and `asset` or returns the existing escrow contract\n   *      if one already exists.\n   *\n   *      The escrow contract is added to the set of sanction override\n   *      addresses for `borrower` so that it can not be blocked.\n   */\n  function createEscrow(\n    address borrower,\n    address account,\n    address asset\n  ) public override returns (address escrowContract) {\n    if (!IWildcatArchController(archController).isRegisteredMarket(msg.sender)) {\n      revert NotRegisteredMarket();\n    }\n\n    escrowContract = getEscrowAddress(borrower, account, asset);\n\n    if (escrowContract.codehash != bytes32(0)) return escrowContract;\n\n    tmpEscrowParams = TmpEscrowParams(borrower, account, asset);\n\n    new WildcatSanctionsEscrow{ salt: keccak256(abi.encode(borrower, account, asset)) }();\n\n    emit NewSanctionsEscrow(borrower, account, asset);\n\n    sanctionOverrides[borrower][escrowContract] = true;\n\n    emit SanctionOverride(borrower, escrowContract);\n\n    _resetTmpEscrowParams();\n  }\n}"
    }
  ]
}