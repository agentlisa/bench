{
  "Title": "[H-03] Attacker could steal almost all the bonus tokens in BathBuddy Vesting Wallet",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L87\n\n\n# Vulnerability details\n\n## Background\n\nBathBuddy is a Vesting Wallet that payout withdrawers any `bonusTokens` they may have accrued while staking in the Bath Token (e.g. network incentives/governance tokens).\n\nBathBuddy Vesting Wallet releases a user their relative share of the pool’s total vested bonus token during the withdraw call on BathToken.sol. This vesting occurs linearly over Unix time.\n\nIt was observed that an attacker could steal almost all the `bonusTokens` in the BathBuddy Vesting Wallet.\n\n## Proof-of-Concept\n\nThe root cause of this issue is that the amount of `bonusTokens` that a user is entitled to is based on their relative share of the pool’s total vested bonus token at the point of the withdraw call. It is calculated based on the user's \"spot\" share in the pool. Thus, it is possible for an attacker to deposit large amount of tokens into a BathToken Pool to gain significant share of the pool (e.g. 95%), and then withdraw the all the shares immediately. The withdraw call will trigger the `BathToken.distributeBonusTokenRewards`, and since attacker holds overwhelming amount of share in the pool, they will receive almost all the `bonusToken` in the BathBuddy Vesting wallet, leaving behind dust amount of `bonusToken` in the wallet. This could be perform in an atomic transaction and attacker can leverage on flash-loan to fund this attack.\n\nThe following shows an example of this issue:\n\n1. A sponsor sent 1000 DAI to the BathBuddy Vesting Wallet to be used as `bonusTokens` for bathWETH pool. The vesting duration is 4 weeks.\n2. Alice and Bob deposited 50 WETH and 50 WETH respectively. The total underlying asset of bathWETH is 100 WETH after depositing. Each of them hold 50% of the shares in the pool.\n3. Fast forward to the last hour of the vesting period, most of the `bonusToken` have been vested and ready for the recipients to claim. In this example, estimate 998 DAI are ready to be claimed at the final hour.\n4. Since Alice has 50% stake in the pool, she should have accured close to 449 DAI at this point. If she decided to withdraw all her bathWETH LP tokens at this point, she would receive close to 449 DAI as `bonusTokens`. But she choose not to withdraw yet.\n5. Unfortunately, an attacker performed a flash-loan to borrow 8500 WETH, and deposit large amount of WETH into the bathWETH gain significant share of the pool, and then withdraw the all the shares immediately.\n6. Since attacker hold the an overwhelming amount of shares in the pool, they will receive almost all the `bonusToken` (around 997 DAI) in the BathBuddy Vesting wallet, leaving behind dust amount of `bonusToken` in the wallet.\n7. At this point, Alice decided to withdraw all her bathWETH LP token. She only received dust amount of 0.7 DAI as `bonusTokens`\n\nThe following code shows that the amount of `bonusTokens` a user is entitled is based on the user's current share in the pool - `amount = releasable * sharesWithdrawn/initialTotalSupply`.\n\n[https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L87](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L87)\n\n```solidity\n/// @inheritdoc IBathBuddy\n/// @dev Added and modified release function. Should be the only callable release function\nfunction release(\n    IERC20 token,\n    address recipient,\n    uint256 sharesWithdrawn,\n    uint256 initialTotalSupply,\n    uint256 poolFee\n) external override {\n    require(\n        msg.sender == beneficiary,\n        \"Caller is not the Bath Token beneficiary of these rewards\"\n    );\n    uint256 releasable = vestedAmount(\n        address(token),\n        uint64(block.timestamp)\n    ) - released(address(token));\n    if (releasable > 0) {\n        uint256 amount = releasable.mul(sharesWithdrawn).div(\n            initialTotalSupply\n        );\n        uint256 _fee = amount.mul(poolFee).div(10000);\n\n        ..SNIP..\n\n        uint256 amountWithdrawn = amount.sub(_fee);\n        token.transfer(recipient, amountWithdrawn);\n\n        _erc20Released[address(token)] += amount;\n        ..SNIP..\n    }\n}\n```\n\n## Test Scripts\n\nFollowing is the test output that demostrate the above scenario:\n\n```javascript\n  Contract: Rubicon Exchange and Pools Original Tests\n    Deployment\n      ✓ is deployed (1783ms)\n    Bath House Initialization of Bath Pair and Bath Tokens\n      ✓ Bath House is deployed and initialized (66ms)\n        new bathWETH! 0x237eda6f0102c1684caEbA3Ebd89e26a79258C6f\n      ✓ WETH Bath Token for WETH asset is deployed and initialized (131ms)\n      ✓ Init BathBuddy Vesting Wallet and Add BathBuddy to WETH BathToken Pool (54ms)\n      ✓ Bath Pair is deployed and initialized w/ BathHouse (59ms)\n        undefined\n      ✓ Alice deposit 50 WETH to WETH bathTokens (137ms)\n        undefined\n      ✓ Bob deposit 50 WETH to WETH bathTokens (174ms)\nbathAssetInstance.bonusTokens.length = 1\nbathBuddyInstance (Vesting Wallet) has 1000 DAI\nbathBuddyInstance.vestedAmount(DAI) = 0.000413359788359788\nbathBuddyInstance.vestedAmount(DAI) = 500.000413359788359788 (End of 2nd week)\nbathBuddyInstance.vestedAmount(DAI) = 998.512318121693121693 (Last hour of the vesting period)\n0 DAI has been released from BathBuddy Vesting Wallet\nCharles has 8500 bathWETH token, 0 DAI, 0 WETH\nCharles withdraw all his bathWETH tokens\n997.338978147402060445 DAI has been released from BathBuddy Vesting Wallet\nCharles has 0 bathWETH token, 997.039776453957839827 DAI, 8497.45 WETH\nAlice has 5 bathWETH token, 0 DAI, 0 WETH\n998.075233164534207763 DAI has been released from BathBuddy Vesting Wallet\nAlice has 0 bathWETH token, 0.736034140627007674 DAI, 6.2731175 WETH\n      ✓ Add Rewards (100 DAI) to BathBuddy Vesting Wallet  (749ms)\nbathAssetInstance: underlyingBalance() = 6.2768825 WETH, balanceOf = 6.2768825 WETH, Outstanding Amount = 0 WETH\n      ✓ [Debug]\n```\n\nAttacker Charles deposited 8500 WETH to the pool and withdraw them immediately at the final hour, and obtained almost all of the `bonusTokens` (997 DAI). When Alice withdraw from the pool, she only received 0.7 DAI as `bonusTokens`.\n\nScript can be found [https://gist.github.com/xiaoming9090/2252f6b6f7e62fca20ecfbaac6f754f5](https://gist.github.com/xiaoming9090/2252f6b6f7e62fca20ecfbaac6f754f5)\n\nNote: Due to some unknown issue with the testing environment, please create a new `BathBuddy.released2` functions to fetch the amount of token already released.\n\n## Impact\n\nLoss of Fund for the users. BathToken LPs not able to receive the accured `bonusToken` that they are entitled to.\n\n## Recommended Mitigation Steps\n\nUpdate the reward mechanism to ensure that the `bonusTokens` are distribute fairly and rewards of each user are accured correctly.\n\nIn the above example, since Alice hold 50% of the shares in the pool throughout the majority of the reward period, she should be entitled to close to 50% to the rewards/bonus. Anyone who join the pool at the last hour of the reward period should only be entitled dust amount of `bonusToken`.\n\nAdditionally, \"spot\" (or current) share of the pool should not be used to determine the amount of `bonusToken` a user is entitled to as it is vulnerable to pool/share manipulation or flash-loan attack. Checkpointing mechanism should be implemented so that at the minimum, the user's amount of share in the previous block is used for determining the rewards. This make flash-loan attack infeasible as such attack has to happen within the same block/transaction.\n\nFor distributing bonus/rewards, I would suggest checking out a widely referenced [Synthetix's Reward](https://github.com/Synthetixio/synthetix/blob/develop/contracts/StakingRewards.sol) Contract as I think that it would be more relevant than OZ's Vesting Wallet for this particular purpose.\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-05-rubicon-contest",
  "Code": [
    {
      "filename": "contracts/peripheral_contracts/BathBuddy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./VestingWallet.sol\";\nimport \"../interfaces/IBathBuddy.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title BathBuddy\n * @dev *** This contract is a lightly modified version of Vesting Wallet by OpenZeppelin\n * @dev PLEASE FIND OZ DOCUMENTATION FOR THIS CONTRACT HERE: https://docs.openzeppelin.com/contracts/4.x/api/finance#VestingWallet\n *\n * @dev The only entrypoint used in the system is the release function called by the Bath Token. Extra care should be taken to make sure only the beneficiary can ever access the funds and send them to the withdrawer (and fee to self)\n *\n * @dev This contract handles the vesting ERC20 tokens for a given beneficiary. Custody of multiple tokens\n * can be given to this contract, which will release the token to the beneficiary following a given vesting schedule.\n * The vesting schedule is customizable through the {vestedAmount} function.\n *\n * Any token transferred to this contract will follow the vesting schedule as if they were locked from the beginning.\n * Consequently, if the vesting has already started, any amount of tokens sent to this contract will (at least partly)\n * be immediately releasable.\n */\ncontract BathBuddy is IBathBuddy {\n    using SafeMath for uint256;\n\n    // Public versions of the base VestingWallet storage\n    uint256 private _released;\n    mapping(address => uint256) private _erc20Released;\n\n    // Beneficiary must be the Bath Token vault recipient that will call release() for its withdrawer\n    address public beneficiary;\n    uint64 public start;\n    uint64 public duration;\n\n    /**\n     * @dev Set the beneficiary, start timestamp and vesting duration of the vesting wallet.\n     */\n    constructor(\n        address beneficiaryAddress,\n        uint64 startTimestamp,\n        uint64 durationSeconds\n    ) {\n        require(\n            beneficiaryAddress != address(0),\n            \"VestingWallet: beneficiary is zero address\"\n        );\n        beneficiary = beneficiaryAddress;\n        start = startTimestamp;\n        duration = durationSeconds;\n    }\n\n    // OZ\n    event EtherReleased(uint256 amount);\n    event ERC20Released(address indexed token, uint256 amount);\n\n    /// @notice Log bonus token reward event\n    event LogClaimBonusToken(\n        address indexed receiver,\n        address indexed callingPool,\n        uint256 amountReceived,\n        uint256 shares,\n        IERC20 bonusToken,\n        uint256 releasableAmountToWholePool\n    );\n\n    /**\n     * @dev The contract should be able to receive Eth.\n     */\n    receive() external payable {}\n\n    /**\n     * @dev Amount of eth already released\n     */\n    function released() public view returns (uint256) {\n        return _released;\n    }\n\n    /**\n     * @dev Amount of token already released\n     */\n    function released(address token) public view returns (uint256) {\n        return _erc20Released[token];\n    }\n\n    /// @inheritdoc IBathBuddy\n    /// @dev Added and modified release function. Should be the only callable release function\n    function release(\n        IERC20 token,\n        address recipient,\n        uint256 sharesWithdrawn,\n        uint256 initialTotalSupply,\n        uint256 poolFee\n    ) external override {\n        require(\n            msg.sender == beneficiary,\n            \"Caller is not the Bath Token beneficiary of these rewards\"\n        );\n        uint256 releasable = vestedAmount(\n            address(token),\n            uint64(block.timestamp)\n        ) - released(address(token));\n        if (releasable > 0) {\n            uint256 amount = releasable.mul(sharesWithdrawn).div(\n                initialTotalSupply\n            );\n            uint256 _fee = amount.mul(poolFee).div(10000);\n\n            // If FeeTo == address(this) then the fee is effectively accrued by the pool\n            // Assume the caller is the liquidity pool and they receive the fee\n            // Keep tokens here by not transfering the _fee anywhere, it is accrued to the Bath Token's Bath Buddy\n            // token.transfer(address(this), _fee);\n\n            uint256 amountWithdrawn = amount.sub(_fee);\n            token.transfer(recipient, amountWithdrawn);\n\n            _erc20Released[address(token)] += amount;\n            emit ERC20Released(address(token), amount);\n\n            emit LogClaimBonusToken(\n                recipient,\n                msg.sender,\n                amountWithdrawn,\n                sharesWithdrawn,\n                token,\n                releasable\n            );\n        }\n    }\n\n    /**\n     * @dev Calculates the amount of tokens that has already vested. Default implementation is a linear vesting curve.\n     */\n    function vestedAmount(address token, uint64 timestamp)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            _vestingSchedule(\n                IERC20(token).balanceOf(address(this)) + released(token),\n                timestamp\n            );\n    }\n\n    /**\n     * @dev Virtual implementation of the vesting formula. This returns the amount vested, as a function of time, for\n     * an asset given its total historical allocation.\n     */\n    function _vestingSchedule(uint256 totalAllocation, uint64 timestamp)\n        internal\n        view\n        returns (uint256)\n    {\n        if (timestamp < start) {\n            return 0;\n        } else if (timestamp > start + duration) {\n            return totalAllocation;\n        } else {\n            return (totalAllocation * (timestamp - start)) / duration;\n        }\n    }\n}"
    }
  ]
}