{
  "Title": "[L21] Lack of assert statement may produce unexpected slash",
  "Content": "In [line 78 of `SlasherUtil.sol`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/SlasherUtil.sol#L78), execution will `return` prematurely if the group of the validator being slashed has `address(0)`. This should be impossible, and represents a user who was not a member of any group at the time in question. The comment on the same line corroborates this by stating this `Should never be true`.\n\n\nConsider changing this line to `assert(group != address(0))`. This way, unexpected errors will revert, rather than making state changes to the code, and any errors in this regard will not result in [slashing a potentially innocent victim](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/SlasherUtil.sol#L68).\n\n\n***Update:** Fixed in [pull request #2891](https://github.com/celo-org/celo-monorepo/pull/2891). The statement was changed to an `assert`.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/governance/SlasherUtil.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"../common/Initializable.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/UsingPrecompiles.sol\";\n\ncontract SlasherUtil is Ownable, Initializable, UsingRegistry, UsingPrecompiles {\n  using SafeMath for uint256;\n\n  struct SlashingIncentives {\n    // Value of LockedGold to slash from the account.\n    uint256 penalty;\n    // Value of LockedGold to send to the observer.\n    uint256 reward;\n  }\n\n  SlashingIncentives public slashingIncentives;\n\n  event SlashingIncentivesSet(uint256 penalty, uint256 reward);\n\n  /**\n   * @notice Sets slashing incentives.\n   * @param penalty Penalty for the slashed signer.\n   * @param reward Reward that the observer gets.\n   */\n  function setSlashingIncentives(uint256 penalty, uint256 reward) public onlyOwner {\n    require(penalty > reward, \"Penalty has to be larger than reward\");\n    slashingIncentives.penalty = penalty;\n    slashingIncentives.reward = reward;\n    emit SlashingIncentivesSet(penalty, reward);\n  }\n\n  /**\n   * @notice Returns the group to be slashed.\n   * @param validator Validator that was slashed.\n   * @param blockNumber Block number associated with slashing.\n   * @param groupMembershipHistoryIndex Index used for history lookup.\n   * @return Group to be slashed.\n   */\n  function groupMembershipAtBlock(\n    address validator,\n    uint256 blockNumber,\n    uint256 groupMembershipHistoryIndex\n  ) internal view returns (address) {\n    uint256 epoch = getEpochNumberOfBlock(blockNumber);\n    require(epoch != 0, \"Cannot slash on epoch 0\");\n    // Use `epoch-1` because the elections were on that epoch\n    return\n      getValidators().groupMembershipInEpoch(validator, epoch.sub(1), groupMembershipHistoryIndex);\n  }\n\n  function performSlashing(\n    address validator,\n    address recipient,\n    uint256 startBlock,\n    uint256 groupMembershipHistoryIndex,\n    address[] memory validatorElectionLessers,\n    address[] memory validatorElectionGreaters,\n    uint256[] memory validatorElectionIndices,\n    address[] memory groupElectionLessers,\n    address[] memory groupElectionGreaters,\n    uint256[] memory groupElectionIndices\n  ) internal {\n    ILockedGold lockedGold = getLockedGold();\n    lockedGold.slash(\n      validator,\n      slashingIncentives.penalty,\n      recipient,\n      slashingIncentives.reward,\n      validatorElectionLessers,\n      validatorElectionGreaters,\n      validatorElectionIndices\n    );\n    address group = groupMembershipAtBlock(validator, startBlock, groupMembershipHistoryIndex);\n    if (group == address(0)) return; // Should never be true\n    lockedGold.slash(\n      group,\n      slashingIncentives.penalty,\n      recipient,\n      slashingIncentives.reward,\n      groupElectionLessers,\n      groupElectionGreaters,\n      groupElectionIndices\n    );\n    IValidators validators = getValidators();\n    validators.forceDeaffiliateIfValidator(validator);\n    validators.halveSlashingMultiplier(group);\n  }\n\n}"
    },
    {
      "filename": "packages/protocol/contracts/governance/SlasherUtil.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"../common/Initializable.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/UsingPrecompiles.sol\";\n\ncontract SlasherUtil is Ownable, Initializable, UsingRegistry, UsingPrecompiles {\n  using SafeMath for uint256;\n\n  struct SlashingIncentives {\n    // Value of LockedGold to slash from the account.\n    uint256 penalty;\n    // Value of LockedGold to send to the observer.\n    uint256 reward;\n  }\n\n  SlashingIncentives public slashingIncentives;\n\n  event SlashingIncentivesSet(uint256 penalty, uint256 reward);\n\n  /**\n   * @notice Sets slashing incentives.\n   * @param penalty Penalty for the slashed signer.\n   * @param reward Reward that the observer gets.\n   */\n  function setSlashingIncentives(uint256 penalty, uint256 reward) public onlyOwner {\n    require(penalty > reward, \"Penalty has to be larger than reward\");\n    slashingIncentives.penalty = penalty;\n    slashingIncentives.reward = reward;\n    emit SlashingIncentivesSet(penalty, reward);\n  }\n\n  /**\n   * @notice Returns the group to be slashed.\n   * @param validator Validator that was slashed.\n   * @param blockNumber Block number associated with slashing.\n   * @param groupMembershipHistoryIndex Index used for history lookup.\n   * @return Group to be slashed.\n   */\n  function groupMembershipAtBlock(\n    address validator,\n    uint256 blockNumber,\n    uint256 groupMembershipHistoryIndex\n  ) internal view returns (address) {\n    uint256 epoch = getEpochNumberOfBlock(blockNumber);\n    require(epoch != 0, \"Cannot slash on epoch 0\");\n    // Use `epoch-1` because the elections were on that epoch\n    return\n      getValidators().groupMembershipInEpoch(validator, epoch.sub(1), groupMembershipHistoryIndex);\n  }\n\n  function performSlashing(\n    address validator,\n    address recipient,\n    uint256 startBlock,\n    uint256 groupMembershipHistoryIndex,\n    address[] memory validatorElectionLessers,\n    address[] memory validatorElectionGreaters,\n    uint256[] memory validatorElectionIndices,\n    address[] memory groupElectionLessers,\n    address[] memory groupElectionGreaters,\n    uint256[] memory groupElectionIndices\n  ) internal {\n    ILockedGold lockedGold = getLockedGold();\n    lockedGold.slash(\n      validator,\n      slashingIncentives.penalty,\n      recipient,\n      slashingIncentives.reward,\n      validatorElectionLessers,\n      validatorElectionGreaters,\n      validatorElectionIndices\n    );\n    address group = groupMembershipAtBlock(validator, startBlock, groupMembershipHistoryIndex);\n    if (group == address(0)) return; // Should never be true\n    lockedGold.slash(\n      group,\n      slashingIncentives.penalty,\n      recipient,\n      slashingIncentives.reward,\n      groupElectionLessers,\n      groupElectionGreaters,\n      groupElectionIndices\n    );\n    IValidators validators = getValidators();\n    validators.forceDeaffiliateIfValidator(validator);\n    validators.halveSlashingMultiplier(group);\n  }\n\n}"
    }
  ]
}