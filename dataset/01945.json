{
  "Title": "M-13: GeneralRepay#repayJUSD returns excess USDC to `to` address rather than msg.sender",
  "Content": "# Issue M-13: GeneralRepay#repayJUSD returns excess USDC to `to` address rather than msg.sender \n\nSource: https://github.com/sherlock-audit/2023-04-jojo-judging/issues/459 \n\n## Found by \n0x52\n## Summary\n\nWhen using GeneralRepay#repayJUSD to repay a position on JUSDBank, any excess tokens are sent to the `to` address. While this is fine for users that are repaying their own debt this is not good when repaying for another user. Additionally, specifying an excess to repay is basically a requirement when attempting to pay off the entire balance of an account. This combination of factors will make it very likely that funds will be refunded incorrectly.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-04-jojo/blob/main/JUSDV1/src/Impl/flashloanImpl/GeneralRepay.sol#L65-L69\n\n            IERC20(USDC).approve(jusdExchange, borrowBalance);\n            IJUSDExchange(jusdExchange).buyJUSD(borrowBalance, address(this));\n            IERC20(USDC).safeTransfer(to, USDCAmount - borrowBalance);\n            JUSDAmount = borrowBalance;\n        }\n\nAs seen above, when there is an excess amount of USDC, it is transferred to the `to` address which is the recipient of the repay. When to != msg.sender all excess will be sent to the recipient of the repay rather than being refunded to the caller.\n\n## Impact\n\nRefund is sent to the wrong address if to != msg.sender\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-jojo/blob/main/JUSDV1/src/Impl/flashloanImpl/GeneralRepay.sol#L32-L73\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nEither send the excess back to the caller or allow them to specify where the refund goes\n\n\n\n## Discussion\n\n**JoscelynFarr**\n\nfix link: \nhttps://github.com/JOJOexchange/JUSDV1/commit/7382ce40dd54f0a396fb5d3f13ab3cfede0493e2\n\n**IAm0x52**\n\nFix looks good. Excess USDC is now refunded to msg.sender\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/70",
  "Code": [
    {
      "filename": "JUSDV1/src/Impl/flashloanImpl/GeneralRepay.sol",
      "content": "/*\n    Copyright 2022 JOJO Exchange\n    SPDX-License-Identifier: BUSL-1.1*/\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../../src/Interface/IJUSDBank.sol\";\nimport \"../../../src/Interface/IJUSDExchange.sol\";\n\npragma solidity 0.8.9;\n\ncontract GeneralRepay {\n    address public immutable USDC;\n    address public jusdBank;\n    address public jusdExchange;\n    address public immutable JUSD;\n\n    using SafeERC20 for IERC20;\n\n    constructor(\n        address _jusdBank,\n        address _jusdExchange,\n        address _USDC,\n        address _JUSD\n    ) {\n        jusdBank = _jusdBank;\n        jusdExchange = _jusdExchange;\n        USDC = _USDC;\n        JUSD = _JUSD;\n    }\n\n    function repayJUSD(\n        address asset,\n        uint256 amount,\n        address to,\n        bytes memory param\n    ) external {\n        IERC20(asset).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 minReceive;\n        if (asset != USDC) {\n            (address approveTarget, address swapTarget, uint256 minAmount, bytes memory data) = abi\n                .decode(param, (address, address, uint256, bytes));\n            IERC20(asset).approve(approveTarget, amount);\n            (bool success, ) = swapTarget.call(data);\n            if (success == false) {\n                assembly {\n                    let ptr := mload(0x40)\n                    let size := returndatasize()\n                    returndatacopy(ptr, 0, size)\n                    revert(ptr, size)\n                }\n            }\n            minReceive = minAmount;\n        }\n\n        uint256 USDCAmount = IERC20(USDC).balanceOf(address(this));\n        require(USDCAmount >= minReceive, \"receive amount is too small\");\n        uint256 JUSDAmount = USDCAmount;\n\n        uint256 borrowBalance = IJUSDBank(jusdBank).getBorrowBalance(to);\n        if (USDCAmount <= borrowBalance) {\n            IERC20(USDC).approve(jusdExchange, USDCAmount);\n            IJUSDExchange(jusdExchange).buyJUSD(USDCAmount, address(this));\n        } else {\n            IERC20(USDC).approve(jusdExchange, borrowBalance);\n            IJUSDExchange(jusdExchange).buyJUSD(borrowBalance, address(this));\n            IERC20(USDC).safeTransfer(to, USDCAmount - borrowBalance);\n            JUSDAmount = borrowBalance;\n        }\n\n        IERC20(JUSD).approve(jusdBank, JUSDAmount);\n        IJUSDBank(jusdBank).repay(JUSDAmount, to);\n    }\n}"
    },
    {
      "filename": "JUSDV1/src/Impl/flashloanImpl/GeneralRepay.sol",
      "content": "/*\n    Copyright 2022 JOJO Exchange\n    SPDX-License-Identifier: BUSL-1.1*/\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../../src/Interface/IJUSDBank.sol\";\nimport \"../../../src/Interface/IJUSDExchange.sol\";\n\npragma solidity 0.8.9;\n\ncontract GeneralRepay {\n    address public immutable USDC;\n    address public jusdBank;\n    address public jusdExchange;\n    address public immutable JUSD;\n\n    using SafeERC20 for IERC20;\n\n    constructor(\n        address _jusdBank,\n        address _jusdExchange,\n        address _USDC,\n        address _JUSD\n    ) {\n        jusdBank = _jusdBank;\n        jusdExchange = _jusdExchange;\n        USDC = _USDC;\n        JUSD = _JUSD;\n    }\n\n    function repayJUSD(\n        address asset,\n        uint256 amount,\n        address to,\n        bytes memory param\n    ) external {\n        IERC20(asset).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 minReceive;\n        if (asset != USDC) {\n            (address approveTarget, address swapTarget, uint256 minAmount, bytes memory data) = abi\n                .decode(param, (address, address, uint256, bytes));\n            IERC20(asset).approve(approveTarget, amount);\n            (bool success, ) = swapTarget.call(data);\n            if (success == false) {\n                assembly {\n                    let ptr := mload(0x40)\n                    let size := returndatasize()\n                    returndatacopy(ptr, 0, size)\n                    revert(ptr, size)\n                }\n            }\n            minReceive = minAmount;\n        }\n\n        uint256 USDCAmount = IERC20(USDC).balanceOf(address(this));\n        require(USDCAmount >= minReceive, \"receive amount is too small\");\n        uint256 JUSDAmount = USDCAmount;\n\n        uint256 borrowBalance = IJUSDBank(jusdBank).getBorrowBalance(to);\n        if (USDCAmount <= borrowBalance) {\n            IERC20(USDC).approve(jusdExchange, USDCAmount);\n            IJUSDExchange(jusdExchange).buyJUSD(USDCAmount, address(this));\n        } else {\n            IERC20(USDC).approve(jusdExchange, borrowBalance);\n            IJUSDExchange(jusdExchange).buyJUSD(borrowBalance, address(this));\n            IERC20(USDC).safeTransfer(to, USDCAmount - borrowBalance);\n            JUSDAmount = borrowBalance;\n        }\n\n        IERC20(JUSD).approve(jusdBank, JUSDAmount);\n        IJUSDBank(jusdBank).repay(JUSDAmount, to);\n    }\n}"
    }
  ]
}