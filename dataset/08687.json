{
  "Title": "[M-12] Sandwich attacks are possible as there is no slippage control option in Marketplace and in Lender yield swaps",
  "Content": "_Submitted by hyh, also found by datapunk, Alex the Entreprenerd, and unforgiven_\n\n<https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/marketplace/MarketPlace.sol#L131-L189>\n\n<https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L634-L657>\n\n### Vulnerability Details\n\nSwapping function in Marketplace and Lender's yield() can be sandwiched as there is no slippage control option. Trades can happen at a manipulated price and end up receiving fewer tokens than current market price dictates.\n\nPlacing severity to be medium as those are system core operations, while funds there can be substantial, so sandwich attacks are often enough economically viable and thus probable, while they result in a partial fund loss.\n\n### Proof of Concept\n\nAll four swapping functions of Marketplace do not allow for slippage control:\n\n<https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/marketplace/MarketPlace.sol#L131-L189>\n\n```solidity\n    /// @notice sells the PT for the PT via the pool\n    /// @param u address of the underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of PT to swap\n    /// @return uint128 amount of PT bought\n    function sellPrincipalToken(\n        address u,\n        uint256 m,\n        uint128 a\n    ) external returns (uint128) {\n        IPool pool = IPool(pools[u][m]);\n        Safe.transfer(IERC20(address(pool.fyToken())), address(pool), a);\n        return pool.sellFYToken(msg.sender, pool.sellFYTokenPreview(a));\n    }\n\n    /// @notice buys the underlying for the PT via the pool\n    /// @param u address of the underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to sell\n    /// @return uint128 amount of PT received\n    function buyPrincipalToken(\n        address u,\n        uint256 m,\n        uint128 a\n    ) external returns (uint128) {\n        IPool pool = IPool(pools[u][m]);\n        Safe.transfer(IERC20(address(pool.base())), address(pool), a);\n        return pool.buyFYToken(msg.sender, pool.buyFYTokenPreview(a), a);\n    }\n\n    /// @notice sells the underlying for the PT via the pool\n    /// @param u address of the underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying to swap\n    /// @return uint128 amount of underlying sold\n    function sellUnderlying(\n        address u,\n        uint256 m,\n        uint128 a\n    ) external returns (uint128) {\n        IPool pool = IPool(pools[u][m]);\n        Safe.transfer(IERC20(address(pool.base())), address(pool), a);\n        return pool.sellBase(msg.sender, pool.sellBasePreview(a));\n    }\n\n    /// @notice buys the underlying for the PT via the pool\n    /// @param u address of the underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of PT to swap\n    /// @return uint128 amount of underlying bought\n    function buyUnderlying(\n        address u,\n        uint256 m,\n        uint128 a\n    ) external returns (uint128) {\n        IPool pool = IPool(pools[u][m]);\n        Safe.transfer(IERC20(address(pool.fyToken())), address(pool), a);\n        return pool.buyBase(msg.sender, pool.buyBasePreview(a), a);\n    }\n```\n\nSimilarly, Lender's yield does the swapping without the ability to control the slippage:\n\n<https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L634-L657>\n\n```solidity\n    /// @notice transfers excess funds to yield pool after principal tokens have been lent out\n    /// @dev this method is only used by the yield, illuminate and swivel protocols\n    /// @param u address of an underlying asset\n    /// @param y the yield pool to lend to\n    /// @param a the amount of underlying tokens to lend\n    /// @param r the receiving address for PTs\n    /// @return uint256 the amount of tokens sent to the yield pool\n    function yield(\n        address u,\n        address y,\n        uint256 a,\n        address r\n    ) internal returns (uint256) {\n        // preview exact swap slippage on yield\n        uint128 returned = IYield(y).sellBasePreview(Cast.u128(a));\n\n        // send the remaing amount to the given yield pool\n        Safe.transfer(IERC20(u), y, a);\n\n        // lend out the remaining tokens in the yield pool\n        IYield(y).sellBase(r, returned);\n\n        return returned;\n    }\n```\n\n#### Recommended Mitigation Steps\n\nConsider adding minimum accepted return argument to the five mentioned functions and condition execution success on it so the caller can control for the realized slippage and sustain the sandwich attacks to an extent.\n\n**[sourabhmarathe (Illuminate) confirmed](https://github.com/code-423n4/2022-06-illuminate-findings/issues/389)** \n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-06-illuminate",
  "Code": [
    {
      "filename": "marketplace/MarketPlace.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Interfaces.sol';\nimport './ERC5095.sol';\nimport './Safe.sol';\n\n/// @title MarketPlace\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice This contract is in charge of managing the avaialable principals for each loan market.\n/// @notice In addition, this contract routes swap orders between metaprincipal tokens and their respective underlying to YieldSpace pools.\ncontract MarketPlace {\n    /// @notice the available principals\n    /// @dev the order of this enum is used to select principals from the markets\n    /// mapping (e.g. Illuminate => 0, Swivel => 1, and so on)\n    enum Principals {\n        Illuminate,\n        Swivel,\n        Yield,\n        Element,\n        Pendle,\n        Tempus,\n        Sense,\n        Apwine,\n        Notional\n    }\n\n    error Exists(string);\n    error Unauthorized();\n    error Invalid(string);\n\n    /// @notice markets are defined by a market pair which point to a fixed length array of principal token addresses. \n    /// @notice The principal tokens those addresses represent correspond to their Principals enum value, thus the array should be ordered in that way\n    mapping(address => mapping(uint256 => address[9])) public markets;\n\n    /// @notice pools map markets to their respective YieldSpace pools for the MetaPrincipal token\n    mapping(address => mapping(uint256 => address)) public pools;\n\n    /// @notice address that is allowed to create markets, set fees, etc. It is commonly used in the authorized modifier.\n    address public admin;\n    /// @notice address of the deployed redeemer contract\n    address public immutable redeemer;\n    /// @notice address of the deployed lender contract\n    address public immutable lender;\n\n    /// @notice emitted upon the creation of a new market\n    event CreateMarket(address indexed underlying, uint256 indexed maturity);\n\n    /// @notice intializes the MarketPlace contract\n    /// @param r address of the deployed redeemer contract\n    /// @param l address of the deployed lender contract\n    constructor(address r, address l) {\n        admin = msg.sender;\n        redeemer = r;\n        lender = l;\n    }\n\n    /// @notice creates a new market for the given underlying token and maturity\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param t principal token addresses for this market minus the illuminate principal (which is added here)\n    /// @param n name for the illuminate token\n    /// @param s symbol for the illuminate token\n    /// @param d decimals for the illuminate token\n    /// @return bool true if successful\n    function createMarket(\n        address u,\n        uint256 m,\n        address[8] memory t,\n        string calldata n,\n        string calldata s,\n        uint8 d\n    ) external authorized(admin) returns (bool) {\n        if (markets[u][m][uint256(Principals.Illuminate)] != address(0)) {\n            revert Exists('market already exists');\n        }\n\n        // deploy an illuminate token with this new market\n        address iToken = address(new ERC5095(u, m, redeemer, lender, n, s, d));\n\n        // the market will have the illuminate principal as its zeroth item, thus t should have Principals[1] as [0]\n        address[9] memory market = [iToken, t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7]];\n\n        // set the market\n        markets[u][m] = market;\n\n        emit CreateMarket(u, m);\n        return true;\n    }\n\n    /// @notice allows the admin to set an individual market\n    /// @param p enum value of the principal token\n    /// @param u underlying token address\n    /// @param m maturity timestamp for the market\n    /// @param a address of the new market\n    /// @return bool true if successful\n    function setPrincipal(uint8 p, address u, uint256 m, address a) external authorized(admin) returns (bool) {\n        if (markets[u][m][p] != address(0)) {\n            revert Exists('Market already exists');\n        }\n        markets[u][m][p] = a;\n        return true;\n    }\n\n    /// @notice sets the admin address\n    /// @param a Address of a new admin\n    /// @return bool true if successful\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        return true;\n    }\n\n    /// @notice sets the address for a pool\n    /// @param u address of the underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a address of the pool\n    /// @return bool true if successful\n    function setPool(\n        address u,\n        uint256 m,\n        address a\n    ) external authorized(admin) returns (bool) {\n        if (pools[u][m] != address(0)) {\n            revert Exists('pool already exists');\n        }\n        pools[u][m] = a;\n        return true;\n    }\n\n    /// @notice sells the PT for the PT via the pool\n    /// @param u address of the underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of PT to swap\n    /// @return uint128 amount of PT bought\n    function sellPrincipalToken(\n        address u,\n        uint256 m,\n        uint128 a\n    ) external returns (uint128) {\n        IPool pool = IPool(pools[u][m]);\n        Safe.transfer(IERC20(address(pool.fyToken())), address(pool), a);\n        return pool.sellFYToken(msg.sender, pool.sellFYTokenPreview(a));\n    }\n\n    /// @notice buys the underlying for the PT via the pool\n    /// @param u address of the underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to sell\n    /// @return uint128 amount of PT received\n    function buyPrincipalToken(\n        address u,\n        uint256 m,\n        uint128 a\n    ) external returns (uint128) {\n        IPool pool = IPool(pools[u][m]);\n        Safe.transfer(IERC20(address(pool.base())), address(pool), a);\n        return pool.buyFYToken(msg.sender, pool.buyFYTokenPreview(a), a);\n    }\n\n    /// @notice sells the underlying for the PT via the pool\n    /// @param u address of the underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying to swap\n    /// @return uint128 amount of underlying sold\n    function sellUnderlying(\n        address u,\n        uint256 m,\n        uint128 a\n    ) external returns (uint128) {\n        IPool pool = IPool(pools[u][m]);\n        Safe.transfer(IERC20(address(pool.base())), address(pool), a);\n        return pool.sellBase(msg.sender, pool.sellBasePreview(a));\n    }\n\n    /// @notice buys the underlying for the PT via the pool\n    /// @param u address of the underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of PT to swap\n    /// @return uint128 amount of underlying bought\n    function buyUnderlying(\n        address u,\n        uint256 m,\n        uint128 a\n    ) external returns (uint128) {\n        IPool pool = IPool(pools[u][m]);\n        Safe.transfer(IERC20(address(pool.fyToken())), address(pool), a);\n        return pool.buyBase(msg.sender, pool.buyBasePreview(a), a);\n    }\n\n    /// @notice mint liquidity tokens in exchange for adding underlying and PT\n    /// @dev amount of liquidity tokens to mint is calculated from the amount of unaccounted for PT in this contract.\n    /// @dev A proportional amount of underlying tokens need to be present in this contract, also unaccounted for.\n    /// @param u the address of the underlying token\n    /// @param m the maturity of the principal token\n    /// @param uA the underlying amount being sent\n    /// @param ptA the principal token amount being sent\n    /// @param minRatio minimum ratio of underlying to PT in the pool.\n    /// @param maxRatio maximum ratio of underlying to PT in the pool.\n    /// @return uint256 the amount of liquidity tokens minted.\n    function mint(address u, uint256 m, uint256 uA, uint256 ptA, uint256 minRatio, uint256 maxRatio) external returns (uint256, uint256, uint256) {\n        IPool pool = IPool(pools[u][m]);\n        Safe.transferFrom(ERC20(address(pool.base())), msg.sender, address(pool), uA);  \n        Safe.transferFrom(ERC20(address(pool.fyToken())), msg.sender, address(pool), ptA);\n        return pool.mint(msg.sender, msg.sender, minRatio, maxRatio);\n    }\n\n    /// @notice Mint liquidity tokens in exchange for adding only underlying\n    /// @dev amount of liquidity tokens is calculated from the amount of PT to buy from the pool,\n    /// plus the amount of unaccounted for PT in this contract.\n    /// @param u the address of the underlying token\n    /// @param m the maturity of the principal token\n    /// @param a the underlying amount being sent\n    /// @param ptBought amount of `PT` being bought in the Pool, from this we calculate how much underlying it will be taken in.\n    /// @param minRatio minimum ratio of underlying to PT in the pool.\n    /// @param maxRatio maximum ratio of underlying to PT in the pool.\n    /// @return uint256 the amount of liquidity tokens minted\n    function mintWithUnderlying(address u, uint256 m, uint256 a, uint256 ptBought, uint256 minRatio, uint256 maxRatio) external returns (uint256, uint256, uint256) {\n        IPool pool = IPool(pools[u][m]);\n        Safe.transferFrom(ERC20(address(pool.base())), msg.sender, address(pool), a);\n        return pool.mintWithBase(msg.sender, msg.sender, ptBought, minRatio, maxRatio);\n    }\n\n    /// @notice burn liquidity tokens in exchange for underlying and PT.\n    /// @param u the address of the underlying token\n    /// @param m the maturity of the principal token\n    /// @param minRatio minimum ratio of underlying to PT in the pool.\n    /// @param maxRatio maximum ratio of underlying to PT in the pool.\n    /// @return uint256 amount of tokens burned and returned (tokensBurned, underlyings, PTs).\n    function burn(address u, uint256 m, uint256 minRatio, uint256 maxRatio) external returns (uint256, uint256, uint256) {\n        return IPool(pools[u][m]).burn(msg.sender, msg.sender, minRatio, maxRatio);\n    }\n\n    /// @notice burn liquidity tokens in exchange for underlying.\n    /// @param u the address of the underlying token\n    /// @param m the maturity of the principal token\n    /// @param minRatio minimum ratio of underlying to PT in the pool.\n    /// @param maxRatio minimum ratio of underlying to PT in the pool.\n    /// @return uint256 amount of underlying tokens returned\n    /// @return uint256 amount of PT tokens sent to the pool\n    function burnForUnderlying(address u, uint256 m, uint256 minRatio, uint256 maxRatio) external returns (uint256, uint256) {\n        return IPool(pools[u][m]).burnForBase(msg.sender, minRatio, maxRatio);\n    }\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Unauthorized();\n        }\n        _;\n    }\n}"
    },
    {
      "filename": "lender/Lender.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Interfaces.sol';\nimport './MarketPlace.sol'; // library of market place specific constructs\nimport './Swivel.sol'; // library of swivel specific constructs\nimport './Element.sol'; // library of element specific constructs\nimport './Safe.sol';\nimport './Cast.sol';\n\n/// @title Lender.sol\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice The lender contract executes loans on behalf of users. \n/// @notice The contract holds the principal tokens for each market and mints an ERC-5095 position to users to represent their lent positions.\ncontract Lender {\n    error Unauthorized();\n    error NotEqual(string);\n    error Exists(address);\n    error Invalid(string);\n\n    /// @notice minimum amount of time the admin must wait before executing a withdrawl\n    uint256 constant public HOLD = 3 days;\n\n    /// @notice address that is allowed to create markets, set fees, etc. It is commonly used in the authorized modifier.\n    address public admin;\n    /// @notice address of the MarketPlace.sol contract, used to access the markets mapping\n    address public marketPlace;\n    /// @notice mapping that determines if a principal may be used by a lender\n    mapping(uint8 => bool) public paused;\n\n    /// @notice third party contract needed to lend on Swivel\n    address public swivelAddr;\n    /// @notice third party contract needed to lend on Pendle\n    address public immutable pendleAddr;\n    /// @notice third party contract needed to lend on Tempus\n    address public immutable tempusAddr;\n\n    /// @notice this value determines the amount of fees paid on loans\n    uint256 public feenominator;\n\n    /// @notice maps underlying tokens to the amount of fees accumulated for that token\n    mapping(address => uint256) public fees;\n    /// @notice maps a token address to a point in time, a hold, after which a withdrawal can be made\n    mapping (address => uint256) public withdrawals;\n\n    /// @notice emitted upon executed lend\n    event Lend(uint8 principal, address indexed underlying, uint256 indexed maturity, uint256 returned);\n    /// @notice emitted upon minted ERC5095 to user\n    event Mint(uint8 principal, address indexed underlying, uint256 indexed maturity, uint256 amount);\n    /// @notice emitted on token withdrawal scheduling\n    event ScheduleWithdrawal(address indexed token, uint256 hold);\n    /// @notice emitted on token withdrawal blocking\n    event BlockWithdrawal(address indexed token);\n    /// @notice emitted on a change to the feenominators array\n\n    /// @notice initializes the Lender contract\n    /// @param s the swivel contract\n    /// @param p the pendle contract\n    /// @param t the tempus contract\n    constructor(\n        address s,\n        address p,\n        address t\n    ) {\n        admin = msg.sender;\n        swivelAddr = s;\n        pendleAddr = p;\n        tempusAddr = t;\n        feenominator = 1000;\n    }\n\n    /// @notice approves the redeemer contract to spend the principal tokens held by the lender contract.\n    /// @param u underlying token's address, used to define the market being approved\n    /// @param m maturity of the underlying token, used to define the market being approved\n    /// @param r the address being approved, in this case the redeemer contract\n    /// @return bool true if the approval was successful, false otherwise\n    function approve(\n        address u,\n        uint256 m,\n        address r\n    ) external authorized(admin) returns (bool) {\n        // max is the maximum integer value for a 256 unsighed integer\n        uint256 max = 2**256 - 1;\n\n        // approve the underlying for max per given principal\n        for (uint8 i; i < 9; ) {\n            // get the principal token's address\n            address token = IMarketPlace(marketPlace).markets(u, m, i);\n            // check that the token is defined for this particular market\n            if (token != address(0)) {\n                // max approve the token\n                Safe.approve(IERC20(token), r, max);\n            }\n            unchecked {\n                i++;\n            }\n        }\n        return true;\n    }\n\n    /// @notice bulk approves the usage of addresses at the given ERC20 addresses. \n    /// @dev the lengths of the inputs must match because the arrays are paired by index\n    /// @param u array of ERC20 token addresses that will be approved on\n    /// @param a array of addresses that will be approved\n    /// @return true if successful\n    function approve(address[] calldata u, address[] calldata a) external authorized(admin) returns (bool) {\n        uint256 len = u.length;\n        if (len != a.length) {\n            revert NotEqual('array length');\n        }\n        uint256 max = 2**256 - 1;\n\n        for (uint256 i; i < len; ) {\n            IERC20 uToken = IERC20(u[i]);\n            if (address(0) != (address(uToken))) {\n                Safe.approve(uToken, a[i], max);\n            }\n            unchecked {\n                i++;\n            }\n        }\n        return true;\n    }\n\n    /// @notice sets the admin address\n    /// @param a address of a new admin\n    /// @return bool true if successful\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        return true;\n    }\n\n    /// @notice sets the feenominator to the given value\n    /// @param f the new value of the feenominator, fees are not collected when the feenominator is 0\n    /// @return bool true if successful\n    function setFee(uint256 f) external authorized(admin) returns (bool) {\n        feenominator = f;\n        return true;\n    }\n\n    /// @notice sets the address of the marketplace contract which contains the addresses of all the fixed rate markets\n    /// @param m the address of the marketplace contract\n    /// @return bool true if the address was set, false otherwise\n    function setMarketPlace(address m) external authorized(admin) returns (bool) {\n        if (marketPlace != address(0)) {\n            revert Exists(marketPlace);\n        }\n        marketPlace = m;\n        return true;\n    }\n\n    /// @notice sets the feenominator to the given value\n    /// @param s the address of the Swivel.sol Router\n    /// @return bool true if successful\n    function setSwivel(address s) external authorized(admin) returns (bool) {\n        swivelAddr = s;\n        return true;\n    }\n\n    /// @notice mint swaps the sender's principal tokens for illuminate's ERC5095 tokens in effect, this opens a new fixed rate position for the sender on illuminate\n    /// @param p value of a specific principal according to the MarketPlace Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount being minted\n    /// @return bool true if the mint was successful, false otherwise\n    function mint(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a\n    ) public returns (bool) {\n        //use market interface to fetch the market for the given market pair\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n        //use safe transfer lib and ERC interface...\n        Safe.transferFrom(IERC20(principal), msg.sender, address(this), a);\n        //use ERC5095 interface...\n        IERC5095(principalToken(u, m)).mint(msg.sender, a);\n\n        emit Mint(p, u, m, a);\n\n        return true;\n    }\n\n    /// @notice lend method signature for both illuminate and yield\n    /// @param p value of a specific principal according to the MarketPlace Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param y yieldspace pool that will execute the swap for the principal token\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        address y\n    ) public unpaused(p) returns (uint256) {\n        // check the principal is illuminate or yield\n        if (p != uint8(MarketPlace.Principals.Illuminate) && p != uint8(MarketPlace.Principals.Yield)) {\n            revert Invalid('principal');\n        }\n\n        // uses yield token interface...\n        IYield pool = IYield(y);\n\n        // the yield token must match the market pair\n        if (address(pool.base()) != u) {\n            revert NotEqual('underlying');\n        } else if (pool.maturity() > m) {\n            revert NotEqual('maturity');\n        }\n\n        // transfer from user to illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        if (p == uint8(MarketPlace.Principals.Yield)) {\n            // Purchase yield PTs to lender.sol (address(this))\n            uint256 returned = yield(u, y, a - calculateFee(a), address(this));\n            // Mint and distribute equivalent illuminate PTs\n            IERC5095(principalToken(u, m)).mint(msg.sender, returned);\n            \n            emit Lend(p, u, m, returned);\n\n            return returned;\n        }\n        else {\n            // Purchase illuminate PTs directly to msg.sender\n            uint256 returned = yield(u, y, a - calculateFee(a), msg.sender);\n\n            emit Lend(p, u, m, returned);\n\n            return returned;\n        }\n    }\n\n    /// @notice lend method signature for swivel\n    /// @dev lends to yield pool. remaining balance is sent to the yield pool\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a array of amounts of underlying tokens lent to each order in the orders array\n    /// @param y yield pool\n    /// @param o array of swivel orders being filled\n    /// @param s array of signatures for each order in the orders array\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256[] memory a,\n        address y,\n        Swivel.Order[] calldata o,\n        Swivel.Components[] calldata s\n    ) public unpaused(p) returns (uint256) {\n\n        // lent represents the number of underlying tokens lent\n        uint256 lent;\n        {\n            // returned represents the number of underlying tokens to lend to yield\n            uint256 returned;\n\n            uint256 totalFee;\n            // iterate through each order a calculate the total lent and returned\n            for (uint256 i = 0; i < o.length; ) {\n                Swivel.Order memory order = o[i];\n                // Require the Swivel order provided matches the underlying and maturity market provided\n                if (order.underlying != u) {\n                    revert NotEqual('underlying');\n                } else if (order.maturity > m) {\n                    revert NotEqual('maturity');\n                }\n\n                {\n                    uint256 amount = a[i];\n                    // Determine the fee\n                    uint256 fee = calculateFee(amount);\n                    // Track accumulated fees\n                    totalFee += fee;\n                    // Amount lent for this order\n                    uint256 amountLent = amount - fee;\n                    // Sum the total amount lent to Swivel (amount of ERC5095 tokens to mint) minus fees\n                    lent += amountLent;\n                    // Sum the total amount of premium paid from Swivel (amount of underlying to lend to yield)\n                    returned += amountLent * order.premium / order.principal;\n                }\n\n                unchecked {\n                    i++;\n                }\n            }\n      \n            // Track accumulated fee\n            fees[u] += totalFee;\n\n            // transfer underlying tokens from user to illuminate\n            Safe.transferFrom(IERC20(u), msg.sender, address(this), lent);\n            // fill the orders on swivel protocol\n            ISwivel(swivelAddr).initiate(o, a, s);\n\n            yield(u, y, returned, address(this));\n        }\n        emit Lend(p, u, m, lent);\n        return lent;\n    }\n\n    /// @notice lend method signature for element\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of principal tokens to lend\n    /// @param r minimum amount to return, this puts a cap on allowed slippage\n    /// @param d deadline is a timestamp by which the swap must be executed deadline is a timestamp by which the swap must be executed\n    /// @param e element pool that is lent to\n    /// @param i the id of the pool\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d,\n        address e,\n        bytes32 i\n    ) public unpaused(p) returns (uint256) {\n        // Get the principal token for this market for element\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n\n        // the element token must match the market pair\n        if (IElementToken(principal).underlying() != u) {\n            revert NotEqual('underlying');\n        } else if (IElementToken(principal).unlockTimestamp() > m) {\n            revert NotEqual('maturity');\n        }\n        // Transfer underlying token from user to illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        // Track the accumulated fees\n        fees[u] += calculateFee(a);\n\n        uint256 purchased;\n        {\n            // Create the variables needed to execute an element swap\n            Element.FundManagement memory fund = Element.FundManagement({\n                sender: address(this),\n                recipient: payable(address(this)),\n                fromInternalBalance: false,\n                toInternalBalance: false\n            });\n\n            Element.SingleSwap memory swap = Element.SingleSwap({\n                userData: '0x00000000000000000000000000000000000000000000000000000000000000',\n                poolId: i,\n                amount: a - calculateFee(a),\n                kind: Element.SwapKind.In,\n                assetIn: Any(u),\n                assetOut: Any(principal)\n            });\n\n            // Conduct the swap on element\n            purchased = IElement(e).swap(swap, fund, r, d);\n        }\n\n        emit Lend(p, u, m, purchased);\n        return purchased;\n    }\n\n    /// @notice lend method signature for pendle\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of principal tokens to lend\n    /// @param r minimum amount to return, this puts a cap on allowed slippage\n    /// @param d deadline is a timestamp by which the swap must be executed\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d\n    ) public unpaused(p) returns (uint256) {\n\n        // Instantiate market and tokens\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n        IPendleToken token = IPendleToken(principal);\n\n        // confirm that we are in the correct market\n        if (token.yieldToken() != u) {\n            revert NotEqual('underlying');\n        } else if (token.expiry() > m) {\n            revert NotEqual('maturity');\n        }\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        uint256 returned;\n        {\n            // Add the accumulated fees to the total\n            uint256 fee = calculateFee(a);\n            fees[u] += fee;\n\n            address[] memory path = new address[](2);\n            path[0] = u;\n            path[1] = principal;\n\n            // Swap on the Pendle Router using the provided market and params\n            returned = IPendle(pendleAddr).swapExactTokensForTokens(a - fee, r, path, address(this), d)[0];\n\n        }\n        // Mint Illuminate zero coupons\n        address illuminateToken = principalToken(u, m);\n        IERC5095(illuminateToken).mint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned);\n        return returned;\n    }\n\n    /// @notice lend method signature for tempus\n    /// @dev This method can be called before maturity to lend to Tempus while minting Illuminate tokens\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of principal tokens to lend\n    /// @param r minimum amount to return when executing the swap (sets a limit to slippage)\n    /// @param d deadline is a timestamp by which the swap must be executed\n    /// @param t tempus pool that houses the underlying principal tokens\n    /// @param x tempus amm that executes the swap\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d,\n        address t,\n        address x\n    ) public unpaused(p) returns (uint256) {\n        {\n            // Instantiate market and tokens\n            address principal = IMarketPlace(marketPlace).markets(u, m, p);\n            if (ITempus(principal).yieldBearingToken() != IERC20Metadata(u)) {\n                revert NotEqual('underlying');\n            } else if (ITempus(principal).maturityTime() > m) {\n                revert NotEqual('maturity');\n            }\n\n            // Get the underlying token\n            IERC20 underlyingToken = IERC20(u);\n\n            // Transfer funds from user to Illuminate, Scope to avoid stack limit\n            Safe.transferFrom(underlyingToken, msg.sender, address(this), a);\n        }\n\n        // Add the accumulated fees to the total\n        uint256 fee = calculateFee(a);\n        fees[u] += fee;\n\n        // Swap on the Tempus Router using the provided market and params\n        IERC5095 illuminateToken = IERC5095(principalToken(u, m));\n        uint256 returned = ITempus(tempusAddr).depositAndFix(Any(x), Any(t), a - fee, true, r, d) -\n            illuminateToken.balanceOf(address(this));\n\n        // Mint Illuminate zero coupons\n        illuminateToken.mint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned);\n        return returned;\n    }\n\n    /// @notice lend method signature for sense\n    /// @dev this method can be called before maturity to lend to Sense while minting Illuminate tokens\n    /// @dev sense provides a [divider] contract that splits [target] assets (underlying) into PTs and YTs. Each [target] asset has a [series] of contracts, each identifiable by their [maturity].\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param r minimum number of tokens to lend (sets a limit on the order)\n    /// @param x amm that is used to conduct the swap\n    /// @param s contract that holds the principal token for this market\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint128 a,\n        uint256 r,\n        address x,\n        address s\n    ) public unpaused(p) returns (uint256) {\n\n        // Get the principal token for this market for this market\n        ISenseToken token = ISenseToken(IMarketPlace(marketPlace).markets(u, m, p));\n\n        // Verify that the underlying and maturity match up\n        if (token.underlying() != u) { // gauruntee the input token is the right token\n            revert NotEqual('underlying'); \n        } else if (ISense(s).pt() != address(token)) {\n            revert NotEqual('principal token'); \n        } else if (ISense(x).maturity() > m) { // gauruntee the input amm has the correct maturity\n            revert NotEqual('maturity');\n        }\n\n        uint256 lent;\n        {\n            // Determine the fee\n            uint256 fee = calculateFee(a);\n\n            // Add the accumulated fees to the total\n            fees[u] += fee;\n\n            // Determine lent amount after fees\n            lent = a - fee;\n        }\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        // Swap those tokens for the principal tokens\n        uint256 returned = ISense(x).swapUnderlyingForPTs(s, m, lent, r);\n\n        // Get the address of the ERC5095 token for this market\n        IERC5095 illuminateToken = IERC5095(principalToken(u, m));\n\n        // Mint the illuminate tokens based on the returned amount\n        illuminateToken.mint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned);\n        return returned;\n    }\n\n    /// @notice this method can be called before maturity to lend to APWine while minting Illuminate tokens\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a the amount of underlying tokens to lend\n    /// @param r the minimum amount of zero-coupon tokens to return accounting for slippage\n    /// @param pool the address of a given APWine pool\n    /// @param i the id of the pool\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,"
    }
  ]
}