{
  "Title": "[49] Fix documentation in regards to timing requirements so code doesn't deviate from docs",
  "Content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/contracts/SystemContext.sol#L428-L434\n\n```solidity\n    function _ensureBatchConsistentWithL2Block(uint128 _newTimestamp) internal view {\n        uint128 currentBlockTimestamp = currentL2BlockInfo.timestamp;\n        require(\n            _newTimestamp > currentBlockTimestamp,\n            \"The timestamp of the batch must be greater than the timestamp of the previous block\"\n        );\n    }\n```\nNow look at this section of the docs https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/docs/Smart%20contract%20Section/Batches%20%26%20L2%20blocks%20on%20zkSync.md#timing-invariants\n\nWe can see that it's been wrongly stated that `For each L2 block its timestamp should be ≥ timestamp of the batch it belongs to` case is with the code implementation we can see that the check is instead strictly greater than.\n\n### Impact\n\nBad code structure, making it harder to understand implementation.\n\n### Recommended Mitigation Steps\n\nFix the docs, change https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/docs/Smart%20contract%20Section/Batches%20%26%20L2%20blocks%20on%20zkSync.md#timing-invariants to `For each L2 block its timestamp should be **>** timestamp of the batch it belongs to`\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-zksync",
  "Code": [
    {
      "filename": "code/system-contracts/contracts/SystemContext.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {ISystemContext} from \"./interfaces/ISystemContext.sol\";\nimport {ISystemContract} from \"./interfaces/ISystemContract.sol\";\nimport {ISystemContextDeprecated} from \"./interfaces/ISystemContextDeprecated.sol\";\nimport {SystemContractHelper} from \"./libraries/SystemContractHelper.sol\";\nimport {BOOTLOADER_FORMAL_ADDRESS, SystemLogKey} from \"./Constants.sol\";\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice Contract that stores some of the context variables, that may be either\n * block-scoped, tx-scoped or system-wide.\n */\ncontract SystemContext is ISystemContext, ISystemContextDeprecated, ISystemContract {\n    /// @notice The number of latest L2 blocks to store.\n    /// @dev EVM requires us to be able to query the hashes of previous 256 blocks.\n    /// We could either:\n    /// - Store the latest 256 hashes (and strictly rely that we do not accidentally override the hash of the block 256 blocks ago)\n    /// - Store the latest 257 blocks' hashes.\n    uint256 internal constant MINIBLOCK_HASHES_TO_STORE = 257;\n\n    /// @notice The chainId of the network. It is set at the genesis.\n    uint256 public chainId;\n\n    /// @notice The `tx.origin` in the current transaction.\n    /// @dev It is updated before each transaction by the bootloader\n    address public origin;\n\n    /// @notice The `tx.gasPrice` in the current transaction.\n    /// @dev It is updated before each transaction by the bootloader\n    uint256 public gasPrice;\n\n    /// @notice The current block's gasLimit.\n    uint256 public blockGasLimit = type(uint32).max;\n\n    /// @notice The `block.coinbase` in the current transaction.\n    /// @dev For the support of coinbase, we will use the bootloader formal address for now\n    address public coinbase = BOOTLOADER_FORMAL_ADDRESS;\n\n    /// @notice Formal `block.difficulty` parameter.\n    uint256 public difficulty = 2.5e15;\n\n    /// @notice The `block.basefee`.\n    /// @dev It is currently a constant.\n    uint256 public baseFee;\n\n    /// @notice The number and the timestamp of the current L1 batch stored packed.\n    BlockInfo internal currentBatchInfo;\n\n    /// @notice The hashes of batches.\n    /// @dev It stores batch hashes for all previous batches.\n    mapping(uint256 batchNumber => bytes32 batchHash) internal batchHashes;\n\n    /// @notice The number and the timestamp of the current L2 block.\n    BlockInfo internal currentL2BlockInfo;\n\n    /// @notice The rolling hash of the transactions in the current L2 block.\n    bytes32 internal currentL2BlockTxsRollingHash;\n\n    /// @notice The hashes of L2 blocks.\n    /// @dev It stores block hashes for previous L2 blocks. Note, in order to make publishing the hashes\n    /// of the miniblocks cheaper, we only store the previous MINIBLOCK_HASHES_TO_STORE ones. Since whenever we need to publish a state\n    /// diff, a pair of <key, value> is published and for cached keys only 8-byte id is used instead of 32 bytes.\n    /// By having this data in a cyclic array of MINIBLOCK_HASHES_TO_STORE blocks, we bring the costs down by 40% (i.e. 40 bytes per miniblock instead of 64 bytes).\n    /// @dev The hash of a miniblock with number N would be stored under slot N%MINIBLOCK_HASHES_TO_STORE.\n    /// @dev Hashes of the blocks older than the ones which are stored here can be calculated as _calculateLegacyL2BlockHash(blockNumber).\n    bytes32[MINIBLOCK_HASHES_TO_STORE] internal l2BlockHash;\n\n    /// @notice To make migration to L2 blocks smoother, we introduce a temporary concept of virtual L2 blocks, the data\n    /// about which will be returned by the EVM-like methods: block.number/block.timestamp/blockhash.\n    /// - Their number will start from being equal to the number of the batch and it will increase until it reaches the L2 block number.\n    /// - Their timestamp is updated each time a new virtual block is created.\n    /// - Their hash is calculated as `keccak256(uint256(number))`\n    BlockInfo internal currentVirtualL2BlockInfo;\n\n    /// @notice The information about the virtual blocks upgrade, which tracks when the migration to the L2 blocks has started and finished.\n    VirtualBlockUpgradeInfo internal virtualBlockUpgradeInfo;\n\n    /// @notice Set the chainId origin.\n    /// @param _newChainId The chainId\n    function setChainId(uint256 _newChainId) external onlyCallFromForceDeployer {\n        chainId = _newChainId;\n    }\n\n    /// @notice Number of current transaction in block.\n    uint16 public txNumberInBlock;\n\n    /// @notice The current gas per pubdata byte\n    uint256 public gasPerPubdataByte;\n\n    /// @notice The number of pubdata spent as of the start of the transaction\n    uint256 internal basePubdataSpent;\n\n    /// @notice Set the current tx origin.\n    /// @param _newOrigin The new tx origin.\n    function setTxOrigin(address _newOrigin) external onlyCallFromBootloader {\n        origin = _newOrigin;\n    }\n\n    /// @notice Set the the current gas price.\n    /// @param _gasPrice The new tx gasPrice.\n    function setGasPrice(uint256 _gasPrice) external onlyCallFromBootloader {\n        gasPrice = _gasPrice;\n    }\n\n    /// @notice Sets the number of L2 gas that is needed to pay a single byte of pubdata.\n    /// @dev This value does not have any impact on the execution and purely serves as a way for users\n    /// to access the current gas price for the pubdata.\n    function setPubdataInfo(uint256 _gasPerPubdataByte, uint256 _basePubdataSpent) external onlyCallFromBootloader {\n        basePubdataSpent = _basePubdataSpent;\n        gasPerPubdataByte = _gasPerPubdataByte;\n    }\n\n    function getCurrentPubdataSpent() public view returns (uint256) {\n        uint256 pubdataPublished = SystemContractHelper.getZkSyncMeta().pubdataPublished;\n        return pubdataPublished > basePubdataSpent ? pubdataPublished - basePubdataSpent : 0;\n    }\n\n    function getCurrentPubdataCost() external view returns (uint256) {\n        return gasPerPubdataByte * getCurrentPubdataSpent();\n    }\n\n    /// @notice The method that emulates `blockhash` opcode in EVM.\n    /// @dev Just like the blockhash in the EVM, it returns bytes32(0),\n    /// when queried about hashes that are older than 256 blocks ago.\n    /// @dev Since zksolc compiler calls this method to emulate `blockhash`,\n    /// its signature can not be changed to `getL2BlockHashEVM`.\n    /// @return hash The blockhash of the block with the given number.\n    function getBlockHashEVM(uint256 _block) external view returns (bytes32 hash) {\n        uint128 blockNumber = currentVirtualL2BlockInfo.number;\n\n        VirtualBlockUpgradeInfo memory currentVirtualBlockUpgradeInfo = virtualBlockUpgradeInfo;\n\n        // Due to virtual blocks upgrade, we'll have to use the following logic for retreiving the blockhash:\n        // 1. If the block number is out of the 256-block supported range, return 0.\n        // 2. If the block was created before the upgrade for the virtual blocks (i.e. there we used to use hashes of the batches),\n        // we return the hash of the batch.\n        // 3. If the block was created after the day when the virtual blocks have caught up with the L2 blocks, i.e.\n        // all the information which is returned for users should be for L2 blocks, we return the hash of the corresponding L2 block.\n        // 4. If the block queried is a virtual blocks, calculate it on the fly.\n        if (blockNumber <= _block || blockNumber - _block > 256) {\n            hash = bytes32(0);\n        } else if (_block < currentVirtualBlockUpgradeInfo.virtualBlockStartBatch) {\n            // Note, that we will get into this branch only for a brief moment of time, right after the upgrade\n            // for virtual blocks before 256 virtual blocks are produced.\n            hash = batchHashes[_block];\n        } else if (\n            _block >= currentVirtualBlockUpgradeInfo.virtualBlockFinishL2Block &&\n            currentVirtualBlockUpgradeInfo.virtualBlockFinishL2Block > 0\n        ) {\n            hash = _getLatest257L2blockHash(_block);\n        } else {\n            // Important: we do not want this number to ever collide with the L2 block hash (either new or old one) and so\n            // that's why the legacy L2 blocks' hashes are keccak256(abi.encodePacked(uint32(_block))), while these are equivalent to\n            // keccak256(abi.encodePacked(_block))\n            hash = keccak256(abi.encode(_block));\n        }\n    }\n\n    /// @notice Returns the hash of the given batch.\n    /// @param _batchNumber The number of the batch.\n    /// @return hash The hash of the batch.\n    function getBatchHash(uint256 _batchNumber) external view returns (bytes32 hash) {\n        hash = batchHashes[_batchNumber];\n    }\n\n    /// @notice Returns the current batch's number and timestamp.\n    /// @return batchNumber and batchTimestamp tuple of the current batch's number and the current batch's timestamp\n    function getBatchNumberAndTimestamp() public view returns (uint128 batchNumber, uint128 batchTimestamp) {\n        BlockInfo memory batchInfo = currentBatchInfo;\n        batchNumber = batchInfo.number;\n        batchTimestamp = batchInfo.timestamp;\n    }\n\n    /// @notice Returns the current block's number and timestamp.\n    /// @return blockNumber and blockTimestamp tuple of the current L2 block's number and the current block's timestamp\n    function getL2BlockNumberAndTimestamp() public view returns (uint128 blockNumber, uint128 blockTimestamp) {\n        BlockInfo memory blockInfo = currentL2BlockInfo;\n        blockNumber = blockInfo.number;\n        blockTimestamp = blockInfo.timestamp;\n    }\n\n    /// @notice Returns the current L2 block's number.\n    /// @dev Since zksolc compiler calls this method to emulate `block.number`,\n    /// its signature can not be changed to `getL2BlockNumber`.\n    /// @return blockNumber The current L2 block's number.\n    function getBlockNumber() public view returns (uint128) {\n        return currentVirtualL2BlockInfo.number;\n    }\n\n    /// @notice Returns the current L2 block's timestamp.\n    /// @dev Since zksolc compiler calls this method to emulate `block.timestamp`,\n    /// its signature can not be changed to `getL2BlockTimestamp`.\n    /// @return timestamp The current L2 block's timestamp.\n    function getBlockTimestamp() public view returns (uint128) {\n        return currentVirtualL2BlockInfo.timestamp;\n    }\n\n    /// @notice Assuming that block is one of the last MINIBLOCK_HASHES_TO_STORE ones, returns its hash.\n    /// @param _block The number of the block.\n    /// @return hash The hash of the block.\n    function _getLatest257L2blockHash(uint256 _block) internal view returns (bytes32) {\n        return l2BlockHash[_block % MINIBLOCK_HASHES_TO_STORE];\n    }\n\n    /// @notice Assuming that the block is one of the last MINIBLOCK_HASHES_TO_STORE ones, sets its hash.\n    /// @param _block The number of the block.\n    /// @param _hash The hash of the block.\n    function _setL2BlockHash(uint256 _block, bytes32 _hash) internal {\n        l2BlockHash[_block % MINIBLOCK_HASHES_TO_STORE] = _hash;\n    }\n\n    /// @notice Calculates the hash of an L2 block.\n    /// @param _blockNumber The number of the L2 block.\n    /// @param _blockTimestamp The timestamp of the L2 block.\n    /// @param _prevL2BlockHash The hash of the previous L2 block.\n    /// @param _blockTxsRollingHash The rolling hash of the transactions in the L2 block.\n    function _calculateL2BlockHash(\n        uint128 _blockNumber,\n        uint128 _blockTimestamp,\n        bytes32 _prevL2BlockHash,\n        bytes32 _blockTxsRollingHash\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encode(_blockNumber, _blockTimestamp, _prevL2BlockHash, _blockTxsRollingHash));\n    }\n\n    /// @notice Calculates the legacy block hash of L2 block, which were used before the upgrade where\n    /// the advanced block hashes were introduced.\n    /// @param _blockNumber The number of the L2 block.\n    function _calculateLegacyL2BlockHash(uint128 _blockNumber) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(uint32(_blockNumber)));\n    }\n\n    /// @notice Performs the upgrade where we transition to the L2 blocks.\n    /// @param _l2BlockNumber The number of the new L2 block.\n    /// @param _expectedPrevL2BlockHash The expected hash of the previous L2 block.\n    /// @param _isFirstInBatch Whether this method is called for the first time in the batch.\n    function _upgradeL2Blocks(uint128 _l2BlockNumber, bytes32 _expectedPrevL2BlockHash, bool _isFirstInBatch) internal {\n        require(_isFirstInBatch, \"Upgrade transaction must be first\");\n\n        // This is how it will be commonly done in practice, but it will simplify some logic later\n        require(_l2BlockNumber > 0, \"L2 block number is never expected to be zero\");\n\n        unchecked {\n            bytes32 correctPrevBlockHash = _calculateLegacyL2BlockHash(_l2BlockNumber - 1);\n            require(correctPrevBlockHash == _expectedPrevL2BlockHash, \"The previous L2 block hash is incorrect\");\n\n            // Whenever we'll be queried about the hashes of the blocks before the upgrade,\n            // we'll use batches' hashes, so we don't need to store 256 previous hashes.\n            // However, we do need to store the last previous hash in order to be able to correctly calculate the\n            // hash of the new L2 block.\n            _setL2BlockHash(_l2BlockNumber - 1, correctPrevBlockHash);\n        }\n    }\n\n    /// @notice Creates new virtual blocks, while ensuring they don't exceed the L2 block number.\n    /// @param _l2BlockNumber The number of the new L2 block.\n    /// @param _maxVirtualBlocksToCreate The maximum number of virtual blocks to create with this L2 block.\n    /// @param _newTimestamp The timestamp of the new L2 block, which is also the timestamp of the new virtual block.\n    function _setVirtualBlock(\n        uint128 _l2BlockNumber,\n        uint128 _maxVirtualBlocksToCreate,\n        uint128 _newTimestamp\n    ) internal {\n        if (virtualBlockUpgradeInfo.virtualBlockFinishL2Block != 0) {\n            // No need to to do anything about virtual blocks anymore\n            // All the info is the same as for L2 blocks.\n            currentVirtualL2BlockInfo = currentL2BlockInfo;\n            return;\n        }\n\n        BlockInfo memory virtualBlockInfo = currentVirtualL2BlockInfo;\n\n        if (currentVirtualL2BlockInfo.number == 0 && virtualBlockInfo.timestamp == 0) {\n            uint128 currentBatchNumber = currentBatchInfo.number;\n\n            // The virtual block is set for the first time. We can count it as 1 creation of a virtual block.\n            // Note, that when setting the virtual block number we use the batch number to make a smoother upgrade from batch number to\n            // the L2 block number.\n            virtualBlockInfo.number = currentBatchNumber;\n            // Remembering the batch number on which the upgrade to the virtual blocks has been done.\n            virtualBlockUpgradeInfo.virtualBlockStartBatch = currentBatchNumber;\n\n            require(_maxVirtualBlocksToCreate > 0, \"Can't initialize the first virtual block\");\n            _maxVirtualBlocksToCreate -= 1;\n        } else if (_maxVirtualBlocksToCreate == 0) {\n            // The virtual blocks have been already initialized, but the operator didn't ask to create\n            // any new virtual blocks. So we can just return.\n            return;\n        }\n\n        virtualBlockInfo.number += _maxVirtualBlocksToCreate;\n        virtualBlockInfo.timestamp = _newTimestamp;\n\n        // The virtual block number must never exceed the L2 block number.\n        // We do not use a `require` here, since the virtual blocks are a temporary solution to let the Solidity's `block.number`\n        // catch up with the L2 block number and so the situation where virtualBlockInfo.number starts getting larger\n        // than _l2BlockNumber is expected once virtual blocks have caught up the L2 blocks.\n        if (virtualBlockInfo.number >= _l2BlockNumber) {\n            virtualBlockUpgradeInfo.virtualBlockFinishL2Block = _l2BlockNumber;\n            virtualBlockInfo.number = _l2BlockNumber;\n        }\n\n        currentVirtualL2BlockInfo = virtualBlockInfo;\n    }\n\n    /// @notice Sets the current block number and timestamp of the L2 block.\n    /// @param _l2BlockNumber The number of the new L2 block.\n    /// @param _l2BlockTimestamp The timestamp of the new L2 block.\n    /// @param _prevL2BlockHash The hash of the previous L2 block.\n    function _setNewL2BlockData(uint128 _l2BlockNumber, uint128 _l2BlockTimestamp, bytes32 _prevL2BlockHash) internal {\n        // In the unsafe version we do not check that the block data is correct\n        currentL2BlockInfo = BlockInfo({number: _l2BlockNumber, timestamp: _l2BlockTimestamp});\n\n        // It is always assumed in production that _l2BlockNumber > 0\n        _setL2BlockHash(_l2BlockNumber - 1, _prevL2BlockHash);\n\n        // Reseting the rolling hash\n        currentL2BlockTxsRollingHash = bytes32(0);\n    }\n\n    /// @notice Sets the current block number and timestamp of the L2 block.\n    /// @dev Called by the bootloader before each transaction. This is needed to ensure\n    /// that the data about the block is consistent with the sequencer.\n    /// @dev If the new block number is the same as the current one, we ensure that the block's data is\n    /// consistent with the one in the current block.\n    /// @dev If the new block number is greater than the current one by 1,\n    /// then we ensure that timestamp has increased.\n    /// @dev If the currently stored number is 0, we assume that it is the first upgrade transaction\n    /// and so we will fill up the old data.\n    /// @param _l2BlockNumber The number of the new L2 block.\n    /// @param _l2BlockTimestamp The timestamp of the new L2 block.\n    /// @param _expectedPrevL2BlockHash The expected hash of the previous L2 block.\n    /// @param _isFirstInBatch Whether this method is called for the first time in the batch.\n    /// @param _maxVirtualBlocksToCreate The maximum number of virtual block to create with this L2 block.\n    /// @dev It is a strict requirement that a new virtual block is created at the start of the batch.\n    /// @dev It is also enforced that the number of the current virtual L2 block can not exceed the number of the L2 block.\n    function setL2Block(\n        uint128 _l2BlockNumber,\n        uint128 _l2BlockTimestamp,\n        bytes32 _expectedPrevL2BlockHash,\n        bool _isFirstInBatch,\n        uint128 _maxVirtualBlocksToCreate\n    ) external onlyCallFromBootloader {\n        // We check that the timestamp of the L2 block is consistent with the timestamp of the batch.\n        if (_isFirstInBatch) {\n            uint128 currentBatchTimestamp = currentBatchInfo.timestamp;\n            require(\n                _l2BlockTimestamp >= currentBatchTimestamp,\n                \"The timestamp of the L2 block must be greater than or equal to the timestamp of the current batch\"\n            );\n            require(_maxVirtualBlocksToCreate > 0, \"There must be a virtual block created at the start of the batch\");\n        }\n\n        (uint128 currentL2BlockNumber, uint128 currentL2BlockTimestamp) = getL2BlockNumberAndTimestamp();\n\n        if (currentL2BlockNumber == 0 && currentL2BlockTimestamp == 0) {\n            // Since currentL2BlockNumber and currentL2BlockTimestamp are zero it means that it is\n            // the first ever batch with L2 blocks, so we need to initialize those.\n            _upgradeL2Blocks(_l2BlockNumber, _expectedPrevL2BlockHash, _isFirstInBatch);\n\n            _setNewL2BlockData(_l2BlockNumber, _l2BlockTimestamp, _expectedPrevL2BlockHash);\n        } else if (currentL2BlockNumber == _l2BlockNumber) {\n            require(!_isFirstInBatch, \"Can not reuse L2 block number from the previous batch\");\n            require(currentL2BlockTimestamp == _l2BlockTimestamp, \"The timestamp of the same L2 block must be same\");\n            require(\n                _expectedPrevL2BlockHash == _getLatest257L2blockHash(_l2BlockNumber - 1),\n                \"The previous hash of the same L2 block must be same\"\n            );\n            require(_maxVirtualBlocksToCreate == 0, \"Can not create virtual blocks in the middle of the miniblock\");\n        } else if (currentL2BlockNumber + 1 == _l2BlockNumber) {\n            // From the checks in _upgradeL2Blocks it is known that currentL2BlockNumber can not be 0\n            bytes32 prevL2BlockHash = _getLatest257L2blockHash(currentL2BlockNumber - 1);\n\n            bytes32 pendingL2BlockHash = _calculateL2BlockHash(\n                currentL2BlockNumber,\n                currentL2BlockTimestamp,\n                prevL2BlockHash,\n                currentL2BlockTxsRollingHash\n            );\n\n            require(_expectedPrevL2BlockHash == pendingL2BlockHash, \"The current L2 block hash is incorrect\");\n            require(\n                _l2BlockTimestamp > currentL2BlockTimestamp,\n                \"The timestamp of the new L2 block must be greater than the timestamp of the previous L2 block\"\n            );\n\n            // Since the new block is created, we'll clear out the rolling hash\n            _setNewL2BlockData(_l2BlockNumber, _l2BlockTimestamp, _expectedPrevL2BlockHash);\n        } else {\n            revert(\"Invalid new L2 block number\");\n        }\n\n        _setVirtualBlock(_l2BlockNumber, _maxVirtualBlocksToCreate, _l2BlockTimestamp);\n    }\n\n    /// @notice Appends the transaction hash to the rolling hash of the current L2 block.\n    /// @param _txHash The hash of the transaction.\n    function appendTransactionToCurrentL2Block(bytes32 _txHash) external onlyCallFromBootloader {\n        currentL2BlockTxsRollingHash = keccak256(abi.encode(currentL2BlockTxsRollingHash, _txHash));\n    }\n\n    /// @notice Publishes L2->L1 logs needed to verify the validity of this batch on L1.\n    /// @dev Should be called at the end of the current batch.\n    function publishTimestampDataToL1() external onlyCallFromBootloader {\n        (uint128 currentBatchNumber, uint128 currentBatchTimestamp) = getBatchNumberAndTimestamp();\n        (, uint128 currentL2BlockTimestamp) = getL2BlockNumberAndTimestamp();\n\n        // The structure of the \"setNewBatch\" implies that currentBatchNumber > 0, but we still double check it\n        require(currentBatchNumber > 0, \"The current batch number must be greater than 0\");\n\n        // In order to spend less pubdata, the packed version is published\n        uint256 packedTimestamps = (uint256(currentBatchTimestamp) << 128) | currentL2BlockTimestamp;\n\n        SystemContractHelper.toL1(\n            false,\n            bytes32(uint256(SystemLogKey.PACKED_BATCH_AND_L2_BLOCK_TIMESTAMP_KEY)),\n            bytes32(packedTimestamps)\n        );\n    }\n\n    /// @notice Ensures that the timestamp of the batch is greater than the timestamp of the last L2 block.\n    /// @param _newTimestamp The timestamp of the new batch.\n    function _ensureBatchConsistentWithL2Block(uint128 _newTimestamp) internal view {\n        uint128 currentBlockTimestamp = currentL2BlockInfo.timestamp;\n        require(\n            _newTimestamp > currentBlockTimestamp,\n            \"The timestamp of the batch must be greater than the timestamp of the previous block\"\n        );\n    }\n\n    /// @notice Increments the current batch number and sets the new timestamp\n    /// @dev Called by the bootloader at the start of the batch.\n    /// @param _prevBatchHash The hash of the previous batch.\n    /// @param _newTimestamp The timestamp of the new batch.\n    /// @param _expectedNewNumber The new batch's number.\n    /// @param _baseFee The new batch's base fee\n    /// @dev While _expectedNewNumber can be derived as prevBatchNumber + 1, we still\n    /// manually supply it here for consistency checks.\n    /// @dev The correctness of the _prevBatchHash and _newTimestamp should be enforced on L1.\n    function setNewBatch(\n        bytes32 _prevBatchHash,\n        uint128 _newTimestamp,\n        uint128 _expectedNewNumber,\n        uint256 _baseFee\n    ) external onlyCallFromBootloader {\n        (uint128 previousBatchNumber, uint128 previousBatchTimestamp) = getBatchNumberAndTimestamp();\n        require(_newTimestamp > previousBatchTimestamp, \"Timestamps should be incremental\");\n        require(previousBatchNumber + 1 == _expectedNewNumber, \"The provided block number is not correct\");\n\n        _ensureBatchConsistentWithL2Block(_newTimestamp);\n\n        batchHashes[previousBatchNumber] = _prevBatchHash;\n\n        // Setting new block number and timestamp\n        BlockInfo memory newBlockInfo = BlockInfo({number: previousBatchNumber + 1, timestamp: _newTimestamp});\n\n        currentBatchInfo = newBlockInfo;\n\n        baseFee = _baseFee;\n\n        // The correctness of this block hash:\n        SystemContractHelper.toL1(false, bytes32(uint256(SystemLogKey.PREV_BATCH_HASH_KEY)), _prevBatchHash);\n    }\n\n    /// @notice A testing method that manually sets the current blocks' number and timestamp.\n    /// @dev Should be used only for testing / ethCalls and should never be used in production.\n    function unsafeOverrideBatch(\n        uint256 _newTimestamp,\n        uint256 _number,\n        uint256 _baseFee\n    ) external onlyCallFromBootloader {\n        BlockInfo memory newBlockInfo = BlockInfo({number: uint128(_number), timestamp: uint128(_newTimestamp)});\n        currentBatchInfo = newBlockInfo;\n\n        baseFee = _baseFee;\n    }\n\n    function incrementTxNumberInBatch() external onlyCallFromBootloader {\n        txNumberInBlock += 1;\n    }\n\n    function resetTxNumberInBatch() external onlyCallFromBootloader {\n        txNumberInBlock = 0;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPRECATED METHODS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Returns the current batch's number and timestamp.\n    /// @dev Deprecated in favor of getBatchNumberAndTimestamp.\n    function currentBlockInfo() external view returns (uint256 blockInfo) {\n        (uint128 blockNumber, uint128 blockTimestamp) = getBatchNumberAndTimestamp();\n        blockInfo = (uint256(blockNumber) << 128) | uint256(blockTimestamp);\n    }\n\n    /// @notice Returns the current batch's number and timestamp.\n    /// @dev Deprecated in favor of getBatchNumberAndTimestamp.\n    function getBlockNumberAndTimestamp() external view returns (uint256 blockNumber, uint256 blockTimestamp) {\n        (blockNumber, blockTimestamp) = getBatchNumberAndTimestamp();\n    }\n\n    /// @notice Returns the hash of the given batch.\n    /// @dev Deprecated in favor of getBatchHash.\n    function blockHash(uint256 _blockNumber) external view returns (bytes32 hash) {\n        hash = batchHashes[_blockNumber];\n    }\n}"
    },
    {
      "filename": "docs/Smart%20contract%20Section/Batches%20%26%20L2%20blocks%20on%20zkSync.md",
      "content": "# Batches & L2 blocks on zkSync\n\n## Glossary\n\n- Batch - a set of transactions that the bootloader processes (`commitBatches`, `proveBatches`, and `executeBatches` work with it). A batch consists of multiple transactions.\n- L2 blocks - non-intersecting sub-sets of consecutively executed transactions in a batch. This is the kind of block you see in the API. This is the one that is used for `block.number`/`block.timestamp`/etc. Note that it wasn't this way before the virtual blocks [migration](#migration--virtual-blocks-logic).\n- Virtual block — a block, the data of which was being returned in the contract execution environment during the migration. They are called “virtual”, since they have no trace in our API, i.e. it is not possible to query information about them in any way. This is now mostly irrelevant, since the migration is alredy finished.\n\n## Motivation\n\nBefore the recent upgrade, `block.number`, `block.timestamp`, as well as `blockhash` in Solidity, returned information about *batches*, i.e. large blocks that are proven on L1 and which consist of many smaller L2 blocks. At the same time, API returns `block.number` and `block.timestamp` as for L2 blocks.\n\nL2 blocks were created for fast soft confirmation in wallets and block explorer. For example, MetaMask shows transactions as confirmed only after the block in which transaction execution was mined. So if the user needs to wait for the batch confirmation it would take at least a few minutes (for soft confirmation) and hours for full confirmation which is very bad UX. But API could return soft confirmation much earlier through L2 blocks.\n\nThere was a huge outcry in the community for us to return the information for L2 blocks in `block.number`, `block.timestamp`, as well as `blockhash`, because of discrepancy of runtime execution and returned data by API.\n\nHowever, there were over 15mln L2 blocks, while less than 200k batches, meaning that if we simply “switched” from returning L1 batches’ info to L2 block’s info, some contracts (especially those that use `block.number` for measuring time intervals instead of `block.timestamp`) would break. For that, we decided to have an accelerated migration process, i.e. the `block.number` will grow faster and faster, until it becomes roughly 8x times the L2 block production speed, allowing it to gradually reach the L2 block number, after which the information on the L2 `block.number` will be returned. The blocks the info of which will be returned during this process are called “virtual blocks”. Their information will never be available in any of our APIs, which should not be a major breaking change, since our API already mostly works with L2 blocks, while L1 batches’s information is returned in the runtime.\n\n## Adapting for Solidity\n\nIn order to get the returned value for `block.number`, `block.timestamp`, `blockhash` our compiler used the following functions:\n\n- `getBlockNumber`\n- `getBlockTimestamp`\n- `getBlockHashEVM`\n\nDuring the migration process, these returned the values of the virtual blocks. Currently, since the migration is complete, they return values for L2 blocks.\n\n## Migration status\n\nAt the time of this writing, the migration has been complete on both testnet and mainnet, i.e. there we already have only the L2 block information returned. Mainnet migration ended in early November 2023.\n\n# Blocks’ processing and consistency checks\n\nOur `SystemContext` contract allows to get information about batches and L2 blocks. Some of the information is hard to calculate onchain. For instace, time. The timing information (for both batches and L2 blocks) are provided by the operator. In order to check that the operator provided some realistic values, certain checks are done on L1. Generally though, we try to check as much as we can on L2.\n\n## Initializing L1 batch\n\nAt the start of the batch, the operator [provides](https://github.com/code-423n4/2024-03-zksync/blob/e8527cab32c9fe2e1be70e414d7c73a20d357550/code/system-contracts/bootloader/bootloader.yul#L3867) the timestamp of the batch, its number and the hash of the previous batch.. The root hash of the Merkle tree serves as the root hash of the batch.\n\nThe SystemContext can immediately check whether the provided number is the correct batch number. It also immediately sends the previous batch hash to L1, where it will be checked during the commit operation. Also, some general consistency checks are performed. This logic can be found [here](https://github.com/code-423n4/2024-03-zksync/blob/e8527cab32c9fe2e1be70e414d7c73a20d357550/code/system-contracts/contracts/SystemContext.sol#L466).\n\n## L2 blocks processing and consistency checks\n\n### `setL2Block`\n\nBefore each transaction, we call `setL2Block` [method](https://github.com/code-423n4/2024-03-zksync/blob/e8527cab32c9fe2e1be70e414d7c73a20d357550/code/system-contracts/bootloader/bootloader.yul#L2825). There we will provide some data about the L2 block that the transaction belongs to:\n\n- `_l2BlockNumber` The number of the new L2 block.\n- `_l2BlockTimestamp` The timestamp of the new L2 block.\n- `_expectedPrevL2BlockHash` The expected hash of the previous L2 block.\n- `_isFirstInBatch` Whether this method is called for the first time in the batch.\n- `_maxVirtualBlocksToCreate` The maximum number of virtual block to create with this L2 block.\n\nIf two transactions belong to the same L2 block, only the first one may have non-zero `_maxVirtualBlocksToCreate`. The rest of the data must be same.\n\nThe `setL2Block` [performs](https://github.com/code-423n4/2024-03-zksync/blob/e8527cab32c9fe2e1be70e414d7c73a20d357550/code/system-contracts/contracts/SystemContext.sol#L341) a lot of similar consistency checks to the ones for the L1 batch.\n\n### L2 blockhash calculation and storage\n\nUnlike L1 batch’s hash, the L2 blocks’ hashes can be checked on L2.\n\nThe hash of an L2 block is `keccak256(abi.encode(_blockNumber,"
    }
  ]
}