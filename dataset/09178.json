{
  "Title": "[G-32] `public` functions not called by the contract should be declared `external` instead",
  "Content": "\nContracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from `external` to `public` and can save gas by doing so.\n\n*There are 18 instances of this issue:*\n\n```solidity\nFile: contracts/ExtraRewardsDistributor.sol\n\n117:      function getReward(address _account, address _token) public {\n\n127       function getReward(\n128           address _account,\n129           address _token,\n130:          uint256 _startIndex\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/ExtraRewardsDistributor.sol#L117>\n\n```solidity\nFile: contracts/AuraMerkleDrop.sol\n\n114       function claim(\n115           bytes32[] calldata _proof,\n116           uint256 _amount,\n117           bool _lock\n118:      ) public returns (bool) {\n\n149       function forwardPenalty() public {\n150:          uint256 toForward = pendingPenalty;\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/AuraMerkleDrop.sol#L114-L118>\n\n```solidity\nFile: contracts/AuraPenaltyForwarder.sol\n\n47        function forward() public {\n48:           require(block.timestamp > lastDistribution + distributionDelay, \"!elapsed\");\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/AuraPenaltyForwarder.sol#L47-L48>\n\n```solidity\nFile: contracts/AuraBalRewardPool.sol\n\n138:      function stakeFor(address _for, uint256 _amount) public updateReward(_for) returns (bool) {\n\n152       function withdraw(\n153           uint256 amount,\n154           bool claim,\n155           bool lock\n156:      ) public updateReward(msg.sender) returns (bool) {\n\n195       function forwardPenalty() public {\n196:          uint256 toForward = pendingPenalty;\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/AuraBalRewardPool.sol#L138>\n\n```solidity\nFile: contracts/BalLiquidityProvider.sol\n\n46:       function provideLiquidity(bytes32 _poolId, IVault.JoinPoolRequest memory _request) public {\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/BalLiquidityProvider.sol#L46>\n\n```solidity\nFile: convex-platform/contracts/contracts/ConvexMasterChef.sol\n\n96        function add(\n97            uint256 _allocPoint,\n98            IERC20 _lpToken,\n99            IRewarder _rewarder,\n100           bool _withUpdate\n101:      ) public onlyOwner {\n\n121       function set(\n122           uint256 _pid,\n123           uint256 _allocPoint,\n124           IRewarder _rewarder,\n125           bool _withUpdate,\n126           bool _updateRewarder\n127:      ) public onlyOwner {\n\n209:      function deposit(uint256 _pid, uint256 _amount) public {\n\n239:      function withdraw(uint256 _pid, uint256 _amount) public {\n\n283:      function emergencyWithdraw(uint256 _pid) public {\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ConvexMasterChef.sol#L96-L101>\n\n```solidity\nFile: convex-platform/contracts/contracts/VoterProxy.sol\n\n151:      function isValidSignature(bytes32 _hash, bytes memory) public view returns (bytes4) {\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/VoterProxy.sol#L151>\n\n```solidity\nFile: convex-platform/contracts/contracts/BaseRewardPool.sol\n\n191       function stakeFor(address _for, uint256 _amount)\n192           public\n193:          returns(bool)\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/BaseRewardPool.sol#L191-L193>\n\n```solidity\nFile: convex-platform/contracts/contracts/VirtualBalanceRewardPool.sol\n\n178       function withdraw(address _account, uint256 amount)\n179           public\n180:          updateReward(_account)\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/VirtualBalanceRewardPool.sol#L178-L180>\n\n```solidity\nFile: convex-platform/contracts/contracts/Booster.sol\n\n493:      function withdrawAll(uint256 _pid) public returns(bool){\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/Booster.sol#L493>\n\n\n\n***\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-05-aura",
  "Code": [
    {
      "filename": "contracts/ExtraRewardsDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport { IExtraRewardsDistributor, IAuraLocker } from \"./Interfaces.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol\";\n\n/**\n * @title   ExtraRewardsDistributor\n * @author  adapted from ConvexFinance\n * @notice  Allows anyone to distribute rewards to the AuraLocker at a given epoch.\n */\ncontract ExtraRewardsDistributor is ReentrancyGuard, IExtraRewardsDistributor {\n    using SafeERC20 for IERC20;\n\n    IAuraLocker public immutable auraLocker;\n\n    // token -> epoch -> amount\n    mapping(address => mapping(uint256 => uint256)) public rewardData;\n    // token -> epochList\n    mapping(address => uint256[]) public rewardEpochs;\n    // token -> account -> last claimed epoch index\n    mapping(address => mapping(address => uint256)) public userClaims;\n\n    /* ========== EVENTS ========== */\n\n    event RewardAdded(address indexed token, uint256 indexed epoch, uint256 reward);\n    event RewardPaid(address indexed user, address indexed token, uint256 reward, uint256 index);\n    event RewardForfeited(address indexed user, address indexed token, uint256 index);\n\n    /**\n     * @dev Simple constructoor\n     * @param _auraLocker Aura Locker address\n     */\n    constructor(address _auraLocker) {\n        auraLocker = IAuraLocker(_auraLocker);\n    }\n\n    /* ========== ADD REWARDS ========== */\n\n    /**\n     * @notice Add a reward to the current epoch. can be called multiple times for the same reward token\n     * @param _token    Reward token address\n     * @param _amount   Amount of reward tokenÏ€\n     */\n    function addReward(address _token, uint256 _amount) external {\n        auraLocker.checkpointEpoch();\n\n        uint256 latestEpoch = auraLocker.epochCount() - 1;\n        _addReward(_token, _amount, latestEpoch);\n    }\n\n    /**\n     * @notice Add reward token to a specific epoch\n     * @param _token    Reward token address\n     * @param _amount   Amount of reward tokens to add\n     * @param _epoch    Which epoch to add to (must be less than the previous epoch)\n     */\n    function addRewardToEpoch(\n        address _token,\n        uint256 _amount,\n        uint256 _epoch\n    ) external {\n        auraLocker.checkpointEpoch();\n\n        uint256 latestEpoch = auraLocker.epochCount() - 1;\n        require(_epoch <= latestEpoch, \"Cannot assign to the future\");\n\n        if (_epoch == latestEpoch) {\n            _addReward(_token, _amount, latestEpoch);\n        } else {\n            uint256 len = rewardEpochs[_token].length;\n            require(len == 0 || rewardEpochs[_token][len - 1] < _epoch, \"Cannot backdate to this epoch\");\n\n            _addReward(_token, _amount, _epoch);\n        }\n    }\n\n    /**\n     * @notice  Transfer reward tokens from sender to contract for vlCVX holders\n     * @dev     Add reward token for specific epoch\n     * @param _token    Reward token address\n     * @param _amount   Amount of reward tokens\n     * @param _epoch    Epoch to add tokens to\n     */\n    function _addReward(\n        address _token,\n        uint256 _amount,\n        uint256 _epoch\n    ) internal nonReentrant {\n        // Pull before reward accrual\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n\n        //convert to reward per token\n        uint256 supply = auraLocker.totalSupplyAtEpoch(_epoch);\n        uint256 rPerT = (_amount * 1e20) / supply;\n        rewardData[_token][_epoch] += rPerT;\n\n        //add epoch to list\n        uint256 len = rewardEpochs[_token].length;\n        if (len == 0 || rewardEpochs[_token][len - 1] < _epoch) {\n            rewardEpochs[_token].push(_epoch);\n        }\n\n        //event\n        emit RewardAdded(_token, _epoch, _amount);\n    }\n\n    /* ========== GET REWARDS ========== */\n\n    /**\n     * @notice Claim rewards for a specific token since the first epoch.\n     * @param _account  Address of vlCVX holder\n     * @param _token    Reward token address\n     */\n    function getReward(address _account, address _token) public {\n        _getReward(_account, _token, 0);\n    }\n\n    /**\n     * @notice Claim rewards for a specific token at a specific epoch\n     * @param _account      Address of vlCVX holder\n     * @param _token        Reward token address\n     * @param _startIndex   Index of rewardEpochs[_token] to start checking for rewards from\n     */\n    function getReward(\n        address _account,\n        address _token,\n        uint256 _startIndex\n    ) public {\n        _getReward(_account, _token, _startIndex);\n    }\n\n    /**\n     * @notice Claim rewards for a specific token at a specific epoch\n     * @param _account     Address of vlCVX holder\n     * @param _token       Reward token address\n     * @param _startIndex  Index of rewardEpochs[_token] to start checking for rewards from\n     */\n    function _getReward(\n        address _account,\n        address _token,\n        uint256 _startIndex\n    ) public {\n        //get claimable tokens\n        (uint256 claimableTokens, uint256 index) = _allClaimableRewards(_account, _token, _startIndex);\n\n        if (claimableTokens > 0) {\n            //set claim checkpoint\n            userClaims[_token][_account] = index;\n\n            //send\n            IERC20(_token).safeTransfer(_account, claimableTokens);\n\n            //event\n            emit RewardPaid(_account, _token, claimableTokens, index);\n        }\n    }\n\n    /**\n     * @notice  Allow a user to set their claimed index forward without claiming rewards\n     *          Because claims cycle through all periods that a specific reward was given\n     *          there becomes a situation where, for example, a new user could lock\n     *          2 years from now and try to claim a token that was given out every week prior.\n     *          This would result in a 2mil gas checkpoint.(about 20k gas * 52 weeks * 2 years)\n     * @param _token  Reward token to forfeit\n     * @param _index  Epoch index to forfeit from\n     */\n    function forfeitRewards(address _token, uint256 _index) external {\n        require(_index > 0 && _index < rewardEpochs[_token].length - 1, \"!past\");\n        require(_index >= userClaims[_token][msg.sender], \"already claimed\");\n\n        //set claim checkpoint. next claim starts from index+1\n        userClaims[_token][msg.sender] = _index + 1;\n\n        emit RewardForfeited(msg.sender, _token, _index);\n    }\n\n    /* ========== VIEW REWARDS ========== */\n\n    /**\n     * @notice Get claimable rewards (rewardToken) for vlCVX holder\n     * @param _account  Address of vlCVX holder\n     * @param _token    Reward token address\n     */\n    function claimableRewards(address _account, address _token) external view returns (uint256) {\n        (uint256 rewards, ) = _allClaimableRewards(_account, _token, 0);\n        return rewards;\n    }\n\n    /**\n     * @notice Get claimable rewards for a token at a specific epoch\n     * @param _account     Address of vlCVX holder\n     * @param _token       Reward token address\n     * @param _epoch       The epoch to check for rewards\n     */\n    function claimableRewardsAtEpoch(\n        address _account,\n        address _token,\n        uint256 _epoch\n    ) external view returns (uint256) {\n        return _claimableRewards(_account, _token, _epoch);\n    }\n\n    /**\n     * @notice  Get all claimable rewards by looping through each epoch starting with the latest\n     *          saved epoch the user last claimed from\n     * @param _account  Address of vlCVX holder\n     * @param _token    Reward token\n     * @param _startIndex  Index of rewardEpochs[_token] to start checking for rewards from\n     */\n    function _allClaimableRewards(\n        address _account,\n        address _token,\n        uint256 _startIndex\n    ) internal view returns (uint256, uint256) {\n        uint256 latestEpoch = auraLocker.epochCount() - 1;\n        // e.g. tokenEpochs = 31, 21\n        uint256 tokenEpochs = rewardEpochs[_token].length;\n\n        // e.g. epochIndex = 0\n        uint256 epochIndex = userClaims[_token][_account];\n        // e.g. epochIndex = 27 > 0 ? 27 : 0 = 27\n        epochIndex = _startIndex > epochIndex ? _startIndex : epochIndex;\n\n        if (epochIndex >= tokenEpochs) {\n            return (0, tokenEpochs);\n        }\n\n        uint256 claimableTokens = 0;\n\n        for (uint256 i = epochIndex; i < tokenEpochs; i++) {\n            //only claimable after rewards are \"locked in\"\n            if (rewardEpochs[_token][i] < latestEpoch) {\n                claimableTokens += _claimableRewards(_account, _token, rewardEpochs[_token][i]);\n                //return index user claims should be set to\n                epochIndex = i + 1;\n            }\n        }\n        return (claimableTokens, epochIndex);\n    }\n\n    /**\n     * @notice Get claimable rewards for a token at a specific epoch\n     * @param _account     Address of vlCVX holder\n     * @param _token       Reward token address\n     * @param _epoch       The epoch to check for rewards\n     */\n    function _claimableRewards(\n        address _account,\n        address _token,\n        uint256 _epoch\n    ) internal view returns (uint256) {\n        //get balance and calc share\n        uint256 balance = auraLocker.balanceAtEpochOf(_epoch, _account);\n        return (balance * rewardData[_token][_epoch]) / 1e20;\n    }\n\n    /**\n     * @notice Simply gets the current epoch count for a given reward token\n     * @param _token    Reward token address\n     * @return _epochs  Number of epochs\n     */\n    function rewardEpochsCount(address _token) external view returns (uint256) {\n        return rewardEpochs[_token].length;\n    }\n}"
    },
    {
      "filename": "contracts/AuraMerkleDrop.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport { MerkleProof } from \"@openzeppelin/contracts-0.8/utils/cryptography/MerkleProof.sol\";\nimport { IAuraLocker } from \"./Interfaces.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol\";\n\n/**\n * @title   AuraMerkleDrop\n * @dev     Forked from convex-platform/contracts/contracts/MerkleAirdrop.sol. Changes:\n *            - solc 0.8.11 & OpenZeppelin MerkleDrop\n *            - Delayed start w/ trigger\n *            - EndTime for withdrawal to treasuryDAO\n *            - Penalty on claim & AuraLocker lock (only if address(auraLocker) != 0)\n *            - Non custodial (cannot change root)\n */\ncontract AuraMerkleDrop {\n    using SafeERC20 for IERC20;\n\n    address public dao;\n    bytes32 public merkleRoot;\n\n    IERC20 public immutable aura;\n    IAuraLocker public auraLocker;\n\n    address public immutable penaltyForwarder;\n    uint256 public pendingPenalty = 0;\n\n    uint256 public startTime;\n    uint256 public immutable expiryTime;\n\n    mapping(address => bool) public hasClaimed;\n\n    event DaoSet(address newDao);\n    event RootSet(bytes32 newRoot);\n    event StartedEarly();\n    event ExpiredWithdrawn(uint256 amount);\n    event LockerSet(address newLocker);\n    event Claimed(address addr, uint256 amt, bool locked);\n    event PenaltyForwarded(uint256 amount);\n\n    /**\n     * @param _dao              The Aura Dao\n     * @param _merkleRoot       Merkle root\n     * @param _aura             Aura token\n     * @param _auraLocker       Aura locker contract\n     * @param _penaltyForwarder PenaltyForwarded contract\n     * @param _startDelay       Delay until claim is live\n     * @param _expiresAfter     Timestamp claim expires\n     */\n    constructor(\n        address _dao,\n        bytes32 _merkleRoot,\n        address _aura,\n        address _auraLocker,\n        address _penaltyForwarder,\n        uint256 _startDelay,\n        uint256 _expiresAfter\n    ) {\n        dao = _dao;\n        merkleRoot = _merkleRoot;\n        aura = IERC20(_aura);\n        auraLocker = IAuraLocker(_auraLocker);\n        penaltyForwarder = _penaltyForwarder;\n        startTime = block.timestamp + _startDelay;\n\n        require(_expiresAfter > 2 weeks, \"!expiry\");\n        expiryTime = startTime + _expiresAfter;\n    }\n\n    /***************************************\n                    CONFIG\n    ****************************************/\n\n    function setDao(address _newDao) external {\n        require(msg.sender == dao, \"!auth\");\n        dao = _newDao;\n        emit DaoSet(_newDao);\n    }\n\n    function setRoot(bytes32 _merkleRoot) external {\n        require(msg.sender == dao, \"!auth\");\n        require(merkleRoot == bytes32(0), \"already set\");\n        merkleRoot = _merkleRoot;\n        emit RootSet(_merkleRoot);\n    }\n\n    function startEarly() external {\n        require(msg.sender == dao, \"!auth\");\n        startTime = block.timestamp;\n        emit StartedEarly();\n    }\n\n    function withdrawExpired() external {\n        require(msg.sender == dao, \"!auth\");\n        require(block.timestamp > expiryTime, \"!expired\");\n        uint256 amt = aura.balanceOf(address(this));\n        aura.safeTransfer(dao, amt);\n        emit ExpiredWithdrawn(amt);\n    }\n\n    function setLocker(address _newLocker) external {\n        require(msg.sender == dao, \"!auth\");\n        auraLocker = IAuraLocker(_newLocker);\n        emit LockerSet(_newLocker);\n    }\n\n    /***************************************\n                    CLAIM\n    ****************************************/\n\n    function claim(\n        bytes32[] calldata _proof,\n        uint256 _amount,\n        bool _lock\n    ) public returns (bool) {\n        require(merkleRoot != bytes32(0), \"!root\");\n        require(block.timestamp > startTime, \"!started\");\n        require(block.timestamp < expiryTime, \"!active\");\n        require(_amount > 0, \"!amount\");\n        require(hasClaimed[msg.sender] == false, \"already claimed\");\n\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender, _amount));\n        require(MerkleProof.verify(_proof, merkleRoot, leaf), \"invalid proof\");\n\n        hasClaimed[msg.sender] = true;\n\n        if (_lock) {\n            aura.safeApprove(address(auraLocker), 0);\n            aura.safeApprove(address(auraLocker), _amount);\n            auraLocker.lock(msg.sender, _amount);\n        } else {\n            // If there is an address for auraLocker, and not locking, apply 20% penalty\n            uint256 penalty = address(auraLocker) == address(0) ? 0 : (_amount * 2) / 10;\n            pendingPenalty += penalty;\n            aura.safeTransfer(msg.sender, _amount - penalty);\n        }\n\n        emit Claimed(msg.sender, _amount, _lock);\n        return true;\n    }\n\n    /***************************************\n                    FORWARD\n    ****************************************/\n\n    function forwardPenalty() public {\n        uint256 toForward = pendingPenalty;\n        pendingPenalty = 0;\n        require(penaltyForwarder != address(0), \"!forwarder\");\n        aura.safeTransfer(penaltyForwarder, toForward);\n        emit PenaltyForwarded(toForward);\n    }\n}"
    },
    {
      "filename": "contracts/AuraPenaltyForwarder.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport { IExtraRewardsDistributor } from \"./Interfaces.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title AuraPenaltyForwarder\n * @dev Receives a given token and forwards it on to a distribution contract. Used during\n *      the bootstrapping period to forward AURA rewards to the extra rewards distributor.\n */\ncontract AuraPenaltyForwarder {\n    using SafeERC20 for IERC20;\n\n    IExtraRewardsDistributor public immutable distributor;\n    IERC20 public immutable token;\n\n    uint256 public immutable distributionDelay;\n    uint256 public lastDistribution;\n\n    event Forwarded(uint256 amount);\n\n    /**\n     * @dev During deployment approves the distributor to spend all tokens\n     * @param _distributor  Contract that will distribute tokens\n     * @param _token        Token to be distributed\n     * @param _delay        Delay between each distribution trigger\n     */\n    constructor(\n        address _distributor,\n        address _token,\n        uint256 _delay\n    ) {\n        distributor = IExtraRewardsDistributor(_distributor);\n        token = IERC20(_token);\n        distributionDelay = _delay;\n\n        lastDistribution = block.timestamp;\n\n        token.safeApprove(address(distributor), type(uint256).max);\n    }\n\n    /**\n     * @dev Forwards the complete balance of token in this contract to the distributor\n     */\n    function forward() public {\n        require(block.timestamp > lastDistribution + distributionDelay, \"!elapsed\");\n        lastDistribution = block.timestamp;\n\n        uint256 bal = token.balanceOf(address(this));\n        require(bal > 0, \"!empty\");\n\n        distributor.addReward(address(token), bal);\n\n        emit Forwarded(bal);\n    }\n}"
    },
    {
      "filename": "contracts/AuraBalRewardPool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport { AuraMath } from \"./AuraMath.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts-0.8/utils/math/SafeMath.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IAuraLocker } from \"./Interfaces.sol\";\n\n/**\n * @title   AuraBalRewardPool\n * @author  Synthetix -> ConvexFinance -> adapted\n * @notice  This AuraBalRewardPool is deployed to support auraBAL deposits during the first 2\n *          weeks of system operation. After which, the BaseRewardPool hooked into the Booster (lockRewards)\n *          will be used for auraBAL farming.\n * @dev     Modifications from convex-platform/contracts/contracts/BaseRewardPool.sol:\n *            - Delayed start (tokens transferred then delay is enforced before notification)\n *            - One time duration of 14 days\n *            - Remove child reward contracts\n *            - Penalty on claim at 20%\n */\ncontract AuraBalRewardPool {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable rewardToken;\n    IERC20 public immutable stakingToken;\n    uint256 public constant duration = 14 days;\n\n    address public immutable rewardManager;\n\n    IAuraLocker public immutable auraLocker;\n    address public immutable penaltyForwarder;\n    uint256 public pendingPenalty = 0;\n    uint256 public immutable startTime;\n\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    uint256 private _totalSupply;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) private _balances;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward, bool locked);\n    event PenaltyForwarded(uint256 amount);\n\n    /**\n     * @dev Simple constructoor\n     * @param _stakingToken  Pool LP token\n     * @param _rewardToken   $AURA\n     * @param _rewardManager Depositor\n     * @param _auraLocker    $AURA lock contract\n     * @param _penaltyForwarder Address to which penalties are sent\n     */\n    constructor(\n        address _stakingToken,\n        address _rewardToken,\n        address _rewardManager,\n        address _auraLocker,\n        address _penaltyForwarder,\n        uint256 _startDelay\n    ) {\n        stakingToken = IERC20(_stakingToken);\n        rewardToken = IERC20(_rewardToken);\n        rewardManager = _rewardManager;\n        auraLocker = IAuraLocker(_auraLocker);\n        penaltyForwarder = _penaltyForwarder;\n        rewardToken.safeApprove(_auraLocker, type(uint256).max);\n\n        require(_startDelay < 2 weeks, \"!delay\");\n        startTime = block.timestamp + _startDelay;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return AuraMath.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(totalSupply())\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            balanceOf(account).mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(\n                rewards[account]\n            );\n    }\n\n    function stake(uint256 _amount) public updateReward(msg.sender) returns (bool) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        _totalSupply = _totalSupply.add(_amount);\n        _balances[msg.sender] = _balances[msg.sender].add(_amount);\n\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Staked(msg.sender, _amount);\n\n        return true;\n    }\n\n    function stakeAll() external returns (bool) {\n        uint256 balance = stakingToken.balanceOf(msg.sender);\n        stake(balance);\n        return true;\n    }\n\n    function stakeFor(address _for, uint256 _amount) public updateReward(_for) returns (bool) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        //give to _for\n        _totalSupply = _totalSupply.add(_amount);\n        _balances[_for] = _balances[_for].add(_amount);\n\n        //take away from sender\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Staked(_for, _amount);\n\n        return true;\n    }\n\n    function withdraw(\n        uint256 amount,\n        bool claim,\n        bool lock\n    ) public updateReward(msg.sender) returns (bool) {\n        require(amount > 0, \"RewardPool : Cannot withdraw 0\");\n\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        stakingToken.safeTransfer(msg.sender, amount);\n        emit Withdrawn(msg.sender, amount);\n\n        if (claim) {\n            getReward(lock);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Gives a staker their rewards\n     * @param _lock Lock the rewards? If false, takes a 20% haircut\n     */\n    function getReward(bool _lock) public updateReward(msg.sender) returns (bool) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            if (_lock) {\n                auraLocker.lock(msg.sender, reward);\n            } else {\n                uint256 penalty = (reward * 2) / 10;\n                pendingPenalty += penalty;\n                rewardToken.safeTransfer(msg.sender, reward - penalty);\n            }\n            emit RewardPaid(msg.sender, reward, _lock);\n        }\n        return true;\n    }\n\n    /**\n     * @dev Forwards to the penalty forwarder for distro to Aura Lockers\n     */\n    function forwardPenalty() public {\n        uint256 toForward = pendingPenalty;\n        pendingPenalty = 0;\n        rewardToken.safeTransfer(penaltyForwarder, toForward);\n        emit PenaltyForwarded(toForward);\n    }\n\n    /**\n     * @dev Called once to initialise the rewards based on balance of stakeToken\n     */\n    function initialiseRewards() external returns (bool) {\n        require(msg.sender == rewardManager || block.timestamp > startTime, \"!authorized\");\n        require(rewardRate == 0, \"!one time\");\n\n        uint256 rewardsAvailable = rewardToken.balanceOf(address(this));\n        require(rewardsAvailable > 0, \"!balance\");\n\n        rewardRate = rewardsAvailable.div(duration);\n\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(duration);\n\n        emit RewardAdded(rewardsAvailable);\n\n        return true;\n    }\n}"
    },
    {
      "filename": "contracts/BalLiquidityProvider.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport { IVault } from \"./Interfaces.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title   BalLiquidityProvider\n * @notice  Provides initial liquidity to a Balancer pool on behalf of a given DAO\n */\ncontract BalLiquidityProvider {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable startToken;\n    IERC20 public immutable pairToken;\n    uint256 public minPairAmount;\n\n    address private immutable provider;\n    address public immutable dao;\n\n    IVault public immutable bVault;\n\n    event LiquidityProvided(uint256[] input, uint256 output);\n    event MinPairAmountChanged(uint256 oldMinPairAmount, uint256 newMinPairAmount);\n\n    constructor(\n        address _startToken,\n        address _pairToken,\n        uint256 _minPairAmount,\n        address _dao,\n        address _bVault\n    ) {\n        startToken = IERC20(_startToken);\n        pairToken = IERC20(_pairToken);\n        minPairAmount = _minPairAmount;\n        provider = msg.sender;\n        dao = _dao;\n        bVault = IVault(_bVault);\n    }\n\n    /**\n     * @dev Provides liquidity on behalf of the dao, in a non-custodial manner.\n     *      Has protections in place to ensure that no erroneous liquidity data gets added.\n     */\n    function provideLiquidity(bytes32 _poolId, IVault.JoinPoolRequest memory _request) public {\n        require(msg.sender == provider, \"!auth\");\n        require(_request.assets.length == 2 && _request.maxAmountsIn.length == 2, \"!valid\");\n        require(pairToken.balanceOf(address(this)) > minPairAmount, \"!minLiq\");\n\n        for (uint256 i = 0; i < 2; i++) {\n            address asset = address(_request.assets[i]);\n            require(asset == address(startToken) || asset == address(pairToken), \"!asset\");\n\n            IERC20 tkn = IERC20(asset);\n            uint256 bal = tkn.balanceOf(address(this));\n            require(bal > 0 && bal == _request.maxAmountsIn[i], \"!bal\");\n\n            tkn.safeApprove(address(bVault), 0);\n            tkn.safeApprove(address(bVault), bal);\n        }\n\n        (address pool, ) = bVault.getPool(_poolId);\n        uint256 supplyBefore = IERC20(pool).totalSupply();\n        require(supplyBefore == 0, \"!init\");\n\n        bVault.joinPool(_poolId, address(this), dao, _request);\n\n        uint256 balAfter = IERC20(pool).balanceOf(dao);\n        require(balAfter > 0, \"!mint\");\n\n        emit LiquidityProvided(_request.maxAmountsIn, balAfter);\n    }\n\n    /**\n     * @dev Allows the DAO to change the minimum amount of the pair token that must be added as liquidity\n     */\n    function changeMinPairAmount(uint256 _newAmount) external {\n        require(msg.sender == dao, \"!auth\");\n        emit MinPairAmountChanged(minPairAmount, _newAmount);\n        minPairAmount = _newAmount;\n    }\n\n    /**\n     * @dev Rescues a given token from the contract.\n     * Only provider or DAO can call this function.\n     */\n    function rescueToken(address _erc20) external {\n        require(msg.sender == provider || msg.sender == dao, \"!auth\");\n        IERC20 tkn = IERC20(_erc20);\n        tkn.safeTransfer(dao, tkn.balanceOf(address(this)));\n    }\n}"
    },
    {
      "filename": "convex-platform/contracts/contracts/ConvexMasterChef.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-0.6/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-0.6/utils/Context.sol\";\nimport \"@openzeppelin/contracts-0.6/access/Ownable.sol\";\nimport \"./interfaces/IRewarder.sol\";\n\n/**\n * @title   ConvexMasterChef\n * @author  ConvexFinance\n * @notice  Masterchef can distribute rewards to n pools over x time\n * @dev     There are some caveats with this usage - once it's turned on it can't be turned off,\n *          and thus it can over complicate the distribution of these rewards.\n *          To kick things off, just transfer CVX here and add some pools - rewards will be distributed\n *          pro-rata based on the allocation points in each pool vs the total alloc.\n */\ncontract ConvexMasterChef is Ownable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // Info of each user.\n    struct UserInfo {\n        uint256 amount; // How many LP tokens the user has provided.\n        uint256 rewardDebt; // Reward debt. See explanation below.\n        //\n        // We do some fancy math here. Basically, any point in time, the amount of CVXs\n        // entitled to a user but is pending to be distributed is:\n        //\n        //   pending reward = (user.amount * pool.accCvxPerShare) - user.rewardDebt\n        //\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\n        //   1. The pool's `accCvxPerShare` (and `lastRewardBlock`) gets updated.\n        //   2. User receives the pending reward sent to his/her address.\n        //   3. User's `amount` gets updated.\n        //   4. User's `rewardDebt` gets updated.\n    }\n\n    // Info of each pool.\n    struct PoolInfo {\n        IERC20 lpToken; // Address of LP token contract.\n        uint256 allocPoint; // How many allocation points assigned to this pool. CVX to distribute per block.\n        uint256 lastRewardBlock; // Last block number that CVXs distribution occurs.\n        uint256 accCvxPerShare; // Accumulated CVXs per share, times 1e12. See below.\n        IRewarder rewarder;\n    }\n\n    //cvx\n    IERC20 public immutable cvx;\n    // CVX tokens created per block.\n    uint256 public immutable rewardPerBlock;\n    // Bonus muliplier for early cvx makers.\n    uint256 public constant BONUS_MULTIPLIER = 2;\n\n    // Info of each pool.\n    PoolInfo[] public poolInfo;\n    // Info of each user that stakes LP tokens.\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n    // Total allocation points. Must be the sum of all allocation points in all pools.\n    uint256 public totalAllocPoint = 0;\n    // The block number when CVX mining starts.\n    uint256 public immutable startBlock;\n    uint256 public immutable endBlock;\n\n    // Events\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event RewardPaid(address indexed user,  uint256 indexed pid, uint256 amount);\n    event EmergencyWithdraw(\n        address indexed user,\n        uint256 indexed pid,\n        uint256 amount\n    );\n\n    constructor(\n        IERC20 _cvx,\n        uint256 _rewardPerBlock,\n        uint256 _startBlock,\n        uint256 _endBlock\n    ) public {\n        cvx = _cvx;\n        rewardPerBlock = _rewardPerBlock;\n        startBlock = _startBlock;\n        endBlock = _endBlock;\n    }\n\n    function poolLength() external view returns (uint256) {\n        return poolInfo.length;\n    }\n\n    // Add a new lp to the pool. Can only be called by the owner.\n    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.\n    function add(\n        uint256 _allocPoint,\n        IERC20 _lpToken,\n        IRewarder _rewarder,\n        bool _withUpdate\n    ) public onlyOwner {\n        if (_withUpdate) {\n            massUpdatePools();\n        }\n        uint256 lastRewardBlock = block.number > startBlock\n            ? block.number\n            : startBlock;\n        totalAllocPoint = totalAllocPoint.add(_allocPoint);\n        poolInfo.push(\n            PoolInfo({\n                lpToken: _lpToken,\n                allocPoint: _allocPoint,\n                lastRewardBlock: lastRewardBlock,\n                accCvxPerShare: 0,\n                rewarder: _rewarder\n            })\n        );\n    }\n\n    // Update the given pool's CVX allocation point. Can only be called by the owner.\n    function set(\n        uint256 _pid,\n        uint256 _allocPoint,\n        IRewarder _rewarder,\n        bool _withUpdate,\n        bool _updateRewarder\n    ) public onlyOwner {\n        if (_withUpdate) {\n            massUpdatePools();\n        }\n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(\n            _allocPoint\n        );"
    }
  ]
}