{
  "Title": "[L10] Lack of input validation",
  "Content": "[Throughout the codebase](https://github.com/holdefi/Holdefi/tree/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts), there are certain functions and calculations that do not perform validation checks to ensure the validity of the inputs. Some of them are the following ones:\n\n\n* The [`withdraw` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/CollateralsWallet.sol#L20) in the `CollateralsWallet` contract does not check that the `recipient` is not the zero address.\n* The [`setPrice` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPrices.sol#L39) in the `HoldefiPrices` contract does not check whether the `newPrice` is the same as the old price, [triggering an event](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPrices.sol#L43) without any new relevant information.\n* The [`setPauseDuration` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPauser.sol#L86) in the `HoldefiPauser` contract does not check the `newPauseDuration` parameter, which could be zero or a very long period of time, possibly locking important functions of the `Holdefi` system.\n\n\nEven though this issue does not pose a security risk, the lack of validation on user-controlled parameters may result in erroneous transactions considering that some clients or owners may default to sending null parameters if none are specified. Consider always adding validation checks to ensure that the parameters are always in the expected range of values.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/CollateralsWallet.sol",
      "content": "pragma solidity ^0.5.16;\r\n\r\ninterface ERC20 {\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\n// This contract holds collateralls\r\ncontract CollateralsWallet {\r\n\r\n\taddress public holdefiContract;\r\n\r\n\t// Disposable function to Get in touch with Holdefi contract\r\n\tfunction setHoldefiContract(address holdefiContractAddress) external {\r\n\t\trequire (holdefiContract == address(0),'Should be set once');\r\n\t\tholdefiContract = holdefiContractAddress;\r\n\t}\r\n\t\r\n\t// Holdefi contract withdraws collateral's tokens from this contract to caller's account\r\n\tfunction withdraw (address collateralAsset, address payable recipient, uint amount) external {\r\n\t\trequire (msg.sender == holdefiContract,'Sender should be holdefi contract');\r\n\t\t\r\n\t\tif (collateralAsset == address(0)){\r\n\t\t\trecipient.transfer(amount);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tERC20 token = ERC20(collateralAsset);\r\n\t\t\tbool success = token.transfer(recipient, amount);\r\n\t\t\trequire (success, 'Cannot Transfer Token');\r\n\t\t}\r\n\t}\r\n\r\n\tfunction () payable external {\r\n\t\trequire (msg.sender == holdefiContract,'Sender should be holdefi contract');\r\n\t}\r\n}"
    },
    {
      "filename": "contracts/HoldefiPrices.sol",
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./Ownable.sol\";\r\n\r\ninterface ETHMedianizerInterface {\r\n\r\n   function read() external view returns(uint price);\r\n}\r\n\r\n //This contract will be changed before adding ERC20 tokens that are not stable coin\r\ncontract HoldefiPrices is Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    uint constant public priceDecimal = 10**18;\r\n   \r\n    mapping(address => uint) public assetPrices;\r\n\r\n    ETHMedianizerInterface public ethMedianizer;\r\n\r\n    event PriceChanged(address asset, uint newPrice);\r\n\r\n    constructor(address newOwnerChanger, ETHMedianizerInterface ethMedianizerContract) public Ownable(newOwnerChanger) {\r\n        ethMedianizer = ethMedianizerContract;\r\n    }\r\n\r\n    // Returns price of selected asset\r\n    function getPrice(address asset) external view returns(uint price) {\r\n    \tif (asset == address(0)){\r\n    \t\tprice = uint(ethMedianizer.read());\r\n    \t}\r\n        else {\r\n            price = assetPrices[asset];\r\n        }\r\n    }\r\n\r\n     // TODO: This function should be internal for the first version of priceFeed\r\n    function setPrice(address asset, uint newPrice) public onlyOwner {\r\n        require (asset != address(0),'Price of ETH can not be changed');\r\n\r\n        assetPrices[asset] = newPrice;\r\n        emit PriceChanged(asset, newPrice);\r\n    }\r\n\r\n    // Called by owner to add new stable token at 1$ price\r\n    function addStableCoin(address asset) public onlyOwner {\r\n        setPrice(asset, priceDecimal);\r\n    }\r\n    \r\n    function() payable external {\r\n        revert();\r\n    }\r\n}"
    },
    {
      "filename": "contracts/HoldefiPauser.sol",
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./Ownable.sol\";\r\n\r\n// Taking ideas from Open Zeppelin's Pausable contract\r\ncontract HoldefiPauser is Ownable {    \r\n    address public pauser;\r\n\r\n     // '0' -> supply\r\n     // '1' -> withdrawSupply\r\n     // '2' -> collatralize\r\n     // '3' -> withdrawCollateral\r\n     // '4' -> borrow\r\n     // '5' -> repayBorrrow\r\n     // '6' -> liquidateBorrowerCollateral\r\n     // '7' -> buyLiquidatedCollateral\r\n    \r\n    uint constant functionsNum = 8;\r\n    uint[8] public paused;\r\n\r\n    uint public pauseDuration = 2592000;\r\n\r\n     \r\n    constructor (address newOwnerChanger) Ownable(newOwnerChanger) public {\r\n    }\r\n\r\n    // Modifier to make a function callable only by owner or pauser   \r\n    modifier onlyPausers() {\r\n        require(msg.sender == owner || msg.sender == pauser , 'Sender should be Owner or Pauser');\r\n        _;\r\n    }\r\n    \r\n    // Modifier to make a function callable only when a functions is not paused.\r\n    modifier whenNotPaused(uint index) {\r\n        require(!isPause(index), \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    // Modifier to make a function callable only when a functions is paused.\r\n    modifier whenPaused(uint index) {\r\n        require(isPause(index), \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    function isPause(uint index) public view returns(bool res) {\r\n        if (block.timestamp - paused[index] >= pauseDuration) {\r\n            res = false;\r\n        }\r\n        else {\r\n            res = true;\r\n        }\r\n    }\r\n    \r\n    // Called by pausers to pause, triggers stopped state.\r\n    function pause(uint index) public onlyPausers {\r\n        paused[index] = block.timestamp;\r\n    }\r\n\r\n    // Called by owner to unpause, returns to normal state.\r\n    function unpause(uint index) public onlyOwner {\r\n        paused[index] = 0;\r\n    }\r\n\r\n    // Called by pausers to pause, triggers stopped state for selected functions\r\n    function batchPause(bool[8] memory newPaused) public onlyPausers {\r\n        for (uint i=0; i<functionsNum; i++) {\r\n            if (newPaused[i] == true){\r\n                pause(i);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Called by pausers to pause, returns to normal state for selected functions\r\n    function batchUnpause(bool[8] memory newUnpaused) public onlyOwner {\r\n        for (uint i=0; i<functionsNum; i++) {\r\n            if (newUnpaused[i] == true){\r\n                unpause(i);\r\n            }\r\n        }\r\n    }\r\n    // Called by owner to set a new pauser\r\n    function setPauser(address newPauser) external onlyOwner {\r\n        pauser = newPauser;\r\n    }\r\n\r\n    function setPauseDuration(uint newPauseDuration) external onlyOwner {\r\n        pauseDuration = newPauseDuration;\r\n    }\r\n}"
    }
  ]
}