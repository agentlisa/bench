{
  "Title": "[M-03] Borrower/Lender excessive ETH not refunded and permanently locked in protocol",
  "Content": "# Lines of code\n\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L292\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L315\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L223\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L265\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineLib.sol#L71\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L388\n\n\n# Vulnerability details\n\n## Impact\nThe protocol does not refund overpayment of ETH. Excessive ETH is not included in the protocols accounting as a result the funds are permanently locked in the protocol **(Loss of funds)**. \nThere are multiple scenarios where excessive ETH could be sent by Borrowers and Lenders to the protocol.\n\nThe vulnerability effects at least five different scenarios and locks both the lender and borrowers ETH in LineOfCredit if overpaid. **There is no way to transfer the locked ETH back to the the users**, as the withdraw methods are dependent on accounting (which is not updated with locked ETH).\n\nThis vulnerability impacts EscrowedLine, LineOfCredit, SpigotedLine and SecuredLine\n\n## Proof of Concept\nThe bug resides in `receiveTokenOrETH` function when receiving ETH. \n\nThe function does not handle cases where `msg.value` is larger than `amount` meaning a refund is needed (`msg.value` - `amount`). In such cases, `msg.value` is added to the balance of LineOfCredit although only `amount` is used in internal accounting. Thus the excessive ETH  is permanently locked in the contract as the withdraw methods are dependent on the internal accounting.\n\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineLib.sol#L59\n```\n  function receiveTokenOrETH(\n      address token,\n      address sender,\n      uint256 amount\n    )\n      external\n      returns (bool)\n    {\n        if(token == address(0)) { revert TransferFailed(); }\n        if(token != Denominations.ETH) { // ERC20\n            IERC20(token).safeTransferFrom(sender, address(this), amount);\n        } else { // ETH\n            if(msg.value < amount) { revert TransferFailed(); }\n        }\n        return true;\n    }\n```\n\nScenarios where borrowers ETH funds will be locked in LineOfCredit: \n1. Borrower calls `depositAndClose` with an ETH value that is above the owed debt.\n2. Borrower calls `depositAndRepay` with an ETH value that is above the amount specified in the parameters.\n3. Borrower calls `close` with an ETH value that is above the owed fees.\n\nScenarios where lenders ETH funds will be locked in LineOfCredit:\n1. Lender calls `addCredit` with and ETH value that is greater than the `amount` parameter.\n2. Lender calls `increaseCredit` with and ETH value that is greater than the `amount` parameter.\n\nThe above scenarios will happen when: \n* Excessive ETH is sent with the confidence that it will be refunded (expected). Intentionally or by mistake.\n* Excessive ETH will be sent (and expected to be refunded) when calling `depositeAndClose()`, `close(id)` and `depositAndRepay(amount)` as they internally update the fees with the `_accrue` method. The amount changes every second because part of the formula that calculates the fees is based on a multiplication of seconds past the previous calculations. In most cases, the caller will not know the amount of interest that will be accrued and must send excessive ETH to not revert the transaction.\n    * The formula that calculates interest: \n`InterestAccrued = (rate.dRate * drawnBalance * timespan) / INTEREST_DENOMINATOR + \n(rate.fRate * (facilityBalance - drawnBalance) * timespan) / INTEREST_DENOMINATOR `\nWhere `timespan` is `timespan= block.timestamp - rate.lastAccrued`\n    * Attached link to Debt DAO docs with more information: https://docs.debtdao.finance/faq/accrued-interest-calculation\n\nThe POC includes four of the mentioned scenarios. To run the POC add the below code to the LineOfCredit.t.sol test and execute `forge test -v`. Expected output:\n```\nRunning 4 tests for contracts/tests/LineOfCredit.t.sol:LineTest\n[PASS] test_freeze_eth_addCredit() (gas: 277920)\n[PASS] test_freeze_eth_depositAndClose() (gas: 280378)\n[PASS] test_freeze_eth_depositAndRepay() (gas: 302991)\n[PASS] test_freeze_eth_increaseCredit() (gas: 318830)\nTest result: ok. 4 passed; 0 failed; finished in 1.59ms\n```\nAdd the following code to tests:\n```\n    function _addCreditEth(address token, uint256 amount) internal {\n        vm.prank(borrower);\n        line.addCredit(dRate, fRate, amount, token, lender);\n        vm.stopPrank();\n        vm.prank(lender);\n        line.addCredit{value: amount}(dRate, fRate, amount, token, lender);\n        vm.stopPrank();\n    }\n    function test_freeze_eth_depositAndClose() public {\n        uint256 amount = 1 ether;\n        address eth = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n        // fund lender\n        deal(lender, amount*5);\n        // fund borrower\n        deal(borrower, amount*5);\n\n        // add credit to line\n        _addCreditEth(eth, amount);\n\n        //borrow 1 ether\n        bytes32 id = line.ids(0);\n        vm.startPrank(borrower);\n        line.borrow(id, amount);\n        vm.stopPrank();\n        \n        //depositAndClose full extra funds (amount * 2)\n        vm.startPrank(borrower);\n        line.depositAndClose{value:amount*2}();\n        vm.stopPrank();\n\n        //validate funds are stuck\n        console.log(address(line).balance);\n        assert(address(line).balance == amount*2 - amount);\n    }\n\n     function test_freeze_eth_depositAndRepay() public {\n        uint256 amount = 1 ether;\n        address eth = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n        // fund lender\n        deal(lender, amount*5);\n        // fund borrower\n        deal(borrower, amount*5);\n\n        // add credit to line\n        _addCreditEth(eth, amount);\n\n        //borrow 1 ether\n        bytes32 id = line.ids(0);\n        vm.startPrank(borrower);\n        line.borrow(id, amount);\n        vm.stopPrank();\n        \n        //depositAndRepay full extra funds (amount * 2)\n        vm.startPrank(borrower);\n        line.depositAndRepay{value:amount*2}(amount);\n        vm.stopPrank();\n\n\n        // Lender calls withdraw \n        vm.startPrank(lender);\n        line.withdraw(id, amount);\n        vm.stopPrank();\n\n        //validate funds are stuck\n        assert(address(line).balance == amount*2 - amount);\n    }\n\n    function test_freeze_eth_addCredit() public {\n        uint256 amount = 1 ether;\n        address eth = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n        // fund lender\n        deal(lender, amount*5);\n        // fund borrower\n        deal(borrower, amount*5);\n\n        // add credit to line\n        vm.prank(borrower);\n        line.addCredit(dRate, fRate, amount, eth, lender);\n        vm.stopPrank();\n        vm.prank(lender);\n        //double msg.value then amount\n        line.addCredit{value: amount*2}(dRate, fRate, amount, eth, lender);\n        vm.stopPrank();\n\n        //borrow 1 ether\n        bytes32 id = line.ids(0);\n        vm.startPrank(borrower);\n        line.borrow(id, amount);\n        vm.stopPrank();\n        \n        //depositAndClose full extra funds (amount)\n        vm.startPrank(borrower);\n        line.depositAndClose{value:amount}();\n        vm.stopPrank();\n\n        //validate funds are stuck\n        assert(address(line).balance == amount*2 - amount);\n    }\n\n    function test_freeze_eth_increaseCredit() public {\n        uint256 amount = 1 ether;\n        address eth = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n        // fund lender\n        deal(lender, amount*5);\n        // fund borrower\n        deal(borrower, amount*5);\n\n        // add credit to line\n        _addCreditEth(eth, amount);\n        \n        // get id\n        bytes32 id = line.ids(0);\n\n        // increase credit to line\n        vm.prank(borrower);\n        line.increaseCredit(id, amount);\n        vm.stopPrank();\n        vm.prank(lender);\n        //double msg.value then amount\n        line.increaseCredit{value:amount*2}(id, amount);\n        vm.stopPrank();\n\n        //total amount * 3 in contract\n\n        //borrow 2 ether\n        vm.startPrank(borrower);\n        line.borrow(id, amount * 2);\n        vm.stopPrank();\n        \n        //depositAndClose full extra funds (amount)\n        vm.startPrank(borrower);\n        line.depositAndClose{value:amount*2}();\n        vm.stopPrank();\n\n        //validate funds are stuck\n        assert(address(line).balance == amount*3 - amount*2);\n    }\n```\n\nThe POC demonstrates how Borrower and Lender funds get locked in the protocol.\n\n## Tools Used\n\nVS Code, Foundry\n\n## Recommended Mitigation Steps\nOptions:\n1. refund - in receiveTokenOrETH, refund tokens back to `msg.sender `if `msg.value > amount`\n2. revert - change the expression `if(msg.value < amount)` to `if(msg.value != amount)` and revert the transaction.",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-11-debt-dao-contest",
  "Code": [
    {
      "filename": "contracts/modules/credit/LineOfCredit.sol",
      "content": "pragma solidity ^0.8.9;\n\nimport { Denominations } from \"chainlink/Denominations.sol\";\nimport { IERC20 } from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20}  from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\n\nimport {LineLib} from \"../../utils/LineLib.sol\";\nimport {CreditLib} from \"../../utils/CreditLib.sol\";\nimport {CreditListLib} from \"../../utils/CreditListLib.sol\";\nimport {MutualConsent} from \"../../utils/MutualConsent.sol\";\nimport {InterestRateCredit} from \"../interest-rate/InterestRateCredit.sol\";\n\nimport {IOracle} from \"../../interfaces/IOracle.sol\";\nimport {ILineOfCredit} from \"../../interfaces/ILineOfCredit.sol\";\n\ncontract LineOfCredit is ILineOfCredit, MutualConsent {\n    using SafeERC20 for IERC20;\n\n    using CreditListLib for bytes32[];\n\n    uint256 public immutable deadline;\n\n    address public immutable borrower;\n\n    address public immutable arbiter;\n\n    IOracle public immutable oracle;\n\n    InterestRateCredit public immutable interestRate;\n\n    uint256 private count; // amount of open credit lines on a Line of Credit facility. ids.length includes null items\n\n    bytes32[] public ids; // all open credit lines\n\n    mapping(bytes32 => Credit) public credits; // id -> Reference ID for a credit line provided by a single Lender for a given token on a Line of Credit\n\n    // Line Financials aggregated accross all existing  Credit\n    LineLib.STATUS public status;\n\n    /**\n   * @notice            - How to deploy a Line of Credit\n   * @dev               - A Borrower and a first Lender agree on terms. Then the Borrower deploys the contract using the constructor below.\n   *                      Later, both Lender and Borrower must call _mutualConsent() during addCredit() to actually enable funds to be deposited.\n   * @param oracle_     - The price oracle to use for getting all token values.\n   * @param arbiter_    - A neutral party with some special priviliges on behalf of Borrower and Lender.\n   * @param borrower_   - The debitor for all credit lines in this contract.\n   * @param ttl_        - The time to live for all credit lines for the Line of Credit facility (sets the maturity/term of the Line of Credit)\n  */\n    constructor(\n        address oracle_,\n        address arbiter_,\n        address borrower_,\n        uint256 ttl_\n    ) {\n        oracle = IOracle(oracle_);\n        arbiter = arbiter_;\n        borrower = borrower_;\n        deadline = block.timestamp + ttl_;  //the deadline is the term/maturity/expiry date of the Line of Credit facility\n        interestRate = new InterestRateCredit();\n\n        emit DeployLine(oracle_, arbiter_, borrower_);\n    }\n\n    function init() external virtual returns(LineLib.STATUS) {\n      if(status != LineLib.STATUS.UNINITIALIZED) { revert AlreadyInitialized(); }\n      return _updateStatus(_init());\n    }\n\n    function _init() internal virtual returns(LineLib.STATUS) {\n       // If no collateral or Spigot then Line of Credit is immediately active\n      return LineLib.STATUS.ACTIVE;\n    }\n\n    ///////////////\n    // MODIFIERS //\n    ///////////////\n\n    modifier whileActive() {\n        if(status != LineLib.STATUS.ACTIVE) { revert NotActive(); }\n        _;\n    }\n\n    modifier whileBorrowing() {\n        if(count == 0 || credits[ids[0]].principal == 0) { revert NotBorrowing(); }\n        _;\n    }\n\n    modifier onlyBorrower() {\n        if(msg.sender != borrower) { revert CallerAccessDenied(); }\n        _;\n    }\n\n    /**\n     * @notice - mutualConsent() but hardcodes borrower address and uses the position id to\n                 get Lender address instead of passing it in directly\n     * @param id - position to pull lender address from for mutual consent agreement\n    */\n    modifier mutualConsentById(bytes32 id) {\n      if(_mutualConsent(borrower, credits[id].lender))  {\n        // Run whatever code is needed for the 2/2 consent\n        _;\n      }\n    }\n\n    /**\n     * @notice - evaluates all covenants encoded in _healthcheck from different Line variants\n     * @dev - updates `status` variable in storage if current status is diferent from existing status\n     * @return - current health status of Line\n    */\n    function healthcheck() external returns (LineLib.STATUS) {\n        // can only check if the line has been initialized\n        require(uint(status) >= uint( LineLib.STATUS.ACTIVE));\n        return _updateStatus(_healthcheck());\n    }\n\n    /// see ILineOfCredit.counts\n    function counts() external view returns (uint256, uint256) {\n        return (count, ids.length);\n    }\n\n    function _healthcheck() internal virtual returns (LineLib.STATUS) {\n        // if line is in a final end state then do not run _healthcheck()\n        LineLib.STATUS s = status;\n        if (\n            s == LineLib.STATUS.REPAID ||               // end state - good\n            s == LineLib.STATUS.INSOLVENT               // end state - bad\n        ) {\n            return s;\n        }\n\n        // Liquidate if all credit lines aren't closed by deadline\n        if (block.timestamp >= deadline && count > 0) {\n            emit Default(ids[0]); // can query all defaulted positions offchain once event picked up\n            return LineLib.STATUS.LIQUIDATABLE;\n        }\n\n        // if nothing wrong, return to healthy ACTIVE state  \n        return LineLib.STATUS.ACTIVE;\n    }\n\n\n    /// see ILineOfCredit.declareInsolvent\n    function declareInsolvent() external whileBorrowing returns(bool) {\n        if(arbiter != msg.sender) { revert CallerAccessDenied(); }\n        if(LineLib.STATUS.LIQUIDATABLE != _updateStatus(_healthcheck())) {\n            revert NotLiquidatable();\n        }\n\n        if(_canDeclareInsolvent()) {\n            _updateStatus(LineLib.STATUS.INSOLVENT);\n            return true;\n        } else {\n          return false;\n        }\n    }\n\n    function _canDeclareInsolvent() internal virtual returns(bool) {\n        // logic updated in Spigoted and Escrowed lines\n        return true;\n    }\n\n    /// see ILineOfCredit.updateOutstandingDebt\n    function updateOutstandingDebt() external override returns (uint256, uint256) {\n        return _updateOutstandingDebt();\n    }\n\n    function _updateOutstandingDebt()\n        internal\n        returns (uint256 principal, uint256 interest)\n    {\n        // use full length not count because positions might not be packed in order\n        uint256 len = ids.length;\n        if (len == 0) return (0, 0);\n\n        bytes32 id;\n        address oracle_ = address(oracle);  // gas savings\n        address interestRate_ = address(interestRate); // gas savings\n        \n        for (uint256 i; i < len; ++i) {\n            id = ids[i];\n\n            // null element in array from closing a position. skip for gas savings\n            if(id == bytes32(0)) { continue; }\n\n            (Credit memory c, uint256 _p, uint256 _i) = CreditLib.getOutstandingDebt(\n              credits[id],\n              id,\n              oracle_,\n              interestRate_\n            );\n            // update total outstanding debt\n            principal += _p;\n            interest += _i;\n            // save changes to storage\n            credits[id] = c;\n        }\n    }\n\n    /// see ILineOfCredit.accrueInterest\n    function accrueInterest() external override returns(bool) {\n        uint256 len = ids.length;\n        bytes32 id;\n        for (uint256 i; i < len; ++i) {\n          id = ids[i];\n          Credit memory credit = credits[id];\n          credits[id] = _accrue(credit, id);\n        }\n        \n        return true;\n    }\n\n    /**\n      @notice - accrues token demoninated interest on a lender's position.\n      @dev MUST call any time a position balance or interest rate changes\n      @param credit - the lender position that is accruing interest\n      @param id - the position id for credit position\n    */\n    function _accrue(Credit memory credit, bytes32 id) internal returns(Credit memory) {\n      return CreditLib.accrue(credit, id, address(interestRate));\n    }\n\n    /// see ILineOfCredit.addCredit\n    function addCredit(\n        uint128 drate,\n        uint128 frate,\n        uint256 amount,\n        address token,\n        address lender\n    )\n        external\n        payable\n        override\n        whileActive\n        mutualConsent(lender, borrower)\n        returns (bytes32)\n    {\n        LineLib.receiveTokenOrETH(token, lender, amount);\n\n        bytes32 id = _createCredit(lender, token, amount);\n\n        require(interestRate.setRate(id, drate, frate));\n        \n        return id;\n    }\n\n    /// see ILineOfCredit.setRates\n    function setRates(\n        bytes32 id,\n        uint128 drate,\n        uint128 frate\n    )\n      external\n      override\n      mutualConsentById(id)\n      returns (bool)\n    {\n        Credit memory credit = credits[id];\n        credits[id] = _accrue(credit, id);\n        require(interestRate.setRate(id, drate, frate));\n        emit SetRates(id, drate, frate);\n        return true;\n    }\n\n    /// see ILineOfCredit.increaseCredit\n    function increaseCredit(bytes32 id, uint256 amount)\n      external\n      payable\n      override\n      whileActive\n      mutualConsentById(id)\n      returns (bool)\n    {\n        Credit memory credit = credits[id];\n        credit = _accrue(credit, id);\n\n        credit.deposit += amount;\n        \n        credits[id] = credit;\n\n        LineLib.receiveTokenOrETH(credit.token, credit.lender, amount);\n\n        emit IncreaseCredit(id, amount);\n\n        return true;\n    }\n\n    ///////////////\n    // REPAYMENT //\n    ///////////////\n\n    /// see ILineOfCredit.depositAndClose\n    function depositAndClose()\n        external\n        payable\n        override\n        whileBorrowing\n        onlyBorrower\n        returns (bool)\n    {\n        bytes32 id = ids[0];\n        Credit memory credit = _accrue(credits[id], id);\n\n        // Borrower deposits the outstanding balance not already repaid\n        uint256 totalOwed = credit.principal + credit.interestAccrued;\n        LineLib.receiveTokenOrETH(credit.token, msg.sender, totalOwed);\n\n        // Borrower clears the debt then closes and deletes the credit line\n        _close(_repay(credit, id, totalOwed), id);\n\n        return true;\n    }\n\n\n    /// see ILineOfCredit.depositAndRepay\n    function depositAndRepay(uint256 amount)\n        external\n        payable\n        override\n        whileBorrowing\n        returns (bool)\n    {\n        bytes32 id = ids[0];\n        Credit memory credit = credits[id];\n        credit = _accrue(credit, id);\n\n        require(amount <= credit.principal + credit.interestAccrued);\n\n        credits[id] = _repay(credit, id, amount);\n\n        LineLib.receiveTokenOrETH(credit.token, msg.sender, amount);\n\n        return true;\n    }\n\n    ////////////////////\n    // FUND TRANSFERS //\n    ////////////////////\n\n    /// see ILineOfCredit.borrow\n    function borrow(bytes32 id, uint256 amount)\n        external\n        override\n        whileActive\n        onlyBorrower\n        returns (bool)\n    {\n        Credit memory credit = _accrue(credits[id], id);\n\n        if(amount > credit.deposit - credit.principal) { revert NoLiquidity(); }\n\n        credit.principal += amount;\n\n        credits[id] = credit; // save new debt before healthcheck\n\n        // ensure that borrowing doesnt cause Line to be LIQUIDATABLE\n        if(_updateStatus(_healthcheck()) != LineLib.STATUS.ACTIVE) { \n            revert NotActive();\n        }\n\n        LineLib.sendOutTokenOrETH(credit.token, borrower, amount);\n\n        emit Borrow(id, amount);\n\n        _sortIntoQ(id);\n\n        return true;\n    }\n\n    /// see ILineOfCredit.withdraw\n    function withdraw(bytes32 id, uint256 amount)\n        external\n        override\n        returns (bool)\n    {\n        Credit memory credit = credits[id];\n\n        if(msg.sender != credit.lender) { revert CallerAccessDenied(); }\n\n        // accrues interest and transfers to Lender\n        credits[id] = CreditLib.withdraw(_accrue(credit, id), id, amount);\n\n        LineLib.sendOutTokenOrETH(credit.token, credit.lender, amount);\n\n        return true;\n    }\n\n    /// see ILineOfCredit.close\n    function close(bytes32 id) external payable override returns (bool) {\n        Credit memory credit = credits[id];\n        address b = borrower; // gas savings\n        if(msg.sender != credit.lender && msg.sender != b) {\n          revert CallerAccessDenied();\n        }\n\n        // ensure all money owed is accounted for. Accrue facility fee since prinicpal was paid off\n        credit = _accrue(credit, id);\n        uint256 facilityFee = credit.interestAccrued;\n        if(facilityFee > 0) {\n          // only allow repaying interest since they are skipping repayment queue.\n          // If principal still owed, _close() MUST fail\n          LineLib.receiveTokenOrETH(credit.token, b, facilityFee);\n\n          credit = _repay(credit, id, facilityFee);\n        }\n\n        _close(credit, id); // deleted; no need to save to storage\n\n        return true;\n    }\n\n    //////////////////////\n    //  Internal  funcs //\n    //////////////////////\n\n    /**\n      * @notice - updates `status` variable in storage if current status is diferent from existing status.\n      * @dev - privileged internal function. MUST check params and logic flow before calling\n      * @dev - does not save new status if it is the same as current status\n      * @return status - the current status of the line after updating\n     */\n    function _updateStatus(LineLib.STATUS status_) internal returns(LineLib.STATUS) {\n      if(status == status_) return status_;\n      emit UpdateStatus(uint256(status_));\n      return (status = status_);\n    }\n\n    /**\n     * @notice - Generates position id and stores lender's position\n     * @dev - positions have unique composite-index on [lineAddress, lenderAddress, tokenAddress]\n     * @dev - privileged internal function. MUST check params and logic flow before calling\n     * @param lender - address that will own and manage position\n     * @param token - ERC20 token that is being lent and borrower\n     * @param amount - amount of tokens lender will initially deposit\n    */\n    function _createCredit(\n        address lender,\n        address token,\n        uint256 amount\n    )\n        internal\n        returns (bytes32 id)\n    {\n        id = CreditLib.computeId(address(this), lender, token);\n        // MUST not double add the credit line. otherwise we can not _close()\n        if(credits[id].lender != address(0)) { revert PositionExists(); }\n\n        credits[id] = CreditLib.create(id, amount, lender, token, address(oracle));\n\n        ids.push(id); // add lender to end of repayment queue\n        \n        unchecked { ++count; }\n\n        return id;\n    }\n\n  /**\n   * @dev - Reduces `principal` and/or `interestAccrued` on a credit line.\n            Expects checks for conditions of repaying and param sanitizing before calling\n            e.g. early repayment of principal, tokens have actually been paid by borrower, etc.\n   * @dev - privileged internal function. MUST check params and logic flow before calling\n   * @param id - position id with all data pertaining to line\n   * @param amount - amount of Credit Token being repaid on credit line\n   * @return credit - position struct in memory with updated values\n  */\n    function _repay(Credit memory credit, bytes32 id, uint256 amount)\n        internal\n        returns (Credit memory)\n    { \n        credit = CreditLib.repay(credit, id, amount);\n\n        // if credit line fully repaid then remove it from the repayment queue\n        if (credit.principal == 0) ids.stepQ();\n\n        return credit;\n    }\n\n    /**\n     * @notice - checks that a credit line is fully repaid and removes it\n     * @dev deletes credit storage. Store any data u might need later in call before _close()\n     * @dev - privileged internal function. MUST check params and logic flow before calling\n     * @return credit - position struct in memory with updated values\n     */\n    function _close(Credit memory credit, bytes32 id) internal virtual returns (bool) {\n        if(credit.principal > 0) { revert CloseFailedWithPrincipal(); }\n\n        // return the Lender's funds that are being repaid\n        if (credit.deposit + credit.interestRepaid > 0) {\n            LineLib.sendOutTokenOrETH(\n                credit.token,\n                credit.lender,\n                credit.deposit + credit.interestRepaid\n            );\n        }\n\n        delete credits[id]; // gas refunds\n\n        // remove from active list\n        ids.removePosition(id);\n        unchecked { --count; }\n\n        // If all credit lines are closed the the overall Line of Credit facility is declared 'repaid'.\n        if (count == 0) { _updateStatus(LineLib.STATUS.REPAID); }\n\n        emit CloseCreditPosition(id);\n\n        return true;\n    }\n\n    /**\n     * @notice - Insert `p` into the next availble FIFO position in the repayment queue\n               - once earliest slot is found, swap places with `p` and position in slot.\n     * @dev - privileged internal function. MUST check params and logic flow before calling\n     * @param p - position id that we are trying to find appropriate place for\n     * @return - if function executed successfully\n     */\n    function _sortIntoQ(bytes32 p) internal returns (bool) {\n        uint256 lastSpot = ids.length - 1;\n        uint256 nextQSpot = lastSpot;\n        bytes32 id;\n        for (uint256 i; i <= lastSpot; ++i) {\n            id = ids[i];\n            if (p != id) {\n                if (\n                  id == bytes32(0) ||       // deleted element. In the middle of the q because it was closed.\n                  nextQSpot != lastSpot ||  // position already found. skip to find `p` asap\n                  credits[id].principal > 0 //`id` should be placed before `p` \n                ) continue;\n                nextQSpot = i;              // index of first undrawn line found\n            } else {\n                if(nextQSpot == lastSpot) return true; // nothing to update\n                // swap positions\n                ids[i] = ids[nextQSpot];    // id put into old `p` position\n                ids[nextQSpot] = p;         // p put at target index\n                return true; \n            }\n          \n        }\n    }\n}"
    },
    {
      "filename": "contracts/modules/credit/LineOfCredit.sol",
      "content": "pragma solidity ^0.8.9;\n\nimport { Denominations } from \"chainlink/Denominations.sol\";\nimport { IERC20 } from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20}  from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\n\nimport {LineLib} from \"../../utils/LineLib.sol\";\nimport {CreditLib} from \"../../utils/CreditLib.sol\";\nimport {CreditListLib} from \"../../utils/CreditListLib.sol\";\nimport {MutualConsent} from \"../../utils/MutualConsent.sol\";\nimport {InterestRateCredit} from \"../interest-rate/InterestRateCredit.sol\";\n\nimport {IOracle} from \"../../interfaces/IOracle.sol\";\nimport {ILineOfCredit} from \"../../interfaces/ILineOfCredit.sol\";\n\ncontract LineOfCredit is ILineOfCredit, MutualConsent {\n    using SafeERC20 for IERC20;\n\n    using CreditListLib for bytes32[];\n\n    uint256 public immutable deadline;\n\n    address public immutable borrower;\n\n    address public immutable arbiter;\n\n    IOracle public immutable oracle;\n\n    InterestRateCredit public immutable interestRate;\n\n    uint256 private count; // amount of open credit lines on a Line of Credit facility. ids.length includes null items\n\n    bytes32[] public ids; // all open credit lines\n\n    mapping(bytes32 => Credit) public credits; // id -> Reference ID for a credit line provided by a single Lender for a given token on a Line of Credit\n\n    // Line Financials aggregated accross all existing  Credit\n    LineLib.STATUS public status;\n\n    /**\n   * @notice            - How to deploy a Line of Credit\n   * @dev               - A Borrower and a first Lender agree on terms. Then the Borrower deploys the contract using the constructor below.\n   *                      Later, both Lender and Borrower must call _mutualConsent() during addCredit() to actually enable funds to be deposited.\n   * @param oracle_     - The price oracle to use for getting all token values.\n   * @param arbiter_    - A neutral party with some special priviliges on behalf of Borrower and Lender.\n   * @param borrower_   - The debitor for all credit lines in this contract.\n   * @param ttl_        - The time to live for all credit lines for the Line of Credit facility (sets the maturity/term of the Line of Credit)\n  */\n    constructor(\n        address oracle_,\n        address arbiter_,\n        address borrower_,\n        uint256 ttl_\n    ) {\n        oracle = IOracle(oracle_);\n        arbiter = arbiter_;\n        borrower = borrower_;\n        deadline = block.timestamp + ttl_;  //the deadline is the term/maturity/expiry date of the Line of Credit facility\n        interestRate = new InterestRateCredit();\n\n        emit DeployLine(oracle_, arbiter_, borrower_);\n    }\n\n    function init() external virtual returns(LineLib.STATUS) {\n      if(status != LineLib.STATUS.UNINITIALIZED) { revert AlreadyInitialized(); }\n      return _updateStatus(_init());\n    }\n\n    function _init() internal virtual returns(LineLib.STATUS) {\n       // If no collateral or Spigot then Line of Credit is immediately active\n      return LineLib.STATUS.ACTIVE;\n    }\n\n    ///////////////\n    // MODIFIERS //\n    ///////////////\n\n    modifier whileActive() {\n        if(status != LineLib.STATUS.ACTIVE) { revert NotActive(); }\n        _;\n    }\n\n    modifier whileBorrowing() {\n        if(count == 0 || credits[ids[0]].principal == 0) { revert NotBorrowing(); }\n        _;\n    }\n\n    modifier onlyBorrower() {\n        if(msg.sender != borrower) { revert CallerAccessDenied(); }\n        _;\n    }\n\n    /**\n     * @notice - mutualConsent() but hardcodes borrower address and uses the position id to\n                 get Lender address instead of passing it in directly\n     * @param id - position to pull lender address from for mutual consent agreement\n    */\n    modifier mutualConsentById(bytes32 id) {\n      if(_mutualConsent(borrower, credits[id].lender))  {\n        // Run whatever code is needed for the 2/2 consent\n        _;\n      }\n    }\n\n    /**\n     * @notice - evaluates all covenants encoded in _healthcheck from different Line variants\n     * @dev - updates `status` variable in storage if current status is diferent from existing status\n     * @return - current health status of Line\n    */\n    function healthcheck() external returns (LineLib.STATUS) {\n        // can only check if the line has been initialized\n        require(uint(status) >= uint( LineLib.STATUS.ACTIVE));\n        return _updateStatus(_healthcheck());\n    }\n\n    /// see ILineOfCredit.counts\n    function counts() external view returns (uint256, uint256) {\n        return (count, ids.length);\n    }\n\n    function _healthcheck() internal virtual returns (LineLib.STATUS) {\n        // if line is in a final end state then do not run _healthcheck()\n        LineLib.STATUS s = status;\n        if (\n            s == LineLib.STATUS.REPAID ||               // end state - good\n            s == LineLib.STATUS.INSOLVENT               // end state - bad\n        ) {\n            return s;\n        }\n\n        // Liquidate if all credit lines aren't closed by deadline\n        if (block.timestamp >= deadline && count > 0) {\n            emit Default(ids[0]); // can query all defaulted positions offchain once event picked up\n            return LineLib.STATUS.LIQUIDATABLE;\n        }\n\n        // if nothing wrong, return to healthy ACTIVE state  \n        return LineLib.STATUS.ACTIVE;\n    }\n\n\n    /// see ILineOfCredit.declareInsolvent\n    function declareInsolvent() external whileBorrowing returns(bool) {\n        if(arbiter != msg.sender) { revert CallerAccessDenied(); }\n        if(LineLib.STATUS.LIQUIDATABLE != _updateStatus(_healthcheck())) {\n            revert NotLiquidatable();\n        }\n\n        if(_canDeclareInsolvent()) {\n            _updateStatus(LineLib.STATUS.INSOLVENT);\n            return true;\n        } else {\n          return false;\n        }\n    }\n\n    function _canDeclareInsolvent() internal virtual returns(bool) {\n        // logic updated in Spigoted and Escrowed lines\n        return true;\n    }\n\n    /// see ILineOfCredit.updateOutstandingDebt\n    function updateOutstandingDebt() external override returns (uint256, uint256) {\n        return _updateOutstandingDebt();\n    }\n\n    function _updateOutstandingDebt()\n        internal\n        returns (uint256 principal, uint256 interest)\n    {\n        // use full length not count because positions might not be packed in order\n        uint256 len = ids.length;\n        if (len == 0) return (0, 0);\n\n        bytes32 id;\n        address oracle_ = address(oracle);  // gas savings\n        address interestRate_ = address(interestRate); // gas savings\n        \n        for (uint256 i; i < len; ++i) {\n            id = ids[i];\n\n            // null element in array from closing a position. skip for gas savings\n            if(id == bytes32(0)) { continue; }\n\n            (Credit memory c, uint256 _p, uint256 _i) = CreditLib.getOutstandingDebt(\n              credits[id],\n              id,\n              oracle_,\n              interestRate_\n            );\n            // update total outstanding debt\n            principal += _p;\n            interest += _i;\n            // save changes to storage\n            credits[id] = c;\n        }\n    }\n\n    /// see ILineOfCredit.accrueInterest\n    function accrueInterest() external override returns(bool) {\n        uint256 len = ids.length;\n        bytes32 id;\n        for (uint256 i; i < len; ++i) {\n          id = ids[i];\n          Credit memory credit = credits[id];\n          credits[id] = _accrue(credit, id);\n        }\n        \n        return true;\n    }\n\n    /**\n      @notice - accrues token demoninated interest on a lender's position.\n      @dev MUST call any time a position balance or interest rate changes\n      @param credit - the lender position that is accruing interest\n      @param id - the position id for credit position\n    */\n    function _accrue(Credit memory credit, bytes32 id) internal returns(Credit memory) {\n      return CreditLib.accrue(credit, id, address(interestRate));\n    }\n\n    /// see ILineOfCredit.addCredit\n    function addCredit(\n        uint128 drate,\n        uint128 frate,\n        uint256 amount,\n        address token,\n        address lender\n    )\n        external\n        payable\n        override\n        whileActive\n        mutualConsent(lender, borrower)\n        returns (bytes32)\n    {\n        LineLib.receiveTokenOrETH(token, lender, amount);\n\n        bytes32 id = _createCredit(lender, token, amount);\n\n        require(interestRate.setRate(id, drate, frate));\n        \n        return id;\n    }\n\n    /// see ILineOfCredit.setRates\n    function setRates(\n        bytes32 id,\n        uint128 drate,\n        uint128 frate\n    )\n      external\n      override\n      mutualConsentById(id)\n      returns (bool)\n    {\n        Credit memory credit = credits[id];\n        credits[id] = _accrue(credit, id);\n        require(interestRate.setRate(id, drate, frate));\n        emit SetRates(id, drate, frate);\n        return true;\n    }\n\n    /// see ILineOfCredit.increaseCredit\n    function increaseCredit(bytes32 id, uint256 amount)\n      external\n      payable\n      override\n      whileActive\n      mutualConsentById(id)\n      returns (bool)\n    {\n        Credit memory credit = credits[id];\n        credit = _accrue(credit, id);\n\n        credit.deposit += amount;\n        \n        credits[id] = credit;\n\n        LineLib.receiveTokenOrETH(credit.token, credit.lender, amount);\n\n        emit IncreaseCredit(id, amount);\n\n        return true;\n    }\n\n    ///////////////\n    // REPAYMENT //\n    ///////////////\n\n    /// see ILineOfCredit.depositAndClose\n    function depositAndClose()\n        external\n        payable\n        override\n        whileBorrowing\n        onlyBorrower\n        returns (bool)\n    {\n        bytes32 id = ids[0];\n        Credit memory credit = _accrue(credits[id], id);\n\n        // Borrower deposits the outstanding balance not already repaid\n        uint256 totalOwed = credit.principal + credit.interestAccrued;\n        LineLib.receiveTokenOrETH(credit.token, msg.sender, totalOwed);\n\n        // Borrower clears the debt then closes and deletes the credit line\n        _close(_repay(credit, id, totalOwed), id);\n\n        return true;\n    }\n\n\n    /// see ILineOfCredit.depositAndRepay\n    function depositAndRepay(uint256 amount)\n        external\n        payable\n        override\n        whileBorrowing\n        returns (bool)\n    {\n        bytes32 id = ids[0];\n        Credit memory credit = credits[id];\n        credit = _accrue(credit, id);\n\n        require(amount <= credit.principal + credit.interestAccrued);\n\n        credits[id] = _repay(credit, id, amount);\n\n        LineLib.receiveTokenOrETH(credit.token, msg.sender, amount);\n\n        return true;\n    }\n\n    ////////////////////\n    // FUND TRANSFERS //\n    ////////////////////\n\n    /// see ILineOfCredit.borrow\n    function borrow(bytes32 id, uint256 amount)\n        external\n        override\n        whileActive\n        onlyBorrower\n        returns (bool)\n    {\n        Credit memory credit = _accrue(credits[id], id);\n\n        if(amount > credit.deposit - credit.principal) { revert NoLiquidity(); }\n\n        credit.principal += amount;\n\n        credits[id] = credit; // save new debt before healthcheck\n\n        // ensure that borrowing doesnt cause Line to be LIQUIDATABLE\n        if(_updateStatus(_healthcheck()) != LineLib.STATUS.ACTIVE) { \n            revert NotActive();\n        }\n\n        LineLib.sendOutTokenOrETH(credit.token, borrower, amount);\n\n        emit Borrow(id, amount);\n\n        _sortIntoQ(id);\n\n        return true;\n    }\n\n    /// see ILineOfCredit.withdraw\n    function withdraw(bytes32 id, uint256 amount)\n        external\n        override\n        returns (bool)\n    {\n        Credit memory credit = credits[id];\n\n        if(msg.sender != credit.lender) { revert CallerAccessDenied(); }\n\n        // accrues interest and transfers to Lender\n        credits[id] = CreditLib.withdraw(_accrue(credit, id), id, amount);\n\n        LineLib.sendOutTokenOrETH(credit.token, credit.lender, amount);\n\n        return true;\n    }\n\n    /// see ILineOfCredit.close\n    function close(bytes32 id) external payable override returns (bool) {\n        Credit memory credit = credits[id];\n        address b = borrower; // gas savings\n        if(msg.sender != credit.lender && msg.sender != b) {\n          revert CallerAccessDenied();\n        }\n\n        // ensure all money owed is accounted for. Accrue facility fee since prinicpal was paid off\n        credit = _accrue(credit, id);\n        uint256 facilityFee = credit.interestAccrued;\n        if(facilityFee > 0) {\n          // only allow repaying interest since they are skipping repayment queue.\n          // If principal still owed, _close() MUST fail\n          LineLib.receiveTokenOrETH(credit.token, b, facilityFee);\n\n          credit = _repay(credit, id, facilityFee);\n        }\n\n        _close(credit, id); // deleted; no need to save to storage\n\n        return true;\n    }\n\n    //////////////////////\n    //  Internal  funcs //\n    //////////////////////\n\n    /**\n      * @notice - updates `status` variable in storage if current status is diferent from existing status.\n      * @dev - privileged internal function. MUST check params and logic flow before calling\n      * @dev - does not save new status if it is the same as current status\n      * @return status - the current status of the line after updating\n     */\n    function _updateStatus(LineLib.STATUS status_) internal returns(LineLib.STATUS) {\n      if(status == status_) return status_;\n      emit UpdateStatus(uint256(status_));\n      return (status = status_);\n    }\n\n    /**\n     * @notice - Generates position id and stores lender's position\n     * @dev - positions have unique composite-index on [lineAddress, lenderAddress, tokenAddress]\n     * @dev - privileged internal function. MUST check params and logic flow before calling\n     * @param lender - address that will own and manage position\n     * @param token - ERC20 token that is being lent and borrower\n     * @param amount - amount of tokens lender will initially deposit\n    */\n    function _createCredit(\n        address lender,\n        address token,\n        uint256 amount\n    )\n        internal\n        returns (bytes32 id)\n    {\n        id = CreditLib.computeId(address(this), lender, token);\n        // MUST not double add the credit line. otherwise we can not _close()\n        if(credits[id].lender != address(0)) { revert PositionExists(); }\n\n        credits[id] = CreditLib.create(id, amount, lender, token, address(oracle));\n\n        ids.push(id); // add lender to end of repayment queue\n        \n        unchecked { ++"
    }
  ]
}