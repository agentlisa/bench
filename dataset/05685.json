{
  "Title": "[M-21] Deployment Nonce Does not Increment For a Reverted Child Contract",
  "Content": "\nThere is an inconsistency between zkSync Era and Ethereum Virtual Machine (EVM) in handling deployment nonce leading to significant consequences. In EVM, the factory's nonce is increased at the beginning of child contract creation, and if the child contract's creation fails, the nonce is not rolled back. In zkSync Era, the deployment nonce increases during the deployment process, and if the child contract constructor reverts, the entire transaction, including the increased deployment nonce, also reverts.\n\n### Proof of Concept\n\nIn zkSync Era, when a factory contract deploys another contract using low-level creation operations (i.e. using `CREATE` or `CREATE2` in assembly, instead of using `new`), it is expected that the deployment nonce of the factory will increment by one, akin to the behavior in the Ethereum Virtual Machine (EVM). However, a notable issue arises when the constructor of the child contract encounters a revert.\n\nIn the EVM, the nonce of the factory increases as soon as the `CREATE` operation begins, regardless of whether the child contract creation is ultimately successful. This can be seen in `GETH` codebase, where the nonce of the factory is increased at line 431. Then, the EVM captures a snapshot, at line 443, to manage any potential failures, allowing for a graceful revert, at line 492, in case of unsuccessful child contract creation. In such cases, the returned address is `address(0),` indicating a failed contract creation attempt.\n\n<https://github.com/ethereum/go-ethereum/blob/dc34fe8291bfcaefbce97f559e9610beffb2e470/core/vm/evm.go#L431><br>\n<https://github.com/ethereum/go-ethereum/blob/dc34fe8291bfcaefbce97f559e9610beffb2e470/core/vm/evm.go#L443><br>\n<https://github.com/ethereum/go-ethereum/blob/dc34fe8291bfcaefbce97f559e9610beffb2e470/core/vm/evm.go#L492>\n\nHowever, zkSync Era differs in its approach. When the `CREATE` opcode is employed, it invokes the `create` or `create2` function within the `ContractDeployer` contract.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/ContractDeployer.sol#L146><br>\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/ContractDeployer.sol#L130>\n\nThis action results in the incremented deployment nonce of the factory, and, in the final stages of contract creation, it calls the constructor of the child contract.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/ContractDeployer.sol#L189><br>\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/ContractDeployer.sol#L344>\n\nIn the event of a revert in the child contract's constructor, the entire transaction in the `ContractDeployer` is reverted. Consequently, the incremented deployment nonce of the factory is also rolled back, and the returned address signifies an unsuccessful contract creation attempt by being set to `address(0).`\n\nThis divergence in nonce management between zkSync Era and the EVM could have far-reaching implications, especially for factories that are deployed on zkSync Era and assume that the deployment nonce behaves in a manner consistent with the EVM.\n\n### PoC\n\nCalling the function `test` triggers the internal function `deploy` three times. In each call, the child contract is deployed, and two values are returned: the predicted address of the to-be-deployed child and the address of the deployed child. The first and third deploy calls provide `false` as an argument to ensure that the constructor of the child doesn't revert. In the second deploy call, `true` is used as an argument, causing the constructor of the child to revert.\n\nComparing the predicted addresses with the deployed addresses reveals the following:\n\n- In EVM: When the second child contract reverts, the factory's nonce increases. Consequently, the predicted address of the third child still matches its deployed address.\n- In zkSync Era: When the second child contract reverts, the factory's nonce remains unchanged. As a result, the deployed address of the **third** child matches the predicted address of the **second** child.\n\nIt's worth noting that the initial value of the variable `nonce` is set to one for the EVM PoC, while it is set to zero for the zkSync Era PoC. This difference is unrelated to this report and has been explained in a separate report.\n\n**In EVM:**\n\n```solidity\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ncontract Factory {\n    uint256 nonce = 1;\n\n    address public predictedAddress1;\n    address public predictedAddress2;\n    address public predictedAddress3;\n\n    address public deployedAddress1;\n    address public deployedAddress2;\n    address public deployedAddress3;\n\n    function test() public {\n        (predictedAddress1, deployedAddress1) = deploy(false);\n        (predictedAddress2, deployedAddress2) = deploy(true);\n        (predictedAddress3, deployedAddress3) = deploy(false);\n    }\n\n    function deploy(bool _shouldRevert) internal returns (address, address) {\n        bytes memory bytecode = type(Child).creationCode;\n        bytecode = abi.encodePacked(bytecode, abi.encode(_shouldRevert));\n\n        address addr;\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        return (predict(), addr);\n    }\n\n    function predict() public returns (address) {\n        address predicted = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            bytes1(0xd6),\n                            bytes1(0x94),\n                            address(this),\n                            uint8(nonce++)\n                        )\n                    )\n                )\n            )\n        );\n        return predicted;\n    }\n}\n\ncontract Child {\n    constructor(bool _shouldRevert) {\n        if (_shouldRevert) {\n            revert();\n        }\n    }\n}\n\n```\n\nThe result for EVM is:\n\n- `predictedAddress1`: 0xbd5b354220B250DF257ed5e988Fe8FE81CdB6235\n- `deployedAddress1`: 0xbd5b354220B250DF257ed5e988Fe8FE81CdB6235\n- `predictedAddress2`: 0x02180dD815cA64898F6126f3911515B06D17acaD\n- `deployedAddress2`: 0x0000000000000000000000000000000000000000\n- `predictedAddress3`: 0x0A9C6D9d0AF27FC9F3F96196c3F8c89C79Df287D\n- `deployedAddress3`: 0x0A9C6D9d0AF27FC9F3F96196c3F8c89C79Df287D\n\n**In zkSync Era:**\n\n```\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ncontract Factory {\n    uint256 nonce = 0;\n\n    address public predictedAddress1;\n    address public predictedAddress2;\n    address public predictedAddress3;\n\n    address public deployedAddress1;\n    address public deployedAddress2;\n    address public deployedAddress3;\n\n    function test() public {\n        (predictedAddress1, deployedAddress1) = deploy(false);\n        (predictedAddress2, deployedAddress2) = deploy(true);\n        (predictedAddress3, deployedAddress3) = deploy(false);\n    }\n\n    function deploy(bool _shouldRevert) internal returns (address, address) {\n        bytes memory bytecode = type(Child).creationCode;\n        bytecode = abi.encodePacked(bytecode, abi.encode(_shouldRevert));\n\n        address addr;\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        return (predict(), addr);\n    }\n\n    function predict() public returns (address newAddress) {\n        bytes32 hash = keccak256(\n            bytes.concat(\n                keccak256(\"zksyncCreate\"),\n                bytes32(uint256(uint160(address(this)))),\n                bytes32(nonce++)\n            )\n        );\n\n        newAddress = address(uint160(uint256(hash)));\n    }\n}\n\ncontract Child {\n    constructor(bool _shouldRevert) {\n        if (_shouldRevert) {\n            revert();\n        }\n    }\n}\n\n```\n\nThe result for zkSync Era is:\n\n- `predictedAddress1`: 0xBADCfBd5E90eA6558580B8C6220b750E9438df7c\n- `deployedAddress1`: 0xBADCfBd5E90eA6558580B8C6220b750E9438df7c\n- `predictedAddress2`: 0xB7E8A1191E6Ef0F3A752eCaa050F0FF7BcaEAF51\n- `deployedAddress2`: 0x0000000000000000000000000000000000000000\n- `predictedAddress3`: 0xfBAE6B995fe81b48A5e389A81E8Af0ee2AaF7302\n- `deployedAddress3`: 0xB7E8A1191E6Ef0F3A752eCaa050F0FF7BcaEAF51\n\nAs you see, the `deployedAddress3` is equal to `predictedAddress2` which is not correct.\n\n### Recommended Mitigation Steps\n\nA potential solution might involve invoking the `_constructContract` function externally within a try/catch block. By doing so, if `_constructContract` reverts (as occurred with the child contract), the deployment nonce won't be rolled back. However, implementing this kind of modification would necessitate reviewing and changing other parts of the code as well.\n\n    function _performDeployOnAddress(\n            bytes32 _bytecodeHash,\n            address _newAddress,\n            AccountAbstractionVersion _aaVersion,\n            bytes calldata _input\n        ) internal {\n            // ...\n\n            try this.constructContract(msg.sender, _newAddress, _bytecodeHash, _input, false, true){//...}\n            catch{//...}\n              \n        }\n\n### Assessed type\n\nContext\n\n**[miladpiri (zkSync) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/91#issuecomment-1794566240):**\n > This can have high impact (it depends on the context), and the probability is medium to high (implementing factory contract is frequent). Medium severity can be fair.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/91#issuecomment-1829785428):**\n > At this time, I am marking the finding as Medium for EVM non equivalence. Please do raise concerns if you can show a specific way to cause loss of funds or broken behaviour for contracts that are widely used.\n\n**[anon (warden) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/91#issuecomment-1836092181):**\n > This issue may pose a challenge when a factory contract, sharing the same address, is deployed on different chains and is intended to generate multiple proxy contracts with identical addresses (because the address of the created proxy contract relies on the factory's address and its nonce).\n> \n> Consider a situation where a factory is deployed with the same address on both Ethereum and zkSync Era (its forks, or other chains). The address of the proxy contract generated by this factory is dependent on the factory's address and its nonce. If, for any reason, a proxy creation fails (for instance, encountering a REVERT during the execution of its `initcode` or running out of gas), the nonce of the factory will increase on Ethereum but not in the zkSync Era. Consequently, the nonces of the factory on both chains will no longer be synchronized, leading to divergent addresses for proxies created by this factory on the two chains going forward.\n> \n> ```solidity\n> // SPDX-License-Identifier: MIT\n> pragma solidity 0.8.20;\n> \n> contract Factory {\n> \n>     function deploy(bytes[] memory _proxy) external {\n>         bytes memory bytecode;\n> \n>         for (uint256 i = 0; i < _proxy.length; ++i) {\n>             bytecode = _proxy[i];\n>             assembly {\n>                 pop(create(0, add(bytecode, 0x20), mload(bytecode)))\n>             }\n>         }\n>     }\n> \n>     function proxyAddress(uint256 _nonce) public view returns (address) {\n>         address predicted = address(\n>             uint160(\n>                 uint256(\n>                     keccak256(\n>                         abi.encodePacked(\n>                             bytes1(0xd6),\n>                             bytes1(0x94),\n>                             address(this),\n>                             uint8(_nonce)\n>                         )\n>                     )\n>                 )\n>             )\n>         );\n>         return predicted;\n>     }\n> }\n> ```\n> \n> Given the frequent implementation of factory contracts (whether for ensuring the consistency of proxy contract addresses across different chains or for other use cases), the impact classification of this issue can be high.\n\n**[unforgiven (warden) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/91#issuecomment-1837486592):**\n > Regarding your above [comment](https://github.com/code-423n4/2023-10-zksync-findings/issues/91#issuecomment-1836092181), which says:\n> >Consider a situation where a factory is deployed with the same address on both Ethereum and zkSync Era (its forks, or other chains).\n> \n> I want to mention that according to the [docs](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/docs/Smart%20contract%20Section/L1%20smart%20contracts.md#L86) currently it's impossible to for Ethereum and zkSync contract to have `sameaddress`:\n>\n> > For most of the rollups the address aliasing needs to prevent cross-chain exploits that would otherwise be possible if we simply reused the same L1 addresses as the L2 sender. In zkSync Era address derivation rule is different from the Ethereum, so cross-chain exploits are already impossible. However, zkSync Era may add full EVM support in the future, so applying address aliasing leaves room for future EVM compatibility.\n\n**[anon (warden) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/91#issuecomment-1837605662):**\n > You are correct that the address derivation in zkSync Era differs from Ethereum. However, my key point is that developers considering the idea of using a factory to generate proxies with identical addresses (on zkSync Era, its forks, and etc.) will encounter the issue of nonce asynchronization.\n\n**[miladpiri (zkSync) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/91#issuecomment-1839001570):**\n > Agree. This can be an issue.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/91#issuecomment-1840776387):**\n > I believe that the finding is valid and Medium. It can cause issues, in some specific scenarios, which are possible but not as common and they are implementation reliant. The issues are not guaranteed, the behaviour is \"sometimes\" wrong.\n> \n> If a contract factory was in scope, I can see the argument for raising the severity; but a `create2` or `create3` deployer, as well as common factories with mappings for children, would work as intended, leading me to confirm Medium Severity as the most appropriate.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-zksync",
  "Code": [
    {
      "filename": "core/vm/evm.go",
      "content": "// Copyright 2014 The go-ethereum Authors\n// This file is part of the go-ethereum library.\n//\n// The go-ethereum library is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// The go-ethereum library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.\n\npackage vm\n\nimport (\n\t\"math/big\"\n\t\"sync/atomic\"\n\n\t\"github.com/ethereum/go-ethereum/common\"\n\t\"github.com/ethereum/go-ethereum/core/types\"\n\t\"github.com/ethereum/go-ethereum/crypto\"\n\t\"github.com/ethereum/go-ethereum/params\"\n\t\"github.com/holiman/uint256\"\n)\n\ntype (\n\t// CanTransferFunc is the signature of a transfer guard function\n\tCanTransferFunc func(StateDB, common.Address, *big.Int) bool\n\t// TransferFunc is the signature of a transfer function\n\tTransferFunc func(StateDB, common.Address, common.Address, *big.Int)\n\t// GetHashFunc returns the n'th block hash in the blockchain\n\t// and is used by the BLOCKHASH EVM op code.\n\tGetHashFunc func(uint64) common.Hash\n)\n\nfunc (evm *EVM) precompile(addr common.Address) (PrecompiledContract, bool) {\n\tvar precompiles map[common.Address]PrecompiledContract\n\tswitch {\n\tcase evm.chainRules.IsCancun:\n\t\tprecompiles = PrecompiledContractsCancun\n\tcase evm.chainRules.IsBerlin:\n\t\tprecompiles = PrecompiledContractsBerlin\n\tcase evm.chainRules.IsIstanbul:\n\t\tprecompiles = PrecompiledContractsIstanbul\n\tcase evm.chainRules.IsByzantium:\n\t\tprecompiles = PrecompiledContractsByzantium\n\tdefault:\n\t\tprecompiles = PrecompiledContractsHomestead\n\t}\n\tp, ok := precompiles[addr]\n\treturn p, ok\n}\n\n// BlockContext provides the EVM with auxiliary information. Once provided\n// it shouldn't be modified.\ntype BlockContext struct {\n\t// CanTransfer returns whether the account contains\n\t// sufficient ether to transfer the value\n\tCanTransfer CanTransferFunc\n\t// Transfer transfers ether from one account to the other\n\tTransfer TransferFunc\n\t// GetHash returns the hash corresponding to n\n\tGetHash GetHashFunc\n\n\t// Block information\n\tCoinbase      common.Address // Provides information for COINBASE\n\tGasLimit      uint64         // Provides information for GASLIMIT\n\tBlockNumber   *big.Int       // Provides information for NUMBER\n\tTime          uint64         // Provides information for TIME\n\tDifficulty    *big.Int       // Provides information for DIFFICULTY\n\tBaseFee       *big.Int       // Provides information for BASEFEE\n\tRandom        *common.Hash   // Provides information for PREVRANDAO\n\tExcessBlobGas *uint64        // ExcessBlobGas field in the header, needed to compute the data\n}\n\n// TxContext provides the EVM with information about a transaction.\n// All fields can change between transactions.\ntype TxContext struct {\n\t// Message information\n\tOrigin     common.Address // Provides information for ORIGIN\n\tGasPrice   *big.Int       // Provides information for GASPRICE\n\tBlobHashes []common.Hash  // Provides information for BLOBHASH\n}\n\n// EVM is the Ethereum Virtual Machine base object and provides\n// the necessary tools to run a contract on the given state with\n// the provided context. It should be noted that any error\n// generated through any of the calls should be considered a\n// revert-state-and-consume-all-gas operation, no checks on\n// specific errors should ever be performed. The interpreter makes\n// sure that any errors generated are to be considered faulty code.\n//\n// The EVM should never be reused and is not thread safe.\ntype EVM struct {\n\t// Context provides auxiliary blockchain related information\n\tContext BlockContext\n\tTxContext\n\t// StateDB gives access to the underlying state\n\tStateDB StateDB\n\t// Depth is the current call stack\n\tdepth int\n\n\t// chainConfig contains information about the current chain\n\tchainConfig *params.ChainConfig\n\t// chain rules contains the chain rules for the current epoch\n\tchainRules params.Rules\n\t// virtual machine configuration options used to initialise the\n\t// evm.\n\tConfig Config\n\t// global (to this context) ethereum virtual machine\n\t// used throughout the execution of the tx.\n\tinterpreter *EVMInterpreter\n\t// abort is used to abort the EVM calling operations\n\tabort atomic.Bool\n\t// callGasTemp holds the gas available for the current call. This is needed because the\n\t// available gas is calculated in gasCall* according to the 63/64 rule and later\n\t// applied in opCall*.\n\tcallGasTemp uint64\n}\n\n// NewEVM returns a new EVM. The returned EVM is not thread safe and should\n// only ever be used *once*.\nfunc NewEVM(blockCtx BlockContext, txCtx TxContext, statedb StateDB, chainConfig *params.ChainConfig, config Config) *EVM {\n\tevm := &EVM{\n\t\tContext:     blockCtx,\n\t\tTxContext:   txCtx,\n\t\tStateDB:     statedb,\n\t\tConfig:      config,\n\t\tchainConfig: chainConfig,\n\t\tchainRules:  chainConfig.Rules(blockCtx.BlockNumber, blockCtx.Random != nil, blockCtx.Time),\n\t}\n\tevm.interpreter = NewEVMInterpreter(evm)\n\treturn evm\n}\n\n// Reset resets the EVM with a new transaction context.Reset\n// This is not threadsafe and should only be done very cautiously.\nfunc (evm *EVM) Reset(txCtx TxContext, statedb StateDB) {\n\tevm.TxContext = txCtx\n\tevm.StateDB = statedb\n}\n\n// Cancel cancels any running EVM operation. This may be called concurrently and\n// it's safe to be called multiple times.\nfunc (evm *EVM) Cancel() {\n\tevm.abort.Store(true)\n}\n\n// Cancelled returns true if Cancel has been called\nfunc (evm *EVM) Cancelled() bool {\n\treturn evm.abort.Load()\n}\n\n// Interpreter returns the current interpreter\nfunc (evm *EVM) Interpreter() *EVMInterpreter {\n\treturn evm.interpreter\n}\n\n// SetBlockContext updates the block context of the EVM.\nfunc (evm *EVM) SetBlockContext(blockCtx BlockContext) {\n\tevm.Context = blockCtx\n\tnum := blockCtx.BlockNumber\n\ttimestamp := blockCtx.Time\n\tevm.chainRules = evm.chainConfig.Rules(num, blockCtx.Random != nil, timestamp)\n}\n\n// Call executes the contract associated with the addr with the given input as\n// parameters. It also handles any necessary value transfer required and takes\n// the necessary steps to create accounts and reverses the state in case of an\n// execution error or failed value transfer.\nfunc (evm *EVM) Call(caller ContractRef, addr common.Address, input []byte, gas uint64, value *big.Int) (ret []byte, leftOverGas uint64, err error) {\n\t// Fail if we're trying to execute above the call depth limit\n\tif evm.depth > int(params.CallCreateDepth) {\n\t\treturn nil, gas, ErrDepth\n\t}\n\t// Fail if we're trying to transfer more than the available balance\n\tif value.Sign() != 0 && !evm.Context.CanTransfer(evm.StateDB, caller.Address(), value) {\n\t\treturn nil, gas, ErrInsufficientBalance\n\t}\n\tsnapshot := evm.StateDB.Snapshot()\n\tp, isPrecompile := evm.precompile(addr)\n\tdebug := evm.Config.Tracer != nil\n\n\tif !evm.StateDB.Exist(addr) {\n\t\tif !isPrecompile && evm.chainRules.IsEIP158 && value.Sign() == 0 {\n\t\t\t// Calling a non existing account, don't do anything, but ping the tracer\n\t\t\tif debug {\n\t\t\t\tif evm.depth == 0 {\n\t\t\t\t\tevm.Config.Tracer.CaptureStart(evm, caller.Address(), addr, false, input, gas, value)\n\t\t\t\t\tevm.Config.Tracer.CaptureEnd(ret, 0, nil)\n\t\t\t\t} else {\n\t\t\t\t\tevm.Config.Tracer.CaptureEnter(CALL, caller.Address(), addr, input, gas, value)\n\t\t\t\t\tevm.Config.Tracer.CaptureExit(ret, 0, nil)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil, gas, nil\n\t\t}\n\t\tevm.StateDB.CreateAccount(addr)\n\t}\n\tevm.Context.Transfer(evm.StateDB, caller.Address(), addr, value)\n\n\t// Capture the tracer start/end events in debug mode\n\tif debug {\n\t\tif evm.depth == 0 {\n\t\t\tevm.Config.Tracer.CaptureStart(evm, caller.Address(), addr, false, input, gas, value)\n\t\t\tdefer func(startGas uint64) { // Lazy evaluation of the parameters\n\t\t\t\tevm.Config.Tracer.CaptureEnd(ret, startGas-gas, err)\n\t\t\t}(gas)\n\t\t} else {\n\t\t\t// Handle tracer events for entering and exiting a call frame\n\t\t\tevm.Config.Tracer.CaptureEnter(CALL, caller.Address(), addr, input, gas, value)\n\t\t\tdefer func(startGas uint64) {\n\t\t\t\tevm.Config.Tracer.CaptureExit(ret, startGas-gas, err)\n\t\t\t}(gas)\n\t\t}\n\t}\n\n\tif isPrecompile {\n\t\tret, gas, err = RunPrecompiledContract(p, input, gas)\n\t} else {\n\t\t// Initialise a new contract and set the code that is to be used by the EVM.\n\t\t// The contract is a scoped environment for this execution context only.\n\t\tcode := evm.StateDB.GetCode(addr)\n\t\tif len(code) == 0 {\n\t\t\tret, err = nil, nil // gas is unchanged\n\t\t} else {\n\t\t\taddrCopy := addr\n\t\t\t// If the account has no code, we can abort here\n\t\t\t// The depth-check is already done, and precompiles handled above\n\t\t\tcontract := NewContract(caller, AccountRef(addrCopy), value, gas)\n\t\t\tcontract.SetCallCode(&addrCopy, evm.StateDB.GetCodeHash(addrCopy), code)\n\t\t\tret, err = evm.interpreter.Run(contract, input, false)\n\t\t\tgas = contract.Gas\n\t\t}\n\t}\n\t// When an error was returned by the EVM or when setting the creation code\n\t// above we revert to the snapshot and consume any gas remaining. Additionally\n\t// when we're in homestead this also counts for code storage gas errors.\n\tif err != nil {\n\t\tevm.StateDB.RevertToSnapshot(snapshot)\n\t\tif err != ErrExecutionReverted {\n\t\t\tgas = 0\n\t\t}\n\t\t// TODO: consider clearing up unused snapshots:\n\t\t//} else {\n\t\t//\tevm.StateDB.DiscardSnapshot(snapshot)\n\t}\n\treturn ret, gas, err\n}\n\n// CallCode executes the contract associated with the addr with the given input\n// as parameters. It also handles any necessary value transfer required and takes\n// the necessary steps to create accounts and reverses the state in case of an\n// execution error or failed value transfer.\n//\n// CallCode differs from Call in the sense that it executes the given address'\n// code with the caller as context.\nfunc (evm *EVM) CallCode(caller ContractRef, addr common.Address, input []byte, gas uint64, value *big.Int) (ret []byte, leftOverGas uint64, err error) {\n\t// Fail if we're trying to execute above the call depth limit\n\tif evm.depth > int(params.CallCreateDepth) {\n\t\treturn nil, gas, ErrDepth\n\t}\n\t// Fail if we're trying to transfer more than the available balance\n\t// Note although it's noop to transfer X ether to caller itself. But\n\t// if caller doesn't have enough balance, it would be an error to allow\n\t// over-charging itself. So the check here is necessary.\n\tif !evm.Context.CanTransfer(evm.StateDB, caller.Address(), value) {\n\t\treturn nil, gas, ErrInsufficientBalance\n\t}\n\tvar snapshot = evm.StateDB.Snapshot()\n\n\t// Invoke tracer hooks that signal entering/exiting a call frame\n\tif evm.Config.Tracer != nil {\n\t\tevm.Config.Tracer.CaptureEnter(CALLCODE, caller.Address(), addr, input, gas, value)\n\t\tdefer func(startGas uint64) {\n\t\t\tevm.Config.Tracer.CaptureExit(ret, startGas-gas, err)\n\t\t}(gas)\n\t}\n\n\t// It is allowed to call precompiles, even via delegatecall\n\tif p, isPrecompile := evm.precompile(addr); isPrecompile {\n\t\tret, gas, err = RunPrecompiledContract(p, input, gas)\n\t} else {\n\t\taddrCopy := addr\n\t\t// Initialise a new contract and set the code that is to be used by the EVM.\n\t\t// The contract is a scoped environment for this execution context only.\n\t\tcontract := NewContract(caller, AccountRef(caller.Address()), value, gas)\n\t\tcontract.SetCallCode(&addrCopy, evm.StateDB.GetCodeHash(addrCopy), evm.StateDB.GetCode(addrCopy))\n\t\tret, err = evm.interpreter.Run(contract, input, false)\n\t\tgas = contract.Gas\n\t}\n\tif err != nil {\n\t\tevm.StateDB.RevertToSnapshot(snapshot)\n\t\tif err != ErrExecutionReverted {\n\t\t\tgas = 0\n\t\t}\n\t}\n\treturn ret, gas, err\n}\n\n// DelegateCall executes the contract associated with the addr with the given input\n// as parameters. It reverses the state in case of an execution error.\n//\n// DelegateCall differs from CallCode in the sense that it executes the given address'\n// code with the caller as context and the caller is set to the caller of the caller.\nfunc (evm *EVM) DelegateCall(caller ContractRef, addr common.Address, input []byte, gas uint64) (ret []byte, leftOverGas uint64, err error) {\n\t// Fail if we're trying to execute above the call depth limit\n\tif evm.depth > int(params.CallCreateDepth) {\n\t\treturn nil, gas, ErrDepth\n\t}\n\tvar snapshot = evm.StateDB.Snapshot()\n\n\t// Invoke tracer hooks that signal entering/exiting a call frame\n\tif evm.Config.Tracer != nil {\n\t\t// NOTE: caller must, at all times be a contract. It should never happen\n\t\t// that caller is something other than a Contract.\n\t\tparent := caller.(*Contract)\n\t\t// DELEGATECALL inherits value from parent call\n\t\tevm.Config.Tracer.CaptureEnter(DELEGATECALL, caller.Address(), addr, input, gas, parent.value)\n\t\tdefer func(startGas uint64) {\n\t\t\tevm.Config.Tracer.CaptureExit(ret, startGas-gas, err)\n\t\t}(gas)\n\t}\n\n\t// It is allowed to call precompiles, even via delegatecall\n\tif p, isPrecompile := evm.precompile(addr); isPrecompile {\n\t\tret, gas, err = RunPrecompiledContract(p, input, gas)\n\t} else {\n\t\taddrCopy := addr\n\t\t// Initialise a new contract and make initialise the delegate values\n\t\tcontract := NewContract(caller, AccountRef(caller.Address()), nil, gas).AsDelegate()\n\t\tcontract.SetCallCode(&addrCopy, evm.StateDB.GetCodeHash(addrCopy), evm.StateDB.GetCode(addrCopy))\n\t\tret, err = evm.interpreter.Run(contract, input, false)\n\t\tgas = contract.Gas\n\t}\n\tif err != nil {\n\t\tevm.StateDB.RevertToSnapshot(snapshot)\n\t\tif err != ErrExecutionReverted {\n\t\t\tgas = 0\n\t\t}\n\t}\n\treturn ret, gas, err\n}\n\n// StaticCall executes the contract associated with the addr with the given input\n// as parameters while disallowing any modifications to the state during the call.\n// Opcodes that attempt to perform such modifications will result in exceptions\n// instead of performing the modifications.\nfunc (evm *EVM) StaticCall(caller ContractRef, addr common.Address, input []byte, gas uint64) (ret []byte, leftOverGas uint64, err error) {\n\t// Fail if we're trying to execute above the call depth limit\n\tif evm.depth > int(params.CallCreateDepth) {\n\t\treturn nil, gas, ErrDepth\n\t}\n\t// We take a snapshot here. This is a bit counter-intuitive, and could probably be skipped.\n\t// However, even a staticcall is considered a 'touch'. On mainnet, static calls were introduced\n\t// after all empty accounts were deleted, so this is not required. However, if we omit this,\n\t// then certain tests start failing; stRevertTest/RevertPrecompiledTouchExactOOG.json.\n\t// We could change this, but for now it's left for legacy reasons\n\tvar snapshot = evm.StateDB.Snapshot()\n\n\t// We do an AddBalance of zero here, just in order to trigger a touch.\n\t// This doesn't matter on Mainnet, where all empties are gone at the time of Byzantium,\n\t// but is the correct thing to do and matters on other networks, in tests, and potential\n\t// future scenarios\n\tevm.StateDB.AddBalance(addr, big0)\n\n\t// Invoke tracer hooks that signal entering/exiting a call frame\n\tif evm.Config.Tracer != nil {\n\t\tevm.Config.Tracer.CaptureEnter(STATICCALL, caller.Address(), addr, input, gas, nil)\n\t\tdefer func(startGas uint64) {\n\t\t\tevm.Config.Tracer.CaptureExit(ret, startGas-gas, err)\n\t\t}(gas)\n\t}\n\n\tif p, isPrecompile := evm.precompile(addr); isPrecompile {\n\t\tret, gas, err = RunPrecompiledContract(p, input, gas)\n\t} else {\n\t\t// At this point, we use a copy of address. If we don't, the go compiler will\n\t\t// leak the 'contract' to the outer scope, and make allocation for 'contract'\n\t\t// even if the actual execution ends on RunPrecompiled above.\n\t\taddrCopy := addr\n\t\t// Initialise a new contract and set the code that is to be used by the EVM.\n\t\t// The contract is a scoped environment for this execution context only.\n\t\tcontract := NewContract(caller, AccountRef(addrCopy), new(big.Int), gas)\n\t\tcontract.SetCallCode(&addrCopy, evm.StateDB.GetCodeHash(addrCopy), evm.StateDB.GetCode(addrCopy))\n\t\t// When an error was returned by the EVM or when setting the creation code\n\t\t// above we revert to the snapshot and consume any gas remaining. Additionally\n\t\t// when we're in Homestead this also counts for code storage gas errors.\n\t\tret, err = evm.interpreter.Run(contract, input, true)\n\t\tgas = contract.Gas\n\t}\n\tif err != nil {\n\t\tevm.StateDB.RevertToSnapshot(snapshot)\n\t\tif err != ErrExecutionReverted {\n\t\t\tgas = 0\n\t\t}\n\t}\n\treturn ret, gas, err\n}\n\ntype codeAndHash struct {\n\tcode []byte\n\thash common.Hash\n}\n\nfunc (c *codeAndHash) Hash() common.Hash {\n\tif c.hash == (common.Hash{}) {\n\t\tc.hash = crypto.Keccak256Hash(c.code)\n\t}\n\treturn c.hash\n}\n\n// create creates a new contract using code as deployment code.\nfunc (evm *EVM) create(caller ContractRef, codeAndHash *codeAndHash, gas uint64, value *big.Int, address common.Address, typ OpCode) ([]byte, common.Address, uint64, error) {\n\t// Depth check execution. Fail if we're trying to execute above the\n\t// limit.\n\tif evm.depth > int(params.CallCreateDepth) {\n\t\treturn nil, common.Address{}, gas, ErrDepth\n\t}\n\tif !evm.Context.CanTransfer(evm.StateDB, caller.Address(), value) {\n\t\treturn nil, common.Address{}, gas, ErrInsufficientBalance\n\t}\n\tnonce := evm.StateDB.GetNonce(caller.Address())\n\tif nonce+1 < nonce {\n\t\treturn nil, common.Address{}, gas, ErrNonceUintOverflow\n\t}\n\tevm.StateDB.SetNonce(caller.Address(), nonce+1)\n\t// We add this to the access list _before_ taking a snapshot. Even if the creation fails,\n\t// the access-list change should not be rolled back\n\tif evm.chainRules.IsBerlin {\n\t\tevm.StateDB.AddAddressToAccessList(address)\n\t}\n\t// Ensure there's no existing contract already at the designated address\n\tcontractHash := evm.StateDB.GetCodeHash(address)\n\tif evm.StateDB.GetNonce(address) != 0 || (contractHash != (common.Hash{}) && contractHash != types.EmptyCodeHash) {\n\t\treturn nil, common.Address{}, 0, ErrContractAddressCollision\n\t}\n\t// Create a new account on the state\n\tsnapshot := evm.StateDB.Snapshot()\n\tevm.StateDB.CreateAccount(address)\n\tif evm.chainRules.IsEIP158 {\n\t\tevm.StateDB.SetNonce(address, 1)\n\t}\n\tevm.Context.Transfer(evm.StateDB, caller.Address(), address, value)\n\n\t// Initialise a new contract and set the code that is to be used by the EVM.\n\t// The contract is a scoped environment for this execution context only.\n\tcontract := NewContract(caller, AccountRef(address), value, gas)\n\tcontract.SetCodeOptionalHash(&address, codeAndHash)\n\n\tif evm.Config.Tracer != nil {\n\t\tif evm.depth == 0 {\n\t\t\tevm.Config.Tracer.CaptureStart(evm, caller.Address(), address, true, codeAndHash.code, gas, value)\n\t\t} else {\n\t\t\tevm.Config.Tracer.CaptureEnter(typ, caller.Address(), address, codeAndHash.code, gas, value)\n\t\t}\n\t}\n\n\tret, err := evm.interpreter.Run(contract, nil, false)\n\n\t// Check whether the max code size has been exceeded, assign err if the case.\n\tif err == nil && evm.chainRules.IsEIP158 && len(ret) > params.MaxCodeSize {\n\t\terr = ErrMaxCodeSizeExceeded\n\t}\n\n\t// Reject code starting with 0xEF if EIP-3541 is enabled.\n\tif err == nil && len(ret) >= 1 && ret[0] == 0xEF && evm.chainRules.IsLondon {\n\t\terr = ErrInvalidCode\n\t}\n\n\t// if the contract creation ran successfully and no errors were returned\n\t// calculate the gas required to store the code. If the code could not\n\t// be stored due to not enough gas set an error and let it be handled\n\t// by the error checking condition below.\n\tif err == nil {\n\t\tcreateDataGas := uint64(len(ret)) * params.CreateDataGas\n\t\tif contract.UseGas(createDataGas) {\n\t\t\tevm.StateDB.SetCode(address, ret)\n\t\t} else {\n\t\t\terr = ErrCodeStoreOutOfGas\n\t\t}\n\t}\n\n\t// When an error was returned by the EVM or when setting the creation code\n\t// above we revert to the snapshot and consume any gas remaining. Additionally\n\t// when we're in homestead this also counts for code storage gas errors.\n\tif err != nil && (evm.chainRules.IsHomestead || err != ErrCodeStoreOutOfGas) {\n\t\tevm.StateDB.RevertToSnapshot(snapshot)\n\t\tif err != ErrExecutionReverted {\n\t\t\tcontract.UseGas(contract.Gas)\n\t\t}\n\t}\n\n\tif evm.Config.Tracer != nil {\n\t\tif evm.depth == 0 {\n\t\t\tevm.Config.Tracer.CaptureEnd(ret, gas-contract.Gas, err)\n\t\t} else {\n\t\t\tevm.Config.Tracer.CaptureExit(ret, gas-contract.Gas, err)\n\t\t}\n\t}\n\treturn ret, address, contract.Gas, err\n}\n\n// Create creates a new contract using code as deployment code.\nfunc (evm *EVM) Create(caller ContractRef, code []byte, gas uint64, value *big.Int) (ret []byte, contractAddr common.Address, leftOverGas uint64, err error) {\n\tcontractAddr = crypto.CreateAddress(caller.Address(), evm.StateDB.GetNonce(caller.Address()))\n\treturn evm.create(caller, &codeAndHash{code: code}, gas, value, contractAddr, CREATE)\n}\n\n// Create2 creates a new contract using code as deployment code.\n//\n// The different between Create2 with Create is Create2 uses keccak256(0xff ++ msg.sender ++ salt ++ keccak256(init_code))[12:]\n// instead of the usual sender-and-nonce-hash as the address where the contract is initialized at.\nfunc (evm *EVM) Create2(caller ContractRef, code []byte, gas uint64, endowment *big.Int, salt *uint256.Int) (ret []byte, contractAddr common.Address, leftOverGas uint64, err error) {\n\tcodeAndHash := &codeAndHash{code: code}\n\tcontractAddr = crypto.CreateAddress2(caller.Address(), salt.Bytes32(), codeAndHash.Hash().Bytes())\n\treturn evm.create(caller, codeAndHash, gas, endowment, contractAddr, CREATE2)\n}\n\n// ChainConfig returns the environment's chain configuration\nfunc (evm *EVM) ChainConfig() *params.ChainConfig { return evm.chainConfig }"
    },
    {
      "filename": "core/vm/evm.go",
      "content": "// Copyright 2014 The go-ethereum Authors\n// This file is part of the go-ethereum library.\n//\n// The go-ethereum library is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// The go-ethereum library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.\n\npackage vm\n\nimport (\n\t\"math/big\"\n\t\"sync/atomic\"\n\n\t\"github.com/ethereum/go-ethereum/common\"\n\t\"github.com/ethereum/go-ethereum/core/types\"\n\t\"github.com/ethereum/go-ethereum/crypto\"\n\t\"github.com/ethereum/go-ethereum/params\"\n\t\"github.com/holiman/uint256\"\n)\n\ntype (\n\t// CanTransferFunc is the signature of a transfer guard function\n\tCanTransferFunc func(StateDB, common.Address, *big.Int) bool\n\t// TransferFunc is the signature of a transfer function\n\tTransferFunc func(StateDB, common.Address, common.Address, *big.Int)\n\t// GetHashFunc returns the n'th block hash in the blockchain\n\t// and is used by the BLOCKHASH EVM op code.\n\tGetHashFunc func(uint64) common.Hash\n)\n\nfunc (evm *EVM) precompile(addr common.Address) (PrecompiledContract, bool) {\n\tvar precompiles map[common.Address]PrecompiledContract\n\tswitch {\n\tcase evm.chainRules.IsCancun:\n\t\tprecompiles = PrecompiledContractsCancun\n\tcase evm.chainRules.IsBerlin:\n\t\tprecompiles = PrecompiledContractsBerlin\n\tcase evm.chainRules.IsIstanbul:\n\t\tprecompiles = PrecompiledContractsIstanbul\n\tcase evm.chainRules.IsByzantium:\n\t\tprecompiles = PrecompiledContractsByzantium\n\tdefault:\n\t\tprecompiles = PrecompiledContractsHomestead\n\t}\n\tp, ok := precompiles[addr]\n\treturn p, ok\n}\n\n// BlockContext provides the EVM with auxiliary information. Once provided\n// it shouldn't be modified.\ntype BlockContext struct {\n\t// CanTransfer returns whether the account contains\n\t// sufficient ether to transfer the value\n\tCanTransfer CanTransferFunc\n\t// Transfer transfers ether from one account to the other\n\tTransfer TransferFunc\n\t// GetHash returns the hash corresponding to n\n\tGetHash GetHashFunc\n\n\t// Block information\n\tCoinbase      common.Address // Provides information for COINBASE\n\tGasLimit      uint64         // Provides information for GASLIMIT\n\tBlockNumber   *big.Int       // Provides information for NUMBER\n\tTime          uint64         // Provides information for TIME\n\tDifficulty    *big.Int       // Provides information for DIFFICULTY\n\tBaseFee       *big.Int       // Provides information for BASEFEE\n\tRandom        *common.Hash   // Provides information for PREVRANDAO\n\tExcessBlobGas *uint64        // ExcessBlobGas field in the header, needed to compute the data\n}\n\n// TxContext provides the EVM with information about a transaction.\n// All fields can change between transactions.\ntype TxContext struct {\n\t// Message information\n\tOrigin     common.Address // Provides information for ORIGIN\n\tGasPrice   *big.Int       // Provides information for GASPRICE\n\tBlobHashes []common.Hash  // Provides information for BLOBHASH\n}\n\n// EVM is the Ethereum Virtual Machine base object and provides\n// the necessary tools to run a contract on the given state with\n// the provided context. It should be noted that any error\n// generated through any of the calls should be considered a\n// revert-state-and-consume-all-gas operation, no checks on\n// specific errors should ever be performed. The interpreter makes\n// sure that any errors generated are to be considered faulty code.\n//\n// The EVM should never be reused and is not thread safe.\ntype EVM struct {\n\t// Context provides auxiliary blockchain related information\n\tContext BlockContext\n\tTxContext\n\t// StateDB gives access to the underlying state\n\tStateDB StateDB\n\t// Depth is the current call stack\n\tdepth int\n\n\t// chainConfig contains information about the current chain\n\tchainConfig *params.ChainConfig\n\t// chain rules contains the chain rules for the current epoch\n\tchainRules params.Rules\n\t// virtual machine configuration options used to initialise the\n\t// evm.\n\tConfig Config\n\t// global (to this context) ethereum virtual machine\n\t// used throughout the execution of the tx.\n\tinterpreter *EVMInterpreter\n\t// abort is used to abort the EVM calling operations\n\tabort atomic.Bool\n\t// callGasTemp holds the gas available for the current call. This is needed because the\n\t// available gas is calculated in gasCall* according to the 63/64 rule and later\n\t// applied in opCall*.\n\tcallGasTemp uint64\n}\n\n// NewEVM returns a new EVM. The returned EVM is not thread safe and should\n// only ever be used *once*.\nfunc NewEVM(blockCtx BlockContext, txCtx TxContext, statedb StateDB, chainConfig *params.ChainConfig, config Config) *EVM {\n\tevm := &EVM{\n\t\tContext:     blockCtx,\n\t\tTxContext:   txCtx,\n\t\tStateDB:     statedb,\n\t\tConfig:      config,\n\t\tchainConfig: chainConfig,\n\t\tchainRules:  chainConfig.Rules(blockCtx.BlockNumber, blockCtx.Random != nil, blockCtx.Time),\n\t}\n\tevm.interpreter = NewEVMInterpreter(evm)\n\treturn evm\n}\n\n// Reset resets the EVM with a new transaction context.Reset\n// This is not threadsafe and should only be done very cautiously.\nfunc (evm *EVM) Reset(txCtx TxContext, statedb StateDB) {\n\tevm.TxContext = txCtx\n\tevm.StateDB = statedb\n}\n\n// Cancel cancels any running EVM operation. This may be called concurrently and\n// it's safe to be called multiple times.\nfunc (evm *EVM) Cancel() {\n\tevm.abort.Store(true)\n}\n\n// Cancelled returns true if Cancel has been called\nfunc (evm *EVM) Cancelled() bool {\n\treturn evm.abort.Load()\n}\n\n// Interpreter returns the current interpreter\nfunc (evm *EVM) Interpreter() *EVMInterpreter {\n\treturn evm.interpreter\n}\n\n// SetBlockContext updates the block context of the EVM.\nfunc (evm *EVM) SetBlockContext(blockCtx BlockContext) {\n\tevm.Context = blockCtx\n\tnum := blockCtx.BlockNumber\n\ttimestamp := blockCtx.Time\n\tevm.chainRules = evm.chainConfig.Rules(num, blockCtx.Random != nil, timestamp)\n}\n\n// Call executes the contract associated with the addr with the given input as\n// parameters. It also handles any necessary value transfer required and takes\n// the necessary steps to create accounts and reverses the state in case of an\n// execution error or failed value transfer.\nfunc (evm *EVM) Call(caller ContractRef, addr common.Address, input []byte, gas uint64, value *big.Int) (ret []byte, leftOverGas uint64, err error) {\n\t// Fail if we're trying to execute above the call depth limit\n\tif evm.depth > int(params.CallCreateDepth) {\n\t\treturn nil, gas, ErrDepth\n\t}\n\t// Fail if we're trying to transfer more than the available balance\n\tif value.Sign() != 0 && !evm.Context.CanTransfer(evm.StateDB, caller.Address(), value) {\n\t\treturn nil, gas, ErrInsufficientBalance\n\t}\n\tsnapshot := evm.StateDB.Snapshot()\n\tp, isPrecompile := evm.precompile(addr)\n\tdebug := evm.Config.Tracer != nil\n\n\tif !evm.StateDB.Exist(addr) {\n\t\tif !isPrecompile && evm.chainRules.IsEIP158 && value.Sign() == 0 {\n\t\t\t// Calling a non existing account, don't do anything, but ping the tracer\n\t\t\tif debug {\n\t\t\t\tif evm.depth == 0 {\n\t\t\t\t\tevm.Config.Tracer.CaptureStart(evm, caller.Address(), addr, false, input, gas, value)\n\t\t\t\t\tevm.Config.Tracer.CaptureEnd(ret, 0, nil)\n\t\t\t\t} else {\n\t\t\t\t\tevm.Config.Tracer.CaptureEnter(CALL, caller.Address(), addr, input, gas, value)\n\t\t\t\t\tevm.Config.Tracer.CaptureExit(ret, 0, nil)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil, gas, nil\n\t\t}\n\t\tevm.StateDB.CreateAccount(addr)\n\t}\n\tevm.Context.Transfer(evm.StateDB, caller.Address(), addr, value)\n\n\t// Capture the tracer start/end events in debug mode\n\tif debug {\n\t\tif evm.depth == 0 {\n\t\t\tevm.Config.Tracer.CaptureStart(evm, caller.Address(), addr, false, input, gas, value)\n\t\t\tdefer func(startGas uint64) { // Lazy evaluation of the parameters\n\t\t\t\tevm.Config.Tracer.CaptureEnd(ret, startGas-gas, err)\n\t\t\t}(gas)\n\t\t} else {\n\t\t\t// Handle tracer events for entering and exiting a call frame\n\t\t\tevm.Config.Tracer.CaptureEnter(CALL, caller.Address(), addr, input, gas, value)\n\t\t\tdefer func(startGas uint64) {\n\t\t\t\tevm.Config.Tracer.CaptureExit(ret, startGas-gas, err)\n\t\t\t}(gas)\n\t\t}\n\t}\n\n\tif isPrecompile {\n\t\tret, gas, err = RunPrecompiledContract(p, input, gas)\n\t} else {\n\t\t// Initialise a new contract and set the code that is to be used by the EVM.\n\t\t// The contract is a scoped environment for this execution context only.\n\t\tcode := evm.StateDB.GetCode(addr)\n\t\tif len(code) == 0 {\n\t\t\tret, err = nil, nil // gas is unchanged\n\t\t} else {\n\t\t\taddrCopy := addr\n\t\t\t// If the account has no code, we can abort here\n\t\t\t// The depth-check is already done, and precompiles handled above\n\t\t\tcontract := NewContract(caller, AccountRef(addrCopy), value, gas)\n\t\t\tcontract.SetCallCode(&addrCopy, evm.StateDB.GetCodeHash(addrCopy), code)\n\t\t\tret, err = evm.interpreter.Run(contract, input, false)\n\t\t\tgas = contract.Gas\n\t\t}\n\t}\n\t// When an error was returned by the EVM or when setting the creation code\n\t// above we revert to the snapshot and consume any gas remaining. Additionally\n\t// when we're in homestead this also counts for code storage gas errors.\n\tif err != nil {\n\t\tevm.StateDB.RevertToSnapshot(snapshot)\n\t\tif err != ErrExecutionReverted {\n\t\t\tgas = 0\n\t\t}\n\t\t// TODO: consider clearing up unused snapshots:\n\t\t//} else {\n\t\t//\tevm.StateDB.DiscardSnapshot(snapshot)\n\t}\n\treturn ret, gas, err\n}\n\n// CallCode executes the contract associated with the addr with the given input\n// as parameters. It also handles any necessary value transfer required and takes\n// the necessary steps to create accounts and reverses the state in case of an\n// execution error or failed value transfer.\n//\n// CallCode differs from Call in the sense that it executes the given address'\n// code with the caller as context.\nfunc (evm *EVM) CallCode(caller ContractRef, addr common.Address, input []byte, gas uint64, value *big.Int) (ret []byte, leftOverGas uint64, err error) {\n\t// Fail if we're trying to execute above the call depth limit\n\tif evm.depth > int(params.CallCreateDepth) {\n\t\treturn nil, gas, ErrDepth\n\t}\n\t// Fail if we're trying to transfer more than the available balance\n\t// Note although it's noop to transfer X ether to caller itself. But\n\t// if caller doesn't have enough balance, it would be an error to allow\n\t// over-charging itself. So the check here is necessary.\n\tif !evm.Context.CanTransfer(evm.StateDB, caller.Address(), value) {\n\t\treturn nil, gas, ErrInsufficientBalance\n\t}\n\tvar snapshot = evm.StateDB.Snapshot()\n\n\t// Invoke tracer hooks that signal entering/exiting a call frame\n\tif evm.Config.Tracer != nil {\n\t\tevm.Config.Tracer.CaptureEnter(CALLCODE, caller.Address(), addr, input, gas, value)\n\t\tdefer func(startGas uint64) {\n\t\t\tevm.Config.Tracer.CaptureExit(ret, startGas-gas, err)\n\t\t}(gas)\n\t}\n\n\t// It is allowed to call precompiles, even via delegatecall\n\tif p, isPrecompile := evm.precompile(addr); isPrecompile {\n\t\tret, gas, err = RunPrecompiledContract(p, input, gas)\n\t} else {\n\t\taddrCopy := addr\n\t\t// Initialise a new contract and set the code that is to be used by the EVM.\n\t\t// The contract is a scoped environment for this execution context only.\n\t\tcontract := NewContract(caller, AccountRef(caller.Address()),"
    }
  ]
}