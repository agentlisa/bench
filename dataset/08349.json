{
  "Title": "[H-10] Upon changing of delegate, `VoteDelegation` updates both the previous and the current checkpoint",
  "Content": "\n<https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L79><br>\n\n<https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L213><br>\n\nThe contract is accidently editing both the previous and current checkpoint when changing/removing a delegate.\n\n### Impact\n\nIncorrect counting of votes.\n\n### Proof of Concept\n\nIf in `delegate` the delegate already has checkpoints, the function will grab the latest checkpoint, and add the `tokenId` to it. Note that it changes the storage variable.\n\n```solidity\n        if (nCheckpoints > 0) {\n            Checkpoint storage checkpoint = checkpoints[toTokenId][nCheckpoints - 1];\n            checkpoint.delegatedTokenIds.push(tokenId);\n            _writeCheckpoint(toTokenId, nCheckpoints, checkpoint.delegatedTokenIds);\n```\n\nIt then calls `_writeCheckpoint`, which [will add](https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L106) a new checkpoint if there's no checkpoint created for this block yet:\n\n```solidity\n        Checkpoint memory oldCheckpoint = checkpoints[toTokenId][nCheckpoints - 1];\n\n        if (nCheckpoints > 0 && oldCheckpoint.fromBlock == block.number) {\n            oldCheckpoint.delegatedTokenIds = _delegatedTokenIds;\n        } else {\n            checkpoints[toTokenId][nCheckpoints] = Checkpoint(block.number, _delegatedTokenIds);\n            numCheckpoints[toTokenId] = nCheckpoints + 1;\n        }\n```\n\nTherefore, if this function has created a new checkpoint with the passed `_delegatedTokenIds`, we already saw that the previous function has already added `tokenId` to the previous checkpoint, so now both the new checkpoint and the previous checkpoint will have `tokenId` in them.<br>\nThis is wrong as it updates an earlier checkpoint with the latest change.\n\nThe same situation happens in [`removeDelegation`](https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L213).\n\n### Recommended Mitigation Steps\n\nWhen reading the latest checkpoint:\n\n```solidity\nCheckpoint storage checkpoint = checkpoints[toTokenId][nCheckpoints - 1];\n```\n\nChange the `storage` to `memory`. This way it will not affect the previous checkpoint, but will pass the correct updated array to `_writeCheckpoint`, which will then write/update the correct checkpoint.\n\n**[zeroexdead (Golom) confirmed and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/81#issuecomment-1238529978):**\n > Fixed `delegate()`: https://github.com/golom-protocol/contracts/commit/8a8c89beea22cd57f4ffaf3d0defcce863e9657f\n> \n> Fixed `removeDelegation()`: https://github.com/golom-protocol/contracts/commit/72350b0a3bdae4f21e2f015327037080f6bab867\n\n**[LSDan (judge) increased severity to High and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/81#issuecomment-1276357474):**\n > I went back and forth on if this was a duplicate of [H-04 (#169)](https://github.com/code-423n4/2022-07-golom-findings/issues/169) or not. The two issues are so similar it's hard to pull them apart. Ultimately I do see the difference, mainly that this version of the issue results in a retroactive manipulation of voting power whereas the other issue allows the creation of infinite voting power. I'm upgrading this to high risk because it effectively destroys the integrity of the voting system which impacts every aspect of the protocol which is subject to vote.\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-07-golom-contest",
  "Code": [
    {
      "filename": "contracts/vote-escrow/VoteEscrowDelegation.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\n/// votescrow extended with delegation\n\n// import {Math} from '@openzeppelin-contracts/utils/math/SafeCast.sol';\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\n\nimport {VoteEscrowCore} from './VoteEscrowCore.sol';\n\ninterface IVoteEscrow {\n    function balanceOf(uint256) external view returns (uint256);\n\n    function balanceOfAtNFT(uint256, uint256) external view returns (uint256);\n\n    function ownerOf(uint256) external view returns (address);\n}\n\ncontract VoteEscrow is VoteEscrowCore, Ownable {\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(uint256 indexed tokenId, uint256 indexed toTokenId, address indexed currentOwner);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of votes.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /// @notice Delegate of the specific token\n    mapping(uint256 => uint256) public delegates;\n\n    /// @notice Total delegated tokens to specific token\n    mapping(uint256 => uint256[]) public delegatedTokenIds;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint256 fromBlock;\n        uint256[] delegatedTokenIds;\n    }\n\n    /// @notice A record of votes checkpoints for each tokenId, by index\n    mapping(uint256 => mapping(uint256 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each delegated tokenId\n    mapping(uint256 => uint256) public numCheckpoints;\n\n    /// @notice minimum voting power required for delegation\n    uint256 public MIN_VOTING_POWER_REQUIRED = 0;\n\n    constructor(address _token) {\n        token = _token;\n        voter = msg.sender;\n        point_history[0].blk = block.number;\n        point_history[0].ts = block.timestamp;\n\n        supportedInterfaces[ERC165_INTERFACE_ID] = true;\n        supportedInterfaces[ERC721_INTERFACE_ID] = true;\n        supportedInterfaces[ERC721_METADATA_INTERFACE_ID] = true;\n\n        // mint-ish\n        emit Transfer(address(0), address(this), tokenId);\n        // burn-ish\n        emit Transfer(address(this), address(0), tokenId);\n    }\n\n    /// @notice Explain to an end user what this does\n    /// @param tokenId token ID which is being delegated\n    /// @param toTokenId token ID to which the {tokenId} is being delegated\n    function delegate(uint256 tokenId, uint256 toTokenId) external {\n        require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');\n        require(this.balanceOfNFT(tokenId) >= MIN_VOTING_POWER_REQUIRED, 'VEDelegation: Need more voting power');\n\n        delegates[tokenId] = toTokenId;\n        uint256 nCheckpoints = numCheckpoints[toTokenId];\n\n        if (nCheckpoints > 0) {\n            Checkpoint storage checkpoint = checkpoints[toTokenId][nCheckpoints - 1];\n            checkpoint.delegatedTokenIds.push(tokenId);\n            _writeCheckpoint(toTokenId, nCheckpoints, checkpoint.delegatedTokenIds);\n        } else {\n            uint256[] memory array = new uint256[](1);\n            array[0] = tokenId;\n            _writeCheckpoint(toTokenId, nCheckpoints, array);\n        }\n\n        emit DelegateChanged(tokenId, toTokenId, msg.sender);\n    }\n\n    /**\n     * @notice Writes the checkpoint to store current NFTs in the specific block\n     */\n    function _writeCheckpoint(\n        uint256 toTokenId,\n        uint256 nCheckpoints,\n        uint256[] memory _delegatedTokenIds\n    ) internal {\n        require(_delegatedTokenIds.length < 500, 'VVDelegation: Cannot stake more');\n\n        Checkpoint memory oldCheckpoint = checkpoints[toTokenId][nCheckpoints - 1];\n\n        if (nCheckpoints > 0 && oldCheckpoint.fromBlock == block.number) {\n            oldCheckpoint.delegatedTokenIds = _delegatedTokenIds;\n        } else {\n            checkpoints[toTokenId][nCheckpoints] = Checkpoint(block.number, _delegatedTokenIds);\n            numCheckpoints[toTokenId] = nCheckpoints + 1;\n        }\n    }\n\n    /**\n     * @notice Gets the current delegated nfts array for `nftid`\n     * @param tokenId The address to get votes balance\n     * @return The current delegated nfts array for `account`\n     */\n    function _getCurrentDelegated(uint256 tokenId) internal view returns (uint256[] memory) {\n        uint256 nCheckpoints = numCheckpoints[tokenId];\n        uint256[] memory myArray;\n        return nCheckpoints > 0 ? checkpoints[tokenId][nCheckpoints - 1].delegatedTokenIds : myArray;\n    }\n\n    /**\n     * @notice Determine the prior delegated nfts array for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param nftId The id of the nft to check\n     * @param blockNumber The block number to get the delegate nft array at\n     * @return The number of delegated nfts the account had as of the given block\n     */\n    function _getPriorDelegated(uint256 nftId, uint256 blockNumber) internal view returns (uint256[] memory) {\n        require(blockNumber < block.number, 'VEDelegation: not yet determined');\n        uint256[] memory myArray;\n        uint256 nCheckpoints = numCheckpoints[nftId];\n        if (nCheckpoints == 0) {\n            return myArray;\n        }\n\n        // First check most recent balance\n        if (checkpoints[nftId][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[nftId][nCheckpoints - 1].delegatedTokenIds;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[nftId][0].fromBlock > blockNumber) {\n            return myArray;\n        }\n\n        uint256 lower = 0;\n        uint256 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[nftId][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.delegatedTokenIds;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[nftId][lower].delegatedTokenIds;\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param tokenId The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getVotes(uint256 tokenId) external view returns (uint256) {\n        uint256[] memory delegated = _getCurrentDelegated(tokenId);\n        uint256 votes = 0;\n        for (uint256 index = 0; index < delegated.length; index++) {\n            votes = votes + this.balanceOfNFT(delegated[index]);\n        }\n        return votes;\n    }\n\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param tokenId The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(uint256 tokenId, uint256 blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, 'VEDelegation: not yet determined');\n        uint256[] memory delegatednft = _getPriorDelegated(tokenId, blockNumber);\n        uint256 votes = 0;\n        for (uint256 index = 0; index < delegatednft.length; index++) {\n            votes = votes + this.balanceOfAtNFT(delegatednft[index], blockNumber);\n        }\n        return votes;\n    }\n\n    /// @notice Removes specific element from the array\n    /// @param _array Whole array\n    /// @param _element The element which we need to remove\n    function removeElement(uint256[] storage _array, uint256 _element) internal {\n        for (uint256 i; i < _array.length; i++) {\n            if (_array[i] == _element) {\n                _array[i] = _array[_array.length - 1];\n                _array.pop();\n                break;\n            }\n        }\n    }\n\n    /// @notice Remove delegation\n    /// @param tokenId TokenId of which delegation needs to be removed\n    function removeDelegation(uint256 tokenId) external {\n        require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');\n        uint256 nCheckpoints = numCheckpoints[tokenId];\n        Checkpoint storage checkpoint = checkpoints[tokenId][nCheckpoints - 1];\n        removeElement(checkpoint.delegatedTokenIds, tokenId);\n        _writeCheckpoint(tokenId, nCheckpoints, checkpoint.delegatedTokenIds);\n    }\n\n    // /// @notice Remove delegation by user\n    // function removeDelegationByOwner(uint256 delegatedTokenId, uint256 ownerTokenId) external {\n    //     require(ownerOf(ownerTokenId) == msg.sender, 'VEDelegation: Not allowed');\n    //     uint256 nCheckpoints = numCheckpoints[delegatedTokenId];\n    //     Checkpoint storage checkpoint = checkpoints[delegatedTokenId][nCheckpoints - 1];\n    //     removeElement(checkpoint.delegatedTokenIds, delegatedTokenId);\n    //     _writeCheckpoint(ownerTokenId, nCheckpoints, checkpoint.delegatedTokenIds);\n    // }\n\n    /// @dev Exeute transfer of a NFT.\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n    ///      address for this NFT. (NOTE: `msg.sender` not allowed in internal function so pass `_sender`.)\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    function _transferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        address _sender\n    ) internal override {\n        require(attachments[_tokenId] == 0 && !voted[_tokenId], 'attached');\n\n        // remove the delegation\n        this.removeDelegation(_tokenId);\n\n        // Check requirements\n        require(_isApprovedOrOwner(_sender, _tokenId));\n        // Clear approval. Throws if `_from` is not the current owner\n        _clearApproval(_from, _tokenId);\n        // Remove NFT. Throws if `_tokenId` is not a valid NFT\n        _removeTokenFrom(_from, _tokenId);\n        // Add NFT\n        _addTokenTo(_to, _tokenId);\n        // Set the block of ownership transfer (for Flash NFT protection)\n        ownership_change[_tokenId] = block.number;\n        // Log the transfer\n        emit Transfer(_from, _to, _tokenId);\n    }\n\n    /// @notice Changes minimum voting power required for delegation\n    /// @param _newMinVotingPower New minimum voting power required\n    function changeMinVotingPower(uint256 _newMinVotingPower) external onlyOwner {\n        MIN_VOTING_POWER_REQUIRED = _newMinVotingPower;\n    }\n}"
    },
    {
      "filename": "contracts/vote-escrow/VoteEscrowDelegation.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\n/// votescrow extended with delegation\n\n// import {Math} from '@openzeppelin-contracts/utils/math/SafeCast.sol';\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\n\nimport {VoteEscrowCore} from './VoteEscrowCore.sol';\n\ninterface IVoteEscrow {\n    function balanceOf(uint256) external view returns (uint256);\n\n    function balanceOfAtNFT(uint256, uint256) external view returns (uint256);\n\n    function ownerOf(uint256) external view returns (address);\n}\n\ncontract VoteEscrow is VoteEscrowCore, Ownable {\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(uint256 indexed tokenId, uint256 indexed toTokenId, address indexed currentOwner);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of votes.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /// @notice Delegate of the specific token\n    mapping(uint256 => uint256) public delegates;\n\n    /// @notice Total delegated tokens to specific token\n    mapping(uint256 => uint256[]) public delegatedTokenIds;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint256 fromBlock;\n        uint256[] delegatedTokenIds;\n    }\n\n    /// @notice A record of votes checkpoints for each tokenId, by index\n    mapping(uint256 => mapping(uint256 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each delegated tokenId\n    mapping(uint256 => uint256) public numCheckpoints;\n\n    /// @notice minimum voting power required for delegation\n    uint256 public MIN_VOTING_POWER_REQUIRED = 0;\n\n    constructor(address _token) {\n        token = _token;\n        voter = msg.sender;\n        point_history[0].blk = block.number;\n        point_history[0].ts = block.timestamp;\n\n        supportedInterfaces[ERC165_INTERFACE_ID] = true;\n        supportedInterfaces[ERC721_INTERFACE_ID] = true;\n        supportedInterfaces[ERC721_METADATA_INTERFACE_ID] = true;\n\n        // mint-ish\n        emit Transfer(address(0), address(this), tokenId);\n        // burn-ish\n        emit Transfer(address(this), address(0), tokenId);\n    }\n\n    /// @notice Explain to an end user what this does\n    /// @param tokenId token ID which is being delegated\n    /// @param toTokenId token ID to which the {tokenId} is being delegated\n    function delegate(uint256 tokenId, uint256 toTokenId) external {\n        require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');\n        require(this.balanceOfNFT(tokenId) >= MIN_VOTING_POWER_REQUIRED, 'VEDelegation: Need more voting power');\n\n        delegates[tokenId] = toTokenId;\n        uint256 nCheckpoints = numCheckpoints[toTokenId];\n\n        if (nCheckpoints > 0) {\n            Checkpoint storage checkpoint = checkpoints[toTokenId][nCheckpoints - 1];\n            checkpoint.delegatedTokenIds.push(tokenId);\n            _writeCheckpoint(toTokenId, nCheckpoints, checkpoint.delegatedTokenIds);\n        } else {\n            uint256[] memory array = new uint256[](1);\n            array[0] = tokenId;\n            _writeCheckpoint(toTokenId, nCheckpoints, array);\n        }\n\n        emit DelegateChanged(tokenId, toTokenId, msg.sender);\n    }\n\n    /**\n     * @notice Writes the checkpoint to store current NFTs in the specific block\n     */\n    function _writeCheckpoint(\n        uint256 toTokenId,\n        uint256 nCheckpoints,\n        uint256[] memory _delegatedTokenIds\n    ) internal {\n        require(_delegatedTokenIds.length < 500, 'VVDelegation: Cannot stake more');\n\n        Checkpoint memory oldCheckpoint = checkpoints[toTokenId][nCheckpoints - 1];\n\n        if (nCheckpoints > 0 && oldCheckpoint.fromBlock == block.number) {\n            oldCheckpoint.delegatedTokenIds = _delegatedTokenIds;\n        } else {\n            checkpoints[toTokenId][nCheckpoints] = Checkpoint(block.number, _delegatedTokenIds);\n            numCheckpoints[toTokenId] = nCheckpoints + 1;\n        }\n    }\n\n    /**\n     * @notice Gets the current delegated nfts array for `nftid`\n     * @param tokenId The address to get votes balance\n     * @return The current delegated nfts array for `account`\n     */\n    function _getCurrentDelegated(uint256 tokenId) internal view returns (uint256[] memory) {\n        uint256 nCheckpoints = numCheckpoints[tokenId];\n        uint256[] memory myArray;\n        return nCheckpoints > 0 ? checkpoints[tokenId][nCheckpoints - 1].delegatedTokenIds : myArray;\n    }\n\n    /**\n     * @notice Determine the prior delegated nfts array for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param nftId The id of the nft to check\n     * @param blockNumber The block number to get the delegate nft array at\n     * @return The number of delegated nfts the account had as of the given block\n     */\n    function _getPriorDelegated(uint256 nftId, uint256 blockNumber) internal view returns (uint256[] memory) {\n        require(blockNumber < block.number, 'VEDelegation: not yet determined');\n        uint256[] memory myArray;\n        uint256 nCheckpoints = numCheckpoints[nftId];\n        if (nCheckpoints == 0) {\n            return myArray;\n        }\n\n        // First check most recent balance\n        if (checkpoints[nftId][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[nftId][nCheckpoints - 1].delegatedTokenIds;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[nftId][0].fromBlock > blockNumber) {\n            return myArray;\n        }\n\n        uint256 lower = 0;\n        uint256 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[nftId][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.delegatedTokenIds;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[nftId][lower].delegatedTokenIds;\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param tokenId The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getVotes(uint256 tokenId) external view returns (uint256) {\n        uint256[] memory delegated = _getCurrentDelegated(tokenId);\n        uint256 votes = 0;\n        for (uint256 index = 0; index < delegated.length; index++) {\n            votes = votes + this.balanceOfNFT(delegated[index]);\n        }\n        return votes;\n    }\n\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param tokenId The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(uint256 tokenId, uint256 blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, 'VEDelegation: not yet determined');\n        uint256[] memory delegatednft = _getPriorDelegated(tokenId, blockNumber);\n        uint256 votes = 0;\n        for (uint256 index = 0; index < delegatednft.length; index++) {\n            votes = votes + this.balanceOfAtNFT(delegatednft[index], blockNumber);\n        }\n        return votes;\n    }\n\n    /// @notice Removes specific element from the array\n    /// @param _array Whole array\n    /// @param _element The element which we need to remove\n    function removeElement(uint256[] storage _array, uint256 _element) internal {\n        for (uint256 i; i < _array.length; i++) {\n            if (_array[i] == _element) {\n                _array[i] = _array[_array.length - 1];\n                _array.pop();\n                break;\n            }\n        }\n    }\n\n    /// @notice Remove delegation\n    /// @param tokenId TokenId of which delegation needs to be removed\n    function removeDelegation(uint256 tokenId) external {\n        require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');\n        uint256 nCheckpoints = numCheckpoints[tokenId];\n        Checkpoint storage checkpoint = checkpoints[tokenId][nCheckpoints - 1];\n        removeElement(checkpoint.delegatedTokenIds, tokenId);\n        _writeCheckpoint(tokenId, nCheckpoints, checkpoint.delegatedTokenIds);\n    }\n\n    // /// @notice Remove delegation by user\n    // function removeDelegationByOwner(uint256 delegatedTokenId, uint256 ownerTokenId) external {\n    //     require(ownerOf(ownerTokenId) == msg.sender, 'VEDelegation: Not allowed');\n    //     uint256 nCheckpoints = numCheckpoints[delegatedTokenId];\n    //     Checkpoint storage checkpoint = checkpoints[delegatedTokenId][nCheckpoints - 1];\n    //     removeElement(checkpoint.delegatedTokenIds, delegatedTokenId);\n    //     _writeCheckpoint(ownerTokenId, nCheckpoints, checkpoint.delegatedTokenIds);\n    // }\n\n    /// @dev Exeute transfer of a NFT.\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n    ///      address for this NFT. (NOTE: `msg.sender` not allowed in internal function so pass `_sender`.)\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    function _transferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        address _sender\n    ) internal override {\n        require(attachments[_tokenId] == 0 && !voted[_tokenId], 'attached');\n\n        // remove the delegation\n        this.removeDelegation(_tokenId);\n\n        // Check requirements\n        require(_isApprovedOrOwner(_sender, _tokenId));\n        // Clear approval. Throws if `_from` is not the current owner\n        _clearApproval(_from, _tokenId);\n        // Remove NFT. Throws if `_tokenId` is not a valid NFT\n        _removeTokenFrom(_from, _tokenId);\n        // Add NFT\n        _addTokenTo(_to, _tokenId);\n        // Set the block of ownership transfer (for Flash NFT protection)\n        ownership_change[_tokenId] = block.number;\n        // Log the transfer\n        emit Transfer(_from, _to, _tokenId);\n    }\n\n    /// @notice Changes minimum voting power required for delegation\n    /// @param _newMinVotingPower New minimum voting power required\n    function changeMinVotingPower(uint256 _newMinVotingPower) external onlyOwner {\n        MIN_VOTING_POWER_REQUIRED = _newMinVotingPower;\n    }\n}"
    },
    {
      "filename": "contracts/vote-escrow/VoteEscrowDelegation.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\n/// votescrow extended with delegation\n\n// import {Math} from '@openzeppelin-contracts/utils/math/SafeCast.sol';\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\n\nimport {VoteEscrowCore} from './VoteEscrowCore.sol';\n\ninterface IVoteEscrow {\n    function balanceOf(uint256) external view returns (uint256);\n\n    function balanceOfAtNFT(uint256, uint256) external view returns (uint256);\n\n    function ownerOf(uint256) external view returns (address);\n}\n\ncontract VoteEscrow is VoteEscrowCore, Ownable {\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(uint256 indexed tokenId, uint256 indexed toTokenId, address indexed currentOwner);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of votes.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /// @notice Delegate of the specific token\n    mapping(uint256 => uint256) public delegates;\n\n    /// @notice Total delegated tokens to specific token\n    mapping(uint256 => uint256[]) public delegatedTokenIds;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint256 fromBlock;\n        uint256[] delegatedTokenIds;\n    }\n\n    /// @notice A record of votes checkpoints for each tokenId, by index\n    mapping(uint256 => mapping(uint256 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each delegated tokenId\n    mapping(uint256 => uint256) public numCheckpoints;\n\n    /// @notice minimum voting power required for delegation\n    uint256 public MIN_VOTING_POWER_REQUIRED = 0;\n\n    constructor(address _token) {\n        token = _token;\n        voter = msg.sender;\n        point_history[0].blk = block.number;\n        point_history[0].ts = block.timestamp;\n\n        supportedInterfaces[ERC165_INTERFACE_ID] = true;\n        supportedInterfaces[ERC721_INTERFACE_ID] = true;\n        supportedInterfaces[ERC721_METADATA_INTERFACE_ID] = true;\n\n        // mint-ish\n        emit Transfer(address(0), address(this), tokenId);\n        // burn-ish\n        emit Transfer(address(this), address(0), tokenId);\n    }\n\n    /// @notice Explain to an end user what this does\n    /// @param tokenId token ID which is being delegated\n    /// @param toTokenId token ID to which the {tokenId} is being delegated\n    function delegate(uint256 tokenId, uint256 toTokenId) external {\n        require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');\n        require(this.balanceOfNFT(tokenId) >= MIN_VOTING_POWER_REQUIRED, 'VEDelegation: Need more voting power');\n\n        delegates[tokenId] = toTokenId;\n        uint256 nCheckpoints = numCheckpoints[toTokenId];\n\n        if (nCheckpoints > 0) {\n            Checkpoint storage checkpoint = checkpoints[toTokenId][nCheckpoints - 1];\n            checkpoint.delegatedTokenIds.push(tokenId);\n            _writeCheckpoint(toTokenId, nCheckpoints, checkpoint.delegatedTokenIds);\n        } else {\n            uint256[] memory array = new uint256[](1);\n            array[0] = tokenId;\n            _writeCheckpoint(toTokenId, nCheckpoints, array);\n        }\n\n        emit DelegateChanged(tokenId, toTokenId, msg.sender);\n    }\n\n    /**\n     * @notice Writes the checkpoint to store current NFTs in the specific block\n     */\n    function _writeCheckpoint(\n        uint256 toTokenId,\n        uint256 nCheckpoints,\n        uint256[] memory _delegatedTokenIds\n    ) internal {\n        require(_delegatedTokenIds.length < 500, 'VVDelegation: Cannot stake more');\n\n        Checkpoint memory oldCheckpoint = checkpoints[toTokenId][nCheckpoints - 1];\n\n        if (nCheckpoints > 0 && oldCheckpoint.fromBlock == block.number) {\n            oldCheckpoint.delegatedTokenIds = _delegatedTokenIds;\n        } else {\n            checkpoints[toTokenId][nCheckpoints] = Checkpoint(block.number, _delegatedTokenIds);\n            numCheckpoints[toTokenId] = nCheckpoints + 1;\n        }\n    }\n\n    /**\n     * @notice Gets the current delegated nfts array for `nftid`\n     * @param tokenId The address to get votes balance\n     * @return The current delegated nfts array for `account`\n     */\n    function _getCurrentDelegated(uint256 tokenId) internal view returns (uint256[] memory) {\n        uint256 nCheckpoints = numCheckpoints[tokenId];\n        uint256[] memory myArray;\n        return nCheckpoints > 0 ? checkpoints[tokenId][nCheckpoints - 1].delegatedTokenIds : myArray;\n    }\n\n    /**\n     * @notice Determine the prior delegated nfts array for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param nftId The id of the nft to check\n     * @param blockNumber The block number to get the delegate nft array at\n     * @return The number of delegated nfts the account had as of the given block\n     */\n    function _getPriorDelegated(uint256 nftId, uint256 blockNumber) internal view returns (uint256[] memory) {\n        require(blockNumber < block.number, 'VEDelegation: not yet determined');\n        uint256[] memory myArray;\n        uint256 nCheckpoints = numCheckpoints[nftId];\n        if (nCheckpoints == 0) {\n            return myArray;\n        }\n\n        // First check most recent balance\n        if (checkpoints[nftId][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[nftId][nCheckpoints - 1].delegatedTokenIds;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[nftId][0].fromBlock > blockNumber) {\n            return myArray;\n        }\n\n        uint256 lower = 0;\n        uint256 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[nftId][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.delegatedTokenIds;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[nftId][lower].delegatedTokenIds;\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param tokenId The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getVotes(uint256 tokenId) external view returns (uint256) {\n        uint256[] memory delegated = _getCurrentDelegated(tokenId);\n        uint256 votes = 0;\n        for (uint256 index = 0; index < delegated.length; index++) {\n            votes = votes + this.balanceOfNFT(delegated[index]);\n        }\n        return votes;\n    }\n\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param tokenId The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(uint256 tokenId, uint256 blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, 'VEDelegation: not yet determined');\n        uint256[] memory delegatednft = _getPriorDelegated(tokenId, blockNumber);\n        uint256 votes = 0;\n        for (uint256 index = 0; index < delegatednft.length; index++) {\n            votes = votes + this.balanceOfAtNFT(delegatednft[index], blockNumber);\n        }\n        return votes;\n    }\n\n    /// @notice Removes specific element from the array\n    /// @param _array Whole array\n    /// @param _element The element which we need to remove\n    function removeElement(uint256[] storage _array, uint256 _element) internal {\n        for (uint256 i; i < _array.length; i++) {\n            if (_array[i] == _element) {\n                _array[i] = _array[_array.length - 1];\n                _array.pop();\n                break;\n            }\n        }\n    }\n\n    /// @notice Remove delegation\n    /// @param tokenId TokenId of which delegation needs to be removed\n    function removeDelegation(uint256 tokenId) external {\n        require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');\n        uint256 nCheckpoints = numCheckpoints[tokenId];\n        Checkpoint storage checkpoint = checkpoints[tokenId][nCheckpoints - 1];\n        removeElement(checkpoint.delegatedTokenIds, tokenId);\n        _writeCheckpoint(tokenId, nCheckpoints, checkpoint.delegatedTokenIds);\n    }\n\n    // /// @notice Remove delegation by user\n    // function removeDelegationByOwner(uint256 delegatedTokenId, uint256 ownerTokenId) external {\n    //     require(ownerOf(ownerTokenId) == msg.sender, 'VEDelegation: Not allowed');\n    //     uint256 nCheckpoints = numCheckpoints[delegatedTokenId];\n    //     Checkpoint storage checkpoint = checkpoints[delegatedTokenId][nCheckpoints - 1];\n    //     removeElement(checkpoint.delegatedTokenIds, delegatedTokenId);\n    //     _writeCheckpoint(ownerTokenId, nCheckpoints, checkpoint.delegatedTokenIds);\n    // }\n\n    /// @dev Exeute transfer of a NFT.\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n    ///      address for this NFT. (NOTE: `msg.sender` not allowed in internal function so pass `_sender`.)\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    function _transferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        address _sender\n    ) internal override {\n        require(attachments[_tokenId] == 0 && !voted[_tokenId], 'attached');\n\n        // remove the delegation\n        this.removeDelegation(_tokenId);\n\n        // Check requirements\n        require(_isApprovedOrOwner(_sender, _tokenId));\n        // Clear approval. Throws if `_from` is not the current owner\n        _clearApproval(_from, _tokenId);\n        // Remove NFT. Throws if `_tokenId` is not a valid NFT\n        _removeTokenFrom(_from, _tokenId);\n        // Add NFT\n        _addTokenTo(_to, _tokenId);\n        // Set the block of ownership transfer (for Flash NFT protection)\n        ownership_change[_tokenId] = block.number;\n        // Log the transfer\n        emit Transfer(_from, _to, _tokenId);\n    }\n\n    /// @notice Changes minimum voting power required for delegation\n    /// @param _newMinVotingPower New minimum voting power required\n    function changeMinVotingPower(uint256 _newMinVotingPower) external onlyOwner {\n        MIN_VOTING_POWER_REQUIRED = _newMinVotingPower;\n    }\n}"
    },
    {
      "filename": "contracts/vote-escrow/VoteEscrowDelegation.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\n/// votescrow extended with delegation\n\n// import {Math} from '@openze"
    }
  ]
}