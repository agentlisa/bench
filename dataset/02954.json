{
  "Title": "The info parameter might lose information about an IPFS hash",
  "Content": "The `info` parameter of the `report`, [`dispute`](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/governance/Reporter.sol#L190-L196), and other functions assume that the length of the IPFS hash is 32 bytes or shorter. However, that is not the case for [CIDv1](https://github.com/multiformats/cid#cidv1) where the hash can be longer than 32 bytes and also contain prefixes.\n\n\nThis leads to a data availability issue when NPM holders might be unable to retrieve the incident information from the smart contracts. Consequently, they are unable to decide whether to attest or refute the incident.\n\n\nConsider using a different data structure for storing an IPFS hash.\n\n\n**Update:** *Fixed as of commit `5ebb130fe274f0237e368ceaac25751936c1b321` in [pull request #165](https://github.com/neptune-mutual-blue/protocol/pull/165).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/core/governance/Reporter.sol",
      "content": "// Neptune Mutual Protocol (https://neptunemutual.com)\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\nimport \"../../interfaces/IReporter.sol\";\nimport \"./Witness.sol\";\n\n/**\n * @title Reporter Contract\n *\n * @dev This contract allows any NPM tokenholder to report a new incident\n * or dispute a previously recorded incident.\n *\n * <br /> <br />\n *\n * When a cover pool is reporting, additional tokenholders may join in to reach a resolution.\n * The `First Reporter` is the user who initially submits an incident,\n * while `Candidate Reporter` is the user who challenges the submitted report.\n *\n * <br /> <br />\n *\n * Valid reporter is one of the aforementioned who receives a favourable decision\n * when resolution is achieved.\n *\n * <br /> <br />\n *\n * **Warning:**\n *\n * <br /> <br />\n *\n * Please carefully check the cover rules, cover exclusions, and standard exclusion\n * in detail before you interact with the Governace contract(s). You entire stake will be forfeited\n * if resolution does not go in your favor. You will be able to unstake\n * and receive back your NPM only if:\n *\n * - incident resolution is in your favor\n * - after reporting period ends\n *\n * <br /> <br />\n *\n * **By using this contract directly via a smart contract call,\n * through an explorer service such as Etherscan, using an SDK and/or API, or in any other way,\n * you are completely aware, fully understand, and accept the risk that you may lose all of\n * your stake.**\n *\n */\nabstract contract Reporter is IReporter, Witness {\n  using GovernanceUtilV1 for IStore;\n  using RegistryLibV1 for IStore;\n  using CoverUtilV1 for IStore;\n  using ProtoUtilV1 for IStore;\n  using StoreKeyUtil for IStore;\n  using ValidationLibV1 for IStore;\n  using NTransferUtilV2 for IERC20;\n\n  /**\n   * @dev Stake NPM tokens to file an incident report.\n   * Check the `[getFirstReportingStake(coverKey) method](#getfirstreportingstake)` to get\n   * the minimum amount required to report this cover.\n   *\n   * <br /> <br />\n   *\n   * For more info, check out the [documentation](https://docs.neptunemutual.com/covers/cover-reporting)\n   *\n   * <br /> <br />\n   *\n   * **Rewards:**\n   *\n   * <br />\n   *\n   * If you obtain a favourable resolution, you will enjoy the following benefits:\n   *\n   * - A proportional commission in NPM tokens on all rewards earned by qualified camp voters (see [Unstakable.unstakeWithClaim](Unstakable.md#unstakewithclaim)).\n   * - A proportional commission on the protocol earnings of all stablecoin claim payouts.\n   * - Your share of the 60 percent pool of invalid camp participants.\n   *\n   *\n   * @custom:note Please note the differences between the following:\n   *\n   * **Observed Date**\n   *\n   * The date an time when incident occurred in the real world.\n   *\n   * **Incident Date**\n   *\n   * Instead of observed date or the real date and time of the trigger incident,\n   * the timestamp when this report is submitted is \"the incident date\".\n   *\n   * Payouts to policyholders is given only if the reported incident date\n   * falls within the coverage period.\n   *\n   *\n   * @custom:warning **Warning:**\n   *\n   * Please carefully check the cover rules, cover exclusions, and standard exclusion\n   * in detail before you submit this report. You entire stake will be forfeited\n   * if resolution does not go in your favor. You will be able to unstake\n   * and receive back your NPM only if:\n   *\n   * - incident resolution is in your favor\n   * - after reporting period ends\n   *\n   * **By using this function directly via a smart contract call,\n   * through an explorer service such as Etherscan, using an SDK and/or API, or in any other way,\n   * you are completely aware, fully understand, and accept the risk that you may lose all of\n   * your stake.**\n   *\n   *\n   * @custom:suppress-acl This is a publicly accessible feature\n   *\n   * @param coverKey Enter the cover key you are reporting\n   * @param productKey Enter the product key you are reporting\n   * @param info Enter IPFS hash of the incident in the following format:\n   * <br />\n   * <pre>{\n   * <br />  incidentTitle: 'Animated Brands Exploit, August 2024',\n   * <br />  observed: 1723484937,\n   * <br />  proofOfIncident: 'https://twitter.com/AnimatedBrand/status/5739383124571205635',\n   * <br />  description: 'In a recent exploit, attackers were able to drain 50M USDC from Animated Brands lending vaults',\n   * <br />}\n   * </pre>\n   * @param stake Enter the amount you would like to stake to submit this report\n   *\n   */\n  function report(\n    bytes32 coverKey,\n    bytes32 productKey,\n    bytes32 info,\n    uint256 stake\n  ) external override nonReentrant {\n    s.mustNotBePaused();\n    s.mustBeSupportedProductOrEmpty(coverKey, productKey);\n\n    s.mustHaveNormalProductStatus(coverKey, productKey);\n\n    uint256 incidentDate = block.timestamp; // solhint-disable-line\n    require(stake > 0, \"Stake insufficient\");\n    require(stake >= s.getMinReportingStakeInternal(coverKey), \"Stake insufficient\");\n\n    s.setUintByKeys(ProtoUtilV1.NS_GOVERNANCE_REPORTING_INCIDENT_DATE, coverKey, productKey, incidentDate);\n\n    // Set the Resolution Timestamp\n    uint256 resolutionDate = block.timestamp + s.getReportingPeriodInternal(coverKey); // solhint-disable-line\n    s.setUintByKeys(ProtoUtilV1.NS_GOVERNANCE_RESOLUTION_TS, coverKey, productKey, resolutionDate);\n\n    // Update the values\n    s.addAttestationInternal(coverKey, productKey, msg.sender, incidentDate, stake);\n\n    // Transfer the stake to the resolution contract\n    s.npmToken().ensureTransferFrom(msg.sender, address(s.getResolutionContract()), stake);\n\n    emit Reported(coverKey, productKey, msg.sender, incidentDate, info, stake, resolutionDate);\n    emit Attested(coverKey, productKey, msg.sender, incidentDate, stake);\n  }\n\n  /**\n   * @dev If you believe that a reported incident is wrong, you can stake NPM tokens to dispute an incident report.\n   * Check the `[getFirstReportingStake(coverKey) method](#getfirstreportingstake)` to get\n   * the minimum amount required to report this cover.\n   *\n   * <br /> <br />\n   *\n   * **Rewards:**\n   *\n   * If you get resolution in your favor, you will receive these rewards:\n   *\n   * - A 10% commission on all reward received by valid camp voters (check `Unstakeable.unstakeWithClaim`) in NPM tokens.\n   * - Your proportional share of the 60% pool of the invalid camp.\n   *\n   * @custom:warning **Warning:**\n   *\n   * Please carefully check the coverage rules and exclusions in detail\n   * before you submit this report. You entire stake will be forfeited\n   * if resolution does not go in your favor. You will be able to unstake\n   * and receive back your NPM only if:\n   *\n   *\n   * By using this function directly via a smart contract call,\n   * through an explorer service such as Etherscan, using an SDK and/or API, or in any other way,\n   * you are completely aware, fully understand, and accept the risk that you may lose all of\n   * your stake.\n   *\n   * - incident resolution is in your favor\n   * - after reporting period ends\n   *\n   *\n   * @custom:suppress-acl This is a publicly accessible feature\n   *\n   * @param coverKey Enter the cover key you are reporting\n   * @param productKey Enter the product key you are reporting\n   * @param info Enter IPFS hash of the incident in the following format:\n   * `{\n   *    incidentTitle: 'Wrong Incident Reporting',\n   *    observed: 1723484937,\n   *    proofOfIncident: 'https://twitter.com/AnimatedBrand/status/5739383124571205635',\n   *    description: 'Animated Brands emphasised in its most recent tweet that the report regarding their purported hack was false.',\n   *  }`\n   * @param stake Enter the amount you would like to stake to submit this dispute\n   *\n   */\n  function dispute(\n    bytes32 coverKey,\n    bytes32 productKey,\n    uint256 incidentDate,\n    bytes32 info,\n    uint256 stake\n  ) external override nonReentrant {\n    s.mustNotBePaused();\n    s.mustBeSupportedProductOrEmpty(coverKey, productKey);\n    s.mustNotHaveDispute(coverKey, productKey);\n    s.mustBeReporting(coverKey, productKey);\n    s.mustBeValidIncidentDate(coverKey, productKey, incidentDate);\n    s.mustBeDuringReportingPeriod(coverKey, productKey);\n\n    require(stake > 0, \"Stake insufficient\");\n    require(stake >= s.getMinReportingStakeInternal(coverKey), \"Stake insufficient\");\n\n    s.addRefutationInternal(coverKey, productKey, msg.sender, incidentDate, stake);\n\n    // Transfer the stake to the resolution contract\n    s.npmToken().ensureTransferFrom(msg.sender, address(s.getResolutionContract()), stake);\n\n    emit Disputed(coverKey, productKey, msg.sender, incidentDate, info, stake);\n    emit Refuted(coverKey, productKey, msg.sender, incidentDate, stake);\n  }\n\n  /**\n   * @dev Allows a cover manager set first reporting (minimum) stake of a given cover.\n   *\n   * @param coverKey Provide a coverKey or leave it empty. If empty, the stake is set as\n   * fallback value. Covers that do not have customized first reporting stake will infer to the fallback value.\n   * @param value Enter the first reporting stake in NPM units\n   *\n   */\n  function setFirstReportingStake(bytes32 coverKey, uint256 value) external override nonReentrant {\n    s.mustNotBePaused();\n    AccessControlLibV1.mustBeCoverManager(s);\n    require(value > 0, \"Please specify value\");\n\n    uint256 previous = getFirstReportingStake(coverKey);\n\n    if (coverKey > 0) {\n      s.setUintByKeys(ProtoUtilV1.NS_GOVERNANCE_REPORTING_MIN_FIRST_STAKE, coverKey, value);\n    } else {\n      s.setUintByKey(ProtoUtilV1.NS_GOVERNANCE_REPORTING_MIN_FIRST_STAKE, value);\n    }\n\n    emit FirstReportingStakeSet(coverKey, previous, value);\n  }\n\n  /**\n   * @dev Returns the minimum amount of NPM tokens required to `report` or `dispute` a cover.\n   *\n   * Warning: this function does not validate the cover key supplied.\n   *\n   * @param coverKey Specify the cover you want to get the minimum stake required value of.\n   *\n   */\n  function getFirstReportingStake(bytes32 coverKey) public view override returns (uint256) {\n    return s.getMinReportingStakeInternal(coverKey);\n  }\n\n  /**\n   * @dev Allows a cover manager set burn rate of the NPM tokens of the invalid camp.\n   * The protocol forfeits all stakes of invalid camp voters. During `unstakeWithClaim`,\n   * NPM tokens get proportionately burned as configured here.\n   *\n   * <br /> <br />\n   *\n   * The unclaimed and thus unburned NPM stakes will be manually pulled\n   * and burned on a periodic but not-so-frequent basis.\n   *\n   * @param value Enter the burn rate in percentage value (Check ProtoUtilV1.MULTIPLIER for division)\n   *\n   */\n  function setReportingBurnRate(uint256 value) external override nonReentrant {\n    require(value > 0, \"Please specify value\");\n\n    s.mustNotBePaused();\n    AccessControlLibV1.mustBeCoverManager(s);\n\n    uint256 previous = s.getUintByKey(ProtoUtilV1.NS_GOVERNANCE_REPORTING_BURN_RATE);\n    s.setUintByKey(ProtoUtilV1.NS_GOVERNANCE_REPORTING_BURN_RATE, value);\n\n    emit ReportingBurnRateSet(previous, value);\n  }\n\n  /**\n   * @dev Allows a cover manager set reporter comission of the NPM tokens from the invalid camp.\n   * The protocol forfeits all stakes of invalid camp voters. During `unstakeWithClaim`,\n   * NPM tokens get proportionately transferred to the **valid reporter** as configured here.\n   *\n   * <br /> <br />\n   *\n   * The unclaimed and thus unrewarded NPM stakes will be manually pulled and burned on a periodic but not-so-frequent basis.\n   *\n   * @param value Enter the valid reporter comission in percentage value (Check ProtoUtilV1.MULTIPLIER for division)\n   *\n   */\n  function setReporterCommission(uint256 value) external override nonReentrant {\n    s.mustNotBePaused();\n    AccessControlLibV1.mustBeCoverManager(s);\n    require(value > 0, \"Please specify value\");\n\n    uint256 previous = s.getUintByKey(ProtoUtilV1.NS_GOVERNANCE_REPORTER_COMMISSION);\n    s.setUintByKey(ProtoUtilV1.NS_GOVERNANCE_REPORTER_COMMISSION, value);\n\n    emit ReporterCommissionSet(previous, value);\n  }\n\n  /**\n   * @dev Gets the latest incident date of a given cover product\n   *\n   * Warning: this function does not validate the cover and product key supplied.\n   *\n   * @param coverKey Enter the cover key you want to get the incident of\n   * @param productKey Enter the product key you want to get the incident of\n   *\n   */\n  function getActiveIncidentDate(bytes32 coverKey, bytes32 productKey) external view override returns (uint256) {\n    return s.getActiveIncidentDateInternal(coverKey, productKey);\n  }\n\n  /**\n   * @dev Gets the reporter of a cover by its incident date\n   *\n   * Warning: this function does not validate the input arguments.\n   *\n   * @custom:note Please note that until resolution deadline is over, the returned\n   * reporter might keep changing.\n   *\n   * @param coverKey Enter the cover key you would like to get the reporter of\n   * @param productKey Enter the product key you would like to get the reporter of\n   * @param productKey Enter the cover's incident date you would like to get the reporter of\n   */\n  function getReporter(\n    bytes32 coverKey,\n    bytes32 productKey,\n    uint256 incidentDate\n  ) external view override returns (address) {\n    return s.getReporterInternal(coverKey, productKey, incidentDate);\n  }\n\n  /**\n   * @dev Retuns the resolution date of a given cover\n   *\n   * Warning: this function does not validate the input arguments.\n   *\n   * @param coverKey Enter the cover key to get the resolution date of\n   * @param productKey Enter the product key to get the resolution date of\n   *\n   */\n  function getResolutionTimestamp(bytes32 coverKey, bytes32 productKey) external view override returns (uint256) {\n    return s.getResolutionTimestampInternal(coverKey, productKey);\n  }\n\n  /**\n   * @dev Gets an account's attestation details. Please also check `getRefutation` since an account\n   * can submit both `attestations` and `refutations` if they wish to.\n   *\n   * Warning: this function does not validate the input arguments.\n   *\n   * @param coverKey Enter the cover key you want to get attestation of\n   * @param productKey Enter the product key you want to get attestation of\n   * @param who Enter the account you want to get attestation of\n   * @param who Enter the specified cover's indicent date for which attestation will be returned\n   *\n   */\n  function getAttestation(\n    bytes32 coverKey,\n    bytes32 productKey,\n    address who,\n    uint256 incidentDate\n  ) external view override returns (uint256 myStake, uint256 totalStake) {\n    return s.getAttestationInternal(coverKey, productKey, who, incidentDate);\n  }\n\n  /**\n   * @dev Gets an account's refutation details. Please also check `getAttestation` since an account\n   * can submit both `attestations` and `refutations` if they wish to.\n   *\n   * Warning: this function does not validate the input arguments.\n   *\n   * @param coverKey Enter the cover key you want to get refutation of\n   * @param productKey Enter the product key you want to get refutation of\n   * @param who Enter the account you want to get refutation of\n   * @param who Enter the specified cover's indicent date for which refutation will be returned\n   *\n   */\n  function getRefutation(\n    bytes32 coverKey,\n    bytes32 productKey,\n    address who,\n    uint256 incidentDate\n  ) external view override returns (uint256 myStake, uint256 totalStake) {\n    return s.getRefutationInternal(coverKey, productKey, who, incidentDate);\n  }\n}"
    }
  ]
}