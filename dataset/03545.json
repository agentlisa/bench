{
  "Title": "[M04] Trapped Liquidity Rewards",
  "Content": "Whenever a liquidity reward campaign is initiated, the `LiquidityReward` contract [ensures the contract is preloaded](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/liquidity/LiquidityReward.sol#L114-L118) with enough reward tokens to execute the campaign. However, some of these rewards would not be distributed if the [campaign is stopped](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/liquidity/LiquidityReward.sol#L137). In this scenario, the excess reward tokens cannot be retrieved from the contract. It would be possible to start a new campaign, but then the funds would be distributed to the existing depositors, which may not be desired (and likely undermines the reason for stopping the campaign). Consider introducing a mechanism to retrieve reward tokens that are not intended for distribution.\n\n\n**Update:** *Fixed in [PR#688](https://github.com/OriginProtocol/origin-dollar/pull/688).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/contracts/liquidity/LiquidityReward.sol",
      "content": "pragma solidity 0.5.11;\n\nimport {\n    Initializable\n} from \"@openzeppelin/upgrades/contracts/Initializable.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\n\n//\n// LiquidityReward contract doles out reward for liquidity\n//   base off of Sushiswap's MasterChef: https://github.com/sushiswap/sushiswap/blob/master/contracts/MasterChef.sol\n//\ncontract LiquidityReward is Initializable, Governable {\n    using SafeMath for uint256;\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // Info of each user.\n    struct UserInfo {\n        uint256 amount; // How many LP tokens the user has provided.\n        int256 rewardDebt; // Reward debt. See explanation below.\n        //\n        // We do some fancy math here. Basically, any point in time, the amount of Reward Tokens\n        // entitled to a user but is pending to be distributed is:\n        //\n        //   pending reward = (user.amount * pool.accRewardPerShare) - user.rewardDebt\n        //\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\n        //   1. The pool's `accRewardPerShare` (and `lastRewardBlock`) gets updated.\n        //   2. User receives the pending reward sent to his/her address.\n        //   3. User's `amount` gets updated.\n        //   4. User's `rewardDebt` gets updated.\n        //\n        // NOTE: rewardDebt can go negative because we allow withdraws without claiming the reward\n        //       in that case we owe the account holder some reward.\n    }\n\n    // Info of each pool.\n    struct PoolInfo {\n        IERC20 lpToken; // Address of LP token contract.\n        uint256 lastRewardBlock; // Last block number that Reward calculation occurs.\n        uint256 accRewardPerShare; // Accumulated Reward per share in reward precision. See below.\n    }\n\n    // The Reward token\n    IERC20 public reward;\n\n    // Reward tokens created per block in 1e18 precision.\n    uint256 public rewardPerBlock;\n\n    // Info on the LP.\n    PoolInfo public pool;\n    // total Reward debt, useful to calculate if we have enough to pay out all rewards\n    int256 public totalRewardDebt;\n    // Info of each user that stakes LP tokens.\n    mapping(address => UserInfo) public userInfo;\n    // The block number when Liquidity rewards ends.\n    uint256 public endBlock;\n\n    event CampaignStarted(\n        uint256 rewardRate,\n        uint256 startBlock,\n        uint256 endBlock\n    );\n    event CampaignStopped(uint256 endBlock);\n    event Deposit(address indexed user, uint256 amount);\n    event Withdraw(address indexed user, uint256 amount);\n    event Claim(address indexed user, uint256 amount);\n\n    /**\n     * Initializer for setting up Liquidity Reward internal state.\n     * @param _reward Address of the reward token(OGN)\n     * @param _lpToken Address of the LP token(Uniswap Pair)\n     */\n    function initialize(IERC20 _reward, IERC20 _lpToken)\n        external\n        onlyGovernor\n        initializer\n    {\n        reward = _reward;\n        pool.lpToken = _lpToken;\n        pool.lastRewardBlock = block.number;\n    }\n\n    /**\n     * @dev start a new reward campaign.\n     *      This will calculate all rewards up to the current block at the old rate.\n     *      This ensures that we pay everyone at the promised rate before update to the new rate.\n     * @param _rewardPerBlock Amount rewarded per block\n     * @param _startBlock Block number that we want to start the rewards at (0 for current block)\n     * @param _numBlocks number of blocks that the campaign should last\n     */\n    function startCampaign(\n        uint256 _rewardPerBlock,\n        uint256 _startBlock,\n        uint256 _numBlocks\n    ) external onlyGovernor {\n        // Calculate up to the current block at the current rate for everyone.\n        updatePool();\n\n        // total Pending calculated at the current pool rate\n        uint256 totalPending = subDebt(\n            pool.accRewardPerShare.mulTruncate(\n                pool.lpToken.balanceOf(address(this))\n            ),\n            totalRewardDebt\n        );\n\n        require(\n            reward.balanceOf(address(this)) >=\n                _rewardPerBlock.mul(_numBlocks).add(totalPending),\n            \"startCampaign: insufficient rewards\"\n        );\n\n        uint256 startBlock = _startBlock;\n        if (startBlock == 0) {\n            // start block number isn't given so we start at the current\n            startBlock = block.number;\n        }\n        require(\n            startBlock >= block.number,\n            \"startCampaign: _startBlock can't be in the past\"\n        );\n        endBlock = startBlock.add(_numBlocks);\n        // we don't start accrue until the startBlock\n        pool.lastRewardBlock = startBlock;\n        // new blocks start at the new reward rate\n        rewardPerBlock = _rewardPerBlock;\n        emit CampaignStarted(rewardPerBlock, startBlock, endBlock);\n    }\n\n    function stopCampaign() external onlyGovernor {\n        //calculate until current pool\n        updatePool();\n        //end the block here (the CampaignMultiplier will be zero)\n        endBlock = block.number;\n        emit CampaignStopped(endBlock);\n    }\n\n    function campaignActive() external view returns (bool) {\n        return endBlock > block.number && block.number >= pool.lastRewardBlock;\n    }\n\n    function balanceOf(address _account) external view returns (uint256) {\n        return userInfo[_account].amount;\n    }\n\n    /**\n     * @dev calculate the number of blocks since we last updated\n     *       within start and end as constraints\n     * @param _to Block number of the ending point.\n     * @return multiplier Multiplier over the given _from to _to block.\n     */\n    function getCampaignMultiplier(uint256 _to)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 from = pool.lastRewardBlock;\n        if (from > endBlock) {\n            return 0;\n        } else {\n            return (_to < endBlock ? _to : endBlock).sub(from);\n        }\n    }\n\n    /**\n     * @dev View function to see pending rewards for each account on frontend.\n     * @param _user Address of the account we're looking up.\n     * @return reward Total rewards owed to this account.\n     */\n    function pendingRewards(address _user) external view returns (uint256) {\n        UserInfo storage user = userInfo[_user];\n        return _pendingRewards(user);\n    }\n\n    function _pendingRewards(UserInfo storage user)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 accRewardPerShare = pool.accRewardPerShare;\n        if (block.number > pool.lastRewardBlock) {\n            uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n            if (lpSupply != 0) {\n                uint256 multiplier = getCampaignMultiplier(block.number);\n                uint256 incReward = multiplier.mul(rewardPerBlock);\n                accRewardPerShare = accRewardPerShare.add(\n                    incReward.divPrecisely(lpSupply)\n                );\n            }\n        }\n        return\n            subDebt(\n                user.amount.mulTruncate(accRewardPerShare),\n                user.rewardDebt\n            );\n    }\n\n    /**\n     * @dev View function to see total outstanding rewards for the entire contract.\n     *      This is how much is owed when everyone pulls out.\n     * @return reward Total rewards owed to everyone.\n     */\n    function totalOutstandingRewards() external view returns (uint256) {\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n        if (block.number > pool.lastRewardBlock && lpSupply != 0) {\n            uint256 multiplier = getCampaignMultiplier(block.number);\n            uint256 incReward = multiplier.mul(rewardPerBlock);\n            uint256 accRewardPerShare = pool.accRewardPerShare;\n            accRewardPerShare = accRewardPerShare.add(\n                incReward.divPrecisely(lpSupply)\n            );\n            return\n                subDebt(\n                    accRewardPerShare.mulTruncate(lpSupply),\n                    totalRewardDebt\n                );\n        }\n        // no supply or not even started\n        return 0;\n    }\n\n    /**\n     * @dev External call for updating the pool.\n     */\n    function doUpdatePool() external {\n        // There should be no harm allowing anyone to call this function.\n        // It just updates the latest accRewardPerShare for the pool.\n        updatePool();\n    }\n\n    /**\n     * @dev Update the Liquidity Pool reward multiplier.\n     *      This locks in the accRewardPerShare from the last update block number to now.\n     *      Will fail if we do not have enough to pay everyone.\n     *      Always call updatePool whenever the balance changes!\n     */\n    function updatePool() internal {\n        if (\n            block.number <= pool.lastRewardBlock ||\n            endBlock <= pool.lastRewardBlock\n        ) {\n            return;\n        }\n\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n        if (lpSupply == 0) {\n            pool.lastRewardBlock = block.number;\n            return;\n        }\n\n        uint256 incReward = getCampaignMultiplier(block.number).mul(\n            rewardPerBlock\n        );\n        // we are of course assuming lpTokens are in 1e18 precision\n        uint256 accRewardPerShare = pool.accRewardPerShare.add(\n            incReward.divPrecisely(lpSupply)\n        );\n\n        pool.accRewardPerShare = accRewardPerShare;\n        pool.lastRewardBlock = block.number;\n    }\n\n    /**\n     * @dev Deposit LP tokens into contract, must be preapproved.\n     * @param _amount Amount of LPToken to deposit.\n     */\n    function deposit(uint256 _amount) external {\n        UserInfo storage user = userInfo[msg.sender];\n        updatePool();\n        if (_amount > 0) {\n            user.amount = user.amount.add(_amount);\n            // newDebt is equal to the change in amount * accRewardPerShare (note accRewardPerShare is historic)\n            int256 newDebt = int256(\n                _amount.mulTruncate(pool.accRewardPerShare)\n            );\n            user.rewardDebt += newDebt;\n            totalRewardDebt += newDebt;\n            emit Deposit(msg.sender, _amount);\n            pool.lpToken.safeTransferFrom(\n                address(msg.sender),\n                address(this),\n                _amount\n            );\n        }\n    }\n\n    /**\n     * @dev Exit out of the contract completely, withdraw LP tokens and claim rewards\n     */\n    function exit() external {\n        UserInfo storage user = userInfo[msg.sender];\n        // withdraw everything\n        _withdraw(user, user.amount, true);\n    }\n\n    /**\n     * @dev Withdraw LP tokens from contract.\n     * @param _amount Amount of LPToken to withdraw.\n     * @param _claim Boolean do we want to claim our rewards or not\n     */\n    function withdraw(uint256 _amount, bool _claim) external {\n        UserInfo storage user = userInfo[msg.sender];\n        _withdraw(user, _amount, _claim);\n    }\n\n    function _withdraw(\n        UserInfo storage user,\n        uint256 _amount,\n        bool _claim\n    ) internal {\n        require(user.amount >= _amount, \"withdraw: overflow\");\n        updatePool();\n\n        // newDebt is equal to the change in amount * accRewardPerShare (note accRewardPerShare is historic)\n        int256 newDebt = -int256(_amount.mulTruncate(pool.accRewardPerShare));\n        if (_claim) {\n            //This is an optimization so we don't modify the storage variable twice\n            uint256 pending = subDebt(\n                user.amount.mulTruncate(pool.accRewardPerShare),\n                user.rewardDebt\n            );\n            if (pending > 0) {\n                reward.safeTransfer(msg.sender, pending);\n                emit Claim(msg.sender, pending);\n            }\n            newDebt += int256(pending);\n        }\n\n        // actually make the changes to the amount and debt\n        if (_amount > 0) {\n            user.amount = user.amount.sub(_amount);\n            pool.lpToken.safeTransfer(address(msg.sender), _amount);\n        }\n        user.rewardDebt += newDebt;\n        totalRewardDebt += newDebt;\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    /**\n     * @dev Claim all pending rewards up to current block\n     */\n    function claim() external {\n        UserInfo storage user = userInfo[msg.sender];\n        uint256 pending = _pendingRewards(user);\n        if (pending > 0) {\n            emit Claim(msg.sender, pending);\n            int256 debtDelta = int256(pending);\n            user.rewardDebt += debtDelta;\n            totalRewardDebt += debtDelta;\n            reward.safeTransfer(msg.sender, pending);\n        }\n    }\n\n    function subDebt(uint256 amount, int256 debt)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        if (debt < 0) {\n            result = amount.add(uint256(-debt));\n        } else {\n            result = amount.sub(uint256(debt));\n        }\n    }\n}"
    }
  ]
}