{
  "Title": "M-12: VaultFactoryV2#changeTreasury misconfigures the vault",
  "Content": "# Issue M-12: VaultFactoryV2#changeTreasury misconfigures the vault \n\nSource: https://github.com/sherlock-audit/2023-03-Y2K-judging/issues/435 \n\n## Found by \n0x52, 0xnirlin, Dug, ElKu, TrungOre, ast3ros, holyhansss, ni8mare, roguereddwarf, spyrosonic10, volodya, warRoom\n\n## Summary\n\nVaultFactoryV2#changeTreasury misconfigures the vault because the setTreasury subcall uses the wrong variable \n\n## Vulnerability Detail\n\n[VaultFactoryV2.sol#L228-L246](https://github.com/sherlock-audit/2023-03-Y2K/blob/main/Earthquake/src/v2/VaultFactoryV2.sol#L228-L246)\n\n    function changeTreasury(uint256 _marketId, address _treasury)\n        public\n        onlyTimeLocker\n    {\n        if (_treasury == address(0)) revert AddressZero();\n\n        address[2] memory vaults = marketIdToVaults[_marketId];\n\n        if (vaults[0] == address(0) || vaults[1] == address(0)) {\n            revert MarketDoesNotExist(_marketId);\n        }\n\n        IVaultV2(vaults[0]).whiteListAddress(_treasury);\n        IVaultV2(vaults[1]).whiteListAddress(_treasury);\n        IVaultV2(vaults[0]).setTreasury(treasury);\n        IVaultV2(vaults[1]).setTreasury(treasury);\n\n        emit AddressWhitelisted(_treasury, _marketId);\n    }\n\nWhen setting the treasury for the underlying vault pair it accidentally use the treasury variable instead of _treasury. This means it uses the local VaultFactoryV2 treasury rather than the function input.\n\n[ControllerPeggedAssetV2.sol#L111-L123](https://github.com/sherlock-audit/2023-03-Y2K/blob/main/Earthquake/src/v2/Controllers/ControllerPeggedAssetV2.sol#L111-L123)\n\n        premiumVault.sendTokens(_epochId, premiumFee, treasury);\n        premiumVault.sendTokens(\n            _epochId,\n            premiumTVL - premiumFee,\n            address(collateralVault)\n        );\n        // strike price is reached so collateral is still entitled to premiumTVL - premiumFee but looses collateralTVL\n        collateralVault.sendTokens(_epochId, collateralFee, treasury);\n        collateralVault.sendTokens(\n            _epochId,\n            collateralTVL - collateralFee,\n            address(premiumVault)\n        );\n\nThis misconfiguration can be damaging as it may cause the triggerDepeg call in the controller to fail due to the sendToken subcall. Additionally the time lock is the one required to call it which has a minimum of 3 days wait period. The result is that valid depegs may not get paid out since they are time sensitive.\n\n## Impact\n\nValid depegs may be missed due to misconfiguration\n\n## Code Snippet\n\n[ControllerPeggedAssetV2.sol#L51-L138](https://github.com/sherlock-audit/2023-03-Y2K/blob/main/Earthquake/src/v2/Controllers/ControllerPeggedAssetV2.sol#L51-L138)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nSet to _treasury rather than treasury.\n\n\n\n## Discussion\n\n**3xHarry**\n\ngood catch! \n\n**3xHarry**\n\nfix PR: https://github.com/Y2K-Finance/Earthquake/pull/132\n\n**IAm0x52**\n\nFix looks good. setTreasury now correctly uses `_treasury` rather than `treasury`\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/57",
  "Code": [
    {
      "filename": "Earthquake/src/v2/VaultFactoryV2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {IVaultV2} from \"./interfaces/IVaultV2.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {VaultV2Creator} from \"./libraries/VaultV2Creator.sol\";\n\n/// @author Y2K Finance Team\n\ncontract VaultFactoryV2 is Ownable {\n    address public immutable WETH;\n    bytes internal constant COLLAT = \"COLLATERAL\";\n    bytes internal constant PREMIUM = \"PREMIUM\";\n    bytes internal constant CSYMBOL = \"cY2K\";\n    bytes internal constant PSYMBOL = \"pY2K\";\n    /*//////////////////////////////////////////////////////////////\n                                Storage\n    //////////////////////////////////////////////////////////////*/\n    address public treasury;\n    bool internal adminSetController;\n    address public timelocker;\n\n    mapping(uint256 => address[2]) public marketIdToVaults; //[0] premium and [1] collateral vault\n    mapping(uint256 => uint256[]) public marketIdToEpochs; //all epochs in the market\n    mapping(uint256 => uint16) public epochFee; // epochId to fee\n    mapping(address => address) public tokenToOracle; //token address to respective oracle smart contract address\n    mapping(address => bool) public controllers;\n\n    /*//////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n    /** @notice Contract constructor\n     * @param _weth WETH address\n     * @param _treasury Treasury address\n     * @param _timelocker Timelocker address\n     */\n    constructor(\n        address _weth,\n        address _treasury,\n        address _timelocker\n    ) {\n        if (_weth == address(0)) revert AddressZero();\n        WETH = _weth;\n        timelocker = _timelocker;\n        treasury = _treasury;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n    /**\n    @notice Function to create two new vaults, premium and collateral, with the respective params, and storing the oracle for the token provided\n    @param  _marketCalldata MarketConfigurationCalldata struct with the market params\n    @return premium address of the premium vault\n    @return collateral address of the collateral vault\n    @return marketId uint256 of the marketId\n     */\n    function createNewMarket(MarketConfigurationCalldata memory _marketCalldata)\n        external\n        onlyOwner\n        returns (\n            address premium,\n            address collateral,\n            uint256 marketId\n        )\n    {\n        if (!controllers[_marketCalldata.controller]) revert ControllerNotSet();\n        if (_marketCalldata.token == address(0)) revert AddressZero();\n        if (_marketCalldata.oracle == address(0)) revert AddressZero();\n        if (_marketCalldata.underlyingAsset == address(0)) revert AddressZero();\n\n        if (tokenToOracle[_marketCalldata.token] == address(0)) {\n            tokenToOracle[_marketCalldata.token] = _marketCalldata.oracle;\n        }\n\n        marketId = getMarketId(_marketCalldata.token, _marketCalldata.strike);\n        if (marketIdToVaults[marketId][0] != address(0))\n            revert MarketAlreadyExists();\n\n        //y2kUSDC_99*PREMIUM\n        premium = VaultV2Creator.createVaultV2(\n            VaultV2Creator.MarketConfiguration(\n                _marketCalldata.underlyingAsset == WETH,\n                _marketCalldata.underlyingAsset,\n                string(abi.encodePacked(_marketCalldata.name, PREMIUM)),\n                string(PSYMBOL),\n                _marketCalldata.tokenURI,\n                _marketCalldata.token,\n                _marketCalldata.strike,\n                _marketCalldata.controller,\n                treasury\n            )\n        );\n\n        // y2kUSDC_99*COLLATERAL\n        collateral = VaultV2Creator.createVaultV2(\n            VaultV2Creator.MarketConfiguration(\n                _marketCalldata.underlyingAsset == WETH,\n                _marketCalldata.underlyingAsset,\n                string(abi.encodePacked(_marketCalldata.name, COLLAT)),\n                string(CSYMBOL),\n                _marketCalldata.tokenURI,\n                _marketCalldata.token,\n                _marketCalldata.strike,\n                _marketCalldata.controller,\n                treasury\n            )\n        );\n\n        //set counterparty vault\n        IVaultV2(premium).setCounterPartyVault(collateral);\n        IVaultV2(collateral).setCounterPartyVault(premium);\n\n        marketIdToVaults[marketId] = [premium, collateral];\n\n        emit MarketCreated(\n            marketId,\n            premium,\n            collateral,\n            _marketCalldata.underlyingAsset,\n            _marketCalldata.token,\n            _marketCalldata.name,\n            _marketCalldata.strike,\n            _marketCalldata.controller\n        );\n\n        return (premium, collateral, marketId);\n    }\n\n    /**    \n    @notice Function set epoch for market,\n    @param  _marketId uint256 of the market index to create more assets in\n    @param  _epochBegin uint40 in UNIX timestamp, representing the begin date of the epoch. Example: Epoch begins in 31/May/2022 at 00h 00min 00sec: 1654038000\n    @param  _epochEnd uint40 in UNIX timestamp, representing the end date of the epoch and also the ID for the minting functions. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1656630000\n    @param _withdrawalFee uint16 of the fee value, multiply your % value by 10, Example: if you want fee of 0.5% , insert 5\n     */\n    function createEpoch(\n        uint256 _marketId,\n        uint40 _epochBegin,\n        uint40 _epochEnd,\n        uint16 _withdrawalFee\n    ) public onlyOwner returns (uint256 epochId, address[2] memory vaults) {\n        vaults = marketIdToVaults[_marketId];\n\n        if (vaults[0] == address(0) || vaults[1] == address(0)) {\n            revert MarketDoesNotExist(_marketId);\n        }\n\n        if (_withdrawalFee == 0) revert FeeCannotBe0();\n\n        if (!controllers[IVaultV2(vaults[0]).controller()])\n            revert ControllerNotSet();\n        if (!controllers[IVaultV2(vaults[1]).controller()])\n            revert ControllerNotSet();\n\n        epochId = getEpochId(_marketId, _epochBegin, _epochEnd);\n\n        _setEpoch(\n            EpochConfiguration(\n                _epochBegin,\n                _epochEnd,\n                _withdrawalFee,\n                _marketId,\n                epochId,\n                IVaultV2(vaults[0]),\n                IVaultV2(vaults[1])\n            )\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function _setEpoch(EpochConfiguration memory _epochConfig) internal {\n        _epochConfig.premium.setEpoch(\n            _epochConfig.epochBegin,\n            _epochConfig.epochEnd,\n            _epochConfig.epochId\n        );\n        _epochConfig.collateral.setEpoch(\n            _epochConfig.epochBegin,\n            _epochConfig.epochEnd,\n            _epochConfig.epochId\n        );\n\n        epochFee[_epochConfig.epochId] = _epochConfig.withdrawalFee;\n        marketIdToEpochs[_epochConfig.marketId].push(_epochConfig.epochId);\n\n        emit EpochCreated(\n            _epochConfig.epochId,\n            _epochConfig.marketId,\n            _epochConfig.epochBegin,\n            _epochConfig.epochEnd,\n            address(_epochConfig.premium),\n            address(_epochConfig.collateral),\n            _epochConfig.premium.token(),\n            _epochConfig.premium.strike(),\n            _epochConfig.withdrawalFee\n        );\n    }\n\n    /**\n    @notice Function to whitelist controller smart contract, only owner or timelocker can add more controllers. \n    owner can set controller once, all future controllers must be set by timelocker.\n    @param  _controller Address of the controller smart contract\n     */\n    function whitelistController(address _controller) public {\n        if (_controller == address(0)) revert AddressZero();\n        if (msg.sender == owner() && !adminSetController) {\n            controllers[_controller] = true;\n            adminSetController = true;\n            emit ControllerWhitelisted(_controller);\n        } else if (msg.sender == timelocker) {\n            controllers[_controller] = !controllers[_controller];\n            if (!adminSetController) adminSetController = true;\n            emit ControllerWhitelisted(_controller);\n        } else {\n            revert NotAuthorized();\n        }\n    }\n\n    /**\n    @notice Admin function, whitelists an address on vault for sendTokens function\n    @param _treasury Treasury address\n    @param  _marketId Target market index\n     */\n    function changeTreasury(uint256 _marketId, address _treasury)\n        public\n        onlyTimeLocker\n    {\n        if (_treasury == address(0)) revert AddressZero();\n\n        address[2] memory vaults = marketIdToVaults[_marketId];\n\n        if (vaults[0] == address(0) || vaults[1] == address(0)) {\n            revert MarketDoesNotExist(_marketId);\n        }\n\n        IVaultV2(vaults[0]).whiteListAddress(_treasury);\n        IVaultV2(vaults[1]).whiteListAddress(_treasury);\n        IVaultV2(vaults[0]).setTreasury(treasury);\n        IVaultV2(vaults[1]).setTreasury(treasury);\n\n        emit AddressWhitelisted(_treasury, _marketId);\n    }\n\n    /**\n    @notice Admin function, whitelists an address on vault for sendTokens function\n    @param  _marketId Target market index\n    @param _wAddress Treasury address\n     */\n    function whitelistAddressOnMarket(uint256 _marketId, address _wAddress)\n        public\n        onlyTimeLocker\n    {\n        if (_wAddress == address(0)) revert AddressZero();\n\n        address[2] memory vaults = marketIdToVaults[_marketId];\n\n        if (vaults[0] == address(0) || vaults[1] == address(0)) {\n            revert MarketDoesNotExist(_marketId);\n        }\n\n        IVaultV2(vaults[0]).whiteListAddress(_wAddress);\n        IVaultV2(vaults[1]).whiteListAddress(_wAddress);\n\n        emit AddressWhitelisted(_wAddress, _marketId);\n    }\n\n    /**\n    @notice Admin function, sets treasury address\n    @param _treasury Treasury address\n     */\n    function setTreasury(address _treasury) public onlyTimeLocker {\n        if (_treasury == address(0)) revert AddressZero();\n        treasury = _treasury;\n        emit TreasurySet(_treasury);\n    }\n\n    /**\n    @notice Timelocker function, changes controller address on vaults\n    @param _marketId Target marketId\n    @param  _controller Address of the controller smart contract\n     */\n    function changeController(uint256 _marketId, address _controller)\n        public\n        onlyTimeLocker\n        controllerIsWhitelisted(_controller)\n    {\n        if (_controller == address(0)) revert AddressZero();\n\n        address[2] memory vaults = marketIdToVaults[_marketId];\n\n        if (vaults[0] == address(0) || vaults[1] == address(0)) {\n            revert MarketDoesNotExist(_marketId);\n        }\n\n        IVaultV2(vaults[0]).changeController(_controller);\n        IVaultV2(vaults[1]).changeController(_controller);\n\n        emit ControllerChanged(_marketId, _controller, vaults[0], vaults[1]);\n    }\n\n    /**\n    @notice Timelocker function, changes oracle address for a given token\n    @param _token Target token address\n    @param  _oracle Oracle address\n     */\n    function changeOracle(address _token, address _oracle)\n        public\n        onlyTimeLocker\n    {\n        if (_oracle == address(0)) revert AddressZero();\n        if (_token == address(0)) revert AddressZero();\n\n        tokenToOracle[_token] = _oracle;\n        emit OracleChanged(_token, _oracle);\n    }\n\n    /**\n    @notice Timelocker function, changes owner address\n    @param _owner Address of the new _owner\n     */\n    function changeOwner(address _owner) public onlyTimeLocker {\n        if (_owner == address(0)) revert AddressZero();\n        _transferOwnership(_owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                GETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n    @notice Function the retrieve the addresses of the premium and collateral vaults, in an array, in the respective order\n    @param index uint256 of the market index which to the vaults are associated to\n    @return vaults Address array of two vaults addresses, [0] being the premium vault, [1] being the collateral vault\n     */\n    function getVaults(uint256 index)\n        public\n        view\n        returns (address[2] memory vaults)\n    {\n        return marketIdToVaults[index];\n    }\n\n    /**\n    @notice Function to retrieve the epochId for a given marketId\n    @param marketId marketId\n    @return epochIds uint256 array of epochIds\n     */\n    function getEpochsByMarketId(uint256 marketId)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        return marketIdToEpochs[marketId];\n    }\n\n    /**\n    @notice Function to retrieve the fee for a given epoch\n    @param epochId uint256 of the epoch\n    @return fee uint16 of the fee\n     */\n    function getEpochFee(uint256 epochId) public view returns (uint16 fee) {\n        return epochFee[epochId];\n    }\n\n    /**\n    @notice Function to compute the marketId from a token and a strike price\n    @param token Address of the token\n    @param strikePrice uint256 of the strike price\n    @return marketId uint256 of the marketId\n     */\n    function getMarketId(address token, uint256 strikePrice)\n        public\n        pure\n        returns (uint256 marketId)\n    {\n        return uint256(keccak256(abi.encodePacked(token, strikePrice)));\n    }\n\n    /**\n    @notice Function to compute the epochId from a marketId, epochBegin and epochEnd\n    @param marketId uint256 of the marketId\n    @param epochBegin uint40 of the epoch begin\n    @param epochEnd uint40 of the epoch end\n    @return epochId uint256 of the epochId\n     */\n    function getEpochId(\n        uint256 marketId,\n        uint40 epochBegin,\n        uint40 epochEnd\n    ) public pure returns (uint256 epochId) {\n        return\n            uint256(\n                keccak256(abi.encodePacked(marketId, epochBegin, epochEnd))\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                STRUCTS\n    //////////////////////////////////////////////////////////////*/\n    struct MarketConfigurationCalldata {\n        address token;\n        uint256 strike;\n        address oracle;\n        address underlyingAsset;\n        string name;\n        string tokenURI;\n        address controller;\n    }\n\n    struct EpochConfiguration {\n        uint40 epochBegin;\n        uint40 epochEnd;\n        uint16 withdrawalFee;\n        uint256 marketId;\n        uint256 epochId;\n        IVaultV2 premium;\n        IVaultV2 collateral;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Modifier to check if the caller is the timelocker\n     */\n    modifier onlyTimeLocker() {\n        if (msg.sender != timelocker) revert NotTimeLocker();\n        _;\n    }\n\n    /** @notice Modifier to check if the controller is whitelisted on the factory\n     */\n    modifier controllerIsWhitelisted(address _controller) {\n        if (!controllers[_controller]) revert ControllerNotSet();\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error MarketDoesNotExist(uint256 marketId);\n    error MarketAlreadyExists();\n    error AddressZero();\n    error ControllerNotSet();\n    error NotTimeLocker();\n    error NotAuthorized();\n    error FeeCannotBe0();\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Market is created when event is emitted\n     * @param marketId market id\n     * @param premium premium vault address\n     * @param collateral collateral vault address\n     * @param underlyingAsset underlying asset address\n     * @param token Token address to monitor strike price\n     * @param name Market name\n     * @param strike Strike price\n     * @param controller Controller address\n     */\n    event MarketCreated(\n        uint256 indexed marketId,\n        address premium,\n        address collateral,\n        address underlyingAsset,\n        address token,\n        string name,\n        uint256 strike,\n        address controller\n    );\n\n    /** @notice event is emitted when epoch is created\n     * @param epochId epoch id derrived out of market id, start and end epoch\n     * @param marketId Current market index\n     * @param startEpoch Epoch start time\n     * @param endEpoch Epoch end time\n     * @param premium premium vault address\n     * @param collateral collateral vault address\n     * @param token Token address\n     * @param strike Strike price\n     * @param withdrawalFee Withdrawal fee\n     */\n    event EpochCreated(\n        uint256 indexed epochId,\n        uint256 indexed marketId,\n        uint40 startEpoch,\n        uint40 endEpoch,\n        address premium,\n        address collateral,\n        address token,\n        uint256 strike,\n        uint16 withdrawalFee\n    );\n\n    /** @notice Controller is changed when event is emitted\n     * @param marketId Target market index\n     * @param controller Target controller address\n     * @param premium Target premium vault address\n     * @param collateral Target collateral vault address\n     */\n    event ControllerChanged(\n        uint256 indexed marketId,\n        address indexed controller,\n        address premium,\n        address collateral\n    );\n\n    /** @notice Oracle is changed when event is emitted\n     * @param _token Target token address\n     * @param _oracle Target oracle address\n     */\n    event OracleChanged(address indexed _token, address _oracle);\n\n    /** @notice Address whitelisted is changed when event is emitted\n     * @param _wAddress whitelisted address\n     * @param _marketId Target market index\n     */\n    event AddressWhitelisted(address _wAddress, uint256 indexed _marketId);\n\n    /** @notice Treasury is changed when event is emitted\n     * @param _treasury Treasury address\n     */\n    event TreasurySet(address _treasury);\n\n    /** @notice New Controller is whitelisted when event is emitted\n     * @param _controller Controller address\n     */\n    event ControllerWhitelisted(address _controller);\n}"
    },
    {
      "filename": "Earthquake/src/v2/Controllers/ControllerPeggedAssetV2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {IVaultFactoryV2} from \"../interfaces/IVaultFactoryV2.sol\";\nimport {IVaultV2} from \"../interfaces/IVaultV2.sol\";\nimport \"@chainlink/interfaces/AggregatorV3Interface.sol\";\nimport \"@chainlink/interfaces/AggregatorV2V3Interface.sol\";\nimport {FixedPointMathLib} from \"@solmate/utils/FixedPointMathLib.sol\";\n\n/// @author Y2K Finance Team\n\ncontract ControllerPeggedAssetV2 {\n    using FixedPointMathLib for uint256;\n    IVaultFactoryV2 public immutable vaultFactory;\n    AggregatorV2V3Interface internal sequencerUptimeFeed;\n\n    uint16 private constant GRACE_PERIOD_TIME = 3600;\n    address public immutable treasury;\n\n    /*//////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Contract constructor\n     * @param _factory VaultFactory address\n     * @param _l2Sequencer Arbitrum sequencer address\n     * @param _treasury Treasury address\n     */\n    constructor(\n        address _factory,\n        address _l2Sequencer,\n        address _treasury\n    ) {\n        if (_factory == address(0)) revert ZeroAddress();\n\n        if (_l2Sequencer == address(0)) revert ZeroAddress();\n\n        vaultFactory = IVaultFactoryV2(_factory);\n        sequencerUptimeFeed = AggregatorV2V3Interface(_l2Sequencer);\n        treasury = _treasury;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Trigger depeg event\n     * @param _marketId Target market index\n     * @param _epochId End of epoch set for market\n     */\n    function triggerDepeg(uint256 _marketId, uint256 _epochId) public {\n        address[2] memory vaults = vaultFactory.getVaults(_marketId);\n\n        if (vaults[0] == address(0) || vaults[1] == address(0))\n            revert MarketDoesNotExist(_marketId);\n\n        IVaultV2 premiumVault = IVaultV2(vaults[0]);\n        IVaultV2 collateralVault = IVaultV2(vaults[1]);\n\n        if (premiumVault.epochExists(_epochId) == false) revert EpochNotExist();\n\n        int256 price = getLatestPrice(premiumVault.token());\n\n        if (int256(premiumVault.strike()) <= price)\n            revert PriceNotAtStrikePrice(price);\n\n        (uint40 epochStart, uint40 epochEnd, ) = premiumVault.getEpochConfig(\n            _epochId\n        );\n\n        if (uint256(epochStart) > block.timestamp) revert EpochNotStarted();\n\n        if (block.timestamp > uint256(epochEnd)) revert EpochExpired();\n\n        //require this function cannot be called twice in the same epoch for the same vault\n        if (premiumVault.epochResolved(_epochId)) revert EpochFinishedAlready();\n        if (collateralVault.epochResolved(_epochId))\n            revert EpochFinishedAlready();\n\n        // check if epoch qualifies for null epoch\n        if (\n            premiumVault.totalAssets(_epochId) == 0 ||\n            collateralVault.totalAssets(_epochId) == 0\n        ) {\n            revert VaultZeroTVL();\n        }\n\n        premiumVault.resolveEpoch(_epochId);\n        collateralVault.resolveEpoch(_epochId);\n\n        uint256 epochFee = vaultFactory.getEpochFee(_epochId);\n\n        uint256 premiumTVL = premiumVault.finalTVL(_epochId);\n        uint256 collateralTVL = collateralVault.finalTVL(_epochId);\n\n        uint256 premiumFee = calculateWithdrawalFeeValue(premiumTVL, epochFee);\n        uint256 collateralFee = calculateWithdrawalFeeValue(\n            collateralTVL,\n            epochFee\n        );\n\n        // avoid stack too deep error by avoiding local variables\n        // uint256 premiumTVLAfterFee = premiumTVL - premiumFee;\n        // uint256 collateralTVLAfterFee = collateralTVL - collateralFee;\n\n        premiumVault.setClaimTVL(_epochId, collateralTVL - collateralFee);\n        collateralVault.setClaimTVL(_epochId, premiumTVL - premiumFee);\n\n        // send fees to treasury and remaining TVL to respective counterparty vault\n        // strike price reached so premium is entitled to collateralTVL - collateralFee\n        premiumVault.sendTokens(_epochId, premiumFee, treasury);\n        premiumVault.sendTokens(\n            _epochId,\n            premiumTVL - premiumFee,\n            address(collateralVault)\n        );\n        // strike price is reached so collateral is still entitled to premiumTVL - premiumFee but looses collateralTVL\n        collateralVault.sendTokens(_epochId, collateralFee, treasury);\n        collateralVault.sendTokens(\n            _epochId,\n            collateralTVL - collateralFee,\n            address(premiumVault)\n        );\n\n        emit EpochResolved(\n            _epochId,\n            _marketId,\n            VaultTVL(\n                premiumTVL - premiumFee,\n                collateralTVL,\n                collateralTVL - collateralFee,\n                premiumTVL\n            ),\n            true,\n            block.timestamp,\n            price\n        );\n    }\n\n    /** @notice Trigger epoch end without depeg event\n     * @param _marketId Target market index\n     * @param _epochId End of epoch set for market\n     */\n    function triggerEndEpoch(uint256 _marketId, uint256 _epochId) public {\n        address[2] memory vaults = vaultFactory.getVaults(_marketId);\n\n        if (vaults[0] == address(0) || vaults[1] == address(0))\n            revert MarketDoesNotExist(_marketId);\n\n        IVaultV2 premiumVault = IVaultV2(vaults[0]);\n        IVaultV2 collateralVault = IVaultV2(vaults[1]);\n\n        if (\n            premiumVault.epochExists(_epochId) == false ||\n            collateralVault.epochExists(_epochId) == false\n        ) revert EpochNotExist();\n\n        (, uint40 epochEnd, ) = premiumVault.getEpochConfig(_epochId);\n\n        if (block.timestamp <= uint256(epochEnd)) revert EpochNotExpired();\n\n        //require this function cannot be called twice in the same epoch for the same vault\n        if (premiumVault.epochResolved(_epochId)) revert EpochFinishedAlready();\n        if (collateralVault.epochResolved(_epochId))\n            revert EpochFinishedAlready();\n\n        premiumVault.resolveEpoch(_epochId);\n        collateralVault.resolveEpoch(_epochId);\n\n        uint256 epochFee = vaultFactory.getEpochFee(_epochId);\n\n        uint256 premiumTVL = premiumVault.finalTVL(_epochId);\n        uint256 collateralTVL = collateralVault.finalTVL(_epochId);\n\n        uint256 premiumFee = calculateWithdrawalFeeValue(premiumTVL, epochFee);\n\n        uint256 premiumTVLAfterFee = premiumTVL - premiumFee;\n        uint256 collateralTVLAfterFee = collateralTVL + premiumTVLAfterFee;\n\n        // strike price is not reached so premium is entiled to 0\n        premiumVault.setClaimTVL(_epochId, 0);\n        // strike price is not reached so collateral is entitled to collateralTVL + premiumTVLAfterFee\n        collateralVault.setClaimTVL(_epochId, collateralTVLAfterFee);\n\n        // send premium fees to treasury and remaining TVL to collateral vault\n        premiumVault.sendTokens(_epochId, premiumFee, treasury);\n        // strike price reached so collateral is entitled to collateralTVLAfterFee\n        premiumVault.sendTokens(\n            _epochId,\n            premiumTVLAfterFee,\n            address(collateralVault)\n        );\n\n        emit EpochResolved(\n            _epochId,\n            _marketId,\n            VaultTVL(collateralTVLAfterFee, collateralTVL, 0, premiumTVL),\n            false,\n            block.timestamp,\n            0\n        );\n    }\n\n    /** @notice Trigger epoch invalid when one vault has 0 TVL\n     * @param _marketId Target market index\n     * @param _epochId End of epoch set for market\n     */\n    function triggerNullEpoch(uint256 _marketId, uint256 _epochId) public {\n        address[2] memory vaults = vaultFactory.getVaults(_marketId);\n\n        if (vaults[0] == address(0) || vaults[1] == address(0))\n            revert MarketDoesNotExist(_marketId);\n\n        IVaultV2 premiumVault = IVaultV2(vaults[0]);\n        IVaultV2 collateralVault = IVaultV2(vaults[1]);\n\n        if (\n            premiumVault.epochExists(_epochId) == false ||\n            collateralVault.epochExists(_epochId) == false\n        ) revert EpochNotExist();\n\n        (uint40 epochStart, , ) = premiumVault.getEpochConfig(_epochId);\n\n        if (block.timestamp < uint256(epochStart)) revert EpochNotStarted();\n\n        //require this function cannot be called twice in the same epoch for the same vault\n        if (premiumVault.epochResolved(_epochId)) revert EpochFinishedAlready();\n        if (collateralVault.epochResolved(_epochId))\n            revert EpochFinishedAlready();\n\n        //set claim TVL to final TVL if total assets are 0\n        if (premiumVault.totalAssets(_epochId) == 0) {\n            premiumVault.resolveEpoch(_epochId);\n            collateralVault.resolveEpoch(_epochId);\n\n            premiumVault.setClaimTVL(_epochId, 0);\n            collateralVault.setClaimTVL(\n                _epochId,\n                collateralVault.finalTVL(_epochId)\n            );\n\n            collateralVault.setEpochNull(_epochId);\n        } else if (collateralVault.totalAssets(_epochId) == 0) {\n            premiumVault.resolveEpoch(_epochId);\n            collateralVault.resolveEpoch(_epochId);\n\n            premiumVault.setClaimTVL(_epochId, premiumVault.finalTVL(_epochId));\n            collateralVault.setClaimTVL(_epochId, 0);\n\n            premiumVault.setEpochNull(_epochId);\n        } else revert VaultNotZeroTVL();\n\n        emit NullEpoch(\n            _epochId,\n            _marketId,\n            VaultTVL(\n                collateralVault.claimTVL(_epochId),\n                collateralVault.finalTVL(_epochId),\n                premiumVault.claimTVL(_epochId),\n                premiumVault.finalTVL(_epochId)\n            ),\n            block.timestamp\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                GETTERS\n    //////////////////////////////////////////////////////////////*/\n    /** @notice Lookup token price\n     * @param _token Target token address\n     * @return nowPrice Current token price\n     */\n    function getLatestPrice(address _token) public view returns (int256) {\n        (\n            ,\n            /*uint80 roundId*/\n            int256 answer,\n            uint256 startedAt, /*uint256 updatedAt*/ /*uint80 answeredInRound*/\n            ,\n\n        ) = sequencerUptimeFeed.latestRoundData();\n\n        // Answer == 0: Sequencer is up\n        // Answer == 1: Sequencer is down\n        bool isSequencerUp = answer == 0;\n        if (!isSequencerUp) {\n            revert SequencerDown();\n        }\n\n        // Make sure the grace period has passed after the sequencer is back up.\n        uint256 timeSinceUp = block.timestamp - startedAt;\n        if (timeSinceUp <= GRACE_PERIOD_TIME) {\n            revert GracePeriodNotOver();\n        }\n\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(\n            vaultFactory.tokenToOracle(_token)\n        );\n        (uint80 roundID, int256 price, , , uint80 answeredInRound) = priceFeed\n            .latestRoundData();\n        uint256 decimals = priceFeed.decimals();\n\n        if (decimals < 18) {\n            decimals = 10**(18 - (decimals));\n            price = price * int256(decimals);\n        } else if (decimals == 18) {\n            price = price;\n        } else {\n            decimals = 10**((decimals - 18));\n            price = price / int256(decimals);\n        }\n\n        if (price <= 0) revert OraclePriceZero();\n\n        if (answeredInRound < roundID) revert RoundIDOutdated();\n\n        return price;\n    }\n\n    /** @notice Lookup target VaultFactory address\n     * @dev need to find way to express typecasts in NatSpec\n     */\n    function getVaultFactory() external view returns (address) {\n        return address(vaultFactory);\n    }\n\n    /** @notice Calculate amount to withdraw after subtracting protocol fee\n     * @param amount Amount of tokens to withdraw\n     * @param fee Fee to be applied\n     */\n    function calculateWithdrawalFeeValue(uint256 amount, uint256 fee)\n        public\n        pure\n        returns (uint256 feeValue)\n    {\n        // 0.5% = multiply by 10000 then divide by 50\n        return amount.mulDivDown(fee, 10000);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error MarketDoesNotExist(uint256 marketId);\n    error SequencerDown();\n    error GracePeriodNotOver();\n    error ZeroAddress();\n    error EpochFinishedAlready();\n    error PriceNotAtStrikePrice(int256 price);\n    error EpochNotStarted();\n    error EpochExpired();\n    error OraclePriceZero();\n    error RoundIDOutdated();\n    error EpochNotExist();\n    error EpochNotExpired();\n    error VaultNotZeroTVL();\n    error VaultZeroTVL();\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Resolves epoch when event is emitted\n     * @param epochId market epoch ID\n     * @param marketId market ID\n     * @param tvl TVL\n     * @param strikeMet Flag if event isDisaster\n     * @param time time\n     * @param depegPrice Price that triggered depeg\n     */\n    event EpochResolved(\n        uint256 indexed epochId,\n        uint256 indexed marketId,\n        VaultTVL tvl,\n        bool strikeMet,\n        uint256 time,\n        int256 depegPrice\n    );\n\n    /** @notice Sets epoch to null when event is emitted\n     * @param epochId market epoch ID\n     * @param marketId market ID\n     * @param tvl TVL\n     * @param time timestamp\n     */\n    event NullEpoch(\n        uint256 indexed epochId,\n        uint256 indexed marketId,\n        VaultTVL tvl,\n        uint256 time\n    );\n\n    struct VaultTVL {\n        uint256 COLLAT_cla"
    }
  ]
}