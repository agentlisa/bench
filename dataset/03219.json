{
  "Title": "Unnecessary and unrestricted `trade()` at `sync/BancorSwapper`",
  "Content": "##### Description\n[trade()](https://github.com/yearn/hardhat-monorepo/blob/ecc0b5147992b34c315e08af170ceb4a5fe071ee/packages/yswaps/contracts/swappers/sync/BancorSwapper.sol#L52) function has no use and most likely remains in contract by an accident. However, it is unrestricted and can be called by anyone. \n##### Recommendation\nAlthough we have not found any attack vector for this issue, we recommend to remove this code to improve security.\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "packages/yswaps/contracts/swappers/sync/BancorSwapper.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport './SyncSwapper.sol';\n\ninterface IContractRegistry {\n  function addressOf(bytes32 contractName) external returns (address);\n}\n\ninterface IBancorNetwork {\n  function convertByPath(\n    address[] memory _path,\n    uint256 _amount,\n    uint256 _minReturn,\n    address _beneficiary,\n    address _affiliateAccount,\n    uint256 _affiliateFee\n  ) external payable returns (uint256);\n\n  function rateByPath(address[] memory _path, uint256 _amount) external view returns (uint256);\n\n  function conversionPath(address _sourceToken, address _targetToken) external view returns (address[] memory);\n\n  function convert(\n    address[] memory path,\n    uint256 amount,\n    uint256 minReturn\n  ) external payable returns (uint256 returnAmount);\n}\n\ninterface IBancorSwapper is ISyncSwapper {}\n\ncontract BancorSwapper is IBancorSwapper, SyncSwapper {\n  using SafeERC20 for IERC20;\n\n  IContractRegistry public contractRegistry;\n  bytes32 public bancorNetworkName;\n\n  constructor(\n    address _governor,\n    address _tradeFactory,\n    IContractRegistry _contractRegistry,\n    bytes32 _bancorNetworkName\n  ) SyncSwapper(_governor, _tradeFactory) {\n    contractRegistry = _contractRegistry;\n    bancorNetworkName = _bancorNetworkName;\n  }\n\n  // path and minReturn generated on chain\n  function trade(\n    address _sourceToken,\n    address _targetToken,\n    uint256 _amount\n  ) external payable returns (uint256 returnAmount) {\n    IBancorNetwork bancorNetwork = IBancorNetwork(contractRegistry.addressOf(bancorNetworkName));\n    address[] memory path = bancorNetwork.conversionPath(_sourceToken, _targetToken);\n    uint256 minReturn = bancorNetwork.rateByPath(path, _amount);\n    returnAmount = bancorNetwork.convertByPath{value: msg.value}(path, _amount, minReturn, address(0x0), address(0x0), 0);\n  }\n\n  function _executeSwap(\n    address _receiver,\n    address _tokenIn,\n    address _tokenOut,\n    uint256 _amountIn,\n    uint256 _maxSlippage,\n    bytes calldata\n  ) internal override {\n    IBancorNetwork _bancorNetwork = IBancorNetwork(contractRegistry.addressOf(bancorNetworkName));\n    address[] memory _path = _bancorNetwork.conversionPath(_tokenIn, _tokenOut);\n    uint256 _minReturn = _bancorNetwork.rateByPath(_path, _amountIn);\n    _minReturn = _minReturn - ((_minReturn * _maxSlippage) / SLIPPAGE_PRECISION / 100); // slippage calcs\n    IERC20(_tokenIn).approve(address(_bancorNetwork), 0);\n    IERC20(_tokenIn).approve(address(_bancorNetwork), _amountIn);\n    IERC20(_tokenOut).safeTransfer(_receiver, _bancorNetwork.convert(_path, _amountIn, _minReturn));\n  }\n}"
    }
  ]
}