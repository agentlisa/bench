{
  "Title": "Incorrect calculation of unmigrated BDVs for use in `InitBipSeedGauge::init`",
  "Content": "**Description:** The current values for the [constants](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/beanstalk/init/InitBipSeedGauge.sol#L35-L39) in `InitBipSeedGauge::init` are an estimation and not finalized. To correctly calculate the BDV, the Beanstalk Farms team simulates migrating all the remaining unmigrated deposits at the block in which BIP-38 was executed such that the change of BDV corresponding to the underlying asset in `BDVFacet::unripeLPToBDV` is considered and subject to the slippage incurred at the time of liquidity migration. The `deposits.json` file contains a list of outstanding deposits at the Silo V3 deployment block `17671557`, so the script considers all `removeDeposit` events after this point as deposits to be removed from the unmigrated BDV. By filtering from the Enroot fix deployment block `17251905`, if an account has removed its deposit after the Enroot fix but before Silo V3 was deployed, this would improperly assume the deposits have been migrated when they haven't. Additionally, given the script is forking mainnet at the BIP-38 execution block `18392690`, it is not correct to use `18480579` as the end block for event filtering.\n\nThe case has also been considered that, given the state changes will already have been applied, and assuming the migration transaction isn't top/bottom of block, it might be desirable to fork/filter up to the block before BIP-38 execution and check whether any migrations occurred before/after the migration transaction that need to be considered manually. After further inspection of the block in which the BIP-38 upgrade took place, it appears this is not necessary as no events were emitted.\n\nAn additional discrepancy in the unmigrated Bean BDV value was identified by the Beanstalk Farms team. After Silo V3, the implementation of `Sun::rewardToSilo` [increments the BDV](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/beanstalk/sun/SeasonFacet/Sun.sol#L201-L204) by the amount of Bean issued to the Silo, but all previously earned Beans are not considered. Therefore, the value returned by `SiloExit::totalEarnedBeans` at the time of Silo V3 deployment should be added to the total.\n\n**Impact:** The calculated unmigrated BDVs are incorrect, as shown below. The current implementation returns values that are smaller than they should be, meaning the total deposited BDV will fail to consider some deposits and be lower than intended.\n\nOutput of the current implementation:\n```\nunmigrated:  {\n  '0x1BEA0050E63e05FBb5D8BA2f10cf5800B6224449': BigNumber { value: \"3209210313166\" },\n  '0x1BEA3CcD22F4EBd3d37d731BA31Eeca95713716D': BigNumber { value: \"6680992571569\" },\n  '0xBEA0000029AD1c77D3d5D23Ba2D8893dB9d1Efab': BigNumber { value: \"304630107407\" },\n  '0xc9C32cd16Bf7eFB85Ff14e0c8603cc90F6F2eE49': BigNumber { value: \"26212521946\" }\n}\n```\n\nCorrected output:\n```\nunmigrated:  {\n  '0x1BEA0050E63e05FBb5D8BA2f10cf5800B6224449': BigNumber { value: \"3736196158417\" },\n  '0x1BEA3CcD22F4EBd3d37d731BA31Eeca95713716D': BigNumber { value: \"7119564766493\" },\n  '0xBEA0000029AD1c77D3d5D23Ba2D8893dB9d1Efab': BigNumber { value: \"689428296238\" },\n  '0xc9C32cd16Bf7eFB85Ff14e0c8603cc90F6F2eE49': BigNumber { value: \"26512602424\" }\n}\n```\n\n**Recommended Mitigation:** Apply the following diff:\n```diff\n// L645\n- const END_BLOCK = 18480579;\n+ const END_BLOCK = BLOCK_NUMBER;\n\n// L811-812\n- //get every transaction that emitted the RemoveDeposit event after block 17251905\n+ //get every transaction that emitted the RemoveDeposit event after block 17671557\n- let events = await queryEvents(\"RemoveDeposit(address,address,uint32,uint256)\", removeDepositInterface, 17251905); //update this block to latest block when running actual script, in theory someone could have migrated meanwhile\n+ let events = await queryEvents(\"RemoveDeposit(address,address,uint32,uint256)\", removeDepositInterface, 17671557);\n```\nRetrieve the amount of Beans previously issued to the Silo:\n```bash\ncast call 0xC1E088fC1323b20BCBee9bd1B9fC9546db5624C5 \"totalEarnedBeans()\" --rpc-url ${FORKING_RPC} --block \"17671557\"\n```\n\n\\clearpage",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/beanstalk/init/InitBipSeedGauge.sol",
      "content": "/*\n SPDX-License-Identifier: MIT\n*/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\nimport {AppStorage, Storage} from \"contracts/beanstalk/AppStorage.sol\";\nimport {C} from \"../../C.sol\";\nimport {LibWhitelistedTokens} from \"contracts/libraries/Silo/LibWhitelistedTokens.sol\";\nimport {LibTokenSilo} from \"contracts/libraries/Silo/LibTokenSilo.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {LibCases} from \"contracts/libraries/LibCases.sol\";\nimport {LibWhitelist} from \"contracts/libraries/Silo/LibWhitelist.sol\";\nimport {LibGauge} from \"contracts/libraries/LibGauge.sol\";\nimport {Weather} from \"contracts/beanstalk/sun/SeasonFacet/Weather.sol\";\n\n/**\n * @author Brean\n * @title InitBipSeedGauge initalizes the seed gauge, updates siloSetting Struct\n **/\ninterface IGaugePointFacet {\n    function defaultGaugePointFunction(\n        uint256 currentGaugePoints,\n        uint256 optimalPercentDepositedBdv,\n        uint256 percentOfDepositedBdv\n    ) external pure returns (uint256 newGaugePoints);\n}\n\ncontract InitBipSeedGauge is Weather {\n    using SafeMath for uint256;\n\n    uint256 private constant TARGET_SEASONS_TO_CATCHUP = 4320;\n    uint256 private constant PRECISION = 1e6;\n\n    // TODO : update these values, once the beanEthMigration BIP has executed.\n    uint256 internal constant BEAN_UNMIGRATED_BDV = 816_105_148629; // 816k BDV\n    uint256 internal constant BEAN_3CRV_UNMIGRATED_BDV = 53_419_468565; // 53k BDV\n    uint256 internal constant UNRIPE_BEAN_UNMIGRATED_BDV = 4_946_644_852785; // 4.9m BDV\n    uint256 internal constant UNRIPE_LP_UNMIGRATED_BDV = 7_774_709_273192; // 7.7m BDV\n\n    // assumption is that unripe assets has been migrated to the bean-eth Wells.\n    function init() external {\n        // update depositedBDV for bean, bean3crv, urBean, and urBeanETH:\n        LibTokenSilo.incrementTotalDepositedBdv(\n            C.BEAN,\n            BEAN_UNMIGRATED_BDV - s.migratedBdvs[C.BEAN]\n        );\n        LibTokenSilo.incrementTotalDepositedBdv(\n            C.CURVE_BEAN_METAPOOL,\n            BEAN_3CRV_UNMIGRATED_BDV - s.migratedBdvs[C.CURVE_BEAN_METAPOOL]\n        );\n        LibTokenSilo.incrementTotalDepositedBdv(\n            C.UNRIPE_BEAN,\n            UNRIPE_BEAN_UNMIGRATED_BDV - s.migratedBdvs[C.UNRIPE_BEAN]\n        );\n        LibTokenSilo.incrementTotalDepositedBdv(\n            C.UNRIPE_LP,\n            UNRIPE_LP_UNMIGRATED_BDV - s.migratedBdvs[C.UNRIPE_LP]\n        );\n\n        uint128 totalBdv;\n        // only lp assets need to be updated.\n        // unripeAssets are not in the seed gauge,\n        // and bean does not have a gauge point function.\n        // (it is based on the max gauge points of LP)\n        // order: bean, beanETH, bean3CRV, urBEAN, urBEANETH\n        address[] memory siloTokens = LibWhitelistedTokens.getWhitelistedTokens();\n        uint128 beanEthGp = uint128(s.ss[C.BEAN_ETH_WELL].stalkEarnedPerSeason) * 500 * 1e12;\n        uint128 bean3crvGp = uint128(s.ss[C.CURVE_BEAN_METAPOOL].stalkEarnedPerSeason) * 500 * 1e12;\n        uint128[5] memory gaugePoints = [uint128(0), beanEthGp, bean3crvGp, 0, 0];\n        bytes4[5] memory gpSelectors = [\n            bytes4(0x00000000),\n            IGaugePointFacet.defaultGaugePointFunction.selector,\n            IGaugePointFacet.defaultGaugePointFunction.selector,\n            0x00000000,\n            0x00000000\n        ];\n        uint96[5] memory optimalPercentDepositedBdv = [uint96(0), 99e6, 1e6, 0, 0];\n        for (uint i = 0; i < siloTokens.length; i++) {\n            // update gaugePoints and gpSelectors\n            s.ss[siloTokens[i]].gaugePoints = gaugePoints[i];\n            s.ss[siloTokens[i]].gpSelector = gpSelectors[i];\n            s.ss[siloTokens[i]].optimalPercentDepositedBdv = optimalPercentDepositedBdv[i];\n\n            // get depositedBDV to use later:\n            totalBdv += s.siloBalances[siloTokens[i]].depositedBdv;\n            \n            // emit event\n            emit LibWhitelist.updateGaugeSettings(siloTokens[i], gpSelectors[i], optimalPercentDepositedBdv[i]);\n        }\n        // initalize seed gauge and emit events.\n        s.seedGauge.beanToMaxLpGpPerBdvRatio = 33_333_333_333_333_333_333; // 33% (50% + 50%* (1/3) = 66%)\n        s.seedGauge.averageGrownStalkPerBdvPerSeason = initializeAverageGrownStalkPerBdv(totalBdv);\n\n        emit BeanToMaxLpGpPerBdvRatioChange(s.season.current, type(uint256).max, int80(s.seedGauge.beanToMaxLpGpPerBdvRatio));\n        emit LibGauge.UpdateStalkPerBdvPerSeason(s.seedGauge.averageGrownStalkPerBdvPerSeason);\n\n        // initalize s.usdTokenPrice for the bean eth well.\n        s.usdTokenPrice[C.BEAN_ETH_WELL] = 1;\n\n        // set s.twaReserves for the bean eth well, and the bean:3crv pool.\n        s.twaReserves[C.BEAN_ETH_WELL].reserve0 = 1;\n        s.twaReserves[C.BEAN_ETH_WELL].reserve1 = 1;\n\n        // Even though it is not used, still initialize.\n        s.usdTokenPrice[C.CURVE_BEAN_METAPOOL] = 1;\n        s.twaReserves[C.CURVE_BEAN_METAPOOL].reserve0 = 1;\n        s.twaReserves[C.CURVE_BEAN_METAPOOL].reserve1 = 1;\n\n        // initalize V2 cases.\n        LibCases.setCasesV2();\n    }\n\n    function initializeAverageGrownStalkPerBdv(uint256 totalBdv) internal view returns (uint128) {\n        uint256 averageGrownStalkPerBdv = s.s.stalk.div(totalBdv).sub(10000);\n        return uint128(averageGrownStalkPerBdv.mul(PRECISION).div(TARGET_SEASONS_TO_CATCHUP));\n    }\n}"
    },
    {
      "filename": "protocol/contracts/beanstalk/sun/SeasonFacet/Sun.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {SafeCast} from \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport {LibFertilizer, SafeMath} from \"contracts/libraries/LibFertilizer.sol\";\nimport {LibSafeMath128} from \"contracts/libraries/LibSafeMath128.sol\";\nimport {Oracle, C} from \"./Oracle.sol\";\n\n/**\n * @title Sun\n * @author Publius\n * @notice Sun controls the minting of new Beans to Fertilizer, the Field, and the Silo.\n */\ncontract Sun is Oracle {\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n    using LibSafeMath128 for uint128;\n\n    /// @dev When Fertilizer is Active, it receives 1/3 of new Bean mints.\n    uint256 private constant FERTILIZER_DENOMINATOR = 3;\n\n    /// @dev After Fertilizer, Harvestable Pods receive 1/2 of new Bean mints. \n    uint256 private constant HARVEST_DENOMINATOR = 2;\n\n    /// @dev When the Pod Rate is high, issue less Soil.\n    uint256 private constant SOIL_COEFFICIENT_HIGH = 0.5e18;\n    \n    /// @dev When the Pod Rate is low, issue more Soil.\n    uint256 private constant SOIL_COEFFICIENT_LOW = 1.5e18;\n\n    /**\n     * @notice Emitted during Sunrise when Beans are distributed to the Field, the Silo, and Fertilizer.\n     * @param season The Season in which Beans were distributed.\n     * @param toField The number of Beans distributed to the Field.\n     * @param toSilo The number of Beans distributed to the Silo.\n     * @param toFertilizer The number of Beans distributed to Fertilizer.\n     */\n    event Reward(\n        uint32 indexed season,\n        uint256 toField,\n        uint256 toSilo,\n        uint256 toFertilizer\n    );\n\n    /**\n     * @notice Emitted during Sunrise when Beanstalk adjusts the amount of available Soil.\n     * @param season The Season in which Soil was adjusted.\n     * @param soil The new amount of Soil available.\n     */\n    event Soil(\n        uint32 indexed season,\n        uint256 soil\n    );\n\n    //////////////////// SUN INTERNAL ////////////////////\n    \n    /**\n     * @param deltaB Pre-calculated deltaB from {Oracle.stepOracle}.\n     * @param caseId Pre-calculated Weather case from {Weather.calcCaseId}.\n     */\n    function stepSun(int256 deltaB, uint256 caseId) internal {\n        // Above peg\n        if (deltaB > 0) {\n            uint256 newHarvestable = rewardBeans(uint256(deltaB));\n            setSoilAbovePeg(newHarvestable, caseId);\n            s.season.abovePeg = true;\n        } \n\n        // Below peg\n        else {\n            setSoil(uint256(-deltaB));\n            s.season.abovePeg = false;\n        }\n    }\n\n    //////////////////// REWARD BEANS ////////////////////\n\n    /**\n     * @dev Mints and distributes Beans to Fertilizer, the Field, and the Silo.\n     */\n    function rewardBeans(uint256 newSupply) internal returns (uint256 newHarvestable) {\n        uint256 newFertilized;\n        \n        C.bean().mint(address(this), newSupply);\n\n        // Distribute first to Fertilizer if some Fertilizer are active\n        if (s.season.fertilizing) {\n            newFertilized = rewardToFertilizer(newSupply);\n            newSupply = newSupply.sub(newFertilized);\n        }\n\n        // Distribute next to the Field if some Pods are still outstanding\n        if (s.f.harvestable < s.f.pods) {\n            newHarvestable = rewardToHarvestable(newSupply);\n            newSupply = newSupply.sub(newHarvestable);\n        }\n\n        // Distribute remainder to the Silo\n        rewardToSilo(newSupply);\n\n        emit Reward(s.season.current, newHarvestable, newSupply, newFertilized);\n    }\n\n    /**\n     * @dev Distributes Beans to Fertilizer.\n     */\n    function rewardToFertilizer(uint256 amount)\n        internal\n        returns (uint256 newFertilized)\n    {\n        // 1/3 of new Beans being minted\n        uint256 maxNewFertilized = amount.div(FERTILIZER_DENOMINATOR);\n\n        // Get the new Beans per Fertilizer and the total new Beans per Fertilizer\n        uint256 newBpf = maxNewFertilized.div(s.activeFertilizer);\n        uint256 oldTotalBpf = s.bpf;\n        uint256 newTotalBpf = oldTotalBpf.add(newBpf);\n\n        // Get the end Beans per Fertilizer of the first Fertilizer to run out.\n        uint256 firstEndBpf = s.fFirst;\n\n        // If the next fertilizer is going to run out, then step BPF according\n        while(newTotalBpf >= firstEndBpf) {\n            // Calculate BPF and new Fertilized when the next Fertilizer ID ends\n            newBpf = firstEndBpf.sub(oldTotalBpf);\n            newFertilized = newFertilized.add(newBpf.mul(s.activeFertilizer));\n\n            // If there is no more fertilizer, end\n            if (!LibFertilizer.pop()) {\n                s.bpf = uint128(firstEndBpf); // SafeCast unnecessary here.\n                s.fertilizedIndex = s.fertilizedIndex.add(newFertilized);\n                require(s.fertilizedIndex == s.unfertilizedIndex, \"Paid != owed\");\n                return newFertilized;\n            }\n\n            // Calculate new Beans per Fertilizer values\n            newBpf = maxNewFertilized.sub(newFertilized).div(s.activeFertilizer);\n            oldTotalBpf = firstEndBpf;\n            newTotalBpf = oldTotalBpf.add(newBpf);\n            firstEndBpf = s.fFirst;\n        }\n\n        // Distribute the rest of the Fertilized Beans\n        s.bpf = uint128(newTotalBpf); // SafeCast unnecessary here.\n        newFertilized = newFertilized.add(newBpf.mul(s.activeFertilizer));\n        s.fertilizedIndex = s.fertilizedIndex.add(newFertilized);\n    }\n\n    /**\n     * @dev Distributes Beans to the Field. The next `amount` Pods in the Pod Line\n     * become Harvestable.\n     */\n    function rewardToHarvestable(uint256 amount)\n        internal    \n        returns (uint256 newHarvestable)\n    {\n        uint256 notHarvestable = s.f.pods - s.f.harvestable; // Note: SafeMath is redundant here.\n        newHarvestable = amount.div(HARVEST_DENOMINATOR);\n        newHarvestable = newHarvestable > notHarvestable\n            ? notHarvestable\n            : newHarvestable;\n        s.f.harvestable = s.f.harvestable.add(newHarvestable);\n    }\n\n    /**\n     * @dev Distribute Beans to the Silo. Stalk & Earned Beans are created here;\n     * Farmers can claim them through {SiloFacet.plant}.\n     */\n    function rewardToSilo(uint256 amount) internal {\n        // NOTE that the Beans have already been minted (see {rewardBeans}).\n        //\n        // `s.earnedBeans` is an accounting mechanism that tracks the total number\n        // of Earned Beans that are claimable by Stalkholders. When claimed via `plant()`,\n        // it is decremented. See {Silo.sol:_plant} for more details.\n        // SafeCast not necessary as `seasonStalk.toUint128();` will fail if amount > type(uint128).max.\n        s.earnedBeans = s.earnedBeans.add(uint128(amount));\n\n        // Mint Stalk (as Earned Stalk). Farmers can claim their Earned Stalk via {SiloFacet.sol:plant}.\n        //\n        // Stalk is created here, rather than in {rewardBeans}, because only\n        // Beans that are allocated to the Silo will receive Stalk.\n        // Constant is used here rather than s.ss[BEAN].stalkIssuedPerBdv\n        // for gas savings.\n        uint256 seasonStalk = amount.mul(C.STALK_PER_BEAN);\n        s.s.stalk = s.s.stalk.add(seasonStalk);\n        // `s.newEarnedStalk` is an accounting mechanism that tracks the  number\n        // of Earned stalk that is allocated during the season. \n        // This is used in _balanceOfEarnedBeans() to linearly distrubute \n        // beans over the course of the season.\n        s.newEarnedStalk = seasonStalk.toUint128();\n        s.vestingPeriodRoots = 0;\n\n        // SafeCast not necessary as `seasonStalk.toUint128();` will fail if amount > type(uint128).max.\n        s.siloBalances[C.BEAN].deposited = s\n            .siloBalances[C.BEAN]\n            .deposited\n            .add(uint128(amount));\n\n        s.siloBalances[C.BEAN].depositedBdv = s\n            .siloBalances[C.BEAN]\n            .depositedBdv\n            .add(uint128(amount));\n    }\n\n    //////////////////// SET SOIL ////////////////////\n\n    /**\n     * @param newHarvestable The number of Beans that were minted to the Field.\n     * @param caseId The current Weather Case.\n     * @dev When above peg, Beanstalk wants to gauge demand for Soil. Here it\n     * issues the amount of Soil that would result in the same number of Pods\n     * as became Harvestable during the last Season.\n     * \n     * When the Pod Rate is high, Beanstalk issues less Soil.\n     * When the Pod Rate is low, Beanstalk issues more Soil.\n     */\n    function setSoilAbovePeg(uint256 newHarvestable, uint256 caseId) internal {\n        uint256 newSoil = newHarvestable.mul(100).div(100 + s.w.t);\n        if (caseId >= 24) {\n            newSoil = newSoil.mul(SOIL_COEFFICIENT_HIGH).div(C.PRECISION); // high podrate\n        } else if (caseId < 8) {\n            newSoil = newSoil.mul(SOIL_COEFFICIENT_LOW).div(C.PRECISION); // low podrate\n        }\n        setSoil(newSoil);\n    }\n\n    \n    function setSoil(uint256 amount) internal {\n        s.f.soil = amount.toUint128();\n        emit Soil(s.season.current, amount.toUint128());\n    }\n}"
    }
  ]
}