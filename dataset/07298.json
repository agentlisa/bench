{
  "Title": "[G-06] `keccak256()` should only need to be called on a specific string literal once",
  "Content": "\nIt should be saved to an immutable variable, and the variable used instead. If the hash is being used as a part of a function selector, the cast to `bytes4` should also only be done once.\n\nhttps://github.com/AstariaXYZ/astaria-gpl/blob/4b49fe993d9b807fe68b3421ee7f2fe91267c9ef/src/ERC20-Cloned.sol#L162-L165\n```solidity\nFile: /src/ERC20-Cloned.sol\n162:    keccak256(\n163:    \"EIP712Domain(string version,uint256 chainId,address verifyingContract)\"\n164:    ),\n165:    keccak256(\"1\"),\n```\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L310\n```solidity\nFile: /src/CollateralToken.sol\n310:      ) != keccak256(\"FlashAction.onFlashAction\")\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-01-astaria",
  "Code": [
    {
      "filename": "src/CollateralToken.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**\n *  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗\n * ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n * ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n * ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n * ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n * ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n *\n * Astaria Labs, Inc\n */\n\npragma solidity =0.8.17;\n\npragma experimental ABIEncoderV2;\n\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {ICollateralToken} from \"core/interfaces/ICollateralToken.sol\";\nimport {IERC165} from \"core/interfaces/IERC165.sol\";\nimport {IERC721} from \"core/interfaces/IERC721.sol\";\nimport {IERC721Receiver} from \"core/interfaces/IERC721Receiver.sol\";\nimport {IFlashAction} from \"core/interfaces/IFlashAction.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\nimport {ISecurityHook} from \"core/interfaces/ISecurityHook.sol\";\nimport {ITransferProxy} from \"core/interfaces/ITransferProxy.sol\";\nimport {Authority} from \"solmate/auth/Auth.sol\";\nimport {CollateralLookup} from \"core/libraries/CollateralLookup.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC721} from \"gpl/ERC721.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {VaultImplementation} from \"core/VaultImplementation.sol\";\nimport {ZoneInterface} from \"seaport/interfaces/ZoneInterface.sol\";\nimport {Bytes32AddressLib} from \"solmate/utils/Bytes32AddressLib.sol\";\nimport {\n  ClonesWithImmutableArgs\n} from \"clones-with-immutable-args/ClonesWithImmutableArgs.sol\";\n\nimport {\n  ConduitControllerInterface\n} from \"seaport/interfaces/ConduitControllerInterface.sol\";\nimport {\n  ConsiderationInterface\n} from \"seaport/interfaces/ConsiderationInterface.sol\";\nimport {\n  AdvancedOrder,\n  CriteriaResolver,\n  OfferItem,\n  ConsiderationItem,\n  ItemType,\n  OrderParameters,\n  OrderComponents,\n  OrderType,\n  Order\n} from \"seaport/lib/ConsiderationStructs.sol\";\n\nimport {Consideration} from \"seaport/lib/Consideration.sol\";\nimport {SeaportInterface} from \"seaport/interfaces/SeaportInterface.sol\";\nimport {ClearingHouse} from \"core/ClearingHouse.sol\";\nimport {AuthInitializable} from \"core/AuthInitializable.sol\";\n\ncontract CollateralToken is\n  AuthInitializable,\n  ERC721,\n  IERC721Receiver,\n  ICollateralToken,\n  ZoneInterface\n{\n  using SafeTransferLib for ERC20;\n  using CollateralLookup for address;\n  using FixedPointMathLib for uint256;\n  uint256 private constant COLLATERAL_TOKEN_SLOT =\n    uint256(keccak256(\"xyz.astaria.CollateralToken.storage.location\")) - 1;\n\n  constructor() {\n    _disableInitializers();\n  }\n\n  function initialize(\n    Authority AUTHORITY_,\n    ITransferProxy TRANSFER_PROXY_,\n    ILienToken LIEN_TOKEN_,\n    ConsiderationInterface SEAPORT_\n  ) public initializer {\n    __initAuth(msg.sender, address(AUTHORITY_));\n    __initERC721(\"Astaria Collateral Token\", \"ACT\");\n    CollateralStorage storage s = _loadCollateralSlot();\n    s.TRANSFER_PROXY = TRANSFER_PROXY_;\n    s.LIEN_TOKEN = LIEN_TOKEN_;\n    s.SEAPORT = SEAPORT_;\n    (, , address conduitController) = s.SEAPORT.information();\n    bytes32 CONDUIT_KEY = Bytes32AddressLib.fillLast12Bytes(address(this));\n    s.CONDUIT_KEY = CONDUIT_KEY;\n    s.CONDUIT_CONTROLLER = ConduitControllerInterface(conduitController);\n\n    s.CONDUIT = s.CONDUIT_CONTROLLER.createConduit(CONDUIT_KEY, address(this));\n    s.CONDUIT_CONTROLLER.updateChannel(\n      address(s.CONDUIT),\n      address(SEAPORT_),\n      true\n    );\n  }\n\n  function SEAPORT() public view returns (ConsiderationInterface) {\n    return _loadCollateralSlot().SEAPORT;\n  }\n\n  function liquidatorNFTClaim(OrderParameters memory params) external {\n    CollateralStorage storage s = _loadCollateralSlot();\n\n    uint256 collateralId = params.offer[0].token.computeId(\n      params.offer[0].identifierOrCriteria\n    );\n    address liquidator = s.LIEN_TOKEN.getAuctionLiquidator(collateralId);\n    if (\n      s.collateralIdToAuction[collateralId] == bytes32(0) ||\n      liquidator == address(0)\n    ) {\n      //revert no auction\n      revert InvalidCollateralState(InvalidCollateralStates.NO_AUCTION);\n    }\n    if (\n      s.collateralIdToAuction[collateralId] != keccak256(abi.encode(params))\n    ) {\n      //revert auction params dont match\n      revert InvalidCollateralState(\n        InvalidCollateralStates.INVALID_AUCTION_PARAMS\n      );\n    }\n\n    if (block.timestamp < params.endTime) {\n      //auction hasn't ended yet\n      revert InvalidCollateralState(InvalidCollateralStates.AUCTION_ACTIVE);\n    }\n\n    Asset memory underlying = s.idToUnderlying[collateralId];\n    address tokenContract = underlying.tokenContract;\n    uint256 tokenId = underlying.tokenId;\n    ClearingHouse CH = ClearingHouse(payable(s.clearingHouse[collateralId]));\n    CH.settleLiquidatorNFTClaim();\n    _releaseToAddress(s, underlying, collateralId, liquidator);\n  }\n\n  function _loadCollateralSlot()\n    internal\n    pure\n    returns (CollateralStorage storage s)\n  {\n    uint256 slot = COLLATERAL_TOKEN_SLOT;\n\n    assembly {\n      s.slot := slot\n    }\n  }\n\n  function isValidOrder(\n    bytes32 orderHash,\n    address caller,\n    address offerer,\n    bytes32 zoneHash\n  ) external view returns (bytes4 validOrderMagicValue) {\n    CollateralStorage storage s = _loadCollateralSlot();\n    return\n      s.collateralIdToAuction[uint256(zoneHash)] == orderHash\n        ? ZoneInterface.isValidOrder.selector\n        : bytes4(0xffffffff);\n  }\n\n  // Called by Consideration whenever any extraData is provided by the caller.\n  function isValidOrderIncludingExtraData(\n    bytes32 orderHash,\n    address caller,\n    AdvancedOrder calldata order,\n    bytes32[] calldata priorOrderHashes,\n    CriteriaResolver[] calldata criteriaResolvers\n  ) external view returns (bytes4 validOrderMagicValue) {\n    CollateralStorage storage s = _loadCollateralSlot();\n    return\n      s.collateralIdToAuction[uint256(order.parameters.zoneHash)] == orderHash\n        ? ZoneInterface.isValidOrder.selector\n        : bytes4(0xffffffff);\n  }\n\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC721, IERC165)\n    returns (bool)\n  {\n    return\n      interfaceId == type(ICollateralToken).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  function fileBatch(File[] calldata files) external requiresAuth {\n    uint256 i;\n    for (; i < files.length; ) {\n      _file(files[i]);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function file(File calldata incoming) public requiresAuth {\n    _file(incoming);\n  }\n\n  function _file(File calldata incoming) internal {\n    CollateralStorage storage s = _loadCollateralSlot();\n\n    FileType what = incoming.what;\n    bytes memory data = incoming.data;\n    if (what == FileType.AstariaRouter) {\n      address addr = abi.decode(data, (address));\n      s.ASTARIA_ROUTER = IAstariaRouter(addr);\n    } else if (what == FileType.SecurityHook) {\n      (address target, address hook) = abi.decode(data, (address, address));\n      s.securityHooks[target] = hook;\n    } else if (what == FileType.FlashEnabled) {\n      (address target, bool enabled) = abi.decode(data, (address, bool));\n      s.flashEnabled[target] = enabled;\n    } else if (what == FileType.Seaport) {\n      s.SEAPORT = ConsiderationInterface(abi.decode(data, (address)));\n      (, , address conduitController) = s.SEAPORT.information();\n      if (s.CONDUIT_KEY == bytes32(0)) {\n        s.CONDUIT_KEY = Bytes32AddressLib.fillLast12Bytes(address(this));\n      }\n      s.CONDUIT_CONTROLLER = ConduitControllerInterface(conduitController);\n      (address conduit, bool exists) = s.CONDUIT_CONTROLLER.getConduit(\n        s.CONDUIT_KEY\n      );\n      if (!exists) {\n        s.CONDUIT = s.CONDUIT_CONTROLLER.createConduit(\n          s.CONDUIT_KEY,\n          address(this)\n        );\n      } else {\n        s.CONDUIT = conduit;\n      }\n      s.CONDUIT_CONTROLLER.updateChannel(\n        address(s.CONDUIT),\n        address(s.SEAPORT),\n        true\n      );\n    } else {\n      revert UnsupportedFile();\n    }\n    emit FileUpdated(what, data);\n  }\n\n  modifier releaseCheck(uint256 collateralId) {\n    CollateralStorage storage s = _loadCollateralSlot();\n\n    if (s.LIEN_TOKEN.getCollateralState(collateralId) != bytes32(0)) {\n      revert InvalidCollateralState(InvalidCollateralStates.ACTIVE_LIENS);\n    }\n    if (s.collateralIdToAuction[collateralId] != bytes32(0)) {\n      revert InvalidCollateralState(InvalidCollateralStates.AUCTION_ACTIVE);\n    }\n    _;\n  }\n\n  modifier onlyOwner(uint256 collateralId) {\n    require(ownerOf(collateralId) == msg.sender);\n    _;\n  }\n\n  function flashAction(\n    IFlashAction receiver,\n    uint256 collateralId,\n    bytes calldata data\n  ) external onlyOwner(collateralId) {\n    address addr;\n    uint256 tokenId;\n    CollateralStorage storage s = _loadCollateralSlot();\n    (addr, tokenId) = getUnderlying(collateralId);\n\n    if (!s.flashEnabled[addr]) {\n      revert InvalidCollateralState(InvalidCollateralStates.FLASH_DISABLED);\n    }\n\n    if (\n      s.LIEN_TOKEN.getCollateralState(collateralId) == bytes32(\"ACTIVE_AUCTION\")\n    ) {\n      revert InvalidCollateralState(InvalidCollateralStates.AUCTION_ACTIVE);\n    }\n\n    bytes32 preTransferState;\n    //look to see if we have a security handler for this asset\n\n    address securityHook = s.securityHooks[addr];\n    if (securityHook != address(0)) {\n      preTransferState = ISecurityHook(securityHook).getState(addr, tokenId);\n    }\n    // transfer the NFT to the destination optimistically\n\n    ClearingHouse(s.clearingHouse[collateralId]).transferUnderlying(\n      addr,\n      tokenId,\n      address(receiver)\n    );\n\n    //trigger the flash action on the receiver\n    if (\n      receiver.onFlashAction(\n        IFlashAction.Underlying(s.clearingHouse[collateralId], addr, tokenId),\n        data\n      ) != keccak256(\"FlashAction.onFlashAction\")\n    ) {\n      revert FlashActionCallbackFailed();\n    }\n\n    if (\n      securityHook != address(0) &&\n      preTransferState != ISecurityHook(securityHook).getState(addr, tokenId)\n    ) {\n      revert FlashActionSecurityCheckFailed();\n    }\n\n    // validate that the NFT returned after the call\n\n    if (\n      IERC721(addr).ownerOf(tokenId) != address(s.clearingHouse[collateralId])\n    ) {\n      revert FlashActionNFTNotReturned();\n    }\n  }\n\n  function releaseToAddress(uint256 collateralId, address releaseTo)\n    public\n    releaseCheck(collateralId)\n    onlyOwner(collateralId)\n  {\n    CollateralStorage storage s = _loadCollateralSlot();\n\n    if (msg.sender != ownerOf(collateralId)) {\n      revert InvalidSender();\n    }\n    Asset memory underlying = s.idToUnderlying[collateralId];\n    address tokenContract = underlying.tokenContract;\n    _burn(collateralId);\n    delete s.idToUnderlying[collateralId];\n    _releaseToAddress(s, underlying, collateralId, releaseTo);\n  }\n\n  /**\n   * @dev Transfers locked collateral to a specified address and deletes the reference to the CollateralToken for that NFT.\n   * @param releaseTo The address to send the NFT to.\n   */\n  function _releaseToAddress(\n    CollateralStorage storage s,\n    Asset memory underlyingAsset,\n    uint256 collateralId,\n    address releaseTo\n  ) internal {\n    ClearingHouse(s.clearingHouse[collateralId]).transferUnderlying(\n      underlyingAsset.tokenContract,\n      underlyingAsset.tokenId,\n      releaseTo\n    );\n    emit ReleaseTo(\n      underlyingAsset.tokenContract,\n      underlyingAsset.tokenId,\n      releaseTo\n    );\n  }\n\n  function getConduitKey() public view returns (bytes32) {\n    CollateralStorage storage s = _loadCollateralSlot();\n    return s.CONDUIT_KEY;\n  }\n\n  function getConduit() public view returns (address) {\n    CollateralStorage storage s = _loadCollateralSlot();\n    return s.CONDUIT;\n  }\n\n  /**\n   * @notice Retrieve the address and tokenId of the underlying NFT of a CollateralToken.\n   * @param collateralId The ID of the CollateralToken wrapping the NFT.\n   * @return The address and tokenId of the underlying NFT.\n   */\n  function getUnderlying(uint256 collateralId)\n    public\n    view\n    returns (address, uint256)\n  {\n    Asset memory underlying = _loadCollateralSlot().idToUnderlying[\n      collateralId\n    ];\n    return (underlying.tokenContract, underlying.tokenId);\n  }\n\n  /**\n   * @notice Retrieve the tokenURI for a CollateralToken.\n   * @param collateralId The ID of the CollateralToken.\n   * @return the URI of the CollateralToken.\n   */\n  function tokenURI(uint256 collateralId)\n    public\n    view\n    virtual\n    override(ERC721, IERC721)\n    returns (string memory)\n  {\n    (address underlyingAsset, uint256 assetId) = getUnderlying(collateralId);\n    return ERC721(underlyingAsset).tokenURI(assetId);\n  }\n\n  function securityHooks(address target) public view returns (address) {\n    return _loadCollateralSlot().securityHooks[target];\n  }\n\n  function getClearingHouse(uint256 collateralId)\n    external\n    view\n    returns (ClearingHouse)\n  {\n    return\n      ClearingHouse(payable(_loadCollateralSlot().clearingHouse[collateralId]));\n  }\n\n  function _generateValidOrderParameters(\n    CollateralStorage storage s,\n    address settlementToken,\n    uint256 collateralId,\n    uint256[] memory prices,\n    uint256 maxDuration\n  ) internal returns (OrderParameters memory orderParameters) {\n    OfferItem[] memory offer = new OfferItem[](1);\n\n    Asset memory underlying = s.idToUnderlying[collateralId];\n\n    offer[0] = OfferItem(\n      ItemType.ERC721,\n      underlying.tokenContract,\n      underlying.tokenId,\n      1,\n      1\n    );\n\n    ConsiderationItem[] memory considerationItems = new ConsiderationItem[](2);\n    considerationItems[0] = ConsiderationItem(\n      ItemType.ERC20,\n      settlementToken,\n      uint256(0),\n      prices[0],\n      prices[1],\n      payable(address(s.clearingHouse[collateralId]))\n    );\n    considerationItems[1] = ConsiderationItem(\n      ItemType.ERC1155,\n      s.clearingHouse[collateralId],\n      uint256(uint160(settlementToken)),\n      prices[0],\n      prices[1],\n      payable(s.clearingHouse[collateralId])\n    );\n\n    orderParameters = OrderParameters({\n      offerer: s.clearingHouse[collateralId],\n      zone: address(this), // 0x20\n      offer: offer,\n      consideration: considerationItems,\n      orderType: OrderType.FULL_OPEN,\n      startTime: uint256(block.timestamp),\n      endTime: uint256(block.timestamp + maxDuration),\n      zoneHash: bytes32(collateralId),\n      salt: uint256(blockhash(block.number)),\n      conduitKey: s.CONDUIT_KEY, // 0x120\n      totalOriginalConsiderationItems: considerationItems.length\n    });\n  }\n\n  function auctionVault(AuctionVaultParams calldata params)\n    external\n    requiresAuth\n    returns (OrderParameters memory orderParameters)\n  {\n    CollateralStorage storage s = _loadCollateralSlot();\n\n    uint256[] memory prices = new uint256[](2);\n    prices[0] = params.startingPrice;\n    prices[1] = params.endingPrice;\n    orderParameters = _generateValidOrderParameters(\n      s,\n      params.settlementToken,\n      params.collateralId,\n      prices,\n      params.maxDuration\n    );\n\n    _listUnderlyingOnSeaport(\n      s,\n      params.collateralId,\n      Order(orderParameters, new bytes(0))\n    );\n  }\n\n  function _listUnderlyingOnSeaport(\n    CollateralStorage storage s,\n    uint256 collateralId,\n    Order memory listingOrder\n  ) internal {\n    //get total Debt and ensure its being sold for more than that\n\n    if (listingOrder.parameters.conduitKey != s.CONDUIT_KEY) {\n      revert InvalidConduitKey();\n    }\n    if (listingOrder.parameters.zone != address(this)) {\n      revert InvalidZone();\n    }\n\n    ClearingHouse(s.clearingHouse[collateralId]).validateOrder(listingOrder);\n    emit ListedOnSeaport(collateralId, listingOrder);\n\n    s.collateralIdToAuction[collateralId] = keccak256(\n      abi.encode(listingOrder.parameters)\n    );\n  }\n\n  function settleAuction(uint256 collateralId) public {\n    CollateralStorage storage s = _loadCollateralSlot();\n    if (\n      s.collateralIdToAuction[collateralId] == bytes32(0) &&\n      ERC721(s.idToUnderlying[collateralId].tokenContract).ownerOf(\n        s.idToUnderlying[collateralId].tokenId\n      ) !=\n      s.clearingHouse[collateralId]\n    ) {\n      revert InvalidCollateralState(InvalidCollateralStates.NO_AUCTION);\n    }\n    require(msg.sender == s.clearingHouse[collateralId]);\n    _settleAuction(s, collateralId);\n    delete s.idToUnderlying[collateralId];\n    _burn(collateralId);\n  }\n\n  function _settleAuction(CollateralStorage storage s, uint256 collateralId)\n    internal\n  {\n    delete s.collateralIdToAuction[collateralId];\n  }\n\n  /**\n   * @dev Mints a new CollateralToken wrapping an NFT.\n   * @param from_ the owner of the collateral deposited\n   * @param tokenId_ The NFT token ID\n   * @return a static return of the receive signature\n   */\n  function onERC721Received(\n    address, /* operator_ */\n    address from_,\n    uint256 tokenId_,\n    bytes calldata // calldata data_\n  ) external override whenNotPaused returns (bytes4) {\n    CollateralStorage storage s = _loadCollateralSlot();\n    uint256 collateralId = msg.sender.computeId(tokenId_);\n\n    Asset memory incomingAsset = s.idToUnderlying[collateralId];\n    if (incomingAsset.tokenContract == address(0)) {\n      require(ERC721(msg.sender).ownerOf(tokenId_) == address(this));\n\n      if (s.clearingHouse[collateralId] == address(0)) {\n        address clearingHouse = ClonesWithImmutableArgs.clone(\n          s.ASTARIA_ROUTER.BEACON_PROXY_IMPLEMENTATION(),\n          abi.encodePacked(\n            address(s.ASTARIA_ROUTER),\n            uint8(IAstariaRouter.ImplementationType.ClearingHouse),\n            collateralId\n          )\n        );\n\n        s.clearingHouse[collateralId] = clearingHouse;\n      }\n      ERC721(msg.sender).safeTransferFrom(\n        address(this),\n        s.clearingHouse[collateralId],\n        tokenId_\n      );\n\n      if (msg.sender == address(this) || msg.sender == address(s.LIEN_TOKEN)) {\n        revert InvalidCollateral();\n      }\n\n      _mint(from_, collateralId);\n\n      s.idToUnderlying[collateralId] = Asset({\n        tokenContract: msg.sender,\n        tokenId: tokenId_\n      });\n\n      emit Deposit721(msg.sender, tokenId_, collateralId, from_);\n      return IERC721Receiver.onERC721Received.selector;\n    } else {\n      revert();\n    }\n  }\n\n  modifier whenNotPaused() {\n    if (_loadCollateralSlot().ASTARIA_ROUTER.paused()) {\n      revert ProtocolPaused();\n    }\n    _;\n  }\n}"
    }
  ]
}