{
  "Title": "[L-05] Consider `isContract` checks in constructors",
  "Content": "\nSeveral addresses are assigned in the contract constructors and assigned to immutable variables. A successful deployment is sensitive to these addresses being assigned correctly for the current network, and that addresses were specified in the correct order. Consider adding checks, as aggressively as possible for the use case, to help ensure the deployment configuration is correct.\n\n* [`AddressRegistry.constructor`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/AddressRegistry.sol#L37) consider requiring that `_cidNFT.isContract()`.\n* [`SubprotocolRegistry.constructor`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/SubprotocolRegistry.sol#L66) and [`CidNFT.constructor`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L129) consider requiring that `_noteContract.isContract()`.\n* [`CidNFT.constructor`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/SubprotocolRegistry.sol#L66) consider requiring that `_subprotocolRegistry.isContract()`.\n\n`.isContract()` is referring to the [OZ Address library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L40) or similar implementation.\n\nThis is related to the automated finding `[NC-1] Missing checks for address(0) when assigning values to address state variables` but suggests a more aggressive check.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2023-01-canto-identity-protocol-contest",
  "Code": [
    {
      "filename": "src/AddressRegistry.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport \"solmate/tokens/ERC721.sol\";\n\n/// @title Address Registry\n/// @notice Allows users to register their CID NFT\ncontract AddressRegistry {\n    /*//////////////////////////////////////////////////////////////\n                                 ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Address of the CID NFT\n    address public immutable cidNFT;\n\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Stores the mappings of users to their CID NFT\n    mapping(address => uint256) private cidNFTs;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event CIDNFTAdded(address indexed user, uint256 indexed cidNFTID);\n    event CIDNFTRemoved(address indexed user, uint256 indexed cidNFTID);\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error NFTNotOwnedByUser(uint256 cidNFTID, address caller);\n    error NoCIDNFTRegisteredForUser(address caller);\n\n    /// @param _cidNFT Address of the CID NFT contract\n    constructor(address _cidNFT) {\n        cidNFT = _cidNFT;\n    }\n\n    /// @notice Register a CID NFT to the address of the caller. NFT has to be owned by the caller\n    /// @dev Will overwrite existing registration if any exists\n    function register(uint256 _cidNFTID) external {\n        if (ERC721(cidNFT).ownerOf(_cidNFTID) != msg.sender)\n            // We only guarantee that a CID NFT is owned by the user at the time of registration\n            // ownerOf reverts if non-existing ID is provided\n            revert NFTNotOwnedByUser(_cidNFTID, msg.sender);\n        cidNFTs[msg.sender] = _cidNFTID;\n        emit CIDNFTAdded(msg.sender, _cidNFTID);\n    }\n\n    /// @notice Remove the current registration of the caller\n    function remove() external {\n        uint256 cidNFTID = cidNFTs[msg.sender];\n        if (cidNFTID == 0) revert NoCIDNFTRegisteredForUser(msg.sender);\n        delete cidNFTs[msg.sender];\n        emit CIDNFTRemoved(msg.sender, cidNFTID);\n    }\n\n    /// @notice Get the CID NFT ID that is registered for the provided user\n    /// @param _user Address to query\n    /// @return cidNFTID The registered CID NFT ID. 0 when no CID NFT is registered for the given address\n    function getCID(address _user) external view returns (uint256 cidNFTID) {\n        cidNFTID = cidNFTs[_user];\n    }\n}"
    },
    {
      "filename": "src/SubprotocolRegistry.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport \"solmate/tokens/ERC721.sol\";\nimport \"solmate/tokens/ERC20.sol\";\nimport \"solmate/utils/SafeTransferLib.sol\";\nimport \"./CidSubprotocolNFT.sol\";\n\n/// @title Subprotocol Registry\n/// @notice Enables registration of new subprotocols\ncontract SubprotocolRegistry {\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Fee for registering a new subprotocol (100 $NOTE)\n    uint256 public constant REGISTER_FEE = 100 * 10**18;\n\n    /// @notice Reference to the $NOTE TOKEN\n    ERC20 public immutable note;\n\n    /// @notice Wallet that receives fees paid when registering\n    address public immutable cidFeeWallet;\n\n    /// @notice Data that is associated with a subprotocol.\n    /// @dev Data types are chosen such that all data fits in one slot\n    struct SubprotocolData {\n        /// @notice Owner (registrant) of the subprotocol\n        address owner;\n        /// @notice Optional cost in NOTE to add an NFT\n        /// @dev Maximum value is (2^96 - 1) / 10^18 =~ 80 billion. Zero for no fee\n        uint96 fee;\n        address nftAddress;\n        bool ordered;\n        bool primary;\n        bool active;\n    }\n\n    /// @notice Mapping (name => data) that contains all registered subprotocols\n    mapping(string => SubprotocolData) private subprotocols;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event SubprotocolRegistered(\n        address indexed registrar,\n        string indexed name,\n        address indexed nftAddress,\n        bool ordered,\n        bool primary,\n        bool active,\n        uint96 fee\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error SubprotocolAlreadyExists(string name, address owner);\n    error NoTypeSpecified(string name);\n    error NotASubprotocolNFT(address nftAddress);\n\n    /// @notice Sets the reference to the $NOTE contract\n    /// @param _noteContract Address of the $NOTE contract\n    /// @param _cidFeeWallet Address of the wallet that receives the fees\n    constructor(address _noteContract, address _cidFeeWallet) {\n        note = ERC20(_noteContract);\n        cidFeeWallet = _cidFeeWallet;\n    }\n\n    /// @notice Register a new subprotocol. There is a 100 $NOTE fee when registering\n    /// @dev The options ordered, primary, active are not mutually exclusive. In practice, only one will be set for most subprotocols,\n    /// but if a subprotocol for instance supports int keys (mapped to one value) and a list of active NFTs, ordered and active is true.\n    /// @param _ordered Ordering allows integers to be used as map keys, to one and only one value\n    /// @param _primary Primary maps string keys to zero or one value\n    /// @param _active Subprotocols that have a list of a active NFTs\n    /// @param _name Name of the subprotocol, has to be unique\n    /// @param _nftAddress Address of the subprotocol NFT. Has to adhere to the CidSubprotocolNFT interface\n    /// @param _fee Fee (in $NOTE) for minting a new token of the subprotocol. Set to 0 if there is no fee. 10% is subtracted from this fee as a CID fee\n    function register(\n        bool _ordered,\n        bool _primary,\n        bool _active,\n        address _nftAddress,\n        string calldata _name,\n        uint96 _fee\n    ) external {\n        SafeTransferLib.safeTransferFrom(note, msg.sender, cidFeeWallet, REGISTER_FEE);\n        if (!(_ordered || _primary || _active)) revert NoTypeSpecified(_name);\n        SubprotocolData memory subprotocolData = subprotocols[_name];\n        if (subprotocolData.owner != address(0)) revert SubprotocolAlreadyExists(_name, subprotocolData.owner);\n        subprotocolData.owner = msg.sender;\n        subprotocolData.fee = _fee;\n        if (!ERC721(_nftAddress).supportsInterface(type(CidSubprotocolNFT).interfaceId))\n            revert NotASubprotocolNFT(_nftAddress);\n        subprotocolData.nftAddress = _nftAddress;\n        subprotocolData.ordered = _ordered;\n        subprotocolData.primary = _primary;\n        subprotocolData.active = _active;\n        subprotocols[_name] = subprotocolData;\n        emit SubprotocolRegistered(msg.sender, _name, _nftAddress, _ordered, _primary, _active, _fee);\n    }\n\n    /// @notice Getter function to retrieve subprotocol data\n    /// @param _name Name of the subprotocol to query\n    /// @return subprotocolData stored under _name. owner will be set to address(0) if subprotocol does not exist\n    function getSubprotocol(string calldata _name) external view returns (SubprotocolData memory) {\n        return subprotocols[_name];\n    }\n}"
    },
    {
      "filename": "src/SubprotocolRegistry.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport \"solmate/tokens/ERC721.sol\";\nimport \"solmate/tokens/ERC20.sol\";\nimport \"solmate/utils/SafeTransferLib.sol\";\nimport \"./CidSubprotocolNFT.sol\";\n\n/// @title Subprotocol Registry\n/// @notice Enables registration of new subprotocols\ncontract SubprotocolRegistry {\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Fee for registering a new subprotocol (100 $NOTE)\n    uint256 public constant REGISTER_FEE = 100 * 10**18;\n\n    /// @notice Reference to the $NOTE TOKEN\n    ERC20 public immutable note;\n\n    /// @notice Wallet that receives fees paid when registering\n    address public immutable cidFeeWallet;\n\n    /// @notice Data that is associated with a subprotocol.\n    /// @dev Data types are chosen such that all data fits in one slot\n    struct SubprotocolData {\n        /// @notice Owner (registrant) of the subprotocol\n        address owner;\n        /// @notice Optional cost in NOTE to add an NFT\n        /// @dev Maximum value is (2^96 - 1) / 10^18 =~ 80 billion. Zero for no fee\n        uint96 fee;\n        address nftAddress;\n        bool ordered;\n        bool primary;\n        bool active;\n    }\n\n    /// @notice Mapping (name => data) that contains all registered subprotocols\n    mapping(string => SubprotocolData) private subprotocols;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event SubprotocolRegistered(\n        address indexed registrar,\n        string indexed name,\n        address indexed nftAddress,\n        bool ordered,\n        bool primary,\n        bool active,\n        uint96 fee\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error SubprotocolAlreadyExists(string name, address owner);\n    error NoTypeSpecified(string name);\n    error NotASubprotocolNFT(address nftAddress);\n\n    /// @notice Sets the reference to the $NOTE contract\n    /// @param _noteContract Address of the $NOTE contract\n    /// @param _cidFeeWallet Address of the wallet that receives the fees\n    constructor(address _noteContract, address _cidFeeWallet) {\n        note = ERC20(_noteContract);\n        cidFeeWallet = _cidFeeWallet;\n    }\n\n    /// @notice Register a new subprotocol. There is a 100 $NOTE fee when registering\n    /// @dev The options ordered, primary, active are not mutually exclusive. In practice, only one will be set for most subprotocols,\n    /// but if a subprotocol for instance supports int keys (mapped to one value) and a list of active NFTs, ordered and active is true.\n    /// @param _ordered Ordering allows integers to be used as map keys, to one and only one value\n    /// @param _primary Primary maps string keys to zero or one value\n    /// @param _active Subprotocols that have a list of a active NFTs\n    /// @param _name Name of the subprotocol, has to be unique\n    /// @param _nftAddress Address of the subprotocol NFT. Has to adhere to the CidSubprotocolNFT interface\n    /// @param _fee Fee (in $NOTE) for minting a new token of the subprotocol. Set to 0 if there is no fee. 10% is subtracted from this fee as a CID fee\n    function register(\n        bool _ordered,\n        bool _primary,\n        bool _active,\n        address _nftAddress,\n        string calldata _name,\n        uint96 _fee\n    ) external {\n        SafeTransferLib.safeTransferFrom(note, msg.sender, cidFeeWallet, REGISTER_FEE);\n        if (!(_ordered || _primary || _active)) revert NoTypeSpecified(_name);\n        SubprotocolData memory subprotocolData = subprotocols[_name];\n        if (subprotocolData.owner != address(0)) revert SubprotocolAlreadyExists(_name, subprotocolData.owner);\n        subprotocolData.owner = msg.sender;\n        subprotocolData.fee = _fee;\n        if (!ERC721(_nftAddress).supportsInterface(type(CidSubprotocolNFT).interfaceId))\n            revert NotASubprotocolNFT(_nftAddress);\n        subprotocolData.nftAddress = _nftAddress;\n        subprotocolData.ordered = _ordered;\n        subprotocolData.primary = _primary;\n        subprotocolData.active = _active;\n        subprotocols[_name] = subprotocolData;\n        emit SubprotocolRegistered(msg.sender, _name, _nftAddress, _ordered, _primary, _active, _fee);\n    }\n\n    /// @notice Getter function to retrieve subprotocol data\n    /// @param _name Name of the subprotocol to query\n    /// @return subprotocolData stored under _name. owner will be set to address(0) if subprotocol does not exist\n    function getSubprotocol(string calldata _name) external view returns (SubprotocolData memory) {\n        return subprotocols[_name];\n    }\n}"
    },
    {
      "filename": "contracts/utils/Address.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert Errors.FailedCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}"
    }
  ]
}