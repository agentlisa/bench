{
  "Title": "[M-04] `COMP` Distributions Can Be Manipulated And Duplicated Across Any Number Of Accounts",
  "Content": "_Submitted by leastwood_\n\n[Comptroller.sol#L240-L242](https://github.com/bunkerfinance/bunker-protocol/blob/752126094691e7457d08fc62a6a5006df59bd2fe/contracts/Comptroller.sol#L240-L242)<br>\n[Comptroller.sol#L260-L262](https://github.com/bunkerfinance/bunker-protocol/blob/752126094691e7457d08fc62a6a5006df59bd2fe/contracts/Comptroller.sol#L260-L262)<br>\n[Comptroller.sol#L469-L472](https://github.com/bunkerfinance/bunker-protocol/blob/752126094691e7457d08fc62a6a5006df59bd2fe/contracts/Comptroller.sol#L469-L472)<br>\n[Comptroller.sol#L496-L499](https://github.com/bunkerfinance/bunker-protocol/blob/752126094691e7457d08fc62a6a5006df59bd2fe/contracts/Comptroller.sol#L496-L499)<br>\n[Comptroller.sol#L1139-L1155](https://github.com/bunkerfinance/bunker-protocol/blob/752126094691e7457d08fc62a6a5006df59bd2fe/contracts/Comptroller.sol#L1139-L1155)<br>\n[Comptroller.sol#L1222-L1243](https://github.com/bunkerfinance/bunker-protocol/blob/752126094691e7457d08fc62a6a5006df59bd2fe/contracts/Comptroller.sol#L1222-L1243)<br>\n\nThe `updateCompSupplyIndex()` and `distributeSupplierComp()` functions are used by Compound to track distributions owed to users for supplying funds to the protocol. Bunker protocol is a fork of compound with NFT integration, however, part of the original functionality appears to have been mistakenly commented out. As a result, whenever users enter or exit the protocol, `COMP` distributions will not be correctly calculated for suppliers. At first glance, its possible that this was intended, however, there is nothing stated in the docs that seems to indicate such. Additionally, the `COMP` distribution functionality has not been commented out for borrowers. Therefore, tokens will still be distributed for borrowers.\n\nBoth the `updateCompSupplyIndex()` and `updateCompBorrowIndex()` functions operate on the same `compSpeeds` value which dictates how many tokens are distributed on each block. Therefore, you cannot directly disable the functionality of supplier distributions without altering how distributions are calculated for borrowers. Because of this, suppliers can manipulate their yield by supplying tokens, calling `updateCompSupplyIndex()` and `distributeSupplierComp()`, removing their tokens and repeating the same process on other accounts. This completely breaks all yield distributions and there is currently no way to upgrade the contracts to alter the contract's behaviour. Tokens can be claimed by redepositing in a previously \"checkpointed\" account, calling `claimComp()` and removing tokens before re-supplying on another account.\n\n### Recommended Mitigation Steps\n\nConsider commenting all behaviour associated with token distributions if token distributions are not meant to be supported. Otherwise, it is worthwhile uncommenting all occurrences of the `updateCompSupplyIndex()` and `distributeSupplierComp()` functions.\n\n**[bunkerfinance-dev (bunker.finance) acknowledged, but disagreed with High severity and commented](https://github.com/code-423n4/2022-05-bunker-findings/issues/105#issuecomment-1129626056):**\n > We are not going to use the COMP code. We could fix documentation or comment more code to make this clearer though.\n\n**[gzeon (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-05-bunker-findings/issues/105#issuecomment-1140432093):**\n > Comptroller.sol is [in scope](https://github.com/code-423n4/2022-05-bunker) of this contest, and there are no indication that token distribution will be disabled despite the sponsor claim they are not going to use the $COMP code. However, it is also true the deployment setup within contest repo lack the deployment of $COMP and its distribution. I believe this is a valid Med Risk issue given fund(reward token) can be lost in certain assumptions.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-bunkerfinance-contest",
  "Code": [
    {
      "filename": "contracts/Comptroller.sol",
      "content": "pragma solidity ^0.5.16;\n\nimport \"./CNftInterface.sol\";\nimport \"./CToken.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./PriceOracle.sol\";\nimport \"./ComptrollerInterface.sol\";\nimport \"./ComptrollerStorage.sol\";\nimport \"./Unitroller.sol\";\nimport \"./Governance/Comp.sol\";\n\n/**\n * @title Compound's Comptroller Contract\n * @author Compound\n */\ncontract Comptroller is ComptrollerNftStorage, ComptrollerInterface, ComptrollerErrorReporter, ExponentialNoError {\n    /// @notice Emitted when an admin supports a market\n    event MarketListed(CToken cToken);\n\n    /// @notice Emitted when an account enters a market\n    event MarketEntered(CToken cToken, address account);\n\n    /// @notice Emitted when an account exits a market\n    event MarketExited(CToken cToken, address account);\n\n    /// @notice Emitted when close factor is changed by admin\n    event NewCloseFactor(uint oldCloseFactorMantissa, uint newCloseFactorMantissa);\n\n    /// @notice Emitted when a collateral factor is changed by admin\n    event NewCollateralFactor(CToken cToken, uint oldCollateralFactorMantissa, uint newCollateralFactorMantissa);\n\n    /// @notice Emitted when the NFT collateral factor is changed by admin\n    event NewNftCollateralFactor(uint oldCollateralFactorMantissa, uint newCollateralFactorMantissa);\n\n    /// @notice Emitted when liquidation incentive is changed by admin\n    event NewLiquidationIncentive(uint oldLiquidationIncentiveMantissa, uint newLiquidationIncentiveMantissa);\n\n    /// @notice Emitted when price oracle is changed\n    event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);\n\n    /// @notice Emitted when pause guardian is changed\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\n\n    /// @notice Emitted when an action is paused globally\n    event ActionPaused(string action, bool pauseState);\n\n    /// @notice Emitted when an action is paused on a market\n    event ActionPaused(CToken cToken, string action, bool pauseState);\n\n    /// @notice Emitted when a new COMP speed is calculated for a market\n    event CompSpeedUpdated(CToken indexed cToken, uint newSpeed);\n\n    /// @notice Emitted when a new COMP speed is set for a contributor\n    event ContributorCompSpeedUpdated(address indexed contributor, uint newSpeed);\n\n    /// @notice Emitted when COMP is distributed to a supplier\n    event DistributedSupplierComp(CToken indexed cToken, address indexed supplier, uint compDelta, uint compSupplyIndex);\n\n    /// @notice Emitted when COMP is distributed to a borrower\n    event DistributedBorrowerComp(CToken indexed cToken, address indexed borrower, uint compDelta, uint compBorrowIndex);\n\n    /// @notice Emitted when borrow cap for a cToken is changed\n    event NewBorrowCap(CToken indexed cToken, uint newBorrowCap);\n\n    /// @notice Emitted when borrow cap guardian is changed\n    event NewBorrowCapGuardian(address oldBorrowCapGuardian, address newBorrowCapGuardian);\n\n    /// @notice Emitted when COMP is granted by admin\n    event CompGranted(address recipient, uint amount);\n\n    /// @notice The initial COMP index for a market\n    uint224 public constant compInitialIndex = 1e36;\n\n    // closeFactorMantissa must be strictly greater than this value\n    uint internal constant closeFactorMinMantissa = 0.05e18; // 0.05\n\n    // closeFactorMantissa must not exceed this value\n    uint internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\n\n    // No collateralFactorMantissa may exceed this value\n    uint internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\n\n    constructor() public {\n        admin = msg.sender;\n    }\n\n    /*** Assets You Are In ***/\n\n    /**\n     * @notice Returns the assets an account has entered\n     * @param account The address of the account to pull assets for\n     * @return A dynamic list with the assets the account has entered\n     */\n    function getAssetsIn(address account) external view returns (CToken[] memory) {\n        CToken[] memory assetsIn = accountAssets[account];\n\n        return assetsIn;\n    }\n\n    /**\n     * @notice Returns whether the given account is entered in the given asset\n     * @param account The address of the account to check\n     * @param cToken The cToken to check\n     * @return True if the account is in the asset, otherwise false.\n     */\n    function checkMembership(address account, CToken cToken) external view returns (bool) {\n        return markets[address(cToken)].accountMembership[account];\n    }\n\n    /**\n     * @notice Add assets to be included in account liquidity calculation\n     * @param cTokens The list of addresses of the cToken markets to be enabled\n     * @return Success indicator for whether each corresponding market was entered\n     */\n    function enterMarkets(address[] memory cTokens) public returns (uint[] memory) {\n        uint len = cTokens.length;\n\n        uint[] memory results = new uint[](len);\n        for (uint i = 0; i < len; i++) {\n            CToken cToken = CToken(cTokens[i]);\n\n            results[i] = uint(addToMarketInternal(cToken, msg.sender));\n        }\n\n        return results;\n    }\n\n    /**\n     * @notice Add the market to the borrower's \"assets in\" for liquidity calculations\n     * @param cToken The market to enter\n     * @param borrower The address of the account to modify\n     * @return Success indicator for whether the market was entered\n     */\n    function addToMarketInternal(CToken cToken, address borrower) internal returns (Error) {\n        Market storage marketToJoin = markets[address(cToken)];\n\n        if (!marketToJoin.isListed) {\n            // market is not listed, cannot join\n            return Error.MARKET_NOT_LISTED;\n        }\n\n        if (marketToJoin.accountMembership[borrower] == true) {\n            // already joined\n            return Error.NO_ERROR;\n        }\n\n        // survived the gauntlet, add to list\n        // NOTE: we store these somewhat redundantly as a significant optimization\n        //  this avoids having to iterate through the list for the most common use cases\n        //  that is, only when we need to perform liquidity checks\n        //  and not whenever we want to check if an account is in a particular market\n        marketToJoin.accountMembership[borrower] = true;\n        accountAssets[borrower].push(cToken);\n\n        emit MarketEntered(cToken, borrower);\n\n        return Error.NO_ERROR;\n    }\n\n    /**\n     * @notice Removes asset from sender's account liquidity calculation\n     * @dev Sender must not have an outstanding borrow balance in the asset,\n     *  or be providing necessary collateral for an outstanding borrow.\n     * @param cTokenAddress The address of the asset to be removed\n     * @return Whether or not the account successfully exited the market\n     */\n    function exitMarket(address cTokenAddress) external returns (uint) {\n        CToken cToken = CToken(cTokenAddress);\n        /* Get sender tokensHeld and amountOwed underlying from the cToken */\n        (uint oErr, uint tokensHeld, uint amountOwed, ) = cToken.getAccountSnapshot(msg.sender);\n        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n\n        /* Fail if the sender has a borrow balance */\n        if (amountOwed != 0) {\n            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\n        }\n\n        /* Fail if the sender is not permitted to redeem all of their tokens */\n        uint allowed = redeemAllowedInternal(cTokenAddress, msg.sender, tokensHeld);\n        if (allowed != 0) {\n            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\n        }\n\n        Market storage marketToExit = markets[address(cToken)];\n\n        /* Return true if the sender is not already ‘in’ the market */\n        if (!marketToExit.accountMembership[msg.sender]) {\n            return uint(Error.NO_ERROR);\n        }\n\n        /* Set cToken account membership to false */\n        delete marketToExit.accountMembership[msg.sender];\n\n        /* Delete cToken from the account’s list of assets */\n        // load into memory for faster iteration\n        CToken[] memory userAssetList = accountAssets[msg.sender];\n        uint len = userAssetList.length;\n        uint assetIndex = len;\n        for (uint i = 0; i < len; i++) {\n            if (userAssetList[i] == cToken) {\n                assetIndex = i;\n                break;\n            }\n        }\n\n        // We *must* have found the asset in the list or our redundant data structure is broken\n        assert(assetIndex < len);\n\n        // copy last item in list to location of item to be removed, reduce length by 1\n        CToken[] storage storedList = accountAssets[msg.sender];\n        storedList[assetIndex] = storedList[storedList.length - 1];\n        storedList.length--;\n\n        emit MarketExited(cToken, msg.sender);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /*** Policy Hooks ***/\n\n    /**\n     * @notice Checks if the account should be allowed to mint tokens in the given market\n     * @param cAsset The market to verify the mint against\n     * @param minter The account which would get the minted tokens\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\n     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function mintAllowed(address cAsset, address minter, uint mintAmount) external returns (uint) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!mintGuardianPaused[cAsset], \"mint is paused\");\n\n        // Shh - currently unused\n        minter;\n        mintAmount;\n\n        if (!markets[cAsset].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        // Keep the flywheel moving\n        // updateCompSupplyIndex(cAsset);\n        // distributeSupplierComp(cAsset, minter);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to redeem tokens in the given market\n     * @param cAsset The market to verify the redeem against\n     * @param redeemer The account which would redeem the tokens\n     * @param redeemTokens The number of cTokens to exchange for the underlying asset in the market\n     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function redeemAllowed(address cAsset, address redeemer, uint redeemTokens) external returns (uint) {\n        uint allowed = redeemAllowedInternal(cAsset, redeemer, redeemTokens);\n        if (allowed != uint(Error.NO_ERROR)) {\n            return allowed;\n        }\n\n        // Keep the flywheel moving\n        // updateCompSupplyIndex(cAsset);\n        // distributeSupplierComp(cAsset, redeemer);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    function redeemAllowedInternal(address cToken, address redeemer, uint redeemTokens) internal view returns (uint) {\n        if (!markets[cToken].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\n        if (cToken != address(nftMarket) && !markets[cToken].accountMembership[redeemer]) {\n            return uint(Error.NO_ERROR);\n        }\n\n        /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\n        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(redeemer, cToken, redeemTokens, 0);\n        if (err != Error.NO_ERROR) {\n            return uint(err);\n        }\n        if (shortfall > 0) {\n            return uint(Error.INSUFFICIENT_LIQUIDITY);\n        }\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates redeem and reverts on rejection. May emit logs.\n     * @param cToken Asset being redeemed\n     * @param redeemer The address redeeming the tokens\n     * @param redeemAmount The amount of the underlying asset being redeemed\n     * @param redeemTokens The number of tokens being redeemed\n     */\n    function redeemVerify(address cToken, address redeemer, uint redeemAmount, uint redeemTokens) external {\n        // Shh - currently unused\n        cToken;\n        redeemer;\n\n        // Require tokens is zero or amount is also zero\n        if (redeemTokens == 0 && redeemAmount > 0) {\n            revert(\"redeemTokens zero\");\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n     * @param cToken The market to verify the borrow against\n     * @param borrower The account which would borrow the asset\n     * @param borrowAmount The amount of underlying the account would borrow\n     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function borrowAllowed(address cToken, address borrower, uint borrowAmount) external returns (uint) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!borrowGuardianPaused[cToken], \"borrow is paused\");\n\n        if (!markets[cToken].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        if (!markets[cToken].accountMembership[borrower]) {\n            // only cTokens may call borrowAllowed if borrower not in market\n            require(msg.sender == cToken, \"sender must be cToken\");\n\n            // attempt to add borrower to the market\n            Error err = addToMarketInternal(CToken(msg.sender), borrower);\n            if (err != Error.NO_ERROR) {\n                return uint(err);\n            }\n\n            // it should be impossible to break the important invariant\n            assert(markets[cToken].accountMembership[borrower]);\n        }\n\n        if (oracle.getUnderlyingPrice(CToken(cToken)) == 0) {\n            return uint(Error.PRICE_ERROR);\n        }\n\n\n        uint borrowCap = borrowCaps[cToken];\n        // Borrow cap of 0 corresponds to unlimited borrowing\n        if (borrowCap != 0) {\n            uint totalBorrows = CToken(cToken).totalBorrows();\n            uint nextTotalBorrows = add_(totalBorrows, borrowAmount);\n            require(nextTotalBorrows < borrowCap, \"market borrow cap reached\");\n        }\n\n        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, cToken, 0, borrowAmount);\n        if (err != Error.NO_ERROR) {\n            return uint(err);\n        }\n        if (shortfall > 0) {\n            return uint(Error.INSUFFICIENT_LIQUIDITY);\n        }\n\n        // Keep the flywheel moving\n        Exp memory borrowIndex = Exp({mantissa: CToken(cToken).borrowIndex()});\n        updateCompBorrowIndex(cToken, borrowIndex);\n        distributeBorrowerComp(cToken, borrower, borrowIndex);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to repay a borrow in the given market\n     * @param cToken The market to verify the repay against\n     * @param payer The account which would repay the asset\n     * @param borrower The account which would borrowed the asset\n     * @param repayAmount The amount of the underlying asset the account would repay\n     * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function repayBorrowAllowed(\n        address cToken,\n        address payer,\n        address borrower,\n        uint repayAmount) external returns (uint) {\n        // Shh - currently unused\n        payer;\n        borrower;\n        repayAmount;\n\n        if (!markets[cToken].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        // Keep the flywheel moving\n        Exp memory borrowIndex = Exp({mantissa: CToken(cToken).borrowIndex()});\n        updateCompBorrowIndex(cToken, borrowIndex);\n        distributeBorrowerComp(cToken, borrower, borrowIndex);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Checks if the liquidation should be allowed to occur\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param repayAmount The amount of underlying being repaid\n     */\n    function liquidateBorrowAllowed(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint repayAmount) external returns (uint) {\n        // Shh - currently unused\n        liquidator;\n\n        if (!markets[cTokenBorrowed].isListed || !markets[cTokenCollateral].isListed && cTokenCollateral != address(nftMarket)) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        uint borrowBalance = CToken(cTokenBorrowed).borrowBalanceStored(borrower);\n\n        /* allow accounts to be liquidated if the market is deprecated */\n        if (isDeprecated(CToken(cTokenBorrowed))) {\n            require(borrowBalance >= repayAmount, \"Can not repay more than the total borrow\");\n        } else {\n            /* The borrower must have shortfall in order to be liquidatable */\n            (Error err, , uint shortfall) = getAccountLiquidityInternal(borrower);\n            if (err != Error.NO_ERROR) {\n                return uint(err);\n            }\n\n            if (shortfall == 0) {\n                return uint(Error.INSUFFICIENT_SHORTFALL);\n            }\n\n            /* The liquidator may not repay more than what is allowed by the closeFactor */\n            uint maxClose = mul_ScalarTruncate(Exp({mantissa: closeFactorMantissa}), borrowBalance);\n            if (repayAmount > maxClose) {\n                return uint(Error.TOO_MUCH_REPAY);\n            }\n        }\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Checks if the seizing of assets should be allowed to occur\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param seizeTokens The number of collateral tokens to seize\n     */\n    function seizeAllowed(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint seizeTokens) external returns (uint) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!seizeGuardianPaused, \"seize is paused\");\n\n        // Shh - currently unused\n        seizeTokens;\n\n        if (!markets[cTokenCollateral].isListed || !markets[cTokenBorrowed].isListed) {\n            return uint(Error.MARKET_NOT_LISTED);\n        }\n\n        if (CToken(cTokenCollateral).comptroller() != CToken(cTokenBorrowed).comptroller()) {\n            return uint(Error.COMPTROLLER_MISMATCH);\n        }\n\n        // Keep the flywheel moving\n        // updateCompSupplyIndex(cTokenCollateral);\n        // distributeSupplierComp(cTokenCollateral, borrower);\n        // distributeSupplierComp(cTokenCollateral, liquidator);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to transfer tokens in the given market\n     * @param cAsset The market to verify the transfer against\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     * @param transferTokens The number of cTokens to transfer\n     * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function transferAllowed(address cAsset, address src, address dst, uint transferTokens) external returns (uint) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!transferGuardianPaused, \"transfer is paused\");\n\n        // Currently the only consideration is whether or not\n        //  the src is allowed to redeem this many tokens\n        uint allowed = redeemAllowedInternal(cAsset, src, transferTokens);\n        if (allowed != uint(Error.NO_ERROR)) {\n            return allowed;\n        }\n\n        // Keep the flywheel moving\n        // updateCompSupplyIndex(cAsset);\n        // distributeSupplierComp(cAsset, src);\n        // distributeSupplierComp(cAsset, dst);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /*** Liquidity/Liquidation Calculations ***/\n\n    /**\n     * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\n     *  Note that `cTokenBalance` is the number of cTokens the account owns in the market,\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\n     */\n    struct AccountLiquidityLocalVars {\n        uint sumCollateral;\n        uint sumBorrowPlusEffects;\n        uint cTokenBalance;\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n        uint oraclePriceMantissa;\n        uint nftOraclePriceMantissa;\n        Exp collateralFactor;\n        Exp nftCollateralFactor;\n        Exp exchangeRate;\n        Exp oraclePrice;\n        Exp nftOraclePrice;\n        Exp tokensToDenom;\n    }\n\n    /**\n     * @notice Determine the current account liquidity wrt collateral requirements\n     * @return (possible error code (semi-opaque),\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, address(0), 0, 0);\n\n        return (uint(err), liquidity, shortfall);\n    }\n\n    /**\n     * @notice Determine the current account liquidity wrt collateral requirements\n     * @return (possible error code,\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n    function getAccountLiquidityInternal(address account) internal view returns (Error, uint, uint) {\n        return getHypotheticalAccountLiquidityInternal(account, address(0), 0, 0);\n    }\n\n    /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param cAssetModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @return (possible error code (semi-opaque),\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n    function getHypotheticalAccountLiquidity(\n        address account,\n        address cAssetModify,\n        uint redeemTokens,\n        uint borrowAmount) public view returns (uint, uint, uint) {\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, cAssetModify, redeemTokens, borrowAmount);\n        return (uint(err), liquidity, shortfall);\n    }\n\n    /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param cAssetModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @dev Note that we calculate the exchangeRateStored for each collateral cToken using stored data,\n     *  without calculating accumulated interest.\n     * @return (possible error code,\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n    function getHypotheticalAccountLiquidityInternal(\n        address account,\n        address cAssetModify,\n        uint redeemTokens,\n        uint borrowAmount) internal view returns (Error, uint, uint) {\n\n        AccountLiquidityLocalVars memory vars; // Holds all our calculation results\n        uint oErr;\n\n        // For each asset the account is in\n        CToken[] memory assets = accountAssets[account];\n        for (uint i = 0; i < assets.length; i++) {\n            CToken asset = assets[i];\n\n            // Read the balances and exchange rate from the cToken\n            (oErr, vars.cTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(account);\n            if (oErr != 0) { // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\n                return (Error.SNAPSHOT_ERROR, 0, 0);\n            }\n            vars.collateralFactor = Exp({mantissa: markets[address(asset)].collateralFactorMantissa});\n            vars.exchangeRate = Exp({mantissa: vars.exchangeRateMantissa});\n\n            // Get the normalized price of the asset\n            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);\n            if (vars.oraclePriceMantissa == 0) {\n                return (Error.PRICE_ERROR, 0, 0);\n            }\n            vars.oraclePrice = Exp({mantissa: vars.oraclePriceMantissa});\n\n            // Pre-compute a conversion factor from tokens -> ether (normalized price value)\n            vars.tokensToDenom = mul_(mul_(vars.collateralFactor, vars.exchangeRate), vars.oraclePrice);\n\n            // sumCollateral += tokensToDenom * cTokenBalance\n            vars.sumCollateral = mul_ScalarTruncateAddUInt(vars.tokensToDenom, vars.cTokenBalance, vars.sumCollateral);\n\n            // sumBorrowPlusEffects += oraclePrice * borrowBalance\n            vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.oraclePrice, vars.borrowBalance, vars.sumBorrowPlusEffects);\n\n            // Calculate effects of interacting with cAssetModify\n            if (address(asset) == cAssetModify) {\n                // redeem effect\n                // sumBorrowPlusEffects += tokensToDenom * redeemTokens\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.tokensToDenom, redeemTokens, vars.sumBorrowPlusEffects);\n\n                // borrow effect\n                // sumBorrowPlusEffects += oraclePrice * borrowAmount\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.oraclePrice, borrowAmount, vars.sumBorrowPlusEffects);\n            }\n        }\n\n        uint256 nftBalance = nftMarket.totalBalance(account);\n        if (nftBalance > 0) {\n            // Get the price of the NFT and the collateral factor\n            vars.nftOraclePriceMantissa =  nftOracle.getUnderlyingPrice(nftMarket);\n            if (vars.nftOraclePriceMantissa == 0) {\n                return (Error.PRICE_ERROR, 0, 0);\n            }\n            vars.nftOraclePrice = Exp({mantissa: vars.nftOraclePriceMantissa});\n            vars.nftCollateralFactor = Exp({mantissa: markets[address(nftMarket)].collateralFactorMantissa});\n\n            // sumCollateral += nftOraclePrice * collateralFactor * nftBalance\n            vars.sumCollateral = mul_ScalarTruncateAddUInt(mul_(vars.nftOraclePrice, markets[address(nftMarket)].collateralFactorMantissa), nftBalance, vars.sumCollateral);\n            if (cAssetModify == address(nftMarket)) {\n                require(borrowAmount == 0, \"cannot borrow NFT\");\n                // sumBorrowPlusEffects += nftOraclePrice * collateralFactor * redeemTokens\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(mul_(vars.nftOraclePrice, markets[address(nftMarket)].collateralFactorMantissa), redeemTokens, vars.sumBorrowPlusEffects);\n            }\n        }\n\n        // These are safe, as the underflow condition is checked first\n        if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\n            return (Error.NO_ERROR, vars.sumCollateral - vars.sumBorrowPlusEffects, 0);\n        } else {\n            return (Error.NO_ERROR, 0, vars.sumBorrowPlusEffects - vars.sumCollateral);\n        }\n    }\n\n    /**\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\n     * @dev Used in liquidation (called in cToken.liquidateBorrowFresh)\n     * @param cTokenBorrowed The address of the borrowed cToken\n     * @param cTokenCollateral The address of the collateral cToken\n     * @param actualRepayAmount The amount of cTokenBorrowed underlying to convert into cTokenCollateral tokens\n     * @return (errorCode, number of cTokenCollateral tokens to be seized in a liquidation)\n     */\n    function liquidateCalculateSeizeTokens(address cTokenBorrowed, address cTokenCollateral, uint actualRepayAmount) external view returns (uint, uint) {\n        /* Read oracle prices for borrowed and collateral markets */\n        uint priceBorrowedMantissa = oracle.getUnderlyingPrice(CToken(cTokenBorrowed));\n        uint priceCollateralMantissa = oracle.getUnderlyingPrice(CToken(cTokenCollateral));\n        if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {\n            return (uint(Error.PRICE_ERROR), 0);\n        }\n\n        /*\n         * Get the exchange rate and calculate the number of collateral tokens to seize:\n         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\n         *  seizeTokens = seizeAmount / exchangeRate\n         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\n         */\n        uint exchangeRateMantissa = CToken(cTokenCollateral).exchangeRateStored(); // Note: reverts on error\n        uint seizeTokens;\n        Exp memory numerator;\n        Exp memory denominator;\n        Exp memory ratio;\n\n        numerator = mul_(Exp({mantissa: liquidationIncentiveMantissa}), Exp({mantissa: priceBorrowedMantissa}));\n        denominator = mul_(Exp({mantissa: priceCollateralMantissa}), Exp({mantissa: exchangeRateMantissa}));\n        ratio = div_(numerator, denominator);\n\n        seizeTokens = mul_ScalarTruncate(ratio, actualRepayAmount);\n\n        return (uint(Error.NO_ERROR), seizeTokens);\n    }\n\n    /**\n     * @notice Calculate number of cNFT tokens to seize given an underlying amount\n     * @dev Used in liquidation (called in cToken.liquidateBorrowFreshNft)\n     * @param cTokenBorrowed The address of the borrowed cToken\n     * @param actualRepayAmount The amount of cTokenBorrowed underlying to convert into NFTs\n     * @return (errorCode, number of cNft tokens to be seized in a liquidation)\n     */\n    function liquidateCalculateSeizeNfts(address cTokenBorrowed, address cNftCollateral, uint actualRepayAmount) external view returns (uint, uint) {\n        require(cNftCollateral == address(nftMarket), \"cNFT is from the wrong comptroller\");\n\n        /* Read oracle prices for borrowed and collateral markets */\n        uint priceBorrowedMantissa = oracle.getUnderlyingPrice(CToken(cTokenBorrowed));\n        uint priceCollateralMantissa = nftOracle.getUnderlyingPrice(nftMarket);\n        if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {\n            return (uint(Error.PRICE_ERROR), 0);\n        }\n\n        /*\n         * Get the exchange rate and calculate the number of collateral tokens to seize:\n         *  seizeTokens = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\n         */\n        uint seizeTokens;\n        Exp memory numerator;\n        Exp memory denominator;\n        Exp memory ratio;\n\n        numerator = mul_(Exp({mantissa: liquidationIncentiveMantissa}), Exp({mantissa: priceBorrowedMantissa}));\n        denominator = Exp({mantissa: priceCollateralMantissa});\n        ratio = div_(numerator, denominator);\n\n        seizeTokens = truncate(mul_(ratio, Exp({mantissa: actualRepayAmount})));\n\n        return (uint(Error.NO_ERROR), seizeTokens);\n    }\n\n    /*** Admin Functions ***/\n\n    function _changeAdmin(address newAdmin) external {\n        require(msg.sender == admin, \"Only admin can change the admin\");\n        admin = newAdmin;\n    }\n\n    /**\n      * @notice Sets a new price oracle for the comptroller\n      * @dev Admin function to set a new price oracle\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function _setPriceOracle(PriceOracle newOracle) public returns (uint) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\n        }\n\n        // Track the old oracle for the comptroller\n        PriceOracle oldOracle = oracle;\n\n        // Set comptroller's oracle to newOracle\n        oracle = newOracle;\n\n        // Emit NewPrice"
    }
  ]
}