{
  "Title": "H-1: Fees aren't distributed properly for positions with multiple lenders, causing loss of funds for lenders",
  "Content": "# Issue H-1: Fees aren't distributed properly for positions with multiple lenders, causing loss of funds for lenders \n\nSource: https://github.com/sherlock-audit/2024-02-leverage-contracts-judging/issues/41 \n\n## Found by \n0xDetermination, zraxx\n## Summary\nFees distributed are calculated according to a lender's amount lent divided by the total amount lent, which causes more recent lenders to steal fees from older lenders.\n## Vulnerability Detail\nThe fees distributed to each lender are determined by the following calculation (https://github.com/sherlock-audit/2024-02-leverage-contracts/blob/main/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L546-L549):\n```solidity\n                uint256 feesAmt = FullMath.mulDiv(feesOwed, cache.holdTokenDebt, borrowedAmount); //fees owed multiplied by the individual amount lent, divided by the total amount lent\n                ...\n                loansFeesInfo[creditor][cache.holdToken] += feesAmt;\n                harvestedAmt += feesAmt;\n```\nThe above is from `harvest()`; `repay()` calculates the fees similarly. Because `borrow()` doesn't distribute fees, the following scenario will occur when a borrower increases an existing position:\n1. Borrower has an existing position with fees not yet collected by the lenders.\n2. Borrower increases the position with a loan from a new lender.\n3. `harvest()` or `repay()` is called, and the new lender is credited with some of the previous fees earned by the other lenders due to the fees calculation. Other lenders lose fees.\n\nThis scenario can naturally occur during the normal functioning of the protocol, or a borrower/attacker with a position with a large amount of uncollected fees can maliciously open a proportionally large loan with an attacker to steal most of the fees.\n\nAlso note that ANY UDPATE ISSUE? LOW PRIO\n## Impact\nLoss of funds for lenders, potential for borrowers to steal fees.\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-02-leverage-contracts/blob/main/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L546-L549\n## Tool used\n\nManual Review\n\n## Recommendation\nA potential fix is to harvest fees in the borrow() function; the scenario above will no longer be possible.\n\n\n\n## Discussion\n\n**sherlock-admin**\n\nThe protocol team fixed this issue in PR/commit https://github.com/RealWagmi/wagmi-leverage/commit/84416fcedfcc7eb062917bdc69f919bba9d3c0b7.\n\n**fann95**\n\nYes, the problem existed and is associated with the same error as #39.\nThis issue is related to an erroneous scheme for accumulating fees and affected almost all functions in the contract, so the PR turned out to be quite large.\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid: high(1)\n\n\n\n**nevillehuang**\n\nSee comments [here](https://github.com/sherlock-audit/2024-02-leverage-contracts-judging/issues/40#issuecomment-1982026558)\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/234",
  "Code": [
    {
      "filename": "wagmi-leverage/contracts/LiquidityBorrowingManager.sol",
      "content": "// SPDX-License-Identifier: SAL-1.0\n\n/**\n * WAGMI Leverage Protocol v1.2\n * wagmi.com\n */\n\npragma solidity 0.8.21;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./abstract/LiquidityManager.sol\";\nimport \"./abstract/OwnerSettings.sol\";\nimport \"./abstract/DailyRateAndCollateral.sol\";\nimport \"./libraries/ErrLib.sol\";\nimport \"./interfaces/ILiquidityBorrowingManager.sol\";\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n/**\n * @title LiquidityBorrowingManager\n * @dev This contract manages the borrowing liquidity functionality for WAGMI Leverage protocol.\n * It inherits from LiquidityManager, OwnerSettings, DailyRateAndCollateral, and ReentrancyGuard contracts.\n */\ncontract LiquidityBorrowingManager is\n    ILiquidityBorrowingManager,\n    LiquidityManager,\n    OwnerSettings,\n    DailyRateAndCollateral,\n    ReentrancyGuard\n{\n    using { ErrLib.revertError } for bool;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    /// borrowingKey=>LoanInfo\n    mapping(bytes32 => LoanInfo[]) private loansInfo;\n    /// borrowingKey=>BorrowingInfo\n    mapping(bytes32 => BorrowingInfo) public borrowingsInfo;\n    /// NonfungiblePositionManager tokenId => EnumerableSet.Bytes32Set\n    mapping(uint256 => EnumerableSet.Bytes32Set) private tokenIdToBorrowingKeys;\n    /// borrower => EnumerableSet.Bytes32Set\n    mapping(address => EnumerableSet.Bytes32Set) private userBorrowingKeys;\n    ///  token => FeesAmt\n    mapping(address => uint256) private platformsFeesInfo;\n\n    /// @dev Modifier to check if the current block timestamp is before or equal to the deadline.\n    modifier checkDeadline(uint256 deadline) {\n        (_blockTimestamp() > deadline).revertError(ErrLib.ErrorCode.TOO_OLD_TRANSACTION);\n        _;\n    }\n\n    modifier onlyOperator() {\n        (msg.sender != operator).revertError(ErrLib.ErrorCode.INVALID_CALLER);\n        _;\n    }\n\n    function _blockTimestamp() internal view returns (uint256) {\n        return block.timestamp;\n    }\n\n    constructor(\n        address _underlyingPositionManagerAddress,\n        address _lightQuoterV3,\n        address _underlyingV3Factory,\n        bytes32 _underlyingV3PoolInitCodeHash\n    )\n        LiquidityManager(\n            _underlyingPositionManagerAddress,\n            _lightQuoterV3,\n            _underlyingV3Factory,\n            _underlyingV3PoolInitCodeHash\n        )\n    {}\n\n    /**\n     * @dev Adds or removes a swap call params to the whitelist.\n     * @param swapTarget The address of the target contract for the swap call.\n     * @param funcSelector The function selector of the swap call.\n     * @param isAllowed A boolean indicating whether the swap call is allowed or not.\n     */\n    function setSwapCallToWhitelist(\n        address swapTarget,\n        bytes4 funcSelector,\n        bool isAllowed\n    ) external onlyOwner {\n        (swapTarget == VAULT_ADDRESS ||\n            swapTarget == address(this) ||\n            swapTarget == address(underlyingPositionManager) ||\n            funcSelector == IERC20.transferFrom.selector).revertError(ErrLib.ErrorCode.FORBIDDEN);\n        whitelistedCall[swapTarget][funcSelector] = isAllowed;\n    }\n\n    /**\n     * @notice This function allows the owner to collect protocol fees for multiple tokens\n     * and transfer them to a specified recipient.\n     * @dev Only the contract owner can call this function.\n     * @param recipient The address of the recipient who will receive the collected fees.\n     * @param tokens An array of addresses representing the tokens for which fees will be collected.\n     */\n    function collectProtocol(address recipient, address[] calldata tokens) external onlyOwner {\n        uint256[] memory amounts = _collect(platformsFeesInfo, recipient, tokens);\n\n        emit CollectProtocol(recipient, tokens, amounts);\n    }\n\n    /**\n     * @notice This function allows the caller to collect their own loan fees for multiple tokens\n     * and transfer them to themselves.\n     * @param tokens An array of addresses representing the tokens for which fees will be collected.\n     */\n    function collectLoansFees(address[] calldata tokens) external {\n        mapping(address => uint256) storage collection = loansFeesInfo[msg.sender];\n        uint256[] memory amounts = _collect(collection, msg.sender, tokens);\n\n        emit CollectLoansFees(msg.sender, tokens, amounts);\n    }\n\n    /**\n     * @notice This function is used to update the daily rate for holding token for specific pair.\n     * @dev Only the daily rate operator can call this function.\n     * @param saleToken The address of the sale token.\n     * @param holdToken The address of the hold token.\n     * @param value The new value of the daily rate for the hold token will be calculated based\n     * on the volatility of the pair and the popularity of loans in it\n     * @dev The value must be within the range of MIN_DAILY_RATE and MAX_DAILY_RATE.\n     */\n    function updateHoldTokenDailyRate(\n        address saleToken,\n        address holdToken,\n        uint256 value\n    ) external onlyOperator {\n        if (value > Constants.MAX_DAILY_RATE || value < Constants.MIN_DAILY_RATE) {\n            revert InvalidSettingsValue(value);\n        }\n        // If the value is within the acceptable range, the function updates the currentDailyRate property\n        // of the holdTokenRateInfo structure associated with the token pair.\n        (, TokenInfo storage holdTokenRateInfo) = _updateHoldTokenRateInfo(saleToken, holdToken);\n        holdTokenRateInfo.currentDailyRate = value;\n        emit UpdateHoldTokenDailyRate(saleToken, holdToken, value);\n    }\n\n    function updateHoldTokenEntranceFee(\n        address saleToken,\n        address holdToken,\n        uint256 value\n    ) external onlyOperator {\n        if (value > Constants.MAX_ENTRANCE_FEE_BPS) {\n            revert InvalidSettingsValue(value);\n        }\n        // If the value is within the acceptable range, the function updates the currentDailyRate property\n        // of the holdTokenRateInfo structure associated with the token pair.\n        (, TokenInfo storage holdTokenEntranceFeeInfo) = _updateHoldTokenRateInfo(\n            saleToken,\n            holdToken\n        );\n        holdTokenEntranceFeeInfo.entranceFeeBP = value;\n        emit UpdateHoldTokeEntranceFee(saleToken, holdToken, value);\n    }\n\n    /**\n     * @notice This function is used to check the daily rate collateral for a specific borrowing.\n     * @param borrowingKey The key of the borrowing.\n     * @return balance The balance of the daily rate collateral.\n     * @return estimatedLifeTime The estimated lifetime of the collateral in seconds.\n     */\n    function checkDailyRateCollateral(\n        bytes32 borrowingKey\n    ) external view returns (int256 balance, uint256 estimatedLifeTime) {\n        (, balance, estimatedLifeTime) = _getDebtInfo(borrowingKey);\n        balance /= int256(Constants.COLLATERAL_BALANCE_PRECISION);\n    }\n\n    /**\n     * @notice Get information about loans associated with a borrowing key\n     * @dev This function retrieves an array of loan information for a given borrowing key.\n     * The loans are stored in the loansInfo mapping, which is a mapping of borrowing keys to LoanInfo arrays.\n     * @param borrowingKey The unique key associated with the borrowing\n     * @return loans An array containing LoanInfo structs representing the loans associated with the borrowing key\n     */\n    function getLoansInfo(bytes32 borrowingKey) external view returns (LoanInfo[] memory loans) {\n        loans = loansInfo[borrowingKey];\n    }\n\n    /**\n     * @notice Retrieves the borrowing information for a specific NonfungiblePositionManager tokenId.\n     * @param tokenId The unique identifier of the PositionManager token.\n     * @return extinfo An array of BorrowingInfoExt structs representing the borrowing information.\n     */\n    function getLenderCreditsInfo(\n        uint256 tokenId\n    ) external view returns (BorrowingInfoExt[] memory extinfo) {\n        bytes32[] memory borrowingKeys = getBorrowingKeysForTokenId(tokenId);\n        extinfo = _getDebtsInfo(borrowingKeys);\n    }\n\n    /**\n     * @dev Retrieves the borrowing keys associated with a token ID.\n     * @param tokenId The identifier of the token.\n     * @return borrowingKeys An array of borrowing keys.\n     */\n    function getBorrowingKeysForTokenId(\n        uint256 tokenId\n    ) public view returns (bytes32[] memory borrowingKeys) {\n        borrowingKeys = tokenIdToBorrowingKeys[tokenId].values();\n    }\n\n    /**\n     * @dev Retrieves the borrowing keys for a specific borrower.\n     * @param borrower The address of the borrower.\n     * @return borrowingKeys An array of borrowing keys.\n     */\n    function getBorrowingKeysForBorrower(\n        address borrower\n    ) public view returns (bytes32[] memory borrowingKeys) {\n        borrowingKeys = userBorrowingKeys[borrower].values();\n    }\n\n    /**\n     * @notice Retrieves the debts information for a specific borrower.\n     * @param borrower The address of the borrower.\n     * @return extinfo An array of BorrowingInfoExt structs representing the borrowing information.\n     */\n    function getBorrowerDebtsInfo(\n        address borrower\n    ) external view returns (BorrowingInfoExt[] memory extinfo) {\n        bytes32[] memory borrowingKeys = userBorrowingKeys[borrower].values();\n        extinfo = _getDebtsInfo(borrowingKeys);\n    }\n\n    /**\n     * @dev Returns the number of loans associated with a given NonfungiblePositionManager tokenId.\n     * @param tokenId The ID of the token.\n     * @return count The total number of loans associated with the tokenId.\n     */\n    function getLenderCreditsCount(uint256 tokenId) external view returns (uint256 count) {\n        count = tokenIdToBorrowingKeys[tokenId].length();\n    }\n\n    /**\n     * @dev Returns the number of borrowings for a given borrower.\n     * @param borrower The address of the borrower.\n     * @return count The total number of borrowings for the borrower.\n     */\n    function getBorrowerDebtsCount(address borrower) external view returns (uint256 count) {\n        count = userBorrowingKeys[borrower].length();\n    }\n\n    /**\n     * @dev Returns the current daily rate for holding token.\n     * @param saleToken The address of the token being sold.\n     * @param holdToken The address of the token being held.\n     * @return  holdTokenRateInfo The structured data containing detailed information for the hold token.\n     */\n    function getHoldTokenInfo(\n        address saleToken,\n        address holdToken\n    ) external view returns (TokenInfo memory holdTokenRateInfo) {\n        holdTokenRateInfo = _getHoldTokenInfo(saleToken, holdToken);\n    }\n\n    /**\n     * @dev Returns the fees information for multiple tokens in an array.\n     * @param feesOwner The address of the owner of the fees.\n     * @param tokens An array of token addresses for which the fees are to be retrieved.\n     * @return fees An array containing the fees for each token.\n     */\n    function getFeesInfo(\n        address feesOwner,\n        address[] calldata tokens\n    ) external view returns (uint256[] memory fees) {\n        mapping(address => uint256) storage collection = loansFeesInfo[feesOwner];\n        fees = _getFees(collection, tokens);\n    }\n\n    /**\n     * @dev Get the platform fees information for a list of tokens.\n     *\n     * This function returns an array of fees corresponding to the list of input tokens provided.\n     * Each fee is retrieved from the `platformsFeesInfo` mapping which stores the fee for each token address.\n     *\n     * @param tokens An array of token addresses for which to retrieve the fees information.\n     * @return fees Returns an array of fees, one per each token given as input in the same order.\n     */\n    function getPlatformFeesInfo(\n        address[] calldata tokens\n    ) external view returns (uint256[] memory fees) {\n        mapping(address => uint256) storage collection = platformsFeesInfo;\n        fees = _getFees(collection, tokens);\n    }\n\n    /**\n     * @dev Calculates the liquidation bonus for a given token, borrowed amount, and times factor.\n     * @param token The address of the token.\n     * @param borrowedAmount The amount of tokens borrowed.\n     * @param times The times factor to apply to the liquidation bonus calculation.\n     * @return liquidationBonus The calculated liquidation bonus.\n     */\n    function getLiquidationBonus(\n        address token,\n        uint256 borrowedAmount,\n        uint256 times\n    ) public view returns (uint256 liquidationBonus) {\n        // Retrieve liquidation bonus for the given token\n        Liquidation memory liq = liquidationBonusForToken[token];\n\n        if (liq.bonusBP == 0) {\n            // If there is no specific bonus for the token\n            // Use default bonus\n            liq.minBonusAmount = Constants.MINIMUM_AMOUNT;\n            liq.bonusBP = dafaultLiquidationBonusBP;\n        }\n        liquidationBonus = (borrowedAmount * liq.bonusBP) / Constants.BP;\n\n        if (liquidationBonus < liq.minBonusAmount) {\n            liquidationBonus = liq.minBonusAmount;\n        }\n        liquidationBonus *= (times > 0 ? times : 1);\n    }\n\n    /**\n     * @dev Calculates the collateral amount required for a lifetime in seconds.\n     *\n     * @param borrowingKey The unique identifier of the borrowing.\n     * @param lifetimeInSeconds The duration of the borrowing in seconds.\n     * @return collateralAmt The calculated collateral amount that is needed.\n     */\n    function calculateCollateralAmtForLifetime(\n        bytes32 borrowingKey,\n        uint256 lifetimeInSeconds\n    ) external view returns (uint256 collateralAmt) {\n        // Retrieve the BorrowingInfo struct associated with the borrowing key\n        BorrowingInfo memory borrowing = borrowingsInfo[borrowingKey];\n        // Check if the borrowed position is existing\n        if (borrowing.borrowedAmount > 0) {\n            // Get the current daily rate for the hold token\n            uint256 currentDailyRate = _getHoldTokenInfo(borrowing.saleToken, borrowing.holdToken)\n                .currentDailyRate;\n            // Calculate the collateral amount per second\n            uint256 everySecond = (\n                FullMath.mulDivRoundingUp(\n                    borrowing.borrowedAmount,\n                    currentDailyRate * Constants.COLLATERAL_BALANCE_PRECISION,\n                    1 days * Constants.BP\n                )\n            );\n            // Calculate the total collateral amount for the borrowing lifetime\n            collateralAmt = FullMath.mulDivRoundingUp(\n                everySecond,\n                lifetimeInSeconds,\n                Constants.COLLATERAL_BALANCE_PRECISION\n            );\n            // Ensure that the collateral amount is at least 1\n            if (collateralAmt == 0) collateralAmt = 1;\n        }\n    }\n\n    /**\n     * @notice This function is used to increase the daily rate collateral for a specific borrowing.\n     * @param borrowingKey The unique identifier of the borrowing.\n     * @param collateralAmt The amount of collateral to be added.\n     * @param deadline The deadline timestamp after which the transaction is considered invalid.\n     */\n    function increaseCollateralBalance(\n        bytes32 borrowingKey,\n        uint256 collateralAmt,\n        uint256 deadline\n    ) external checkDeadline(deadline) {\n        BorrowingInfo storage borrowing = borrowingsInfo[borrowingKey];\n        // Ensure that the borrowed position exists and the borrower is the message sender\n        (borrowing.borrowedAmount == 0 || borrowing.borrower != address(msg.sender)).revertError(\n            ErrLib.ErrorCode.INVALID_BORROWING_KEY\n        );\n        // Increase the daily rate collateral balance by the specified collateral amount\n        borrowing.dailyRateCollateralBalance +=\n            collateralAmt *\n            Constants.COLLATERAL_BALANCE_PRECISION;\n        _pay(borrowing.holdToken, msg.sender, VAULT_ADDRESS, collateralAmt);\n        emit IncreaseCollateralBalance(msg.sender, borrowingKey, collateralAmt);\n    }\n\n    /**\n     * @notice Borrow function allows a user to borrow tokens by providing collateral and taking out loans.\n     * The trader opens a long position by borrowing the liquidity of Uniswap V3 and extracting it into a pair of tokens,\n     * one of which will be swapped into a desired(holdToken).The tokens will be kept in storage until the position is closed.\n     * The margin is calculated on the basis that liquidity must be restored with any price movement.\n     * The time the position is held is paid by the trader.\n     * @dev Emits a Borrow event upon successful borrowing.\n     * @param params The BorrowParams struct containing the necessary parameters for borrowing.\n     * @param deadline The deadline timestamp after which the transaction is considered invalid.\n     *\n     * @return borrowedAmount The total amount of `params.holdToken` borrowed.\n     * @return marginDeposit The required collateral deposit amount for initiating the loan.\n     * @return liquidationBonus An additional amount added to the debt as a bonus in case of liquidation.\n     * @return dailyRateCollateral The collateral deposit to hold the transaction for a day.\n     */\n    function borrow(\n        BorrowParams calldata params,\n        uint256 deadline\n    )\n        external\n        nonReentrant\n        checkDeadline(deadline)\n        returns (uint256, uint256, uint256, uint256, uint256)\n    {\n        // Precalculating borrowing details and storing them in cache\n        BorrowCache memory cache = _precalculateBorrowing(params);\n        // Initializing borrowing variables and obtaining borrowing key\n        (\n            uint256 feesDebt,\n            bytes32 borrowingKey,\n            BorrowingInfo storage borrowing\n        ) = _initOrUpdateBorrowing(\n                params.saleToken,\n                params.holdToken,\n                cache.accLoanRatePerSeconds,\n                cache.holdTokenEntraceFee\n            );\n        uint256 liquidationBonus;\n        {\n            // Adding borrowing key and loans information to storage\n            uint256 pushCounter = _addKeysAndLoansInfo(borrowingKey, params.loans);\n            // Calculating liquidation bonus based on hold token, borrowed amount, and number of used loans\n            liquidationBonus = getLiquidationBonus(\n                params.holdToken,\n                cache.borrowedAmount,\n                pushCounter\n            );\n        }\n        uint256 marginDeposit;\n        // positive slippage\n        if (cache.holdTokenBalance > cache.borrowedAmount) {\n            // Thus, we stimulate the platform to look for the best conditions for swapping on external aggregators.\n            platformsFeesInfo[params.holdToken] +=\n                (cache.holdTokenBalance - cache.borrowedAmount) *\n                Constants.COLLATERAL_BALANCE_PRECISION;\n        } else {\n            marginDeposit = cache.borrowedAmount - cache.holdTokenBalance;\n            (marginDeposit > params.maxMarginDeposit).revertError(\n                ErrLib.ErrorCode.TOO_BIG_MARGIN_DEPOSIT\n            );\n        }\n\n        // Updating borrowing details\n        borrowing.borrowedAmount += cache.borrowedAmount;\n        borrowing.liquidationBonus += liquidationBonus;\n        borrowing.dailyRateCollateralBalance +=\n            cache.dailyRateCollateral *\n            Constants.COLLATERAL_BALANCE_PRECISION;\n        //\n        cache.holdTokenEntraceFee =\n            cache.holdTokenEntraceFee /\n            Constants.COLLATERAL_BALANCE_PRECISION +\n            1;\n\n        // Transfer the required tokens to the VAULT_ADDRESS for collateral and holdTokenBalance\n        _pay(\n            params.holdToken,\n            msg.sender,\n            VAULT_ADDRESS,\n            marginDeposit +\n                liquidationBonus +\n                cache.dailyRateCollateral +\n                feesDebt +\n                cache.holdTokenEntraceFee\n        );\n        // Transferring holdTokenBalance to VAULT_ADDRESS\n        _pay(params.holdToken, address(this), VAULT_ADDRESS, cache.holdTokenBalance);\n        // Emit the Borrow event with the borrower, borrowing key, and borrowed amount\n        emit Borrow(\n            msg.sender,\n            borrowingKey,\n            cache.borrowedAmount,\n            marginDeposit,\n            liquidationBonus,\n            cache.dailyRateCollateral,\n            feesDebt,\n            cache.holdTokenEntraceFee\n        );\n        return (\n            cache.borrowedAmount,\n            marginDeposit,\n            liquidationBonus,\n            cache.dailyRateCollateral,\n            cache.holdTokenEntraceFee\n        );\n    }\n\n    /**\n     * @notice Allows lenders to harvest the fees accumulated from their loans.\n     * @dev Retrieves and updates fee amounts for all loans associated with a borrowing position.\n     * The function iterates through each loan, calculating and updating the amount of fees due.\n     *\n     * Requirements:\n     * - The borrowingKey must correspond to an active and valid borrowing position.\n     * - The collateral balance must be above zero or the current fees must be above the minimum required amount.\n     *\n     * @param borrowingKey The unique identifier for the specific borrowing position.\n     *\n     * @return harvestedAmt The total amount of fees harvested by the borrower.\n     */\n    function harvest(bytes32 borrowingKey) external nonReentrant returns (uint256 harvestedAmt) {\n        BorrowingInfo storage borrowing = borrowingsInfo[borrowingKey];\n        // Check if the borrowing key is valid\n        _existenceCheck(borrowing.borrowedAmount);\n\n        // Update token rate information and get holdTokenRateInfo storage reference\n        (, TokenInfo storage holdTokenRateInfo) = _updateHoldTokenRateInfo(\n            borrowing.saleToken,\n            borrowing.holdToken\n        );\n\n        // Calculate collateral balance and validate caller\n        (int256 collateralBalance, uint256 currentFees) = _calculateCollateralBalance(\n            borrowing.borrowedAmount,\n            borrowing.accLoanRatePerSeconds,\n            borrowing.dailyRateCollateralBalance,\n            holdTokenRateInfo.accLoanRatePerSeconds\n        );\n\n        (collateralBalance < 0 ||\n            currentFees < Constants.MINIMUM_AMOUNT * Constants.COLLATERAL_BALANCE_PRECISION)\n            .revertError(ErrLib.ErrorCode.FORBIDDEN);\n\n        // Calculate platform fees and adjust fees owed\n        borrowing.dailyRateCollateralBalance -= currentFees;\n        borrowing.feesOwed += _pickUpPlatformFees(borrowing.holdToken, currentFees);\n        // Set the accumulated loan rate per second for the borrowing position\n        borrowing.accLoanRatePerSeconds = holdTokenRateInfo.accLoanRatePerSeconds;\n\n        uint256 feesOwed = borrowing.feesOwed;\n        uint256 borrowedAmount = borrowing.borrowedAmount;\n\n        bool zeroForSaleToken = borrowing.saleToken < borrowing.holdToken;\n\n        // Create a memory struct to store liquidity cache information.\n        NftPositionCache memory cache;\n        // Get the array of LoanInfo structs associated with the given borrowing key.\n        LoanInfo[] memory loans = loansInfo[borrowingKey];\n        // Iterate through each loan in the loans array.\n        for (uint256 i; i < loans.length; ) {\n            LoanInfo memory loan = loans[i];\n            // Get the owner address of the loan's token ID using the underlyingPositionManager contract.\n            address creditor = _getOwnerOf(loan.tokenId);\n            // Check if the owner of the loan's token ID is equal to the `msg.sender`.\n            if (creditor != address(0)) {\n                // Update the liquidity cache based on the loan information.\n                _upNftPositionCache(zeroForSaleToken, loan, cache);\n                uint256 feesAmt = FullMath.mulDiv(feesOwed, cache.holdTokenDebt, borrowedAmount);\n                // Calculate the fees amount based on the total fees owed and holdTokenDebt.\n                loansFeesInfo[creditor][cache.holdToken] += feesAmt;\n                harvestedAmt += feesAmt;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        borrowing.feesOwed -= harvestedAmt;\n\n        emit Harvest(borrowingKey, harvestedAmt);\n    }\n\n    /**\n     * @notice Used for repaying loans, optionally with liquidation or emergency liquidity withdrawal.\n     * The position is closed either by the trader or by the liquidator if the trader has not paid for holding the position\n     * and the moment of liquidation has arrived.The positions borrowed from liquidation providers are restored from the held\n     * token and the remainder is sent to the caller.In the event of liquidation, the liquidity provider\n     * whose liquidity is present in the traderâ€™s position can use the emergency mode and withdraw their liquidity.In this case,\n     * he will receive hold tokens and liquidity will not be restored in the uniswap pool.\n     * @param params The repayment parameters including\n     *  activation of the emergency liquidity restoration mode (available only to the lender)\n     *  internal swap pool fee,\n     *  external swap parameters,\n     *  borrowing key,\n     *  swap slippage allowance.\n     * @param deadline The deadline by which the repayment must be made.\n     *\n     * @return saleTokenOut The amount of saleToken returned back to the user after repayment.\n     * @return holdTokenOut The amount of holdToken returned back to the user after repayment or emergency withdrawal.\n     */\n    function repay(\n        RepayParams calldata params,\n        uint256 deadline\n    )\n        external\n        nonReentrant\n        checkDeadline(deadline)\n        returns (uint256 saleTokenOut, uint256 holdTokenOut)\n    {\n        BorrowingInfo memory borrowing = borrowingsInfo[params.borrowingKey];\n        // Check if the borrowing key is valid\n        _existenceCheck(borrowing.borrowedAmount);\n\n        bool zeroForSaleToken = borrowing.saleToken < borrowing.holdToken;\n        uint256 liquidationBonus = borrowing.liquidationBonus;\n        int256 collateralBalance;\n        // Update token rate information and get holdTokenRateInfo storage reference\n        (, TokenInfo storage holdTokenRateInfo) = _updateHoldTokenRateInfo(\n            borrowing.saleToken,\n            borrowing.holdToken\n        );\n        {\n            // Calculate collateral balance and validate caller\n            uint256 accLoanRatePerSeconds = holdTokenRateInfo.accLoanRatePerSeconds;\n            uint256 currentFees;\n            (collateralBalance, currentFees) = _calculateCollateralBalance(\n                borrowing.borrowedAmount,\n                borrowing.accLoanRatePerSeconds,\n                borrowing.dailyRateCollateralBalance,\n                accLoanRatePerSeconds\n            );\n\n            (msg.sender != borrowing.borrower && collateralBalance >= 0).revertError(\n                ErrLib.ErrorCode.INVALID_CALLER\n            );\n\n            // Calculate liquidation bonus and adjust fees owed\n\n            if (collateralBalance > 0) {\n                uint256 compensation = _calcFeeCompensationUpToMin(\n                    collateralBalance,\n                    currentFees,\n                    borrowing.feesOwed\n                );\n                currentFees += compensation;\n                collateralBalance -= int256(compensation);\n                liquidationBonus +=\n                    uint256(collateralBalance) /\n                    Constants.COLLATERAL_BALANCE_PRECISION;\n            } else {\n                currentFees = borrowing.dailyRateCollateralBalance;\n            }\n\n            // Calculate platform fees and adjust fees owed\n            borrowing.feesOwed += _pickUpPlatformFees(borrowing.holdToken, currentFees);\n        }\n        // Check if it's an emergency repayment\n        if (params.isEmergency) {\n            (collateralBalance >= 0).revertError(ErrLib.ErrorCode.FORBIDDEN);\n            (\n                uint256 removedAmt,\n                uint256 feesAmt,\n                bool completeRepayment\n            ) = _calculateEmergencyLoanClosure(\n                    zeroForSaleToken,\n                    params.borrowingKey,\n                    borrowing.feesOwed,\n                    borrowing.borrowedAmount\n                );\n            (removedAmt == 0).revertError(ErrLib.ErrorCode.LIQUIDITY_IS_ZERO);\n            // Subtract the removed amount and fees from borrowedAmount and feesOwed\n            borrowing.borrowedAmount -= removedAmt;\n            borrowing.feesOwed -= feesAmt;\n            feesAmt /= Constants.COLLATERAL_BALANCE_PRECISION;\n            // Deduct the removed amount from totalBorrowed\n            holdTokenRateInfo.totalBorrowed -= removedAmt;\n            // If loansInfoLength is 0, remove the borrowing key from storage and get the liquidation bonus\n            if (completeRepayment) {\n                LoanInfo[] memory empty;\n                _removeKeysAndClearStorage(borrowing.borrower, params.borrowingKey, empty);\n                feesAmt += liquidationBonus;\n            } else {\n                // make changes to the storage\n                BorrowingInfo storage borrowingStorage = borrowingsInfo[params.borrowingKey];\n                borrowingStorage.dailyRateCollateralBalance = 0;\n                borrowingStorage.feesOwed = borrowing.feesOwed;\n                borrowingStorage.borrowedAmount = borrowing.borrowedAmount;\n            }\n            holdTokenOut = removedAmt + feesAmt;\n            // Transfer removedAmt + feesAmt to msg.sender and emit EmergencyLoanClosure event\n            Vault(VAULT_ADDRESS).transferToken(borrowing.holdToken, msg.sender, holdTokenOut);\n            emit EmergencyLoanClosure(borrowing.borrower, msg.sender, params.borrowingKey);\n        } else {\n            // Deduct borrowedAmount from totalBorrowed\n            holdTokenRateInfo.totalBorrowed -= borrowing.borrowedAmount;\n\n            // Transfer the borrowed amount and liquidation bonus from the VAULT to this contract\n            Vault(VAULT_ADDRESS).transferToken(\n                borrowing.holdToken,\n                address(this),\n                borrowing.borrowedAmount + liquidationBonus\n            );\n\n            if (params.externalSwap.length != 0) {\n                _callExternalSwap(borrowing.holdToken, params.externalSwap);\n            }\n\n            // Restore liquidity using the borrowed amount and pay a daily rate fee\n            LoanInfo[] memory loans = loansInfo[params.borrowingKey];\n            _maxApproveIfNecessary(\n                borrowing.holdToken,\n                address(underlyingPositionManager),\n                type(uint128).max\n            );\n            _maxApproveIfNecessary(\n                borrowing.saleToken,\n                address(underlyingPositionManager),\n                type(uint128).max\n            );\n\n            _restoreLiquidity(\n                RestoreLiquidityParams({\n                    zeroForSaleToken: zeroForSaleToken,\n                    swapPoolfeeTier: params.internalSwapPoolfee,\n                    totalfeesOwed: borrowing.feesOwed,\n                    totalBorrowedAmount: borrowing.borrowedAmount\n                }),\n                loans\n            );\n\n            // Remove borrowing key from related data structures\n            _removeKeysAndClearStorage(borrowing.borrower, params.borrowingKey, loans);\n\n            // Get the remaining balance of saleToken and holdToken\n            (saleTokenOut, holdTokenOut) = _getPairBalance(\n                borrowing.saleToken,\n                borrowing.holdToken\n            );\n\n            if (saleTokenOut > 0 && params.returnOnlyHoldToken) {\n                (, uint256 holdTokenAmountOut) = _simulateSwap(\n                    zeroForSaleToken,\n                    params.internalSwapPoolfee,\n                    borrowing.saleToken, // saleToken is tokenIn\n                    borrowing.holdToken,\n                    saleTokenOut\n                );\n                if (holdTokenAmountOut > 0) {\n                    // Call the internal v3SwapExactInput function\n                    holdTokenOut += _v3SwapExactInput(\n                        v3SwapExactInputParams({\n                            fee: params.internalSwapPoolfee,\n                            tokenIn: borrowing.saleToken,\n                            tokenOut: borrowing.holdToken,\n                            amountIn: saleTokenOut\n                        })\n                    );\n                    saleTokenOut = 0;\n                }\n            }\n\n            (holdTokenOut < params.minHoldTokenOut || saleTokenOut < params.minSaleTokenOut)\n                .revertError(ErrLib.ErrorCode.PRICE_SLIPPAGE_CHECK);\n\n            // Pay a"
    }
  ]
}