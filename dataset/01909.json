{
  "Title": "M-3: convertFromStorage() fails to use rounding-up when converting a negative storedCashBalance into signedPrimeSupplyValue.",
  "Content": "# Issue M-3: convertFromStorage() fails to use rounding-up when converting a negative storedCashBalance into signedPrimeSupplyValue. \n\nSource: https://github.com/sherlock-audit/2023-03-notional-judging/issues/70 \n\n## Found by \nchaduke\n## Summary\n``convertFromStorage()`` fails to use rounding-up when converting a negative ``storedCashBalance`` into ``signedPrimeSupplyValue``.\n\n## Vulnerability Detail\n``convertFromStorage()`` is used to convert ``storedCashBalance`` into ``signedPrimeSupplyValue``. When  ``storedCashBalance`` is negative, it represents a debt - positive prime cash owed.\n\n[https://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/internal/pCash/PrimeRateLib.sol#L60-L74](https://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/internal/pCash/PrimeRateLib.sol#L60-L74)\n\nUnfortunately, when converting a negative  ``storedCashBalance`` into ``signedPrimeSupplyValue``, the following division will apply a rounding-down (near zero) mode, leading to a user to owe less than it is supposed to be. \n\n```javascript\n\nreturn storedCashBalance.mul(pr.debtFactor).div(pr.supplyFactor);\n\n```\n\nThis is not acceptable. Typically, rounding should be in favor of the protocol, not in favor of the user to prevent draining of the protocol and losing funds of the protocol. \n\n\nThe following POC shows a rounding-down will happen for a negative value division. The result of the following test is -3.  \n\n```javascript\n\nfunction testMod() public {\n         \n         int256 result = -14;\n         result = result / 4;\n         console2.logInt(result);\n    }\n\n\n```\n\n## Impact\n``convertFromStorage()`` fails to use rounding-up when converting a negative ``storedCashBalance`` into ``signedPrimeSupplyValue``.  The protocol is losing some dusts amount, but it can be accumulative or a vulnerability that can be exploited. \n\n\n## Code Snippet\n\n## Tool used\nVSCode\n\nManual Review\n\n## Recommendation\nUse rounding-up instead. \n\n```diff\nfunction convertFromStorage(\n        PrimeRate memory pr,\n        int256 storedCashBalance\n    ) internal pure returns (int256 signedPrimeSupplyValue) {\n        if (storedCashBalance >= 0) {\n            return storedCashBalance;\n        } else {\n            // Convert negative stored cash balance to signed prime supply value\n            // signedPrimeSupply = (negativePrimeDebt * debtFactor) / supplyFactor\n\n            // cashBalance is stored as int88, debt factor is uint80 * uint80 so there\n            // is no chance of phantom overflow (88 + 80 + 80 = 248) on mul\n-           return storedCashBalance.mul(pr.debtFactor).div(pr.supplyFactor);\n+         return (storedCashBalance.mul(pr.debtFactor).sub(pr.supplyFactor-1)).div(pr.supplyFactor);\n        }\n    }\n```\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/59",
  "Code": [
    {
      "filename": "contracts-v2/contracts/internal/pCash/PrimeRateLib.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport {\n    PrimeRate,\n    PrimeCashFactors,\n    PrimeCashFactorsStorage,\n    PrimeSettlementRateStorage,\n    MarketParameters,\n    TotalfCashDebtStorage\n} from \"../../global/Types.sol\";\nimport {LibStorage} from \"../../global/LibStorage.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {Deployments} from \"../../global/Deployments.sol\";\n\nimport {FloatingPoint} from \"../../math/FloatingPoint.sol\";\nimport {SafeUint256} from \"../../math/SafeUint256.sol\";\nimport {SafeInt256} from \"../../math/SafeInt256.sol\";\n\nimport {Emitter} from \"../Emitter.sol\";\nimport {BalanceHandler} from \"../balances/BalanceHandler.sol\";\nimport {nTokenHandler} from \"../nToken/nTokenHandler.sol\";\nimport {PrimeCashExchangeRate} from \"./PrimeCashExchangeRate.sol\";\nimport {Market} from \"../markets/Market.sol\";\n\nlibrary PrimeRateLib {\n    using SafeUint256 for uint256;\n    using SafeInt256 for int256;\n    using Market for MarketParameters;\n\n    /// @notice Emitted when a settlement rate is set\n    event SetPrimeSettlementRate(\n        uint256 indexed currencyId,\n        uint256 indexed maturity,\n        int256 supplyFactor,\n        int256 debtFactor\n    );\n\n    /// Prime cash balances are stored differently than they are used on the stack\n    /// and in memory. On the stack, all prime cash balances (positive and negative) are fungible\n    /// with each other and denominated in prime cash supply terms. In storage, negative prime cash\n    /// (i.e. prime cash debt) is is stored in different terms so that it can properly accrue interest\n    /// over time. In other words, positive prime cash balances are static (non-rebasing), but negative\n    /// prime cash balances are monotonically increasing (i.e. rebasing) over time. This is because a\n    /// negative prime cash balance represents an ever increasing amount of positive prime cash owed.\n    ///\n    /// Math is as follows:\n    ///   positivePrimeSupply * supplyFactor = underlying\n    ///   negativePrimeDebt * debtFactor = underlying\n    ///\n    /// Setting them equal:\n    ///   positivePrimeSupply * supplyFactor = negativePrimeDebt * debtFactor\n    ///\n    ///   positivePrimeSupply = (negativePrimeDebt * debtFactor) / supplyFactor\n    ///   negativePrimeDebt = (positivePrimeSupply * supplyFactor) / debtFactor\n    \n    /// @notice Converts stored cash balance into a signed value in prime supply\n    /// terms (see comment above)\n    function convertFromStorage(\n        PrimeRate memory pr,\n        int256 storedCashBalance\n    ) internal pure returns (int256 signedPrimeSupplyValue) {\n        if (storedCashBalance >= 0) {\n            return storedCashBalance;\n        } else {\n            // Convert negative stored cash balance to signed prime supply value\n            // signedPrimeSupply = (negativePrimeDebt * debtFactor) / supplyFactor\n\n            // cashBalance is stored as int88, debt factor is uint80 * uint80 so there\n            // is no chance of phantom overflow (88 + 80 + 80 = 248) on mul\n            return storedCashBalance.mul(pr.debtFactor).div(pr.supplyFactor);\n        }\n    }\n\n    function convertSettledfCashView(\n        PrimeRate memory presentPrimeRate,\n        uint16 currencyId,\n        uint256 maturity,\n        int256 fCashBalance,\n        uint256 blockTime\n    ) internal view returns (int256 signedPrimeSupplyValue) {\n        PrimeRate memory settledPrimeRate = buildPrimeRateSettlementView(currencyId, maturity, blockTime);\n        (signedPrimeSupplyValue, /* */) = _convertSettledfCash(presentPrimeRate, settledPrimeRate, fCashBalance);\n    }\n\n    function convertSettledfCashInVault(\n        uint16 currencyId,\n        uint256 maturity,\n        int256 fCashBalance,\n        address vault\n    ) internal returns (int256 settledPrimeStorageValue) {\n        (PrimeRate memory settledPrimeRate, bool isSet) = _getPrimeSettlementRate(currencyId, maturity);\n        // Requires that the vault has a settlement rate set first. This means that markets have been\n        // initialized already. Vaults cannot have idiosyncratic borrow dates so relying on market initialization\n        // is safe.\n        require(isSet); // dev: settlement rate unset\n\n        // This is exactly how much prime debt the vault owes at settlement.\n        settledPrimeStorageValue = convertUnderlyingToDebtStorage(settledPrimeRate, fCashBalance);\n\n        // Only emit the settle fcash event for the vault, not individual accounts\n        if (vault != address(0)) {\n            Emitter.emitSettlefCash(\n                vault, currencyId, maturity, fCashBalance, settledPrimeStorageValue\n            );\n        }\n    }\n\n    /// @notice Converts settled fCash to the current signed prime supply value\n    function convertSettledfCash(\n        PrimeRate memory presentPrimeRate,\n        address account,\n        uint16 currencyId,\n        uint256 maturity,\n        int256 fCashBalance,\n        uint256 blockTime\n    ) internal returns (int256 signedPrimeSupplyValue) {\n        PrimeRate memory settledPrimeRate = buildPrimeRateSettlementStateful(currencyId, maturity, blockTime);\n\n        int256 settledPrimeStorageValue;\n        (signedPrimeSupplyValue, settledPrimeStorageValue) = _convertSettledfCash(\n            presentPrimeRate, settledPrimeRate, fCashBalance\n        );\n\n        // Allows vault accounts to suppress this event because it is not relevant to them\n        if (account != address(0)) {\n            Emitter.emitSettlefCash(\n                account, currencyId, maturity, fCashBalance, settledPrimeStorageValue\n            );\n        }\n    }\n\n    /// @notice Converts an fCash balance to a signed prime supply value.\n    /// @return signedPrimeSupplyValue the current (signed) prime cash value of the fCash \n    /// @return settledPrimeStorageValue the storage value of the fCash at settlement, used for\n    /// emitting events only\n    function _convertSettledfCash(\n        PrimeRate memory presentPrimeRate,\n        PrimeRate memory settledPrimeRate,\n        int256 fCashBalance\n    ) private pure returns (int256 signedPrimeSupplyValue, int256 settledPrimeStorageValue) {\n        // These values are valid at the time of settlement.\n        signedPrimeSupplyValue = convertFromUnderlying(settledPrimeRate, fCashBalance);\n        settledPrimeStorageValue = convertToStorageValue(settledPrimeRate, signedPrimeSupplyValue);\n\n        // If the signed prime supply value is negative, we need to accrue interest on the\n        // debt up to the present from the settled prime rate. This simulates storing the\n        // the debt, reading the debt from storage and then accruing interest up to the\n        // current time. This is only required for debt values.\n        // debtSharesAtSettlement = signedPrimeSupplyValue * settled.supplyFactor / settled.debtFactor\n        // currentSignedPrimeSupplyValue = debtSharesAtSettlement * present.debtFactor / present.supplyFactor\n        if (signedPrimeSupplyValue < 0) {\n            // Divide between multiplication actions to protect against a phantom overflow at 256 due\n            // to the two mul in the numerator.\n            signedPrimeSupplyValue = signedPrimeSupplyValue\n                .mul(settledPrimeRate.supplyFactor)\n                .div(settledPrimeRate.debtFactor)\n                .mul(presentPrimeRate.debtFactor)\n                .div(presentPrimeRate.supplyFactor)\n                // subtract one to protect protocol against rounding errors in division operations\n                .sub(1);\n        }\n    }\n\n    function convertToStorageValue(\n        PrimeRate memory pr,\n        int256 signedPrimeSupplyValueToStore\n    ) internal pure returns (int256 newStoredCashBalance) {\n        newStoredCashBalance = signedPrimeSupplyValueToStore >= 0 ?\n            signedPrimeSupplyValueToStore :\n            // negativePrimeDebt = (signedPrimeSupply * supplyFactor) / debtFactor\n            // subtract one to increase debt and protect protocol against rounding errors\n            signedPrimeSupplyValueToStore.mul(pr.supplyFactor).div(pr.debtFactor).sub(1);\n    }\n\n    /// @notice Updates total prime debt during settlement if debts are repaid by cash\n    /// balances.\n    /// @param pr current prime rate\n    /// @param currencyId currency id this prime rate refers to\n    /// @param previousSignedCashBalance the previous signed supply value of the stored cash balance\n    /// @param positiveSettledCash amount of positive cash balances that have settled\n    /// @param negativeSettledCash amount of negative cash balances that have settled\n    function convertToStorageInSettlement(\n        PrimeRate memory pr,\n        address account,\n        uint16 currencyId,\n        int256 previousSignedCashBalance,\n        int256 positiveSettledCash,\n        int256 negativeSettledCash\n    ) internal returns (int256 newStoredCashBalance) {\n        // The new cash balance is the sum of all the balances converted to a proper storage value\n        int256 endSignedBalance = previousSignedCashBalance.add(positiveSettledCash).add(negativeSettledCash);\n        newStoredCashBalance = convertToStorageValue(pr, endSignedBalance);\n\n        // At settlement, the total prime debt outstanding is increased by the total fCash debt\n        // outstanding figure in `_settleTotalfCashDebts`. This figure, however, is not aware of\n        // individual accounts that have sufficient cash (or matured fCash) to repay a settled debt.\n        // An example of the scenario would be an account with:\n        //      +100 units of ETH cash balance, -50 units of matured fETH\n        //\n        // At settlement the total ETH debt outstanding is set to -50 ETH, causing an increase in\n        // prime cash utilization and an increase to the prime cash debt rate. If this account settled\n        // exactly at maturity, they would have +50 units of ETH cash balance and have accrued zero\n        // additional variable rate debt. However, since the the smart contract is not made aware of this\n        // without an explicit settlement transaction, it will continue to accrue interest to prime cash\n        // suppliers (meaning that this account is paying variable interest on its -50 units of matured\n        // fETH until it actually issues a settlement transaction).\n        //\n        // The effect of this is that the account will be paying the spread between the prime cash supply\n        // interest rate and the prime debt interest rate for the period where it is not settled. If the\n        // account remains un-settled for long enough, it will slowly creep into insolvency (i.e. once the\n        // debt is greater than the cash, the account is insolvent). However, settlement transactions are\n        // permission-less and only require the payment of a minor gas cost so anyone can settle an account\n        // to stop the accrual of the variable rate debt and prevent an insolvency.\n        //\n        // The variable debt accrued by this account up to present time must be paid and is calculated\n        // in `_convertSettledfCash`. The logic below will detect the netPrimeDebtChange based on the\n        // cash balances and settled amounts and properly update the total prime debt figure accordingly.\n\n        // Only need to update total prime debt when there is a debt repayment via existing cash balances\n        // or positive settled cash. In all other cases, settled prime debt or existing prime debt are\n        // already captured by the total prime debt figure.\n        require(0 <= positiveSettledCash);\n        require(negativeSettledCash <= 0);\n\n        if (0 < previousSignedCashBalance) {\n            positiveSettledCash = previousSignedCashBalance.add(positiveSettledCash);\n        } else {\n            negativeSettledCash = previousSignedCashBalance.add(negativeSettledCash);\n        }\n\n        int256 netPrimeSupplyChange;\n        if (negativeSettledCash.neg() < positiveSettledCash) {\n            // All of the negative settled cash is repaid\n            netPrimeSupplyChange = negativeSettledCash;\n        } else {\n            // Positive cash portion of the debt is repaid\n            netPrimeSupplyChange = positiveSettledCash.neg();\n        }\n\n        // netPrimeSupplyChange should always be negative or zero at this point\n        if (netPrimeSupplyChange < 0) {\n            int256 netPrimeDebtChange = netPrimeSupplyChange.mul(pr.supplyFactor).div(pr.debtFactor);\n\n            PrimeCashExchangeRate.updateTotalPrimeDebt(\n                account,\n                currencyId,\n                netPrimeDebtChange,\n                netPrimeSupplyChange\n            );\n        }\n    }\n\n    /// @notice Converts signed prime supply value into a stored prime cash balance\n    /// value, converting negative prime supply values into prime debt values if required.\n    /// Also, updates totalPrimeDebt based on the net change in storage values. Should not\n    /// be called during settlement.\n    function convertToStorageNonSettlementNonVault(\n        PrimeRate memory pr,\n        address account,\n        uint16 currencyId,\n        int256 previousStoredCashBalance,\n        int256 signedPrimeSupplyValueToStore\n    ) internal returns (int256 newStoredCashBalance) {\n        newStoredCashBalance = convertToStorageValue(pr, signedPrimeSupplyValueToStore);\n        updateTotalPrimeDebt(\n            pr,\n            account,\n            currencyId,\n            // This will return 0 if both cash balances are positive.\n            previousStoredCashBalance.negChange(newStoredCashBalance)\n        );\n    }\n\n    /// @notice Updates totalPrimeDebt given the change to the stored cash balance\n    function updateTotalPrimeDebt(\n        PrimeRate memory pr,\n        address account,\n        uint16 currencyId,\n        int256 netPrimeDebtChange\n    ) internal {\n        if (netPrimeDebtChange != 0) {\n            // Whenever prime debt changes, prime supply must also change to the same degree in\n            // its own denomination. This marks the position of some lender in the system who\n            // will receive the repayment of the debt change.\n            // NOTE: total prime supply will also change when tokens enter or exit the system.\n            int256 netPrimeSupplyChange = netPrimeDebtChange.mul(pr.debtFactor).div(pr.supplyFactor);\n\n            PrimeCashExchangeRate.updateTotalPrimeDebt(\n                account,\n                currencyId,\n                netPrimeDebtChange,\n                netPrimeSupplyChange\n            );\n        }\n    }\n\n    /// @notice Converts a prime cash balance to underlying (both in internal 8\n    /// decimal precision).\n    function convertToUnderlying(\n        PrimeRate memory pr,\n        int256 primeCashBalance\n    ) internal pure returns (int256) {\n        return primeCashBalance.mul(pr.supplyFactor).div(Constants.DOUBLE_SCALAR_PRECISION);\n    }\n\n    /// @notice Converts underlying to a prime cash balance (both in internal 8\n    /// decimal precision).\n    function convertFromUnderlying(\n        PrimeRate memory pr,\n        int256 underlyingBalance\n    ) internal pure returns (int256) {\n        return underlyingBalance.mul(Constants.DOUBLE_SCALAR_PRECISION).div(pr.supplyFactor);\n    }\n\n    function convertDebtStorageToUnderlying(\n        PrimeRate memory pr,\n        int256 debtStorage\n    ) internal pure returns (int256) {\n        // debtStorage must be negative\n        require(debtStorage < 1);\n        return debtStorage.mul(pr.debtFactor).div(Constants.DOUBLE_SCALAR_PRECISION);\n    }\n\n    function convertUnderlyingToDebtStorage(\n        PrimeRate memory pr,\n        int256 underlying\n    ) internal pure returns (int256) {\n        // Floor dust balances at zero to prevent the following require check from reverting\n        if (0 <= underlying && underlying < 10) return 0;\n        require(underlying < 0);\n        // underlying debt is specified as a negative number and therefore subtract\n        // one to protect the protocol against rounding errors\n        return underlying.mul(Constants.DOUBLE_SCALAR_PRECISION).div(pr.debtFactor).sub(1);\n    }\n    \n    /// @notice Returns a prime rate object accrued up to the current time and updates\n    /// values in storage.\n    function buildPrimeRateStateful(\n        uint16 currencyId\n    ) internal returns (PrimeRate memory) {\n        return PrimeCashExchangeRate.getPrimeCashRateStateful(currencyId, block.timestamp);\n    }\n\n    /// @notice Returns a prime rate object for settlement at a particular maturity\n    function buildPrimeRateSettlementView(\n        uint16 currencyId,\n        uint256 maturity,\n        uint256 blockTime\n    ) internal view returns (PrimeRate memory pr) {\n        bool isSet;\n        (pr, isSet) = _getPrimeSettlementRate(currencyId, maturity);\n        \n        if (!isSet) {\n            // Return the current cash rate if settlement rate not found\n            (pr, /* */) = PrimeCashExchangeRate.getPrimeCashRateView(currencyId, blockTime);\n        }\n    }\n\n    /// @notice Returns a prime rate object for settlement at a particular maturity,\n    /// and sets both accrued values and the settlement rate (if not set already).\n    function buildPrimeRateSettlementStateful(\n        uint16 currencyId,\n        uint256 maturity,\n        uint256 blockTime\n    ) internal returns (PrimeRate memory pr) {\n        bool isSet;\n        (pr, isSet) = _getPrimeSettlementRate(currencyId, maturity);\n\n        if (!isSet) {\n            pr = _setPrimeSettlementRate(currencyId, maturity, blockTime);\n        }\n    }\n\n    /// @notice Loads the settlement rate from storage or uses the current rate if it\n    /// has not yet been set.\n    function _getPrimeSettlementRate(\n        uint16 currencyId,\n        uint256 maturity\n    ) private view returns (PrimeRate memory pr, bool isSet) {\n        mapping(uint256 => mapping(uint256 =>\n            PrimeSettlementRateStorage)) storage store = LibStorage.getPrimeSettlementRates();\n        PrimeSettlementRateStorage storage rateStorage = store[currencyId][maturity];\n        isSet = rateStorage.isSet;\n\n        // If the settlement rate is not set, then this method will return zeros\n        if (isSet) {\n            uint256 underlyingScalar = rateStorage.underlyingScalar;\n            pr.supplyFactor = int256(uint256(rateStorage.supplyScalar).mul(underlyingScalar));\n            pr.debtFactor = int256(uint256(rateStorage.debtScalar).mul(underlyingScalar));\n        }\n    }\n\n    function _setPrimeSettlementRate(\n        uint16 currencyId,\n        uint256 maturity,\n        uint256 blockTime\n    ) private returns (PrimeRate memory pr) {\n        // Accrues prime rates up to current time and sets them\n        pr = PrimeCashExchangeRate.getPrimeCashRateStateful(currencyId, blockTime);\n        // These are the accrued factors\n        PrimeCashFactors memory factors = PrimeCashExchangeRate.getPrimeCashFactors(currencyId);\n\n        mapping(uint256 => mapping(uint256 =>\n            PrimeSettlementRateStorage)) storage store = LibStorage.getPrimeSettlementRates();\n        PrimeSettlementRateStorage storage rateStorage = store[currencyId][maturity];\n\n        require(Deployments.NOTIONAL_V2_FINAL_SETTLEMENT < maturity); // dev: final settlement\n        require(factors.lastAccrueTime == blockTime); // dev: did not accrue\n        require(0 < blockTime); // dev: zero block time\n        require(maturity <= blockTime); // dev: settlement rate timestamp\n        require(0 < pr.supplyFactor); // dev: settlement rate zero\n        require(0 < pr.debtFactor); // dev: settlement rate zero\n\n        rateStorage.underlyingScalar = factors.underlyingScalar.toUint80();\n        rateStorage.supplyScalar = factors.supplyScalar.toUint80();\n        rateStorage.debtScalar = factors.debtScalar.toUint80();\n        rateStorage.isSet = true;\n\n        _settleTotalfCashDebts(currencyId, maturity, pr);\n\n        emit SetPrimeSettlementRate(\n            currencyId,\n            maturity,\n            pr.supplyFactor,\n            pr.debtFactor\n        );\n    }\n\n    function _settleTotalfCashDebts(\n        uint16 currencyId,\n        uint256 maturity,\n        PrimeRate memory settlementRate\n    ) private {\n        mapping(uint256 => mapping(uint256 => TotalfCashDebtStorage)) storage store = LibStorage.getTotalfCashDebtOutstanding();\n        TotalfCashDebtStorage storage s = store[currencyId][maturity];\n        int256 totalDebt = -int256(s.totalfCashDebt);\n        \n        // The nToken must be settled first via InitializeMarkets if there is any liquidity\n        // in the matching market (if one exists).\n        MarketParameters memory market;\n        market.loadSettlementMarket(currencyId, maturity, maturity);\n        require(market.totalLiquidity == 0, \"Must init markets\");\n\n        // totalDebt is negative, but netPrimeSupplyChange and netPrimeDebtChange must both be positive\n        // since we are increasing the total debt load.\n        int256 netPrimeSupplyChange = convertFromUnderlying(settlementRate, totalDebt.neg());\n        int256 netPrimeDebtChange = convertUnderlyingToDebtStorage(settlementRate, totalDebt).neg();\n\n        // The settlement reserve will receive all of the prime debt initially and each account\n        // will receive prime cash or prime debt as they settle individually.\n        PrimeCashExchangeRate.updateTotalPrimeDebt(\n            Constants.SETTLEMENT_RESERVE, currencyId, netPrimeDebtChange, netPrimeSupplyChange\n        );\n\n        // This is purely done to fully reconcile off chain accounting with the edge condition where\n        // leveraged vaults lend at zero interest.\n        int256 fCashDebtInReserve = -int256(s.fCashDebtHeldInSettlementReserve);\n        int256 primeCashInReserve = int256(s.primeCashHeldInSettlementReserve);\n        if (fCashDebtInReserve > 0 || primeCashInReserve > 0) {\n            int256 settledPrimeCash = convertFromUnderlying(settlementRate, fCashDebtInReserve);\n            int256 excessCash;\n            if (primeCashInReserve > settledPrimeCash) {\n                excessCash = primeCashInReserve - settledPrimeCash;\n                BalanceHandler.incrementFeeToReserve(currencyId, excessCash);\n            } \n\n            Emitter.emitSettlefCashDebtInReserve(\n                currencyId, maturity, fCashDebtInReserve, settledPrimeCash, excessCash\n            );\n        }\n\n        // Clear the storage slot, no longer needed\n        delete store[currencyId][maturity];\n    }\n\n    /// @notice Checks whether or not a currency has exceeded its total prime supply cap. Used to\n    /// prevent some listed currencies to be used as collateral above a threshold where liquidations\n    /// can be safely done on chain.\n    /// @dev Called during deposits in AccountAction and BatchAction. Supply caps are not checked\n    /// during settlement, liquidation and withdraws.\n    function checkSupplyCap(PrimeRate memory pr, uint16 currencyId) internal view {\n        (uint256 maxUnderlyingSupply, uint256 totalUnderlyingSupply) = getSupplyCap(pr, currencyId);\n        if (maxUnderlyingSupply == 0) return;\n\n        require(totalUnderlyingSupply <= maxUnderlyingSupply, \"Over Supply Cap\");\n    }\n\n    function getSupplyCap(\n        PrimeRate memory pr,\n        uint16 currencyId\n    ) internal view returns (uint256 maxUnderlyingSupply, uint256 totalUnderlyingSupply) {\n        PrimeCashFactorsStorage storage s = LibStorage.getPrimeCashFactors()[currencyId];\n        maxUnderlyingSupply = FloatingPoint.unpackFromBits(s.maxUnderlyingSupply);\n        // No potential for overflow due to storage size\n        int256 totalPrimeSupply = int256(uint256(s.totalPrimeSupply));\n        totalUnderlyingSupply = convertToUnderlying(pr, totalPrimeSupply).toUint();\n    }\n}"
    }
  ]
}