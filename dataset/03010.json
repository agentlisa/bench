{
  "Title": "M-19: Deprecated Balancer Price Oracles could lead to locked funds in the Balancer strategy vaults",
  "Content": "# Issue M-19: Deprecated Balancer Price Oracles could lead to locked funds in the Balancer strategy vaults \n\nSource: https://github.com/sherlock-audit/2022-09-notional-judging/issues/46 \n\n## Found by \nJeiwan\n\n## Summary\nThe Balancer strategy vaults (`Boosted3TokenAuraVault` and `MetaStable2TokenAuraVault`) use the price oracle of related Balancer vaults during settlement. However, price oracles in Balancer vaults [were deprecated](https://docs.balancer.fi/products/oracles-deprecated). It's likely that liquidity will be drained from such vaults and will be moved to new vaults. Lowered liquidity will result it price deviation, which will lead to failing settlement due to [the cross-checking with Chainlink oracles](https://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/math/Stable2TokenOracleMath.sol#L63). \n\n## Vulnerability Detail\nDuring settlement of the Balancer strategy vaults, [token spot prices are queried from Balancer Price Oracle](https://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/math/Stable2TokenOracleMath.sol#L76). The spot prices are [then](https://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/math/Stable2TokenOracleMath.sol#L77) [compared to those reported by Chainlink](https://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/math/Stable2TokenOracleMath.sol#L50). If the difference is too big, [settlement will fail](https://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/math/Stable2TokenOracleMath.sol#L63). Lowered liquidity in the deprecated Balancer vaults will result in high price deviation, blocked settlement, and locked funds.\n\n## Impact\nSince [Balancer has deprecated price oracles in its vaults](https://docs.balancer.fi/products/oracles-deprecated) and advised against using the vaults with price oracles enabled (they won't be disabled), it's likely that liquidity will be removed from such vaults and will be moved to new Balancer vaults that don't have the price oracle functionality. Since the Balancer strategy vaults of Notional are integrated with such deprecated Balancer vaults, it's likely that the strategy vaults will be impacted by lowered liquidity of the Balancer vaults. Lower liquidity will result in higher slippage, which means higher deviation of Balancer price oracle reported spot prices compared to those of Chainlink. In the case when price deviation is higher than defined in the `oraclePriceDeviationLimitPercent` setting (which is very likely due to Balancer recommending against using the deprecated vaults), settlement won't be possible and funds will be locked.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/math/Stable2TokenOracleMath.sol#L76-L77\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/math/Stable2TokenOracleMath.sol#L43-L65\n\n## Tool used\n\nManual Review\n\n## Recommendation\nShort term, don't revert (`Errors.InvalidPrice`) in case of a price deviation and use the Chainlink price instead. Long term, migrate to the new Balancer vaults that don't have a price oracle and use Chainlink only.\n\n## Discussion\n\n**jeffywu**\n\n@T-Woodward / @weitianjie2000\n\nGood call on the balancer oracle deprecation, although existing pools will continue to have them.\n\n**T-Woodward**\n\nYup confirmed, we're removing the balancer oracle dependency\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/2",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/internal/math/Stable2TokenOracleMath.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {StableOracleContext, TwoTokenPoolContext, StrategyContext} from \"../../BalancerVaultTypes.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {IPriceOracle} from \"../../../../../interfaces/balancer/IPriceOracle.sol\";\nimport {StableMath} from \"./StableMath.sol\";\nimport {ITradingModule} from \"../../../../../interfaces/trading/ITradingModule.sol\";\n\nlibrary Stable2TokenOracleMath {\n    using TypeConvert for int256;\n    using Stable2TokenOracleMath for StableOracleContext;\n\n    function _getSpotPrice(\n        StableOracleContext memory oracleContext, \n        TwoTokenPoolContext memory poolContext, \n        uint256 tokenIndex\n    ) internal view returns (uint256 spotPrice) {\n        // Prevents overflows, we don't expect tokens to be greater than 18 decimals, don't use\n        // equal sign for minor gas optimization\n        require(poolContext.primaryDecimals < 19); /// @dev primaryDecimals overflow\n        require(poolContext.secondaryDecimals < 19); /// @dev secondaryDecimals overflow\n        require(tokenIndex < 2); /// @dev invalid token index\n\n        (uint256 balanceX, uint256 balanceY) = tokenIndex == 0 ?\n            (poolContext.primaryBalance, poolContext.secondaryBalance) :\n            (poolContext.secondaryBalance, poolContext.primaryBalance);\n\n        uint256 invariant = StableMath._calculateInvariant(\n            oracleContext.ampParam, StableMath._balances(balanceX, balanceY), true // round up\n        );\n\n        spotPrice = StableMath._calcSpotPrice({\n            amplificationParameter: oracleContext.ampParam,\n            invariant: invariant,\n            balanceX: balanceX,\n            balanceY: balanceY\n        });\n    }\n\n    function _checkPriceLimit(\n        StrategyContext calldata strategyContext,\n        TwoTokenPoolContext memory poolContext,\n        uint256 poolPrice\n    ) private view returns (bool) {\n        (\n            int256 answer, int256 decimals\n        ) = strategyContext.tradingModule.getOraclePrice(poolContext.secondaryToken, poolContext.primaryToken);\n\n        require(decimals == int256(BalancerConstants.BALANCER_PRECISION));\n\n        uint256 oraclePairPrice = answer.toUint();\n        uint256 lowerLimit = (oraclePairPrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS - strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n        uint256 upperLimit = (oraclePairPrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS + strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n\n        if (poolPrice < lowerLimit || upperLimit < poolPrice) {\n            revert Errors.InvalidPrice(oraclePairPrice, poolPrice);\n        }\n    }\n\n    /// @notice calculates the expected min exit amounts for a given BPT amount\n    function _getMinExitAmounts(\n        StableOracleContext calldata oracleContext,\n        TwoTokenPoolContext calldata poolContext,\n        StrategyContext calldata strategyContext,\n        uint256 bptAmount\n    ) internal view returns (uint256 minPrimary, uint256 minSecondary) {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        // Validate the spot price to make sure the pool is not being manipulated\n        uint256 spotPrice = _getSpotPrice(oracleContext, poolContext, 0);\n        _checkPriceLimit(strategyContext, poolContext, spotPrice);\n\n        // min amounts are calculated based on the share of the Balancer pool with a small discount applied\n        uint256 totalBPTSupply = poolContext.basePool.pool.totalSupply();\n        minPrimary = (poolContext.primaryBalance * bptAmount * \n            strategyContext.vaultSettings.balancerPoolSlippageLimitPercent) / \n            (totalBPTSupply * uint256(BalancerConstants.VAULT_PERCENT_BASIS));\n        minSecondary = (poolContext.secondaryBalance * bptAmount * \n            strategyContext.vaultSettings.balancerPoolSlippageLimitPercent) / \n            (totalBPTSupply * uint256(BalancerConstants.VAULT_PERCENT_BASIS));\n    }\n\n    function _validateSpotPriceAndPairPrice(\n        StableOracleContext calldata oracleContext,\n        TwoTokenPoolContext calldata poolContext,\n        StrategyContext calldata strategyContext,\n        uint256 primaryAmount, \n        uint256 secondaryAmount\n    ) internal view {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        uint256 spotPrice = _getSpotPrice(oracleContext, poolContext, 0);\n        _checkPriceLimit(strategyContext, poolContext, spotPrice);\n\n        // We always validate in terms of the primary here so it is the first value in the _balances array\n        uint256 invariant = StableMath._calculateInvariant(\n            oracleContext.ampParam, StableMath._balances(primaryAmount, secondaryAmount), true // round up\n        );\n\n        /// @notice Balancer math functions expect all amounts to be in BALANCER_PRECISION\n        uint256 primaryPrecision = 10 ** poolContext.primaryDecimals;\n        uint256 secondaryPrecision = 10 ** poolContext.secondaryDecimals;\n        primaryAmount = primaryAmount * BalancerConstants.BALANCER_PRECISION / primaryPrecision;\n        secondaryAmount = secondaryAmount * BalancerConstants.BALANCER_PRECISION / secondaryPrecision;\n\n        uint256 calculatedPairPrice = StableMath._calcSpotPrice({\n            amplificationParameter: oracleContext.ampParam,\n            invariant: invariant,\n            balanceX: primaryAmount,\n            balanceY: secondaryAmount\n        });\n\n        _checkPriceLimit(strategyContext, poolContext, calculatedPairPrice);\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/internal/math/Stable2TokenOracleMath.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {StableOracleContext, TwoTokenPoolContext, StrategyContext} from \"../../BalancerVaultTypes.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {IPriceOracle} from \"../../../../../interfaces/balancer/IPriceOracle.sol\";\nimport {StableMath} from \"./StableMath.sol\";\nimport {ITradingModule} from \"../../../../../interfaces/trading/ITradingModule.sol\";\n\nlibrary Stable2TokenOracleMath {\n    using TypeConvert for int256;\n    using Stable2TokenOracleMath for StableOracleContext;\n\n    function _getSpotPrice(\n        StableOracleContext memory oracleContext, \n        TwoTokenPoolContext memory poolContext, \n        uint256 tokenIndex\n    ) internal view returns (uint256 spotPrice) {\n        // Prevents overflows, we don't expect tokens to be greater than 18 decimals, don't use\n        // equal sign for minor gas optimization\n        require(poolContext.primaryDecimals < 19); /// @dev primaryDecimals overflow\n        require(poolContext.secondaryDecimals < 19); /// @dev secondaryDecimals overflow\n        require(tokenIndex < 2); /// @dev invalid token index\n\n        (uint256 balanceX, uint256 balanceY) = tokenIndex == 0 ?\n            (poolContext.primaryBalance, poolContext.secondaryBalance) :\n            (poolContext.secondaryBalance, poolContext.primaryBalance);\n\n        uint256 invariant = StableMath._calculateInvariant(\n            oracleContext.ampParam, StableMath._balances(balanceX, balanceY), true // round up\n        );\n\n        spotPrice = StableMath._calcSpotPrice({\n            amplificationParameter: oracleContext.ampParam,\n            invariant: invariant,\n            balanceX: balanceX,\n            balanceY: balanceY\n        });\n    }\n\n    function _checkPriceLimit(\n        StrategyContext calldata strategyContext,\n        TwoTokenPoolContext memory poolContext,\n        uint256 poolPrice\n    ) private view returns (bool) {\n        (\n            int256 answer, int256 decimals\n        ) = strategyContext.tradingModule.getOraclePrice(poolContext.secondaryToken, poolContext.primaryToken);\n\n        require(decimals == int256(BalancerConstants.BALANCER_PRECISION));\n\n        uint256 oraclePairPrice = answer.toUint();\n        uint256 lowerLimit = (oraclePairPrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS - strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n        uint256 upperLimit = (oraclePairPrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS + strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n\n        if (poolPrice < lowerLimit || upperLimit < poolPrice) {\n            revert Errors.InvalidPrice(oraclePairPrice, poolPrice);\n        }\n    }\n\n    /// @notice calculates the expected min exit amounts for a given BPT amount\n    function _getMinExitAmounts(\n        StableOracleContext calldata oracleContext,\n        TwoTokenPoolContext calldata poolContext,\n        StrategyContext calldata strategyContext,\n        uint256 bptAmount\n    ) internal view returns (uint256 minPrimary, uint256 minSecondary) {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        // Validate the spot price to make sure the pool is not being manipulated\n        uint256 spotPrice = _getSpotPrice(oracleContext, poolContext, 0);\n        _checkPriceLimit(strategyContext, poolContext, spotPrice);\n\n        // min amounts are calculated based on the share of the Balancer pool with a small discount applied\n        uint256 totalBPTSupply = poolContext.basePool.pool.totalSupply();\n        minPrimary = (poolContext.primaryBalance * bptAmount * \n            strategyContext.vaultSettings.balancerPoolSlippageLimitPercent) / \n            (totalBPTSupply * uint256(BalancerConstants.VAULT_PERCENT_BASIS));\n        minSecondary = (poolContext.secondaryBalance * bptAmount * \n            strategyContext.vaultSettings.balancerPoolSlippageLimitPercent) / \n            (totalBPTSupply * uint256(BalancerConstants.VAULT_PERCENT_BASIS));\n    }\n\n    function _validateSpotPriceAndPairPrice(\n        StableOracleContext calldata oracleContext,\n        TwoTokenPoolContext calldata poolContext,\n        StrategyContext calldata strategyContext,\n        uint256 primaryAmount, \n        uint256 secondaryAmount\n    ) internal view {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        uint256 spotPrice = _getSpotPrice(oracleContext, poolContext, 0);\n        _checkPriceLimit(strategyContext, poolContext, spotPrice);\n\n        // We always validate in terms of the primary here so it is the first value in the _balances array\n        uint256 invariant = StableMath._calculateInvariant(\n            oracleContext.ampParam, StableMath._balances(primaryAmount, secondaryAmount), true // round up\n        );\n\n        /// @notice Balancer math functions expect all amounts to be in BALANCER_PRECISION\n        uint256 primaryPrecision = 10 ** poolContext.primaryDecimals;\n        uint256 secondaryPrecision = 10 ** poolContext.secondaryDecimals;\n        primaryAmount = primaryAmount * BalancerConstants.BALANCER_PRECISION / primaryPrecision;\n        secondaryAmount = secondaryAmount * BalancerConstants.BALANCER_PRECISION / secondaryPrecision;\n\n        uint256 calculatedPairPrice = StableMath._calcSpotPrice({\n            amplificationParameter: oracleContext.ampParam,\n            invariant: invariant,\n            balanceX: primaryAmount,\n            balanceY: secondaryAmount\n        });\n\n        _checkPriceLimit(strategyContext, poolContext, calculatedPairPrice);\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/internal/math/Stable2TokenOracleMath.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {StableOracleContext, TwoTokenPoolContext, StrategyContext} from \"../../BalancerVaultTypes.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {IPriceOracle} from \"../../../../../interfaces/balancer/IPriceOracle.sol\";\nimport {StableMath} from \"./StableMath.sol\";\nimport {ITradingModule} from \"../../../../../interfaces/trading/ITradingModule.sol\";\n\nlibrary Stable2TokenOracleMath {\n    using TypeConvert for int256;\n    using Stable2TokenOracleMath for StableOracleContext;\n\n    function _getSpotPrice(\n        StableOracleContext memory oracleContext, \n        TwoTokenPoolContext memory poolContext, \n        uint256 tokenIndex\n    ) internal view returns (uint256 spotPrice) {\n        // Prevents overflows, we don't expect tokens to be greater than 18 decimals, don't use\n        // equal sign for minor gas optimization\n        require(poolContext.primaryDecimals < 19); /// @dev primaryDecimals overflow\n        require(poolContext.secondaryDecimals < 19); /// @dev secondaryDecimals overflow\n        require(tokenIndex < 2); /// @dev invalid token index\n\n        (uint256 balanceX, uint256 balanceY) = tokenIndex == 0 ?\n            (poolContext.primaryBalance, poolContext.secondaryBalance) :\n            (poolContext.secondaryBalance, poolContext.primaryBalance);\n\n        uint256 invariant = StableMath._calculateInvariant(\n            oracleContext.ampParam, StableMath._balances(balanceX, balanceY), true // round up\n        );\n\n        spotPrice = StableMath._calcSpotPrice({\n            amplificationParameter: oracleContext.ampParam,\n            invariant: invariant,\n            balanceX: balanceX,\n            balanceY: balanceY\n        });\n    }\n\n    function _checkPriceLimit(\n        StrategyContext calldata strategyContext,\n        TwoTokenPoolContext memory poolContext,\n        uint256 poolPrice\n    ) private view returns (bool) {\n        (\n            int256 answer, int256 decimals\n        ) = strategyContext.tradingModule.getOraclePrice(poolContext.secondaryToken, poolContext.primaryToken);\n\n        require(decimals == int256(BalancerConstants.BALANCER_PRECISION));\n\n        uint256 oraclePairPrice = answer.toUint();\n        uint256 lowerLimit = (oraclePairPrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS - strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n        uint256 upperLimit = (oraclePairPrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS + strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n\n        if (poolPrice < lowerLimit || upperLimit < poolPrice) {\n            revert Errors.InvalidPrice(oraclePairPrice, poolPrice);\n        }\n    }\n\n    /// @notice calculates the expected min exit amounts for a given BPT amount\n    function _getMinExitAmounts(\n        StableOracleContext calldata oracleContext,\n        TwoTokenPoolContext calldata poolContext,\n        StrategyContext calldata strategyContext,\n        uint256 bptAmount\n    ) internal view returns (uint256 minPrimary, uint256 minSecondary) {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        // Validate the spot price to make sure the pool is not being manipulated\n        uint256 spotPrice = _getSpotPrice(oracleContext, poolContext, 0);\n        _checkPriceLimit(strategyContext, poolContext, spotPrice);\n\n        // min amounts are calculated based on the share of the Balancer pool with a small discount applied\n        uint256 totalBPTSupply = poolContext.basePool.pool.totalSupply();\n        minPrimary = (poolContext.primaryBalance * bptAmount * \n            strategyContext.vaultSettings.balancerPoolSlippageLimitPercent) / \n            (totalBPTSupply * uint256(BalancerConstants.VAULT_PERCENT_BASIS));\n        minSecondary = (poolContext.secondaryBalance * bptAmount * \n            strategyContext.vaultSettings.balancerPoolSlippageLimitPercent) / \n            (totalBPTSupply * uint256(BalancerConstants.VAULT_PERCENT_BASIS));\n    }\n\n    function _validateSpotPriceAndPairPrice(\n        StableOracleContext calldata oracleContext,\n        TwoTokenPoolContext calldata poolContext,\n        StrategyContext calldata strategyContext,\n        uint256 primaryAmount, \n        uint256 secondaryAmount\n    ) internal view {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        uint256 spotPrice = _getSpotPrice(oracleContext, poolContext, 0);\n        _checkPriceLimit(strategyContext, poolContext, spotPrice);\n\n        // We always validate in terms of the primary here so it is the first value in the _balances array\n        uint256 invariant = StableMath._calculateInvariant(\n            oracleContext.ampParam, StableMath._balances(primaryAmount, secondaryAmount), true // round up\n        );\n\n        /// @notice Balancer math functions expect all amounts to be in BALANCER_PRECISION\n        uint256 primaryPrecision = 10 ** poolContext.primaryDecimals;\n        uint256 secondaryPrecision = 10 ** poolContext.secondaryDecimals;\n        primaryAmount = primaryAmount * BalancerConstants.BALANCER_PRECISION / primaryPrecision;\n        secondaryAmount = secondaryAmount * BalancerConstants.BALANCER_PRECISION / secondaryPrecision;\n\n        uint256 calculatedPairPrice = StableMath._calcSpotPrice({\n            amplificationParameter: oracleContext.ampParam,\n            invariant: invariant,\n            balanceX: primaryAmount,\n            balanceY: secondaryAmount\n        });\n\n        _checkPriceLimit(strategyContext, poolContext, calculatedPairPrice);\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/internal/math/Stable2TokenOracleMath.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {StableOracleContext, TwoTokenPoolContext, StrategyContext} from \"../../BalancerVaultTypes.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {IPriceOracle} from \"../../../../../interfaces/balancer/IPriceOracle.sol\";\nimport {StableMath} from \"./StableMath.sol\";\nimport {ITradingModule} from \"../../../../../interfaces/trading/ITradingModule.sol\";\n\nlibrary Stable2TokenOracleMath {\n    using TypeConvert for int256;\n    using Stable2TokenOracleMath for StableOracleContext;\n\n    function _getSpotPrice(\n        StableOracleContext memory oracleContext, \n        TwoTokenPoolContext memory poolContext, \n        uint256 tokenIndex\n    ) internal view returns (uint256 spotPrice) {\n        // Prevents overflows, we don't expect tokens to be greater than 18 decimals, don't use\n        // equal sign for minor gas optimization\n        require(poolContext.primaryDecimals < 19); /// @dev primaryDecimals overflow\n        require(poolContext.secondaryDecimals < 19); /// @dev secondaryDecimals overflow\n        require(tokenIndex < 2); /// @dev invalid token index\n\n        (uint256 balanceX, uint256 balanceY) = tokenIndex == 0 ?\n            (poolContext.primaryBalance, poolContext.secondaryBalance) :\n            (poolContext.secondaryBalance, poolContext.primaryBalance);\n\n        uint256 invariant = StableMath._calculateInvariant(\n            oracleContext.ampParam, StableMath._balances(balanceX, balanceY), true // round up\n        );\n\n        spotPrice = StableMath._calcSpotPrice({\n            amplificationParameter: oracleContext.ampParam,\n            invariant: invariant,\n            balanceX: balanceX,\n            balanceY: balanceY\n        });\n    }\n\n    function _checkPriceLimit(\n        StrategyContext calldata strategyContext,\n        TwoTokenPoolContext memory poolContext,\n        uint256 poolPrice\n    ) private view returns (bool) {\n        (\n            int256 answer, int256 decimals\n        ) = strategyContext.tradingModule.getOraclePrice(poolContext.secondaryToken, poolContext.primaryToken);\n\n        require(decimals == int256(BalancerConstants.BALANCER_PRECISION));\n\n        uint256 oraclePairPrice = answer.toUint();\n        uint256 lowerLimit = (oraclePairPrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS - strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n        uint256 upperLimit = (oraclePairPrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS + strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n\n        if (poolPrice < lowerLimit || upperLimit < poolPrice) {\n            revert Errors.InvalidPrice(oraclePairPrice, poolPrice);\n        }\n    }\n\n    /// @notice calculates the expected min exit amounts for a given BPT amount\n    function _getMinExitAmounts(\n        StableOracleContext calldata oracleContext,\n        TwoTokenPoolContext calldata poolContext,\n        StrategyContext calldata strategyContext,\n        uint256 bptAmount\n    ) internal view returns (uint256 minPrimary, uint256 minSecondary) {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        // Validate the spot price to make sure the pool is not being manipulated\n        uint256 spotPrice = _getSpotPrice(oracleContext, poolContext, 0);\n        _checkPriceLimit(strategyContext, poolContext, spotPrice);\n\n        // min amounts are calculated based on the share of the Balancer pool with a small discount applied\n        uint256 totalBPTSupply = poolContext.basePool.pool.totalSupply();\n        minPrimary = (poolContext.primaryBalance * bptAmount * \n            strategyContext.vaultSettings.balancerPoolSlippageLimitPercent) / \n            (totalBPTSupply * uint256(BalancerConstants.VAULT_PERCENT_BASIS));\n        minSecondary = (poolContext.secondaryBalance * bptAmount * \n            strategyContext.vaultSettings.balancerPoolSlippageLimitPercent) / \n            (totalBPTSupply * uint256(BalancerConstants.VAULT_PERCENT_BASIS));\n    }\n\n    function _validateSpotPriceAndPairPrice(\n        StableOracleContext calldata oracleContext,\n        TwoTokenPoolContext calldata poolContext,\n        StrategyContext calldata strategyContext,\n        uint256 primaryAmount, \n        uint256 secondaryAmount\n    ) internal view {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        uint256 spotPrice = _getSpotPrice(oracleContext, poolContext, 0);\n        _checkPriceLimit(strategyContext, poolContext, spotPrice);\n\n        // We always validate in terms of the primary here so it is the first value in the _balances array\n        uint256 invariant = StableMath._calculateInvariant(\n            oracleContext.ampParam, StableMath._balances(primaryAmount, secondaryAmount), true // round up\n        );\n\n        /// @notice Balancer math functions expect all amounts to be in BALANCER_PRECISION\n        uint256 primaryPrecision = 10 ** poolContext.primaryDecimals;\n        uint256 secondaryPrecision = 10 ** poolContext.secondaryDecimals;\n        primaryAmount = primaryAmount * BalancerConstants.BALANCER_PRECISION / primaryPrecision;\n        secondaryAmount = secondaryAmount * BalancerConstants.BALANCER_PRECISION / secondaryPrecision;\n\n        uint256 calculatedPairPrice = StableMath._calcSpotPrice({\n            amplificationParameter: oracleContext.ampParam,\n            invariant: invariant,\n            balanceX: primaryAmount,\n            balanceY: secondaryAmount\n        });\n\n        _checkPriceLimit(strategyContext, poolContext, calculatedPairPrice);\n    }\n}"
    }
  ]
}