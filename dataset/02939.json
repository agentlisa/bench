{
  "Title": "Unenforced staking requirement",
  "Content": "Adding liquidity requires a liquidity provider to have at least [a minimum amount of NPM tokens](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/VaultLibV1.sol#L151) staked in the vault.\n\n\nHowever, the purpose and usefulness of this requirement is unclear, since it can be bypassed. In particular:\n\n\n* there is no relationship between the amount of PODs created and the size of the stake\n* PODs are transferable to unstaked users, so users can provide liquidity without staking\n* staked users can [exit their entire staked `amount`](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/liquidity/VaultLiquidity.sol#L113-L118) without redeeming any PODs by calling `removeLiquidity` with parameters `podsToRedeem = 0`, `npmStakeToRemove = amount`, and `exit = 1`; the `exit = 1` is crucial as it allows execution of [line 234](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/VaultLibV1.sol#L234) of `VaultLibV1.sol`\n\n\nConsider documenting and enforcing the intended relationship between NPM staking and liquidity provision.\n\n\n**Update:** *Acknowledged, not fixed. The Neptune team stated:*\n\n\n\n> *Although we plan to redo the staking requirement logic from scratch, we wish to consider this risk as acceptable for the time being.*\n> \n> \n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/libraries/VaultLibV1.sol",
      "content": "// Neptune Mutual Protocol (https://neptunemutual.com)\n// SPDX-License-Identifier: BUSL-1.1\n/* solhint-disable ordering  */\npragma solidity ^0.8.0;\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-solidity/contracts/interfaces/IERC3156FlashLender.sol\";\nimport \"./ProtoUtilV1.sol\";\nimport \"./StoreKeyUtil.sol\";\nimport \"./RegistryLibV1.sol\";\nimport \"./CoverUtilV1.sol\";\nimport \"./RoutineInvokerLibV1.sol\";\nimport \"./StrategyLibV1.sol\";\nimport \"./ValidationLibV1.sol\";\n\nlibrary VaultLibV1 {\n  using ProtoUtilV1 for IStore;\n  using StoreKeyUtil for IStore;\n  using RegistryLibV1 for IStore;\n  using CoverUtilV1 for IStore;\n  using RoutineInvokerLibV1 for IStore;\n  using StrategyLibV1 for IStore;\n\n  // Before withdrawing, wait for the following number of blocks after deposit\n  uint256 public constant WITHDRAWAL_HEIGHT_OFFSET = 1;\n\n  /**\n   * @dev Calculates the amount of PODS to mint for the given amount of liquidity to transfer\n   */\n  function calculatePodsInternal(\n    IStore s,\n    bytes32 coverKey,\n    address pod,\n    uint256 liquidityToAdd\n  ) public view returns (uint256) {\n    require(s.getBoolByKeys(ProtoUtilV1.NS_COVER_HAS_FLASH_LOAN, coverKey) == false, \"On flash loan, please try again\");\n\n    uint256 balance = s.getStablecoinOwnedByVaultInternal(coverKey);\n    uint256 podSupply = IERC20(pod).totalSupply();\n    uint256 stablecoinPrecision = s.getStablecoinPrecision();\n\n    // This smart contract contains stablecoins without liquidity provider contribution.\n    // This can happen if someone wants to create a nuisance by sending stablecoin\n    // to this contract immediately after deployment.\n    if (podSupply == 0 && balance > 0) {\n      revert(\"Liquidity/POD mismatch\");\n    }\n\n    if (balance > 0) {\n      return (podSupply * liquidityToAdd) / balance;\n    }\n\n    return (liquidityToAdd * ProtoUtilV1.POD_PRECISION) / stablecoinPrecision;\n  }\n\n  /**\n   * @dev Calculates the amount of liquidity to transfer for the given amount of PODs to burn.\n   *\n   * The Vault contract lends out liquidity to external protocols to maximize reward\n   * regularly. But it also withdraws periodically to receive back the loaned amount\n   * with interest. In other words, the Vault contract continuously supplies\n   * available liquidity to lending protocols and withdraws during a fixed interval.\n   * For example, supply during `180-day lending period` and allow withdrawals\n   * during `7-day withdrawal period`.\n   */\n  function calculateLiquidityInternal(\n    IStore s,\n    bytes32 coverKey,\n    address pod,\n    uint256 podsToBurn\n  ) public view returns (uint256) {\n    require(s.getBoolByKeys(ProtoUtilV1.NS_COVER_HAS_FLASH_LOAN, coverKey) == false, \"On flash loan, please try again\");\n\n    uint256 balance = s.getStablecoinOwnedByVaultInternal(coverKey);\n    uint256 podSupply = IERC20(pod).totalSupply();\n\n    return (balance * podsToBurn) / podSupply;\n  }\n\n  /**\n   * @dev Gets information of a given vault by the cover key\n   * @param s Provide a store instance\n   * @param coverKey Specify cover key to obtain the info of.\n   * @param pod Provide the address of the POD\n   * @param you The address for which the info will be customized\n   * @param values[0] totalPods --> Total PODs in existence\n   * @param values[1] balance --> Stablecoins held in the vault\n   * @param values[2] extendedBalance --> Stablecoins lent outside of the protocol\n   * @param values[3] totalReassurance -- > Total reassurance for this cover\n   * @param values[4] myPodBalance --> Your POD Balance\n   * @param values[5] myShare --> My share of the liquidity pool (in stablecoin)\n   * @param values[6] withdrawalOpen --> The timestamp when withdrawals are opened\n   * @param values[7] withdrawalClose --> The timestamp when withdrawals are closed again\n   */\n  function getInfoInternal(\n    IStore s,\n    bytes32 coverKey,\n    address pod,\n    address you\n  ) external view returns (uint256[] memory values) {\n    values = new uint256[](11);\n\n    values[0] = IERC20(pod).totalSupply(); // Total PODs in existence\n    values[1] = s.getStablecoinOwnedByVaultInternal(coverKey);\n    values[2] = s.getAmountInStrategies(coverKey, s.getStablecoin()); //  Stablecoins lent outside of the protocol\n    values[3] = s.getReassuranceAmountInternal(coverKey); // Total reassurance for this cover\n    values[4] = IERC20(pod).balanceOf(you); // Your POD Balance\n    values[5] = calculateLiquidityInternal(s, coverKey, pod, values[5]); //  My share of the liquidity pool (in stablecoin)\n    values[6] = s.getUintByKey(RoutineInvokerLibV1.getNextWithdrawalStartKey(coverKey));\n    values[7] = s.getUintByKey(RoutineInvokerLibV1.getNextWithdrawalEndKey(coverKey));\n  }\n\n  /**\n   * @dev Called before adding liquidity to the specified cover contract\n   *\n   * @custom:suppress-malicious-erc The address `stablecoin` can be trusted here because we are ensuring it matches with the protocol stablecoin address.\n   * @custom:suppress-address-trust-issue The address `stablecoin` can be trusted here because we are ensuring it matches with the protocol stablecoin address.\n   *\n   * @param coverKey Enter the cover key\n   * @param account Specify the account on behalf of which the liquidity is being added.\n   * @param amount Enter the amount of liquidity token to supply.\n   * @param npmStakeToAdd Enter the amount of NPM token to stake.\n   */\n  function preAddLiquidityInternal(\n    IStore s,\n    bytes32 coverKey,\n    address pod,\n    address account,\n    uint256 amount,\n    uint256 npmStakeToAdd\n  ) external returns (uint256 podsToMint, uint256 myPreviousStake) {\n    require(account != address(0), \"Invalid account\");\n\n    // Update values\n    myPreviousStake = _updateNpmStake(s, coverKey, account, npmStakeToAdd);\n    podsToMint = calculatePodsInternal(s, coverKey, pod, amount);\n\n    _updateLastBlock(s, coverKey);\n  }\n\n  function _updateLastBlock(IStore s, bytes32 coverKey) private {\n    s.setUintByKey(CoverUtilV1.getLastDepositHeightKey(coverKey), block.number);\n  }\n\n  function _updateNpmStake(\n    IStore s,\n    bytes32 coverKey,\n    address account,\n    uint256 amount\n  ) private returns (uint256 myPreviousStake) {\n    myPreviousStake = _getMyNpmStake(s, coverKey, account);\n    require(amount + myPreviousStake >= s.getMinStakeToAddLiquidity(), \"Insufficient stake\");\n\n    if (amount > 0) {\n      s.addUintByKey(CoverUtilV1.getCoverLiquidityStakeKey(coverKey), amount); // Total stake\n      s.addUintByKey(CoverUtilV1.getCoverLiquidityStakeIndividualKey(coverKey, account), amount); // Your stake\n    }\n  }\n\n  function _getMyNpmStake(\n    IStore s,\n    bytes32 coverKey,\n    address account\n  ) private view returns (uint256 myStake) {\n    (, myStake) = getCoverNpmStake(s, coverKey, account);\n  }\n\n  function getCoverNpmStake(\n    IStore s,\n    bytes32 coverKey,\n    address account\n  ) public view returns (uint256 totalStake, uint256 myStake) {\n    totalStake = s.getUintByKey(CoverUtilV1.getCoverLiquidityStakeKey(coverKey));\n    myStake = s.getUintByKey(CoverUtilV1.getCoverLiquidityStakeIndividualKey(coverKey, account));\n  }\n\n  function mustHaveNoBalanceInStrategies(\n    IStore s,\n    bytes32 coverKey,\n    address stablecoin\n  ) external view {\n    require(s.getAmountInStrategies(coverKey, stablecoin) == 0, \"Strategy balance is not zero\");\n  }\n\n  function mustMaintainBlockHeightOffset(IStore s, bytes32 coverKey) external view {\n    uint256 lastDeposit = s.getUintByKey(CoverUtilV1.getLastDepositHeightKey(coverKey));\n    require(block.number > lastDeposit + WITHDRAWAL_HEIGHT_OFFSET, \"Please wait a few blocks\");\n  }\n\n  /**\n   * @dev Removes liquidity from the specified cover contract\n   *\n   * @custom:suppress-malicious-erc The address `pod` although can only come from VaultBase,\n   * we still need to ensure if it is a protocol member. Check `_redeemPodCalculation` for more info.\n   * @custom:suppress-address-trust-issue The address `pod` can't be trusted and therefore needs to be checked\n   * if it is a protocol member.\n   *\n   * @param coverKey Enter the cover key\n   * @param podsToRedeem Enter the amount of liquidity token to remove.\n   */\n  function preRemoveLiquidityInternal(\n    IStore s,\n    bytes32 coverKey,\n    address pod,\n    address account,\n    uint256 podsToRedeem,\n    uint256 npmStakeToRemove,\n    bool exit\n  ) external returns (address stablecoin, uint256 releaseAmount) {\n    stablecoin = s.getStablecoin();\n\n    // Redeem the PODs and receive DAI\n    releaseAmount = _redeemPodCalculation(s, coverKey, pod, podsToRedeem);\n\n    ValidationLibV1.mustNotExceedStablecoinThreshold(s, releaseAmount);\n    GovernanceUtilV1.mustNotExceedNpmThreshold(npmStakeToRemove);\n\n    // Unstake NPM tokens\n    if (npmStakeToRemove > 0) {\n      _unStakeNpm(s, account, coverKey, npmStakeToRemove, exit);\n    }\n  }\n\n  function _unStakeNpm(\n    IStore s,\n    address account,\n    bytes32 coverKey,\n    uint256 amount,\n    bool exit\n  ) private {\n    uint256 remainingStake = _getMyNpmStake(s, coverKey, account);\n    uint256 minStakeToMaintain = s.getMinStakeToAddLiquidity();\n\n    if (exit) {\n      require(remainingStake == amount, \"Invalid NPM stake to exit\");\n    } else {\n      require(remainingStake - amount >= minStakeToMaintain, \"Can't go below min stake\");\n    }\n\n    s.subtractUintByKey(CoverUtilV1.getCoverLiquidityStakeKey(coverKey), amount); // Total stake\n    s.subtractUintByKey(CoverUtilV1.getCoverLiquidityStakeIndividualKey(coverKey, account), amount); // Your stake\n  }\n\n  function _redeemPodCalculation(\n    IStore s,\n    bytes32 coverKey,\n    address pod,\n    uint256 podsToRedeem\n  ) private view returns (uint256) {\n    if (podsToRedeem == 0) {\n      return 0;\n    }\n\n    s.mustBeProtocolMember(pod);\n\n    uint256 precision = s.getStablecoinPrecision();\n\n    uint256 balance = s.getStablecoinOwnedByVaultInternal(coverKey);\n    uint256 commitment = s.getTotalLiquidityUnderProtection(coverKey, precision);\n    uint256 available = balance - commitment;\n\n    uint256 releaseAmount = calculateLiquidityInternal(s, coverKey, pod, podsToRedeem);\n\n    // You may need to wait till active policies expire\n    require(available >= releaseAmount, \"Insufficient balance. Lower the amount or wait till policy expiry.\"); // solhint-disable-line\n\n    return releaseAmount;\n  }\n\n  function accrueInterestInternal(IStore s, bytes32 coverKey) external {\n    (bool isWithdrawalPeriod, , , , ) = s.getWithdrawalInfoInternal(coverKey);\n    require(isWithdrawalPeriod == true, \"Withdrawal hasn't yet begun\");\n\n    s.updateStateAndLiquidity(coverKey);\n\n    s.setAccrualCompleteInternal(coverKey, true);\n  }\n\n  function mustBeAccrued(IStore s, bytes32 coverKey) external view {\n    require(s.isAccrualCompleteInternal(coverKey) == true, \"Wait for accrual\");\n  }\n\n  /**\n   * @dev The fee to be charged for a given loan.\n   * @param s Provide an instance of the store\n   * @param token The loan currency.\n   * @param amount The amount of tokens lent.\n   * @param fee The amount of `token` to be charged for the loan, on top of the returned principal.\n   * @param protocolFee The fee received by the protocol\n   */\n  function getFlashFeesInternal(\n    IStore s,\n    bytes32 coverKey,\n    address token,\n    uint256 amount\n  ) public view returns (uint256 fee, uint256 protocolFee) {\n    address stablecoin = s.getStablecoin();\n    require(stablecoin != address(0), \"Cover liquidity uninitialized\");\n\n    /*\n    https://eips.ethereum.org/EIPS/eip-3156\n\n    The flashFee function MUST return the fee charged for a loan of amount token.\n    If the token is not supported flashFee MUST revert.\n    */\n    require(stablecoin == token, \"Unsupported token\");\n    require(IERC20(stablecoin).balanceOf(s.getVaultAddress(coverKey)) > amount, \"Amount insufficient\");\n\n    uint256 rate = _getFlashLoanFeeRateInternal(s);\n    uint256 protocolRate = _getProtocolFlashLoanFeeRateInternal(s);\n\n    fee = (amount * rate) / ProtoUtilV1.MULTIPLIER;\n    protocolFee = (fee * protocolRate) / ProtoUtilV1.MULTIPLIER;\n  }\n\n  function getFlashFeeInternal(\n    IStore s,\n    bytes32 coverKey,\n    address token,\n    uint256 amount\n  ) external view returns (uint256) {\n    (uint256 fee, ) = getFlashFeesInternal(s, coverKey, token, amount);\n    return fee;\n  }\n\n  function _getFlashLoanFeeRateInternal(IStore s) private view returns (uint256) {\n    return s.getUintByKey(ProtoUtilV1.NS_COVER_LIQUIDITY_FLASH_LOAN_FEE);\n  }\n\n  function _getProtocolFlashLoanFeeRateInternal(IStore s) private view returns (uint256) {\n    return s.getUintByKey(ProtoUtilV1.NS_COVER_LIQUIDITY_FLASH_LOAN_FEE_PROTOCOL);\n  }\n\n  /**\n   * @dev The amount of currency available to be lent.\n   * @param token The loan currency.\n   * @return The amount of `token` that can be borrowed.\n   */\n  function getMaxFlashLoanInternal(\n    IStore s,\n    bytes32 coverKey,\n    address token\n  ) external view returns (uint256) {\n    address stablecoin = s.getStablecoin();\n    require(stablecoin != address(0), \"Cover liquidity uninitialized\");\n\n    if (stablecoin == token) {\n      return IERC20(stablecoin).balanceOf(s.getVaultAddress(coverKey));\n    }\n\n    /*\n    https://eips.ethereum.org/EIPS/eip-3156\n\n    The maxFlashLoan function MUST return the maximum loan possible for token.\n    If a token is not currently supported maxFlashLoan MUST return 0, instead of reverting.    \n    */\n    return 0;\n  }\n}"
    },
    {
      "filename": "contracts/core/liquidity/VaultLiquidity.sol",
      "content": "// Neptune Mutual Protocol (https://neptunemutual.com)\n// SPDX-License-Identifier: BUSL-1.1\nimport \"./VaultBase.sol\";\n\npragma solidity ^0.8.0;\n\nabstract contract VaultLiquidity is VaultBase {\n  using ProtoUtilV1 for IStore;\n  using RegistryLibV1 for IStore;\n  using NTransferUtilV2 for IERC20;\n\n  /**\n   * @dev Transfers stablecoins to claims processor contracts for claims payout.\n   * Uses the hooks `preTransferGovernance` and `postTransferGovernance` on the vault delegate contract.\n   *\n   * @custom:suppress-acl This function is only callable by the claims processor as checked in `preTransferGovernance` and `postTransferGovernace`\n   * @custom:suppress-pausable\n   *\n   */\n  function transferGovernance(\n    bytes32 coverKey,\n    address to,\n    uint256 amount\n  ) external override nonReentrant {\n    require(coverKey == key, \"Forbidden\");\n    require(amount > 0, \"Please specify amount\");\n\n    /******************************************************************************************\n      PRE\n     ******************************************************************************************/\n    address stablecoin = delgate().preTransferGovernance(msg.sender, coverKey, to, amount);\n\n    /******************************************************************************************\n      BODY\n     ******************************************************************************************/\n\n    IERC20(stablecoin).ensureTransfer(to, amount);\n\n    /******************************************************************************************\n      POST\n     ******************************************************************************************/\n    delgate().postTransferGovernance(msg.sender, coverKey, to, amount);\n    emit GovernanceTransfer(to, amount);\n  }\n\n  /**\n   * @dev Adds liquidity to the specified cover contract.\n   * Uses the hooks `preAddLiquidity` and `postAddLiquidity` on the vault delegate contract.\n   *\n   * @custom:suppress-acl This is a publicly accessible feature\n   * @custom:suppress-pausable\n   *\n   * @param coverKey Enter the cover key\n   * @param amount Enter the amount of liquidity token to supply.\n   * @param npmStakeToAdd Enter the amount of NPM token to stake.\n   *\n   */\n  function addLiquidity(\n    bytes32 coverKey,\n    uint256 amount,\n    uint256 npmStakeToAdd,\n    bytes32 referralCode\n  ) external override nonReentrant {\n    require(coverKey == key, \"Forbidden\");\n    require(amount > 0, \"Please specify amount\");\n\n    /******************************************************************************************\n      PRE\n     ******************************************************************************************/\n\n    (uint256 podsToMint, uint256 previousNpmStake) = delgate().preAddLiquidity(msg.sender, coverKey, amount, npmStakeToAdd);\n\n    require(podsToMint > 0, \"Can't determine PODs\");\n\n    /******************************************************************************************\n      BODY\n     ******************************************************************************************/\n\n    IERC20(sc).ensureTransferFrom(msg.sender, address(this), amount);\n\n    if (npmStakeToAdd > 0) {\n      IERC20(s.getNpmTokenAddress()).ensureTransferFrom(msg.sender, address(this), npmStakeToAdd);\n    }\n\n    super._mint(msg.sender, podsToMint);\n\n    /******************************************************************************************\n      POST\n     ******************************************************************************************/\n\n    delgate().postAddLiquidity(msg.sender, coverKey, amount, npmStakeToAdd);\n\n    emit PodsIssued(msg.sender, podsToMint, amount, referralCode);\n\n    if (previousNpmStake == 0) {\n      emit Entered(coverKey, msg.sender);\n    }\n\n    emit NpmStaken(msg.sender, npmStakeToAdd);\n  }\n\n  /**\n   * @dev Removes liquidity from the specified cover contract\n   * Uses the hooks `preRemoveLiquidity` and `postRemoveLiquidity` on the vault delegate contract.\n   *\n   * @custom:suppress-acl This is a publicly accessible feature\n   * @custom:suppress-pausable\n   *\n   * @param coverKey Enter the cover key\n   * @param podsToRedeem Enter the amount of pods to redeem\n   * @param npmStakeToRemove Enter the amount of NPM stake to remove.\n   */\n  function removeLiquidity(\n    bytes32 coverKey,\n    uint256 podsToRedeem,\n    uint256 npmStakeToRemove,\n    bool exit\n  ) external override nonReentrant {\n    require(coverKey == key, \"Forbidden\");\n    require(podsToRedeem > 0 || npmStakeToRemove > 0, \"Please specify amount\");\n\n    /******************************************************************************************\n      PRE\n     ******************************************************************************************/\n    (address stablecoin, uint256 stablecoinToRelease) = delgate().preRemoveLiquidity(msg.sender, coverKey, podsToRedeem, npmStakeToRemove, exit);\n\n    /******************************************************************************************\n      BODY\n     ******************************************************************************************/\n    if(podsToRedeem > 0) {\n      IERC20(address(this)).ensureTransferFrom(msg.sender, address(this), podsToRedeem);\n      IERC20(stablecoin).ensureTransfer(msg.sender, stablecoinToRelease);\n    }\n\n    super._burn(address(this), podsToRedeem);\n\n    // Unstake NPM tokens\n    if (npmStakeToRemove > 0) {\n      IERC20(s.getNpmTokenAddress()).ensureTransfer(msg.sender, npmStakeToRemove);\n    }\n\n    /******************************************************************************************\n      POST\n     ******************************************************************************************/\n    delgate().postRemoveLiquidity(msg.sender, coverKey, podsToRedeem, npmStakeToRemove, exit);\n\n    emit PodsRedeemed(msg.sender, podsToRedeem, stablecoinToRelease);\n\n    if (exit) {\n      emit Exited(coverKey, msg.sender);\n    }\n\n    if (npmStakeToRemove > 0) {\n      emit NpmUnstaken(msg.sender, npmStakeToRemove);\n    }\n  }\n\n  /**\n   * @dev Calculates the amount of PODS to mint for the given amount of liquidity to transfer\n   */\n  function calculatePods(uint256 forStablecoinUnits) external view override returns (uint256) {\n    return delgate().calculatePodsImplementation(key, forStablecoinUnits);\n  }\n\n  /**\n   * @dev Calculates the amount of stablecoins to withdraw for the given amount of PODs to redeem\n   */\n  function calculateLiquidity(uint256 podsToBurn) external view override returns (uint256) {\n    return delgate().calculateLiquidityImplementation(key, podsToBurn);\n  }\n\n  /**\n   * @dev Returns the stablecoin balance of this vault\n   * This also includes amounts lent out in lending strategies\n   */\n  function getStablecoinBalanceOf() external view override returns (uint256) {\n    return delgate().getStablecoinBalanceOfImplementation(key);\n  }\n\n  /**\n   * @dev Accrues interests from external straties\n   *\n   * @custom:suppress-acl This is a publicly accessible feature\n   * @custom:suppress-pausable Validated in `accrueInterestImplementation`\n   *\n   */\n  function accrueInterest() external override nonReentrant {\n    delgate().accrueInterestImplementation(msg.sender, key);\n    emit InterestAccrued(key);\n  }\n}"
    }
  ]
}