{
  "Title": "[M-13] User might execute `PositionToken` of token set by previous token owner",
  "Content": "\nThe `AutoRange.configToken()` function updates the state variable `positionConfigs` for a `tokenId` and callable by the owner of the `tokenId`. However, in the call to `AutoRange.execute()`, the state variable `positionConfigs` for the `tokenId` is used in setting the local variable `PositionConfig memory config` without any further check to ensure the config has been set by the current owner of the `tokenId`.\n\nThis in some way could affect the swapcall on the token position such that the protocol does not receive any incentive.\n\n### Proof of Concept\n\n1. Alice is an operator and owns token 1 and sets the `configToken()` to configure token to be used before calling `executeWithVault()`.\n\n<https://github.com/code-423n4/2024-03-revert-lend/blob/main/src/transformers/AutoRange.sol#L276-L297>\n\n`positionConfigs` state variable for `tokenId` is set in `configToken()` by token owner:\n\n    function configToken(uint256 tokenId, address vault, PositionConfig calldata config) external {\n            _validateOwner(tokenId, vault);\n\n            // lower tick must be always below or equal to upper tick - if they are equal - range adjustment is deactivated\n            if (config.lowerTickDelta > config.upperTickDelta) {\n                revert InvalidConfig();\n            }\n\n            positionConfigs[tokenId] = config;\n\n2. After a while and eventually Alice no longer has any position on token and transfers the token to Bob.\n\n3. Bob is another operator and calls `executeWithVault()`; the calls happen using the old token config set by Alice.\n\n<https://github.com/code-423n4/2024-03-revert-lend/blob/main/src/transformers/AutoRange.sol#L111-L116>\n\n`positionConfigs`\\[`tokenId`] set by a previous `tokenId` owner being used:\n\n    function execute(ExecuteParams calldata params) external {\n            if (!operators[msg.sender] && !vaults[msg.sender]) {\n                revert Unauthorized();\n            }\n            ExecuteState memory state;\n            PositionConfig memory config = positionConfigs[params.tokenId];\n\n### Recommended Mitigation Steps\n\nUsing an enumerable set or additional mapping parameter to set the current owner in the `positionConfigs` state variable and an additional check in `execute()` to ensure the config was set by token owner.\n\n**[kalinbas (Revert) acknowledged and commented](https://github.com/code-423n4/2024-03-revert-lend-findings/issues/256#issuecomment-2020889898):**\n > Position config is not reset when transferring a position to someone else, but the operator `approval`/`approvalforall` is reset. So the position can't be automated anymore, and if it is given approval, the revert UI will also let the user set the new config. So this is valid but not a problem.\n\n**[ronnyx2017 (judge) commented](https://github.com/code-423n4/2024-03-revert-lend-findings/issues/256#issuecomment-2028615749):**\n > Makes sense. I also believe that frontend security checks are unreliable, so I'm still maintaining it as an Medium.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-03-revert-lend",
  "Code": [
    {
      "filename": "src/transformers/AutoRange.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"../automators/Automator.sol\";\n\n/// @title AutoRange\n/// @notice Allows operator of AutoRange contract (Revert controlled bot) to change range for configured positions\n/// Positions need to be approved (setApprovalForAll) for the contract and configured with configToken method\n/// When executed a new position is created and automatically configured the same way as the original position\n/// When position is inside Vault - transform is called\ncontract AutoRange is Automator {\n    event RangeChanged(uint256 indexed oldTokenId, uint256 indexed newTokenId);\n    event PositionConfigured(\n        uint256 indexed tokenId,\n        int32 lowerTickLimit,\n        int32 upperTickLimit,\n        int32 lowerTickDelta,\n        int32 upperTickDelta,\n        uint64 token0SlippageX64,\n        uint64 token1SlippageX64,\n        bool onlyFees,\n        uint64 maxRewardX64\n    );\n\n    constructor(\n        INonfungiblePositionManager _npm,\n        address _operator,\n        address _withdrawer,\n        uint32 _TWAPSeconds,\n        uint16 _maxTWAPTickDifference,\n        address _zeroxRouter,\n        address _universalRouter\n    ) Automator(_npm, _operator, _withdrawer, _TWAPSeconds, _maxTWAPTickDifference, _zeroxRouter, _universalRouter) {}\n\n    // defines when and how a position can be changed by operator\n    // when a position is adjusted config for the position is cleared and copied to the newly created position\n    struct PositionConfig {\n        // needs more than int24 because it can be [-type(uint24).max,type(uint24).max]\n        int32 lowerTickLimit; // if negative also in-range positions may be adjusted / if 0 out of range positions may be adjusted\n        int32 upperTickLimit; // if negative also in-range positions may be adjusted / if 0 out of range positions may be adjusted\n        int32 lowerTickDelta; // this amount is added to current tick (floored to tickspacing) to define lowerTick of new position\n        int32 upperTickDelta; // this amount is added to current tick (floored to tickspacing) to define upperTick of new position\n        uint64 token0SlippageX64; // max price difference from current pool price for swap / Q64 for token0\n        uint64 token1SlippageX64; // max price difference from current pool price for swap / Q64 for token1\n        bool onlyFees; // if only fees maybe used for protocol reward\n        uint64 maxRewardX64; // max allowed reward percentage of fees or full position\n    }\n\n    // configured tokens\n    mapping(uint256 => PositionConfig) public positionConfigs;\n\n    /// @notice params for execute()\n    struct ExecuteParams {\n        uint256 tokenId;\n        bool swap0To1;\n        uint256 amountIn; // if this is set to 0 no swap happens\n        bytes swapData;\n        uint128 liquidity; // liquidity the calculations are based on\n        uint256 amountRemoveMin0; // min amount to be removed from liquidity\n        uint256 amountRemoveMin1; // min amount to be removed from liquidity\n        uint256 deadline; // for uniswap operations - operator promises fair value\n        uint64 rewardX64; // which reward will be used for protocol, can be max configured amount (considering onlyFees)\n    }\n\n    struct ExecuteState {\n        address owner;\n        address realOwner;\n        IUniswapV3Pool pool;\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        int24 currentTick;\n        uint256 amount0;\n        uint256 amount1;\n        uint256 feeAmount0;\n        uint256 feeAmount1;\n        uint256 maxAddAmount0;\n        uint256 maxAddAmount1;\n        uint256 amountAdded0;\n        uint256 amountAdded1;\n        uint128 liquidity;\n        uint256 protocolReward0;\n        uint256 protocolReward1;\n        uint256 amountOutMin;\n        uint256 amountInDelta;\n        uint256 amountOutDelta;\n        uint256 newTokenId;\n    }\n\n    /**\n     * @notice Adjust token (which is in a Vault) - via transform method\n     * Can only be called from configured operator account - vault must be configured as well\n     * Swap needs to be done with max price difference from current pool price - otherwise reverts\n     */\n    function executeWithVault(ExecuteParams calldata params, address vault) external {\n        if (!operators[msg.sender] || !vaults[vault]) {\n            revert Unauthorized();\n        }\n        IVault(vault).transform(\n            params.tokenId, address(this), abi.encodeWithSelector(AutoRange.execute.selector, params)\n        );\n    }\n\n    /**\n     * @notice Adjust token directly (must be in correct state)\n     * Can only be called only from configured operator account, or vault via transform\n     * Swap needs to be done with max price difference from current pool price - otherwise reverts\n     */\n    function execute(ExecuteParams calldata params) external {\n        if (!operators[msg.sender] && !vaults[msg.sender]) {\n            revert Unauthorized();\n        }\n        ExecuteState memory state;\n        PositionConfig memory config = positionConfigs[params.tokenId];\n\n        if (config.lowerTickDelta == config.upperTickDelta) {\n            revert NotConfigured();\n        }\n\n        if (\n            config.onlyFees && params.rewardX64 > config.maxRewardX64\n                || !config.onlyFees && params.rewardX64 > config.maxRewardX64\n        ) {\n            revert ExceedsMaxReward();\n        }\n\n        // get position info\n        (,, state.token0, state.token1, state.fee, state.tickLower, state.tickUpper, state.liquidity,,,,) =\n            nonfungiblePositionManager.positions(params.tokenId);\n\n        if (state.liquidity != params.liquidity) {\n            revert LiquidityChanged();\n        }\n\n        (state.amount0, state.amount1, state.feeAmount0, state.feeAmount1) = _decreaseFullLiquidityAndCollect(\n            params.tokenId, state.liquidity, params.amountRemoveMin0, params.amountRemoveMin1, params.deadline\n        );\n\n        // if only fees reward is removed before adding\n        if (config.onlyFees) {\n            state.protocolReward0 = state.feeAmount0 * params.rewardX64 / Q64;\n            state.protocolReward1 = state.feeAmount1 * params.rewardX64 / Q64;\n            state.amount0 -= state.protocolReward0;\n            state.amount1 -= state.protocolReward1;\n        }\n\n        if (params.swap0To1 && params.amountIn > state.amount0 || !params.swap0To1 && params.amountIn > state.amount1) {\n            revert SwapAmountTooLarge();\n        }\n\n        // get pool info\n        state.pool = _getPool(state.token0, state.token1, state.fee);\n\n        // check oracle for swap\n        (state.amountOutMin, state.currentTick,,) = _validateSwap(\n            params.swap0To1,\n            params.amountIn,\n            state.pool,\n            TWAPSeconds,\n            maxTWAPTickDifference,\n            params.swap0To1 ? config.token0SlippageX64 : config.token1SlippageX64\n        );\n\n        if (\n            state.currentTick < state.tickLower - config.lowerTickLimit\n                || state.currentTick >= state.tickUpper + config.upperTickLimit\n        ) {\n            int24 tickSpacing = _getTickSpacing(state.fee);\n            int24 baseTick = state.currentTick - (((state.currentTick % tickSpacing) + tickSpacing) % tickSpacing);\n\n            // check if new range same as old range\n            if (\n                baseTick + config.lowerTickDelta == state.tickLower\n                    && baseTick + config.upperTickDelta == state.tickUpper\n            ) {\n                revert SameRange();\n            }\n\n            (state.amountInDelta, state.amountOutDelta) = _routerSwap(\n                Swapper.RouterSwapParams(\n                    params.swap0To1 ? IERC20(state.token0) : IERC20(state.token1),\n                    params.swap0To1 ? IERC20(state.token1) : IERC20(state.token0),\n                    params.amountIn,\n                    state.amountOutMin,\n                    params.swapData\n                )\n            );\n\n            state.amount0 = params.swap0To1 ? state.amount0 - state.amountInDelta : state.amount0 + state.amountOutDelta;\n            state.amount1 = params.swap0To1 ? state.amount1 + state.amountOutDelta : state.amount1 - state.amountInDelta;\n\n            // max amount to add - removing max potential fees (if config.onlyFees - the have been removed already)\n            state.maxAddAmount0 = config.onlyFees ? state.amount0 : state.amount0 * Q64 / (params.rewardX64 + Q64);\n            state.maxAddAmount1 = config.onlyFees ? state.amount1 : state.amount1 * Q64 / (params.rewardX64 + Q64);\n\n            INonfungiblePositionManager.MintParams memory mintParams = INonfungiblePositionManager.MintParams(\n                address(state.token0),\n                address(state.token1),\n                state.fee,\n                SafeCast.toInt24(baseTick + config.lowerTickDelta), // reverts if out of valid range\n                SafeCast.toInt24(baseTick + config.upperTickDelta), // reverts if out of valid range\n                state.maxAddAmount0,\n                state.maxAddAmount1,\n                0,\n                0,\n                address(this), // is sent to real recipient aftwards\n                params.deadline\n            );\n\n            // approve npm\n            SafeERC20.safeApprove(IERC20(state.token0), address(nonfungiblePositionManager), state.maxAddAmount0);\n            SafeERC20.safeApprove(IERC20(state.token1), address(nonfungiblePositionManager), state.maxAddAmount1);\n\n            // mint is done to address(this) first - its not a safemint\n            (state.newTokenId,, state.amountAdded0, state.amountAdded1) = nonfungiblePositionManager.mint(mintParams);\n\n            // remove remaining approval\n            SafeERC20.safeApprove(IERC20(state.token0), address(nonfungiblePositionManager), 0);\n            SafeERC20.safeApprove(IERC20(state.token1), address(nonfungiblePositionManager), 0);\n\n            state.owner = nonfungiblePositionManager.ownerOf(params.tokenId);\n\n            // get the real owner - if owner is vault - for sending leftover tokens\n            state.realOwner = state.owner;\n            if (vaults[state.owner]) {\n                state.realOwner = IVault(state.owner).ownerOf(params.tokenId);\n            }\n\n            // send the new nft to the owner / vault\n            nonfungiblePositionManager.safeTransferFrom(address(this), state.owner, state.newTokenId);\n\n            // protocol reward is calculated based on added amount (to incentivize optimal swap done by operator)\n            if (!config.onlyFees) {\n                state.protocolReward0 = state.amountAdded0 * params.rewardX64 / Q64;\n                state.protocolReward1 = state.amountAdded1 * params.rewardX64 / Q64;\n                state.amount0 -= state.protocolReward0;\n                state.amount1 -= state.protocolReward1;\n            }\n\n            // send leftover to real owner\n            if (state.amount0 - state.amountAdded0 > 0) {\n                _transferToken(state.realOwner, IERC20(state.token0), state.amount0 - state.amountAdded0, true);\n            }\n            if (state.amount1 - state.amountAdded1 > 0) {\n                _transferToken(state.realOwner, IERC20(state.token1), state.amount1 - state.amountAdded1, true);\n            }\n\n            // copy token config for new token\n            positionConfigs[state.newTokenId] = config;\n            emit PositionConfigured(\n                state.newTokenId,\n                config.lowerTickLimit,\n                config.upperTickLimit,\n                config.lowerTickDelta,\n                config.upperTickDelta,\n                config.token0SlippageX64,\n                config.token1SlippageX64,\n                config.onlyFees,\n                config.maxRewardX64\n            );\n\n            // delete config for old position\n            delete positionConfigs[params.tokenId];\n            emit PositionConfigured(params.tokenId, 0, 0, 0, 0, 0, 0, false, 0);\n\n            emit RangeChanged(params.tokenId, state.newTokenId);\n        } else {\n            revert NotReady();\n        }\n    }\n\n    // function to configure a token to be used with this runner\n    // it needs to have approvals set for this contract beforehand\n    function configToken(uint256 tokenId, address vault, PositionConfig calldata config) external {\n        _validateOwner(tokenId, vault);\n\n        // lower tick must be always below or equal to upper tick - if they are equal - range adjustment is deactivated\n        if (config.lowerTickDelta > config.upperTickDelta) {\n            revert InvalidConfig();\n        }\n\n        positionConfigs[tokenId] = config;\n\n        emit PositionConfigured(\n            tokenId,\n            config.lowerTickLimit,\n            config.upperTickLimit,\n            config.lowerTickDelta,\n            config.upperTickDelta,\n            config.token0SlippageX64,\n            config.token1SlippageX64,\n            config.onlyFees,\n            config.maxRewardX64\n        );\n    }\n\n    // get tick spacing for fee tier (cached when possible)\n    function _getTickSpacing(uint24 fee) internal view returns (int24) {\n        if (fee == 10000) {\n            return 200;\n        } else if (fee == 3000) {\n            return 60;\n        } else if (fee == 500) {\n            return 10;\n        } else {\n            int24 spacing = IUniswapV3Factory(factory).feeAmountTickSpacing(fee);\n            if (spacing <= 0) {\n                revert NotSupportedFeeTier();\n            }\n            return spacing;\n        }\n    }\n}"
    },
    {
      "filename": "src/transformers/AutoRange.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"../automators/Automator.sol\";\n\n/// @title AutoRange\n/// @notice Allows operator of AutoRange contract (Revert controlled bot) to change range for configured positions\n/// Positions need to be approved (setApprovalForAll) for the contract and configured with configToken method\n/// When executed a new position is created and automatically configured the same way as the original position\n/// When position is inside Vault - transform is called\ncontract AutoRange is Automator {\n    event RangeChanged(uint256 indexed oldTokenId, uint256 indexed newTokenId);\n    event PositionConfigured(\n        uint256 indexed tokenId,\n        int32 lowerTickLimit,\n        int32 upperTickLimit,\n        int32 lowerTickDelta,\n        int32 upperTickDelta,\n        uint64 token0SlippageX64,\n        uint64 token1SlippageX64,\n        bool onlyFees,\n        uint64 maxRewardX64\n    );\n\n    constructor(\n        INonfungiblePositionManager _npm,\n        address _operator,\n        address _withdrawer,\n        uint32 _TWAPSeconds,\n        uint16 _maxTWAPTickDifference,\n        address _zeroxRouter,\n        address _universalRouter\n    ) Automator(_npm, _operator, _withdrawer, _TWAPSeconds, _maxTWAPTickDifference, _zeroxRouter, _universalRouter) {}\n\n    // defines when and how a position can be changed by operator\n    // when a position is adjusted config for the position is cleared and copied to the newly created position\n    struct PositionConfig {\n        // needs more than int24 because it can be [-type(uint24).max,type(uint24).max]\n        int32 lowerTickLimit; // if negative also in-range positions may be adjusted / if 0 out of range positions may be adjusted\n        int32 upperTickLimit; // if negative also in-range positions may be adjusted / if 0 out of range positions may be adjusted\n        int32 lowerTickDelta; // this amount is added to current tick (floored to tickspacing) to define lowerTick of new position\n        int32 upperTickDelta; // this amount is added to current tick (floored to tickspacing) to define upperTick of new position\n        uint64 token0SlippageX64; // max price difference from current pool price for swap / Q64 for token0\n        uint64 token1SlippageX64; // max price difference from current pool price for swap / Q64 for token1\n        bool onlyFees; // if only fees maybe used for protocol reward\n        uint64 maxRewardX64; // max allowed reward percentage of fees or full position\n    }\n\n    // configured tokens\n    mapping(uint256 => PositionConfig) public positionConfigs;\n\n    /// @notice params for execute()\n    struct ExecuteParams {\n        uint256 tokenId;\n        bool swap0To1;\n        uint256 amountIn; // if this is set to 0 no swap happens\n        bytes swapData;\n        uint128 liquidity; // liquidity the calculations are based on\n        uint256 amountRemoveMin0; // min amount to be removed from liquidity\n        uint256 amountRemoveMin1; // min amount to be removed from liquidity\n        uint256 deadline; // for uniswap operations - operator promises fair value\n        uint64 rewardX64; // which reward will be used for protocol, can be max configured amount (considering onlyFees)\n    }\n\n    struct ExecuteState {\n        address owner;\n        address realOwner;\n        IUniswapV3Pool pool;\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        int24 currentTick;\n        uint256 amount0;\n        uint256 amount1;\n        uint256 feeAmount0;\n        uint256 feeAmount1;\n        uint256 maxAddAmount0;\n        uint256 maxAddAmount1;\n        uint256 amountAdded0;\n        uint256 amountAdded1;\n        uint128 liquidity;\n        uint256 protocolReward0;\n        uint256 protocolReward1;\n        uint256 amountOutMin;\n        uint256 amountInDelta;\n        uint256 amountOutDelta;\n        uint256 newTokenId;\n    }\n\n    /**\n     * @notice Adjust token (which is in a Vault) - via transform method\n     * Can only be called from configured operator account - vault must be configured as well\n     * Swap needs to be done with max price difference from current pool price - otherwise reverts\n     */\n    function executeWithVault(ExecuteParams calldata params, address vault) external {\n        if (!operators[msg.sender] || !vaults[vault]) {\n            revert Unauthorized();\n        }\n        IVault(vault).transform(\n            params.tokenId, address(this), abi.encodeWithSelector(AutoRange.execute.selector, params)\n        );\n    }\n\n    /**\n     * @notice Adjust token directly (must be in correct state)\n     * Can only be called only from configured operator account, or vault via transform\n     * Swap needs to be done with max price difference from current pool price - otherwise reverts\n     */\n    function execute(ExecuteParams calldata params) external {\n        if (!operators[msg.sender] && !vaults[msg.sender]) {\n            revert Unauthorized();\n        }\n        ExecuteState memory state;\n        PositionConfig memory config = positionConfigs[params.tokenId];\n\n        if (config.lowerTickDelta == config.upperTickDelta) {\n            revert NotConfigured();\n        }\n\n        if (\n            config.onlyFees && params.rewardX64 > config.maxRewardX64\n                || !config.onlyFees && params.rewardX64 > config.maxRewardX64\n        ) {\n            revert ExceedsMaxReward();\n        }\n\n        // get position info\n        (,, state.token0, state.token1, state.fee, state.tickLower, state.tickUpper, state.liquidity,,,,) =\n            nonfungiblePositionManager.positions(params.tokenId);\n\n        if (state.liquidity != params.liquidity) {\n            revert LiquidityChanged();\n        }\n\n        (state.amount0, state.amount1, state.feeAmount0, state.feeAmount1) = _decreaseFullLiquidityAndCollect(\n            params.tokenId, state.liquidity, params.amountRemoveMin0, params.amountRemoveMin1, params.deadline\n        );\n\n        // if only fees reward is removed before adding\n        if (config.onlyFees) {\n            state.protocolReward0 = state.feeAmount0 * params.rewardX64 / Q64;\n            state.protocolReward1 = state.feeAmount1 * params.rewardX64 / Q64;\n            state.amount0 -= state.protocolReward0;\n            state.amount1 -= state.protocolReward1;\n        }\n\n        if (params.swap0To1 && params.amountIn > state.amount0 || !params.swap0To1 && params.amountIn > state.amount1) {\n            revert SwapAmountTooLarge();\n        }\n\n        // get pool info\n        state.pool = _getPool(state.token0, state.token1, state.fee);\n\n        // check oracle for swap\n        (state.amountOutMin, state.currentTick,,) = _validateSwap(\n            params.swap0To1,\n            params.amountIn,\n            state.pool,\n            TWAPSeconds,\n            maxTWAPTickDifference,\n            params.swap0To1 ? config.token0SlippageX64 : config.token1SlippageX64\n        );\n\n        if (\n            state.currentTick < state.tickLower - config.lowerTickLimit\n                || state.currentTick >= state.tickUpper + config.upperTickLimit\n        ) {\n            int24 tickSpacing = _getTickSpacing(state.fee);\n            int24 baseTick = state.currentTick - (((state.currentTick % tickSpacing) + tickSpacing) % tickSpacing);\n\n            // check if new range same as old range\n            if (\n                baseTick + config.lowerTickDelta == state.tickLower\n                    && baseTick + config.upperTickDelta == state.tickUpper\n            ) {\n                revert SameRange();\n            }\n\n            (state.amountInDelta, state.amountOutDelta) = _routerSwap(\n                Swapper.RouterSwapParams(\n                    params.swap0To1 ? IERC20(state.token0) : IERC20(state.token1),\n                    params.swap0To1 ? IERC20(state.token1) : IERC20(state.token0),\n                    params.amountIn,\n                    state.amountOutMin,\n                    params.swapData\n                )\n            );\n\n            state.amount0 = params.swap0To1 ? state.amount0 - state.amountInDelta : state.amount0 + state.amountOutDelta;\n            state.amount1 = params.swap0To1 ? state.amount1 + state.amountOutDelta : state.amount1 - state.amountInDelta;\n\n            // max amount to add - removing max potential fees (if config.onlyFees - the have been removed already)\n            state.maxAddAmount0 = config.onlyFees ? state.amount0 : state.amount0 * Q64 / (params.rewardX64 + Q64);\n            state.maxAddAmount1 = config.onlyFees ? state.amount1 : state.amount1 * Q64 / (params.rewardX64 + Q64);\n\n            INonfungiblePositionManager.MintParams memory mintParams = INonfungiblePositionManager.MintParams(\n                address(state.token0),\n                address(state.token1),\n                state.fee,\n                SafeCast.toInt24(baseTick + config.lowerTickDelta), // reverts if out of valid range\n                SafeCast.toInt24(baseTick + config.upperTickDelta), // reverts if out of valid range\n                state.maxAddAmount0,\n                state.maxAddAmount1,\n                0,\n                0,\n                address(this), // is sent to real recipient aftwards\n                params.deadline\n            );\n\n            // approve npm\n            SafeERC20.safeApprove(IERC20(state.token0), address(nonfungiblePositionManager), state.maxAddAmount0);\n            SafeERC20.safeApprove(IERC20(state.token1), address(nonfungiblePositionManager), state.maxAddAmount1);\n\n            // mint is done to address(this) first - its not a safemint\n            (state.newTokenId,, state.amountAdded0, state.amountAdded1) = nonfungiblePositionManager.mint(mintParams);\n\n            // remove remaining approval\n            SafeERC20.safeApprove(IERC20(state.token0), address(nonfungiblePositionManager), 0);\n            SafeERC20.safeApprove(IERC20(state.token1), address(nonfungiblePositionManager), 0);\n\n            state.owner = nonfungiblePositionManager.ownerOf(params.tokenId);\n\n            // get the real owner - if owner is vault - for sending leftover tokens\n            state.realOwner = state.owner;\n            if (vaults[state.owner]) {\n                state.realOwner = IVault(state.owner).ownerOf(params.tokenId);\n            }\n\n            // send the new nft to the owner / vault\n            nonfungiblePositionManager.safeTransferFrom(address(this), state.owner, state.newTokenId);\n\n            // protocol reward is calculated based on added amount (to incentivize optimal swap done by operator)\n            if (!config.onlyFees) {\n                state.protocolReward0 = state.amountAdded0 * params.rewardX64 / Q64;\n                state.protocolReward1 = state.amountAdded1 * params.rewardX64 / Q64;\n                state.amount0 -= state.protocolReward0;\n                state.amount1 -= state.protocolReward1;\n            }\n\n            // send leftover to real owner\n            if (state.amount0 - state.amountAdded0 > 0) {\n                _transferToken(state.realOwner, IERC20(state.token0), state.amount0 - state.amountAdded0, true);\n            }\n            if (state.amount1 - state.amountAdded1 > 0) {\n                _transferToken(state.realOwner, IERC20(state.token1), state.amount1 - state.amountAdded1, true);\n            }\n\n            // copy token config for new token\n            positionConfigs[state.newTokenId] = config;\n            emit PositionConfigured(\n                state.newTokenId,\n                config.lowerTickLimit,\n                config.upperTickLimit,\n                config.lowerTickDelta,\n                config.upperTickDelta,\n                config.token0SlippageX64,\n                config.token1SlippageX64,\n                config.onlyFees,\n                config.maxRewardX64\n            );\n\n            // delete config for old position\n            delete positionConfigs[params.tokenId];\n            emit PositionConfigured(params.tokenId, 0, 0, 0, 0, 0, 0, false, 0);\n\n            emit RangeChanged(params.tokenId, state.newTokenId);\n        } else {\n            revert NotReady();\n        }\n    }\n\n    // function to configure a token to be used with this runner\n    // it needs to have approvals set for this contract beforehand\n    function configToken(uint256 tokenId, address vault, PositionConfig calldata config) external {\n        _validateOwner(tokenId, vault);\n\n        // lower tick must be always below or equal to upper tick - if they are equal - range adjustment is deactivated\n        if (config.lowerTickDelta > config.upperTickDelta) {\n            revert InvalidConfig();\n        }\n\n        positionConfigs[tokenId] = config;\n\n        emit PositionConfigured(\n            tokenId,\n            config.lowerTickLimit,\n            config.upperTickLimit,\n            config.lowerTickDelta,\n            config.upperTickDelta,\n            config.token0SlippageX64,\n            config.token1SlippageX64,\n            config.onlyFees,\n            config.maxRewardX64\n        );\n    }\n\n    // get tick spacing for fee tier (cached when possible)\n    function _getTickSpacing(uint24 fee) internal view returns (int24) {\n        if (fee == 10000) {\n            return 200;\n        } else if (fee == 3000) {\n            return 60;\n        } else if (fee == 500) {\n            return 10;\n        } else {\n            int24 spacing = IUniswapV3Factory(factory).feeAmountTickSpacing(fee);\n            if (spacing <= 0) {\n                revert NotSupportedFeeTier();\n            }\n            return spacing;\n        }\n    }\n}"
    }
  ]
}