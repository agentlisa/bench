{
  "Title": "Slashing mechanism grants exponentially more rewards than expected",
  "Content": "In the [`VotingV2`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/VotingV2.sol) contract the function [`updateTrackers`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/VotingV2.sol#798) calls the internal function [`_updateAccountSlashingTrackers`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/VotingV2.sol#L831) with parameter `indexTo` set to the `priceRequestIds.length` to process the slashing rewards and penalties associated with all resolved requests.\n\n\nWithin the `_updateAccountSlashingTrackers` function, a for-loop processes all requests starting with the last request that has not yet been considered for the respective voter up to `priceRequestIds = indexTo - 1`. During this process it is [ensured](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/VotingV2.sol#L915) that any `slash` changes throughout one voting round are first accumulated and only applied at the end of the round. This ensures that slash rewards and penalties within one round accumulate linearly instead of exponentially. More specifically, the value `activeStake` which is directly proportional to any penalties and rewards received is meant to be kept constant throughout each round, but should be altered by the amount `slash` between rounds. Finally, the function `_updateAccountSlashingTrackers` applies all remaining `slash` changes to the voter’s `activeStake` regardless of round boundaries.\n\n\nAdditionally, the contract contains a function [`updateTrackersRange`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/VotingV2.sol#L809) that is callable without authorization, with freely chosen parameters `voterAddress` and `indexTo` which are passed to `_updateAccountSlashingTrackers`. The use of this function is necessary whenever the potentially unbounded amount of requests to be processed within the for-loop exceeds the gas limit.\n\n\n**Issue:** Assume that a voter has committed and revealed multiple votes within one round, and that these votes are resolved and correct. Further assume the voter has not yet called `commitVote` in any of the following rounds (which will automatically call `_updateTrackers` internally). In this scenario, the voter can obtain exponentially more `slash` rewards than intended by applying the steps outlined in the **Strategy** section below. Moreover, this will lead to the total `slash` reward payout exceeding the captured `slash` penalties, in contrast to the expectation of both quantities always being equal. In effect, the staking balances stored in `VotingV2` will no longer be backed by actual UMA tokens contained in the same contract. This will render many stakers unable to withdraw their stake and equip exploiters with disproportionally large voting power thereby breaking the core functionality for the UMA ecosystem.\n\n\n**Strategy:** To receive exponentially more rewards, a voter must avoid calling `updateTrackers` which linearly accumulates their rewards (by computing them against the same, round-wise fix value of `activeStake`) and instead perform multiple calls to `updateTrackersRange` with increasing values of `indexTo`, such that the function `_updateAccountSlashingTrackers` processes each request – in which the voter committed & revealed a correct vote in said round – individually. Because each call changes the voter’s `activeStake`, this strategy leads to an exponential accumulation of slashing rewards instead of the intended roundwise-linear accumulation of rewards.\n\n\nConsider modifying the respective `update` functions to ensure that `slash` values can only be applied round-wise. Additionally, consider implementing a monitoring solution that continuously checks whether the sum of all staked balances is equal to the amount of UMA contained within the contract and whether this value lies within an expected range. Finally, consider implementing an emergency mechanism to temporarily suspend the reward system without affecting the contract’s functionality as a governance and voting system.\n\n\n**Update:** *Fixed as of commit [`18aef110f2bc882a9bfe115bc4ca86f3681f2d4b`](https://github.com/UMAprotocol/protocol/pull/4067/commits/18aef110f2bc882a9bfe115bc4ca86f3681f2d4b) in [pull request #4067](https://github.com/UMAprotocol/protocol/pull/4067).*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "packages/core/contracts/oracle/implementation/VotingV2.sol",
      "content": "// TODO: this whole /oracle/implementation directory should be restructured to separate the DVM and the OO.\n\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"../../common/implementation/AncillaryData.sol\";\nimport \"../../common/implementation/MultiCaller.sol\";\n\nimport \"../interfaces/FinderInterface.sol\";\nimport \"../interfaces/IdentifierWhitelistInterface.sol\";\nimport \"../interfaces/OracleAncillaryInterface.sol\";\nimport \"../interfaces/OracleGovernanceInterface.sol\";\nimport \"../interfaces/OracleInterface.sol\";\nimport \"../interfaces/VotingV2Interface.sol\";\nimport \"./Constants.sol\";\nimport \"./Registry.sol\";\nimport \"./ResultComputationV2.sol\";\nimport \"./SlashingLibrary.sol\";\nimport \"./SpamGuardIdentifierLib.sol\";\nimport \"./Staker.sol\";\nimport \"./VoteTimingV2.sol\";\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n/**\n * @title VotingV2 contract for UMA's DVM mechanism.\n * @dev Handles receiving and resolving price requests via a commit-reveal voting schelling scheme.\n */\n\ncontract VotingV2 is\n    Staker,\n    OracleInterface,\n    OracleAncillaryInterface,\n    OracleGovernanceInterface,\n    VotingV2Interface,\n    MultiCaller\n{\n    using VoteTimingV2 for VoteTimingV2.Data;\n    using ResultComputationV2 for ResultComputationV2.Data;\n\n    /****************************************\n     *        VOTING DATA STRUCTURES        *\n     ****************************************/\n\n    // Identifies a unique price request. Tracks ongoing votes as well as the result of the vote.\n    struct PriceRequest {\n        // If in the past, this was the voting round where this price was resolved. If current or the upcoming round,\n        // this is the voting round where this price will be voted on, but not necessarily resolved.\n        uint32 lastVotingRound;\n        // Denotes whether this is a governance request or not.\n        bool isGovernance;\n        // The pendingRequestIndex in the `pendingPriceRequests` that references this PriceRequest. A value of UINT_MAX\n        // means that this PriceRequest is resolved and has been cleaned up from `pendingPriceRequests`.\n        uint64 pendingRequestIndex;\n        // Each request has a unique requestIndex number that is used to order all requests. This is the index within\n        // the priceRequestIds array and is incremented on each request.\n        uint64 priceRequestIndex;\n        // Timestamp that should be used when evaluating the request.\n        // Note: this is a uint56 to allow better variable packing while still leaving more than ample room for\n        // timestamps to stretch far into the future.\n        uint64 time;\n        // Identifier that defines how the voters should resolve the request.\n        bytes32 identifier;\n        // A map containing all votes for this price in various rounds.\n        mapping(uint256 => VoteInstance) voteInstances;\n        // Additional data used to resolve the request.\n        bytes ancillaryData;\n    }\n\n    struct VoteInstance {\n        mapping(address => VoteSubmission) voteSubmissions; // Maps (voterAddress) to their submission.\n        ResultComputationV2.Data resultComputation; // The data structure containing the computed voting results.\n    }\n\n    struct VoteSubmission {\n        bytes32 commit; // A bytes32 of `0` indicates no commit or a commit that was already revealed.\n        bytes32 revealHash; // The hash of the value that was revealed. This is only used for computation of rewards.\n    }\n\n    struct Round {\n        uint256 gat; // GAT is the required number of tokens to vote to not roll the vote.\n        uint256 cumulativeActiveStakeAtRound; // Total staked tokens at the start of the round.\n    }\n\n    // Represents the status a price request has.\n    enum RequestStatus {\n        NotRequested, // Was never requested.\n        Active, // Is being voted on in the current round.\n        Resolved, // Was resolved in a previous round.\n        Future // Is scheduled to be voted on in a future round.\n    }\n\n    // Only used as a return value in view methods -- never stored in the contract.\n    struct RequestState {\n        RequestStatus status;\n        uint256 lastVotingRound;\n    }\n\n    /****************************************\n     *          INTERNAL TRACKING           *\n     ****************************************/\n\n    // Maps round numbers to the rounds.\n    mapping(uint256 => Round) public rounds;\n\n    // Maps price request IDs to the PriceRequest struct.\n    mapping(bytes32 => PriceRequest) public priceRequests;\n\n    bytes32[] public priceRequestIds;\n\n    mapping(uint64 => uint64) public deletedRequests;\n\n    // Price request ids for price requests that haven't yet been resolved. These requests may be for future rounds.\n    bytes32[] public pendingPriceRequests;\n\n    VoteTimingV2.Data public voteTiming;\n\n    // Number of tokens that must participate to resolve a vote.\n    uint256 public gat;\n\n    // Reference to the Finder.\n    FinderInterface private immutable finder;\n\n    // Reference to Slashing Library.\n    SlashingLibrary public slashingLibrary;\n\n    // If non-zero, this contract has been migrated to this address.\n    address public migratedAddress;\n\n    // Max value of an unsigned integer.\n    uint64 private constant UINT64_MAX = type(uint64).max;\n\n    // Max length in bytes of ancillary data that can be appended to a price request.\n    uint256 public constant ancillaryBytesLimit = 8192;\n\n    /****************************************\n     *          SLASHING TRACKERS           *\n     ****************************************/\n\n    // Only used as a return value in view methods -- never stored in the contract.\n    struct SlashingTracker {\n        uint256 wrongVoteSlashPerToken;\n        uint256 noVoteSlashPerToken;\n        uint256 totalSlashed;\n        uint256 totalCorrectVotes;\n    }\n\n    /****************************************\n     *        SPAM DELETION TRACKERS        *\n     ****************************************/\n\n    uint256 spamDeletionProposalBond;\n\n    struct SpamDeletionRequest {\n        uint256[2][] spamRequestIndices;\n        uint256 requestTime;\n        bool executed;\n        address proposer;\n    }\n\n    // Maps round numbers to the spam deletion request.\n    SpamDeletionRequest[] public spamDeletionProposals;\n\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n\n    event VoteCommitted(\n        address indexed voter,\n        address indexed caller,\n        uint256 roundId,\n        bytes32 indexed identifier,\n        uint256 time,\n        bytes ancillaryData\n    );\n\n    event EncryptedVote(\n        address indexed caller,\n        uint256 indexed roundId,\n        bytes32 indexed identifier,\n        uint256 time,\n        bytes ancillaryData,\n        bytes encryptedVote\n    );\n\n    event VoteRevealed(\n        address indexed voter,\n        address indexed caller,\n        uint256 roundId,\n        bytes32 indexed identifier,\n        uint256 time,\n        int256 price,\n        bytes ancillaryData,\n        uint256 numTokens\n    );\n\n    event PriceRequestAdded(\n        address requester,\n        uint256 indexed roundId,\n        bytes32 indexed identifier,\n        uint256 indexed time,\n        uint256 requestIndex,\n        bytes ancillaryData,\n        bool isGovernance\n    );\n\n    event PriceResolved(\n        uint256 indexed roundId,\n        bytes32 indexed identifier,\n        uint256 time,\n        int256 price,\n        bytes ancillaryData\n    );\n\n    event VotingContractMigrated(address newAddress);\n\n    event GatChanged(uint256 newGat);\n\n    event SlashingLibraryChanged(address newAddress);\n\n    event SpamDeletionProposalBondChanged(uint256 newBond);\n\n    event VoterSlashed(address indexed voter, int256 slashedTokens, uint256 postActiveStake);\n\n    event SignaledRequestsAsSpamForDeletion(\n        uint256 indexed proposalId,\n        address indexed sender,\n        uint256[2][] spamRequestIndices\n    );\n\n    event ExecutedSpamDeletion(uint256 indexed proposalId, bool indexed executed);\n\n    /**\n     * @notice Construct the VotingV2 contract.\n     * @param _emissionRate amount of voting tokens that are emitted per second, split prorate between stakers.\n     * @param _unstakeCoolDown time that a voter must wait to unstake after requesting to unstake.\n     * @param _phaseLength length of the voting phases in seconds.\n     * @param _minRollToNextRoundLength time before the end of a round in which a request must be made for the request\n     *  to be voted on in the next round. If after this, the request is rolled to a round after the next round.\n     * @param _gat number of tokens that must participate to resolve a vote.\n     * @param _votingToken address of the UMA token contract used to commit votes.\n     * @param _finder keeps track of all contracts within the system based on their interfaceName.\n     * Must be set to 0x0 for production environments that use live time.\n     * @param _slashingLibrary contract used to calculate voting slashing penalties based on voter participation.\n     */\n    constructor(\n        uint256 _emissionRate,\n        uint256 _spamDeletionProposalBond,\n        uint64 _unstakeCoolDown,\n        uint64 _phaseLength,\n        uint64 _minRollToNextRoundLength,\n        uint256 _gat,\n        uint64 _startingRequestIndex,\n        address _votingToken,\n        address _finder,\n        address _slashingLibrary\n    ) Staker(_emissionRate, _unstakeCoolDown, _votingToken) {\n        voteTiming.init(_phaseLength, _minRollToNextRoundLength);\n        require(_gat < IERC20(_votingToken).totalSupply() && _gat > 0, \"0 < GAT < total supply\");\n        gat = _gat;\n        finder = FinderInterface(_finder);\n        slashingLibrary = SlashingLibrary(_slashingLibrary);\n        setSpamDeletionProposalBond(_spamDeletionProposalBond);\n\n        // We assume indices never get above 2^64. So we should never start with an index above half that range.\n        require(_startingRequestIndex < type(uint64).max / 2, \"startingRequestIndex too large\");\n\n        assembly {\n            sstore(priceRequestIds.slot, _startingRequestIndex)\n        }\n    }\n\n    /***************************************\n                    MODIFIERS\n    ****************************************/\n\n    modifier onlyRegisteredContract() {\n        _requireRegisteredContract();\n        _;\n    }\n\n    modifier onlyIfNotMigrated() {\n        _requireNotMigrated();\n        _;\n    }\n\n    /****************************************\n     *  PRICE REQUEST AND ACCESS FUNCTIONS  *\n     ****************************************/\n\n    /**\n     * @notice Enqueues a request (if a request isn't already present) for the `identifier`, `time` pair.\n     * @dev Time must be in the past and the identifier must be supported. The length of the ancillary data\n     * is limited such that this method abides by the EVM transaction gas limit.\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\n     * @param time unix timestamp for the price request.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     */\n    function requestPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public override onlyRegisteredContract() {\n        _requestPrice(identifier, time, ancillaryData, false);\n    }\n\n    /**\n     * @notice Enqueues a governance action request (if a request isn't already present) for `identifier`, `time` pair.\n     * @dev Time must be in the past and the identifier must be supported. The length of the ancillary data\n     * is limited such that this method abides by the EVM transaction gas limit.\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\n     * @param time unix timestamp for the price request.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     */\n    function requestGovernanceAction(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public override onlyOwner() {\n        _requestPrice(identifier, time, ancillaryData, true);\n    }\n\n    /**\n     * @notice Enqueues a request (if a request isn't already present) for the given `identifier`, `time` pair.\n     * @dev Time must be in the past and the identifier must be supported. The length of the ancillary data is limited\n     * such that this method abides by the EVM transaction gas limit.\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\n     * @param time unix timestamp for the price request.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     * @param isGovernance indicates whether the request is for a governance action.\n     */\n    function _requestPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData,\n        bool isGovernance\n    ) internal {\n        uint256 blockTime = getCurrentTime();\n        require(time <= blockTime, \"Can only request in past\");\n        require(\n            isGovernance || _getIdentifierWhitelist().isIdentifierSupported(identifier),\n            \"Unsupported identifier request\"\n        );\n        require(ancillaryData.length <= ancillaryBytesLimit, \"Invalid ancillary data\");\n\n        bytes32 priceRequestId = _encodePriceRequest(identifier, time, ancillaryData);\n        PriceRequest storage priceRequest = priceRequests[priceRequestId];\n        uint256 currentRoundId = voteTiming.computeCurrentRoundId(blockTime);\n\n        RequestStatus requestStatus = _getRequestStatus(priceRequest, currentRoundId);\n\n        // Price has never been requested.\n        if (requestStatus == RequestStatus.NotRequested) {\n            // If the price request is a governance action then always place it in the following round. If the price\n            // request is a normal request then either place it in the next round or the following round based off\n            // the minRollToNextRoundLength. This limits when a request must be made for it to occur in the next round.\n            uint256 roundIdToVoteOnPriceRequest =\n                isGovernance ? currentRoundId + 1 : voteTiming.computeRoundToVoteOnPriceRequest(blockTime);\n            PriceRequest storage newPriceRequest = priceRequests[priceRequestId];\n            newPriceRequest.identifier = identifier;\n            newPriceRequest.time = SafeCast.toUint64(time);\n            newPriceRequest.lastVotingRound = SafeCast.toUint32(roundIdToVoteOnPriceRequest);\n            newPriceRequest.pendingRequestIndex = SafeCast.toUint64(pendingPriceRequests.length);\n            newPriceRequest.priceRequestIndex = SafeCast.toUint64(priceRequestIds.length);\n            newPriceRequest.ancillaryData = ancillaryData;\n            if (isGovernance) newPriceRequest.isGovernance = isGovernance;\n\n            pendingPriceRequests.push(priceRequestId);\n            priceRequestIds.push(priceRequestId);\n\n            emit PriceRequestAdded(\n                msg.sender,\n                roundIdToVoteOnPriceRequest,\n                identifier,\n                time,\n                newPriceRequest.priceRequestIndex,\n                ancillaryData,\n                isGovernance\n            );\n        }\n    }\n\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\n    function requestPrice(bytes32 identifier, uint256 time) public override {\n        requestPrice(identifier, time, \"\");\n    }\n\n    /**\n     * @notice Whether the price for `identifier` and `time` is available.\n     * @dev Time must be in the past and the identifier must be supported.\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\n     * @param time unix timestamp of for the price request.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     * @return _hasPrice bool if the DVM has resolved to a price for the given identifier and timestamp.\n     */\n    function hasPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public view override onlyRegisteredContract() returns (bool) {\n        (bool _hasPrice, , ) = _getPriceOrError(identifier, time, ancillaryData);\n        return _hasPrice;\n    }\n\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\n    function hasPrice(bytes32 identifier, uint256 time) public view override returns (bool) {\n        return hasPrice(identifier, time, \"\");\n    }\n\n    /**\n     * @notice Gets the price for `identifier` and `time` if it has already been requested and resolved.\n     * @dev If the price is not available, the method reverts.\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\n     * @param time unix timestamp of for the price request.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     * @return int256 representing the resolved price for the given identifier and timestamp.\n     */\n    function getPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public view override onlyRegisteredContract() returns (int256) {\n        (bool _hasPrice, int256 price, string memory message) = _getPriceOrError(identifier, time, ancillaryData);\n\n        // If the price wasn't available, revert with the provided message.\n        require(_hasPrice, message);\n        return price;\n    }\n\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\n    function getPrice(bytes32 identifier, uint256 time) public view override returns (int256) {\n        return getPrice(identifier, time, \"\");\n    }\n\n    /**\n     * @notice Gets the status of a list of price requests, identified by their identifier and time.\n     * @dev If the status for a particular request is NotRequested, the lastVotingRound will always be 0.\n     * @param requests array of type PendingRequest which includes an identifier and timestamp for each request.\n     * @return requestStates a list, in the same order as the input list, giving the status of each of the specified price requests.\n     */\n    function getPriceRequestStatuses(PendingRequestAncillary[] memory requests)\n        public\n        view\n        returns (RequestState[] memory)\n    {\n        RequestState[] memory requestStates = new RequestState[](requests.length);\n        uint256 currentRoundId = voteTiming.computeCurrentRoundId(getCurrentTime());\n        for (uint256 i = 0; i < requests.length; i = unsafe_inc(i)) {\n            PriceRequest storage priceRequest =\n                _getPriceRequest(requests[i].identifier, requests[i].time, requests[i].ancillaryData);\n\n            RequestStatus status = _getRequestStatus(priceRequest, currentRoundId);\n\n            // If it's an active request, its true lastVotingRound is the current one, even if it hasn't been updated.\n            if (status == RequestStatus.Active) requestStates[i].lastVotingRound = currentRoundId;\n            else requestStates[i].lastVotingRound = priceRequest.lastVotingRound;\n            requestStates[i].status = status;\n        }\n        return requestStates;\n    }\n\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\n    function getPriceRequestStatuses(PendingRequest[] memory requests) public view returns (RequestState[] memory) {\n        PendingRequestAncillary[] memory requestsAncillary = new PendingRequestAncillary[](requests.length);\n\n        for (uint256 i = 0; i < requests.length; i = unsafe_inc(i)) {\n            requestsAncillary[i].identifier = requests[i].identifier;\n            requestsAncillary[i].time = requests[i].time;\n            requestsAncillary[i].ancillaryData = \"\";\n        }\n        return getPriceRequestStatuses(requestsAncillary);\n    }\n\n    /****************************************\n     *          VOTING FUNCTIONS            *\n     ****************************************/\n\n    /**\n     * @notice Commit a vote for a price request for `identifier` at `time`.\n     * @dev `identifier`, `time` must correspond to a price request that's currently in the commit phase.\n     * Commits can be changed.\n     * @dev Since transaction data is public, the salt will be revealed with the vote. While this is the system’s\n     * expected behavior, voters should never reuse salts. If someone else is able to guess the voted price and knows\n     * that a salt will be reused, then they can determine the vote pre-reveal.\n     * @param identifier uniquely identifies the committed vote. EG BTC/USD price pair.\n     * @param time unix timestamp of the price being voted on.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     * @param hash keccak256 hash of the `price`, `salt`, voter `address`, `time`, current `roundId`, and `identifier`.\n     */\n    function commitVote(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData,\n        bytes32 hash\n    ) public override onlyIfNotMigrated() {\n        uint256 currentRoundId = voteTiming.computeCurrentRoundId(getCurrentTime());\n        address voter = getVoterFromDelegate(msg.sender);\n        _updateTrackers(voter);\n        uint256 blockTime = getCurrentTime();\n        require(hash != bytes32(0), \"Invalid provided hash\");\n        require(voteTiming.computeCurrentPhase(blockTime) == Phase.Commit, \"Cannot commit in reveal phase\");\n\n        PriceRequest storage priceRequest = _getPriceRequest(identifier, time, ancillaryData);\n        require(\n            _getRequestStatus(priceRequest, currentRoundId) == RequestStatus.Active,\n            \"Cannot commit inactive request\"\n        );\n\n        VoteInstance storage voteInstance = priceRequest.voteInstances[currentRoundId];\n        voteInstance.voteSubmissions[voter].commit = hash;\n\n        emit VoteCommitted(voter, msg.sender, currentRoundId, identifier, time, ancillaryData);\n    }\n\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\n    function commitVote(\n        bytes32 identifier,\n        uint256 time,\n        bytes32 hash\n    ) public override onlyIfNotMigrated() {\n        commitVote(identifier, time, \"\", hash);\n    }\n\n    /**\n     * @notice Reveal a previously committed vote for `identifier` at `time`.\n     * @dev The revealed `price`, `salt`, `address`, `time`, `roundId`, and `identifier`, must hash to the latest `hash`\n     * that `commitVote()` was called with. Only the committer can reveal their vote.\n     * @param identifier voted on in the commit phase. EG BTC/USD price pair.\n     * @param time specifies the unix timestamp of the price being voted on.\n     * @param price voted on during the commit phase.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     * @param salt value used to hide the commitment price during the commit phase.\n     */\n    function revealVote(\n        bytes32 identifier,\n        uint256 time,\n        int256 price,\n        bytes memory ancillaryData,\n        int256 salt\n    ) public override onlyIfNotMigrated() {\n        // Note: computing the current round is required to disallow people from revealing an old commit after the round is over.\n        uint256 currentRoundId = voteTiming.computeCurrentRoundId(getCurrentTime());\n        _freezeRoundVariables(currentRoundId);\n        VoteInstance storage voteInstance =\n            _getPriceRequest(identifier, time, ancillaryData).voteInstances[currentRoundId];\n        address voter = getVoterFromDelegate(msg.sender);\n        VoteSubmission storage voteSubmission = voteInstance.voteSubmissions[voter];\n\n        // Scoping to get rid of a stack too deep errors for require messages.\n        {\n            // Can only reveal in the reveal phase.\n            require(voteTiming.computeCurrentPhase(getCurrentTime()) == Phase.Reveal);\n            // 0 hashes are disallowed in the commit phase, so they indicate a different error.\n            // Cannot reveal an uncommitted or previously revealed hash\n            require(voteSubmission.commit != bytes32(0), \"Invalid hash reveal\");\n\n            // Check that the hash that was committed matches to the one that was revealed. Note that if the voter had\n            // delegated this means that they must reveal with the same account they had committed with.\n            require(\n                keccak256(abi.encodePacked(price, salt, msg.sender, time, ancillaryData, currentRoundId, identifier)) ==\n                    voteSubmission.commit,\n                \"Revealed data != commit hash\"\n            );\n        }\n\n        delete voteSubmission.commit; // Small gas refund for clearing up storage.\n\n        voteSubmission.revealHash = keccak256(abi.encode(price)); // Set the voter's submission.\n        uint256 activeStake = voterStakes[voter].activeStake;\n        voteInstance.resultComputation.addVote(price, activeStake); // Add vote to the results.\n        emit VoteRevealed(voter, msg.sender, currentRoundId, identifier, time, price, ancillaryData, activeStake);\n    }\n\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\n    function revealVote(\n        bytes32 identifier,\n        uint256 time,\n        int256 price,\n        int256 salt\n    ) public override {\n        revealVote(identifier, time, price, \"\", salt);\n    }\n\n    /**\n     * @notice commits a vote and logs an event with a data blob, typically an encrypted version of the vote\n     * @dev An encrypted version of the vote is emitted in an event `EncryptedVote` to allow off-chain infrastructure to\n     * retrieve the commit. The contents of `encryptedVote` are never used on chain: it is purely for convenience.\n     * @param identifier unique price pair identifier. Eg: BTC/USD price pair.\n     * @param time unix timestamp of for the price request.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     * @param hash keccak256 hash of the price you want to vote for and a `int256 salt`.\n     * @param encryptedVote offchain encrypted blob containing the voters amount, time and salt.\n     */\n    function commitAndEmitEncryptedVote(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData,\n        bytes32 hash,\n        bytes memory encryptedVote\n    ) public override {\n        commitVote(identifier, time, ancillaryData, hash);\n\n        uint256 roundId = voteTiming.computeCurrentRoundId(getCurrentTime());\n        emit EncryptedVote(msg.sender, roundId, identifier, time, ancillaryData, encryptedVote);\n    }\n\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\n    function commitAndEmitEncryptedVote(\n        bytes32 identifier,\n        uint256 time,\n        bytes32 hash,\n        bytes memory encryptedVote\n    ) public override {\n        commitVote(identifier, time, \"\", hash);\n\n        commitAndEmitEncryptedVote(identifier, time, \"\", hash, encryptedVote);\n    }\n\n    /**\n     * @notice Sets the delegate of a voter. This delegate can vote on behalf of the staker. The staker will still own\n     * all staked balances, receive rewards and be slashed based on the actors of the delegate. Intended use is using a\n     * low-security available wallet for voting while keeping access to staked amounts secure by a more secure wallet.\n     * @param delegate the address of the delegate.\n     */\n    function setDelegate(address delegate) public {\n        voterStakes[msg.sender].delegate = delegate;\n    }\n\n    /**\n     * @notice Sets the delegator of a voter. Acts to accept a delegation. The delegate can only vote for delegator if\n     * the delegator also selected the delegate to do so (two way relationship needed).\n     * @param delegator the address of the delegate.\n     */\n    function setDelegator(address delegator) public {\n        delegateToStaker[msg.sender] = delegator;\n    }\n\n    /****************************************\n     *        VOTING GETTER FUNCTIONS       *\n     ****************************************/\n\n    /**\n     * @notice Gets the voter from the delegate.\n     * @return address voter that corresponds to the delegate.\n     */\n    function getVoterFromDelegate(address caller) public view returns (address) {\n        if (\n            delegateToStaker[caller] != address(0) && // The delegate chose to be a delegate for the staker.\n            voterStakes[delegateToStaker[caller]].delegate == caller // The staker chose the delegate.\n        ) return delegateToStaker[caller];\n        else return caller;\n    }\n\n    /**\n     * @notice Gets the queries that are being voted on this round.\n     * @return pendingRequests array containing identifiers of type `PendingRequest`.\n     */\n    function getPendingRequests() public view override returns (PendingRequestAncillary[] memory) {\n        uint256 blockTime = getCurrentTime();\n        uint256 currentRoundId = voteTiming.computeCurrentRoundId(blockTime);\n\n        // Solidity memory arrays aren't resizable (and reading storage is expensive). Hence this hackery to filter\n        // `pendingPriceRequests` only to those requests that have an Active RequestStatus.\n        PendingRequestAncillary[] memory unresolved = new PendingRequestAncillary[](pendingPriceRequests.length);\n        uint256 numUnresolved = 0;\n\n        for (uint256 i = 0; i < pendingPriceRequests.length; i = unsafe_inc(i)) {\n            PriceRequest storage priceRequest = priceRequests[pendingPriceRequests[i]];\n            if (_getRequestStatus(priceRequest, currentRoundId) == RequestStatus.Active) {\n                unresolved[numUnresolved] = PendingRequestAncillary({\n                    identifier: priceRequest.identifier,\n                    time: priceRequest.time,\n                    ancillaryData: priceRequest.ancillaryData\n                });\n                numUnresolved++;\n            }\n        }\n\n        PendingRequestAncillary[] memory pendingRequests = new PendingRequestAncillary[](numUnresolved);\n        for (uint256 i = 0; i < numUnresolved; i = unsafe_inc(i)) {\n            pendingRequests[i] = unresolved[i];\n        }\n        return pendingRequests;\n    }\n\n    /**\n     * @notice Checks if there are current active requests.\n     * @return bool true if there are active requests, false otherwise.\n     */\n    function currentActiveRequests() public view returns (bool) {\n        uint256 blockTime = getCurrentTime();\n        uint256 currentRoundId = voteTiming.computeCurrentRoundId(blockTime);\n        for (uint256 i = 0; i < pendingPriceRequests.length; i = unsafe_inc(i)) {\n            if (_getRequestStatus(priceRequests[pendingPriceRequests[i]], currentRoundId) == RequestStatus.Active)\n                return true;\n        }\n        return false;\n    }\n\n    /**\n     * @notice Returns the current voting phase, as a function of the current time.\n     * @return Phase to indicate the current phase. Either { Commit, Reveal, NUM_PHASES_PLACEHOLDER }.\n     */\n    function getVotePhase() public view override returns (Phase) {\n        return voteTiming.computeCurrentPhase(getCurrentTime());\n    }\n\n    /**\n     * @notice Returns the current round ID, as a function of the current time.\n     * @return uint256 representing the unique round ID.\n     */\n    function getCurrentRoundId() public view override returns (uint256) {\n        return voteTiming.computeCurrentRoundId(getCurrentTime());\n    }\n\n    /**\n     * @notice Returns the current round ID, as a function of the current time.\n     * @return uint256 representing the unique round ID.\n     */\n    function getRoundEndTime(uint256 roundId) public view returns (uint256) {\n        return voteTiming.computeRoundEndTime(roundId);\n    }\n\n    function getNumberOfPriceRequests() public view returns (uint256) {\n        return priceRequestIds.length;\n    }\n\n    function requestSlashingTrackers(uint256 requestIndex) public view returns (SlashingTracker memory) {\n        uint256 currentRoundId = voteTiming.computeCurrentRoundId(getCurrentTime());\n        PriceRequest storage priceRequest = priceRequests[priceRequestIds[requestIndex]];\n\n        if (_getRequestStatus(priceReq"
    }
  ]
}