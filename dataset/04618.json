{
  "Title": "No on-chain validation that rate will not reachÂ zero",
  "Content": "The rate decreases at each block according to the [`rateChange`](https://github.com/decentraland/mana/blob/a13905356378cc0153dd3c2153c8ceae6400970d/contracts/MANACrowdsale.sol#L25) parameter. The parameter could cause the rate calculation to fail if it accidentally reaches zero. Consider validating on construction that `rate &gt; rateChange * (endBlock - startBlock)`.\n\n\n**EDIT:** fixed in commit [`fd0c0a7574b44adafeffbe6033ef2bb6450921c2`](https://github.com/decentraland/mana/commit/fd0c0a7574b44adafeffbe6033ef2bb6450921c2).\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/MANACrowdsale.sol",
      "content": "pragma solidity ^0.4.11;\n\nimport \"zeppelin-solidity/contracts/crowdsale/CappedCrowdsale.sol\";\nimport \"zeppelin-solidity/contracts/crowdsale/Crowdsale.sol\";\nimport \"zeppelin-solidity/contracts/crowdsale/FinalizableCrowdsale.sol\";\nimport \"./ContinuousCrowdsale.sol\";\nimport \"./WhitelistedCrowdsale.sol\";\nimport \"./MANAToken.sol\";\n\ncontract MANACrowdsale is ContinuousCrowdsale, CappedCrowdsale, WhitelistedCrowdsale, FinalizableCrowdsale {\n\n    uint256 public constant INFLATION = 8; // percent\n\n    uint256 public constant TOTAL_SHARE = 100;\n    uint256 public constant CROWDSALE_SHARE = 40;\n    uint256 public constant FOUNDATION_SHARE = 60;\n\n    // price at which whitelisted buyers will be able to buy tokens\n    uint256 public preferentialRate;\n\n    // customize the rate for each whitelisted buyer\n    mapping (address => uint256) public buyerRate;\n\n    // change of price in every block during the initial coin offering\n    uint256 public rateChange;\n\n    event RateChange(uint256 amount);\n\n    function MANACrowdsale(\n        uint256 _startBlock, uint256 _endBlock,\n        uint256 _rate, uint256 _rateChange,\n        uint256 _preferentialRate,\n        address _wallet\n    )\n        CappedCrowdsale(150000 ether)\n        WhitelistedCrowdsale()\n        FinalizableCrowdsale()\n        Crowdsale(_startBlock, _endBlock, _rate, _wallet)\n    {\n        rateChange = _rateChange;\n        preferentialRate = _preferentialRate;\n    }\n\n    function createTokenContract() internal returns (MintableToken) {\n        return new MANAToken();\n    }\n\n    function setBuyerRate(address buyer, uint256 rate) onlyOwner {\n        require(buyer != 0);\n        require(rate != 0);\n\n        buyerRate[buyer] = rate;\n    }\n\n    function getRate() internal returns(uint256) {\n        // return the current price if we are in continuous sale\n        if (continuousSale) {\n            return rate;\n        }\n\n        // some early buyers are offered a discount on the crowdsale price\n        if (buyerRate[msg.sender] != 0) {\n            return buyerRate[msg.sender];\n        }\n\n        // whitelisted buyers can purchase at preferential price before crowdsale ends\n        if (isWhitelisted(msg.sender) && !hasEnded()) {\n            return preferentialRate;\n        }\n\n        // otherwise compute the price for the auction\n        return rate.sub(rateChange.mul(block.number - startBlock));\n    }\n\n    // low level token purchase function\n    function processPurchase(address beneficiary) internal returns(uint256) {\n        uint256 weiAmount = msg.value;\n        uint256 updatedWeiRaised = weiRaised.add(weiAmount);\n\n        uint256 rate = getRate();\n        // calculate token amount to be created\n        uint256 tokens = weiAmount.mul(rate);\n\n        // update state\n        weiRaised = updatedWeiRaised;\n\n        token.mint(beneficiary, tokens);\n        TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n\n        forwardFunds();\n\n        return tokens;\n    }\n\n    function setWallet(address _wallet) onlyOwner {\n        require(_wallet != 0x0);\n        wallet = _wallet;\n    }\n\n    function setRate(uint256 _rate) onlyOwner {\n        require(isFinalized);\n        rate = _rate;\n        RateChange(_rate);\n    }\n\n    function startContinuousSale() onlyOwner {\n        require(isFinalized);\n        continuousSale = true;\n    }\n\n    function hasEnded() constant returns(bool) {\n        return isFinalized || super.hasEnded();\n    }\n\n    function finalize() onlyOwner {\n        require(!isFinalized);\n\n        finalization();\n        Finalized();\n\n        isFinalized = true;\n    }\n\n    function finalization() internal {\n        uint256 totalSupply = token.totalSupply();\n        uint256 finalSupply = TOTAL_SHARE.mul(totalSupply).div(CROWDSALE_SHARE);\n\n        // emit tokens for the foundation\n        token.mint(wallet, FOUNDATION_SHARE.mul(finalSupply).div(TOTAL_SHARE));\n\n        // initialize issuance \n        // TODO: possibility of overflow in these operations should be analized\n        uint256 annualIssuance = finalSupply.mul(INFLATION).div(100);\n        issuance = annualIssuance.mul(BUCKET_SIZE).div(1 years);\n\n        // NOTE: cannot call super here because it would finish minting and\n        // the continuous sale would not be able to proceed\n    }\n}"
    }
  ]
}