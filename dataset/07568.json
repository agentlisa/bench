{
  "Title": "[N-05]  Upgradeable contract is missing a `__gap[50]` storage variable to allow for new storage variables in later versions",
  "Content": "See [this](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps) link for a description of this storage variable. While some contracts may not currently be sub-classed, adding the variable now protects against forgetting to add it in the future.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: paraspace-core/contracts/ui/WPunkGateway.sol\n\n19    contract WPunkGateway is\n20        ReentrancyGuard,\n21        IWPunkGateway,\n22        IERC721Receiver,\n23:       OwnableUpgradeable\n\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/ui/WPunkGateway.sol#L19-L23\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-11-paraspace",
  "Code": [
    {
      "filename": "paraspace-core/contracts/ui/WPunkGateway.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.10;\n\nimport {OwnableUpgradeable} from \"../dependencies/openzeppelin/upgradeability/OwnableUpgradeable.sol\";\nimport {IPool} from \"../interfaces/IPool.sol\";\nimport {ReserveConfiguration} from \"../protocol/libraries/configuration/ReserveConfiguration.sol\";\nimport {UserConfiguration} from \"../protocol/libraries/configuration/UserConfiguration.sol\";\nimport {DataTypes} from \"../protocol/libraries/types/DataTypes.sol\";\n\n// ERC721 imports\nimport {IERC721} from \"../dependencies/openzeppelin/contracts/IERC721.sol\";\nimport {IERC721Receiver} from \"../dependencies/openzeppelin/contracts/IERC721Receiver.sol\";\nimport {IPunks} from \"../misc/interfaces/IPunks.sol\";\nimport {IWrappedPunks} from \"../misc/interfaces/IWrappedPunks.sol\";\nimport {IWPunkGateway} from \"./interfaces/IWPunkGateway.sol\";\nimport {INToken} from \"../interfaces/INToken.sol\";\nimport {ReentrancyGuard} from \"../dependencies/openzeppelin/contracts/ReentrancyGuard.sol\";\n\ncontract WPunkGateway is\n    ReentrancyGuard,\n    IWPunkGateway,\n    IERC721Receiver,\n    OwnableUpgradeable\n{\n    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n    using UserConfiguration for DataTypes.UserConfigurationMap;\n\n    IPunks internal immutable Punk;\n    IWrappedPunks internal immutable WPunk;\n    IPool internal immutable Pool;\n    address public proxy;\n\n    address public immutable punk;\n    address public immutable wpunk;\n    address public immutable pool;\n\n    /**\n     * @dev Sets the WETH address and the PoolAddressesProvider address. Infinite approves pool.\n     * @param _punk Address of the Punk contract\n     * @param _wpunk Address of the Wrapped Punk contract\n     * @param _pool Address of the proxy pool of this contract\n     **/\n    constructor(\n        address _punk,\n        address _wpunk,\n        address _pool\n    ) {\n        punk = _punk;\n        wpunk = _wpunk;\n        pool = _pool;\n\n        Punk = IPunks(punk);\n        WPunk = IWrappedPunks(wpunk);\n        Pool = IPool(pool);\n    }\n\n    function initialize() external initializer {\n        __Ownable_init();\n\n        // create new WPunk Proxy for PunkGateway contract\n        WPunk.registerProxy();\n\n        // address(this) = WPunkGatewayProxy\n        // proxy of PunkGateway contract is the new Proxy created above\n        proxy = WPunk.proxyInfo(address(this));\n\n        WPunk.setApprovalForAll(pool, true);\n    }\n\n    /**\n     * @dev supplies (deposits) WPunk into the reserve, using native Punk. A corresponding amount of the overlying asset (xTokens)\n     * is minted.\n     * @param punkIndexes punkIndexes to supply to gateway\n     * @param onBehalfOf address of the user who will receive the xTokens representing the supply\n     * @param referralCode integrators are assigned a referral code and can potentially receive rewards.\n     **/\n    function supplyPunk(\n        DataTypes.ERC721SupplyParams[] calldata punkIndexes,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external nonReentrant {\n        for (uint256 i = 0; i < punkIndexes.length; i++) {\n            Punk.buyPunk(punkIndexes[i].tokenId);\n            Punk.transferPunk(proxy, punkIndexes[i].tokenId);\n            // gatewayProxy is the sender of this function, not the original gateway\n            WPunk.mint(punkIndexes[i].tokenId);\n        }\n\n        Pool.supplyERC721(\n            address(WPunk),\n            punkIndexes,\n            onBehalfOf,\n            referralCode\n        );\n    }\n\n    /**\n     * @dev withdraws the WPUNK _reserves of msg.sender.\n     * @param punkIndexes indexes of nWPunks to withdraw and receive native WPunk\n     * @param to address of the user who will receive native Punks\n     */\n    function withdrawPunk(uint256[] calldata punkIndexes, address to)\n        external\n        nonReentrant\n    {\n        INToken nWPunk = INToken(\n            Pool.getReserveData(address(WPunk)).xTokenAddress\n        );\n        for (uint256 i = 0; i < punkIndexes.length; i++) {\n            nWPunk.safeTransferFrom(msg.sender, address(this), punkIndexes[i]);\n        }\n        Pool.withdrawERC721(address(WPunk), punkIndexes, address(this));\n        for (uint256 i = 0; i < punkIndexes.length; i++) {\n            WPunk.burn(punkIndexes[i]);\n            Punk.transferPunk(to, punkIndexes[i]);\n        }\n    }\n\n    /**\n     * @notice Implements the acceptBidWithCredit feature. AcceptBidWithCredit allows users to\n     * accept a leveraged bid on ParaSpace NFT marketplace. Users can submit leveraged bid and pay\n     * at most (1 - LTV) * $NFT\n     * @dev The nft receiver just needs to do the downpayment\n     * @param marketplaceId The marketplace identifier\n     * @param payload The encoded parameters to be passed to marketplace contract (selector eliminated)\n     * @param credit The credit that user would like to use for this purchase\n     * @param referralCode The referral code used\n     */\n    function acceptBidWithCredit(\n        bytes32 marketplaceId,\n        bytes calldata payload,\n        DataTypes.Credit calldata credit,\n        uint256[] calldata punkIndexes,\n        uint16 referralCode\n    ) external nonReentrant {\n        for (uint256 i = 0; i < punkIndexes.length; i++) {\n            Punk.buyPunk(punkIndexes[i]);\n            Punk.transferPunk(proxy, punkIndexes[i]);\n            // gatewayProxy is the sender of this function, not the original gateway\n            WPunk.mint(punkIndexes[i]);\n\n            IERC721(wpunk).safeTransferFrom(\n                address(this),\n                msg.sender,\n                punkIndexes[i]\n            );\n        }\n        Pool.acceptBidWithCredit(\n            marketplaceId,\n            payload,\n            credit,\n            msg.sender,\n            referralCode\n        );\n    }\n\n    /**\n     * @notice Implements the batchAcceptBidWithCredit feature. AcceptBidWithCredit allows users to\n     * accept a leveraged bid on ParaSpace NFT marketplace. Users can submit leveraged bid and pay\n     * at most (1 - LTV) * $NFT\n     * @dev The nft receiver just needs to do the downpayment\n     * @param marketplaceIds The marketplace identifiers\n     * @param payloads The encoded parameters to be passed to marketplace contract (selector eliminated)\n     * @param credits The credits that the makers have approved to use for this purchase\n     * @param referralCode The referral code used\n     */\n    function batchAcceptBidWithCredit(\n        bytes32[] calldata marketplaceIds,\n        bytes[] calldata payloads,\n        DataTypes.Credit[] calldata credits,\n        uint256[] calldata punkIndexes,\n        uint16 referralCode\n    ) external nonReentrant {\n        for (uint256 i = 0; i < punkIndexes.length; i++) {\n            Punk.buyPunk(punkIndexes[i]);\n            Punk.transferPunk(proxy, punkIndexes[i]);\n            // gatewayProxy is the sender of this function, not the original gateway\n            WPunk.mint(punkIndexes[i]);\n\n            IERC721(wpunk).safeTransferFrom(\n                address(this),\n                msg.sender,\n                punkIndexes[i]\n            );\n        }\n        Pool.batchAcceptBidWithCredit(\n            marketplaceIds,\n            payloads,\n            credits,\n            msg.sender,\n            referralCode\n        );\n    }\n\n    /**\n     * @dev transfer ERC721 from the utility contract, for ERC721 recovery in case of stuck tokens due\n     * direct transfers to the contract address.\n     * @param token ERC721 token to transfer\n     * @param tokenId tokenId to send\n     * @param to recipient of the transfer\n     */\n    function emergencyERC721TokenTransfer(\n        address token,\n        uint256 tokenId,\n        address to\n    ) external onlyOwner {\n        IERC721(token).safeTransferFrom(address(this), to, tokenId);\n        emit EmergencyERC721TokenTransfer(token, tokenId, to);\n    }\n\n    /**\n     * @dev transfer native Punk from the utility contract, for native Punk recovery in case of stuck Punk\n     * due selfdestructs or transfer punk to pre-computated contract address before deployment.\n     * @param to recipient of the transfer\n     * @param punkIndex punk to send\n     */\n    function emergencyPunkTransfer(address to, uint256 punkIndex)\n        external\n        onlyOwner\n    {\n        Punk.transferPunk(to, punkIndex);\n        emit EmergencyPunkTransfer(to, punkIndex);\n    }\n\n    /**\n     * @dev Get WPunk address used by WPunkGateway\n     */\n    function getWPunkAddress() external view returns (address) {\n        return address(WPunk);\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}"
    }
  ]
}