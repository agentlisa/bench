{
  "Title": "H-1: Can steal gOhm by calling Clearinghouse.claimDefaulted on loans not made by Clearinghouse",
  "Content": "# Issue H-1: Can steal gOhm by calling Clearinghouse.claimDefaulted on loans not made by Clearinghouse \n\nSource: https://github.com/sherlock-audit/2023-08-cooler-judging/issues/28 \n\n## Found by \ndetectiveking, jkoppel, mert\\_eren\n\n`Clearinghouse.claimDefaulted` assumes that all loans passed in were originated by the Clearinghouse. However, nothing guarantees that. An attacker can wreak havoc by calling it with a mixture of Clearinghouse-originated and external loans. In particular, they can inflate the computed `totalCollateral` recovered to steal excess gOhm from defaulted loans.\n\n## Vulnerability Detail\n\n1. Alice creates a Cooler. 9 times, she calls `requestLoan` (not through the Clearinghouse) to request a loan of 0.000001 DAI collateralized by 2 gOhm. For each loan, she then calls `clearLoan` and loans the 0.000001 DAI to herself.\n1. One week later, Bob calls `Clearinghouse.lendToCooler` and takes a loan for 3000 DAI collateralized by 1 gOHM\n3. Alice defaults on the loans she made to herself and waits 7 days\n4. Bob defaults on his loan\n5. Alice calls `Clearinghouse.claimDefaulted`, passing in both her loans to herself and Bob's loan from the Clearinghouse. `Clearinghouse.claimDefaulted` calls `Cooler.claimDefaulted` on each, returning 18 gOhm to Alice and 1 gOhm to the Clearinghouse.\n6. For each of Alice's loan, the keeper reward is incremented by the max award of 0.1 gOhm. For Bob's loan, the keeper reward is incremented by somewhere between 0 and 0.05 gOhm,  depending on how much time has elapsed since Bob's loan defaulted. \n8. The keeper reward is transferred to Alice. Alice's reward will be between 0.9 and 0.95 gOhm, but it should be between 0 and 0.05 gOhm. The contract should recover between 0.95 and 1 gOhm, but it only recovers between 0.05 and 0.1 gOhm.  Alice has effectively stolen 0.9 gOhm from the contract\n\nThe attack as stated above can steal at most 5% of the collateral. **Note that Alice can get this even without waiting 7 days from loan expiry time.** It further requires the Clearinghouse have some extra gOhm around, as it will burn `totalCollateral - keeperRewards`. This can happen if the treasury or someone sends it some gOhm for some reason, or by calling claimDefault as in #3 .\n\nHowever, #5  extends this attack so that Alice can steal 100% of the collateral, even if the Clearinghouse has no extra gOhm lying around.\n\nFor added fun, note that, when setting up her loans to herself, Alice can set the loan duration to 0 seconds. So this only requires setting up 1 block in advance.\n\n## Impact\n\nAnyone can steal collateral from defaulted loans.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-08-cooler/blob/main/Cooler/src/Clearinghouse.sol#L191\n\nNotice the lack of any checks that the loan's lender is the Clearingouse\n\n```solidity\n    function claimDefaulted(address[] calldata coolers_, uint256[] calldata loans_) external {\n        uint256 loans = loans_.length;\n        if (loans != coolers_.length) revert LengthDiscrepancy();\n\n        uint256 totalDebt;\n        uint256 totalInterest;\n        uint256 totalCollateral;\n        uint256 keeperRewards;\n        for (uint256 i=0; i < loans;) {\n            // Validate that cooler was deployed by the trusted factory.\n            if (!factory.created(coolers_[i])) revert OnlyFromFactory();\n            \n            // Claim defaults and update cached metrics.\n            (uint256 debt, uint256 collateral, uint256 elapsed) = Cooler(coolers_[i]).claimDefaulted(loans_[i]);\n```\n\n`keeperRewards` is incremented for every loan.\n\n```solidity\n            // Cap rewards to 5% of the collateral to avoid OHM holder's dillution.\n            uint256 maxAuctionReward = collateral * 5e16 / 1e18;\n            // Cap rewards to avoid exorbitant amounts.\n            uint256 maxReward = (maxAuctionReward < MAX_REWARD)\n                ? maxAuctionReward\n                : MAX_REWARD;\n            // Calculate rewards based on the elapsed time since default.\n            keeperRewards = (elapsed < 7 days)\n                ? keeperRewards + maxReward * elapsed / 7 days\n                : keeperRewards + maxReward;\n        }\n```\n\nhttps://github.com/sherlock-audit/2023-08-cooler/blob/main/Cooler/src/Cooler.sol#L318\n\n`Cooler.claimDefaulted` can be called by anyone.\n\n```solidity\n function claimDefaulted(uint256 loanID_) external returns (uint256, uint256, uint256) {\n        Loan memory loan = loans[loanID_];\n        delete loans[loanID_];\n\n       // Hey look, no checks on sender\n}\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCheck that the Clearinghouse is the originator of all loans passed to claimDefaulted\n\n\n\n## Discussion\n\n**0xRusowsky**\n\n- https://github.com/ohmzeus/Cooler/pull/48\n\n**jkoppel**\n\nNote on this:\n\nThe link to #3 is meant to be a link to #46\n\nThe link to #5 is meant to be a link to #115\n\nIn the past, when I linked to issues in my private judging repository, Sherlock would properly update them upon submission. Now it just links them to whatever issue in the public judging repo has the same number.\n\n**jkoppel**\n\nFix confirmed.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/107",
  "Code": [
    {
      "filename": "Cooler/src/Clearinghouse.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC4626} from \"solmate/mixins/ERC4626.sol\";\nimport {ROLESv1, RolesConsumer} from \"olympus-v3/modules/ROLES/OlympusRoles.sol\";\nimport {TRSRYv1} from \"olympus-v3/modules/TRSRY/TRSRY.v1.sol\";\nimport {MINTRv1} from \"olympus-v3/modules/MINTR/MINTR.v1.sol\";\nimport \"olympus-v3/Kernel.sol\";\n\nimport {IStaking} from \"interfaces/IStaking.sol\";\n\nimport {CoolerFactory, Cooler} from \"src/CoolerFactory.sol\";\nimport {CoolerCallback} from \"src/CoolerCallback.sol\";\n\n/// @title  Olympus Clearinghouse.\n/// @notice Olympus Clearinghouse (Policy) Contract.\n/// @dev    The Olympus Clearinghouse is a lending facility built on top of Cooler Loans. The Clearinghouse\n///         ensures that OHM holders can take loans against their gOHM holdings according to the parameters\n///         approved by the community in OIP-144 and its subsequent RFCs. The Clearinghouse parameters are\n///         immutable, because of that, if backing was to increase substantially, a new governance process\n///         to fork this implementation with upgraded parameters should take place.\n///         Although the Cooler contracts allow lenders to transfer ownership of their repayment rights, the\n///         Clearinghouse doesn't implement any functions to use that feature.\ncontract Clearinghouse is Policy, RolesConsumer, CoolerCallback {\n\n    // --- ERRORS ----------------------------------------------------\n\n    error BadEscrow();\n    error DurationMaximum();\n    error OnlyBurnable();\n    error TooEarlyToFund();\n    error LengthDiscrepancy();\n\n    // --- EVENTS ----------------------------------------------------\n\n    event Deactivated();\n    event Reactivated();\n    \n    // --- RELEVANT CONTRACTS ----------------------------------------\n\n    ERC20 public immutable dai;             // Debt token\n    ERC4626 public immutable sdai;          // Idle DAI will wrapped into sDAI\n    ERC20 public immutable gOHM;            // Collateral token\n    IStaking public immutable staking;      // Necessary to unstake (and burn) OHM from defaults\n    \n    // --- MODULES ---------------------------------------------------\n\n    TRSRYv1 public TRSRY;      // Olympus V3 Treasury Module\n    MINTRv1 public MINTR;      // Olympus V3 Minter Module\n\n    // --- PARAMETER BOUNDS ------------------------------------------\n\n    uint256 public constant INTEREST_RATE = 5e15;               // 0.5% anually\n    uint256 public constant LOAN_TO_COLLATERAL = 3000e18;       // 3,000 DAI/gOHM\n    uint256 public constant DURATION = 121 days;                // Four months\n    uint256 public constant FUND_CADENCE = 7 days;              // One week\n    uint256 public constant FUND_AMOUNT = 18_000_000e18;        // 18 million\n    uint256 public constant MAX_REWARD = 1e17;                  // 0.1 gOHM\n\n    // --- STATE VARIABLES -------------------------------------------\n\n    /// @notice determines whether the contract can be funded or not.\n    bool public active;\n\n    /// @notice timestamp at which the next rebalance can occur.\n    uint256 public fundTime;\n\n    /// @notice outstanding loan receivables.\n    /// Incremented when a loan is taken or rolled.\n    /// Decremented when a loan is repaid or collateral is burned.\n    uint256 public receivables;\n\n    // --- INITIALIZATION --------------------------------------------\n\n    constructor(\n        address gohm_,\n        address staking_,\n        address sdai_,\n        address coolerFactory_,\n        address kernel_\n    ) Policy(Kernel(kernel_)) CoolerCallback(coolerFactory_) {\n        // Store the relevant contracts.\n        gOHM = ERC20(gohm_);\n        staking = IStaking(staking_);\n        sdai = ERC4626(sdai_);\n        dai = ERC20(sdai.asset());\n        \n        // Initialize the contract status and its funding schedule.\n        active = true;\n        fundTime = block.timestamp;\n    }\n\n    /// @notice Default framework setup. Configure dependencies for olympus-v3 modules.\n    /// @dev    This function will be called when the `executor` installs the Clearinghouse\n    ///         policy in the olympus-v3 `Kernel`.\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](3);\n        dependencies[0] = toKeycode(\"TRSRY\");\n        dependencies[1] = toKeycode(\"MINTR\");\n        dependencies[2] = toKeycode(\"ROLES\");\n\n        TRSRY = TRSRYv1(getModuleAddress(toKeycode(\"TRSRY\")));\n        MINTR = MINTRv1(getModuleAddress(toKeycode(\"MINTR\")));\n        ROLES = ROLESv1(getModuleAddress(toKeycode(\"ROLES\")));\n    }\n\n    /// @notice Default framework setup. Request permissions for interacting with olympus-v3 modules.\n    /// @dev    This function will be called when the `executor` installs the Clearinghouse\n    ///         policy in the olympus-v3 `Kernel`.\n    function requestPermissions() external view override returns (Permissions[] memory requests) {\n        Keycode TRSRY_KEYCODE = toKeycode(\"TRSRY\");\n\n        requests = new Permissions[](4);\n        requests[0] = Permissions(TRSRY_KEYCODE, TRSRY.setDebt.selector);\n        requests[1] = Permissions(TRSRY_KEYCODE, TRSRY.increaseWithdrawApproval.selector);\n        requests[2] = Permissions(TRSRY_KEYCODE, TRSRY.withdrawReserves.selector);\n        requests[3] = Permissions(toKeycode(\"MINTR\"), MINTR.burnOhm.selector);\n    }\n\n    // --- OPERATION -------------------------------------------------\n\n    /// @notice Lend to a cooler.\n    /// @dev    To simplify the UX and easily ensure that all holders get the same terms,\n    ///         this function requests a new loan and clears it in the same transaction.\n    /// @param  cooler_ to lend to.\n    /// @param  amount_ of DAI to lend.\n    /// @return the id of the granted loan.\n    function lendToCooler(Cooler cooler_, uint256 amount_) external returns (uint256) {\n        // Attempt a clearinghouse <> treasury rebalance.\n        rebalance();\n        // Validate that cooler was deployed by the trusted factory.\n        if (!factory.created(address(cooler_))) revert OnlyFromFactory();\n        // Validate cooler collateral and debt tokens.\n        if (cooler_.collateral() != gOHM || cooler_.debt() != dai) revert BadEscrow();\n\n        // Compute and access collateral. Increment loan receivables.\n        uint256 collateral = cooler_.collateralFor(amount_, LOAN_TO_COLLATERAL);\n        receivables += debtForCollateral(collateral);\n        gOHM.transferFrom(msg.sender, address(this), collateral);\n\n        // Create a new loan request.\n        gOHM.approve(address(cooler_), collateral);\n        uint256 reqID = cooler_.requestLoan(amount_, INTEREST_RATE, LOAN_TO_COLLATERAL, DURATION);\n\n        // Clear the created loan request by providing enough DAI.\n        sdai.withdraw(amount_, address(this), address(this));\n        dai.approve(address(cooler_), amount_);\n        uint256 loanID = cooler_.clearRequest(reqID, true, true);\n        \n        return loanID;\n    }\n\n    /// @notice Rollover an existing loan.\n    /// @dev    To simplify the UX and easily ensure that all holders get the same terms,\n    ///         this function provides the governance-approved terms for a rollover and\n    ///         does the loan rollover in the same transaction.\n    /// @param  cooler_ to provide terms.\n    /// @param  loanID_ of loan in cooler.\n    function rollLoan(Cooler cooler_, uint256 loanID_) external {\n        // Validate that cooler was deployed by the trusted factory.\n        if (!factory.created(address(cooler_))) revert OnlyFromFactory();\n\n        // Provide rollover terms.\n        cooler_.provideNewTermsForRoll(loanID_, INTEREST_RATE, LOAN_TO_COLLATERAL, DURATION);\n\n        // Increment loan receivables by applying the interest to the previous debt.\n        uint256 newDebt = cooler_.interestFor(\n            cooler_.getLoan(loanID_).amount,\n            INTEREST_RATE,              \n            DURATION\n        );\n        receivables += newDebt;    \n\n        // If necessary, pledge more collateral from user.\n        uint256 newCollateral = cooler_.newCollateralFor(loanID_);\n        if (newCollateral > 0) {\n            gOHM.transferFrom(msg.sender, address(this), newCollateral);\n            gOHM.approve(address(cooler_), newCollateral);\n        }\n\n        // Roll loan.\n        cooler_.rollLoan(loanID_);\n    }\n\n    /// @notice Batch several default claims to save gas.\n    ///         The elements on both arrays must be paired based on their index.\n    /// @dev    Implements an auction style reward system that linearly increases up to a max reward.\n    /// @param  coolers_ Array of contracts where the default must be claimed.\n    /// @param  loans_ Array of defaulted loan ids.\n    function claimDefaulted(address[] calldata coolers_, uint256[] calldata loans_) external {\n        uint256 loans = loans_.length;\n        if (loans != coolers_.length) revert LengthDiscrepancy();\n\n        uint256 totalDebt;\n        uint256 totalInterest;\n        uint256 totalCollateral;\n        uint256 keeperRewards;\n        for (uint256 i=0; i < loans;) {\n            // Validate that cooler was deployed by the trusted factory.\n            if (!factory.created(coolers_[i])) revert OnlyFromFactory();\n            \n            // Claim defaults and update cached metrics.\n            (uint256 debt, uint256 collateral, uint256 elapsed) = Cooler(coolers_[i]).claimDefaulted(loans_[i]);\n            uint256 interest = interestFromDebt(debt);\n            unchecked {\n                // Cannot overflow due to max supply limits for both tokens\n                totalDebt += debt;\n                totalInterest += interest;\n                totalCollateral += collateral;\n                // There will not exist more than 2**256 loans\n                ++i;\n            }\n\n            // Cap rewards to 5% of the collateral to avoid OHM holder's dillution.\n            uint256 maxAuctionReward = collateral * 5e16 / 1e18;\n            // Cap rewards to avoid exorbitant amounts.\n            uint256 maxReward = (maxAuctionReward < MAX_REWARD)\n                ? maxAuctionReward\n                : MAX_REWARD;\n            // Calculate rewards based on the elapsed time since default.\n            keeperRewards = (elapsed < 7 days)\n                ? keeperRewards + maxReward * elapsed / 7 days\n                : keeperRewards + maxReward;\n        }\n\n        // Decrement loan receivables.\n        receivables = (receivables > totalDebt) ? receivables - totalDebt : 0;\n        // Update outstanding debt owed to the Treasury upon default.\n        uint256 outstandingDebt = TRSRY.reserveDebt(dai, address(this));\n        // debt owed to TRSRY = user debt - user interest\n        TRSRY.setDebt({\n            debtor_: address(this),\n            token_: dai,\n            amount_: (outstandingDebt > (totalDebt - totalInterest))\n                ? outstandingDebt - (totalDebt - totalInterest)\n                : 0\n        });\n\n        // Reward keeper.\n        gOHM.transfer(msg.sender, keeperRewards);\n        // Unstake and burn the collateral of the defaulted loans.\n        gOHM.approve(address(staking), totalCollateral - keeperRewards);\n        MINTR.burnOhm(address(this), staking.unstake(address(this), totalCollateral - keeperRewards, false, false));\n    }\n\n    // --- CALLBACKS -----------------------------------------------------\n\n    /// @notice Overridden callback to decrement loan receivables.\n    /// @param *unused loadID_ of the load.\n    /// @param amount_ repaid (in DAI).\n    function _onRepay(uint256, uint256 amount_) internal override {\n        _sweepIntoDSR(amount_);\n\n        // Decrement loan receivables.\n        receivables = (receivables > amount_) ? receivables - amount_ : 0;\n    }\n    \n    /// @notice Unused callback since rollovers are handled by the clearinghouse.\n    /// @dev Overriden and left empty to save gas.\n    function _onRoll(uint256, uint256, uint256) internal override {}\n\n    /// @notice Unused callback since defaults are handled by the clearinghouse.\n    /// @dev Overriden and left empty to save gas.\n    function _onDefault(uint256, uint256, uint256) internal override {}\n\n    // --- FUNDING ---------------------------------------------------\n\n    /// @notice Fund loan liquidity from treasury.\n    /// @dev    Exposure is always capped at FUND_AMOUNT and rebalanced at up to FUND_CADANCE.\n    ///         If several rebalances are available (because some were missed), calling this\n    ///         function several times won't impact the funds controlled by the contract.\n    ///         If the emergency shutdown is triggered, a rebalance will send funds back to\n    ///         the treasury.\n    /// @return False if too early to rebalance. Otherwise, true.\n    function rebalance() public returns (bool) {\n        // If the contract is deactivated, defund.\n        uint256 maxFundAmount = active ? FUND_AMOUNT : 0;        \n        // Update funding schedule if necessary.\n        if (fundTime > block.timestamp) return false;\n        fundTime += FUND_CADENCE;\n\n        uint256 daiBalance = sdai.maxWithdraw(address(this));\n        uint256 outstandingDebt = TRSRY.reserveDebt(dai, address(this));\n        // Rebalance funds on hand with treasury's reserves.\n        if (daiBalance < maxFundAmount) {\n            // Since users loans are denominated in DAI, the clearinghouse\n            // debt is set in DAI terms. It must be adjusted when funding.\n            uint256 fundAmount = maxFundAmount - daiBalance;\n            TRSRY.setDebt({\n                debtor_: address(this),\n                token_: dai,\n                amount_: outstandingDebt + fundAmount\n            });\n\n            // Since TRSRY holds sDAI, a conversion must be done before\n            // funding the clearinghouse.\n            uint256 sdaiAmount = sdai.previewWithdraw(fundAmount);\n            TRSRY.increaseWithdrawApproval(address(this), sdai, sdaiAmount);\n            TRSRY.withdrawReserves(address(this), sdai, sdaiAmount);\n\n            // Sweep DAI into DSR if necessary.\n            uint256 idle = dai.balanceOf(address(this));\n            if (idle != 0) _sweepIntoDSR(idle);\n        } else if (daiBalance > maxFundAmount) {\n            // Since users loans are denominated in DAI, the clearinghouse\n            // debt is set in DAI terms. It must be adjusted when defunding.\n            uint256 defundAmount = daiBalance - maxFundAmount;\n            TRSRY.setDebt({\n                debtor_: address(this),\n                token_: dai,\n                amount_: (outstandingDebt > defundAmount) ? outstandingDebt - defundAmount : 0\n            });\n\n            // Since TRSRY holds sDAI, a conversion must be done before\n            // sending sDAI back.\n            uint256 sdaiAmount = sdai.previewWithdraw(defundAmount);\n            sdai.approve(address(TRSRY), sdaiAmount);\n            sdai.transfer(address(TRSRY), sdaiAmount);\n        }\n        return true;\n    }\n\n    /// @notice Sweep excess DAI into vault.\n    function sweepIntoDSR() public {\n        uint256 daiBalance = dai.balanceOf(address(this));\n        _sweepIntoDSR(daiBalance);\n    }\n\n    /// @notice Sweep excess DAI into vault.\n    function _sweepIntoDSR(uint256 amount_) internal {\n        dai.approve(address(sdai), amount_);\n        sdai.deposit(amount_, address(this));\n    }\n\n    /// @notice Return funds to treasury.\n    /// @param  token_ to transfer.\n    /// @param  amount_ to transfer.\n    function defund(ERC20 token_, uint256 amount_) public onlyRole(\"cooler_overseer\") {\n        if (token_ == gOHM) revert OnlyBurnable();\n        if (token_ == sdai || token_ == dai) {\n            // Since users loans are denominated in DAI, the clearinghouse\n            // debt is set in DAI terms. It must be adjusted when defunding.\n            uint256 outstandingDebt = TRSRY.reserveDebt(dai, address(this));\n            uint256 daiAmount = (token_ == sdai)\n                ? sdai.previewRedeem(amount_)\n                : amount_;\n    \n            TRSRY.setDebt({\n                debtor_: address(this),\n                token_: dai,\n                amount_: (outstandingDebt > daiAmount) ? outstandingDebt - daiAmount : 0\n            });\n        }\n\n        token_.transfer(address(TRSRY), amount_);\n    }\n\n    /// @notice Deactivate the contract and return funds to treasury.\n    function emergencyShutdown() external onlyRole(\"emergency_shutdown\") {\n        active = false;\n\n        // If necessary, defund sDAI.\n        uint256 sdaiBalance = sdai.balanceOf(address(this));\n        if (sdaiBalance != 0) defund(sdai, sdaiBalance);\n\n        // If necessary, defund DAI.\n        uint256 daiBalance = dai.balanceOf(address(this));\n        if (daiBalance != 0) defund(dai, daiBalance);\n\n        emit Deactivated();\n    }\n\n    /// @notice Reactivate the contract.\n    function reactivate() external onlyRole(\"cooler_overseer\") {\n        active = true;\n\n        emit Reactivated();\n    }\n\n    // --- AUX FUNCTIONS ---------------------------------------------\n    \n    /// @notice view function computing loan for a collateral amount.\n    /// @param  collateral_ amount of gOHM.\n    /// @return debt (amount to be lent + interest) for a given collateral amount.\n    function debtForCollateral(uint256 collateral_) public pure returns (uint256) {\n        uint256 interestPercent = (INTEREST_RATE * DURATION) / 365 days;\n        uint256 loan = collateral_ * LOAN_TO_COLLATERAL / 1e18;\n        uint256 interest = loan * interestPercent / 1e18;\n        return loan + interest;\n    }\n    \n    /// @notice view function to compute the interest for a given debt amount.\n    /// @param debt_ amount of gOHM.\n    function interestFromDebt(uint256 debt_) public pure returns (uint256) {\n        uint256 interestPercent = (INTEREST_RATE * DURATION) / 365 days;\n        return debt_ * interestPercent / 1e18;\n    }\n}"
    },
    {
      "filename": "Cooler/src/Cooler.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {Clone} from \"clones/Clone.sol\";\n\nimport {IDelegate} from \"interfaces/IDelegate.sol\";\nimport {CoolerFactory} from \"src/CoolerFactory.sol\";\nimport {CoolerCallback} from \"src/CoolerCallback.sol\";\n\n/// @title  Cooler Loans.\n/// @notice A Cooler is a smart contract escrow that facilitates fixed-duration, peer-to-peer\n///         loans for a user-defined debt-collateral pair.\n/// @dev    This contract uses Clones (https://github.com/wighawag/clones-with-immutable-args)\n///         to save gas on deployment.\ncontract Cooler is Clone {\n    using SafeTransferLib for ERC20;\n\n    // --- ERRORS ----------------------------------------------------\n\n    error OnlyApproved();\n    error Deactivated();\n    error Default();\n    error NoDefault();\n    error NotRollable();\n    error ZeroCollateralReturned();\n    error NotCoolerCallback();\n\n    // --- DATA STRUCTURES -------------------------------------------\n\n    /// @notice A loan begins with a borrow request.\n    struct Request {\n        uint256 amount;             // Amount to be borrowed.\n        uint256 interest;           // Annualized percentage to be paid as interest.\n        uint256 loanToCollateral;   // Requested loan-to-collateral ratio.\n        uint256 duration;           // Time to repay the loan before it defaults.\n        bool active;                // Any lender can clear an active loan request.\n    }\n\n    /// @notice A request is converted to a loan when a lender clears it.\n    struct Loan {\n        Request request;        // Loan terms specified in the request.\n        uint256 amount;         // Amount of debt owed to the lender.\n        uint256 unclaimed;      // Amount of debt tokens repaid but unclaimed.\n        uint256 collateral;     // Amount of collateral pledged.\n        uint256 expiry;         // Time when the loan defaults.\n        address lender;         // Lender's address.\n        bool repayDirect;       // If this is false, repaid tokens must be claimed by lender.\n        bool callback;          // If this is true, the lender must inherit CoolerCallback.\n    }\n\n    // --- IMMUTABLES ------------------------------------------------\n\n    // This makes the code look prettier.\n    uint256 private constant DECIMALS_INTEREST = 1e18;\n\n    /// @notice This address owns the collateral in escrow.\n    function owner() public pure returns (address _owner) {\n        return _getArgAddress(0x0);\n    }\n\n    /// @notice This token is borrowed against.\n    function collateral() public pure returns (ERC20 _collateral) {\n        return ERC20(_getArgAddress(0x14));\n    }\n\n    /// @notice This token is lent.\n    function debt() public pure returns (ERC20 _debt) {\n        return ERC20(_getArgAddress(0x28));\n    }\n    \n    /// @notice This contract created the Cooler\n    function factory() public pure returns (CoolerFactory _factory) {\n        return CoolerFactory(_getArgAddress(0x3c));\n    }\n\n    // --- STATE VARIABLES -------------------------------------------\n\n    /// @notice Arrays stores all the loan requests.\n    Request[] public requests;\n\n    /// @notice Arrays stores all the granted loans.\n    Loan[] public loans;\n\n    /// @notice Facilitates transfer of lender ownership to new addresses\n    mapping(uint256 => address) public approvals;\n\n    // --- BORROWER --------------------------------------------------\n\n    /// @notice Request a loan with given parameters.\n    ///         Collateral is taken at time of request.\n    /// @param  amount_ of debt tokens to borrow.\n    /// @param  interest_ to pay (annualized % of 'amount_'). Expressed in DECIMALS_INTEREST.\n    /// @param  loanToCollateral_ debt tokens per collateral token pledged. Expressed in 10**debt().decimals().\n    /// @param  duration_ of loan tenure in seconds.\n    /// @return reqID of the created request. Equivalent to the index of request in requests[].\n    function requestLoan(\n        uint256 amount_,\n        uint256 interest_,\n        uint256 loanToCollateral_,\n        uint256 duration_\n    ) external returns (uint256 reqID) {\n        reqID = requests.length;\n        requests.push(\n            Request({\n                amount: amount_,\n                interest: interest_,\n                loanToCollateral: loanToCollateral_,\n                duration: duration_,\n                active: true\n            })\n        );\n\n        // The collateral is taken upfront. Will be escrowed\n        // until the loan is repaid or defaulted.\n        collateral().safeTransferFrom(\n            msg.sender,\n            address(this),\n            collateralFor(amount_, loanToCollateral_)\n        );\n\n        // Log the event.\n        factory().newEvent(reqID, CoolerFactory.Events.RequestLoan, 0);\n    }\n\n    /// @notice Cancel a loan request and get the collateral back.\n    /// @param  reqID_ index of request in requests[].\n    function rescindRequest(uint256 reqID_) external {\n        if (msg.sender != owner()) revert OnlyApproved();\n\n        Request storage req = requests[reqID_];\n\n        if (!req.active) revert Deactivated();\n\n        // Update storage and send collateral back to the owner.\n        req.active = false;\n        collateral().safeTransfer(owner(), collateralFor(req.amount, req.loanToCollateral));\n\n        // Log the event.\n        factory().newEvent(reqID_, CoolerFactory.Events.RescindRequest, 0);\n    }\n\n    /// @notice Repay a loan to get the collateral back.\n    /// @dev    Despite a malicious lender could reenter with the callback, the\n    ///         usage of `msg.sender` prevents any economical benefit to the\n    ///         attacker, since they would be repaying the loan themselves.\n    /// @param  loanID_ index of loan in loans[]\n    /// @param  repaid_ debt tokens to be repaid.\n    /// @return collateral given back to the borrower.\n    function repayLoan(uint256 loanID_, uint256 repaid_) external returns (uint256) {\n        Loan memory loan = loans[loanID_];\n\n        if (block.timestamp > loan.expiry) revert Default();\n\n        if (repaid_ > loan.amount) repaid_ = loan.amount;\n\n        uint256 decollateralized = (loan.collateral * repaid_) / loan.amount;\n        if (decollateralized == 0) revert ZeroCollateralReturned();\n\n        // Update loan memory.\n        loan.amount -= repaid_;\n        loan.collateral -= decollateralized;\n\n        address repayTo;\n        // Check whether repayment needs to be manually claimed or not.\n        if (loan.repayDirect) {\n            repayTo = loan.lender;\n        } else {\n            repayTo = address(this);\n            loan.unclaimed += repaid_;\n        }\n\n        // Save updated loan info in storage.\n        loans[loanID_] = loan;\n\n        // Transfer repaid debt back to the lender and (de)collateral back to the owner.\n        debt().safeTransferFrom(msg.sender, repayTo, repaid_);\n        collateral().safeTransfer(owner(), decollateralized);\n\n        // Log the event.\n        factory().newEvent(loanID_, CoolerFactory.Events.RepayLoan, repaid_);\n\n        // If necessary, trigger lender callback.\n        if (loan.callback) CoolerCallback(loan.lender).onRepay(loanID_, repaid_);\n        return decollateralized;\n    }\n\n    /// @notice Roll a loan over with new terms.\n    ///         provideNewTermsForRoll must have been called beforehand by the lender.\n    /// @param  loanID_ index of loan in loans[].\n    function rollLoan(uint256 loanID_) external {\n        Loan memory loan = loans[loanID_];\n\n        if (block.timestamp > loan.expiry) revert Default();\n        if (!loan.request.active) revert NotRollable();\n\n        // Check whether rolling the loan requires pledging more collateral or not (if there was a previous repayment).\n        uint256 newCollateral = newCollateralFor(loanID_);\n        uint256 newDebt = interestFor(loan.amount, loan.request.interest, loan.request.duration);\n\n        // Update memory accordingly.\n        loan.amount += newDebt;\n        loan.collateral += newCollateral;\n        loan.expiry += loan.request.duration;\n        loan.request.active = false;\n\n        // Save updated loan info in storage.\n        loans[loanID_] = loan;\n\n        if (newCollateral > 0) {\n            collateral().safeTransferFrom(msg.sender, address(this), newCollateral);\n        }\n\n        // If necessary, trigger lender callback.\n        if (loan.callback) CoolerCallback(loan.lender).onRoll(loanID_, newDebt, newCollateral);\n    }\n\n    /// @notice Delegate voting power on collateral.\n    /// @param  to_ address to delegate.\n    function delegateVoting(address to_) external {\n        if (msg.sender != owner()) revert OnlyApproved();\n        IDelegate(address(collateral())).delegate(to_);\n    }\n\n    // --- LENDER ----------------------------------------------------\n\n    /// @notice Fill a requested loan as a lender.\n    /// @param  reqID_ index of request in requests[].\n    /// @param  repayDirect_ lender should input false if concerned about debt token blacklisting.\n    /// @param  isCallback_ true if the lender implements the CoolerCallback abstract. False otherwise.\n    /// @return loanID of the granted loan. Equivalent to the index of loan in loans[].\n    function clearRequest(\n        uint256 reqID_,\n        bool repayDirect_,\n        bool isCallback_\n    ) external returns (uint256 loanID) {\n        Request memory req = requests[reqID_];\n\n        // If necessary, ensure lender implements the CoolerCallback abstract.\n        if (isCallback_ && !CoolerCallback(msg.sender).isCoolerCallback()) revert NotCoolerCallback();\n\n        // Ensure loan request is active. \n        if (!req.active) revert Deactivated();\n\n        // Clear the loan request in memory.\n        req.active = false;\n\n        // Calculate and store loan terms.\n        uint256 interest = interestFor(req.amount, req.interest, req.duration);\n        uint256 collat = collateralFor(req.amount, req.loanToCollateral);\n        uint256 expiration = block.timestamp + req.duration;\n        loanID = loans.length;\n        loans.push(\n            Loan({\n                request: req,\n                amount: req.amount + interest,\n                unclaimed: 0,\n                collateral: collat,\n                expiry: expiration,\n                lender: msg.sender,\n                repayDirect: repayDirect_,\n                callback: isCallback_\n            })\n        );\n\n        // Clear the loan request storage.\n        requests[reqID_].active = false;\n\n        // Transfer debt tokens to the owner of the request.\n        debt().safeTransferFrom(msg.sender, owner(), req.amount);\n\n        // Log the event.\n        factory().newEvent(reqID_, CoolerFactory.Events.ClearRequest, 0);\n    }\n\n    /// @notice Provide new terms for loan to be rolled over.\n    /// @param  loanID_ index of loan in loans[].\n    /// @param  interest_ to pay (annualized % of 'amount_'). Expressed in DECIMALS_INTEREST.\n    /// @param  loanToCollateral_ debt tokens per collateral token pledged. Expressed in 10**debt().decimals().\n    /// @param  duration_ of loan tenure in seconds.\n    function provideNewTermsForRoll(\n        uint256 loanID_,\n        uint256 interest_,\n        uint256 loanToCollateral_,\n        uint256 duration_\n    ) external {\n        Loan storage loan = loans[loanID_];\n\n        if (msg.sender != loan.lender) revert OnlyApproved();\n\n        loan.request =\n            Request(\n                loan.amount,\n                interest_,\n                loanToCollateral_,\n                duration_,\n                true\n            );\n    }\n\n    /// @notice Claim debt tokens if repayDirect was false.\n    /// @param  loanID_ index of loan in loans[].\n    function claimRepaid(uint256 loanID_) external {\n        Loan memory loan = loans[loanID_];\n\n        // Update storage.\n        uint256 claim = loan.unclaimed;\n        delete loans[loanID_].unclaimed;\n\n        // Transfer repaid debt back to the lender.\n        debt().safeTransfer(loan.lender, claim);\n    }\n\n    /// @notice Claim collateral upon loan default.\n    /// @param loanID_ index of loan in loans[]\n    /// @return defaulted debt by the borrower, collateral kept by the lender, elapsed time since expiry.\n    function claimDefaulted(uint256 loanID_) external returns (uint256, uint256, uint256) {\n        Loan memory loan = loans[loanID_];\n        delete loans[loanID_];\n\n        if (block.timestamp <= loan.expiry) revert NoDefault();\n\n        // Transfer defaulted collateral to the lender.\n        collateral().safeTransfer(loan.lender, loan.collateral);\n\n        // Log the event.\n        factory().newEvent(loanID_, CoolerFactory.Events.DefaultLoan, 0);\n\n        // If necessary, trigger lender callback.\n        if (loan.callback) CoolerCallback(loan.lender).onDefault(loanID_, loan.amount, loan.collateral);\n        return (loan.amount, loan.collateral, block.timestamp - loan.expiry);\n    }\n\n    /// @notice Approve transfer of loan ownership rights to a new address.\n    /// @param  to_ address to be approved.\n    /// @param  loanID_ index of loan in loans[].\n    function approveTransfer(address to_, uint256 loanID_) external {\n        if (msg.sender != loans[loanID_].lender) revert OnlyApproved();\n\n        // Update transfer approvals.\n        approvals[loanID_] = to_;\n    }\n\n    /// @notice Execute loan ownership transfer. Must be previously approved by the lender.\n    /// @param  loanID_ index of loan in loans[].\n    function transferOwnership(uint256 loanID_) external {\n        if (msg.sender != approvals[loanID_]) revert OnlyApproved();\n\n        // Update the load lender.\n        loans[loanID_].lender = msg.sender;\n        // Clear transfer approvals.\n        approvals[loanID_] = address(0);\n    }\n\n    /// @notice Set direct repayment of a given loan.\n    /// @param  loanID_ of lender's loan.\n    /// @param  direct_ true if a direct repayment is desired. False otherwise.\n    function setDirectRepay(uint256 loanID_, bool direct_) external {\n        if (msg.sender != loans[loanID_].lender) revert OnlyApproved();\n\n        // Update the repayment method.\n        loans[loanID_].repayDirect = direct_;\n    }\n\n    // --- AUX FUNCTIONS ---------------------------------------------\n\n    /// @notice Compute collateral needed for loan amount at given loan to collateral ratio.\n    /// @param  amount_ of collateral tokens.\n    /// @param  loanToCollateral_ ratio for loan.\n    function collateralFor(uint256 amount_, uint256 loanToCollateral_) public view returns (uint256) {\n        return (amount_ * (10 ** collateral().decimals())) / loanToCollateral_;\n    }\n\n    /// @notice compute collateral needed to roll loan.\n    /// @param  loanID_ of loan to roll.\n    function newCollateralFor(uint256 loanID_) public view returns (uint256) {\n        Loan memory loan = loans[loanID_];\n        /"
    }
  ]
}