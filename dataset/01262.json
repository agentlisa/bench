{
  "Title": "Emitting incorrect event value",
  "Content": "# Emitting incorrect event value\n\n### Severity\nLow Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibShortRecord.sol#L366\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibShortRecord.sol#L366</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibShortRecord.sol#L371\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibShortRecord.sol#L371</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibShortRecord.sol#L374\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibShortRecord.sol#L374</a>\n\n\n## Summary\n\nThe `LibShortRecord::burnNFT()` emits an incorrect event value.\n\n## Vulnerability Details\n\nThe `burnNFT()` emits an incorrect event value: `nft.owner`. Specifically, the `nft` variable will point to the [storage object specified by the `tokenId`](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibShortRecord.sol#L366). However, the [pointing storage object will be deleted](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibShortRecord.sol#L371) before [emitting the `Transfer` event](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibShortRecord.sol#L374).\n\nSubsequently, the `ERC721::Transfer` event will be emitted with `nft.owner` == `address(0)`.\n\n```solidity\n    function burnNFT(uint256 tokenId) internal {\n        //@dev No need to check downcast tokenId because it is handled in function that calls burnNFT\n        AppStorage storage s = appStorage();\n@>      STypes.NFT storage nft = s.nftMapping[tokenId];\n        if (nft.owner == address(0)) revert Errors.NotMinted();\n        address asset = s.assetMapping[nft.assetId];\n        STypes.ShortRecord storage short =\n            s.shortRecords[asset][nft.owner][nft.shortRecordId];\n@>      delete s.nftMapping[tokenId];\n        delete s.getApproved[tokenId];\n        delete short.tokenId;\n@>      emit Events.Transfer(nft.owner, address(0), tokenId);\n    }\n```\n\n- https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibShortRecord.sol#L366\n\n- https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibShortRecord.sol#L371\n\n- https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibShortRecord.sol#L374\n\n## Impact\n\nThe `ERC721::Transfer` is an important event. The incorrect event logs may cause off-chain services to malfunction.\n\n## Tools Used\n\nManual Review\n\n## Recommendations\n\nEmit the `Transfer` event before the `delete` operations.\n\n```diff\n    function burnNFT(uint256 tokenId) internal {\n        //@dev No need to check downcast tokenId because it is handled in function that calls burnNFT\n        AppStorage storage s = appStorage();\n        STypes.NFT storage nft = s.nftMapping[tokenId];\n        if (nft.owner == address(0)) revert Errors.NotMinted();\n        address asset = s.assetMapping[nft.assetId];\n        STypes.ShortRecord storage short =\n            s.shortRecords[asset][nft.owner][nft.shortRecordId];\n+       emit Events.Transfer(nft.owner, address(0), tokenId);\n        delete s.nftMapping[tokenId];\n        delete s.getApproved[tokenId];\n        delete short.tokenId;\n-       emit Events.Transfer(nft.owner, address(0), tokenId);\n    }\n```",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clm871gl00001mp081mzjdlwc",
  "Code": [
    {
      "filename": "contracts/libraries/LibShortRecord.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U88, U80} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {STypes, SR} from \"contracts/libraries/DataTypes.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {AppStorage, appStorage} from \"contracts/libraries/AppStorage.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\nlibrary LibShortRecord {\n    using U256 for uint256;\n    using U88 for uint88;\n    using U80 for uint80;\n\n    function getCollateralRatio(STypes.ShortRecord memory short, address asset)\n        internal\n        view\n        returns (uint256 cRatio)\n    {\n        return short.collateral.div(short.ercDebt.mul(LibOracle.getPrice(asset)));\n    }\n\n    function getCollateralRatioSpotPrice(\n        STypes.ShortRecord memory short,\n        uint256 oraclePrice\n    ) internal pure returns (uint256 cRatio) {\n        return short.collateral.div(short.ercDebt.mul(oraclePrice));\n    }\n\n    /**\n     * @notice Returns number of active shortRecords\n     *\n     * @param asset The market that will be impacted\n     * @param shorter Shorter address\n     *\n     * @return shortRecordCount\n     */\n    function getShortRecordCount(address asset, address shorter)\n        internal\n        view\n        returns (uint256 shortRecordCount)\n    {\n        AppStorage storage s = appStorage();\n\n        // Retrieve first non-HEAD short\n        uint8 id = s.shortRecords[asset][shorter][Constants.HEAD].nextId;\n        if (id <= Constants.HEAD) {\n            return 0;\n        }\n\n        while (true) {\n            shortRecordCount++;\n            // One short of one shorter in this order book\n            STypes.ShortRecord storage currentShort = s.shortRecords[asset][shorter][id];\n            // Move to next short unless this is the last one\n            if (currentShort.nextId > Constants.HEAD) {\n                id = currentShort.nextId;\n            } else {\n                return shortRecordCount;\n            }\n        }\n    }\n\n    function createShortRecord(\n        address asset,\n        address shorter,\n        SR status,\n        uint88 collateral,\n        uint88 ercAmount,\n        uint64 ercDebtRate,\n        uint80 zethYieldRate,\n        uint40 tokenId\n    ) internal returns (uint8 id) {\n        AppStorage storage s = appStorage();\n\n        // ensure the tokenId can be downcasted to 40 bits\n        if (tokenId > type(uint40).max) revert Errors.InvalidTokenId();\n\n        uint8 nextId;\n        (id, nextId) = setShortRecordIds(asset, shorter);\n\n        if (id <= Constants.SHORT_MAX_ID) {\n            s.shortRecords[asset][shorter][id] = STypes.ShortRecord({\n                prevId: Constants.HEAD,\n                id: id,\n                nextId: nextId,\n                status: status,\n                collateral: collateral,\n                ercDebt: ercAmount,\n                ercDebtRate: ercDebtRate,\n                zethYieldRate: zethYieldRate,\n                flaggerId: 0,\n                tokenId: tokenId,\n                updatedAt: LibOrders.getOffsetTimeHours()\n            });\n            emit Events.CreateShortRecord(asset, shorter, id);\n        } else {\n            // All shortRecordIds used, combine into max shortRecordId\n            id = Constants.SHORT_MAX_ID;\n            fillShortRecord(\n                asset,\n                shorter,\n                id,\n                status,\n                collateral,\n                ercAmount,\n                ercDebtRate,\n                zethYieldRate\n            );\n        }\n    }\n\n    function transferShortRecord(\n        address asset,\n        address from,\n        address to,\n        uint40 tokenId,\n        STypes.NFT memory nft\n    ) internal {\n        AppStorage storage s = appStorage();\n        STypes.ShortRecord storage short = s.shortRecords[asset][from][nft.shortRecordId];\n        if (short.status == SR.Cancelled) revert Errors.OriginalShortRecordCancelled();\n        if (short.flaggerId != 0) revert Errors.CannotTransferFlaggedShort();\n\n        deleteShortRecord(asset, from, nft.shortRecordId);\n\n        uint8 id = createShortRecord(\n            asset,\n            to,\n            SR.FullyFilled,\n            short.collateral,\n            short.ercDebt,\n            short.ercDebtRate,\n            short.zethYieldRate,\n            tokenId\n        );\n\n        if (id == Constants.SHORT_MAX_ID) {\n            revert Errors.ReceiverExceededShortRecordLimit();\n        }\n\n        s.nftMapping[tokenId].owner = to;\n        s.nftMapping[tokenId].shortRecordId = id;\n    }\n\n    function fillShortRecord(\n        address asset,\n        address shorter,\n        uint8 shortId,\n        SR status,\n        uint88 collateral,\n        uint88 ercAmount,\n        uint256 ercDebtRate,\n        uint256 zethYieldRate\n    ) internal {\n        AppStorage storage s = appStorage();\n\n        uint256 ercDebtSocialized = ercAmount.mul(ercDebtRate);\n        uint256 yield = collateral.mul(zethYieldRate);\n\n        STypes.ShortRecord storage short = s.shortRecords[asset][shorter][shortId];\n        if (short.status == SR.Cancelled) {\n            short.ercDebt = short.collateral = 0;\n        }\n\n        short.status = status;\n        LibShortRecord.merge(\n            short,\n            ercAmount,\n            ercDebtSocialized,\n            collateral,\n            yield,\n            LibOrders.getOffsetTimeHours()\n        );\n    }\n\n    function deleteShortRecord(address asset, address shorter, uint8 id) internal {\n        AppStorage storage s = appStorage();\n\n        STypes.ShortRecord storage shortRecord = s.shortRecords[asset][shorter][id];\n        // Because of the onlyValidShortRecord modifier, only cancelShort can pass SR.Cancelled\n        // Don't recycle shortRecord id 254 so it can be used for all overflow uint8 ids\n        if (shortRecord.status != SR.PartialFill && id < Constants.SHORT_MAX_ID) {\n            // remove the links of ID in the market\n            // @dev (ID) is exiting, [ID] is inserted\n            // BEFORE: PREV <-> (ID) <-> NEXT\n            // AFTER : PREV <----------> NEXT\n            s.shortRecords[asset][shorter][shortRecord.prevId].nextId = shortRecord.nextId;\n            if (shortRecord.nextId != Constants.HEAD) {\n                s.shortRecords[asset][shorter][shortRecord.nextId].prevId =\n                    shortRecord.prevId;\n            }\n            // Make reuseable for future short records\n            uint8 prevHEAD = s.shortRecords[asset][shorter][Constants.HEAD].prevId;\n            s.shortRecords[asset][shorter][Constants.HEAD].prevId = id;\n            // Move the cancelled ID behind HEAD to re-use it\n            // note: C_IDs (cancelled ids) only need to point back (set prevId, can retain nextId)\n            // BEFORE: .. C_ID2 <- C_ID1 <--------- HEAD <-> ... [ID]\n            // AFTER1: .. C_ID2 <- C_ID1 <- [ID] <- HEAD <-> ...\n            if (prevHEAD > Constants.HEAD) {\n                shortRecord.prevId = prevHEAD;\n            } else {\n                // if this is the first ID cancelled\n                // HEAD.prevId needs to be HEAD\n                // and one of the cancelled id.prevID should point to HEAD\n                // BEFORE: HEAD <--------- HEAD <-> ... [ID]\n                // AFTER1: HEAD <- [ID] <- HEAD <-> ...\n                shortRecord.prevId = Constants.HEAD;\n            }\n\n            //Event for delete SR is emitted here and not at the top level because\n            //SR may be cancelled, but there might tied to an active short order\n            //The code above is hit when that SR id is ready for reuse\n            emit Events.DeleteShortRecord(asset, shorter, id);\n        }\n\n        shortRecord.status = SR.Cancelled;\n    }\n\n    function setShortRecordIds(address asset, address shorter)\n        private\n        returns (uint8 id, uint8 nextId)\n    {\n        AppStorage storage s = appStorage();\n\n        STypes.ShortRecord storage guard = s.shortRecords[asset][shorter][Constants.HEAD];\n        STypes.AssetUser storage AssetUser = s.assetUser[asset][shorter];\n        // Initialize HEAD in case of first short createShortRecord\n        if (AssetUser.shortRecordId == 0) {\n            AssetUser.shortRecordId = Constants.SHORT_STARTING_ID;\n            guard.prevId = Constants.HEAD;\n            guard.nextId = Constants.HEAD;\n        }\n        // BEFORE: HEAD <-> .. <-> PREV <--------------> NEXT\n        // AFTER1: HEAD <-> .. <-> PREV <-> (NEW ID) <-> NEXT\n        // place created short next to HEAD\n        nextId = guard.nextId;\n        uint8 canceledId = guard.prevId;\n        // @dev (ID) is exiting, [ID] is inserted\n        // in this case, the protocol re-uses (ID) and moves it to [ID]\n        // check if a previously closed short exists\n        if (canceledId > Constants.HEAD) {\n            // BEFORE: CancelledID <- (ID) <- HEAD <-> .. <-> PREV <----------> NEXT\n            // AFTER1: CancelledID <--------- HEAD <-> .. <-> PREV <-> [ID] <-> NEXT\n            uint8 prevCanceledId = s.shortRecords[asset][shorter][canceledId].prevId;\n            if (prevCanceledId > Constants.HEAD) {\n                guard.prevId = prevCanceledId;\n            } else {\n                // BEFORE: HEAD <- (ID) <- HEAD <-> .. <-> PREV <----------> NEXT\n                // AFTER1: HEAD <--------- HEAD <-> .. <-> PREV <-> [ID] <-> NEXT\n                guard.prevId = Constants.HEAD;\n            }\n            // re-use the previous order's id\n            id = canceledId;\n        } else {\n            // BEFORE: HEAD <-> .. <-> PREV <--------------> NEXT\n            // AFTER1: HEAD <-> .. <-> PREV <-> (NEW ID) <-> NEXT\n            // otherwise just increment to a new short record id\n            // and the short record grows in height/size\n            id = AssetUser.shortRecordId;\n            // Avoids overflow revert, prevents DOS on uint8\n            if (id < type(uint8).max) {\n                AssetUser.shortRecordId += 1;\n            } else {\n                // If max id reached, match into max shortRecordId\n                return (id, nextId);\n            }\n        }\n\n        if (nextId > Constants.HEAD) {\n            s.shortRecords[asset][shorter][nextId].prevId = id;\n        }\n        guard.nextId = id;\n    }\n\n    function updateErcDebt(address asset, address shorter, uint8 shortId) internal {\n        AppStorage storage s = appStorage();\n\n        STypes.ShortRecord storage short = s.shortRecords[asset][shorter][shortId];\n\n        // Distribute ercDebt\n        uint64 ercDebtRate = s.asset[asset].ercDebtRate;\n        uint88 ercDebt = short.ercDebt.mulU88(ercDebtRate - short.ercDebtRate);\n\n        if (ercDebt > 0) {\n            short.ercDebt += ercDebt;\n            short.ercDebtRate = ercDebtRate;\n        }\n    }\n\n    function updateErcDebt(STypes.ShortRecord storage short, address asset) internal {\n        AppStorage storage s = appStorage();\n\n        // Distribute ercDebt\n        uint64 ercDebtRate = s.asset[asset].ercDebtRate;\n        uint88 ercDebt = short.ercDebt.mulU88(ercDebtRate - short.ercDebtRate);\n\n        if (ercDebt > 0) {\n            short.ercDebt += ercDebt;\n            short.ercDebtRate = ercDebtRate;\n        }\n    }\n\n    function merge(\n        STypes.ShortRecord storage short,\n        uint88 ercDebt,\n        uint256 ercDebtSocialized,\n        uint88 collateral,\n        uint256 yield,\n        uint24 creationTime\n    ) internal {\n        // Resolve ercDebt\n        ercDebtSocialized += short.ercDebt.mul(short.ercDebtRate);\n        short.ercDebt += ercDebt;\n        short.ercDebtRate = ercDebtSocialized.divU64(short.ercDebt);\n        // Resolve zethCollateral\n        yield += short.collateral.mul(short.zethYieldRate);\n        short.collateral += collateral;\n        short.zethYieldRate = yield.divU80(short.collateral);\n        // Assign updatedAt\n        short.updatedAt = creationTime;\n    }\n\n    function disburseCollateral(\n        address asset,\n        address shorter,\n        uint88 collateral,\n        uint256 zethYieldRate,\n        uint24 updatedAt\n    ) internal {\n        AppStorage storage s = appStorage();\n\n        STypes.Asset storage Asset = s.asset[asset];\n        uint256 vault = Asset.vault;\n        STypes.Vault storage Vault = s.vault[vault];\n\n        Vault.zethCollateral -= collateral;\n        Asset.zethCollateral -= collateral;\n        // Distribute yield\n        uint88 yield = collateral.mulU88(Vault.zethYieldRate - zethYieldRate);\n        if (yield > 0) {\n            /*\n            @dev If somebody exits a short, gets margin called, decreases their collateral before YIELD_DELAY_HOURS duration is up,\n            they lose their yield to the TAPP\n            */\n            bool isNotRecentlyModified =\n                LibOrders.getOffsetTimeHours() - updatedAt > Constants.YIELD_DELAY_HOURS;\n            if (isNotRecentlyModified) {\n                s.vaultUser[vault][shorter].ethEscrowed += yield;\n            } else {\n                s.vaultUser[vault][address(this)].ethEscrowed += yield;\n            }\n        }\n    }\n\n    function burnNFT(uint256 tokenId) internal {\n        //@dev No need to check downcast tokenId because it is handled in function that calls burnNFT\n        AppStorage storage s = appStorage();\n        STypes.NFT storage nft = s.nftMapping[tokenId];\n        if (nft.owner == address(0)) revert Errors.NotMinted();\n        address asset = s.assetMapping[nft.assetId];\n        STypes.ShortRecord storage short =\n            s.shortRecords[asset][nft.owner][nft.shortRecordId];\n        delete s.nftMapping[tokenId];\n        delete s.getApproved[tokenId];\n        delete short.tokenId;\n        emit Events.Transfer(nft.owner, address(0), tokenId);\n    }\n\n    function setFlagger(\n        STypes.ShortRecord storage short,\n        address cusd,\n        uint16 flaggerHint\n    ) internal {\n        AppStorage storage s = appStorage();\n        STypes.AssetUser storage flagStorage = s.assetUser[cusd][msg.sender];\n\n        //@dev Whenever a new flagger flags, use the flaggerIdCounter.\n        if (flagStorage.g_flaggerId == 0) {\n            address flaggerToReplace = s.flagMapping[flaggerHint];\n\n            uint256 timeDiff = flaggerToReplace != address(0)\n                ? LibOrders.getOffsetTimeHours()\n                    - s.assetUser[cusd][flaggerToReplace].g_updatedAt\n                : 0;\n            //@dev re-use an inactive flaggerId\n            if (timeDiff > LibAsset.firstLiquidationTime(cusd)) {\n                delete s.assetUser[cusd][flaggerToReplace].g_flaggerId;\n                short.flaggerId = flagStorage.g_flaggerId = flaggerHint;\n            } else if (s.flaggerIdCounter < type(uint16).max) {\n                //@dev generate brand new flaggerId\n                short.flaggerId = flagStorage.g_flaggerId = s.flaggerIdCounter;\n                s.flaggerIdCounter++;\n            } else {\n                revert Errors.InvalidFlaggerHint();\n            }\n            s.flagMapping[short.flaggerId] = msg.sender;\n        } else {\n            //@dev re-use flaggerId if flagger has an existing one\n            short.flaggerId = flagStorage.g_flaggerId;\n        }\n        short.updatedAt = flagStorage.g_updatedAt = LibOrders.getOffsetTimeHours();\n    }\n\n    //@dev reset flag info if new cratio is above primaryLiquidationCR\n    function maybeResetFlag(STypes.ShortRecord storage short, address asset) internal {\n        if (short.flaggerId != 0) {\n            if (\n                LibShortRecord.getCollateralRatio(short, asset)\n                    >= LibAsset.primaryLiquidationCR(asset)\n            ) {\n                LibShortRecord.resetFlag(short);\n            }\n        }\n    }\n\n    function resetFlag(STypes.ShortRecord storage shortRecord) internal {\n        delete shortRecord.flaggerId;\n        shortRecord.updatedAt = LibOrders.getOffsetTimeHours();\n    }\n}"
    },
    {
      "filename": "contracts/libraries/LibShortRecord.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U88, U80} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {STypes, SR} from \"contracts/libraries/DataTypes.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {AppStorage, appStorage} from \"contracts/libraries/AppStorage.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\nlibrary LibShortRecord {\n    using U256 for uint256;\n    using U88 for uint88;\n    using U80 for uint80;\n\n    function getCollateralRatio(STypes.ShortRecord memory short, address asset)\n        internal\n        view\n        returns (uint256 cRatio)\n    {\n        return short.collateral.div(short.ercDebt.mul(LibOracle.getPrice(asset)));\n    }\n\n    function getCollateralRatioSpotPrice(\n        STypes.ShortRecord memory short,\n        uint256 oraclePrice\n    ) internal pure returns (uint256 cRatio) {\n        return short.collateral.div(short.ercDebt.mul(oraclePrice));\n    }\n\n    /**\n     * @notice Returns number of active shortRecords\n     *\n     * @param asset The market that will be impacted\n     * @param shorter Shorter address\n     *\n     * @return shortRecordCount\n     */\n    function getShortRecordCount(address asset, address shorter)\n        internal\n        view\n        returns (uint256 shortRecordCount)\n    {\n        AppStorage storage s = appStorage();\n\n        // Retrieve first non-HEAD short\n        uint8 id = s.shortRecords[asset][shorter][Constants.HEAD].nextId;\n        if (id <= Constants.HEAD) {\n            return 0;\n        }\n\n        while (true) {\n            shortRecordCount++;\n            // One short of one shorter in this order book\n            STypes.ShortRecord storage currentShort = s.shortRecords[asset][shorter][id];\n            // Move to next short unless this is the last one\n            if (currentShort.nextId > Constants.HEAD) {\n                id = currentShort.nextId;\n            } else {\n                return shortRecordCount;\n            }\n        }\n    }\n\n    function createShortRecord(\n        address asset,\n        address shorter,\n        SR status,\n        uint88 collateral,\n        uint88 ercAmount,\n        uint64 ercDebtRate,\n        uint80 zethYieldRate,\n        uint40 tokenId\n    ) internal returns (uint8 id) {\n        AppStorage storage s = appStorage();\n\n        // ensure the tokenId can be downcasted to 40 bits\n        if (tokenId > type(uint40).max) revert Errors.InvalidTokenId();\n\n        uint8 nextId;\n        (id, nextId) = setShortRecordIds(asset, shorter);\n\n        if (id <= Constants.SHORT_MAX_ID) {\n            s.shortRecords[asset][shorter][id] = STypes.ShortRecord({\n                prevId: Constants.HEAD,\n                id: id,\n                nextId: nextId,\n                status: status,\n                collateral: collateral,\n                ercDebt: ercAmount,\n                ercDebtRate: ercDebtRate,\n                zethYieldRate: zethYieldRate,\n                flaggerId: 0,\n                tokenId: tokenId,\n                updatedAt: LibOrders.getOffsetTimeHours()\n            });\n            emit Events.CreateShortRecord(asset, shorter, id);\n        } else {\n            // All shortRecordIds used, combine into max shortRecordId\n            id = Constants.SHORT_MAX_ID;\n            fillShortRecord(\n                asset,\n                shorter,\n                id,\n                status,\n                collateral,\n                ercAmount,\n                ercDebtRate,\n                zethYieldRate\n            );\n        }\n    }\n\n    function transferShortRecord(\n        address asset,\n        address from,\n        address to,\n        uint40 tokenId,\n        STypes.NFT memory nft\n    ) internal {\n        AppStorage storage s = appStorage();\n        STypes.ShortRecord storage short = s.shortRecords[asset][from][nft.shortRecordId];\n        if (short.status == SR.Cancelled) revert Errors.OriginalShortRecordCancelled();\n        if (short.flaggerId != 0) revert Errors.CannotTransferFlaggedShort();\n\n        deleteShortRecord(asset, from, nft.shortRecordId);\n\n        uint8 id = createShortRecord(\n            asset,\n            to,\n            SR.FullyFilled,\n            short.collateral,\n            short.ercDebt,\n            short.ercDebtRate,\n            short.zethYieldRate,\n            tokenId\n        );\n\n        if (id == Constants.SHORT_MAX_ID) {\n            revert Errors.ReceiverExceededShortRecordLimit();\n        }\n\n        s.nftMapping[tokenId].owner = to;\n        s.nftMapping[tokenId].shortRecordId = id;\n    }\n\n    function fillShortRecord(\n        address asset,\n        address shorter,\n        uint8 shortId,\n        SR status,\n        uint88 collateral,\n        uint88 ercAmount,\n        uint256 ercDebtRate,\n        uint256 zethYieldRate\n    ) internal {\n        AppStorage storage s = appStorage();\n\n        uint256 ercDebtSocialized = ercAmount.mul(ercDebtRate);\n        uint256 yield = collateral.mul(zethYieldRate);\n\n        STypes.ShortRecord storage short = s.shortRecords[asset][shorter][shortId];\n        if (short.status == SR.Cancelled) {\n            short.ercDebt = short.collateral = 0;\n        }\n\n        short.status = status;\n        LibShortRecord.merge(\n            short,\n            ercAmount,\n            ercDebtSocialized,\n            collateral,\n            yield,\n            LibOrders.getOffsetTimeHours()\n        );\n    }\n\n    function deleteShortRecord(address asset, address shorter, uint8 id) internal {\n        AppStorage storage s = appStorage();\n\n        STypes.ShortRecord storage shortRecord = s.shortRecords[asset][shorter][id];\n        // Because of the onlyValidShortRecord modifier, only cancelShort can pass SR.Cancelled\n        // Don't recycle shortRecord id 254 so it can be used for all overflow uint8 ids\n        if (shortRecord.status != SR.PartialFill && id < Constants.SHORT_MAX_ID) {\n            // remove the links of ID in the market\n            // @dev (ID) is exiting, [ID] is inserted\n            // BEFORE: PREV <-> (ID) <-> NEXT\n            // AFTER : PREV <----------> NEXT\n            s.shortRecords[asset][shorter][shortRecord.prevId].nextId = shortRecord.nextId;\n            if (shortRecord.nextId != Constants.HEAD) {\n                s.shortRecords[asset][shorter][shortRecord.nextId].prevId =\n                    shortRecord.prevId;\n            }\n            // Make reuseable for future short records\n            uint8 prevHEAD = s.shortRecords[asset][shorter][Constants.HEAD].prevId;\n            s.shortRecords[asset][shorter][Constants.HEAD].prevId = id;\n            // Move the cancelled ID behind HEAD to re-use it\n            // note: C_IDs (cancelled ids) only need to point back (set prevId, can retain nextId)\n            // BEFORE: .. C_ID2 <- C_ID1 <--------- HEAD <-> ... [ID]\n            // AFTER1: .. C_ID2 <- C_ID1 <- [ID] <- HEAD <-> ...\n            if (prevHEAD > Constants.HEAD) {\n                shortRecord.prevId = prevHEAD;\n            } else {\n                // if this is the first ID cancelled\n                // HEAD.prevId needs to be HEAD\n                // and one of the cancelled id.prevID should point to HEAD\n                // BEFORE: HEAD <--------- HEAD <-> ... [ID]\n                // AFTER1: HEAD <- [ID] <- HEAD <-> ...\n                shortRecord.prevId = Constants.HEAD;\n            }\n\n            //Event for delete SR is emitted here and not at the top level because\n            //SR may be cancelled, but there might tied to an active short order\n            //The code above is hit when that SR id is ready for reuse\n            emit Events.DeleteShortRecord(asset, shorter, id);\n        }\n\n        shortRecord.status = SR.Cancelled;\n    }\n\n    function setShortRecordIds(address asset, address shorter)\n        private\n        returns (uint8 id, uint8 nextId)\n    {\n        AppStorage storage s = appStorage();\n\n        STypes.ShortRecord storage guard = s.shortRecords[asset][shorter][Constants.HEAD];\n        STypes.AssetUser storage AssetUser = s.assetUser[asset][shorter];\n        // Initialize HEAD in case of first short createShortRecord\n        if (AssetUser.shortRecordId == 0) {\n            AssetUser.shortRecordId = Constants.SHORT_STARTING_ID;\n            guard.prevId = Constants.HEAD;\n            guard.nextId = Constants.HEAD;\n        }\n        // BEFORE: HEAD <-> .. <-> PREV <--------------> NEXT\n        // AFTER1: HEAD <-> .. <-> PREV <-> (NEW ID) <-> NEXT\n        // place created short next to HEAD\n        nextId = guard.nextId;\n        uint8 canceledId = guard.prevId;\n        // @dev (ID) is exiting, [ID] is inserted\n        // in this case, the protocol re-uses (ID) and moves it to [ID]\n        // check if a previously closed short exists\n        if (canceledId > Constants.HEAD) {\n            // BEFORE: CancelledID <- (ID) <- HEAD <-> .. <-> PREV <----------> NEXT\n            // AFTER1: CancelledID <--------- HEAD <-> .. <-> PREV <-> [ID] <-> NEXT\n            uint8 prevCanceledId = s.shortRecords[asset][shorter][canceledId].prevId;\n            if (prevCanceledId > Constants.HEAD) {\n                guard.prevId = prevCanceledId;\n            } else {\n                // BEFORE: HEAD <- (ID) <- HEAD <-> .. <-> PREV <----------> NEXT\n                // AFTER1: HEAD <--------- HEAD <-> .. <-> PREV <-> [ID] <-> NEXT\n                guard.prevId = Constants.HEAD;\n            }\n            // re-use the previous order's id\n            id = canceledId;\n        } else {\n            // BEFORE: HEAD <-> .. <-> PREV <--------------> NEXT\n            // AFTER1: HEAD <-> .. <-> PREV <-> (NEW ID) <-> NEXT\n            // otherwise just increment to a new short record id\n            // and the short record grows in height/size\n            id = AssetUser.shortRecordId;\n            // Avoids overflow revert, prevents DOS on uint8\n            if (id < type(uint8).max) {\n                AssetUser.shortRecordId += 1;\n            } else {\n                // If max id reached, match into max shortRecordId\n                return (id, nextId);\n            }\n        }\n\n        if (nextId > Constants.HEAD) {\n            s.shortRecords[asset][shorter][nextId].prevId = id;\n        }\n        guard.nextId = id;\n    }\n\n    function updateErcDebt(address asset, address shorter, uint8 shortId) internal {\n        AppStorage storage s = appStorage();\n\n        STypes.ShortRecord storage short = s.shortRecords[asset][shorter][shortId];\n\n        // Distribute ercDebt\n        uint64 ercDebtRate = s.asset[asset].ercDebtRate;\n        uint88 ercDebt = short.ercDebt.mulU88(ercDebtRate - short.ercDebtRate);\n\n        if (ercDebt > 0) {\n            short.ercDebt += ercDebt;\n            short.ercDebtRate = ercDebtRate;\n        }\n    }\n\n    function updateErcDebt(STypes.ShortRecord storage short, address asset) internal {\n        AppStorage storage s = appStorage();\n\n        // Distribute ercDebt\n        uint64 ercDebtRate = s.asset[asset].ercDebtRate;\n        uint88 ercDebt = short.ercDebt.mulU88(ercDebtRate - short.ercDebtRate);\n\n        if (ercDebt > 0) {\n            short.ercDebt += ercDebt;\n            short.ercDebtRate = ercDebtRate;\n        }\n    }\n\n    function merge(\n        STypes.ShortRecord storage short,\n        uint88 ercDebt,\n        uint256 ercDebtSocialized,\n        uint88 collateral,\n        uint256 yield,\n        uint24 creationTime\n    ) internal {\n        // Resolve ercDebt\n        ercDebtSocialized += short.ercDebt.mul(short.ercDebtRate);\n        short.ercDebt += ercDebt;\n        short.ercDebtRate = ercDebtSocialized.divU64(short.ercDebt);\n        // Resolve zethCollateral\n        yield += short.collateral.mul(short.zethYieldRate);\n        short.collateral += collateral;\n        short.zethYieldRate = yield.divU80(short.collateral);\n        // Assign updatedAt\n        short.updatedAt = creationTime;\n    }\n\n    function disburseCollateral(\n        address asset,\n        address shorter,\n        uint88 collateral,\n        uint256 zethYieldRate,\n        uint24 updatedAt\n    ) internal {\n        AppStorage storage s = appStorage();\n\n        STypes.Asset storage Asset = s.asset[asset];\n        uint256 vault = Asset.vault;\n        STypes.Vault storage Vault = s.vault[vault];\n\n        Vault.zethCollateral -= collateral;\n        Asset.zethCollateral -= collateral;\n        // Distribute yield\n        uint88 yield = collateral.mulU88(Vault.zethYieldRate - zethYieldRate);\n        if (yield > 0) {\n            /*\n            @dev If somebody exits a short, gets margin called, decreases their collateral before YIELD_DELAY_HOURS duration is up,\n            they lose their yield to the TAPP\n            */\n            bool isNotRecentlyModified =\n                LibOrders.getOffsetTimeHours() - updatedAt > Constants.YIELD_DELAY_HOURS;\n            if (isNotRecentlyModified) {\n                s.vaultUser[vault][shorter].ethEscrowed += yield;\n            } else {\n                s.vaultUser[vault][address(this)].ethEscrowed += yield;\n            }\n        }\n    }\n\n    function burnNFT(uint256 tokenId) internal {\n        //@dev No need to check downcast tokenId because it is handled in function that calls burnNFT\n        AppStorage storage s = appStorage();\n        STypes.NFT storage nft = s.nftMapping[tokenId];\n        if (nft.owner == address(0)) revert Errors.NotMinted();\n        address asset = s.assetMapping[nft.assetId];\n        STypes.ShortRecord storage short =\n            s.shortRecords[asset][nft.owner][nft.shortRecordId];\n        delete s.nftMapping[tokenId];\n        delete s.getApproved[tokenId];\n        delete short.tokenId;\n        emit Events.Transfer(nft.owner, address(0), tokenId);\n    }\n\n    function setFlagger(\n        STypes.ShortRecord storage short,\n        address cusd,\n        uint16 flaggerHint\n    ) internal {\n        AppStorage storage s = appStorage();\n        STypes.AssetUser storage flagStorage = s.assetUser[cusd][msg.sender];\n\n        //@dev Whenever a new flagger flags, use the flaggerIdCounter.\n        if (flagStorage.g_flaggerId == 0) {\n            address flaggerToReplace = s.flagMapping[flaggerHint];\n\n            uint256 timeDiff = flaggerToReplace != address(0)\n                ? LibOrders.getOffsetTimeHours()\n                    - s.assetUser[cusd][flaggerToReplace].g_updatedAt\n                : 0;\n            //@dev re-use an inactive flaggerId\n            if (timeDiff > LibAsset.firstLiquidationTime(cusd)) {\n                delete s.assetUser[cusd][flaggerToReplace].g_flaggerId;\n                short.flaggerId = flagStorage.g_flaggerId = flaggerHint;\n            } else if (s.flaggerIdCounter < type(uint16).max) {\n                //@dev generate brand new flaggerId\n                short.flaggerId = flagStorage.g_flaggerId = s.flaggerIdCounter;\n                s.flaggerIdCounter++;\n            } else {\n                revert Errors.InvalidFlaggerHint();\n            }\n            s.flagMapping[short.flaggerId] = msg.sender;\n        } else {\n            //@dev re-use flaggerId if flagger has an existing one\n            short.flaggerId = flagStorage.g_flaggerId;\n        }\n        short.updatedAt = flagStorage.g_updatedAt = LibOrders.getOffsetTimeHours();\n    }\n\n    //@dev reset flag info if new cratio is above primaryLiquidationCR\n    function maybeResetFlag(STypes.ShortRecord storage short, address asset) internal {\n        if (short.flaggerId != 0) {\n            if (\n                LibShortRecord.getCollateralRatio(short, asset)\n                    >= LibAsset.primaryLiquidationCR(asset)\n            ) {\n                LibShortRecord.resetFlag(short);\n            }\n        }\n    }\n\n    function resetFlag(STypes.ShortRecord storage shortRecord) internal {\n        delete shortRecord.flaggerId;\n        shortRecord.updatedAt = LibOrders.getOffsetTimeHours();\n    }\n}"
    },
    {
      "filename": "contracts/libraries/LibShortRecord.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U88, U80} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {STypes, SR} from \"contracts/libraries/DataTypes.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {AppStorage, appStorage} from \"contracts/libraries/AppStorage.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOrde"
    }
  ]
}