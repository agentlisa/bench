{
  "Title": "[G-09] Default value initialization",
  "Content": "\nSaves `80 GAS` in 4 instances\n\nIf a variable is not set/initialized, it is assumed to have the default value`(0, false, 0x0 etc depending on the data type)`. Explicitly initializing it with its default value is an anti-pattern and wastes gas.\n\nSaves `15-20` GAS per instance. \n\n```diff\nFILE: 2023-07-axelar/contracts/interchain-governance-executor/InterchainProposalSender.sol\n\n- 63: for (uint256 i = 0; i < interchainCalls.length; ) {\n+ 63: for (uint256 i; i < interchainCalls.length; ) {\n\n- 105: uint256 totalGas = 0;\n+ 105: uint256 totalGas ;\n\n- 106: for (uint256 i = 0; i < interchainCalls.length; ) {\n+ 106: for (uint256 i ; i < interchainCalls.length; ) {\n```\n\nhttps://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/interchain-governance-executor/InterchainProposalSender.sol#L63\n\n```diff\nFILE: 2023-07-axelar/contracts/interchain-governance-executor/InterchainProposalExecutor.sol\n\n- 74: for (uint256 i = 0; i < calls.length; i++) {\n+ 74: for (uint256 i ; i < calls.length; i++) {\n```\n\nhttps://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/interchain-governance-executor/InterchainProposalExecutor.sol#L74\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-07-axelar",
  "Code": [
    {
      "filename": "contracts/interchain-governance-executor/InterchainProposalSender.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IAxelarGateway } from '../gmp-sdk/interfaces/IAxelarGateway.sol';\nimport { IAxelarGasService } from '../gmp-sdk/interfaces/IAxelarGasService.sol';\nimport { IInterchainProposalSender } from './interfaces/IInterchainProposalSender.sol';\nimport { InterchainCalls } from './lib/InterchainCalls.sol';\n\n/**\n * @title InterchainProposalSender\n * @dev This contract is responsible for facilitating the execution of approved proposals across multiple chains.\n * It achieves this by working in conjunction with the AxelarGateway and AxelarGasService contracts.\n *\n * The contract allows for the sending of a single proposal to multiple destination chains. This is achieved\n * through the `sendProposals` function, which takes in arrays representing the destination chains,\n * destination contracts, fees, target contracts, amounts of tokens to send, function signatures, and encoded\n * function arguments.\n *\n * Each destination chain has a unique corresponding set of contracts to call, amounts of native tokens to send,\n * function signatures to call, and encoded function arguments. This information is provided in a 2D array where\n * the first dimension is the destination chain index, and the second dimension corresponds to the specific details\n * for each chain.\n *\n * In addition, the contract also allows for the execution of a single proposal at a single destination chain\n * through the `sendProposal` function. This is a more granular approach and works similarly to the\n * aforementioned function but for a single destination.\n *\n * The contract ensures the correctness of the provided proposal details and fees through a series of internal\n * functions that revert the transaction if any of the checks fail. This includes checking if the provided fees\n * are equal to the total value sent with the transaction, if the lengths of the provided arrays match, and if the\n * provided proposal arguments are valid.\n *\n * The contract works in conjunction with the AxelarGateway and AxelarGasService contracts. It uses the\n * AxelarGasService contract to pay for the gas fees of the interchain transactions and the AxelarGateway\n * contract to call the target contracts on the destination chains with the provided encoded function arguments.\n */\ncontract InterchainProposalSender is IInterchainProposalSender {\n    IAxelarGateway public gateway;\n    IAxelarGasService public gasService;\n\n    constructor(address _gateway, address _gasService) {\n        gateway = IAxelarGateway(_gateway);\n        gasService = IAxelarGasService(_gasService);\n    }\n\n    /**\n     * @dev Broadcast the proposal to be executed at multiple destination chains\n     * @param interchainCalls An array of `InterchainCalls.InterchainCall` to be executed at the destination chains. Where each `InterchainCalls.InterchainCall` contains the following:\n     * - destinationChain: destination chain\n     * - destinationContract: destination contract\n     * - gas: gas to be paid for the interchain transaction\n     * - calls: An array of `InterchainCalls.Call` to be executed at the destination chain. Where each `InterchainCalls.Call` contains the following:\n     *   - target: target contract\n     *   - value: amount of tokens to send\n     *   - callData: encoded function arguments\n     * Note that the destination chain must be unique in the destinationChains array.\n     */\n    function sendProposals(InterchainCalls.InterchainCall[] calldata interchainCalls) external payable override {\n        // revert if the sum of given fees are not equal to the msg.value\n        revertIfInvalidFee(interchainCalls);\n\n        for (uint256 i = 0; i < interchainCalls.length; ) {\n            _sendProposal(interchainCalls[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Broadcast the proposal to be executed at single destination chain.\n     * @param destinationChain destination chain\n     * @param destinationContract destination contract\n     * @param calls An array of calls to be executed at the destination chain. Where each call contains the following:\n     * - target: target contract\n     * - value: amount of tokens to send\n     * - callData: encoded function arguments\n     */\n    function sendProposal(\n        string memory destinationChain,\n        string memory destinationContract,\n        InterchainCalls.Call[] calldata calls\n    ) external payable override {\n        _sendProposal(InterchainCalls.InterchainCall(destinationChain, destinationContract, msg.value, calls));\n    }\n\n    function _sendProposal(InterchainCalls.InterchainCall memory interchainCall) internal {\n        bytes memory payload = abi.encode(msg.sender, interchainCall.calls);\n\n        if (interchainCall.gas > 0) {\n            gasService.payNativeGasForContractCall{ value: interchainCall.gas }(\n                address(this),\n                interchainCall.destinationChain,\n                interchainCall.destinationContract,\n                payload,\n                msg.sender\n            );\n        }\n\n        gateway.callContract(interchainCall.destinationChain, interchainCall.destinationContract, payload);\n    }\n\n    function revertIfInvalidFee(InterchainCalls.InterchainCall[] calldata interchainCalls) private {\n        uint256 totalGas = 0;\n        for (uint256 i = 0; i < interchainCalls.length; ) {\n            totalGas += interchainCalls[i].gas;\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (totalGas != msg.value) {\n            revert InvalidFee();\n        }\n    }\n}"
    },
    {
      "filename": "contracts/interchain-governance-executor/InterchainProposalExecutor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Ownable } from '@openzeppelin/contracts/access/Ownable.sol';\nimport { StringToAddress } from '../gmp-sdk/util/AddressString.sol';\nimport { AxelarExecutable } from '../gmp-sdk/executable/AxelarExecutable.sol';\nimport { IInterchainProposalExecutor } from './interfaces/IInterchainProposalExecutor.sol';\nimport { InterchainCalls } from './lib/InterchainCalls.sol';\n\n/**\n * @title InterchainProposalExecutor\n * @dev This contract is intended to be the destination contract for `InterchainProposalSender` contract.\n * The proposal will be finally executed from this contract on the destination chain.\n *\n * The contract maintains whitelists for proposal senders and proposal callers. Proposal senders\n * are InterchainProposalSender contracts at the source chain and proposal callers are contracts\n * that call the InterchainProposalSender at the source chain.\n * For most governance system, the proposal caller should be the Timelock contract.\n *\n * This contract is abstract and some of its functions need to be implemented in a derived contract.\n */\ncontract InterchainProposalExecutor is IInterchainProposalExecutor, AxelarExecutable, Ownable {\n    // Whitelisted proposal callers. The proposal caller is the contract that calls the `InterchainProposalSender` at the source chain.\n    mapping(string => mapping(address => bool)) public whitelistedCallers;\n\n    // Whitelisted proposal senders. The proposal sender is the `InterchainProposalSender` contract address at the source chain.\n    mapping(string => mapping(address => bool)) public whitelistedSenders;\n\n    constructor(address _gateway, address _owner) AxelarExecutable(_gateway) {\n        _transferOwnership(_owner);\n    }\n\n    /**\n     * @dev Executes the proposal. The source address must be a whitelisted sender.\n     * @param sourceAddress The source address\n     * @param payload The payload. It is ABI encoded of the caller and calls.\n     * Where:\n     * - `caller` is the address that calls the `InterchainProposalSender` at the source chain.\n     * - `calls` is the array of `InterchainCalls.Call` to execute. Each call contains the target, value, signature and data.\n     */\n    function _execute(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) internal override {\n        _beforeProposalExecuted(sourceChain, sourceAddress, payload);\n\n        // Check that the source address is whitelisted\n        if (!whitelistedSenders[sourceChain][StringToAddress.toAddress(sourceAddress)]) {\n            revert NotWhitelistedSourceAddress();\n        }\n\n        // Decode the payload\n        (address interchainProposalCaller, InterchainCalls.Call[] memory calls) = abi.decode(payload, (address, InterchainCalls.Call[]));\n\n        // Check that the caller is whitelisted\n        if (!whitelistedCallers[sourceChain][interchainProposalCaller]) {\n            revert NotWhitelistedCaller();\n        }\n\n        // Execute the proposal with the given arguments\n        _executeProposal(calls);\n\n        _onProposalExecuted(sourceChain, sourceAddress, interchainProposalCaller, payload);\n\n        emit ProposalExecuted(keccak256(abi.encode(sourceChain, sourceAddress, interchainProposalCaller, payload)));\n    }\n\n    /**\n     * @dev Executes the proposal. Calls each target with the respective value, signature, and data.\n     * @param calls The calls to execute.\n     */\n    function _executeProposal(InterchainCalls.Call[] memory calls) internal {\n        for (uint256 i = 0; i < calls.length; i++) {\n            InterchainCalls.Call memory call = calls[i];\n            (bool success, bytes memory result) = call.target.call{ value: call.value }(call.callData);\n\n            if (!success) {\n                _onTargetExecutionFailed(call, result);\n            } else {\n                _onTargetExecuted(call, result);\n            }\n        }\n    }\n\n    /**\n     * @dev Set the proposal caller whitelist status\n     * @param sourceChain The source chain\n     * @param sourceCaller The source caller\n     * @param whitelisted The whitelist status\n     */\n    function setWhitelistedProposalCaller(\n        string calldata sourceChain,\n        address sourceCaller,\n        bool whitelisted\n    ) external override onlyOwner {\n        whitelistedCallers[sourceChain][sourceCaller] = whitelisted;\n        emit WhitelistedProposalCallerSet(sourceChain, sourceCaller, whitelisted);\n    }\n\n    /**\n     * @dev Set the proposal sender whitelist status\n     * @param sourceChain The source chain\n     * @param sourceSender The source sender\n     * @param whitelisted The whitelist status\n     */\n    function setWhitelistedProposalSender(\n        string calldata sourceChain,\n        address sourceSender,\n        bool whitelisted\n    ) external override onlyOwner {\n        whitelistedSenders[sourceChain][sourceSender] = whitelisted;\n        emit WhitelistedProposalSenderSet(sourceChain, sourceSender, whitelisted);\n    }\n\n    /**\n     * @dev A callback function that is called before the proposal is executed.\n     * This function can be used to handle the payload before the proposal is executed.\n     * @param sourceChain The source chain from where the proposal was sent.\n     * @param sourceAddress The source address that sent the proposal. The source address should be the `InterchainProposalSender` contract address at the source chain.\n     * @param payload The payload. It is ABI encoded of the caller and calls.\n     * Where:\n     * - `caller` is the address that calls the `InterchainProposalSender` at the source chain.\n     * - `calls` is the array of `InterchainCalls.Call` to execute. Each call contains the target, value, calldata.\n     */\n    function _beforeProposalExecuted(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) internal virtual {\n        // You can add your own logic here to handle the payload before the proposal is executed.\n    }\n\n    /**\n     * @dev A callback function that is called after the proposal is executed.\n     * This function emits an event containing the hash of the payload to signify successful execution.\n     * @param payload The payload. It is ABI encoded of the caller and calls.\n     * Where:\n     * - `caller` is the address that calls the `InterchainProposalSender` at the source chain.\n     * - `calls` is the array of `InterchainCalls.Call` to execute. Each call contains the target, value, signature and data.\n     */\n    function _onProposalExecuted(\n        string calldata, /* sourceChain */\n        string calldata, /* sourceAddress */\n        address, /* caller */\n        bytes calldata payload\n    ) internal virtual {\n        // You can add your own logic here to handle the payload after the proposal is executed.\n    }\n\n    /**\n     * @dev A callback function that is called when the execution of a target contract within a proposal fails.\n     * This function will revert the transaction providing the failure reason if present in the failure data.\n     * @param result The return data from the failed call to the target contract.\n     */\n    function _onTargetExecutionFailed(\n        InterchainCalls.Call memory, /* call */\n        bytes memory result\n    ) internal virtual {\n        // You can add your own logic here to handle the failure of the target contract execution. The code below is just an example.\n        if (result.length > 0) {\n            // The failure data is a revert reason string.\n            assembly {\n                revert(add(32, result), mload(result))\n            }\n        } else {\n            // There is no failure data, just revert with no reason.\n            revert ProposalExecuteFailed();\n        }\n    }\n\n    /**\n     * @dev Called after a target is successfully executed. The derived contract should implement this function.\n     * This function should do some post-execution work, such as emitting events.\n     * @param call The call that has been executed.\n     * @param result The result of the call.\n     */\n    function _onTargetExecuted(InterchainCalls.Call memory call, bytes memory result) internal virtual {\n        // You can add your own logic here to handle the success of each target contract execution.\n    }\n}"
    }
  ]
}