{
  "Title": "H-2: The calculation of ````totalUSDborrowed```` in ````openLoan()```` is not correct",
  "Content": "# Issue H-2: The calculation of ````totalUSDborrowed```` in ````openLoan()```` is not correct \n\nSource: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/85 \n\n## Found by \nclems4ever, cccz, CodingNameKiki, HollaDieWaldfee, Jeiwan, caventa, libratus, KingNFT\n\n## Summary\nThe ````openLoan()```` function  wrongly use ````isoUSDLoaned```` to calculate ````totalUSDborrowed````. Attacker can exploit it to bypass security check and loan isoUSD with no enough collateral.\n\n## Vulnerability Detail\nvulnerability point\n```solidity\nfunction openLoan(\n    // ...\n    ) external override whenNotPaused \n    {\n    //...\n    uint256 colInUSD = priceCollateralToUSD(currencyKey, _colAmount\n                        + collateralPosted[_collateralAddress][msg.sender]);\n    uint256 totalUSDborrowed = _USDborrowed \n        +  (isoUSDLoaned[_collateralAddress][msg.sender] * virtualPrice)/LOAN_SCALE;\n        // @audit should be isoUSDLoanAndInterest[_collateralAddress][msg.sender]\n    require(totalUSDborrowed >= ONE_HUNDRED_DOLLARS, \"Loan Requested too small\");\n    uint256 borrowMargin = (totalUSDborrowed * minOpeningMargin) / LOAN_SCALE;\n    require(colInUSD >= borrowMargin, \"Minimum margin not met!\");\n\n    // ...\n}\n```\nAttack example:\n<1>Attacker normally loans and produces 10000 isoUSD interest\n<2>Attacker repays principle but left interest\n<3>Attacker open a new 10000 isoUSD loan without providing collateral\n## Impact\nAttacker can loan isoUSD with no enough collateral.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/Vault_Synths.sol#L120\n\n## Tool used\n\nManual Review\n\n## Recommendation\nSee Vulnerability Detail\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor confirmed, duplicate of issue #68 \n\n**kree-dotcom**\n\nFixed https://github.com/kree-dotcom/isomorph/commit/3d77c9f706a52eb6312abc711a007ea8431f749b\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/22",
  "Code": [
    {
      "filename": "contracts/Isomorph/contracts/Vault_Synths.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Vault_Synths.sol for isomorph.loans\n// Bug bounties available\n\npragma solidity =0.8.9; \npragma abicoder v2;\n\n// External Synthetix interfaces\nimport \"./helper/interfaces/ISynthetix.sol\";\nimport \"./helper/interfaces/IExchangeRates.sol\";\nimport \"./helper/interfaces/ISystemStatus.sol\";\n\n//Vault Base for common functions\nimport \"./Vault_Base_ERC20.sol\";\n\n\ncontract Vault_Synths is Vault_Base_ERC20 {\n    \n    //Constants, private to reduce code size\n    bytes32 private constant SUSD_CODE = \"sUSD\"; \n    uint256 private constant ONE_HUNDRED_DOLLARS = 100 ether;\n    \n    //Optimism Mainnet addresses\n    \n    address public constant EXCHANGE_RATES = 0x22602469d704BfFb0936c7A7cfcD18f7aA269375;\n    address public constant PROXY_ERC20 = 0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4;\n    address public constant SUSD_ADDR = 0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9;\n    address public constant SYSTEM_STATUS = 0xE8c41bE1A167314ABAF2423b72Bf8da826943FFD;\n    \n    IExchangeRates private synthetixExchangeRates = IExchangeRates(EXCHANGE_RATES);\n    ISystemStatus private synthetixSystemStatus = ISystemStatus(SYSTEM_STATUS);\n   \n    \n    \n    constructor(\n        address _isoUSD, //isoUSD address\n        address _treasury, //treasury address\n        address _collateralBook //collateral structure book address\n        ){\n        require(_isoUSD != address(0), \"Zero Address used isoUSD\");\n        require(_treasury != address(0), \"Zero Address used Treasury\");\n        require(_collateralBook != address(0), \"Zero Address used Collateral\");\n        isoUSD = IisoUSDToken(_isoUSD);\n        treasury = _treasury;\n        collateralBook = ICollateralBook(_collateralBook);\n        _setupRole(ADMIN_ROLE, msg.sender);\n        _setupRole(PAUSER_ROLE, msg.sender);\n       \n    } \n\n\n    /**\n        Internal helper and check functions\n     */\n\n    /// @dev process for Synthetix assets\n    /// @dev leverages synthetix system to verify that the collateral in question is currently trading\n    /// @dev this prevents people frontrunning closed weekend markets for expected price crashes etc\n    /// @notice this call verifies Synthetix system, exchange and the synths in question are all available.\n    /// @notice if any of them aren't the function will revert.\n    /// @param _currencyKey the code used by synthetix to identify different synths, linked in collateral structure to collateral address\n    function _checkIfCollateralIsActive(bytes32 _currencyKey) internal view override {\n             synthetixSystemStatus.requireExchangeBetweenSynthsAllowed(_currencyKey, SUSD_CODE);\n         \n    }\n\n    /**\n        Public functions \n    */\n\n\n    //isoUSD is assumed to be valued at $1 by all of the system to avoid oracle attacks. \n    /// @param _currencyKey code used by Synthetix to identify each collateral/synth\n    /// @param _amount quantity of collateral to price into sUSD\n    /// @return returns the value of the given synth in sUSD which is assumed to be pegged at $1.\n    function priceCollateralToUSD(bytes32 _currencyKey, uint256 _amount) public view override returns(uint256){\n        //As it is a synth use synthetix for pricing\n        return (synthetixExchangeRates.effectiveValue(_currencyKey, _amount, SUSD_CODE));      \n    }\n\n    /**\n        External user loan interaction functions\n     */\n\n\n     /**\n      * @notice Only Vaults can mint isoUSD.\n      * @dev Mints 'USDborrowed' amount of isoUSD to vault and transfers to msg.sender and emits transfer event.\n      * @param _collateralAddress address of collateral token being used.\n      * @param _colAmount amount of collateral tokens being used.\n      * @param _USDborrowed amount of isoUSD to be minted, it is then split into the amount sent and the opening fee.\n     **/\n    function openLoan(\n        address _collateralAddress,\n        uint256 _colAmount,\n        uint256 _USDborrowed\n        ) external override whenNotPaused \n        {\n        _collateralExists(_collateralAddress);\n        IERC20 collateral = IERC20(_collateralAddress);\n        require(collateral.balanceOf(msg.sender) >= _colAmount, \"User lacks collateral quantity!\");\n        //make sure virtual price is related to current time before fetching collateral details\n        //slither-disable-next-line reentrancy-vulnerabilities-1\n        _updateVirtualPrice(block.timestamp, _collateralAddress);  \n        \n        (   \n            bytes32 currencyKey,\n            uint256 minOpeningMargin,\n            ,\n            ,\n            ,\n            uint256 virtualPrice,\n            \n        ) = _getCollateral(_collateralAddress);\n        //check for frozen or paused collateral\n        _checkIfCollateralIsActive(currencyKey);\n\n        //make sure the total isoUSD borrowed doesn't exceed the opening borrow margin ratio\n        uint256 colInUSD = priceCollateralToUSD(currencyKey, _colAmount + collateralPosted[_collateralAddress][msg.sender]);\n        uint256 totalUSDborrowed = _USDborrowed +  (isoUSDLoaned[_collateralAddress][msg.sender] * virtualPrice)/LOAN_SCALE;\n        require(totalUSDborrowed >= ONE_HUNDRED_DOLLARS, \"Loan Requested too small\"); \n        uint256 borrowMargin = (totalUSDborrowed * minOpeningMargin) / LOAN_SCALE;\n        require(colInUSD >= borrowMargin, \"Minimum margin not met!\");\n\n        //update mappings with new loan amounts\n        collateralPosted[_collateralAddress][msg.sender] = collateralPosted[_collateralAddress][msg.sender] + _colAmount;\n        isoUSDLoaned[_collateralAddress][msg.sender] = isoUSDLoaned[_collateralAddress][msg.sender] + _USDborrowed;\n        isoUSDLoanAndInterest[_collateralAddress][msg.sender] = isoUSDLoanAndInterest[_collateralAddress][msg.sender] + ((_USDborrowed * LOAN_SCALE) / virtualPrice);\n        \n        emit OpenOrIncreaseLoan(msg.sender, _USDborrowed, currencyKey, _colAmount);\n\n        //Now all effects are handled, transfer the assets so we follow CEI pattern\n        _increaseCollateral(collateral, _colAmount);\n        _increaseLoan(_USDborrowed);\n        \n        \n    }\n\n\n    /**\n      * @dev Increases collateral supplied against an existing loan. \n      * @notice Checks adding the collateral will keep the user above liquidation, \n      * @notice this debatable check isn't technically needed but feels fairer to end users.\n      * @param _collateralAddress address of collateral token being used.\n      * @param _colAmount amount of collateral tokens being used.\n     **/\n    function increaseCollateralAmount(\n        address _collateralAddress,\n        uint256 _colAmount\n        ) external override whenNotPaused \n        {\n        _collateralExists(_collateralAddress);\n        require(collateralPosted[_collateralAddress][msg.sender] > 0, \"No existing collateral!\"); //feels like semantic overloading and also problematic for dust after a loan is 'closed'\n        require(_colAmount > 0 , \"Zero amount\"); //Not strictly needed, prevents event spamming though\n        //make sure virtual price is related to current time before fetching collateral details\n        //slither-disable-next-line reentrancy-vulnerabilities-1\n        _updateVirtualPrice(block.timestamp, _collateralAddress);\n        IERC20 collateral = IERC20(_collateralAddress);\n        require(collateral.balanceOf(msg.sender) >= _colAmount, \"User lacks collateral amount\");\n        (   \n            bytes32 currencyKey,\n            ,\n            uint256 liquidatableMargin,\n            ,\n            ,\n            uint256 virtualPrice,\n            \n        ) = _getCollateral(_collateralAddress);\n        //check for frozen or paused collateral\n        _checkIfCollateralIsActive(currencyKey);\n        //debatable check begins here \n        uint256 totalCollat = collateralPosted[_collateralAddress][msg.sender] + _colAmount;\n        uint256 colInUSD = priceCollateralToUSD(currencyKey, totalCollat);\n        uint256 USDborrowed = (isoUSDLoanAndInterest[_collateralAddress][msg.sender] * virtualPrice) / LOAN_SCALE;\n        uint256 borrowMargin = (USDborrowed * liquidatableMargin) / LOAN_SCALE;\n        require(colInUSD >= borrowMargin, \"Liquidation margin not met!\");\n        //debatable check ends here\n        //update mapping with new collateral amount\n        collateralPosted[_collateralAddress][msg.sender] = collateralPosted[_collateralAddress][msg.sender] + _colAmount;\n        emit IncreaseCollateral(msg.sender, currencyKey, _colAmount);\n        //Now all effects are handled, transfer the collateral so we follow CEI pattern\n        _increaseCollateral(collateral, _colAmount);\n        \n    }\n\n\n     /**\n      * @notice Only Vault can destroy isoUSD.\n      * @dev destroys USDreturned of isoUSD held by caller, returns user collateral, close debt \n      * @dev if debt remains, checks minimum collateral ratio is upheld \n      * @dev if cost of a transaction can be <$0.01 YOU MUST UPDATE TENTH_OF_CENT check otherwise users can open microloans and close, withdrawing collateral without repaying. \n      * @param _collateralAddress address of collateral token being used.\n      * @param _collateralToUser amount of collateral tokens being returned to user.\n      * @param _USDToVault amount of isoUSD to be burnt.\n     **/\n\n    function closeLoan(\n        address _collateralAddress,\n        uint256 _collateralToUser,\n        uint256 _USDToVault\n        ) external override whenNotPaused \n        {\n        _collateralExists(_collateralAddress);\n        _closeLoanChecks(_collateralAddress, _collateralToUser, _USDToVault);\n        //make sure virtual price is related to current time before fetching collateral details\n        //slither-disable-next-line reentrancy-vulnerabilities-1\n        _updateVirtualPrice(block.timestamp, _collateralAddress);\n        (   \n            bytes32 currencyKey,\n            uint256 minOpeningMargin,\n            ,\n            ,\n            ,\n            uint256 virtualPrice,\n            \n        ) = _getCollateral(_collateralAddress);\n        //check for frozen or paused collateral\n        _checkIfCollateralIsActive(currencyKey);\n        uint256 isoUSDdebt = (isoUSDLoanAndInterest[_collateralAddress][msg.sender] * virtualPrice) / LOAN_SCALE;\n        require( isoUSDdebt >= _USDToVault, \"Trying to return more isoUSD than borrowed!\");\n        uint256 outstandingisoUSD = isoUSDdebt - _USDToVault;\n        if(outstandingisoUSD >= TENTH_OF_CENT){ //ignore leftover debts less than $0.001\n            uint256 collateralLeft = collateralPosted[_collateralAddress][msg.sender] - _collateralToUser;\n            uint256 colInUSD = priceCollateralToUSD(currencyKey, collateralLeft); \n            uint256 borrowMargin = (outstandingisoUSD * minOpeningMargin) / LOAN_SCALE;\n            require(colInUSD > borrowMargin , \"Remaining debt fails to meet minimum margin!\");\n        }\n        \n        //record paying off loan principle before interest\n        //slither-disable-next-line uninitialized-local-variables\n        uint256 interestPaid;\n        uint256 loanPrinciple = isoUSDLoaned[_collateralAddress][msg.sender];\n        if( loanPrinciple >= _USDToVault){\n            //pay off loan principle first\n            isoUSDLoaned[_collateralAddress][msg.sender] = loanPrinciple - _USDToVault;\n        }\n        else{\n            interestPaid = _USDToVault - loanPrinciple;\n            //loan principle is fully repaid so record this.\n            isoUSDLoaned[_collateralAddress][msg.sender] = 0;\n        }\n        //update mappings with reduced amounts\n        isoUSDLoanAndInterest[_collateralAddress][msg.sender] = isoUSDLoanAndInterest[_collateralAddress][msg.sender] - ((_USDToVault * LOAN_SCALE) / virtualPrice);\n        collateralPosted[_collateralAddress][msg.sender] = collateralPosted[_collateralAddress][msg.sender] - _collateralToUser;\n        emit ClosedLoan(msg.sender, _USDToVault, currencyKey, _collateralToUser);\n        //Now all effects are handled, transfer the assets so we follow CEI pattern\n        _decreaseLoan(_collateralAddress, _collateralToUser, _USDToVault, interestPaid);\n        }\n    \n    \n\n    /**\n        Liquidation functions\n     \n    */\n\n     /**\n      * @notice Anyone can liquidate any other undercollateralised loan.\n      * @notice The max acceptable liquidation quantity is calculated using viewLiquidatableAmount\n      * @dev checks that partial liquidation would be insufficient to recollaterize the loanHolder's debt \n      * @dev caller is paid 1e18 -`LIQUIDATION_RETURN` as reward for calling the liquidation.\n      * @dev In the event of full liquidation being insufficient the leftover debt is written off and an event tracking this is emitted.\n      * @param _loanHolder address of loanee being liquidated.\n      * @param _collateralAddress address of collateral token being used.\n     **/\n        \n        function callLiquidation(\n            address _loanHolder,\n            address _collateralAddress\n        ) external override whenNotPaused  \n        {   \n            _collateralExists(_collateralAddress);\n            require(_loanHolder != address(0), \"Zero address used\"); \n             //make sure virtual price is related to current time before fetching collateral details\n            //slither-disable-next-line reentrancy-vulnerabilities-1\n            _updateVirtualPrice(block.timestamp, _collateralAddress);\n            (\n                bytes32 currencyKey,\n                ,\n                uint256 liquidatableMargin,\n                ,\n                ,\n                uint256 virtualPrice,\n                \n            ) = _getCollateral(_collateralAddress);\n            //check for frozen or paused collateral\n            _checkIfCollateralIsActive(currencyKey);\n            //check how much of the specified loan should be closed\n            uint256 isoUSDBorrowed = (isoUSDLoanAndInterest[_collateralAddress][_loanHolder] * virtualPrice) / LOAN_SCALE;\n            uint256 totalUserCollateral = collateralPosted[_collateralAddress][_loanHolder];\n            uint256 currentPrice = priceCollateralToUSD(currencyKey, LOAN_SCALE); //assumes LOAN_SCALE = 1 ether, i.e. one unit of collateral!\n            uint256 liquidationAmount = viewLiquidatableAmount(totalUserCollateral, currentPrice, isoUSDBorrowed, liquidatableMargin);\n            require(liquidationAmount > 0 , \"Loan not liquidatable\");\n            //if complete liquidation falls short of recovering the position we settle for complete liquidation\n            if(liquidationAmount > totalUserCollateral){\n                liquidationAmount = totalUserCollateral;\n            }\n            uint256 isoUSDreturning = liquidationAmount*currentPrice*LIQUIDATION_RETURN/LOAN_SCALE/LOAN_SCALE;  \n            \n            //if the liquidation is the entire loan we need to record more\n            if(totalUserCollateral == liquidationAmount){\n                //and some of the loan is not being repaid.\n                if(isoUSDBorrowed > isoUSDreturning){\n                    //if a user is being fully liquidated we will forgive any remaining debt and interest so it\n                    // doesn't roll over if they open a new loan of the same collateral.\n                    delete isoUSDLoanAndInterest[_collateralAddress][_loanHolder];\n                    emit BadDebtCleared(_loanHolder, msg.sender, isoUSDBorrowed - isoUSDreturning, currencyKey);\n                    \n                }\n            }\n            //finally we call an internal function that updates mappings\n            // burns the liquidator's isoUSD and transfers the collateral to the liquidator as payment\n            _liquidate(_loanHolder, _collateralAddress, liquidationAmount, isoUSDreturning, currencyKey, virtualPrice);\n            \n        } \n}"
    }
  ]
}