{
  "Title": "Zero values",
  "Content": "##### Description\nNo check for zero values at constructor for parameters `stakeToken` https://github.com/aave/incentives-proposal/blob/f6712e33db79210a7ae8106f7cfa1ce2adea8d69/contracts/incentives/StakedTokenIncentivesController.sol#L45 and `emissionManager` https://github.com/aave/incentives-proposal/blob/f6712e33db79210a7ae8106f7cfa1ce2adea8d69/contracts/incentives/DistributionManager.sol#L37\n##### Recommendation\nWe recommend to check for zero values",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/incentives/StakedTokenIncentivesController.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.5;\npragma experimental ABIEncoderV2;\n\nimport {SafeERC20} from '@aave/aave-stake/contracts/lib/SafeERC20.sol';\nimport {SafeMath} from '../lib/SafeMath.sol';\nimport {DistributionTypes} from '../lib/DistributionTypes.sol';\nimport {VersionedInitializable} from '@aave/aave-stake/contracts/utils/VersionedInitializable.sol';\nimport {DistributionManager} from './DistributionManager.sol';\nimport {IStakedTokenWithConfig} from '../interfaces/IStakedTokenWithConfig.sol';\nimport {IERC20} from '@aave/aave-stake/contracts/interfaces/IERC20.sol';\nimport {IScaledBalanceToken} from '../interfaces/IScaledBalanceToken.sol';\nimport {IAaveIncentivesController} from '../interfaces/IAaveIncentivesController.sol';\n\n/**\n * @title StakedTokenIncentivesController\n * @notice Distributor contract for rewards to the Aave protocol, using a staked token as rewards asset.\n * The contract stakes the rewards before redistributing them to the Aave protocol participants.\n * The reference staked token implementation is at https://github.com/aave/aave-stake-v2\n * @author Aave\n **/\ncontract StakedTokenIncentivesController is\n  IAaveIncentivesController,\n  VersionedInitializable,\n  DistributionManager\n{\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n  uint256 public constant REVISION = 2;\n\n  IStakedTokenWithConfig public immutable STAKE_TOKEN;\n\n  mapping(address => uint256) internal _usersUnclaimedRewards;\n\n  // this mapping allows whitelisted addresses to claim on behalf of others\n  // useful for contracts that hold tokens to be rewarded but don't have any native logic to claim Liquidity Mining rewards\n  mapping(address => address) internal _authorizedClaimers;\n\n  modifier onlyAuthorizedClaimers(address claimer, address user) {\n    require(_authorizedClaimers[user] == claimer, 'CLAIMER_UNAUTHORIZED');\n    _;\n  }\n\n  constructor(IStakedTokenWithConfig stakeToken, address emissionManager)\n    DistributionManager(emissionManager)\n  {\n    STAKE_TOKEN = stakeToken;\n  }\n\n  /**\n   * @dev Initialize IStakedTokenIncentivesController. Empty after REVISION 1, but maintains the expected interface.\n   **/\n  function initialize(address) external initializer {}\n\n  /// @inheritdoc IAaveIncentivesController\n  function configureAssets(address[] calldata assets, uint256[] calldata emissionsPerSecond)\n    external\n    override\n    onlyEmissionManager\n  {\n    require(assets.length == emissionsPerSecond.length, 'INVALID_CONFIGURATION');\n\n    DistributionTypes.AssetConfigInput[] memory assetsConfig =\n      new DistributionTypes.AssetConfigInput[](assets.length);\n\n    for (uint256 i = 0; i < assets.length; i++) {\n      assetsConfig[i].underlyingAsset = assets[i];\n      assetsConfig[i].emissionPerSecond = uint104(emissionsPerSecond[i]);\n\n      require(assetsConfig[i].emissionPerSecond == emissionsPerSecond[i], 'INVALID_CONFIGURATION');\n\n      assetsConfig[i].totalStaked = IScaledBalanceToken(assets[i]).scaledTotalSupply();\n    }\n    _configureAssets(assetsConfig);\n  }\n\n  /// @inheritdoc IAaveIncentivesController\n  function handleAction(\n    address user,\n    uint256 totalSupply,\n    uint256 userBalance\n  ) external override {\n    uint256 accruedRewards = _updateUserAssetInternal(user, msg.sender, userBalance, totalSupply);\n    if (accruedRewards != 0) {\n      _usersUnclaimedRewards[user] = _usersUnclaimedRewards[user].add(accruedRewards);\n      emit RewardsAccrued(user, accruedRewards);\n    }\n  }\n\n  /// @inheritdoc IAaveIncentivesController\n  function getRewardsBalance(address[] calldata assets, address user)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    uint256 unclaimedRewards = _usersUnclaimedRewards[user];\n\n    DistributionTypes.UserStakeInput[] memory userState =\n      new DistributionTypes.UserStakeInput[](assets.length);\n    for (uint256 i = 0; i < assets.length; i++) {\n      userState[i].underlyingAsset = assets[i];\n      (userState[i].stakedByUser, userState[i].totalStaked) = IScaledBalanceToken(assets[i])\n        .getScaledUserBalanceAndSupply(user);\n    }\n    unclaimedRewards = unclaimedRewards.add(_getUnclaimedRewards(user, userState));\n    return unclaimedRewards;\n  }\n\n  /// @inheritdoc IAaveIncentivesController\n  function claimRewards(\n    address[] calldata assets,\n    uint256 amount,\n    address to\n  ) external override returns (uint256) {\n    require(to != address(0), 'INVALID_TO_ADDRESS');\n    return _claimRewards(assets, amount, msg.sender, msg.sender, to);\n  }\n\n  /// @inheritdoc IAaveIncentivesController\n  function claimRewardsOnBehalf(\n    address[] calldata assets,\n    uint256 amount,\n    address user,\n    address to\n  ) external override onlyAuthorizedClaimers(msg.sender, user) returns (uint256) {\n    require(user != address(0), 'INVALID_USER_ADDRESS');\n    require(to != address(0), 'INVALID_TO_ADDRESS');\n    return _claimRewards(assets, amount, msg.sender, user, to);\n  }\n\n  /// @inheritdoc IAaveIncentivesController\n  function claimRewardsToSelf(address[] calldata assets, uint256 amount)\n    external\n    override\n    returns (uint256)\n  {\n    return _claimRewards(assets, amount, msg.sender, msg.sender, msg.sender);\n  }\n\n  /**\n   * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards.\n   * @param amount Amount of rewards to claim\n   * @param user Address to check and claim rewards\n   * @param to Address that will be receiving the rewards\n   * @return Rewards claimed\n   **/\n\n  /// @inheritdoc IAaveIncentivesController\n  function setClaimer(address user, address caller) external override onlyEmissionManager {\n    _authorizedClaimers[user] = caller;\n    emit ClaimerSet(user, caller);\n  }\n\n  /// @inheritdoc IAaveIncentivesController\n  function getClaimer(address user) external view override returns (address) {\n    return _authorizedClaimers[user];\n  }\n\n  /// @inheritdoc IAaveIncentivesController\n  function getUserUnclaimedRewards(address _user) external view override returns (uint256) {\n    return _usersUnclaimedRewards[_user];\n  }\n\n  /// @inheritdoc IAaveIncentivesController\n  function REWARD_TOKEN() external view override returns (address) {\n    return address(STAKE_TOKEN);\n  }\n\n  /**\n   * @dev returns the revision of the implementation contract\n   */\n  function getRevision() internal pure override returns (uint256) {\n    return REVISION;\n  }\n\n  /**\n   * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards.\n   * @param amount Amount of rewards to claim\n   * @param user Address to check and claim rewards\n   * @param to Address that will be receiving the rewards\n   * @return Rewards claimed\n   **/\n  function _claimRewards(\n    address[] calldata assets,\n    uint256 amount,\n    address claimer,\n    address user,\n    address to\n  ) internal returns (uint256) {\n    if (amount == 0) {\n      return 0;\n    }\n    uint256 unclaimedRewards = _usersUnclaimedRewards[user];\n\n    DistributionTypes.UserStakeInput[] memory userState =\n      new DistributionTypes.UserStakeInput[](assets.length);\n    for (uint256 i = 0; i < assets.length; i++) {\n      userState[i].underlyingAsset = assets[i];\n      (userState[i].stakedByUser, userState[i].totalStaked) = IScaledBalanceToken(assets[i])\n        .getScaledUserBalanceAndSupply(user);\n    }\n\n    uint256 accruedRewards = _claimRewards(user, userState);\n    if (accruedRewards != 0) {\n      unclaimedRewards = unclaimedRewards.add(accruedRewards);\n      emit RewardsAccrued(user, accruedRewards);\n    }\n\n    if (unclaimedRewards == 0) {\n      return 0;\n    }\n\n    uint256 amountToClaim = amount > unclaimedRewards ? unclaimedRewards : amount;\n    _usersUnclaimedRewards[user] = unclaimedRewards - amountToClaim; // Safe due to the previous line\n\n    STAKE_TOKEN.stake(to, amountToClaim);\n    emit RewardsClaimed(user, to, claimer, amountToClaim);\n\n    return amountToClaim;\n  }\n}"
    }
  ]
}