{
  "Title": "[Gâ€‘01] Avoid contract existence checks by using low level calls",
  "Content": "\nPrior to 0.8.10, the compiler inserted extra code, including `EXTCODESIZE` (100 gas), to check for contract existence for external function calls. In more recent solidity versions, the compiler will not insert these checks if the external call has a return value. Similar behavior can be achieved in earlier versions by using low-level calls, since low level calls never check for contract existence.\n\nThere are 168 instances of this issue:\n\n<details>\n\n```solidity\nFile: /src/erc-20/ERC20Gauges.sol\n208    IBaseV2Gauge(gauge).accrueBribes(user);\n```\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/erc-20/ERC20Gauges.sol#L208\n\n```solidity\nFile: /src/erc-4626/UlyssesERC4626.sol\n27   if (ERC20(_asset).decimals() != 18) revert InvalidAssetDecimals();\n```\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/erc-4626/UlyssesERC4626.sol#L27\n\n\n```solidity\nFile: /src/gauges/factories/UniswapV3GaugeFactory.sol\n100   UniswapV3Gauge(gauge).setMinimumWidth(minimumWidth);\n```\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/factories/UniswapV3GaugeFactory.sol#L100\n\n```solidity\nFile: /src/gauges/UniswapV3Gauge.sol\n54    IUniswapV3Staker(uniswapV3Staker).createIncentiveFromGauge(amount);\n```\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/UniswapV3Gauge.sol#L54\n\n\n```solidity\nFile: /src/hermes/minters/BaseV2Minter.sol\n61    underlying = address(ERC4626(_vault).asset());\n\n109   return HERMES(underlying).totalSupply() - vault.totalAssets();\n\n119   return (vault.totalAssets() * _minted) / HERMES(underlying).totalSupply();\n\n140   HERMES(underlying).mint(address(this), _required - _balanceOf);\n```\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/hermes/minters/BaseV2Minter.sol#L61\n\n```solidity\nFile: /src/maia/tokens/ERC4626PartnerManager.sol\n\n192   if (oldPartnerVault != address(0)) IBaseVault(oldPartnerVault).clearAll();\n\n206   if (newPartnerVault != address(0)) IBaseVault(newPartnerVault).applyAll();\n\n244   ERC20MultiVotes(partnerGovernance).mint(address(this), amount * bHermesRate);\n```\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/maia/tokens/ERC4626PartnerManager.sol#L192\n\n```solidity\nFile: /src/rewards/FlywheelCoreInstant.sol\n41    return IFlywheelInstantRewards(flywheelRewards).getAccruedRewards();\n```\nhttps://github.com/code-423n4/2023-05-maia/tree/main/src/rewards/FlywheelCoreInstant.sol#L41\n\n\n```solidity\nFile: /src/rewards/FlywheelCoreStrategy.sol\n40   return IFlywheelAcummulatedRewards(flywheelRewards).getAccruedRewards(strategy);\n```\nhttps://github.com/code-423n4/2023-05-maia/tree/main/src/rewards/FlywheelCoreStrategy.sol#L40\n\n\n```solidity\nFile: /src/talos/TalosStrategyStaked.sol\n82    _boostAggregator.setOwnRewardsDepot(address(FlywheelInstantRewards(_flywheel.flywheelRewards()).rewardsDepot()));\n```\nhttps://github.com/code-423n4/2023-05-maia/tree/main/src/talos/TalosStrategyStaked.sol#L82\n\n```solidity\nFile: /src/ulysses-omnichain/factories/ArbitrumBranchBridgeAgentFactory.sol\n104   IPort(localPortAddress).addBridgeAgent(newBridgeAgent);\n```\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/factories/ArbitrumBranchBridgeAgentFactory.sol#L104\n\n```solidity\nFile: /src/ulysses-omnichain/factories/BranchBridgeAgentFactory.sol\n99    IPort(localPortAddress).addBridgeAgent(newCoreBridgeAgent);\n\n139   IPort(localPortAddress).addBridgeAgent(newBridgeAgent);\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/factories/BranchBridgeAgentFactory.sol#L99\n\n```solidity\nFile: /src/ulysses-omnichain/factories/RootBridgeAgentFactory.sol\n62    local`AnyCall`ExecutorAddress = IAnycallProxy(local`AnyCall`Address).executor();\n\n88    IRootPort(rootPortAddress).addBridgeAgent(msg.sender, newBridgeAgent);\n```\n\nhttps://github.com/code-423n4/2023-05-maia/tree/main/src/ulysses-omnichain/factories/RootBridgeAgentFactory.sol#L62\n\n```solidity\nFile: /src/ulysses-omnichain/ArbitrumBranchBridgeAgent.sol\n103   IArbPort(localPortAddress).depositToPort(\n            msg.sender, msg.sender, underlyingAddress, _normalizeDecimals(amount, ERC20(underlyingAddress).decimals())\n        );\n\n115   IArbPort(localPortAddress).withdrawFromPort(msg.sender, msg.sender, localAddress, amount);\n\n143   IRootBridgeAgent(rootBridgeAgentAddress).anyExecute(_callData);\n```\n\nhttps://github.com/code-423n4/2023-05-maia/tree/main/src/ulysses-omnichain/ArbitrumBranchBridgeAgent.sol#L103\n\n```solidity\nFile: /src/ulysses-omnichain/ArbitrumBranchPort.sol\n49    address globalToken = IRootPort(rootPortAddress).getLocalTokenFromUnder(_underlyingAddress, localChainId);\n\n54    IRootPort(rootPortAddress).mintToLocalBranch(_recipient, globalToken, _deposit);\n\n62    if (!IRootPort(rootPortAddress).isGlobalToken(_globalAddress, localChainId)) {\n\n66     address underlyingAddress = IRootPort(rootPortAddress).getUnderlyingTokenFromLocal(_globalAddress, localChainId);\n\n70   IRootPort(rootPortAddress).burnFromLocalBranch(_depositor, _globalAddress, _deposit);\n\n72   underlyingAddress.safeTransfer(_recipient, _denormalizeDecimals(_deposit, ERC20(underlyingAddress).decimals()));\n\n82   _recipient, _denormalizeDecimals(_deposit, ERC20(_underlyingAddress).decimals())\n\n92    IRootPort(rootPortAddress).bridgeToLocalBranchFromRoot(_recipient, _localAddress, _amount);\n\n102   IRootPort(rootPortAddress).bridgeToLocalBranchFromRoot(_recipient, _localAddresses[i], _amounts[i]);\n\n120   _depositor, address(this), _denormalizeDecimals(_deposit, ERC20(_underlyingAddress).decimals())\n\n124   IRootPort(rootPortAddress).bridgeToRootFromLocalBranch(_depositor, _localAddress, _amount - _deposit);\n\n141   _denormalizeDecimals(_deposits[i], ERC20(_underlyingAddresses[i]).decimals())\n\n145   IRootPort(rootPortAddress).bridgeToRootFromLocalBranch(\n                    _depositor, _localAddresses[i], _amounts[i] - _deposits[i]\n                );\n```\n\nhttps://github.com/code-423n4/2023-05-maia/tree/main/src/ulysses-omnichain/ArbitrumBranchPort.sol#L49\n\n```solidity\nFile: /src/ulysses-omnichain/ArbitrumCoreBranchRouter.sol\n49  string memory name = ERC20(_underlyingAddress).name();\n\n50  string memory symbol = ERC20(_underlyingAddress).symbol();\n\n59   IBridgeAgent(localBridgeAgentAddress).performCallOut(msg.sender, packedData, 0, 0);\n\n83    if (!IPort(localPortAddress).isBridgeAgentFactory(_branchBridgeAgentFactory)) {\n\n88   address newBridgeAgent = IBridgeAgentFactory(_branchBridgeAgentFactory).createBridgeAgent(\n            _newBranchRouter, _rootBridgeAgent, _rootBridgeAgentFactory\n        );    \n\n93   if (!IPort(localPortAddress).isBridgeAgent(newBridgeAgent)) {\n\n104  IBridgeAgent(localBridgeAgentAddress).performSystemCallOut(address(this), packedData, 0, 0);    \n```\n\nhttps://github.com/code-423n4/2023-05-maia/tree/main/src/ulysses-omnichain/ArbitrumCoreBranchRouter.sol#L49\n\n```solidity\nFile: /src/ulysses-omnichain/BaseBranchRouter.sol\n40    bridgeAgentExecutorAddress = IBridgeAgent(localBridgeAgentAddress).bridgeAgentExecutorAddress();\n\n50    return IBridgeAgent(localBridgeAgentAddress).getDepositEntry(_depositNonce);\n\n59    IBridgeAgent(localBridgeAgentAddress).performCallOut{value: msg.value}(\n            msg.sender, params, 0, remoteExecutionGas\n        );\n70     IBridgeAgent(localBridgeAgentAddress).performCallOutAndBridge{value: msg.value}(\n            msg.sender, params, dParams, 0, remoteExecutionGas\n        );\n81         IBridgeAgent(localBridgeAgentAddress).performCallOutAndBridgeMultiple{value: msg.value}(\n            msg.sender, params, dParams, 0, remoteExecutionGas\n        );\n\n88      IBridgeAgent(localBridgeAgentAddress).retrySettlement{value: msg.value}(_settlementNonce, _gasToBoostSettlement);\n\n93    IBridgeAgent(localBridgeAgentAddress).redeemDeposit(_depositNonce);\n```\n\nhttps://github.com/code-423n4/2023-05-maia/tree/main/src/ulysses-omnichain/BaseBranchRouter.sol#L40\n\n```solidity\nFile: /src/ulysses-omnichain/BranchBridgeAgent.sol\n252   _normalizeDecimals(_dParams.deposit, ERC20(_dParams.token).decimals()),\n\n284   _deposits[i] = _normalizeDecimals(_dParams.deposits[i], ERC20(_dParams.tokens[i]).decimals());\n\n342    getDeposit[_depositNonce].deposits[0], ERC20(getDeposit[_depositNonce].tokens[0]).decimals()\n\n357     getDeposit[_depositNonce].deposits[0], ERC20(getDeposit[_depositNonce].tokens[0]).decimals()\n\n624      IPort(localPortAddress).bridgeIn(_recipient, _hTokens[i], _amounts[i] - _deposits[i]);\n\n628    IPort(localPortAddress).withdraw(_recipient, _tokens[i], _deposits[i]);\n\n687    _normalizeDecimals(_dParams.deposit, ERC20(_dParams.token).decimals()),\n\n720    deposits[i] = _normalizeDecimals(_dParams.deposits[i], ERC20(_dParams.tokens[i]).decimals());\n\n866    IPort(localPortAddress).bridgeOut(_user, _hToken, _token, _amount, _deposit);\n\n912    IPort(localPortAddress).bridgeOutMultiple(_user, _hTokens, _tokens, _amounts, _deposits);\n\n980     IPort(localPortAddress).bridgeIn(_recipient, _hToken, _amount - _deposit);\n\n984    IPort(localPortAddress).withdraw(_recipient, _token, _deposit);\n\n1008    IAnycallProxy(local`AnyCall`Address).anyCall(\n            rootBridgeAgentAddress, _calldata, rootChainId, AnycallFlags.FLAG_ALLOW_FALLBACK, \"\"\n        );\n\n1078     IPort(localPortAddress).withdraw(address(this), address(wrappedNativeToken), minExecCost);\n\n1103   IPort(localPortAddress).withdraw(address(this), address(wrappedNativeToken), gasAmount);\n\n1110   (from, fromChainId,) = IAnycallExecutor(local`AnyCall`ExecutorAddress).context();\n\n1154   try BranchBridgeAgentExecutor(bridgeAgentExecutorAddress).executeNoSettlement(localRouterAddress, data)\n\n1177    try BranchBridgeAgentExecutor(bridgeAgentExecutorAddress).executeWithSettlement(\n\n1201     try BranchBridgeAgentExecutor(bridgeAgentExecutorAddress).executeWithSettlementMultiple(\n\n1324    IAnycallConfig anycallConfig = IAnycallConfig(IAnycallProxy(local`AnyCall`Address).config());\n\n1388    (address from,,) = IAnycallExecutor(local`AnyCall`ExecutorAddress).context();\n\n76    (success, result) = IRouter(_router).anyExecuteNoSettlement(_data[25:_data.length - PARAMS_GAS_OUT]);\n```\n\nhttps://github.com/code-423n4/2023-05-maia/tree/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L252\n\n```solidity\nFile: /src/ulysses-omnichain/BranchBridgeAgentExecutor.sol\n104   BranchBridgeAgent(payable(msg.sender)).clearToken(\n            sParams.recipient, sParams.hToken, sParams.token, sParams.amount, sParams.deposit\n        );\n\n110    (success, result) = IRouter(_router).anyExecuteSettlement(_data[129:_data.length - PARAMS_GAS_OUT], sParams);\n\n147   (success, result) = IRouter(_router).anyExecuteSettlementMultiple(    \n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgentExecutor.sol#L104\n\n```solidity\nFile: /src/ulysses-omnichain/BranchPort.sol\n127   uint256 currBalance = ERC20(_token).balanceOf(address(this));\n\n138   uint256 currBalance = ERC20(_token).balanceOf(address(this));\n\n180   IPortStrategy(_strategy).withdraw(address(this), _token, amountToWithdraw);\n\n212    _recipient, _denormalizeDecimals(_deposit, ERC20(_underlyingAddress).decimals())\n\n222   ERC20hTokenBranch(_localAddress).mint(_recipient, _amount);\n\n232    ERC20hTokenBranch(_localAddresses[i]).mint(_recipient, _amounts[i]);\n\n250   ERC20hTokenBranch(_localAddress).burn(_amount - _deposit);\n\n254  _depositor, address(this), _denormalizeDecimals(_deposit, ERC20(_underlyingAddress).decimals())\n\n272  _denormalizeDecimals(_deposits[i], ERC20(_underlyingAddresses[i]).decimals())\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchPort.sol#L127\n\n```solidity\nFile: /src/ulysses-omnichain/CoreBranchRouter.sol\n54   IBridgeAgent(localBridgeAgentAddress).performCallOut{value: msg.value}(\n            msg.sender, packedData, 0, _remoteExecutionGas\n        );\n\n65    string memory name = ERC20(_underlyingAddress).name();\n\n66    string memory symbol = ERC20(_underlyingAddress).symbol();   \n\n69    ERC20hToken newToken = ITokenFactory(hTokenFactoryAddress).createToken(name, symbol);\n\n78     IBridgeAgent(localBridgeAgentAddress).performCallOut{value: msg.value}(msg.sender, packedData, 0, 0);\n\n102    ERC20hToken newToken = ITokenFactory(hTokenFactoryAddress).createToken(_name, _symbol);\n\n111    IBridgeAgent(localBridgeAgentAddress).performSystemCallOut(address(this), packedData, _rootExecutionGas, 0);\n\n133    if (!IPort(localPortAddress).isBridgeAgentFactory(_branchBridgeAgentFactory)) {\n\n138     address newBridgeAgent = IBridgeAgentFactory(_branchBridgeAgentFactory).createBridgeAgent(\n            _newBranchRouter, _rootBridgeAgent, _rootBridgeAgentFactory\n        );\n\n143     if (!IPort(localPortAddress).isBridgeAgent(newBridgeAgent)) {\n            revert UnrecognizedBridgeAgent();\n        }\n\n154     IBridgeAgent(localBridgeAgentAddress).performSystemCallOut(address(this), packedData, _remoteExecutionGas, 0);\n\n164   if (!IPort(localPortAddress).isBridgeAgentFactory(_newBridgeAgentFactoryAddress)) {\n\n165   IPort(localPortAddress).addBridgeAgentFactory(_newBridgeAgentFactoryAddress);\n\n167   IPort(localPortAddress).toggleBridgeAgentFactory(_newBridgeAgentFactoryAddress);\n\n178     if (!IPort(localPortAddress).isBridgeAgent(_branchBridgeAgent)) revert UnrecognizedBridgeAgent();\n\n179   IPort(localPortAddress).toggleBridgeAgent(_branchBridgeAgent);\n\n190   if (!IPort(localPortAddress).isStrategyToken(_underlyingToken)) {\n\n191   IPort(localPortAddress).addStrategyToken(_underlyingToken, _minimumReservesRatio);\n\n193   IPort(localPortAddress).toggleStrategyToken(_underlyingToken);\n\n212   if (!IPort(localPortAddress).isPortStrategy(_portStrategy, _underlyingToken)) {\n\n214   IPort(localPortAddress).addPortStrategy(_portStrategy, _underlyingToken, _dailyManagementLimit);\n\n217    IPort(localPortAddress).updatePortStrategy(_portStrategy, _underlyingToken, _dailyManagementLimit);\n\n220   IPort(localPortAddress).togglePortStrategy(_portStrategy, _underlyingToken);\n```\n\nhttps://github.com/code-423n4/2023-05-maia/tree/main/src/ulysses-omnichain/CoreBranchRouter.sol#L54\n\n```solidity\nFile: /src/ulysses-omnichain/CoreRootRouter.sol\n65    bridgeAgentExecutorAddress = IBridgeAgent(_bridgeAgentAddress).bridgeAgentExecutorAddress();\n\n90    if (msg.sender != IPort(rootPortAddress).getBridgeAgentManager(_rootBridgeAgent)) {\n            revert UnauthorizedCallerNotManager();\n        }\n\n95    if (!IPort(rootPortAddress).isChainId(_toChain)) revert InvalidChainId();\n\n98     if (IBridgeAgent(_rootBridgeAgent).getBranchBridgeAgent(_toChain) != address(0)) revert InvalidChainId();\n\n101   if (!IBridgeAgent(_rootBridgeAgent).isBranchBridgeAgentAllowed(_toChain)) revert UnauthorizedChainId();\n\n104   address rootBridgeAgentFactory = IBridgeAgent(_rootBridgeAgent).factoryAddress();\n\n115   IBridgeAgent(bridgeAgentAddress).callOut{value: msg.value}(_gasReceiver, packedData, _toChain);\n\n128     IPort(rootPortAddress).syncBranchBridgeAgentWithRoot(_newBranchBridgeAgent, _rootBridgeAgent, _fromChain);\n    }\n\n148   if (!IPort(rootPortAddress).isGlobalAddress(_globalAddress)) {\n\n153   if (IPort(rootPortAddress).isGlobalToken(_globalAddress, _toChain)) {\n\n159    _globalAddress, ERC20(_globalAddress).name(), ERC20(_globalAddress).symbol(), _remoteExecutionGas\n\n166   IBridgeAgent(bridgeAgentAddress).callOut(_gasReceiver, packedData, _toChain);\n\n187    IPort(rootPortAddress).isGlobalAddress(_underlyingAddress)\n\n188      || IPort(rootPortAddress).isLocalToken(_underlyingAddress, _fromChain)\n\n189      || IPort(rootPortAddress).isUnderlyingToken(_underlyingAddress, _fromChain)\n\n193    address newToken = address(IFactory(hTokenFactoryAddress).createToken(_name, _symbol));\n\n196    IPort(rootPortAddress).setAddresses(\n            newToken, (_fromChain == rootChainId) ? newToken : _localAddress, _underlyingAddress, _fromChain\n        );\n\n210    if (IPort(rootPortAddress).isLocalToken(_localAddress, _toChain)) revert TokenAlreadyAdded();\n\n213    IPort(rootPortAddress).setLocalAddress(_globalAddress, _localAddress, _toChain);\n\n233    if (!IPort(rootPortAddress).isBridgeAgentFactory(_rootBridgeAgentFactory)) {\n\n244    IBridgeAgent(bridgeAgentAddress).callOut{value: msg.value}(_gasReceiver, packedData, _toChain);\n\n265      IBridgeAgent(bridgeAgentAddress).callOut{value: msg.value}(_gasReceiver, packedData, _toChain);\n\n288     IBridgeAgent(bridgeAgentAddress).callOut{value: msg.value}(_gasReceiver, packedData, _toChain);\n\n\n315     IBridgeAgent(bridgeAgentAddress).callOut{value: msg.value}(_gasReceiver, packedData, _toChain);\n```\n\nhttps://github.com/code-423n4/2023-05-maia/tree/main/src/ulysses-omnichain/CoreRootRouter.sol#L65\n\n```solidity\nFile: /src/ulysses-omnichain/MulticallRootRouter.sol\n78     bridgeAgentExecutorAddress = IBridgeAgent(_bridgeAgentAddress).bridgeAgentExecutorAddress();\n\n96    (blockNumber, returnData) = IMulticall(multicallAddress).aggregate(calls);\n\n120   ERC20hTokenRoot(outputToken).approve(bridgeAgentAddress, amountOut);\n\n123   IBridgeAgent(bridgeAgentAddress).callOutAndBridge{value: msg.value}(\n            owner, recipient, \"\", outputToken, amountOut, depositOut, toChain\n        );\n\n155   IBridgeAgent(bridgeAgentAddress).callOutAndBridgeMultiple{value: msg.value}(\n            owner, recipient, \"\", outputTokens, amountsOut, depositsOut, toChain\n        );   \n        \n281   IVirtualAccount(userAccount).call(calls);\n\n289   IVirtualAccount(userAccount).call(calls);\n\n292    IVirtualAccount(userAccount).withdrawERC20(outputParams.outputToken, outputParams.amountOut);\n\n295   IVirtualAccount(userAccount).userAddress(),\n\n309   IVirtualAccount(userAccount).call(calls);\n\n312     IVirtualAccount(userAccount).withdrawERC20(outputParams.outputTokens[i], outputParams.amountsOut[i]);\n\n320   IVirtualAccount(userAccount).userAddress(),\n\n388   IVirtualAccount(userAccount).withdrawERC20(outputParams.outputTokens[i], outputParams.amountsOut[i]);\n\n396   IVirtualAccount(userAccount).userAddress(),\n\n444   IVirtualAccount(userAccount).withdrawERC20(outputParams.outputToken, outputParams.amountOut);\n\n464    IVirtualAccount(userAccount).withdrawERC20(outputParams.outputTokens[i], outputParams.amountsOut[i]);\n\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/MulticallRootRouter.sol#L78\n\n```solidity\nFile: /src/ulysses-omnichain/RootBridgeAgentExecutor.sol\n84   (success, result) = IRouter(_router).anyExecuteResponse(\n            bytes1(_data[PARAMS_TKN_START]), _data[6:_data.length - PARAMS_GAS_IN], _fromChainId\n        );\n105    IRouter(_router).anyExecute(bytes1(_data[5]), _data[6:_data.length - PARAMS_GAS_IN], _fromChainId);\n\n137   (success, result) = IRouter(_router).anyExecuteDepositSingle(\n                _data[112], _data[113:_data.length - PARAMS_GAS_IN], dParams, _fromChainId\n            );\n\n177   (success, result) = IRouter(_router).anyExecuteDepositMultiple(\n                bytes1(_data[PARAMS_END_OFFSET + uint16(numOfAssets) * PARAMS_TKN_SET_SIZE_MULTIPLE]),\n                _data[\n                    PARAMS_START + PARAMS_END_OFFSET + uint16(numOfAssets) * PARAMS_TKN_SET_SIZE_MULTIPLE:\n                        length - PARAMS_GAS_IN\n                ],\n                dParams,\n                _fromChainId\n            );\n208        IRouter(_router).anyExecuteSigned(_data[25], _data[26:_data.length - PARAMS_GAS_IN], _account, _fromChainId);\n\n241   (success, result) = IRouter(_router).anyExecuteSignedDepositSingle(\n                _data[132], _data[133:_data.length - PARAMS_GAS_IN], dParams, _account, _fromChainId\n            );\n\n283   (success, result) = IRouter(_router).anyExecuteSignedDepositMultiple(\n                    _data[PARAMS_END_SIGNED_OFFSET\n                        + uint16(uint8(bytes1(_data[PARAMS_START_SIGNED]))) * PARAMS_TKN_SET_SIZE_MULTIPLE],\n                    _data[\n                        PARAMS_START + PARAMS_END_SIGNED_OFFSET\n                            + uint16(uint8(bytes1(_data[PARAMS_START_SIGNED]))) * PARAMS_TKN_SET_SIZE_MULTIPLE:\n                            _data.length - PARAMS_GAS_IN\n                    ],\n                    dParams,\n                    _account,\n                    _fromChainId\n                );\n\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgentExecutor.sol#L84\n\n```solidity\nFile: /src/ulysses-omnichain/RootPort.sol\n153   IBridgeAgent(_coreRootBridgeAgent).syncBranchBridgeAgent(_coreLocalBranchBridgeAgent, localChainId);\n\n295   ERC20hTokenRoot(_hToken).mint(_to, _amount, _fromChain);\n\n301   ERC20hTokenRoot(_hToken).burn(_from, _amount, _fromChain);\n\n332   ERC20hTokenRoot(_hToken).burn(_from, _amount, localChainId);\n\n383   if (IBridgeAgent(_rootBridgeAgent).getBranchBridgeAgent(_branchChainId) != address(0)) {\n\n386   if (!IBridgeAgent(_rootBridgeAgent).isBranchBridgeAgentAllowed(_branchChainId)) {\n\n389    IBridgeAgent(_rootBridgeAgent).syncBranchBridgeAgent(_newBranchBridgeAgent, _branchChainId);\n\n435    IERC20hTokenRootFactory(ICoreRootRouter(coreRootRouterAddress).hTokenFactoryAddress()).createToken(\n                _wrappedGasTokenName, _wrappedGasTokenSymbol\n            )\n440   ERC20hTokenRoot(newGlobalToken).mint(_pledger, _pledgedInitialAmount, _chainId);\n\n442   IBridgeAgent(ICoreRootRouter(coreRootRouterAddress).bridgeAgentAddress()).syncBranchBridgeAgent(\n            _coreBranchBridgeAgentAddress, _chainId\n        );\n\n465    newGasPoolAddress = INonfungiblePositionManager(_nonFungiblePositionManagerAddress)\n                .createAndInitializePoolIfNecessary(newGlobalToken, wrappedNativeTokenAddress, _fee, _sqrtPriceX96);\n469    newGasPoolAddress = INonfungiblePositionManager(_nonFungiblePositionManagerAddress)\n                .createAndInitializePoolIfNecessary(wrappedNativeTokenAddress, newGlobalToken, _fee, _sqrtPriceX96);\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootPort.sol#L153\n\n```solidity\nFile: /src/ulysses-omnichain/VirtualAccount.sol\n37   ERC721(_token).transferFrom(address(this), msg.sender, _tokenId);\n\n70   if ((!IRootPort(localPortAddress).isRouterApproved(this, msg.sender)) && (msg.sender != userAddress)) {\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/VirtualAccount.sol#L37\n\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/erc-20/ERC20Gauges.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Gauge weight logic inspired by Tribe DAO Contracts (flywheel-v2/src/token/ERC20Gauges.sol)\npragma solidity ^0.8.0;\n\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\n\nimport {EnumerableSet} from \"@lib/EnumerableSet.sol\";\n\nimport {IBaseV2Gauge} from \"@gauges/interfaces/IBaseV2Gauge.sol\";\n\nimport {ERC20MultiVotes} from \"./ERC20MultiVotes.sol\";\n\nimport {Errors} from \"./interfaces/Errors.sol\";\nimport {IERC20Gauges} from \"./interfaces/IERC20Gauges.sol\";\n\n/// @title  An ERC20 with an embedded \"Gauge\" style vote with liquid weights\nabstract contract ERC20Gauges is ERC20MultiVotes, ReentrancyGuard, IERC20Gauges {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using SafeCastLib for *;\n\n    /**\n     * @notice Construct a new ERC20Gauges\n     * @param _gaugeCycleLength the length of a gauge cycle in seconds\n     * @param _incrementFreezeWindow the length of the grace period in seconds\n     */\n    constructor(uint32 _gaugeCycleLength, uint32 _incrementFreezeWindow) {\n        if (_incrementFreezeWindow >= _gaugeCycleLength) revert IncrementFreezeError();\n        gaugeCycleLength = _gaugeCycleLength;\n        incrementFreezeWindow = _incrementFreezeWindow;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            GAUGE STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Gauges\n    uint32 public immutable override gaugeCycleLength;\n\n    /// @inheritdoc IERC20Gauges\n    uint32 public immutable override incrementFreezeWindow;\n\n    /// @inheritdoc IERC20Gauges\n    mapping(address => mapping(address => uint112)) public override getUserGaugeWeight;\n\n    /// @inheritdoc IERC20Gauges\n    /// @dev NOTE this may contain weights for deprecated gauges\n    mapping(address => uint112) public override getUserWeight;\n\n    /// @notice a mapping from a gauge to the total weight allocated to it\n    /// @dev NOTE this may contain weights for deprecated gauges\n    mapping(address => Weight) internal _getGaugeWeight;\n\n    /// @notice the total global allocated weight ONLY of live gauges\n    Weight internal _totalWeight;\n\n    mapping(address => EnumerableSet.AddressSet) internal _userGauges;\n\n    EnumerableSet.AddressSet internal _gauges;\n\n    // Store deprecated gauges in case a user needs to free dead weight\n    EnumerableSet.AddressSet internal _deprecatedGauges;\n\n    /*///////////////////////////////////////////////////////////////\n                              VIEW HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Gauges\n    function getGaugeCycleEnd() external view returns (uint32) {\n        return _getGaugeCycleEnd();\n    }\n\n    function _getGaugeCycleEnd() internal view returns (uint32) {\n        uint32 nowPlusOneCycle = block.timestamp.toUint32() + gaugeCycleLength;\n        unchecked {\n            return (nowPlusOneCycle / gaugeCycleLength) * gaugeCycleLength; // cannot divide by zero and always <= nowPlusOneCycle so no overflow\n        }\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function getGaugeWeight(address gauge) external view returns (uint112) {\n        return _getGaugeWeight[gauge].currentWeight;\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function getStoredGaugeWeight(address gauge) external view returns (uint112) {\n        if (_deprecatedGauges.contains(gauge)) return 0;\n        return _getStoredWeight(_getGaugeWeight[gauge], _getGaugeCycleEnd());\n    }\n\n    function _getStoredWeight(Weight storage gaugeWeight, uint32 currentCycle) internal view returns (uint112) {\n        return gaugeWeight.currentCycle < currentCycle ? gaugeWeight.currentWeight : gaugeWeight.storedWeight;\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function totalWeight() external view returns (uint112) {\n        return _totalWeight.currentWeight;\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function storedTotalWeight() external view returns (uint112) {\n        return _getStoredWeight(_totalWeight, _getGaugeCycleEnd());\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function gauges() external view returns (address[] memory) {\n        return _gauges.values();\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function gauges(uint256 offset, uint256 num) external view returns (address[] memory values) {\n        values = new address[](num);\n        for (uint256 i = 0; i < num;) {\n            unchecked {\n                values[i] = _gauges.at(offset + i); // will revert if out of bounds\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function isGauge(address gauge) external view returns (bool) {\n        return _gauges.contains(gauge) && !_deprecatedGauges.contains(gauge);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function numGauges() external view returns (uint256) {\n        return _gauges.length();\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function deprecatedGauges() external view returns (address[] memory) {\n        return _deprecatedGauges.values();\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function numDeprecatedGauges() external view returns (uint256) {\n        return _deprecatedGauges.length();\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function userGauges(address user) external view returns (address[] memory) {\n        return _userGauges[user].values();\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function isUserGauge(address user, address gauge) external view returns (bool) {\n        return _userGauges[user].contains(gauge);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function userGauges(address user, uint256 offset, uint256 num) external view returns (address[] memory values) {\n        values = new address[](num);\n        for (uint256 i = 0; i < num;) {\n            unchecked {\n                values[i] = _userGauges[user].at(offset + i); // will revert if out of bounds\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function numUserGauges(address user) external view returns (uint256) {\n        return _userGauges[user].length();\n    }\n\n    /// @inheritdoc ERC20MultiVotes\n    function userUnusedVotes(address user) public view override returns (uint256) {\n        return super.userUnusedVotes(user) - getUserWeight[user];\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function calculateGaugeAllocation(address gauge, uint256 quantity) external view returns (uint256) {\n        if (_deprecatedGauges.contains(gauge)) return 0;\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        uint112 total = _getStoredWeight(_totalWeight, currentCycle);\n        uint112 weight = _getStoredWeight(_getGaugeWeight[gauge], currentCycle);\n        return (quantity * weight) / total;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        USER GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Gauges\n    function incrementGauge(address gauge, uint112 weight) external nonReentrant returns (uint112 newUserWeight) {\n        uint32 currentCycle = _getGaugeCycleEnd();\n        _incrementGaugeWeight(msg.sender, gauge, weight, currentCycle);\n        return _incrementUserAndGlobalWeights(msg.sender, weight, currentCycle);\n    }\n\n    /**\n     * @notice Increment the weight of a gauge for a user\n     * @dev This function calls accrueBribes for the gauge to ensure the gauge handles the balance change.\n     * @param user the user to increment the weight of\n     * @param gauge the gauge to increment the weight of\n     * @param weight the weight to increment by\n     * @param cycle the cycle to increment the weight for\n     */\n    function _incrementGaugeWeight(address user, address gauge, uint112 weight, uint32 cycle) internal {\n        if (!_gauges.contains(gauge) || _deprecatedGauges.contains(gauge)) revert InvalidGaugeError();\n        unchecked {\n            if (cycle - block.timestamp <= incrementFreezeWindow) revert IncrementFreezeError();\n        }\n\n        IBaseV2Gauge(gauge).accrueBribes(user);\n\n        bool added = _userGauges[user].add(gauge); // idempotent add\n        if (added && _userGauges[user].length() > maxGauges && !canContractExceedMaxGauges[user]) {\n            revert MaxGaugeError();\n        }\n\n        getUserGaugeWeight[user][gauge] += weight;\n\n        _writeGaugeWeight(_getGaugeWeight[gauge], _add112, weight, cycle);\n\n        emit IncrementGaugeWeight(user, gauge, weight, cycle);\n    }\n\n    /**\n     * @notice Increment the weight of a gauge for a user and the total weight\n     * @param user the user to increment the weight of\n     * @param weight the weight to increment by\n     * @param cycle the cycle to increment the weight for\n     * @return newUserWeight the new user's weight\n     */\n    function _incrementUserAndGlobalWeights(address user, uint112 weight, uint32 cycle)\n        internal\n        returns (uint112 newUserWeight)\n    {\n        newUserWeight = getUserWeight[user] + weight;\n\n        // new user weight must be less than or equal to the total user weight\n        if (newUserWeight > getVotes(user)) revert OverWeightError();\n\n        // Update gauge state\n        getUserWeight[user] = newUserWeight;\n\n        _writeGaugeWeight(_totalWeight, _add112, weight, cycle);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function incrementGauges(address[] calldata gaugeList, uint112[] calldata weights)\n        external\n        nonReentrant\n        returns (uint256 newUserWeight)\n    {\n        uint256 size = gaugeList.length;\n        if (weights.length != size) revert SizeMismatchError();\n\n        // store total in summary for a batch update on user/global state\n        uint112 weightsSum;\n\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        // Update a gauge's specific state\n        for (uint256 i = 0; i < size;) {\n            address gauge = gaugeList[i];\n            uint112 weight = weights[i];\n            weightsSum += weight;\n\n            _incrementGaugeWeight(msg.sender, gauge, weight, currentCycle);\n            unchecked {\n                i++;\n            }\n        }\n        return _incrementUserAndGlobalWeights(msg.sender, weightsSum, currentCycle);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function decrementGauge(address gauge, uint112 weight) external nonReentrant returns (uint112 newUserWeight) {\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        // All operations will revert on underflow, protecting against bad inputs\n        _decrementGaugeWeight(msg.sender, gauge, weight, currentCycle);\n        if (!_deprecatedGauges.contains(gauge)) {\n            _writeGaugeWeight(_totalWeight, _subtract112, weight, currentCycle);\n        }\n        return _decrementUserWeights(msg.sender, weight);\n    }\n\n    /**\n     * @notice Decrement the weight of a gauge for a user\n     * @dev This function calls accrueBribes for the gauge to ensure the gauge handles the balance change.\n     * @param user the user to decrement the weight of\n     * @param gauge the gauge to decrement the weight of\n     * @param weight the weight to decrement by\n     * @param cycle the cycle to decrement the weight for\n     */\n    function _decrementGaugeWeight(address user, address gauge, uint112 weight, uint32 cycle) internal {\n        if (!_gauges.contains(gauge)) revert InvalidGaugeError();\n\n        uint112 oldWeight = getUserGaugeWeight[user][gauge];\n\n        IBaseV2Gauge(gauge).accrueBribes(user);\n\n        getUserGaugeWeight[user][gauge] = oldWeight - weight;\n        if (oldWeight == weight) {\n            // If removing all weight, remove gauge from user list.\n            require(_userGauges[user].remove(gauge));\n        }\n\n        _writeGaugeWeight(_getGaugeWeight[gauge], _subtract112, weight, cycle);\n\n        emit DecrementGaugeWeight(user, gauge, weight, cycle);\n    }\n\n    /**\n     * @notice Decrement the weight of a gauge for a user and the total weight\n     * @param user the user to decrement the weight of\n     * @param weight the weight to decrement by\n     * @return newUserWeight the new user's weight\n     */\n    function _decrementUserWeights(address user, uint112 weight) internal returns (uint112 newUserWeight) {\n        newUserWeight = getUserWeight[user] - weight;\n        getUserWeight[user] = newUserWeight;\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function decrementGauges(address[] calldata gaugeList, uint112[] calldata weights)\n        external\n        nonReentrant\n        returns (uint112 newUserWeight)\n    {\n        uint256 size = gaugeList.length;\n        if (weights.length != size) revert SizeMismatchError();\n\n        // store total in summary for the batch update on user and global state\n        uint112 weightsSum;\n        uint112 globalWeightsSum;\n\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        // Update the gauge's specific state\n        // All operations will revert on underflow, protecting against bad inputs\n        for (uint256 i = 0; i < size;) {\n            address gauge = gaugeList[i];\n            uint112 weight = weights[i];\n            weightsSum += weight;\n            if (!_deprecatedGauges.contains(gauge)) globalWeightsSum += weight;\n\n            _decrementGaugeWeight(msg.sender, gauge, weight, currentCycle);\n            unchecked {\n                i++;\n            }\n        }\n        _writeGaugeWeight(_totalWeight, _subtract112, globalWeightsSum, currentCycle);\n\n        return _decrementUserWeights(msg.sender, weightsSum);\n    }\n\n    /**\n     * @dev this function is the key to the entire contract.\n     *  The storage weight it operates on is either a global or gauge-specific weight.\n     *  The operation applied is either addition for incrementing gauges or subtraction for decrementing a gauge.\n     * @param weight the weight to apply the operation to\n     * @param op the operation to apply\n     * @param delta the amount to apply the operation by\n     * @param cycle the cycle to apply the operation for\n     */\n    function _writeGaugeWeight(\n        Weight storage weight,\n        function(uint112, uint112) view returns (uint112) op,\n        uint112 delta,\n        uint32 cycle\n    ) private {\n        uint112 currentWeight = weight.currentWeight;\n        // If the last cycle of the weight is before the current cycle, use the current weight as the stored.\n        uint112 stored = weight.currentCycle < cycle ? currentWeight : weight.storedWeight;\n        uint112 newWeight = op(currentWeight, delta);\n\n        weight.storedWeight = stored;\n        weight.currentWeight = newWeight;\n        weight.currentCycle = cycle;\n    }\n\n    function _add112(uint112 a, uint112 b) private pure returns (uint112) {\n        return a + b;\n    }\n\n    function _subtract112(uint112 a, uint112 b) private pure returns (uint112) {\n        return a - b;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ADMIN GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Gauges\n    uint256 public override maxGauges;\n\n    /// @inheritdoc IERC20Gauges\n    mapping(address => bool) public override canContractExceedMaxGauges;\n\n    /// @inheritdoc IERC20Gauges\n    function addGauge(address gauge) external onlyOwner returns (uint112) {\n        return _addGauge(gauge);\n    }\n\n    /**\n     * @notice Add a gauge to the contract\n     * @param gauge the gauge to add\n     * @return weight the previous weight of the gauge, if it was already added\n     */\n    function _addGauge(address gauge) internal returns (uint112 weight) {\n        bool newAdd = _gauges.add(gauge);\n        bool previouslyDeprecated = _deprecatedGauges.remove(gauge);\n        // add and fail loud if zero address or already present and not deprecated\n        if (gauge == address(0) || !(newAdd || previouslyDeprecated)) revert InvalidGaugeError();\n\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        // Check if some previous weight exists and re-add to the total. Gauge and user weights are preserved.\n        weight = _getGaugeWeight[gauge].currentWeight;\n        if (weight > 0) {\n            _writeGaugeWeight(_totalWeight, _add112, weight, currentCycle);\n        }\n\n        emit AddGauge(gauge);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function removeGauge(address gauge) external onlyOwner {\n        _removeGauge(gauge);\n    }\n\n    /**\n     * @notice Remove a gauge from the contract\n     * @param gauge the gauge to remove\n     */\n    function _removeGauge(address gauge) internal {\n        // add to deprecated and fail loud if not present\n        if (!_deprecatedGauges.add(gauge)) revert InvalidGaugeError();\n\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        // Remove weight from total but keep the gauge and user weights in storage in case the gauge is re-added.\n        uint112 weight = _getGaugeWeight[gauge].currentWeight;\n        if (weight > 0) {\n            _writeGaugeWeight(_totalWeight, _subtract112, weight, currentCycle);\n        }\n\n        emit RemoveGauge(gauge);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function replaceGauge(address oldGauge, address newGauge) external onlyOwner {\n        _removeGauge(oldGauge);\n        _addGauge(newGauge);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function setMaxGauges(uint256 newMax) external onlyOwner {\n        uint256 oldMax = maxGauges;\n        maxGauges = newMax;\n\n        emit MaxGaugesUpdate(oldMax, newMax);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function setContractExceedMaxGauges(address account, bool canExceedMax) external onlyOwner {\n        if (canExceedMax && account.code.length == 0) revert Errors.NonContractError(); // can only approve contracts\n\n        canContractExceedMaxGauges[account] = canExceedMax;\n\n        emit CanContractExceedMaxGaugesUpdate(account, canExceedMax);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// NOTE: any \"removal\" of tokens from a user requires userUnusedVotes < amount.\n    /// _decrementWeightUntilFree is called as a greedy algorithm to free up weight.\n    /// It may be more gas efficient to free weight before burning or transferring tokens.\n\n    /**\n     * @notice Burns `amount` of tokens from `from` address.\n     * @dev Frees weights and votes with a greedy algorithm if needed to burn tokens\n     * @param from The address to burn tokens from.\n     * @param amount The amount of tokens to burn.\n     */\n    function _burn(address from, uint256 amount) internal virtual override {\n        _decrementWeightUntilFree(from, amount);\n        super._burn(from, amount);\n    }\n\n    /**\n     * @notice Transfers `amount` of tokens from `msg.sender` to `to` address.\n     * @dev Frees weights and votes with a greedy algorithm if needed to burn tokens\n     * @param to the address to transfer to.\n     * @param amount the amount to transfer.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        _decrementWeightUntilFree(msg.sender, amount);\n        return super.transfer(to, amount);\n    }\n\n    /**\n     * @notice Transfers `amount` of tokens from `from` address to `to` address.\n     * @dev Frees weights and votes with a greedy algorithm if needed to burn tokens\n     * @param from the address to transfer from.\n     * @param to the address to transfer to.\n     * @param amount the amount to transfer.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        _decrementWeightUntilFree(from, amount);\n        return super.transferFrom(from, to, amount);\n    }\n\n    /**\n     * @notice A greedy algorithm for freeing weight before a token burn/transfer\n     * @dev Frees up entire gauges, so likely will free more than `weight`\n     * @param user the user to free weight for\n     * @param weight the weight to free\n     */\n    function _decrementWeightUntilFree(address user, uint256 weight) internal nonReentrant {\n        uint256 userFreeWeight = freeVotes(user) + userUnusedVotes(user);\n\n        // early return if already free\n        if (userFreeWeight >= weight) return;\n\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        // cache totals for batch updates\n        uint112 userFreed;\n        uint112 totalFreed;\n\n        // Loop through all user gauges, live and deprecated\n        address[] memory gaugeList = _userGauges[user].values();\n\n        // Free gauges through the entire list or until underweight\n        uint256 size = gaugeList.length;\n        for (uint256 i = 0; i < size && (userFreeWeight + totalFreed) < weight;) {\n            address gauge = gaugeList[i];\n            uint112 userGaugeWeight = getUserGaugeWeight[user][gauge];\n            if (userGaugeWeight != 0) {\n                // If the gauge is live (not deprecated), include its weight in the total to remove\n                if (!_deprecatedGauges.contains(gauge)) {\n                    totalFreed += userGaugeWeight;\n                }\n                userFreed += userGaugeWeight;\n                _decrementGaugeWeight(user, gauge, userGaugeWeight, currentCycle);\n\n                unchecked {\n                    i++;\n                }\n            }\n        }\n\n        getUserWeight[user] -= userFreed;\n        _writeGaugeWeight(_totalWeight, _subtract112, totalFreed, currentCycle);\n    }\n}"
    },
    {
      "filename": "src/erc-4626/UlyssesERC4626.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\n\nimport {IUlyssesERC4626} from \"./interfaces/IUlyssesERC4626.sol\";\n\n/// @title Minimal ERC4626 tokenized 1:1 Vault implementation\n/// @author Maia DAO (https://github.com/Maia-DAO)\nabstract contract UlyssesERC4626 is ERC20, ReentrancyGuard, IUlyssesERC4626 {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    address public immutable asset;\n\n    constructor(address _asset, string memory _name, string memory _symbol) ERC20(_name, _symbol, 18) {\n        asset = _asset;\n\n        if (ERC20(_asset).decimals() != 18) revert InvalidAssetDecimals();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function deposit(uint256 assets, address receiver) public virtual nonReentrant returns (uint256 shares) {\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        shares = beforeDeposit(assets);\n\n        require(shares != 0, \"ZERO_SHARES\");\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n\n    function mint(uint256 shares, address receiver) public virtual nonReentrant returns (uint256 assets) {\n        assets = beforeMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        require(assets != 0, \"ZERO_ASSETS\");\n\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n\n    function redeem(uint256 shares, address receiver, address owner)\n        public\n        virtual\n        nonReentrant\n        returns (uint256 assets)\n    {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        _burn(owner, shares);\n\n        assets = afterRedeem(shares);\n\n        require(assets != 0, \"ZERO_ASSETS\");\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        return assets;\n    }\n\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        return shares;\n    }\n\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return assets;\n    }\n\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        return shares;\n    }\n\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return shares;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Should not do any external calls to prevent reentrancy.\n    function beforeDeposit(uint256 assets) internal virtual returns (uint256 shares);\n\n    /// @dev Should not do any external calls to prevent reentrancy.\n    function beforeMint(uint256 shares) internal virtual returns (uint256 assets);\n\n    /// @dev Should not do any external calls to prevent reentrancy.\n    function afterRedeem(uint256 shares) internal virtual returns (uint256 assets);\n}"
    },
    {
      "filename": "src/gauges/factories/UniswapV3GaugeFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {bHermesBoost} from \"@hermes/tokens/bHermesBoost.sol\";\n\nimport {UniswapV3Gauge, BaseV2Gauge} from \"@gauges/UniswapV3Gauge.sol\";\n\nimport {FlywheelGaugeRewards} from \"@rewards/rewards/FlywheelGaugeRewards.sol\";\n\nimport {\n    UniswapV3Staker,\n    IUniswapV3Factory,\n    INonfungiblePositionManager,\n    IUniswapV3Pool\n} from \"@v3-staker/UniswapV3Staker.sol\";\n\nimport {BribesFactory} from \"./BribesFactory.sol\";\nimport {BaseV2GaugeFactory} from \"./BaseV2GaugeFactory.sol\";\nimport {BaseV2GaugeManager} from \"./BaseV2GaugeManager.sol\";\n\nimport {IUniswapV3GaugeFactory} from \"../interfaces/IUniswapV3GaugeFactory.sol\";\n\n/// @title Uniswap V3 Gauge Factory\ncontract UniswapV3GaugeFactory is BaseV2GaugeFactory, IUniswapV3GaugeFactory {\n    /*//////////////////////////////////////////////////////////////\n                         FACTORY STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IUniswapV3GaugeFactory\n    UniswapV3Staker public immutable override uniswapV3Staker;\n\n    /// @inheritdoc IUniswapV3GaugeFactory\n    FlywheelGaugeRewards public immutable override flywheelGaugeRewards;\n\n    /**\n     * @notice Creates a new Uniswap V3 Gauge Factory\n     * @param _gaugeManager Gauge Factory manager\n     * @param _bHermesBoost bHermes Boost Token\n     * @param _factory Uniswap V3 Factory\n     * @param _nonfungiblePositionManager Uniswap V3 Nonfungible Position Manager\n     * @param _flywheelGaugeRewards Flywheel Gauge Rewards\n     * @param _bribesFactory Bribes Factory\n     * @param _owner Owner of this contract\n     */\n    constructor(\n        BaseV2GaugeManager _gaugeManager,\n        bHermesBoost _bHermesBoost,\n        IUniswapV3Factory _factory,\n        INonfungiblePositionManager _nonfungiblePositionManager,\n        FlywheelGaugeRewards _flywheelGaugeRewards,\n        BribesFactory _bribesFactory,\n        address _owner\n    ) BaseV2GaugeFactory(_gaugeManager, _bHermesBoost, _bribesFactory, _owner) {\n        flywheelGaugeRewards = _flywheelGaugeRewards;\n        uniswapV3Staker = new UniswapV3Staker(\n            _factory,\n            _nonfungiblePositionManager,\n            this,\n            _bHermesBoost,\n            52 weeks,\n            address(_flywheelGaugeRewards.minter()),\n            address(_flywheelGaugeRewards.rewardToken())\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         GAUGE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Creates a new Uniswap V3 Gauge\n    function newGauge(address strategy, bytes memory data) internal override returns (BaseV2Gauge) {\n        uint24 minimumWidth = abi.decode(data, (uint24));\n        return new UniswapV3Gauge(\n                flywheelGaugeRewards,\n                address(uniswapV3Staker),\n                strategy,\n                minimumWidth,\n                address(this)\n            );\n    }\n\n    /// @notice Adds Gauge to UniswapV3Staker\n    /// @dev Updates the UniswapV3 staker with bribe and minimum width information\n    function afterCreateGauge(address strategy, bytes memory) internal override {\n        uniswapV3Staker.updateGauges(IUniswapV3Pool(strategy));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ADMIN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IUniswapV3GaugeFactory\n    function setMinimumWidth(address gauge, uint24 minimumWidth) external onlyOwner {\n        if (!activeGauges[BaseV2Gauge(gauge)]) revert InvalidGauge();\n        UniswapV3Gauge(gauge).setMinimumWidth(minimumWidth);\n        uniswapV3Staker.updateGauges(IUniswapV3Pool(UniswapV3Gauge(gauge).strategy()));\n    }\n}"
    },
    {
      "filename": "src/gauges/UniswapV3Gauge.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {IUniswapV3Staker} from \"@v3-staker/interfaces/IUniswapV3Staker.sol\";\n\nimport {BaseV2Gauge, FlywheelGaugeRewards} from \"./BaseV2Gauge.sol\";\nimport {IUniswapV3Gauge} from \"./interfaces/IUniswapV3Gauge.sol\";\n\n/// @title Uniswap V3 Gauge - Handles liquidity provider incentives for Uniswap V3 in the Base V2 Gauge implementation.\ncontract UniswapV3Gauge is BaseV2Gauge, IUniswapV3Gauge {\n    using SafeTransferLib for address;\n\n    /*//////////////////////////////////////////////////////////////\n                         GAUGE STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IUniswapV3Gauge\n    address public immutable override uniswapV3Staker;\n\n    /// @inheritdoc IUniswapV3Gauge\n    uint24 public override minimumWidth;\n\n    /**\n     * @notice Constructs the UniswapV3Gauge contract.\n     * @param _flywheelGaugeRewards The FlywheelGaugeRewards contract.\n     * @param _uniswapV3Staker The UniswapV3Staker contract.\n     * @param _uniswapV3Pool The UniswapV3Pool contract.\n     * @param _minimumWidth The minimum width.\n     * @param _owner The owner of the contract.\n     */\n    constructor(\n        FlywheelGaugeRewards _flywheelGaugeRewards,\n        address _uniswapV3Staker,\n        address _uniswapV3Pool,\n        uint24 _minimumWidth,\n        address _owner\n    ) BaseV2Gauge(_flywheelGaugeRewards, _uniswapV3Pool, _owner) {\n        uniswapV3Staker = _uniswapV3Staker;\n        minimumWidth = _minimumWidth;\n\n        emit NewMinimumWidth(_minimumWidth);\n\n        rewardToken.safeApprove(_uniswapV3Staker, type(uint256).max);\n    }\n\n    /**\n     *  @notice Distributes weekly emissions to the Uniswap V3 Staker for the current epoch.\n     *  @dev must be called during the 12-hour offset after an epoch ends\n     *       or rewards will be queued for the next epoch.\n     */\n    function distribute(uint256 amount) internal override {\n        IUniswapV3Staker(uniswapV3Staker).createIncentiveFromGauge(amount);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ADMIN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IUniswapV3Gauge\n    function setMinimumWidth(uint24 _minimumWidth) external onlyOwner {\n        minimumWidth = _minimumWidth;\n\n        emit NewMinimumWidth(_minimumWidth);\n    }\n\n    /"
    }
  ]
}