{
  "Title": "M-7: update() wrong privilege control",
  "Content": "# Issue M-7: update() wrong privilege control \n\nSource: https://github.com/sherlock-audit/2023-07-perennial-judging/issues/121 \n\n## Found by \nbin2chen\n`oracle.update()`  wrong privilege control\nlead to `OracleFactory.update()` unable to add `oracleProvider`\n\n## Vulnerability Detail\nin `OracleFactory.update()` will call `oracle.update()`\n\n```solidity\ncontract OracleFactory is IOracleFactory, Factory {\n...\n    function update(bytes32 id, IOracleProviderFactory factory) external onlyOwner {\n        if (!factories[factory]) revert OracleFactoryNotRegisteredError();\n        if (oracles[id] == IOracleProvider(address(0))) revert OracleFactoryNotCreatedError();\n\n        IOracleProvider oracleProvider = factory.oracles(id);\n        if (oracleProvider == IOracleProvider(address(0))) revert OracleFactoryInvalidIdError();\n\n        IOracle oracle = IOracle(address(oracles[id]));\n@>      oracle.update(oracleProvider);\n    }\n\n```\n\nBut `oracle.update()` permission is needed for `OracleFactory.owner()` and not `OracleFactory` itself.\n\n```solidity\n@>  function update(IOracleProvider newProvider) external onlyOwner {\n        _updateCurrent(newProvider);\n        _updateLatest(newProvider.latest());\n    }\n\n    modifier onlyOwner {\n@>      if (msg.sender != factory().owner()) revert InstanceNotOwnerError(msg.sender);\n        _;\n    }\n```\n\nThis results in `OracleFactory` not being able to do `update()`.\nSuggest changing the limit of ``oracle.update()`` to ``factory()``.\n\n## Impact\n\n`OracleFactory.update()` unable to add `IOracleProvider`\n\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-07-perennial/blob/main/perennial-v2/packages/perennial-oracle/contracts/OracleFactory.sol#L81\n\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n```solidity\ncontract Oracle is IOracle, Instance {\n...\n\n-   function update(IOracleProvider newProvider) external onlyOwner {\n+   function update(IOracleProvider newProvider) external {\n+       require(msg.sender == factory(),\"invalid sender\");\n        _updateCurrent(newProvider);\n        _updateLatest(newProvider.latest());\n    }\n```\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**__141345__** commented:\n> m\n\n\n\n**arjun-io**\n\nFixed: https://github.com/equilibria-xyz/perennial-v2/pull/81\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/106",
  "Code": [
    {
      "filename": "perennial-v2/packages/perennial-oracle/contracts/OracleFactory.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport \"@equilibria/root/token/types/Token18.sol\";\nimport \"@equilibria/root/attribute/Factory.sol\";\nimport \"@equilibria/perennial-v2/contracts/interfaces/IOracleProviderFactory.sol\";\nimport \"./interfaces/IOracleFactory.sol\";\n\n/// @title OracleFactory\n/// @notice Factory for creating and managing oracles\ncontract OracleFactory is IOracleFactory, Factory {\n    /// @notice The token that is paid out as a reward to oracle keepers\n    Token18 public incentive;\n\n    /// @notice The maximum amount of tokens that can be rewarded in a single price update\n    UFixed6 public maxClaim;\n\n    /// @notice Mapping of which factory's instances are authorized to request from this contract\n    mapping(IFactory => bool) public callers;\n\n    /// @notice Mapping of oracle id to oracle instance\n    mapping(bytes32 => IOracleProvider) public oracles;\n\n    /// @notice Mapping of factory to whether it is registered\n    mapping(IOracleProviderFactory => bool) public factories;\n\n    /// @notice Constructs the contract\n    /// @param implementation_ The implementation contract for the oracle\n    constructor(address implementation_) Factory(implementation_) { }\n\n    /// @notice Initializes the contract state\n    /// @param incentive_ The token that is paid out as a reward to oracle keepers\n    function initialize(Token18 incentive_) external initializer(1) {\n        __UOwnable__initialize();\n\n        incentive = incentive_;\n    }\n\n    /// @notice Registers a new oracle provider factory to be used in the underlying oracle instances\n    /// @param factory The factory to register\n    function register(IOracleProviderFactory factory) external onlyOwner {\n        factories[factory] = true;\n        emit FactoryRegistered(factory);\n    }\n\n    /// @notice Authorizes a factory's instances to request from this contract\n    /// @param caller The factory to authorize\n    function authorize(IFactory caller) external onlyOwner {\n        callers[caller] = true;\n        emit CallerAuthorized(caller);\n    }\n\n    /// @notice Creates a new oracle instance\n    /// @param id The id of the oracle to create\n    /// @param factory The initial underlying oracle factory for this oracle to use\n    /// @return newOracle The newly created oracle instance\n    function create(bytes32 id, IOracleProviderFactory factory) external onlyOwner returns (IOracle newOracle) {\n        if (!factories[factory]) revert OracleFactoryNotRegisteredError();\n        if (oracles[id] != IOracleProvider(address(0))) revert OracleFactoryAlreadyCreatedError();\n\n        IOracleProvider oracleProvider = factory.oracles(id);\n        if (oracleProvider == IOracleProvider(address(0))) revert OracleFactoryInvalidIdError();\n\n        newOracle = IOracle(address(_create(abi.encodeCall(IOracle.initialize, (oracleProvider)))));\n        oracles[id] = newOracle;\n\n        emit OracleCreated(newOracle, id);\n    }\n\n    /// @notice Updates the underlying oracle factory for an oracle instance\n    /// @param id The id of the oracle to update\n    /// @param factory The new underlying oracle factory for this oracle to use\n    function update(bytes32 id, IOracleProviderFactory factory) external onlyOwner {\n        if (!factories[factory]) revert OracleFactoryNotRegisteredError();\n        if (oracles[id] == IOracleProvider(address(0))) revert OracleFactoryNotCreatedError();\n\n        IOracleProvider oracleProvider = factory.oracles(id);\n        if (oracleProvider == IOracleProvider(address(0))) revert OracleFactoryInvalidIdError();\n\n        IOracle oracle = IOracle(address(oracles[id]));\n        oracle.update(oracleProvider);\n    }\n\n    /// @notice Updates the maximum amount of tokens that can be rewarded in a single price update\n    function updateMaxClaim(UFixed6 newMaxClaim) external onlyOwner {\n        maxClaim = newMaxClaim;\n        emit MaxClaimUpdated(newMaxClaim);\n    }\n\n    /// @notice Claims an amount of incentive tokens, to be paid out as a reward to the keeper\n    /// @dev Can only be called by a registered underlying oracle provider factory\n    /// @param amount The amount of tokens to claim\n    function claim(UFixed6 amount) external {\n        if (amount.gt(maxClaim)) revert OracleFactoryClaimTooLargeError();\n        if (!factories[IOracleProviderFactory(msg.sender)]) revert OracleFactoryNotRegisteredError();\n        incentive.push(msg.sender, UFixed18Lib.from(amount));\n    }\n\n    /// @notice Checks whether a caller is authorized to request from this contract\n    /// @param caller The caller to check\n    /// @return Whether the caller is authorized\n    function authorized(address caller) external view returns (bool) {\n        IInstance callerInstance = IInstance(caller);\n        IFactory callerFactory = callerInstance.factory();\n        if (!callerFactory.instances(callerInstance)) return false;\n        return callers[callerFactory];\n    }\n\n    // @notice Claims the oracle's fee from the given market\n    /// @param market The market to claim from\n    function fund(IMarket market) external {\n        if (!instances(IInstance(address(market.oracle())))) revert FactoryNotInstanceError();\n        market.claimFee();\n    }\n}"
    }
  ]
}