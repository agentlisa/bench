{
  "Title": "If the dao removes a bridge, user's deposited tokens for that bridge will be lost.",
  "Content": "# If the dao removes a bridge, user's deposited tokens for that bridge will be lost.\n\n### Severity\nHigh Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/facets/OwnerFacet.sol#L287-L304\">https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/facets/OwnerFacet.sol#L287-L304</a>\n\n\n## Summary\nIf the dao removes a bridge for any (non-malicious) reason, user's deposited tokens for that bridge will be lost.\n\n## Vulnerability Details\nIn the ```OwnerFacet.sol``` the dao of the system has the option to remove a bridge by calling the ```deleteBridge()``` function. There is no check if there are any assets in the bridge. Also users may deposit funds in the bridge during the voting period. \n\nPOC\nAdd the following function in the ```BridgeRouter.t.sol```\n\n```\nfunction test_DeleteBridgeWithAssets() public {\n        console.log(\"Sender ethEscrowed in vault 2 before deposit: \", diamond.getVaultUserStruct(2, sender).ethEscrowed);\n        deal(_rethA, sender, 10000 ether);\n\n        vm.startPrank(sender);\n        uint88 deposit1 = 1000 ether;\n        uint88 withdrawAmount = 100 ether;\n        diamond.deposit(_bridgeRethToBeDeleted, deposit1);\n        console.log(\"Sender ethEscrowed in vault2 after deposit: \", diamond.getVaultUserStruct(2, sender).ethEscrowed);\n        diamond.withdraw(_bridgeRethToBeDeleted, withdrawAmount);\n        console.log(\"Sender ethEscrowed after withdraw: \", diamond.getVaultUserStruct(2, sender).ethEscrowed);\n        vm.stopPrank();\n\n        console.log(\"Balance of reth in the bridgeRethToBeDeleted: \", rethA.balanceOf(_bridgeRethToBeDeleted));\n\n        /// INFO: DAO deletes the bridge after a vote has been passed\n        vm.startPrank(owner) ;\n        diamond.deleteBridge(_bridgeRethToBeDeleted);\n        vm.stopPrank();\n\n        vm.startPrank(sender);\n        vm.expectRevert();\n        diamond.withdraw(_bridgeRethToBeDeleted, withdrawAmount);\n        console.log(\"Balance of reth in the bridgeRethToBeDeleted: \", rethA.balanceOf(_bridgeRethToBeDeleted));\n        vm.stopPrank();\n    }\n```\n\nIn order to run this test, you also have to add \n```\n rethA.approve(\n                _bridgeRethToBeDeleted,\n                0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n            );\n```\nto ```setUp()``` function of the ```BridgeROuter.t.sol``` contract\n\nIn ```DeployHelper.sol``` another bridge and vault have to be added in order for the test to run:\n\n```\n/// INFO: added by auditor\n    IBridge public bridgeRethToBeDeleted;\n    address public _bridgeRethToBeDeleted;\n    IAsset public zethToBeDeletedVault;\n    address public _zethToBeDeletedVault;\n    IRocketStorage public rocketStorageA;\n    address public _rocketStorageA;\n    IRocketTokenRETH public rethA;\n    address public _rethA;\n```\n\nAdd the following to ```deployContracts()``` function\n```\nif (chainId == 31337) {\n            //mocks\n            _immutableCreate2Factory = deployCode(\"ImmutableCreate2Factory.sol\");\n\n            if (isMock) {\n                _steth = deployCode(\"STETH.sol\");\n                _unsteth = deployCode(\"UNSTETH.sol\", abi.encode(_steth));\n                _rocketStorage = deployCode(\"RocketStorage.sol\");\n                _reth = deployCode(\"RocketTokenRETH.sol\");\n                reth = IRocketTokenRETH(_reth);\n                _ethAggregator = deployCode(\"MockAggregatorV3.sol\");\n                /// INFO: added by auditor\n                _rocketStorageA = deployCode(\"RocketStorage.sol\");\n                _rethA = deployCode(\"RocketTokenRETH.sol\");\n                rethA = IRocketTokenRETH(_rethA);\n            }\n\n            rocketStorage = IRocketStorage(_rocketStorage);\n            /// INFO: added by auditor\n            rocketStorageA = IRocketStorage(_rocketStorageA);\n            steth = ISTETH(_steth);\n            unsteth = IUNSTETH(payable(_unsteth));\n            ethAggregator = IMockAggregatorV3(_ethAggregator);\n        }\n\n/// INFO: Added by auditor \n        _zethToBeDeletedVault = factory.safeCreate2(\n            salt,\n            abi.encodePacked(\n                vm.getCode(\"Asset.sol:Asset\"), abi.encode(_diamond, \"Zebra ETH Two\", \"ZETHT\")\n            )\n        );\n\n      _bridgeRethToBeDeleted = factory.safeCreate2(\n            salt,\n            abi.encodePacked(\n                vm.getCode(\"BridgeReth.sol:BridgeReth\"),\n                abi.encode(_rocketStorageA, _diamond)\n            )\n        );\n\n        bridgeRethToBeDeleted = IBridge(_bridgeRethToBeDeleted);\n            MTypes.CreateVaultParams memory vaultParams;\n            vaultParams.zethTithePercent = 10_00;\n            vaultParams.dittoMatchedRate = 1;\n            vaultParams.dittoShorterRate = 1;\n            diamond.createVault({zeth: _zeth, vault: Vault.CARBON, params: vaultParams});\n\n            MTypes.CreateVaultParams memory vaultParamsTwo;\n            vaultParamsTwo.zethTithePercent = 9_00;\n            vaultParamsTwo.dittoMatchedRate = 1;\n            vaultParamsTwo.dittoShorterRate = 1;\n            zethToBeDeletedVault = IAsset(_zethToBeDeletedVault);\n            diamond.createVault({zeth: _zethToBeDeletedVault, vault: 2, params: vaultParamsTwo});\n            STypes.Vault memory carbonVaultConfigTwo = diamond.getVaultStruct(2);\n            assertEq(carbonVaultConfigTwo.zethTithePercent, 9_00);\n\n             diamond.createBridge({\n                bridge: _bridgeRethToBeDeleted,\n                vault: 2,\n                withdrawalFee: 150,\n                unstakeFee: 0\n            });\n            \n            if (isMock) {\n                rocketStorage.setDeposit(_reth);\n                rocketStorage.setReth(_reth);\n                /// INFO: added by auditor\n                rocketStorageA.setDeposit(_rethA);\n                rocketStorageA.setReth(_rethA);\n                _setETH(4000 ether);\n            }\n```\nTo run the test  use ```forge test -vvv --mt test_DeleteBridgeWithAsset```\n\n## Impact\nUser's deposited ```RETH``` or ```STETH``` in that bridge will be lost, as the user doesn't have the option to withdraw them. Because the withdraw functions can only be called trough the ```Diamond.sol```\n\n## Tools Used\nManual Review\n\n## Recommendations\nIn ```deleteBridge()``` make sure that the contract doesn't have any assets",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clm871gl00001mp081mzjdlwc",
  "Code": [
    {
      "filename": "contracts/facets/OwnerFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {STypes, MTypes, SR} from \"contracts/libraries/DataTypes.sol\";\nimport {LibDiamond} from \"contracts/libraries/LibDiamond.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract OwnerFacet is Modifiers {\n    using U256 for uint256;\n\n    /**\n     * @notice Initialize data for newly deployed market\n     * @dev Single use only\n     *\n     * @param asset The market that will be impacted\n     * @param a The market settings\n     */\n\n    /*\n     * @param oracle The oracle for the asset\n     * @param initialMargin Initial margin value of the new market\n     * @param primaryLiquidationCR Liquidation ratio (Maintenance margin) value of the new market\n     * @param secondaryLiquidationCR CRatio threshold for secondary liquidations\n     * @param forcedBidPriceBuffer Liquidation limit value of the new market\n     * @param minimumCR Lowest threshold for shortRecord to not lose collateral during liquidation\n     * @param resetLiquidationTime Time limit for when flagged shorts get reset\n     * @param secondLiquidationTime Time limit for when flagged shorts can be liquidated by others, not just flagger\n     * @param firstLiquidationTime Time limit for when flagged shorts get be liquidated by flagger\n     * @param tappFeePct Primary liquidation fee sent to TAPP out of shorter collateral\n     * @param callerFeePct Primary liquidation fee sent to margin caller out of shorter collateral\n     * @param minBidEth Minimum bid dust amount\n     * @param minAskEth Minimum ask dust amount\n     * @param minShortErc Minimum short record debt amount\n    */\n\n    function createMarket(address asset, STypes.Asset memory a) external onlyDAO {\n        STypes.Asset storage Asset = s.asset[asset];\n        // can check non-zero ORDER_ID to prevent creating same asset\n        if (Asset.orderId != 0) revert Errors.MarketAlreadyCreated();\n\n        Asset.vault = a.vault;\n        _setAssetOracle(asset, a.oracle);\n\n        Asset.assetId = uint8(s.assets.length);\n        s.assetMapping[s.assets.length] = asset;\n        s.assets.push(asset);\n\n        STypes.Order memory guardOrder;\n        guardOrder.prevId = Constants.HEAD;\n        guardOrder.id = Constants.HEAD;\n        guardOrder.nextId = Constants.TAIL;\n        //@dev parts of OB depend on having sell's HEAD's price and creationTime = 0\n        s.asks[asset][Constants.HEAD] = s.shorts[asset][Constants.HEAD] = guardOrder;\n\n        //@dev Using Bid's HEAD's order contain oracle data\n        guardOrder.creationTime = LibOrders.getOffsetTime();\n        guardOrder.ercAmount = uint80(LibOracle.getOraclePrice(asset));\n        s.bids[asset][Constants.HEAD] = guardOrder;\n\n        //@dev hardcoded value\n        Asset.orderId = Constants.STARTING_ID; // 100\n        Asset.startingShortId = Constants.HEAD;\n\n        //@dev comment with initial values\n        _setInitialMargin(asset, a.initialMargin); // 500 -> 5 ether\n        _setPrimaryLiquidationCR(asset, a.primaryLiquidationCR); // 400 -> 4 ether\n        _setSecondaryLiquidationCR(asset, a.secondaryLiquidationCR); // 150 -> 1.5 ether\n        _setForcedBidPriceBuffer(asset, a.forcedBidPriceBuffer); // 110 -> 1.1 ether\n        _setMinimumCR(asset, a.minimumCR); // 110 -> 1.1 ether\n        _setResetLiquidationTime(asset, a.resetLiquidationTime); // 1600 -> 16 hours\n        _setSecondLiquidationTime(asset, a.secondLiquidationTime); // 1200 -> 12 hours\n        _setFirstLiquidationTime(asset, a.firstLiquidationTime); // 1000 -> 10 hours\n        _setTappFeePct(asset, a.tappFeePct); //25 -> .025 ether\n        _setCallerFeePct(asset, a.callerFeePct); //5 -> .005 ether\n        _setMinBidEth(asset, a.minBidEth); //1 -> 0.001 ether\n        _setMinAskEth(asset, a.minAskEth); //1 -> 0.001 ether\n        _setMinShortErc(asset, a.minShortErc); //2000 -> 2000 ether\n\n        // Create TAPP short\n        LibShortRecord.createShortRecord(\n            asset, address(this), SR.FullyFilled, 0, 0, 0, 0, 0\n        );\n        emit Events.CreateMarket(asset, Asset);\n    }\n\n    //@dev does not need read only re-entrancy\n    function owner() external view returns (address) {\n        return LibDiamond.contractOwner();\n    }\n\n    function admin() external view returns (address) {\n        return s.admin;\n    }\n\n    //@dev does not need read only re-entrancy\n    function ownerCandidate() external view returns (address) {\n        return s.ownerCandidate;\n    }\n\n    function transferOwnership(address newOwner) external onlyDAO {\n        s.ownerCandidate = newOwner;\n        emit Events.NewOwnerCandidate(newOwner);\n    }\n\n    //@dev event emitted in setContractOwner\n    function claimOwnership() external {\n        if (s.ownerCandidate != msg.sender) revert Errors.NotOwnerCandidate();\n        LibDiamond.setContractOwner(msg.sender);\n        delete s.ownerCandidate;\n    }\n\n    //No need for claim step because DAO can also set admin\n    function transferAdminship(address newAdmin) external onlyAdminOrDAO {\n        s.admin = newAdmin;\n        emit Events.NewAdmin(newAdmin);\n    }\n\n    //When deactivating an asset make sure to zero out the oracle.\n    function setAssetOracle(address asset, address oracle) external onlyDAO {\n        _setAssetOracle(asset, oracle);\n        emit Events.UpdateAssetOracle(asset, oracle);\n    }\n\n    function createVault(\n        address zeth,\n        uint256 vault,\n        MTypes.CreateVaultParams calldata params\n    ) external onlyDAO {\n        if (s.zethVault[zeth] != 0) revert Errors.VaultAlreadyCreated();\n        s.zethVault[zeth] = vault;\n        _setTithe(vault, params.zethTithePercent);\n        _setDittoMatchedRate(vault, params.dittoMatchedRate);\n        _setDittoShorterRate(vault, params.dittoShorterRate);\n        emit Events.CreateVault(zeth, vault);\n    }\n\n    // Update eligibility requirements for yield accrual\n    function setTithe(uint256 vault, uint16 zethTithePercent) external onlyAdminOrDAO {\n        _setTithe(vault, zethTithePercent);\n        emit Events.ChangeVaultSetting(vault);\n    }\n\n    function setDittoMatchedRate(uint256 vault, uint16 rewardRate)\n        external\n        onlyAdminOrDAO\n    {\n        _setDittoMatchedRate(vault, rewardRate);\n        emit Events.ChangeVaultSetting(vault);\n    }\n\n    function setDittoShorterRate(uint256 vault, uint16 rewardRate)\n        external\n        onlyAdminOrDAO\n    {\n        _setDittoShorterRate(vault, rewardRate);\n        emit Events.ChangeVaultSetting(vault);\n    }\n\n    // For Short Record collateral ratios\n    // initialMargin > primaryLiquidationCR > secondaryLiquidationCR > minimumCR\n    // After initial market creation. Set CRs from smallest to largest to prevent triggering the require checks\n\n    function setInitialMargin(address asset, uint16 value) external onlyAdminOrDAO {\n        require(value > s.asset[asset].primaryLiquidationCR, \"below primary liquidation\");\n        _setInitialMargin(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setPrimaryLiquidationCR(address asset, uint16 value)\n        external\n        onlyAdminOrDAO\n    {\n        require(\n            value > s.asset[asset].secondaryLiquidationCR, \"below secondary liquidation\"\n        );\n        _setPrimaryLiquidationCR(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setSecondaryLiquidationCR(address asset, uint16 value)\n        external\n        onlyAdminOrDAO\n    {\n        _setSecondaryLiquidationCR(asset, value);\n        require(\n            LibAsset.secondaryLiquidationCR(asset) > LibAsset.minimumCR(asset),\n            \"below minimum CR\"\n        );\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setForcedBidPriceBuffer(address asset, uint8 value)\n        external\n        onlyAdminOrDAO\n    {\n        _setForcedBidPriceBuffer(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setMinimumCR(address asset, uint8 value) external onlyAdminOrDAO {\n        _setMinimumCR(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    // Used for Primary Margin Call\n    // resetLiquidationTime > secondLiquidationTime > firstLiquidationTime\n\n    function setResetLiquidationTime(address asset, uint16 value)\n        external\n        onlyAdminOrDAO\n    {\n        _setResetLiquidationTime(asset, value);\n        require(\n            value >= s.asset[asset].secondLiquidationTime, \"below secondLiquidationTime\"\n        );\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setSecondLiquidationTime(address asset, uint16 value)\n        external\n        onlyAdminOrDAO\n    {\n        _setSecondLiquidationTime(asset, value);\n        require(\n            value >= s.asset[asset].firstLiquidationTime, \"below firstLiquidationTime\"\n        );\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setFirstLiquidationTime(address asset, uint16 value)\n        external\n        onlyAdminOrDAO\n    {\n        _setFirstLiquidationTime(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setTappFeePct(address asset, uint8 value) external onlyAdminOrDAO {\n        _setTappFeePct(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setCallerFeePct(address asset, uint8 value) external onlyAdminOrDAO {\n        _setCallerFeePct(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setMinBidEth(address asset, uint8 value) external onlyAdminOrDAO {\n        _setMinBidEth(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setMinAskEth(address asset, uint8 value) external onlyAdminOrDAO {\n        _setMinAskEth(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setMinShortErc(address asset, uint16 value) external onlyAdminOrDAO {\n        _setMinShortErc(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function createBridge(\n        address bridge,\n        uint256 vault,\n        uint16 withdrawalFee,\n        uint8 unstakeFee\n    ) external onlyDAO {\n        s.vaultBridges[vault].push(bridge);\n        s.bridge[bridge].vault = uint8(vault);\n        _setWithdrawalFee(bridge, withdrawalFee);\n        _setUnstakeFee(bridge, unstakeFee);\n        emit Events.CreateBridge(bridge, s.bridge[bridge]);\n    }\n\n    function deleteBridge(address bridge) external onlyDAO {\n        uint256 vault = s.bridge[bridge].vault;\n        if (vault == 0) revert Errors.InvalidBridge();\n\n        address[] storage VaultBridges = s.vaultBridges[vault];\n        uint256 length = VaultBridges.length;\n        for (uint256 i; i < length; i++) {\n            if (VaultBridges[i] == bridge) {\n                if (i != length - 1) {\n                    VaultBridges[i] = VaultBridges[length - 1];\n                }\n                VaultBridges.pop();\n                break;\n            }\n        }\n        delete s.bridge[bridge];\n        emit Events.DeleteBridge(bridge);\n    }\n\n    function setWithdrawalFee(address bridge, uint16 withdrawalFee)\n        external\n        onlyAdminOrDAO\n    {\n        _setWithdrawalFee(bridge, withdrawalFee);\n        emit Events.ChangeBridgeSetting(bridge);\n    }\n\n    function setUnstakeFee(address bridge, uint8 unstakeFee) external onlyAdminOrDAO {\n        _setUnstakeFee(bridge, unstakeFee);\n        emit Events.ChangeBridgeSetting(bridge);\n    }\n\n    function _setAssetOracle(address asset, address oracle) private {\n        if (asset == address(0) || oracle == address(0)) revert Errors.ParameterIsZero();\n        s.asset[asset].oracle = oracle;\n    }\n\n    function _setTithe(uint256 vault, uint16 zethTithePercent) private {\n        if (zethTithePercent > 33_33) revert Errors.InvalidTithe();\n        s.vault[vault].zethTithePercent = zethTithePercent;\n    }\n\n    function _setDittoMatchedRate(uint256 vault, uint16 rewardRate) private {\n        require(rewardRate <= 100, \"above 100\");\n        s.vault[vault].dittoMatchedRate = rewardRate;\n    }\n\n    function _setDittoShorterRate(uint256 vault, uint16 rewardRate) private {\n        require(rewardRate <= 100, \"above 100\");\n        s.vault[vault].dittoShorterRate = rewardRate;\n    }\n\n    function _setInitialMargin(address asset, uint16 value) private {\n        require(value > 100, \"below 1.0\");\n        s.asset[asset].initialMargin = value;\n        require(LibAsset.initialMargin(asset) < Constants.CRATIO_MAX, \"above max CR\");\n    }\n\n    function _setPrimaryLiquidationCR(address asset, uint16 value) private {\n        require(value > 100, \"below 1.0\");\n        require(value <= 500, \"above 5.0\");\n        require(value < s.asset[asset].initialMargin, \"above initial margin\");\n        s.asset[asset].primaryLiquidationCR = value;\n    }\n\n    function _setSecondaryLiquidationCR(address asset, uint16 value) private {\n        require(value > 100, \"below 1.0\");\n        require(value <= 500, \"above 5.0\");\n        require(value < s.asset[asset].primaryLiquidationCR, \"above primary liquidation\");\n        s.asset[asset].secondaryLiquidationCR = value;\n    }\n\n    function _setForcedBidPriceBuffer(address asset, uint8 value) private {\n        require(value >= 100, \"below 1.0\");\n        require(value <= 200, \"above 2.0\");\n        s.asset[asset].forcedBidPriceBuffer = value;\n    }\n\n    function _setMinimumCR(address asset, uint8 value) private {\n        require(value >= 100, \"below 1.0\");\n        require(value <= 200, \"above 2.0\");\n        s.asset[asset].minimumCR = value;\n        require(\n            LibAsset.minimumCR(asset) < LibAsset.secondaryLiquidationCR(asset),\n            \"above secondary liquidation\"\n        );\n    }\n\n    // Used for Primary Margin Call\n    // resetLiquidationTime > secondLiquidationTime > firstLiquidationTime\n\n    function _setResetLiquidationTime(address asset, uint16 value) private {\n        require(value >= 100, \"below 1.00\");\n        require(value <= 4800, \"above 48.00\");\n        s.asset[asset].resetLiquidationTime = value;\n    }\n\n    function _setSecondLiquidationTime(address asset, uint16 value) private {\n        require(value >= 100, \"below 1.00\");\n        require(\n            value <= s.asset[asset].resetLiquidationTime, \"above resetLiquidationTime\"\n        );\n        s.asset[asset].secondLiquidationTime = value;\n    }\n\n    function _setFirstLiquidationTime(address asset, uint16 value) private {\n        require(value >= 100, \"below 1.00\");\n        require(\n            value <= s.asset[asset].secondLiquidationTime, \"above secondLiquidationTime\"\n        );\n        s.asset[asset].firstLiquidationTime = value;\n    }\n\n    function _setTappFeePct(address asset, uint8 value) private {\n        require(value > 0, \"Can't be zero\");\n        require(value <= 250, \"above 25.0\");\n        s.asset[asset].tappFeePct = value;\n    }\n\n    function _setCallerFeePct(address asset, uint8 value) private {\n        require(value > 0, \"Can't be zero\");\n        require(value <= 250, \"above 25.0\");\n        s.asset[asset].callerFeePct = value;\n    }\n\n    function _setMinBidEth(address asset, uint8 value) private {\n        //no upperboard check because uint8 max - 255\n        require(value > 0, \"Can't be zero\");\n        s.asset[asset].minBidEth = value;\n    }\n\n    function _setMinAskEth(address asset, uint8 value) private {\n        //no upperboard check because uint8 max - 255\n        require(value > 0, \"Can't be zero\");\n        s.asset[asset].minAskEth = value;\n    }\n\n    function _setMinShortErc(address asset, uint16 value) private {\n        //no upperboard check because uint8 max - 65,535\n        require(value > 0, \"Can't be zero\");\n        s.asset[asset].minShortErc = value;\n    }\n\n    function _setWithdrawalFee(address bridge, uint16 withdrawalFee) private {\n        require(withdrawalFee <= 1500, \"above 15.00%\");\n        s.bridge[bridge].withdrawalFee = withdrawalFee;\n    }\n\n    function _setUnstakeFee(address bridge, uint8 unstakeFee) private {\n        require(unstakeFee <= 250, \"above 2.50%\");\n        s.bridge[bridge].unstakeFee = unstakeFee;\n    }\n}"
    }
  ]
}