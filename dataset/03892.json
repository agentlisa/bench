{
  "Title": "No validation of the address parameter value in contract constructor",
  "Content": "##### Description\nThe variable is assigned the value of the constructor input parameter. But this parameter is not checked before this. If the value turns out to be zero, then it will be necessary to redeploy the contract, since there is no other functionality to set this variable.\n\n* At line https://github.com/sushiswap/bentobox/blob/c2e150b16b8764ebfe2e1e6e267ae14e10738065/contracts/BentoBox.sol#L46 the `WETH` variable is set to the value of the `WETH_` input parameter.\n* At line https://github.com/sushiswap/bentobox/blob/c2e150b16b8764ebfe2e1e6e267ae14e10738065/contracts/LendingPair.sol#L123 the `bentoBox` variable is set to the value of the `bentoBox__` input parameter.\n* At line https://github.com/sushiswap/bentobox/blob/c2e150b16b8764ebfe2e1e6e267ae14e10738065/contracts/swappers/SushiSwapSwapper.sol#L17 the `bentoBox` variable is set to the value of the `bentoBox_` input parameter.\n* At line https://github.com/sushiswap/bentobox/blob/c2e150b16b8764ebfe2e1e6e267ae14e10738065/contracts/swappers/SushiSwapSwapper.sol#L18 the `factory` variable is set to the value of the `factory_` input parameter.\n\n##### Recommendation\nIn all the cases, it is necessary to add a check of the input parameter to zero before initializing the variables.\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/BentoBox.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\n// The BentoBox\r\n\r\n//  ▄▄▄▄· ▄▄▄ . ▐ ▄ ▄▄▄▄▄      ▄▄▄▄·       ▐▄• ▄ \r\n//  ▐█ ▀█▪▀▄.▀·•█▌▐█•██  ▪     ▐█ ▀█▪▪      █▌█▌▪\r\n//  ▐█▀▀█▄▐▀▀▪▄▐█▐▐▌ ▐█.▪ ▄█▀▄ ▐█▀▀█▄ ▄█▀▄  ·██· \r\n//  ██▄▪▐█▐█▄▄▌██▐█▌ ▐█▌·▐█▌.▐▌██▄▪▐█▐█▌.▐▌▪▐█·█▌\r\n//  ·▀▀▀▀  ▀▀▀ ▀▀ █▪ ▀▀▀  ▀█▄▀▪·▀▀▀▀  ▀█▄▀▪•▀▀ ▀▀\r\n\r\n// This contract stores funds, handles their transfers.\r\n\r\n// Copyright (c) 2020 BoringCrypto - All rights reserved\r\n// Twitter: @Boring_Crypto\r\n\r\n// WARNING!!! DO NOT USE!!! BEING AUDITED!!!\r\n\r\n// solhint-disable no-inline-assembly\r\n// solhint-disable avoid-low-level-calls\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\nimport \"./libraries/BoringMath.sol\";\r\nimport \"./interfaces/IERC20.sol\";\r\nimport \"./interfaces/IWETH.sol\";\r\nimport \"./interfaces/IMasterContract.sol\";\r\n\r\ncontract BentoBox {\r\n    using BoringMath for uint256;\r\n    using BoringMath128 for uint128;\r\n\r\n    event LogDeploy(address indexed masterContract, bytes data, address indexed cloneAddress);\r\n    event LogSetMasterContractApproval(address indexed masterContract, address indexed user, bool indexed approved);\r\n    event LogDeposit(IERC20 indexed token, address indexed from, address indexed to, uint256 amount);\r\n    event LogWithdraw(IERC20 indexed token, address indexed from, address indexed to, uint256 amount);\r\n    event LogTransfer(IERC20 indexed token, address indexed from, address indexed to, uint256 amount);\r\n\r\n    mapping(address => address) public masterContractOf; // Mapping from clone contracts to their masterContract\r\n    mapping(address => mapping(address => bool)) public masterContractApproved; // masterContract to user to approval state\r\n    mapping(IERC20 => mapping(address => uint256)) public balanceOf; // Balance per token per address/contract\r\n    mapping(IERC20 => uint256) public totalSupply;\r\n    // solhint-disable-next-line var-name-mixedcase\r\n    IERC20 public immutable WETH;\r\n\r\n    // solhint-disable-next-line var-name-mixedcase\r\n    constructor(IERC20 WETH_) public {\r\n        WETH = WETH_;\r\n    }\r\n\r\n    // Deploys a given master Contract as a clone.\r\n    function deploy(address masterContract, bytes calldata data) public {\r\n        bytes20 targetBytes = bytes20(masterContract); // Takes the first 20 bytes of the masterContract's address\r\n        address cloneAddress; // Address where the clone contract will reside.\r\n\r\n        // Creates clone, more info here: https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract/\r\n        assembly {\r\n            let clone := mload(0x40)\r\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(clone, 0x14), targetBytes)\r\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            cloneAddress := create(0, clone, 0x37)\r\n        }\r\n        masterContractOf[cloneAddress] = masterContract;\r\n\r\n        IMasterContract(cloneAddress).init(data);\r\n\r\n        emit LogDeploy(masterContract, data, cloneAddress);\r\n    }\r\n\r\n    // *** Public actions *** //\r\n    function setMasterContractApproval(address masterContract, bool approved) public {\r\n        require(masterContract != address(0), \"BentoBox: masterContract not set\"); // Important for security\r\n        masterContractApproved[masterContract][msg.sender] = approved;\r\n        emit LogSetMasterContractApproval(masterContract, msg.sender, approved);\r\n    }\r\n\r\n    modifier allowed(address from) {\r\n        require(msg.sender == from || masterContractApproved[masterContractOf[msg.sender]][from], \"BentoBox: Transfer not approved\");\r\n        _;\r\n    }\r\n\r\n    function deposit(IERC20 token, address from, uint256 amount) public payable { depositTo(token, from, msg.sender, amount); }\r\n    function depositTo(IERC20 token, address from, address to, uint256 amount) public payable allowed(from) {\r\n        _deposit(token, from, to, amount);\r\n    }\r\n\r\n    function depositWithPermit(IERC20 token, address from, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public payable \r\n    { \r\n        depositWithPermitTo(token, from, msg.sender, amount, deadline, v, r, s); \r\n    }\r\n    function depositWithPermitTo(\r\n        IERC20 token, address from, address to, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s\r\n    ) public payable allowed(from) {\r\n        token.permit(from, address(this), amount, deadline, v, r, s);\r\n        _deposit(token, from, to, amount);\r\n    }\r\n\r\n    function withdraw(IERC20 token, address to, uint256 amount) public { withdrawFrom(token, msg.sender, to, amount); }\r\n    function withdrawFrom(IERC20 token, address from, address to, uint256 amount) public allowed(from) {\r\n        _withdraw(token, from, to, amount);\r\n    }\r\n\r\n    // *** Approved contract actions *** //\r\n    // Clones of master contracts can transfer from any account that has approved them\r\n    function transfer(IERC20 token, address to, uint256 amount) public { transferFrom(token, msg.sender, to, amount); }\r\n    function transferFrom(IERC20 token, address from, address to, uint256 amount) public allowed(from) {\r\n        require(to != address(0), \"BentoBox: to not set\"); // To avoid a bad UI from burning funds\r\n        balanceOf[token][from] = balanceOf[token][from].sub(amount);\r\n        balanceOf[token][to] = balanceOf[token][to].add(amount);\r\n\r\n        emit LogTransfer(token, from, to, amount);\r\n    }\r\n\r\n    function transferMultiple(IERC20 token, address[] calldata tos, uint256[] calldata amounts) public\r\n    {\r\n        transferMultipleFrom(token, msg.sender, tos, amounts);\r\n    }\r\n    function transferMultipleFrom(IERC20 token, address from, address[] calldata tos, uint256[] calldata amounts) public allowed(from) {\r\n        require(tos[0] != address(0), \"BentoBox: to[0] not set\"); // To avoid a bad UI from burning funds\r\n        uint256 totalAmount;\r\n        for (uint256 i=0; i < tos.length; i++) {\r\n            address to = tos[i];\r\n            balanceOf[token][to] = balanceOf[token][to].add(amounts[i]);\r\n            totalAmount = totalAmount.add(amounts[i]);\r\n            emit LogTransfer(token, from, to, amounts[i]);\r\n        }\r\n        balanceOf[token][from] = balanceOf[token][from].sub(totalAmount);\r\n    }\r\n\r\n    function skim(IERC20 token) public returns (uint256 amount) { amount = skimTo(token, msg.sender); }\r\n    function skimTo(IERC20 token, address to) public returns (uint256 amount) {\r\n        require(to != address(0), \"BentoBox: to not set\"); // To avoid a bad UI from burning funds\r\n        amount = token.balanceOf(address(this)).sub(totalSupply[token]);\r\n        balanceOf[token][to] = balanceOf[token][to].add(amount);\r\n        totalSupply[token] = totalSupply[token].add(amount);\r\n        emit LogDeposit(token, address(this), to, amount);\r\n    }\r\n\r\n    function skimETH() public returns (uint256 amount) { amount = skimETHTo(msg.sender); }\r\n    function skimETHTo(address to) public returns (uint256 amount) {\r\n        IWETH(address(WETH)).deposit{value: address(this).balance}();\r\n        amount = skimTo(WETH, to);\r\n    }\r\n\r\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns(bool[] memory successes, bytes[] memory results) {\r\n        successes = new bool[](calls.length);\r\n        results = new bytes[](calls.length);\r\n        for (uint256 i = 0; i < calls.length; i++) {\r\n            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);\r\n            require(success || !revertOnFail, \"BentoBox: Transaction failed\");\r\n            successes[i] = success;\r\n            results[i] = result;\r\n        }\r\n    }\r\n\r\n    // solhint-disable-next-line no-empty-blocks\r\n    receive() external payable {}\r\n\r\n    // *** Private functions *** //\r\n    function _deposit(IERC20 token, address from, address to, uint256 amount) private {\r\n        require(to != address(0), \"BentoBox: to not set\"); // To avoid a bad UI from burning funds\r\n        balanceOf[token][to] = balanceOf[token][to].add(amount);\r\n        uint256 supply = totalSupply[token];\r\n        totalSupply[token] = supply.add(amount);\r\n\r\n        if (address(token) == address(WETH)) {\r\n            IWETH(address(WETH)).deposit{value: amount}();\r\n        } else {\r\n            if (supply == 0) { // During the first deposit, we check that this token is 'real'\r\n                require(token.totalSupply() > 0, \"BentoBox: No tokens\");\r\n            }\r\n            (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0x23b872dd, from, address(this), amount));\r\n            require(success && (data.length == 0 || abi.decode(data, (bool))), \"BentoBox: TransferFrom failed\");\r\n        }\r\n        emit LogDeposit(token, from, to, amount);\r\n    }\r\n\r\n    function _withdraw(IERC20 token, address from, address to, uint256 amount) private {\r\n        require(to != address(0), \"BentoBox: to not set\"); // To avoid a bad UI from burning funds\r\n        balanceOf[token][from] = balanceOf[token][from].sub(amount);\r\n        totalSupply[token] = totalSupply[token].sub(amount);\r\n        if (address(token) == address(WETH)) {\r\n            IWETH(address(WETH)).withdraw(amount);\r\n            (bool success,) = to.call{value: amount}(new bytes(0));\r\n            require(success, \"BentoBox: ETH transfer failed\");\r\n        } else {\r\n            (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0xa9059cbb, to, amount));\r\n            require(success && (data.length == 0 || abi.decode(data, (bool))), \"BentoBox: Transfer failed\");\r\n        }\r\n        emit LogWithdraw(token, from, to, amount);\r\n    }\r\n}"
    },
    {
      "filename": "contracts/LendingPair.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\n// Medium Risk LendingPair\r\n\r\n// ▄▄▌  ▄▄▄ . ▐ ▄ ·▄▄▄▄  ▪   ▐ ▄  ▄▄ •  ▄▄▄· ▄▄▄· ▪  ▄▄▄\r\n// ██•  ▀▄.▀·•█▌▐███▪ ██ ██ •█▌▐█▐█ ▀ ▪▐█ ▄█▐█ ▀█ ██ ▀▄ █·\r\n// ██▪  ▐▀▀▪▄▐█▐▐▌▐█· ▐█▌▐█·▐█▐▐▌▄█ ▀█▄ ██▀·▄█▀▀█ ▐█·▐▀▀▄\r\n// ▐█▌▐▌▐█▄▄▌██▐█▌██. ██ ▐█▌██▐█▌▐█▄▪▐█▐█▪·•▐█ ▪▐▌▐█▌▐█•█▌\r\n// .▀▀▀  ▀▀▀ ▀▀ █▪▀▀▀▀▀• ▀▀▀▀▀ █▪·▀▀▀▀ .▀    ▀  ▀ ▀▀▀.▀  ▀\r\n\r\n// Copyright (c) 2020 BoringCrypto - All rights reserved\r\n// Twitter: @Boring_Crypto\r\n\r\n// Special thanks to:\r\n// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations\r\n\r\n// WARNING!!! DO NOT USE!!! BEING AUDITED!!!\r\n\r\n// solhint-disable avoid-low-level-calls\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./libraries/BoringMath.sol\";\r\nimport \"./interfaces/IOracle.sol\";\r\nimport \"./Ownable.sol\";\r\nimport \"./ERC20.sol\";\r\nimport \"./interfaces/IMasterContract.sol\";\r\nimport \"./interfaces/ISwapper.sol\";\r\nimport \"./interfaces/IWETH.sol\";\r\n\r\n// TODO: check all reentrancy paths\r\n// TODO: what to do when the entire pool is underwater?\r\n// TODO: check that all actions on a users funds can only be initiated by that user as msg.sender\r\n\r\ncontract LendingPair is ERC20, Ownable, IMasterContract {\r\n    using BoringMath for uint256;\r\n    using BoringMath128 for uint128;\r\n\r\n    // MasterContract variables\r\n    IBentoBox public immutable bentoBox;\r\n    LendingPair public immutable masterContract;\r\n    address public feeTo;\r\n    address public dev;\r\n    mapping(ISwapper => bool) public swappers;\r\n\r\n    // Per clone variables\r\n    // Clone settings\r\n    IERC20 public collateral;\r\n    IERC20 public asset;\r\n    IOracle public oracle;\r\n    bytes public oracleData;\r\n\r\n    // User balances\r\n    mapping(address => uint256) public userCollateralAmount;\r\n    // userAssetFraction is called balanceOf for ERC20 compatibility\r\n    mapping(address => uint256) public userBorrowFraction;\r\n\r\n    struct TokenTotals {\r\n        uint128 amount;\r\n        uint128 fraction;\r\n    }\r\n\r\n    // Total amounts\r\n    uint256 public totalCollateralAmount;\r\n    TokenTotals public totalAsset; // The total assets belonging to the suppliers (including any borrowed amounts).\r\n    TokenTotals public totalBorrow; // Total units of asset borrowed\r\n\r\n    // totalSupply for ERC20 compatibility\r\n    function totalSupply() public view returns(uint256) {\r\n        return totalAsset.fraction;\r\n    }\r\n\r\n    // Exchange and interest rate tracking\r\n    uint256 public exchangeRate;\r\n\r\n    struct AccrueInfo {\r\n        uint64 interestPerBlock;\r\n        uint64 lastBlockAccrued;\r\n        uint128 feesPendingAmount;\r\n    }\r\n    AccrueInfo public accrueInfo;\r\n\r\n    // ERC20 'variables'\r\n    function symbol() public view returns(string memory) {\r\n        (bool success, bytes memory data) = address(asset).staticcall(abi.encodeWithSelector(0x95d89b41));\r\n        string memory assetSymbol = success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\r\n\r\n        (success, data) = address(collateral).staticcall(abi.encodeWithSelector(0x95d89b41));\r\n        string memory collateralSymbol = success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\r\n\r\n        return string(abi.encodePacked(\"bm\", collateralSymbol, \">\", assetSymbol, \"-\", oracle.symbol(oracleData)));\r\n    }\r\n\r\n    function name() public view returns(string memory) {\r\n        (bool success, bytes memory data) = address(asset).staticcall(abi.encodeWithSelector(0x06fdde03));\r\n        string memory assetName = success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\r\n\r\n        (success, data) = address(collateral).staticcall(abi.encodeWithSelector(0x06fdde03));\r\n        string memory collateralName = success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\r\n\r\n        return string(abi.encodePacked(\"Bento Med Risk \", collateralName, \">\", assetName, \"-\", oracle.symbol(oracleData)));\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        (bool success, bytes memory data) = address(asset).staticcall(abi.encodeWithSelector(0x313ce567));\r\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\r\n    }\r\n\r\n    event LogExchangeRate(uint256 rate);\r\n    event LogAccrue(uint256 accruedAmount, uint256 feeAmount, uint256 rate, uint256 utilization);\r\n    event LogAddCollateral(address indexed user, uint256 amount);\r\n    event LogAddAsset(address indexed user, uint256 amount, uint256 fraction);\r\n    event LogAddBorrow(address indexed user, uint256 amount, uint256 fraction);\r\n    event LogRemoveCollateral(address indexed user, uint256 amount);\r\n    event LogRemoveAsset(address indexed user, uint256 amount, uint256 fraction);\r\n    event LogRemoveBorrow(address indexed user, uint256 amount, uint256 fraction);\r\n    event LogFeeTo(address indexed newFeeTo);\r\n    event LogDev(address indexed newDev);\r\n    event LogWithdrawFees();\r\n\r\n    constructor(IBentoBox bentoBox_) public {\r\n        bentoBox = bentoBox_;\r\n        masterContract = LendingPair(this);\r\n        dev = msg.sender;\r\n        feeTo = msg.sender;\r\n        emit LogDev(msg.sender);\r\n        emit LogFeeTo(msg.sender);\r\n    }\r\n\r\n    // Settings for the Medium Risk LendingPair\r\n    uint256 public constant CLOSED_COLLATERIZATION_RATE = 75000; // 75%\r\n    uint256 public constant OPEN_COLLATERIZATION_RATE = 77000; // 77%\r\n    uint256 public constant MINIMUM_TARGET_UTILIZATION = 7e17; // 70%\r\n    uint256 public constant MAXIMUM_TARGET_UTILIZATION = 8e17; // 80%\r\n\r\n    uint256 public constant STARTING_INTEREST_PER_BLOCK = 4566210045; // approx 1% APR\r\n    uint256 public constant MINIMUM_INTEREST_PER_BLOCK = 1141552511; // approx 0.25% APR\r\n    uint256 public constant MAXIMUM_INTEREST_PER_BLOCK = 4566210045000;  // approx 1000% APR\r\n    uint256 public constant INTEREST_ELASTICITY = 2000e36; // Half or double in 2000 blocks (approx 8 hours)\r\n\r\n    uint256 public constant LIQUIDATION_MULTIPLIER = 112000; // add 12%\r\n\r\n    // Fees\r\n    uint256 public constant PROTOCOL_FEE = 10000; // 10%\r\n    uint256 public constant DEV_FEE = 10000; // 10% of the PROTOCOL_FEE = 1%\r\n    uint256 public constant BORROW_OPENING_FEE = 50; // 0.05%\r\n\r\n    // Serves as the constructor, as clones can't have a regular constructor\r\n    function init(bytes calldata data) public override {\r\n        require(address(collateral) == address(0), \"LendingPair: already initialized\");\r\n        (collateral, asset, oracle, oracleData) = abi.decode(data, (IERC20, IERC20, IOracle, bytes));\r\n\r\n        accrueInfo.interestPerBlock = uint64(STARTING_INTEREST_PER_BLOCK);  // 1% APR, with 1e18 being 100%\r\n        updateExchangeRate();\r\n    }\r\n\r\n    function getInitData(IERC20 collateral_, IERC20 asset_, IOracle oracle_, bytes calldata oracleData_) public pure returns(bytes memory data) {\r\n        return abi.encode(collateral_, asset_, oracle_, oracleData_);\r\n    }\r\n\r\n    // Accrues the interest on the borrowed tokens and handles the accumulation of fees\r\n    function accrue() public {\r\n        AccrueInfo memory info = accrueInfo;\r\n        // Number of blocks since accrue was called\r\n        uint256 blocks = block.number - info.lastBlockAccrued;\r\n        if (blocks == 0) {return;}\r\n        info.lastBlockAccrued = uint64(block.number);\r\n\r\n        uint256 extraAmount;\r\n        uint256 feeAmount;\r\n\r\n        TokenTotals memory _totalBorrow = totalBorrow;\r\n        TokenTotals memory _totalAsset = totalAsset;\r\n        if (_totalBorrow.amount > 0) {\r\n            // Accrue interest\r\n            extraAmount = uint256(_totalBorrow.amount).mul(info.interestPerBlock).mul(blocks) / 1e18;\r\n            feeAmount = extraAmount.mul(PROTOCOL_FEE) / 1e5; // % of interest paid goes to fee\r\n            _totalBorrow.amount = _totalBorrow.amount.add(extraAmount.to128());\r\n            totalBorrow = _totalBorrow;\r\n            _totalAsset.amount = _totalAsset.amount.add(extraAmount.sub(feeAmount).to128());\r\n            totalAsset = _totalAsset;\r\n            info.feesPendingAmount = info.feesPendingAmount.add(feeAmount.to128());\r\n        }\r\n\r\n        if (_totalAsset.amount == 0) {\r\n            if (info.interestPerBlock != STARTING_INTEREST_PER_BLOCK) {\r\n                info.interestPerBlock = uint64(STARTING_INTEREST_PER_BLOCK);\r\n                emit LogAccrue(extraAmount, feeAmount, STARTING_INTEREST_PER_BLOCK, 0);\r\n            }\r\n            accrueInfo = info; return;\r\n        }\r\n\r\n        // Update interest rate\r\n        uint256 utilization = uint256(_totalBorrow.amount).mul(1e18) / _totalAsset.amount;\r\n        uint256 newInterestPerBlock;\r\n        if (utilization < MINIMUM_TARGET_UTILIZATION) {\r\n            uint256 underFactor = MINIMUM_TARGET_UTILIZATION.sub(utilization).mul(1e18) / MINIMUM_TARGET_UTILIZATION;\r\n            uint256 scale = INTEREST_ELASTICITY.add(underFactor.mul(underFactor).mul(blocks));\r\n            newInterestPerBlock = uint256(info.interestPerBlock).mul(INTEREST_ELASTICITY) / scale;\r\n            if (newInterestPerBlock < MINIMUM_INTEREST_PER_BLOCK) {newInterestPerBlock = MINIMUM_INTEREST_PER_BLOCK;} // 0.25% APR minimum\r\n       } else if (utilization > MAXIMUM_TARGET_UTILIZATION) {\r\n            uint256 overFactor = utilization.sub(MAXIMUM_TARGET_UTILIZATION).mul(1e18) / uint256(1e18).sub(MAXIMUM_TARGET_UTILIZATION);\r\n            uint256 scale = INTEREST_ELASTICITY.add(overFactor.mul(overFactor).mul(blocks));\r\n            newInterestPerBlock = uint256(info.interestPerBlock).mul(scale) / INTEREST_ELASTICITY;\r\n            if (newInterestPerBlock > MAXIMUM_INTEREST_PER_BLOCK) {newInterestPerBlock = MAXIMUM_INTEREST_PER_BLOCK;} // 1000% APR maximum\r\n        } else {\r\n            emit LogAccrue(extraAmount, feeAmount, info.interestPerBlock, utilization);\r\n            accrueInfo = info; return;\r\n        }\r\n\r\n        info.interestPerBlock = uint64(newInterestPerBlock);\r\n        emit LogAccrue(extraAmount, feeAmount, newInterestPerBlock, utilization);\r\n        accrueInfo = info;\r\n    }\r\n\r\n    // Checks if the user is solvent.\r\n    // Has an option to check if the user is solvent in an open/closed liquidation case.\r\n    function isSolvent(address user, bool open) public view returns (bool) {\r\n        // accrue must have already been called!\r\n        if (userBorrowFraction[user] == 0) return true;\r\n        if (totalCollateralAmount == 0) return false;\r\n\r\n        TokenTotals memory _totalBorrow = totalBorrow;\r\n\r\n        return userCollateralAmount[user].mul(1e13).mul(open ? OPEN_COLLATERIZATION_RATE : CLOSED_COLLATERIZATION_RATE)\r\n            >= (userBorrowFraction[user].mul(_totalBorrow.amount) / _totalBorrow.fraction).mul(exchangeRate);\r\n    }\r\n\r\n    function peekExchangeRate() public view returns (bool, uint256) {\r\n        return oracle.peek(oracleData);\r\n    }\r\n\r\n    // Gets the exchange rate. How much collateral to buy 1e18 asset.\r\n    function updateExchangeRate() public returns (uint256) {\r\n        (bool success, uint256 rate) = oracle.get(oracleData);\r\n\r\n        // TODO: How to deal with unsuccessful fetch\r\n        if (success) {\r\n            exchangeRate = rate;\r\n            emit LogExchangeRate(rate);\r\n        }\r\n        return exchangeRate;\r\n    }\r\n\r\n    // Handles internal variable updates when collateral is deposited\r\n    function _addCollateralAmount(address user, uint256 amount) private {\r\n        // Adds this amount to user\r\n        userCollateralAmount[user] = userCollateralAmount[user].add(amount);\r\n        // Adds the amount deposited to the total of collateral\r\n        totalCollateralAmount = totalCollateralAmount.add(amount);\r\n        emit LogAddCollateral(msg.sender, amount);\r\n    }\r\n\r\n    // Handles internal variable updates when supply (the borrowable token) is deposited\r\n    function _addAssetAmount(address user, uint256 amount) private {\r\n        TokenTotals memory _totalAsset = totalAsset;\r\n        // Calculates what amount of the pool the user gets for the amount deposited\r\n        uint256 newFraction = _totalAsset.fraction == 0 ? amount : amount.mul(_totalAsset.fraction) / _totalAsset.amount;\r\n        // Adds this amount to user\r\n        balanceOf[user] = balanceOf[user].add(newFraction);\r\n        // Adds this amount to the total of supply amounts\r\n        _totalAsset.fraction = _totalAsset.fraction.add(newFraction.to128());\r\n        // Adds the amount deposited to the total of supply\r\n        _totalAsset.amount = _totalAsset.amount.add(amount.to128());\r\n        totalAsset = _totalAsset;\r\n        emit LogAddAsset(msg.sender, amount, newFraction);\r\n    }\r\n\r\n    // Handles internal variable updates when supply (the borrowable token) is borrowed\r\n    function _addBorrowAmount(address user, uint256 amount) private {\r\n        TokenTotals memory _totalBorrow = totalBorrow;\r\n        // Calculates what amount of the borrowed funds the user gets for the amount borrowed\r\n        uint256 newFraction = _totalBorrow.fraction == 0 ? amount : amount.mul(_totalBorrow.fraction) / _totalBorrow.amount;\r\n        // Adds this amount to the user\r\n        userBorrowFraction[user] = userBorrowFraction[user].add(newFraction);\r\n        // Adds amount borrowed to the total amount borrowed\r\n        _totalBorrow.fraction = _totalBorrow.fraction.add(newFraction.to128());\r\n        // Adds amount borrowed to the total amount borrowed\r\n        _totalBorrow.amount = _totalBorrow.amount.add(amount.to128());\r\n        totalBorrow = _totalBorrow;\r\n        emit LogAddBorrow(msg.sender, amount, newFraction);\r\n    }\r\n\r\n    // Handles internal variable updates when collateral is withdrawn and returns the amount of collateral withdrawn\r\n    function _removeCollateralAmount(address user, uint256 amount) private {\r\n        // Subtracts the amount from user\r\n        userCollateralAmount[user] = userCollateralAmount[user].sub(amount);\r\n        // Subtracts the amount from the total of collateral\r\n        totalCollateralAmount = totalCollateralAmount.sub(amount);\r\n        emit LogRemoveCollateral(msg.sender, amount);\r\n    }\r\n\r\n    // Handles internal variable updates when supply is withdrawn and returns the amount of supply withdrawn\r\n    function _removeAssetFraction(address user, uint256 fraction) private returns (uint256 amount) {\r\n        TokenTotals memory _totalAsset = totalAsset;\r\n        // Subtracts the fraction from user\r\n        balanceOf[user] = balanceOf[user].sub(fraction);\r\n        // Calculates the amount of tokens to withdraw\r\n        amount = fraction.mul(_totalAsset.amount) / _totalAsset.fraction;\r\n        // Subtracts the calculated fraction from the total of supply\r\n        _totalAsset.fraction = _totalAsset.fraction.sub(fraction.to128());\r\n        // Subtracts the amount from the total of supply amounts\r\n        _totalAsset.amount = _totalAsset.amount.sub(amount.to128());\r\n        totalAsset = _totalAsset;\r\n        emit LogRemoveAsset(msg.sender, amount, fraction);\r\n    }\r\n\r\n    // Handles internal variable updates when supply is repaid\r\n    function _removeBorrowFraction(address user, uint256 fraction) private returns (uint256 amount) {\r\n        TokenTotals memory _totalBorrow = totalBorrow;\r\n        // Subtracts the fraction from user\r\n        userBorrowFraction[user] = userBorrowFraction[user].sub(fraction);\r\n        // Calculates the amount of tokens to repay\r\n        amount = fraction.mul(_totalBorrow.amount) / _totalBorrow.fraction;\r\n        // Subtracts the fraction from the total of amounts borrowed\r\n        _totalBorrow.fraction = _totalBorrow.fraction.sub(fraction.to128());\r\n        // Subtracts the calculated amount from the total amount borrowed\r\n        _totalBorrow.amount = _totalBorrow.amount.sub(amount.to128());\r\n        totalBorrow = _totalBorrow;\r\n        emit LogRemoveBorrow(msg.sender, amount, fraction);\r\n    }\r\n\r\n    // Deposits an amount of collateral from the caller\r\n    function addCollateral(uint256 amount) public payable { addCollateralTo(amount, msg.sender); }\r\n    function addCollateralTo(uint256 amount, address to) public payable {\r\n        _addCollateralAmount(to, amount);\r\n        bentoBox.deposit{value: msg.value}(collateral, msg.sender, amount);\r\n    }\r\n\r\n    function addCollateralFromBento(uint256 amount) public { addCollateralFromBentoTo(amount, msg.sender); }\r\n    function addCollateralFromBentoTo(uint256 amount, address to) public {\r\n        _addCollateralAmount(to, amount);\r\n        bentoBox.transferFrom(collateral, msg.sender, address(this), amount);\r\n    }\r\n\r\n    // Deposits an amount of supply (the borrowable token) from the caller\r\n    function addAsset(uint256 amount) public payable { addAssetTo(amount, msg.sender); }\r\n    function addAssetTo(uint256 amount, address to) public payable {\r\n        // Accrue interest before calculating pool amounts in _addAssetAmount\r\n        accrue();\r\n        _addAssetAmount(to, amount);\r\n        bentoBox.deposit{value: msg.value}(asset, msg.sender, amount);\r\n    }\r\n\r\n    function addAssetFromBento(uint256 amount) public payable { addAssetFromBentoTo(amount, msg.sender); }\r\n    function addAssetFromBentoTo(uint256 amount, address to) public payable {\r\n        // Accrue interest before calculating pool amounts in _addAssetAmount\r\n        accrue();\r\n        _addAssetAmount(to, amount);\r\n        bentoBox.transferFrom(asset, msg.sender, address(this), amount);\r\n    }\r\n\r\n    // Withdraws a amount of collateral of the caller to the specified address\r\n    function removeCollateral(uint256 amount, address to) public {\r\n        accrue();\r\n        _removeCollateralAmount(msg.sender, amount);\r\n        // Only allow withdrawing if user is solvent (in case of a closed liquidation)\r\n        require(isSolvent(msg.sender, false), \"LendingPair: user insolvent\");\r\n        bentoBox.withdraw(collateral, to, amount);\r\n    }\r\n\r\n    function removeCollateralToBento(uint256 amount, address to) public {\r\n        accrue();\r\n        _removeCollateralAmount(msg.sender, amount);\r\n        // Only allow withdrawing if user is solvent (in case of a closed liquidation)\r\n        require(isSolvent(msg.sender, false), \"LendingPair: user insolvent\");\r\n        bentoBox.transfer(collateral, to, amount);\r\n    }\r\n\r\n    // Withdraws a amount of supply (the borrowable token) of the caller to the specified address\r\n    function removeAsset(uint256 fraction, address to) public {\r\n        // Accrue interest before calculating pool amounts in _removeAssetFraction\r\n        accrue();\r\n        uint256 amount = _removeAssetFraction(msg.sender, fraction);\r\n        bentoBox.withdraw(asset, to, amount);\r\n    }\r\n\r\n    function removeAssetToBento(uint256 fraction, address to) public {\r\n        // Accrue interest before calculating pool amounts in _removeAssetFraction\r\n        accrue();\r\n        uint256 amount = _removeAssetFraction(msg.sender, fraction);\r\n        bentoBox.transfer(asset, to, amount);\r\n    }\r\n\r\n    // Borrows the given amount from the supply to the specified address\r\n    function borrow(uint256 amount, address to) public {\r\n        accrue();\r\n        uint256 feeAmount = amount.mul(BORROW_OPENING_FEE) / 1e5; // A flat % fee is charged for any borrow\r\n        _addBorrowAmount(msg.sender, amount.add(feeAmount));\r\n        totalAsset.amount = totalAsset.amount.add(feeAmount.to128());\r\n        bentoBox.withdraw(asset, to, amount);\r\n        require(isSolvent(msg.sender, false), \"LendingPair: user insolvent\");\r\n    }\r\n\r\n    function borrowToBento(uint256 amount, address to) public {\r\n        accrue();\r\n        uint256 feeAmount = amount.mul(BORROW_OPENING_FEE) / 1e5; // A flat % fee is charged for any borrow\r\n        _addBorrowAmount(msg.sender, amount.add(feeAmount));\r\n        totalAsset.amount = totalAsset.amount.add(feeAmount.to128());\r\n        bentoBox.transfer(asset, to, amount);\r\n        require(isSolvent(msg.sender, false), \"LendingPair: user insolvent\");\r\n    }\r\n\r\n    // Repays the given fraction\r\n    function repay(uint256 fraction) public { repayFor(fraction, msg.sender); }\r\n    function repayFor(uint256 fraction, address beneficiary) public {\r\n        accrue();\r\n        uint256 amount = _removeBorrowFraction(beneficiary, fraction);\r\n        bentoBox.deposit(asset, msg.sender, amount);\r\n    }\r\n\r\n    function repayFromBento(uint256 fraction) public { repayFromBentoTo(fraction, msg.sender); }\r\n    function repayFromBentoTo(uint256 fraction, address beneficiary) public {\r\n        accrue();\r\n        uint256 amount = _removeBorrowFraction(beneficiary, fraction);\r\n        bentoBox.transferFrom(asset, msg.sender, address(this), amount);\r\n    }\r\n\r\n    // Handles shorting with an approved swapper\r\n    function short(ISwapper swapper, uint256 assetAmount, uint256 minCollateralAmount) public {\r\n        require(masterContract.swappers(swapper), \"LendingPair: Invalid swapper\");\r\n        accrue();\r\n        _addBorrowAmount(msg.sender, assetAmount);\r\n        bentoBox.transferFrom(asset, address(this), address(swapper), assetAmount);\r\n\r\n        // Swaps the borrowable asset for collateral\r\n        swapper.swap(asset, collateral, assetAmount, minCollateralAmount);\r\n        uint256 returnedCollateralAmount = bentoBox.skim(collateral); // TODO: Reentrancy issue? Should we take a before and after balance?\r\n        require(returnedCollateralAmount >= minCollateralAmount, \"LendingPair: not enough\");\r\n        _addCollateralAmount(msg.sender, returnedCollateralAmount);\r\n\r\n        require(isSolvent(msg.sender, false), \"LendingPair: user insolvent\");\r\n    }\r\n\r\n    // Handles unwinding shorts with an approved swapper\r\n    function unwind(ISwapper swapper, uint256 borrowFraction, uint256 maxAmountCollateral) public {\r\n        require(masterContract.swappers(swapper), \"LendingPair: Invalid swapper\");\r\n        accrue();\r\n        bentoBox.transferFrom(collateral, address(this), address(swapper), maxAmountCollateral);\r\n\r\n        uint256 borrowAmount = _removeBorrowFraction(msg.sender, borrowFraction);\r\n\r\n        // Swaps the collateral back for the borrowal asset\r\n        uint256 usedAmount = swapper.swapExact(collateral, asset, maxAmountCollateral, borrowAmount, address(this));\r\n        uint256 returnedAssetAmount = bentoBox.skim(asset); // TODO: Reentrancy issue? Should we take a before and after balance?\r\n        require(returnedAssetAmount >= borrowAmount, \"LendingPair: Not enough\");\r\n\r\n        _removeCollateralAmount(msg.sender, maxAmountCollateral.sub(usedAmount));\r\n\r\n        require(isSolvent(msg.sender, false), \"LendingPair: user insolvent\");\r\n    }\r\n\r\n    // Handles the liquidation of users' balances, once the users' amount of collateral is too low\r\n    function liquidate(address[] calldata users, uint256[] calldata borrowFractions, address to, ISwapper swapper, bool open) public {\r\n        accrue();\r\n        updateExchangeRate();\r\n\r\n        uint256 allCollateralAmount;\r\n        uint256 allBorrowAmount;\r\n        uint256 allBorrowFraction;\r\n        TokenTotals memory _totalBorrow = totalBorrow;\r\n        for (uint256 i = 0; i < users.length; i++) {\r\n            address user = users[i];\r\n            if (!isSolvent(user, open)) {\r\n                // Gets the user's amount of the total borrowed amount\r\n                uint256 borrowFraction = borrowFractions[i];\r\n                // Calculates the user's amount borrowed"
    }
  ]
}