{
  "Title": "[M-15] Zero strike call options will avoid paying system fee",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L494-L506\n\n\n# Vulnerability details\n\nZero and near zero strike calls are common derivative type. For such derivatives the system will not be receiving fees are the fee is now formulated as a fraction of order strike.\n\nAlso, it can be a problem for OTM call options, when the option itself is nearly worthless, while the fee will be substantial as strike will be big. Say 1k ETH BAYC call doesn't have much value, but the associated fee will be 10x of usual fee, i.e. substantial, while there is nothing to justify that.\n\nMarking this as medium severity as that's a design specifics that can turn off or distort core system fee gathering.\n\n## Proof of Concept\n\nCurrently fee is linked to the order strike which makes it vary heavily for different types of orders, for example deep ITM and OTM calls:\n\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L494-L506\n\n```solidity\n        // transfer strike to owner if put is expired or call is exercised\n        if ((order.isCall && isExercised) || (!order.isCall && !isExercised)) {\n            // send the fee to the admin/DAO if fee is greater than 0%\n            uint256 feeAmount = 0;\n            if (fee > 0) {\n                feeAmount = (order.strike * fee) / 1000;\n                ERC20(order.baseAsset).safeTransfer(owner(), feeAmount);\n            }\n\n            ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount);\n\n            return;\n        }\n```\n\n## Recommended Mitigation Steps\n\nConsider linking the fee to option premium as this is option value that cannot be easily manipulated and exactly corresponds to the trading volume of the system.\n\nI.e. consider moving fee gathering to fillOrder:\n\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L322-L340\n\n```solidity\n        // transfer premium to whoever is short from whomever is long\n        if (order.isLong) {\n            ERC20(order.baseAsset).safeTransferFrom(order.maker, msg.sender, order.premium);\n        } else {\n            // handle the case where the user uses native ETH instead of WETH to pay the premium\n            if (weth == order.baseAsset && msg.value > 0) {\n                // check enough ETH was sent to cover the premium\n                require(msg.value == order.premium, \"Incorrect ETH amount sent\");\n\n                // convert ETH to WETH and send premium to maker\n                // converting to WETH instead of forwarding native ETH to the maker has two benefits;\n                // 1) active market makers will mostly be using WETH not native ETH\n                // 2) attack surface for re-entrancy is reduced\n                IWETH(weth).deposit{value: msg.value}();\n                IWETH(weth).transfer(order.maker, msg.value);\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, order.maker, order.premium);\n            }\n        }\n```\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-06-putty-contest",
  "Code": [
    {
      "filename": "contracts/src/PuttyV2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n/**\n\n    ██████╗ ██╗   ██╗████████╗████████╗██╗   ██╗    ██╗   ██╗██████╗ \n    ██╔══██╗██║   ██║╚══██╔══╝╚══██╔══╝╚██╗ ██╔╝    ██║   ██║╚════██╗\n    ██████╔╝██║   ██║   ██║      ██║    ╚████╔╝     ██║   ██║ █████╔╝\n    ██╔═══╝ ██║   ██║   ██║      ██║     ╚██╔╝      ╚██╗ ██╔╝██╔═══╝ \n    ██║     ╚██████╔╝   ██║      ██║      ██║        ╚████╔╝ ███████╗\n    ╚═╝      ╚═════╝    ╚═╝      ╚═╝      ╚═╝         ╚═══╝  ╚══════╝\n    \n                                \n            _..._               \n          .'     '.      _       \n         /    .-\"\"-\\   _/ \\ \n       .-|   /:.   |  |   |   bussin\n       |  \\  |:.   /.-'-./\n       | .-'-;:__.'    =/\n       .'=  *=|     _.='\n      /   _.  |    ;        minister you satoshi\n     ;-.-'|    \\   |\n    /   | \\    _\\  _\\\n    \\__/'._;.  ==' ==\\\n             \\    \\   |\n             /    /   / \n             /-._/-._/\n      jgs    \\   `\\  \\\n              `-._/._/\n\n\n    this is a public good.\n    by out.eth and tamagoyaki\n    \n */\n\nimport \"./lib/IWETH.sol\";\n\nimport \"openzeppelin/utils/cryptography/SignatureChecker.sol\";\nimport \"openzeppelin/utils/cryptography/draft-EIP712.sol\";\nimport \"openzeppelin/utils/Strings.sol\";\nimport \"openzeppelin/access/Ownable.sol\";\nimport \"solmate/utils/SafeTransferLib.sol\";\nimport \"solmate/tokens/ERC721.sol\";\n\nimport \"./PuttyV2Nft.sol\";\n\n/**\n    @title PuttyV2\n    @author out.eth\n    @notice An otc erc721 and erc20 option market.\n */\ncontract PuttyV2 is PuttyV2Nft, EIP712(\"Putty\", \"2.0\"), ERC721TokenReceiver, Ownable {\n    /* ~~~ TYPES ~~~ */\n\n    using SafeTransferLib for ERC20;\n\n    struct ERC20Asset {\n        address token;\n        uint256 tokenAmount;\n    }\n\n    struct ERC721Asset {\n        address token;\n        uint256 tokenId;\n    }\n\n    struct Order {\n        address maker;\n        bool isCall;\n        bool isLong;\n        address baseAsset;\n        uint256 strike;\n        uint256 premium;\n        uint256 duration;\n        uint256 expiration;\n        uint256 nonce;\n        address[] whitelist;\n        address[] floorTokens;\n        ERC20Asset[] erc20Assets;\n        ERC721Asset[] erc721Assets;\n    }\n\n    /* ~~~ STATE VARIABLES ~~~ */\n\n    /**\n        @dev ERC721Asset type hash used for EIP-712 encoding.\n     */\n    bytes32 public constant ERC721ASSET_TYPE_HASH =\n        keccak256(abi.encodePacked(\"ERC721Asset(address token,uint256 tokenId)\"));\n\n    /**\n        @dev ERC20Asset type hash used for EIP-712 encoding.\n     */\n    bytes32 public constant ERC20ASSET_TYPE_HASH =\n        keccak256(abi.encodePacked(\"ERC20Asset(address token,uint256 tokenAmount)\"));\n\n    /**\n        @dev ERC721Asset type hash used for EIP-712 encoding.\n     */\n    bytes32 public constant ORDER_TYPE_HASH =\n        keccak256(\n            abi.encodePacked(\n                \"Order(\",\n                \"address maker,\",\n                \"bool isCall,\",\n                \"bool isLong,\",\n                \"address baseAsset,\",\n                \"uint256 strike,\",\n                \"uint256 premium,\",\n                \"uint256 duration,\",\n                \"uint256 expiration,\",\n                \"uint256 nonce,\",\n                \"address[] whitelist,\",\n                \"address[] floorTokens,\",\n                \"ERC20Asset[] erc20Assets,\",\n                \"ERC721Asset[] erc721Assets\",\n                \")\",\n                \"ERC20Asset(address token,uint256 tokenAmount)\",\n                \"ERC721Asset(address token,uint256 tokenId)\"\n            )\n        );\n\n    /**\n        @dev Contract address for Wrapped Ethereum.\n     */\n    address public immutable weth;\n\n    /**\n        @dev baseURI used to generate the tokenURI for PuttyV2 NFTs.\n    */\n    string public baseURI;\n\n    /**\n        @notice Fee rate that is applied on exercise.\n    */\n    uint256 public fee;\n\n    /**\n        @notice Whether or not an order has been cancelled. Maps \n                from orderHash to isCancelled.\n    */\n    mapping(bytes32 => bool) public cancelledOrders;\n\n    /**\n        @notice The current expiration timestamp of a position. Maps \n                from positionId to an expiration unix timestamp.\n    */\n    mapping(uint256 => uint256) public positionExpirations;\n\n    /**\n        @notice Whether or not a position has been exercised. Maps \n                from positionId to isExercised.\n    */\n    mapping(uint256 => bool) public exercisedPositions;\n\n    /**\n        @notice The floor asset token ids for a position. Maps from \n                positionId to floor asset token ids. This should only \n                be set for a long call position in `fillOrder`, or for \n                a short put position in `exercise`.\n    */\n    mapping(uint256 => uint256[]) public positionFloorAssetTokenIds;\n\n    /* ~~~ EVENTS ~~~ */\n\n    /**\n        @notice Emitted when a new base URI is set.\n        @param baseURI The new baseURI.\n     */\n    event NewBaseURI(string baseURI);\n\n    /**\n        @notice Emitted when a new fee is set.\n        @param fee The new fee.\n     */\n    event NewFee(uint256 fee);\n\n    /**\n        @notice Emitted when an order is filled.\n        @param orderHash The hash of the order that was filled.\n        @param floorAssetTokenIds The floor asset token ids that were used.\n        @param order The order that was filled.\n     */\n    event FilledOrder(bytes32 indexed orderHash, uint256[] floorAssetTokenIds, Order order);\n\n    /**\n        @notice Emitted when an order is exercised.\n        @param orderHash The hash of the order that was exercised.\n        @param floorAssetTokenIds The floor asset token ids that were used.\n        @param order The order that was exercised.\n     */\n    event ExercisedOrder(bytes32 indexed orderHash, uint256[] floorAssetTokenIds, Order order);\n\n    /**\n        @notice Emitted when an order is withdrawn.\n        @param orderHash The hash of the order that was withdrawn.\n        @param order The order that was withdrawn.\n     */\n    event WithdrawOrder(bytes32 indexed orderHash, Order order);\n\n    /**\n        @notice emitted When an order is cancelled.\n        @param orderHash The hash of the order that was cancelled.\n        @param order The order that was cancelled.\n     */\n    event CancelledOrder(bytes32 indexed orderHash, Order order);\n\n    constructor(\n        string memory _baseURI,\n        uint256 _fee,\n        address _weth\n    ) {\n        require(_weth != address(0), \"Unset weth address\");\n\n        setBaseURI(_baseURI);\n        setFee(_fee);\n        weth = _weth;\n    }\n\n    /* ~~~ ADMIN FUNCTIONS ~~~ */\n\n    /**\n        @notice Sets a new baseURI that is used in the construction\n                of the tokenURI for each NFT position. Admin/DAO only.\n        @param _baseURI The new base URI to use.\n     */\n    function setBaseURI(string memory _baseURI) public payable onlyOwner {\n        baseURI = _baseURI;\n\n        emit NewBaseURI(_baseURI);\n    }\n\n    /**\n        @notice Sets a new fee rate that is applied on exercise. The\n                fee has a precision of 1 decimal. e.g. 1000 = 100%,\n                100 = 10%, 1 = 0.1%. Admin/DAO only.\n        @param _fee The new fee rate to use.\n     */\n    function setFee(uint256 _fee) public payable onlyOwner {\n        require(_fee < 30, \"fee must be less than 3%\");\n\n        fee = _fee;\n\n        emit NewFee(_fee);\n    }\n\n    /*\n        ~~~ MAIN LOGIC FUNCTIONS ~~~\n\n        Standard lifecycle:\n            [1] fillOrder()\n            [2] exercise()\n            [3] withdraw()\n\n            * It is also possible to cancel() an order before fillOrder()\n    */\n\n    /**\n        @notice Fills an offchain order and settles it onchain. Mints two\n                NFTs that represent the long and short position for the order.\n        @param order The order to fill.\n        @param signature The signature for the order. Signature must recover to order.maker.\n        @param floorAssetTokenIds The floor asset token ids to use. Should only be set \n               when filling a long call order.\n        @return positionId The id of the position NFT that the msg.sender receives.\n     */\n    function fillOrder(\n        Order memory order,\n        bytes calldata signature,\n        uint256[] memory floorAssetTokenIds\n    ) public payable returns (uint256 positionId) {\n        /* ~~~ CHECKS ~~~ */\n\n        bytes32 orderHash = hashOrder(order);\n\n        // check signature is valid using EIP-712\n        require(SignatureChecker.isValidSignatureNow(order.maker, orderHash, signature), \"Invalid signature\");\n\n        // check order is not cancelled\n        require(!cancelledOrders[orderHash], \"Order has been cancelled\");\n\n        // check msg.sender is allowed to fill the order\n        require(order.whitelist.length == 0 || isWhitelisted(order.whitelist, msg.sender), \"Not whitelisted\");\n\n        // check duration is valid\n        require(order.duration < 10_000 days, \"Duration too long\");\n\n        // check order has not expired\n        require(block.timestamp < order.expiration, \"Order has expired\");\n\n        // check base asset exists\n        require(order.baseAsset.code.length > 0, \"baseAsset is not contract\");\n\n        // check floor asset token ids length is 0 unless the order type is call and side is long\n        order.isCall && order.isLong\n            ? require(floorAssetTokenIds.length == order.floorTokens.length, \"Wrong amount of floor tokenIds\")\n            : require(floorAssetTokenIds.length == 0, \"Invalid floor tokens length\");\n\n        /*  ~~~ EFFECTS ~~~ */\n\n        // create long/short position for maker\n        _mint(order.maker, uint256(orderHash));\n\n        // create opposite long/short position for taker\n        bytes32 oppositeOrderHash = hashOppositeOrder(order);\n        positionId = uint256(oppositeOrderHash);\n        _mint(msg.sender, positionId);\n\n        // save floorAssetTokenIds if filling a long call order\n        if (order.isLong && order.isCall) {\n            positionFloorAssetTokenIds[uint256(orderHash)] = floorAssetTokenIds;\n        }\n\n        // save the long position expiration\n        positionExpirations[order.isLong ? uint256(orderHash) : positionId] = block.timestamp + order.duration;\n\n        emit FilledOrder(orderHash, floorAssetTokenIds, order);\n\n        /* ~~~ INTERACTIONS ~~~ */\n\n        // transfer premium to whoever is short from whomever is long\n        if (order.isLong) {\n            ERC20(order.baseAsset).safeTransferFrom(order.maker, msg.sender, order.premium);\n        } else {\n            // handle the case where the user uses native ETH instead of WETH to pay the premium\n            if (weth == order.baseAsset && msg.value > 0) {\n                // check enough ETH was sent to cover the premium\n                require(msg.value == order.premium, \"Incorrect ETH amount sent\");\n\n                // convert ETH to WETH and send premium to maker\n                // converting to WETH instead of forwarding native ETH to the maker has two benefits;\n                // 1) active market makers will mostly be using WETH not native ETH\n                // 2) attack surface for re-entrancy is reduced\n                IWETH(weth).deposit{value: msg.value}();\n                IWETH(weth).transfer(order.maker, msg.value);\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, order.maker, order.premium);\n            }\n        }\n\n        // filling short put: transfer strike from maker to contract\n        if (!order.isLong && !order.isCall) {\n            ERC20(order.baseAsset).safeTransferFrom(order.maker, address(this), order.strike);\n            return positionId;\n        }\n\n        // filling long put: transfer strike from taker to contract\n        if (order.isLong && !order.isCall) {\n            // handle the case where the taker uses native ETH instead of WETH to deposit the strike\n            if (weth == order.baseAsset && msg.value > 0) {\n                // check enough ETH was sent to cover the strike\n                require(msg.value == order.strike, \"Incorrect ETH amount sent\");\n\n                // convert ETH to WETH\n                // we convert the strike ETH to WETH so that the logic in exercise() works\n                // - because exercise() assumes an ERC20 interface on the base asset.\n                IWETH(weth).deposit{value: msg.value}();\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n            }\n\n            return positionId;\n        }\n\n        // filling short call: transfer assets from maker to contract\n        if (!order.isLong && order.isCall) {\n            _transferERC20sIn(order.erc20Assets, order.maker);\n            _transferERC721sIn(order.erc721Assets, order.maker);\n            return positionId;\n        }\n\n        // filling long call: transfer assets from taker to contract\n        if (order.isLong && order.isCall) {\n            _transferERC20sIn(order.erc20Assets, msg.sender);\n            _transferERC721sIn(order.erc721Assets, msg.sender);\n            _transferFloorsIn(order.floorTokens, floorAssetTokenIds, msg.sender);\n            return positionId;\n        }\n    }\n\n    /**\n        @notice Exercises a long order and also burns the long position NFT which \n                represents it.\n        @param order The order of the position to exercise.\n        @param floorAssetTokenIds The floor asset token ids to use. Should only be set \n               when exercising a put order.\n     */\n    function exercise(Order memory order, uint256[] calldata floorAssetTokenIds) public payable {\n        /* ~~~ CHECKS ~~~ */\n\n        bytes32 orderHash = hashOrder(order);\n\n        // check user owns the position\n        require(ownerOf(uint256(orderHash)) == msg.sender, \"Not owner\");\n\n        // check position is long\n        require(order.isLong, \"Can only exercise long positions\");\n\n        // check position has not expired\n        require(block.timestamp < positionExpirations[uint256(orderHash)], \"Position has expired\");\n\n        // check floor asset token ids length is 0 unless the position type is put\n        !order.isCall\n            ? require(floorAssetTokenIds.length == order.floorTokens.length, \"Wrong amount of floor tokenIds\")\n            : require(floorAssetTokenIds.length == 0, \"Invalid floor tokenIds length\");\n\n        /* ~~~ EFFECTS ~~~ */\n\n        // send the long position to 0xdead.\n        // instead of doing a standard burn by sending to 0x000...000, sending\n        // to 0xdead ensures that the same position id cannot be minted again.\n        transferFrom(msg.sender, address(0xdead), uint256(orderHash));\n\n        // mark the position as exercised\n        exercisedPositions[uint256(orderHash)] = true;\n\n        emit ExercisedOrder(orderHash, floorAssetTokenIds, order);\n\n        /* ~~~ INTERACTIONS ~~~ */\n\n        if (order.isCall) {\n            // -- exercising a call option\n\n            // transfer strike from exerciser to putty\n            // handle the case where the taker uses native ETH instead of WETH to pay the strike\n            if (weth == order.baseAsset && msg.value > 0) {\n                // check enough ETH was sent to cover the strike\n                require(msg.value == order.strike, \"Incorrect ETH amount sent\");\n\n                // convert ETH to WETH\n                // we convert the strike ETH to WETH so that the logic in withdraw() works\n                // - because withdraw() assumes an ERC20 interface on the base asset.\n                IWETH(weth).deposit{value: msg.value}();\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n            }\n\n            // transfer assets from putty to exerciser\n            _transferERC20sOut(order.erc20Assets);\n            _transferERC721sOut(order.erc721Assets);\n            _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[uint256(orderHash)]);\n        } else {\n            // -- exercising a put option\n\n            // save the floor asset token ids to the short position\n            uint256 shortPositionId = uint256(hashOppositeOrder(order));\n            positionFloorAssetTokenIds[shortPositionId] = floorAssetTokenIds;\n\n            // transfer strike from putty to exerciser\n            ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike);\n\n            // transfer assets from exerciser to putty\n            _transferERC20sIn(order.erc20Assets, msg.sender);\n            _transferERC721sIn(order.erc721Assets, msg.sender);\n            _transferFloorsIn(order.floorTokens, floorAssetTokenIds, msg.sender);\n        }\n    }\n\n    /**\n        @notice Withdraws the assets from a short order and also burns the short position \n                that represents it. The assets that are withdrawn are dependent on whether \n                the order is exercised or expired and if the order is a put or call.\n        @param order The order to withdraw.\n     */\n    function withdraw(Order memory order) public {\n        /* ~~~ CHECKS ~~~ */\n\n        // check order is short\n        require(!order.isLong, \"Must be short position\");\n\n        bytes32 orderHash = hashOrder(order);\n\n        // check msg.sender owns the position\n        require(ownerOf(uint256(orderHash)) == msg.sender, \"Not owner\");\n\n        uint256 longPositionId = uint256(hashOppositeOrder(order));\n        bool isExercised = exercisedPositions[longPositionId];\n\n        // check long position has either been exercised or is expired\n        require(block.timestamp > positionExpirations[longPositionId] || isExercised, \"Must be exercised or expired\");\n\n        /* ~~~ EFFECTS ~~~ */\n\n        // send the short position to 0xdead.\n        // instead of doing a standard burn by sending to 0x000...000, sending\n        // to 0xdead ensures that the same position id cannot be minted again.\n        transferFrom(msg.sender, address(0xdead), uint256(orderHash));\n\n        emit WithdrawOrder(orderHash, order);\n\n        /* ~~~ INTERACTIONS ~~~ */\n\n        // transfer strike to owner if put is expired or call is exercised\n        if ((order.isCall && isExercised) || (!order.isCall && !isExercised)) {\n            // send the fee to the admin/DAO if fee is greater than 0%\n            uint256 feeAmount = 0;\n            if (fee > 0) {\n                feeAmount = (order.strike * fee) / 1000;\n                ERC20(order.baseAsset).safeTransfer(owner(), feeAmount);\n            }\n\n            ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount);\n\n            return;\n        }\n\n        // transfer assets from putty to owner if put is exercised or call is expired\n        if ((order.isCall && !isExercised) || (!order.isCall && isExercised)) {\n            _transferERC20sOut(order.erc20Assets);\n            _transferERC721sOut(order.erc721Assets);\n\n            // for call options the floor token ids are saved in the long position in fillOrder(),\n            // and for put options the floor tokens ids are saved in the short position in exercise()\n            uint256 floorPositionId = order.isCall ? longPositionId : uint256(orderHash);\n            _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[floorPositionId]);\n\n            return;\n        }\n    }\n\n    /**\n        @notice Cancels an order which prevents it from being filled in the future.\n        @param order The order to cancel.\n     */\n    function cancel(Order memory order) public {\n        require(msg.sender == order.maker, \"Not your order\");\n\n        bytes32 orderHash = hashOrder(order);\n\n        // mark the order as cancelled\n        cancelledOrders[orderHash] = true;\n\n        emit CancelledOrder(orderHash, order);\n    }\n\n    /* ~~~ PERIPHERY LOGIC FUNCTIONS ~~~ */\n\n    /**\n        @notice Batch fills multiple orders.\n        @param orders The orders to fill.\n        @param signatures The signatures to use for each respective order.\n        @param floorAssetTokenIds The floorAssetTokenIds to use for each respective order.\n        @return positionIds The ids of the position NFT that the msg.sender receives.\n     */\n    function batchFillOrder(\n        Order[] memory orders,\n        bytes[] calldata signatures,\n        uint256[][] memory floorAssetTokenIds\n    ) public returns (uint256[] memory positionIds) {\n        require(orders.length == signatures.length, \"Length mismatch in input\");\n        require(signatures.length == floorAssetTokenIds.length, \"Length mismatch in input\");\n\n        positionIds = new uint256[](orders.length);\n\n        for (uint256 i = 0; i < orders.length; i++) {\n            positionIds[i] = fillOrder(orders[i], signatures[i], floorAssetTokenIds[i]);\n        }\n    }\n\n    /**\n        @notice Accepts a counter offer for an order. It fills the counter offer, and then\n                cancels the original order that the counter offer was made for.\n        @dev There is no need for floorTokenIds here because there is no situation in which\n             it makes sense to have them when accepting counter offers. When accepting a counter \n             offer for a short call order, the complementary long call order already knows what \n             tokenIds are used in the short call so floorTokens should always be empty.\n        @param order The counter offer to accept.\n        @param signature The signature for the counter offer.\n        @param originalOrder The original order that the counter was made for.\n        @return positionId The id of the position NFT that the msg.sender receives.\n     */\n    function acceptCounterOffer(\n        Order memory order,\n        bytes calldata signature,\n        Order memory originalOrder\n    ) public payable returns (uint256 positionId) {\n        // cancel the original order\n        cancel(originalOrder);\n\n        // accept the counter offer\n        uint256[] memory floorAssetTokenIds = new uint256[](0);\n        positionId = fillOrder(order, signature, floorAssetTokenIds);\n    }\n\n    /* ~~~ HELPER FUNCTIONS ~~~ */\n\n    /**\n        @notice Transfers an array of erc20s into the contract from an address.\n        @param assets The erc20 tokens and amounts to transfer in.\n        @param from Who to transfer the erc20 assets from.\n     */\n    function _transferERC20sIn(ERC20Asset[] memory assets, address from) internal {\n        for (uint256 i = 0; i < assets.length; i++) {\n            address token = assets[i].token;\n            uint256 tokenAmount = assets[i].tokenAmount;\n\n            require(token.code.length > 0, \"ERC20: Token is not contract\");\n            require(tokenAmount > 0, \"ERC20: Amount too small\");\n\n            ERC20(token).safeTransferFrom(from, address(this), tokenAmount);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc721s into the contract from an address.\n        @param assets The erc721 tokens and token ids to transfer in.\n        @param from Who to transfer the erc721 assets from.\n     */\n    function _transferERC721sIn(ERC721Asset[] memory assets, address from) internal {\n        for (uint256 i = 0; i < assets.length; i++) {\n            ERC721(assets[i].token).safeTransferFrom(from, address(this), assets[i].tokenId);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc721 floor tokens into the contract from an address.\n        @param floorTokens The contract addresses of each erc721.\n        @param floorTokenIds The token id of each erc721.\n        @param from Who to transfer the floor tokens from.\n     */\n    function _transferFloorsIn(\n        address[] memory floorTokens,\n        uint256[] memory floorTokenIds,\n        address from\n    ) internal {\n        for (uint256 i = 0; i < floorTokens.length; i++) {\n            ERC721(floorTokens[i]).safeTransferFrom(from, address(this), floorTokenIds[i]);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc20 tokens to the msg.sender.\n        @param assets The erc20 tokens and amounts to send.\n     */\n    function _transferERC20sOut(ERC20Asset[] memory assets) internal {\n        for (uint256 i = 0; i < assets.length; i++) {\n            ERC20(assets[i].token).safeTransfer(msg.sender, assets[i].tokenAmount);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc721 tokens to the msg.sender.\n        @param assets The erc721 tokens and token ids to send.\n     */\n    function _transferERC721sOut(ERC721Asset[] memory assets) internal {\n        for (uint256 i = 0; i < assets.length; i++) {\n            ERC721(assets[i].token).safeTransferFrom(address(this), msg.sender, assets[i].tokenId);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc721 floor tokens to the msg.sender.\n        @param floorTokens The contract addresses for each floor token.\n        @param floorTokenIds The token id of each floor token.\n     */\n    function _transferFloorsOut(address[] memory floorTokens, uint256[] memory floorTokenIds) internal {\n        for (uint256 i = 0; i < floorTokens.length; i++) {\n            ERC721(floorTokens[i]).safeTransferFrom(address(this), msg.sender, floorTokenIds[i]);\n        }\n    }\n\n    /**\n        @notice Checks whether or not an address exists in the whitelist.\n        @param whitelist The whitelist to check against.\n        @param target The target address to check.\n        @return If it exists in the whitelist or not.\n     */\n    function isWhitelisted(address[] memory whitelist, address target) public pure returns (bool) {\n        for (uint256 i = 0; i < whitelist.length; i++) {\n            if (target == whitelist[i]) return true;\n        }\n\n        return false;\n    }\n\n    /**\n        @notice Get the orderHash for a complementary short/long order - e.g for a long order,\n                this returns the hash of it's opposite short order.\n        @param order The order to find the complementary long/short hash for.\n        @return orderHash The hash of the opposite order.\n     */\n    function hashOppositeOrder(Order memory order) public view returns (bytes32 orderHash) {\n        // use decode/encode to get a copy instead of reference\n        Order memory oppositeOrder = abi.decode(abi.encode(order), (Order));\n\n        // get the opposite side of the order (short/long)\n        oppositeOrder.isLong = !order.isLong;\n        orderHash = hashOrder(oppositeOrder);\n    }\n\n    /* ~~~ EIP-712 HELPERS ~~~ */\n\n    /**\n        @notice Hashes an order based on the eip-712 encoding scheme.\n        @param order The order to hash.\n        @return orderHash The eip-712 compliant hash of the order.\n     */\n    function hashOrder(Order memory order) public view returns (bytes32 orderHash) {\n        orderHash = keccak256(\n            abi.encode(\n                ORDER_TYPE_HASH,\n                order.maker,\n                order.isCall,\n                order.isLong,\n                order.baseAsset,\n                order.strike,\n                order.premium,\n                order.duration,\n                order.expiration,\n                order.nonce,\n                keccak256(abi.encodePacked(order.whitelist)),\n                keccak256(abi.encodePacked(order.floorTokens)),\n                keccak256(encodeERC20Assets(order.erc20Assets)),\n                keccak256(encodeERC721Assets(order.erc721Assets))\n            )\n        );\n\n        orderHash = _hashTypedDataV4(orderHash);\n    }\n\n    /**\n        @notice Encodes an array of erc20 assets following the eip-712 encoding scheme.\n        @param arr Array of erc20 assets to hash.\n        @return encoded The eip-712 encoded array of erc20 assets.\n     */\n    function encodeERC20Assets(ERC20Asset[] memory arr) public pure returns (bytes memory encoded) {\n        for (uint256 i = 0; i < arr.length; i++) {\n            encoded = abi.encodePacked(\n                encoded,\n                keccak256(abi.encode(ERC20ASSET_TYPE_HASH, arr[i].token, arr[i].tokenAmount))\n            );\n        }\n    }\n\n    /**\n        @notice Encodes an array of erc721 assets following the eip-712 encoding scheme.\n        @param arr Array of erc721 assets to hash.\n        @return encoded The eip-712 encoded array of erc721 assets.\n     */\n    function encodeERC721Assets(ERC721Asset[] memory arr) public pure returns (bytes memory encoded) {\n        for (uint256 i = 0; i < arr.length; i++) {\n            encoded = abi.encodePacked(\n                encoded,\n                keccak256(abi.encode(ERC721ASSET_TYPE_HASH, arr[i].token, arr[i].tokenId))\n            );\n        }\n    }\n\n    /**\n        @return The domain seperator used when calculating the eip-712 hash.\n     */\n    function domainSeparatorV4() public view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /* ~~~ OVERRIDES ~~~ */\n\n    /**\n        @notice Gets the token URI for an NFT.\n        @param id The id of the position NFT.\n        @return The tokenURI of the position NFT.\n     */\n    function tokenURI(uint256 id) public view override returns (string memory) {\n        require(_ownerOf[id] != address(0), \"URI query for NOT_MINTED token\");\n\n        return string.concat(baseURI, Strings.toString(id));\n    }\n}"
    }
  ]
}