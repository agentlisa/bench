{
  "Title": "Removing a Role Does Not Remove the Role From All Users",
  "Content": "The [`removeRole`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/PermissionsRegistry.sol#L79-L91) function in the `PermissionsRegistry` contract allows the Thena multisig to remove roles from the `PermissionsRegistry`.\n\n\nWhen removing roles, the role is removed from the [`_roles`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/PermissionsRegistry.sol#L85) list, but does not remove that role's entries in the `hasRole` mapping.\n\n\nThis is problematic because [typical](https://github.com/ThenafiBNB/THENA-Contracts/blob/e5458ee4ea811788576585af7a56c02986d16122/contracts/VoterV3.sol#L117) access control using the `PermissionsRegistry` contract looks up `msg.sender` in the `hasRole` mapping without first checking if the role is valid via either `_checkRole` or the `_roles` list. As a consequence, it is possible that formerly authorized entities can still perform sensitive operations.\n\n\nConsider removing all users from the role upon deletion of the role.\n\n\n***Update:** Resolved in [pull request #4](https://github.com/ThenafiBNB/THENA-Contracts/pull/4) at commit [8b2b9c1](https://github.com/ThenafiBNB/THENA-Contracts/pull/4/commits/8b2b9c1bf68be92d298db0d16ae8791326b8ae18).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/PermissionsRegistry.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\n\n/*\n    This contract handles the accesses to the various Thena contracts.\n*/\n\ncontract PermissionsRegistry {\n\n    /// @notice Control this contract \n    address public thenaMultisig;\n\n    /// @notice Control this contract \n    address public thenaTeamMultisig;\n\n    /// @notice Control emergency functions (set to multisig)\n    address public emergencyCouncil;\n\n    /// @notice Check if caller has a role active   (role -> caller -> true/false)\n    mapping(bytes => mapping(address => bool)) public hasRole;\n    mapping(bytes => bool) internal _checkRole;\n\n    mapping(bytes => address[]) internal _roleToAddresses;\n    mapping(address => bytes[]) internal _addressToRoles;\n\n    /// @notice Roles array\n    bytes[] internal _roles;\n\n\n    constructor() {\n        thenaTeamMultisig = msg.sender;\n        thenaMultisig = msg.sender;\n        emergencyCouncil = msg.sender;\n\n\n        _roles.push(bytes(\"GOVERNANCE\"));\n        _checkRole[(bytes(\"GOVERNANCE\"))] = true;\n\n        _roles.push(bytes(\"VOTER_ADMIN\"));\n        _checkRole[(bytes(\"VOTER_ADMIN\"))] = true;\n\n        _roles.push(bytes(\"GAUGE_ADMIN\"));\n        _checkRole[(bytes(\"GAUGE_ADMIN\"))] = true;\n\n        _roles.push(bytes(\"BRIBE_ADMIN\"));\n        _checkRole[(bytes(\"BRIBE_ADMIN\"))] = true;\n        \n        _roles.push(bytes(\"FEE_MANAGER\"));\n        _checkRole[(bytes(\"FEE_MANAGER\"))] = true;\n\n        _roles.push(bytes(\"CL_FEES_VAULT_ADMIN\"));\n        _checkRole[(bytes(\"CL_FEES_VAULT_ADMIN\"))] = true;\n\n    }\n\n    modifier onlyThenaMultisig() {\n        require(msg.sender == thenaMultisig);\n        _;\n    }\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    ROLES SETTINGS\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    /// @notice add a new role\n    /// @param  role    new role's string (eg role = \"GAUGE_ADMIN\")\n    function addRole(string memory role) external onlyThenaMultisig {\n        bytes memory _role = bytes(role);\n        require(!_checkRole[_role], 'is a role');\n        _checkRole[_role] = true;\n        _roles.push(_role);\n    }\n\n    /// @notice Remove a role\n    /// @dev    set last one to i_th position then .pop()\n    function removeRole(string memory role) external onlyThenaMultisig {\n        bytes memory _role = bytes(role);\n        require(_checkRole[_role], 'not a role');\n\n        for(uint i = 0; i < _roles.length; i++){\n            if(keccak256(_roles[i]) == keccak256(_role)){\n                _roles[i] = _roles[_roles.length -1];\n                _roles.pop();\n                _checkRole[_role] = false;\n                break; \n            }\n        }\n    }\n\n\n    \n    /// @notice Set a role for an address\n    function setRoleFor(address c, string memory role) external onlyThenaMultisig {\n        bytes memory _role = bytes(role);\n        require(_checkRole[_role], 'not a role');\n        require(!hasRole[_role][c], 'assigned');\n\n        hasRole[_role][c] = true;\n\n        _roleToAddresses[_role].push(c);\n        _addressToRoles[c].push(_role);\n\n    }\n\n    \n    /// @notice remove a role from an address\n    function removeRoleFrom(address c, string memory role) external onlyThenaMultisig {\n        bytes memory _role = bytes(role);\n        require(_checkRole[_role], 'not a role');\n        require(hasRole[_role][c], 'not assigned');\n\n        hasRole[_role][c] = false;\n\n        address[] storage rta = _roleToAddresses[_role];\n        for(uint i = 0; i < rta.length; i++){\n            if(rta[i] == c){\n                rta[i] = rta[rta.length -1];\n                rta.pop();\n            }\n        }\n\n        bytes[] storage atr = _addressToRoles[c];\n        for(uint i = 0; i < rta.length; i++){\n            if(keccak256(atr[i]) == keccak256(_role)){\n                atr[i] = atr[atr.length -1];\n                atr.pop();\n            }\n        }\n        \n    }\n\n    \n\n  \n\n    /************************************************************\n                                VIEW\n    *************************************************************/\n    \n    /// @notice Read roles and return strings\n    function rolesToString() external view returns(string[] memory __roles){\n        __roles = new string[](_roles.length);\n        for(uint i = 0; i < _roles.length; i++){\n            __roles[i] = string(_roles[i]);\n        }\n    }\n\n    \n    /// @notice Read roles array and return bytes\n    function roles() external view returns(bytes[] memory){\n        return _roles;\n    }\n\n    /// @notice Read roles length\n    function rolesLength() external view returns(uint){\n        return _roles.length;\n    }\n\n     /// @notice Return addresses for a given role\n    function roleToAddresses(string memory role) external view returns(address[] memory _addresses){\n        return _roleToAddresses[bytes(role)];\n    }\n\n    /// @notice Return roles for a given address\n    function addressToRole(address _user) external view returns(string[] memory){\n        string[] memory _temp = new string[](_addressToRoles[_user].length);\n        uint i = 0;\n        for(i; i < _temp.length; i++){\n            _temp[i] = string(_addressToRoles[_user][i]);\n        }\n        return _temp;\n    }\n\n    \n    /************************************************************\n                                HELPERS\n    *************************************************************/\n\n    /// @notice Helper function to get bytes from a string\n    function __helper_stringToBytes(string memory _input) public pure returns(bytes memory){\n        return bytes(_input);\n    }\n\n    /// @notice Helper function to get string from bytes\n    function __helper_bytesToString(bytes memory _input) public pure returns(string memory){\n        return string(_input);\n    }\n\n\n  \n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                EMERGENCY AND MULTISIG\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n\n    /// @notice set emergency counsil\n    /// @param _new new address    \n    function setEmergencyCouncil(address _new) external {\n        require(msg.sender == emergencyCouncil || msg.sender == thenaMultisig);\n        require(_new != address(0));\n        require(_new != emergencyCouncil);\n        emergencyCouncil = _new;\n    }\n\n\n    /// @notice set thena team multisig\n    /// @param _new new address    \n    function setThenaTeamMultisig(address _new) external {\n        require(msg.sender == thenaTeamMultisig);\n        require(_new != address(0));\n        require(_new != thenaTeamMultisig);\n        thenaTeamMultisig = _new;\n    }\n\n    /// @notice set thena multisig\n    /// @param _new new address    \n    function setThenaMultisig(address _new) external {\n        require(msg.sender == thenaMultisig);\n        require(_new != address(0));\n        require(_new != thenaMultisig);\n        thenaMultisig = _new;\n    }\n    \n\n\n}"
    },
    {
      "filename": "contracts/PermissionsRegistry.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\n\n/*\n    This contract handles the accesses to the various Thena contracts.\n*/\n\ncontract PermissionsRegistry {\n\n    /// @notice Control this contract \n    address public thenaMultisig;\n\n    /// @notice Control this contract \n    address public thenaTeamMultisig;\n\n    /// @notice Control emergency functions (set to multisig)\n    address public emergencyCouncil;\n\n    /// @notice Check if caller has a role active   (role -> caller -> true/false)\n    mapping(bytes => mapping(address => bool)) public hasRole;\n    mapping(bytes => bool) internal _checkRole;\n\n    mapping(bytes => address[]) internal _roleToAddresses;\n    mapping(address => bytes[]) internal _addressToRoles;\n\n    /// @notice Roles array\n    bytes[] internal _roles;\n\n\n    constructor() {\n        thenaTeamMultisig = msg.sender;\n        thenaMultisig = msg.sender;\n        emergencyCouncil = msg.sender;\n\n\n        _roles.push(bytes(\"GOVERNANCE\"));\n        _checkRole[(bytes(\"GOVERNANCE\"))] = true;\n\n        _roles.push(bytes(\"VOTER_ADMIN\"));\n        _checkRole[(bytes(\"VOTER_ADMIN\"))] = true;\n\n        _roles.push(bytes(\"GAUGE_ADMIN\"));\n        _checkRole[(bytes(\"GAUGE_ADMIN\"))] = true;\n\n        _roles.push(bytes(\"BRIBE_ADMIN\"));\n        _checkRole[(bytes(\"BRIBE_ADMIN\"))] = true;\n        \n        _roles.push(bytes(\"FEE_MANAGER\"));\n        _checkRole[(bytes(\"FEE_MANAGER\"))] = true;\n\n        _roles.push(bytes(\"CL_FEES_VAULT_ADMIN\"));\n        _checkRole[(bytes(\"CL_FEES_VAULT_ADMIN\"))] = true;\n\n    }\n\n    modifier onlyThenaMultisig() {\n        require(msg.sender == thenaMultisig);\n        _;\n    }\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    ROLES SETTINGS\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    /// @notice add a new role\n    /// @param  role    new role's string (eg role = \"GAUGE_ADMIN\")\n    function addRole(string memory role) external onlyThenaMultisig {\n        bytes memory _role = bytes(role);\n        require(!_checkRole[_role], 'is a role');\n        _checkRole[_role] = true;\n        _roles.push(_role);\n    }\n\n    /// @notice Remove a role\n    /// @dev    set last one to i_th position then .pop()\n    function removeRole(string memory role) external onlyThenaMultisig {\n        bytes memory _role = bytes(role);\n        require(_checkRole[_role], 'not a role');\n\n        for(uint i = 0; i < _roles.length; i++){\n            if(keccak256(_roles[i]) == keccak256(_role)){\n                _roles[i] = _roles[_roles.length -1];\n                _roles.pop();\n                _checkRole[_role] = false;\n                break; \n            }\n        }\n    }\n\n\n    \n    /// @notice Set a role for an address\n    function setRoleFor(address c, string memory role) external onlyThenaMultisig {\n        bytes memory _role = bytes(role);\n        require(_checkRole[_role], 'not a role');\n        require(!hasRole[_role][c], 'assigned');\n\n        hasRole[_role][c] = true;\n\n        _roleToAddresses[_role].push(c);\n        _addressToRoles[c].push(_role);\n\n    }\n\n    \n    /// @notice remove a role from an address\n    function removeRoleFrom(address c, string memory role) external onlyThenaMultisig {\n        bytes memory _role = bytes(role);\n        require(_checkRole[_role], 'not a role');\n        require(hasRole[_role][c], 'not assigned');\n\n        hasRole[_role][c] = false;\n\n        address[] storage rta = _roleToAddresses[_role];\n        for(uint i = 0; i < rta.length; i++){\n            if(rta[i] == c){\n                rta[i] = rta[rta.length -1];\n                rta.pop();\n            }\n        }\n\n        bytes[] storage atr = _addressToRoles[c];\n        for(uint i = 0; i < rta.length; i++){\n            if(keccak256(atr[i]) == keccak256(_role)){\n                atr[i] = atr[atr.length -1];\n                atr.pop();\n            }\n        }\n        \n    }\n\n    \n\n  \n\n    /************************************************************\n                                VIEW\n    *************************************************************/\n    \n    /// @notice Read roles and return strings\n    function rolesToString() external view returns(string[] memory __roles){\n        __roles = new string[](_roles.length);\n        for(uint i = 0; i < _roles.length; i++){\n            __roles[i] = string(_roles[i]);\n        }\n    }\n\n    \n    /// @notice Read roles array and return bytes\n    function roles() external view returns(bytes[] memory){\n        return _roles;\n    }\n\n    /// @notice Read roles length\n    function rolesLength() external view returns(uint){\n        return _roles.length;\n    }\n\n     /// @notice Return addresses for a given role\n    function roleToAddresses(string memory role) external view returns(address[] memory _addresses){\n        return _roleToAddresses[bytes(role)];\n    }\n\n    /// @notice Return roles for a given address\n    function addressToRole(address _user) external view returns(string[] memory){\n        string[] memory _temp = new string[](_addressToRoles[_user].length);\n        uint i = 0;\n        for(i; i < _temp.length; i++){\n            _temp[i] = string(_addressToRoles[_user][i]);\n        }\n        return _temp;\n    }\n\n    \n    /************************************************************\n                                HELPERS\n    *************************************************************/\n\n    /// @notice Helper function to get bytes from a string\n    function __helper_stringToBytes(string memory _input) public pure returns(bytes memory){\n        return bytes(_input);\n    }\n\n    /// @notice Helper function to get string from bytes\n    function __helper_bytesToString(bytes memory _input) public pure returns(string memory){\n        return string(_input);\n    }\n\n\n  \n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                EMERGENCY AND MULTISIG\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n\n    /// @notice set emergency counsil\n    /// @param _new new address    \n    function setEmergencyCouncil(address _new) external {\n        require(msg.sender == emergencyCouncil || msg.sender == thenaMultisig);\n        require(_new != address(0));\n        require(_new != emergencyCouncil);\n        emergencyCouncil = _new;\n    }\n\n\n    /// @notice set thena team multisig\n    /// @param _new new address    \n    function setThenaTeamMultisig(address _new) external {\n        require(msg.sender == thenaTeamMultisig);\n        require(_new != address(0));\n        require(_new != thenaTeamMultisig);\n        thenaTeamMultisig = _new;\n    }\n\n    /// @notice set thena multisig\n    /// @param _new new address    \n    function setThenaMultisig(address _new) external {\n        require(msg.sender == thenaMultisig);\n        require(_new != address(0));\n        require(_new != thenaMultisig);\n        thenaMultisig = _new;\n    }\n    \n\n\n}"
    },
    {
      "filename": "contracts/VoterV3.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport './libraries/Math.sol';\nimport './interfaces/IBribe.sol';\nimport './interfaces/IBribeFactory.sol';\nimport './interfaces/IGauge.sol';\nimport './interfaces/IGaugeFactory.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IMinter.sol';\nimport './interfaces/IPairInfo.sol';\nimport './interfaces/IPairFactory.sol';\nimport './interfaces/IVoter.sol';\nimport './interfaces/IVotingEscrow.sol';\nimport './interfaces/IPermissionsRegistry.sol';\nimport './interfaces/IAlgebraFactory.sol';\nimport \"hardhat/console.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\n\ninterface IHypervisor {\n    function pool() external view returns(address);\n}\n\ncontract VoterV3 is IVoter, OwnableUpgradeable, ReentrancyGuardUpgradeable {\n\n    \n    bool internal initflag;\n\n    address public _ve;                                         // the ve token that governs these contracts\n    address public factory;                                     // classic stable and volatile Pair Factory\n    address[] public factories;                                 // Array with all the pair factories\n    address internal base;                                      // $the token\n    address public gaugefactory;                                // gauge factory\n    address[] public gaugeFactories;                            // array with all the gauge factories\n    address public bribefactory;                                // bribe factory (internal and external)\n    address public minter;                                      // minter mints $the each epoch\n    address public permissionRegistry;                          // registry to check accesses\n    address[] public pools;                                     // all pools viable for incentives\n\n\n    uint internal index;                                        // gauge index\n    uint internal constant DURATION = 7 days;                   // rewards are released over 7 days\n    uint public VOTE_DELAY;                                     // delay between votes in seconds\n    uint public constant MAX_VOTE_DELAY = 7 days;               // Max vote delay allowed\n\n\n    mapping(address => uint) internal supplyIndex;              // gauge    => index\n    mapping(address => uint) public claimable;                  // gauge    => claimable $the\n    mapping(address => address) public gauges;                  // pool     => gauge\n    mapping(address => uint) public gaugesDistributionTimestmap;// gauge    => last Distribution Time\n    mapping(address => address) public poolForGauge;            // gauge    => pool\n    mapping(address => address) public internal_bribes;         // gauge    => internal bribe (only fees)\n    mapping(address => address) public external_bribes;         // gauge    => external bribe (real bribes)\n    mapping(uint => mapping(address => uint256)) public votes;  // nft      => pool     => votes\n    mapping(uint => address[]) public poolVote;                 // nft      => pools\n    mapping(uint => mapping(address => uint)) internal weightsPerEpoch; // timestamp => pool => weights\n    mapping(uint => uint) internal totWeightsPerEpoch;         // timestamp => total weights\n    mapping(uint => uint) public usedWeights;                   // nft      => total voting weight of user\n    mapping(uint => uint) public lastVoted;                     // nft      => timestamp of last vote\n    mapping(address => bool) public isGauge;                    // gauge    => boolean [is a gauge?]\n    mapping(address => bool) public isWhitelisted;              // token    => boolean [is an allowed token?]\n    mapping(address => bool) public isAlive;                    // gauge    => boolean [is the gauge alive?]\n    mapping(address => bool) public isFactory;                  // factory  => boolean [the pair factory exists?]\n    mapping(address => bool) public isGaugeFactory;             // g.factory=> boolean [the gauge factory exists?]\n\n    event GaugeCreated(address indexed gauge, address creator, address internal_bribe, address indexed external_bribe, address indexed pool);\n    event GaugeKilled(address indexed gauge);\n    event GaugeRevived(address indexed gauge);\n    event Voted(address indexed voter, uint tokenId, uint256 weight);\n    event Abstained(uint tokenId, uint256 weight);\n    event NotifyReward(address indexed sender, address indexed reward, uint amount);\n    event DistributeReward(address indexed sender, address indexed gauge, uint amount);\n    event Attach(address indexed owner, address indexed gauge, uint tokenId);\n    event Detach(address indexed owner, address indexed gauge, uint tokenId);\n    event Whitelisted(address indexed whitelister, address indexed token);\n    event Blacklisted(address indexed blacklister, address indexed token);\n\n    constructor() {}\n\n    function initialize(address __ve, address _factory, address  _gauges, address _bribes) initializer public {\n        __Ownable_init();\n        __ReentrancyGuard_init();\n\n        _ve = __ve;\n        base = IVotingEscrow(__ve).token();\n\n        factory = _factory;\n        factories.push(factory);\n        isFactory[factory] = true;\n\n        gaugefactory = _gauges;\n        gaugeFactories.push(_gauges);\n        isGaugeFactory[_gauges] = true;\n\n        bribefactory = _bribes;\n\n        minter = msg.sender;\n        permissionRegistry = msg.sender;\n\n        VOTE_DELAY = 0;\n        initflag = false;\n    }\n\n \n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    MODIFIERS\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    modifier VoterAdmin() {\n        require(IPermissionsRegistry(permissionRegistry).hasRole(\"VOTER_ADMIN\",msg.sender), 'ERR: VOTER_ADMIN');\n        _;\n    }\n\n    modifier Governance() {\n        require(IPermissionsRegistry(permissionRegistry).hasRole(\"GOVERNANCE\",msg.sender), 'ERR: GOVERNANCE');\n        _;\n    }\n\n    \n    /// @notice initialize the voter contract \n    /// @param  _tokens array of tokens to whitelist\n    /// @param  _minter the minter of $the\n    function _init(address[] memory _tokens, address _permissionsRegistry, address _minter) external {\n        require(msg.sender == minter || IPermissionsRegistry(permissionRegistry).hasRole(\"VOTER_ADMIN\",msg.sender));\n        require(!initflag);\n        for (uint i = 0; i < _tokens.length; i++) {\n            _whitelist(_tokens[i]);\n        }\n        minter = _minter;\n        permissionRegistry = _permissionsRegistry;\n        initflag = true;\n    }\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    VoterAdmin\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    /// @notice set vote delay in seconds\n    function setVoteDelay(uint _delay) external VoterAdmin {\n        require(_delay != VOTE_DELAY);\n        require(_delay <= MAX_VOTE_DELAY);\n        VOTE_DELAY = _delay;\n    }\n\n    /// @notice Set a new Minter\n    function setMinter(address _minter) external VoterAdmin {\n        require(_minter != address(0));\n        minter = _minter;\n    }\n\n    /// @notice Set a new Bribe Factory\n    function setBribeFactory(address _bribeFactory) external VoterAdmin {\n        bribefactory = _bribeFactory;\n    }\n\n    /// @notice Set a new Gauge Factory\n    function setGaugeFactory(address _gaugeFactory) external VoterAdmin {\n        gaugefactory = _gaugeFactory;\n    }\n\n    /// @notice Set a new Pair Factory\n    function setPairFactory(address _factory) external VoterAdmin {\n        factory = _factory;\n    }\n\n    /// @notice Set a new PermissionRegistry\n    function setPermissionsRegistry(address _permissionRegistry) external VoterAdmin {\n        permissionRegistry = _permissionRegistry;\n    }\n\n    /// @notice Set a new bribes for a given gauge\n    function setNewBribes(address _gauge, address _internal, address _external) external VoterAdmin {\n        require(isGauge[_gauge] == true);\n        _setInternalBribe(_gauge, _internal);\n        _setExternalBribe(_gauge, _external);\n    }\n\n    /// @notice Set a new internal bribe for a given gauge\n    function setInternalBribeFor(address _gauge, address _internal) external VoterAdmin {\n        require(isGauge[_gauge]);\n        _setInternalBribe(_gauge, _internal);\n    }\n\n    /// @notice Set a new External bribe for a given gauge\n    function setExternalBribeFor(address _gauge, address _external) external VoterAdmin {\n        require(isGauge[_gauge]);\n        _setExternalBribe(_gauge, _external);\n    }\n\n    function _setInternalBribe(address _gauge, address _internal) private {\n        internal_bribes[_gauge] = _internal;\n    }\n\n    function _setExternalBribe(address _gauge, address _external) private {\n        external_bribes[_gauge] = _external;\n    }\n    \n    \n    /// @notice Increase gauge approvals if max is type(uint).max is reached    [very long run could happen]\n    function increaseGaugeApprovals(address _gauge) external VoterAdmin {\n        require(isGauge[_gauge]);\n        IERC20(base).approve(_gauge, 0);\n        IERC20(base).approve(_gauge, type(uint).max);\n    }\n\n    \n    function addFactory(address _pairFactory, address _gaugeFactory) external VoterAdmin {\n        require(_pairFactory != address(0), 'addr 0');\n        require(_gaugeFactory != address(0), 'addr 0');\n        require(!isFactory[_pairFactory], 'factory true');\n        require(!isGaugeFactory[_gaugeFactory], 'g.fact true');\n\n        factories.push(_pairFactory);\n        gaugeFactories.push(_gaugeFactory);\n        isFactory[_pairFactory] = true;\n        isGaugeFactory[_gaugeFactory] = true;\n    }\n\n    function replaceFactory(address _pairFactory, address _gaugeFactory, uint256 _pos) external VoterAdmin {\n        require(_pairFactory != address(0), 'addr 0');\n        require(_gaugeFactory != address(0), 'addr 0');\n        require(isFactory[_pairFactory], 'factory false');\n        require(isGaugeFactory[_gaugeFactory], 'g.fact false');\n        address oldPF = factories[_pos];\n        address oldGF = gaugeFactories[_pos];\n        isFactory[oldPF] = false;\n        isGaugeFactory[oldGF] = false;\n\n        factories[_pos] = (_pairFactory);\n        gaugeFactories[_pos] = (_gaugeFactory);\n        isFactory[_pairFactory] = true;\n        isGaugeFactory[_gaugeFactory] = true;\n    }\n\n    function removeFactory(uint256 _pos) external VoterAdmin {\n        address oldPF = factories[_pos];\n        address oldGF = gaugeFactories[_pos];\n        require(isFactory[oldPF], 'factory false');\n        require(isGaugeFactory[oldGF], 'g.fact false');\n        factories[_pos] = address(0);\n        gaugeFactories[_pos] = address(0);\n        isFactory[oldPF] = false;\n        isGaugeFactory[oldGF] = false;\n    }\n\n    \n    \n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    GOVERNANCE\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n    \n    \n    /// @notice Whitelist a token for gauge creation\n    function whitelist(address[] memory _token) external Governance {\n        uint256 i = 0;\n        for(i = 0; i < _token.length; i++){\n            _whitelist(_token[i]);\n        }\n    }\n       \n    function _whitelist(address _token) private {\n        require(!isWhitelisted[_token]);\n        isWhitelisted[_token] = true;\n        emit Whitelisted(msg.sender, _token);\n    }\n    \n    /// @notice Blacklist a malicious token\n    function blacklist(address[] memory _token) external Governance {\n        uint256 i = 0;\n        for(i = 0; i < _token.length; i++){\n            _blacklist(_token[i]);\n        }\n    }\n       \n    function _blacklist(address _token) private {\n        require(isWhitelisted[_token]);\n        isWhitelisted[_token] = false;\n        emit Blacklisted(msg.sender, _token);\n    }\n\n     /// @notice Kill a malicious gauge \n    /// @param  _gauge gauge to kill\n    function killGauge(address _gauge) external Governance {\n        require(isAlive[_gauge], \"gauge already dead\");\n        isAlive[_gauge] = false;\n        claimable[_gauge] = 0;\n        emit GaugeKilled(_gauge);\n    }\n\n    /// @notice Revive a malicious gauge \n    /// @param  _gauge gauge to revive\n    function reviveGauge(address _gauge) external Governance {\n        require(!isAlive[_gauge], \"gauge already alive\");\n        require(isGauge[_gauge], 'gauge killed totally');\n        isAlive[_gauge] = true;\n        emit GaugeRevived(_gauge);\n    }\n    \n    /// @notice Kill a malicious gauge completly\n    /// @param  _gauge gauge to kill\n    function killGaugeTotally(address _gauge) external Governance {\n        require(isAlive[_gauge], \"gauge already dead\");\n\n        delete isAlive[_gauge];\n        delete internal_bribes[_gauge];\n        delete external_bribes[_gauge];\n        delete poolForGauge[_gauge];\n        delete isGauge[_gauge];\n        delete claimable[_gauge];\n        delete supplyIndex[_gauge];\n\n        address _pool = poolForGauge[_gauge];\n        gauges[_pool] = address(0);\n        \n\n        emit GaugeKilled(_gauge);\n    }\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    USER INTERACTION\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    \n    /// @notice Reset the votes of a given TokenID\n    function reset(uint _tokenId) external nonReentrant {\n        _voteDelay(_tokenId);\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, _tokenId));\n        _reset(_tokenId);\n        IVotingEscrow(_ve).abstain(_tokenId);\n        lastVoted[_tokenId] = block.timestamp;\n    }\n\n    function _reset(uint _tokenId) internal {\n        address[] storage _poolVote = poolVote[_tokenId];\n        uint _poolVoteCnt = _poolVote.length;\n        uint256 _totalWeight = 0;\n        uint256 _time = _epochTimestamp();\n\n        for (uint i = 0; i < _poolVoteCnt; i ++) {\n            address _pool = _poolVote[i];\n            uint256 _votes = votes[_tokenId][_pool];\n\n            if (_votes != 0) {\n                _updateFor(gauges[_pool]);\n\n                // if user last vote is < than epochTimestamp then votes are 0! IF not underflow occur\n                if(lastVoted[_tokenId] > _epochTimestamp()) weightsPerEpoch[_time][_pool] -= _votes;\n\n                votes[_tokenId][_pool] -= _votes;\n\n                if (_votes > 0) {\n                    IBribe(internal_bribes[gauges[_pool]])._withdraw(uint256(_votes), _tokenId);\n                    IBribe(external_bribes[gauges[_pool]])._withdraw(uint256(_votes), _tokenId);\n                    _totalWeight += _votes;\n                }\n                \n                emit Abstained(_tokenId, _votes);\n            }\n        }\n\n        \n        // if user last vote is < than epochTimestamp then _totalWeight is 0! IF not underflow occur\n        if(lastVoted[_tokenId] < _epochTimestamp()) _totalWeight = 0;\n        \n        totWeightsPerEpoch[_time] -= _totalWeight;\n        usedWeights[_tokenId] = 0;\n        delete poolVote[_tokenId];\n    }\n\n    /// @notice Recast the saved votes of a given TokenID\n    function poke(uint _tokenId) external nonReentrant {\n        _voteDelay(_tokenId);\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, _tokenId));\n        address[] memory _poolVote = poolVote[_tokenId];\n        uint _poolCnt = _poolVote.length;\n        uint256[] memory _weights = new uint256[](_poolCnt);\n\n        for (uint i = 0; i < _poolCnt; i ++) {\n            _weights[i] = votes[_tokenId][_poolVote[i]];\n        }\n\n        _vote(_tokenId, _poolVote, _weights);\n        lastVoted[_tokenId] = block.timestamp;\n    }\n\n    \n    /// @notice Vote for pools\n    /// @param  _tokenId    veNFT tokenID used to vote\n    /// @param  _poolVote   array of LPs addresses to vote  (eg.: [sAMM usdc-usdt   , sAMM busd-usdt, vAMM wbnb-the ,...])\n    /// @param  _weights    array of weights for each LPs   (eg.: [10               , 90            , 45             ,...])  \n    function vote(uint _tokenId, address[] calldata _poolVote, uint256[] calldata _weights) external nonReentrant {\n        _voteDelay(_tokenId);\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, _tokenId));\n        require(_poolVote.length == _weights.length);\n        _vote(_tokenId, _poolVote, _weights);\n        lastVoted[_tokenId] = block.timestamp;\n    }\n    \n    function _vote(uint _tokenId, address[] memory _poolVote, uint256[] memory _weights) internal {\n        _reset(_tokenId);\n        uint _poolCnt = _poolVote.length;"
    }
  ]
}