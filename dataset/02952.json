{
  "Title": "No unstaking window",
  "Content": "After an incident is resolved, successful stakers can retrieve their rewards [provided the incident has not been finalized](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/ValidationLibV1.sol#L425). When the incident occurred, they will have [at least the claim period](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/governance/resolution/Finalization.sol#L60). However, if the incident was successfully disputed, there is no claim period and the incident can be finalized immediately before stakers have been provided sufficient time to claim their rewards. Consider including an unstaking window for this scenario.\n\n\n**Update:** *Acknowledged, not fixed. The Neptune team stated:*\n\n\n\n> *For incidents resolved as `false reporting`, we intend to restore the cover status to operational as soon as possible. This flexibility allows us to accomplish a speedier finalization while still allowing the tokenholder community sufficient time to unstake their claim (with reward) on a case-by-case basis.*\n> \n> \n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/libraries/ValidationLibV1.sol",
      "content": "// Neptune Mutual Protocol (https://neptunemutual.com)\n// SPDX-License-Identifier: BUSL-1.1\n/* solhint-disable ordering  */\npragma solidity ^0.8.0;\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-solidity/contracts/access/IAccessControl.sol\";\nimport \"./ProtoUtilV1.sol\";\nimport \"./StoreKeyUtil.sol\";\nimport \"./RegistryLibV1.sol\";\nimport \"./CoverUtilV1.sol\";\nimport \"./GovernanceUtilV1.sol\";\nimport \"./AccessControlLibV1.sol\";\nimport \"../interfaces/IStore.sol\";\nimport \"../interfaces/IPausable.sol\";\nimport \"../interfaces/ICxToken.sol\";\n\nlibrary ValidationLibV1 {\n  using ProtoUtilV1 for IStore;\n  using StoreKeyUtil for IStore;\n  using CoverUtilV1 for IStore;\n  using GovernanceUtilV1 for IStore;\n  using RegistryLibV1 for IStore;\n\n  /**\n   * @dev Reverts if the protocol is paused\n   */\n  function mustNotBePaused(IStore s) public view {\n    address protocol = s.getProtocolAddress();\n    require(IPausable(protocol).paused() == false, \"Protocol is paused\");\n  }\n\n  /**\n   * @dev Reverts if the cover or any of the cover's product is not normal.\n   * @param coverKey Enter the cover key to check\n   */\n  function mustEnsureAllProductsAreNormal(IStore s, bytes32 coverKey) external view {\n    require(s.getBoolByKeys(ProtoUtilV1.NS_COVER, coverKey), \"Cover does not exist\");\n    require(s.isCoverNormalInternal(coverKey) == true, \"Status not normal\");\n  }\n\n  /**\n   * @dev Reverts if the key does not resolve in a valid cover contract\n   * or if the cover is under governance.\n   * @param coverKey Enter the cover key to check\n   * @param productKey Enter the product key to check\n   */\n  function mustHaveNormalProductStatus(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey\n  ) external view {\n    require(s.getBoolByKeys(ProtoUtilV1.NS_COVER, coverKey), \"Cover does not exist\");\n    require(s.getProductStatusInternal(coverKey, productKey) == CoverUtilV1.ProductStatus.Normal, \"Status not normal\");\n  }\n\n  /**\n   * @dev Reverts if the key does not resolve in a valid cover contract.\n   * @param coverKey Enter the cover key to check\n   */\n  function mustBeValidCoverKey(IStore s, bytes32 coverKey) external view {\n    require(s.getBoolByKeys(ProtoUtilV1.NS_COVER, coverKey), \"Cover does not exist\");\n  }\n\n  /**\n   * @dev Reverts if the cover does not support creating products.\n   * @param coverKey Enter the cover key to check\n   */\n  function mustSupportProducts(IStore s, bytes32 coverKey) external view {\n    require(s.supportsProductsInternal(coverKey), \"Does not have products\");\n  }\n\n  /**\n   * @dev Reverts if the key does not resolve in a valid product of a cover contract.\n   * @param coverKey Enter the cover key to check\n   * @param productKey Enter the cover key to check\n   */\n  function mustBeValidProduct(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey\n  ) public view {\n    require(s.isValidProductInternal(coverKey, productKey), \"Product does not exist\");\n  }\n\n  /**\n   * @dev Reverts if the key resolves in an expired product.\n   * @param coverKey Enter the cover key to check\n   * @param productKey Enter the cover key to check\n   */\n  function mustBeActiveProduct(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey\n  ) public view {\n    require(s.isActiveProductInternal(coverKey, productKey), \"Product retired or deleted\");\n  }\n\n  /**\n   * @dev Reverts if the sender is not the cover owner\n   * @param coverKey Enter the cover key to check\n   * @param sender The `msg.sender` value\n   */\n  function mustBeCoverOwner(\n    IStore s,\n    bytes32 coverKey,\n    address sender\n  ) public view {\n    bool isCoverOwner = s.getCoverOwner(coverKey) == sender;\n    require(isCoverOwner, \"Forbidden\");\n  }\n\n  /**\n   * @dev Reverts if the sender is not the cover owner or the cover contract\n   * @param coverKey Enter the cover key to check\n   * @param sender The `msg.sender` value\n   */\n  function mustBeCoverOwnerOrCoverContract(\n    IStore s,\n    bytes32 coverKey,\n    address sender\n  ) external view {\n    bool isCoverOwner = s.getCoverOwner(coverKey) == sender;\n    bool isCoverContract = address(s.getCoverContract()) == sender;\n\n    require(isCoverOwner || isCoverContract, \"Forbidden\");\n  }\n\n  function senderMustBeCoverOwnerOrAdmin(IStore s, bytes32 coverKey) external view {\n    if (AccessControlLibV1.hasAccess(s, AccessControlLibV1.NS_ROLES_ADMIN, msg.sender) == false) {\n      mustBeCoverOwner(s, coverKey, msg.sender);\n    }\n  }\n\n  function senderMustBePolicyContract(IStore s) external view {\n    s.senderMustBeExactContract(ProtoUtilV1.CNS_COVER_POLICY);\n  }\n\n  function senderMustBePolicyManagerContract(IStore s) external view {\n    s.senderMustBeExactContract(ProtoUtilV1.CNS_COVER_POLICY_MANAGER);\n  }\n\n  function senderMustBeCoverContract(IStore s) external view {\n    s.senderMustBeExactContract(ProtoUtilV1.CNS_COVER);\n  }\n\n  function senderMustBeVaultContract(IStore s, bytes32 coverKey) external view {\n    address vault = s.getVaultAddress(coverKey);\n    require(msg.sender == vault, \"Forbidden\");\n  }\n\n  function senderMustBeGovernanceContract(IStore s) external view {\n    s.senderMustBeExactContract(ProtoUtilV1.CNS_GOVERNANCE);\n  }\n\n  function senderMustBeClaimsProcessorContract(IStore s) external view {\n    s.senderMustBeExactContract(ProtoUtilV1.CNS_CLAIM_PROCESSOR);\n  }\n\n  function callerMustBeClaimsProcessorContract(IStore s, address caller) external view {\n    s.callerMustBeExactContract(ProtoUtilV1.CNS_CLAIM_PROCESSOR, caller);\n  }\n\n  function senderMustBeStrategyContract(IStore s) external view {\n    bool senderIsStrategyContract = s.getBoolByKey(_getIsActiveStrategyKey(msg.sender));\n    require(senderIsStrategyContract == true, \"Not a strategy contract\");\n  }\n\n  function callerMustBeStrategyContract(IStore s, address caller) public view {\n    bool isActive = s.getBoolByKey(_getIsActiveStrategyKey(caller));\n    bool wasDisabled = s.getBoolByKey(_getIsDisabledStrategyKey(caller));\n\n    require(isActive == true || wasDisabled == true, \"Not a strategy contract\");\n  }\n\n  function callerMustBeSpecificStrategyContract(\n    IStore s,\n    address caller,\n    bytes32 strategyName\n  ) external view {\n    callerMustBeStrategyContract(s, caller);\n    require(IMember(caller).getName() == strategyName, \"Access denied\");\n  }\n\n  /**\n   * @dev Hash key of the \"active strategy flag\".\n   *\n   * Warning: this function does not validate the input arguments.\n   *\n   * @param strategyAddress Enter a strategy address\n   *\n   */\n  function _getIsActiveStrategyKey(address strategyAddress) private pure returns (bytes32) {\n    return keccak256(abi.encodePacked(ProtoUtilV1.NS_LENDING_STRATEGY_ACTIVE, strategyAddress));\n  }\n\n  /**\n   * @dev Hash key of the \"disabled strategy flag\".\n   *\n   * Warning: this function does not validate the input arguments.\n   *\n   * @param strategyAddress Enter a strategy address\n   *\n   */\n  function _getIsDisabledStrategyKey(address strategyAddress) private pure returns (bytes32) {\n    return keccak256(abi.encodePacked(ProtoUtilV1.NS_LENDING_STRATEGY_DISABLED, strategyAddress));\n  }\n\n  function senderMustBeProtocolMember(IStore s) external view {\n    require(s.isProtocolMember(msg.sender), \"Forbidden\");\n  }\n\n  function mustBeReporting(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey\n  ) external view {\n    require(s.getProductStatusInternal(coverKey, productKey) == CoverUtilV1.ProductStatus.IncidentHappened, \"Not reporting\");\n  }\n\n  function mustBeDisputed(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey\n  ) external view {\n    require(s.getProductStatusInternal(coverKey, productKey) == CoverUtilV1.ProductStatus.FalseReporting, \"Not disputed\");\n  }\n\n  function mustBeClaimable(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey\n  ) public view {\n    require(s.getProductStatusInternal(coverKey, productKey) == CoverUtilV1.ProductStatus.Claimable, \"Not claimable\");\n  }\n\n  function mustBeClaimingOrDisputed(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey\n  ) external view {\n    CoverUtilV1.ProductStatus status = s.getProductStatusInternal(coverKey, productKey);\n\n    bool claiming = status == CoverUtilV1.ProductStatus.Claimable;\n    bool falseReporting = status == CoverUtilV1.ProductStatus.FalseReporting;\n\n    require(claiming || falseReporting, \"Not claimable nor disputed\");\n  }\n\n  function mustBeReportingOrDisputed(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey\n  ) external view {\n    CoverUtilV1.ProductStatus status = s.getProductStatusInternal(coverKey, productKey);\n    bool incidentHappened = status == CoverUtilV1.ProductStatus.IncidentHappened;\n    bool falseReporting = status == CoverUtilV1.ProductStatus.FalseReporting;\n\n    require(incidentHappened || falseReporting, \"Not reported nor disputed\");\n  }\n\n  function mustBeBeforeResolutionDeadline(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey\n  ) external view {\n    uint256 deadline = s.getResolutionDeadlineInternal(coverKey, productKey);\n\n    if (deadline > 0) {\n      require(block.timestamp < deadline, \"Emergency resolution deadline over\"); // solhint-disable-line\n    }\n  }\n\n  function mustNotHaveResolutionDeadline(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey\n  ) external view {\n    uint256 deadline = s.getResolutionDeadlineInternal(coverKey, productKey);\n    require(deadline == 0, \"Resolution already has deadline\");\n  }\n\n  function mustBeAfterResolutionDeadline(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey\n  ) public view {\n    uint256 deadline = s.getResolutionDeadlineInternal(coverKey, productKey);\n    require(deadline > 0 && block.timestamp > deadline, \"Still unresolved\"); // solhint-disable-line\n  }\n\n  function mustBeValidIncidentDate(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey,\n    uint256 incidentDate\n  ) public view {\n    require(s.getActiveIncidentDateInternal(coverKey, productKey) == incidentDate, \"Invalid incident date\");\n  }\n\n  function mustHaveDispute(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey\n  ) external view {\n    bool hasDispute = s.getBoolByKey(GovernanceUtilV1.getHasDisputeKeyInternal(coverKey, productKey));\n    require(hasDispute == true, \"Not disputed\");\n  }\n\n  function mustNotHaveDispute(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey\n  ) external view {\n    bool hasDispute = s.getBoolByKey(GovernanceUtilV1.getHasDisputeKeyInternal(coverKey, productKey));\n    require(hasDispute == false, \"Already disputed\");\n  }\n\n  function mustBeDuringReportingPeriod(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey\n  ) external view {\n    require(s.getResolutionTimestampInternal(coverKey, productKey) >= block.timestamp, \"Reporting window closed\"); // solhint-disable-line\n  }\n\n  function mustBeAfterReportingPeriod(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey\n  ) public view {\n    require(block.timestamp > s.getResolutionTimestampInternal(coverKey, productKey), \"Reporting still active\"); // solhint-disable-line\n  }\n\n  function mustBeValidCxToken(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey,\n    address cxToken,\n    uint256 incidentDate\n  ) public view {\n    require(s.getBoolByKeys(ProtoUtilV1.NS_COVER_CXTOKEN, cxToken) == true, \"Unknown cxToken\");\n\n    bytes32 COVER_KEY = ICxToken(cxToken).COVER_KEY(); // solhint-disable-line\n    bytes32 PRODUCT_KEY = ICxToken(cxToken).PRODUCT_KEY(); // solhint-disable-line\n\n    require(coverKey == COVER_KEY && productKey == PRODUCT_KEY, \"Invalid cxToken\");\n\n    uint256 expires = ICxToken(cxToken).expiresOn();\n    require(expires > incidentDate, \"Invalid or expired cxToken\");\n  }\n\n  function mustBeValidClaim(\n    IStore s,\n    address account,\n    bytes32 coverKey,\n    bytes32 productKey,\n    address cxToken,\n    uint256 incidentDate,\n    uint256 amount\n  ) external view {\n    mustBeSupportedProductOrEmpty(s, coverKey, productKey);\n    mustBeValidCxToken(s, coverKey, productKey, cxToken, incidentDate);\n    mustBeClaimable(s, coverKey, productKey);\n    mustBeValidIncidentDate(s, coverKey, productKey, incidentDate);\n    mustBeDuringClaimPeriod(s, coverKey, productKey);\n    require(ICxToken(cxToken).getClaimablePolicyOf(account) >= amount, \"Claim exceeds your coverage\");\n  }\n\n  function mustNotHaveUnstaken(\n    IStore s,\n    address account,\n    bytes32 coverKey,\n    bytes32 productKey,\n    uint256 incidentDate\n  ) public view {\n    uint256 withdrawal = s.getReportingUnstakenAmountInternal(account, coverKey, productKey, incidentDate);\n    require(withdrawal == 0, \"Already unstaken\");\n  }\n\n  /**\n   * @dev Validates your `unstakeWithoutClaim` arguments\n   *\n   * @custom:note This function is not intended be used and does not produce correct result\n   * during a claim period. Please use `validateUnstakeWithClaim` if you are accessing\n   * this function during claim period.\n   */\n  function validateUnstakeWithoutClaim(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey,\n    uint256 incidentDate\n  ) external view {\n    mustNotBePaused(s);\n    mustBeSupportedProductOrEmpty(s, coverKey, productKey);\n    mustNotHaveUnstaken(s, msg.sender, coverKey, productKey, incidentDate);\n    mustBeAfterReportingPeriod(s, coverKey, productKey);\n\n    // Before the deadline, emergency resolution can still happen\n    // that may have an impact on the final decision. We, therefore, have to wait.\n    mustBeAfterResolutionDeadline(s, coverKey, productKey);\n  }\n\n  /**\n   * @dev Validates your `unstakeWithClaim` arguments\n   *\n   * @custom:note This function is only intended be used during a claim period.\n   * Please use `validateUnstakeWithoutClaim` if you are accessing\n   * this function after claim period expiry.\n   */\n  function validateUnstakeWithClaim(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey,\n    uint256 incidentDate\n  ) external view {\n    mustNotBePaused(s);\n    mustBeSupportedProductOrEmpty(s, coverKey, productKey);\n    mustNotHaveUnstaken(s, msg.sender, coverKey, productKey, incidentDate);\n    mustBeAfterReportingPeriod(s, coverKey, productKey);\n\n    // If this reporting gets finalized, incident date will become invalid\n    // meaning this execution will revert thereby restricting late comers\n    // to access this feature. But they can still access `unstake` feature\n    // to withdraw their stake.\n    mustBeValidIncidentDate(s, coverKey, productKey, incidentDate);\n\n    // Before the deadline, emergency resolution can still happen\n    // that may have an impact on the final decision. We, therefore, have to wait.\n    mustBeAfterResolutionDeadline(s, coverKey, productKey);\n\n    bool incidentHappened = s.getProductStatusOfInternal(coverKey, productKey, incidentDate) == CoverUtilV1.ProductStatus.Claimable;\n\n    if (incidentHappened) {\n      // Incident occurred. Must unstake with claim during the claim period.\n      mustBeDuringClaimPeriod(s, coverKey, productKey);\n      return;\n    }\n  }\n\n  function mustBeDuringClaimPeriod(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey\n  ) public view {\n    uint256 beginsFrom = s.getUintByKeys(ProtoUtilV1.NS_CLAIM_BEGIN_TS, coverKey, productKey);\n    uint256 expiresAt = s.getUintByKeys(ProtoUtilV1.NS_CLAIM_EXPIRY_TS, coverKey, productKey);\n\n    require(beginsFrom > 0, \"Invalid claim begin date\");\n    require(expiresAt > beginsFrom, \"Invalid claim period\");\n\n    require(block.timestamp >= beginsFrom, \"Claim period hasn't begun\"); // solhint-disable-line\n    require(block.timestamp <= expiresAt, \"Claim period has expired\"); // solhint-disable-line\n  }\n\n  function mustBeAfterClaimExpiry(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey\n  ) external view {\n    require(block.timestamp > s.getUintByKeys(ProtoUtilV1.NS_CLAIM_EXPIRY_TS, coverKey, productKey), \"Claim still active\"); // solhint-disable-line\n  }\n\n  /**\n   * @dev Reverts if the sender is not whitelisted cover creator.\n   */\n  function senderMustBeWhitelistedCoverCreator(IStore s) external view {\n    require(s.getAddressBooleanByKey(ProtoUtilV1.NS_COVER_CREATOR_WHITELIST, msg.sender), \"Not whitelisted\");\n  }\n\n  function senderMustBeWhitelistedIfRequired(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey,\n    address sender\n  ) external view {\n    bool supportsProducts = s.supportsProductsInternal(coverKey);\n    bool required = supportsProducts ? s.checkIfProductRequiresWhitelist(coverKey, productKey) : s.checkIfRequiresWhitelist(coverKey);\n\n    if (required == false) {\n      return;\n    }\n\n    require(s.getAddressBooleanByKeys(ProtoUtilV1.NS_COVER_USER_WHITELIST, coverKey, productKey, sender), \"You are not whitelisted\");\n  }\n\n  function mustBeSupportedProductOrEmpty(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey\n  ) public view {\n    bool hasProducts = s.supportsProductsInternal(coverKey);\n\n    hasProducts ? require(productKey > 0, \"Specify a product\") : require(productKey == 0, \"Invalid product\");\n\n    if (hasProducts) {\n      mustBeValidProduct(s, coverKey, productKey);\n      mustBeActiveProduct(s, coverKey, productKey);\n    }\n  }\n\n  function mustNotHavePolicyDisabled(\n    IStore s,\n    bytes32 coverKey,\n    bytes32 productKey\n  ) external view {\n    require(!s.isPolicyDisabledInternal(coverKey, productKey), \"Policy purchase disabled\");\n  }\n\n  function mustNotExceedStablecoinThreshold(IStore s, uint256 amount) external view {\n    uint256 stablecoinPrecision = s.getStablecoinPrecision();\n    require(amount <= ProtoUtilV1.MAX_LIQUIDITY * stablecoinPrecision, \"Please specify a smaller amount\");\n  }\n\n  function mustNotExceedProposalThreshold(IStore s, uint256 amount) external view {\n    uint256 stablecoinPrecision = s.getStablecoinPrecision();\n    require(amount <= ProtoUtilV1.MAX_PROPOSAL_AMOUNT * stablecoinPrecision, \"Please specify a smaller amount\");\n  }\n}"
    }
  ]
}