{
  "Title": "User can deccrease allowance",
  "Content": "##### Description\nUser can decrease allowance before fillOrder will be executed\n##### Recommendation\nAdd additional require for checking allowance for user before next lines.\nhttps://github.com/1inch/limit-order-protocol/blob/a14bde6a260458de5083cee117d734221e1cbc05/contracts/LimitOrderProtocol.sol#L206\nhttps://github.com/1inch/limit-order-protocol/blob/a14bde6a260458de5083cee117d734221e1cbc05/contracts/LimitOrderProtocol.sol#L305\nIt saves some gas in this case. Also it possible to add this checking on user side before transaction executing.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/LimitOrderProtocol.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/drafts/EIP712.sol\";\nimport \"@openzeppelin/contracts/drafts/IERC20Permit.sol\";\n\nimport \"./helpers/AmountCalculator.sol\";\nimport \"./helpers/ChainlinkCalculator.sol\";\nimport \"./helpers/ERC1155Proxy.sol\";\nimport \"./helpers/ERC20Proxy.sol\";\nimport \"./helpers/ERC721Proxy.sol\";\nimport \"./helpers/NonceManager.sol\";\nimport \"./helpers/PredicateHelper.sol\";\nimport \"./interfaces/IERC1271.sol\";\nimport \"./interfaces/InteractiveMaker.sol\";\nimport \"./libraries/UncheckedAddress.sol\";\nimport \"./libraries/ArgumentsDecoder.sol\";\nimport \"./libraries/SilentECDSA.sol\";\n\n\n/// @title 1inch Limit Order Protocol v1\ncontract LimitOrderProtocol is\n    ImmutableOwner(address(this)),\n    EIP712(\"1inch Limit Order Protocol\", \"1\"),\n    AmountCalculator,\n    ChainlinkCalculator,\n    ERC1155Proxy,\n    ERC20Proxy,\n    ERC721Proxy,\n    NonceManager,\n    PredicateHelper\n{\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using UncheckedAddress for address;\n    using ArgumentsDecoder for bytes;\n\n    // Expiration Mask:\n    //   predicate := PredicateHelper.timestampBelow(deadline)\n    //\n    // Maker Nonce:\n    //   predicate := this.nonceEquals(makerAddress, makerNonce)\n\n    event OrderFilled(\n        address indexed maker,\n        bytes32 orderHash,\n        uint256 remaining\n    );\n\n    event OrderFilledRFQ(\n        bytes32 orderHash,\n        uint256 makingAmount\n    );\n\n    struct OrderRFQ {\n        uint256 info;\n        address makerAsset;\n        address takerAsset;\n        bytes makerAssetData; // (transferFrom.selector, signer, ______, makerAmount, ...)\n        bytes takerAssetData; // (transferFrom.selector, sender, signer, takerAmount, ...)\n    }\n\n    struct Order {\n        uint256 salt;\n        address makerAsset;\n        address takerAsset;\n        bytes makerAssetData; // (transferFrom.selector, signer, ______, makerAmount, ...)\n        bytes takerAssetData; // (transferFrom.selector, sender, signer, takerAmount, ...)\n        bytes getMakerAmount; // this.staticcall(abi.encodePacked(bytes, swapTakerAmount)) => (swapMakerAmount)\n        bytes getTakerAmount; // this.staticcall(abi.encodePacked(bytes, swapMakerAmount)) => (swapTakerAmount)\n        bytes predicate;      // this.staticcall(bytes) => (bool)\n        bytes permit;         // On first fill: permit.1.call(abi.encodePacked(permit.selector, permit.2))\n        bytes interaction;\n    }\n\n    bytes32 constant public LIMIT_ORDER_TYPEHASH = keccak256(\n        \"Order(uint256 salt,address makerAsset,address takerAsset,bytes makerAssetData,bytes takerAssetData,bytes getMakerAmount,bytes getTakerAmount,bytes predicate,bytes permit,bytes interaction)\"\n    );\n\n    bytes32 constant public LIMIT_ORDER_RFQ_TYPEHASH = keccak256(\n        \"OrderRFQ(uint256 info,address makerAsset,address takerAsset,bytes makerAssetData,bytes takerAssetData)\"\n    );\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes4 immutable private _MAX_SELECTOR = bytes4(uint32(IERC20.transferFrom.selector) + 10);\n\n    uint256 constant private _FROM_INDEX = 0;\n    uint256 constant private _TO_INDEX = 1;\n    uint256 constant private _AMOUNT_INDEX = 2;\n\n    mapping(bytes32 => uint256) private _remaining;\n    mapping(address => mapping(uint256 => uint256)) private _invalidator;\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns(bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /// @notice Returns unfilled amount for order. Throws if order does not exist\n    function remaining(bytes32 orderHash) external view returns(uint256) {\n        return _remaining[orderHash].sub(1, \"LOP: Unknown order\");\n    }\n\n    /// @notice Returns unfilled amount for order\n    /// @return Result Unfilled amount of order plus one if order exists. Otherwise 0\n    function remainingRaw(bytes32 orderHash) external view returns(uint256) {\n        return _remaining[orderHash];\n    }\n\n    /// @notice Same as `remainingRaw` but for multiple orders\n    function remainingsRaw(bytes32[] memory orderHashes) external view returns(uint256[] memory results) {\n        results = new uint256[](orderHashes.length);\n        for (uint i = 0; i < orderHashes.length; i++) {\n            results[i] = _remaining[orderHashes[i]];\n        }\n    }\n\n    /// @notice Returns bitmask for double-spend invalidators based on lowest byte of order.info and filled quotes\n    /// @return Result Each bit represents whenever corresponding quote was filled\n    function invalidatorForOrderRFQ(address maker, uint256 slot) external view returns(uint256) {\n        return _invalidator[maker][slot];\n    }\n\n    /// @notice Checks order predicate\n    function checkPredicate(Order memory order) public view returns(bool) {\n        bytes memory result = address(this).uncheckedFunctionStaticCall(order.predicate, \"LOP: predicate call failed\");\n        require(result.length == 32, \"LOP: invalid predicate return\");\n        return abi.decode(result, (bool));\n    }\n\n    /**\n     * @notice Calls every target with corresponding data. Then reverts with CALL_RESULTS_0101011 where zeroes and ones\n     * denote failure or success of the corresponding call\n     * @param targets Array of addresses that will be called\n     * @param data Array of data that will be passed to each call\n     */\n    function simulateCalls(address[] calldata targets, bytes[] calldata data) external {\n        require(targets.length == data.length, \"LOP: array size mismatch\");\n        bytes memory reason = new bytes(targets.length);\n        for (uint i = 0; i < targets.length; i++) {\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, bytes memory result) = targets[i].call(data[i]);\n            if (success && result.length > 0) {\n                success = abi.decode(result, (bool));\n            }\n            reason[i] = success ? bytes1(\"1\") : bytes1(\"0\");\n        }\n\n        // Always revert and provide per call results\n        revert(string(abi.encodePacked(\"CALL_RESULTS_\", reason)));\n    }\n\n    /// @notice Cancels order by setting remaining amount to zero\n    function cancelOrder(Order memory order) external {\n        require(order.makerAssetData.decodeAddress(_FROM_INDEX) == msg.sender, \"LOP: Access denied\");\n\n        bytes32 orderHash = _hash(order);\n        _remaining[orderHash] = 1;\n        emit OrderFilled(msg.sender, orderHash, 0);\n    }\n\n    /// @notice Cancels order's quote\n    function cancelOrderRFQ(uint256 orderInfo) external {\n        _invalidator[msg.sender][uint64(orderInfo) >> 8] |= (1 << (orderInfo & 0xff));\n    }\n\n    /// @notice Fills order's quote, fully or partially (whichever is possible)\n    /// @param order Order quote to fill\n    /// @param signature Signature to confirm quote ownership\n    /// @param makingAmount Making amount\n    /// @param takingAmount Taking amount\n    function fillOrderRFQ(\n        OrderRFQ memory order,\n        bytes memory signature,\n        uint256 makingAmount,\n        uint256 takingAmount\n    ) external returns(uint256, uint256) {\n        return fillOrderRFQTo(order, signature, makingAmount, takingAmount, msg.sender);\n    }\n\n    function fillOrderRFQToWithPermit(\n        OrderRFQ memory order,\n        bytes memory signature,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        address target,\n        bytes memory permit\n    ) external returns(uint256, uint256) {\n        _permit(permit);\n        return fillOrderRFQTo(order, signature, makingAmount, takingAmount, target);\n    }\n\n    function fillOrderRFQTo(\n        OrderRFQ memory order,\n        bytes memory signature,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        address target\n    ) public returns(uint256, uint256) {\n        // Check time expiration\n        uint256 expiration = uint128(order.info) >> 64;\n        require(expiration == 0 || block.timestamp <= expiration, \"LOP: order expired\");  // solhint-disable-line not-rely-on-time\n\n        {  // Stack too deep\n            // Validate double spend\n            address maker = order.makerAssetData.decodeAddress(_FROM_INDEX);\n            uint256 invalidatorSlot = uint64(order.info) >> 8;\n            uint256 invalidatorBit = 1 << uint8(order.info);\n            uint256 invalidator = _invalidator[maker][invalidatorSlot];\n            require(invalidator & invalidatorBit == 0, \"LOP: already filled\");\n            _invalidator[maker][invalidatorSlot] = invalidator | invalidatorBit;\n        }\n\n        // Compute partial fill if needed\n        uint256 orderMakerAmount = order.makerAssetData.decodeUint256(_AMOUNT_INDEX);\n        uint256 orderTakerAmount = order.takerAssetData.decodeUint256(_AMOUNT_INDEX);\n        if (takingAmount == 0 && makingAmount == 0) {\n            // Two zeros means whole order\n            makingAmount = orderMakerAmount;\n            takingAmount = orderTakerAmount;\n        }\n        else if (takingAmount == 0) {\n            takingAmount = (makingAmount.mul(orderTakerAmount).add(orderMakerAmount).sub(1)).div(orderMakerAmount);\n        }\n        else if (makingAmount == 0) {\n            makingAmount = takingAmount.mul(orderMakerAmount).div(orderTakerAmount);\n        }\n        else {\n            revert(\"LOP: one of amounts should be 0\");\n        }\n\n        require(makingAmount > 0 && takingAmount > 0, \"LOP: can't swap 0 amount\");\n        require(makingAmount <= orderMakerAmount, \"LOP: making amount exceeded\");\n        require(takingAmount <= orderTakerAmount, \"LOP: taking amount exceeded\");\n\n        // Validate order\n        bytes32 orderHash = _hash(order);\n        _validate(order.makerAssetData, order.takerAssetData, signature, orderHash);\n\n        // Maker => Taker, Taker => Maker\n        _callMakerAssetTransferFrom(order.makerAsset, order.makerAssetData, target, makingAmount);\n        _callTakerAssetTransferFrom(order.takerAsset, order.takerAssetData, takingAmount);\n\n        emit OrderFilledRFQ(orderHash, makingAmount);\n        return (makingAmount, takingAmount);\n    }\n\n    /// @notice Fills an order. If one doesn't exist (first fill) it will be created using order.makerAssetData\n    /// @param order Order quote to fill\n    /// @param signature Signature to confirm quote ownership\n    /// @param makingAmount Making amount\n    /// @param takingAmount Taking amount\n    /// @param thresholdAmount If makingAmout > 0 this is max takingAmount, else it is min makingAmount\n    function fillOrder(\n        Order memory order,\n        bytes calldata signature,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 thresholdAmount\n    ) external returns(uint256, uint256) {\n        return fillOrderTo(order, signature, makingAmount, takingAmount, thresholdAmount, msg.sender);\n    }\n\n    function fillOrderToWithPermit(\n        Order memory order,\n        bytes calldata signature,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 thresholdAmount,\n        address target,\n        bytes memory permit\n    ) external returns(uint256, uint256) {\n        _permit(permit);\n        return fillOrderTo(order, signature, makingAmount, takingAmount, thresholdAmount, target);\n    }\n\n    function fillOrderTo(\n        Order memory order,\n        bytes calldata signature,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 thresholdAmount,\n        address target\n    ) public returns(uint256, uint256) {\n        bytes32 orderHash = _hash(order);\n\n        {  // Stack too deep\n            uint256 remainingMakerAmount;\n            { // Stack too deep\n                bool orderExists;\n                (orderExists, remainingMakerAmount) = _remaining[orderHash].trySub(1);\n                if (!orderExists) {\n                    // First fill: validate order and permit maker asset\n                    _validate(order.makerAssetData, order.takerAssetData, signature, orderHash);\n                    remainingMakerAmount = order.makerAssetData.decodeUint256(_AMOUNT_INDEX);\n                    if (order.permit.length > 0) {\n                        _permit(order.permit);\n                        require(_remaining[orderHash] == 0, \"LOP: reentrancy detected\");\n                    }\n                }\n            }\n\n            // Check if order is valid\n            if (order.predicate.length > 0) {\n                require(checkPredicate(order), \"LOP: predicate returned false\");\n            }\n\n            // Compute maker and taker assets amount\n            if ((takingAmount == 0) == (makingAmount == 0)) {\n                revert(\"LOP: only one amount should be 0\");\n            }\n            else if (takingAmount == 0) {\n                takingAmount = _callGetTakerAmount(order, makingAmount);\n                require(takingAmount <= thresholdAmount, \"LOP: taking amount too high\");\n            }\n            else {\n                makingAmount = _callGetMakerAmount(order, takingAmount);\n                require(makingAmount >= thresholdAmount, \"LOP: making amount too low\");\n            }\n\n            require(makingAmount > 0 && takingAmount > 0, \"LOP: can't swap 0 amount\");\n\n            // Update remaining amount in storage\n            remainingMakerAmount = remainingMakerAmount.sub(makingAmount, \"LOP: taking > remaining\");\n            _remaining[orderHash] = remainingMakerAmount + 1;\n            emit OrderFilled(msg.sender, orderHash, remainingMakerAmount);\n        }\n\n        // Taker => Maker\n        _callTakerAssetTransferFrom(order.takerAsset, order.takerAssetData, takingAmount);\n\n        // Maker can handle funds interactively\n        if (order.interaction.length > 0) {\n            InteractiveMaker(order.makerAssetData.decodeAddress(_FROM_INDEX))\n                .notifyFillOrder(order.makerAsset, order.takerAsset, makingAmount, takingAmount, order.interaction);\n        }\n\n        // Maker => Taker\n        _callMakerAssetTransferFrom(order.makerAsset, order.makerAssetData, target, makingAmount);\n\n        return (makingAmount, takingAmount);\n    }\n\n    function _permit(bytes memory permitData) private {\n        (address token, bytes memory permit) = abi.decode(permitData, (address, bytes));\n        token.uncheckedFunctionCall(abi.encodePacked(IERC20Permit.permit.selector, permit), \"LOP: permit failed\");\n    }\n\n    function _hash(Order memory order) private view returns(bytes32) {\n        return _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    LIMIT_ORDER_TYPEHASH,\n                    order.salt,\n                    order.makerAsset,\n                    order.takerAsset,\n                    keccak256(order.makerAssetData),\n                    keccak256(order.takerAssetData),\n                    keccak256(order.getMakerAmount),\n                    keccak256(order.getTakerAmount),\n                    keccak256(order.predicate),\n                    keccak256(order.permit),\n                    keccak256(order.interaction)\n                )\n            )\n        );\n    }\n\n    function _hash(OrderRFQ memory order) private view returns(bytes32) {\n        return _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    LIMIT_ORDER_RFQ_TYPEHASH,\n                    order.info,\n                    order.makerAsset,\n                    order.takerAsset,\n                    keccak256(order.makerAssetData),\n                    keccak256(order.takerAssetData)\n                )\n            )\n        );\n    }\n\n    function _validate(bytes memory makerAssetData, bytes memory takerAssetData, bytes memory signature, bytes32 orderHash) private view {\n        require(makerAssetData.length >= 100, \"LOP: bad makerAssetData.length\");\n        require(takerAssetData.length >= 100, \"LOP: bad takerAssetData.length\");\n        bytes4 makerSelector = makerAssetData.decodeSelector();\n        bytes4 takerSelector = takerAssetData.decodeSelector();\n        require(makerSelector >= IERC20.transferFrom.selector && makerSelector <= _MAX_SELECTOR, \"LOP: bad makerAssetData.selector\");\n        require(takerSelector >= IERC20.transferFrom.selector && takerSelector <= _MAX_SELECTOR, \"LOP: bad takerAssetData.selector\");\n\n        address maker = address(makerAssetData.decodeAddress(_FROM_INDEX));\n        if ((signature.length != 65 && signature.length != 64) || SilentECDSA.recover(orderHash, signature) != maker) {\n            bytes memory result = maker.uncheckedFunctionStaticCall(abi.encodeWithSelector(IERC1271.isValidSignature.selector, orderHash, signature), \"LOP: isValidSignature failed\");\n            require(result.length == 32 && abi.decode(result, (bytes4)) == IERC1271.isValidSignature.selector, \"LOP: bad signature\");\n        }\n    }\n\n    function _callMakerAssetTransferFrom(address makerAsset, bytes memory makerAssetData, address taker, uint256 makingAmount) private {\n        // Patch receiver or validate private order\n        address orderTakerAddress = makerAssetData.decodeAddress(_TO_INDEX);\n        if (orderTakerAddress != address(0)) {\n            require(orderTakerAddress == msg.sender, \"LOP: private order\");\n        }\n        if (orderTakerAddress != taker) {\n            makerAssetData.patchAddress(_TO_INDEX, taker);\n        }\n\n        // Patch maker amount\n        makerAssetData.patchUint256(_AMOUNT_INDEX, makingAmount);\n\n        require(makerAsset != address(0) && makerAsset != 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE, \"LOP: raw ETH is not supported\");\n\n        // Transfer asset from maker to taker\n        bytes memory result = makerAsset.uncheckedFunctionCall(makerAssetData, \"LOP: makerAsset.call failed\");\n        if (result.length > 0) {\n            require(abi.decode(result, (bool)), \"LOP: makerAsset.call bad result\");\n        }\n    }\n\n    function _callTakerAssetTransferFrom(address takerAsset, bytes memory takerAssetData, uint256 takingAmount) private {\n        // Patch spender\n        takerAssetData.patchAddress(_FROM_INDEX, msg.sender);\n\n        // Patch taker amount\n        takerAssetData.patchUint256(_AMOUNT_INDEX, takingAmount);\n\n        require(takerAsset != address(0) && takerAsset != 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE, \"LOP: raw ETH is not supported\");\n\n        // Transfer asset from taker to maker\n        bytes memory result = takerAsset.uncheckedFunctionCall(takerAssetData, \"LOP: takerAsset.call failed\");\n        if (result.length > 0) {\n            require(abi.decode(result, (bool)), \"LOP: takerAsset.call bad result\");\n        }\n    }\n\n    function _callGetMakerAmount(Order memory order, uint256 takerAmount) private view returns(uint256 makerAmount) {\n        if (order.getMakerAmount.length == 0 && takerAmount == order.takerAssetData.decodeUint256(_AMOUNT_INDEX)) {\n            // On empty order.getMakerAmount calldata only whole fills are allowed\n            return order.makerAssetData.decodeUint256(_AMOUNT_INDEX);\n        }\n\n        bytes memory result = address(this).uncheckedFunctionStaticCall(abi.encodePacked(order.getMakerAmount, takerAmount), \"LOP: getMakerAmount call failed\");\n        require(result.length == 32, \"LOP: invalid getMakerAmount ret\");\n        return abi.decode(result, (uint256));\n    }\n\n    function _callGetTakerAmount(Order memory order, uint256 makerAmount) private view returns(uint256 takerAmount) {\n        if (order.getTakerAmount.length == 0 && makerAmount == order.makerAssetData.decodeUint256(_AMOUNT_INDEX)) {\n            // On empty order.getTakerAmount calldata only whole fills are allowed\n            return order.takerAssetData.decodeUint256(_AMOUNT_INDEX);\n        }\n        bytes memory result = address(this).uncheckedFunctionStaticCall(abi.encodePacked(order.getTakerAmount, makerAmount), \"LOP: getTakerAmount call failed\");\n        require(result.length == 32, \"LOP: invalid getTakerAmount ret\");\n        return abi.decode(result, (uint256));\n    }\n}"
    },
    {
      "filename": "contracts/LimitOrderProtocol.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/drafts/EIP712.sol\";\nimport \"@openzeppelin/contracts/drafts/IERC20Permit.sol\";\n\nimport \"./helpers/AmountCalculator.sol\";\nimport \"./helpers/ChainlinkCalculator.sol\";\nimport \"./helpers/ERC1155Proxy.sol\";\nimport \"./helpers/ERC20Proxy.sol\";\nimport \"./helpers/ERC721Proxy.sol\";\nimport \"./helpers/NonceManager.sol\";\nimport \"./helpers/PredicateHelper.sol\";\nimport \"./interfaces/IERC1271.sol\";\nimport \"./interfaces/InteractiveMaker.sol\";\nimport \"./libraries/UncheckedAddress.sol\";\nimport \"./libraries/ArgumentsDecoder.sol\";\nimport \"./libraries/SilentECDSA.sol\";\n\n\n/// @title 1inch Limit Order Protocol v1\ncontract LimitOrderProtocol is\n    ImmutableOwner(address(this)),\n    EIP712(\"1inch Limit Order Protocol\", \"1\"),\n    AmountCalculator,\n    ChainlinkCalculator,\n    ERC1155Proxy,\n    ERC20Proxy,\n    ERC721Proxy,\n    NonceManager,\n    PredicateHelper\n{\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using UncheckedAddress for address;\n    using ArgumentsDecoder for bytes;\n\n    // Expiration Mask:\n    //   predicate := PredicateHelper.timestampBelow(deadline)\n    //\n    // Maker Nonce:\n    //   predicate := this.nonceEquals(makerAddress, makerNonce)\n\n    event OrderFilled(\n        address indexed maker,\n        bytes32 orderHash,\n        uint256 remaining\n    );\n\n    event OrderFilledRFQ(\n        bytes32 orderHash,\n        uint256 makingAmount\n    );\n\n    struct OrderRFQ {\n        uint256 info;\n        address makerAsset;\n        address takerAsset;\n        bytes makerAssetData; // (transferFrom.selector, signer, ______, makerAmount, ...)\n        bytes takerAssetData; // (transferFrom.selector, sender, signer, takerAmount, ...)\n    }\n\n    struct Order {\n        uint256 salt;\n        address makerAsset;\n        address takerAsset;\n        bytes makerAssetData; // (transferFrom.selector, signer, ______, makerAmount, ...)\n        bytes takerAssetData; // (transferFrom.selector, sender, signer, takerAmount, ...)\n        bytes getMakerAmount; // this.staticcall(abi.encodePacked(bytes, swapTakerAmount)) => (swapMakerAmount)\n        bytes getTakerAmount; // this.staticcall(abi.encodePacked(bytes, swapMakerAmount)) => (swapTakerAmount)\n        bytes predicate;      // this.staticcall(bytes) => (bool)\n        bytes permit;         // On first fill: permit.1.call(abi.encodePacked(permit.selector, permit.2))\n        bytes interaction;\n    }\n\n    bytes32 constant public LIMIT_ORDER_TYPEHASH = keccak256(\n        \"Order(uint256 salt,address makerAsset,address takerAsset,bytes makerAssetData,bytes takerAssetData,bytes getMakerAmount,bytes getTakerAmount,bytes predicate,bytes permit,bytes interaction)\"\n    );\n\n    bytes32 constant public LIMIT_ORDER_RFQ_TYPEHASH = keccak256(\n        \"OrderRFQ(uint256 info,address makerAsset,address takerAsset,bytes makerAssetData,bytes takerAssetData)\"\n    );\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes4 immutable private _MAX_SELECTOR = bytes4(uint32(IERC20.transferFrom.selector) + 10);\n\n    uint256 constant private _FROM_INDEX = 0;\n    uint256 constant private _TO_INDEX = 1;\n    uint256 constant private _AMOUNT_INDEX = 2;\n\n    mapping(bytes32 => uint256) private _remaining;\n    mapping(address => mapping(uint256 => uint256)) private _invalidator;\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns(bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /// @notice Returns unfilled amount for order. Throws if order does not exist\n    function remaining(bytes32 orderHash) external view returns(uint256) {\n        return _remaining[orderHash].sub(1, \"LOP: Unknown order\");\n    }\n\n    /// @notice Returns unfilled amount for order\n    /// @return Result Unfilled amount of order plus one if order exists. Otherwise 0\n    function remainingRaw(bytes32 orderHash) external view returns(uint256) {\n        return _remaining[orderHash];\n    }\n\n    /// @notice Same as `remainingRaw` but for multiple orders\n    function remainingsRaw(bytes32[] memory orderHashes) external view returns(uint256[] memory results) {\n        results = new uint256[](orderHashes.length);\n        for (uint i = 0; i < orderHashes.length; i++) {\n            results[i] = _remaining[orderHashes[i]];\n        }\n    }\n\n    /// @notice Returns bitmask for double-spend invalidators based on lowest byte of order.info and filled quotes\n    /// @return Result Each bit represents whenever corresponding quote was filled\n    function invalidatorForOrderRFQ(address maker, uint256 slot) external view returns(uint256) {\n        return _invalidator[maker][slot];\n    }\n\n    /// @notice Checks order predicate\n    function checkPredicate(Order memory order) public view returns(bool) {\n        bytes memory result = address(this).uncheckedFunctionStaticCall(order.predicate, \"LOP: predicate call failed\");\n        require(result.length == 32, \"LOP: invalid predicate return\");\n        return abi.decode(result, (bool));\n    }\n\n    /**\n     * @notice Calls every target with corresponding data. Then reverts with CALL_RESULTS_0101011 where zeroes and ones\n     * denote failure or success of the corresponding call\n     * @param targets Array of addresses that will be called\n     * @param data Array of data that will be passed to each call\n     */\n    function simulateCalls(address[] calldata targets, bytes[] calldata data) external {\n        require(targets.length == data.length, \"LOP: array size mismatch\");\n        bytes memory reason = new bytes(targets.length);\n        for (uint i = 0; i < targets.length; i++) {\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, bytes memory result) = targets[i].call(data[i]);\n            if (success && result.length > 0) {\n                success = abi.decode(result, (bool));\n            }\n            reason[i] = success ? bytes1(\"1\") : bytes1(\"0\");\n        }\n\n        // Always revert and provide per call results\n        revert(string(abi.encodePacked(\"CALL_RESULTS_\", reason)));\n    }\n\n    /// @notice Cancels order by setting remaining amount to zero\n    function cancelOrder(Order memory order) external {\n        require(order.makerAssetData.decodeAddress(_FROM_INDEX) == msg.sender, \"LOP: Access denied\");\n\n        bytes32 orderHash = _hash(order);\n        _remaining[orderHash] = 1;\n        emit OrderFilled(msg.sender, orderHash, 0);\n    }\n\n    /// @notice Cancels order's quote\n    function cancelOrderRFQ(uint256 orderInfo) external {\n        _invalidator[msg.sender][uint64(orderInfo) >> 8] |= (1 << (orderInfo & 0xff));\n    }\n\n    /// @notice Fills order's quote, fully or partially (whichever is possible)\n    /// @param order Order quote to fill\n    /// @param signature Signature to confirm quote ownership\n    /// @param makingAmount Making amount\n    /// @param takingAmount Taking amount\n    function fillOrderRFQ(\n        OrderRFQ memory order,\n        bytes memory signature,\n        uint256 makingAmount,\n        uint256 takingAmount\n    ) external returns(uint256, uint256) {\n        return fillOrderRFQTo(order, signature, makingAmount, takingAmount, msg.sender);\n    }\n\n    function fillOrderRFQToWithPermit(\n        OrderRFQ memory order,\n        bytes memory signature,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        address target,\n        bytes memory permit\n    ) external returns(uint256, uint256) {\n        _permit(permit);\n        return fillOrderRFQTo(order, signature, makingAmount, takingAmount, target);\n    }\n\n    function fillOrderRFQTo(\n        OrderRFQ memory order,\n        bytes memory signature,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        address target\n    ) public returns(uint256, uint256) {\n        // Check time expiration\n        uint256 expiration = uint128(order.info) >> 64;\n        require(expiration == 0 || block.timestamp <= expiration, \"LOP: order expired\");  // solhint-disable-line not-rely-on-time\n\n        {  // Stack too deep\n            // Validate double spend\n            address maker = order.makerAssetData.decodeAddress(_FROM_INDEX);\n            uint256 invalidatorSlot = uint64(order.info) >> 8;\n            uint256 invalidatorBit = 1 << uint8(order.info);\n            uint256 invalidator = _invalidator[maker][invalidatorSlot];\n            require(invalidator & invalidatorBit == 0, \"LOP: already filled\");\n            _invalidator[maker][invalidatorSlot] = invalidator | invalidatorBit;\n        }\n\n        // Compute partial fill if needed\n        uint256 orderMakerAmount = order.makerAssetData.decodeUint256(_AMOUNT_INDEX);\n        uint256 orderTakerAmount = order.takerAssetData.decodeUint256(_AMOUNT_INDEX);\n        if (takingAmount == 0 && makingAmount == 0) {\n            // Two zeros means whole order\n            makingAmount = orderMakerAmount;\n            takingAmount = orderTakerAmount;\n        }\n        else if (takingAmount == 0) {\n            takingAmount = (makingAmount.mul(orderTakerAmount).add(orderMakerAmount).sub(1)).div(orderMakerAmount);\n        }\n        else if (makingAmount == 0) {\n            makingAmount = takingAmount.mul(orderMakerAmount).div(orderTakerAmount);\n        }\n        else {\n            revert(\"LOP: one of amounts should be 0\");\n        }\n\n        require(makingAmount > 0 && takingAmount > 0, \"LOP: can't swap 0 amount\");\n        require(makingAmount <= orderMakerAmount, \"LOP: making amount exceeded\");\n        require(takingAmount <= orderTakerAmount, \"LOP: taking amount exceeded\");\n\n        // Validate order\n        bytes32 orderHash = _hash(order);\n        _validate(order.makerAssetData, order.takerAssetData, signature, orderHash);\n\n        // Maker => Taker, Taker => Maker\n        _callMakerAssetTransferFrom(order.makerAsset, order.makerAssetData, target, makingAmount);\n        _callTakerAssetTransferFrom(order.takerAsset, order.takerAssetData, takingAmount);\n\n        emit OrderFilledRFQ(orderHash, makingAmount);\n        return (makingAmount, takingAmount);\n    }\n\n    /// @notice Fills an order. If one doesn't exist (first fill) it will be created using order.makerAssetData\n    /// @param order Order quote to fill\n    /// @param signature Signature to confirm quote ownership\n    /// @param makingAmount Making amount\n    /// @param takingAmount Taking amount\n    /// @param thresholdAmount If makingAmout > 0 this is max takingAmount, else it is min makingAmount\n    function fillOrder(\n        Order memory order,\n        bytes calldata signature,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 thresholdAmount\n    ) external returns(uint256, uint256) {\n        return fillOrderTo(order, signature, makingAmount, takingAmount, thresholdAmount, msg.sender);\n    }\n\n    function fillOrderToWithPermit(\n        Order memory order,\n        bytes calldata signature,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 thresholdAmount,\n        address target,\n        bytes memory permit\n    ) external returns(uint256, uint256) {\n        _permit(permit);\n        return fillOrderTo(order, signature, makingAmount, takingAmount, thresholdAmount, target);\n    }\n\n    function fillOrderTo(\n        Order memory order,\n        bytes calldata signature,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 thresholdAmount,\n        address target\n    ) public returns(uint256, uint256) {\n        bytes32 orderHash = _hash(order);\n\n        {  // Stack too deep\n            uint256 remainingMakerAmount;\n            { // Stack too deep\n                bool orderExists;\n                (orderExists, remainingMakerAmount) = _remaining[orderHash].trySub(1);\n                if (!orderExists) {\n                    // First fill: validate order and permit maker asset\n                    _validate(order.makerAssetData, order.takerAssetData, signature, orderHash);\n                    remainingMakerAmount = order.makerAssetData.decodeUint256(_AMOUNT_INDEX);\n                    if (order.permit.length > 0) {\n                        _permit(order.permit);\n                        require(_remaining[orderHash] == 0, \"LOP: reentrancy detected\");\n                    }\n                }\n            }\n\n            // Check if order is valid\n            if (order.predicate.length > 0) {\n                require(checkPredicate(order), \"LOP: predicate returned false\");\n            }\n\n            // Compute maker and taker assets amount\n            if ((takingAmount == 0) == (makingAmount == 0)) {\n                revert(\"LOP: only one amount should be 0\");\n            }\n            else if (takingAmount == 0) {\n                takingAmount = _callGetTakerAmount(o"
    }
  ]
}