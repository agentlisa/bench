{
  "Title": "[H-02] if the Virtual Account's owner is a Contract Account (multisig wallet), attackers can gain control of the Virtual Accounts by gaining control of the same owner's address in a different chain",
  "Content": "\nAttackers can gain control of User's Virtual Accounts and steal all the assets in these accounts held in the Root environment.\n\n### Proof of Concept\n\n- When sending signed messages from a Branch to Root, the RootBridgeAgent contract calls the [`RootPort::fetchVirtualAccount()`](https://github.com/code-423n4/2023-09-maia/blob/main/src/RootPort.sol#L350-L353) to get the Virtual Account that is assigned in the Root environment to the address who initiated the call in the SrcBranch; if that address doesn't have an assigned Virtual Account yet, it proceeds to create one and assign it.\n\n- The problem is that the `fetchVirtualAccount()` function solely relies on the address of the caller in the SrcBranch; however, it doesn't take into account from *which* Branch the call comes.\n\n**BranchBridgeAgent.sol:**\n\n```solidity\nfunction callOutSignedAndBridge(\n    ...\n) external payable override lock {\n  ...\n  //Encode Data for cross-chain call.\n  bytes memory payload = abi.encodePacked(\n      _hasFallbackToggled ? bytes1(0x85) : bytes1(0x05),\n      //@audit-info => Encodes the address of the caller in the Branch and sends it to the RootBridgeAgent\n      //@audit-info => This address will be used to fetch the VirtualAccount assigned to it!\n      msg.sender,\n      _depositNonce,\n      _dParams.hToken,\n      _dParams.token,\n      _dParams.amount,\n      _dParams.deposit,\n      _params\n  );\n}\n```\n\n**RootBridgeAgent.sol:**\n\n```solidity\nfunction lzReceiveNonBlocking(\n  ...\n\n) public override requiresEndpoint(_endpoint, _srcChainId, _srcAddress) {\n  ...\n  ...\n  ...\n  else if (_payload[0] == 0x04) {\n      // Parse deposit nonce\n      nonce = uint32(bytes4(_payload[PARAMS_START_SIGNED:PARAMS_TKN_START_SIGNED]));\n\n      //Check if tx has already been executed\n      if (executionState[_srcChainId][nonce] != STATUS_READY) {\n          revert AlreadyExecutedTransaction();\n      }\n\n      //@audit-info => Reads the address of the msg.sender in the BranchBridgeAgent and forwards that address to the RootPort::fetchVirtualAccount()\n      // Get User Virtual Account\n      VirtualAccount userAccount = IPort(localPortAddress).fetchVirtualAccount(\n          address(uint160(bytes20(_payload[PARAMS_START:PARAMS_START_SIGNED])))\n      );\n\n      // Toggle Router Virtual Account use for tx execution\n      IPort(localPortAddress).toggleVirtualAccountApproved(userAccount, localRouterAddress);\n\n    ...\n    ...\n  }\n  ...\n  ...\n}\n\n```\n\n**RootPort.sol:**\n\n```solidity\n//@audit-info => Receives from the RootBridgeAgent contract the address of the caller in the BranchBridgeAgent contract\n//@audit-info => Fetches the VirtualAccount assigned to the _user address regardless from what Branch the call came from\nfunction fetchVirtualAccount(address _user) external override returns (VirtualAccount account) {\n    account = getUserAccount[_user];\n    if (address(account) == address(0)) account = addVirtualAccount(_user);\n}\n```\n\nLike the example, let's suppose that a user uses a MultiSigWallet contract to deposit tokens from Avax to Root, in the RootBridgeAgent contract. The address of the MultisigWallet will be used to create a Virtual Account, and all the `globalTokens` that were bridged will be deposited in this Virtual Account.\n\nNow, the problem is that the address of the MultisigWallet, might not be controlled by the same user on a different chain. For example, in Polygon, an attacker could gain control of the address of the same address of the MultisigWallet that was used to deposit tokens from Avax in the Root environment. An attacker can send a signed message from Polygon, using the same address of the MultisigWallet that deposited tokens from Avax, to the Root environment, requesting to withdraw the assets that the Virtual Account is holding in the Root environment to the Polygon Branch.\n\nWhen the message is processed by the Root environment, the address that will be used to obtain the Virtual Account will be the address that initiated the call in Polygon; which will be the same address of the user's MultisigWallet contract who deposited the assets from Avax. However, the Root environment, when fetching the virtual account, makes no distinctions between the branches. Thus, it will give access to the Virtual Account of the attacker's caller address and process the message in the Root environment.\n\nAs a result, an attacker can gain control of the Virtual Account of an account contract that was used to deposit assets from a chain into Root, by gaining control of the same address of the account contract that deposited the assets in a different chain.\n\nAs explained in detail on this [article written by Rekt](https://rekt.news/wintermute-rekt/), it is possible to gain control of the same address for contract accounts in a different chain; especially for those contract accounts that are deployed using the Gnosis Safe contracts:\n\n![SafeWallet Rekt Article Write Up](https://user-images.githubusercontent.com/135237830/283603636-43f35ddc-3017-4055-8f17-bc833f6ccc1f.png)\n\n### Recommended Mitigation Steps\n\nThe recommendation is to add some logic that validates if the caller address in the BranchBridgeAgent is a contract account or an EOA. If it's a contract account, send a special flag as part of the crosschain message, so that the RootBridgeAgent contract can know if the caller in the SrcBranch it's a contract or an EOA.\n\n- If the caller is an EOA, the caller's address can be assigned as the Virtual Account owner on all the chains, for EOAs there are no problems.\n\n- But, if the caller is a Contract Account, when fetching the virtual account forward to the SrcChain, and if a Virtual Account is created, authorize the caller address on the SrcBranch as the owner for that Virtual Account. This way, only the contract account in the SrcBranch can access the Virtual Account in the Root environment.\n\nMake sure to use the `srcChainId` to validate if the caller is an owner of the Virtual Account.\n\n### Assessed type\n\nAccess Control\n\n**[0xLightt (Maia) confirmed](https://github.com/code-423n4/2023-09-maia-findings/issues/877#issuecomment-1767123029):**\n > Contracts should not use Virtual Accounts and deploying a specific router for contract usage is most likely the safest option.\n\n**[alcueca (judge) increased severity to High and commented](https://github.com/code-423n4/2023-09-maia-findings/issues/877#issuecomment-1782581398):**\n > This is related to [#351](https://github.com/code-423n4/2023-09-maia-findings/issues/351) in the wrong assumption that a given address is controlled by the same individual in all chains. There are different attack vectors and impacts, but fixing that core assumption will solve all of them.\n\n**[alcueca (judge) commented](https://github.com/code-423n4/2023-09-maia-findings/issues/877#issuecomment-1782710130):**\n > The underlying issue is assuming that the same addresses are controlled by the same people in different chains, which is not necessarily true. While the sponsor states that contracts should not use virtual accounts, that is not specified in the documentation, and might only have been discovered in a future issue of rekt.\n\n**[Limbooo (warden) commented](https://github.com/code-423n4/2023-09-maia-findings/issues/877#issuecomment-1788441802):**\n>@alcueca - While I appreciate the in-depth analysis presented in the report, there's a fundamental discrepancy when it comes to the exploitability of the vulnerability mentioned.\n> \n> The report suggests that on Polygon, an attacker could simply gain control of an address identical to the MultiSigWallet from Avax. However, referring to a recent real-world scenario as detailed in the Wintermute incident, we observe that this assumption may be oversimplified.\n> \n> The Wintermute incident underscores the intricacies and challenges involved in gaining control of a similar address on a different chain:\n> \n> 1. The address would have to be unclaimed or unused on the target chain.\n> 2. Assuming the MultiSigWallet is used across multiple chains, the rightful owners might have already claimed the address.\n> 3. Even if the address is unclaimed, there are intricate steps involving replicating nonce values and other parameters to \"hijack\" the address, and this is far from being straightforward.\n> \n> Given these complexities and the potential for failure, it's crucial to approach the reported vulnerability with a nuanced understanding of its practical exploitability.\n\n**[ladboy233 (warden) commented](https://github.com/code-423n4/2023-09-maia-findings/issues/877#issuecomment-1792408036):**\n > Agree with the above comments, that there may be some efforts involved to gain control the same address. The wrong assumption that the same address is controlled by same person when using smart contract wallet does cost Wintermute to lose 20M OP token.\n> \n> Once funds are lost, the loss amount is large.\n> \n> In the case of wintermute, the multisig wallet is created using the opcode \"CREATE\" instead of \"CREATE2\". The create opcode is not really deprecated, and still be used.\n> \n> More info about the CREATE opcode [here](https://www.evm.codes/#f0?fork=shanghai) and [deterministic addresses](https://coinsbench.com/a-comprehensive-guide-to-the-create2-opcode-in-solidity-7c6d40e3f1af).\n> \n> Agree with high severity because the potential loss of funds is large.\n\n**[alcueca (judge) commented](https://github.com/code-423n4/2023-09-maia-findings/issues/877#issuecomment-1792833402):**\n> There is a significant chance of actual losses because of this vulnerability, that don't need to be enabled by any unlikely prior. The severity is High.\n\n**[0xBugsy (Maia) commented](https://github.com/code-423n4/2023-09-maia-findings/issues/877#issuecomment-1807194080):**\n > Addressed [here](https://github.com/Maia-DAO/2023-09-maia-remediations/commit/4df0350023d8e49055254c3973d472bcd3f57e33).\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-09-maia",
  "Code": [
    {
      "filename": "src/RootPort.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {IERC20hTokenRootFactory} from \"./interfaces/IERC20hTokenRootFactory.sol\";\nimport {IRootBridgeAgent as IBridgeAgent} from \"./interfaces/IRootBridgeAgent.sol\";\nimport {IRootPort, ICoreRootRouter, GasParams, VirtualAccount} from \"./interfaces/IRootPort.sol\";\n\nimport {ERC20hTokenRoot} from \"./token/ERC20hTokenRoot.sol\";\n\n/// @title Root Port - Omnichain Token Management Contract\n/// @author MaiaDAO\ncontract RootPort is Ownable, IRootPort {\n    using SafeTransferLib for address;\n\n    /*///////////////////////////////////////////////////////////////\n                            SETUP STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice True if setup is still ongoing, false otherwise.\n    bool internal _setup;\n\n    /// @notice True if core setup is still ongoing, false otherwise.\n    bool internal _setupCore;\n\n    /*///////////////////////////////////////////////////////////////\n                        ROOT PORT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Local Chain Id\n    uint256 public immutable localChainId;\n\n    /// @notice The address of local branch port responsible for handling local transactions.\n    address public localBranchPortAddress;\n\n    /// @notice The address of the core router in charge of adding new tokens to the system.\n    address public coreRootRouterAddress;\n\n    /// @notice The address of the core router in charge of adding new tokens to the system.\n    address public coreRootBridgeAgentAddress;\n\n    /*///////////////////////////////////////////////////////////////\n                        VIRTUAL ACCOUNT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping from user address to Virtual Account.\n    mapping(address user => VirtualAccount account) public getUserAccount;\n\n    /// @notice Holds the mapping from Virtual account to router address => bool.\n    /// @notice Stores whether a router is approved to spend a virtual account.\n    mapping(VirtualAccount acount => mapping(address router => bool allowed)) public isRouterApproved;\n\n    /*///////////////////////////////////////////////////////////////\n                        BRIDGE AGENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping from address to Bridge Agent.\n    mapping(uint256 chainId => bool isActive) public isChainId;\n\n    /// @notice Mapping from address to isBridgeAgent (bool).\n    mapping(address bridgeAgent => bool isActive) public isBridgeAgent;\n\n    /// @notice Bridge Agents deployed in root chain.\n    address[] public bridgeAgents;\n\n    /// @notice Mapping address Bridge Agent => address Bridge Agent Manager\n    mapping(address bridgeAgent => address bridgeAgentManager) public getBridgeAgentManager;\n\n    /*///////////////////////////////////////////////////////////////\n                    BRIDGE AGENT FACTORIES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping from Underlying Address to isUnderlying (bool).\n    mapping(address bridgeAgentFactory => bool isActive) public isBridgeAgentFactory;\n\n    /// @notice Bridge Agents deployed in root chain.\n    address[] public bridgeAgentFactories;\n\n    /*///////////////////////////////////////////////////////////////\n                            hTOKENS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping with all global hTokens deployed in the system.\n    mapping(address token => bool isGlobalToken) public isGlobalAddress;\n\n    /// @notice ChainId -> Local Address -> Global Address\n    mapping(address chainId => mapping(uint256 localAddress => address globalAddress)) public getGlobalTokenFromLocal;\n\n    /// @notice ChainId -> Global Address -> Local Address\n    mapping(address chainId => mapping(uint256 globalAddress => address localAddress)) public getLocalTokenFromGlobal;\n\n    /// @notice ChainId -> Underlying Address -> Local Address\n    mapping(address chainId => mapping(uint256 underlyingAddress => address localAddress)) public\n        getLocalTokenFromUnderlying;\n\n    /// @notice Mapping from Local Address to Underlying Address.\n    mapping(address chainId => mapping(uint256 localAddress => address underlyingAddress)) public\n        getUnderlyingTokenFromLocal;\n\n    /*///////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Constructor for Root Port.\n     * @param _localChainId layer zero chain id of the local chain.\n     */\n    constructor(uint256 _localChainId) {\n        localChainId = _localChainId;\n        isChainId[_localChainId] = true;\n\n        _initializeOwner(msg.sender);\n        _setup = true;\n        _setupCore = true;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    INITIALIZATION FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     *  @notice Function to initialize the Root Port.\n     *   @param _bridgeAgentFactory The address of the Bridge Agent Factory.\n     *   @param _coreRootRouter The address of the Core Root Router.\n     */\n    function initialize(address _bridgeAgentFactory, address _coreRootRouter) external onlyOwner {\n        require(_bridgeAgentFactory != address(0), \"Bridge Agent Factory cannot be 0 address.\");\n        require(_coreRootRouter != address(0), \"Core Root Router cannot be 0 address.\");\n        require(_setup, \"Setup ended.\");\n        _setup = false;\n\n        isBridgeAgentFactory[_bridgeAgentFactory] = true;\n        bridgeAgentFactories.push(_bridgeAgentFactory);\n\n        coreRootRouterAddress = _coreRootRouter;\n    }\n\n    /**\n     *  @notice Function to initialize the Root Chain Core Contracts in Port Storage.\n     *   @param _coreRootBridgeAgent The address of the Core Root Bridge Agent.\n     *   @param _coreLocalBranchBridgeAgent The address of the Core Arbitrum Branch Bridge Agent.\n     *   @param _localBranchPortAddress The address of the Arbitrum Branch Port.\n     */\n    function initializeCore(\n        address _coreRootBridgeAgent,\n        address _coreLocalBranchBridgeAgent,\n        address _localBranchPortAddress\n    ) external onlyOwner {\n        require(_coreRootBridgeAgent != address(0), \"Core Root Bridge Agent cannot be 0 address.\");\n        require(_coreLocalBranchBridgeAgent != address(0), \"Core Local Branch Bridge Agent cannot be 0 address.\");\n        require(_localBranchPortAddress != address(0), \"Local Branch Port Address cannot be 0 address.\");\n        require(isBridgeAgent[_coreRootBridgeAgent], \"Core Bridge Agent doesn't exist.\");\n        require(_setupCore, \"Core Setup ended.\");\n        _setupCore = false;\n\n        coreRootBridgeAgentAddress = _coreRootBridgeAgent;\n        localBranchPortAddress = _localBranchPortAddress;\n        IBridgeAgent(_coreRootBridgeAgent).syncBranchBridgeAgent(_coreLocalBranchBridgeAgent, localChainId);\n        getBridgeAgentManager[_coreRootBridgeAgent] = owner();\n    }\n\n    /// @notice Function being overriden to prevent mistakenly renouncing ownership.\n    function renounceOwnership() public payable override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        EXTERNAL VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootPort\n    function getLocalToken(address _localAddress, uint256 _srcChainId, uint256 _dstChainId)\n        external\n        view\n        override\n        returns (address)\n    {\n        return _getLocalToken(_localAddress, _srcChainId, _dstChainId);\n    }\n\n    /**\n     * @notice View Function returns Local Token's Local Address on another chain.\n     * @param _localAddress The address of the token in the local chain.\n     * @param _srcChainId The chainId of the chain where the token is deployed.\n     * @param _dstChainId The chainId of the chain for which the token address is requested.\n     */\n    function _getLocalToken(address _localAddress, uint256 _srcChainId, uint256 _dstChainId)\n        internal\n        view\n        returns (address)\n    {\n        address globalAddress = getGlobalTokenFromLocal[_localAddress][_srcChainId];\n        return getLocalTokenFromGlobal[globalAddress][_dstChainId];\n    }\n\n    /// @inheritdoc IRootPort\n    function getUnderlyingTokenFromGlobal(address _globalAddress, uint256 _srcChainId)\n        external\n        view\n        override\n        returns (address)\n    {\n        address localAddress = getLocalTokenFromGlobal[_globalAddress][_srcChainId];\n        return getUnderlyingTokenFromLocal[localAddress][_srcChainId];\n    }\n\n    /// @inheritdoc IRootPort\n    function isGlobalToken(address _globalAddress, uint256 _srcChainId) external view override returns (bool) {\n        return getLocalTokenFromGlobal[_globalAddress][_srcChainId] != address(0);\n    }\n\n    /// @inheritdoc IRootPort\n    function isLocalToken(address _localAddress, uint256 _srcChainId) external view override returns (bool) {\n        return getGlobalTokenFromLocal[_localAddress][_srcChainId] != address(0);\n    }\n\n    /// @inheritdoc IRootPort\n    function isLocalToken(address _localAddress, uint256 _srcChainId, uint256 _dstChainId)\n        external\n        view\n        returns (bool)\n    {\n        return _getLocalToken(_localAddress, _srcChainId, _dstChainId) != address(0);\n    }\n\n    /// @inheritdoc IRootPort\n    function isUnderlyingToken(address _underlyingToken, uint256 _srcChainId) external view override returns (bool) {\n        return getLocalTokenFromUnderlying[_underlyingToken][_srcChainId] != address(0);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        hTOKEN MANAGEMENT FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootPort\n    function setAddresses(\n        address _globalAddress,\n        address _localAddress,\n        address _underlyingAddress,\n        uint256 _srcChainId\n    ) external override requiresCoreRootRouter {\n        if (_globalAddress == address(0)) revert InvalidGlobalAddress();\n        if (_localAddress == address(0)) revert InvalidLocalAddress();\n        if (_underlyingAddress == address(0)) revert InvalidUnderlyingAddress();\n\n        isGlobalAddress[_globalAddress] = true;\n        getGlobalTokenFromLocal[_localAddress][_srcChainId] = _globalAddress;\n        getLocalTokenFromGlobal[_globalAddress][_srcChainId] = _localAddress;\n        getLocalTokenFromUnderlying[_underlyingAddress][_srcChainId] = _localAddress;\n        getUnderlyingTokenFromLocal[_localAddress][_srcChainId] = _underlyingAddress;\n\n        emit LocalTokenAdded(_underlyingAddress, _localAddress, _globalAddress, _srcChainId);\n    }\n\n    /// @inheritdoc IRootPort\n    function setLocalAddress(address _globalAddress, address _localAddress, uint256 _srcChainId)\n        external\n        override\n        requiresCoreRootRouter\n    {\n        if (_localAddress == address(0)) revert InvalidLocalAddress();\n\n        getGlobalTokenFromLocal[_localAddress][_srcChainId] = _globalAddress;\n        getLocalTokenFromGlobal[_globalAddress][_srcChainId] = _localAddress;\n\n        emit GlobalTokenAdded(_localAddress, _globalAddress, _srcChainId);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        hTOKEN ACCOUNTING FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootPort\n    function bridgeToRoot(address _recipient, address _hToken, uint256 _amount, uint256 _deposit, uint256 _srcChainId)\n        external\n        override\n        requiresBridgeAgent\n    {\n        if (!isGlobalAddress[_hToken]) revert UnrecognizedToken();\n\n        if (_amount - _deposit > 0) {\n            unchecked {\n                _hToken.safeTransfer(_recipient, _amount - _deposit);\n            }\n        }\n\n        if (_deposit > 0) if (!ERC20hTokenRoot(_hToken).mint(_recipient, _deposit, _srcChainId)) revert UnableToMint();\n    }\n\n    /// @inheritdoc IRootPort\n    function bridgeToRootFromLocalBranch(address _from, address _hToken, uint256 _amount)\n        external\n        override\n        requiresLocalBranchPort\n    {\n        if (!isGlobalAddress[_hToken]) revert UnrecognizedToken();\n\n        _hToken.safeTransferFrom(_from, address(this), _amount);\n    }\n\n    function bridgeToLocalBranchFromRoot(address _to, address _hToken, uint256 _amount)\n        external\n        override\n        requiresLocalBranchPort\n    {\n        if (!isGlobalAddress[_hToken]) revert UnrecognizedToken();\n\n        _hToken.safeTransfer(_to, _amount);\n    }\n\n    /// @inheritdoc IRootPort\n    function burn(address _from, address _hToken, uint256 _amount, uint256 _srcChainId)\n        external\n        override\n        requiresBridgeAgent\n    {\n        if (!isGlobalAddress[_hToken]) revert UnrecognizedToken();\n        ERC20hTokenRoot(_hToken).burn(_from, _amount, _srcChainId);\n    }\n\n    /// @inheritdoc IRootPort\n    function burnFromLocalBranch(address _from, address _hToken, uint256 _amount)\n        external\n        override\n        requiresLocalBranchPort\n    {\n        if (!isGlobalAddress[_hToken]) revert UnrecognizedToken();\n\n        ERC20hTokenRoot(_hToken).burn(_from, _amount, localChainId);\n    }\n\n    /// @inheritdoc IRootPort\n    function mintToLocalBranch(address _to, address _hToken, uint256 _amount)\n        external\n        override\n        requiresLocalBranchPort\n    {\n        if (!isGlobalAddress[_hToken]) revert UnrecognizedToken();\n        if (!ERC20hTokenRoot(_hToken).mint(_to, _amount, localChainId)) revert UnableToMint();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    VIRTUAL ACCOUNT MANAGEMENT FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootPort\n    function fetchVirtualAccount(address _user) external override returns (VirtualAccount account) {\n        account = getUserAccount[_user];\n        if (address(account) == address(0)) account = addVirtualAccount(_user);\n    }\n\n    /**\n     * @notice Creates a new virtual account for a user.\n     * @param _user address of the user to associate a virtual account with.\n     */\n    function addVirtualAccount(address _user) internal returns (VirtualAccount newAccount) {\n        if (_user == address(0)) revert InvalidUserAddress();\n\n        newAccount = new VirtualAccount{salt: keccak256(abi.encode(_user))}(_user, address(this));\n        getUserAccount[_user] = newAccount;\n\n        emit VirtualAccountCreated(_user, address(newAccount));\n    }\n\n    /// @inheritdoc IRootPort\n    function toggleVirtualAccountApproved(VirtualAccount _userAccount, address _router)\n        external\n        override\n        requiresBridgeAgent\n    {\n        isRouterApproved[_userAccount][_router] = !isRouterApproved[_userAccount][_router];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        BRIDGE AGENT ADDITION FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootPort\n    function addBridgeAgent(address _manager, address _bridgeAgent) external override requiresBridgeAgentFactory {\n        if (isBridgeAgent[_bridgeAgent]) revert AlreadyAddedBridgeAgent();\n\n        bridgeAgents.push(_bridgeAgent);\n        getBridgeAgentManager[_bridgeAgent] = _manager;\n        isBridgeAgent[_bridgeAgent] = true;\n\n        emit BridgeAgentAdded(_bridgeAgent, _manager);\n    }\n\n    /// @inheritdoc IRootPort\n    function syncBranchBridgeAgentWithRoot(\n        address _newBranchBridgeAgent,\n        address _rootBridgeAgent,\n        uint256 _branchChainId\n    ) external override requiresCoreRootRouter {\n        if (IBridgeAgent(_rootBridgeAgent).getBranchBridgeAgent(_branchChainId) != address(0)) {\n            revert AlreadyAddedBridgeAgent();\n        }\n        if (!IBridgeAgent(_rootBridgeAgent).isBranchBridgeAgentAllowed(_branchChainId)) {\n            revert BridgeAgentNotAllowed();\n        }\n        IBridgeAgent(_rootBridgeAgent).syncBranchBridgeAgent(_newBranchBridgeAgent, _branchChainId);\n\n        emit BridgeAgentSynced(_newBranchBridgeAgent, _rootBridgeAgent, _branchChainId);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootPort\n    function toggleBridgeAgent(address _bridgeAgent) external override onlyOwner {\n        isBridgeAgent[_bridgeAgent] = !isBridgeAgent[_bridgeAgent];\n\n        emit BridgeAgentToggled(_bridgeAgent);\n    }\n\n    /// @inheritdoc IRootPort\n    function addBridgeAgentFactory(address _bridgeAgentFactory) external override onlyOwner {\n        if (isBridgeAgentFactory[_bridgeAgentFactory]) revert AlreadyAddedBridgeAgentFactory();\n\n        bridgeAgentFactories.push(_bridgeAgentFactory);\n        isBridgeAgentFactory[_bridgeAgentFactory] = true;\n\n        emit BridgeAgentFactoryAdded(_bridgeAgentFactory);\n    }\n\n    /// @inheritdoc IRootPort\n    function toggleBridgeAgentFactory(address _bridgeAgentFactory) external override onlyOwner {\n        isBridgeAgentFactory[_bridgeAgentFactory] = !isBridgeAgentFactory[_bridgeAgentFactory];\n\n        emit BridgeAgentFactoryToggled(_bridgeAgentFactory);\n    }\n\n    /// @inheritdoc IRootPort\n    function addNewChain(\n        address _coreBranchBridgeAgentAddress,\n        uint256 _chainId,\n        string memory _wrappedGasTokenName,\n        string memory _wrappedGasTokenSymbol,\n        uint8 _wrappedGasTokenDecimals,\n        address _newLocalBranchWrappedNativeTokenAddress,\n        address _newUnderlyingBranchWrappedNativeTokenAddress\n    ) external override onlyOwner {\n        // Check if chain already added\n        if (isChainId[_chainId]) revert AlreadyAddedChain();\n\n        // Create new global token for new chain's wrapped native token\n        address newGlobalToken = address(\n            IERC20hTokenRootFactory(ICoreRootRouter(coreRootRouterAddress).hTokenFactoryAddress()).createToken(\n                _wrappedGasTokenName, _wrappedGasTokenSymbol, _wrappedGasTokenDecimals\n            )\n        );\n\n        // Sync new branch bridge agent with root core bridge agent\n        IBridgeAgent(ICoreRootRouter(coreRootRouterAddress).bridgeAgentAddress()).syncBranchBridgeAgent(\n            _coreBranchBridgeAgentAddress, _chainId\n        );\n\n        // Update State\n\n        // 1. Add new chain to chainId mapping\n        isChainId[_chainId] = true;\n        // 2. Add new chain to global address mapping\n        isGlobalAddress[newGlobalToken] = true;\n        // 3. Add new branch local token to global token address mapping\n        getGlobalTokenFromLocal[_newLocalBranchWrappedNativeTokenAddress][_chainId] = newGlobalToken;\n        // 4. Add new global token to branch local token address mapping\n        getLocalTokenFromGlobal[newGlobalToken][_chainId] = _newLocalBranchWrappedNativeTokenAddress;\n        // 5. Add new branch underlying token to branch local token address mapping\n        getLocalTokenFromUnderlying[_newUnderlyingBranchWrappedNativeTokenAddress][_chainId] =\n            _newLocalBranchWrappedNativeTokenAddress;\n        // 6. Add new branch local token to branch underlying token address mapping\n        getUnderlyingTokenFromLocal[_newLocalBranchWrappedNativeTokenAddress][_chainId] =\n            _newUnderlyingBranchWrappedNativeTokenAddress;\n\n        emit NewChainAdded(_chainId);\n    }\n\n    /// @inheritdoc IRootPort\n    function addEcosystemToken(address _ecoTokenGlobalAddress) external override onlyOwner {\n        // Check if token already added\n        if (isGlobalAddress[_ecoTokenGlobalAddress]) revert AlreadyAddedEcosystemToken();\n\n        // Check if token is already a underlying token in current chain\n        if (getUnderlyingTokenFromLocal[_ecoTokenGlobalAddress][localChainId] != address(0)) {\n            revert AlreadyAddedEcosystemToken();\n        }\n\n        // Check if token is already a local branch token in current chain\n        if (getLocalTokenFromUnderlying[_ecoTokenGlobalAddress][localChainId] != address(0)) {\n            revert AlreadyAddedEcosystemToken();\n        }\n\n        // Update State\n        // 1. Add new global token to global address mapping\n        isGlobalAddress[_ecoTokenGlobalAddress] = true;\n        // 2. Add new branch local token address to global token mapping\n        getGlobalTokenFromLocal[_ecoTokenGlobalAddress][localChainId] = _ecoTokenGlobalAddress;\n        // 3. Add new global token to branch local token address mapping\n        getLocalTokenFromGlobal[_ecoTokenGlobalAddress][localChainId] = _ecoTokenGlobalAddress;\n\n        emit EcosystemTokenAdded(_ecoTokenGlobalAddress);\n    }\n\n    /// @inheritdoc IRootPort\n    function setCoreRootRouter(address _coreRootRouter, address _coreRootBridgeAgent) external override onlyOwner {\n        if (_coreRootRouter == address(0)) revert InvalidCoreRootRouter();\n        if (_coreRootBridgeAgent == address(0)) revert InvalidCoreRootBridgeAgent();\n\n        coreRootRouterAddress = _coreRootRouter;\n        coreRootBridgeAgentAddress = _coreRootBridgeAgent;\n        getBridgeAgentManager[_coreRootBridgeAgent] = owner();\n\n        emit CoreRootSet(_coreRootRouter, _coreRootBridgeAgent);\n    }\n\n    /// @inheritdoc IRootPort\n    function setCoreBranchRouter(\n        address _refundee,\n        address _coreBranchRouter,\n        address _coreBranchBridgeAgent,\n        uint16 _dstChainId,\n        GasParams calldata _gParams\n    ) external payable override onlyOwner {\n        if (_coreBranchRouter == address(0)) revert InvalidCoreBranchRouter();\n        if (_coreBranchBridgeAgent == address(0)) revert InvalidCoreBrancBridgeAgent();\n\n        ICoreRootRouter(coreRootRouterAddress).setCoreBranch{value: msg.value}(\n            _refundee, _coreBranchRouter, _coreBranchBridgeAgent, _dstChainId, _gParams\n        );\n\n        emit CoreBranchSet(_coreBranchRouter, _coreBranchBridgeAgent, _dstChainId);\n    }\n\n    /// @inheritdoc IRootPort\n    function syncNewCoreBranchRouter(address _coreBranchRouter, address _coreBranchBridgeAgent, uint16 _dstChainId)\n        external\n        override\n        onlyOwner\n    {\n        if (_coreBranchRouter == address(0)) revert InvalidCoreBranchRouter();\n        if (_coreBranchBridgeAgent == address(0)) revert InvalidCoreBrancBridgeAgent();\n\n        IBridgeAgent(coreRootBridgeAgentAddress).syncBranchBridgeAgent(_coreBranchBridgeAgent, _dstChainId);\n\n        emit CoreBranchSynced(_coreBranchRouter, _coreBranchBridgeAgent, _dstChainId);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Modifier that verifies msg sender is an active Bridge Agent Factory.\n    modifier requiresBridgeAgentFactory() {\n        if (!isBridgeAgentFactory[msg.sender]) revert UnrecognizedBridgeAgentFactory();\n        _;\n    }\n\n    /// @notice Modifier that verifies msg sender is an active Bridge Agent.\n    modifier requiresBridgeAgent() {\n        if (!isBridgeAgent[msg.sender]) revert UnrecognizedBridgeAgent();\n        _;\n    }\n\n    /// @notice Modifier that verifies msg sender is the Root Chain's Core Router.\n    modifier requiresCoreRootRouter() {\n        if (msg.sender != coreRootRouterAddress) revert UnrecognizedCoreRootRouter();\n        _;\n    }\n\n    /// @notice Modifier that verifies msg sender is the Root Chain's Local Branch Port.\n    modifier requiresLocalBranchPort() {\n        if (msg.sender != localBranchPortAddress) revert UnrecognizedLocalBranchPort();\n        _;\n    }\n}"
    }
  ]
}