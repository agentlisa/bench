{
  "Title": "[H-02] `UniswapV2PriceOracle.sol` `currentCumulativePrices()` will revert when `priceCumulative` addition overflow",
  "Content": "_Submitted by WatchPug_\n\n[UniswapV2PriceOracle.sol#L62](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/UniswapV2PriceOracle.sol#L62)<br>\n\n```solidity\n(uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) = address(pair).currentCumulativePrices();\n```\n\nBecause the Solidity version used by the current implementation of `UniswapV2OracleLibrary.sol` is `>=0.8.7`, and there are some breaking changes in Solidity v0.8.0:\n\n> Arithmetic operations revert on underflow and overflow.\n\nRef: <https://docs.soliditylang.org/en/v0.8.13/080-breaking-changes.html#silent-changes-of-the-semantics>\n\nWhile in `UniswapV2OracleLibrary.sol`, subtraction overflow is desired at `blockTimestamp - blockTimestampLast` in `currentCumulativePrices()`:\n\n<https://github.com/Uniswap/v2-periphery/blob/master/contracts/libraries/UniswapV2OracleLibrary.sol#L25-L33>\n\n```solidity\nif (blockTimestampLast != blockTimestamp) {\n    // subtraction overflow is desired\n    uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n    // addition overflow is desired\n    // counterfactual\n    price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\n    // counterfactual\n    price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\n}\n```\n\nIn another word, `Uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary` only works at solidity < `0.8.0`.\n\nAs a result, when `price0Cumulative` or `price1Cumulative` is big enough, `currentCumulativePrices` will revert due to overflow.\n\n### Impact\n\nSince the overflow is desired in the original version, and it's broken because of using Solidity version >0.8. The `UniswapV2PriceOracle` contract will break when the desired overflow happens, and further breaks other parts of the system that relies on `UniswapV2PriceOracle`.\n\n### Recommended Mitigation Steps\n\nNote: this recommended fix requires a fork of the library contract provided by Uniswap.\n\nChange to:\n\n```solidity\nif (blockTimestampLast != blockTimestamp) {\n    unchecked {\n        // subtraction overflow is desired\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n        // addition overflow is desired\n        // counterfactual\n        price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\n        // counterfactual\n        price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\n    }\n}\n```\n\n**[jn-lp (Phuture Finance) confirmed and resolved](https://github.com/code-423n4/2022-04-phuture-findings/issues/62)**\n\n\n\n***\n\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-04-phuture-finance-contest",
  "Code": [
    {
      "filename": "contracts/UniswapV2PriceOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity >=0.8.7;\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport \"@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol\";\n\nimport \"./interfaces/IUniswapV2PriceOracle.sol\";\n\n/// @title Uniswap V2 price oracle\n/// @notice Contains logic for price calculation of asset using Uniswap V2 Pair\n/// @dev Oracle works through base asset which is set in initialize function\ncontract UniswapV2PriceOracle is IUniswapV2PriceOracle, ERC165 {\n    using UniswapV2OracleLibrary for address;\n\n    /// @notice Minimum oracle update interval\n    /// @dev If min update interval hasn't passed (24h) before update, previously cached value is returned\n    uint private constant MIN_UPDATE_INTERVAL = 24 hours;\n\n    IUniswapV2Pair immutable pair;\n    /// @inheritdoc IUniswapV2PriceOracle\n    address public immutable override asset0;\n    /// @inheritdoc IUniswapV2PriceOracle\n    address public immutable override asset1;\n\n    uint private price0CumulativeLast;\n    uint private price1CumulativeLast;\n    uint32 private blockTimestampLast;\n    uint private price0Average;\n    uint private price1Average;\n\n    constructor(\n        address _factory,\n        address _assetA,\n        address _assetB\n    ) {\n        IUniswapV2Pair _pair = IUniswapV2Pair(IUniswapV2Factory(_factory).getPair(_assetA, _assetB));\n        pair = _pair;\n        asset0 = _pair.token0();\n        asset1 = _pair.token1();\n\n        uint112 reserve0;\n        uint112 reserve1;\n        (reserve0, reserve1, blockTimestampLast) = _pair.getReserves();\n        require(reserve0 != 0 && reserve1 != 0, \"UniswapV2PriceOracle: RESERVES\");\n\n        uint _price0CumulativeLast = _pair.price0CumulativeLast();\n        uint _price1CumulativeLast = _pair.price1CumulativeLast();\n        (uint price0Cml, uint price1Cml, uint32 blockTimestamp) = address(_pair).currentCumulativePrices();\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n        price0CumulativeLast = _price0CumulativeLast;\n        price1CumulativeLast = _price1CumulativeLast;\n        price0Average = (price0Cml - _price0CumulativeLast) / timeElapsed;\n        price1Average = (price1Cml - _price1CumulativeLast) / timeElapsed;\n    }\n\n    /// @inheritdoc IPriceOracle\n    /// @dev Updates and returns cumulative price value\n    /// @dev If min update interval hasn't passed (24h), previously cached value is returned\n    function refreshedAssetPerBaseInUQ(address _asset) external override returns (uint) {\n        (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) = address(pair).currentCumulativePrices();\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n\n        if (timeElapsed >= MIN_UPDATE_INTERVAL) {\n            price0Average = (price0Cumulative - price0CumulativeLast) / timeElapsed;\n            price1Average = (price1Cumulative - price1CumulativeLast) / timeElapsed;\n\n            price0CumulativeLast = price0Cumulative;\n            price1CumulativeLast = price1Cumulative;\n            blockTimestampLast = blockTimestamp;\n        }\n\n        return lastAssetPerBaseInUQ(_asset);\n    }\n\n    /// @inheritdoc IPriceOracle\n    /// @dev Returns cumulative price value cached during last refresh call\n    function lastAssetPerBaseInUQ(address _asset) public view override returns (uint) {\n        if (_asset == asset0) {\n            return price1Average;\n        } else {\n            require(_asset == asset1, \"UniswapV2PriceOracle: UNKNOWN\");\n            return price0Average;\n        }\n    }\n\n    /// @inheritdoc ERC165\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return\n            _interfaceId == type(IUniswapV2PriceOracle).interfaceId ||\n            _interfaceId == type(IPriceOracle).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n}"
    },
    {
      "filename": "contracts/libraries/UniswapV2OracleLibrary.sol",
      "content": "pragma solidity >=0.5.0;\n\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\nimport '@uniswap/lib/contracts/libraries/FixedPoint.sol';\n\n// library with helper methods for oracles that are concerned with computing average prices\nlibrary UniswapV2OracleLibrary {\n    using FixedPoint for *;\n\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n    function currentBlockTimestamp() internal view returns (uint32) {\n        return uint32(block.timestamp % 2 ** 32);\n    }\n\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n    function currentCumulativePrices(\n        address pair\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\n        blockTimestamp = currentBlockTimestamp();\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\n        if (blockTimestampLast != blockTimestamp) {\n            // subtraction overflow is desired\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n            // addition overflow is desired\n            // counterfactual\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\n            // counterfactual\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\n        }\n    }\n}"
    }
  ]
}