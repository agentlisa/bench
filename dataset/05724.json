{
  "Title": "[39] Using `msg.timestamp` as an expiration timestamp invites MEV manipulations",
  "Content": "\n### Impact\n\nSetting the expiration timestamp to a value that depends directly of `block.timestamp` is useless, as `block.timestamp` is the timestamp when the transaction is **EXECUTED**, not when it is submitted to the network, opening the door to MEV manipulations. Think of the typical Uniswap-based bug in which expiration timestamp is set to `block.timestamp + K`, but applied to inter-chain swaps or highly-sensitive time-dependant operations (e. g. arbitrage or inter-chain DEXes like [Interport](https://interport.medium.com/interport-finance-whats-special-a5ea7caef237)).\n\n### Proof of concept\n\nThanks to Proof of Stake, validators and, in fact, everyone in the Ethereum network knows who is gonna submit the next block with a margin of 6 minutes and 24 seconds to 12 minutes and 48 seconds (see the References section below). That's enough time for bots and validators to do MEV calculations for many of the transactions waiting in the mempool **AND** submit their own with the right amount of gas to make sure their transactions are executed within the next block. Because of this, highly-sensitive operations like swaps between tokens need 1) slippage control and 2) expiration timestamps so that users will **NOT** incur in extreme losses due to MEV bots sandwiching/front-running them or validators *\"storing\"* transactions until they can make a profitable *\"chain\"*.\n\nThis idea can be extended to inter-chain operations pretty easily, so that the requested transactions from one layer to another do not wait idly in the mempool of the first one. However, doing request from Ethereum to zkSync Era through `Mailbox`, the expiration timestamp is set to:\n\n[Mailbox, line 295](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L295)\n\n```solidity\n        uint64 expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION); // Safe to cast\n```\n\nWith:\n\n[Config, line 46](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/Config.sol#L46)\n\n```solidity\nuint256 constant PRIORITY_EXPIRATION = 0 days;\n```\n\nWhich equals `block.timestamp`, which is bad as its value will **NOT** be the time the user submitted the transaction to the network, but the time the transaction is picked by a validator and included in a block. That means, virtually, there is no expiration timestamp for such a transaction.\n\nSome ways to exploit this, from a hacker's POV, is via rogue validators (see [here](https://news.bitcoin.com/rogue-validator-exploits-mev-bots-on-ethereum-resulting-in-25-3m-in-crypto-losses)) or *\"chained transaction-blocks\"*. The idea is that, thanks to POS, the odds for a validator to execute sequentially `n > 2` blocks increases with the amount of ETH staked so it is possible to delay a highly profitable transaction and place it between two validator-controlled blocks and sandwich it on zkSync Era (as they are executed sequentially via [a priority queue](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L369)). This issue is real and feasible, although pretty expensive, but the damages to users may be huge if they are doing, say, an inter-chain [Furocombo](https://furucombo.app/combo) combo worth 3 million dollars or any other type of highly-sensitive inter-chain operation.\n\n### Recommended Mitigation steps\n\nPass the expiration timestamp as a function argument retrieved from the front-end and revert if it is less than the `block.timestamp` in which the transaction is executed:\n\n[Mailbox, function `requestL2Transaction`](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L236C1-L273C6)\n\n```diff\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n-       address _refundRecipient\n+       address _refundRecipient,\n+       uint64 _expirationTimestamp\n    ) external payable nonReentrant senderCanCallFunction(s.allowList) returns (bytes32 canonicalTxHash) {\n+       require(_expirationTimestamp > block.timestamp, \"MEV trying to do their things\");\n        // Change the sender address if it is a smart contract to prevent address collision between L1 and L2.\n        // Please note, currently zkSync address derivation is different from Ethereum one, but it may be changed in the future.\n        address sender = msg.sender;\n        if (sender != tx.origin) {\n            sender = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n        }\n\n        // Enforcing that `_l2GasPerPubdataByteLimit` equals to a certain constant number. This is needed\n        // to ensure that users do not get used to using \"exotic\" numbers for _l2GasPerPubdataByteLimit, e.g. 1-2, etc.\n        // VERY IMPORTANT: nobody should rely on this constant to be fixed and every contract should give their users the ability to provide the\n        // ability to provide `_l2GasPerPubdataByteLimit` for each independent transaction.\n        // CHANGING THIS CONSTANT SHOULD BE A CLIENT-SIDE CHANGE.\n        require(_l2GasPerPubdataByteLimit == REQUIRED_L2_GAS_PRICE_PER_PUBDATA, \"qp\");\n\n        // The L1 -> L2 transaction may be failed and funds will be sent to the `_refundRecipient`,\n        // so we use `msg.value` instead of `_l2Value` as the bridged amount.\n        _verifyDepositLimit(msg.sender, msg.value);\n        canonicalTxHash = _requestL2Transaction(\n            sender,\n            _contractL2,\n            _l2Value,\n            _calldata,\n            _l2GasLimit,\n            _l2GasPerPubdataByteLimit,\n            _factoryDeps,\n            false,\n-           _refundRecipient\n+           _refundRecipient,\n+           _expirationTimestamp\n        );\n    }\n```\n\n[Mailbox, function `_requestL2Transaction`](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L283C1-L327C6)\n\n```diff\n    function _requestL2Transaction(\n        address _sender,\n        address _contractAddressL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        bool _isFree,\n-       address _refundRecipient\n+       address _refundRecipient,\n+       uint64 _expirationTimestamp\n    ) internal returns (bytes32 canonicalTxHash) {\n        require(_factoryDeps.length <= MAX_NEW_FACTORY_DEPS, \"uj\");\n-       uint64 expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION); // Safe to cast\n        uint256 txId = s.priorityQueue.getTotalPriorityTxs();\n\n        // Here we manually assign fields for the struct to prevent \"stack too deep\" error\n        WritePriorityOpParams memory params;\n\n        // Checking that the user provided enough ether to pay for the transaction.\n        // Using a new scope to prevent \"stack too deep\" error\n        {\n            params.l2GasPrice = _isFree ? 0 : _deriveL2GasPrice(tx.gasprice, _l2GasPerPubdataByteLimit);\n            uint256 baseCost = params.l2GasPrice * _l2GasLimit;\n            require(msg.value >= baseCost + _l2Value, \"mv\"); // The `msg.value` doesn't cover the transaction cost\n        }\n\n        // If the `_refundRecipient` is not provided, we use the `_sender` as the recipient.\n        address refundRecipient = _refundRecipient == address(0) ? _sender : _refundRecipient;\n        // If the `_refundRecipient` is a smart contract, we apply the L1 to L2 alias to prevent foot guns.\n        if (refundRecipient.code.length > 0) {\n            refundRecipient = AddressAliasHelper.applyL1ToL2Alias(refundRecipient);\n        }\n\n        params.sender = _sender;\n        params.txId = txId;\n        params.l2Value = _l2Value;\n        params.contractAddressL2 = _contractAddressL2;\n-       params.expirationTimestamp = expirationTimestamp;\n+       params.expirationTimestamp = _expirationTimestamp;\n        params.l2GasLimit = _l2GasLimit;\n        params.l2GasPricePerPubdata = _l2GasPerPubdataByteLimit;\n        params.valueToMint = msg.value;\n        params.refundRecipient = refundRecipient;\n\n        canonicalTxHash = _writePriorityOp(params, _calldata, _factoryDeps);\n    }\n```\n\nOn top of that, change the `deposit` functions in both bridges to match the ABI of the new `requestL2Transaction` and remove the `PRIORITY_EXPIRATION` constant in [Config, line 46](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/Config.sol#L46).\n\n### References\n\n[https://blog.uniswap.org/uniswap-v3-oracles?utm_source=blog.bytes032.xyz&utm_medium=referral&utm_campaign=why-you-should-stop-using-block-timestamp-as-deadline-in-swaps#how-much-does-a-two-block-20-manipulation-require](https://blog.uniswap.org/uniswap-v3-oracles?utm_source=blog.bytes032.xyz&utm_medium=referral&utm_campaign=why-you-should-stop-using-block-timestamp-as-deadline-in-swaps#how-much-does-a-two-block-20-manipulation-require)\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-10-zksync",
  "Code": [
    {
      "filename": "code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport {IMailbox, TxStatus} from \"../interfaces/IMailbox.sol\";\nimport {Merkle} from \"../libraries/Merkle.sol\";\nimport {PriorityQueue, PriorityOperation} from \"../libraries/PriorityQueue.sol\";\nimport {TransactionValidator} from \"../libraries/TransactionValidator.sol\";\nimport {L2Message, L2Log} from \"../Storage.sol\";\nimport {UncheckedMath} from \"../../common/libraries/UncheckedMath.sol\";\nimport {UnsafeBytes} from \"../../common/libraries/UnsafeBytes.sol\";\nimport {L2ContractHelper} from \"../../common/libraries/L2ContractHelper.sol\";\nimport {AddressAliasHelper} from \"../../vendor/AddressAliasHelper.sol\";\nimport {IAllowList} from \"../../common/interfaces/IAllowList.sol\";\nimport {Base} from \"./Base.sol\";\nimport {\n    REQUIRED_L2_GAS_PRICE_PER_PUBDATA,\n    FAIR_L2_GAS_PRICE,\n    L1_GAS_PER_PUBDATA_BYTE,\n    L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH,\n    PRIORITY_OPERATION_L2_TX_TYPE,\n    PRIORITY_EXPIRATION,\n    MAX_NEW_FACTORY_DEPS\n} from \"../Config.sol\";\nimport {\n    L2_BOOTLOADER_ADDRESS,\n    L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR,\n    L2_ETH_TOKEN_SYSTEM_CONTRACT_ADDR\n} from \"../../common/L2ContractAddresses.sol\";\n\n\n/// @title zkSync Mailbox contract providing interfaces for L1 <-> L2 interaction.\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ncontract MailboxFacet is Base, IMailbox {\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n\n    string public constant override getName = \"MailboxFacet\";\n\n    /// @notice Prove that a specific arbitrary-length message was sent in a specific L2 batch number\n    /// @param _batchNumber The executed L2 batch number in which the message appeared\n    /// @param _index The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _message Information about the sent message: sender address, the message itself, tx index in the L2 batch where the message was sent\n    /// @param _proof Merkle proof for inclusion of L2 log that was sent with the message\n    /// @return Whether the proof is valid\n    function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message memory _message,\n        bytes32[] calldata _proof\n    ) public view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _L2MessageToLog(_message), _proof);\n    }\n\n    /// @notice Prove that a specific L2 log was sent in a specific L2 batch\n    /// @param _batchNumber The executed L2 batch number in which the log appeared\n    /// @param _index The position of the l2log in the L2 logs Merkle tree\n    /// @param _log Information about the sent log\n    /// @param _proof Merkle proof for inclusion of the L2 log\n    /// @return Whether the proof is correct and L2 log is included in batch\n    function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _log, _proof);\n    }\n\n    /// @notice Prove that the L1 -> L2 transaction was processed with the specified status.\n    /// @param _l2TxHash The L2 canonical transaction hash\n    /// @param _l2BatchNumber The L2 batch number where the transaction was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction\n    /// @param _status The execution status of the L1 -> L2 transaction (true - success & 0 - fail)\n    /// @return Whether the proof is correct and the transaction was actually executed with provided status\n    /// NOTE: It may return `false` for incorrect proof, but it doesn't mean that the L1 -> L2 transaction has an opposite status!\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) public view override returns (bool) {\n        // Bootloader sends an L2 -> L1 log only after processing the L1 -> L2 transaction.\n        // Thus, we can verify that the L1 -> L2 transaction was included in the L2 batch with specified status.\n        //\n        // The semantics of such L2 -> L1 log is always:\n        // - sender = L2_BOOTLOADER_ADDRESS\n        // - key = hash(L1ToL2Transaction)\n        // - value = status of the processing transaction (1 - success & 0 - fail)\n        // - isService = true (just a conventional value)\n        // - l2ShardId = 0 (means that L1 -> L2 transaction was processed in a rollup shard, other shards are not available yet anyway)\n        // - txNumberInBatch = number of transaction in the batch\n        L2Log memory l2Log = L2Log({\n            l2ShardId: 0,\n            isService: true,\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: L2_BOOTLOADER_ADDRESS,\n            key: _l2TxHash,\n            value: bytes32(uint256(_status))\n        });\n        return _proveL2LogInclusion(_l2BatchNumber, _l2MessageIndex, l2Log, _merkleProof);\n    }\n\n    /// @notice Transfer ether from the contract to the receiver\n    /// @dev Reverts only if the transfer call failed\n    function _withdrawFunds(address _to, uint256 _amount) internal {\n        bool callSuccess;\n        // Low-level assembly call, to avoid any memory copying (save gas)\n        assembly {\n            callSuccess := call(gas(), _to, _amount, 0, 0, 0, 0)\n        }\n        require(callSuccess, \"pz\");\n    }\n\n    /// @dev Prove that a specific L2 log was sent in a specific L2 batch number\n    function _proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) internal view returns (bool) {\n        require(_batchNumber <= s.totalBatchesExecuted, \"xx\");\n\n        bytes32 hashedLog = keccak256(\n            abi.encodePacked(_log.l2ShardId, _log.isService, _log.txNumberInBatch, _log.sender, _log.key, _log.value)\n        );\n        // Check that hashed log is not the default one,\n        // otherwise it means that the value is out of range of sent L2 -> L1 logs\n        require(hashedLog != L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH, \"tw\");\n\n        // It is ok to not check length of `_proof` array, as length\n        // of leaf preimage (which is `L2_TO_L1_LOG_SERIALIZE_SIZE`) is not\n        // equal to the length of other nodes preimages (which are `2 * 32`)\n\n        bytes32 calculatedRootHash = Merkle.calculateRoot(_proof, _index, hashedLog);\n        bytes32 actualRootHash = s.l2LogsRootHashes[_batchNumber];\n\n        return actualRootHash == calculatedRootHash;\n    }\n\n    /// @dev Convert arbitrary-length message to the raw l2 log\n    function _L2MessageToLog(L2Message memory _message) internal pure returns (L2Log memory) {\n        return\n            L2Log({\n                l2ShardId: 0,\n                isService: true,\n                txNumberInBatch: _message.txNumberInBatch,\n                sender: L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR,\n                key: bytes32(uint256(uint160(_message.sender))),\n                value: keccak256(_message.data)\n            });\n    }\n\n    /// @notice Estimates the cost in Ether of requesting execution of an L2 transaction from L1\n    /// @param _gasPrice expected L1 gas price at which the user requests the transaction execution\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount of L2 gas that the operator may charge the user for a single byte of pubdata.\n    /// @return The estimated ETH spent on L2 gas for the transaction\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) public pure returns (uint256) {\n        uint256 l2GasPrice = _deriveL2GasPrice(_gasPrice, _l2GasPerPubdataByteLimit);\n        return l2GasPrice * _l2GasLimit;\n    }\n\n    /// @notice Derives the price for L2 gas in ETH to be paid.\n    /// @param _l1GasPrice The gas price on L1.\n    /// @param _gasPricePerPubdata The price for each pubdata byte in L2 gas\n    /// @return The price of L2 gas in ETH\n    function _deriveL2GasPrice(uint256 _l1GasPrice, uint256 _gasPricePerPubdata) internal pure returns (uint256) {\n        uint256 pubdataPriceETH = L1_GAS_PER_PUBDATA_BYTE * _l1GasPrice;\n        uint256 minL2GasPriceETH = (pubdataPriceETH + _gasPricePerPubdata - 1) / _gasPricePerPubdata;\n\n        return Math.max(FAIR_L2_GAS_PRICE, minL2GasPriceETH);\n    }\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeEthWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external override nonReentrant senderCanCallFunction(s.allowList) {\n        require(!s.isEthWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex], \"jj\");\n\n        L2Message memory l2ToL1Message = L2Message({\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: L2_ETH_TOKEN_SYSTEM_CONTRACT_ADDR,\n            data: _message\n        });\n\n        (address _l1WithdrawReceiver, uint256 _amount) = _parseL2WithdrawalMessage(_message);\n\n        bool proofValid = proveL2MessageInclusion(_l2BatchNumber, _l2MessageIndex, l2ToL1Message, _merkleProof);\n        require(proofValid, \"pi\"); // Failed to verify that withdrawal was actually initialized on L2\n\n        s.isEthWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex] = true;\n        _withdrawFunds(_l1WithdrawReceiver, _amount);\n\n        emit EthWithdrawalFinalized(_l1WithdrawReceiver, _amount);\n    }\n\n    /// @notice Request execution of L2 transaction from L1.\n    /// @param _contractL2 The L2 receiver address\n    /// @param _l2Value `msg.value` of L2 transaction\n    /// @param _calldata The input of the L2 transaction\n    /// @param _l2GasLimit Maximum amount of L2 gas that transaction can consume during execution on L2\n    /// @param _l2GasPerPubdataByteLimit The maximum amount L2 gas that the operator may charge the user for single byte of pubdata.\n    /// @param _factoryDeps An array of L2 bytecodes that will be marked as known on L2\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient's address to eliminate sending funds to addresses out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds are controllable,\n    /// since address aliasing to the from address for the L2 tx will be applied if the L1 `msg.sender` is a contract.\n    /// Without address aliasing for L1 contracts as refund recipients they would not be able to make proper L2 tx requests\n    /// through the Mailbox to use or withdraw the funds from L2, and the funds would be lost.\n    /// @return canonicalTxHash The hash of the requested L2 transaction. This hash can be used to follow the transaction status\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable nonReentrant senderCanCallFunction(s.allowList) returns (bytes32 canonicalTxHash) {\n        // Change the sender address if it is a smart contract to prevent address collision between L1 and L2.\n        // Please note, currently zkSync address derivation is different from Ethereum one, but it may be changed in the future.\n        address sender = msg.sender;\n        if (sender != tx.origin) {\n            sender = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n        }\n\n        // Enforcing that `_l2GasPerPubdataByteLimit` equals to a certain constant number. This is needed\n        // to ensure that users do not get used to using \"exotic\" numbers for _l2GasPerPubdataByteLimit, e.g. 1-2, etc.\n        // VERY IMPORTANT: nobody should rely on this constant to be fixed and every contract should give their users the ability to provide the\n        // ability to provide `_l2GasPerPubdataByteLimit` for each independent transaction.\n        // CHANGING THIS CONSTANT SHOULD BE A CLIENT-SIDE CHANGE.\n        require(_l2GasPerPubdataByteLimit == REQUIRED_L2_GAS_PRICE_PER_PUBDATA, \"qp\");\n\n        // The L1 -> L2 transaction may be failed and funds will be sent to the `_refundRecipient`,\n        // so we use `msg.value` instead of `_l2Value` as the bridged amount.\n        _verifyDepositLimit(msg.sender, msg.value);\n        canonicalTxHash = _requestL2Transaction(\n            sender,\n            _contractL2,\n            _l2Value,\n            _calldata,\n            _l2GasLimit,\n            _l2GasPerPubdataByteLimit,\n            _factoryDeps,\n            false,\n            _refundRecipient\n        );\n    }\n\n    function _verifyDepositLimit(address _depositor, uint256 _amount) internal {\n        IAllowList.Deposit memory limitData = IAllowList(s.allowList).getTokenDepositLimitData(address(0)); // address(0) denotes the ETH\n        if (!limitData.depositLimitation) return; // no deposit limitation is placed for ETH\n\n        require(s.totalDepositedAmountPerUser[_depositor] + _amount <= limitData.depositCap, \"d2\");\n        s.totalDepositedAmountPerUser[_depositor] += _amount;\n    }\n\n    function _requestL2Transaction(\n        address _sender,\n        address _contractAddressL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        bool _isFree,\n        address _refundRecipient\n    ) internal returns (bytes32 canonicalTxHash) {\n        require(_factoryDeps.length <= MAX_NEW_FACTORY_DEPS, \"uj\");\n        uint64 expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION); // Safe to cast\n        uint256 txId = s.priorityQueue.getTotalPriorityTxs();\n\n        // Here we manually assign fields for the struct to prevent \"stack too deep\" error\n        WritePriorityOpParams memory params;\n\n        // Checking that the user provided enough ether to pay for the transaction.\n        // Using a new scope to prevent \"stack too deep\" error\n        {\n            params.l2GasPrice = _isFree ? 0 : _deriveL2GasPrice(tx.gasprice, _l2GasPerPubdataByteLimit);\n            uint256 baseCost = params.l2GasPrice * _l2GasLimit;\n            require(msg.value >= baseCost + _l2Value, \"mv\"); // The `msg.value` doesn't cover the transaction cost\n        }\n\n        // If the `_refundRecipient` is not provided, we use the `_sender` as the recipient.\n        address refundRecipient = _refundRecipient == address(0) ? _sender : _refundRecipient;\n        // If the `_refundRecipient` is a smart contract, we apply the L1 to L2 alias to prevent foot guns.\n        if (refundRecipient.code.length > 0) {\n            refundRecipient = AddressAliasHelper.applyL1ToL2Alias(refundRecipient);\n        }\n\n        params.sender = _sender;\n        params.txId = txId;\n        params.l2Value = _l2Value;\n        params.contractAddressL2 = _contractAddressL2;\n        params.expirationTimestamp = expirationTimestamp;\n        params.l2GasLimit = _l2GasLimit;\n        params.l2GasPricePerPubdata = _l2GasPerPubdataByteLimit;\n        params.valueToMint = msg.value;\n        params.refundRecipient = refundRecipient;\n\n        canonicalTxHash = _writePriorityOp(params, _calldata, _factoryDeps);\n    }\n\n    function _serializeL2Transaction(\n        WritePriorityOpParams memory _priorityOpParams,\n        bytes calldata _calldata,\n        bytes[] calldata _factoryDeps\n    ) internal pure returns (L2CanonicalTransaction memory transaction) {\n        transaction = L2CanonicalTransaction({\n            txType: PRIORITY_OPERATION_L2_TX_TYPE,\n            from: uint256(uint160(_priorityOpParams.sender)),\n            to: uint256(uint160(_priorityOpParams.contractAddressL2)),\n            gasLimit: _priorityOpParams.l2GasLimit,\n            gasPerPubdataByteLimit: _priorityOpParams.l2GasPricePerPubdata,\n            maxFeePerGas: uint256(_priorityOpParams.l2GasPrice),\n            maxPriorityFeePerGas: uint256(0),\n            paymaster: uint256(0),\n            // Note, that the priority operation id is used as \"nonce\" for L1->L2 transactions\n            nonce: uint256(_priorityOpParams.txId),\n            value: _priorityOpParams.l2Value,\n            reserved: [_priorityOpParams.valueToMint, uint256(uint160(_priorityOpParams.refundRecipient)), 0, 0],\n            data: _calldata,\n            signature: new bytes(0),\n            factoryDeps: _hashFactoryDeps(_factoryDeps),\n            paymasterInput: new bytes(0),\n            reservedDynamic: new bytes(0)\n        });\n    }\n\n    /// @notice Stores a transaction record in storage & send event about that\n    function _writePriorityOp(\n        WritePriorityOpParams memory _priorityOpParams,\n        bytes calldata _calldata,\n        bytes[] calldata _factoryDeps\n    ) internal returns (bytes32 canonicalTxHash) {\n        L2CanonicalTransaction memory transaction = _serializeL2Transaction(_priorityOpParams, _calldata, _factoryDeps);\n\n        bytes memory transactionEncoding = abi.encode(transaction);\n\n        TransactionValidator.validateL1ToL2Transaction(transaction, transactionEncoding, s.priorityTxMaxGasLimit);\n\n        canonicalTxHash = keccak256(transactionEncoding);\n\n        s.priorityQueue.pushBack(\n            PriorityOperation({\n                canonicalTxHash: canonicalTxHash,\n                expirationTimestamp: _priorityOpParams.expirationTimestamp,\n                layer2Tip: uint192(0) // TODO: Restore after fee modeling will be stable. (SMA-1230)\n            })\n        );\n\n        // Data that is needed for the operator to simulate priority queue offchain\n        emit NewPriorityRequest(\n            _priorityOpParams.txId,\n            canonicalTxHash,\n            _priorityOpParams.expirationTimestamp,\n            transaction,\n            _factoryDeps\n        );\n    }\n\n    /// @notice Hashes the L2 bytecodes and returns them in the format in which they are processed by the bootloader\n    function _hashFactoryDeps(bytes[] calldata _factoryDeps)\n        internal\n        pure\n        returns (uint256[] memory hashedFactoryDeps)\n    {\n        uint256 factoryDepsLen = _factoryDeps.length;\n        hashedFactoryDeps = new uint256[](factoryDepsLen);\n        for (uint256 i = 0; i < factoryDepsLen; i = i.uncheckedInc()) {\n            bytes32 hashedBytecode = L2ContractHelper.hashL2Bytecode(_factoryDeps[i]);\n\n            // Store the resulting hash sequentially in bytes.\n            assembly {\n                mstore(add(hashedFactoryDeps, mul(add(i, 1), 32)), hashedBytecode)\n            }\n        }\n    }\n\n    /// @dev Decode the withdraw message that came from L2\n    function _parseL2WithdrawalMessage(bytes memory _message)\n        internal\n        pure\n        returns (address l1Receiver, uint256 amount)\n    {\n        // We check that the message is long enough to read the data.\n        // Please note that there are two versions of the message:\n        // 1. The message that is sent by `withdraw(address _l1Receiver)`\n        // It should be equal to the length of the bytes4 function signature + address l1Receiver + uint256 amount = 4 + 20 + 32 = 56 (bytes).\n        // 2. The message that is sent by `withdrawWithMessage(address _l1Receiver, bytes calldata _additionalData)`\n        // It should be equal to the length of the following:\n        // bytes4 function signature + address l1Receiver + uint256 amount + address l2Sender + bytes _additionalData =\n        // = 4 + 20 + 32 + 32 + _additionalData.length >= 68 (bytes).\n\n        // So the data is expected to be at least 56 bytes long.\n        require(_message.length >= 56, \"pm\");\n\n        (uint32 functionSignature, uint256 offset) = UnsafeBytes.readUint32(_message, 0);\n        require(bytes4(functionSignature) == this.finalizeEthWithdrawal.selector, \"is\");\n\n        (l1Receiver, offset) = UnsafeBytes.readAddress(_message, offset);\n        (amount, offset) = UnsafeBytes.readUint256(_message, offset);\n    }\n}"
    },
    {
      "filename": "code/contracts/ethereum/contracts/zksync/Config.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\n/// @dev `keccak256(\"\")`\nbytes32 constant EMPTY_STRING_KECCAK = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n/// @dev Bytes in raw L2 log\n/// @dev Equal to the bytes size of the tuple - (uint8 ShardId, bool isService, uint16 txNumberInBatch, address sender,\n/// bytes32 key, bytes32 value)\nuint256 constant L2_TO_L1_LOG_SERIALIZE_SIZE = 88;\n\n/// @dev The maximum length of the bytes array with L2 -> L1 logs\nuint256 constant MAX_L2_TO_L1_LOGS_COMMITMENT_BYTES = 4 + L2_TO_L1_LOG_SERIALIZE_SIZE * 512;\n\n/// @dev The value of default leaf hash for L2 -> L1 logs Merkle tree\n/// @dev An incomplete fixed-size tree is filled with this value to be a full binary tree\n/// @dev Actually equal to the `keccak256(new bytes(L2_TO_L1_LOG_SERIALIZE_SIZE))`\nbytes32 constant L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH = 0x72abee45b59e344af8a6e520241c4744aff26ed411f4c4b00f8af09adada43ba;\n\n/// @dev Number of bytes in a one initial storage change\n/// @dev Equal to the bytes size of the tuple - (bytes32 key, bytes32 value)\nuint256 constant INITIAL_STORAGE_CHANGE_SERIALIZE_SIZE = 64;\n\n/// @dev The maximum length of the bytes array with initial storage changes\nuint256 constant MAX_INITIAL_STORAGE_CHANGES_COMMITMENT_BYTES = 4 + INITIAL_STORAGE_CHANGE_SERIALIZE_SIZE * 4765;\n\n/// @dev Number of bytes in a one repeated storage change\n/// @dev Equal to the bytes size of the tuple - (bytes8 key, bytes32 value)\nuint256 constant REPEATED_STORAGE_CHANGE_SERIALIZE_SIZE = 40;\n\n/// @dev The maximum length of the bytes array with repeated storage changes\nuint256 constant MAX_REPEATED_STORAGE_CHANGES_COMMITMENT_BYTES = 4 + REPEATED_STORAGE_CHANGE_SERIALIZE_SIZE * 7564;\n\n// TODO: change constant to the real root hash of empty Merkle tree (SMA-184)\nbytes32 constant DEFAULT_L2_LOGS_TREE_ROOT_HASH = bytes32(0);\n\n/// @dev Denotes the type of the zkSync transaction that came from L1.\nuint256 constant PRIORITY_OPERATION_L2_TX_TYPE = 255;\n\n/// @dev Denotes the type of the zkSync transaction that is used for system upgrades.\nuint256 constant SYSTEM_UPGRADE_L2_TX_TYPE = 254;\n\n/// @dev The amount of time in seconds the validator has to process the priority transaction\n/// NOTE: The constant is set to zero for the Alpha release period\nuint256 constant PRIORITY_EXPIRATION = 0 days;\n\n/// @dev Notice period before activation preparation status of upgrade mode (in seconds)\n/// @dev NOTE: we must reserve for users enough time to send full exit operation, wait maximum time for processing this\n/// operation and withdraw funds from it.\nuint256 constant UPGRADE_NOTICE_PERIOD = $$(defined(UPGRADE_NOTICE_PERIOD) ? UPGRADE_NOTICE_PERIOD : \"14 days\");\n\n/// @dev Timestamp - seconds since unix epoch\nuint256 constant COMMIT_TIMESTAMP_NOT_OLDER = $$(\n    defined(COMMIT_TIMESTAMP_NOT_OLDER) ? COMMIT_TIMESTAMP_NOT_OLDER : \"365 days\"\n);\n\n/// @dev Maximum available error between real commit block timestamp and analog used in the verifier (in seconds)\n/// @dev Must be used cause miner's `block.timestamp` value can differ on some small value (as we know - 15 seconds)\nuint256 constant COMMIT_TIMESTAMP_APPROXIMATION_DELTA = $$(\n    defined(COMMIT_TIMESTAMP_APPROXIMATION_DELTA) ? COMMIT_TIMESTAMP_APPROXIMATION_DELTA : \"365 days\"\n);\n\n/// @dev Bit mask to apply for verifier public input before verifying.\nuint256 constant INPUT_MASK = $$(~uint256(0) >> 32);\n\n/// @dev The maximum number of L2 gas that a user can request for an L2 transaction\nuint256 constant L2_TX_MAX_GAS_LIMIT = $(L2_TX_MAX_GAS_LIMIT);\n\n/// @dev The maximum number of the pubdata an L2 operation should be allowed to use.\nuint256 constant MAX_PUBDATA_PER_BATCH = $(MAX_PUBDATA_PER_BATCH);\n\n/// @dev The maximum number of the pubdata an priority operation should be allowed to use.\n/// For now, it is somewhat lower than the maximum number of pubdata allowed for an L2 transaction,\n/// to ensure that the transaction is definitely processable on L2 despite any potential overhead.\nuint256 constant PRIORITY_TX_MAX_PUBDATA = $(PRIORITY_TX_MAX_PUBDATA);\n\n/// @dev The default price per L2 gas to be used for L1->L2 transactions\nuint256 constant FAIR_L2_GAS_PRICE = $(FAIR_L2_GAS_PRICE);\n\n/// @dev Even though the price for 1 byte of pubdata is 16 L1 gas, we have a slightly increased\n/// value.\nuint256 constant L1_GAS_PER_PUBDATA_BYTE = $(L1_GAS_PER_PUBDATA_BYTE);\n\n/// @dev The computational overhead of processing an L2 batch.\nuint256 constant BATCH_OVERHEAD_L2_GAS = $(BATCH_OVERHEAD_L2_GAS);\n\n/// @dev The overhead in L1 gas of interacting with the L1\nuint256 constant BATCH_OVERHEAD_L1_GAS = $(BATCH_OVERHEAD_L1_GAS);\n\n/// @dev The equivalent in L1 pubdata of L1 gas used for working with L1\nuint256 constant BATCH_OVERHEAD_PUBDATA = BATCH_OVERHEAD_L1_GAS / L1_GAS_PER_PUBDATA_BYTE;\n\n/// @dev The maximum number of transactions in L2 batch:\nuint256 constant MAX_TRANSACTIONS_IN_BATCH = $(MAX_TRANSACTIONS_IN_BATCH);\n\n/// @dev The size of the bootloader memory dedicated to the encodings of transactions\nuint256 constant BOOTLOADER_TX_ENCODING_SPACE = $(BOOTLOADER_TX_ENCODING_SPACE);\n\n/// @dev The intrinsic cost of the L1->l2 transaction in computational L2 gas\nuint256 constant L1_TX_INTRINSIC_L2_GAS = $(L1_TX_INTRINSIC_L2_GAS);\n\n/// @dev The intrinsic cost of the L1->l2 transaction in pubdata\nuint256 constant L1_TX_INTRINSIC_PUBDATA = $(L1_TX_INTRINSIC_PUBDATA);\n\n/// @dev The minimal base price for L1 transaction\nuint256 constant L1_TX_MIN_L2_GAS_BASE = $(L1_TX_MIN_L2_GAS_BASE);\n\n/// @dev The number of L2 gas the transaction starts costing more with each 544 bytes of encoding\nuint256 constant L1_TX_DELTA_544_ENCODING_BYTES = $(L1_TX_DELTA_544_ENCODING_BYTES);\n\n/// @dev The number of L2 gas an L1->L2 transaction gains with each new factory dependency\nuint256 constant L1_TX_DELTA_FACTORY_DEPS_L2_GAS = $(L1_TX_DELTA_FACTORY_DEPS_L2_GAS);\n\n/// @dev The number of L2 gas an L1->L2 transaction gains with each new factory dependency\nuint256 constant L1_TX_DELTA_FACTORY_DEPS_PUBDATA = $(L1_TX_DELTA_FACTORY_DEPS_PUBDATA);\n\n/// @dev The number of pubdata an L1->L2 transaction requires with each new factory dependency\nuint256 constant MAX_NEW_FACTORY_DEPS = $(MAX_NEW_FACTORY_DEPS);\n\n/// @dev The L2 gasPricePerPubdata required to be used in bridges.\nuint256 constant REQUIRED_L2_GAS_PRICE_PER_PUBDATA = $(REQUIRED_L2_GAS_PRICE_PER_PUBDATA);\n\n/// @dev The mask which should be applied to the packed batch and L2 block timestamp in order\n/// to obtain the L2 block timestamp. Applying this mask is equivalent to calculating modulo 2**128\nuint256 constant PACKED_L2_BLOCK_TIMESTAMP_MASK = 0xffffffffffffffffffffffffffffffff;"
    },
    {
      "filename": "code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport {IMailbox, TxStatus} from \"../interfaces/IMailbox.sol\";\nimport {Merkle} from \"../libraries/Merkle.sol\";\nimport {PriorityQueue, PriorityOperation} from \"../libraries/PriorityQueue.sol\";\nimport {TransactionValidator} from \"../libraries/TransactionValidator.sol\";\nimport {L2Message, L2Log} from \"../Storage.sol\";\nimport {UncheckedMath} from \"../../common/libraries/UncheckedMath.sol\";\nimport {UnsafeBytes} from \"../../common/libraries/UnsafeBytes.sol\";\nimport {L2ContractHelper} from \"../../common/libraries/L2ContractHelper.sol\";\nimport {AddressAliasHelper} from \"../../vendor/AddressAliasHelper.sol\";\nimport {IAllowList} from \"../../common/interfaces/IAllowList.sol\";\nimport {Base} from \"./Base.sol\";\nimport {\n    REQUIRED_L2_GAS_PRICE_PER_PUBDATA,\n    FAIR_L2_GAS_PRICE,\n    L1_GAS_PER_PUBDATA_BYTE,\n    L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH,\n    PRIORITY_OPERATION_L2_TX_TYPE,\n    PRIORITY_EXPIRATION,\n    MAX_NEW_FACTORY_DEPS\n} from \"../Config.sol\";\nimport {\n    L2_BOOTLOADER_ADDRESS,\n    L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR,\n    L2_ETH_TOKEN_SYSTEM_CONTRACT_ADDR\n} from \"../../common/L2ContractAddresses.sol\";\n\n\n/// @title zkSync Mailbox contract providing interfaces for L1 <-> L2 interaction.\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ncontract MailboxFacet is Base, IMailbox {\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n\n    string public constant override getName = \"MailboxFacet\";\n\n    /// @notice Prove that a specific arbitrary-length message was sent in a specific L2 batch number\n    /// @param _batchNumber The executed L2 batch number in which the message appeared\n    /// @param _index The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _message Information about the sent message: sender address, the message itself, tx index in the L2 batch where the message was sent\n    /// @param _proof Merkle proof for inclusion of L2 log that was sent with the message\n    /// @return Whether the proof is valid\n    function proveL2MessageInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Message memory _message,\n        bytes32[] calldata _proof\n    ) public view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _L2MessageToLog(_message), _proof);\n    }\n\n    /// @notice Prove that a specific L2 log was sent in a specific L2 batch\n    /// @param _batchNumber The executed L2 batch number in which the log appeared\n    /// @param _index The position of the l2log in the L2 logs Merkle tree\n    /// @param _log Information about the sent log\n    /// @param _proof Merkle proof for inclusion of the L2 log\n    /// @return Whether the proof is correct and L2 log is included in batch\n    function proveL2LogInclusion(\n        uint256 _batchNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_batchNumber, _index, _log, _proof);\n    }\n\n    /// @notice Prove that the L1 -> L2 transaction was processed with the specified status.\n    /// @param _l2TxHash The L2 canonical transaction hash\n    /// @param _l2BatchNumber The L2 batch number where the transaction was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction\n    /// @param _status The execution status of the L1 -> L2 transaction (true - success & 0 - fail)\n    /// @return Whether the proof is correct and the transaction was actually executed with provided status\n    /// NOTE: It may return `false` for incorrect proof, but it doesn't mean that the L1 -> L2 transaction has an opposite status!\n    function proveL1ToL2TransactionStatus(\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof,\n        TxStatus _status\n    ) publ"
    }
  ]
}