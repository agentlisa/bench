{
  "Title": "[L-04] Enforce beta is not zero",
  "Content": "Authorized users can change `beta` value (https://github.com/code-423n4/2023-10-badger/blob/main/packages/contracts/contracts/CdpManager.sol#L830), if it's set to zero.\n\nWe'll divide by zero here:\n\nhttps://github.com/code-423n4/2023-10-badger/blob/main/packages/contracts/contracts/CdpManager.sol#L624\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-10-badger",
  "Code": [
    {
      "filename": "packages/contracts/contracts/CdpManager.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./Interfaces/ICdpManager.sol\";\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/IEBTCToken.sol\";\nimport \"./Interfaces/ISortedCdps.sol\";\nimport \"./Dependencies/ICollateralTokenOracle.sol\";\nimport \"./CdpManagerStorage.sol\";\nimport \"./Dependencies/Proxy.sol\";\n\n/// @title CdpManager is mainly in charge of all Cdp related core processing like collateral & debt accounting, split fee calculation, redemption, etc\n/// @notice Except for redemption, end user typically will interact with BorrowerOeprations for individual Cdp actions\n/// @dev CdpManager also handles liquidation through delegatecall to LiquidationLibrary\ncontract CdpManager is CdpManagerStorage, ICdpManager, Proxy {\n    // --- Dependency setter ---\n\n    /// @notice Constructor for CdpManager contract.\n    /// @dev Sets up dependencies and initial staking reward split.\n    /// @param _liquidationLibraryAddress Address of the liquidation library.\n    /// @param _authorityAddress Address of the authority.\n    /// @param _borrowerOperationsAddress Address of BorrowerOperations.\n    /// @param _collSurplusPoolAddress Address of CollSurplusPool.\n    /// @param _ebtcTokenAddress Address of the eBTC token.\n    /// @param _sortedCdpsAddress Address of the SortedCDPs.\n    /// @param _activePoolAddress Address of the ActivePool.\n    /// @param _priceFeedAddress Address of the price feed.\n    /// @param _collTokenAddress Address of the collateral token.\n    constructor(\n        address _liquidationLibraryAddress,\n        address _authorityAddress,\n        address _borrowerOperationsAddress,\n        address _collSurplusPoolAddress,\n        address _ebtcTokenAddress,\n        address _sortedCdpsAddress,\n        address _activePoolAddress,\n        address _priceFeedAddress,\n        address _collTokenAddress\n    )\n        CdpManagerStorage(\n            _liquidationLibraryAddress,\n            _authorityAddress,\n            _borrowerOperationsAddress,\n            _collSurplusPoolAddress,\n            _ebtcTokenAddress,\n            _sortedCdpsAddress,\n            _activePoolAddress,\n            _priceFeedAddress,\n            _collTokenAddress\n        )\n    {\n        stakingRewardSplit = STAKING_REWARD_SPLIT;\n        // Emit initial value for analytics\n        emit StakingRewardSplitSet(stakingRewardSplit);\n\n        (uint256 _oldIndex, uint256 _newIndex) = _readStEthIndex();\n        _syncStEthIndex(_oldIndex, _newIndex);\n        systemStEthFeePerUnitIndex = DECIMAL_PRECISION;\n    }\n\n    // --- Getters ---\n\n    /// @notice Get the count of active Cdps in the system\n    /// @return The number of current active Cdps (not closed) in the system.\n    function getActiveCdpsCount() external view override returns (uint256) {\n        return CdpIds.length;\n    }\n\n    /// @notice Get the CdpId at a given _index in the global active CdpIds array.\n    /// @param _index Index of the CdpIds array.\n    /// @return Cdp ID at the specified _index within the global active CdpIds array.\n    function getIdFromCdpIdsArray(uint256 _index) external view override returns (bytes32) {\n        return CdpIds[_index];\n    }\n\n    // --- Cdp Liquidation functions ---\n    // -----------------------------------------------------------------\n    //    Cdp ICR     |       Liquidation Behavior (TODO gas compensation?)\n    //\n    //  < MCR         |  debt could be fully repaid by liquidator\n    //                |  and ALL collateral transferred to liquidator\n    //                |  OR debt could be partially repaid by liquidator and\n    //                |  liquidator could get collateral of (repaidDebt * max(LICR, min(ICR, MCR)) / price)\n    //\n    //  > MCR & < TCR |  only liquidatable in Recovery Mode (TCR < CCR)\n    //                |  debt could be fully repaid by liquidator\n    //                |  and up to (repaid debt * MCR) worth of collateral\n    //                |  transferred to liquidator while the residue of collateral\n    //                |  will be available in CollSurplusPool for owner to claim\n    //                |  OR debt could be partially repaid by liquidator and\n    //                |  liquidator could get collateral of (repaidDebt * max(LICR, min(ICR, MCR)) / price)\n    // -----------------------------------------------------------------\n\n    /// @notice Fully liquidate a single Cdp by ID. Cdp must meet the criteria for liquidation at the time of execution.\n    /// @notice callable by anyone, attempts to liquidate the CdpId. Executes successfully if Cdp meets the conditions for liquidation (e.g. in Normal Mode, it liquidates if the Cdp's ICR < the system MCR).\n    /// @dev forwards msg.data directly to the liquidation library using OZ proxy core delegation function\n    /// @param _cdpId ID of the Cdp to liquidate.\n    function liquidate(bytes32 _cdpId) external override {\n        _delegate(liquidationLibrary);\n    }\n\n    /// @notice Partially liquidate a single Cdp.\n    /// @dev forwards msg.data directly to the liquidation library using OZ proxy core delegation function\n    /// @param _cdpId ID of the Cdp to partially liquidate.\n    /// @param _partialAmount Amount to partially liquidate.\n    /// @param _upperPartialHint Upper hint for reinsertion of the Cdp into the linked list.\n    /// @param _lowerPartialHint Lower hint for reinsertion of the Cdp into the linked list.\n    function partiallyLiquidate(\n        bytes32 _cdpId,\n        uint256 _partialAmount,\n        bytes32 _upperPartialHint,\n        bytes32 _lowerPartialHint\n    ) external override {\n        _delegate(liquidationLibrary);\n    }\n\n    // --- Batch/Sequence liquidation functions ---\n\n    /// @notice Attempt to liquidate a custom list of Cdps provided by the caller\n    /// @notice Callable by anyone, accepts a custom list of Cdps addresses as an argument.\n    /// @notice Steps through the provided list and attempts to liquidate every Cdp, until it reaches the end or it runs out of gas.\n    /// @notice A Cdp is liquidated only if it meets the conditions for liquidation.\n    /// @dev forwards msg.data directly to the liquidation library using OZ proxy core delegation function\n    /// @param _cdpArray Array of Cdps to liquidate.\n    function batchLiquidateCdps(bytes32[] memory _cdpArray) external override {\n        _delegate(liquidationLibrary);\n    }\n\n    // --- Redemption functions ---\n\n    /// @notice // Redeem as much collateral as possible from given Cdp in exchange for EBTC up to specified maximum\n    /// @param _redeemColFromCdp Struct containing variables for redeeming collateral.\n    /// @return singleRedemption Struct containing redemption values.\n    function _redeemCollateralFromCdp(\n        SingleRedemptionInputs memory _redeemColFromCdp\n    ) internal returns (SingleRedemptionValues memory singleRedemption) {\n        // Determine the remaining amount (lot) to be redeemed,\n        // capped by the entire debt of the Cdp minus the liquidation reserve\n        singleRedemption.debtToRedeem = EbtcMath._min(\n            _redeemColFromCdp.maxEBTCamount,\n            Cdps[_redeemColFromCdp.cdpId].debt /// @audit Redeem everything\n        );\n\n        singleRedemption.collSharesDrawn = collateral.getSharesByPooledEth(\n            (singleRedemption.debtToRedeem * DECIMAL_PRECISION) / _redeemColFromCdp.price\n        );\n\n        // Repurposing this struct here to avoid stack too deep.\n        CdpDebtAndCollShares memory _oldDebtAndColl = CdpDebtAndCollShares(\n            Cdps[_redeemColFromCdp.cdpId].debt,\n            Cdps[_redeemColFromCdp.cdpId].coll\n        );\n\n        // Decrease the debt and collateral of the current Cdp according to the EBTC lot and corresponding ETH to send\n        uint256 newDebt = _oldDebtAndColl.debt - singleRedemption.debtToRedeem;\n        uint256 newColl = _oldDebtAndColl.collShares - singleRedemption.collSharesDrawn;\n\n        if (newDebt == 0) {\n            // No debt remains, close Cdp\n            // No debt left in the Cdp, therefore the cdp gets closed\n            {\n                address _borrower = sortedCdps.getOwnerAddress(_redeemColFromCdp.cdpId);\n                uint256 _liquidatorRewardShares = Cdps[_redeemColFromCdp.cdpId]\n                    .liquidatorRewardShares;\n\n                singleRedemption.collSurplus = newColl; // Collateral surplus processed on full redemption\n                singleRedemption.liquidatorRewardShares = _liquidatorRewardShares;\n                singleRedemption.fullRedemption = true;\n\n                _closeCdpByRedemption(\n                    _redeemColFromCdp.cdpId,\n                    0,\n                    newColl,\n                    _liquidatorRewardShares,\n                    _borrower\n                );\n\n                emit CdpUpdated(\n                    _redeemColFromCdp.cdpId,\n                    _borrower,\n                    msg.sender,\n                    _oldDebtAndColl.debt,\n                    _oldDebtAndColl.collShares,\n                    0,\n                    0,\n                    0,\n                    CdpOperation.redeemCollateral\n                );\n            }\n        } else {\n            // Debt remains, reinsert Cdp\n            uint256 newNICR = EbtcMath._computeNominalCR(newColl, newDebt);\n\n            /*\n             * If the provided hint is out of date, we bail since trying to reinsert without a good hint will almost\n             * certainly result in running out of gas.\n             *\n             * If the resultant net coll of the partial is less than the minimum, we bail.\n             */\n            if (\n                newNICR != _redeemColFromCdp.partialRedemptionHintNICR ||\n                collateral.getPooledEthByShares(newColl) < MIN_NET_STETH_BALANCE\n            ) {\n                singleRedemption.cancelledPartial = true;\n                return singleRedemption;\n            }\n\n            sortedCdps.reInsert(\n                _redeemColFromCdp.cdpId,\n                newNICR,\n                _redeemColFromCdp.upperPartialRedemptionHint,\n                _redeemColFromCdp.lowerPartialRedemptionHint\n            );\n\n            Cdps[_redeemColFromCdp.cdpId].debt = newDebt;\n            Cdps[_redeemColFromCdp.cdpId].coll = newColl;\n            _updateStakeAndTotalStakes(_redeemColFromCdp.cdpId);\n\n            emit CdpUpdated(\n                _redeemColFromCdp.cdpId,\n                ISortedCdps(sortedCdps).getOwnerAddress(_redeemColFromCdp.cdpId),\n                msg.sender,\n                _oldDebtAndColl.debt,\n                _oldDebtAndColl.collShares,\n                newDebt,\n                newColl,\n                Cdps[_redeemColFromCdp.cdpId].stake,\n                CdpOperation.redeemCollateral\n            );\n        }\n\n        return singleRedemption;\n    }\n\n    /*\n     * Called when a full redemption occurs, and closes the cdp.\n     * The redeemer swaps (debt) EBTC for (debt)\n     * worth of stETH, so the stETH liquidation reserve is all that remains.\n     * In order to close the cdp, the stETH liquidation reserve is returned to the Cdp owner,\n     * The debt recorded on the cdp's struct is zero'd elswhere, in _closeCdp.\n     * Any surplus stETH left in the cdp, is sent to the Coll surplus pool, and can be later claimed by the borrower.\n     */\n    function _closeCdpByRedemption(\n        bytes32 _cdpId,\n        uint256 _EBTC,\n        uint256 _collSurplus,\n        uint256 _liquidatorRewardShares,\n        address _borrower\n    ) internal {\n        _closeCdpWithoutRemovingSortedCdps(_cdpId, Status.closedByRedemption);\n\n        // Update Active Pool EBTC, and send ETH to account\n        activePool.decreaseSystemDebt(_EBTC);\n\n        // Register stETH surplus from upcoming transfers of stETH collateral and liquidator reward shares\n        collSurplusPool.increaseSurplusCollShares(_borrower, _collSurplus + _liquidatorRewardShares);\n\n        // CEI: send stETH coll and liquidator reward shares from Active Pool to CollSurplus Pool\n        activePool.transferSystemCollSharesAndLiquidatorReward(\n            address(collSurplusPool),\n            _collSurplus,\n            _liquidatorRewardShares\n        );\n    }\n\n    /// @notice Returns true if the CdpId specified is the lowest-ICR Cdp in the linked list that still has MCR > ICR\n    /// @dev Returns false if the specified CdpId hint is blank\n    /// @dev Returns false if the specified CdpId hint doesn't exist in the list\n    /// @dev Returns false if the ICR of the specified CdpId is < MCR\n    /// @dev Returns true if the specified CdpId is not blank, exists in the list, has an ICR > MCR, and the next lower Cdp in the list is either blank or has an ICR < MCR.\n    function _isValidFirstRedemptionHint(\n        bytes32 _firstRedemptionHint,\n        uint256 _price\n    ) internal view returns (bool) {\n        if (\n            _firstRedemptionHint == sortedCdps.nonExistId() ||\n            !sortedCdps.contains(_firstRedemptionHint) ||\n            getSyncedICR(_firstRedemptionHint, _price) < MCR\n        ) {\n            return false;\n        }\n\n        bytes32 nextCdp = sortedCdps.getNext(_firstRedemptionHint);\n        return nextCdp == sortedCdps.nonExistId() || getSyncedICR(nextCdp, _price) < MCR;\n    }\n\n    /// @notice Send _debt EBTC to the system and redeem the corresponding amount of collateral\n    /// @notice from as many Cdps as are needed to fill the redemption request.\n    /// @notice\n    /// @notice Note that if _debt is very large, this function can run out of gas, specially if traversed cdps are small (meaning many small Cdps are redeemed against).\n    /// @notice This can be easily avoided by splitting the total _debt in appropriate chunks and calling the function multiple times.\n    /// @notice\n    /// @notice There is a optional parameter `_maxIterations` which can also be provided, so the loop through Cdps is capped (if itâ€™s zero, it will be ignored).\n    /// @notice This makes it easier to avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough,\n    /// @notice without needing to know the \"topology\" of the cdp list. It also avoids the need to set the cap in stone in the contract,\n    /// @notice nor doing gas calculations, as both gas price and opcode costs can vary.\n    /// @notice\n    /// @notice All Cdps that are redeemed from -- with the likely exception of the last one -- will end up with no debt left,\n    /// @notice therefore they will be closed.\n    /// @notice If the last Cdp does have some remaining debt & collateral (it has a valid meaningful ICR) then reinsertion of the CDP\n    /// @notice could be anywhere in the entire SortedCdps list, therefore this redemption requires a hint.\n    /// @notice\n    /// @notice A frontend should use HintHelper.getRedemptionHints() to calculate what the ICR of this Cdp will be after redemption,\n    /// @notice and pass a hint for its position in the SortedCdps list along with the ICR value that the hint was found for.\n    /// @notice\n    /// @notice If another transaction modifies the list between calling getRedemptionHints()\n    /// @notice and passing the hints to redeemCollateral(), it is very likely that the last (partially)\n    /// @notice redeemed Cdp would end up with a different ICR than what the hint is for.\n    /// @notice\n    /// @notice In this case, the redemption will stop after the last completely redeemed Cdp and the sender will keep the\n    /// @notice remaining EBTC amount, which they can attempt to redeem later.\n    /// @param _debt The total eBTC debt amount to be redeemed\n    /// @param _firstRedemptionHint The first CdpId to be considered for redemption, could get from HintHelper.getRedemptionHints()\n    /// @param _upperPartialRedemptionHint The first CdpId to be considered for redemption, could get from HintHelper.getApproxHint(_partialRedemptionHintNICR) then SortedCdps.findInsertPosition(_partialRedemptionHintNICR)\n    /// @param _lowerPartialRedemptionHint The first CdpId to be considered for redemption, could get from HintHelper.getApproxHint(_partialRedemptionHintNICR) then SortedCdps.findInsertPosition(_partialRedemptionHintNICR)\n    /// @param _partialRedemptionHintNICR The new Nominal Collateral Ratio (NICR) of the last redeemed CDP after partial redemption, could get from HintHelper.getRedemptionHints()\n    /// @param _maxIterations The maximum allowed iteration along the SortedCdps loop, if zero then there is no limit\n    /// @param _maxFeePercentage The maximum allowed redemption fee for this redemption\n    function redeemCollateral(\n        uint256 _debt,\n        bytes32 _firstRedemptionHint,\n        bytes32 _upperPartialRedemptionHint,\n        bytes32 _lowerPartialRedemptionHint,\n        uint256 _partialRedemptionHintNICR,\n        uint256 _maxIterations,\n        uint256 _maxFeePercentage\n    ) external override nonReentrantSelfAndBOps {\n        RedemptionTotals memory totals;\n\n        // early check to ensure redemption is not paused\n        require(redemptionsPaused == false, \"CdpManager: Redemptions Paused\");\n\n        _requireValidMaxFeePercentage(_maxFeePercentage);\n\n        _syncGlobalAccounting(); // Apply state, we will syncGracePeriod at end of function\n\n        totals.price = priceFeed.fetchPrice();\n        {\n            (\n                uint256 tcrAtStart,\n                uint256 systemCollSharesAtStart,\n                uint256 systemDebtAtStart\n            ) = _getTCRWithSystemDebtAndCollShares(totals.price);\n            totals.tcrAtStart = tcrAtStart;\n            totals.systemCollSharesAtStart = systemCollSharesAtStart;\n            totals.systemDebtAtStart = systemDebtAtStart;\n        }\n\n        _requireTCRisNotBelowMCR(totals.price, totals.tcrAtStart);\n        _requireAmountGreaterThanZero(_debt);\n\n        _requireEbtcBalanceCoversRedemptionAndWithinSupply(\n            msg.sender,\n            _debt,\n            totals.systemDebtAtStart\n        );\n\n        totals.remainingDebtToRedeem = _debt;\n        address currentBorrower;\n        bytes32 _cId = _firstRedemptionHint;\n\n        if (_isValidFirstRedemptionHint(_firstRedemptionHint, totals.price)) {\n            currentBorrower = sortedCdps.getOwnerAddress(_firstRedemptionHint);\n        } else {\n            _cId = sortedCdps.getLast();\n            currentBorrower = sortedCdps.getOwnerAddress(_cId);\n            // Find the first cdp with ICR >= MCR\n            while (currentBorrower != address(0) && getSyncedICR(_cId, totals.price) < MCR) {\n                _cId = sortedCdps.getPrev(_cId);\n                currentBorrower = sortedCdps.getOwnerAddress(_cId);\n            }\n        }\n\n        // Loop through the Cdps starting from the one with lowest collateral\n        // ratio until _amount of EBTC is exchanged for collateral\n        if (_maxIterations == 0) {\n            _maxIterations = type(uint256).max;\n        }\n\n        bytes32 _firstRedeemed = _cId;\n        bytes32 _lastRedeemed = _cId;\n        uint256 _numCdpsFullyRedeemed;\n\n        /**\n            Core Redemption Loop\n        */\n        while (\n            currentBorrower != address(0) && totals.remainingDebtToRedeem > 0 && _maxIterations > 0\n        ) {\n            // Save the address of the Cdp preceding the current one, before potentially modifying the list\n            {\n                _syncAccounting(_cId); /// @audit This happens even if the re-insertion doesn't\n\n                SingleRedemptionInputs memory _redeemColFromCdp = SingleRedemptionInputs(\n                    _cId,\n                    totals.remainingDebtToRedeem,\n                    totals.price,\n                    _upperPartialRedemptionHint,\n                    _lowerPartialRedemptionHint,\n                    _partialRedemptionHintNICR\n                );\n                SingleRedemptionValues memory singleRedemption = _redeemCollateralFromCdp(\n                    _redeemColFromCdp\n                );\n                // Partial redemption was cancelled (out-of-date hint, or new net debt < minimum),\n                // therefore we could not redeem from the last Cdp\n                if (singleRedemption.cancelledPartial) break;\n\n                totals.debtToRedeem = totals.debtToRedeem + singleRedemption.debtToRedeem;\n                totals.collSharesDrawn = totals.collSharesDrawn + singleRedemption.collSharesDrawn;\n                totals.remainingDebtToRedeem =\n                    totals.remainingDebtToRedeem -\n                    singleRedemption.debtToRedeem;\n                totals.totalCollSharesSurplus =\n                    totals.totalCollSharesSurplus +\n                    singleRedemption.collSurplus;\n\n                if (singleRedemption.fullRedemption) {\n                    _lastRedeemed = _cId;\n                    _numCdpsFullyRedeemed = _numCdpsFullyRedeemed + 1;\n                }\n\n                bytes32 _nextId = sortedCdps.getPrev(_cId);\n                address nextUserToCheck = sortedCdps.getOwnerAddress(_nextId);\n                currentBorrower = nextUserToCheck;\n                _cId = _nextId;\n            }\n            _maxIterations--;\n        }\n        require(totals.collSharesDrawn > 0, \"CdpManager: Unable to redeem any amount\");\n\n        // remove from sortedCdps\n        if (_numCdpsFullyRedeemed == 1) {\n            sortedCdps.remove(_firstRedeemed);\n        } else if (_numCdpsFullyRedeemed > 1) {\n            bytes32[] memory _toRemoveIds = _getCdpIdsToRemove(\n                _lastRedeemed,\n                _numCdpsFullyRedeemed,\n                _firstRedeemed\n            );\n            sortedCdps.batchRemove(_toRemoveIds);\n        }\n\n        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption.\n        // Use the saved total EBTC supply value, from before it was reduced by the redemption.\n        _updateBaseRateFromRedemption(\n            totals.collSharesDrawn,\n            totals.price,\n            totals.systemDebtAtStart\n        );\n\n        // Calculate the ETH fee\n        totals.feeCollShares = _getRedemptionFee(totals.collSharesDrawn);\n\n        _requireUserAcceptsFee(totals.feeCollShares, totals.collSharesDrawn, _maxFeePercentage);\n\n        totals.collSharesToRedeemer = totals.collSharesDrawn - totals.feeCollShares;\n\n        _syncGracePeriodForGivenValues(\n            totals.systemCollSharesAtStart - totals.collSharesDrawn - totals.totalCollSharesSurplus,\n            totals.systemDebtAtStart - totals.debtToRedeem,\n            totals.price\n        );\n\n        emit Redemption(\n            _debt,\n            totals.debtToRedeem,\n            totals.collSharesDrawn,\n            totals.feeCollShares,\n            msg.sender\n        );\n\n        // Burn the total eBTC that is redeemed\n        ebtcToken.burn(msg.sender, totals.debtToRedeem);\n\n        // Update Active Pool eBTC debt internal accounting\n        activePool.decreaseSystemDebt(totals.debtToRedeem);\n\n        // Allocate the stETH fee to the FeeRecipient\n        activePool.allocateSystemCollSharesToFeeRecipient(totals.feeCollShares);\n\n        // CEI: Send the stETH drawn to the redeemer\n        activePool.transferSystemCollShares(msg.sender, totals.collSharesToRedeemer);\n    }\n\n    // --- Helper functions ---\n\n    function _getCdpIdsToRemove(\n        bytes32 _start,\n        uint256 _total,\n        bytes32 _end\n    ) internal view returns (bytes32[] memory) {\n        uint256 _cnt = _total;\n        bytes32 _id = _start;\n        bytes32[] memory _toRemoveIds = new bytes32[](_total);\n        while (_cnt > 0 && _id != bytes32(0)) {\n            _toRemoveIds[_total - _cnt] = _id;\n            _cnt = _cnt - 1;\n            _id = sortedCdps.getNext(_id);\n        }\n        require(_toRemoveIds[0] == _start, \"CdpManager: batchRemoveSortedCdpIds check start error\");\n        require(\n            _toRemoveIds[_total - 1] == _end,\n            \"CdpManager: batchRemoveSortedCdpIds check end error\"\n        );\n        return _toRemoveIds;\n    }\n\n    /// @notice Synchorize the accounting for the specified Cdp\n    /// @notice It will synchronize global accounting with stETH share index first\n    /// @notice then apply split fee and debt redistribution if any\n    /// @param _cdpId cdpId to sync pending accounting state for\n    function syncAccounting(bytes32 _cdpId) external virtual override {\n        /// @audit Opening can cause invalid reordering of Cdps due to changing values without reInserting into sortedCdps\n        _requireCallerIsBorrowerOperations();\n        return _syncAccounting(_cdpId);\n    }\n\n    /// @notice Update stake for the specified Cdp and total stake within the system.\n    /// @dev Only BorrowerOperations is allowed to call this function\n    /// @param _cdpId cdpId to update stake for\n    function updateStakeAndTotalStakes(bytes32 _cdpId) external override returns (uint256) {\n        _requireCallerIsBorrowerOperations();\n        return _updateStakeAndTotalStakes(_cdpId);\n    }\n\n    /// @notice Close the specified Cdp by ID.\n    /// @dev Only BorrowerOperations is allowed to call this function.\n    /// @dev This will close the Cdp and update its status to `closedByOwner`\n    /// @dev The collateral and debt will be zero'd out\n    /// @dev The Cdp will be removed from the sorted list\n    /// @dev The close will emit a `CdpUpdated` event containing closing details\n    /// @param _cdpId ID of the Cdp to close\n    /// @param _borrower Address of the Cdp borrower\n    /// @param _debt The recorded Cdp debt prior to closing\n    /// @param _coll The recorded Cdp collateral shares prior to closing\n    function closeCdp(\n        bytes32 _cdpId,\n        address _borrower,\n        uint256 _debt,\n        uint256 _coll\n    ) external override {\n        _requireCallerIsBorrowerOperations();\n        emit CdpUpdated(_cdpId, _borrower, msg.sender, _debt, _coll, 0, 0, 0, CdpOperation.closeCdp);\n        return _closeCdp(_cdpId, Status.closedByOwner);\n    }\n\n    // Push the owner's address to the Cdp owners list, and record the corresponding array index on the Cdp struct\n    function _addCdpIdToArray(bytes32 _cdpId) internal returns (uint128 index) {\n        /* Max array size is 2**128 - 1, i.e. ~3e30 cdps. No risk of overflow, since cdps have minimum EBTC\n        debt of liquidation reserve plus MIN_NET_DEBT.\n        3e30 EBTC dwarfs the value of all wealth in the world ( which is < 1e15 USD). */\n\n        // Push the Cdpowner to the array\n        CdpIds.push(_cdpId);\n\n        // Record the index of the new Cdpowner on their Cdp struct\n        index = uint128(CdpIds.length - 1);\n        Cdps[_cdpId].arrayIndex = index;\n\n        return index;\n    }\n\n    // --- Recovery Mode and TCR functions ---\n\n    /// @notice Get the sum of debt units assigned to all Cdps within eBTC system\n    /// @dev It is actually the `systemDebt` value of the ActivePool.\n    /// @return entireSystemDebt entire system debt accounting value\n    function getSystemDebt() public view returns (uint256 entireSystemDebt) {\n        return _getSystemDebt();\n    }\n\n    /// @notice The total collateralization ratio (TCR) of the system as a cached \"view\" (maybe outdated)\n    /// @dev It is based on the current recorded system debt and collateral.\n    /// @dev Possible split fee is not considered with this function.\n    /// @dev Please use getSyncedTCR() otherwise\n    /// @param _price The current stETH:BTC price\n    /// @return TCR The cached total collateralization ratio (TCR) of the system (does not take into account pending global state)\n    function getCachedTCR(uint256 _price) external view override returns (uint256) {\n        return _getCachedTCR(_price);\n    }\n\n    /// @notice Whether or not the system is in Recovery Mode (TCR is below the CCR)\n    /// @dev Possible split fee is not considered with this function.\n    /// @dev Please use getSyncedTCR() otherwise\n    /// @param _price The current stETH:BTC price\n    /// @return True if system is in recovery mode with cached values (TCR < CCR), false otherwise\n    function checkRecoveryMode(uint256 _price) external view override returns (bool) {\n        return _checkRecoveryMode(_price);\n    }\n\n    // Check whether or not the system *would be* in Recovery Mode,\n    // given an ETH:USD price, and the entire system coll and debt.\n    function _checkPotentialRecoveryMode(\n        uint256 _systemCollShares,\n        uint256 _systemDebt,\n        uint256 _price\n    ) internal view returns (bool) {\n        uint256 TCR = _computeTCRWithGivenSystemValues(_systemCollShares, _systemDebt, _price);\n        return TCR < CCR;\n    }\n\n    // --- Redemption fee functions ---\n\n    /*\n     * This function has two impacts on the baseRate state variable:\n     * 1) decays the baseRate based on time passed since last redemption or EBTC borrowing operation.\n     * then,\n     * 2) increases the baseRate based on the amount redeemed, as a proportion of total supply\n     */\n    function _updateBaseRateFromRedemption(\n        uint256 _ETHDrawn,\n        uint256 _price,\n        uint256 _totalEBTCSupply\n    ) internal returns (uint256) {\n        uint256 decayedBaseRate = _calcDecayedBaseRate();\n\n        /* Convert the drawn ETH back to EBTC at face value rate (1 EBTC:1 USD), in order to get\n         * the fraction of total supply that was redeemed at face value. */\n        uint256 redeemedEBTCFraction = (collateral.getPooledEthByShares(_ETHDrawn) * _price) /\n            _totalEBTCSupply;\n\n        uint256 newBaseRate = decayedBaseRate + (redeemedEBTCFraction / beta);\n        newBaseRate = EbtcMath._min(newBaseRate, DECIMAL_PRECISION); // cap baseRate at a maximum of 100%\n        require(newBaseRate > 0, \"CdpManager: new baseRate is zero!\"); // Base rate is always non-zero after redemption\n\n        // Update the baseRate state variable\n        baseRate = newBaseRate;\n        emit BaseRateUpdated(newBaseRate);\n\n        _updateLastRedemptionTimestamp();\n\n        return newBaseRate;\n    }\n\n    /// @return current fee rate for redemption with base rate\n    function getRedemptionRate() public view override returns (uint256) {\n        return _calcRedemptionRate(baseRate);\n    }\n\n    /// @return current fee rate for redemption with decayed base rate\n    function getRedemptionRateWithDecay() public view override returns (uint256) {\n        return _calcRedemptionRate(_calcDecayedBaseRate());\n    }\n\n    function _calcRedemptionRate(uint256 _baseRate) internal view returns (uint256) {\n        return\n            EbtcMath._min(\n                redemptionFeeFloor + _baseRate,\n                DECIMAL_PRECISION // cap at a maximum of 100%\n            );\n    }\n\n    function _getRedemptionFee(uint256 _ETHDrawn) internal view returns (uint256) {\n        return _calcRedemptionFee(getRedemptionRate(), _ETHDrawn);\n    }\n\n    /// @return redemption fee for the specified collateral amount\n    /// @param _stETHToRedeem The total expected stETH amount to redeem\n    function getRedemptionFeeWithDecay(\n        uint256 _stETHToRedeem\n    ) external view override returns (uint256) {\n        return _calcRedemptionFee(getRedemptionRateWithDecay(), _stETHToRedeem);\n    }\n\n    function _calcRedemptionFee(\n        uint256 _redemptionRate,\n        uint256 _ETHDrawn\n    ) internal pure returns (uint256) {\n        uint256 redemptionFee = (_redemptionRate * _ETHDrawn) / DECIMAL_PRECISION;\n        require(redemptionFee < _ETHDrawn, \"CdpManager: Fee would eat up all returned collateral\");\n        return redemptionFee;\n    }\n\n    function _decayBaseRate() internal {\n        uint256 decayedBaseRate = _calcDecayedBaseRate();\n        require(decayedBaseRate <= DECIMAL_PRECISION, \"CdpManager: baseRate too large!\"); // The baseRate can decay to 0\n\n        baseRate = decayedBaseRate;\n        emit BaseRateUpdated(decayedBaseRate);\n\n        _updateLastRedemptionTimestamp();\n    }\n\n    // --- Internal fee functions ---\n\n    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.\n    function _updateLastRedemptionTimestamp() internal {\n        uint256 timePassed = block.timestamp > lastRedemptionTimestamp\n            ? block.timestamp - lastRedemptionTimestamp\n            : 0;\n\n        if (timePassed >= SECONDS_IN_ONE_MINUTE) {\n            // Using the effective elapsed time that is consumed so far to update lastRedemptionTimestamp\n            // instead block.timestamp for consistency with _calcDecayedBaseRate()\n            lastRedemptionTimestamp += _minutesPassedSinceLastRedemption() * SECONDS_IN_ONE_MINUTE;\n            emit LastRedemptionTimestampUpdated(block.timestamp);\n        }\n    }\n\n    function _calcDecayedBaseRate() internal view returns (uint256) {\n        uint256 minutesPassed = _minutesPassedSinceLastRedemption();\n        uint256 decayFactor = EbtcMath._decPow(minuteDecayFactor, minutesPassed);\n\n        return (baseRate * decayFactor) / DECIMAL_PRECIS"
    }
  ]
}