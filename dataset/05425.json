{
  "Title": "[H-04] Users staking via the `SurplusGuildMinter` can be immediately slashed when staking into a gauge that had previously incurred a loss",
  "Content": "\nUser's can stake into a gauge directly via the `GuildToken` or indirectly via the `SurplusGuildMinter`. When a user stakes into a new gauge (i.e. their weight goes from `0` to `> 0`) via `GuildToken::incrementGauge`, their `lastGaugeLossApplied` mapping for this gauge, which is how the system keeps track of whether or not the user deserves to be slashed, is set to the current timestamp:\n\n[GuildToken.sol#L247-L256](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L247-L256)\n\n```solidity\n247:        uint256 _lastGaugeLoss = lastGaugeLoss[gauge];\n248:        uint256 _lastGaugeLossApplied = lastGaugeLossApplied[gauge][user];\n249:        if (getUserGaugeWeight[user][gauge] == 0) {\n250:            lastGaugeLossApplied[gauge][user] = block.timestamp;\n251:        } else {\n252:            require(\n253:                _lastGaugeLossApplied >= _lastGaugeLoss,\n254:                \"GuildToken: pending loss\"\n255:            );\n256:        }\n```\n\nThis ensures that any loss that occurred in the gauge, before the user staked, will result in the following condition: `lastGaugeLossApplied[gauge][user] > lastGaugeLoss[gauge]`. This means the user staked into the gauge after the gauge experienced a loss and therefore, they can not be slashed:\n\n[GuildToken.sol#L133-L140](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L133-L140)\n\n```solidity\n133:    function applyGaugeLoss(address gauge, address who) external {\n134:        // check preconditions\n135:        uint256 _lastGaugeLoss = lastGaugeLoss[gauge];\n136:        uint256 _lastGaugeLossApplied = lastGaugeLossApplied[gauge][who];\n137:        require(\n138:            _lastGaugeLoss != 0 && _lastGaugeLossApplied < _lastGaugeLoss,\n139:            \"GuildToken: no loss to apply\"\n140:        );\n```\n\nThe above function showcases the requirements that need to be met in order for a user to be slashed: the user must have been staked in the gauge when the gauge experienced a loss in order for the user to be slashed. With this in mind, let us observe the process that occurs when users stake via the `SurplusGuildMinter`:\n\nWhen a user stakes into a gauge via the `SurpluGuildMinter::stake` function the `SurplusGuildMinter::getRewards` function is invoked:\n\n[SurplusGuildMinter.sol#L216-L236](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L216-L236)\n\n```solidity\n216:    function getRewards(\n217:        address user,\n218:        address term\n219:    )\n220:        public\n221:        returns (\n222:            uint256 lastGaugeLoss, // GuildToken.lastGaugeLoss(term)\n223:            UserStake memory userStake, // stake state after execution of getRewards()\n224:            bool slashed // true if the user has been slashed\n225:        )\n226:    {\n227:        bool updateState;\n228:        lastGaugeLoss = GuildToken(guild).lastGaugeLoss(term);\n229:        if (lastGaugeLoss > uint256(userStake.lastGaugeLoss)) {\n230:            slashed = true;\n231:        }\n232:\n233:        // if the user is not staking, do nothing\n234:        userStake = _stakes[user][term];\n235:        if (userStake.stakeTime == 0)\n236:            return (lastGaugeLoss, userStake, slashed);\n```\n\nAs seen above, this function will retrieve the `lastGaugeLoss` for the specified gauge (`term`) the user is staking into and will identify this user as being slashed, i.e. `slashed = true`, if `lastGaugeLoss > userStake.lastGaugeLoss`. The issue lies in the fact that, at this point in the code execution, the `userStake` struct is a freshly initialized memory struct and therefore, all of the struct's fields are set to `0`. Thus, the check on lines 229-230 are really doing the following:\n\n```solidity\n        if (lastGaugeLoss > uint256(0)) {\n            slashed = true;\n        }\n```\n\nThe above code will always set `slashed` to `true` if the specified gauge has experienced any loss in its history. Therefore, a gauge can have experienced a loss, been off-boarded, and then been re-onboarded at a future time and The `SurplusGuildMinter` will consider any user who stakes into this gauge to be `slashed`.\n\nThe code execution will then continue to lines 235-236, where the user's stake is retrieved from storage (it is initialized to all `0`'s since the user has not staked yet) and if the `stakeTime` field is `0` (it is), the execution returns to the `GuildToken::stake` function:\n\n[SurplusGuildMinter.sol#L114-L125](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L114-L125)\n\n```solidity\n114:    function stake(address term, uint256 amount) external whenNotPaused {\n115:        // apply pending rewards\n116:        (uint256 lastGaugeLoss, UserStake memory userStake, ) = getRewards(\n117:            msg.sender,\n118:            term\n119:        );\n120:\n121:        require(\n122:            lastGaugeLoss != block.timestamp,\n123:            \"SurplusGuildMinter: loss in block\"\n124:        );\n125:        require(amount >= MIN_STAKE, \"SurplusGuildMinter: min stake\");\n```\n\nThe above code illustrates the only validation checks that are performed in this `stake` function. As long as the user is not attempting to stake into a gauge in the same block that the gauge experienced a loss, and the user is staking at least `1e18`, the user's `stake` position will be initialized (the user will be allowed to stake their `Credit`):\n\n[SurplusGuildMinter.sol#L114-L125](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L114-L125)\n\n```solidity\n139:        userStake = UserStake({\n140:            stakeTime: SafeCastLib.safeCastTo48(block.timestamp),\n141:            lastGaugeLoss: SafeCastLib.safeCastTo48(lastGaugeLoss),\n142:            profitIndex: SafeCastLib.safeCastTo160(\n143:                ProfitManager(profitManager).userGaugeProfitIndex(\n144:                    address(this),\n145:                    term\n146:                )\n147:            ),\n148:            credit: userStake.credit + SafeCastLib.safeCastTo128(amount),\n149:            guild: userStake.guild + SafeCastLib.safeCastTo128(guildAmount)\n150:        });\n151:        _stakes[msg.sender][term] = userStake;\n```\n\nThe user would naturally perform the next actions: They can call `SurplusGuildMinter::getRewards` when they want to receive rewards and they can call `SurplusGuildMinter::unstake` when they want to unstake from their position, i.e. withdraw their deposited `Credit`. It is important to note that when the `unstake` function is called, similar to the `stake` function, the `getRewards` function will first be invoked. As we previously observed, the `getRewards` function will consider the user `slashed` if the gauge had previously experienced any loss in its history. Therefore, after a user has staked, any call to `getRewards` will result in the following logic to execute:\n\n[SurplusGuildMinter.sol#L274-L289](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L274-L289)\n\n```solidity\n274:        if (slashed) {\n275:            emit Unstake(block.timestamp, term, uint256(userStake.credit));\n276:            userStake = UserStake({\n277:                stakeTime: uint48(0),\n278:                lastGaugeLoss: uint48(0),\n279:                profitIndex: uint160(0),\n280:                credit: uint128(0),\n281:                guild: uint128(0)\n282:            });\n283:            updateState = true;\n284:        }\n285:\n286:        // store the updated stake, if needed\n287:        if (updateState) {\n288:            _stakes[user][term] = userStake;\n289:        }\n```\n\nAs we can see above, when a user calls `getRewards` or `unstake` after staking into a gauge that has experienced a loss sometime in its history, the user's `stake` position will be deleted (slashed). If the user is attempting to unstake then the execution flow will continue in the `unstake` function:\n\n[SurplusGuildMinter.sol#L158-L166C25](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L158-L166C25)\n\n```solidity\n158:    function unstake(address term, uint256 amount) external {\n159:        // apply pending rewards\n160:        (, UserStake memory userStake, bool slashed) = getRewards(\n161:            msg.sender,\n162:            term\n163:        );\n164:\n165:        // if the user has been slashed, there is nothing to do\n166:        if (slashed) return;\n```\n\nSince the user has been considered `slashed`, the execution will return on line 166 and the user will not be allowed to withdraw their staked `Credit`.\n\nI would also like to note that the user will still have a chance to receive some `earned Credit` after the gauge experiences a profit. However, since the user is considered `slashed`, they will not be given any `guild rewards`:\n\n[SurplusGuildMinter.sol#L247-L264](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L247-L264)\n\n```solidity\n247:        uint256 deltaIndex = _profitIndex - _userProfitIndex;\n248:\n249:        if (deltaIndex != 0) {\n250:            uint256 creditReward = (uint256(userStake.guild) * deltaIndex) /\n251:                1e18;\n252:            uint256 guildReward = (creditReward * rewardRatio) / 1e18;\n253:            if (slashed) {\n254:                guildReward = 0;\n255:            }\n256:\n257:            // forward rewards to user\n258:            if (guildReward != 0) {\n259:                RateLimitedMinter(rlgm).mint(user, guildReward);\n260:                emit GuildReward(block.timestamp, user, guildReward);\n261:            }\n262:            if (creditReward != 0) {\n263:                CreditToken(credit).transfer(user, creditReward);\n264:            }\n```\n\nAs seen above, if the user is eligible to claim rewards (the gauge they staked into has experienced a profit), then they will be sent `creditReward` of `Credit`. However, since they are considered `slashed`, their `guildReward` is set to `0`. This scenario will only occur if no one calls `getReward` for this user before the gauge generates a profit. If any call to `getReward` for this user is invoked before that, the user will not be able to receive any rewards and in both situations they will lose their staked `Credit`.\n\nAn additional, lesser effect, is that the `Guild` which was minted on behalf of the user who staked will not be unstaked from the gauge, it will not be burned, and the `RateLimitedGuildMinter`'s buffer will not be replenished. I.e. the following code from the `unstake` function will not execute:\n\n[SurplusGuildMinter.sol#L205-L208](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L205-L208)\n\n```solidity\n205:        // burn GUILD\n206:        GuildToken(guild).decrementGauge(term, guildAmount);\n207:        RateLimitedMinter(rlgm).replenishBuffer(guildAmount);\n208:        GuildToken(guild).burn(guildAmount);\n```\n\n### Impact\n\nUser's utilizing the `SurplusGuildMinter` to stake into a gauge, which has previously experienced a loss sometime in its history, can be immediately slashed. This will result in the user losing out on any guild rewards (if they were staked into the gauge while it experienced a profit), but most importantly this will result in the user losing their staked principle (`Credit`).\n\nTo further illustrate the impact of this vulnerability, lets consider the following scenario:\n\nA gauge experiences a loss. The gauge is then off-boarded. The gauge is re-onboarded in the future. A user stakes into this gauge via the `SurplusGuildMinter`. A malicious actor immediately calls `getRewards(gauge, user)` and the user is `slashed` and loses their staked `Credit`.\n\n### Proof of Concept\n\nThe following test describes the main impact highlighted above, in which a user stakes into a previously lossy gauge and is immediately slashed:\n\nPlace the following test inside of `test/unit/loan/SurplusGuildMinter.t.sol`:\n\n```solidity\n    function testUserImmediatelySlashed() public {\n        // initial state\n        assertEq(guild.getGaugeWeight(term), 50e18);\n\n        // add credit to surplus buffer\n        credit.mint(address(this), 100e18);\n        credit.approve(address(profitManager), 50e18);\n        profitManager.donateToSurplusBuffer(50e18);\n\n        // term incurs loss\n        profitManager.notifyPnL(term, -50e18);\n        assertEq(guild.lastGaugeLoss(term), block.timestamp);\n\n        // term offboarded\n        guild.removeGauge(term);\n        assertEq(guild.isGauge(term), false);\n\n        // time passes and term is re-onboarded\n        vm.roll(block.number + 100);\n        vm.warp(block.timestamp + (100 * 13));\n        guild.addGauge(1, term);\n        assertEq(guild.isGauge(term), true);\n\n        // user stakes into term directly\n        address user = address(0x01010101);\n        guild.mint(user, 10e18);\n        vm.startPrank(user);\n        guild.incrementGauge(term, 10e18);\n        vm.stopPrank();\n\n        // user can un-stake from term\n        vm.startPrank(user);\n        guild.decrementGauge(term, 10e18);\n        vm.stopPrank();\n\n        // user stakes into term via sgm\n        credit.mint(user, 10e18);\n        vm.startPrank(user);\n        credit.approve(address(sgm), 10e18);\n        sgm.stake(term, 10e18);\n        vm.stopPrank();\n        \n        // check after-stake state\n        assertEq(credit.balanceOf(user), 0);\n        assertEq(profitManager.termSurplusBuffer(term), 10e18);\n        assertEq(guild.getGaugeWeight(term), 70e18);\n        SurplusGuildMinter.UserStake memory userStake = sgm.getUserStake(user, term);\n        assertEq(uint256(userStake.stakeTime), block.timestamp);\n        assertEq(userStake.lastGaugeLoss, guild.lastGaugeLoss(term));\n        assertEq(userStake.profitIndex, 0);\n        assertEq(userStake.credit, 10e18);\n        assertEq(userStake.guild, 20e18);\n\n        // malicious actor is aware of bug and slashes the user's stake immediately, despite no loss occurring in the gauge\n        sgm.getRewards(user, term);\n\n        // check after-getReward state (user was slashed even though no loss has occurred since term was re-onboarded)\n        assertEq(credit.balanceOf(user), 0);\n        assertEq(profitManager.termSurplusBuffer(term), 10e18);\n        assertEq(guild.getGaugeWeight(term), 70e18);\n        userStake = sgm.getUserStake(user, term);\n        assertEq(uint256(userStake.stakeTime), 0);\n        assertEq(userStake.lastGaugeLoss, 0);\n        assertEq(userStake.profitIndex, 0);\n        assertEq(userStake.credit, 0);\n        assertEq(userStake.guild, 0);\n\n        // user tries to unstake but will not receive anything\n        uint256 userBalanceBefore = credit.balanceOf(user);\n        vm.startPrank(user);\n        sgm.unstake(term, 10e18);\n        vm.stopPrank();\n        uint256 userAfterBalance = credit.balanceOf(user);\n\n        assertEq(userBalanceBefore, 0);\n        assertEq(userAfterBalance, 0);\n    }\n```\n\n### Recommended Mitigation Steps\n\nSimilar to how the `GuildToken::incrementGauge` function initializes a user's `lastGaugeLossApplied` value, the `SurplusGuildMinter` should initialize a user's `userStake.lastGaugeLoss` to `block.timestamp`. It should then compare the `lastGaugeLoss` to the user's stored `userStake.lastGaugeLoss` instead of comparing the `lastGaugeLoss` to a freshly initialized `userStake` memory struct, whose fields are all `0`.\n\n**[eswak (Ethereum Credit Guild) confirmed via duplicate issue #1164](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/1164#issuecomment-1885000522)**\n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/473).*\n\n***\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-12-ethereumcreditguild",
  "Code": [
    {
      "filename": "src/tokens/GuildToken.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\nimport {ERC20Burnable} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {LendingTerm} from \"@src/loan/LendingTerm.sol\";\nimport {ERC20Gauges} from \"@src/tokens/ERC20Gauges.sol\";\nimport {ProfitManager} from \"@src/governance/ProfitManager.sol\";\nimport {ERC20MultiVotes} from \"@src/tokens/ERC20MultiVotes.sol\";\n\n/** \n@title  GUILD ERC20 Token\n@author eswak\n@notice This is the governance token of the Ethereum Credit Guild.\n    On deploy, this token is non-transferrable.\n    During the non-transferrable period, GUILD can still be minted & burnt, only\n    `transfer` and `transferFrom` are reverting.\n\n    The gauge system is used to define debt ceilings on a set of lending terms.\n    Lending terms can be whitelisted by adding a gauge for their address, if GUILD\n    holders vote for these lending terms in the gauge system, the lending terms will\n    have a non-zero debt ceiling, and borrowing will be available under these terms.\n\n    When a lending term creates bad debt, a loss is notified in a gauge on this\n    contract (`notifyGaugeLoss`). When a loss is notified, all the GUILD token weight voting\n    for this gauge becomes non-transferable and can be permissionlessly slashed. Until the\n    loss is realized (`applyGaugeLoss`), a user cannot transfer their locked tokens or\n    decrease the weight they assign to the gauge that suffered a loss.\n    Even when a loss occur, users can still transfer tokens with which they vote for gauges\n    that did not suffer a loss.\n*/\ncontract GuildToken is CoreRef, ERC20Burnable, ERC20Gauges, ERC20MultiVotes {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice reference to ProfitManager\n    address public profitManager;\n\n    constructor(\n        address _core,\n        address _profitManager\n    )\n        CoreRef(_core)\n        ERC20(\"Ethereum Credit Guild - GUILD\", \"GUILD\")\n        ERC20Permit(\"Ethereum Credit Guild - GUILD\")\n    {\n        profitManager = _profitManager;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        VOTING MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Set `maxDelegates`, the maximum number of addresses any account can delegate voting power to.\n    function setMaxDelegates(\n        uint256 newMax\n    ) external onlyCoreRole(CoreRoles.GUILD_GOVERNANCE_PARAMETERS) {\n        _setMaxDelegates(newMax);\n    }\n\n    /// @notice Allow or disallow an address to delegate voting power to more addresses than `maxDelegates`.\n    function setContractExceedMaxDelegates(\n        address account,\n        bool canExceedMax\n    ) external onlyCoreRole(CoreRoles.GUILD_GOVERNANCE_PARAMETERS) {\n        _setContractExceedMaxDelegates(account, canExceedMax);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        GAUGE MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n    function addGauge(\n        uint256 _type,\n        address gauge\n    ) external onlyCoreRole(CoreRoles.GAUGE_ADD) returns (uint256) {\n        return _addGauge(_type, gauge);\n    }\n\n    function removeGauge(\n        address gauge\n    ) external onlyCoreRole(CoreRoles.GAUGE_REMOVE) {\n        _removeGauge(gauge);\n    }\n\n    function setMaxGauges(\n        uint256 max\n    ) external onlyCoreRole(CoreRoles.GAUGE_PARAMETERS) {\n        _setMaxGauges(max);\n    }\n\n    function setCanExceedMaxGauges(\n        address who,\n        bool can\n    ) external onlyCoreRole(CoreRoles.GAUGE_PARAMETERS) {\n        _setCanExceedMaxGauges(who, can);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        LOSS MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice emitted when a loss in a gauge is notified.\n    event GaugeLoss(address indexed gauge, uint256 indexed when);\n    /// @notice emitted when a loss in a gauge is applied (for each user).\n    event GaugeLossApply(\n        address indexed gauge,\n        address indexed who,\n        uint256 weight,\n        uint256 when\n    );\n\n    /// @notice last block.timestamp when a loss occurred in a given gauge\n    mapping(address => uint256) public lastGaugeLoss;\n\n    /// @notice last block.timestamp when a user apply a loss that occurred in a given gauge\n    mapping(address => mapping(address => uint256)) public lastGaugeLossApplied;\n\n    /// @notice notify loss in a given gauge\n    function notifyGaugeLoss(address gauge) external {\n        require(msg.sender == profitManager, \"UNAUTHORIZED\");\n\n        // save gauge loss\n        lastGaugeLoss[gauge] = block.timestamp;\n        emit GaugeLoss(gauge, block.timestamp);\n    }\n\n    /// @notice apply a loss that occurred in a given gauge\n    /// anyone can apply the loss on behalf of anyone else\n    function applyGaugeLoss(address gauge, address who) external {\n        // check preconditions\n        uint256 _lastGaugeLoss = lastGaugeLoss[gauge];\n        uint256 _lastGaugeLossApplied = lastGaugeLossApplied[gauge][who];\n        require(\n            _lastGaugeLoss != 0 && _lastGaugeLossApplied < _lastGaugeLoss,\n            \"GuildToken: no loss to apply\"\n        );\n\n        // read user weight allocated to the lossy gauge\n        uint256 _userGaugeWeight = getUserGaugeWeight[who][gauge];\n\n        // remove gauge weight allocation\n        lastGaugeLossApplied[gauge][who] = block.timestamp;\n        _decrementGaugeWeight(who, gauge, _userGaugeWeight);\n        if (!_deprecatedGauges.contains(gauge)) {\n            totalTypeWeight[gaugeType[gauge]] -= _userGaugeWeight;\n            totalWeight -= _userGaugeWeight;\n        }\n\n        // apply loss\n        _burn(who, uint256(_userGaugeWeight));\n        emit GaugeLossApply(\n            gauge,\n            who,\n            uint256(_userGaugeWeight),\n            block.timestamp\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        TRANSFERABILITY\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice at deployment, tokens are not transferable (can only mint/burn).\n    /// Governance can enable transfers with `enableTransfers()`.\n    bool public transferable; // default = false\n\n    /// @notice emitted when transfers are enabled.\n    event TransfersEnabled(uint256 block, uint256 timestamp);\n\n    /// @notice permanently enable token transfers.\n    function enableTransfer() external onlyCoreRole(CoreRoles.GOVERNOR) {\n        transferable = true;\n        emit TransfersEnabled(block.number, block.timestamp);\n    }\n\n    /// @dev prevent transfers if they are not globally enabled.\n    /// mint and burn (transfers to and from address 0) are accepted.\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 /* amount*/\n    ) internal view override {\n        require(\n            transferable || from == address(0) || to == address(0),\n            \"GuildToken: transfers disabled\"\n        );\n    }\n\n    /// @notice emitted when reference to ProfitManager is updated\n    event ProfitManagerUpdated(uint256 timestamp, address newValue);\n\n    /// @notice set reference to ProfitManager\n    function setProfitManager(address _newProfitManager) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        profitManager = _newProfitManager;\n        emit ProfitManagerUpdated(block.timestamp, _newProfitManager);\n    }\n\n    /// @dev prevent outbound token transfers (_decrementWeightUntilFree) and gauge weight decrease\n    /// (decrementGauge, decrementGauges) for users who have an unrealized loss in a gauge, or if the\n    /// gauge is currently using its allocated debt ceiling. To decrement gauge weight, guild holders\n    /// might have to call loans if the debt ceiling is used.\n    /// Also update the user profit index and claim rewards.\n    function _decrementGaugeWeight(\n        address user,\n        address gauge,\n        uint256 weight\n    ) internal override {\n        uint256 _lastGaugeLoss = lastGaugeLoss[gauge];\n        uint256 _lastGaugeLossApplied = lastGaugeLossApplied[gauge][user];\n        require(\n            _lastGaugeLossApplied >= _lastGaugeLoss,\n            \"GuildToken: pending loss\"\n        );\n\n        // update the user profit index and claim rewards\n        ProfitManager(profitManager).claimGaugeRewards(user, gauge);\n\n        // check if gauge is currently using its allocated debt ceiling.\n        // To decrement gauge weight, guild holders might have to call loans if the debt ceiling is used.\n        uint256 issuance = LendingTerm(gauge).issuance();\n        if (issuance != 0) {\n            uint256 debtCeilingAfterDecrement = LendingTerm(gauge).debtCeiling(-int256(weight));\n            require(\n                issuance <= debtCeilingAfterDecrement,\n                \"GuildToken: debt ceiling used\"\n            );\n        }\n\n        super._decrementGaugeWeight(user, gauge, weight);\n    }\n\n    /// @dev prevent weight increment for gauge if user has an unapplied loss.\n    /// If the user has 0 weight (i.e. no loss to realize), allow incrementing\n    /// gauge weight & update lastGaugeLossApplied to current time.\n    /// Also update the user profit index an claim rewards.\n    /// @dev note that users voting for a gauge that is not a proper lending term could result in this\n    /// share of the user's tokens to be frozen, due to being unable to decrement weight.\n    function _incrementGaugeWeight(\n        address user,\n        address gauge,\n        uint256 weight\n    ) internal override {\n        uint256 _lastGaugeLoss = lastGaugeLoss[gauge];\n        uint256 _lastGaugeLossApplied = lastGaugeLossApplied[gauge][user];\n        if (getUserGaugeWeight[user][gauge] == 0) {\n            lastGaugeLossApplied[gauge][user] = block.timestamp;\n        } else {\n            require(\n                _lastGaugeLossApplied >= _lastGaugeLoss,\n                \"GuildToken: pending loss\"\n            );\n        }\n\n        ProfitManager(profitManager).claimGaugeRewards(user, gauge);\n\n        super._incrementGaugeWeight(user, gauge, weight);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        MINT / BURN\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice mint new tokens to the target address\n    function mint(\n        address to,\n        uint256 amount\n    ) external onlyCoreRole(CoreRoles.GUILD_MINTER) {\n        _mint(to, amount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        Inheritance reconciliation\n    //////////////////////////////////////////////////////////////*/\n\n    function _burn(\n        address from,\n        uint256 amount\n    ) internal virtual override(ERC20, ERC20Gauges, ERC20MultiVotes) {\n        _decrementWeightUntilFree(from, amount);\n        _decrementVotesUntilFree(from, amount);\n        ERC20._burn(from, amount);\n    }\n\n    function transfer(\n        address to,\n        uint256 amount\n    )\n        public\n        virtual\n        override(ERC20, ERC20Gauges, ERC20MultiVotes)\n        returns (bool)\n    {\n        _decrementWeightUntilFree(msg.sender, amount);\n        _decrementVotesUntilFree(msg.sender, amount);\n        return ERC20.transfer(to, amount);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    )\n        public\n        virtual\n        override(ERC20, ERC20Gauges, ERC20MultiVotes)\n        returns (bool)\n    {\n        _decrementWeightUntilFree(from, amount);\n        _decrementVotesUntilFree(from, amount);\n        return ERC20.transferFrom(from, to, amount);\n    }\n}"
    },
    {
      "filename": "src/tokens/GuildToken.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\nimport {ERC20Burnable} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {LendingTerm} from \"@src/loan/LendingTerm.sol\";\nimport {ERC20Gauges} from \"@src/tokens/ERC20Gauges.sol\";\nimport {ProfitManager} from \"@src/governance/ProfitManager.sol\";\nimport {ERC20MultiVotes} from \"@src/tokens/ERC20MultiVotes.sol\";\n\n/** \n@title  GUILD ERC20 Token\n@author eswak\n@notice This is the governance token of the Ethereum Credit Guild.\n    On deploy, this token is non-transferrable.\n    During the non-transferrable period, GUILD can still be minted & burnt, only\n    `transfer` and `transferFrom` are reverting.\n\n    The gauge system is used to define debt ceilings on a set of lending terms.\n    Lending terms can be whitelisted by adding a gauge for their address, if GUILD\n    holders vote for these lending terms in the gauge system, the lending terms will\n    have a non-zero debt ceiling, and borrowing will be available under these terms.\n\n    When a lending term creates bad debt, a loss is notified in a gauge on this\n    contract (`notifyGaugeLoss`). When a loss is notified, all the GUILD token weight voting\n    for this gauge becomes non-transferable and can be permissionlessly slashed. Until the\n    loss is realized (`applyGaugeLoss`), a user cannot transfer their locked tokens or\n    decrease the weight they assign to the gauge that suffered a loss.\n    Even when a loss occur, users can still transfer tokens with which they vote for gauges\n    that did not suffer a loss.\n*/\ncontract GuildToken is CoreRef, ERC20Burnable, ERC20Gauges, ERC20MultiVotes {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice reference to ProfitManager\n    address public profitManager;\n\n    constructor(\n        address _core,\n        address _profitManager\n    )\n        CoreRef(_core)\n        ERC20(\"Ethereum Credit Guild - GUILD\", \"GUILD\")\n        ERC20Permit(\"Ethereum Credit Guild - GUILD\")\n    {\n        profitManager = _profitManager;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        VOTING MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Set `maxDelegates`, the maximum number of addresses any account can delegate voting power to.\n    function setMaxDelegates(\n        uint256 newMax\n    ) external onlyCoreRole(CoreRoles.GUILD_GOVERNANCE_PARAMETERS) {\n        _setMaxDelegates(newMax);\n    }\n\n    /// @notice Allow or disallow an address to delegate voting power to more addresses than `maxDelegates`.\n    function setContractExceedMaxDelegates(\n        address account,\n        bool canExceedMax\n    ) external onlyCoreRole(CoreRoles.GUILD_GOVERNANCE_PARAMETERS) {\n        _setContractExceedMaxDelegates(account, canExceedMax);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        GAUGE MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n    function addGauge(\n        uint256 _type,\n        address gauge\n    ) external onlyCoreRole(CoreRoles.GAUGE_ADD) returns (uint256) {\n        return _addGauge(_type, gauge);\n    }\n\n    function removeGauge(\n        address gauge\n    ) external onlyCoreRole(CoreRoles.GAUGE_REMOVE) {\n        _removeGauge(gauge);\n    }\n\n    function setMaxGauges(\n        uint256 max\n    ) external onlyCoreRole(CoreRoles.GAUGE_PARAMETERS) {\n        _setMaxGauges(max);\n    }\n\n    function setCanExceedMaxGauges(\n        address who,\n        bool can\n    ) external onlyCoreRole(CoreRoles.GAUGE_PARAMETERS) {\n        _setCanExceedMaxGauges(who, can);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        LOSS MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice emitted when a loss in a gauge is notified.\n    event GaugeLoss(address indexed gauge, uint256 indexed when);\n    /// @notice emitted when a loss in a gauge is applied (for each user).\n    event GaugeLossApply(\n        address indexed gauge,\n        address indexed who,\n        uint256 weight,\n        uint256 when\n    );\n\n    /// @notice last block.timestamp when a loss occurred in a given gauge\n    mapping(address => uint256) public lastGaugeLoss;\n\n    /// @notice last block.timestamp when a user apply a loss that occurred in a given gauge\n    mapping(address => mapping(address => uint256)) public lastGaugeLossApplied;\n\n    /// @notice notify loss in a given gauge\n    function notifyGaugeLoss(address gauge) external {\n        require(msg.sender == profitManager, \"UNAUTHORIZED\");\n\n        // save gauge loss\n        lastGaugeLoss[gauge] = block.timestamp;\n        emit GaugeLoss(gauge, block.timestamp);\n    }\n\n    /// @notice apply a loss that occurred in a given gauge\n    /// anyone can apply the loss on behalf of anyone else\n    function applyGaugeLoss(address gauge, address who) external {\n        // check preconditions\n        uint256 _lastGaugeLoss = lastGaugeLoss[gauge];\n        uint256 _lastGaugeLossApplied = lastGaugeLossApplied[gauge][who];\n        require(\n            _lastGaugeLoss != 0 && _lastGaugeLossApplied < _lastGaugeLoss,\n            \"GuildToken: no loss to apply\"\n        );\n\n        // read user weight allocated to the lossy gauge\n        uint256 _userGaugeWeight = getUserGaugeWeight[who][gauge];\n\n        // remove gauge weight allocation\n        lastGaugeLossApplied[gauge][who] = block.timestamp;\n        _decrementGaugeWeight(who, gauge, _userGaugeWeight);\n        if (!_deprecatedGauges.contains(gauge)) {\n            totalTypeWeight[gaugeType[gauge]] -= _userGaugeWeight;\n            totalWeight -= _userGaugeWeight;\n        }\n\n        // apply loss\n        _burn(who, uint256(_userGaugeWeight));\n        emit GaugeLossApply(\n            gauge,\n            who,\n            uint256(_userGaugeWeight),\n            block.timestamp\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        TRANSFERABILITY\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice at deployment, tokens are not transferable (can only mint/burn).\n    /// Governance can enable transfers with `enableTransfers()`.\n    bool public transferable; // default = false\n\n    /// @notice emitted when transfers are enabled.\n    event TransfersEnabled(uint256 block, uint256 timestamp);\n\n    /// @notice permanently enable token transfers.\n    function enableTransfer() external onlyCoreRole(CoreRoles.GOVERNOR) {\n        transferable = true;\n        emit TransfersEnabled(block.number, block.timestamp);\n    }\n\n    /// @dev prevent transfers if they are not globally enabled.\n    /// mint and burn (transfers to and from address 0) are accepted.\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 /* amount*/\n    ) internal view override {\n        require(\n            transferable || from == address(0) || to == address(0),\n            \"GuildToken: transfers disabled\"\n        );\n    }\n\n    /// @notice emitted when reference to ProfitManager is updated\n    event ProfitManagerUpdated(uint256 timestamp, address newValue);\n\n    /// @notice set reference to ProfitManager\n    function setProfitManager(address _newProfitManager) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        profitManager = _newProfitManager;\n        emit ProfitManagerUpdated(block.timestamp, _newProfitManager);\n    }\n\n    /// @dev prevent outbound token transfers (_decrementWeightUntilFree) and gauge weight decrease\n    /// (decrementGauge, decrementGauges) for users who have an unrealized loss in a gauge, or if the\n    /// gauge is currently using its allocated debt ceiling. To decrement gauge weight, guild holders\n    /// might have to call loans if the debt ceiling is used.\n    /// Also update the user profit index and claim rewards.\n    function _decrementGaugeWeight(\n        address user,\n        address gauge,\n        uint256 weight\n    ) internal override {\n        uint256 _lastGaugeLoss = lastGaugeLoss[gauge];\n        uint256 _lastGaugeLossApplied = lastGaugeLossApplied[gauge][user];\n        require(\n            _lastGaugeLossApplied >= _lastGaugeLoss,\n            \"GuildToken: pending loss\"\n        );\n\n        // update the user profit index and claim rewards\n        ProfitManager(profitManager).claimGaugeRewards(user, gauge);\n\n        // check if gauge is currently using its allocated debt ceiling.\n        // To decrement gauge weight, guild holders might have to call loans if the debt ceiling is used.\n        uint256 issuance = LendingTerm(gauge).issuance();\n        if (issuance != 0) {\n            uint256 debtCeilingAfterDecrement = LendingTerm(gauge).debtCeiling(-int256(weight));\n            require(\n                issuance <= debtCeilingAfterDecrement,\n                \"GuildToken: debt ceiling used\"\n            );\n        }\n\n        super._decrementGaugeWeight(user, gauge, weight);\n    }\n\n    /// @dev prevent weight increment for gauge if user has an unapplied loss.\n    /// If the user has 0 weight (i.e. no loss to realize), allow incrementing\n    /// gauge weight & update lastGaugeLossApplied to current time.\n    /// Also update the user profit index an claim rewards.\n    /// @dev note that users voting for a gauge that is not a proper lending term could result in this\n    /// share of the user's tokens to be frozen, due to being unable to decrement weight.\n    function _incrementGaugeWeight(\n        address user,\n        address gauge,\n        uint256 weight\n    ) internal override {\n        uint256 _lastGaugeLoss = lastGaugeLoss[gauge];\n        uint256 _lastGaugeLossApplied = lastGaugeLossApplied[gauge][user];\n        if (getUserGaugeWeight[user][gauge] == 0) {\n            lastGaugeLossApplied[gauge][user] = block.timestamp;\n        } else {\n            require(\n                _lastGaugeLossApplied >= _lastGaugeLoss,\n                \"GuildToken: pending loss\"\n            );\n        }\n\n        ProfitManager(profitManager).claimGaugeRewards(user, gauge);\n\n        super._incrementGaugeWeight(user, gauge, weight);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        MINT / BURN\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice mint new tokens to the target address\n    function mint(\n        address to,\n        uint256 amount\n    ) external onlyCoreRole(CoreRoles.GUILD_MINTER) {\n        _mint(to, amount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        Inheritance reconciliation\n    //////////////////////////////////////////////////////////////*/\n\n    function _burn(\n        address from,\n        uint256 amount\n    ) internal virtual override(ERC20, ERC20Gauges, ERC20MultiVotes) {\n        _decrementWeightUntilFree(from, amount);\n        _decrementVotesUntilFree(from, amount);\n        ERC20._burn(from, amount);\n    }\n\n    function transfer(\n        address to,\n        uint256 amount\n    )\n        public\n        virtual\n        override(ERC20, ERC20Gauges, ERC20MultiVotes)\n        returns (bool)\n    {\n        _decrementWeightUntilFree(msg.sender, amount);\n        _decrementVotesUntilFree(msg.sender, amount);\n        return ERC20.transfer(to, amount);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    )\n        public\n        virtual\n        override(ERC20, ERC20Gauges, ERC20MultiVotes)\n        returns (bool)\n    {\n        _decrementWeightUntilFree(from, amount);\n        _decrementVotesUntilFree(from, amount);\n        return ERC20.transferFrom(from, to, amount);\n    }\n}"
    },
    {
      "filename": "src/loan/SurplusGuildMinter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {SafeCastLib} from \"@src/external/solmate/SafeCastLib.sol\";\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {GuildToken} from \"@src/tokens/GuildToken.sol\";\nimport {CreditToken} from \"@src/tokens/CreditToken.sol\";\nimport {ProfitManager} from \"@src/governance/ProfitManager.sol\";\nimport {RateLimitedMinter} from \"@src/rate-limits/RateLimitedMinter.sol\";\n\n/// @notice SurplusGuildMinter allows GUILD to be minted from CREDIT collateral.\n/// In this contract, CREDIT tokens can be provided as first-loss capital to\n/// the surplus buffer of chosen terms, and in exchange, users can participate in the\n/// gauge voting system at a reduced capital cost & without exposure to GUILD\n/// token's price fluctuations. GUILD minted through this contract can only\n/// participate in the gauge system to increase debt ceiling and earn fees\n/// from selected lending terms.\n/// @dev note that any update to the `rewardRatio` (through `setRewardRatio`) will\n/// change the rewards of all pending unclaimed rewards. Before a proposal to update\n/// the reward ratio execute, this contract should be pinged with `getRewards` for\n/// all users that have pending rewards.\ncontract SurplusGuildMinter is CoreRef {\n    /// @notice minimum number of CREDIT to stake\n    uint256 public constant MIN_STAKE = 1e18;\n\n    /// @notice reference number of seconds in 1 year\n    uint256 public constant YEAR = 31557600;\n\n    /// @notice emitted when a user stakes CREDIT on a target lending term\n    event Stake(\n        uint256 indexed timestamp,\n        address indexed term,\n        uint256 amount\n    );\n    /// @notice emitted when a user unstakes CREDIT on a target lending term\n    event Unstake(\n        uint256 indexed timestamp,\n        address indexed term,\n        uint256 amount\n    );\n    /// @notice emitted when a user is rewarded GUILD from non-zero interest\n    /// rate and closing their position without loss.\n    event GuildReward(\n        uint256 indexed timestamp,\n        address indexed user,\n        uint256 amount\n    );\n    /// @notice emitted when the mintRatio is updated\n    event MintRatioUpdate(uint256 indexed timestamp, uint256 ratio);\n    /// @notice emitted when the rewardRatio is updated\n    event RewardRatioUpdate(uint256 indexed timestamp, uint256 ratio);\n\n    /// @notice reference to the ProfitManager\n    address public immutable profitManager;\n\n    /// @notice reference to the CREDIT token\n    address public immutable credit;\n\n    /// @notice reference to the GUILD token\n    address public immutable guild;\n\n    /// @notice reference to the RateLimitedGuildMinter\n    address public immutable rlgm;\n\n    /// @notice ratio of GUILD tokens minted per CREDIT tokens staked.\n    /// expressed with 18 decimals, e.g. a ratio of 2e18 would provide 2e18\n    /// GUILD tokens to a user that stakes 1e18 CREDIT tokens.\n    uint256 public mintRatio;\n\n    /// @notice ratio of GUILD tokens earned per CREDIT tokens earned.\n    /// expressed with 18 decimals, e.g. a ratio of 2e18 would provide 2e18\n    /// GUILD tokens to a user that stakes earned 1e18 CREDIT tokens.\n    uint256 public rewardRatio;\n\n    struct UserStake {\n        uint48 stakeTime;\n        uint48 lastGaugeLoss;\n        uint160 profitIndex;\n        uint128 credit;\n        uint128 guild;\n    }\n\n    /// @notice list of user stakes (stakes[user][term]=UserStake)\n    mapping(address => mapping(address => UserStake)) internal _stakes;\n\n    constructor(\n        address _core,\n        address _profitManager,\n        address _credit,\n        address _guild,\n        address _rlgm,\n        uint256 _mintRatio,\n        uint256 _rewardRatio\n    ) CoreRef(_core) {\n        profitManager = _profitManager;\n        credit = _credit;\n        guild = _guild;\n        rlgm = _rlgm;\n        mintRatio = _mintRatio;\n        rewardRatio = _rewardRatio;\n    }\n\n    /// @notice get a given user stake\n    function getUserStake(\n        address user,\n        address term\n    ) external view returns (UserStake memory) {\n        return _stakes[user][term];\n    }\n\n    /// @notice stake CREDIT tokens to start voting in a gauge.\n    function stake(address term, uint256 amount) external whenNotPaused {\n        // apply pending rewards\n        (uint256 lastGaugeLoss, UserStake memory userStake, ) = getRewards(\n            msg.sender,\n            term\n        );\n\n        require(\n            lastGaugeLoss != block.timestamp,\n            \"SurplusGuildMinter: loss in block\"\n        );\n        require(amount >= MIN_STAKE, \"SurplusGuildMinter: min stake\");\n\n        // pull CREDIT from user & transfer it to surplus buffer\n        CreditToken(credit).transferFrom(msg.sender, address(this), amount);\n        CreditToken(credit).approve(address(profitManager), amount);\n        ProfitManager(profitManager).donateToTermSurplusBuffer(term, amount);\n\n        // self-mint GUILD tokens\n        uint256 _mintRatio = mintRatio;\n        uint256 guildAmount = (_mintRatio * amount) / 1e18;\n        RateLimitedMinter(rlgm).mint(address(this), guildAmount);\n        GuildToken(guild).incrementGauge(term, guildAmount);\n\n        // update state\n        userStake = UserStake({\n            stakeTime: SafeCastLib.safeCastTo48(block.timestamp),\n            lastGaugeLoss: SafeCastLib.safeCastTo48(lastGaugeLoss),\n            profitIndex: SafeCastLib.safeCastTo160(\n                ProfitManager(profitManager).userGaugeProfitIndex(\n                    address(this),\n                    term\n                )\n            ),\n            credit: userStake.credit + SafeCastLib.safeCastTo128(amount),\n            guild: userStake.guild + SafeCastLib.safeCastTo128(guildAmount)\n        });\n        _stakes[msg.sender][term] = userStake;\n\n        // emit event\n        emit Stake(block.timestamp, term, amount);\n    }\n\n    /// @notice unstake CREDIT tokens and stop voting in a gauge.\n    function unstake(address term, uint256 amount) external {\n        // apply pending rewards\n        (, UserStake memory userStake, bool slashed) = getRewards(\n            msg.sender,\n            term\n        );\n\n        // if the user has been slashed, there is nothing to do\n        if (slashed) return;\n\n        // check that the user is at least staking `amount` CREDIT\n        require(\n            amount != 0 && userStake.credit >= amount,\n            \"SurplusGuildMinter: invalid amount\"\n        );\n\n        // update stake\n        uint256 userMintRatio = (uint256(userStake.guild) * 1e18) /\n            userStake.credit; /// upcast guild to prevent overflow\n        uint256 guildAmount = (userMintRatio * amount) / 1e18;\n\n        if (amount == userStake.credit) guildAmount = userStake.guild;\n\n        userStake.credit -= SafeCastLib.safeCastTo128(amount);\n        userStake.guild -= SafeCastLib.safeCastTo128(guildAmount);\n\n        if (userStake.credit == 0) {\n            userStake.stakeTime = 0;\n            userStake.lastGaugeLoss = 0;\n            userStake.profitIndex = 0;\n        } else {\n            // if not unstaking all, make sure the stake remains\n            // greater than the minimum stake\n            require(\n                userStake.credit >= MIN_STAKE,\n                \"SurplusGuildMinter: remaining stake below min\"\n            );\n        }\n        _stakes[msg.sender][term] = userStake;\n\n        // withdraw & transfer CREDIT\n        ProfitManager(profitManager).withdrawFromTermSurplusBuffer(\n            term,\n            msg.sender,\n            amount\n        );\n\n        // burn GUILD\n        GuildToken(guild).decrementGauge(term, guildAmount);\n        RateLimitedMinter(rlgm).replenishBuffer(guildAmount);\n        GuildToken(guild).burn(guildAmount);\n\n        // emit event\n        emit Unstake(block.timestamp, term, amount);\n    }\n\n    /// @notice get rewards from a staking position without unstaking.\n    /// This can be used to slash users that have an outstanding unapplied loss.\n    function getRewards(\n        address user,\n        address term\n    )\n        public\n        returns (\n            uint256 lastGaugeLoss, // GuildToken.lastGaugeLoss(term)\n            UserStake memory userStake, // stake state after execution of getRewards()\n            bool slashed // true if the user has been slashed\n        )\n    {\n        bool updateState;\n        lastGaugeLoss = GuildToken(guild).lastGaugeLoss(term);\n        if (lastGaugeLoss > uint256(userStake.lastGaugeLoss)) {\n            slashe"
    }
  ]
}