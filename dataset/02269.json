{
  "Title": "H-5: Reinvest will return sub-optimal return if the pool is imbalanced",
  "Content": "# Issue H-5: Reinvest will return sub-optimal return if the pool is imbalanced \n\nSource: https://github.com/sherlock-audit/2023-02-notional-judging/issues/9 \n\n## Found by \nxiaoming90\n\n## Summary\n\nReinvesting only allows proportional deposit. If the pool is imbalanced due to unexpected circumstances, performing a proportional deposit is not optimal. This result in fewer pool tokens in return due to sub-optimal trade, eventually leading to a loss of gain for the vault shareholder.\n\n## Vulnerability Detail\n\nDuring reinvest rewards, the vault will ensure that the amount of primary and secondary tokens deposited is of the right proportion per the comment in Line 163 below.\n\nhttps://github.com/sherlock-audit/2023-02-notional/blob/main/leveraged-vaults/contracts/vaults/curve/external/Curve2TokenConvexHelper.sol#L163\n\n```solidity\nFile: Curve2TokenConvexHelper.sol\n146:     function reinvestReward(\n147:         Curve2TokenConvexStrategyContext calldata context,\n148:         ReinvestRewardParams calldata params\n149:     ) external {\n..SNIP..\n163:         // Make sure we are joining with the right proportion to minimize slippage\n164:         poolContext._validateSpotPriceAndPairPrice({\n165:             strategyContext: strategyContext,\n166:             oraclePrice: poolContext.basePool._getOraclePairPrice(strategyContext),\n167:             primaryAmount: primaryAmount,\n168:             secondaryAmount: secondaryAmount\n169:         });\n```\n\nThe `Curve2TokenConvexHelper.reinvestReward` function will internally call the `Curve2TokenPoolUtils._checkPrimarySecondaryRatio`, which will check that the primary and secondary tokens deposited are of the right proportion.\n\nhttps://github.com/sherlock-audit/2023-02-notional/blob/main/leveraged-vaults/contracts/vaults/curve/internal/pool/Curve2TokenPoolUtils.sol#L147\n\n```solidity\nFile: Curve2TokenPoolUtils.sol\n147:     function _checkPrimarySecondaryRatio(\n148:         StrategyContext memory strategyContext,\n149:         uint256 primaryAmount, \n150:         uint256 secondaryAmount, \n151:         uint256 primaryPoolBalance, \n152:         uint256 secondaryPoolBalance\n153:     ) private pure {\n154:         uint256 totalAmount = primaryAmount + secondaryAmount;\n155:         uint256 totalPoolBalance = primaryPoolBalance + secondaryPoolBalance;\n156: \n157:         uint256 primaryPercentage = primaryAmount * CurveConstants.CURVE_PRECISION / totalAmount;        \n158:         uint256 expectedPrimaryPercentage = primaryPoolBalance * CurveConstants.CURVE_PRECISION / totalPoolBalance;\n159: \n160:         strategyContext._checkPriceLimit(expectedPrimaryPercentage, primaryPercentage);\n161: \n162:         uint256 secondaryPercentage = secondaryAmount * CurveConstants.CURVE_PRECISION / totalAmount;\n163:         uint256 expectedSecondaryPercentage = secondaryPoolBalance * CurveConstants.CURVE_PRECISION / totalPoolBalance;\n164: \n165:         strategyContext._checkPriceLimit(expectedSecondaryPercentage, secondaryPercentage);\n166:     }\n```\n\nThis concept of proportional join appears to be taken from the design of earlier Notional's Balancer leverage vaults. For Balancer Pools, it is recommended to join with all the pool's tokens in exact proportions to minimize the price impact of the join ([Reference](https://docs.balancer.fi/guides/builders/join-pool.html#building-a-join-transaction)).\n\nHowever, the concept of proportional join to minimize slippage does not always hold for Curve Pools as they operate differently. \n\nA Curve pool is considered imbalanced when there is an imbalance between the assets within it.  For instance, the Curve stETH/ETH pool is considered imbalanced if it has the following reserves:\n\n- ETH: 340,472.34 (31.70%)\n- stETH: 733,655.65 (68.30%)\n\nIf a Curve Pool is imbalanced, attempting to perform a proportional join will not give an optimal return (e.g. result in fewer Pool LP tokens received). \n\nIn Curve Pool, there are penalties/bonuses when depositing to a pool. The pools are always trying to balance themselves. If a deposit helps the pool to reach that desired balance, a deposit bonus will be given (receive extra tokens). On the other hand, if a deposit deviates from the pool from the desired balance, a deposit penalty will be applied (receive fewer tokens).\n\nThe following is the source code of `add_liquidity` function taken from https://github.com/curvefi/curve-contract/blob/master/contracts/pools/steth/StableSwapSTETH.vy. As shown below, the function attempts to calculate the `difference` between the `ideal_balance` and `new_balances`, and uses the `difference` as a factor of the fee computation, which is tied to the bonus and penalty.\n\n```python\ndef add_liquidity(amounts: uint256[N_COINS], min_mint_amount: uint256) -> uint256:\n..SNIP..\n    if token_supply > 0:\n        # Only account for fees if we are not the first to deposit\n        fee: uint256 = self.fee * N_COINS / (4 * (N_COINS - 1))\n        admin_fee: uint256 = self.admin_fee\n        for i in range(N_COINS):\n            ideal_balance: uint256 = D1 * old_balances[i] / D0\n            difference: uint256 = 0\n            if ideal_balance > new_balances[i]:\n                difference = ideal_balance - new_balances[i]\n            else:\n                difference = new_balances[i] - ideal_balance\n            fees[i] = fee * difference / FEE_DENOMINATOR\n            if admin_fee != 0:\n                self.admin_balances[i] += fees[i] * admin_fee / FEE_DENOMINATOR\n            new_balances[i] -= fees[i]\n        D2 = self.get_D(new_balances, amp)\n        mint_amount = token_supply * (D2 - D0) / D0\n    else:\n        mint_amount = D1  # Take the dust if there was any\n..SNIP..\n```\n\nFollowing is the mathematical explanation of the penalties/bonuses extracted from Curve's Discord channel:\n\n- There is a “natural” amount of D increase that corresponds to a given total deposit amount; when the pool is perfectly balanced, this D increase is optimally achieved by a balanced deposit. Any other deposit proportions for the same total amount will give you less D.\n- However, when the pool is imbalanced, a balanced deposit is no longer optimal for the D increase.\n\n## Impact\n\nThere is no guarantee that a Curve Pool will always be balanced. Historically, there are multiple instances where the largest Curve pool (stETH/ETH) becomes imbalanced (Reference [#1](https://twitter.com/LidoFinance/status/1437124281150935044) and [#2](https://www.coindesk.com/markets/2022/06/17/biggest-steth-pool-almost-empty-complicating-exit-for-would-be-sellers/)).\n\nIf the pool is imbalanced due to unexpected circumstances, performing a proportional deposit is not optimal, leading to the trade resulting in fewer tokens than possible due to the deposit penalty. In addition, the trade also misses out on the potential gain from the deposit bonus.\n\nThe side-effect is that reinvesting the reward tokens will result in fewer pool tokens in return due to sub-optimal trade, eventually leading to a loss of gain for the vault shareholder.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-notional/blob/main/leveraged-vaults/contracts/vaults/curve/external/Curve2TokenConvexHelper.sol#L163\n\nhttps://github.com/sherlock-audit/2023-02-notional/blob/main/leveraged-vaults/contracts/vaults/curve/internal/pool/Curve2TokenPoolUtils.sol#L147\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider removing the `_checkPrimarySecondaryRatio` function from the `_validateSpotPriceAndPairPrice` function to give the callers the option to deposit the reward tokens in a \"non-proportional\" manner if a Curve Pool becomes imbalanced so that the deposit penalty could be minimized or the deposit bonus can be exploited to increase the return.\n\n## Discussion\n\n**jeffywu**\n\nValid, should get the optimal way to join via some off chain function for Curve pools. This is will work because we are using a permissioned reward reinvestment role.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/52",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/curve/external/Curve2TokenConvexHelper.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {\n    Curve2TokenConvexStrategyContext,\n    Curve2TokenPoolContext\n} from \"../CurveVaultTypes.sol\";\nimport {\n    StrategyContext,\n    StrategyVaultSettings,\n    StrategyVaultState,\n    TwoTokenPoolContext,\n    DepositParams,\n    RedeemParams,\n    ReinvestRewardParams\n} from \"../../common/VaultTypes.sol\";\nimport {TwoTokenPoolUtils} from \"../../common/internal/pool/TwoTokenPoolUtils.sol\";\nimport {SettlementUtils} from \"../../common/internal/settlement/SettlementUtils.sol\";\nimport {StrategyUtils} from \"../../common/internal/strategy/StrategyUtils.sol\";\nimport {VaultStorage} from \"../../common/VaultStorage.sol\";\nimport {VaultEvents} from \"../../common/VaultEvents.sol\";\nimport {Curve2TokenPoolUtils} from \"../internal/pool/Curve2TokenPoolUtils.sol\";\nimport {IERC20} from \"../../../../interfaces/IERC20.sol\";\n\nlibrary Curve2TokenConvexHelper {\n    using Curve2TokenPoolUtils for Curve2TokenPoolContext;\n    using TwoTokenPoolUtils for TwoTokenPoolContext;\n    using StrategyUtils for StrategyContext;\n    using SettlementUtils for StrategyContext;\n    using VaultStorage for StrategyVaultState;\n\n    function deposit(\n        Curve2TokenConvexStrategyContext memory context,\n        uint256 deposit,\n        bytes calldata data\n    ) external returns (uint256 strategyTokensMinted) {\n        DepositParams memory params = abi.decode(data, (DepositParams));\n\n        strategyTokensMinted = context.poolContext._deposit({\n            strategyContext: context.baseStrategy,\n            stakingContext: context.stakingContext,\n            deposit: deposit,\n            params: params\n        });\n    }\n\n    function redeem(\n        Curve2TokenConvexStrategyContext memory context,\n        uint256 strategyTokens,\n        bytes calldata data\n    ) external returns (uint256 finalPrimaryBalance) {\n        RedeemParams memory params = abi.decode(data, (RedeemParams));\n\n        finalPrimaryBalance = context.poolContext._redeem({\n            strategyContext: context.baseStrategy,\n            stakingContext: context.stakingContext,\n            strategyTokens: strategyTokens,\n            params: params\n        });\n    }\n\n    function settleVault(\n        Curve2TokenConvexStrategyContext calldata context,\n        uint256 maturity,\n        uint256 strategyTokensToRedeem,\n        RedeemParams memory params\n    ) external {\n        uint256 poolClaimToSettle = context.baseStrategy._convertStrategyTokensToPoolClaim(strategyTokensToRedeem);\n        \n        _executeSettlement({\n            strategyContext: context.baseStrategy,\n            poolContext: context.poolContext,\n            maturity: maturity,\n            poolClaimToSettle: poolClaimToSettle,\n            redeemStrategyTokenAmount: strategyTokensToRedeem,\n            params: params\n        });\n\n        emit VaultEvents.VaultSettlement(maturity, poolClaimToSettle, strategyTokensToRedeem);\n    }\n\n    function settleVaultEmergency(\n        Curve2TokenConvexStrategyContext calldata context, \n        uint256 maturity, \n        bytes calldata data\n    ) external {\n        RedeemParams memory params = SettlementUtils._decodeParamsAndValidate(\n            context.baseStrategy.vaultSettings.emergencySettlementSlippageLimitPercent,\n            data\n        );\n\n        uint256 poolClaimToSettle = context.baseStrategy._getEmergencySettlementParams({\n            maturity: maturity, \n            totalPoolSupply: context.poolContext.basePool.poolToken.totalSupply()\n        });\n\n        uint256 redeemStrategyTokenAmount = \n            context.baseStrategy._convertPoolClaimToStrategyTokens(poolClaimToSettle);\n\n        _executeSettlement({\n            strategyContext: context.baseStrategy,\n            poolContext: context.poolContext,\n            maturity: maturity,\n            poolClaimToSettle: poolClaimToSettle,\n            redeemStrategyTokenAmount: redeemStrategyTokenAmount,\n            params: params\n        });\n\n        emit VaultEvents.EmergencyVaultSettlement(maturity, poolClaimToSettle, redeemStrategyTokenAmount);    \n    }\n\n    function _executeSettlement(\n        StrategyContext calldata strategyContext,\n        Curve2TokenPoolContext calldata poolContext,\n        uint256 maturity,\n        uint256 poolClaimToSettle,\n        uint256 redeemStrategyTokenAmount,\n        RedeemParams memory params\n    ) private {\n        (uint256 spotPrice, uint256 oraclePrice) = poolContext._getSpotPriceAndOraclePrice(strategyContext);\n\n        /// @notice params.minPrimary and params.minSecondary are not required to be passed in by the caller\n        /// for this strategy vault\n        (params.minPrimary, params.minSecondary) = poolContext.basePool._getMinExitAmounts({\n            strategyContext: strategyContext,\n            oraclePrice: oraclePrice,\n            spotPrice: spotPrice,\n            poolClaim: poolClaimToSettle\n        });\n\n        int256 expectedUnderlyingRedeemed = poolContext._convertStrategyToUnderlying({\n            strategyContext: strategyContext,\n            strategyTokenAmount: redeemStrategyTokenAmount,\n            oraclePrice: oraclePrice,\n            spotPrice: spotPrice\n        });\n\n        strategyContext._executeSettlement({\n            maturity: maturity,\n            expectedUnderlyingRedeemed: expectedUnderlyingRedeemed,\n            redeemStrategyTokenAmount: redeemStrategyTokenAmount,\n            params: params\n        });    \n    }\n\n    function reinvestReward(\n        Curve2TokenConvexStrategyContext calldata context,\n        ReinvestRewardParams calldata params\n    ) external {\n        StrategyContext memory strategyContext = context.baseStrategy;\n        Curve2TokenPoolContext calldata poolContext = context.poolContext; \n\n        (\n            address rewardToken, \n            uint256 primaryAmount, \n            uint256 secondaryAmount\n        ) = poolContext.basePool._executeRewardTrades({\n            rewardTokens: context.stakingContext.rewardTokens,\n            tradingModule: strategyContext.tradingModule,\n            data: params.tradeData\n        });\n\n        // Make sure we are joining with the right proportion to minimize slippage\n        poolContext._validateSpotPriceAndPairPrice({\n            strategyContext: strategyContext,\n            oraclePrice: poolContext.basePool._getOraclePairPrice(strategyContext),\n            primaryAmount: primaryAmount,\n            secondaryAmount: secondaryAmount\n        });\n\n        uint256 poolClaimAmount = poolContext._joinPoolAndStake({\n            strategyContext: strategyContext,\n            stakingContext: context.stakingContext,\n            primaryAmount: primaryAmount,\n            secondaryAmount: secondaryAmount,\n            /// @notice minPoolClaim is not required to be set by the caller because primaryAmount\n            /// and secondaryAmount are already validated\n            minPoolClaim: params.minPoolClaim      \n        });\n\n        strategyContext.vaultState.totalPoolClaim += poolClaimAmount;\n        strategyContext.vaultState.setStrategyVaultState(); \n\n        emit VaultEvents.RewardReinvested(rewardToken, primaryAmount, secondaryAmount, poolClaimAmount);\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/curve/internal/pool/Curve2TokenPoolUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {Deployments} from \"../../../../global/Deployments.sol\";\nimport {\n    StrategyContext, \n    TwoTokenPoolContext,\n    StrategyVaultSettings, \n    StrategyVaultState,\n    DepositParams,\n    RedeemParams,\n    ReinvestRewardParams\n} from \"../../../common/VaultTypes.sol\";\nimport {CurveConstants} from \"../CurveConstants.sol\";\nimport {Curve2TokenPoolContext, ConvexStakingContext} from \"../../CurveVaultTypes.sol\";\nimport {TwoTokenPoolUtils} from \"../../../common/internal/pool/TwoTokenPoolUtils.sol\";\nimport {StrategyUtils} from \"../../../common/internal/strategy/StrategyUtils.sol\";\nimport {VaultStorage} from \"../../../common/VaultStorage.sol\";\nimport {VaultConstants} from \"../../../common/VaultConstants.sol\";\nimport {ICurve2TokenPool} from \"../../../../../interfaces/curve/ICurvePool.sol\";\n\nlibrary Curve2TokenPoolUtils {\n    using StrategyUtils for StrategyContext;\n    using Curve2TokenPoolUtils for Curve2TokenPoolContext;\n    using TwoTokenPoolUtils for TwoTokenPoolContext;\n    using TypeConvert for uint256;\n    using VaultStorage for StrategyVaultSettings;\n    using VaultStorage for StrategyVaultState;\n\n    function _deposit(\n        Curve2TokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        ConvexStakingContext memory stakingContext,\n        uint256 deposit,\n        DepositParams memory params\n    ) internal returns (uint256 strategyTokensMinted) {\n        uint256 secondaryAmount;\n        if (params.tradeData.length != 0) {\n            // Allows users to trade on a different DEX when joining\n            (uint256 primarySold, uint256 secondaryBought) = poolContext.basePool._tradePrimaryForSecondary({\n                strategyContext: strategyContext,\n                data: params.tradeData\n            });\n            deposit -= primarySold;\n            secondaryAmount = secondaryBought;\n        }\n\n        uint256 poolClaimMinted = poolContext._joinPoolAndStake({\n            strategyContext: strategyContext,\n            stakingContext: stakingContext,\n            primaryAmount: deposit,\n            secondaryAmount: secondaryAmount,\n            minPoolClaim: params.minPoolClaim\n        });\n\n        strategyTokensMinted = strategyContext._mintStrategyTokens(poolClaimMinted);\n    }\n\n    function _redeem(\n        Curve2TokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        ConvexStakingContext memory stakingContext,\n        uint256 strategyTokens,\n        RedeemParams memory params\n    ) internal returns (uint256 finalPrimaryBalance) {\n        uint256 poolClaim = strategyContext._redeemStrategyTokens(strategyTokens);\n\n        // Underlying token balances from exiting the pool\n        (uint256 primaryBalance, uint256 secondaryBalance)\n            = _unstakeAndExitPool(poolContext, stakingContext, poolClaim, params);\n\n        finalPrimaryBalance = primaryBalance;\n        if (secondaryBalance > 0) {\n            uint256 primaryPurchased = poolContext.basePool._sellSecondaryBalance(\n                strategyContext, params, secondaryBalance\n            );\n\n            finalPrimaryBalance += primaryPurchased;\n        }\n    }\n\n    function _getSpotPrice(\n        Curve2TokenPoolContext memory poolContext, \n        uint256 tokenIndex\n    ) internal view returns (uint256 spotPrice) {\n        require(tokenIndex < 2);\n        if (tokenIndex == 0) {\n            spotPrice = poolContext.curvePool.get_dy(\n                int8(poolContext.basePool.primaryIndex), \n                int8(poolContext.basePool.secondaryIndex), \n                10**poolContext.basePool.primaryDecimals // 1 unit of primary\n            );\n            uint256 secondaryPrecision = 10**poolContext.basePool.secondaryDecimals;\n            spotPrice = spotPrice * CurveConstants.CURVE_PRECISION / secondaryPrecision;\n        } else {\n            spotPrice = poolContext.curvePool.get_dy(\n                int8(poolContext.basePool.secondaryIndex),\n                int8(poolContext.basePool.primaryIndex), \n                10**poolContext.basePool.secondaryDecimals // 1 unit of secondary\n            );\n            uint256 primaryPrecision = 10**poolContext.basePool.primaryDecimals;\n            spotPrice = spotPrice * CurveConstants.CURVE_PRECISION / primaryPrecision;\n        }\n    }\n\n    function _validateSpotPriceAndPairPrice(\n        Curve2TokenPoolContext calldata poolContext,\n        StrategyContext memory strategyContext,\n        uint256 oraclePrice,\n        uint256 primaryAmount, \n        uint256 secondaryAmount\n    ) internal view {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        uint256 spotPrice = _getSpotPrice({\n            poolContext: poolContext,\n            tokenIndex: 0\n        });\n\n        /// @notice Check spotPrice against oracle price to make sure that \n        /// the pool is not being manipulated\n        strategyContext._checkPriceLimit(oraclePrice, spotPrice);\n\n        uint256 primaryPrecision = 10**poolContext.basePool.primaryDecimals;\n        uint256 secondaryPrecision = 10**poolContext.basePool.secondaryDecimals;\n\n        // Convert input amounts and pool amounts to CURVE_PRECISION (1e18)\n\n        primaryAmount = primaryAmount * strategyContext.poolClaimPrecision / primaryPrecision;\n        secondaryAmount = secondaryAmount * strategyContext.poolClaimPrecision / secondaryPrecision;\n\n        uint256 primaryPoolBalance = poolContext.basePool.primaryBalance * CurveConstants.CURVE_PRECISION \n            / primaryPrecision;\n        uint256 secondaryPoolBalance = poolContext.basePool.secondaryBalance * CurveConstants.CURVE_PRECISION \n            / secondaryPrecision;\n\n        return _checkPrimarySecondaryRatio({\n            strategyContext: strategyContext,\n            primaryAmount: primaryAmount,\n            secondaryAmount: secondaryAmount,\n            primaryPoolBalance: primaryPoolBalance,\n            secondaryPoolBalance: secondaryPoolBalance\n        });\n    }\n    \n    function _checkPrimarySecondaryRatio(\n        StrategyContext memory strategyContext,\n        uint256 primaryAmount, \n        uint256 secondaryAmount, \n        uint256 primaryPoolBalance, \n        uint256 secondaryPoolBalance\n    ) private pure {\n        uint256 totalAmount = primaryAmount + secondaryAmount;\n        uint256 totalPoolBalance = primaryPoolBalance + secondaryPoolBalance;\n\n        uint256 primaryPercentage = primaryAmount * CurveConstants.CURVE_PRECISION / totalAmount;        \n        uint256 expectedPrimaryPercentage = primaryPoolBalance * CurveConstants.CURVE_PRECISION / totalPoolBalance;\n\n        strategyContext._checkPriceLimit(expectedPrimaryPercentage, primaryPercentage);\n\n        uint256 secondaryPercentage = secondaryAmount * CurveConstants.CURVE_PRECISION / totalAmount;\n        uint256 expectedSecondaryPercentage = secondaryPoolBalance * CurveConstants.CURVE_PRECISION / totalPoolBalance;\n\n        strategyContext._checkPriceLimit(expectedSecondaryPercentage, secondaryPercentage);\n    }\n\n    /// @notice We value strategy tokens in terms of the primary balance. The time weighted\n    /// primary balance is used in order to prevent pool manipulation.\n    /// @param poolContext pool context variables\n    /// @param strategyContext strategy context variables\n    /// @param strategyTokenAmount amount of strategy tokens\n    /// @return underlyingValue underlying value of strategy tokens\n    function _convertStrategyToUnderlying(\n        Curve2TokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        uint256 strategyTokenAmount,\n        uint256 oraclePrice,\n        uint256 spotPrice\n    ) internal view returns (int256 underlyingValue) {\n        \n        uint256 poolClaim \n            = strategyContext._convertStrategyTokensToPoolClaim(strategyTokenAmount);\n\n        underlyingValue \n            = poolContext.basePool._getTimeWeightedPrimaryBalance({\n                strategyContext: strategyContext,\n                poolClaim: poolClaim,\n                oraclePrice: oraclePrice, \n                spotPrice: spotPrice\n            }).toInt();\n    }   \n\n    function _joinPoolAndStake(\n        Curve2TokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        ConvexStakingContext memory stakingContext,\n        uint256 primaryAmount,\n        uint256 secondaryAmount,\n        uint256 minPoolClaim\n    ) internal returns (uint256 poolClaimMinted) {\n        uint256[2] memory amounts;\n        uint256 msgValue;\n        amounts[poolContext.basePool.primaryIndex] = primaryAmount;\n        amounts[poolContext.basePool.secondaryIndex] = secondaryAmount;\n\n        if (poolContext.basePool.primaryToken == Deployments.ETH_ADDRESS) {\n            msgValue = primaryAmount;\n        } else if (poolContext.basePool.secondaryToken == Deployments.ETH_ADDRESS) {\n            msgValue = secondaryAmount;\n        }\n\n        poolClaimMinted = ICurve2TokenPool(address(poolContext.curvePool)).add_liquidity{value: msgValue}(\n            amounts, minPoolClaim\n        );\n\n        // Check pool claim threshold to make sure our share of the pool is\n        // below maxPoolShare\n        uint256 poolClaimThreshold = strategyContext.vaultSettings._poolClaimThreshold(\n            poolContext.basePool.poolToken.totalSupply()\n        );\n        uint256 poolClaimHeldAfterJoin = strategyContext.vaultState.totalPoolClaim + poolClaimMinted;\n        if (poolClaimThreshold < poolClaimHeldAfterJoin)\n            revert Errors.PoolShareTooHigh(poolClaimHeldAfterJoin, poolClaimThreshold);\n\n\n        bool success = stakingContext.booster.deposit(stakingContext.poolId, poolClaimMinted, true); // stake = true\n        require(success);    \n    }\n\n    function _unstakeAndExitPool(\n        Curve2TokenPoolContext memory poolContext,\n        ConvexStakingContext memory stakingContext,\n        uint256 poolClaim,\n        RedeemParams memory params\n    ) internal returns (uint256 primaryBalance, uint256 secondaryBalance) {\n        // Withdraw pool tokens back to the vault for redemption\n        bool success = stakingContext.rewardPool.withdrawAndUnwrap(poolClaim, false); // claimRewards = false\n        if (!success) revert Errors.UnstakeFailed();\n\n        if (params.secondaryTradeParams.length == 0) {\n            // Redeem single-sided\n            primaryBalance = ICurve2TokenPool(address(poolContext.curvePool)).remove_liquidity_one_coin(\n                poolClaim, int8(poolContext.basePool.primaryIndex), params.minPrimary\n            );\n        } else {\n            // Redeem proportionally\n            uint256[2] memory minAmounts;\n            minAmounts[poolContext.basePool.primaryIndex] = params.minPrimary;\n            minAmounts[poolContext.basePool.secondaryIndex] = params.minSecondary;\n            uint256[2] memory exitBalances = ICurve2TokenPool(address(poolContext.curvePool)).remove_liquidity(\n                poolClaim, minAmounts\n            );\n\n            (primaryBalance, secondaryBalance) \n                = (exitBalances[poolContext.basePool.primaryIndex], exitBalances[poolContext.basePool.secondaryIndex]);\n        }\n    }\n\n    function _getSpotPriceAndOraclePrice(\n        Curve2TokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext\n    ) internal view returns (uint256 spotPrice, uint256 oraclePrice) {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        // Validate the spot price to make sure the pool is not being manipulated\n        spotPrice = poolContext._getSpotPrice(0); // tokenIndex\n        oraclePrice = poolContext.basePool._getOraclePairPrice(strategyContext);\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/curve/external/Curve2TokenConvexHelper.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {\n    Curve2TokenConvexStrategyContext,\n    Curve2TokenPoolContext\n} from \"../CurveVaultTypes.sol\";\nimport {\n    StrategyContext,\n    StrategyVaultSettings,\n    StrategyVaultState,\n    TwoTokenPoolContext,\n    DepositParams,\n    RedeemParams,\n    ReinvestRewardParams\n} from \"../../common/VaultTypes.sol\";\nimport {TwoTokenPoolUtils} from \"../../common/internal/pool/TwoTokenPoolUtils.sol\";\nimport {SettlementUtils} from \"../../common/internal/settlement/SettlementUtils.sol\";\nimport {StrategyUtils} from \"../../common/internal/strategy/StrategyUtils.sol\";\nimport {VaultStorage} from \"../../common/VaultStorage.sol\";\nimport {VaultEvents} from \"../../common/VaultEvents.sol\";\nimport {Curve2TokenPoolUtils} from \"../internal/pool/Curve2TokenPoolUtils.sol\";\nimport {IERC20} from \"../../../../interfaces/IERC20.sol\";\n\nlibrary Curve2TokenConvexHelper {\n    using Curve2TokenPoolUtils for Curve2TokenPoolContext;\n    using TwoTokenPoolUtils for TwoTokenPoolContext;\n    using StrategyUtils for StrategyContext;\n    using SettlementUtils for StrategyContext;\n    using VaultStorage for StrategyVaultState;\n\n    function deposit(\n        Curve2TokenConvexStrategyContext memory context,\n        uint256 deposit,\n        bytes calldata data\n    ) external returns (uint256 strategyTokensMinted) {\n        DepositParams memory params = abi.decode(data, (DepositParams));\n\n        strategyTokensMinted = context.poolContext._deposit({\n            strategyContext: context.baseStrategy,\n            stakingContext: context.stakingContext,\n            deposit: deposit,\n            params: params\n        });\n    }\n\n    function redeem(\n        Curve2TokenConvexStrategyContext memory context,\n        uint256 strategyTokens,\n        bytes calldata data\n    ) external returns (uint256 finalPrimaryBalance) {\n        RedeemParams memory params = abi.decode(data, (RedeemParams));\n\n        finalPrimaryBalance = context.poolContext._redeem({\n            strategyContext: context.baseStrategy,\n            stakingContext: context.stakingContext,\n            strategyTokens: strategyTokens,\n            params: params\n        });\n    }\n\n    function settleVault(\n        Curve2TokenConvexStrategyContext calldata context,\n        uint256 maturity,\n        uint256 strategyTokensToRedeem,\n        RedeemParams memory params\n    ) external {\n        uint256 poolClaimToSettle = context.baseStrategy._convertStrategyTokensToPoolClaim(strategyTokensToRedeem);\n        \n        _executeSettlement({\n            strategyContext: context.baseStrategy,\n            poolContext: context.poolContext,\n            maturity: maturity,\n            poolClaimToSettle: poolClaimToSettle,\n            redeemStrategyTokenAmount: strategyTokensToRedeem,\n            params: params\n        });\n\n        emit VaultEvents.VaultSettlement(maturity, poolClaimToSettle, strategyTokensToRedeem);\n    }\n\n    function settleVaultEmergency(\n        Curve2TokenConvexStrategyContext calldata context, \n        uint256 maturity, \n        bytes calldata data\n    ) external {\n        RedeemParams memory params = SettlementUtils._decodeParamsAndValidate(\n            context.baseStrategy.vaultSettings.emergencySettlementSlippageLimitPercent,\n            data\n        );\n\n        uint256 poolClaimToSettle = context.baseStrategy._getEmergencySettlementParams({\n            maturity: maturity, \n            totalPoolSupply: context.poolContext.basePool.poolToken.totalSupply()\n        });\n\n        uint256 redeemStrategyTokenAmount = \n            context.baseStrategy._convertPoolClaimToStrategyTokens(poolClaimToSettle);\n\n        _executeSettlement({\n            strategyContext: context.baseStrategy,\n            poolContext: context.poolContext,\n            maturity: maturity,\n            poolClaimToSettle: poolClaimToSettle,\n            redeemStrategyTokenAmount: redeemStrategyTokenAmount,\n            params: params\n        });\n\n        emit VaultEvents.EmergencyVaultSettlement(maturity, poolClaimToSettle, redeemStrategyTokenAmount);    \n    }\n\n    function _executeSettlement(\n        StrategyContext calldata strategyContext,\n        Curve2TokenPoolContext calldata poolContext,\n        uint256 maturity,\n        uint256 poolClaimToSettle,\n        uint256 redeemStrategyTokenAmount,\n        RedeemParams memory params\n    ) private {\n        (uint256 spotPrice, uint256 oraclePrice) = poolContext._getSpotPriceAndOraclePrice(strategyContext);\n\n        /// @notice params.minPrimary and params.minSecondary are not required to be passed in by the caller\n        /// for this strategy vault\n        (params.minPrimary, params.minSecondary) = poolContext.basePool._getMinExitAmounts({\n            strategyContext: strategyContext,\n            oraclePrice: oraclePrice,\n            spotPrice: spotPrice,\n            poolClaim: poolClaimToSettle\n        });\n\n        int256 expectedUnderlyingRedeemed = poolContext._convertStrategyToUnderlying({\n            strategyContext: strategyContext,\n            strategyTokenAmount: redeemStrategyTokenAmount,\n            oraclePrice: oraclePrice,\n            spotPrice: spotPrice\n        });\n\n        strategyContext._executeSettlement({\n            maturity: maturity,\n            expectedUnderlyingRedeemed: expectedUnderlyingRedeemed,\n            redeemStrategyTokenAmount: redeemStrategyTokenAmount,\n            params: params\n        });    \n    }\n\n    function reinvestReward(\n        Curve2TokenConvexStrategyContext calldata context,\n        ReinvestRewardParams calldata params\n    ) external {\n        StrategyContext memory strategyContext = context.baseStrategy;\n        Curve2TokenPoolContext calldata poolContext = context.poolContext; \n\n        (\n            address rewardToken, \n            uint256 primaryAmount, \n            uint256 secondaryAmount\n        ) = poolContext.basePool._executeRewardTrades({\n            rewardTokens: context.stakingContext.rewardTokens,\n            tradingModule: strategyContext.tradingModule,\n            data: params.tradeData\n        });\n\n        // Make sure we are joining with the right proportion to minimize slippage\n        poolContext._validateSpotPriceAndPairPrice({\n            strategyContext: strategyContext,\n            oraclePrice: poolContext.basePool._getOraclePairPrice(strategyContext),\n            primaryAmount: primaryAmount,\n            secondaryAmount: secondaryAmount\n        });\n\n        uint256 poolClaimAmount = poolContext._joinPoolAndStake({\n            strategyContext: strategyContext,\n            stakingContext: context.stakingContext,\n            primaryAmount: primaryAmount,\n            secondaryAmount: secondaryAmount,\n            /// @notice minPoolClaim is not required to be set by the caller because primaryAmount\n            /// and secondaryAmount are already validated\n            minPoolClaim: params.minPoolClaim      \n        });\n\n        strategyContext.vaultState.totalPoolClaim += poolClaimAmount;\n        strategyContext.vaultState.setStrategyVaultState(); \n\n        emit VaultEvents.RewardReinvested(rewardToken, primaryAmount, secondaryAmount, poolClaimAmount);\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/curve/internal/pool/Curve2TokenPoolUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {Deployments} from \"../../../../global/Deployments.sol\";\nimport {\n    StrategyContext, \n    TwoTokenPoolContext,\n    StrategyVaultSettings, \n    StrategyVaultState,\n    DepositParams,\n    RedeemParams,\n    ReinvestRewardParams\n} from \"../../../common/VaultTypes.sol\";\nimport {CurveConstants} from \"../CurveConstants.sol\";\nimport {Curve2TokenPoolContext, ConvexStakingContext} from \"../../CurveVaultTypes.sol\";\nimport {TwoTokenPoolUtils} from \"../../../common/internal/pool/TwoTokenPoolUtils.sol\";\nimport {StrategyUtils} from \"../../../common/internal/strategy/StrategyUtils.sol\";\nimport {VaultStorage} from \"../../../common/VaultStorage.sol\";\nimport {VaultConstants} from \"../../../common/VaultConstants.sol\";\nimport {ICurve2TokenPool} from \"../../../../../interfaces/curve/ICurvePool.sol\";\n\nlibrary Curve2TokenPoolUtils {\n    using StrategyUtils for StrategyContext;\n    using Curve2TokenPoolUtils for Curve2TokenPoolContext;\n    using TwoTokenPoolUtils for TwoTokenPoolContext;\n    using TypeConvert for uint256;\n    using VaultStorage for StrategyVaultSettings;\n    using VaultStorage for StrategyVaultState;\n\n    function _deposit(\n        Curve2TokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        ConvexStakingContext memory stakingContext,\n        uint256 deposit,\n        DepositParams memory params\n    ) internal returns (uint256 strategyTokensMinted) {\n        uint256 secondaryAmount;\n        if (params.tradeData.length != 0) {\n            // Allows users to trade on a different DEX when joining\n            (uint256 primarySold, uint256 secondaryBought) = poolContext.basePool._tradePrimaryForSecondary({\n                strategyContext: strategyContext,\n                data: params.tradeData\n            });\n            deposit -= primarySold;\n            secondaryAmount = secondaryBought;\n        }\n\n        uint256 poolClaimMinted = poolContext._joinPoolAndStake({\n            strategyContext: strategyContext,\n            stakingContext: stakingContext,\n            primaryAmount: deposit,\n            secondaryAmount: secondaryAmount,\n            minPoolClaim: params.minPoolClaim\n        });\n\n        strategyTokensMinted = strategyContext._mintStrategyTokens(poolClaimMinted);\n    }\n\n    function _redeem(\n        Curve2TokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        ConvexStakingContext memory stakingContext,\n        uint256 strategyTokens,\n        RedeemParams memory params\n    ) internal returns (uint256 finalPrimaryBalance) {\n        uint256 poolClaim = strategyContext._redeemStrategyTokens(strategyTokens);\n\n        // Underlying token balances from exiting the pool\n        (uint256 primaryBalance, uint256 secondaryBalance)\n            = _unstakeAndExitPool(poolContext, stakingContext, poolClaim, params);\n\n        finalPrimaryBalance = primaryBalance;\n        if (secondaryBalance > 0) {\n            uint256 primaryPurchased = poolContext.basePool._sellSecondaryBalance(\n                strategyContext, params, secondaryBalance\n            );\n\n            finalPrimaryBalance += primaryPurchased;\n        }\n    }\n\n    function _getSpotPrice(\n        Curve2TokenPoolContext memory poolContext, \n        uint256 tokenIndex\n    ) internal view returns (uint256 spotPrice) {\n        require(tokenIndex < 2);\n        if (tokenIndex == 0) {\n            spotPrice = poolContext.curvePool.get_dy(\n                int8(poolContext.basePool.primaryIndex), \n                int8(poolContext.basePool.secondaryIndex), \n                10**poolContext.basePool.primaryDecimals // 1 unit of primary\n            );\n            uint256 secondaryPrecision = 10**poolContext.basePool.secondaryDecimals;\n            spotPrice = spotPrice * CurveConstants.CURVE_PRECISION / secondaryPrecision;\n        } else {\n            spotPrice = poolContext.curvePool.get_dy(\n                int8(poolContext.basePool.secondaryIndex),\n                int8(poolContext.basePool.primaryIndex), \n                10**poolContext.basePool.secondaryDecimals // 1 unit of secondary\n            );\n            uint256 primaryPrecision = 10**poolContext.basePool.primaryDecimals;\n            spotPrice = spotPrice * CurveConstants.CURVE_PRECISION / primaryPrecision;\n        }\n    }\n\n    function _validateSpotPriceAndPairPrice(\n        Curve2TokenPoolContext calldata poolContext,\n        StrategyContext memory strategyContext,\n        uint256 oraclePrice,\n        uint256 primaryAmount, \n        uint256 secondaryAmount\n    ) internal view {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        uint256 spotPrice = _getSpotPrice({\n            poolContext: poolContext,\n            tokenIndex: 0\n        });\n\n        /// @notice Check spotPrice against oracle price to make sure that \n        /// the pool is not being manipulated\n        strategyContext._checkPriceLimit(oraclePrice, spotPrice);\n\n        uint256 primaryPrecision = 10**poolContext.basePool.primaryDecimals;\n        uint256 secondaryPrecision = 10**poolContext.basePool.secondaryDecimals;\n\n        // Convert input amounts and pool amounts to CURVE_PRECISION (1e18)\n\n        primaryAmount = primaryAmount * strategyContext.poolClaimPrecision / primaryPrecision;\n        secondaryAmount = secondaryAmount * strategyContext.poolClaimPrecision / secondaryPrecision;\n\n        uint256 primaryPoolBalance = poolContext.basePool.primaryBalance * CurveConstants.CURVE_PRECISION \n            / primaryPrecision;\n        uint256 secondaryPoolBalance = poolContext.basePool.secondaryBalance * CurveConstants.CURVE_PRECISION \n            / secondaryPrecision;\n\n        return _checkPrimarySecondaryRatio({\n            strategyContext: strategyContext,\n            primaryAmount: primaryAmount,\n            secondaryAmount: secondaryAmount,\n            primaryPoolBalance: primaryPoolBalance,\n            secondaryPoolBalance: secondaryPoolBalance\n        });\n    }\n    \n    function _checkPrimarySecondaryRatio(\n        StrategyContext memory strategyContext,\n        uint256 primaryAmount, \n        uint256 secondaryA"
    }
  ]
}