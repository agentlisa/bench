{
  "Title": "Not informative names of functions and variables",
  "Content": "##### Description\nFor the function names `forceD ()` and `forceW ()`, it is not clear what these functions are used for.\nIt is at the following lines:\n- https://github.com/orbxball/stablecoins-ypool/blob/5d80af7aeeff9f9b8f6d47d0334d36db3e97e5e4/contracts/StrategyDAIypool.sol#L250 and https://github.com/orbxball/stablecoins-ypool/blob/5d80af7aeeff9f9b8f6d47d0334d36db3e97e5e4/contracts/StrategyDAIypool.sol#L263\n- https://github.com/orbxball/stablecoins-ypool/blob/5d80af7aeeff9f9b8f6d47d0334d36db3e97e5e4/contracts/StrategyTUSDypool.sol#L250 and https://github.com/orbxball/stablecoins-ypool/blob/5d80af7aeeff9f9b8f6d47d0334d36db3e97e5e4/contracts/StrategyTUSDypool.sol#L263 \n- https://github.com/orbxball/stablecoins-ypool/blob/5d80af7aeeff9f9b8f6d47d0334d36db3e97e5e4/contracts/StrategyUSDCypool.sol#L250 and https://github.com/orbxball/stablecoins-ypool/blob/5d80af7aeeff9f9b8f6d47d0334d36db3e97e5e4/contracts/StrategyUSDCypool.sol#L263 \n- https://github.com/orbxball/stablecoins-ypool/blob/5d80af7aeeff9f9b8f6d47d0334d36db3e97e5e4/contracts/StrategyUSDTypool.sol#L250 and https://github.com/orbxball/stablecoins-ypool/blob/5d80af7aeeff9f9b8f6d47d0334d36db3e97e5e4/contracts/StrategyUSDTypool.sol#L263 \n\nFor the names of the variables `p` and` _p`, it is impossible to understand what these variables are used for.\nIt is on the following lines:\n- https://github.com/orbxball/stablecoins-ypool/blob/5d80af7aeeff9f9b8f6d47d0334d36db3e97e5e4/contracts/StrategyDAIypool.sol#L40 and https://github.com/orbxball/stablecoins-ypool/blob/5d80af7aeeff9f9b8f6d47d0334d36db3e97e5e4/contracts/StrategyDAIypool.sol#L98-L105\n- https://github.com/orbxball/stablecoins-ypool/blob/5d80af7aeeff9f9b8f6d47d0334d36db3e97e5e4/contracts/StrategyTUSDypool.sol#L40 and https://github.com/orbxball/stablecoins-ypool/blob/5d80af7aeeff9f9b8f6d47d0334d36db3e97e5e4/contracts/StrategyTUSDypool.sol#L98-L105 \n- https://github.com/orbxball/stablecoins-ypool/blob/5d80af7aeeff9f9b8f6d47d0334d36db3e97e5e4/contracts/StrategyUSDCypool.sol#L40 and https://github.com/orbxball/stablecoins-ypool/blob/5d80af7aeeff9f9b8f6d47d0334d36db3e97e5e4/contracts/StrategyUSDCypool.sol#L98-L105 \n- https://github.com/orbxball/stablecoins-ypool/blob/5d80af7aeeff9f9b8f6d47d0334d36db3e97e5e4/contracts/StrategyUSDTypool.sol#L40 and https://github.com/orbxball/stablecoins-ypool/blob/5d80af7aeeff9f9b8f6d47d0334d36db3e97e5e4/contracts/StrategyUSDTypool.sol#L98-L105 \n\nCorrect names of functions and variables make programs easier to use.\n\n##### Recommendation\nIt is recommended to give correct names to functions and variables.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/StrategyDAIypool.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {\n    BaseStrategy,\n    StrategyParams\n} from \"@yearnvaults/contracts/BaseStrategy.sol\";\nimport \"@openzeppelinV3/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelinV3/contracts/math/SafeMath.sol\";\nimport \"@openzeppelinV3/contracts/utils/Address.sol\";\nimport \"@openzeppelinV3/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../interfaces/yearn/Vault.sol\";\nimport \"../interfaces/curve/ICurve.sol\";\n\n\ncontract StrategyDAIypool is BaseStrategy {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address constant public ypool = address(0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51);\n    address constant public ycrv = address(0xdF5e0e81Dff6FAF3A7e52BA697820c5e32D806A8);\n    address constant public yycrv = address(0x5dbcF33D8c2E976c6b560249878e6F1491Bca25c);\n\n    address constant public dai = address(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n    address constant public ydai = address(0x16de59092dAE5CcF4A1E6439D611fd0653f0Bd01);\n    address constant public usdc = address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n    address constant public yusdc = address(0xd6aD7a6750A7593E092a9B218d66C0A814a3436e);\n    address constant public usdt = address(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n    address constant public yusdt = address(0x83f798e925BcD4017Eb265844FDDAbb448f1707D);\n    address constant public tusd = address(0x0000000000085d4780B73119b644AE5ecd22b376);\n    address constant public ytusd = address(0x73a052500105205d34Daf004eAb301916DA8190f);\n\n    uint256 constant public DENOMINATOR = 10000;\n    uint256 public threshold;\n    uint256 public slip;\n    uint256 public tank;\n    uint256 public p;\n\n    constructor(address _vault) public BaseStrategy(_vault) {\n        // minReportDelay = 6300;\n        // profitFactor = 100;\n        // debtThreshold = 0;\n        threshold = 8000;\n        slip = 100;\n        want.safeApprove(ydai, uint256(-1));\n        IERC20(ydai).safeApprove(ypool, uint256(-1));\n        IERC20(yusdc).safeApprove(ypool, uint256(-1));\n        IERC20(yusdt).safeApprove(ypool, uint256(-1));\n        IERC20(ytusd).safeApprove(ypool, uint256(-1));\n        IERC20(ycrv).safeApprove(yycrv, uint256(-1));\n        IERC20(ycrv).safeApprove(ypool, uint256(-1));\n    }\n\n    function setThreshold(uint256 _threshold) external onlyAuthorized {\n        threshold = _threshold;\n    }\n\n    function setSlip(uint256 _slip) external onlyAuthorized {\n        slip = _slip;\n    }\n\n    function name() external override pure returns (string memory) {\n        return \"StrategyCurveypoolDAI\";\n    }\n\n    function estimatedTotalAssets() public override view returns (uint256) {\n        return balanceOfWant().add(balanceOfYYCRVinWant());\n    }\n\n    function balanceOfWant() public view returns (uint256) {\n        return want.balanceOf(address(this));\n    }\n\n    function balanceOfYYCRV() public view returns (uint256) {\n        return IERC20(yycrv).balanceOf(address(this));\n    }\n\n    function balanceOfYYCRVinWant() public view returns (uint256) {\n        return balanceOfYYCRV()\n                .mul(Vault(yycrv).getPricePerFullShare()).div(1e18)\n                .mul(ICurve(ypool).get_virtual_price()).div(1e18);\n    }\n\n    function prepareReturn(uint256 _debtOutstanding)\n        internal\n        override\n        returns (\n            uint256 _profit,\n            uint256 _loss,\n            uint256 _debtPayment\n        )\n    {\n        _profit = want.balanceOf(address(this));\n        uint256 _p = Vault(yycrv).getPricePerFullShare();\n        _p = _p.mul(ICurve(ypool).get_virtual_price()).div(1e18);\n        if (_p >= p) {\n            _profit = _profit.add((_p.sub(p)).mul(balanceOfYYCRV()).div(1e18));\n        }\n        else {\n            _loss = (p.sub(_p)).mul(balanceOfYYCRV()).div(1e18);\n        }\n        p = _p;\n\n        if (_debtOutstanding > 0) {\n            _debtPayment = liquidatePosition(_debtOutstanding);\n        }\n    }\n\n    function adjustPosition(uint256 _debtOutstanding) internal override {\n        rebalance();\n        _deposit();\n    }\n\n    function _deposit() internal {\n        uint256 _want = (want.balanceOf(address(this))).sub(tank);\n        if (_want > 0) {\n            Vault(ydai).deposit(_want);\n        }\n        uint256 _y = IERC20(ydai).balanceOf(address(this));\n        if (_y > 0) {\n            uint256 v = _want.mul(1e18).div(ICurve(ypool).get_virtual_price());\n            ICurve(ypool).add_liquidity([_y, 0, 0, 0], v.mul(DENOMINATOR.sub(slip)).div(DENOMINATOR));\n        }\n        uint256 _bal = IERC20(ycrv).balanceOf(address(this));\n        if (_bal > 0) {\n            Vault(yycrv).deposit(_bal);\n        }\n    }\n\n    function exitPosition(uint256 _debtOutstanding)\n        internal\n        override\n        returns (uint256 _profit, uint256 _loss, uint256 _debtPayment)\n    {\n        (_profit, _loss, _debtPayment) = prepareReturn(_debtOutstanding);\n        _withdrawAll();\n        _debtPayment = want.balanceOf(address(this));\n    }\n\n    function _withdrawAll() internal {\n        uint256 _yycrv = IERC20(yycrv).balanceOf(address(this));\n        if (_yycrv > 0) {\n            Vault(yycrv).withdraw(_yycrv);\n            _withdrawOne(IERC20(ycrv).balanceOf(address(this)));\n        }\n    }\n\n    function _withdrawOne(uint256 _amnt) internal returns (uint256) {        \n        uint256 _aux = _amnt.mul(DENOMINATOR.sub(slip)).div(DENOMINATOR);\n        uint256 _t = IERC20(ycrv).totalSupply();\n        ICurve(ypool).remove_liquidity(_amnt, [\n            ICurve(ypool).balances(0).mul(_aux).div(_t), \n            ICurve(ypool).balances(1).mul(_aux).div(_t), \n            ICurve(ypool).balances(2).mul(_aux).div(_t), \n            ICurve(ypool).balances(3).mul(_aux).div(_t)]);\n\n        uint256 _yusdc = IERC20(yusdc).balanceOf(address(this));\n        uint256 _yusdt = IERC20(yusdt).balanceOf(address(this));\n        uint256 _ytusd = IERC20(ytusd).balanceOf(address(this));\n    \n        uint256 tmp;\n        if (_yusdc > 0) {\n            tmp = ICurve(ypool).get_dy(1, 0, _yusdc);\n            ICurve(ypool).exchange(1, 0, _yusdc, tmp.mul(DENOMINATOR.sub(slip)).div(DENOMINATOR));\n        }\n        if (_yusdt > 0) {\n            tmp = ICurve(ypool).get_dy(2, 0, _yusdt);\n            ICurve(ypool).exchange(2, 0, _yusdt, tmp.mul(DENOMINATOR.sub(slip)).div(DENOMINATOR));\n        }\n        if (_ytusd > 0) {\n            tmp = ICurve(ypool).get_dy(3, 0, _ytusd);\n            ICurve(ypool).exchange(3, 0, _ytusd, tmp.mul(DENOMINATOR.sub(slip)).div(DENOMINATOR));\n        }\n\n        uint256 _before = want.balanceOf(address(this));\n        Vault(ydai).withdraw(IERC20(ydai).balanceOf(address(this)));\n        uint256 _after = want.balanceOf(address(this));\n        \n        return _after.sub(_before);\n    }\n\n    function liquidatePosition(uint256 _amountNeeded)\n        internal\n        override\n        returns (uint256 _amountFreed)\n    {\n        uint256 _balance = want.balanceOf(address(this));\n        if (_balance < _amountNeeded) {\n            _amountFreed = _withdrawSome(_amountNeeded.sub(_balance));\n            _amountFreed = _amountFreed.add(_balance);\n            tank = 0;\n        }\n        else {\n            _amountFreed = _amountNeeded;\n            if (tank >= _amountNeeded) tank = tank.sub(_amountNeeded);\n            else tank = 0;\n        }\n    }\n\n    function _withdrawSome(uint256 _amount) internal returns (uint256) {\n        uint256 _amnt = _amount.mul(1e18).div(ICurve(ypool).get_virtual_price());\n        uint256 _amt = _amnt.mul(1e18).div(Vault(yycrv).getPricePerFullShare());\n        uint256 _before = IERC20(ycrv).balanceOf(address(this));\n        Vault(yycrv).withdraw(_amt);\n        uint256 _after = IERC20(ycrv).balanceOf(address(this));\n        return _withdrawOne(_after.sub(_before));\n    }\n\n    // NOTE: Can override `tendTrigger` and `harvestTrigger` if necessary\n    function tendTrigger(uint256 callCost) public override view returns (bool) {\n        (uint256 _t, uint256 _c) = tick();\n        return (_c > _t);\n    }\n\n    function prepareMigration(address _newStrategy) internal override {\n        IERC20(yycrv).safeTransfer(_newStrategy, IERC20(yycrv).balanceOf(address(this)));\n        IERC20(ycrv).safeTransfer(_newStrategy, IERC20(ycrv).balanceOf(address(this)));\n    }\n\n    function protectedTokens()\n        internal\n        override\n        view\n        returns (address[] memory)\n    {\n        address[] memory protected = new address[](2);\n        protected[0] = ycrv;\n        protected[1] = yycrv;\n        return protected;\n    }\n\n    function tick() public view returns (uint256 _t, uint256 _c) {\n        _t = ICurve(ypool).balances(0)\n                .mul(Vault(ydai).getPricePerFullShare()).div(1e18)\n                .mul(threshold).div(DENOMINATOR);\n        _c = balanceOfYYCRVinWant();\n    }\n\n    function rebalance() public {\n        (uint256 _t, uint256 _c) = tick();\n        if (_c > _t) {\n            _withdrawSome(_c.sub(_t));\n            tank = want.balanceOf(address(this));\n        }\n    }\n\n    function forceD(uint256 _amount) external onlyAuthorized {\n        Vault(ydai).deposit(_amount);\n        uint256 _y = IERC20(ydai).balanceOf(address(this));\n        uint256 v = _amount.mul(1e18).div(ICurve(ypool).get_virtual_price());\n        ICurve(ypool).add_liquidity([_y, 0, 0, 0], v.mul(DENOMINATOR.sub(slip)).div(DENOMINATOR));\n\n        uint256 _bal = IERC20(ycrv).balanceOf(address(this));\n        Vault(yycrv).deposit(_bal);\n\n        if (_amount < tank) tank = tank.sub(_amount);\n        else tank = 0;\n    }\n\n    function forceW(uint256 _amt) external onlyAuthorized {\n        uint256 _before = IERC20(ycrv).balanceOf(address(this));\n        Vault(yycrv).withdraw(_amt);\n        uint256 _after = IERC20(ycrv).balanceOf(address(this));\n        _amt = _after.sub(_before);\n        \n        _before = want.balanceOf(address(this));\n        _withdrawOne(_amt);\n        _after = want.balanceOf(address(this));\n        tank = tank.add(_after.sub(_before));\n    }\n}"
    },
    {
      "filename": "contracts/StrategyTUSDypool.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {\n    BaseStrategy,\n    StrategyParams\n} from \"@yearnvaults/contracts/BaseStrategy.sol\";\nimport \"@openzeppelinV3/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelinV3/contracts/math/SafeMath.sol\";\nimport \"@openzeppelinV3/contracts/utils/Address.sol\";\nimport \"@openzeppelinV3/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../interfaces/yearn/Vault.sol\";\nimport \"../interfaces/curve/ICurve.sol\";\n\n\ncontract StrategyTUSDypool is BaseStrategy {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address constant public ypool = address(0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51);\n    address constant public ycrv = address(0xdF5e0e81Dff6FAF3A7e52BA697820c5e32D806A8);\n    address constant public yycrv = address(0x5dbcF33D8c2E976c6b560249878e6F1491Bca25c);\n\n    address constant public dai = address(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n    address constant public ydai = address(0x16de59092dAE5CcF4A1E6439D611fd0653f0Bd01);\n    address constant public usdc = address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n    address constant public yusdc = address(0xd6aD7a6750A7593E092a9B218d66C0A814a3436e);\n    address constant public usdt = address(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n    address constant public yusdt = address(0x83f798e925BcD4017Eb265844FDDAbb448f1707D);\n    address constant public tusd = address(0x0000000000085d4780B73119b644AE5ecd22b376);\n    address constant public ytusd = address(0x73a052500105205d34Daf004eAb301916DA8190f);\n\n    uint256 constant public DENOMINATOR = 10000;\n    uint256 public threshold;\n    uint256 public slip;\n    uint256 public tank;\n    uint256 public p;\n\n    constructor(address _vault) public BaseStrategy(_vault) {\n        // minReportDelay = 6300;\n        // profitFactor = 100;\n        // debtThreshold = 0;\n        threshold = 8000;\n        slip = 100;\n        want.safeApprove(ytusd, uint256(-1));\n        IERC20(ydai).safeApprove(ypool, uint256(-1));\n        IERC20(yusdc).safeApprove(ypool, uint256(-1));\n        IERC20(yusdt).safeApprove(ypool, uint256(-1));\n        IERC20(ytusd).safeApprove(ypool, uint256(-1));\n        IERC20(ycrv).safeApprove(yycrv, uint256(-1));\n        IERC20(ycrv).safeApprove(ypool, uint256(-1));\n    }\n\n    function setThreshold(uint256 _threshold) external onlyAuthorized {\n        threshold = _threshold;\n    }\n\n    function setSlip(uint256 _slip) external onlyAuthorized {\n        slip = _slip;\n    }\n\n    function name() external override pure returns (string memory) {\n        return \"StrategyCurveypoolTUSD\";\n    }\n\n    function estimatedTotalAssets() public override view returns (uint256) {\n        return balanceOfWant().add(balanceOfYYCRVinWant());\n    }\n\n    function balanceOfWant() public view returns (uint256) {\n        return want.balanceOf(address(this));\n    }\n\n    function balanceOfYYCRV() public view returns (uint256) {\n        return IERC20(yycrv).balanceOf(address(this));\n    }\n\n    function balanceOfYYCRVinWant() public view returns (uint256) {\n        return balanceOfYYCRV()\n                .mul(Vault(yycrv).getPricePerFullShare()).div(1e18)\n                .mul(ICurve(ypool).get_virtual_price()).div(1e18);\n    }\n\n    function prepareReturn(uint256 _debtOutstanding)\n        internal\n        override\n        returns (\n            uint256 _profit,\n            uint256 _loss,\n            uint256 _debtPayment\n        )\n    {\n        _profit = want.balanceOf(address(this));\n        uint256 _p = Vault(yycrv).getPricePerFullShare();\n        _p = _p.mul(ICurve(ypool).get_virtual_price()).div(1e18);\n        if (_p >= p) {\n            _profit = _profit.add((_p.sub(p)).mul(balanceOfYYCRV()).div(1e18));\n        }\n        else {\n            _loss = (p.sub(_p)).mul(balanceOfYYCRV()).div(1e18);\n        }\n        p = _p;\n\n        if (_debtOutstanding > 0) {\n            _debtPayment = liquidatePosition(_debtOutstanding);\n        }\n    }\n\n    function adjustPosition(uint256 _debtOutstanding) internal override {\n        rebalance();\n        _deposit();\n    }\n\n    function _deposit() internal {\n        uint256 _want = (want.balanceOf(address(this))).sub(tank);\n        if (_want > 0) {\n            Vault(ytusd).deposit(_want);\n        }\n        uint256 _y = IERC20(ytusd).balanceOf(address(this));\n        if (_y > 0) {\n            uint256 v = _want.mul(1e18).div(ICurve(ypool).get_virtual_price());\n            ICurve(ypool).add_liquidity([0, 0, 0, _y], v.mul(DENOMINATOR.sub(slip)).div(DENOMINATOR));\n        }\n        uint256 _bal = IERC20(ycrv).balanceOf(address(this));\n        if (_bal > 0) {\n            Vault(yycrv).deposit(_bal);\n        }\n    }\n\n    function exitPosition(uint256 _debtOutstanding)\n        internal\n        override\n        returns (uint256 _profit, uint256 _loss, uint256 _debtPayment)\n    {\n        (_profit, _loss, _debtPayment) = prepareReturn(_debtOutstanding);\n        _withdrawAll();\n        _debtPayment = want.balanceOf(address(this));\n    }\n\n    function _withdrawAll() internal {\n        uint256 _yycrv = IERC20(yycrv).balanceOf(address(this));\n        if (_yycrv > 0) {\n            Vault(yycrv).withdraw(_yycrv);\n            _withdrawOne(IERC20(ycrv).balanceOf(address(this)));\n        }\n    }\n\n    function _withdrawOne(uint256 _amnt) internal returns (uint256) {        \n        uint256 _aux = _amnt.mul(DENOMINATOR.sub(slip)).div(DENOMINATOR);\n        uint256 _t = IERC20(ycrv).totalSupply();\n        ICurve(ypool).remove_liquidity(_amnt, [\n            ICurve(ypool).balances(0).mul(_aux).div(_t), \n            ICurve(ypool).balances(1).mul(_aux).div(_t), \n            ICurve(ypool).balances(2).mul(_aux).div(_t), \n            ICurve(ypool).balances(3).mul(_aux).div(_t)]);\n\n        uint256 _ydai = IERC20(ydai).balanceOf(address(this));\n        uint256 _yusdc = IERC20(yusdc).balanceOf(address(this));\n        uint256 _yusdt = IERC20(yusdt).balanceOf(address(this));\n    \n        uint256 tmp;\n        if (_ydai > 0) {\n            tmp = ICurve(ypool).get_dy(0, 3, _ydai);\n            ICurve(ypool).exchange(0, 3, _ydai, tmp.mul(DENOMINATOR.sub(slip)).div(DENOMINATOR));\n        }\n        if (_yusdc > 0) {\n            tmp = ICurve(ypool).get_dy(1, 3, _yusdc);\n            ICurve(ypool).exchange(1, 3, _yusdc, tmp.mul(DENOMINATOR.sub(slip)).div(DENOMINATOR));\n        }\n        if (_yusdt > 0) {\n            tmp = ICurve(ypool).get_dy(2, 3, _yusdt);\n            ICurve(ypool).exchange(2, 3, _yusdt, tmp.mul(DENOMINATOR.sub(slip)).div(DENOMINATOR));\n        }\n\n        uint256 _before = want.balanceOf(address(this));\n        Vault(ytusd).withdraw(IERC20(ytusd).balanceOf(address(this)));\n        uint256 _after = want.balanceOf(address(this));\n        \n        return _after.sub(_before);\n    }\n\n    function liquidatePosition(uint256 _amountNeeded)\n        internal\n        override\n        returns (uint256 _amountFreed)\n    {\n        uint256 _balance = want.balanceOf(address(this));\n        if (_balance < _amountNeeded) {\n            _amountFreed = _withdrawSome(_amountNeeded.sub(_balance));\n            _amountFreed = _amountFreed.add(_balance);\n            tank = 0;\n        }\n        else {\n            _amountFreed = _amountNeeded;\n            if (tank >= _amountNeeded) tank = tank.sub(_amountNeeded);\n            else tank = 0;\n        }\n    }\n\n    function _withdrawSome(uint256 _amount) internal returns (uint256) {\n        uint256 _amnt = _amount.mul(1e18).div(ICurve(ypool).get_virtual_price());\n        uint256 _amt = _amnt.mul(1e18).div(Vault(yycrv).getPricePerFullShare());\n        uint256 _before = IERC20(ycrv).balanceOf(address(this));\n        Vault(yycrv).withdraw(_amt);\n        uint256 _after = IERC20(ycrv).balanceOf(address(this));\n        return _withdrawOne(_after.sub(_before));\n    }\n\n    // NOTE: Can override `tendTrigger` and `harvestTrigger` if necessary\n    function tendTrigger(uint256 callCost) public override view returns (bool) {\n        (uint256 _t, uint256 _c) = tick();\n        return (_c > _t);\n    }\n\n    function prepareMigration(address _newStrategy) internal override {\n        IERC20(yycrv).safeTransfer(_newStrategy, IERC20(yycrv).balanceOf(address(this)));\n        IERC20(ycrv).safeTransfer(_newStrategy, IERC20(ycrv).balanceOf(address(this)));\n    }\n\n    function protectedTokens()\n        internal\n        override\n        view\n        returns (address[] memory)\n    {\n        address[] memory protected = new address[](2);\n        protected[0] = ycrv;\n        protected[1] = yycrv;\n        return protected;\n    }\n\n    function tick() public view returns (uint256 _t, uint256 _c) {\n        _t = ICurve(ypool).balances(3)\n                .mul(Vault(ytusd).getPricePerFullShare()).div(1e18)\n                .mul(threshold).div(DENOMINATOR);\n        _c = balanceOfYYCRVinWant();\n    }\n\n    function rebalance() public {\n        (uint256 _t, uint256 _c) = tick();\n        if (_c > _t) {\n            _withdrawSome(_c.sub(_t));\n            tank = want.balanceOf(address(this));\n        }\n    }\n\n    function forceD(uint256 _amount) external onlyAuthorized {\n        Vault(ytusd).deposit(_amount);\n        uint256 _y = IERC20(ytusd).balanceOf(address(this));\n        uint256 v = _amount.mul(1e18).div(ICurve(ypool).get_virtual_price());\n        ICurve(ypool).add_liquidity([0, 0, 0, _y], v.mul(DENOMINATOR.sub(slip)).div(DENOMINATOR));\n\n        uint256 _bal = IERC20(ycrv).balanceOf(address(this));\n        Vault(yycrv).deposit(_bal);\n\n        if (_amount < tank) tank = tank.sub(_amount);\n        else tank = 0;\n    }\n\n    function forceW(uint256 _amt) external onlyAuthorized {\n        uint256 _before = IERC20(ycrv).balanceOf(address(this));\n        Vault(yycrv).withdraw(_amt);\n        uint256 _after = IERC20(ycrv).balanceOf(address(this));\n        _amt = _after.sub(_before);\n        \n        _before = want.balanceOf(address(this));\n        _withdrawOne(_amt);\n        _after = want.balanceOf(address(this));\n        tank = tank.add(_after.sub(_before));\n    }\n}"
    },
    {
      "filename": "contracts/StrategyUSDCypool.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {\n    BaseStrategy,\n    StrategyParams\n} from \"@yearnvaults/contracts/BaseStrategy.sol\";\nimport \"@openzeppelinV3/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelinV3/contracts/math/SafeMath.sol\";\nimport \"@openzeppelinV3/contracts/utils/Address.sol\";\nimport \"@openzeppelinV3/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../interfaces/yearn/Vault.sol\";\nimport \"../interfaces/curve/ICurve.sol\";\n\n\ncontract StrategyUSDCypool is BaseStrategy {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address constant public ypool = address(0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51);\n    address constant public ycrv = address(0xdF5e0e81Dff6FAF3A7e52BA697820c5e32D806A8);\n    address constant public yycrv = address(0x5dbcF33D8c2E976c6b560249878e6F1491Bca25c);\n\n    address constant public dai = address(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n    address constant public ydai = address(0x16de59092dAE5CcF4A1E6439D611fd0653f0Bd01);\n    address constant public usdc = address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n    address constant public yusdc = address(0xd6aD7a6750A7593E092a9B218d66C0A814a3436e);\n    address constant public usdt = address(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n    address constant public yusdt = address(0x83f798e925BcD4017Eb265844FDDAbb448f1707D);\n    address constant public tusd = address(0x0000000000085d4780B73119b644AE5ecd22b376);\n    address constant public ytusd = address(0x73a052500105205d34Daf004eAb301916DA8190f);\n\n    uint256 constant public DENOMINATOR = 10000;\n    uint256 public threshold;\n    uint256 public slip;\n    uint256 public tank;\n    uint256 public p;\n\n    constructor(address _vault) public BaseStrategy(_vault) {\n        // minReportDelay = 6300;\n        // profitFactor = 100;\n        // debtThreshold = 0;\n        threshold = 8000;\n        slip = 100;\n        want.safeApprove(yusdc, uint256(-1));\n        IERC20(ydai).safeApprove(ypool, uint256(-1));\n        IERC20(yusdc).safeApprove(ypool, uint256(-1));\n        IERC20(yusdt).safeApprove(ypool, uint256(-1));\n        IERC20(ytusd).safeApprove(ypool, uint256(-1));\n        IERC20(ycrv).safeApprove(yycrv, uint256(-1));\n        IERC20(ycrv).safeApprove(ypool, uint256(-1));\n    }\n\n    function setThreshold(uint256 _threshold) external onlyAuthorized {\n        threshold = _threshold;\n    }\n\n    function setSlip(uint256 _slip) external onlyAuthorized {\n        slip = _slip;\n    }\n\n    function name() external override pure returns (string memory) {\n        return \"StrategyCurveypoolUSDC\";\n    }\n\n    function estimatedTotalAssets() public override view returns (uint256) {\n        return balanceOfWant().add(balanceOfYYCRVinWant());\n    }\n\n    function balanceOfWant() public view returns (uint256) {\n        return want.balanceOf(address(this));\n    }\n\n    function balanceOfYYCRV() public view returns (uint256) {\n        return IERC20(yycrv).balanceOf(address(this));\n    }\n\n    function balanceOfYYCRVinWant() public view returns (uint256) {\n        return balanceOfYYCRV()\n                .mul(Vault(yycrv).getPricePerFullShare()).div(1e18)\n                .mul(ICurve(ypool).get_virtual_price()).div(1e30);\n    }\n\n    function prepareReturn(uint256 _debtOutstanding)\n        internal\n        override\n        returns (\n            uint256 _profit,\n            uint256 _loss,\n            uint256 _debtPayment\n        )\n    {\n        _profit = want.balanceOf(address(this));\n        uint256 _p = Vault(yycrv).getPricePerFullShare();\n        _p = _p.mul(ICurve(ypool).get_virtual_price()).div(1e18);\n        if (_p >= p) {\n            _profit = _profit.add((_p.sub(p)).mul(balanceOfYYCRV()).div(1e30));\n        }\n        else {\n            _loss = (p.sub(_p)).mul(balanceOfYYCRV()).div(1e30);\n        }\n        p = _p;\n\n        if (_debtOutstanding > 0) {\n            _debtPayment = liquidatePosition(_debtOutstanding);\n        }\n    }\n\n    function adjustPosition(uint256 _debtOutstanding) internal override {\n        rebalance();\n        _deposit();\n    }\n\n    function _deposit() internal {\n        uint256 _want = (want.balanceOf(address(this))).sub(tank);\n        if (_want > 0) {\n            Vault(yusdc).deposit(_want);\n        }\n        uint256 _y = IERC20(yusdc).balanceOf(address(this));\n        if (_y > 0) {\n            uint256 v = _want.mul(1e30).div(ICurve(ypool).get_virtual_price());\n            ICurve(ypool).add_liquidity([0, _y, 0, 0], v.mul(DENOMINATOR.sub(slip)).div(DENOMINATOR));\n        }\n        uint256 _bal = IERC20(ycrv).balanceOf(address(this));\n        if (_bal > 0) {\n            Vault(yycrv).deposit(_bal);\n        }\n    }\n\n    function exitPosition(uint256 _debtOutstanding)\n        internal\n        override\n        returns (uint256 _profit, uint256 _loss, uint256 _debtPayment)\n    {\n        (_profit, _loss, _debtPayment) = prepareReturn(_debtOutstanding);\n        _withdrawAll();\n        _debtPayment = want.balanceOf(address(this));\n    }\n\n    function _withdrawAll() internal {\n        uint256 _yycrv = IERC20(yycrv).balanceOf(address(this));\n        if (_yycrv > 0) {\n            Vault(yycrv).withdraw(_yycrv);\n            _withdrawOne(IERC20(ycrv).balanceOf(address(this)));\n        }\n    }\n\n    function _withdrawOne(uint256 _amnt) internal returns (uint256) {\n        uint256 _aux = _amnt.mul(DENOMINATOR.sub(slip)).div(DENOMINATOR);\n        uint256 _t = IERC20(ycrv).totalSupply();\n        ICurve(ypool).remove_liquidity(_amnt, [\n            ICurve(ypool).balances(0).mul(_aux).div(_t), \n            ICurve(ypool).balances(1).mul(_aux).div(_t), \n            ICurve(ypool).balances(2).mul(_aux).div(_t), \n            ICurve(ypool).balances(3).mul(_aux).div(_t)]);\n\n        uint256 _ydai = IERC20(ydai).balanceOf(address(this));\n        uint256 _yusdt = IERC20(yusdt).balanceOf(address(this));\n        uint256 _ytusd = IERC20(ytusd).balanceOf(address(this));\n\n        uint256 tmp;\n        if (_ydai > 0) {\n            tmp = ICurve(ypool).get_dy(0, 1, _ydai);\n            ICurve(ypool).exchange(0, 1, _ydai, tmp.mul(DENOMINATOR.sub(slip)).div(DENOMINATOR));\n        }\n        if (_yusdt > 0) {\n            tmp = ICurve(ypool).get_dy(2, 1, _yusdt);\n            ICurve(ypool).exchange(2, 1, _yusdt, tmp.mul(DENOMINATOR.sub(slip)).div(DENOMINATOR));\n        }\n        if (_ytusd > 0) {\n            tmp = ICurve(ypool).get_dy(3, 1, _ytusd);\n            ICurve(ypool).exchange(3, 1, _ytusd, tmp.mul(DENOMINATOR.sub(slip)).div(DENOMINATOR));\n        }\n\n        uint256 _before = want.balanceOf(address(this));\n        Vault(yusdc).withdraw(IERC20(yusdc).balanceOf(address(this)));\n        uint256 _after = want.balanceOf(address(this));\n\n        return _after.sub(_before);\n    }\n\n    function liquidatePosition(uint256 _amountNeeded)\n        internal\n        override\n        returns (uint256 _amountFreed)\n    {\n        uint256 _balance = want.balanceOf(address(this));\n        if (_balance < _amountNeeded) {\n            _amountFreed = _withdrawSome(_amountNeeded.sub(_balance));\n            _amountFreed = _amountFreed.add(_balance);\n            tank = 0;\n        }\n        else {\n            _amountFreed = _amountNeeded;\n            if (tank >= _amountNeeded) tank = tank.sub(_amountNeeded);\n            else tank = 0;\n        }\n    }\n\n    function _withdrawSome(uint256 _amount) internal returns (uint256) {\n        uint256 _amnt = _amount.mul(1e30).div(ICurve(ypool).get_virtual_price());\n        uint256 _amt = _amnt.mul(1e18).div(Vault(yycrv).getPricePerFullShare());\n        uint256 _before = IERC20(ycrv).balanceOf(address(this));\n        Vault(yycrv).withdraw(_amt);\n        uint256 _after = IERC20(ycrv).balanceOf(address(this));\n        return _withdrawOne(_after.sub(_before));\n    }\n\n    // NOTE: Can override `tendTrigger` and `harvestTrigger` if necessary\n    function tendTrigger(uint256 callCost) public override view returns (bool) {\n        (uint256 _t, uint256 _c) = tick();\n        return (_c > _t);\n    }\n\n    function prepareMigration(address _newStrategy) internal override {\n        IERC20(yycrv).safeTransfer(_newStrategy, IERC20(yycrv).balanceOf(address(this)));\n        IERC20(ycrv).safeTransfer(_newStrategy, IERC20(ycrv).balanceOf(address(this)));\n    }\n\n    function protectedTokens()\n        internal\n        override\n        view\n        returns (address[] memory)\n    {\n        address[] memory protected = new address[](2);\n        protected[0] = ycrv;\n        protected[1] = yycrv;\n        return protected;\n    }\n\n    function tick() public view returns (uint256 _t, uint256 _c) {\n        _t = ICurve(ypool).balances(1)\n                .mul(Vault(yusdc).getPricePerFullShare()).div(1e18)\n                .mul(threshold).div(DENOMINATOR);\n        _c = balanceOfYYCRVinWant();\n    }\n\n    function rebalance() public {\n        (uint256 _t, uint256 _c) = tick();\n        if (_c > _t) {\n            _withdrawSome(_c.sub(_t));\n            tank = want.balanceOf(address(this));\n        }\n    }\n\n    function forceD(uint256 _amount) external onlyAuthorized {\n        Vault(yusdc).deposit(_amount);\n        uint256 _y = IERC20(yusdc).balanceOf(address(this));\n        uint256 v = _amount.mul(1e30).div(ICurve(ypool).get_virtual_price());\n        ICurve(ypool).add_liquidity([0, _y, 0, 0], v.mul(DENOMINATOR.sub(slip)).div(DENOMINATOR));\n\n        uint256 _bal = IERC20(ycrv).balanceOf(address(this));\n        Vault(yycrv).deposit(_bal);\n\n        if (_amount < tank) tank = tank.sub(_amount);\n        else tank = 0;\n    }\n\n    function forceW(uint256 _amt) external onlyAuthorized {\n        uint256 _before = IERC20(ycrv).balanceOf(address(this));\n        Vault(yycrv).withdraw(_amt);\n        uint256 _after = IERC20(ycrv).balanceOf(address(this));\n        _amt = _after.sub(_before);\n\n        _before = want.balanceOf(address(this));\n        _withdrawOne(_amt);\n        _after = want.balanceOf(address(this));\n        tank = tank.add(_after.sub(_before));\n    }\n}"
    },
    {
      "filename": "contracts/StrategyUSDTypool.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {\n    BaseStrategy,\n    StrategyParams\n} from \"@yearnvaults/contracts/BaseStrategy.sol\";\nimport \"@openzeppelinV3/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelinV3/contracts/math/SafeMath.sol\";\nimport \"@openzeppelinV3/contracts/utils/Address.sol\";\nimport \"@openzeppelinV3/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../interfaces/yearn/Vault.sol\";\nimport \"../interfaces/curve/ICurve.sol\";\n\n\ncontract StrategyUSDTypool is BaseStrategy {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address constant public ypool = address(0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51);\n    address constant public ycrv = address(0xdF5e0e81Dff6FAF3A7e52BA697820c5e32D806A8);\n    address constant public yycrv = address(0x5dbcF33D8c2E976c6b560249878e6F1491Bca25c);\n\n    address constant public dai = address(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n    address constant public ydai = address(0x16de59092dAE5CcF4A1E6439D611fd0653f0Bd01);\n    address constant public usdc = address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n    address constant public yusdc = address(0xd6aD7a6750A7593E092a9B218d66C0A814a3436e);\n    address constant public usdt = address(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n    address constant public yusdt = address(0x83f798e925BcD4017Eb265844FDDAbb448f1707D);\n    address constant public tusd = address(0x0000000000085d4780B73119b644AE5ecd22b376);\n    address constant public ytusd = address(0x73a052500105205d34Daf004eAb301916DA8190f);\n\n    uint256 constant public DENOMINATOR = 10000;\n    uint256 public threshold;\n    uint256 public slip;\n    uint256 public tank;\n    uint256 public p;\n\n    constructor(address _vault) public BaseStrategy(_vault) {\n        // minReportDelay = 6300;\n        // profitFactor = 100;\n        // debtThreshold = 0;\n        threshold = 8000;\n        slip = 100;\n        want.safeApprove(yusdt, uint256(-1));\n        IERC20(ydai).safeApprove(ypool, uint256(-1));\n        IERC20(yusdc).safeApprove(ypool, uint256(-1));\n        IERC20(yusdt).safeApprove(ypool, uint256(-1));\n        IERC20(ytusd).safeApprove(ypool, uint256(-1));\n        IERC20(ycrv).safeApprove(yycrv, uint256(-1));\n        IERC20(ycrv).safeApprove(ypool, uint256(-1));\n    }\n\n    function setThreshold(uint256 _threshold) external onlyAuthorized {\n        threshold = _threshold;\n    }\n\n    function setSlip(uint256 _slip) external onlyAuthori"
    }
  ]
}