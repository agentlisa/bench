{
  "Title": "[G-08] Redundant check",
  "Content": "\nThe following require statement is redundant:\n\n*   [SequentialMintCollection.sol#L63](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/collections/SequentialMintCollection.sol#L63)\n\n```diff\nFile: SequentialMintCollection.sol\n62:   function _initializeSequentialMintCollection(address payable _creator, uint32 _maxTokenId) internal onlyInitializing {\n- 63:     require(_creator != address(0), \"SequentialMintCollection: Creator cannot be the zero address\"); //@audit gas: this is redundant as only factory can init and always pass good result\n64: \n65:     owner = _creator;\n66:     maxTokenId = _maxTokenId;\n67:   }\n```\n\nThis is due to the fact that the `initialize()` methods have the `onlyContractFactory` modifier already, and that calls to `initialize` from the factory are not using `address(0)` (and hardly ever will in the future of the solution). See these initializations where the first argument is `creator`:\n\n```solidity\ncontracts/NFTCollectionFactory.sol:\n  211:     INFTCollectionInitializer(_implementation).initialize(\n  212        payable(address(rolesContract)),\n```\n\n```solidity\n  237:     INFTDropCollectionInitializer(_implementation).initialize(\n  238        payable(address(this)),\n```\n\n```solidity\n  267:     INFTCollectionInitializer(collection).initialize(payable(msg.sender), name, symbol);\n```\n\n```solidity\n  399:     INFTDropCollectionInitializer(collection).initialize(\n  400        payable(msg.sender),\n```\n\nConsider removing this check.\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-08-foundation-drop-contest",
  "Code": [
    {
      "filename": "contracts/mixins/collections/SequentialMintCollection.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol\";\n\nimport \"../../interfaces/ITokenCreator.sol\";\n\n/**\n * @title Extends the OZ ERC721 implementation for collections which mint sequential token IDs.\n */\nabstract contract SequentialMintCollection is ITokenCreator, Initializable, ERC721BurnableUpgradeable {\n  /****** Slot 0 (after inheritance) ******/\n  /**\n   * @notice The creator/owner of this NFT collection.\n   * @dev This is the default royalty recipient if an different `paymentAddress` was not provided.\n   * @return The collection's creator/owner address.\n   */\n  address payable public owner;\n\n  /**\n   * @notice The tokenId of the most recently created NFT.\n   * @dev Minting starts at tokenId 1. Each mint will use this value + 1.\n   * @return The most recently minted tokenId, or 0 if no NFTs have been minted yet.\n   */\n  uint32 public latestTokenId;\n\n  /**\n   * @notice The max tokenId which can be minted.\n   * @dev This max may be less than the final `totalSupply` if 1 or more tokens were burned.\n   * @return The max tokenId which can be minted.\n   */\n  uint32 public maxTokenId;\n\n  /**\n   * @notice Tracks how many tokens have been burned.\n   * @dev This number is used to calculate the total supply efficiently.\n   */\n  uint32 private burnCounter;\n\n  /****** End of storage ******/\n\n  /**\n   * @notice Emitted when the max tokenId supported by this collection is updated.\n   * @param maxTokenId The new max tokenId. All NFTs in this collection will have a tokenId less than\n   * or equal to this value.\n   */\n  event MaxTokenIdUpdated(uint256 indexed maxTokenId);\n\n  /**\n   * @notice Emitted when this collection is self destructed by the creator/owner/admin.\n   * @param admin The account which requested this contract be self destructed.\n   */\n  event SelfDestruct(address indexed admin);\n\n  modifier onlyCreator() {\n    require(msg.sender == owner, \"SequentialMintCollection: Caller is not creator\");\n    _;\n  }\n\n  function _initializeSequentialMintCollection(address payable _creator, uint32 _maxTokenId) internal onlyInitializing {\n    require(_creator != address(0), \"SequentialMintCollection: Creator cannot be the zero address\");\n\n    owner = _creator;\n    maxTokenId = _maxTokenId;\n  }\n\n  /**\n   * @notice Allows the collection owner to destroy this contract only if\n   * no NFTs have been minted yet or the minted NFTs have been burned.\n   */\n  function _selfDestruct() internal {\n    require(totalSupply() == 0, \"SequentialMintCollection: Any NFTs minted must be burned first\");\n\n    emit SelfDestruct(msg.sender);\n    selfdestruct(payable(msg.sender));\n  }\n\n  /**\n   * @notice Allows the owner to set a max tokenID.\n   * This provides a guarantee to collectors about the limit of this collection contract, if applicable.\n   * @dev Once this value has been set, it may be decreased but can never be increased.\n   * @param _maxTokenId The max tokenId to set, all NFTs must have a tokenId less than or equal to this value.\n   */\n  function _updateMaxTokenId(uint32 _maxTokenId) internal {\n    require(_maxTokenId != 0, \"SequentialMintCollection: Max token ID may not be cleared\");\n    require(maxTokenId == 0 || _maxTokenId < maxTokenId, \"SequentialMintCollection: Max token ID may not increase\");\n    require(latestTokenId <= _maxTokenId, \"SequentialMintCollection: Max token ID must be >= last mint\");\n\n    maxTokenId = _maxTokenId;\n    emit MaxTokenIdUpdated(_maxTokenId);\n  }\n\n  function _burn(uint256 tokenId) internal virtual override {\n    unchecked {\n      // Number of burned tokens cannot exceed latestTokenId which is the same size.\n      ++burnCounter;\n    }\n    super._burn(tokenId);\n  }\n\n  /**\n   * @inheritdoc ITokenCreator\n   * @dev The tokenId param is ignored since all NFTs return the same value.\n   */\n  function tokenCreator(\n    uint256 /* tokenId */\n  ) external view returns (address payable creator) {\n    creator = owner;\n  }\n\n  /**\n   * @notice Returns the total amount of tokens stored by the contract.\n   * @dev From the ERC-721 enumerable standard.\n   * @return supply The total number of NFTs tracked by this contract.\n   */\n  function totalSupply() public view returns (uint256 supply) {\n    unchecked {\n      // Number of tokens minted is always >= burned tokens.\n      supply = latestTokenId - burnCounter;\n    }\n  }\n}"
    }
  ]
}