{
  "Title": "H-4: LibMuon Signature hash collision",
  "Content": "# Issue H-4: LibMuon Signature hash collision \n\nSource: https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/214 \n\n## Found by \nbin2chen, shaka\n## Summary\n\nIn `LibMuon `, all signatures do not distinguish between type prefixes, and  `abi.encodePacked` is used when calculating the hash\nCause when  `abi.encodePacked`, if there is a dynamic array, different structures but the same hash value may be obtained\nDue to conflicting hash values, signatures can be substituted for each other, making malicious use of illegal signatures possible\n\n## Vulnerability Detail\n\nThe following two methods are examples\n\n1.verifyPrices:\n```solidity\n    function verifyPrices(PriceSig memory priceSig, address partyA) internal view {\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n        require(priceSig.prices.length == priceSig.symbolIds.length, \"LibMuon: Invalid length\");\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                muonLayout.muonAppId,\n                priceSig.reqId,\n                address(this),\n@>              partyA,\n@>              priceSig.upnl,\n@>              priceSig.totalUnrealizedLoss,\n@>              priceSig.symbolIds,\n@>              priceSig.prices,\n                priceSig.timestamp,\n                getChainId()\n            )\n        );\n        verifyTSSAndGateway(hash, priceSig.sigs, priceSig.gatewaySignature);\n    }\n```\n\n2.verifyPartyAUpnlAndPrice\n```solidity\n    function verifyPartyAUpnlAndPrice(\n        SingleUpnlAndPriceSig memory upnlSig,\n        address partyA,\n        uint256 symbolId\n    ) internal view {\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n//        require(\n//            block.timestamp <= upnlSig.timestamp + muonLayout.upnlValidTime,\n//            \"LibMuon: Expired signature\"\n//        );\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                muonLayout.muonAppId,\n                upnlSig.reqId,\n                address(this),\n@>              partyA,\n@>              AccountStorage.layout().partyANonces[partyA],\n@>              upnlSig.upnl,\n@>              symbolId,\n@>              upnlSig.price,\n                upnlSig.timestamp,\n                getChainId()\n            )\n        );\n        verifyTSSAndGateway(hash, upnlSig.sigs, upnlSig.gatewaySignature);\n    }\n```\nWe exclude the same common part (muonAppId/reqId/address (this)/timestamp/getChainId ())\n\nThrough the following simplified test code, although the structure is different, the hash value is the same at that time\n\n```solidity\n  function test() external {\n    address verifyPrices_partyA = address(0x1);\n    int256 verifyPrices_upnl = 100;\n    int256 verifyPrices_totalUnrealizedLoss = 100;\n    uint256 [] memory verifyPrices_symbolIds = new uint256[](1);\n    verifyPrices_symbolIds[0]=1;\n    uint256 [] memory verifyPrices_prices = new uint256[](1);\n    verifyPrices_prices[0]=1000;  \n\n    bytes32 verifyPrices  = keccak256(abi.encodePacked(\n            verifyPrices_partyA,\n            verifyPrices_upnl,\n            verifyPrices_totalUnrealizedLoss,\n            verifyPrices_symbolIds,\n            verifyPrices_prices\n            ));\n\n    address verifyPartyAUpnlAndPrice_partyA = verifyPrices_partyA;\n    int256  verifyPartyAUpnlAndPrice_partyANonces = verifyPrices_upnl;\n    int256  verifyPartyAUpnlAndPrice_upnl = verifyPrices_totalUnrealizedLoss;\n    uint256 verifyPartyAUpnlAndPrice_symbolId = verifyPrices_symbolIds[0];\n    uint256 verifyPartyAUpnlAndPrice_price = verifyPrices_prices[0];\n\n\n    bytes32 verifyPartyAUpnlAndPrice  = keccak256(abi.encodePacked(\n            verifyPartyAUpnlAndPrice_partyA,\n            verifyPartyAUpnlAndPrice_partyANonces,\n            verifyPartyAUpnlAndPrice_upnl,\n            verifyPartyAUpnlAndPrice_symbolId,\n            verifyPartyAUpnlAndPrice_price\n            ));\n\n    console.log(\"verifyPrices == verifyPartyAUpnlAndPrice:\",verifyPrices == verifyPartyAUpnlAndPrice);\n\n  }\n```\n\n```console\n$ forge test -vvv\n\nRunning 1 test for test/Counter.t.sol:CounterTest\n[PASS] test() (gas: 4991)\nLogs:\n  verifyPrices == verifyPartyAUpnlAndPrice: true\n\nTest result: ok. 1 passed; 0 failed; finished in 11.27ms\n```\n\nFrom the above test example, we can see that the `verifyPrices` and `verifyPartyAUpnlAndPrice` signatures can be used interchangeably\nIf we get a legal `verifyPartyAUpnlAndPrice `, it can be used as the signature of `verifyPrices ()`\nUse `partyANonces` as  `upnl`, etc\n\n## Impact\nSignatures can be reused due to hash collisions, through illegal signatures, using illegal `unpl`, etc\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/libraries/LibMuon.sol#L12\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIt is recommended to add the prefix of the hash, or use `api.encode`\nSuch as:\n```solidity\n    function verifyPrices(PriceSig memory priceSig, address partyA) internal view {\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n        require(priceSig.prices.length == priceSig.symbolIds.length, \"LibMuon: Invalid length\");\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n+              \"verifyPrices\",\n                muonLayout.muonAppId,\n                priceSig.reqId,\n                address(this),\n                partyA,\n                priceSig.upnl,\n                priceSig.totalUnrealizedLoss,\n                priceSig.symbolIds,\n                priceSig.prices,\n                priceSig.timestamp,\n                getChainId()\n            )\n        );\n        verifyTSSAndGateway(hash, priceSig.sigs, priceSig.gatewaySignature);\n    }\n```\n\n\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n> Escalate\n> \n> This issue and duplicate are invalid:\n> These issues suggest that a collision is possible between hashes being used in `verifyPrices` and `verifyPartyAUpnlAndPrice`.\n> \n> The following check:\n> https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/libraries/LibMuon.sol#L52\n> \n> ensures that `priceSig.symbolIds.length + priceSig.prices.length != 3` and so:\n> \n> ```solidity\n> abi.encodePacked(\n>     muonLayout.muonAppId,\n>     priceSig.reqId,\n>     address(this),\n>     partyA,\n>     priceSig.upnl,\n>     priceSig.totalUnrealizedLoss,\n>     priceSig.symbolIds,\n>     priceSig.prices,\n>     priceSig.timestamp,\n>     getChainId()\n> ) != abi.encodePacked(\n>     muonLayout.muonAppId,\n>     upnlSig.reqId,\n>     address(this),\n>     partyA,\n>     AccountStorage.layout().partyANonces[partyA],\n>     upnlSig.upnl,\n>     upnlSig.timestamp,\n>     getChainId()\n> )\n> ```\n> because the two structures cannot be of the same length given the check \n\n    You've deleted an escalation for this issue.\n\n**MoonKnightDev**\n\nFixed code PR link:\nhttps://github.com/SYMM-IO/symmio-core/pull/11\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/85",
  "Code": [
    {
      "filename": "symmio-core/contracts/libraries/LibMuon.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"../libraries/LibMuonV04ClientBase.sol\";\nimport \"../storages/MuonStorage.sol\";\nimport \"../storages/AccountStorage.sol\";\n\nlibrary LibMuon {\n    using ECDSA for bytes32;\n\n    function getChainId() internal view returns (uint256 id) {\n        assembly {\n            id := chainid()\n        }\n    }\n\n    // CONTEXT for commented out lines\n    // We're utilizing muon signatures for asset pricing and user uPNLs calculations. \n    // Even though these signatures are necessary for full testing of the system, particularly when invoking various methods.\n    // The process of creating automated functional signature for tests has proven to be either impractical or excessively time-consuming. therefore, we've established commenting out the necessary code as a workaround specifically for testing.\n    // Essentially, during testing, we temporarily disable the code sections responsible for validating these signatures. The sections I'm referring to are located within the LibMuon file. Specifically, the body of the 'verifyTSSAndGateway' method is a prime candidate for temporary disablement. In addition, several 'require' statements within other functions of this file, which examine the signatures' expiration status, also need to be temporarily disabled.\n    // However, it is crucial to note that these lines should not be disabled in the production deployed version. \n    // We emphasize this because they are only disabled for testing purposes.\n\n    function verifyTSSAndGateway(\n        bytes32 hash,\n        SchnorrSign memory sign,\n        bytes memory gatewaySignature\n    ) internal view {\n//       bool verified = LibMuonV04ClientBase.muonVerify(\n//           uint256(hash),\n//           sign,\n//           MuonStorage.layout().muonPublicKey\n//       );\n//       require(verified, \"LibMuon: TSS not verified\");\n//\n//       hash = hash.toEthSignedMessageHash();\n//       address gatewaySignatureSigner = hash.recover(gatewaySignature);\n//\n//       require(\n//           gatewaySignatureSigner == MuonStorage.layout().validGateway,\n//           \"LibMuon: Gateway is not valid\"\n//       );\n    }\n\n    function verifyPrices(PriceSig memory priceSig, address partyA) internal view {\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n        require(priceSig.prices.length == priceSig.symbolIds.length, \"LibMuon: Invalid length\");\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                muonLayout.muonAppId,\n                priceSig.reqId,\n                address(this),\n                partyA,\n                priceSig.upnl,\n                priceSig.totalUnrealizedLoss,\n                priceSig.symbolIds,\n                priceSig.prices,\n                priceSig.timestamp,\n                getChainId()\n            )\n        );\n        verifyTSSAndGateway(hash, priceSig.sigs, priceSig.gatewaySignature);\n    }\n\n    function verifyQuotePrices(QuotePriceSig memory priceSig) internal view {\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n        require(priceSig.prices.length == priceSig.quoteIds.length, \"LibMuon: Invalid length\");\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                muonLayout.muonAppId,\n                priceSig.reqId,\n                address(this),\n                priceSig.quoteIds,\n                priceSig.prices,\n                priceSig.timestamp,\n                getChainId()\n            )\n        );\n        verifyTSSAndGateway(hash, priceSig.sigs, priceSig.gatewaySignature);\n    }\n\n    function verifyPartyAUpnl(SingleUpnlSig memory upnlSig, address partyA) internal view {\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n//        require(\n//            block.timestamp <= upnlSig.timestamp + muonLayout.upnlValidTime,\n//            \"LibMuon: Expired signature\"\n//        );\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                muonLayout.muonAppId,\n                upnlSig.reqId,\n                address(this),\n                partyA,\n                AccountStorage.layout().partyANonces[partyA],\n                upnlSig.upnl,\n                upnlSig.timestamp,\n                getChainId()\n            )\n        );\n        verifyTSSAndGateway(hash, upnlSig.sigs, upnlSig.gatewaySignature);\n    }\n\n    function verifyPartyAUpnlAndPrice(\n        SingleUpnlAndPriceSig memory upnlSig,\n        address partyA,\n        uint256 symbolId\n    ) internal view {\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n//        require(\n//            block.timestamp <= upnlSig.timestamp + muonLayout.upnlValidTime,\n//            \"LibMuon: Expired signature\"\n//        );\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                muonLayout.muonAppId,\n                upnlSig.reqId,\n                address(this),\n                partyA,\n                AccountStorage.layout().partyANonces[partyA],\n                upnlSig.upnl,\n                symbolId,\n                upnlSig.price,\n                upnlSig.timestamp,\n                getChainId()\n            )\n        );\n        verifyTSSAndGateway(hash, upnlSig.sigs, upnlSig.gatewaySignature);\n    }\n\n    function verifyPartyBUpnl(\n        SingleUpnlSig memory upnlSig,\n        address partyB,\n        address partyA\n    ) internal view {\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n//        require(\n//            block.timestamp <= upnlSig.timestamp + muonLayout.upnlValidTime,\n//            \"LibMuon: Expired signature\"\n//        );\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                muonLayout.muonAppId,\n                upnlSig.reqId,\n                address(this),\n                partyB,\n                partyA,\n                AccountStorage.layout().partyBNonces[partyB][partyA],\n                upnlSig.upnl,\n                upnlSig.timestamp,\n                getChainId()\n            )\n        );\n        verifyTSSAndGateway(hash, upnlSig.sigs, upnlSig.gatewaySignature);\n    }\n\n    function verifyPairUpnlAndPrice(\n        PairUpnlAndPriceSig memory upnlSig,\n        address partyB,\n        address partyA,\n        uint256 symbolId\n    ) internal view {\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n//        require(\n//            block.timestamp <= upnlSig.timestamp + muonLayout.upnlValidTime,\n//            \"LibMuon: Expired signature\"\n//        );\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                muonLayout.muonAppId,\n                upnlSig.reqId,\n                address(this),\n                partyB,\n                partyA,\n                AccountStorage.layout().partyBNonces[partyB][partyA],\n                AccountStorage.layout().partyANonces[partyA],\n                upnlSig.upnlPartyB,\n                upnlSig.upnlPartyA,\n                symbolId,\n                upnlSig.price,\n                upnlSig.timestamp,\n                getChainId()\n            )\n        );\n        verifyTSSAndGateway(hash, upnlSig.sigs, upnlSig.gatewaySignature);\n    }\n\n    function verifyPairUpnl(\n        PairUpnlSig memory upnlSig,\n        address partyB,\n        address partyA\n    ) internal view {\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n//        require(\n//            block.timestamp <= upnlSig.timestamp + muonLayout.upnlValidTime,\n//            \"LibMuon: Expired signature\"\n//        );\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                muonLayout.muonAppId,\n                upnlSig.reqId,\n                address(this),\n                partyB,\n                partyA,\n                AccountStorage.layout().partyBNonces[partyB][partyA],\n                AccountStorage.layout().partyANonces[partyA],\n                upnlSig.upnlPartyB,\n                upnlSig.upnlPartyA,\n                upnlSig.timestamp,\n                getChainId()\n            )\n        );\n        verifyTSSAndGateway(hash, upnlSig.sigs, upnlSig.gatewaySignature);\n    }\n}"
    },
    {
      "filename": "symmio-core/contracts/libraries/LibMuon.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"../libraries/LibMuonV04ClientBase.sol\";\nimport \"../storages/MuonStorage.sol\";\nimport \"../storages/AccountStorage.sol\";\n\nlibrary LibMuon {\n    using ECDSA for bytes32;\n\n    function getChainId() internal view returns (uint256 id) {\n        assembly {\n            id := chainid()\n        }\n    }\n\n    // CONTEXT for commented out lines\n    // We're utilizing muon signatures for asset pricing and user uPNLs calculations. \n    // Even though these signatures are necessary for full testing of the system, particularly when invoking various methods.\n    // The process of creating automated functional signature for tests has proven to be either impractical or excessively time-consuming. therefore, we've established commenting out the necessary code as a workaround specifically for testing.\n    // Essentially, during testing, we temporarily disable the code sections responsible for validating these signatures. The sections I'm referring to are located within the LibMuon file. Specifically, the body of the 'verifyTSSAndGateway' method is a prime candidate for temporary disablement. In addition, several 'require' statements within other functions of this file, which examine the signatures' expiration status, also need to be temporarily disabled.\n    // However, it is crucial to note that these lines should not be disabled in the production deployed version. \n    // We emphasize this because they are only disabled for testing purposes.\n\n    function verifyTSSAndGateway(\n        bytes32 hash,\n        SchnorrSign memory sign,\n        bytes memory gatewaySignature\n    ) internal view {\n//       bool verified = LibMuonV04ClientBase.muonVerify(\n//           uint256(hash),\n//           sign,\n//           MuonStorage.layout().muonPublicKey\n//       );\n//       require(verified, \"LibMuon: TSS not verified\");\n//\n//       hash = hash.toEthSignedMessageHash();\n//       address gatewaySignatureSigner = hash.recover(gatewaySignature);\n//\n//       require(\n//           gatewaySignatureSigner == MuonStorage.layout().validGateway,\n//           \"LibMuon: Gateway is not valid\"\n//       );\n    }\n\n    function verifyPrices(PriceSig memory priceSig, address partyA) internal view {\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n        require(priceSig.prices.length == priceSig.symbolIds.length, \"LibMuon: Invalid length\");\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                muonLayout.muonAppId,\n                priceSig.reqId,\n                address(this),\n                partyA,\n                priceSig.upnl,\n                priceSig.totalUnrealizedLoss,\n                priceSig.symbolIds,\n                priceSig.prices,\n                priceSig.timestamp,\n                getChainId()\n            )\n        );\n        verifyTSSAndGateway(hash, priceSig.sigs, priceSig.gatewaySignature);\n    }\n\n    function verifyQuotePrices(QuotePriceSig memory priceSig) internal view {\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n        require(priceSig.prices.length == priceSig.quoteIds.length, \"LibMuon: Invalid length\");\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                muonLayout.muonAppId,\n                priceSig.reqId,\n                address(this),\n                priceSig.quoteIds,\n                priceSig.prices,\n                priceSig.timestamp,\n                getChainId()\n            )\n        );\n        verifyTSSAndGateway(hash, priceSig.sigs, priceSig.gatewaySignature);\n    }\n\n    function verifyPartyAUpnl(SingleUpnlSig memory upnlSig, address partyA) internal view {\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n//        require(\n//            block.timestamp <= upnlSig.timestamp + muonLayout.upnlValidTime,\n//            \"LibMuon: Expired signature\"\n//        );\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                muonLayout.muonAppId,\n                upnlSig.reqId,\n                address(this),\n                partyA,\n                AccountStorage.layout().partyANonces[partyA],\n                upnlSig.upnl,\n                upnlSig.timestamp,\n                getChainId()\n            )\n        );\n        verifyTSSAndGateway(hash, upnlSig.sigs, upnlSig.gatewaySignature);\n    }\n\n    function verifyPartyAUpnlAndPrice(\n        SingleUpnlAndPriceSig memory upnlSig,\n        address partyA,\n        uint256 symbolId\n    ) internal view {\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n//        require(\n//            block.timestamp <= upnlSig.timestamp + muonLayout.upnlValidTime,\n//            \"LibMuon: Expired signature\"\n//        );\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                muonLayout.muonAppId,\n                upnlSig.reqId,\n                address(this),\n                partyA,\n                AccountStorage.layout().partyANonces[partyA],\n                upnlSig.upnl,\n                symbolId,\n                upnlSig.price,\n                upnlSig.timestamp,\n                getChainId()\n            )\n        );\n        verifyTSSAndGateway(hash, upnlSig.sigs, upnlSig.gatewaySignature);\n    }\n\n    function verifyPartyBUpnl(\n        SingleUpnlSig memory upnlSig,\n        address partyB,\n        address partyA\n    ) internal view {\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n//        require(\n//            block.timestamp <= upnlSig.timestamp + muonLayout.upnlValidTime,\n//            \"LibMuon: Expired signature\"\n//        );\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                muonLayout.muonAppId,\n                upnlSig.reqId,\n                address(this),\n                partyB,\n                partyA,\n                AccountStorage.layout().partyBNonces[partyB][partyA],\n                upnlSig.upnl,\n                upnlSig.timestamp,\n                getChainId()\n            )\n        );\n        verifyTSSAndGateway(hash, upnlSig.sigs, upnlSig.gatewaySignature);\n    }\n\n    function verifyPairUpnlAndPrice(\n        PairUpnlAndPriceSig memory upnlSig,\n        address partyB,\n        address partyA,\n        uint256 symbolId\n    ) internal view {\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n//        require(\n//            block.timestamp <= upnlSig.timestamp + muonLayout.upnlValidTime,\n//            \"LibMuon: Expired signature\"\n//        );\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                muonLayout.muonAppId,\n                upnlSig.reqId,\n                address(this),\n                partyB,\n                partyA,\n                AccountStorage.layout().partyBNonces[partyB][partyA],\n                AccountStorage.layout().partyANonces[partyA],\n                upnlSig.upnlPartyB,\n                upnlSig.upnlPartyA,\n                symbolId,\n                upnlSig.price,\n                upnlSig.timestamp,\n                getChainId()\n            )\n        );\n        verifyTSSAndGateway(hash, upnlSig.sigs, upnlSig.gatewaySignature);\n    }\n\n    function verifyPairUpnl(\n        PairUpnlSig memory upnlSig,\n        address partyB,\n        address partyA\n    ) internal view {\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\n//        require(\n//            block.timestamp <= upnlSig.timestamp + muonLayout.upnlValidTime,\n//            \"LibMuon: Expired signature\"\n//        );\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                muonLayout.muonAppId,\n                upnlSig.reqId,\n                address(this),\n                partyB,\n                partyA,\n                AccountStorage.layout().partyBNonces[partyB][partyA],\n                AccountStorage.layout().partyANonces[partyA],\n                upnlSig.upnlPartyB,\n                upnlSig.upnlPartyA,\n                upnlSig.timestamp,\n                getChainId()\n            )\n        );\n        verifyTSSAndGateway(hash, upnlSig.sigs, upnlSig.gatewaySignature);\n    }\n}"
    }
  ]
}