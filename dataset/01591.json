{
  "Title": "H-2: Failed withdrawals from VUSD#processWithdrawals will be lost forever",
  "Content": "# Issue H-2: Failed withdrawals from VUSD#processWithdrawals will be lost forever \n\nSource: https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/162 \n\n## Found by \n0x52, 0xDjango, 0xpinky, Delvir0, Kaiziron, dirk\\_y, kutugu, n1punp, ver0759, yy\n## Summary\n\nWhen withdrawals fail inside VUSD#processWithdrawals they are permanently passed over and cannot be retried. The result is that any failed withdrawal will be lost forever.\n\n## Vulnerability Detail\n\n[VUSD.sol#L75-L81](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/VUSD.sol#L75-L81)\n\n            (bool success, bytes memory data) = withdrawal.usr.call{value: withdrawal.amount}(\"\");\n            if (success) {\n                reserve -= withdrawal.amount;\n            } else {\n                emit WithdrawalFailed(withdrawal.usr, withdrawal.amount, data);\n            }\n            i += 1;\n\nIf the call to withdrawal.usr fails the contract will simply emit an event and continue on with its cycle. Since there is no way to retry withdrawals, these funds will be permanently lost.\n\n## Impact\n\nWithdrawals that fail will be permanently locked\n\n## Code Snippet\n\n[VUSD.sol#L65-L85](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/VUSD.sol#L65-L85)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCache failed withdrawals and allow them to be retried or simply send VUSD to the user if it fails.\n\n\n\n## Discussion\n\n**asquare08**\n\nwill add functionality to retry withdrawals\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/72",
  "Code": [
    {
      "filename": "hubble-protocol/contracts/VUSD.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { ERC20PresetMinterPauserUpgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol\";\nimport { IVUSD } from './Interfaces.sol';\n\n/**\n * @title VUSD is a wrapper over USDC (also the gas token). VUSD it the 0th collateral in the system and also the only coin accepted by the insurance fund.\n * @notice In Hubble Exchange docs/contracts etc, VUSD is interchangeably referred to as hUSD\n*/\ncontract VUSD is ERC20PresetMinterPauserUpgradeable, ReentrancyGuard, IVUSD {\n\n    uint8 private constant PRECISION = 6;\n    uint256 private constant SCALING_FACTOR = 1e12;\n\n    struct Withdrawal {\n        address usr;\n        uint amount;\n    }\n    Withdrawal[] public withdrawals;\n\n    /// @dev withdrawals will start processing at withdrawals[start]\n    uint public start;\n\n    /// @dev Constrained by block gas limit\n    uint public maxWithdrawalProcesses;\n\n    uint256[50] private __gap;\n\n    function initialize(string memory name, string memory symbol) public override virtual {\n        super.initialize(name, symbol); // has initializer modifier\n        _revokeRole(MINTER_ROLE, _msgSender()); // __ERC20PresetMinterPauser_init_unchained grants this but is not required\n        maxWithdrawalProcesses = 100;\n    }\n\n    /**\n    * @notice mint hUSD by depositing hubble gas token\n    * @dev keeping the function name same as v1 for compatibility\n    * @param to address to mint for\n    * @param amount amount to mint - precision 1e6\n    * msg.value has to be exactly 1e12 times `amount`\n    */\n    function mintWithReserve(address to, uint amount) external override payable whenNotPaused {\n        require(msg.value == amount * SCALING_FACTOR, \"vUSD: Insufficient amount transferred\");\n        _mint(to, amount);\n    }\n\n    function withdraw(uint amount) external override whenNotPaused {\n        _withdrawTo(_msgSender(), amount);\n    }\n\n    /**\n    * @notice Burn vusd from msg.sender and Q the withdrawal to `to`\n    * @dev no need to add onlyMarginAccountHelper modifier as vusd is burned from caller and sent to specified address\n    */\n    function withdrawTo(address to, uint amount) external override whenNotPaused {\n        _withdrawTo(to, amount);\n    }\n\n    /**\n     * @notice Process withdrawals in the queue. Sends gas token to the user.\n    */\n    function processWithdrawals() external override whenNotPaused nonReentrant {\n        uint reserve = address(this).balance;\n        require(reserve >= withdrawals[start].amount, 'Cannot process withdrawals at this time: Not enough balance');\n        uint i = start;\n        while (i < withdrawals.length && (i - start) < maxWithdrawalProcesses) {\n            Withdrawal memory withdrawal = withdrawals[i];\n            if (reserve < withdrawal.amount) {\n                break;\n            }\n\n            (bool success, bytes memory data) = withdrawal.usr.call{value: withdrawal.amount}(\"\");\n            if (success) {\n                reserve -= withdrawal.amount;\n            } else {\n                emit WithdrawalFailed(withdrawal.usr, withdrawal.amount, data);\n            }\n            i += 1;\n        }\n        // re-entracy not possible, hence can update `start` at the end\n        start = i;\n    }\n\n    function withdrawalQueue() external view returns(Withdrawal[] memory queue) {\n        uint l = _min(withdrawals.length-start, maxWithdrawalProcesses);\n        queue = new Withdrawal[](l);\n\n        for (uint i = 0; i < l; i++) {\n            queue[i] = withdrawals[start+i];\n        }\n    }\n\n    function withdrawalQLength() external view returns (uint) {\n        return withdrawals.length;\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return PRECISION;\n    }\n\n    function setMaxWithdrawalProcesses(uint _maxWithdrawalProcesses) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have admin role\");\n        maxWithdrawalProcesses = _maxWithdrawalProcesses;\n    }\n\n    function _withdrawTo(address to, uint amount) internal {\n        require(amount >= 5 * (10 ** PRECISION), \"min withdraw is 5 vusd\");\n        burn(amount); // burn vusd from msg.sender\n        withdrawals.push(Withdrawal(to, amount * SCALING_FACTOR));\n    }\n\n    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}"
    },
    {
      "filename": "hubble-protocol/contracts/VUSD.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { ERC20PresetMinterPauserUpgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol\";\nimport { IVUSD } from './Interfaces.sol';\n\n/**\n * @title VUSD is a wrapper over USDC (also the gas token). VUSD it the 0th collateral in the system and also the only coin accepted by the insurance fund.\n * @notice In Hubble Exchange docs/contracts etc, VUSD is interchangeably referred to as hUSD\n*/\ncontract VUSD is ERC20PresetMinterPauserUpgradeable, ReentrancyGuard, IVUSD {\n\n    uint8 private constant PRECISION = 6;\n    uint256 private constant SCALING_FACTOR = 1e12;\n\n    struct Withdrawal {\n        address usr;\n        uint amount;\n    }\n    Withdrawal[] public withdrawals;\n\n    /// @dev withdrawals will start processing at withdrawals[start]\n    uint public start;\n\n    /// @dev Constrained by block gas limit\n    uint public maxWithdrawalProcesses;\n\n    uint256[50] private __gap;\n\n    function initialize(string memory name, string memory symbol) public override virtual {\n        super.initialize(name, symbol); // has initializer modifier\n        _revokeRole(MINTER_ROLE, _msgSender()); // __ERC20PresetMinterPauser_init_unchained grants this but is not required\n        maxWithdrawalProcesses = 100;\n    }\n\n    /**\n    * @notice mint hUSD by depositing hubble gas token\n    * @dev keeping the function name same as v1 for compatibility\n    * @param to address to mint for\n    * @param amount amount to mint - precision 1e6\n    * msg.value has to be exactly 1e12 times `amount`\n    */\n    function mintWithReserve(address to, uint amount) external override payable whenNotPaused {\n        require(msg.value == amount * SCALING_FACTOR, \"vUSD: Insufficient amount transferred\");\n        _mint(to, amount);\n    }\n\n    function withdraw(uint amount) external override whenNotPaused {\n        _withdrawTo(_msgSender(), amount);\n    }\n\n    /**\n    * @notice Burn vusd from msg.sender and Q the withdrawal to `to`\n    * @dev no need to add onlyMarginAccountHelper modifier as vusd is burned from caller and sent to specified address\n    */\n    function withdrawTo(address to, uint amount) external override whenNotPaused {\n        _withdrawTo(to, amount);\n    }\n\n    /**\n     * @notice Process withdrawals in the queue. Sends gas token to the user.\n    */\n    function processWithdrawals() external override whenNotPaused nonReentrant {\n        uint reserve = address(this).balance;\n        require(reserve >= withdrawals[start].amount, 'Cannot process withdrawals at this time: Not enough balance');\n        uint i = start;\n        while (i < withdrawals.length && (i - start) < maxWithdrawalProcesses) {\n            Withdrawal memory withdrawal = withdrawals[i];\n            if (reserve < withdrawal.amount) {\n                break;\n            }\n\n            (bool success, bytes memory data) = withdrawal.usr.call{value: withdrawal.amount}(\"\");\n            if (success) {\n                reserve -= withdrawal.amount;\n            } else {\n                emit WithdrawalFailed(withdrawal.usr, withdrawal.amount, data);\n            }\n            i += 1;\n        }\n        // re-entracy not possible, hence can update `start` at the end\n        start = i;\n    }\n\n    function withdrawalQueue() external view returns(Withdrawal[] memory queue) {\n        uint l = _min(withdrawals.length-start, maxWithdrawalProcesses);\n        queue = new Withdrawal[](l);\n\n        for (uint i = 0; i < l; i++) {\n            queue[i] = withdrawals[start+i];\n        }\n    }\n\n    function withdrawalQLength() external view returns (uint) {\n        return withdrawals.length;\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return PRECISION;\n    }\n\n    function setMaxWithdrawalProcesses(uint _maxWithdrawalProcesses) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have admin role\");\n        maxWithdrawalProcesses = _maxWithdrawalProcesses;\n    }\n\n    function _withdrawTo(address to, uint amount) internal {\n        require(amount >= 5 * (10 ** PRECISION), \"min withdraw is 5 vusd\");\n        burn(amount); // burn vusd from msg.sender\n        withdrawals.push(Withdrawal(to, amount * SCALING_FACTOR));\n    }\n\n    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}"
    }
  ]
}