{
  "Title": "M-7: Stakers can avoid validator penalties",
  "Content": "# Issue M-7: Stakers can avoid validator penalties \n\nSource: https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/190 \n\n## Found by \nmonrel, zzykxx\n## Summary\nStakers can frontrun validators penalties and slashing events with a withdrawal request in order to avoid the loss, this is possible if the deposit pool has enough liquidity available.\n\n## Vulnerability Detail\nValidators can lose part of their deposit via [penalties](https://eth2book.info/capella/part2/incentives/penalties/) or [slashing](https://eth2book.info/capella/part2/incentives/slashing/) events:\n- In case of penalties Eigenlayer can be notified of the balance drop via the permissionless function \n[EigenPod::verifyBalanceUpdates()](https://github.com/Layr-Labs/eigenlayer-contracts/blob/v0.2.1-goerli-m2/src/contracts/pods/EigenPod.sol#L185). \n- In case of slashing the validator is forced to exit and Eigenlayer can be notified via the permissionless function [EigenPod::verifyAndProcessWithdrawals()](https://github.com/Layr-Labs/eigenlayer-contracts/blob/v0.2.1-goerli-m2/src/contracts/pods/EigenPod.sol#L232) because the slashing event is effectively a full withdrawal.\n\nAs soon as either [EigenPod::verifyBalanceUpdates()](https://github.com/Layr-Labs/eigenlayer-contracts/blob/v0.2.1-goerli-m2/src/contracts/pods/EigenPod.sol#L185) or [EigenPod::verifyAndProcessWithdrawals()](https://github.com/Layr-Labs/eigenlayer-contracts/blob/v0.2.1-goerli-m2/src/contracts/pods/EigenPod.sol#L232) is called the TVL of the Rio protocol drops instantly. This is because both of the functions update the variable [`podOwnerShares[podOwner]`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/v0.2.1-goerli-m2/src/contracts/pods/EigenPodManager.sol#L120):\n- [EigenPod::verifyBalanceUpdates()](https://github.com/Layr-Labs/eigenlayer-contracts/blob/v0.2.1-goerli-m2/src/contracts/pods/EigenPod.sol#L185) will update the variable [here](https://github.com/Layr-Labs/eigenlayer-contracts/blob/v0.2.1-goerli-m2/src/contracts/pods/EigenPod.sol#L220)\n- [EigenPod::verifyAndProcessWithdrawals()](https://github.com/Layr-Labs/eigenlayer-contracts/blob/v0.2.1-goerli-m2/src/contracts/pods/EigenPod.sol#L232) will update the variable [here](https://github.com/Layr-Labs/eigenlayer-contracts/blob/v0.2.1-goerli-m2/src/contracts/pods/EigenPod.sol#L275)\n\nThis makes it possible for stakers to:\n1. Request a withdrawal via [RioLRTCoordinator::rebalance()](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/main/rio-sherlock-audit/contracts/restaking/RioLRTCoordinator.sol#L99) for all the `LRTTokens` held.\n2. Call either [EigenPod::verifyBalanceUpdates()](https://github.com/Layr-Labs/eigenlayer-contracts/blob/v0.2.1-goerli-m2/src/contracts/pods/EigenPod.sol#L185) or [EigenPod::verifyAndProcessWithdrawals()](https://github.com/Layr-Labs/eigenlayer-contracts/blob/v0.2.1-goerli-m2/src/contracts/pods/EigenPod.sol#L232).\n\nAt this point when [RioLRTCoordinator::rebalance()](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/main/rio-sherlock-audit/contracts/restaking/RioLRTCoordinator.sol#L121) will be called and a withdrawal will be queued that does not include penalties or slashing. \n\nIt's possible to withdraw `LRTTokens` while avoiding penalties or slashing up to the amount of liquidity available in the deposit pool.\n\n### POC\nI wrote a POC whose main point is to show that requesting a withdrawal before an instant TVL drop will withdraw the full amount requested without taking the drop into account. The POC doesn't show that [EigenPod::verifyBalanceUpdates()](https://github.com/Layr-Labs/eigenlayer-contracts/blob/v0.2.1-goerli-m2/src/contracts/pods/EigenPod.sol#L185) or [EigenPod::verifyAndProcessWithdrawals()](https://github.com/Layr-Labs/eigenlayer-contracts/blob/v0.2.1-goerli-m2/src/contracts/pods/EigenPod.sol#L232) actually lowers the TVL because I wasn't able to implement it in the tests.\n\nAdd imports to `RioLRTCoordinator.t.sol`:\n```solidity\nimport {IRioLRTOperatorRegistry} from 'contracts/interfaces/IRioLRTOperatorRegistry.sol';\nimport {RioLRTOperatorDelegator} from 'contracts/restaking/RioLRTOperatorDelegator.sol';\nimport {CredentialsProofs, BeaconWithdrawal} from 'test/utils/beacon-chain/MockBeaconChain.sol';\n```\n\nthen copy-paste:\n```solidity\nIRioLRTOperatorRegistry.StrategyShareCap[] public emptyStrategyShareCaps;\nfunction test_avoidInstantPriceDrop() public {\n    //-> Add two operators with 1 validator each\n    uint8[] memory operatorIds = addOperatorDelegators(\n        reETH.operatorRegistry,\n        address(reETH.rewardDistributor),\n        2,\n        emptyStrategyShareCaps,\n        1\n    );\n    address operatorAddress0 = address(uint160(1));\n\n    //-> Deposit ETH so there's 74ETH in the deposit pool\n    uint256 depositAmount = 2*ETH_DEPOSIT_SIZE - address(reETH.depositPool).balance;\n    uint256 amountToWithdraw = 10 ether;\n    reETH.coordinator.depositETH{value: amountToWithdraw + depositAmount}();\n\n    //-> Stake the 64ETH on the validators, 32ETH each and 10 ETH stay in the deposit pool\n    vm.prank(EOA, EOA);\n    reETH.coordinator.rebalance(ETH_ADDRESS);\n\n    //-> Attacker notices a validator is going receive penalties and immediately requests a withdrawal of 10ETH\n    reETH.coordinator.requestWithdrawal(ETH_ADDRESS, amountToWithdraw);\n\n    //-> Validator get some penalties and Eigenlayer notified \n    //IMPORTANT: The following block of code it's a simulation of what would happen if a validator balances gets lowered because of penalties\n    //and `verifyBalanceUpdates()` gets called on Eigenlayer. It uses another bug to achieve an instant loss of TVL.\n\n    //      ~~~Start penalties simulation~~~\n    {\n        //-> Verify validators credentials of the two validators\n        verifyCredentialsForValidators(reETH.operatorRegistry, 1, 1);\n        verifyCredentialsForValidators(reETH.operatorRegistry, 2, 1);\n\n        //-> Cache current TVL and ETH Balance\n        uint256 TVLBefore = reETH.coordinator.getTVL();\n\n        //->Operator calls `undelegate()` on Eigenlayer\n        //IMPORTANT: This achieves the same a calling `verifyBalanceUpdates()` on Eigenlayer after a validator suffered penalties,\n        //an instant drop in TVL.\n        IRioLRTOperatorRegistry.OperatorPublicDetails memory details = reETH.operatorRegistry.getOperatorDetails(operatorIds[0]);\n        vm.prank(operatorAddress0);\n        delegationManager.undelegate(details.delegator);\n\n        //-> TVL dropped\n        uint256 TVLAfter = reETH.coordinator.getTVL();\n\n        assertLt(TVLAfter, TVLBefore);\n    }\n    //      ~~~End penalties simulation~~~\n\n    //-> Rebalance gets called\n    skip(reETH.coordinator.rebalanceDelay());\n    vm.prank(EOA, EOA);\n    reETH.coordinator.rebalance(ETH_ADDRESS);\n\n    //-> Attacker receives all of the ETH he withdrew, avoiding the effect of penalties\n    uint256 balanceBefore = address(this).balance;\n    reETH.withdrawalQueue.claimWithdrawalsForEpoch(IRioLRTWithdrawalQueue.ClaimRequest({asset: ETH_ADDRESS, epoch: 0}));\n    uint256 balanceAfter = address(this).balance;\n    assertEq(balanceAfter - balanceBefore, amountToWithdraw);\n}\n```\n\n## Impact\nStakers can avoid validator penalties and slashing events if there's enough liquidity in the deposit pool.\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\nWhen [RioLRTCoordinator::rebalance()](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/main/rio-sherlock-audit/contracts/restaking/RioLRTCoordinator.sol#L121) is called and penalties or slashing events happened during the epoch being settled, distribute the correct amount of penalties to all the `LRTTokens` withdrawn in the current epoch, including the ones that requested the withdrawal before the drop.\n\n\n\n## Discussion\n\n**nevillehuang**\n\nCould be related to #52 and duplicates, both seems to involve front-running/sandwiching rebalance calls. Separated for now for further discussions\n\n\n**solimander**\n\nValid, though need to take some time to consider whether this will be addressed. Could potentially frontrun slashing using any liquidity pool.\n\n**KupiaSecAdmin**\n\nEscalate\n\nThis issue should be considered as Low, because this happens under rare condition and impact is pretty small.\n1. When a staker notices a slashing event, tries to withdraw all of their assets, wait for rebalance delay, another wait for EigenLayer withdrawal period.\n2. The slashing amount is maximum 1ETH, compared to each validator deposits 32ETH, the amount does not affect TVL much.\n3. The penalty amount that staker can avoid is `Staker'sAmount * 1 / TVL`, which looks pretty small in real word experience, thus much less incentive for staker to monitor slashing events and avoid the penalty.\n4. Another point to consider is that once a staker requests a withdrawal, the staker loses earning during the withdrawal period, which makes it less incentive.\n\n\n**sherlock-admin2**\n\n> Escalate\n> \n> This issue should be considered as Low, because this happens under rare condition and impact is pretty small.\n> 1. When a staker notices a slashing event, tries to withdraw all of their assets, wait for rebalance delay, another wait for EigenLayer withdrawal period.\n> 2. The slashing amount is maximum 1ETH, compared to each validator deposits 32ETH, the amount does not affect TVL much.\n> 3. The penalty amount that staker can avoid is `Staker'sAmount * 1 / TVL`, which looks pretty small in real word experience, thus much less incentive for staker to monitor slashing events and avoid the penalty.\n> 4. Another point to consider is that once a staker requests a withdrawal, the staker loses earning during the withdrawal period, which makes it less incentive.\n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**0xmonrel**\n\nEscalate \n\nI will argue that this is a High issue\n\nThe core of this issue is not that TVL is dropped but rather that the slashing will be concentrated among those that don't front-run. \n\nIf 50% front-run then the rest will pay 50% more in slashing penalty. Taken to the worst case scenario, if all but 1 user front-run he will pay for the entire slashing amount. \n\nLook at the duplicate #362 that shows this. \n\nWhen this issue becomes known a new \"meta\" will be at play, everybody will have to front-run otherwise they risk losing all their funds since they will have to cover an outsized part of the slashing penalty. The most likely scenario is that users leave the protocol since there is no assurance they don't lose all their funds if other manage to front-run and they don't. \n\nAs such slashing does not actually have to happen for this to be an issue, when users known that this issue exists the rational decision is to exit the protocol.\n\nI am not sure if this fulfills the \"Inflicts serious non-material losses (doesn't include contract simply not working).\" requirement but I would like the judge to consider the above arguments.\n\n**sherlock-admin2**\n\n> Escalate \n> \n> I will argue that this is a High issue\n> \n> The core of this issue is not that TVL is dropped but rather that the slashing will be concentrated among those that don't front-run. \n> \n> If 50% front-run then the rest will pay 50% more in slashing penalty. Taken to the worst case scenario, if all but 1 user front-run he will pay for the entire slashing amount. \n> \n> Look at the duplicate #362 that shows this. \n> \n> When this issue becomes known a new \"meta\" will be at play, everybody will have to front-run otherwise they risk losing all their funds since they will have to cover an outsized part of the slashing penalty. The most likely scenario is that users leave the protocol since there is no assurance they don't lose all their funds if other manage to front-run and they don't. \n> \n> As such slashing does not actually have to happen for this to be an issue, when users known that this issue exists the rational decision is to exit the protocol.\n> \n> I am not sure if this fulfills the \"Inflicts serious non-material losses (doesn't include contract simply not working).\" requirement but I would like the judge to consider the above arguments.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Czar102**\n\n> When a staker notices a slashing event, tries to withdraw all of their assets, wait for rebalance delay, another wait for EigenLayer withdrawal period.\n\n@KupiaSecAdmin how long is the rebalance delay and the EigenLayer withdrawal period?\n\n> The slashing amount is maximum 1ETH, compared to each validator deposits 32ETH, the amount does not affect TVL much.\n\nThere could be multiple slashings at once, right? So the amount isn't capped.\ncc @nevillehuang @0xmonrel \n\n**KupiaSecAdmin**\n\n@Czar102 - Rebalance delay is max 3 days, EigenLayer's withdrawal period is about 5-7 days.\n\nRegarding the slashing, as it can be shown on beaconscan, usually 1-2(max 3-4) slashing happens in 12 days. And usually one slash amount is around 0.6 ETH, max capped at 1ETH.\nSo they are 1-2 slashing of 1M validators, and in 12 days. Not sure how many validators can Rio could have control of, but the amount is relatively too small to incentivize stakers withdraw all their assets to avoid penalties.\n\n**0xmonrel**\n\nThe point is that if other front-run you lose an unproportional amount if that is 1 ETH or 20 ETH [launchnode](https://blog.lido.fi/post-mortem-launchnodes-slashing-incident/) does not change the fact that the penalty is re-distributed. \n\nConsider this from a user's perspective: They could based on the action of other LRT holders lose all their assets even based on a small % slashing. If something big happens such as the launchnode event the chance is of course increased.\n\nI believe this is a critical issue for an LRT or LST, each user having a guarantee that they only pay a proportional amount is a requirement for it to be a viable product. \n\nAs it stands: If slashed you could lose a proportional amount or up to 100% of your assets, you don't know. It will be a race to front-run.\n\n**KupiaSecAdmin**\n\n@0xmonrel - Talking about launchnode, they had about 5000 validators, so the staked amount is 160,000ETH.\nSaying 20ETH is slashed, it is like 0.0125%.\nStakers withdrawing all assets because they want to avoid 0.01% of their asset does not seem to make much sense.\n\nAlso not quite understanding what you've described above, how front-run can let other LRT holders lose all assets?\n\n**0xmonrel**\n\nAlso the the following argument is not true:\n\n>When a staker notices a slashing event, tries to withdraw all of their assets, wait for rebalance delay, another >wait for EigenLayer withdrawal period.\n\nAt the point when you front-run  withdrawal you have already calculated the exchange rate. Rebalancing does not have to happen before validator balance is updated on EigenLayer. You only need to call withdrawal on Rio which is where `sharesOwed` is calculated.\n\nThis issue actually makes it seem like there are other constraints, that is not true. Look at my duplicate issue #362. You only need request withdrawl to lock in your `sharesOwed`.\n\n**0xmonrel**\n\n> @0xmonrel - Talking about launchnode, they had about 5000 validators, so the staked amount is 160,000ETH. Saying 20ETH is slashed, it is like 0.0125%. Stakers withdrawing all assets because they want to avoid 0.01% of their asset does not seem to make much sense.\n> \n> Also not quite understanding what you've described above, how front-run can let other LRT holders lose all assets?\n\nI linked that to answer Czar question of multiple slashing being possible, which it is. \n\nI will explain again that this issue leads to re-distribution of slashing, that is why you can lose 100%. \n\nSimple Example:\n\n1. 1 ETH slashed\n2. All front-run other than 1 user that has shares worth 1 ETH. shares on EigenLayer=1.\n3. When balance is updated on Eigenlayer it will be 0 ETH since 1-1=0\n4. Last user has lost 100% of assets.\n\nObserve that all withdrawals for users in 2 will be successful at the `sharesOwed` calculated when they request their withdrawal since no deficit is reached.\n\nIts the re-distribution from all that front-run to those that are left that leads to large losses. \n\n**Czar102**\n\nI believe that, given the sole requirement that a larger than usual (still, possibly small) slashing event needs to happen for this strategy of withdrawing to be profitable (lowering losses), the severity is High. It's quite close to being a Medium, though.\n\nPlanning to accept the second escalation and make this a High severity issue.\n\n**nevillehuang**\n\n@Czar102 @solimander @0xmonrel Isn't slashing a less common event given validators are not incentivized to do so?\n\n**solimander**\n\n> Isn't slashing a less common event given validators are not incentivized to do so?\n\nIt's an edge case. Only about 0.0425% of Ethereum validators have been slashed and we're working with professional operators, but it should be handled gracefully regardless.\n\n**0xmonrel**\n\nI think we should also consider that a small amount of slashing and profit for front-runners can still lead to very large loss for those that do not front-run.\n\nHere is a POC of a case where 1 ETH slashing leads to 100% loss for those that do not front-run.\n\n```solidity\n    function test_FrontRunReDistribution() public{\n        \n        uint8[] memory operatorIds = addOperatorDelegators( //add 2 validators to 1 operator\n        reETH.operatorRegistry,\n        address(reETH.rewardDistributor),\n        1,\n        emptyStrategyShareCaps,\n        2\n        );\n        \n        // POC is based on two cohorts, each cohort could include 1 or multiple users. \n        // Cohort 1 is the set of users that front-run. In total they hold 31 ETH\n        // Cohort 2 is the set of cohort that do not front-run. These users hold 1 ETH\n        //\n        // I show that if cohort 1 front-runs cohort 2 after a 1 ETH slashing\n        // cohort 2 loses 100% of their assets, they were supposed to only lose only ~3%\n        \n        uint256 depositAmount = ETH_DEPOSIT_SIZE - address(reETH.depositPool).balance;  \n        reETH.coordinator.depositETH{value: depositAmount}(); \n\n        vm.prank(EOA, EOA);\n        reETH.coordinator.rebalance(ETH_ADDRESS); \n        uint40[] memory validatorIndices = verifyCredentialsForValidators(reETH.operatorRegistry, 1, 1);\n        \n        address delegator = reETH.operatorRegistry.getOperatorDetails(operatorIds[0]).delegator;\n        \n        // Slashing for 1 ETH and 31 ETH front-runs the update\n\n        uint256 withdrawalAmount = 31 ether;\n        reETH.coordinator.requestWithdrawal(ETH_ADDRESS, withdrawalAmount);\n        uint256 firstEpoch = reETH.withdrawalQueue.getCurrentEpoch(ETH_ADDRESS);\n\n        // Slashing is updated on EigenLayer\n        // We manually update balance to 1 to simulate the update. \n        \n        int256 shares = RioLRTOperatorDelegator(payable(delegator)).getEigenPodShares();         \n        \n        IEigenPodManager manager = IEigenPodManager(EIGEN_POD_MANAGER_ADDRESS);\n        stdstore.target(EIGEN_POD_MANAGER_ADDRESS).sig(\"podOwnerShares(address)\").with_key(delegator).checked_write_int(int256(shares-1 ether));\n        int256 loadInt = stdstore.target(EIGEN_POD_MANAGER_ADDRESS).sig(\"podOwnerShares(address)\").with_key(delegator).read_int();\n\n        skip(reETH.coordinator.rebalanceDelay());\n        vm.prank(EOA, EOA);\n        reETH.coordinator.rebalance(ETH_ADDRESS);\n        \n        // Check the availalbe shares left after front-run and slashing update\n\n        shares = RioLRTOperatorDelegator(payable(delegator)).getEigenPodShares();         \n        \n        assertEq(shares,0);\n        \n        console2.log(\"Amount of shares available for cohort 2 after cohort 1 front-runs:\", shares);\n        uint256 expectedShares = 1e18 * 31 /32;\n\n        console2.log(\"Amount of shares expected for cohort 2 after 1 ETH slashing:\", expectedShares);\n\n    }\n\n```\n\n```\nLogs:\n  Amount of shares available for cohort 2 after cohort 1 front-runs: 0\n  Amount of shares expected for cohort 2 after 1 ETH slashing: 968750000000000000\n\n```\n\n**Czar102**\n\nI understand the impact, but, on second thoughts, given that the slashings are very rare and there are multiple safeguards and incentives set to prevent them, it makes more sense to consider this a Medium severity issue.\n\nPlanning to reject the escalation and leave it as is.\n\n**Czar102**\n\nResult:\nMedium\nHas duplicates\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [KupiaSecAdmin](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/190/#issuecomment-2023159432): rejected\n- [0xmonrel](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/190/#issuecomment-2023758478): rejected\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/rio-org/rio-sherlock-audit/pull/13\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/176",
  "Code": [
    {
      "filename": "src/contracts/pods/EigenPod.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.12;\n\nimport \"@openzeppelin-upgrades/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin-upgrades/contracts/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin-upgrades/contracts/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin-upgrades/contracts/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin-upgrades/contracts/utils/math/MathUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../libraries/BeaconChainProofs.sol\";\nimport \"../libraries/BytesLib.sol\";\nimport \"../libraries/Endian.sol\";\n\nimport \"../interfaces/IETHPOSDeposit.sol\";\nimport \"../interfaces/IEigenPodManager.sol\";\nimport \"../interfaces/IEigenPod.sol\";\nimport \"../interfaces/IDelayedWithdrawalRouter.sol\";\nimport \"../interfaces/IPausable.sol\";\n\nimport \"./EigenPodPausingConstants.sol\";\n\n/**\n * @title The implementation contract used for restaking beacon chain ETH on EigenLayer\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n * @notice The main functionalities are:\n * - creating new ETH validators with their withdrawal credentials pointed to this contract\n * - proving from beacon chain state roots that withdrawal credentials are pointed to this contract\n * - proving from beacon chain state roots the balances of ETH validators with their withdrawal credentials\n *   pointed to this contract\n * - updating aggregate balances in the EigenPodManager\n * - withdrawing eth when withdrawals are initiated\n * @notice This EigenPod Beacon Proxy implementation adheres to the current Capella consensus specs\n * @dev Note that all beacon chain balances are stored as gwei within the beacon chain datastructures. We choose\n *   to account balances in terms of gwei in the EigenPod contract and convert to wei when making calls to other contracts\n */\ncontract EigenPod is IEigenPod, Initializable, ReentrancyGuardUpgradeable, EigenPodPausingConstants {\n    using BytesLib for bytes;\n    using SafeERC20 for IERC20;\n    using BeaconChainProofs for *;\n\n    // CONSTANTS + IMMUTABLES\n    // @notice Internal constant used in calculations, since the beacon chain stores balances in Gwei rather than wei\n    uint256 internal constant GWEI_TO_WEI = 1e9;\n\n    /**\n     * @notice Maximum \"staleness\" of a Beacon Chain state root against which `verifyBalanceUpdate` or `verifyWithdrawalCredentials` may be proven.\n     * We can't allow \"stale\" roots to be used for restaking as the validator may have been slashed in a more updated beacon state root. \n     */\n    uint256 internal constant VERIFY_BALANCE_UPDATE_WINDOW_SECONDS = 4.5 hours;\n\n    /// @notice This is the beacon chain deposit contract\n    IETHPOSDeposit public immutable ethPOS;\n\n    /// @notice Contract used for withdrawal routing, to provide an extra \"safety net\" mechanism\n    IDelayedWithdrawalRouter public immutable delayedWithdrawalRouter;\n\n    /// @notice The single EigenPodManager for EigenLayer\n    IEigenPodManager public immutable eigenPodManager;\n\n    ///@notice The maximum amount of ETH, in gwei, a validator can have restaked in the eigenlayer\n    uint64 public immutable MAX_RESTAKED_BALANCE_GWEI_PER_VALIDATOR;\n\n    /// @notice This is the genesis time of the beacon state, to help us calculate conversions between slot and timestamp\n    uint64 public immutable GENESIS_TIME;\n\n    // STORAGE VARIABLES\n    /// @notice The owner of this EigenPod\n    address public podOwner;\n\n    /**\n     * @notice The latest timestamp at which the pod owner withdrew the balance of the pod, via calling `withdrawBeforeRestaking`.\n     * @dev This variable is only updated when the `withdrawBeforeRestaking` function is called, which can only occur before `hasRestaked` is set to true for this pod.\n     * Proofs for this pod are only valid against Beacon Chain state roots corresponding to timestamps after the stored `mostRecentWithdrawalTimestamp`.\n     */\n    uint64 public mostRecentWithdrawalTimestamp;\n\n    /// @notice the amount of execution layer ETH in this contract that is staked in EigenLayer (i.e. withdrawn from the Beacon Chain but not from EigenLayer),\n    uint64 public withdrawableRestakedExecutionLayerGwei;\n\n    /// @notice an indicator of whether or not the podOwner has ever \"fully restaked\" by successfully calling `verifyCorrectWithdrawalCredentials`.\n    bool public hasRestaked;\n\n    /// @notice This is a mapping of validatorPubkeyHash to timestamp to whether or not they have proven a withdrawal for that timestamp\n    mapping(bytes32 => mapping(uint64 => bool)) public provenWithdrawal;\n\n    /// @notice This is a mapping that tracks a validator's information by their pubkey hash\n    mapping(bytes32 => ValidatorInfo) internal _validatorPubkeyHashToInfo;\n\n    /// @notice This variable tracks any ETH deposited into this contract via the `receive` fallback function\n    uint256 public nonBeaconChainETHBalanceWei;\n\n     /// @notice This variable tracks the total amount of partial withdrawals claimed via merkle proofs prior to a switch to ZK proofs for claiming partial withdrawals\n    uint64 public sumOfPartialWithdrawalsClaimedGwei;\n\n    modifier onlyEigenPodManager() {\n        require(msg.sender == address(eigenPodManager), \"EigenPod.onlyEigenPodManager: not eigenPodManager\");\n        _;\n    }\n\n    modifier onlyEigenPodOwner() {\n        require(msg.sender == podOwner, \"EigenPod.onlyEigenPodOwner: not podOwner\");\n        _;\n    }\n\n    modifier hasNeverRestaked() {\n        require(!hasRestaked, \"EigenPod.hasNeverRestaked: restaking is enabled\");\n        _;\n    }\n\n    /// @notice checks that hasRestaked is set to true by calling activateRestaking()\n    modifier hasEnabledRestaking() {\n        require(hasRestaked, \"EigenPod.hasEnabledRestaking: restaking is not enabled\");\n        _;\n    }\n\n    /// @notice Checks that `timestamp` is strictly greater than the value stored in `mostRecentWithdrawalTimestamp`\n    modifier proofIsForValidTimestamp(uint64 timestamp) {\n        require(\n            timestamp > mostRecentWithdrawalTimestamp,\n            \"EigenPod.proofIsForValidTimestamp: beacon chain proof must be for timestamp after mostRecentWithdrawalTimestamp\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Based on 'Pausable' code, but uses the storage of the EigenPodManager instead of this contract. This construction\n     * is necessary for enabling pausing all EigenPods at the same time (due to EigenPods being Beacon Proxies).\n     * Modifier throws if the `indexed`th bit of `_paused` in the EigenPodManager is 1, i.e. if the `index`th pause switch is flipped.\n     */\n    modifier onlyWhenNotPaused(uint8 index) {\n        require(\n            !IPausable(address(eigenPodManager)).paused(index),\n            \"EigenPod.onlyWhenNotPaused: index is paused in EigenPodManager\"\n        );\n        _;\n    }\n\n    constructor(\n        IETHPOSDeposit _ethPOS,\n        IDelayedWithdrawalRouter _delayedWithdrawalRouter,\n        IEigenPodManager _eigenPodManager,\n        uint64 _MAX_RESTAKED_BALANCE_GWEI_PER_VALIDATOR,\n        uint64 _GENESIS_TIME\n    ) {\n        ethPOS = _ethPOS;\n        delayedWithdrawalRouter = _delayedWithdrawalRouter;\n        eigenPodManager = _eigenPodManager;\n        MAX_RESTAKED_BALANCE_GWEI_PER_VALIDATOR = _MAX_RESTAKED_BALANCE_GWEI_PER_VALIDATOR;\n        GENESIS_TIME = _GENESIS_TIME;\n        _disableInitializers();\n    }\n\n    /// @notice Used to initialize the pointers to addresses crucial to the pod's functionality. Called on construction by the EigenPodManager.\n    function initialize(address _podOwner) external initializer {\n        require(_podOwner != address(0), \"EigenPod.initialize: podOwner cannot be zero address\");\n        podOwner = _podOwner;\n        /**\n         * From the M2 deployment onwards, we are requiring that pods deployed are by default enabled with restaking\n         * In prior deployments without proofs, EigenPods could be deployed with restaking disabled so as to allow\n         * simple (proof-free) withdrawals.  However, this is no longer the case.  Thus going forward, all pods are\n         * initialized with hasRestaked set to true.\n         */\n        hasRestaked = true;\n        emit RestakingActivated(podOwner);\n    }\n\n    /// @notice payable fallback function that receives ether deposited to the eigenpods contract\n    receive() external payable {\n        nonBeaconChainETHBalanceWei += msg.value;\n        emit NonBeaconChainETHReceived(msg.value);\n    }\n\n    /**\n     * @notice This function records an update (either increase or decrease) in a validator's balance.\n     * @param oracleTimestamp The oracleTimestamp whose state root the proof will be proven against.\n     *        Must be within `VERIFY_BALANCE_UPDATE_WINDOW_SECONDS` of the current block.\n     * @param validatorIndices is the list of indices of the validators being proven, refer to consensus specs \n     * @param stateRootProof proves a `beaconStateRoot` against a block root fetched from the oracle\n     * @param validatorFieldsProofs proofs against the `beaconStateRoot` for each validator in `validatorFields`\n     * @param validatorFields are the fields of the \"Validator Container\", refer to consensus specs\n     * @dev For more details on the Beacon Chain spec, see: https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#validator\n     */\n    function verifyBalanceUpdates(\n        uint64 oracleTimestamp,\n        uint40[] calldata validatorIndices,\n        BeaconChainProofs.StateRootProof calldata stateRootProof,\n        bytes[] calldata validatorFieldsProofs,\n        bytes32[][] calldata validatorFields\n    ) external onlyWhenNotPaused(PAUSED_EIGENPODS_VERIFY_BALANCE_UPDATE) {\n        require(\n            (validatorIndices.length == validatorFieldsProofs.length) && (validatorFieldsProofs.length == validatorFields.length),\n            \"EigenPod.verifyBalanceUpdates: validatorIndices and proofs must be same length\"\n        );\n\n        // Balance updates should not be \"stale\" (older than VERIFY_BALANCE_UPDATE_WINDOW_SECONDS)\n        require(\n            oracleTimestamp + VERIFY_BALANCE_UPDATE_WINDOW_SECONDS >= block.timestamp,\n            \"EigenPod.verifyBalanceUpdates: specified timestamp is too far in past\"\n        );\n\n        // Verify passed-in beaconStateRoot against oracle-provided block root:\n        BeaconChainProofs.verifyStateRootAgainstLatestBlockRoot({\n            latestBlockRoot: eigenPodManager.getBlockRootAtTimestamp(oracleTimestamp),\n            beaconStateRoot: stateRootProof.beaconStateRoot,\n            stateRootProof: stateRootProof.proof\n        });\n\n        int256 sharesDeltaGwei;\n        for (uint256 i = 0; i < validatorIndices.length; i++) {\n            sharesDeltaGwei += _verifyBalanceUpdate(\n                oracleTimestamp,\n                validatorIndices[i],\n                stateRootProof.beaconStateRoot,\n                validatorFieldsProofs[i], // Use validator fields proof because contains the effective balance\n                validatorFields[i]\n            );\n        }\n        eigenPodManager.recordBeaconChainETHBalanceUpdate(podOwner, sharesDeltaGwei * int256(GWEI_TO_WEI));\n    }\n\n    /**\n     * @notice This function records full and partial withdrawals on behalf of one or more of this EigenPod's validators\n     * @param oracleTimestamp is the timestamp of the oracle slot that the withdrawal is being proven against\n     * @param stateRootProof proves a `beaconStateRoot` against a block root fetched from the oracle\n     * @param withdrawalProofs proves several withdrawal-related values against the `beaconStateRoot`\n     * @param validatorFieldsProofs proves `validatorFields` against the `beaconStateRoot`\n     * @param withdrawalFields are the fields of the withdrawals being proven\n     * @param validatorFields are the fields of the validators being proven\n     */\n    function verifyAndProcessWithdrawals(\n        uint64 oracleTimestamp,\n        BeaconChainProofs.StateRootProof calldata stateRootProof,\n        BeaconChainProofs.WithdrawalProof[] calldata withdrawalProofs,\n        bytes[] calldata validatorFieldsProofs,\n        bytes32[][] calldata validatorFields,\n        bytes32[][] calldata withdrawalFields\n    ) external onlyWhenNotPaused(PAUSED_EIGENPODS_VERIFY_WITHDRAWAL) {\n        require(\n            (validatorFields.length == validatorFieldsProofs.length) &&\n                (validatorFieldsProofs.length == withdrawalProofs.length) &&\n                (withdrawalProofs.length == withdrawalFields.length),\n            \"EigenPod.verifyAndProcessWithdrawals: inputs must be same length\"\n        );\n\n        // Verify passed-in beaconStateRoot against oracle-provided block root:\n        BeaconChainProofs.verifyStateRootAgainstLatestBlockRoot({\n            latestBlockRoot: eigenPodManager.getBlockRootAtTimestamp(oracleTimestamp),\n            beaconStateRoot: stateRootProof.beaconStateRoot,\n            stateRootProof: stateRootProof.proof\n        });\n\n        VerifiedWithdrawal memory withdrawalSummary;\n        for (uint256 i = 0; i < withdrawalFields.length; i++) {\n            VerifiedWithdrawal memory verifiedWithdrawal = _verifyAndProcessWithdrawal(\n                stateRootProof.beaconStateRoot,\n                withdrawalProofs[i],\n                validatorFieldsProofs[i],\n                validatorFields[i],\n                withdrawalFields[i]\n            );\n\n            withdrawalSummary.amountToSendGwei += verifiedWithdrawal.amountToSendGwei;\n            withdrawalSummary.sharesDeltaGwei += verifiedWithdrawal.sharesDeltaGwei;\n        }\n\n        // If any withdrawals are eligible for immediate redemption, send to the pod owner via\n        // DelayedWithdrawalRouter\n        if (withdrawalSummary.amountToSendGwei != 0) {\n            _sendETH_AsDelayedWithdrawal(podOwner, withdrawalSummary.amountToSendGwei * GWEI_TO_WEI);\n        }\n        // If any withdrawals resulted in a change in the pod's shares, update the EigenPodManager\n        if (withdrawalSummary.sharesDeltaGwei != 0) {\n            eigenPodManager.recordBeaconChainETHBalanceUpdate(podOwner, withdrawalSummary.sharesDeltaGwei * int256(GWEI_TO_WEI));\n        }\n    }\n\n    /*******************************************************************************\n                    EXTERNAL FUNCTIONS CALLABLE BY EIGENPOD OWNER\n    *******************************************************************************/\n\n    /**\n     * @notice This function verifies that the withdrawal credentials of validator(s) owned by the podOwner are pointed to\n     * this contract. It also verifies the effective balance  of the validator.  It verifies the provided proof of the ETH validator against the beacon chain state\n     * root, marks the validator as 'active' in EigenLayer, and credits the restaked ETH in Eigenlayer.\n     * @param oracleTimestamp is the Beacon Chain timestamp whose state root the `proof` will be proven against.\n     * @param stateRootProof proves a `beaconStateRoot` against a block root fetched from the oracle\n     * @param validatorIndices is the list of indices of the validators being proven, refer to consensus specs\n     * @param validatorFieldsProofs proofs against the `beaconStateRoot` for each validator in `validatorFields`\n     * @param validatorFields are the fields of the \"Validator Container\", refer to consensus specs\n     * for details: https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#validator\n     */\n    function verifyWithdrawalCredentials(\n        uint64 oracleTimestamp,\n        BeaconChainProofs.StateRootProof calldata stateRootProof,\n        uint40[] calldata validatorIndices,\n        bytes[] calldata validatorFieldsProofs,\n        bytes32[][] calldata validatorFields\n    )\n        external\n        onlyEigenPodOwner\n        onlyWhenNotPaused(PAUSED_EIGENPODS_VERIFY_CREDENTIALS)\n        // check that the provided `oracleTimestamp` is after the `mostRecentWithdrawalTimestamp`\n        proofIsForValidTimestamp(oracleTimestamp)\n        // ensure that caller has previously enabled restaking by calling `activateRestaking()`\n        hasEnabledRestaking\n    {\n        require(\n            (validatorIndices.length == validatorFieldsProofs.length) &&\n                (validatorFieldsProofs.length == validatorFields.length),\n            \"EigenPod.verifyWithdrawalCredentials: validatorIndices and proofs must be same length\"\n        );\n\n        /**\n         * Withdrawal credential proof should not be \"stale\" (older than VERIFY_BALANCE_UPDATE_WINDOW_SECONDS) as we are doing a balance check here\n         * The validator container persists as the state evolves and even after the validator exits. So we can use a more \"fresh\" credential proof within\n         * the VERIFY_BALANCE_UPDATE_WINDOW_SECONDS window, not just the first proof where the validator container is registered in the state.\n         */\n        require(\n            oracleTimestamp + VERIFY_BALANCE_UPDATE_WINDOW_SECONDS >= block.timestamp,\n            \"EigenPod.verifyWithdrawalCredentials: specified timestamp is too far in past\"\n        );\n\n        // Verify passed-in beaconStateRoot against oracle-provided block root:\n        BeaconChainProofs.verifyStateRootAgainstLatestBlockRoot({\n            latestBlockRoot: eigenPodManager.getBlockRootAtTimestamp(oracleTimestamp),\n            beaconStateRoot: stateRootProof.beaconStateRoot,\n            stateRootProof: stateRootProof.proof\n        });\n\n        uint256 totalAmountToBeRestakedWei;\n        for (uint256 i = 0; i < validatorIndices.length; i++) {\n            totalAmountToBeRestakedWei += _verifyWithdrawalCredentials(\n                oracleTimestamp,\n                stateRootProof.beaconStateRoot,\n                validatorIndices[i],\n                validatorFieldsProofs[i],\n                validatorFields[i]\n            );\n        }\n\n        // Update the EigenPodManager on this pod's new balance\n        eigenPodManager.recordBeaconChainETHBalanceUpdate(podOwner, int256(totalAmountToBeRestakedWei));\n    }\n\n    /// @notice Called by the pod owner to withdraw the nonBeaconChainETHBalanceWei\n    function withdrawNonBeaconChainETHBalanceWei(\n        address recipient,\n        uint256 amountToWithdraw\n    ) external onlyEigenPodOwner onlyWhenNotPaused(PAUSED_NON_PROOF_WITHDRAWALS) {\n        require(\n            amountToWithdraw <= nonBeaconChainETHBalanceWei,\n            \"EigenPod.withdrawnonBeaconChainETHBalanceWei: amountToWithdraw is greater than nonBeaconChainETHBalanceWei\"\n        );\n        nonBeaconChainETHBalanceWei -= amountToWithdraw;\n        emit NonBeaconChainETHWithdrawn(recipient, amountToWithdraw);\n        _sendETH_AsDelayedWithdrawal(recipient, amountToWithdraw);\n    }\n\n    /// @notice called by owner of a pod to remove any ERC20s deposited in the pod\n    function recoverTokens(\n        IERC20[] memory tokenList,\n        uint256[] memory amountsToWithdraw,\n        address recipient\n    ) external onlyEigenPodOwner onlyWhenNotPaused(PAUSED_NON_PROOF_WITHDRAWALS) {\n        require(\n            tokenList.length == amountsToWithdraw.length,\n            \"EigenPod.recoverTokens: tokenList and amountsToWithdraw must be same length\"\n        );\n        for (uint256 i = 0; i < tokenList.length; i++) {\n            tokenList[i].safeTransfer(recipient, amountsToWithdraw[i]);\n        }\n    }\n\n    /**\n     * @notice Called by the pod owner to activate restaking by withdrawing\n     * all existing ETH from the pod and preventing further withdrawals via\n     * \"withdrawBeforeRestaking()\"\n     */\n    function activateRestaking()\n        external\n        onlyWhenNotPaused(PAUSED_EIGENPODS_VERIFY_CREDENTIALS)\n        onlyEigenPodOwner\n        hasNeverRestaked\n    {\n        hasRestaked = true;\n        _processWithdrawalBeforeRestaking(podOwner);\n\n        emit RestakingActivated(podOwner);\n    }\n\n    /// @notice Called by the pod owner to withdraw the balance of the pod when `hasRestaked` is set to false\n    function withdrawBeforeRestaking() external onlyEigenPodOwner hasNeverRestaked {\n        _processWithdrawalBeforeRestaking(podOwner);\n    }\n\n    /*******************************************************************************\n                    EXTERNAL FUNCTIONS CALLABLE BY EIGENPODMANAGER\n    *******************************************************************************/\n\n    /// @notice Called by EigenPodManager when the owner wants to create another ETH validator.\n    function stake(\n        bytes calldata pubkey,\n        bytes calldata signature,\n        bytes32 depositDataRoot\n    ) external payable onlyEigenPodManager {\n        // stake on ethpos\n        require(msg.value == 32 ether, \"EigenPod.stake: must initially stake for any validator with 32 ether\");\n        ethPOS.deposit{value: 32 ether}(pubkey, _podWithdrawalCredentials(), signature, depositDataRoot);\n        emit EigenPodStaked(pubkey);\n    }\n\n    /**\n     * @notice Transfers `amountWei` in ether from this contract to the specified `recipient` address\n     * @notice Called by EigenPodManager to withdrawBeaconChainETH that has been added to the EigenPod's balance due to a withdrawal from the beacon chain.\n     * @dev The podOwner must have already proved sufficient withdrawals, so that this pod's `withdrawableRestakedExecutionLayerGwei` exceeds the\n     * `amountWei` input (when converted to GWEI).\n     * @dev Reverts if `amountWei` is not a whole Gwei amount\n     */\n    function withdrawRestakedBeaconChainETH(address recipient, uint256 amountWei) external onlyEigenPodManager {\n        require(amountWei % GWEI_TO_WEI == 0, \"EigenPod.withdrawRestakedBeaconChainETH: amountWei must be a whole Gwei amount\");\n        uint64 amountGwei = uint64(amountWei / GWEI_TO_WEI);\n        require(amountGwei <= withdrawableRestakedExecutionLayerGwei, \"EigenPod.withdrawRestakedBeaconChainETH: amountGwei exceeds withdrawableRestakedExecutionLayerGwei\");\n        withdrawableRestakedExecutionLayerGwei -= amountGwei;\n        emit RestakedBeaconChainETHWithdrawn(recipient, amountWei);\n        // transfer ETH from pod to `recipient` directly\n        _sendETH(recipient, amountWei);\n    }\n\n    /*******************************************************************************\n                                INTERNAL FUNCTIONS\n    *******************************************************************************/\n    /**\n     * @notice internal function that proves an individual validator's withdrawal credentials\n     * @param oracleTimestamp is the timestamp whose state root the `proof` will be proven against.\n     * @param validatorIndex is the index of the validator being proven\n     * @param validatorFieldsProof is the bytes that prove the ETH validator's  withdrawal credentials against a beacon chain state root\n     * @param validatorFields are the fields of the \"Validator Container\", refer to consensus specs\n     */\n    function _verifyWithdrawalCredentials(\n        uint64 oracleTimestamp,\n        bytes32 beaconStateRoot,\n        uint40 validatorIndex,\n        bytes calldata validatorFieldsProof,\n        bytes32[] calldata validatorFields\n    ) internal returns (uint256) {\n        bytes32 validatorPubkeyHash = validatorFields.getPubkeyHash();\n        ValidatorInfo memory validatorInfo = _validatorPubkeyHashToInfo[validatorPubkeyHash];\n\n        // Withdrawal credential proofs should only be processed for \"INACTIVE\" validators\n        require(\n            validatorInfo.status == VALIDATOR_STATUS.INACTIVE,\n            \"EigenPod.verifyCorrectWithdrawalCredentials: Validator must be inactive to prove withdrawal credentials\"\n        );\n\n        // Ensure the `validatorFields` we're proving have the correct withdrawal credentials\n        require(\n            validatorFields.getWithdrawalCredentials() == bytes32(_podWithdrawalCredentials()),\n            \"EigenPod.verifyCorrectWithdrawalCredentials: Proof is not for this EigenPod\"\n        );\n\n        /**\n         * Deserialize the balance field from the Validator struct.  Note that this is the \"effective\" balance of the validator\n         * rather than the current balance.  Effective balance is generated via a hystersis function such that an effective\n         * balance, always a multiple of 1 ETH, will only lower to the next multiple of 1 ETH if the current balance is less\n         * than 0.25 ETH below their current effective balance.  For example, if the effective balance is 31ETH, it only falls to\n         * 30ETH when the true balance falls below 30.75ETH.  Thus in the worst case, the effective balance is overestimating the\n         * actual validator balance by 0.25 ETH. \n         */\n        uint64 validatorEffectiveBalanceGwei = validatorFields.getEffectiveBalanceGwei();\n\n        // Verify passed-in validatorFields against verified beaconStateRoot:\n        BeaconChainProofs.verifyValidatorFields({\n            beaconStateRoot: beaconStateRoot,\n            validatorFields: validatorFields,\n            validatorFieldsProof: validatorFieldsProof,\n            validatorIndex: validatorIndex\n        });\n\n        // Proofs complete - update this validator's status, record its proven balance, and save in state:\n        validatorInfo.status = VALIDATOR_STATUS.ACTIVE;\n        validatorInfo.validatorIndex = validatorIndex;\n        validatorInfo.mostRecentBalanceUpdateTimestamp = oracleTimestamp;\n\n        if (validatorEffectiveBalanceGwei > MAX_RESTAKED_BALANCE_GWEI_PER_VALIDATOR) {\n            validatorInfo.restakedBalanceGwei = MAX_RESTAKED_BALANCE_GWEI_PER_VALIDATOR;\n        } else {\n            validatorInfo.restakedBalanceGwei = validatorEffectiveBalanceGwei;\n        }\n        _validatorPubkeyHashToInfo[validatorPubkeyHash] = validatorInfo;\n\n        emit ValidatorRestaked(validatorIndex);\n        emit ValidatorBalanceUpdated(validatorIndex, oracleTimestamp, validatorInfo.restakedBalanceGwei);\n\n        return validatorInfo.restakedBalanceGwei * GWEI_TO_WEI;\n    }\n\n    function _verifyBalanceUpdate(\n        uint64 oracleTimestamp,\n        uint40 validatorIndex,\n        bytes32 beaconStateRoot,\n        bytes calldata validatorFieldsProof,\n        bytes32[] calldata validatorFields\n    ) internal returns(int256 sharesDeltaGwei){\n        uint64 validatorEffectiveBalanceGwei = validatorFields.getEffectiveBalanceGwei();\n        bytes32 validatorPubkeyHash = validatorFields.getPubkeyHash();\n        ValidatorInfo memory validatorInfo = _validatorPubkeyHashToInfo[validatorPubkeyHash];\n\n        // 1. Balance updates should be more recent than the most recent update\n        require(\n            validatorInfo.mostRecentBalanceUpdateTimestamp < oracleTimestamp,\n            \"EigenPod.verifyBalanceUpdate: Validators balance has already been updated for this timestamp\"\n        );\n\n        // 2. Balance updates should only be performed on \"ACTIVE\" validators\n        require(\n            validatorInfo.status == VALIDATOR_STATUS.ACTIVE, \n            \"EigenPod.verifyBalanceUpdate: Validator not active\"\n        );\n\n        // 3. Balance updates should only be made before a validator is fully withdrawn. \n        // -- A withdrawable validator may not have withdrawn yet, so we require their balance is nonzero\n        // -- A fully withdrawn validator should withdraw via verifyAndProcessWithdrawals\n        if (validatorFields.getWithdrawableEpoch() <= _timestampToEpoch(oracleTimestamp)) {\n            require(\n                validatorEffectiveBalanceGwei > 0,\n                \"EigenPod.verifyBalanceUpdate: validator is withdrawable but has not withdrawn\"\n            );\n        }\n\n        // Verify passed-in validatorFields against verified beaconStateRoot:\n        BeaconChainProofs.verifyValidatorFields({\n            beaconStateRoot: beaconStateRoot,\n            validatorFields: validatorFields,\n            validatorFieldsProof: validatorFieldsProof,\n            validatorIndex: validatorIndex\n        });\n\n        // Done with proofs! Now update the validator's balance and send to the EigenPodManager if needed\n\n        uint64 currentRestakedBalanceGwei = validatorInfo.restakedBalanceGwei;\n        uint64 newRestakedBalanceGwei;\n        if (validatorEffectiveBalanceGwei > MAX_RESTAKED_BALANCE_GWEI_PER_VALIDATOR) {\n            newRestakedBalanceGwei = MAX_RESTAKED_BALANCE_GWEI_PER_VALIDATOR;\n        } else {\n            newRestakedBalanceGwei = validatorEffectiveBalanceGwei;\n        }\n        \n        // Update validator balance and timestamp, and save to state:\n        validatorInfo.restakedBalanceGwei = newRestakedBalanceGwei;\n        validatorInfo.mostRecentBalanceUpdateTimestamp = oracleTimestamp;\n        _validatorPubkeyHashToInfo[validatorPubkeyHash] = validatorInfo;\n\n        // If our new and old balances differ, calculate the delta and send to the EigenPodManager\n        if (newRestakedBalanceGwei != currentRestakedBalanceGwei) {\n            emit ValidatorBalanceUpdated(validatorIndex, oracleTimestamp, newRestakedBalanceGwei);\n\n            sharesDeltaGwei = _calculateSharesDelta({\n                newAmountGwei: newRestakedBalanceGwei,\n                previousAmountGwei: currentRestakedBalanceGwei\n            });\n        }\n    }\n\n    function _verifyAndProcessWithdrawal(\n        bytes32 beaconStateRoot,\n        BeaconChainProofs.WithdrawalProof calldata withdrawalProof,\n        bytes calldata validatorFieldsProof,\n        bytes32[] calldata validatorFields,\n        bytes32[] calldata withdrawalFields\n    )\n        internal\n        /**\n         * Check that the provided timestamp being proven against is after the `mostRecentWithdrawalTimestamp`.\n         * Without this check, there is an edge case where a user proves a past withdrawal for a validator whose funds they already withdrew,\n         * as a way to \"withdraw the same funds twice\" without providing adequate proof.\n         * Note that this check is not made using the oracleTimestamp as in the `verifyWithdrawalCredentials` proof; instead this proof\n         * proof is made for the timestamp of the withdrawal, which may be within SLOTS_PER_HISTORICAL_ROOT slots of the oracleTimestamp.\n         * This difference in modifier usage is OK, since it is still not possible to `verifyAndProcessWithdrawal` against a slot that occurred\n         * *prior* to the proof provided in the `verifyWithdrawalCredentials` function.\n         */\n        proofIsForValidTimestamp(withdrawalProof.getWithdrawalTimestamp())\n        returns (VerifiedWithdrawal memory)\n    {\n        uint64 withdrawalTimestamp = withdrawalProof.getWithdrawalTimestamp();\n        bytes32 validatorPubkeyHash = validatorFields.getPubkeyHash();\n\n        /**\n         * Withdrawal processing should only be performed for \"ACTIVE\" or \"WITHDRAWN\" validators.\n         * (WITHDRAWN is allowed because technically you can deposit to a validator even after it exits)\n         */\n        require(\n            _validatorPubkeyHashToInfo[validatorPubkeyHash].status != VALIDATOR_STATUS.INACTIVE,\n            \"EigenPod._verifyAndProcessWithdrawal: Validator never proven to have withdrawal credentials pointed to this contract\"\n        );\n\n        // Ensure we don't process the same withdrawal twice\n        require(\n            !provenWithdrawal[validatorPubkeyHash][withdrawalTimestamp],\n            \"EigenPod._verifyAndProcessWithdrawal: withdrawal has already been proven for this timestamp\"\n        );\n\n        provenWithdrawal[validatorPubkeyHash][withdrawalTimestamp] = true;\n\n        // Verifying the withdrawal against verified beaconStateRoot:\n        BeaconChainProofs.verifyWithdrawal({\n            beaconStateRoot: beaconStateRoot, \n            withdrawalFields: withdrawalFields, \n            withdrawalProof: withdrawalProof,\n            denebForkTimestamp: eigenPodManager.denebForkTimestamp()\n        });\n\n        uint40 validatorIndex = withdrawalFields.getValidatorIndex();\n\n        // Verify passed-in validatorFields against verified beaconStateRoot:\n        BeaconChainProofs.verifyValidatorFields({\n            beaconStateRoot: beaconStateRoot,\n            validatorFields: validatorFields,\n            validatorFieldsProof: validatorFieldsProof,\n            validatorIndex: validatorIndex\n        });\n\n        uint64 withdrawalAmountGwei = withdrawalFields.getWithdrawalAmountGwei();\n        \n        /**\n         * If the withdrawal's epoch comes after the validator's \"withdrawable epoch,\" we know the validator\n         * has fully withdrawn, and we process this as a full withdrawal.\n         */\n        if (withdrawalProof.getWithdrawalEpoch() >= validatorFields.getWithdrawableEpoch()) {\n            return\n                _processFullWithdrawal(\n                    validatorIndex,\n                    validatorPubkeyHash,\n                    withdrawalTimestamp,"
    }
  ]
}