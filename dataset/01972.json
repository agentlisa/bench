{
  "Title": "H-13: `BalancerPairOracle` can be manipulated using read-only reentrancy",
  "Content": "# Issue H-13: `BalancerPairOracle` can be manipulated using read-only reentrancy \n\nSource: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/141 \n\n## Found by \ncuthalion0x\n## Summary\n\n`BalancerPairOracle.getPrice` makes an external call to `BalancerVault.getPoolTokens` without checking the Balancer Vault's reentrancy guard. As a result, the oracle can be trivially manipulated to liquidate user positions prematurely.\n\n## Vulnerability Detail\n\nIn February, the Balancer team disclosed a read-only reentrancy vulnerability in the Balancer Vault. The detailed disclosure can be found [here](https://forum.balancer.fi/t/reentrancy-vulnerability-scope-expanded/4345). In short, all Balancer pools are susceptible to manipulation of their external queries, and all integrations must now take an extra step of precaution when consuming data. Via reentrancy, an attacker can force token balances and BPT supply to be out of sync, creating very inaccurate BPT prices.\n\nSome protocols, such as Sentiment, remained unaware of this issue for a few months and were later [hacked](https://twitter.com/spreekaway/status/1643313471180644360) as a result.\n\n`BalancerPairOracle.getPrice` makes a price calculation of the form `f(balances) / pool.totalSupply()`, so it is clearly vulnerable to synchronization issues between the two data points. A rough outline of the attack might look like this:\n\n```solidity\nAttackerContract.flashLoan() ->\n    // Borrow lots of tokens and trigger a callback.\n    SomeProtocol.flashLoan() ->\n        AttackerContract.exploit()\n\nAttackerContract.exploit() ->\n    // Join a Balancer Pool using the borrowed tokens and send some ETH along with the call.\n    BalancerVault.joinPool() ->\n        // The Vault will return the excess ETH to the sender, which will reenter this contract.\n        // At this point in the execution, the BPT supply has been updated but the token balances have not.\n        AttackerContract.receive()\n\nAttackerContract.receive() ->\n    // Liquidate a position using the same Balancer Pool as collateral.\n    BlueBerryBank.liquidate() ->\n        // Call to the oracle to check the price.\n        BalancerPairOracle.getPrice() ->\n            // Query the token balances. At this point in the execution, these have not been updated (see above).\n            // So, the balances are still the same as before the start of the large pool join.\n            BalancerVaul.getPoolTokens()\n\n            // Query the BPT supply. At this point in the execution, the supply has already been updated (see above).\n            // So, it includes the latest large pool join, and as such the BPT supply has grown by a large amount.\n            BalancerPool.getTotalSupply()\n\n            // Now the price is computed using both balances and supply, and the result is much smaller than it should be.\n            price = f(balances) / pool.totalSupply()\n\n        // The position is liquidated under false pretenses.\n```\n\n## Impact\n\nUsers choosing Balancer pool positions (such as Aura vaults) as collateral can be prematurely liquidated due to unreliable price data.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/oracle/BalancerPairOracle.sol#L70-L92\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe Balancer team recommends utilizing their [official library](https://github.com/balancer/balancer-v2-monorepo/blob/3ce5138abd8e336f9caf4d651184186fffcd2025/pkg/pool-utils/contracts/lib/VaultReentrancyLib.sol) to safeguard queries such as `Vault.getPoolTokens`. However, the library makes a state-modifying call to the Balancer Vault, so it is not suitable for `view` functions such as `BalancerPairOracle.getPrice`. There are then two options:\n1. Invoke the library somewhere else. Perhaps insert a hook into critical system functions like `BlueBerryBank.liquidate`.\n2. Adapt a slightly different read-only solution that checks the Balancer Vault's reentrancy guard without actually entering.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/69",
  "Code": [
    {
      "filename": "blueberry-core/contracts/oracle/BalancerPairOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"./UsingBaseOracle.sol\";\nimport \"../interfaces/IBaseOracle.sol\";\nimport \"../interfaces/balancer/IBalancerPool.sol\";\nimport \"../interfaces/balancer/IBalancerVault.sol\";\n\n/**\n * @author BlueberryProtocol\n * @title Balancer Pair Oracle\n * @notice Oracle contract which privides price feeds of Balancer Pair tokens\n * @dev Implented Fair Lp Pricing\n *      Ref: https://blog.alphaventuredao.io/fair-lp-token-pricing/\n */\ncontract BalancerPairOracle is UsingBaseOracle, IBaseOracle {\n    constructor(IBaseOracle _base) UsingBaseOracle(_base) {}\n\n    /// @notice Return fair reserve amounts given spot reserves, weights, and fair prices.\n    /// @param resA Reserve of the first asset\n    /// @param resB Reserve of the second asset\n    /// @param wA Weight of the first asset\n    /// @param wB Weight of the second asset\n    /// @param pxA Fair price of the first asset\n    /// @param pxB Fair price of the second asset\n    function computeFairReserves(\n        uint256 resA,\n        uint256 resB,\n        uint256 wA,\n        uint256 wB,\n        uint256 pxA,\n        uint256 pxB\n    ) internal pure returns (uint256 fairResA, uint256 fairResB) {\n        // NOTE: wA + wB = 1 (normalize weights)\n        // constant product = resA^wA * resB^wB\n        // constraints:\n        // - fairResA^wA * fairResB^wB = constant product\n        // - fairResA * pxA / wA = fairResB * pxB / wB\n        // Solving equations:\n        // --> fairResA^wA * (fairResA * (pxA * wB) / (wA * pxB))^wB = constant product\n        // --> fairResA / r1^wB = constant product\n        // --> fairResA = resA^wA * resB^wB * r1^wB\n        // --> fairResA = resA * (resB/resA)^wB * r1^wB = resA * (r1/r0)^wB\n        uint256 r0 = resA / resB;\n        uint256 r1 = (wA * pxB) / (wB * pxA);\n        // fairResA = resA * (r1 / r0) ^ wB\n        // fairResB = resB * (r0 / r1) ^ wA\n        if (r0 > r1) {\n            uint256 ratio = r1 / r0;\n            fairResA = resA * (ratio ** wB);\n            fairResB = resB / (ratio ** wA);\n        } else {\n            uint256 ratio = r0 / r1;\n            fairResA = resA / (ratio ** wB);\n            fairResB = resB * (ratio ** wA);\n        }\n    }\n\n    /// @notice Return the USD value of given Curve Lp, with 18 decimals of precision.\n    /// @param token The ERC-20 token to check the value.\n    function getPrice(address token) external view override returns (uint256) {\n        IBalancerPool pool = IBalancerPool(token);\n        IBalancerVault vault = IBalancerVault(pool.getVault());\n        (address[] memory tokens, uint256[] memory balances, ) = vault\n            .getPoolTokens(pool.getPoolId());\n        uint256[] memory weights = pool.getNormalizedWeights();\n        require(tokens.length == 2, \"num tokens must be 2\");\n        address tokenA = tokens[0];\n        address tokenB = tokens[1];\n        uint256 price0 = base.getPrice(tokenA);\n        uint256 price1 = base.getPrice(tokenB);\n        (uint256 fairResA, uint256 fairResB) = computeFairReserves(\n            balances[0],\n            balances[1],\n            weights[0],\n            weights[1],\n            price0,\n            price1\n        );\n        // use fairReserveA and fairReserveB to compute LP token price\n        // LP price = (fairResA * pxA + fairResB * pxB) / totalLPSupply\n        return (fairResA * price0 + fairResB * price1) / pool.totalSupply();\n    }\n}"
    }
  ]
}