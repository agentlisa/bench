{
  "Title": "[M-06] Liquidation condition should not factor the liquidation reward into the premiums",
  "Content": "\nThe premiums used to determine the liquidation condition have the liquidation reward already discounted, potentially causing a lien to be considered underwater while technically it is not.\n\n### Impact\n\nPositions in Particle LAMM can be liquidated if the owed tokens exceed the available premiums in the lien. Liquidators are incentivized with a reward to keep the protocol sane. This can be found in the implementation of `liquidatePosition()`:\n\n<https://github.com/code-423n4/2023-12-particle/blob/a3af40839b24aa13f5764d4f84933dbfa8bc8134/contracts/protocol/ParticlePositionManager.sol#L348-L368>\n\n```solidity\n348:         // calculate liquidation reward\n349:         liquidateCache.liquidationRewardFrom =\n350:             ((closeCache.tokenFromPremium) * LIQUIDATION_REWARD_FACTOR) /\n351:             uint128(Base.BASIS_POINT);\n352:         liquidateCache.liquidationRewardTo =\n353:             ((closeCache.tokenToPremium) * LIQUIDATION_REWARD_FACTOR) /\n354:             uint128(Base.BASIS_POINT);\n355:         closeCache.tokenFromPremium -= liquidateCache.liquidationRewardFrom;\n356:         closeCache.tokenToPremium -= liquidateCache.liquidationRewardTo;\n357: \n358:         // check for liquidation condition\n359:         ///@dev the liquidation condition is that\n360:         ///     (EITHER premium is not enough) OR (cutOffTime > startTime AND currentTime > startTime + LOAN_TERM)\n361:         if (\n362:             !((closeCache.tokenFromPremium < liquidateCache.tokenFromOwed ||\n363:                 closeCache.tokenToPremium < liquidateCache.tokenToOwed) ||\n364:                 (lien.startTime < lps.getRenewalCutoffTime(lien.tokenId) &&\n365:                     lien.startTime + LOAN_TERM < block.timestamp))\n366:         ) {\n367:             revert Errors.LiquidationNotMet();\n368:         }\n```\n\nThe liquidation rewards are calculated as a portion of the premiums, and discounted from these to keep them reserved from any further calculation that may involve `tokenFromPremium` or `tokenToPremium`. However, these are discounted **before** checking the liquidation condition.\n\nThe values used to check the conditions at lines 362 and 363 already incorporate the discounted rewards. This implies that the borrower might still maintain a healthy position if it weren't for the subtracted amounts. The lien could be liquidated even if it's not technically underwater.\n\n### Recommendation\n\nSubtract the liquidation rewards from premiums after checking the liquidation condition.\n\n```diff\n-       // calculate liquidation reward\n-       liquidateCache.liquidationRewardFrom =\n-           ((closeCache.tokenFromPremium) * LIQUIDATION_REWARD_FACTOR) /\n-           uint128(Base.BASIS_POINT);\n-       liquidateCache.liquidationRewardTo =\n-           ((closeCache.tokenToPremium) * LIQUIDATION_REWARD_FACTOR) /\n-           uint128(Base.BASIS_POINT);\n-       closeCache.tokenFromPremium -= liquidateCache.liquidationRewardFrom;\n-       closeCache.tokenToPremium -= liquidateCache.liquidationRewardTo;\n\n        // check for liquidation condition\n        ///@dev the liquidation condition is that\n        ///     (EITHER premium is not enough) OR (cutOffTime > startTime AND currentTime > startTime + LOAN_TERM)\n        if (\n            !((closeCache.tokenFromPremium < liquidateCache.tokenFromOwed ||\n                closeCache.tokenToPremium < liquidateCache.tokenToOwed) ||\n                (lien.startTime < lps.getRenewalCutoffTime(lien.tokenId) &&\n                    lien.startTime + LOAN_TERM < block.timestamp))\n        ) {\n            revert Errors.LiquidationNotMet();\n        }\n        \n+       // calculate liquidation reward\n+       liquidateCache.liquidationRewardFrom =\n+           ((closeCache.tokenFromPremium) * LIQUIDATION_REWARD_FACTOR) /\n+           uint128(Base.BASIS_POINT);\n+       liquidateCache.liquidationRewardTo =\n+           ((closeCache.tokenToPremium) * LIQUIDATION_REWARD_FACTOR) /\n+           uint128(Base.BASIS_POINT);\n+       closeCache.tokenFromPremium -= liquidateCache.liquidationRewardFrom;\n+       closeCache.tokenToPremium -= liquidateCache.liquidationRewardTo;\n```\n\n**[wukong-particle commented](https://github.com/code-423n4/2023-12-particle-findings/issues/51#issuecomment-1868221110):**\n > Hold on. The idea for liquidation is that after paying liquidator, the amount going back to the LP should meet what is rightfully owed to the LP. \n> \n> Let's imagine we just meet the liquidation condition, i.e.\n> \n> ```\n> closeCache.tokenFromPremium = liquidateCache.tokenFromOwed || \n> closeCache.tokenToPremium = liquidateCache.tokenToOwed\n> ```\n> \n>  If we get the liquidation reward *after* checking the condition, then it means after deducting the liquidation reward from `tokenFromPremium` and `tokenToPremium`, there isn't enough left to pay for `tokenFromOwed` and `tokenToOwed`. \n> \n> So yeah, I think it's by design that some amount is going to liquidator, and then the left should be enough to meet the LP requirement (liquidation condition).\n\n\n**[adriro (Warden) commented](https://github.com/code-423n4/2023-12-particle-findings/issues/51#issuecomment-1868295056):**\n > > If we get the liquidation reward _after_ checking the condition, then it means after deducting the liquidation reward from `tokenFromPremium` and `tokenToPremium`, there isn't enough left to pay for `tokenFromOwed` and `tokenToOwed`.\n> \n> I understand the argument, but you can never guarantee that premiums will be enough to pay for owed fees. I believe that is why those capped here https://github.com/code-423n4/2023-12-particle/blob/a3af40839b24aa13f5764d4f84933dbfa8bc8134/contracts/protocol/ParticlePositionManager.sol#L476-L477\n> \n\n**[wukong-particle (Particle) disputed and commented](https://github.com/code-423n4/2023-12-particle-findings/issues/51#issuecomment-1868300718):**\n > You are right about the cap. Just want to follow up with the reward before/after liquidation condition -- \n> \n> If it's after, then we *always* pay LP an amount less than the `tokenOwed`. This is because at the very beginning of liquidation condition being met, amount to LP is already deducted from 100% `tokenOwed`. Hence we designed it to do the liquidation reward before the condition check.\n\n**[0xleastwood (Judge) commented](https://github.com/code-423n4/2023-12-particle-findings/issues/51#issuecomment-1868379894):**\n > It seems that this might be by design but I will leave it up to the warden to follow-up with the sponsor. @adriro \n\n**[said (Warden) commented](https://github.com/code-423n4/2023-12-particle-findings/issues/51#issuecomment-1868492088):**\n > It should also consider the argument inside the duplicate issue [\\#14](https://github.com/code-423n4/2023-12-particle-findings/issues/14), that the `LIQUIDATION_REWARD_FACTOR` can be changed by the admin, which can immediately affect the health condition of users' positions.\n\n**[0xleastwood (Judge) decreased the severity to Medium](https://github.com/code-423n4/2023-12-particle-findings/issues/51#issuecomment-1869476678)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-12-particle",
  "Code": [
    {
      "filename": "contracts/protocol/ParticlePositionManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {IERC721Receiver} from \"../../lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {Multicall} from \"../../lib/openzeppelin-contracts/contracts/utils/Multicall.sol\";\nimport {ReentrancyGuard} from \"../../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport {Ownable2StepUpgradeable} from \"../../lib/openzeppelin-contracts-upgradeable/contracts/access/Ownable2StepUpgradeable.sol\";\nimport {UUPSUpgradeable} from \"../../lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/UUPSUpgradeable.sol\";\nimport {TransferHelper} from \"../../lib/v3-periphery/contracts/libraries/TransferHelper.sol\";\n\nimport {IParticlePositionManager} from \"../interfaces/IParticlePositionManager.sol\";\nimport {Base} from \"../libraries/Base.sol\";\nimport {LiquidityPosition} from \"../libraries/LiquidityPosition.sol\";\nimport {Lien} from \"../libraries/Lien.sol\";\nimport {SwapPosition} from \"../libraries/SwapPosition.sol\";\nimport {DataStruct, DataCache} from \"../libraries/Structs.sol\";\nimport {Errors} from \"../libraries/Errors.sol\";\n\ncontract ParticlePositionManager is\n    IParticlePositionManager,\n    Ownable2StepUpgradeable,\n    UUPSUpgradeable,\n    IERC721Receiver,\n    ReentrancyGuard,\n    Multicall\n{\n    using LiquidityPosition for mapping(uint256 => LiquidityPosition.Info);\n    using Lien for mapping(bytes32 => Lien.Info);\n    using SwapPosition for mapping(bytes32 => SwapPosition.Info);\n\n    /* Constants */\n    uint256 private constant _TREASURY_RATE_MAX = 500_000;\n    uint256 private constant _FEE_FACTOR_MAX = 1_000;\n    uint128 private constant _LIQUIDATION_REWARD_FACTOR_MAX = 100_000;\n    uint256 private constant _LOAN_TERM_MAX = 30 days;\n\n    /* Variables */\n    uint96 private _nextRecordId; ///@dev used for both lien and swap\n    uint256 private _treasuryRate;\n    // solhint-disable var-name-mixedcase\n    address public DEX_AGGREGATOR;\n    uint256 public FEE_FACTOR;\n    uint128 public LIQUIDATION_REWARD_FACTOR;\n    uint256 public LOAN_TERM;\n    // solhint-enable var-name-mixedcase\n\n    /* Storage */\n    mapping(uint256 => LiquidityPosition.Info) public lps; ///@dev tokenId => liquidity position\n    mapping(bytes32 => Lien.Info) public liens; ///@dev (address, lienId) => lien\n    mapping(address => uint256) private _treasury; ///@dev address => amount\n\n    // required by openzeppelin UUPS module\n    // solhint-disable-next-line no-empty-blocks\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address dexAggregator,\n        uint256 feeFactor,\n        uint128 liquidationRewardFactor,\n        uint256 loanTerm,\n        uint256 treasuryRate\n    ) external initializer {\n        __UUPSUpgradeable_init();\n        __Ownable_init();\n        DEX_AGGREGATOR = dexAggregator;\n        FEE_FACTOR = feeFactor;\n        LIQUIDATION_REWARD_FACTOR = liquidationRewardFactor;\n        LOAN_TERM = loanTerm;\n        _treasuryRate = treasuryRate;\n    }\n\n    /*==============================================================\n                        Liquidity Provision Logic\n    ==============================================================*/\n\n    /// @inheritdoc IParticlePositionManager\n    function mint(\n        DataStruct.MintParams calldata params\n    )\n        external\n        override\n        nonReentrant\n        returns (uint256 tokenId, uint128 liquidity, uint256 amount0Minted, uint256 amount1Minted)\n    {\n        (tokenId, liquidity, amount0Minted, amount1Minted) = lps.mint(params);\n    }\n\n    /**\n     * @notice Receiver function upon ERC721 LP position transfer\n     * @dev LP must use safeTransferFrom to trigger onERC721Received\n     * @param from the address which previously owned the NFT\n     * @param tokenId the NFT identifier which is being transferred\n     */\n    function onERC721Received(\n        address,\n        address from,\n        uint256 tokenId,\n        bytes calldata\n    ) external override returns (bytes4) {\n        if (msg.sender == Base.UNI_POSITION_MANAGER_ADDR) {\n            // matched with Uniswap v3 position NFTs\n            lps[tokenId] = LiquidityPosition.Info({owner: from, renewalCutoffTime: 0, token0Owed: 0, token1Owed: 0});\n            (, , , , , , , uint128 liquidity, , , , ) = Base.UNI_POSITION_MANAGER.positions(tokenId);\n            emit LiquidityPosition.SupplyLiquidity(tokenId, from, liquidity);\n        }\n        return this.onERC721Received.selector;\n    }\n\n    /*==============================================================\n                       Liquidity Management Logic\n    ==============================================================*/\n\n    /// @inheritdoc IParticlePositionManager\n    function increaseLiquidity(\n        uint256 tokenId,\n        uint256 amount0,\n        uint256 amount1\n    ) external override nonReentrant returns (uint128 liquidity, uint256 amount0Added, uint256 amount1Added) {\n        (liquidity, amount0Added, amount1Added) = lps.increaseLiquidity(tokenId, amount0, amount1);\n    }\n\n    /// @inheritdoc IParticlePositionManager\n    function decreaseLiquidity(\n        uint256 tokenId,\n        uint128 liquidity\n    ) external override nonReentrant returns (uint256 amount0Decreased, uint256 amount1Decreased) {\n        (amount0Decreased, amount1Decreased) = lps.decreaseLiquidity(tokenId, liquidity);\n    }\n\n    /// @inheritdoc IParticlePositionManager\n    function collectLiquidity(\n        uint256 tokenId\n    ) external override nonReentrant returns (uint256 amount0Collected, uint256 amount1Collected) {\n        (amount0Collected, amount1Collected) = lps.collectLiquidity(tokenId);\n    }\n\n    /// @inheritdoc IParticlePositionManager\n    function reclaimLiquidity(uint256 tokenId) external override nonReentrant {\n        lps.reclaimLiquidity(tokenId);\n    }\n\n    /*=============================================================\n                             Open Position\n    ==============================================================*/\n\n    /// @inheritdoc IParticlePositionManager\n    function openPosition(\n        DataStruct.OpenPositionParams calldata params\n    ) public override nonReentrant returns (uint96 lienId, uint256 collateralTo) {\n        if (params.liquidity == 0) revert Errors.InsufficientBorrow();\n\n        // local cache to avoid stack too deep\n        DataCache.OpenPositionCache memory cache;\n\n        // prepare data for swap\n        (\n            cache.tokenFrom,\n            cache.tokenTo,\n            cache.feeGrowthInside0LastX128,\n            cache.feeGrowthInside1LastX128,\n            cache.collateralFrom,\n            collateralTo\n        ) = Base.prepareLeverage(params.tokenId, params.liquidity, params.zeroForOne);\n\n        // decrease liquidity from LP position, pull the amount to this contract\n        (cache.amountFromBorrowed, cache.amountToBorrowed) = LiquidityPosition.decreaseLiquidity(\n            params.tokenId,\n            params.liquidity\n        );\n        LiquidityPosition.collectLiquidity(\n            params.tokenId,\n            uint128(cache.amountFromBorrowed),\n            uint128(cache.amountToBorrowed),\n            address(this)\n        );\n        if (!params.zeroForOne)\n            (cache.amountFromBorrowed, cache.amountToBorrowed) = (cache.amountToBorrowed, cache.amountFromBorrowed);\n\n        // transfer in enough collateral\n        if (params.marginFrom > 0) {\n            TransferHelper.safeTransferFrom(cache.tokenFrom, msg.sender, address(this), params.marginFrom);\n        }\n        if (params.marginTo > 0) {\n            TransferHelper.safeTransferFrom(cache.tokenTo, msg.sender, address(this), params.marginTo);\n        }\n\n        // pay for fee\n        if (FEE_FACTOR > 0) {\n            cache.feeAmount = ((params.marginFrom + cache.amountFromBorrowed) * FEE_FACTOR) / Base.BASIS_POINT;\n            cache.treasuryAmount = (cache.feeAmount * _treasuryRate) / Base.BASIS_POINT;\n            _treasury[cache.tokenFrom] += cache.treasuryAmount;\n            if (params.zeroForOne) {\n                lps.addTokensOwed(params.tokenId, uint128(cache.feeAmount - cache.treasuryAmount), 0);\n            } else {\n                lps.addTokensOwed(params.tokenId, 0, uint128(cache.feeAmount - cache.treasuryAmount));\n            }\n        }\n\n        // cannot swap more than available amount\n        if (params.amountSwap > params.marginFrom + cache.amountFromBorrowed - cache.feeAmount)\n            revert Errors.OverSpend();\n\n        // swap to meet the collateral requirement\n        (cache.amountSpent, cache.amountReceived) = Base.swap(\n            cache.tokenFrom,\n            cache.tokenTo,\n            params.amountSwap,\n            collateralTo - cache.amountToBorrowed - params.marginTo, // amount needed to meet requirement\n            DEX_AGGREGATOR,\n            params.data\n        );\n\n        // leftover amounts from the collateral are now premiums, and ensure enough premium is stored\n        if (params.zeroForOne) {\n            cache.token0PremiumPortion = Base.uint256ToUint24(\n                ((params.marginFrom + cache.amountFromBorrowed - cache.feeAmount - cache.amountSpent) *\n                    Base.BASIS_POINT) / cache.collateralFrom\n            );\n            cache.token1PremiumPortion = Base.uint256ToUint24(\n                ((cache.amountReceived + cache.amountToBorrowed + params.marginTo - collateralTo) * Base.BASIS_POINT) /\n                    collateralTo\n            );\n            if (\n                cache.token0PremiumPortion < params.tokenFromPremiumPortionMin ||\n                cache.token1PremiumPortion < params.tokenToPremiumPortionMin\n            ) revert Errors.InsufficientPremium();\n        } else {\n            cache.token1PremiumPortion = Base.uint256ToUint24(\n                ((params.marginFrom + cache.amountFromBorrowed - cache.feeAmount - cache.amountSpent) *\n                    Base.BASIS_POINT) / cache.collateralFrom\n            );\n            cache.token0PremiumPortion = Base.uint256ToUint24(\n                ((cache.amountReceived + cache.amountToBorrowed + params.marginTo - collateralTo) * Base.BASIS_POINT) /\n                    collateralTo\n            );\n            if (\n                cache.token0PremiumPortion < params.tokenToPremiumPortionMin ||\n                cache.token1PremiumPortion < params.tokenFromPremiumPortionMin\n            ) revert Errors.InsufficientPremium();\n        }\n\n        // create a new lien\n        liens[keccak256(abi.encodePacked(msg.sender, lienId = _nextRecordId++))] = Lien.Info({\n            tokenId: uint40(params.tokenId),\n            liquidity: params.liquidity,\n            token0PremiumPortion: cache.token0PremiumPortion,\n            token1PremiumPortion: cache.token1PremiumPortion,\n            startTime: uint32(block.timestamp),\n            feeGrowthInside0LastX128: cache.feeGrowthInside0LastX128,\n            feeGrowthInside1LastX128: cache.feeGrowthInside1LastX128,\n            zeroForOne: params.zeroForOne\n        });\n\n        emit OpenPosition(msg.sender, lienId, collateralTo);\n    }\n\n    /*=============================================================\n                             Close Position\n    ==============================================================*/\n\n    /// @inheritdoc IParticlePositionManager\n    function closePosition(DataStruct.ClosePositionParams calldata params) external override nonReentrant {\n        bytes32 lienKey = keccak256(abi.encodePacked(msg.sender, params.lienId));\n        Lien.Info memory lien = liens.getInfo(lienKey);\n\n        // check lien is valid\n        if (lien.liquidity == 0) revert Errors.RecordEmpty();\n\n        // delete lien from storage\n        delete liens[lienKey];\n\n        // local cache to avoid stack too deep\n        DataCache.ClosePositionCache memory cache;\n\n        // prepare data for swap back\n        ///@dev the token/collateralFrom and token/collateralTo are swapped compared to openPosition\n        (cache.tokenTo, cache.tokenFrom, , , cache.collateralTo, cache.collateralFrom) = Base.prepareLeverage(\n            lien.tokenId,\n            lien.liquidity,\n            lien.zeroForOne\n        );\n\n        // get the amount of premium in the lien\n        if (lien.zeroForOne) {\n            (cache.tokenToPremium, cache.tokenFromPremium) = Base.getPremium(\n                cache.collateralTo,\n                cache.collateralFrom,\n                lien.token0PremiumPortion,\n                lien.token1PremiumPortion\n            );\n        } else {\n            (cache.tokenFromPremium, cache.tokenToPremium) = Base.getPremium(\n                cache.collateralFrom,\n                cache.collateralTo,\n                lien.token0PremiumPortion,\n                lien.token1PremiumPortion\n            );\n        }\n\n        // execute actual position closing\n        _closePosition(params, cache, lien, msg.sender);\n\n        emit ClosePosition(msg.sender, lien.tokenId, cache.amountFromAdd, cache.amountToAdd);\n    }\n\n    /// @inheritdoc IParticlePositionManager\n    function liquidatePosition(\n        DataStruct.ClosePositionParams calldata params,\n        address borrower\n    ) external override nonReentrant {\n        bytes32 lienKey = keccak256(abi.encodePacked(borrower, params.lienId));\n        Lien.Info memory lien = liens.getInfo(lienKey);\n\n        // check lien is valid\n        if (lien.liquidity == 0) revert Errors.RecordEmpty();\n\n        // local cache to avoid stack too deep\n        DataCache.ClosePositionCache memory closeCache;\n        DataCache.LiquidatePositionCache memory liquidateCache;\n\n        // get liquidation parameters\n        ///@dev calculate premium outside of _closePosition to allow liquidatePosition to take reward from premium\n        (\n            closeCache.tokenFrom,\n            closeCache.tokenTo,\n            liquidateCache.tokenFromOwed,\n            liquidateCache.tokenToOwed,\n            closeCache.tokenFromPremium,\n            closeCache.tokenToPremium,\n            closeCache.collateralFrom,\n\n        ) = Base.getOwedInfoConverted(\n            DataStruct.OwedInfoParams({\n                tokenId: lien.tokenId,\n                liquidity: lien.liquidity,\n                feeGrowthInside0LastX128: lien.feeGrowthInside0LastX128,\n                feeGrowthInside1LastX128: lien.feeGrowthInside1LastX128,\n                token0PremiumPortion: lien.token0PremiumPortion,\n                token1PremiumPortion: lien.token1PremiumPortion\n            }),\n            lien.zeroForOne\n        );\n\n        // calculate liquidation reward\n        liquidateCache.liquidationRewardFrom =\n            ((closeCache.tokenFromPremium) * LIQUIDATION_REWARD_FACTOR) /\n            uint128(Base.BASIS_POINT);\n        liquidateCache.liquidationRewardTo =\n            ((closeCache.tokenToPremium) * LIQUIDATION_REWARD_FACTOR) /\n            uint128(Base.BASIS_POINT);\n        closeCache.tokenFromPremium -= liquidateCache.liquidationRewardFrom;\n        closeCache.tokenToPremium -= liquidateCache.liquidationRewardTo;\n\n        // check for liquidation condition\n        ///@dev the liquidation condition is that\n        ///     (EITHER premium is not enough) OR (cutOffTime > startTime AND currentTime > startTime + LOAN_TERM)\n        if (\n            !((closeCache.tokenFromPremium < liquidateCache.tokenFromOwed ||\n                closeCache.tokenToPremium < liquidateCache.tokenToOwed) ||\n                (lien.startTime < lps.getRenewalCutoffTime(lien.tokenId) &&\n                    lien.startTime + LOAN_TERM < block.timestamp))\n        ) {\n            revert Errors.LiquidationNotMet();\n        }\n\n        // delete lien from storage\n        delete liens[lienKey];\n\n        // execute actual position closing\n        _closePosition(params, closeCache, lien, borrower);\n\n        // reward liquidator\n        TransferHelper.safeTransfer(closeCache.tokenFrom, msg.sender, liquidateCache.liquidationRewardFrom);\n        TransferHelper.safeTransfer(closeCache.tokenTo, msg.sender, liquidateCache.liquidationRewardTo);\n\n        emit LiquidatePosition(borrower, lien.tokenId, closeCache.amountFromAdd, closeCache.amountToAdd);\n    }\n\n    /**\n     * @notice Internal function to close a position\n     * @dev Caller must ensure either the msg.sender is borrower or liquidation condition is met\n     * @param params close position parameters\n     * @param cache local cache to avoid stack too deep\n     * @param lien lien info\n     * @param borrower borrower address\n     */\n    function _closePosition(\n        DataStruct.ClosePositionParams calldata params,\n        DataCache.ClosePositionCache memory cache,\n        Lien.Info memory lien,\n        address borrower\n    ) internal {\n        // optimistically use the input numbers to swap for repay\n        /// @dev amountSwap overspend will be caught by refundWithCheck step in below\n        (cache.amountSpent, cache.amountReceived) = Base.swap(\n            cache.tokenFrom,\n            cache.tokenTo,\n            params.amountSwap,\n            0, /// @dev we check cache.amountReceived is sufficient to repay LP in below\n            DEX_AGGREGATOR,\n            params.data\n        );\n\n        // based on borrowed liquidity, compute the required return amount\n        /// @dev the from-to swapping direction is reverted compared to openPosition\n        (cache.amountToAdd, cache.amountFromAdd) = Base.getRequiredRepay(lien.liquidity, lien.tokenId);\n        if (!lien.zeroForOne) (cache.amountToAdd, cache.amountFromAdd) = (cache.amountFromAdd, cache.amountToAdd);\n\n        // the liquidity to add must be no less than the available amount\n        /// @dev the max available amount contains the tokensOwed, will have another check in below at refundWithCheck\n        if (\n            cache.amountFromAdd > cache.collateralFrom + cache.tokenFromPremium - cache.amountSpent ||\n            cache.amountToAdd > cache.amountReceived + cache.tokenToPremium\n        ) {\n            revert Errors.InsufficientRepay();\n        }\n\n        // add liquidity back to borrower\n        if (lien.zeroForOne) {\n            (cache.liquidityAdded, cache.amountToAdd, cache.amountFromAdd) = LiquidityPosition.increaseLiquidity(\n                cache.tokenTo,\n                cache.tokenFrom,\n                lien.tokenId,\n                cache.amountToAdd,\n                cache.amountFromAdd\n            );\n        } else {\n            (cache.liquidityAdded, cache.amountFromAdd, cache.amountToAdd) = LiquidityPosition.increaseLiquidity(\n                cache.tokenFrom,\n                cache.tokenTo,\n                lien.tokenId,\n                cache.amountFromAdd,\n                cache.amountToAdd\n            );\n        }\n\n        // obtain the position's latest FeeGrowthInside after increaseLiquidity\n        (, , , , , , , , cache.feeGrowthInside0LastX128, cache.feeGrowthInside1LastX128, , ) = Base\n            .UNI_POSITION_MANAGER\n            .positions(lien.tokenId);\n\n        // caculate the amounts owed since last fee collection during the borrowing period\n        (cache.token0Owed, cache.token1Owed) = Base.getOwedFee(\n            cache.feeGrowthInside0LastX128,\n            cache.feeGrowthInside1LastX128,\n            lien.feeGrowthInside0LastX128,\n            lien.feeGrowthInside1LastX128,\n            lien.liquidity\n        );\n\n        // calculate the the amounts owed to LP up to the premium in the lien\n        // must ensure enough amount is left to pay for interest first, then send gains and fund left to borrower\n        ///@dev refundWithCheck ensures actual cannot be more than expected, since amount owed to LP is in actual,\n        ///     it ensures (1) on the collateralFrom part of refund, tokenOwed is covered, and (2) on the amountReceived\n        ///      part, received is no less than liquidity addback + token owed.\n        if (lien.zeroForOne) {\n            cache.token0Owed = cache.token0Owed < cache.tokenToPremium ? cache.token0Owed : cache.tokenToPremium;\n            cache.token1Owed = cache.token1Owed < cache.tokenFromPremium ? cache.token1Owed : cache.tokenFromPremium;\n            Base.refundWithCheck(\n                borrower,\n                cache.tokenFrom,\n                cache.collateralFrom + cache.tokenFromPremium,\n                cache.amountSpent + cache.amountFromAdd + cache.token1Owed\n            );\n            Base.refundWithCheck(\n                borrower,\n                cache.tokenTo,\n                cache.amountReceived + cache.tokenToPremium,\n                cache.amountToAdd + cache.token0Owed\n            );\n        } else {\n            cache.token0Owed = cache.token0Owed < cache.tokenFromPremium ? cache.token0Owed : cache.tokenFromPremium;\n            cache.token1Owed = cache.token1Owed < cache.tokenToPremium ? cache.token1Owed : cache.tokenToPremium;\n            Base.refundWithCheck(\n                borrower,\n                cache.tokenFrom,\n                cache.collateralFrom + cache.tokenFromPremium,\n                cache.amountSpent + cache.amountFromAdd + cache.token0Owed\n            );\n            Base.refundWithCheck(\n                borrower,\n                cache.tokenTo,\n                cache.amountReceived + cache.tokenToPremium,\n                cache.amountToAdd + cache.token1Owed\n            );\n        }\n\n        // pay for interest\n        lps.addTokensOwed(lien.tokenId, cache.token0Owed, cache.token1Owed);\n    }\n\n    /*=============================================================\n                             Premium Logic\n    ==============================================================*/\n\n    /// @inheritdoc IParticlePositionManager\n    function addPremium(uint96 lienId, uint128 premium0, uint128 premium1) external override nonReentrant {\n        bytes32 lienKey = keccak256(abi.encodePacked(msg.sender, lienId));\n        Lien.Info memory lien = liens.getInfo(lienKey);\n\n        // check lien is valid\n        if (lien.liquidity == 0) revert Errors.RecordEmpty();\n\n        // check LP allows extension of this lien\n        if (lps.getRenewalCutoffTime(lien.tokenId) > lien.startTime) revert Errors.RenewalDisabled();\n\n        (, , address token0, address token1, , int24 tickLower, int24 tickUpper, , , , , ) = Base\n            .UNI_POSITION_MANAGER\n            .positions(lien.tokenId);\n        (uint256 collateral0, uint256 collateral1) = Base.getRequiredCollateral(lien.liquidity, tickLower, tickUpper);\n\n        (uint128 token0Premium, uint128 token1Premium) = Base.getPremium(\n            collateral0,\n            collateral1,\n            lien.token0PremiumPortion,\n            lien.token1PremiumPortion\n        );\n\n        liens.updatePremium(\n            lienKey,\n            uint24(((token0Premium + premium0) * Base.BASIS_POINT) / collateral0),\n            uint24(((token1Premium + premium1) * Base.BASIS_POINT) / collateral1)\n        );\n\n        // transfer in added premium\n        if (premium0 > 0) {\n            TransferHelper.safeTransferFrom(token0, msg.sender, address(this), premium0);\n        }\n        if (premium1 > 0) {\n            TransferHelper.safeTransferFrom(token1, msg.sender, address(this), premium1);\n        }\n\n        emit AddPremium(msg.sender, lienId, premium0, premium1);\n    }\n\n    /*=============================================================\n                              Vanilla Swap\n    ==============================================================*/\n\n    /// @inheritdoc IParticlePositionManager\n    function swap(\n        address token0,\n        address token1,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        bytes calldata data\n    ) external override nonReentrant returns (uint256 amount0, uint256 amount1) {\n        (amount0, amount1) = SwapPosition.swap(token0, token1, amountIn, amountOutMinimum, DEX_AGGREGATOR, data);\n    }\n\n    /*=============================================================\n                              Admin logic\n    ==============================================================*/\n\n    /// @inheritdoc IParticlePositionManager\n    function updateDexAggregator(address dexAggregator) external override onlyOwner {\n        if (dexAggregator == address(0)) revert Errors.InvalidValue();\n        DEX_AGGREGATOR = dexAggregator;\n        emit UpdateDexAggregator(dexAggregator);\n    }\n\n    /// @inheritdoc IParticlePositionManager\n    function updateLiquidationRewardFactor(uint128 liquidationRewardFactor) external override onlyOwner {\n        if (liquidationRewardFactor > _LIQUIDATION_REWARD_FACTOR_MAX) revert Errors.InvalidValue();\n        LIQUIDATION_REWARD_FACTOR = liquidationRewardFactor;\n        emit UpdateLiquidationRewardFactor(liquidationRewardFactor);\n    }\n\n    /// @inheritdoc IParticlePositionManager\n    function updateFeeFactor(uint256 feeFactor) external override onlyOwner {\n        if (feeFactor > _FEE_FACTOR_MAX) revert Errors.InvalidValue();\n        FEE_FACTOR = feeFactor;\n        emit UpdateFeeFactor(feeFactor);\n    }\n\n    /// @inheritdoc IParticlePositionManager\n    function updateLoanTerm(uint256 loanTerm) external override onlyOwner {\n        if (loanTerm > _LOAN_TERM_MAX) revert Errors.InvalidValue();\n        LOAN_TERM = loanTerm;\n        emit UpdateLoanTerm(loanTerm);\n    }\n\n    /// @inheritdoc IParticlePositionManager\n    function updateTreasuryRate(uint256 treasuryRate) external override onlyOwner {\n        if (treasuryRate > _TREASURY_RATE_MAX) revert Errors.InvalidValue();\n        _treasuryRate = treasuryRate;\n        emit UpdateTreasuryRate(treasuryRate);\n    }\n\n    /// @inheritdoc IParticlePositionManager\n    function withdrawTreasury(address token, address recipient) external override onlyOwner nonReentrant {\n        uint256 withdrawAmount = _treasury[token];\n        if (withdrawAmount > 0) {\n            if (recipient == address(0)) {\n                revert Errors.InvalidRecipient();\n            }\n            _treasury[token] = 0;\n            TransferHelper.safeTransfer(token, recipient, withdrawAmount);\n            emit WithdrawTreasury(token, recipient, withdrawAmount);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/protocol/ParticlePositionManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {IERC721Receiver} from \"../../lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {Multicall} from \"../../lib/openzeppelin-contracts/contracts/utils/Multicall.sol\";\nimport {ReentrancyGuard} from \"../../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport {Ownable2StepUpgradeable} from \"../../lib/openzeppelin-contracts-upgradeable/contracts/access/Ownable2StepUpgradeable.sol\";\nimport {UUPSUpgradeable} from \"../../lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/UUPSUpgradeable.sol\";\nimport {TransferHelper} from \"../../lib/v3-periphery/contracts/libraries/TransferHelper.sol\";\n\nimport {IParticlePositionManager} from \"../interfaces/IParticlePositionManager.sol\";\nimport {Base} from \"../libraries/Base.sol\";\nimport {LiquidityPosition} from \"../libraries/LiquidityPosition.sol\";\nimport {Lien} from \"../libraries/Lien.sol\";\nimport {SwapPosition} from \"../libraries/SwapPosition.sol\";\nimport {DataStruct, DataCache} from \"../libraries/Structs.sol\";\nimport {Errors} from \"../libraries/Errors.sol\";\n\ncontract ParticlePositionManager is\n    IParticlePositionManager,\n    Ownable2StepUpgradeable,\n    UUPSUpgradeable,\n    IERC721Receiver,\n    ReentrancyGuard,\n    Multicall\n{\n    using LiquidityPosition for mapping(uint256 => LiquidityPosition.Info);\n    using Lien for mapping(bytes32 => Lien.Info);\n    using SwapPosition for mapping(bytes32 => SwapPosition.Info);\n\n    /* Constants */\n    uint256 private constant _TREASURY_RATE_MAX = 500_000;\n    uint256 private constant _FEE_FACTOR_MAX = 1_000;\n    uint128 private constant _LIQUIDATION_REWARD_FACTOR_MAX = 100_000;\n    uint256 private constant _LOAN_TERM_MAX = 30 days;\n\n    /* Variables */\n    uint96 private _nextRecordId; ///@dev used for both lien and swap\n    uint256 private _treasuryRate;\n    // solhint-disable var-name-mixedcase\n    address public DEX_AGGREGATOR;\n    uint256 public FEE_FACTOR;\n    uint128 public LIQUIDATION_REWARD_FACTOR;\n    uint256 public LOAN_TERM;\n    // solhint-enable var-name-mixedcase\n\n    /* Storage */\n    mapping(uint256 => LiquidityPosition.Info) public lps; ///@dev tokenId => liquidity position\n    mapping(bytes32 => Lien.Info) public liens; ///@dev (address, lienId) => lien\n    mapping(address => uint256) private _treasury; ///@dev address => amount\n\n    // required by openzeppelin UUPS module\n    // solhint-disable-next-line no-empty-blocks\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address dexAggregator,\n        uint256 feeFactor,\n        uint128 liquidationRewardFactor,\n        uint256 loanTerm,\n        uint256 treasuryRate\n    ) external initializer {\n        __UUPSUpgradeable_init();\n        __Ownable_init();\n        DEX_AGGREGATOR = dexAggregator;\n        FEE_FACTOR = feeFactor;\n        LIQUIDATION_REWARD_FACTOR = liquidationRewardFactor;\n        LOAN_TERM = loanTerm;\n        _treasuryRate = treasuryRate;\n    }\n\n    /*==============================================================\n                        Liquidity Provision Logic\n    ==============================================================*/\n\n    /// @inheritdoc IParticlePositionManager\n    function mint(\n        DataStruct.MintParams calldata params\n    )\n        external\n        override\n        nonReentrant\n        returns (uint256 tokenId, uint128 liquidity, uint256 amount0Minted, uint256 amount1Minted)\n    {\n        (tokenId, liquidity, amount0Minted, amount1Minted) = lps.mint(params);\n    }\n\n    /**\n     * @notice Receiver function upon ERC721 LP position transfer\n     * @dev LP must use safeTransferFrom to trigger onERC721Received\n     * @param from the address which previously owned the NFT\n     * @param tokenId the NFT identifier which is being transferred\n     */\n    function onERC721Received(\n        address,\n        address from,\n        uint256 tokenId,\n        bytes calldata\n    ) external override returns (bytes4) {\n        if (msg.sender == Base.UNI_POSITION_MANAGER_ADDR) {\n            // matched with Uniswap v3 position NFTs\n            lps[tokenId] = LiquidityPosition.Info({owner: from, renewalCutoffTime: 0, token0Owed: 0, token1Owed: 0});\n            (, , , , , , , uint128 liquidity, , , , ) = Base.UNI_POSITION_MANAGER.positions(tokenId);\n            emit LiquidityPosition.SupplyLiquidity(tokenId, from, liquidity);\n        }\n        return this.onERC721Received.selector;\n    }\n\n    /*==============================================================\n                       Liquidity Management Logic\n    ==============================================================*/\n\n    /// @inheritdoc IParticlePositionManager\n    function increaseLiquidity(\n        uint256 tokenId,\n        uint256 amount0,\n        uint256 amount1\n    ) external override nonReentrant returns (uint128 liquidity, uint256 amount0Added, uint256 amount1Added) {\n        (liquidity, amount0Added, amount1Added) = lps.increaseLiquidity(tokenId, amount0, amount1);\n    }\n\n    /// @inheritdoc IParticlePositionManager\n    function decreaseLiquidity(\n        uint256 tokenId,\n        uint128 liquidity\n    ) external override nonReentrant returns (uint256 amount0Decreased, uint256 amount1Decreased) {\n        (amount0Decreased, amount1Decreased) = lps.decreaseLiquidity(tokenId, liquidity);\n    }\n\n    /// @inheritdoc IParticlePositionManager\n    function collectLiquidity(\n        uint256 tokenId\n    ) external override nonReentrant returns (uint256 amount0Collected, uint256 amount1Collected) {\n        (amount0Collected, amount1Collected) = lps.collectLiquidity(tokenId);\n    }\n\n    /// @inheritdoc IParticlePositionManager\n    function reclaimLiquidity(uint256 tokenId) external override nonReentrant {\n        lps.reclaimLiquidity(tokenId);\n    }\n\n    /*=============================================================\n                             Open Position\n    ==============================================================*/\n\n    /// @inheritdoc IParticlePositionManager\n    function openPosition(\n        DataStruct.OpenPositionParams calldata params\n    ) public override nonReentrant returns (uint96 lienId, uint256 collateralTo) {\n        if (params.liquidity == 0) revert Errors.InsufficientBorrow();\n\n        // local cache to avoid stack too deep\n        DataCache.OpenPositionCache memory cache;\n\n        // prepare data for swap\n        (\n            cache.tokenFrom,\n            cache.tokenTo,\n            cache.feeGrowthInside0LastX128,\n            cache.feeGrowthInside1LastX128,\n            cache.collateralFrom,"
    }
  ]
}