{
  "Title": "[H-04] TokenDistributor: ERC777 tokensToSend hook can be exploited to drain contract",
  "Content": "# Lines of code\n\nhttps://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/distribution/TokenDistributor.sol#L131\nhttps://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/distribution/TokenDistributor.sol#L386\n\n\n# Vulnerability details\n\n## Impact\n`TokenDistributor.createERC20Distribution` can be used to create token distributions for ERC777 tokens (which are backwards-compatible with ERC20). However, this introduces a reentrancy vulnerability which allows a party to get the tokens of another party. The problem is the `tokensToSend` hook which is executed BEFORE balance updates happens (see https://eips.ethereum.org/EIPS/eip-777). When this hook is executed, `token.balanceOf(address(this))` therefore still returns the old value, but `_storedBalances[balanceID]` was already decreased.\n\n## Proof Of Concept\nParty A and Party B have a balance of 1,000,000 tokens (of some arbitrary ERC777 token) in the distributor. Let's say for the sake of simplicity that both parties only have one user (user A in party A, user B in party B). User A (or rather his smart contract) performs the following attack:\n- He calls `claim`, which transfers 1,000,000 tokens to his contract address. In `_transfer`, `_storedBalances[balanceId]` is decreased by 1,000,000 and therefore now has a value of 1,000,000.\n- In the `tokensToSend` hook, he initiates another distribution for his party A by calling `PartyGovernance.distribute` which calls `TokenDistributor.createERC20Distribution` (we assume for the sake of simplicity that the party does not have more of these tokens, so the call transfers 0 tokens to the distributor). `TokenDistributor.createERC20Distribution` passes `token.balanceOf(address(this))` to `_createDistribution`. Note that this is still 2,000,000 because we are in the `tokensToSend` hook.\n- The supply of this distribution is calculated as `(args.currentTokenBalance - _storedBalances[balanceId]) = 2,000,000 - 1,000,000 = 1,000,000`.\n- When the `tokensToSend` hook is exited (and the first transfer has finished), he can retrieve the tokens of the second distribution (that was created in the hook) to steal the 1,000,000 tokens of party B.\n\n## Recommended Mitigation Steps\nDo not allow reentrancy in these functions.",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-09-partydao-contest",
  "Code": [
    {
      "filename": "contracts/distribution/TokenDistributor.sol",
      "content": "// SPDX-License-Identifier: Beta Software\npragma solidity ^0.8;\n\nimport \"../globals/IGlobals.sol\";\nimport \"../globals/LibGlobals.sol\";\nimport \"../tokens/IERC20.sol\";\nimport \"../utils/LibAddress.sol\";\nimport \"../utils/LibERC20Compat.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/LibSafeCast.sol\";\n\nimport \"./ITokenDistributor.sol\";\n\n/// @notice Creates token distributions for parties (or any contract that\n///         implements `ITokenDistributorParty`).\ncontract TokenDistributor is ITokenDistributor {\n    using LibAddress for address payable;\n    using LibERC20Compat for IERC20;\n    using LibRawResult for bytes;\n    using LibSafeCast for uint256;\n\n    struct DistributionState {\n        // The remaining member supply.\n        uint128 remainingMemberSupply;\n        // The 15-byte hash of the `DistributionInfo`.\n        bytes15 distributionHash15;\n        // Whether the distribution's feeRecipient has claimed its fee.\n        bool wasFeeClaimed;\n        // Whether a governance token has claimed its distribution share.\n        mapping(uint256 => bool) hasPartyTokenClaimed;\n    }\n\n    // Arguments for `_createDistribution()`.\n    struct CreateDistributionArgs {\n        ITokenDistributorParty party;\n        TokenType tokenType;\n        address token;\n        uint256 currentTokenBalance;\n        address payable feeRecipient;\n        uint16 feeBps;\n    }\n\n    error OnlyPartyDaoError(address notDao, address partyDao);\n    error OnlyPartyDaoAuthorityError(address notDaoAuthority);\n    error InvalidDistributionInfoError(DistributionInfo info);\n    error DistributionAlreadyClaimedByPartyTokenError(uint256 distributionId, uint256 partyTokenId);\n    error DistributionFeeAlreadyClaimedError(uint256 distributionId);\n    error MustOwnTokenError(address sender, address expectedOwner, uint256 partyTokenId);\n    error EmergencyActionsNotAllowedError();\n    error InvalidDistributionSupplyError(uint128 supply);\n    error OnlyFeeRecipientError(address caller, address feeRecipient);\n    error InvalidFeeBpsError(uint16 feeBps);\n\n    // Token address used to indicate a native distribution (i.e. distribution of ETH).\n    address private constant NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice The `Globals` contract storing global configuration values. This contract\n    ///         is immutable and it’s address will never change.\n    IGlobals public immutable GLOBALS;\n\n    /// @notice Whether the DAO is no longer allowed to call emergency functions.\n    bool public emergencyActionsDisabled;\n    /// @notice Last distribution ID for a party.\n    mapping(ITokenDistributorParty => uint256) public lastDistributionIdPerParty;\n    /// Last known balance of a token, identified by an ID derived from the token.\n    /// Gets lazily updated when creating and claiming a distribution (transfers).\n    /// Allows one to simply transfer and call `createDistribution()` without\n    /// fussing with allowances.\n    mapping(bytes32 => uint256) private _storedBalances;\n    // tokenDistributorParty => distributionId => DistributionState\n    mapping(ITokenDistributorParty => mapping(uint256 => DistributionState)) private _distributionStates;\n\n    // msg.sender == DAO\n    modifier onlyPartyDao() {\n        {\n            address partyDao = GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);\n            if (msg.sender != partyDao) {\n                revert OnlyPartyDaoError(msg.sender, partyDao);\n            }\n        }\n        _;\n    }\n\n    // emergencyActionsDisabled == false\n    modifier onlyIfEmergencyActionsAllowed() {\n        if (emergencyActionsDisabled) {\n            revert EmergencyActionsNotAllowedError();\n        }\n        _;\n    }\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) {\n        GLOBALS = globals;\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function createNativeDistribution(\n        ITokenDistributorParty party,\n        address payable feeRecipient,\n        uint16 feeBps\n    )\n        external\n        payable\n        returns (DistributionInfo memory info)\n    {\n        info = _createDistribution(CreateDistributionArgs({\n            party: party,\n            tokenType: TokenType.Native,\n            token: NATIVE_TOKEN_ADDRESS,\n            currentTokenBalance: address(this).balance,\n            feeRecipient: feeRecipient,\n            feeBps: feeBps\n        }));\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function createErc20Distribution(\n        IERC20 token,\n        ITokenDistributorParty party,\n        address payable feeRecipient,\n        uint16 feeBps\n    )\n        external\n        returns (DistributionInfo memory info)\n    {\n        info = _createDistribution(CreateDistributionArgs({\n            party: party,\n            tokenType: TokenType.Erc20,\n            token: address(token),\n            currentTokenBalance: token.balanceOf(address(this)),\n            feeRecipient: feeRecipient,\n            feeBps: feeBps\n        }));\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function claim(DistributionInfo calldata info, uint256 partyTokenId)\n        public\n        returns (uint128 amountClaimed)\n    {\n        // Caller must own the party token.\n        {\n            address ownerOfPartyToken = info.party.ownerOf(partyTokenId);\n            if (msg.sender != ownerOfPartyToken) {\n                revert MustOwnTokenError(msg.sender, ownerOfPartyToken, partyTokenId);\n            }\n        }\n        // DistributionInfo must be correct for this distribution ID.\n        DistributionState storage state = _distributionStates[info.party][info.distributionId];\n        if (state.distributionHash15 != _getDistributionHash(info)) {\n            revert InvalidDistributionInfoError(info);\n        }\n        // The partyTokenId must not have claimed its distribution yet.\n        if (state.hasPartyTokenClaimed[partyTokenId]) {\n            revert DistributionAlreadyClaimedByPartyTokenError(info.distributionId, partyTokenId);\n        }\n        // Mark the partyTokenId as having claimed their distribution.\n        state.hasPartyTokenClaimed[partyTokenId] = true;\n\n        // Compute amount owed to partyTokenId.\n        amountClaimed = getClaimAmount(info.party, info.memberSupply, partyTokenId);\n\n        // Cap at the remaining member supply. Otherwise a malicious\n        // party could drain more than the distribution supply.\n        uint128 remainingMemberSupply = state.remainingMemberSupply;\n        amountClaimed = amountClaimed > remainingMemberSupply\n            ? remainingMemberSupply\n            : amountClaimed;\n        state.remainingMemberSupply = remainingMemberSupply - amountClaimed;\n\n        // Transfer tokens owed.\n        _transfer(\n            info.tokenType,\n            info.token,\n            payable(msg.sender),\n            amountClaimed\n        );\n        emit DistributionClaimedByPartyToken(\n            info.party,\n            partyTokenId,\n            msg.sender,\n            info.tokenType,\n            info.token,\n            amountClaimed\n        );\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function claimFee(DistributionInfo calldata info, address payable recipient)\n        public\n    {\n        // DistributionInfo must be correct for this distribution ID.\n        DistributionState storage state = _distributionStates[info.party][info.distributionId];\n        if (state.distributionHash15 != _getDistributionHash(info)) {\n            revert InvalidDistributionInfoError(info);\n        }\n        // Caller must be the fee recipient.\n        if (info.feeRecipient != msg.sender) {\n            revert OnlyFeeRecipientError(msg.sender, info.feeRecipient);\n        }\n        // Must not have claimed the fee yet.\n        if (state.wasFeeClaimed) {\n            revert DistributionFeeAlreadyClaimedError(info.distributionId);\n        }\n        // Mark the fee as claimed.\n        state.wasFeeClaimed = true;\n        // Transfer the tokens owed.\n        _transfer(\n            info.tokenType,\n            info.token,\n            recipient,\n            info.fee\n        );\n        emit DistributionFeeClaimed(\n            info.party,\n            info.feeRecipient,\n            info.tokenType,\n            info.token,\n            info.fee\n        );\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function batchClaim(DistributionInfo[] calldata infos, uint256[] calldata partyTokenIds)\n        external\n        returns (uint128[] memory amountsClaimed)\n    {\n        amountsClaimed = new uint128[](infos.length);\n        for (uint256 i = 0; i < infos.length; ++i) {\n            amountsClaimed[i] = claim(infos[i], partyTokenIds[i]);\n        }\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function batchClaimFee(DistributionInfo[] calldata infos, address payable[] calldata recipients)\n        external\n    {\n        for (uint256 i = 0; i < infos.length; ++i) {\n            claimFee(infos[i], recipients[i]);\n        }\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function getClaimAmount(\n        ITokenDistributorParty party,\n        uint256 memberSupply,\n        uint256 partyTokenId\n    )\n        public\n        view\n        returns (uint128)\n    {\n        // getDistributionShareOf() is the fraction of the memberSupply partyTokenId\n        // is entitled to, scaled by 1e18.\n        // We round up here to prevent dust amounts getting trapped in this contract.\n        return (\n            (\n                uint256(party.getDistributionShareOf(partyTokenId))\n                * memberSupply\n                + (1e18 - 1)\n            )\n            / 1e18\n        ).safeCastUint256ToUint128();\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function wasFeeClaimed(ITokenDistributorParty party, uint256 distributionId)\n        external\n        view\n        returns (bool)\n    {\n        return _distributionStates[party][distributionId].wasFeeClaimed;\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function hasPartyTokenIdClaimed(\n        ITokenDistributorParty party,\n        uint256 partyTokenId,\n        uint256 distributionId\n    )\n        external\n        view returns (bool)\n    {\n        return _distributionStates[party][distributionId].hasPartyTokenClaimed[partyTokenId];\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function getRemainingMemberSupply(\n        ITokenDistributorParty party,\n        uint256 distributionId\n    )\n        external\n        view\n        returns (uint128)\n    {\n        return _distributionStates[party][distributionId].remainingMemberSupply;\n    }\n\n    /// @notice DAO-only function to clear a distribution in case something goes wrong.\n    function emergencyRemoveDistribution(\n        ITokenDistributorParty party,\n        uint256 distributionId\n    )\n        onlyPartyDao\n        onlyIfEmergencyActionsAllowed\n        external\n    {\n        delete _distributionStates[party][distributionId];\n    }\n\n    /// @notice DAO-only function to withdraw tokens in case something goes wrong.\n    function emergencyWithdraw(\n        TokenType tokenType,\n        address token,\n        address payable recipient,\n        uint256 amount\n    )\n        onlyPartyDao\n        onlyIfEmergencyActionsAllowed\n        external\n    {\n        _transfer(tokenType, token, recipient, amount);\n    }\n\n    /// @notice DAO-only function to disable emergency functions forever.\n    function disableEmergencyActions() onlyPartyDao external {\n        emergencyActionsDisabled = true;\n    }\n\n    function _createDistribution(CreateDistributionArgs memory args)\n        private\n        returns (DistributionInfo memory info)\n    {\n        if (args.feeBps > 1e4) {\n            revert InvalidFeeBpsError(args.feeBps);\n        }\n        uint128 supply;\n        {\n            bytes32 balanceId = _getBalanceId(args.tokenType, args.token);\n            supply = (args.currentTokenBalance - _storedBalances[balanceId])\n                .safeCastUint256ToUint128();\n            // Supply must be nonzero.\n            if (supply == 0) {\n                revert InvalidDistributionSupplyError(supply);\n            }\n            // Update stored balance.\n            _storedBalances[balanceId] = args.currentTokenBalance;\n        }\n\n        // Create a distribution.\n        uint128 fee = supply * args.feeBps / 1e4;\n        uint128 memberSupply = supply - fee;\n\n        info = DistributionInfo({\n            tokenType: args.tokenType,\n            distributionId: ++lastDistributionIdPerParty[args.party],\n            token: args.token,\n            party: args.party,\n            memberSupply: memberSupply,\n            feeRecipient: args.feeRecipient,\n            fee: fee\n        });\n        (\n            _distributionStates[args.party][info.distributionId].distributionHash15,\n            _distributionStates[args.party][info.distributionId].remainingMemberSupply\n        ) = (_getDistributionHash(info), memberSupply);\n        emit DistributionCreated(args.party, info);\n    }\n\n    function _transfer(\n        TokenType tokenType,\n        address token,\n        address payable recipient,\n        uint256 amount\n    )\n        private\n    {\n        bytes32 balanceId = _getBalanceId(tokenType, token);\n        // Reduce stored token balance.\n        _storedBalances[balanceId] -= amount;\n        if (tokenType == TokenType.Native) {\n            recipient.transferEth(amount);\n        } else {\n            assert(tokenType == TokenType.Erc20);\n            IERC20(token).compatTransfer(recipient, amount);\n        }\n    }\n\n    function _getDistributionHash(DistributionInfo memory info)\n        internal\n        pure\n        returns (bytes15 hash)\n    {\n        assembly {\n            hash := and(\n                keccak256(info, 0xe0),\n                0xffffffffffffffffffffffffffffff0000000000000000000000000000000000\n            )\n        }\n    }\n\n    function _getBalanceId(TokenType tokenType, address token)\n        private\n        pure\n        returns (bytes32 balanceId)\n    {\n        if (tokenType == TokenType.Native) {\n            return bytes32(uint256(uint160(NATIVE_TOKEN_ADDRESS)));\n        }\n        assert(tokenType == TokenType.Erc20);\n        return bytes32(uint256(uint160(token)));\n    }\n}"
    },
    {
      "filename": "contracts/distribution/TokenDistributor.sol",
      "content": "// SPDX-License-Identifier: Beta Software\npragma solidity ^0.8;\n\nimport \"../globals/IGlobals.sol\";\nimport \"../globals/LibGlobals.sol\";\nimport \"../tokens/IERC20.sol\";\nimport \"../utils/LibAddress.sol\";\nimport \"../utils/LibERC20Compat.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/LibSafeCast.sol\";\n\nimport \"./ITokenDistributor.sol\";\n\n/// @notice Creates token distributions for parties (or any contract that\n///         implements `ITokenDistributorParty`).\ncontract TokenDistributor is ITokenDistributor {\n    using LibAddress for address payable;\n    using LibERC20Compat for IERC20;\n    using LibRawResult for bytes;\n    using LibSafeCast for uint256;\n\n    struct DistributionState {\n        // The remaining member supply.\n        uint128 remainingMemberSupply;\n        // The 15-byte hash of the `DistributionInfo`.\n        bytes15 distributionHash15;\n        // Whether the distribution's feeRecipient has claimed its fee.\n        bool wasFeeClaimed;\n        // Whether a governance token has claimed its distribution share.\n        mapping(uint256 => bool) hasPartyTokenClaimed;\n    }\n\n    // Arguments for `_createDistribution()`.\n    struct CreateDistributionArgs {\n        ITokenDistributorParty party;\n        TokenType tokenType;\n        address token;\n        uint256 currentTokenBalance;\n        address payable feeRecipient;\n        uint16 feeBps;\n    }\n\n    error OnlyPartyDaoError(address notDao, address partyDao);\n    error OnlyPartyDaoAuthorityError(address notDaoAuthority);\n    error InvalidDistributionInfoError(DistributionInfo info);\n    error DistributionAlreadyClaimedByPartyTokenError(uint256 distributionId, uint256 partyTokenId);\n    error DistributionFeeAlreadyClaimedError(uint256 distributionId);\n    error MustOwnTokenError(address sender, address expectedOwner, uint256 partyTokenId);\n    error EmergencyActionsNotAllowedError();\n    error InvalidDistributionSupplyError(uint128 supply);\n    error OnlyFeeRecipientError(address caller, address feeRecipient);\n    error InvalidFeeBpsError(uint16 feeBps);\n\n    // Token address used to indicate a native distribution (i.e. distribution of ETH).\n    address private constant NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice The `Globals` contract storing global configuration values. This contract\n    ///         is immutable and it’s address will never change.\n    IGlobals public immutable GLOBALS;\n\n    /// @notice Whether the DAO is no longer allowed to call emergency functions.\n    bool public emergencyActionsDisabled;\n    /// @notice Last distribution ID for a party.\n    mapping(ITokenDistributorParty => uint256) public lastDistributionIdPerParty;\n    /// Last known balance of a token, identified by an ID derived from the token.\n    /// Gets lazily updated when creating and claiming a distribution (transfers).\n    /// Allows one to simply transfer and call `createDistribution()` without\n    /// fussing with allowances.\n    mapping(bytes32 => uint256) private _storedBalances;\n    // tokenDistributorParty => distributionId => DistributionState\n    mapping(ITokenDistributorParty => mapping(uint256 => DistributionState)) private _distributionStates;\n\n    // msg.sender == DAO\n    modifier onlyPartyDao() {\n        {\n            address partyDao = GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);\n            if (msg.sender != partyDao) {\n                revert OnlyPartyDaoError(msg.sender, partyDao);\n            }\n        }\n        _;\n    }\n\n    // emergencyActionsDisabled == false\n    modifier onlyIfEmergencyActionsAllowed() {\n        if (emergencyActionsDisabled) {\n            revert EmergencyActionsNotAllowedError();\n        }\n        _;\n    }\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) {\n        GLOBALS = globals;\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function createNativeDistribution(\n        ITokenDistributorParty party,\n        address payable feeRecipient,\n        uint16 feeBps\n    )\n        external\n        payable\n        returns (DistributionInfo memory info)\n    {\n        info = _createDistribution(CreateDistributionArgs({\n            party: party,\n            tokenType: TokenType.Native,\n            token: NATIVE_TOKEN_ADDRESS,\n            currentTokenBalance: address(this).balance,\n            feeRecipient: feeRecipient,\n            feeBps: feeBps\n        }));\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function createErc20Distribution(\n        IERC20 token,\n        ITokenDistributorParty party,\n        address payable feeRecipient,\n        uint16 feeBps\n    )\n        external\n        returns (DistributionInfo memory info)\n    {\n        info = _createDistribution(CreateDistributionArgs({\n            party: party,\n            tokenType: TokenType.Erc20,\n            token: address(token),\n            currentTokenBalance: token.balanceOf(address(this)),\n            feeRecipient: feeRecipient,\n            feeBps: feeBps\n        }));\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function claim(DistributionInfo calldata info, uint256 partyTokenId)\n        public\n        returns (uint128 amountClaimed)\n    {\n        // Caller must own the party token.\n        {\n            address ownerOfPartyToken = info.party.ownerOf(partyTokenId);\n            if (msg.sender != ownerOfPartyToken) {\n                revert MustOwnTokenError(msg.sender, ownerOfPartyToken, partyTokenId);\n            }\n        }\n        // DistributionInfo must be correct for this distribution ID.\n        DistributionState storage state = _distributionStates[info.party][info.distributionId];\n        if (state.distributionHash15 != _getDistributionHash(info)) {\n            revert InvalidDistributionInfoError(info);\n        }\n        // The partyTokenId must not have claimed its distribution yet.\n        if (state.hasPartyTokenClaimed[partyTokenId]) {\n            revert DistributionAlreadyClaimedByPartyTokenError(info.distributionId, partyTokenId);\n        }\n        // Mark the partyTokenId as having claimed their distribution.\n        state.hasPartyTokenClaimed[partyTokenId] = true;\n\n        // Compute amount owed to partyTokenId.\n        amountClaimed = getClaimAmount(info.party, info.memberSupply, partyTokenId);\n\n        // Cap at the remaining member supply. Otherwise a malicious\n        // party could drain more than the distribution supply.\n        uint128 remainingMemberSupply = state.remainingMemberSupply;\n        amountClaimed = amountClaimed > remainingMemberSupply\n            ? remainingMemberSupply\n            : amountClaimed;\n        state.remainingMemberSupply = remainingMemberSupply - amountClaimed;\n\n        // Transfer tokens owed.\n        _transfer(\n            info.tokenType,\n            info.token,\n            payable(msg.sender),\n            amountClaimed\n        );\n        emit DistributionClaimedByPartyToken(\n            info.party,\n            partyTokenId,\n            msg.sender,\n            info.tokenType,\n            info.token,\n            amountClaimed\n        );\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function claimFee(DistributionInfo calldata info, address payable recipient)\n        public\n    {\n        // DistributionInfo must be correct for this distribution ID.\n        DistributionState storage state = _distributionStates[info.party][info.distributionId];\n        if (state.distributionHash15 != _getDistributionHash(info)) {\n            revert InvalidDistributionInfoError(info);\n        }\n        // Caller must be the fee recipient.\n        if (info.feeRecipient != msg.sender) {\n            revert OnlyFeeRecipientError(msg.sender, info.feeRecipient);\n        }\n        // Must not have claimed the fee yet.\n        if (state.wasFeeClaimed) {\n            revert DistributionFeeAlreadyClaimedError(info.distributionId);\n        }\n        // Mark the fee as claimed.\n        state.wasFeeClaimed = true;\n        // Transfer the tokens owed.\n        _transfer(\n            info.tokenType,\n            info.token,\n            recipient,\n            info.fee\n        );\n        emit DistributionFeeClaimed(\n            info.party,\n            info.feeRecipient,\n            info.tokenType,\n            info.token,\n            info.fee\n        );\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function batchClaim(DistributionInfo[] calldata infos, uint256[] calldata partyTokenIds)\n        external\n        returns (uint128[] memory amountsClaimed)\n    {\n        amountsClaimed = new uint128[](infos.length);\n        for (uint256 i = 0; i < infos.length; ++i) {\n            amountsClaimed[i] = claim(infos[i], partyTokenIds[i]);\n        }\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function batchClaimFee(DistributionInfo[] calldata infos, address payable[] calldata recipients)\n        external\n    {\n        for (uint256 i = 0; i < infos.length; ++i) {\n            claimFee(infos[i], recipients[i]);\n        }\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function getClaimAmount(\n        ITokenDistributorParty party,\n        uint256 memberSupply,\n        uint256 partyTokenId\n    )\n        public\n        view\n        returns (uint128)\n    {\n        // getDistributionShareOf() is the fraction of the memberSupply partyTokenId\n        // is entitled to, scaled by 1e18.\n        // We round up here to prevent dust amounts getting trapped in this contract.\n        return (\n            (\n                uint256(party.getDistributionShareOf(partyTokenId))\n                * memberSupply\n                + (1e18 - 1)\n            )\n            / 1e18\n        ).safeCastUint256ToUint128();\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function wasFeeClaimed(ITokenDistributorParty party, uint256 distributionId)\n        external\n        view\n        returns (bool)\n    {\n        return _distributionStates[party][distributionId].wasFeeClaimed;\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function hasPartyTokenIdClaimed(\n        ITokenDistributorParty party,\n        uint256 partyTokenId,\n        uint256 distributionId\n    )\n        external\n        view returns (bool)\n    {\n        return _distributionStates[party][distributionId].hasPartyTokenClaimed[partyTokenId];\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function getRemainingMemberSupply(\n        ITokenDistributorParty party,\n        uint256 distributionId\n    )\n        external\n        view\n        returns (uint128)\n    {\n        return _distributionStates[party][distributionId].remainingMemberSupply;\n    }\n\n    /// @notice DAO-only function to clear a distribution in case something goes wrong.\n    function emergencyRemoveDistribution(\n        ITokenDistributorParty party,\n        uint256 distributionId\n    )\n        onlyPartyDao\n        onlyIfEmergencyActionsAllowed\n        external\n    {\n        delete _distributionStates[party][distributionId];\n    }\n\n    /// @notice DAO-only function to withdraw tokens in case something goes wrong.\n    function emergencyWithdraw(\n        TokenType tokenType,\n        address token,\n        address payable recipient,\n        uint256 amount\n    )\n        onlyPartyDao\n        onlyIfEmergencyActionsAllowed\n        external\n    {\n        _transfer(tokenType, token, recipient, amount);\n    }\n\n    /// @notice DAO-only function to disable emergency functions forever.\n    function disableEmergencyActions() onlyPartyDao external {\n        emergencyActionsDisabled = true;\n    }\n\n    function _createDistribution(CreateDistributionArgs memory args)\n        private\n        returns (DistributionInfo memory info)\n    {\n        if (args.feeBps > 1e4) {\n            revert InvalidFeeBpsError(args.feeBps);\n        }\n        uint128 supply;\n        {\n            bytes32 balanceId = _getBalanceId(args.tokenType, args.token);\n            supply = (args.currentTokenBalance - _storedBalances[balanceId])\n                .safeCastUint256ToUint128();\n            // Supply must be nonzero.\n            if (supply == 0) {\n                revert InvalidDistributionSupplyError(supply);\n            }\n            // Update stored balance.\n            _storedBalances[balanceId] = args.currentTokenBalance;\n        }\n\n        // Create a distribution.\n        uint128 fee = supply * args.feeBps / 1e4;\n        uint128 memberSupply = supply - fee;\n\n        info = DistributionInfo({\n            tokenType: args.tokenType,\n            distributionId: ++lastDistributionIdPerParty[args.party],\n            token: args.token,\n            party: args.party,\n            memberSupply: memberSupply,\n            feeRecipient: args.feeRecipient,\n            fee: fee\n        });\n        (\n            _distributionStates[args.party][info.distributionId].distributionHash15,\n            _distributionStates[args.party][info.distributionId].remainingMemberSupply\n        ) = (_getDistributionHash(info), memberSupply);\n        emit DistributionCreated(args.party, info);\n    }\n\n    function _transfer(\n        TokenType tokenType,\n        address token,\n        address payable recipient,\n        uint256 amount\n    )\n        private\n    {\n        bytes32 balanceId = _getBalanceId(tokenType, token);\n        // Reduce stored token balance.\n        _storedBalances[balanceId] -= amount;\n        if (tokenType == TokenType.Native) {\n            recipient.transferEth(amount);\n        } else {\n            assert(tokenType == TokenType.Erc20);\n            IERC20(token).compatTransfer(recipient, amount);\n        }\n    }\n\n    function _getDistributionHash(DistributionInfo memory info)\n        internal\n        pure\n        returns (bytes15 hash)\n    {\n        assembly {\n            hash := and(\n                keccak256(info, 0xe0),\n                0xffffffffffffffffffffffffffffff0000000000000000000000000000000000\n            )\n        }\n    }\n\n    function _getBalanceId(TokenType tokenType, address token)\n        private\n        pure\n        returns (bytes32 balanceId)\n    {\n        if (tokenType == TokenType.Native) {\n            return bytes32(uint256(uint160(NATIVE_TOKEN_ADDRESS)));\n        }\n        assert(tokenType == TokenType.Erc20);\n        return bytes32(uint256(uint160(token)));\n    }\n}"
    }
  ]
}