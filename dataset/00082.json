{
  "Title": "Unhandled Call Output",
  "Content": "The `BalanceUtils` contract implements methods to handle share balances and allowances. When balances are changed, the [`tryBalanceTrackerHook` function](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/EVault/shared/BalanceUtils.sol#L34) is called which makes an external call to the `BalanceTracker` contract.\n\n\nHowever, the function returns an [unhandled `success` output](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/EVault/shared/BalanceUtils.sol#L130-L132) which is also not being handled in the methods that use it. Even though the name implies that it might be possible to have a non-successful call and continue with the execution, there is no explicit handling mechanism to catch the situation and inform the user or the protocol.\n\n\nConsider handling such output in each function that makes use of the `tryBalanceTrackerHook` function, at least for logging the failed hook call so users can be aware of it.\n\n\n***Update:** Resolved in [pull request #140](https://github.com/euler-xyz/euler-vault-kit/pull/140). The Euler team stated:*\n\n\n\n> *We have decided to not attempt to handle failed calls to the balance tracker contract. Instead, we will be using Certoraâ€™s formal verification tools to prove that the balance tracker implementation we will be using will not revert.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/EVault/shared/BalanceUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {Base} from \"./Base.sol\";\nimport {IBalanceTracker} from \"../../interfaces/IBalanceTracker.sol\";\n\nimport \"./types/Types.sol\";\n\n/// @title BalanceUtils\n/// @author Euler Labs (https://www.eulerlabs.com/)\n/// @notice Utilities for tracking share balances and allowances\nabstract contract BalanceUtils is Base {\n    using TypesLib for uint256;\n\n    // Balances\n\n    function increaseBalance(\n        VaultCache memory vaultCache,\n        address account,\n        address sender,\n        Shares amount,\n        Assets assets\n    ) internal virtual {\n        if (account == address(0)) revert E_BadSharesReceiver();\n\n        (Shares origBalance, bool balanceForwarderEnabled) = vaultStorage.users[account].getBalanceAndBalanceForwarder();\n        Shares newBalance = origBalance + amount;\n\n        vaultStorage.users[account].setBalance(newBalance);\n        vaultStorage.totalShares = vaultCache.totalShares = vaultCache.totalShares + amount;\n\n        if (balanceForwarderEnabled) {\n            tryBalanceTrackerHook(account, newBalance.toUint(), false);\n        }\n\n        emit Transfer(address(0), account, amount.toUint());\n        emit Deposit(sender, account, assets.toUint(), amount.toUint());\n    }\n\n    function decreaseBalance(\n        VaultCache memory vaultCache,\n        address account,\n        address sender,\n        address receiver,\n        Shares amount,\n        Assets assets\n    ) internal virtual {\n        (Shares origBalance, bool balanceForwarderEnabled) = vaultStorage.users[account].getBalanceAndBalanceForwarder();\n        if (origBalance < amount) revert E_InsufficientBalance();\n\n        Shares newBalance;\n        unchecked {\n            newBalance = origBalance - amount;\n        }\n\n        vaultStorage.users[account].setBalance(newBalance);\n        vaultStorage.totalShares = vaultCache.totalShares = vaultCache.totalShares - amount;\n\n        if (balanceForwarderEnabled) {\n            // if the balance is decreased as a part of the collateral transfer during liquidation,\n            // which is indicated by the EVC with a collateral control in progress flag,\n            // instruct the balance tracker to forfeit rewards due to the liquidated account, in order to\n            // limit gas consumption, which could potentially be abused by violators to prevent liquidations.\n            tryBalanceTrackerHook(account, newBalance.toUint(), isControlCollateralInProgress());\n        }\n\n        emit Transfer(account, address(0), amount.toUint());\n        emit Withdraw(sender, receiver, account, assets.toUint(), amount.toUint());\n    }\n\n    function transferBalance(address from, address to, Shares amount) internal virtual {\n        if (!amount.isZero()) {\n            (Shares origFromBalance, bool fromBalanceForwarderEnabled) =\n                vaultStorage.users[from].getBalanceAndBalanceForwarder();\n\n            (Shares origToBalance, bool toBalanceForwarderEnabled) =\n                vaultStorage.users[to].getBalanceAndBalanceForwarder();\n\n            if (origFromBalance < amount) revert E_InsufficientBalance();\n\n            Shares newFromBalance;\n            unchecked {\n                newFromBalance = origFromBalance - amount;\n            }\n            Shares newToBalance = origToBalance + amount;\n\n            vaultStorage.users[from].setBalance(newFromBalance);\n            vaultStorage.users[to].setBalance(newToBalance);\n\n            if (fromBalanceForwarderEnabled) {\n                tryBalanceTrackerHook(from, newFromBalance.toUint(), isControlCollateralInProgress());\n            }\n\n            if (toBalanceForwarderEnabled) {\n                tryBalanceTrackerHook(to, newToBalance.toUint(), false);\n            }\n        }\n\n        emit Transfer(from, to, amount.toUint());\n    }\n\n    // Allowance\n\n    function setAllowance(address owner, address spender, uint256 amount) internal {\n        if (spender == owner) revert E_SelfApproval();\n\n        vaultStorage.users[owner].eTokenAllowance[spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function decreaseAllowance(address owner, address spender, Shares amount) internal virtual {\n        if (amount.isZero()) return;\n\n        uint256 allowance = vaultStorage.users[owner].eTokenAllowance[spender];\n        if (owner != spender && allowance != type(uint256).max) {\n            if (allowance < amount.toUint()) revert E_InsufficientAllowance();\n            unchecked {\n                allowance -= amount.toUint();\n            }\n            vaultStorage.users[owner].eTokenAllowance[spender] = allowance;\n            emit Approval(owner, spender, allowance);\n        }\n    }\n\n    function tryBalanceTrackerHook(address account, uint256 newAccountBalance, bool forfeitRecentReward)\n        private\n        returns (bool success)\n    {\n        (success,) = address(balanceTracker).call(\n            abi.encodeCall(IBalanceTracker.balanceTrackerHook, (account, newAccountBalance, forfeitRecentReward))\n        );\n    }\n}"
    },
    {
      "filename": "src/EVault/shared/BalanceUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {Base} from \"./Base.sol\";\nimport {IBalanceTracker} from \"../../interfaces/IBalanceTracker.sol\";\n\nimport \"./types/Types.sol\";\n\n/// @title BalanceUtils\n/// @author Euler Labs (https://www.eulerlabs.com/)\n/// @notice Utilities for tracking share balances and allowances\nabstract contract BalanceUtils is Base {\n    using TypesLib for uint256;\n\n    // Balances\n\n    function increaseBalance(\n        VaultCache memory vaultCache,\n        address account,\n        address sender,\n        Shares amount,\n        Assets assets\n    ) internal virtual {\n        if (account == address(0)) revert E_BadSharesReceiver();\n\n        (Shares origBalance, bool balanceForwarderEnabled) = vaultStorage.users[account].getBalanceAndBalanceForwarder();\n        Shares newBalance = origBalance + amount;\n\n        vaultStorage.users[account].setBalance(newBalance);\n        vaultStorage.totalShares = vaultCache.totalShares = vaultCache.totalShares + amount;\n\n        if (balanceForwarderEnabled) {\n            tryBalanceTrackerHook(account, newBalance.toUint(), false);\n        }\n\n        emit Transfer(address(0), account, amount.toUint());\n        emit Deposit(sender, account, assets.toUint(), amount.toUint());\n    }\n\n    function decreaseBalance(\n        VaultCache memory vaultCache,\n        address account,\n        address sender,\n        address receiver,\n        Shares amount,\n        Assets assets\n    ) internal virtual {\n        (Shares origBalance, bool balanceForwarderEnabled) = vaultStorage.users[account].getBalanceAndBalanceForwarder();\n        if (origBalance < amount) revert E_InsufficientBalance();\n\n        Shares newBalance;\n        unchecked {\n            newBalance = origBalance - amount;\n        }\n\n        vaultStorage.users[account].setBalance(newBalance);\n        vaultStorage.totalShares = vaultCache.totalShares = vaultCache.totalShares - amount;\n\n        if (balanceForwarderEnabled) {\n            // if the balance is decreased as a part of the collateral transfer during liquidation,\n            // which is indicated by the EVC with a collateral control in progress flag,\n            // instruct the balance tracker to forfeit rewards due to the liquidated account, in order to\n            // limit gas consumption, which could potentially be abused by violators to prevent liquidations.\n            tryBalanceTrackerHook(account, newBalance.toUint(), isControlCollateralInProgress());\n        }\n\n        emit Transfer(account, address(0), amount.toUint());\n        emit Withdraw(sender, receiver, account, assets.toUint(), amount.toUint());\n    }\n\n    function transferBalance(address from, address to, Shares amount) internal virtual {\n        if (!amount.isZero()) {\n            (Shares origFromBalance, bool fromBalanceForwarderEnabled) =\n                vaultStorage.users[from].getBalanceAndBalanceForwarder();\n\n            (Shares origToBalance, bool toBalanceForwarderEnabled) =\n                vaultStorage.users[to].getBalanceAndBalanceForwarder();\n\n            if (origFromBalance < amount) revert E_InsufficientBalance();\n\n            Shares newFromBalance;\n            unchecked {\n                newFromBalance = origFromBalance - amount;\n            }\n            Shares newToBalance = origToBalance + amount;\n\n            vaultStorage.users[from].setBalance(newFromBalance);\n            vaultStorage.users[to].setBalance(newToBalance);\n\n            if (fromBalanceForwarderEnabled) {\n                tryBalanceTrackerHook(from, newFromBalance.toUint(), isControlCollateralInProgress());\n            }\n\n            if (toBalanceForwarderEnabled) {\n                tryBalanceTrackerHook(to, newToBalance.toUint(), false);\n            }\n        }\n\n        emit Transfer(from, to, amount.toUint());\n    }\n\n    // Allowance\n\n    function setAllowance(address owner, address spender, uint256 amount) internal {\n        if (spender == owner) revert E_SelfApproval();\n\n        vaultStorage.users[owner].eTokenAllowance[spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function decreaseAllowance(address owner, address spender, Shares amount) internal virtual {\n        if (amount.isZero()) return;\n\n        uint256 allowance = vaultStorage.users[owner].eTokenAllowance[spender];\n        if (owner != spender && allowance != type(uint256).max) {\n            if (allowance < amount.toUint()) revert E_InsufficientAllowance();\n            unchecked {\n                allowance -= amount.toUint();\n            }\n            vaultStorage.users[owner].eTokenAllowance[spender] = allowance;\n            emit Approval(owner, spender, allowance);\n        }\n    }\n\n    function tryBalanceTrackerHook(address account, uint256 newAccountBalance, bool forfeitRecentReward)\n        private\n        returns (bool success)\n    {\n        (success,) = address(balanceTracker).call(\n            abi.encodeCall(IBalanceTracker.balanceTrackerHook, (account, newAccountBalance, forfeitRecentReward))\n        );\n    }\n}"
    }
  ]
}