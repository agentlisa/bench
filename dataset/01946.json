{
  "Title": "H-1: Escrow approvals are not cleared when club is transferred allowing for abuse after transfer",
  "Content": "# Issue H-1: Escrow approvals are not cleared when club is transferred allowing for abuse after transfer \n\nSource: https://github.com/sherlock-audit/2023-04-footium-judging/issues/289 \n\n## Found by \n0x52, BenRai, Brenzee, CMierez, J4de, MiloTruck, PokemonAuditSimulator, Quantish, cergyk, ctf\\_sec, mstpr-brainbot, pengun, sashik\\_eth, shaka, shogoki, toshii\n## Summary\n\nEscrow approvals remain even across club token transfers. This allows a malicious club owners to sell their club then drain everything after sale due to previous approvals.\n\n## Vulnerability Detail\n\nERC20 and ERC721 token approval persist regardless of the owner of the club. The result is that approvals set by one owner can be accessed after a token has been sold or transferred. This allows the following attack:\n\n1) User A owns clubId = 1\n2) User A sets approval to themselves\n3) User A sells clubId = 1 to User B\n4) User A uses persistent approval to drain all players and tokens\n\n## Impact\n\nMalicious approvals can be used to drain club after sale\n\n## Code Snippet\n\n[FootiumEscrow.sol#L75-L81](https://github.com/sherlock-audit/2023-04-footium/blob/main/footium-eth-shareable/contracts/FootiumEscrow.sol#L75-L81)\n\n[FootiumEscrow.sol#L90-L96](https://github.com/sherlock-audit/2023-04-footium/blob/main/footium-eth-shareable/contracts/FootiumEscrow.sol#L90-L96)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nClub escrow system needs to be redesigned\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/71",
  "Code": [
    {
      "filename": "footium-eth-shareable/contracts/FootiumEscrow.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {ERC721Holder} from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport {IERC1271} from \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"./common/Errors.sol\";\n\n/**\n * @title Footium Escrow\n * @notice An escrow contract that stores club's players and tokens.\n */\ncontract FootiumEscrow is ERC721Holder, IERC1271 {\n    bytes4 private constant MAGICVALUE = 0x1626ba7e;\n\n    address private immutable footiumClubAddress;\n    uint256 private immutable clubId;\n\n    event ETHReceived(address sender, uint256 amount);\n\n    /**\n     * @notice Constructs Footium Escrow contract\n     * @param _footiumClubAddress The address of Footium Club contract.\n     * @param _clubId Footium Club ID.\n     */\n    constructor(address _footiumClubAddress, uint256 _clubId) {\n        footiumClubAddress = _footiumClubAddress;\n        clubId = _clubId;\n    }\n\n    modifier onlyClubOwner() {\n        if (msg.sender != IERC721(footiumClubAddress).ownerOf(clubId)) {\n            revert NotClubOwner(clubId, msg.sender);\n        }\n        _;\n    }\n\n    /**\n     * @notice Enables the contract to receive ETH\n     * Emits a {ETHReceived} event when ETH is received.\n     */\n    receive() external payable {\n        emit ETHReceived(msg.sender, msg.value);\n    }\n\n    /**\n     * @notice Checks if the signature is valid.\n     * @param hash The Hashed message.\n     * @param signature The signature of hashed message.\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature)\n        external\n        view\n        returns (bytes4 magicValue)\n    {\n        if (\n            ECDSA.recover(hash, signature) ==\n            IERC721(footiumClubAddress).ownerOf(clubId)\n        ) {\n            return MAGICVALUE;\n        }\n\n        return 0xffffffff;\n    }\n\n    /**\n     * @notice Sets approval for ERC20 tokens.\n     * @param erc20Contract ERC20 contract address.\n     * @param to The address of token spender.\n     * @param amount Token amount to spend.\n     * @dev only the club owner address allowed.\n     */\n    function setApprovalForERC20(\n        IERC20 erc20Contract,\n        address to,\n        uint256 amount\n    ) external onlyClubOwner {\n        erc20Contract.approve(to, amount);\n    }\n\n    /**\n     * @notice Sets approval for ERC721 tokens.\n     * @param erc721Contract ERC721 contract address.\n     * @param to The address of token spender.\n     * @param approved Boolean flag indicating whether approved or not.\n     * @dev only the club owner address allowed.\n     */\n    function setApprovalForERC721(\n        IERC721 erc721Contract,\n        address to,\n        bool approved\n    ) external onlyClubOwner {\n        erc721Contract.setApprovalForAll(to, approved);\n    }\n\n    /**\n     * @notice Transfers ERC20 tokens to `to` address.\n     * @param erc20Contract ERC20 contract address.\n     * @param to Token receiver address.\n     * @param amount Token amount to transfer.\n     * @dev only the club owner address allowed.\n     */\n    function transferERC20(\n        IERC20 erc20Contract,\n        address to,\n        uint256 amount\n    ) external onlyClubOwner {\n        erc20Contract.transfer(to, amount);\n    }\n\n    /**\n     * @notice Transfers ERC721 tokens to `to` address.\n     * @param erc721Contract ERC721 contract address.\n     * @param to Token receiver address.\n     * @param tokenId Token ID to be transferred.\n     * @dev only the club owner address allowed.\n     */\n    function transferERC721(\n        IERC721 erc721Contract,\n        address to,\n        uint256 tokenId\n    ) external onlyClubOwner {\n        erc721Contract.safeTransferFrom(address(this), to, tokenId);\n    }\n\n    /**\n     * @notice Transfers contract available ether balance to the club owner address\n     * @dev Only club owner address allowed\n     */\n    function withdraw() external onlyClubOwner {\n        uint256 balance = address(this).balance;\n        if (balance > 0) {\n            (bool sent, ) = payable(msg.sender).call{value: balance}(\"\");\n            if (!sent) {\n                revert FailedToSendETH(balance);\n            }\n        }\n    }\n}"
    },
    {
      "filename": "footium-eth-shareable/contracts/FootiumEscrow.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {ERC721Holder} from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport {IERC1271} from \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"./common/Errors.sol\";\n\n/**\n * @title Footium Escrow\n * @notice An escrow contract that stores club's players and tokens.\n */\ncontract FootiumEscrow is ERC721Holder, IERC1271 {\n    bytes4 private constant MAGICVALUE = 0x1626ba7e;\n\n    address private immutable footiumClubAddress;\n    uint256 private immutable clubId;\n\n    event ETHReceived(address sender, uint256 amount);\n\n    /**\n     * @notice Constructs Footium Escrow contract\n     * @param _footiumClubAddress The address of Footium Club contract.\n     * @param _clubId Footium Club ID.\n     */\n    constructor(address _footiumClubAddress, uint256 _clubId) {\n        footiumClubAddress = _footiumClubAddress;\n        clubId = _clubId;\n    }\n\n    modifier onlyClubOwner() {\n        if (msg.sender != IERC721(footiumClubAddress).ownerOf(clubId)) {\n            revert NotClubOwner(clubId, msg.sender);\n        }\n        _;\n    }\n\n    /**\n     * @notice Enables the contract to receive ETH\n     * Emits a {ETHReceived} event when ETH is received.\n     */\n    receive() external payable {\n        emit ETHReceived(msg.sender, msg.value);\n    }\n\n    /**\n     * @notice Checks if the signature is valid.\n     * @param hash The Hashed message.\n     * @param signature The signature of hashed message.\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature)\n        external\n        view\n        returns (bytes4 magicValue)\n    {\n        if (\n            ECDSA.recover(hash, signature) ==\n            IERC721(footiumClubAddress).ownerOf(clubId)\n        ) {\n            return MAGICVALUE;\n        }\n\n        return 0xffffffff;\n    }\n\n    /**\n     * @notice Sets approval for ERC20 tokens.\n     * @param erc20Contract ERC20 contract address.\n     * @param to The address of token spender.\n     * @param amount Token amount to spend.\n     * @dev only the club owner address allowed.\n     */\n    function setApprovalForERC20(\n        IERC20 erc20Contract,\n        address to,\n        uint256 amount\n    ) external onlyClubOwner {\n        erc20Contract.approve(to, amount);\n    }\n\n    /**\n     * @notice Sets approval for ERC721 tokens.\n     * @param erc721Contract ERC721 contract address.\n     * @param to The address of token spender.\n     * @param approved Boolean flag indicating whether approved or not.\n     * @dev only the club owner address allowed.\n     */\n    function setApprovalForERC721(\n        IERC721 erc721Contract,\n        address to,\n        bool approved\n    ) external onlyClubOwner {\n        erc721Contract.setApprovalForAll(to, approved);\n    }\n\n    /**\n     * @notice Transfers ERC20 tokens to `to` address.\n     * @param erc20Contract ERC20 contract address.\n     * @param to Token receiver address.\n     * @param amount Token amount to transfer.\n     * @dev only the club owner address allowed.\n     */\n    function transferERC20(\n        IERC20 erc20Contract,\n        address to,\n        uint256 amount\n    ) external onlyClubOwner {\n        erc20Contract.transfer(to, amount);\n    }\n\n    /**\n     * @notice Transfers ERC721 tokens to `to` address.\n     * @param erc721Contract ERC721 contract address.\n     * @param to Token receiver address.\n     * @param tokenId Token ID to be transferred.\n     * @dev only the club owner address allowed.\n     */\n    function transferERC721(\n        IERC721 erc721Contract,\n        address to,\n        uint256 tokenId\n    ) external onlyClubOwner {\n        erc721Contract.safeTransferFrom(address(this), to, tokenId);\n    }\n\n    /**\n     * @notice Transfers contract available ether balance to the club owner address\n     * @dev Only club owner address allowed\n     */\n    function withdraw() external onlyClubOwner {\n        uint256 balance = address(this).balance;\n        if (balance > 0) {\n            (bool sent, ) = payable(msg.sender).call{value: balance}(\"\");\n            if (!sent) {\n                revert FailedToSendETH(balance);\n            }\n        }\n    }\n}"
    }
  ]
}