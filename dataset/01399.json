{
  "Title": "M-9: Price returned by Oracle is not verified",
  "Content": "# Issue M-9: Price returned by Oracle is not verified \n\nSource: https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/604 \n\n## Found by \nxiaoming90\n\nThe price returned by the oracle is not adequately verified, leading to incorrect pricing being accepted.\n\n## Vulnerability Detail\n\nAs per the [example](https://github.com/tellor-io/tellor-caller-liquity/blob/3ed91e4b15f0bac737f2966e36805ade3daf8162/contracts/TellorCaller.sol#L51C34-L51C34) provided by Tellor on how to integrate the Tellor oracle into the system, it has shown the need to check that the price returned by the oracle is not zero.\n\nhttps://github.com/tellor-io/tellor-caller-liquity/blob/3ed91e4b15f0bac737f2966e36805ade3daf8162/contracts/TellorCaller.sol#L51C34-L51C34\n\n```solidity\nfunction getTellorCurrentValue(bytes32 _queryId)\n\t..SNIP..\n    // retrieve most recent 20+ minute old value for a queryId. the time buffer allows time for a bad value to be disputed\n    (, bytes memory data, uint256 timestamp) = tellor.getDataBefore(_queryId, block.timestamp - 20 minutes);\n    uint256 _value = abi.decode(data, (uint256));\n    if (timestamp == 0 || _value == 0) return (false, _value, timestamp);\n```\n\nThus, the value returned from the `getDataBefore` function should be verified to ensure that the price returned by the oracle is not zero. However, this was not implemented.\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/oracles/providers/TellorOracle.sol#L101\n\n```solidity\nFile: TellorOracle.sol\n101:     function getPriceInEth(address tokenToPrice) external returns (uint256) {\n102:         TellorInfo memory tellorInfo = _getQueryInfo(tokenToPrice);\n103:         uint256 timestamp = block.timestamp;\n104:         // Giving time for Tellor network to dispute price\n105:         (bytes memory value, uint256 timestampRetrieved) = getDataBefore(tellorInfo.queryId, timestamp - 30 minutes);\n106:         uint256 tellorStoredTimeout = uint256(tellorInfo.pricingTimeout);\n107:         uint256 tokenPricingTimeout = tellorStoredTimeout == 0 ? DEFAULT_PRICING_TIMEOUT : tellorStoredTimeout;\n108: \n109:         // Check that something was returned and freshness of price.\n110:         if (timestampRetrieved == 0 || timestamp - timestampRetrieved > tokenPricingTimeout) {\n111:             revert InvalidDataReturned();\n112:         }\n113: \n114:         uint256 price = abi.decode(value, (uint256));\n115:         return _denominationPricing(tellorInfo.denomination, price, tokenToPrice);\n116:     }\n```\n\n## Impact\n\nThe protocol relies on the oracle to provide accurate pricing for many critical operations, such as determining the debt values of DV, calculators/stats used during the rebalancing process, NAV/shares of the LMPVault, and determining how much assets the users should receive during withdrawal.\n\nIf an incorrect value of zero is returned from Tellor, affected assets within the protocol will be considered worthless.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/oracles/providers/TellorOracle.sol#L101\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUpdate the affected function as follows.\n\n```diff\nfunction getPriceInEth(address tokenToPrice) external returns (uint256) {\n    TellorInfo memory tellorInfo = _getQueryInfo(tokenToPrice);\n    uint256 timestamp = block.timestamp;\n    // Giving time for Tellor network to dispute price\n    (bytes memory value, uint256 timestampRetrieved) = getDataBefore(tellorInfo.queryId, timestamp - 30 minutes);\n    uint256 tellorStoredTimeout = uint256(tellorInfo.pricingTimeout);\n    uint256 tokenPricingTimeout = tellorStoredTimeout == 0 ? DEFAULT_PRICING_TIMEOUT : tellorStoredTimeout;\n\n    // Check that something was returned and freshness of price.\n-   if (timestampRetrieved == 0 || timestamp - timestampRetrieved > tokenPricingTimeout) {\n+\tif (timestampRetrieved == 0 || value == 0 || timestamp - timestampRetrieved > tokenPricingTimeout) {\n        revert InvalidDataReturned();\n    }\n\n    uint256 price = abi.decode(value, (uint256));\n    return _denominationPricing(tellorInfo.denomination, price, tokenToPrice);\n}\n```\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**Trumpero** commented:\n> low, similar to chainlink round completeness\n\n\n\n**xiaoming9090**\n\nEscalate\n\nThe reason why chainlink round completeness is considered invalid/low in Sherlock is that the OCR does not rely on rounds for reporting anymore. Not validating the price returned from the oracle is zero is a much more serious issue and is different from the round completeness issue related to lagged/outdated price.\n\nIf an incorrect value of zero is returned from Tellor, affected assets within the protocol will be considered worthless. Thus, it is important that this check must be done. In addition, per the [example](https://github.com/tellor-io/tellor-caller-liquity/blob/3ed91e4b15f0bac737f2966e36805ade3daf8162/contracts/TellorCaller.sol#L51C34-L51C34) provided by Tellor on how to integrate the Tellor oracle into the system, it has shown the need to check that the price returned by the oracle is not zero.\n\nThus, this is a valid High issue.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> The reason why chainlink round completeness is considered invalid/low in Sherlock is that the OCR does not rely on rounds for reporting anymore. Not validating the price returned from the oracle is zero is a much more serious issue and is different from the round completeness issue related to lagged/outdated price.\n> \n> If an incorrect value of zero is returned from Tellor, affected assets within the protocol will be considered worthless. Thus, it is important that this check must be done. In addition, per the [example](https://github.com/tellor-io/tellor-caller-liquity/blob/3ed91e4b15f0bac737f2966e36805ade3daf8162/contracts/TellorCaller.sol#L51C34-L51C34) provided by Tellor on how to integrate the Tellor oracle into the system, it has shown the need to check that the price returned by the oracle is not zero.\n> \n> Thus, this is a valid High issue.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Trumpero**\n\nHello @xiaoming9090, according to the information I found in the [Tellor documentation](https://docs.tellor.io/tellor/getting-data/solidity-integration#reading-data) under the section \"Solidity Integration,\" the [provided example](https://github.com/tellor-io/sampleUsingTellor/blob/master/contracts/SampleUsingTellor.sol) in the documentation differs from the example you provided, and it lacks a check for the 0-value.\n\nCould you please provide more details about the source of your example?\n\n**xiaoming9090**\n\nHey @Trumpero, the repo can be found in the [Tellor's User Checklist](https://docs.tellor.io/tellor/getting-data/user-checklists#ensure-that-functions-do-not-use-old-tellor-values), which is a guide that the protocol team need to go through before using the Tellor oracle.\n\nOne point to make is that [Chainlink](https://docs.chain.link/data-feeds/getting-started#examine-the-sample-contract) or Tellor would not provide an example that checks for zero-value in all their examples. The reason is that not all use cases require zero-value checks. Suppose a simple protocol performs a non-price-sensitive operation, such as fetching a price to emit an event for the protocol team's internal reference. In that case, there is no need to check for zero value.\n\nHowever, for Tokemak and many other protocols involving financial transactions, it is critical that the price of assets cannot be zero due to errors from Oracle. Thus, a zero-values check is consistently implemented on such kind of protocols. Therefore, we need to determine if a zero-values check is required on a case-by-case basis. In this case, Tokemak falls under the latter group.\n\n**Trumpero**\n\nTks @xiaoming9090, understand it now. Seem a valid issue for me @codenutt. \nThe severity for me should be medium, since it assumes the tellor oracle returns a 0 price value. \n\n**Evert0x**\n\nPlanning to accept escalation and make issue medium\n\n**codenutt**\n\n@Trumpero  Our goal with the check is to verify that a price was actually found. Based on their contract checking for timestamp == 0 is sufficient as it returns both 0 and 0 in this state: https://github.com/tellor-io/tellorFlex/blob/bdefcab6d90d4e86c34253fdc9e1ec778f370c3c/contracts/TellorFlex.sol#L450\n\n**Trumpero**\n\nBased on the sponsor's comment, I think this issue is low. \n\n**Evert0x**\n\nPlanning to reject escalation and keep issue state as is @xiaoming9090 \n\n\n**xiaoming9090**\n\nThe [sponsor's comment](https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/604#issuecomment-1778408999) simply explains the purpose/intention of the [if-condition](https://github.com/sherlock-audit/2023-06-tokemak/blob/5d8e902ce33981a6506b1b5fb979a084602c6c9a/v2-core-audit-2023-07-14/src/oracles/providers/TellorOracle.sol#L110) is to check that a price is returned from Tellor Oracle. However, this does not necessarily mean that it is fine that the returned price is zero OR there is no risk if the return price is zero.\n\nThe protocol uses two (2) oracles (Chainlink and Tellor). In their Chainlink oracle's implementation, the protocol has explicitly checked that the price returned is more than zero. Otherwise, the oracle will revert. Thus, it is obvious that zero price is not accepted to the protocol based on the codebase.\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/5d8e902ce33981a6506b1b5fb979a084602c6c9a/v2-core-audit-2023-07-14/src/oracles/providers/ChainlinkOracle.sol#L113\n```solidity\nif (\n\troundId == 0 || price <= 0 || updatedAt == 0 || updatedAt > timestamp\n\t\t|| updatedAt < timestamp - tokenPricingTimeout\n) revert InvalidDataReturned();\n```\nHowever, this was not consistently implemented in their Tellor's oracle, which is highlighted in this report.\n\nIn addition, as pointed out in my earlier escalation. for Tokemak and many other protocols involving financial transactions, it is critical that the price of assets cannot be zero. Thus, a zero-values check is consistently implemented on such kind of protocols. Some examples are as follows:\n- AAVE - [Source Code](https://github.com/aave/aave-protocol/blob/4b4545fb583fd4f400507b10f3c3114f45b8a037/contracts/misc/ChainlinkProxyPriceProvider.sol#L78) and [Documentation](https://docs.aave.com/developers/v/1.0/developing-on-aave/the-protocol/price-oracle)\n- Compound - [Source Code](https://github.com/compound-finance/comet/blob/22cf923b6263177555272dde8b0791703895517d/contracts/pricefeeds/WBTCPriceFeed.sol#L69)\n\n**Evert0x**\n\nThanks @xiaoming9090 \n\nThe core issue is that 0 value isn't handled well. There is no counter argument to this in the recent comments.\n\nPlanning to accept escalation and make issue medium\n\n\n\n\n\n**Evert0x**\n\n@Trumpero let me know if you agree with this. \n\n**Trumpero**\n\nI agree that this issue should be a medium within the scope of Tokemak contracts.\n\n**Evert0x**\n\nResult:\nMedium\nUnique\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [xiaoming9090](https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/604/#issuecomment-1748034104): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/101",
  "Code": [
    {
      "filename": "contracts/TellorCaller.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"./interfaces/ITellorCaller.sol\";\nimport \"./interfaces/ITellor.sol\";\n/*\n* This contract serves as an example of how to integrate the Tellor oracle into a Liquity-like system. It\n* utilizes a best practice for using Tellor by implementing a time buffer. In addition, by caching the most \n* recent value and timestamp, it also seeks to limit dispute attacks.\n* \n* This contract has a single external function that calls Tellor: getTellorCurrentValue(). \n*\n* The function is called by the Liquity contract PriceFeed.sol. If any of its inner calls to Tellor revert, \n* this function will revert, and PriceFeed will catch the failure and handle it accordingly.\n*\n*/\ncontract TellorCaller is ITellorCaller {\n    ITellor public tellor;\n\n    mapping (bytes32 => uint256) public lastStoredTimestamps;\n    mapping (bytes32 => uint256) public lastStoredPrices;\n\n    constructor (address payable _tellorOracleAddress) public {\n        tellor = ITellor(_tellorOracleAddress);\n    }\n\n    /*\n    * getTellorCurrentValue(): retrieves most recent value with a 20 minute time buffer.\n    * This buffer can be updated before deployment.\n    *\n    * @dev Allows the user to get the latest value with a time buffer for the queryId specified\n    * @param _queryId is the queryId to look up the value for\n    * @return ifRetrieve bool true if it is able to retrieve a value and the value's timestamp\n    * @return value the value retrieved, converted from bytes to a uint256 value\n    * @return _timestampRetrieved the value's timestamp\n    */\n    function getTellorCurrentValue(bytes32 _queryId)\n        external\n        override\n        returns (\n            bool ifRetrieve,\n            uint256 value,\n            uint256 _timestampRetrieved\n        )\n    {\n        // retrieve most recent 20+ minute old value for a queryId. the time buffer allows time for a bad value to be disputed\n        (, bytes memory data, uint256 timestamp) = tellor.getDataBefore(_queryId, block.timestamp - 20 minutes);\n        uint256 _value = abi.decode(data, (uint256));\n        if (timestamp == 0 || _value == 0) return (false, _value, timestamp);\n        if (timestamp > lastStoredTimestamps[_queryId]) {\n            lastStoredTimestamps[_queryId] = timestamp;\n            lastStoredPrices[_queryId] = _value;\n            return (true, _value, timestamp);\n        } else {\n            return (true, lastStoredPrices[_queryId], lastStoredTimestamps[_queryId]);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/TellorCaller.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"./interfaces/ITellorCaller.sol\";\nimport \"./interfaces/ITellor.sol\";\n/*\n* This contract serves as an example of how to integrate the Tellor oracle into a Liquity-like system. It\n* utilizes a best practice for using Tellor by implementing a time buffer. In addition, by caching the most \n* recent value and timestamp, it also seeks to limit dispute attacks.\n* \n* This contract has a single external function that calls Tellor: getTellorCurrentValue(). \n*\n* The function is called by the Liquity contract PriceFeed.sol. If any of its inner calls to Tellor revert, \n* this function will revert, and PriceFeed will catch the failure and handle it accordingly.\n*\n*/\ncontract TellorCaller is ITellorCaller {\n    ITellor public tellor;\n\n    mapping (bytes32 => uint256) public lastStoredTimestamps;\n    mapping (bytes32 => uint256) public lastStoredPrices;\n\n    constructor (address payable _tellorOracleAddress) public {\n        tellor = ITellor(_tellorOracleAddress);\n    }\n\n    /*\n    * getTellorCurrentValue(): retrieves most recent value with a 20 minute time buffer.\n    * This buffer can be updated before deployment.\n    *\n    * @dev Allows the user to get the latest value with a time buffer for the queryId specified\n    * @param _queryId is the queryId to look up the value for\n    * @return ifRetrieve bool true if it is able to retrieve a value and the value's timestamp\n    * @return value the value retrieved, converted from bytes to a uint256 value\n    * @return _timestampRetrieved the value's timestamp\n    */\n    function getTellorCurrentValue(bytes32 _queryId)\n        external\n        override\n        returns (\n            bool ifRetrieve,\n            uint256 value,\n            uint256 _timestampRetrieved\n        )\n    {\n        // retrieve most recent 20+ minute old value for a queryId. the time buffer allows time for a bad value to be disputed\n        (, bytes memory data, uint256 timestamp) = tellor.getDataBefore(_queryId, block.timestamp - 20 minutes);\n        uint256 _value = abi.decode(data, (uint256));\n        if (timestamp == 0 || _value == 0) return (false, _value, timestamp);\n        if (timestamp > lastStoredTimestamps[_queryId]) {\n            lastStoredTimestamps[_queryId] = timestamp;\n            lastStoredPrices[_queryId] = _value;\n            return (true, _value, timestamp);\n        } else {\n            return (true, lastStoredPrices[_queryId], lastStoredTimestamps[_queryId]);\n        }\n    }\n}"
    },
    {
      "filename": "v2-core-audit-2023-07-14/src/oracles/providers/TellorOracle.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\n\npragma solidity 0.8.17;\n\nimport { BaseOracleDenominations, ISystemRegistry } from \"src/oracles/providers/base/BaseOracleDenominations.sol\";\nimport { IEthValueOracle } from \"src/interfaces/pricing/IEthValueOracle.sol\";\nimport { Errors } from \"src/utils/Errors.sol\";\n\nimport { UsingTellor } from \"usingtellor/UsingTellor.sol\";\n\n/**\n * @title Gets the spot price of tokens that Tellor provides a feed for.\n * @dev Will convert all tokens to Eth pricing regardless of original denomination.\n * @dev Returns 18 decimals of precision.\n */\ncontract TellorOracle is BaseOracleDenominations, UsingTellor {\n    /**\n     * @notice Used to store information about Tellor price queries.\n     * @dev No decimals, all returned in e18 precision.\n     * @param queryId bytes32 queryId for pricing query. See here: https://tellor.io/queryidstation/.\n     * @param pricingTimeout Custom timeout for asset.  If 0, contract will use default defined in\n     *    `BaseOracleDenominations.sol`.\n     * @param denomination Enum representing denomination of price returned.\n     */\n    struct TellorInfo {\n        bytes32 queryId;\n        uint32 pricingTimeout;\n        Denomination denomination;\n    }\n\n    /// @dev Token address to TellorInfo structs.\n    mapping(address => TellorInfo) private tellorQueryInfo;\n\n    /// @notice Emitted when information about a Tellor query is registered.\n    event TellorRegistrationAdded(address token, Denomination denomination, bytes32 _queryId);\n\n    /// @notice Emitted when  information about a Tellor query is removed.\n    event TellorRegistrationRemoved(address token, bytes32 queryId);\n\n    constructor(\n        ISystemRegistry _systemRegistry,\n        address _tellorOracleAddress\n    )\n        // Tellor requires payable address\n        UsingTellor(payable(_tellorOracleAddress))\n        BaseOracleDenominations(_systemRegistry)\n    {\n        Errors.verifyNotZero(_tellorOracleAddress, \"tellor\");\n    }\n\n    /**\n     * @notice Allows permissioned address to set _queryId, denomination for token address.\n     * @param token Address of token to set queryId for.\n     * @param _queryId Bytes32 queryId.\n     * @param denomination Denomination of token.\n     * @param pricingTimeout Custom timeout for queryId if needed.  Can be set to zero\n     *      to use default defined in `BaseOracleDenominations.sol`.\n     */\n    function addTellorRegistration(\n        address token,\n        bytes32 _queryId,\n        Denomination denomination,\n        uint32 pricingTimeout\n    ) external onlyOwner {\n        Errors.verifyNotZero(token, \"tokenForQueryId\");\n        Errors.verifyNotZero(_queryId, \"queryId\");\n        if (tellorQueryInfo[token].queryId != bytes32(0)) revert Errors.MustBeZero();\n        tellorQueryInfo[token] =\n            TellorInfo({ queryId: _queryId, denomination: denomination, pricingTimeout: pricingTimeout });\n        emit TellorRegistrationAdded(token, denomination, _queryId);\n    }\n\n    /**\n     * @notice Allows permissioned removal registration for token address.\n     * @param token Token to remove TellorInfo struct for.\n     */\n    function removeTellorRegistration(address token) external onlyOwner {\n        Errors.verifyNotZero(token, \"tokenToRemoveRegistration\");\n        bytes32 queryIdBeforeDeletion = tellorQueryInfo[token].queryId;\n        Errors.verifyNotZero(queryIdBeforeDeletion, \"queryIdBeforeDeletion\");\n        delete tellorQueryInfo[token];\n        emit TellorRegistrationRemoved(token, queryIdBeforeDeletion);\n    }\n\n    /**\n     * @notice External function to view TellorInfo struct for token address.\n     * @dev Will return empty struct for unregistered token address.\n     * @param token Address of token to view TellorInfo struct for.\n     */\n    function getQueryInfo(address token) external view returns (TellorInfo memory) {\n        return tellorQueryInfo[token];\n    }\n\n    /**\n     * @dev Tellor always returns prices with 18 decimals of precision for spot pricing, so we do not need\n     *      to worry about increasing or decreasing precision here.  See here:\n     *      https://github.com/tellor-io/dataSpecs/blob/main/types/SpotPrice.md\n     */\n    // slither-disable-start timestamp\n    function getPriceInEth(address tokenToPrice) external returns (uint256) {\n        TellorInfo memory tellorInfo = _getQueryInfo(tokenToPrice);\n        uint256 timestamp = block.timestamp;\n        // Giving time for Tellor network to dispute price\n        (bytes memory value, uint256 timestampRetrieved) = getDataBefore(tellorInfo.queryId, timestamp - 30 minutes);\n        uint256 tellorStoredTimeout = uint256(tellorInfo.pricingTimeout);\n        uint256 tokenPricingTimeout = tellorStoredTimeout == 0 ? DEFAULT_PRICING_TIMEOUT : tellorStoredTimeout;\n\n        // Check that something was returned and freshness of price.\n        if (timestampRetrieved == 0 || timestamp - timestampRetrieved > tokenPricingTimeout) {\n            revert InvalidDataReturned();\n        }\n\n        uint256 price = abi.decode(value, (uint256));\n        return _denominationPricing(tellorInfo.denomination, price, tokenToPrice);\n    }\n    // slither-disable-end timestamp\n\n    /// @dev Used to enforce non-existent queryId checks\n    function _getQueryInfo(address token) private view returns (TellorInfo memory tellorInfo) {\n        tellorInfo = tellorQueryInfo[token];\n        Errors.verifyNotZero(tellorInfo.queryId, \"queryId\");\n    }\n}"
    },
    {
      "filename": "v2-core-audit-2023-07-14/src/oracles/providers/TellorOracle.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\n\npragma solidity 0.8.17;\n\nimport { BaseOracleDenominations, ISystemRegistry } from \"src/oracles/providers/base/BaseOracleDenominations.sol\";\nimport { IEthValueOracle } from \"src/interfaces/pricing/IEthValueOracle.sol\";\nimport { Errors } from \"src/utils/Errors.sol\";\n\nimport { UsingTellor } from \"usingtellor/UsingTellor.sol\";\n\n/**\n * @title Gets the spot price of tokens that Tellor provides a feed for.\n * @dev Will convert all tokens to Eth pricing regardless of original denomination.\n * @dev Returns 18 decimals of precision.\n */\ncontract TellorOracle is BaseOracleDenominations, UsingTellor {\n    /**\n     * @notice Used to store information about Tellor price queries.\n     * @dev No decimals, all returned in e18 precision.\n     * @param queryId bytes32 queryId for pricing query. See here: https://tellor.io/queryidstation/.\n     * @param pricingTimeout Custom timeout for asset.  If 0, contract will use default defined in\n     *    `BaseOracleDenominations.sol`.\n     * @param denomination Enum representing denomination of price returned.\n     */\n    struct TellorInfo {\n        bytes32 queryId;\n        uint32 pricingTimeout;\n        Denomination denomination;\n    }\n\n    /// @dev Token address to TellorInfo structs.\n    mapping(address => TellorInfo) private tellorQueryInfo;\n\n    /// @notice Emitted when information about a Tellor query is registered.\n    event TellorRegistrationAdded(address token, Denomination denomination, bytes32 _queryId);\n\n    /// @notice Emitted when  information about a Tellor query is removed.\n    event TellorRegistrationRemoved(address token, bytes32 queryId);\n\n    constructor(\n        ISystemRegistry _systemRegistry,\n        address _tellorOracleAddress\n    )\n        // Tellor requires payable address\n        UsingTellor(payable(_tellorOracleAddress))\n        BaseOracleDenominations(_systemRegistry)\n    {\n        Errors.verifyNotZero(_tellorOracleAddress, \"tellor\");\n    }\n\n    /**\n     * @notice Allows permissioned address to set _queryId, denomination for token address.\n     * @param token Address of token to set queryId for.\n     * @param _queryId Bytes32 queryId.\n     * @param denomination Denomination of token.\n     * @param pricingTimeout Custom timeout for queryId if needed.  Can be set to zero\n     *      to use default defined in `BaseOracleDenominations.sol`.\n     */\n    function addTellorRegistration(\n        address token,\n        bytes32 _queryId,\n        Denomination denomination,\n        uint32 pricingTimeout\n    ) external onlyOwner {\n        Errors.verifyNotZero(token, \"tokenForQueryId\");\n        Errors.verifyNotZero(_queryId, \"queryId\");\n        if (tellorQueryInfo[token].queryId != bytes32(0)) revert Errors.MustBeZero();\n        tellorQueryInfo[token] =\n            TellorInfo({ queryId: _queryId, denomination: denomination, pricingTimeout: pricingTimeout });\n        emit TellorRegistrationAdded(token, denomination, _queryId);\n    }\n\n    /**\n     * @notice Allows permissioned removal registration for token address.\n     * @param token Token to remove TellorInfo struct for.\n     */\n    function removeTellorRegistration(address token) external onlyOwner {\n        Errors.verifyNotZero(token, \"tokenToRemoveRegistration\");\n        bytes32 queryIdBeforeDeletion = tellorQueryInfo[token].queryId;\n        Errors.verifyNotZero(queryIdBeforeDeletion, \"queryIdBeforeDeletion\");\n        delete tellorQueryInfo[token];\n        emit TellorRegistrationRemoved(token, queryIdBeforeDeletion);\n    }\n\n    /**\n     * @notice External function to view TellorInfo struct for token address.\n     * @dev Will return empty struct for unregistered token address.\n     * @param token Address of token to view TellorInfo struct for.\n     */\n    function getQueryInfo(address token) external view returns (TellorInfo memory) {\n        return tellorQueryInfo[token];\n    }\n\n    /**\n     * @dev Tellor always returns prices with 18 decimals of precision for spot pricing, so we do not need\n     *      to worry about increasing or decreasing precision here.  See here:\n     *      https://github.com/tellor-io/dataSpecs/blob/main/types/SpotPrice.md\n     */\n    // slither-disable-start timestamp\n    function getPriceInEth(address tokenToPrice) external returns (uint256) {\n        TellorInfo memory tellorInfo = _getQueryInfo(tokenToPrice);\n        uint256 timestamp = block.timestamp;\n        // Giving time for Tellor network to dispute price\n        (bytes memory value, uint256 timestampRetrieved) = getDataBefore(tellorInfo.queryId, timestamp - 30 minutes);\n        uint256 tellorStoredTimeout = uint256(tellorInfo.pricingTimeout);\n        uint256 tokenPricingTimeout = tellorStoredTimeout == 0 ? DEFAULT_PRICING_TIMEOUT : tellorStoredTimeout;\n\n        // Check that something was returned and freshness of price.\n        if (timestampRetrieved == 0 || timestamp - timestampRetrieved > tokenPricingTimeout) {\n            revert InvalidDataReturned();\n        }\n\n        uint256 price = abi.decode(value, (uint256));\n        return _denominationPricing(tellorInfo.denomination, price, tokenToPrice);\n    }\n    // slither-disable-end timestamp\n\n    /// @dev Used to enforce non-existent queryId checks\n    function _getQueryInfo(address token) private view returns (TellorInfo memory tellorInfo) {\n        tellorInfo = tellorQueryInfo[token];\n        Errors.verifyNotZero(tellorInfo.queryId, \"queryId\");\n    }\n}"
    },
    {
      "filename": "contracts/TellorCaller.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"./interfaces/ITellorCaller.sol\";\nimport \"./interfaces/ITellor.sol\";\n/*\n* This contract serves as an example of how to integrate the Tellor oracle into a Liquity-like system. It\n* utilizes a best practice for using Tellor by implementing a time buffer. In addition, by caching the most \n* recent value and timestamp, it also seeks to limit dispute attacks.\n* \n* This contract has a single external function that calls Tellor: getTellorCurrentValue(). \n*\n* The function is called by the Liquity contract PriceFeed.sol. If any of its inner calls to Tellor revert, \n* this function will revert, and PriceFeed will catch the failure and handle it accordingly.\n*\n*/\ncontract TellorCaller is ITellorCaller {\n    ITellor public tellor;\n\n    mapping (bytes32 => uint256) public lastStoredTimestamps;\n    mapping (bytes32 => uint256) public lastStoredPrices;\n\n    constructor (address payable _tellorOracleAddress) public {\n        tellor = ITellor(_tellorOracleAddress);\n    }\n\n    /*\n    * getTellorCurrentValue(): retrieves most recent value with a 20 minute time buffer.\n    * This buffer can be updated before deployment.\n    *\n    * @dev Allows the user to get the latest value with a time buffer for the queryId specified\n    * @param _queryId is the queryId to look up the value for\n    * @return ifRetrieve bool true if it is able to retrieve a value and the value's timestamp\n    * @return value the value retrieved, converted from bytes to a uint256 value\n    * @return _timestampRetrieved the value's timestamp\n    */\n    function getTellorCurrentValue(bytes32 _queryId)\n        external\n        override\n        returns (\n            bool ifRetrieve,\n            uint256 value,\n            uint256 _timestampRetrieved\n        )\n    {\n        // retrieve most recent 20+ minute old value for a queryId. the time buffer allows time for a bad value to be disputed\n        (, bytes memory data, uint256 timestamp) = tellor.getDataBefore(_queryId, block.timestamp - 20 minutes);\n        uint256 _value = abi.decode(data, (uint256));\n        if (timestamp == 0 || _value == 0) return (false, _value, timestamp);\n        if (timestamp > lastStoredTimestamps[_queryId]) {\n            lastStoredTimestamps[_queryId] = timestamp;\n            lastStoredPrices[_queryId] = _value;\n            return (true, _value, timestamp);\n        } else {\n            return (true, lastStoredPrices[_queryId], lastStoredTimestamps[_queryId]);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/TellorCaller.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"./interfaces/ITellorCaller.sol\";\nimport \"./interfaces/ITellor.sol\";\n/*\n* This contract serves as an example of how to integrate the Tellor oracle into a Liquity-like system. It\n* utilizes a best practice for using Tellor by implementing a time buffer. In addition, by caching the most \n* recent value and timestamp, it also seeks to limit dispute attacks.\n* \n* This contract has a single external function that calls Tellor: getTellorCurrentValue(). \n*\n* The function is called by the Liquity contract PriceFeed.sol. If any of its inner calls to Tellor revert, \n* this function will revert, and PriceFeed will catch the failure and handle it accordingly.\n*\n*/\ncontract TellorCaller is ITellorCaller {\n    ITellor public tellor;\n\n    mapping (bytes32 => uint256) public lastStoredTimestamps;\n    mapping (bytes32 => uint256) public lastStoredPrices;\n\n    constructor (address payable _tellorOracleAddress) public {\n        tellor = ITellor(_tellorOracleAddress);\n    }\n\n    /*\n    * getTellorCurrentValue(): retrieves most recent value with a 20 minute time buffer.\n    * This buffer can be updated before deployment.\n    *\n    * @dev Allows the user to get the latest value with a time buffer for the queryId specified\n    * @param _queryId is the queryId to look up the value for\n    * @return ifRetrieve bool true if it is able to retrieve a value and the value's timestamp\n    * @return value the value retrieved, converted from bytes to a uint256 value\n    * @return _timestampRetrieved the value's timestamp\n    */\n    function getTellorCurrentValue(bytes32 _queryId)\n        external\n        override\n        returns (\n            bool ifRetrieve,\n            uint256 value,\n            uint256 _timestampRetrieved\n        )\n    {\n        // retrieve most recent 20+ minute old value for a queryId. the time buffer allows time for a bad value to be disputed\n        (, bytes memory data, uint256 timestamp) = tellor.getDataBefore(_queryId, block.timestamp - 20 minutes);\n        uint256 _value = abi.decode(data, (uint256));\n        if (timestamp == 0 || _value == 0) return (false, _value, timestamp);\n        if (timestamp > lastStoredTimestamps[_queryId]) {\n            lastStoredTimestamps[_queryId] = timestamp;\n            lastStoredPrices[_queryId] = _value;\n            return (true, _value, timestamp);\n        } else {\n            return (true, lastStoredPrices[_queryId], lastStoredTimestamps[_queryId]);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/TellorFlex.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\nimport \"./interfaces/IERC20.sol\";\n\n/**\n @author Tellor Inc.\n @title TellorFlex\n @dev This is a streamlined Tellor oracle system which handles staking, reporting,\n * slashing, and user data getters in one contract. This contract is controlled\n * by a single address known as 'governance', which could be an externally owned\n * account or a contract, allowing for a flexible, modular design.\n*/\ncontract TellorFlex {\n    // Storage\n    IERC20 public token; // token used for staking and rewards\n    address public governance; // address with ability to remove values and slash reporters\n    address public owner; // contract deployer, can call init function once\n    uint256 public accumulatedRewardPerShare; // accumulated staking reward per staked token\n    uint256 public minimumStakeAmount; // minimum amount of tokens required to stake\n    uint256 public reportingLock; // base amount of time before a reporter is able to submit a value again\n    uint256 public rewardRate; // total staking rewards released per second\n    uint256 public stakeAmount; // minimum amount required to be a staker\n    uint256 public stakeAmountDollarTarget; // amount of US dollars required to be a staker\n    uint256 public stakingRewardsBalance; // total amount of staking rewards\n    bytes32 public stakingTokenPriceQueryId; // staking token SpotPrice queryId, used for updating stakeAmount\n    uint256 public timeBasedReward = 5e17; // amount of TB rewards released per 5 minutes\n    uint256 public timeOfLastAllocation; // time of last update to accumulatedRewardPerShare\n    uint256 public timeOfLastNewValue = block.timestamp; // time of the last new submitted value, originally set to the block timestamp\n    uint256 public totalRewardDebt; // staking reward debt, used to calculate real staking rewards balance\n    uint256 public totalStakeAmount; // total amount of tokens locked in contract (via stake)\n    uint256 public totalStakers; // total number of stakers with at least stakeAmount staked, not exact\n    uint256 public toWithdraw; //amountLockedForWithdrawal\n\n    mapping(bytes32 => Report) private reports; // mapping of query IDs to a report\n    mapping(address => StakeInfo) private stakerDetails; // mapping from a persons address to their staking info\n\n    // Structs\n    struct Report {\n        uint256[] timestamps; // array of all newValueTimestamps reported\n        mapping(uint256 => uint256) timestampIndex; // mapping of timestamps to respective indices\n        mapping(uint256 => uint256) timestampToBlockNum; // mapping of timestamp to block number\n        mapping(uint256 => bytes) valueByTimestamp; // mapping of timestamps to values\n        mapping(uint256 => address) reporterByTimestamp; // mapping of timestamps to reporters\n        mapping(uint256 => bool) isDisputed;\n    }\n\n    struct StakeInfo {\n        uint256 startDate; // stake or withdrawal request start date\n        uint256 stakedBalance; // staked token balance\n        uint256 lockedBalance; // amount locked for withdrawal\n        uint256 rewardDebt; // used for staking reward calculation\n        uint256 reporterLastTimestamp; // timestamp of reporter's last reported value\n        uint256 reportsSubmitted; // total number of reports submitted by reporter\n        uint256 startVoteCount; // total number of governance votes when stake deposited\n        uint256 startVoteTally; // staker vote tally when stake deposited\n        bool staked; // used to keep track of total stakers\n        mapping(bytes32 => uint256) reportsSubmittedByQueryId; // mapping of queryId to number of reports submitted by reporter\n    }\n\n    // Events\n    event NewReport(\n        bytes32 indexed _queryId,\n        uint256 indexed _time,\n        bytes _value,\n        uint256 _nonce,\n        bytes _queryData,\n        address indexed _reporter\n    );\n    event NewStakeAmount(uint256 _newStakeAmount);\n    event NewStaker(address indexed _staker, uint256 indexed _amount);\n    event ReporterSlashed(\n        address indexed _reporter,\n        address _recipient,\n        uint256 _slashAmount\n    );\n    event StakeWithdrawn(address _staker);\n    event StakeWithdrawRequested(address _staker, uint256 _amount);\n    event ValueRemoved(bytes32 _queryId, uint256 _timestamp);\n\n    // Functions\n    /**\n     * @dev Initializes system parameters\n     * @param _token address of token used for staking and rewards\n     * @param _reportingLock base amount of time (seconds) before reporter is able to report again\n     * @param _stakeAmountDollarTarget fixed USD amount that stakeAmount targets on updateStakeAmount\n     * @param _stakingTokenPrice current price of staking token in USD (18 decimals)\n     * @param _stakingTokenPriceQueryId queryId where staking token price is reported\n     */\n    constructor(\n        address _token,\n        uint256 _reportingLock,\n        uint256 _stakeAmountDollarTarget,\n        uint256 _stakingTokenPrice,\n        uint256 _minimumStakeAmount,\n        bytes32 _stakingTokenPriceQueryId\n    ) {\n        require(_token != address(0), \"must set token address\");\n        require(_stakingTokenPrice > 0, \"must set staking token price\");\n        require(_reportingLock > 0, \"must set reporting lock\");\n        require(_stakingTokenPriceQueryId != bytes32(0), \"must set staking token price queryId\");\n        token = IERC20(_token);\n        owner = msg.sender;\n        reportingLock = _reportingLock;\n        stakeAmountDollarTarget = _stakeAmountDollarTarget;\n        minimumStakeAmount = _minimumStakeAmount;\n        uint256 _potentialStakeAmount = (_stakeAmountDollarTarget * 1e18) / _stakingTokenPrice;\n        if(_potentialStakeAmount < _minimumStakeAmount) {\n            stakeAmount = _minimumStakeAmount;\n        } else {\n            stakeAmount = _potentialStakeAmount;\n        }\n        stakingTokenPriceQueryId = _stakingTokenPriceQueryId;\n    }\n\n    /**\n     * @dev Allows the owner to initialize the governance (flex addy needed for governance deployment)\n     * @param _governanceAddress address of governance contract (github.com/tellor-io/governance)\n     */\n    function init(address _governanceAddress) external {\n        require(msg.sender == owner, \"only owner can set governance address\");\n        require(governance == address(0), \"governance address already set\");\n        require(\n            _governanceAddress != address(0),\n            \"governance address can't be zero address\"\n        );\n        governance = _governanceAddress;\n    }\n\n    /**\n     * @dev Funds the Flex contract with staking rewards (paid by autopay and minting)\n     * @param _amount amount of tokens to fund contract with\n     */\n    function addStakingRewards(uint256 _amount) external {\n        require(token.transferFrom(msg.sender, address(this), _amount));\n        _updateRewards();\n        stakingRewardsBalance += _amount;\n        // update reward rate = real staking rewards balance / 30 days\n        rewardRate =\n            (stakingRewardsBalance -\n                ((accumulatedRewardPerShare * totalStakeAmount) /\n                    1e18 -\n                    totalRewardDebt)) /\n            30 days;\n    }\n\n    /**\n     * @dev Allows a reporter to submit stake\n     * @param _amount amount of tokens to stake\n     */\n    function depositStake(uint256 _amount) external {\n        require(governance != address(0), \"governance address not set\");\n        StakeInfo storage _staker = stakerDetails[msg.sender];\n        uint256 _stakedBalance = _staker.stakedBalance;\n        uint256 _lockedBalance = _staker.lockedBalance;\n        if (_lockedBalance > 0) {\n            if (_lockedBalance >= _amount) {\n                // if staker's locked balance covers full _amount, use that\n                _staker.lockedBalance -= _amount;\n                toWithdraw -= _amount;\n            } else {\n                // otherwise, stake the whole locked balance and transfer the\n                // remaining amount from the staker's address\n                require(\n                    token.transferFrom(\n                        msg.sender,\n                        address(this),\n                        _amount - _lockedBalance\n                    )\n                );\n                toWithdraw -= _staker.lockedBalance;\n                _staker.lockedBalance = 0;\n            }\n        } else {\n            if (_stakedBalance == 0) {\n                // if staked balance and locked balance equal 0, save current vote tally.\n                // voting participation used for calculating rewards\n                (bool _success, bytes memory _returnData) = governance.call(\n                    abi.encodeWithSignature(\"getVoteCount()\")\n                );\n                if (_success) {\n                    _staker.startVoteCount = uint256(abi.decode(_returnData, (uint256)));\n                }\n                (_success,_returnData) = governance.call(\n                    abi.encodeWithSignature(\"getVoteTallyByAddress(address)\",msg.sender)\n                );\n                if(_success){\n                    _staker.startVoteTally =  abi.decode(_returnData,(uint256));\n                }\n            }\n            require(token.transferFrom(msg.sender, address(this), _amount));\n        }\n        _updateStakeAndPayRewards(msg.sender, _stakedBalance + _amount);\n        _staker.startDate = block.timestamp; // This resets the staker start date to now\n        emit NewStaker(msg.sender, _amount);\n    }\n\n    /**\n     * @dev Removes a value from the oracle.\n     * Note: this function is only callable by the Governance contract.\n     * @param _queryId is ID of the specific data feed\n     * @param _timestamp is the timestamp of the data value to remove\n     */\n    function removeValue(bytes32 _queryId, uint256 _timestamp) external {\n        require(msg.sender == governance, \"caller must be governance address\");\n        Report storage _report = reports[_queryId];\n        require(!_report.isDisputed[_timestamp], \"value already disputed\");\n        uint256 _index = _report.timestampIndex[_timestamp];\n        require(_timestamp == _report.timestamps[_index], \"invalid timestamp\");\n        _report.valueByTimestamp[_timestamp] = \"\";\n        _report.isDisputed[_timestamp] = true;\n        emit ValueRemoved(_queryId, _timestamp);\n    }\n\n    /**\n     * @dev Allows a reporter to request to withdraw their stake\n     * @param _amount amount of staked tokens requesting to withdraw\n     */\n    function requestStakingWithdraw(uint256 _amount) external {\n        StakeInfo storage _staker = stakerDetails[msg.sender];\n        require(\n            _staker.stakedBalance >= _amount,\n            \"insufficient staked balance\"\n        );\n        _updateStakeAndPayRewards(msg.sender, _staker.stakedBalance - _amount);\n        _staker.startDate = block.timestamp;\n        _staker.lockedBalance += _amount;\n        toWithdraw += _amount;\n        emit StakeWithdrawRequested(msg.sender, _amount);\n    }\n\n    /**\n     * @dev Slashes a reporter and transfers their stake amount to the given recipient\n     * Note: this function is only callable by the governance address.\n     * @param _reporter is the address of the reporter being slashed\n     * @param _recipient is the address receiving the reporter's stake\n     * @return _slashAmount uint256 amount of token slashed and sent to rec"
    }
  ]
}