{
  "Title": "[M05] Rounding errors in compound and compound2",
  "Content": "Due to the fact that Solidity truncates when dividing, performing a division in the middle of a calculation can result in truncated amounts being amplified and these amplifications leading to large errors. In the `MathUtils` contract, the [`compound` function](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/blob/943df3a8fcd8dd128af3beb0c85a0480c0e95ead/contracts/lib/math/MathUtils.sol#L32) [divides at the end](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/blob/943df3a8fcd8dd128af3beb0c85a0480c0e95ead/contracts/lib/math/MathUtils.sol#L41) of every iteration of the `while` loop. The more iterations of the `while` loop, the more the result diverges from the true value. While the [`compound2` function](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/blob/943df3a8fcd8dd128af3beb0c85a0480c0e95ead/contracts/lib/math/MathUtils.sol#L47) is generally more accurate, it also performs this truncated division in the [`odd` case](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/blob/943df3a8fcd8dd128af3beb0c85a0480c0e95ead/contracts/lib/math/MathUtils.sol#L53) of the while loop.\n\n\nAs an example of how significant these errors can be, consider the calculation of compound interest with 100 principal, 1.02e18 rate, and 100 periods. The correct answer for this calculation is `724.46`. [`compound`](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/blob/943df3a8fcd8dd128af3beb0c85a0480c0e95ead/contracts/lib/math/MathUtils.sol#L32) gives the result `584`, and [`compound2`](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/blob/943df3a8fcd8dd128af3beb0c85a0480c0e95ead/contracts/lib/math/MathUtils.sol#L47) gives the result `720`.\n\n\nConsider updating the calculations to always perform divisions as late as possible, while also ensuring the intermediate results do not overflow.\n\n\n**Update**: *The BarnBridge team did not address this issue. They stated: “The code uses only the `compound2` function, which we consider to have a good tradeoff between accuracy/gas cost/complexity. Should we decide this is no longer the case, we’ll update the `BondModelV1` which uses the `compound2` function.”*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/lib/math/MathUtils.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nlibrary MathUtils {\n\n    using SafeMath for uint256;\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x < y ? x : y;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x > y ? x : y;\n    }\n\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function compound(\n        // in wei\n        uint256 principal,\n        // rate is * 1e18\n        uint256 ratePerPeriod,\n        uint16 periods\n    ) internal pure returns (uint256) {\n        while (periods > 0) {\n            // principal += principal * ratePerPeriod / 1e18;\n            principal = principal.add(principal.mul(ratePerPeriod).div(1e18));\n            periods -= 1;\n        }\n        return principal;\n    }\n\n    function compound2(\n      uint256 principal,\n      uint256 ratePerPeriod,\n      uint16 periods\n    ) internal pure returns (uint256) {\n      while (periods > 0) {\n        if (periods % 2 == 1) {\n          //principal += principal * ratePerPeriod / 1e18;\n          principal = principal.add(principal.mul(ratePerPeriod).div(1e18));\n          periods -= 1;\n        } else {\n          //ratePerPeriod = ((2 * ratePerPeriod * 1e18) + (ratePerPeriod * ratePerPeriod)) / 1e18;\n          ratePerPeriod = ((uint256(2).mul(ratePerPeriod).mul(1e18)).add(ratePerPeriod.mul(ratePerPeriod))).div(1e18);\n          periods /= 2;\n        }\n      }\n      return principal;\n    }\n\n    // computes a * f / 1e18\n    function fractionOf(uint256 a, uint256 f) internal pure returns (uint256) {\n      return a.mul(f).div(1e18);\n    }\n\n}"
    },
    {
      "filename": "contracts/lib/math/MathUtils.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nlibrary MathUtils {\n\n    using SafeMath for uint256;\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x < y ? x : y;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x > y ? x : y;\n    }\n\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function compound(\n        // in wei\n        uint256 principal,\n        // rate is * 1e18\n        uint256 ratePerPeriod,\n        uint16 periods\n    ) internal pure returns (uint256) {\n        while (periods > 0) {\n            // principal += principal * ratePerPeriod / 1e18;\n            principal = principal.add(principal.mul(ratePerPeriod).div(1e18));\n            periods -= 1;\n        }\n        return principal;\n    }\n\n    function compound2(\n      uint256 principal,\n      uint256 ratePerPeriod,\n      uint16 periods\n    ) internal pure returns (uint256) {\n      while (periods > 0) {\n        if (periods % 2 == 1) {\n          //principal += principal * ratePerPeriod / 1e18;\n          principal = principal.add(principal.mul(ratePerPeriod).div(1e18));\n          periods -= 1;\n        } else {\n          //ratePerPeriod = ((2 * ratePerPeriod * 1e18) + (ratePerPeriod * ratePerPeriod)) / 1e18;\n          ratePerPeriod = ((uint256(2).mul(ratePerPeriod).mul(1e18)).add(ratePerPeriod.mul(ratePerPeriod))).div(1e18);\n          periods /= 2;\n        }\n      }\n      return principal;\n    }\n\n    // computes a * f / 1e18\n    function fractionOf(uint256 a, uint256 f) internal pure returns (uint256) {\n      return a.mul(f).div(1e18);\n    }\n\n}"
    }
  ]
}