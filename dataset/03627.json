{
  "Title": "It is desirable to make an access modifier",
  "Content": "##### Description\nAt the line https://github.com/aave/governance-crosschain-bridges/blob/763ef5da8befff3a129443a3ff4ef7ca4d3bb446/contracts/ArbitrumBridgeExecutor.sol#L36 uses check: \n`require(msg.sender == _ethereumGovernanceExecutor, 'UNAUTHORIZED_EXECUTOR');`. \nBut the code will be nicer if you use the access modifier:\n\n```solidity\nmodifier onlyEthereumGovernanceExecutor() {\n    require(msg.sender == _ethereumGovernanceExecutor, 'UNAUTHORIZED_EXECUTOR');\n    _;\n}\n```  \n\nAt the line https://github.com/aave/governance-crosschain-bridges/blob/763ef5da8befff3a129443a3ff4ef7ca4d3bb446/contracts/PolygonBridgeExecutor.sol#L36 uses check: \n`require(msg.sender == _fxChild, 'UNAUTHORIZED_CHILD_ORIGIN');`. \nBut the code will be nicer if you use the access modifier:\n\n```solidity\nmodifier onlyFxChild() {\n     require(msg.sender == _fxChild, 'UNAUTHORIZED_CHILD_ORIGIN');\n    _;\n}\n```  \n\n##### Recommendation\nIt is recommended to make access modifiers.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/ArbitrumBridgeExecutor.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.7.5;\npragma abicoder v2;\n\nimport './BridgeExecutorBase.sol';\n\ncontract ArbitrumBridgeExecutor is BridgeExecutorBase {\n  address private immutable _ethereumGovernanceExecutor;\n\n  constructor(\n    address ethereumGovernanceExecutor,\n    uint256 delay,\n    uint256 gracePeriod,\n    uint256 minimumDelay,\n    uint256 maximumDelay,\n    address guardian\n  ) BridgeExecutorBase(delay, gracePeriod, minimumDelay, maximumDelay, guardian) {\n    _ethereumGovernanceExecutor = ethereumGovernanceExecutor;\n  }\n\n  /**\n   * @dev Queue the cross-chain message in the BridgeExecutor\n   * @param targets list of contracts called by each action's associated transaction\n   * @param values list of value in wei for each action's  associated transaction\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget, else calls the target\n   **/\n  function queue(\n    address[] memory targets,\n    uint256[] memory values,\n    string[] memory signatures,\n    bytes[] memory calldatas,\n    bool[] memory withDelegatecalls\n  ) external {\n    require(msg.sender == _ethereumGovernanceExecutor, 'UNAUTHORIZED_EXECUTOR');\n    _queue(targets, values, signatures, calldatas, withDelegatecalls);\n  }\n}"
    },
    {
      "filename": "contracts/PolygonBridgeExecutor.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.7.5;\npragma abicoder v2;\n\nimport './interfaces/IFxMessageProcessor.sol';\nimport './BridgeExecutorBase.sol';\n\ncontract PolygonBridgeExecutor is BridgeExecutorBase, IFxMessageProcessor {\n  address private immutable _fxRootSender;\n  address private immutable _fxChild;\n\n  constructor(\n    address fxRootSender,\n    address fxChild,\n    uint256 delay,\n    uint256 gracePeriod,\n    uint256 minimumDelay,\n    uint256 maximumDelay,\n    address guardian\n  ) BridgeExecutorBase(delay, gracePeriod, minimumDelay, maximumDelay, guardian) {\n    _fxRootSender = fxRootSender;\n    _fxChild = fxChild;\n  }\n\n  /**\n   * @dev Process the cross-chain message from an FxChild contract through the ETH/Polygon StateSender\n   * @param stateId Id of the cross-chain message created in the ETH/Polygon StateSender\n   * @param rootMessageSender address that initally sent this message on ethereum\n   * @param data the data from the abi-encoded cross-chain message\n   **/\n  function processMessageFromRoot(\n    uint256 stateId,\n    address rootMessageSender,\n    bytes calldata data\n  ) external override {\n    require(msg.sender == _fxChild, 'UNAUTHORIZED_CHILD_ORIGIN');\n    require(rootMessageSender == _fxRootSender, 'UNAUTHORIZED_ROOT_ORIGIN');\n\n    address[] memory targets;\n    uint256[] memory values;\n    string[] memory signatures;\n    bytes[] memory calldatas;\n    bool[] memory withDelegatecalls;\n\n    (targets, values, signatures, calldatas, withDelegatecalls) = abi.decode(\n      data,\n      (address[], uint256[], string[], bytes[], bool[])\n    );\n\n    _queue(targets, values, signatures, calldatas, withDelegatecalls);\n  }\n}"
    }
  ]
}