{
  "Title": "[H-12] Malicious Users Can Exploit Residual Allowance To Steal Assets",
  "Content": "_Submitted by xiaoming90, also found by 0x29A, 0xalpharush, 0xDjango, ayeslick, Critical, infosec&#95;us&#95;team, and Treasure-Seeker_\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L58>\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L77>\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L91>\n\n### Vulnerability Details\n\nA depositor cannot have any residual allowance after depositing to the vault because the tokens can be stolen by anyone.\n\n### Proof of Concept\n\nAssume that Alice has finished deploying the vault, and she would like to deposit her ERC20, ERC721, and ERC1155 tokens to the vault. She currently holds the following assets in her wallet\n\n*   `1000` XYZ ERC20 tokens\n*   APE #1 ERC721 NFT, APE #2 ERC721 NFT, APE #3 ERC721 NFT,\n*   `1000` ABC ERC1155 tokens\n\nThus, she sets up the necessary approval to grant [`baseVault`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L17) contract the permission to transfer her tokens to the vault.\n\n```solidity\nerc20.approve(address(baseVault), type(uint256).max);\nerc721.setApprovalForAll(address(baseVault), true);\nerc1155.setApprovalForAll(address(baseVault), true);\n```\n\nAlice decided to deposit `50` XYZ ERC20 tokens, APE #1 ERC721 NFT, and `50` ABC tokens to the vault by calling `baseVault.batchDepositERC20`, `baseVault.batchDepositERC721`, and `baseVault.batchDepositERC1155` as shown below:\n\n```solidity\nbaseVault.batchDepositERC20(alice.addr, vault, [XYZ.addr], [50])\nbaseVault.batchDepositERC721(alice.addr, vault, [APE.addr], [#1])\nbaseVault.batchDepositERC1155(alice.addr, vault, [ABC.addr], [#1], [50], \"\")\n```\n\nAn attacker notices that there is residual allowance left on the `baseVault`, thus the attacker executes the following transactions to steal Alice's assets and send them to the attacker's wallet address.\n\n```solidity\nbaseVault.batchDepositERC20(alice.addr, attacker.addr, [XYZ.addr], [950])\nbaseVault.batchDepositERC721(alice.addr, attacker.addr, [APE.addr, APE.addr], [#2, #3])\nbaseVault.batchDepositERC1155(alice.addr, attacker.addr, [ABC.addr], [#1], [950], \"\")\n```\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L58>\n\n```solidity\nfunction batchDepositERC20(\n    address _from,\n    address _to,\n    address[] calldata _tokens,\n    uint256[] calldata _amounts\n) external {\n    for (uint256 i = 0; i < _tokens.length; ) {\n        IERC20(_tokens[i]).transferFrom(_from, _to, _amounts[i]);\n        unchecked {\n            ++i;\n        }\n    }\n}\n```\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L77>\n\n```solidity\nfunction batchDepositERC721(\n    address _from,\n    address _to,\n    address[] calldata _tokens,\n    uint256[] calldata _ids\n) external {\n    for (uint256 i = 0; i < _tokens.length; ) {\n        IERC721(_tokens[i]).safeTransferFrom(_from, _to, _ids[i]);\n        unchecked {\n            ++i;\n        }\n    }\n}\n```\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L91>\n\n```solidity\nfunction batchDepositERC1155(\n    address _from,\n    address _to,\n    address[] calldata _tokens,\n    uint256[] calldata _ids,\n    uint256[] calldata _amounts,\n    bytes[] calldata _datas\n) external {\n    unchecked {\n        for (uint256 i = 0; i < _tokens.length; ++i) {\n            IERC1155(_tokens[i]).safeTransferFrom(\n                _from,\n                _to,\n                _ids[i],\n                _amounts[i],\n                _datas[i]\n            );\n        }\n    }\n}\n```\n\n### Impact\n\nLoss of assets for users as a malicious user could utilise the `baseVault` contract to exploit the user's residual allowance to steal their assets.\n\n### Recommended Mitigation Steps\n\nIt is recommended to only allow the `baseVault.batchDepositERC20`, `baseVault.batchDepositERC721`, and `baseVault.batchDepositERC1155` functions to pull tokens from the caller (`msg.sender`).\n\nConsidering updating the affected functions to remove the `from` parameter, and use `msg.sender` instead.\n\n```diff\nfunction batchDepositERC20(\n-   address _from,\n    address _to,\n    address[] calldata _tokens,\n    uint256[] calldata _amounts\n) external {\n    for (uint256 i = 0; i < _tokens.length; ) {\n-       IERC20(_tokens[i]).transferFrom(_from, _to, _amounts[i]);\n+       IERC20(_tokens[i]).transferFrom(msg.sender, _to, _amounts[i]);\n        unchecked {\n            ++i;\n        }\n    }\n}\n```\n\n```diff\nfunction batchDepositERC721(\n-   address _from,\n    address _to,\n    address[] calldata _tokens,\n    uint256[] calldata _ids\n) external {\n    for (uint256 i = 0; i < _tokens.length; ) {\n-       IERC721(_tokens[i]).safeTransferFrom(_from, _to, _ids[i]);\n+       IERC721(_tokens[i]).safeTransferFrom(msg.sender, _to, _ids[i]);\n        unchecked {\n            ++i;\n        }\n    }\n}\n```\n\n```diff\nfunction batchDepositERC1155(\n-   address _from,\n    address _to,\n    address[] calldata _tokens,\n    uint256[] calldata _ids,\n    uint256[] calldata _amounts,\n    bytes[] calldata _datas\n) external {\n    unchecked {\n        for (uint256 i = 0; i < _tokens.length; ++i) {\n            IERC1155(_tokens[i]).safeTransferFrom(\n-               _from,\n+               msg.sender,\n                _to,\n                _ids[i],\n                _amounts[i],\n                _datas[i]\n            );\n        }\n    }\n}\n```\n\n**[stevennevins (Fractional) confirmed and commented](https://github.com/code-423n4/2022-07-fractional-findings/issues/468#issuecomment-1187638235):**\n > Confirmed, we will be addressing this issue!\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-07-fractional-findings/issues/468#issuecomment-1208628673):**\n > Anyone who approved the BaseVault can have their tokens stolen. Agree this is high risk.\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-07-fractional-v2-contest",
  "Code": [
    {
      "filename": "src/modules/protoforms/BaseVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IBaseVault} from \"../../interfaces/IBaseVault.sol\";\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\nimport {IERC721} from \"../../interfaces/IERC721.sol\";\nimport {IERC1155} from \"../../interfaces/IERC1155.sol\";\nimport {IModule} from \"../../interfaces/IProtoform.sol\";\nimport {IVaultRegistry, Permission} from \"../../interfaces/IVaultRegistry.sol\";\nimport {MerkleBase} from \"../../utils/MerkleBase.sol\";\nimport {Minter} from \"../Minter.sol\";\nimport {Multicall} from \"../../utils/Multicall.sol\";\n\n/// @title BaseVault\n/// @author Fractional Art\n/// @notice Protoform contract for vault deployments with a fixed supply and buyout mechanism\ncontract BaseVault is IBaseVault, MerkleBase, Minter, Multicall {\n    /// @notice Address of VaultRegistry contract\n    address public registry;\n\n    /// @notice Initializes registry and supply contracts\n    /// @param _registry Address of the VaultRegistry contract\n    /// @param _supply Address of the Supply target contract\n    constructor(address _registry, address _supply) Minter(_supply) {\n        registry = _registry;\n    }\n\n    /// @notice Deploys a new Vault and mints initial supply of fractions\n    /// @param _fractionSupply Number of NFT Fractions minted to control the vault\n    /// @param _modules The list of modules to be installed on the vault\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @param _mintProof List of proofs to execute a mint function\n    function deployVault(\n        uint256 _fractionSupply,\n        address[] calldata _modules,\n        address[] calldata _plugins,\n        bytes4[] calldata _selectors,\n        bytes32[] calldata _mintProof\n    ) external returns (address vault) {\n        bytes32[] memory leafNodes = generateMerkleTree(_modules);\n        bytes32 merkleRoot = getRoot(leafNodes);\n        vault = IVaultRegistry(registry).create(\n            merkleRoot,\n            _plugins,\n            _selectors\n        );\n        emit ActiveModules(vault, _modules);\n\n        _mintFractions(vault, msg.sender, _fractionSupply, _mintProof);\n    }\n\n    /// @notice Transfers ERC-20 tokens\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _tokens[] Addresses of token contracts\n    /// @param _amounts[] Transfer amounts\n    function batchDepositERC20(\n        address _from,\n        address _to,\n        address[] calldata _tokens,\n        uint256[] calldata _amounts\n    ) external {\n        for (uint256 i = 0; i < _tokens.length; ) {\n            IERC20(_tokens[i]).transferFrom(_from, _to, _amounts[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Transfers ERC-721 tokens\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _tokens[] Addresses of token contracts\n    /// @param _ids[] IDs of the tokens\n    function batchDepositERC721(\n        address _from,\n        address _to,\n        address[] calldata _tokens,\n        uint256[] calldata _ids\n    ) external {\n        for (uint256 i = 0; i < _tokens.length; ) {\n            IERC721(_tokens[i]).safeTransferFrom(_from, _to, _ids[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Transfers ERC-1155 tokens\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _tokens[] Addresses of token contracts\n    /// @param _ids[] Ids of the token types\n    /// @param _amounts[] Transfer amounts\n    /// @param _datas[] Additional transaction data\n    function batchDepositERC1155(\n        address _from,\n        address _to,\n        address[] calldata _tokens,\n        uint256[] calldata _ids,\n        uint256[] calldata _amounts,\n        bytes[] calldata _datas\n    ) external {\n        unchecked {\n            for (uint256 i = 0; i < _tokens.length; ++i) {\n                IERC1155(_tokens[i]).safeTransferFrom(\n                    _from,\n                    _to,\n                    _ids[i],\n                    _amounts[i],\n                    _datas[i]\n                );\n            }\n        }\n    }\n\n    /// @notice Generates a merkle tree from the hashed permission lists of the given modules\n    /// @param _modules List of module contracts\n    /// @return hashes A combined list of leaf nodes\n    function generateMerkleTree(address[] calldata _modules)\n        public\n        view\n        returns (bytes32[] memory hashes)\n    {\n        uint256 counter;\n        hashes = new bytes32[](6);\n        unchecked {\n            for (uint256 i; i < _modules.length; ++i) {\n                bytes32[] memory leaves = IModule(_modules[i]).getLeafNodes();\n                for (uint256 j; j < leaves.length; ++j) {\n                    hashes[counter++] = leaves[j];\n                }\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/modules/protoforms/BaseVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IBaseVault} from \"../../interfaces/IBaseVault.sol\";\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\nimport {IERC721} from \"../../interfaces/IERC721.sol\";\nimport {IERC1155} from \"../../interfaces/IERC1155.sol\";\nimport {IModule} from \"../../interfaces/IProtoform.sol\";\nimport {IVaultRegistry, Permission} from \"../../interfaces/IVaultRegistry.sol\";\nimport {MerkleBase} from \"../../utils/MerkleBase.sol\";\nimport {Minter} from \"../Minter.sol\";\nimport {Multicall} from \"../../utils/Multicall.sol\";\n\n/// @title BaseVault\n/// @author Fractional Art\n/// @notice Protoform contract for vault deployments with a fixed supply and buyout mechanism\ncontract BaseVault is IBaseVault, MerkleBase, Minter, Multicall {\n    /// @notice Address of VaultRegistry contract\n    address public registry;\n\n    /// @notice Initializes registry and supply contracts\n    /// @param _registry Address of the VaultRegistry contract\n    /// @param _supply Address of the Supply target contract\n    constructor(address _registry, address _supply) Minter(_supply) {\n        registry = _registry;\n    }\n\n    /// @notice Deploys a new Vault and mints initial supply of fractions\n    /// @param _fractionSupply Number of NFT Fractions minted to control the vault\n    /// @param _modules The list of modules to be installed on the vault\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @param _mintProof List of proofs to execute a mint function\n    function deployVault(\n        uint256 _fractionSupply,\n        address[] calldata _modules,\n        address[] calldata _plugins,\n        bytes4[] calldata _selectors,\n        bytes32[] calldata _mintProof\n    ) external returns (address vault) {\n        bytes32[] memory leafNodes = generateMerkleTree(_modules);\n        bytes32 merkleRoot = getRoot(leafNodes);\n        vault = IVaultRegistry(registry).create(\n            merkleRoot,\n            _plugins,\n            _selectors\n        );\n        emit ActiveModules(vault, _modules);\n\n        _mintFractions(vault, msg.sender, _fractionSupply, _mintProof);\n    }\n\n    /// @notice Transfers ERC-20 tokens\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _tokens[] Addresses of token contracts\n    /// @param _amounts[] Transfer amounts\n    function batchDepositERC20(\n        address _from,\n        address _to,\n        address[] calldata _tokens,\n        uint256[] calldata _amounts\n    ) external {\n        for (uint256 i = 0; i < _tokens.length; ) {\n            IERC20(_tokens[i]).transferFrom(_from, _to, _amounts[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Transfers ERC-721 tokens\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _tokens[] Addresses of token contracts\n    /// @param _ids[] IDs of the tokens\n    function batchDepositERC721(\n        address _from,\n        address _to,\n        address[] calldata _tokens,\n        uint256[] calldata _ids\n    ) external {\n        for (uint256 i = 0; i < _tokens.length; ) {\n            IERC721(_tokens[i]).safeTransferFrom(_from, _to, _ids[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Transfers ERC-1155 tokens\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _tokens[] Addresses of token contracts\n    /// @param _ids[] Ids of the token types\n    /// @param _amounts[] Transfer amounts\n    /// @param _datas[] Additional transaction data\n    function batchDepositERC1155(\n        address _from,\n        address _to,\n        address[] calldata _tokens,\n        uint256[] calldata _ids,\n        uint256[] calldata _amounts,\n        bytes[] calldata _datas\n    ) external {\n        unchecked {\n            for (uint256 i = 0; i < _tokens.length; ++i) {\n                IERC1155(_tokens[i]).safeTransferFrom(\n                    _from,\n                    _to,\n                    _ids[i],\n                    _amounts[i],\n                    _datas[i]\n                );\n            }\n        }\n    }\n\n    /// @notice Generates a merkle tree from the hashed permission lists of the given modules\n    /// @param _modules List of module contracts\n    /// @return hashes A combined list of leaf nodes\n    function generateMerkleTree(address[] calldata _modules)\n        public\n        view\n        returns (bytes32[] memory hashes)\n    {\n        uint256 counter;\n        hashes = new bytes32[](6);\n        unchecked {\n            for (uint256 i; i < _modules.length; ++i) {\n                bytes32[] memory leaves = IModule(_modules[i]).getLeafNodes();\n                for (uint256 j; j < leaves.length; ++j) {\n                    hashes[counter++] = leaves[j];\n                }\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/modules/protoforms/BaseVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IBaseVault} from \"../../interfaces/IBaseVault.sol\";\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\nimport {IERC721} from \"../../interfaces/IERC721.sol\";\nimport {IERC1155} from \"../../interfaces/IERC1155.sol\";\nimport {IModule} from \"../../interfaces/IProtoform.sol\";\nimport {IVaultRegistry, Permission} from \"../../interfaces/IVaultRegistry.sol\";\nimport {MerkleBase} from \"../../utils/MerkleBase.sol\";\nimport {Minter} from \"../Minter.sol\";\nimport {Multicall} from \"../../utils/Multicall.sol\";\n\n/// @title BaseVault\n/// @author Fractional Art\n/// @notice Protoform contract for vault deployments with a fixed supply and buyout mechanism\ncontract BaseVault is IBaseVault, MerkleBase, Minter, Multicall {\n    /// @notice Address of VaultRegistry contract\n    address public registry;\n\n    /// @notice Initializes registry and supply contracts\n    /// @param _registry Address of the VaultRegistry contract\n    /// @param _supply Address of the Supply target contract\n    constructor(address _registry, address _supply) Minter(_supply) {\n        registry = _registry;\n    }\n\n    /// @notice Deploys a new Vault and mints initial supply of fractions\n    /// @param _fractionSupply Number of NFT Fractions minted to control the vault\n    /// @param _modules The list of modules to be installed on the vault\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @param _mintProof List of proofs to execute a mint function\n    function deployVault(\n        uint256 _fractionSupply,\n        address[] calldata _modules,\n        address[] calldata _plugins,\n        bytes4[] calldata _selectors,\n        bytes32[] calldata _mintProof\n    ) external returns (address vault) {\n        bytes32[] memory leafNodes = generateMerkleTree(_modules);\n        bytes32 merkleRoot = getRoot(leafNodes);\n        vault = IVaultRegistry(registry).create(\n            merkleRoot,\n            _plugins,\n            _selectors\n        );\n        emit ActiveModules(vault, _modules);\n\n        _mintFractions(vault, msg.sender, _fractionSupply, _mintProof);\n    }\n\n    /// @notice Transfers ERC-20 tokens\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _tokens[] Addresses of token contracts\n    /// @param _amounts[] Transfer amounts\n    function batchDepositERC20(\n        address _from,\n        address _to,\n        address[] calldata _tokens,\n        uint256[] calldata _amounts\n    ) external {\n        for (uint256 i = 0; i < _tokens.length; ) {\n            IERC20(_tokens[i]).transferFrom(_from, _to, _amounts[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Transfers ERC-721 tokens\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _tokens[] Addresses of token contracts\n    /// @param _ids[] IDs of the tokens\n    function batchDepositERC721(\n        address _from,\n        address _to,\n        address[] calldata _tokens,\n        uint256[] calldata _ids\n    ) external {\n        for (uint256 i = 0; i < _tokens.length; ) {\n            IERC721(_tokens[i]).safeTransferFrom(_from, _to, _ids[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Transfers ERC-1155 tokens\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _tokens[] Addresses of token contracts\n    /// @param _ids[] Ids of the token types\n    /// @param _amounts[] Transfer amounts\n    /// @param _datas[] Additional transaction data\n    function batchDepositERC1155(\n        address _from,\n        address _to,\n        address[] calldata _tokens,\n        uint256[] calldata _ids,\n        uint256[] calldata _amounts,\n        bytes[] calldata _datas\n    ) external {\n        unchecked {\n            for (uint256 i = 0; i < _tokens.length; ++i) {\n                IERC1155(_tokens[i]).safeTransferFrom(\n                    _from,\n                    _to,\n                    _ids[i],\n                    _amounts[i],\n                    _datas[i]\n                );\n            }\n        }\n    }\n\n    /// @notice Generates a merkle tree from the hashed permission lists of the given modules\n    /// @param _modules List of module contracts\n    /// @return hashes A combined list of leaf nodes\n    function generateMerkleTree(address[] calldata _modules)\n        public\n        view\n        returns (bytes32[] memory hashes)\n    {\n        uint256 counter;\n        hashes = new bytes32[](6);\n        unchecked {\n            for (uint256 i; i < _modules.length; ++i) {\n                bytes32[] memory leaves = IModule(_modules[i]).getLeafNodes();\n                for (uint256 j; j < leaves.length; ++j) {\n                    hashes[counter++] = leaves[j];\n                }\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/modules/protoforms/BaseVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IBaseVault} from \"../../interfaces/IBaseVault.sol\";\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\nimport {IERC721} from \"../../interfaces/IERC721.sol\";\nimport {IERC1155} from \"../../interfaces/IERC1155.sol\";\nimport {IModule} from \"../../interfaces/IProtoform.sol\";\nimport {IVaultRegistry, Permission} from \"../../interfaces/IVaultRegistry.sol\";\nimport {MerkleBase} from \"../../utils/MerkleBase.sol\";\nimport {Minter} from \"../Minter.sol\";\nimport {Multicall} from \"../../utils/Multicall.sol\";\n\n/// @title BaseVault\n/// @author Fractional Art\n/// @notice Protoform contract for vault deployments with a fixed supply and buyout mechanism\ncontract BaseVault is IBaseVault, MerkleBase, Minter, Multicall {\n    /// @notice Address of VaultRegistry contract\n    address public registry;\n\n    /// @notice Initializes registry and supply contracts\n    /// @param _registry Address of the VaultRegistry contract\n    /// @param _supply Address of the Supply target contract\n    constructor(address _registry, address _supply) Minter(_supply) {\n        registry = _registry;\n    }\n\n    /// @notice Deploys a new Vault and mints initial supply of fractions\n    /// @param _fractionSupply Number of NFT Fractions minted to control the vault\n    /// @param _modules The list of modules to be installed on the vault\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @param _mintProof List of proofs to execute a mint function\n    function deployVault(\n        uint256 _fractionSupply,\n        address[] calldata _modules,\n        address[] calldata _plugins,\n        bytes4[] calldata _selectors,\n        bytes32[] calldata _mintProof\n    ) external returns (address vault) {\n        bytes32[] memory leafNodes = generateMerkleTree(_modules);\n        bytes32 merkleRoot = getRoot(leafNodes);\n        vault = IVaultRegistry(registry).create(\n            merkleRoot,\n            _plugins,\n            _selectors\n        );\n        emit ActiveModules(vault, _modules);\n\n        _mintFractions(vault, msg.sender, _fractionSupply, _mintProof);\n    }\n\n    /// @notice Transfers ERC-20 tokens\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _tokens[] Addresses of token contracts\n    /// @param _amounts[] Transfer amounts\n    function batchDepositERC20(\n        address _from,\n        address _to,\n        address[] calldata _tokens,\n        uint256[] calldata _amounts\n    ) external {\n        for (uint256 i = 0; i < _tokens.length; ) {\n            IERC20(_tokens[i]).transferFrom(_from, _to, _amounts[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Transfers ERC-721 tokens\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _tokens[] Addresses of token contracts\n    /// @param _ids[] IDs of the tokens\n    function batchDepositERC721(\n        address _from,\n        address _to,\n        address[] calldata _tokens,\n        uint256[] calldata _ids\n    ) external {\n        for (uint256 i = 0; i < _tokens.length; ) {\n            IERC721(_tokens[i]).safeTransferFrom(_from, _to, _ids[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Transfers ERC-1155 tokens\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _tokens[] Addresses of token contracts\n    /// @param _ids[] Ids of the token types\n    /// @param _amounts[] Transfer amounts\n    /// @param _datas[] Additional transaction data\n    function batchDepositERC1155(\n        address _from,\n        address _to,\n        address[] calldata _tokens,\n        uint256[] calldata _ids,\n        uint256[] calldata _amounts,\n        bytes[] calldata _datas\n    ) external {\n        unchecked {\n            for (uint256 i = 0; i < _tokens.length; ++i) {\n                IERC1155(_tokens[i]).safeTransferFrom(\n                    _from,\n                    _to,\n                    _ids[i],\n                    _amounts[i],\n                    _datas[i]\n                );\n            }\n        }\n    }\n\n    /// @notice Generates a merkle tree from the hashed permission lists of the given modules\n    /// @param _modules List of module contracts\n    /// @return hashes A combined list of leaf nodes\n    function generateMerkleTree(address[] calldata _modules)\n        public\n        view\n        returns (bytes32[] memory hashes)\n    {\n        uint256 counter;\n        hashes = new bytes32[](6);\n        unchecked {\n            for (uint256 i; i < _modules.length; ++i) {\n                bytes32[] memory leaves = IModule(_modules[i]).getLeafNodes();\n                for (uint256 j; j < leaves.length; ++j) {\n                    hashes[counter++] = leaves[j];\n                }\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/modules/protoforms/BaseVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IBaseVault} from \"../../interfaces/IBaseVault.sol\";\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\nimport {IERC721} from \"../../interfaces/IERC721.sol\";\nimport {IERC1155} from \"../../interfaces/IERC1155.sol\";\nimport {IModule} from \"../../interfaces/IProtoform.sol\";\nimport {IVaultRegistry, Permission} from \"../../interfaces/IVaultRegistry.sol\";\nimport {MerkleBase} from \"../../utils/MerkleBase.sol\";\nimport {Minter} from \"../Minter.sol\";\nimport {Multicall} from \"../../utils/Multicall.sol\";\n\n/// @title BaseVault\n/// @author Fractional Art\n/// @notice Protoform contract for vault deployments with a fixed supply and buyout mechanism\ncontract BaseVault is IBaseVault, MerkleBase, Minter, Multicall {\n    /// @notice Address of VaultRegistry contract\n    address public registry;\n\n    /// @notice Initializes registry and supply contracts\n    /// @param _registry Address of the VaultRegistry contract\n    /// @param _supply Address of the Supply target contract\n    constructor(address _registry, address _supply) Minter(_supply) {\n        registry = _registry;\n    }\n\n    /// @notice Deploys a new Vault and mints initial supply of fractions\n    /// @param _fractionSupply Number of NFT Fractions minted to control the vault\n    /// @param _modules The list of modules to be installed on the vault\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @param _mintProof List of proofs to execute a mint function\n    function deployVault(\n        uint256 _fractionSupply,\n        address[] calldata _modules,\n        address[] calldata _plugins,\n        bytes4[] calldata _selectors,\n        bytes32[] calldata _mintProof\n    ) external returns (address vault) {\n        bytes32[] memory leafNodes = generateMerkleTree(_modules);\n        bytes32 merkleRoot = getRoot(leafNodes);\n        vault = IVaultRegistry(registry).create(\n            merkleRoot,\n            _plugins,\n            _selectors\n        );\n        emit ActiveModules(vault, _modules);\n\n        _mintFractions(vault, msg.sender, _fractionSupply, _mintProof);\n    }\n\n    /// @notice Transfers ERC-20 tokens\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _tokens[] Addresses of token contracts\n    /// @param _amounts[] Transfer amounts\n    function batchDepositERC20(\n        address _from,\n        address _to,\n        address[] calldata _tokens,\n        uint256[] calldata _amounts\n    ) external {\n        for (uint256 i = 0; i < _tokens.length; ) {\n            IERC20(_tokens[i]).transferFrom(_from, _to, _amounts[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Transfers ERC-721 tokens\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _tokens[] Addresses of token contracts\n    /// @param _ids[] IDs of the tokens\n    function batchDepositERC721(\n        address _from,\n        address _to,\n        address[] calldata _tokens,\n        uint256[] calldata _ids\n    ) external {\n        for (uint256 i = 0; i < _tokens.length; ) {\n            IERC721(_tokens[i]).safeTransferFrom(_from, _to, _ids[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Transfers ERC-1155 tokens\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _tokens[] Addresses of token contracts\n    /// @param _ids[] Ids of the token types\n    /// @param _amounts[] Transfer amounts\n    /// @param _datas[] Additional transaction data\n    function batchDepositERC1155(\n        address _from,\n        address _to,\n        address[] calldata _tokens,\n        uint256[] calldata _ids,\n        uint256[] calldata _amounts,\n        bytes[] calldata _datas\n    ) external {\n        unchecked {\n            for (uint256 i = 0; i < _tokens.length; ++i) {\n                IERC1155(_tokens[i]).safeTransferFrom(\n                    _from,\n                    _to,\n                    _ids[i],\n                    _amounts[i],\n                    _datas[i]\n                );\n            }\n        }\n    }\n\n    /// @notice Generates a merkle tree from the hashed permission lists of the given modules\n    /// @param _modules List of module contracts\n    /// @return hashes A combined list of leaf nodes\n    function generateMerkleTree(address[] calldata _modules)\n        public\n        view\n        returns (bytes32[] memory hashes)\n    {\n        uint256 counter;\n        hashes = new bytes32[](6);\n        unchecked {\n            for (uint256 i; i < _modules.length; ++i) {\n                bytes32[] memory leaves = IModule(_modules[i]).getLeafNodes();\n                for (uint256 j; j < leaves.length; ++j) {\n                    hashes[counter++] = leaves[j];\n                }\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/modules/protoforms/BaseVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IBaseVault} from \"../../interfaces/IBaseVault.sol\";\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\nimport {IERC721} from \"../../interfaces/IERC721.sol\";\nimport {IERC1155} from \"../../interfaces/IERC1155.sol\";\nimport {IModule} from \"../../interfaces/IProtoform.sol\";\nimport {IVaultRegistry, Permission} from \"../../interfaces/IVaultRegistry.sol\";\nimport {MerkleBase} from \"../../utils/MerkleBase.sol\";\nimport {Minter} from \"../Minter.sol\";\nimport {Multicall} from \"../../utils/Multicall.sol\";\n\n/// @title BaseVault\n/// @author Fractional Art\n/// @notice Protoform contract for vault deployments with a fixed supply and buyout mechanism\ncontract BaseVault is IBaseVault, MerkleBase, Minter, Multicall {\n    /// @notice Address of VaultRegistry contract\n    address public registry;\n\n    /// @notice Initializes registry and supply contracts\n    /// @param _registry Address of the VaultRegistry contract\n    /// @param _supply Address of the Supply target contract\n    constructor(address _registry, address _supply) Minter(_supply) {\n        registry = _registry;\n    }\n\n    /// @notice Deploys a new Vault and mints initial supply of fractions\n    /// @param _fractionSupply Number of NFT Fractions minted to control the vault\n    /// @param _modules The list of modules to be installed on the vault\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @param _mintProof List of proofs to execute a mint function\n    function deployVault(\n        uint256 _fractionSupply,\n        address[] calldata _modules,\n        address[] calldata _plugins,\n        bytes4[] calldata _selectors,\n        bytes32[] calldata _mintProof\n    ) external returns (address vault) {\n        bytes32[] memory leafNodes = generateMerkleTree(_modules);\n        bytes32 merkleRoot = getRoot(leafNodes);\n        vault = IVaultRegistry(registry).create(\n            merkleRoot,\n            _plugins,\n            _selectors\n        );\n        emit ActiveModules(vault, _modules);\n\n        _mintFractions(vault, msg.sender, _fractionSupply, _mintProof);\n    }\n\n    /// @notice Transfers ERC-20 tokens\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _tokens[] Addresses of token contracts\n    /// @param _amounts[] Transfer amounts\n    function batchDepositERC20(\n        address _from,\n        address _to,\n        address[] calldata _tokens,\n        uint256[] calldata _amounts\n    ) external {\n        for (uint256 i = 0; i < _tokens.length; ) {\n            IERC20(_tokens[i]).transferFrom(_from, _to, _amounts[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Transfers ERC-721 tokens\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _tokens[] Addresses of token contracts\n    /// @param _ids[] IDs of the tokens\n    function batchDepositERC721(\n        address _from,\n        address _to,\n        address[] calldata _tokens,\n        uint256[] calldata _ids\n    ) external {\n        for (uint256 i = 0; i < _tokens.length; ) {\n            IERC721(_tokens[i]).safeTransferFrom(_from, _to, _ids[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Transfers ERC-1155 tokens\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _tokens[] Addresses of token contracts\n    /// @param _ids[] Ids of the token types\n    /// @param _amounts[] Transfer amounts\n    /// @param _datas[] Additional transaction data\n    function batchDepositERC1155(\n        address _from,\n        address _to,\n        address[] calldata _tokens,\n        uint256[] calldata _ids,\n        uint256[] calldata _amounts,\n        bytes[] calldata _datas\n    ) external {\n        unchecked {\n            for (uint256 i = 0; i < _tokens.length; ++i) {\n                IERC1155(_tokens[i]).safeTransferFrom(\n                    _from,\n                    _to,\n                    _ids[i],\n                    _amounts[i],\n                    _datas[i]\n                );\n            }\n        }\n    }\n\n    /// @notice Generates a merkle tree from the hashed permission lists of the given modules\n    /// @param _modules List of module contracts\n    /// @return hashes A combined list of leaf nodes\n    function generateMerkleTree(address[] calldata _modules)\n        public\n        view\n        returns (bytes32[] memory hashes)\n    {\n        uint256 counter;\n        hashes = new bytes32[](6);\n        unchecked {\n            for (uint256 i; i < _modules.length; ++i) {\n                bytes32[] memory leaves = IModule(_modules[i]).getLeafNodes();\n                for (uint256 j; j < leaves.length; ++j) {\n                    hashes[counter++] = leaves[j];\n                }\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/modules/protoforms/BaseVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IBaseVault} from \"../../interfaces/IBaseVault.sol\";\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\nimport {IERC721} from \"../../interfaces/IERC721.sol\";\nimport {IERC1155} from \"../../interfaces/IERC1155.sol\";\nimport {IModule} from \"../../interfaces/IProtoform.sol\";\nimport {IVaultRegistry, Permission} from \"../../interfaces/IVaultRegistry.sol\";\nimport {MerkleBase} from \"../../utils/MerkleBase.sol\";\nimport {Minter} from \"../Minter.sol\";\nimport {Multicall} from \"../../utils/Multicall.sol\";\n\n/// @title BaseVault\n/// @author Fractional Art\n/// @notice Protoform contract for vault deployments with a fixed supply and buyout mechanism\ncontract BaseVault is IBaseVault, MerkleBase, Minter, Multicall {\n    /// @notice Address of VaultRegistry contract\n    address public registry;\n\n    /// @notice Initializes registry and supply contracts\n    /// @param _registry Address of the VaultRegistry contract\n    /// @param _supply Address of the Supply target contract\n    constructor(address _registry, address _supply) Minter(_supply) {\n        registry = _registry;\n    }\n\n    /// @notice Deploys a new Vault and mints initial supply of fractions\n    /// @param _fractionSupply Number of NFT Fractions minted to control the vault\n    /// @param _modules The list of modules to be installed on the vault\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @param _mintProof List of proofs to execute a mint function\n    function deployVault(\n        uint256 _fractionSupply,\n        address[] calldata _modules,\n        address[] calldata _plugins,\n        bytes4[] calldata _selectors,\n        bytes32[] calldata _mintProof\n    ) external returns (address vault) {\n        bytes32[] memory leafNodes = generateMerkleTree(_modules);\n        bytes32 merkleRoot = getRoot(leafNodes);\n        vault = IVaultRegistry(registry).create(\n            merkleRoot,\n            _plugins,\n            _selectors\n        );\n        emit ActiveModules(vault, _modules);\n\n        _mintFractions(vault, msg.sender, _fractionSupply, _mintProof);\n    }\n\n    /// @notice Transfers ERC-20 tokens\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _tokens[] Addresses of token contracts\n    /// @param _amounts[] Transfer amounts\n    function batchDepositERC20(\n        address _from,\n        address _to,\n        address[] calldata _tokens,\n        uint256[] calldata _amounts\n    ) external {\n        for (uint256 i = 0; i < _tokens.length; ) {\n            IERC20(_tokens[i]).transferFrom(_from, _to, _amounts[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Transfers ERC-721 tokens\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _tokens[] Addresses of token contracts\n    /// @param _ids[] IDs of the tokens\n    function batchDepositERC721(\n        address _from,\n        address _to,\n        address[] calldata _tokens,\n        uint256[] calldata _ids\n    ) external {\n        for (uint256 i = 0; i < _tokens.length; ) {\n            IERC721(_tokens[i]).safeTransfe"
    }
  ]
}