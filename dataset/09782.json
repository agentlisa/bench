{
  "Title": "[M-11] LiquidityProviders: Setting new liquidity pool will break contract",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityProviders.sol#L171\n\n\n# Vulnerability details\n\n## Impact\nOwners can change the `liquidityPool` variable any time with the `setLiquidityPool` function.\nIf a liquidity pool was already set and users added liquidity with `addTokenLiquidity`, the tokens are directly transferred to the liquidity pool and not kept in the `LiquidityProviders` contract.\nChanging the `liquidityPool` to a different contract will make it impossible for the users to withdraw their liquidity using `removeLiquidity` because the tokens are still in the old `liquidityPool` and cannot be retrieved.\n\nAll users will lose their funds.\n\n## Recommended Mitigation Steps\nChanging the `liquidityPool` requires a sophisticated migration mechanism.\nOnly allow setting the `liquidityPool` contract once.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-03-biconomy-hyphen-20-contest",
  "Code": [
    {
      "filename": "contracts/hyphen/LiquidityProviders.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"./metatx/ERC2771ContextUpgradeable.sol\";\n\nimport \"../security/Pausable.sol\";\nimport \"./interfaces/ILPToken.sol\";\nimport \"./interfaces/ITokenManager.sol\";\nimport \"./interfaces/IWhiteListPeriodManager.sol\";\nimport \"./interfaces/ILiquidityPool.sol\";\n\ncontract LiquidityProviders is\n    Initializable,\n    ReentrancyGuardUpgradeable,\n    ERC2771ContextUpgradeable,\n    OwnableUpgradeable,\n    Pausable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    address internal constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    uint256 public constant BASE_DIVISOR = 10**18;\n\n    ILPToken internal lpToken;\n    ILiquidityPool internal liquidityPool;\n    ITokenManager internal tokenManager;\n    IWhiteListPeriodManager internal whiteListPeriodManager;\n\n    event LiquidityAdded(address indexed tokenAddress, uint256 indexed amount, address indexed lp);\n    event LiquidityRemoved(address indexed tokenAddress, uint256 indexed amount, address indexed lp);\n    event FeeClaimed(address indexed tokenAddress, uint256 indexed fee, address indexed lp, uint256 sharesBurnt);\n    event FeeAdded(address indexed tokenAddress, uint256 indexed fee);\n    event EthReceived(address indexed sender, uint256 value);\n    event CurrentLiquidityChanged(address indexed token, uint256 indexed oldValue, uint256 indexed newValue);\n\n    // LP Fee Distribution\n    mapping(address => uint256) public totalReserve; // Include Liquidity + Fee accumulated\n    mapping(address => uint256) public totalLiquidity; // Include Liquidity only\n    mapping(address => uint256) public currentLiquidity; // Include current liquidity, updated on every in and out transfer\n    mapping(address => uint256) public totalLPFees;\n    mapping(address => uint256) public totalSharesMinted;\n\n    /**\n     * @dev Modifier for checking to validate a NFTId and it's ownership\n     * @param _tokenId token id to validate\n     * @param _transactor typically msgSender(), passed to verify against owner of _tokenId\n     */\n    modifier onlyValidLpToken(uint256 _tokenId, address _transactor) {\n        (address token, , ) = lpToken.tokenMetadata(_tokenId);\n        require(lpToken.exists(_tokenId), \"ERR__TOKEN_DOES_NOT_EXIST\");\n        require(lpToken.ownerOf(_tokenId) == _transactor, \"ERR__TRANSACTOR_DOES_NOT_OWN_NFT\");\n        _;\n    }\n\n    /**\n     * @dev Modifier for checking if msg.sender in liquiditypool\n     */\n    modifier onlyLiquidityPool() {\n        require(_msgSender() == address(liquidityPool), \"ERR__UNAUTHORIZED\");\n        _;\n    }\n\n    modifier tokenChecks(address tokenAddress) {\n        require(tokenAddress != address(0), \"Token address cannot be 0\");\n        require(_isSupportedToken(tokenAddress), \"Token not supported\");\n        _;\n    }\n\n    /**\n     * @dev initalizes the contract, acts as constructor\n     * @param _trustedForwarder address of trusted forwarder\n     */\n    function initialize(\n        address _trustedForwarder,\n        address _lpToken,\n        address _tokenManager,\n        address _pauser\n    ) public initializer {\n        __ERC2771Context_init(_trustedForwarder);\n        __Ownable_init();\n        __Pausable_init(_pauser);\n        __ReentrancyGuard_init();\n        _setLPToken(_lpToken);\n        _setTokenManager(_tokenManager);\n    }\n\n    function _isSupportedToken(address _token) internal view returns (bool) {\n        return tokenManager.getTokensInfo(_token).supportedToken;\n    }\n\n    function getTotalReserveByToken(address tokenAddress) public view returns (uint256) {\n        return totalReserve[tokenAddress];\n    }\n\n    function getSuppliedLiquidityByToken(address tokenAddress) public view returns (uint256) {\n        return totalLiquidity[tokenAddress];\n    }\n\n    function getTotalLPFeeByToken(address tokenAddress) public view returns (uint256) {\n        return totalLPFees[tokenAddress];\n    }\n\n    function getCurrentLiquidity(address tokenAddress) public view returns (uint256) {\n        return currentLiquidity[tokenAddress];\n    }\n\n    /**\n     * @dev To be called post initialization, used to set address of NFT Contract\n     * @param _lpToken address of lpToken\n     */\n    function setLpToken(address _lpToken) external onlyOwner {\n        _setLPToken(_lpToken);\n    }\n\n    /**\n     * Internal method to set LP token contract.\n     */\n    function _setLPToken(address _lpToken) internal {\n        lpToken = ILPToken(_lpToken);\n    }\n\n    function increaseCurrentLiquidity(address tokenAddress, uint256 amount) public onlyLiquidityPool {\n        _increaseCurrentLiquidity(tokenAddress, amount);\n    }\n\n    function decreaseCurrentLiquidity(address tokenAddress, uint256 amount) public onlyLiquidityPool {\n        _decreaseCurrentLiquidity(tokenAddress, amount);\n    }\n\n    function _increaseCurrentLiquidity(address tokenAddress, uint256 amount) private {\n        currentLiquidity[tokenAddress] += amount;\n        emit CurrentLiquidityChanged(tokenAddress, currentLiquidity[tokenAddress]-amount, currentLiquidity[tokenAddress]);\n    }\n\n    function _decreaseCurrentLiquidity(address tokenAddress, uint256 amount) private {\n        currentLiquidity[tokenAddress] -= amount;\n        emit CurrentLiquidityChanged(tokenAddress, currentLiquidity[tokenAddress]+amount, currentLiquidity[tokenAddress]);\n    }\n\n    /**\n     * Public method to set TokenManager contract.\n     */\n    function setTokenManager(address _tokenManager) external onlyOwner {\n        _setTokenManager(_tokenManager);\n    }\n\n    /**\n     * Internal method to set TokenManager contract.\n     */\n    function _setTokenManager(address _tokenManager) internal {\n        tokenManager = ITokenManager(_tokenManager);\n    }\n\n    /**\n     * @dev To be called post initialization, used to set address of WhiteListPeriodManager Contract\n     * @param _whiteListPeriodManager address of WhiteListPeriodManager\n     */\n    function setWhiteListPeriodManager(address _whiteListPeriodManager) external onlyOwner {\n        whiteListPeriodManager = IWhiteListPeriodManager(_whiteListPeriodManager);\n    }\n\n    /**\n     * @dev To be called post initialization, used to set address of LiquidityPool Contract\n     * @param _liquidityPool address of LiquidityPool\n     */\n    function setLiquidityPool(address _liquidityPool) external onlyOwner {\n        liquidityPool = ILiquidityPool(_liquidityPool);\n    }\n\n    /**\n     * @dev Returns price of Base token in terms of LP Shares\n     * @param _baseToken address of baseToken\n     * @return Price of Base token in terms of LP Shares\n     */\n    function getTokenPriceInLPShares(address _baseToken) public view returns (uint256) {\n        uint256 supply = totalSharesMinted[_baseToken];\n        if (supply > 0) {\n            return totalSharesMinted[_baseToken] / totalReserve[_baseToken];\n        }\n        return BASE_DIVISOR;\n    }\n\n    /**\n     * @dev Converts shares to token amount\n     */\n\n    function sharesToTokenAmount(uint256 _shares, address _tokenAddress) public view returns (uint256) {\n        return (_shares * totalReserve[_tokenAddress]) / totalSharesMinted[_tokenAddress];\n    }\n\n    /**\n     * @dev Returns the fee accumulated on a given NFT\n     * @param _nftId Id of NFT\n     * @return accumulated fee\n     */\n    function getFeeAccumulatedOnNft(uint256 _nftId) public view returns (uint256) {\n        require(lpToken.exists(_nftId), \"ERR__INVALID_NFT\");\n\n        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);\n\n        if (totalNFTShares == 0) {\n            return 0;\n        }\n        // Calculate rewards accumulated\n        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);\n        uint256 lpFeeAccumulated;\n\n        // Handle edge cases where eligibleLiquidity is less than what was supplied by very small amount \n        if(nftSuppliedLiquidity > eligibleLiquidity) {\n            lpFeeAccumulated = 0;\n        } else {\n            unchecked {\n                lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;\n            }\n        }\n        return lpFeeAccumulated;\n    }\n\n    /**\n     * @dev Records fee being added to total reserve\n     * @param _token Address of Token for which LP fee is being added\n     * @param _amount Amount being added\n     */\n    function addLPFee(address _token, uint256 _amount) external onlyLiquidityPool tokenChecks(_token) whenNotPaused {\n        totalReserve[_token] += _amount;\n        totalLPFees[_token] += _amount;\n        emit FeeAdded(_token, _amount);\n    }\n\n    /**\n     * @dev Internal function to add liquidity to a new NFT\n     */\n    function _addLiquidity(address _token, uint256 _amount) internal {\n        require(_amount > 0, \"ERR__AMOUNT_IS_0\");\n        uint256 nftId = lpToken.mint(_msgSender());\n        LpTokenMetadata memory data = LpTokenMetadata(_token, 0, 0);\n        lpToken.updateTokenMetadata(nftId, data);\n        _increaseLiquidity(nftId, _amount);\n    }\n\n    /**\n     * @dev Function to mint a new NFT for a user, add native liquidity and store the\n     *      record in the newly minted NFT\n     */\n    function addNativeLiquidity() external payable nonReentrant tokenChecks(NATIVE) whenNotPaused {\n        (bool success, ) = address(liquidityPool).call{value: msg.value}(\"\");\n        require(success, \"ERR__NATIVE_TRANSFER_FAILED\");\n        _addLiquidity(NATIVE, msg.value);\n    }\n\n    /**\n     * @dev Function to mint a new NFT for a user, add token liquidity and store the\n     *      record in the newly minted NFT\n     * @param _token Address of token for which liquidity is to be added\n     * @param _amount Amount of liquidity added\n     */\n    function addTokenLiquidity(address _token, uint256 _amount)\n        external\n        nonReentrant\n        tokenChecks(_token)\n        whenNotPaused\n    {\n        require(_token != NATIVE, \"ERR__WRONG_FUNCTION\");\n        require(\n            IERC20Upgradeable(_token).allowance(_msgSender(), address(this)) >= _amount,\n            \"ERR__INSUFFICIENT_ALLOWANCE\"\n        );\n        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(_token), _msgSender(), address(liquidityPool), _amount);\n        _addLiquidity(_token, _amount);\n    }\n\n    /**\n     * @dev Internal helper function to increase liquidity in a given NFT\n     */\n    function _increaseLiquidity(uint256 _nftId, uint256 _amount) internal onlyValidLpToken(_nftId, _msgSender()) {\n        (address token, uint256 totalSuppliedLiquidity, uint256 totalShares) = lpToken.tokenMetadata(_nftId);\n\n        require(_amount > 0, \"ERR__AMOUNT_IS_0\");\n        whiteListPeriodManager.beforeLiquidityAddition(_msgSender(), token, _amount);\n\n        uint256 mintedSharesAmount;\n        // Adding liquidity in the pool for the first time\n        if (totalReserve[token] == 0) {\n            mintedSharesAmount = BASE_DIVISOR * _amount;\n        } else {\n            mintedSharesAmount = (_amount * totalSharesMinted[token]) / totalReserve[token];\n        }\n\n        require(mintedSharesAmount >= BASE_DIVISOR, \"ERR__AMOUNT_BELOW_MIN_LIQUIDITY\");\n\n        totalLiquidity[token] += _amount;\n        totalReserve[token] += _amount;\n        totalSharesMinted[token] += mintedSharesAmount;\n\n        LpTokenMetadata memory data = LpTokenMetadata(\n            token,\n            totalSuppliedLiquidity + _amount,\n            totalShares + mintedSharesAmount\n        );\n        lpToken.updateTokenMetadata(_nftId, data);\n\n        // Increase the current liquidity\n        _increaseCurrentLiquidity(token, _amount);\n        emit LiquidityAdded(token, _amount, _msgSender());\n    }\n\n    /**\n     * @dev Function to allow LPs to add ERC20 token liquidity to existing NFT\n     * @param _nftId ID of NFT for updating the balances\n     * @param _amount Token amount to be added\n     */\n    function increaseTokenLiquidity(uint256 _nftId, uint256 _amount) external nonReentrant whenNotPaused {\n        (address token, , ) = lpToken.tokenMetadata(_nftId);\n        require(_isSupportedToken(token), \"ERR__TOKEN_NOT_SUPPORTED\");\n        require(token != NATIVE, \"ERR__WRONG_FUNCTION\");\n        require(\n            IERC20Upgradeable(token).allowance(_msgSender(), address(this)) >= _amount,\n            \"ERR__INSUFFICIENT_ALLOWANCE\"\n        );\n        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(token), _msgSender(), address(liquidityPool), _amount);\n        _increaseLiquidity(_nftId, _amount);\n    }\n\n    /**\n     * @dev Function to allow LPs to add native token liquidity to existing NFT\n     */\n    function increaseNativeLiquidity(uint256 _nftId) external payable nonReentrant whenNotPaused {\n        (address token, , ) = lpToken.tokenMetadata(_nftId);\n        require(_isSupportedToken(NATIVE), \"ERR__TOKEN_NOT_SUPPORTED\");\n        require(token == NATIVE, \"ERR__WRONG_FUNCTION\");\n        (bool success, ) = address(liquidityPool).call{value: msg.value}(\"\");\n        require(success, \"ERR__NATIVE_TRANSFER_FAILED\");\n        _increaseLiquidity(_nftId, msg.value);\n    }\n\n    /**\n     * @dev Function to allow LPs to remove their liquidity from an existing NFT\n     *      Also automatically redeems any earned fee\n     */\n    function removeLiquidity(uint256 _nftId, uint256 _amount)\n        external\n        nonReentrant\n        onlyValidLpToken(_nftId, _msgSender())\n        whenNotPaused\n    {\n        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);\n        require(_isSupportedToken(_tokenAddress), \"ERR__TOKEN_NOT_SUPPORTED\");\n\n        require(_amount != 0, \"ERR__INVALID_AMOUNT\");\n        require(nftSuppliedLiquidity >= _amount, \"ERR__INSUFFICIENT_LIQUIDITY\");\n        whiteListPeriodManager.beforeLiquidityRemoval(_msgSender(), _tokenAddress, _amount);\n        // Claculate how much shares represent input amount\n        uint256 lpSharesForInputAmount = _amount * getTokenPriceInLPShares(_tokenAddress);\n\n        // Calculate rewards accumulated\n        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);\n        \n        uint256 lpFeeAccumulated;\n\n        // Handle edge cases where eligibleLiquidity is less than what was supplied by very small amount \n        if(nftSuppliedLiquidity > eligibleLiquidity) {\n            lpFeeAccumulated = 0;\n        } else {\n            unchecked {\n                lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;\n            }\n        }\n        // Calculate amount of lp shares that represent accumulated Fee\n        uint256 lpSharesRepresentingFee = lpFeeAccumulated * getTokenPriceInLPShares(_tokenAddress);\n\n        totalLPFees[_tokenAddress] -= lpFeeAccumulated;\n        uint256 amountToWithdraw = _amount + lpFeeAccumulated;\n        uint256 lpSharesToBurn = lpSharesForInputAmount + lpSharesRepresentingFee;\n\n        // Handle round off errors to avoid dust lp token in contract\n        if (totalNFTShares - lpSharesToBurn < BASE_DIVISOR) {\n            lpSharesToBurn = totalNFTShares;\n        }\n        totalReserve[_tokenAddress] -= amountToWithdraw;\n        totalLiquidity[_tokenAddress] -= _amount;\n        totalSharesMinted[_tokenAddress] -= lpSharesToBurn;\n\n        _decreaseCurrentLiquidity(_tokenAddress, _amount);\n\n        _burnSharesFromNft(_nftId, lpSharesToBurn, _amount, _tokenAddress);\n\n        _transferFromLiquidityPool(_tokenAddress, _msgSender(), amountToWithdraw);\n\n        emit LiquidityRemoved(_tokenAddress, amountToWithdraw, _msgSender());\n    }\n\n    /**\n     * @dev Function to allow LPs to claim the fee earned on their NFT\n     * @param _nftId ID of NFT where liquidity is recorded\n     */\n    function claimFee(uint256 _nftId) external onlyValidLpToken(_nftId, _msgSender()) whenNotPaused nonReentrant {\n        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);\n        require(_isSupportedToken(_tokenAddress), \"ERR__TOKEN_NOT_SUPPORTED\");\n\n        uint256 lpSharesForSuppliedLiquidity = nftSuppliedLiquidity * getTokenPriceInLPShares(_tokenAddress);\n\n        // Calculate rewards accumulated\n        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);\n        uint256 lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;\n        require(lpFeeAccumulated > 0, \"ERR__NO_REWARDS_TO_CLAIM\");\n        // Calculate amount of lp shares that represent accumulated Fee\n        uint256 lpSharesRepresentingFee = totalNFTShares - lpSharesForSuppliedLiquidity;\n\n        totalReserve[_tokenAddress] -= lpFeeAccumulated;\n        totalSharesMinted[_tokenAddress] -= lpSharesRepresentingFee;\n        totalLPFees[_tokenAddress] -= lpFeeAccumulated;\n\n        _burnSharesFromNft(_nftId, lpSharesRepresentingFee, 0, _tokenAddress);\n        _transferFromLiquidityPool(_tokenAddress, _msgSender(), lpFeeAccumulated);\n        emit FeeClaimed(_tokenAddress, lpFeeAccumulated, _msgSender(), lpSharesRepresentingFee);\n    }\n\n    /**\n     * @dev Internal Function to burn LP shares and remove liquidity from existing NFT\n     */\n    function _burnSharesFromNft(\n        uint256 _nftId,\n        uint256 _shares,\n        uint256 _tokenAmount,\n        address _tokenAddress\n    ) internal {\n        (, uint256 nftSuppliedLiquidity, uint256 nftShares) = lpToken.tokenMetadata(_nftId);\n        nftShares -= _shares;\n        nftSuppliedLiquidity -= _tokenAmount;\n\n        lpToken.updateTokenMetadata(_nftId, LpTokenMetadata(_tokenAddress, nftSuppliedLiquidity, nftShares));\n    }\n\n    function _transferFromLiquidityPool(\n        address _tokenAddress,\n        address _receiver,\n        uint256 _tokenAmount\n    ) internal {\n        liquidityPool.transfer(_tokenAddress, _receiver, _tokenAmount);\n    }\n\n    function getSuppliedLiquidity(uint256 _nftId) external view returns (uint256) {\n        (, uint256 totalSuppliedLiquidity, ) = lpToken.tokenMetadata(_nftId);\n        return totalSuppliedLiquidity;\n    }\n\n    function _msgSender()\n        internal\n        view\n        virtual\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (address sender)\n    {\n        return ERC2771ContextUpgradeable._msgSender();\n    }\n\n    function _msgData()\n        internal\n        view\n        virtual\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        return ERC2771ContextUpgradeable._msgData();\n    }\n\n    receive() external payable {\n        emit EthReceived(_msgSender(), msg.value);\n    }\n}"
    }
  ]
}