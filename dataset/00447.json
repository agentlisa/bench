{
  "Title": "M-28: Not considering fees when wrapping mtOFTs leads to DoS in leverage executors",
  "Content": "# Issue M-28: Not considering fees when wrapping mtOFTs leads to DoS in leverage executors \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/126 \n\n## Found by \n0xadrii, cergyk\n## Summary\n\nWhen wrapping mtOFTs in leverage executors, fees are not considered, making calls always revert because the obtained assets amount is always smaller than expected.\n\n## Vulnerability Detail\n\nTapioca will allow tOFTs and mtOFTs to act as collateral in some of Tapioca’s markets, [as described by the documentation](https://docs.tapioca.xyz/tapioca/core-technologies/toft#unifying-liquidity). Although regular tOFTs don’t hardcode fees to 0, meta-tOFTs (mtOFTs) could incur a fee when wrapping, as shown in the following code snippet, where `_checkAndExtractFees()` is used to calculate a fee considering the wrapped `_amount`:\n\n```solidity\n// mTOFT.sol\n\nfunction wrap(address _fromAddress, address _toAddress, uint256 _amount)\n        external\n        payable \n        whenNotPaused\n        nonReentrant\n        returns (uint256 minted)\n    {\n        ...\n     \n        uint256 feeAmount = _checkAndExtractFees(_amount);\n        if (erc20 == address(0)) {\n            _wrapNative(_toAddress, _amount, feeAmount);\n        } else { \n            if (msg.value > 0) revert mTOFT_NotNative();\n            _wrap(_fromAddress, _toAddress, _amount, feeAmount);\n        }\n\n        return _amount - feeAmount;\n    } \n```\n\nWhen fees are applied, the amount of `mtOFTs` minted to the caller won’t be the full `_amount`, but the `_amount - feeAmount`. \n\nTapioca’s leverage executors are required to wrap/unwrap assets when tOFTs are used as collateral in order to properly perform their logic. The problem is that leverage executors don’t consider the fact that if collateral is an `mtOFT`, then a fee could be applied.\n\nLet’s consider the `BaseLeverageExecutor` ****contract (who whas the `_swapAndTransferToSender()` function, called by all leverage executors):\n\n```solidity\n// BaseLeverageExecutor.sol\n\nfunction _swapAndTransferToSender( \n        bool sendBack, \n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn, \n        bytes memory data\n    ) internal returns (uint256 amountOut) {\n        SLeverageSwapData memory swapData = abi.decode(data, (SLeverageSwapData)); \n \n\t\t\t  ...\n  \n        // If the tokenOut is a tOFT, wrap it. Handles ETH and ERC20.\n        // If `sendBack` is true, wrap the `amountOut to` the sender. else, wrap it to this contract.\n        if (swapData.toftInfo.isTokenOutToft) {  \n            _handleToftWrapToSender(sendBack, tokenOut, amountOut);\n        } else if (sendBack == true) {\n            // If the token wasn't sent by the wrap OP, send it as a transfer.\n            IERC20(tokenOut).safeTransfer(msg.sender, amountOut);\n        } \n    } \n\n```\n\nAs we can see in the code snippet, if the user requires to wrap the obtained swapped assets by setting `swapData.toftInfo.isTokenOutToft` to `true`, then the internal `_handleToftWrapToSender()` function will be called. This function will wrap the tOFT (or mtOFT) and send it to `msg.sender` or `address(this)`, depending on the user’s `sendBack` input:\n\n```solidity\n// BaseLeverageExecutor.sol\n\nfunction _handleToftWrapToSender(bool sendBack, address tokenOut, uint256 amountOut) internal {\n        address toftErc20 = ITOFT(tokenOut).erc20();\n        address wrapsTo = sendBack == true ? msg.sender : address(this);\n\n        if (toftErc20 == address(0)) {\n            // If the tOFT is for ETH, withdraw from WETH and wrap it.\n            weth.withdraw(amountOut);\n            ITOFT(tokenOut).wrap{value: amountOut}(address(this), wrapsTo, amountOut);\n        } else {\n            // If the tOFT is for an ERC20, wrap it.\n            toftErc20.safeApprove(tokenOut, amountOut);\n            ITOFT(tokenOut).wrap(address(this), wrapsTo, amountOut);\n            toftErc20.safeApprove(tokenOut, 0);\n        }\n    }\n```\n\nThe problem here is that if `tokenOut` is an mtOFT, then a fee might be applied when wrapping. However, this function does not consider the `wrap()` function return value (which as shown in the first code snippet in this report, whill return the actual minted amount, which is always `_amount - feeAmount` ).\n\nThis leads to a vulnerability where contracts performing this wraps will believe they have more funds than the intended, leading to a Denial of Service and making the leverage executors never work with mtOFTs.\n\n## Proof of concept\n\nLet’s say a user wants to lever up by calling `BBLeverage.sol`'s `buyCollateral()` function:\n\n```solidity\n// BBLeverage.sol\n\nfunction buyCollateral(address from, uint256 borrowAmount, uint256 supplyAmount, bytes calldata data) \n        external\n        optionNotPaused(PauseType.LeverageBuy)\n        solvent(from, false)\n        notSelf(from)  \n        returns (uint256 amountOut) \n    { \n        \n\n        ...\n        \n        { \n            amountOut = leverageExecutor.getCollateral( \n                collateralId, \n                address(asset),\n                address(collateral),\n                memoryData.supplyShareToAmount + memoryData.borrowShareToAmount,\n                calldata_.from,\n                calldata_.data\n            );\n        }\n        uint256 collateralShare = yieldBox.toShare(collateralId, amountOut, false);\n        address(asset).safeApprove(address(yieldBox), type(uint256).max); \n  \n        \n        yieldBox.depositAsset(collateralId, address(this), address(this), 0, collateralShare); \n        address(asset).safeApprove(address(yieldBox), 0); \n \n        ...\n    } \n```\n\n1. As we can see, the contract will call `leverageExecutor.getCollateral()` in order to perform the swap. Notice how the value returned by `getCollateral()` will be stored in the amountOut variable, which will later be converted to `collateralShare` and deposited into the `yieldBox`.\n2. Let’s say the `leverageExecutor` in this case is the `SimpleLeverageExecutor.sol` contract. When `getCollateral()` is called, `SimpleLeverageExecutor` will directly return the value returned by the internal `_swapAndTransferToSender()` function:\n    \n    ```solidity\n    // SimpleLeverageExecutor.sol\n    \n    function getCollateral(  \n            address assetAddress,\n            address collateralAddress,\n            uint256 assetAmountIn,\n            bytes calldata swapperData \n        ) external payable override returns (uint256 collateralAmountOut) {\n            // Should be called only by approved SGL/BB markets.\n            if (!cluster.isWhitelisted(0, msg.sender)) revert SenderNotValid();\n            return _swapAndTransferToSender(true, assetAddress, collateralAddress, assetAmountIn, swapperData);\n        }  \n    ```\n    \n3. As seen in the report, `_swapAndTransferToSender()` won’t return the amount swapped and wrapped, and will instead only return the amount obtained when swapping, assuming that wraps will always mint the same amount:\n    \n    ```solidity\n    // BaseLeverageExecutor.sol\n    \n    function _swapAndTransferToSender( \n            bool sendBack, \n            address tokenIn,\n            address tokenOut,\n            uint256 amountIn, \n            bytes memory data\n        ) internal returns (uint256 amountOut) {\n        \n            ...\n            \n            amountOut = swapper.swap(swapperData, amountIn, swapData.minAmountOut);\n            \n            ...\n            if (swapData.toftInfo.isTokenOutToft) {  \n                _handleToftWrapToSender(sendBack, tokenOut, amountOut);\n            } else if (sendBack == true) {\n                // If the token wasn't sent by the wrap OP, send it as a transfer.\n                IERC20(tokenOut).safeTransfer(msg.sender, amountOut);\n            } \n        } \n    ```\n    \n\nIf the tokenOut is an mtOFT, the actual obtained amount will be smaller than the `amountOut` stored due to the fees that might be applied.\n\nThis makes the `yieldBox.depositAsset()` in `BBLeverage.sol` inevitably always fail due to not having enough funds to deposit into the YieldBox effectively causing a Denial of Service\n\n## Impact\n\nHigh. The core functionality of leverage won’t work if the tokens are mtOFT tokens.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/leverage/AssetToSGLPLeverageExecutor.sol#L97\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/leverage/AssetTotsDaiLeverageExecutor.sol#L63\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/leverage/BaseLeverageExecutor.sol#L196-L200\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider the fees applied when wrapping assets by following OFT’s API, and store the returned value by `wrap()`. For example, `_handleToftWrapToSender()` could return an integer with the actual amount obtained after wrapping:\n\n```diff\n// BaseLeverageExecutor.sol\n\nfunction _handleToftWrapToSender(bool sendBack, address tokenOut, uint256 amountOut) internal returns(uint256 _amountOut) {\n        address toftErc20 = ITOFT(tokenOut).erc20();\n        address wrapsTo = sendBack == true ? msg.sender : address(this);\n\n        if (toftErc20 == address(0)) {\n            // If the tOFT is for ETH, withdraw from WETH and wrap it.\n            weth.withdraw(amountOut);\n-            ITOFT(tokenOut).wrap{value: amountOut}(address(this), wrapsTo, amountOut);\n+\t    _amountOut = ITOFT(tokenOut).wrap{value: amountOut}(address(this), wrapsTo, amountOut);\n        } else {\n            // If the tOFT is for an ERC20, wrap it.\n            toftErc20.safeApprove(tokenOut, amountOut);\n-           _amountOut = ITOFT(tokenOut).wrap(address(this), wrapsTo, amountOut);\n+           ITOFT(tokenOut).wrap(address(this), wrapsTo, amountOut);\n            toftErc20.safeApprove(tokenOut, 0);\n        }\n    }\n```\n\nAnd this value should be the one stored in _swapAndTransferToSender`()`'s `amountOut`:\n\n```diff\nfunction _swapAndTransferToSender( \n        bool sendBack, \n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn, \n        bytes memory data\n    ) internal returns (uint256 amountOut) {\n        SLeverageSwapData memory swapData = abi.decode(data, (SLeverageSwapData)); \n \n\t\t\t  ...\n  \n        // If the tokenOut is a tOFT, wrap it. Handles ETH and ERC20.\n        // If `sendBack` is true, wrap the `amountOut to` the sender. else, wrap it to this contract.\n        if (swapData.toftInfo.isTokenOutToft) {  \n-            _handleToftWrapToSender(sendBack, tokenOut, amountOut);\n+\t     amountOut = _handleToftWrapToSender(sendBack, tokenOut, amountOut);\n        } else if (sendBack == true) {\n            // If the token wasn't sent by the wrap OP, send it as a transfer.\n            IERC20(tokenOut).safeTransfer(msg.sender, amountOut);\n        } \n    } \n\n```\n\n\n\n## Discussion\n\n**cryptotechmaker**\n\nDuplicate of https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/46\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Tapioca-DAO/Tapioca-bar/pull/364.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "Tapioca-bar/contracts/markets/leverage/AssetToSGLPLeverageExecutor.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\n\n// Tapioca\nimport {IGmxRewardRouterV2} from \"tapioca-periph/interfaces/external/gmx/IGmxRewardRouterV2.sol\";\nimport {IGmxGlpManager} from \"tapioca-periph/interfaces/external/gmx/IGmxGlpManager.sol\";\nimport {ITOFT} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\nimport {BaseLeverageExecutor, SLeverageSwapData} from \"./BaseLeverageExecutor.sol\";\nimport {IZeroXSwapper} from \"tapioca-periph/interfaces/periph/IZeroXSwapper.sol\";\nimport {ICluster} from \"tapioca-periph/interfaces/periph/ICluster.sol\";\nimport {SafeApprove} from \"../../libraries/SafeApprove.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\nstruct SGlpLeverageSwapData {\n    SLeverageSwapData swapData;\n    // Token to swap USDO > token > tsGLP.\n    address token;\n    // Min amount of tokens to receive after a buy/sell GLP swap\n    // In the case of a buy swap, it represents the min amount of GLP to receive\n    // In the case of a sell swap, it represents the min amount of `token` to receive\n    uint256 minAmountOut;\n}\n\n/// @title AssetToSGLPLeverageExecutor\n/// @notice Contract for leverage executor for tsGLP markets\ncontract AssetToSGLPLeverageExecutor is BaseLeverageExecutor, Pausable {\n    using SafeApprove for address;\n\n    IGmxRewardRouterV2 private immutable glpRewardRouter;\n    IGmxGlpManager private immutable glpManager;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n\n    error NotEnough(uint256 expected, uint256 received);\n\n    constructor(IZeroXSwapper _swapper, ICluster _cluster, IGmxRewardRouterV2 _glpRewardRouter)\n        BaseLeverageExecutor(_swapper, _cluster)\n    {\n        glpManager = IGmxGlpManager(_glpRewardRouter.glpManager());\n        glpRewardRouter = _glpRewardRouter;\n    }\n\n    // ********************* //\n    // *** PUBLIC METHODS *** //\n    // ********************* //\n\n    /**\n     * @dev USDO > SGlpLeverageSwapData.token > wrap to tsGLP\n     * @dev Expects SLeverageSwapData.toftInfo.isTokenInToft to be false. Does the unwrapping internally.\n     * @dev Expects SLeverageSwapData.toftInfo.isTokenOutToft to be false. Does the wrapping internally.\n     * @dev SGlpLeverageSwapData.minAmountOut represents the min amount of GLP.\n     *\n     * @inheritdoc BaseLeverageExecutor\n     */\n    function getCollateral(address assetAddress, address collateralAddress, uint256 assetAmountIn, bytes calldata data)\n        external\n        payable\n        override\n        whenNotPaused\n        returns (uint256 collateralAmountOut)\n    {\n        if (msg.value > 0) revert NativeNotSupported();\n\n        // Should be called only by approved SGL/BB markets.\n        if (!cluster.isWhitelisted(0, msg.sender)) revert SenderNotValid();\n\n        // Decode data\n        SGlpLeverageSwapData memory glpSwapData = abi.decode(data, (SGlpLeverageSwapData));\n\n        // Swap asset with `SGlpLeverageSwapData.token`\n        uint256 tokenAmount = _swapAndTransferToSender(\n            false, assetAddress, glpSwapData.token, assetAmountIn, glpSwapData.swapData.swapperData\n        );\n\n        // Swap `SGlpLeverageSwapData.token` with GLP\n        collateralAmountOut = _buyGlp(glpSwapData.token, tokenAmount, glpSwapData.minAmountOut);\n\n        // Wrap into tsGLP to sender\n        address sGLP = ITOFT(collateralAddress).erc20();\n        sGLP.safeApprove(collateralAddress, collateralAmountOut);\n        ITOFT(collateralAddress).wrap(address(this), msg.sender, collateralAmountOut);\n        sGLP.safeApprove(collateralAddress, 0);\n    }\n\n    /**\n     * @dev unwrap tsGLP > SGlpLeverageSwapData.token > USDO\n     * @dev Expects SLeverageSwapData.toftInfo.isTokenInToft to be false. Does the unwrapping internally.\n     * @dev Expects SLeverageSwapData.toftInfo.isTokenOutToft to be false. Does the wrapping internally.\n     * @dev SGlpLeverageSwapData.minAmountOut represents the min amount of `SGlpLeverageSwapData.token`.\n     *\n     * @inheritdoc BaseLeverageExecutor\n     */\n    function getAsset(address collateralAddress, address assetAddress, uint256 collateralAmountIn, bytes calldata data)\n        external\n        override\n        returns (uint256 assetAmountOut)\n    {\n        // Should be called only by approved SGL/BB markets.\n        if (!cluster.isWhitelisted(0, msg.sender)) revert SenderNotValid();\n\n        // Decode data\n        SGlpLeverageSwapData memory tokenSwapData = abi.decode(data, (SGlpLeverageSwapData));\n\n        // Unwrap tsGLP\n        ITOFT(collateralAddress).unwrap(address(this), collateralAmountIn);\n\n        // Swap GLP with `SGlpLeverageSwapData.token`\n        address sGLP = ITOFT(collateralAddress).erc20();\n        uint256 tokenAmount = _sellGlp(tokenSwapData.token, tokenSwapData.minAmountOut, sGLP, collateralAmountIn);\n\n        // Swap `SGlpLeverageSwapData.token` with asset.\n        // If sendBack true and swapData.swapperData.toftInfo.isTokenOutToft false\n        // The asset will be transfer via IERC20 transfer.\n        assetAmountOut = _swapAndTransferToSender(\n            true, tokenSwapData.token, assetAddress, tokenAmount, tokenSwapData.swapData.swapperData\n        );\n    }\n\n    // ********************** //\n    // *** PRIVATE METHODS *** //\n    // ********************** //\n\n    /**\n     * @dev Buys GLP with a chosen `token`. The `token` is chosen off-chain and is computed to be the best to buy GLP with,\n     * for swapping USDO to the `token`.\n     *\n     * @param token Token to swap for GLP\n     * @param tokenAmount Amount of `token` to swap for GLP\n     * @param minGlpAmountOut Min amount of GLP to receive\n     *\n     * @return glpAmount Amount of GLP received\n     */\n    function _buyGlp(address token, uint256 tokenAmount, uint256 minGlpAmountOut) private returns (uint256 glpAmount) {\n        token.safeApprove(address(glpManager), tokenAmount);\n        glpAmount = glpRewardRouter.mintAndStakeGlp(token, tokenAmount, 0, minGlpAmountOut);\n        token.safeApprove(address(glpManager), 0);\n\n        if (glpAmount < minGlpAmountOut) revert NotEnough(minGlpAmountOut, glpAmount);\n    }\n\n    /**\n     * @dev Sells GLP for `token`. The `token` is chosen off-chain and is computed to be the best to sell GLP for,\n     * for swapping the `token` to USDO.\n     *\n     * @param token Token to swap for GLP\n     * @param minTokenAmountOut Min amount of `token` to receive\n     * @param sGLP sGLP address\n     * @param glpAmount Amount of GLP to swap for `token`\n     *\n     * @return tokenAmount Amount of `token` received\n     */\n    function _sellGlp(address token, uint256 minTokenAmountOut, address sGLP, uint256 glpAmount)\n        private\n        returns (uint256 tokenAmount)\n    {\n        sGLP.safeApprove(address(glpManager), glpAmount);\n        tokenAmount = glpRewardRouter.unstakeAndRedeemGlp(token, glpAmount, minTokenAmountOut, address(this));\n        sGLP.safeApprove(address(glpManager), 0);\n        if (tokenAmount < minTokenAmountOut) revert NotEnough(minTokenAmountOut, tokenAmount);\n    }\n}"
    },
    {
      "filename": "Tapioca-bar/contracts/markets/leverage/AssetTotsDaiLeverageExecutor.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n//interfaces\nimport {ISavingsDai} from \"tapioca-periph/interfaces/external/makerdao/ISavingsDai.sol\";\nimport {BaseLeverageExecutor, SLeverageSwapData} from \"./BaseLeverageExecutor.sol\";\nimport {IZeroXSwapper} from \"tapioca-periph/interfaces/periph/IZeroXSwapper.sol\";\nimport {ICluster} from \"tapioca-periph/interfaces/periph/ICluster.sol\";\nimport {ITOFT} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\nimport {SafeApprove} from \"../../libraries/SafeApprove.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract AssetTotsDaiLeverageExecutor is BaseLeverageExecutor {\n    using SafeApprove for address;\n\n    constructor(IZeroXSwapper _swapper, ICluster _cluster) BaseLeverageExecutor(_swapper, _cluster) {}\n\n    // ********************* //\n    // *** PUBLIC METHODS *** //\n    // ********************* //\n\n    /**\n     * @dev USDO > DAI > sDAi > wrap to tsDai\n     * @dev Expects SLeverageSwapData.toftInfo.isTokenInToft to be false. Does the unwrapping internally.\n     * @dev Expects SLeverageSwapData.toftInfo.isTokenOutToft to be false. Does the wrapping internally.\n     * @inheritdoc BaseLeverageExecutor\n     */\n    function getCollateral(address assetAddress, address collateralAddress, uint256 assetAmountIn, bytes calldata data)\n        external\n        payable\n        override\n        returns (uint256 collateralAmountOut)\n    {\n        if (msg.value > 0) revert NativeNotSupported();\n\n        // Should be called only by approved SGL/BB markets.\n        if (!cluster.isWhitelisted(0, msg.sender)) revert SenderNotValid();\n\n        //retrieve addresses\n        (address sDaiAddress, address daiAddress) = _getAddresses(collateralAddress);\n\n        //swap USDO (asset) with DAI\n        SLeverageSwapData memory swapData = abi.decode(data, (SLeverageSwapData));\n        uint256 daiAmount =\n            _swapAndTransferToSender(false, assetAddress, daiAddress, assetAmountIn, swapData.swapperData);\n\n        //obtain sDai\n        daiAddress.safeApprove(sDaiAddress, daiAmount);\n        collateralAmountOut = ISavingsDai(sDaiAddress).deposit(daiAmount, address(this));\n\n        // Wrap into tsDai to sender\n        sDaiAddress.safeApprove(collateralAddress, collateralAmountOut);\n        ITOFT(collateralAddress).wrap(address(this), msg.sender, collateralAmountOut);\n        sDaiAddress.safeApprove(collateralAddress, 0);\n    }\n\n    /**\n     * @dev unwrap tsDai > withdraw sDai > Dai > USDO\n     * @dev Expects SLeverageSwapData.toftInfo.isTokenInToft to be false. Does the unwrapping internally.\n     * @dev Expects SLeverageSwapData.toftInfo.isTokenOutToft to be false. Does the wrapping internally.\n     * @inheritdoc BaseLeverageExecutor\n     */\n    function getAsset(address collateralAddress, address assetAddress, uint256 collateralAmountIn, bytes calldata data)\n        external\n        override\n        returns (uint256 assetAmountOut)\n    {\n        // Should be called only by approved SGL/BB markets.\n        if (!cluster.isWhitelisted(0, msg.sender)) revert SenderNotValid();\n\n        //retrieve addresses\n        (address sDaiAddress, address daiAddress) = _getAddresses(collateralAddress);\n        //unwrap tsDai\n        ITOFT(collateralAddress).unwrap(address(this), collateralAmountIn);\n        //redeem from sDai\n        uint256 obtainedDai = ISavingsDai(sDaiAddress).redeem(collateralAmountIn, address(this), address(this));\n        // swap DAI with USDO, and transfer to sender\n        SLeverageSwapData memory swapData = abi.decode(data, (SLeverageSwapData));\n        // If sendBack true and swapData.swapperData.toftInfo.isTokenOutToft false\n        // The asset will be transfer via IERC20 transfer.\n        assetAmountOut = _swapAndTransferToSender(true, daiAddress, assetAddress, obtainedDai, swapData.swapperData);\n    }\n\n    // ********************** //\n    // *** PRIVATE METHODS *** //\n    // ********************** //\n\n    /**\n     * @dev retrieve sDai and Dai addresses from tsDai\n     */\n    function _getAddresses(address collateralAddress) private view returns (address sDaiAddress, address daiAddress) {\n        //retrieve sDAI address from tsDai\n        sDaiAddress = ITOFT(collateralAddress).erc20();\n        if (sDaiAddress == address(0)) revert TokenNotValid();\n\n        //retrieve DAI address from sDAI\n        daiAddress = ISavingsDai(sDaiAddress).dai();\n    }\n}"
    },
    {
      "filename": "Tapioca-bar/contracts/markets/leverage/BaseLeverageExecutor.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {IZeroXSwapper} from \"tapioca-periph/interfaces/periph/IZeroXSwapper.sol\";\nimport {IWeth9} from \"tapioca-periph/interfaces/external/weth/IWeth9.sol\";\nimport {ICluster} from \"tapioca-periph/interfaces/periph/ICluster.sol\";\nimport {ITOFT} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\nimport {SafeApprove} from \"../../libraries/SafeApprove.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\nstruct SToftInfo {\n    bool isTokenInToft;\n    bool isTokenOutToft;\n}\n\nstruct SLeverageSwapData {\n    uint256 minAmountOut;\n    SToftInfo toftInfo;\n    bytes swapperData;\n}\n\nabstract contract BaseLeverageExecutor is Ownable {\n    using SafeApprove for address;\n    using SafeERC20 for IERC20;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n\n    IZeroXSwapper public swapper;\n    ICluster public cluster;\n    IWeth9 public weth;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n\n    error MinAmountNotValid(uint256 expected, uint256 received);\n    error SwapperNotAuthorized();\n    error SwapperNotValid();\n    error SenderNotValid();\n    error TokenNotValid();\n    error NativeNotSupported();\n\n    constructor(IZeroXSwapper _swapper, ICluster _cluster) {\n        swapper = _swapper;\n        cluster = _cluster;\n    }\n\n    receive() external payable {}\n\n    // ******************** //\n    // *** OWNER METHODS *** //\n    // ******************** //\n\n    /// @notice sets swapper\n    /// @param _swapper the new IZeroXSwapper\n    function setSwapper(IZeroXSwapper _swapper) external onlyOwner {\n        swapper = _swapper;\n    }\n\n    /// @notice sets cluster\n    /// @param _cluster the new ICluster\n    function setCluster(ICluster _cluster) external onlyOwner {\n        cluster = _cluster;\n    }\n\n    // ********************* //\n    // *** PUBLIC METHODS *** //\n    // ********************* //\n\n    /**\n     * @notice Buys an asked amount of collateral with an asset using the ZeroXSwapper.\n     * @dev Expects the token to be already transferred to this contract.\n     * @param assetAddress asset address.\n     * @param collateralAddress collateral address.\n     * @param assetAmountIn amount to swap.\n     * @param data SLeverageSwapData.\n     */\n    function getCollateral(address assetAddress, address collateralAddress, uint256 assetAmountIn, bytes calldata data)\n        external\n        payable\n        virtual\n        returns (uint256 collateralAmountOut)\n    {}\n\n    /**\n     * @notice Buys an asked amount of asset with a collateral using the ZeroXSwapper.\n     * @dev Expects the token to be already transferred to this contract.\n     * @param collateralAddress collateral address.\n     * @param assetAddress asset address.\n     * @param collateralAmountIn amount to swap.\n     * @param data SLeverageSwapData.\n     */\n    function getAsset(address collateralAddress, address assetAddress, uint256 collateralAmountIn, bytes calldata data)\n        external\n        virtual\n        returns (uint256 assetAmountOut)\n    {}\n\n    // *********************** //\n    // *** INTERNAL METHODS *** //\n    // *********************** //\n\n    /**\n     * @notice Sell `tokenIn` and buy `tokenOut`.\n     * @dev Sends the `amountOut` of `tokenOut` to the sender if `sendBack` is true, by wrapping or transferring it.\n     *\n     * @param tokenIn token to swap. Can be tOFT.\n     * @param tokenOut token to receive. Can be tOFT.\n     * @param amountIn amount to swap.\n     * @param data SLeverageSwapData.\n     */\n    function _swapAndTransferToSender(\n        bool sendBack,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        bytes memory data\n    ) internal returns (uint256 amountOut) {\n        SLeverageSwapData memory swapData = abi.decode(data, (SLeverageSwapData));\n\n        // If the tokenIn is a tOFT, unwrap it. Handles ETH and ERC20.\n        if (swapData.toftInfo.isTokenInToft) {\n            tokenIn = _handleToftUnwrap(tokenIn, amountIn);\n        }\n\n        // Approve the swapper to spend the tokenIn, and perform the swap.\n        tokenIn.safeApprove(address(swapper), amountIn);\n        IZeroXSwapper.SZeroXSwapData memory swapperData =\n            abi.decode(swapData.swapperData, (IZeroXSwapper.SZeroXSwapData));\n        amountOut = swapper.swap(swapperData, amountIn, swapData.minAmountOut);\n        if (amountOut < swapData.minAmountOut) revert MinAmountNotValid(swapData.minAmountOut, amountOut);\n        tokenIn.safeApprove(address(swapper), 0);\n\n        // If the tokenOut is a tOFT, wrap it. Handles ETH and ERC20.\n        // If `sendBack` is true, wrap the `amountOut to` the sender. else, wrap it to this contract.\n        if (swapData.toftInfo.isTokenOutToft) {\n            _handleToftWrapToSender(sendBack, tokenOut, amountOut);\n        } else if (sendBack == true) {\n            // If the token wasn't sent by the wrap OP, send it as a transfer.\n            IERC20(tokenOut).safeTransfer(msg.sender, amountOut);\n        }\n    }\n\n    /**\n     * @notice Unwraps a tOFT token if it is the tokenIn. If the tOFT is an ERC20, it unwraps it and returns the ERC20 address.\n     * if the tOFT is an ETH, it unwraps it and returns the WETH address.\n     *\n     * @param tokenIn tOFT token to unwrap.\n     * @param amountIn amount to unwrap.\n     * @return tokenToSwap address of the token to swap. Either WETH or the ERC20 address.\n     */\n    function _handleToftUnwrap(address tokenIn, uint256 amountIn) internal returns (address tokenToSwap) {\n        ITOFT(tokenIn).unwrap(address(this), amountIn); // Sends ETH to `receive()` if not an ERC20.\n        tokenIn = ITOFT(tokenIn).erc20();\n        // If the tokenIn is ETH, wrap it to WETH.\n        if (tokenIn == address(0)) {\n            weth.deposit{value: amountIn}();\n            tokenToSwap = address(weth);\n        } else {\n            tokenToSwap = tokenIn;\n        }\n    }\n\n    /**\n     * @notice Wrap an ERC20 or ETH to a `tokenOut` tOFT token.\n     * @dev Wraps the amountOut and sends it to the sender.\n     *\n     * @param sendBack if true, sends the `amountOut` to the sender. Else, sends it to this contract.\n     * @param tokenOut tOFT token.\n     * @param amountOut amount to wrap.\n     */\n    function _handleToftWrapToSender(bool sendBack, address tokenOut, uint256 amountOut) internal {\n        address toftErc20 = ITOFT(tokenOut).erc20();\n        address wrapsTo = sendBack == true ? msg.sender : address(this);\n\n        if (toftErc20 == address(0)) {\n            // If the tOFT is for ETH, withdraw from WETH and wrap it.\n            weth.withdraw(amountOut);\n            ITOFT(tokenOut).wrap{value: amountOut}(address(this), wrapsTo, amountOut);\n        } else {\n            // If the tOFT is for an ERC20, wrap it.\n            toftErc20.safeApprove(tokenOut, amountOut);\n            ITOFT(tokenOut).wrap(address(this), wrapsTo, amountOut);\n            toftErc20.safeApprove(tokenOut, 0);\n        }\n    }\n}"
    }
  ]
}