{
  "Title": "Public functions for withdrawn assets in the `PeripheryPayments` contract",
  "Content": "##### Description\nThe [`sweepToken`](https://github.com/DivergenceProtocol/diver-contracts/blob/e5286f94a7ccb9d6279fae51ea66a8833672628a/src/periphery/base/PeripheryPayments.sol#L31) and [`refundETH`](https://github.com/DivergenceProtocol/diver-contracts/blob/e5286f94a7ccb9d6279fae51ea66a8833672628a/src/periphery/base/PeripheryPayments.sol#L42) functions allow anyone to withdraw funds from the `Manager` contract. There are no funds on the contract by design but if someone makes a wrong transfer to the contract by mistake, an attacker can steal it. Also, there is a risk of inheritance of this contract in the future in other cases where funds will be kept on a new contract. \n\n##### Recommendation\nWe recommend adding access control to the withdraw functions.\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/periphery/base/PeripheryPayments.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.14;\n\nimport { IERC20 } from \"@oz/token/ERC20/IERC20.sol\";\nimport { TransferHelper } from \"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\";\nimport { Errors } from \"../../core/errors/Errors.sol\";\nimport { IPeripheryPayments } from \"../interfaces/IPeripheryPayments.sol\";\nimport { IWETH9 } from \"../interfaces/external/IWETH9.sol\";\nimport { PeripheryImmutableState } from \"./PeripheryImmutableState.sol\";\n\nabstract contract PeripheryPayments is IPeripheryPayments, PeripheryImmutableState {\n    receive() external payable {\n        if (msg.sender != WETH9) {\n            revert Errors.NotWETH9();\n        }\n    }\n\n    function unwrapWETH9(uint256 amountMinimum, address recipient) public payable override {\n        uint256 balanceWETH9 = IWETH9(WETH9).balanceOf(address(this));\n        if (balanceWETH9 < amountMinimum) {\n            revert Errors.Insufficient();\n        }\n\n        if (balanceWETH9 > 0) {\n            IWETH9(WETH9).withdraw(balanceWETH9);\n            TransferHelper.safeTransferETH(recipient, balanceWETH9);\n        }\n    }\n\n    function sweepToken(address token, uint256 amountMinimum, address recipient) public payable override {\n        uint256 balanceToken = IERC20(token).balanceOf(address(this));\n        if (balanceToken < amountMinimum) {\n            revert Errors.Insufficient();\n        }\n\n        if (balanceToken > 0) {\n            TransferHelper.safeTransfer(token, recipient, balanceToken);\n        }\n    }\n\n    function refundETH() external payable override {\n        if (address(this).balance > 0) {\n            TransferHelper.safeTransferETH(msg.sender, address(this).balance);\n        }\n    }\n\n    function pay(address tokenAddr, address payer, address recipient, uint256 value) internal {\n        if (tokenAddr == WETH9 && address(this).balance >= value) {\n            // pay with WETH9\n            IWETH9(WETH9).deposit{ value: value }(); // wrap only what is needed\n                // to pay\n            IWETH9(WETH9).transfer(recipient, value);\n        } else if (payer == address(this)) {\n            // pay with tokens already in the contract (for the exact input\n            // multihop case)\n            TransferHelper.safeTransfer(tokenAddr, recipient, value);\n        } else {\n            // pull payment\n            TransferHelper.safeTransferFrom(tokenAddr, payer, recipient, value);\n        }\n    }\n}"
    }
  ]
}