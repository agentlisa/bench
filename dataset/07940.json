{
  "Title": "[Gâ€‘15] Use custom errors rather than `revert()`/`require()` strings to save gas",
  "Content": "\nCustom errors are available from solidity version 0.8.4. Custom errors save [**\\~50 gas**](https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hit by [avoiding having to allocate and store the revert string](https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas\n\n*There are 32 instances of this issue:*\n\n```solidity\nFile: src/core/contracts/AlgebraFactory.sol\n\n109:      require(uint256(alpha1) + uint256(alpha2) + uint256(baseFee) <= type(uint16).max, 'Max fee exceeded');\n\n110:      require(gamma1 != 0 && gamma2 != 0 && volumeGamma != 0, 'Gammas must be > 0');\n\n```\n\n<https://github.com/code-423n4/2022-09-quickswap/blob/15ea643c85ed936a92d2676a7aabf739b210af39/src/core/contracts/AlgebraFactory.sol#L109>\n\n```solidity\nFile: src/core/contracts/AlgebraPool.sol\n\n60:       require(topTick < TickMath.MAX_TICK + 1, 'TUM');\n\n61:       require(topTick > bottomTick, 'TLU');\n\n62:       require(bottomTick > TickMath.MIN_TICK - 1, 'TLM');\n\n194:      require(globalState.price == 0, 'AI');\n\n224:        require(currentLiquidity > 0, 'NP'); // Do not recalculate the empty ranges\n\n434:      require(liquidityDesired > 0, 'IL');\n\n454:        if (amount0 > 0) require((receivedAmount0 = balanceToken0() - receivedAmount0) > 0, 'IIAM');\n\n455:        if (amount1 > 0) require((receivedAmount1 = balanceToken1() - receivedAmount1) > 0, 'IIAM');\n\n469:      require(liquidityActual > 0, 'IIL2');\n\n474:        require((amount0 = uint256(amount0Int)) <= receivedAmount0, 'IIAM2');\n\n475:        require((amount1 = uint256(amount1Int)) <= receivedAmount1, 'IIAM2');\n\n608:        require(balance0Before.add(uint256(amount0)) <= balanceToken0(), 'IIA');\n\n614:        require(balance1Before.add(uint256(amount1)) <= balanceToken1(), 'IIA');\n\n636:      require(globalState.unlocked, 'LOK');\n\n641:        require((amountRequired = int256(balanceToken0().sub(balance0Before))) > 0, 'IIA');\n\n645:        require((amountRequired = int256(balanceToken1().sub(balance1Before))) > 0, 'IIA');\n\n731:        require(unlocked, 'LOK');\n\n733:        require(amountRequired != 0, 'AS');\n\n739:          require(limitSqrtPrice < currentPrice && limitSqrtPrice > TickMath.MIN_SQRT_RATIO, 'SPL');\n\n743:          require(limitSqrtPrice > currentPrice && limitSqrtPrice < TickMath.MAX_SQRT_RATIO, 'SPL');\n\n898:      require(_liquidity > 0, 'L');\n\n921:      require(balance0Before.add(fee0) <= paid0, 'F0');\n\n935:      require(balance1Before.add(fee1) <= paid1, 'F1');\n\n```\n\n<https://github.com/code-423n4/2022-09-quickswap/blob/15ea643c85ed936a92d2676a7aabf739b210af39/src/core/contracts/AlgebraPool.sol#L60>\n\n```solidity\nFile: src/core/contracts/base/PoolState.sol\n\n41:       require(globalState.unlocked, 'LOK');\n\n```\n\n<https://github.com/code-423n4/2022-09-quickswap/blob/15ea643c85ed936a92d2676a7aabf739b210af39/src/core/contracts/base/PoolState.sol#L41>\n\n```solidity\nFile: src/core/contracts/DataStorageOperator.sol\n\n27:       require(msg.sender == pool, 'only pool can call this');\n\n45:       require(uint256(_feeConfig.alpha1) + uint256(_feeConfig.alpha2) + uint256(_feeConfig.baseFee) <= type(uint16).max, 'Max fee exceeded');\n\n46:       require(_feeConfig.gamma1 != 0 && _feeConfig.gamma2 != 0 && _feeConfig.volumeGamma != 0, 'Gammas must be > 0');\n\n```\n\n<https://github.com/code-423n4/2022-09-quickswap/blob/15ea643c85ed936a92d2676a7aabf739b210af39/src/core/contracts/DataStorageOperator.sol#L27>\n\n```solidity\nFile: src/core/contracts/libraries/DataStorage.sol\n\n238:      require(lteConsideringOverflow(self[oldestIndex].blockTimestamp, target, time), 'OLD');\n\n```\n\n<https://github.com/code-423n4/2022-09-quickswap/blob/15ea643c85ed936a92d2676a7aabf739b210af39/src/core/contracts/libraries/DataStorage.sol#L238>\n\n```solidity\nFile: src/core/contracts/libraries/TickManager.sol\n\n96:       require(liquidityTotalAfter < Constants.MAX_LIQUIDITY_PER_TICK + 1, 'LO');\n\n```\n\n<https://github.com/code-423n4/2022-09-quickswap/blob/15ea643c85ed936a92d2676a7aabf739b210af39/src/core/contracts/libraries/TickManager.sol#L96>\n\n```solidity\nFile: src/core/contracts/libraries/TickTable.sol\n\n15:       require(tick % Constants.TICK_SPACING == 0, 'tick is not spaced'); // ensure that the tick is spaced\n\n```\n\n<https://github.com/code-423n4/2022-09-quickswap/blob/15ea643c85ed936a92d2676a7aabf739b210af39/src/core/contracts/libraries/TickTable.sol#L15>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-09-quickswap",
  "Code": [
    {
      "filename": "src/core/contracts/AlgebraFactory.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport './interfaces/IAlgebraFactory.sol';\nimport './interfaces/IAlgebraPoolDeployer.sol';\nimport './interfaces/IDataStorageOperator.sol';\nimport './libraries/AdaptiveFee.sol';\nimport './DataStorageOperator.sol';\n\n/**\n * @title Algebra factory\n * @notice Is used to deploy pools and its dataStorages\n */\ncontract AlgebraFactory is IAlgebraFactory {\n  /// @inheritdoc IAlgebraFactory\n  address public override owner;\n\n  /// @inheritdoc IAlgebraFactory\n  address public immutable override poolDeployer;\n\n  /// @inheritdoc IAlgebraFactory\n  address public override farmingAddress;\n\n  /// @inheritdoc IAlgebraFactory\n  address public override vaultAddress;\n\n  // values of constants for sigmoids in fee calculation formula\n  AdaptiveFee.Configuration public baseFeeConfiguration =\n    AdaptiveFee.Configuration(\n      3000 - Constants.BASE_FEE, // alpha1\n      15000 - 3000, // alpha2\n      360, // beta1\n      60000, // beta2\n      59, // gamma1\n      8500, // gamma2\n      0, // volumeBeta\n      10, // volumeGamma\n      Constants.BASE_FEE // baseFee\n    );\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  mapping(address => mapping(address => address)) public override poolByPair;\n\n  constructor(address _poolDeployer, address _vaultAddress) {\n    owner = msg.sender;\n    emit Owner(msg.sender);\n\n    poolDeployer = _poolDeployer;\n    vaultAddress = _vaultAddress;\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  function createPool(address tokenA, address tokenB) external override returns (address pool) {\n    require(tokenA != tokenB);\n    (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    require(token0 != address(0));\n    require(poolByPair[token0][token1] == address(0));\n\n    IDataStorageOperator dataStorage = new DataStorageOperator(computeAddress(token0, token1));\n\n    dataStorage.changeFeeConfiguration(baseFeeConfiguration);\n\n    pool = IAlgebraPoolDeployer(poolDeployer).deploy(address(dataStorage), address(this), token0, token1);\n\n    poolByPair[token0][token1] = pool; // to avoid future addresses comparing we are populating the mapping twice\n    poolByPair[token1][token0] = pool;\n    emit Pool(token0, token1, pool);\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  function setOwner(address _owner) external override onlyOwner {\n    require(owner != _owner);\n    emit Owner(_owner);\n    owner = _owner;\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  function setFarmingAddress(address _farmingAddress) external override onlyOwner {\n    require(farmingAddress != _farmingAddress);\n    emit FarmingAddress(_farmingAddress);\n    farmingAddress = _farmingAddress;\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  function setVaultAddress(address _vaultAddress) external override onlyOwner {\n    require(vaultAddress != _vaultAddress);\n    emit VaultAddress(_vaultAddress);\n    vaultAddress = _vaultAddress;\n  }\n\n  /// @inheritdoc IAlgebraFactory\n  function setBaseFeeConfiguration(\n    uint16 alpha1,\n    uint16 alpha2,\n    uint32 beta1,\n    uint32 beta2,\n    uint16 gamma1,\n    uint16 gamma2,\n    uint32 volumeBeta,\n    uint16 volumeGamma,\n    uint16 baseFee\n  ) external override onlyOwner {\n    require(uint256(alpha1) + uint256(alpha2) + uint256(baseFee) <= type(uint16).max, 'Max fee exceeded');\n    require(gamma1 != 0 && gamma2 != 0 && volumeGamma != 0, 'Gammas must be > 0');\n\n    baseFeeConfiguration = AdaptiveFee.Configuration(alpha1, alpha2, beta1, beta2, gamma1, gamma2, volumeBeta, volumeGamma, baseFee);\n    emit FeeConfiguration(alpha1, alpha2, beta1, beta2, gamma1, gamma2, volumeBeta, volumeGamma, baseFee);\n  }\n\n  bytes32 internal constant POOL_INIT_CODE_HASH = 0x6ec6c9c8091d160c0aa74b2b14ba9c1717e95093bd3ac085cee99a49aab294a4;\n\n  /// @notice Deterministically computes the pool address given the factory and PoolKey\n  /// @param token0 first token\n  /// @param token1 second token\n  /// @return pool The contract address of the Algebra pool\n  function computeAddress(address token0, address token1) internal view returns (address pool) {\n    pool = address(uint256(keccak256(abi.encodePacked(hex'ff', poolDeployer, keccak256(abi.encode(token0, token1)), POOL_INIT_CODE_HASH))));\n  }\n}"
    },
    {
      "filename": "src/core/contracts/AlgebraPool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.7.6;\n\nimport './interfaces/IAlgebraPool.sol';\nimport './interfaces/IDataStorageOperator.sol';\nimport './interfaces/IAlgebraVirtualPool.sol';\n\nimport './base/PoolState.sol';\nimport './base/PoolImmutables.sol';\n\nimport './libraries/TokenDeltaMath.sol';\nimport './libraries/PriceMovementMath.sol';\nimport './libraries/TickManager.sol';\nimport './libraries/TickTable.sol';\n\nimport './libraries/LowGasSafeMath.sol';\nimport './libraries/SafeCast.sol';\n\nimport './libraries/FullMath.sol';\nimport './libraries/Constants.sol';\nimport './libraries/TransferHelper.sol';\nimport './libraries/TickMath.sol';\nimport './libraries/LiquidityMath.sol';\n\nimport './interfaces/IAlgebraPoolDeployer.sol';\nimport './interfaces/IAlgebraFactory.sol';\nimport './interfaces/IERC20Minimal.sol';\nimport './interfaces/callback/IAlgebraMintCallback.sol';\nimport './interfaces/callback/IAlgebraSwapCallback.sol';\nimport './interfaces/callback/IAlgebraFlashCallback.sol';\n\ncontract AlgebraPool is PoolState, PoolImmutables, IAlgebraPool {\n  using LowGasSafeMath for uint256;\n  using LowGasSafeMath for int256;\n  using LowGasSafeMath for uint128;\n  using SafeCast for uint256;\n  using SafeCast for int256;\n  using TickTable for mapping(int16 => uint256);\n  using TickManager for mapping(int24 => TickManager.Tick);\n\n  struct Position {\n    uint128 liquidity; // The amount of liquidity concentrated in the range\n    uint32 lastLiquidityAddTimestamp; // Timestamp of last adding of liquidity\n    uint256 innerFeeGrowth0Token; // The last updated fee growth per unit of liquidity\n    uint256 innerFeeGrowth1Token;\n    uint128 fees0; // The amount of token0 owed to a LP\n    uint128 fees1; // The amount of token1 owed to a LP\n  }\n\n  /// @inheritdoc IAlgebraPoolState\n  mapping(bytes32 => Position) public override positions;\n\n  /// @dev Restricts everyone calling a function except factory owner\n  modifier onlyFactoryOwner() {\n    require(msg.sender == IAlgebraFactory(factory).owner());\n    _;\n  }\n\n  modifier onlyValidTicks(int24 bottomTick, int24 topTick) {\n    require(topTick < TickMath.MAX_TICK + 1, 'TUM');\n    require(topTick > bottomTick, 'TLU');\n    require(bottomTick > TickMath.MIN_TICK - 1, 'TLM');\n    _;\n  }\n\n  constructor() PoolImmutables(msg.sender) {\n    globalState.fee = Constants.BASE_FEE;\n  }\n\n  function balanceToken0() private view returns (uint256) {\n    return IERC20Minimal(token0).balanceOf(address(this));\n  }\n\n  function balanceToken1() private view returns (uint256) {\n    return IERC20Minimal(token1).balanceOf(address(this));\n  }\n\n  /// @inheritdoc IAlgebraPoolState\n  function timepoints(uint256 index)\n    external\n    view\n    override\n    returns (\n      bool initialized,\n      uint32 blockTimestamp,\n      int56 tickCumulative,\n      uint160 secondsPerLiquidityCumulative,\n      uint88 volatilityCumulative,\n      int24 averageTick,\n      uint144 volumePerLiquidityCumulative\n    )\n  {\n    return IDataStorageOperator(dataStorageOperator).timepoints(index);\n  }\n\n  struct Cumulatives {\n    int56 tickCumulative;\n    uint160 outerSecondPerLiquidity;\n    uint32 outerSecondsSpent;\n  }\n\n  /// @inheritdoc IAlgebraPoolDerivedState\n  function getInnerCumulatives(int24 bottomTick, int24 topTick)\n    external\n    view\n    override\n    onlyValidTicks(bottomTick, topTick)\n    returns (\n      int56 innerTickCumulative,\n      uint160 innerSecondsSpentPerLiquidity,\n      uint32 innerSecondsSpent\n    )\n  {\n    Cumulatives memory lower;\n    {\n      TickManager.Tick storage _lower = ticks[bottomTick];\n      (lower.tickCumulative, lower.outerSecondPerLiquidity, lower.outerSecondsSpent) = (\n        _lower.outerTickCumulative,\n        _lower.outerSecondsPerLiquidity,\n        _lower.outerSecondsSpent\n      );\n      require(_lower.initialized);\n    }\n\n    Cumulatives memory upper;\n    {\n      TickManager.Tick storage _upper = ticks[topTick];\n      (upper.tickCumulative, upper.outerSecondPerLiquidity, upper.outerSecondsSpent) = (\n        _upper.outerTickCumulative,\n        _upper.outerSecondsPerLiquidity,\n        _upper.outerSecondsSpent\n      );\n\n      require(_upper.initialized);\n    }\n\n    (int24 currentTick, uint16 currentTimepointIndex) = (globalState.tick, globalState.timepointIndex);\n\n    if (currentTick < bottomTick) {\n      return (\n        lower.tickCumulative - upper.tickCumulative,\n        lower.outerSecondPerLiquidity - upper.outerSecondPerLiquidity,\n        lower.outerSecondsSpent - upper.outerSecondsSpent\n      );\n    }\n\n    if (currentTick < topTick) {\n      uint32 globalTime = _blockTimestamp();\n      (int56 globalTickCumulative, uint160 globalSecondsPerLiquidityCumulative, , ) = _getSingleTimepoint(\n        globalTime,\n        0,\n        currentTick,\n        currentTimepointIndex,\n        liquidity\n      );\n      return (\n        globalTickCumulative - lower.tickCumulative - upper.tickCumulative,\n        globalSecondsPerLiquidityCumulative - lower.outerSecondPerLiquidity - upper.outerSecondPerLiquidity,\n        globalTime - lower.outerSecondsSpent - upper.outerSecondsSpent\n      );\n    }\n\n    return (\n      upper.tickCumulative - lower.tickCumulative,\n      upper.outerSecondPerLiquidity - lower.outerSecondPerLiquidity,\n      upper.outerSecondsSpent - lower.outerSecondsSpent\n    );\n  }\n\n  /// @inheritdoc IAlgebraPoolDerivedState\n  function getTimepoints(uint32[] calldata secondsAgos)\n    external\n    view\n    override\n    returns (\n      int56[] memory tickCumulatives,\n      uint160[] memory secondsPerLiquidityCumulatives,\n      uint112[] memory volatilityCumulatives,\n      uint256[] memory volumePerAvgLiquiditys\n    )\n  {\n    return\n      IDataStorageOperator(dataStorageOperator).getTimepoints(\n        _blockTimestamp(),\n        secondsAgos,\n        globalState.tick,\n        globalState.timepointIndex,\n        liquidity\n      );\n  }\n\n  /// @inheritdoc IAlgebraPoolActions\n  function initialize(uint160 initialPrice) external override {\n    require(globalState.price == 0, 'AI');\n    // getTickAtSqrtRatio checks validity of initialPrice inside\n    int24 tick = TickMath.getTickAtSqrtRatio(initialPrice);\n\n    uint32 timestamp = _blockTimestamp();\n    IDataStorageOperator(dataStorageOperator).initialize(timestamp, tick);\n\n    globalState.price = initialPrice;\n    globalState.unlocked = true;\n    globalState.tick = tick;\n\n    emit Initialize(initialPrice, tick);\n  }\n\n  /**\n   * @notice Increases amounts of tokens owed to owner of the position\n   * @param _position The position object to operate with\n   * @param liquidityDelta The amount on which to increase\\decrease the liquidity\n   * @param innerFeeGrowth0Token Total fee token0 fee growth per 1/liquidity between position's lower and upper ticks\n   * @param innerFeeGrowth1Token Total fee token1 fee growth per 1/liquidity between position's lower and upper ticks\n   */\n  function _recalculatePosition(\n    Position storage _position,\n    int128 liquidityDelta,\n    uint256 innerFeeGrowth0Token,\n    uint256 innerFeeGrowth1Token\n  ) internal {\n    (uint128 currentLiquidity, uint32 lastLiquidityAddTimestamp) = (_position.liquidity, _position.lastLiquidityAddTimestamp);\n\n    if (liquidityDelta == 0) {\n      require(currentLiquidity > 0, 'NP'); // Do not recalculate the empty ranges\n    } else {\n      if (liquidityDelta < 0) {\n        uint32 _liquidityCooldown = liquidityCooldown;\n        if (_liquidityCooldown > 0) {\n          require((_blockTimestamp() - lastLiquidityAddTimestamp) >= _liquidityCooldown);\n        }\n      }\n\n      // change position liquidity\n      uint128 liquidityNext = LiquidityMath.addDelta(currentLiquidity, liquidityDelta);\n      (_position.liquidity, _position.lastLiquidityAddTimestamp) = (\n        liquidityNext,\n        liquidityNext > 0 ? (liquidityDelta > 0 ? _blockTimestamp() : lastLiquidityAddTimestamp) : 0\n      );\n    }\n\n    // update the position\n    uint256 _innerFeeGrowth0Token = _position.innerFeeGrowth0Token;\n    uint256 _innerFeeGrowth1Token = _position.innerFeeGrowth1Token;\n    uint128 fees0;\n    if (innerFeeGrowth0Token != _innerFeeGrowth0Token) {\n      _position.innerFeeGrowth0Token = innerFeeGrowth0Token;\n      fees0 = uint128(FullMath.mulDiv(innerFeeGrowth0Token - _innerFeeGrowth0Token, currentLiquidity, Constants.Q128));\n    }\n    uint128 fees1;\n    if (innerFeeGrowth1Token != _innerFeeGrowth1Token) {\n      _position.innerFeeGrowth1Token = innerFeeGrowth1Token;\n      fees1 = uint128(FullMath.mulDiv(innerFeeGrowth1Token - _innerFeeGrowth1Token, currentLiquidity, Constants.Q128));\n    }\n\n    // To avoid overflow owner has to collect fee before it\n    if (fees0 | fees1 != 0) {\n      _position.fees0 += fees0;\n      _position.fees1 += fees1;\n    }\n  }\n\n  struct UpdatePositionCache {\n    uint160 price; // The square root of the current price in Q64.96 format\n    int24 tick; // The current tick\n    uint16 timepointIndex; // The index of the last written timepoint\n  }\n\n  /**\n   * @dev Updates position's ticks and its fees\n   * @return position The Position object to operate with\n   * @return amount0 The amount of token0 the caller needs to send, negative if the pool needs to send it\n   * @return amount1 The amount of token1 the caller needs to send, negative if the pool needs to send it\n   */\n  function _updatePositionTicksAndFees(\n    address owner,\n    int24 bottomTick,\n    int24 topTick,\n    int128 liquidityDelta\n  )\n    private\n    returns (\n      Position storage position,\n      int256 amount0,\n      int256 amount1\n    )\n  {\n    UpdatePositionCache memory cache = UpdatePositionCache(globalState.price, globalState.tick, globalState.timepointIndex);\n\n    position = getOrCreatePosition(owner, bottomTick, topTick);\n\n    (uint256 _totalFeeGrowth0Token, uint256 _totalFeeGrowth1Token) = (totalFeeGrowth0Token, totalFeeGrowth1Token);\n\n    bool toggledBottom;\n    bool toggledTop;\n    if (liquidityDelta != 0) {\n      uint32 time = _blockTimestamp();\n      (int56 tickCumulative, uint160 secondsPerLiquidityCumulative, , ) = _getSingleTimepoint(time, 0, cache.tick, cache.timepointIndex, liquidity);\n\n      if (\n        ticks.update(\n          bottomTick,\n          cache.tick,\n          liquidityDelta,\n          _totalFeeGrowth0Token,\n          _totalFeeGrowth1Token,\n          secondsPerLiquidityCumulative,\n          tickCumulative,\n          time,\n          false // isTopTick\n        )\n      ) {\n        toggledBottom = true;\n        tickTable.toggleTick(bottomTick);\n      }\n\n      if (\n        ticks.update(\n          topTick,\n          cache.tick,\n          liquidityDelta,\n          _totalFeeGrowth0Token,\n          _totalFeeGrowth1Token,\n          secondsPerLiquidityCumulative,\n          tickCumulative,\n          time,\n          true // isTopTick\n        )\n      ) {\n        toggledTop = true;\n        tickTable.toggleTick(topTick);\n      }\n    }\n\n    (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) = ticks.getInnerFeeGrowth(\n      bottomTick,\n      topTick,\n      cache.tick,\n      _totalFeeGrowth0Token,\n      _totalFeeGrowth1Token\n    );\n\n    _recalculatePosition(position, liquidityDelta, feeGrowthInside0X128, feeGrowthInside1X128);\n\n    if (liquidityDelta != 0) {\n      // if liquidityDelta is negative and the tick was toggled, it means that it should not be initialized anymore, so we delete it\n      if (liquidityDelta < 0) {\n        if (toggledBottom) delete ticks[bottomTick];\n        if (toggledTop) delete ticks[topTick];\n      }\n\n      int128 globalLiquidityDelta;\n      (amount0, amount1, globalLiquidityDelta) = _getAmountsForLiquidity(bottomTick, topTick, liquidityDelta, cache.tick, cache.price);\n      if (globalLiquidityDelta != 0) {\n        uint128 liquidityBefore = liquidity;\n        uint16 newTimepointIndex = _writeTimepoint(cache.timepointIndex, _blockTimestamp(), cache.tick, liquidityBefore, volumePerLiquidityInBlock);\n        if (cache.timepointIndex != newTimepointIndex) {\n          globalState.fee = _getNewFee(_blockTimestamp(), cache.tick, newTimepointIndex, liquidityBefore);\n          globalState.timepointIndex = newTimepointIndex;\n          volumePerLiquidityInBlock = 0;\n        }\n        liquidity = LiquidityMath.addDelta(liquidityBefore, liquidityDelta);\n      }\n    }\n  }\n\n  function _getAmountsForLiquidity(\n    int24 bottomTick,\n    int24 topTick,\n    int128 liquidityDelta,\n    int24 currentTick,\n    uint160 currentPrice\n  )\n    private\n    pure\n    returns (\n      int256 amount0,\n      int256 amount1,\n      int128 globalLiquidityDelta\n    )\n  {\n    // If current tick is less than the provided bottom one then only the token0 has to be provided\n    if (currentTick < bottomTick) {\n      amount0 = TokenDeltaMath.getToken0Delta(TickMath.getSqrtRatioAtTick(bottomTick), TickMath.getSqrtRatioAtTick(topTick), liquidityDelta);\n    } else if (currentTick < topTick) {\n      amount0 = TokenDeltaMath.getToken0Delta(currentPrice, TickMath.getSqrtRatioAtTick(topTick), liquidityDelta);\n      amount1 = TokenDeltaMath.getToken1Delta(TickMath.getSqrtRatioAtTick(bottomTick), currentPrice, liquidityDelta);\n\n      globalLiquidityDelta = liquidityDelta;\n    }\n    // If current tick is greater than the provided top one then only the token1 has to be provided\n    else {\n      amount1 = TokenDeltaMath.getToken1Delta(TickMath.getSqrtRatioAtTick(bottomTick), TickMath.getSqrtRatioAtTick(topTick), liquidityDelta);\n    }\n  }\n\n  /**\n   * @notice This function fetches certain position object\n   * @param owner The address owing the position\n   * @param bottomTick The position's bottom tick\n   * @param topTick The position's top tick\n   * @return position The Position object\n   */\n  function getOrCreatePosition(\n    address owner,\n    int24 bottomTick,\n    int24 topTick\n  ) private view returns (Position storage) {\n    bytes32 key;\n    assembly {\n      key := or(shl(24, or(shl(24, owner), and(bottomTick, 0xFFFFFF))), and(topTick, 0xFFFFFF))\n    }\n    return positions[key];\n  }\n\n  /// @inheritdoc IAlgebraPoolActions\n  function mint(\n    address sender,\n    address recipient,\n    int24 bottomTick,\n    int24 topTick,\n    uint128 liquidityDesired,\n    bytes calldata data\n  )\n    external\n    override\n    lock\n    onlyValidTicks(bottomTick, topTick)\n    returns (\n      uint256 amount0,\n      uint256 amount1,\n      uint128 liquidityActual\n    )\n  {\n    require(liquidityDesired > 0, 'IL');\n    {\n      (int256 amount0Int, int256 amount1Int, ) = _getAmountsForLiquidity(\n        bottomTick,\n        topTick,\n        int256(liquidityDesired).toInt128(),\n        globalState.tick,\n        globalState.price\n      );\n\n      amount0 = uint256(amount0Int);\n      amount1 = uint256(amount1Int);\n    }\n\n    uint256 receivedAmount0;\n    uint256 receivedAmount1;\n    {\n      if (amount0 > 0) receivedAmount0 = balanceToken0();\n      if (amount1 > 0) receivedAmount1 = balanceToken1();\n      IAlgebraMintCallback(msg.sender).algebraMintCallback(amount0, amount1, data);\n      if (amount0 > 0) require((receivedAmount0 = balanceToken0() - receivedAmount0) > 0, 'IIAM');\n      if (amount1 > 0) require((receivedAmount1 = balanceToken1() - receivedAmount1) > 0, 'IIAM');\n    }\n\n    liquidityActual = liquidityDesired;\n    if (receivedAmount0 < amount0) {\n      liquidityActual = uint128(FullMath.mulDiv(uint256(liquidityActual), receivedAmount0, amount0));\n    }\n    if (receivedAmount1 < amount1) {\n      uint128 liquidityForRA1 = uint128(FullMath.mulDiv(uint256(liquidityActual), receivedAmount1, amount1));\n      if (liquidityForRA1 < liquidityActual) {\n        liquidityActual = liquidityForRA1;\n      }\n    }\n\n    require(liquidityActual > 0, 'IIL2');\n\n    {\n      (, int256 amount0Int, int256 amount1Int) = _updatePositionTicksAndFees(recipient, bottomTick, topTick, int256(liquidityActual).toInt128());\n\n      require((amount0 = uint256(amount0Int)) <= receivedAmount0, 'IIAM2');\n      require((amount1 = uint256(amount1Int)) <= receivedAmount1, 'IIAM2');\n    }\n\n    if (receivedAmount0 > amount0) {\n      TransferHelper.safeTransfer(token0, sender, receivedAmount0 - amount0);\n    }\n    if (receivedAmount1 > amount1) {\n      TransferHelper.safeTransfer(token1, sender, receivedAmount1 - amount1);\n    }\n    emit Mint(msg.sender, recipient, bottomTick, topTick, liquidityActual, amount0, amount1);\n  }\n\n  /// @inheritdoc IAlgebraPoolActions\n  function collect(\n    address recipient,\n    int24 bottomTick,\n    int24 topTick,\n    uint128 amount0Requested,\n    uint128 amount1Requested\n  ) external override lock returns (uint128 amount0, uint128 amount1) {\n    Position storage position = getOrCreatePosition(msg.sender, bottomTick, topTick);\n    (uint128 positionFees0, uint128 positionFees1) = (position.fees0, position.fees1);\n\n    amount0 = amount0Requested > positionFees0 ? positionFees0 : amount0Requested;\n    amount1 = amount1Requested > positionFees1 ? positionFees1 : amount1Requested;\n\n    if (amount0 | amount1 != 0) {\n      position.fees0 = positionFees0 - amount0;\n      position.fees1 = positionFees1 - amount1;\n\n      if (amount0 > 0) TransferHelper.safeTransfer(token0, recipient, amount0);\n      if (amount1 > 0) TransferHelper.safeTransfer(token1, recipient, amount1);\n    }\n\n    emit Collect(msg.sender, recipient, bottomTick, topTick, amount0, amount1);\n  }\n\n  /// @inheritdoc IAlgebraPoolActions\n  function burn(\n    int24 bottomTick,\n    int24 topTick,\n    uint128 amount\n  ) external override lock onlyValidTicks(bottomTick, topTick) returns (uint256 amount0, uint256 amount1) {\n    (Position storage position, int256 amount0Int, int256 amount1Int) = _updatePositionTicksAndFees(\n      msg.sender,\n      bottomTick,\n      topTick,\n      -int256(amount).toInt128()\n    );\n\n    amount0 = uint256(-amount0Int);\n    amount1 = uint256(-amount1Int);\n\n    if (amount0 | amount1 != 0) {\n      (position.fees0, position.fees1) = (position.fees0.add128(uint128(amount0)), position.fees1.add128(uint128(amount1)));\n    }\n\n    emit Burn(msg.sender, bottomTick, topTick, amount, amount0, amount1);\n  }\n\n  /// @dev Returns new fee according combination of sigmoids\n  function _getNewFee(\n    uint32 _time,\n    int24 _tick,\n    uint16 _index,\n    uint128 _liquidity\n  ) private returns (uint16 newFee) {\n    newFee = IDataStorageOperator(dataStorageOperator).getFee(_time, _tick, _index, _liquidity);\n    emit Fee(newFee);\n  }\n\n  function _payCommunityFee(address token, uint256 amount) private {\n    address vault = IAlgebraFactory(factory).vaultAddress();\n    TransferHelper.safeTransfer(token, vault, amount);\n  }\n\n  function _writeTimepoint(\n    uint16 timepointIndex,\n    uint32 blockTimestamp,\n    int24 tick,\n    uint128 liquidity,\n    uint128 volumePerLiquidityInBlock\n  ) private returns (uint16 newTimepointIndex) {\n    return IDataStorageOperator(dataStorageOperator).write(timepointIndex, blockTimestamp, tick, liquidity, volumePerLiquidityInBlock);\n  }\n\n  function _getSingleTimepoint(\n    uint32 blockTimestamp,\n    uint32 secondsAgo,\n    int24 startTick,\n    uint16 timepointIndex,\n    uint128 liquidityStart\n  )\n    private\n    view\n    returns (\n      int56 tickCumulative,\n      uint160 secondsPerLiquidityCumulative,\n      uint112 volatilityCumulative,\n      uint256 volumePerAvgLiquidity\n    )\n  {\n    return IDataStorageOperator(dataStorageOperator).getSingleTimepoint(blockTimestamp, secondsAgo, startTick, timepointIndex, liquidityStart);\n  }\n\n  function _swapCallback(\n    int256 amount0,\n    int256 amount1,\n    bytes calldata data\n  ) private {\n    IAlgebraSwapCallback(msg.sender).algebraSwapCallback(amount0, amount1, data);\n  }\n\n  /// @inheritdoc IAlgebraPoolActions\n  function swap(\n    address recipient,\n    bool zeroToOne,\n    int256 amountRequired,\n    uint160 limitSqrtPrice,\n    bytes calldata data\n  ) external override returns (int256 amount0, int256 amount1) {\n    uint160 currentPrice;\n    int24 currentTick;\n    uint128 currentLiquidity;\n    uint256 communityFee;\n    // function _calculateSwapAndLock locks globalState.unlocked and does not release\n    (amount0, amount1, currentPrice, currentTick, currentLiquidity, communityFee) = _calculateSwapAndLock(zeroToOne, amountRequired, limitSqrtPrice);\n\n    if (zeroToOne) {\n      if (amount1 < 0) TransferHelper.safeTransfer(token1, recipient, uint256(-amount1)); // transfer to recipient\n\n      uint256 balance0Before = balanceToken0();\n      _swapCallback(amount0, amount1, data); // callback to get tokens from the caller\n      require(balance0Before.add(uint256(amount0)) <= balanceToken0(), 'IIA');\n    } else {\n      if (amount0 < 0) TransferHelper.safeTransfer(token0, recipient, uint256(-amount0)); // transfer to recipient\n\n      uint256 balance1Before = balanceToken1();\n      _swapCallback(amount0, amount1, data); // callback to get tokens from the caller\n      require(balance1Before.add(uint256(amount1)) <= balanceToken1(), 'IIA');\n    }\n\n    if (communityFee > 0) {\n      _payCommunityFee(zeroToOne ? token0 : token1, communityFee);\n    }\n\n    emit Swap(msg.sender, recipient, amount0, amount1, currentPrice, currentLiquidity, currentTick);\n    globalState.unlocked = true; // release after lock in _calculateSwapAndLock\n  }\n\n  /// @inheritdoc IAlgebraPoolActions\n  function swapSupportingFeeOnInputTokens(\n    address sender,\n    address recipient,\n    bool zeroToOne,\n    int256 amountRequired,\n    uint160 limitSqrtPrice,\n    bytes calldata data\n  ) external override returns (int256 amount0, int256 amount1) {\n    // Since the pool can get less tokens then sent, firstly we are getting tokens from the\n    // original caller of the transaction. And change the _amountRequired_\n    require(globalState.unlocked, 'LOK');\n    globalState.unlocked = false;\n    if (zeroToOne) {\n      uint256 balance0Before = balanceToken0();\n      _swapCallback(amountRequired, 0, data);\n      require((amountRequired = int256(balanceToken0().sub(balance0Before))) > 0, 'IIA');\n    } else {\n      uint256 balance1Before = balanceToken1();\n      _swapCallback(0, amountRequired, data);\n      require((amountRequired = int256(balanceToken1().sub(balance1Before))) > 0, 'IIA');\n    }\n    globalState.unlocked = true;\n\n    uint160 currentPrice;\n    int24 currentTick;\n    uint128 currentLiquidity;\n    uint256 communityFee;\n    // function _calculateSwapAndLock locks 'globalState.unlocked' and does not release\n    (amount0, amount1, currentPrice, currentTick, currentLiquidity, communityFee) = _calculateSwapAndLock(zeroToOne, amountRequired, limitSqrtPrice);\n\n    // only transfer to the recipient\n    if (zeroToOne) {\n      if (amount1 < 0) TransferHelper.safeTransfer(token1, recipient, uint256(-amount1));\n      // return the leftovers\n      if (amount0 < amountRequired) TransferHelper.safeTransfer(token0, sender, uint256(amountRequired.sub(amount0)));\n    } else {\n      if (amount0 < 0) TransferHelper.safeTransfer(token0, recipient, uint256(-amount0));\n      // return the leftovers\n      if (amount1 < amountRequired) TransferHelper.safeTransfer(token1, sender, uint256(amountRequired.sub(amount1)));\n    }\n\n    if (communityFee > 0) {\n      _payCommunityFee(zeroToOne ? token0 : token1, communityFee);\n    }\n\n    emit Swap(msg.sender, recipient, amount0, amount1, currentPrice, currentLiquidity, currentTick);\n    globalState.unlocked = true; // release after lock in _calculateSwapAndLock\n  }\n\n  struct SwapCalculationCache {\n    uint256 communityFee; // The community fee of the selling token, uint256 to minimize casts\n    uint128 volumePerLiquidityInBlock;\n    int56 tickCumulative; // The global tickCumulative at the moment\n    uint160 secondsPerLiquidityCumulative; // The global secondPerLiquidity at the moment\n    bool computedLatestTimepoint; //  if we have already fetched _tickCumulative_ and _secondPerLiquidity_ from the DataOperator\n    int256 amountRequiredInitial; // The initial value of the exact input\\output amount\n    int256 amountCalculated; // The additive amount of total output\\input calculated trough the swap\n    uint256 totalFeeGrowth; // The initial totalFeeGrowth + the fee growth during a swap\n    uint256 totalFeeGrowthB;\n    IAlgebraVirtualPool.Status incentiveStatus; // If there is an active incentive at the moment\n    bool exactInput; // Whether the exact input or output is specified\n    uint16 fee; // The current dynamic fee\n    int24 startTick; // The tick at the start of a swap\n    uint16 timepointIndex; // The index of last written timepoint\n  }\n\n  struct PriceMovementCache {\n    uint160 stepSqrtPrice; // The Q64.96 sqrt of the price at the start of the step\n    int24 nextTick; // The tick till the current step goes\n    bool initialized; // True if the _nextTick is initialized\n    uint160 nextTickPrice; // The Q64.96 sqrt of the price calculated from the _nextTick\n    uint256 input; // The additive amount of tokens that have been provided\n    uint256 output; // The additive amount of token that have been withdrawn\n    uint256 feeAmount; // The total amount of fee earned within a current step\n  }\n\n  /// @notice For gas optimization, locks 'globalState.unlocked' and does not release.\n  function _calculateSwapAndLock(\n    bool zeroToOne,\n    int256 amountRequired,\n    uint160 limitSqrtPrice\n  )\n    private\n    returns (\n      int256 amount0,\n      int256 amount1,\n      uint160 currentPrice,\n      int24 currentTick,\n      uint128 currentLiquidity,\n      uint256 communityFeeAmount\n    )\n  {\n    uint32 blockTimestamp;\n    SwapCalculationCache memory cache;\n    {\n      // load from one storage slot\n      currentPrice = globalState.price;\n      currentTick = globalState.tick;\n      cache.fee = globalState.fee;\n      cache.timepointIndex = globalState.timepointIndex;\n      uint256 _communityFeeToken0 = globalState.communityFeeToken0;\n      uint256 _communityFeeToken1 = globalState.communityFeeToken1;\n      bool unlocked = globalState.unlocked;\n\n      globalState.unlocked = false; // lock will not be released in this function\n      require(unlocked, 'LOK');\n\n      require(amountRequired != 0, 'AS');\n      (cache.amountRequiredInitial, cache.exactInput) = (amountRequired, amountRequired > 0);\n\n      (currentLiquidity, cache.volumePerLiquidityInBlock) = (liquidity, volumePerLiquidityInBlock);\n\n      if (zeroToOne) {\n        require(limitSqrtPrice < currentPrice && limitSqrtPrice > TickMath.MIN_SQRT_RATIO, 'SPL');\n        cache.totalFeeGrowth = totalFeeGrowth0Token;\n        cache.communityFee = _communityFeeToken0;\n      } else {\n        require(limitSqrtPrice > currentPrice && limitSqrtPrice < TickMath.MAX_SQRT_RATIO, 'SPL');\n        cache.totalFeeGrowth = totalFeeGrowth1Token;\n        cache.communityFee = _communityFeeToken1;\n      }\n\n      cache.startTick = currentTick;\n\n      blockTimestamp = _blockTimestamp();\n\n      if (activeIncentive != address(0)) {\n        IAlgebraVirtualPool.Status _status = IAlgebraVirtualPool(activeIncentive).increaseCumulative(blockTimestamp);\n        if (_status == IAlgebraVirtualPool.Status.NOT_EXIST) {\n          activeIncentive = address(0);\n        } else if (_status == IAlgebraVirtualPool.Status.ACTIVE) {\n          cache.incentiveStatus = IAlgebraVirtualPool.Status.ACTIVE;\n        } else if (_status == IAlgebraVirtualPool.Status.NOT_STARTED) {\n          cache.incentiveStatus = IAlgebraVirtualPool.Status.NOT_STARTED;\n        }\n      }\n\n      uint16 newTimepointIndex = _writeTimepoint(\n        cache.timepointIndex,\n        blockTimestamp,\n        cache.startTick,\n        currentLiquidity,\n        cache.volumePerLiquidityInBlock\n      );\n\n      // new timepoint appears only for first swap in block\n      if (newTimepointIndex != cache.timepointIndex) {\n        cache.timepointIndex = newTimepointIndex;\n        cache.volumePerLiquidityInBlock = 0;\n        cache.fee = _getNewFee(blockTimestamp, currentTick, newTimepointIndex, currentLiquidity);\n      }\n    }\n\n    PriceMovementCache memory step;\n    // swap until there is remaining input or output tokens or we reach the price limit\n    while (true) {\n      step.stepSqrtPrice = currentPrice;\n\n      (step.nextTick, step.initialized) = tickTable.nextTickInTheSameRow(currentTick, zeroToOne);\n\n      step.nextTickPrice = TickMath.getSqrtRatioAtTick(step.nextTick);\n\n      // calculate the amounts needed to move the price to the next target if it is possible or as much as possible\n      (currentPrice, step.input, step.output, step.feeAmount) = PriceMovementMath.movePriceTowardsTarget(\n        zeroToOne,\n        currentPrice,\n        (zeroToOne == (step.nextTickPrice < limitSqrtPrice)) // move"
    }
  ]
}