{
  "Title": "H-10: CompoundProvider's balanceUnderlying and calcShares outputs are scaled incorrectly",
  "Content": "# Issue H-10: CompoundProvider's balanceUnderlying and calcShares outputs are scaled incorrectly \n\nSource: https://github.com/sherlock-audit/2023-01-derby-judging/issues/202 \n\n## Found by \nJeiwan, hyh\n\n## Summary\n\nbalanceUnderlying() returns values scaled with CToken decimals instead of the underlying decimals.\n\ncalcShares() also incorrectly scales its output, which have underlying decimals instead of the CToken decimals.\n\n## Vulnerability Detail\n\nUnderlying reason is exchangeRate() output is similarly and incorrectly processed in both functions. This results in wrong decimals of the both return values.\n\nCToken and underlying decimals can differ, for example cDAI has 8 decimals, while DAI has 18.\n\n## Impact\n\nAmount of the underlying held by Compound pool and amount of shares needed are misstated by magnitudes, which can lead to protocol-wide losses.\n\n## Code Snippet\n\nbalanceUnderlying() cancels out exchangeRate() decimals with dividing by `10^(18 - 8 + Underlying Token Decimals)`, which results in CToken decimals:\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/CompoundProvider.sol#L86-L100\n\n```solidity\n  /// @notice Get balance from address in underlying token\n  /// @param _address Address to request balance from, most likely a Vault\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return balance in underlying token\n  function balanceUnderlying(\n    address _address,\n    address _cToken\n  ) public view override returns (uint256) {\n    uint256 balanceShares = balance(_address, _cToken);\n    // The returned exchange rate from comp is scaled by 1 * 10^(18 - 8 + Underlying Token Decimals).\n    uint256 price = exchangeRate(_cToken);\n    uint256 decimals = IERC20Metadata(ICToken(_cToken).underlying()).decimals();\n\n    return (balanceShares * price) / 10 ** (10 + decimals);\n  }\n```\n\nAs balance() returns CToken balance and have CToken decimals:\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/CompoundProvider.sol#L113-L120\n\n```solidity\n  /// @notice Get balance of cToken from address\n  /// @param _address Address to request balance from\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return number of shares i.e LP tokens\n  function balance(address _address, address _cToken) public view override returns (uint256) {\n    uint256 _balanceShares = ICToken(_cToken).balanceOf(_address);\n    return _balanceShares;\n  }\n```\n\nWhile exchangeRate() is CToken's exchangeRateStored() with (18 - 8 + Underlying Token Decimals) decimals:\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/CompoundProvider.sol#L122-L129\n\n```solidity\n  /// @notice Exchange rate of underyling protocol token\n  /// @dev returned price from compound is scaled https://compound.finance/docs/ctokens#exchange-rate\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return price of LP token\n  function exchangeRate(address _cToken) public view override returns (uint256) {\n    uint256 _price = ICToken(_cToken).exchangeRateStored();\n    return _price;\n  }\n```\n\nhttps://docs.compound.finance/v2/ctokens/#exchange-rate\n\nSo balanceUnderlying() have CTokens decimals, which differ from underlying decimals, for example cUSDC have decimals of 8:\n\nhttps://etherscan.io/token/0x39aa39c021dfbae8fac545936693ac917d5e7563\n\nWhile USDC have decimals of 6:\n\nhttps://etherscan.io/token/0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\n\ncDAI has 8 decimals:\n\nhttps://etherscan.io/token/0x5d3a536e4d6dbd6114cc1ead35777bab948e3643\n\nDAI has 18:\n\nhttps://etherscan.io/token/0x6b175474e89094c44da98b954eedeac495271d0f\n\nbalanceUnderlying() is used in Vault rebalancing:\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Vault.sol#L178-L192\n\n```solidity\n  function rebalanceCheckProtocols(\n    uint256 _newTotalUnderlying\n  ) internal returns (uint256[] memory) {\n    uint256[] memory protocolToDeposit = new uint[](controller.latestProtocolId(vaultNumber));\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    for (uint i = 0; i < latestID; i++) {\n      bool isBlacklisted = controller.getProtocolBlacklist(vaultNumber, i);\n\n      storePriceAndRewards(_newTotalUnderlying, i);\n\n      if (isBlacklisted) continue;\n      setAllocation(i);\n\n      int256 amountToProtocol = calcAmountToProtocol(_newTotalUnderlying, i);\n      uint256 currentBalance = balanceUnderlying(i);\n```\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Vault.sol#L111-L118\n\n```solidity\n  function pullFunds(uint256 _value) internal {\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    for (uint i = 0; i < latestID; i++) {\n      if (currentAllocations[i] == 0) continue;\n\n      uint256 shortage = _value - vaultCurrency.balanceOf(address(this));\n      uint256 balanceProtocol = balanceUnderlying(i);\n\n```\n\nSame for calcShares(), where `shares` scale is corrected wrongly, it has underlying decimals instead of CToken decimals:\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/CompoundProvider.sol#L107-L111\n\n```solidity\n  function calcShares(uint256 _amount, address _cToken) external view override returns (uint256) {\n    uint256 decimals = IERC20Metadata(ICToken(_cToken).underlying()).decimals();\n    uint256 shares = (_amount * (10 ** (10 + decimals))) / exchangeRate(_cToken);\n    return shares;\n  }\n```\n\ncalcShares() is used in rebalancing as well:\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Vault.sol#L307-L315\n\n```solidity\n  function withdrawFromProtocol(uint256 _protocolNum, uint256 _amount) internal {\n    if (_amount <= 0) return;\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\n      vaultNumber,\n      _protocolNum\n    );\n\n    _amount = (_amount * protocol.uScale) / uScale;\n    uint256 shares = IProvider(protocol.provider).calcShares(_amount, protocol.LPToken);\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCompound exchange rate is specifically scaled so that `CToken_balance * price` has `18 + Underlying Token Decimals`, so it's enough to use `1e18`:\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/CompoundProvider.sol#L86-L100\n\n```diff\n  /// @notice Get balance from address in underlying token\n  /// @param _address Address to request balance from, most likely a Vault\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return balance in underlying token\n  function balanceUnderlying(\n    address _address,\n    address _cToken\n  ) public view override returns (uint256) {\n    uint256 balanceShares = balance(_address, _cToken);\n    // The returned exchange rate from comp is scaled by 1 * 10^(18 - 8 + Underlying Token Decimals).\n    uint256 price = exchangeRate(_cToken);\n    uint256 decimals = IERC20Metadata(ICToken(_cToken).underlying()).decimals();\n\n-   return (balanceShares * price) / 10 ** (10 + decimals);\n+   return (balanceShares * price) / 1e18;\n  }\n```\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/CompoundProvider.sol#L102-L111\n\n```diff\n  /// @notice Calculates how many shares are equal to the amount\n  /// @dev returned price from compound is scaled https://compound.finance/docs/ctokens#exchange-rate\n  /// @param _amount Amount in underyling token e.g USDC\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return number of shares i.e LP tokens\n  function calcShares(uint256 _amount, address _cToken) external view override returns (uint256) {\n-   uint256 decimals = IERC20Metadata(ICToken(_cToken).underlying()).decimals();\n-   uint256 shares = (_amount * (10 ** (10 + decimals))) / exchangeRate(_cToken);\n+   uint256 shares = _amount * 1e18 / exchangeRate(_cToken);\n    return shares;\n  }\n```\n\n\n\n## Discussion\n\n**sjoerdsommen**\n\nduplicate with #132 \n\n**dmitriia**\n\nEscalate for 10 USDC\nThe only valid duplicate of 202 looks to be 329, all the others are different issues.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> The only valid duplicate of 202 looks to be 329, all the others are different issues.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted\n\nThe only valid duplicate is #329 \n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> The only valid duplicate is #329 \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/13",
  "Code": [
    {
      "filename": "derby-yield-optimiser/contracts/Providers/CompoundProvider.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../Interfaces/ExternalInterfaces/ICToken.sol\";\nimport \"../Interfaces/ExternalInterfaces/IComptroller.sol\";\nimport \"../Interfaces/IProvider.sol\";\n\ncontract CompoundProvider is IProvider {\n  using SafeERC20 for IERC20;\n\n  IComptroller public comptroller;\n\n  constructor(address _comptroller) {\n    comptroller = IComptroller(_comptroller);\n  }\n\n  /// @notice Deposit the underlying asset in Compound\n  /// @dev Pulls underlying asset from Vault, deposit them in Compound, send cTokens back.\n  /// @param _amount Amount to deposit\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @param _uToken Address of underlying Token eg USDC\n  /// @return Tokens received and sent to vault\n  function deposit(\n    uint256 _amount,\n    address _cToken,\n    address _uToken\n  ) external override returns (uint256) {\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(address(this));\n\n    IERC20(_uToken).safeTransferFrom(msg.sender, address(this), _amount);\n    IERC20(_uToken).safeIncreaseAllowance(_cToken, _amount);\n\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(address(this));\n    require((balanceAfter - balanceBefore - _amount) == 0, \"Error Deposit: under/overflow\");\n\n    uint256 cTokenBefore = ICToken(_cToken).balanceOf(address(this));\n    require(ICToken(_cToken).mint(_amount) == 0, \"Error minting Compound\");\n    uint256 cTokenAfter = ICToken(_cToken).balanceOf(address(this));\n\n    uint cTokensReceived = cTokenAfter - cTokenBefore;\n    ICToken(_cToken).transfer(msg.sender, cTokensReceived);\n\n    return cTokensReceived;\n  }\n\n  /// @notice Withdraw the underlying asset from Compound\n  /// @dev Pulls cTokens from Vault, redeem them from Compound, send underlying back.\n  /// @param _amount Amount to withdraw\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @param _uToken Address of underlying Token eg USDC\n  /// @return Underlying tokens received and sent to vault e.g USDC\n  function withdraw(\n    uint256 _amount,\n    address _cToken,\n    address _uToken\n  ) external override returns (uint256) {\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(msg.sender);\n\n    uint256 balanceBeforeRedeem = IERC20(_uToken).balanceOf(address(this));\n\n    require(\n      ICToken(_cToken).transferFrom(msg.sender, address(this), _amount) == true,\n      \"Error: transferFrom\"\n    );\n    // Compound redeem: 0 on success, otherwise an Error code\n    require(ICToken(_cToken).redeem(_amount) == 0, \"Error: compound redeem\");\n\n    uint256 balanceAfterRedeem = IERC20(_uToken).balanceOf(address(this));\n    uint256 uTokensReceived = balanceAfterRedeem - balanceBeforeRedeem;\n\n    IERC20(_uToken).safeTransfer(msg.sender, uTokensReceived);\n\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(msg.sender);\n    require(\n      (balanceAfter - balanceBefore - uTokensReceived) == 0,\n      \"Error Withdraw: under/overflow\"\n    );\n\n    return uTokensReceived;\n  }\n\n  /// @notice Get balance from address in underlying token\n  /// @param _address Address to request balance from, most likely a Vault\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return balance in underlying token\n  function balanceUnderlying(\n    address _address,\n    address _cToken\n  ) public view override returns (uint256) {\n    uint256 balanceShares = balance(_address, _cToken);\n    // The returned exchange rate from comp is scaled by 1 * 10^(18 - 8 + Underlying Token Decimals).\n    uint256 price = exchangeRate(_cToken);\n    uint256 decimals = IERC20Metadata(ICToken(_cToken).underlying()).decimals();\n\n    return (balanceShares * price) / 10 ** (10 + decimals);\n  }\n\n  /// @notice Calculates how many shares are equal to the amount\n  /// @dev returned price from compound is scaled https://compound.finance/docs/ctokens#exchange-rate\n  /// @param _amount Amount in underyling token e.g USDC\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return number of shares i.e LP tokens\n  function calcShares(uint256 _amount, address _cToken) external view override returns (uint256) {\n    uint256 decimals = IERC20Metadata(ICToken(_cToken).underlying()).decimals();\n    uint256 shares = (_amount * (10 ** (10 + decimals))) / exchangeRate(_cToken);\n    return shares;\n  }\n\n  /// @notice Get balance of cToken from address\n  /// @param _address Address to request balance from\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return number of shares i.e LP tokens\n  function balance(address _address, address _cToken) public view override returns (uint256) {\n    uint256 _balanceShares = ICToken(_cToken).balanceOf(_address);\n    return _balanceShares;\n  }\n\n  /// @notice Exchange rate of underyling protocol token\n  /// @dev returned price from compound is scaled https://compound.finance/docs/ctokens#exchange-rate\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return price of LP token\n  function exchangeRate(address _cToken) public view override returns (uint256) {\n    uint256 _price = ICToken(_cToken).exchangeRateStored();\n    return _price;\n  }\n\n  /// @notice Claims/harvest COMP tokens from the Comptroller\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  function claim(address _cToken, address _claimer) external override returns (bool) {\n    address[] memory cTokens = new address[](1);\n    cTokens[0] = _cToken;\n    comptroller.claimComp(_claimer, cTokens);\n\n    return true;\n  }\n}"
    },
    {
      "filename": "derby-yield-optimiser/contracts/Providers/CompoundProvider.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../Interfaces/ExternalInterfaces/ICToken.sol\";\nimport \"../Interfaces/ExternalInterfaces/IComptroller.sol\";\nimport \"../Interfaces/IProvider.sol\";\n\ncontract CompoundProvider is IProvider {\n  using SafeERC20 for IERC20;\n\n  IComptroller public comptroller;\n\n  constructor(address _comptroller) {\n    comptroller = IComptroller(_comptroller);\n  }\n\n  /// @notice Deposit the underlying asset in Compound\n  /// @dev Pulls underlying asset from Vault, deposit them in Compound, send cTokens back.\n  /// @param _amount Amount to deposit\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @param _uToken Address of underlying Token eg USDC\n  /// @return Tokens received and sent to vault\n  function deposit(\n    uint256 _amount,\n    address _cToken,\n    address _uToken\n  ) external override returns (uint256) {\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(address(this));\n\n    IERC20(_uToken).safeTransferFrom(msg.sender, address(this), _amount);\n    IERC20(_uToken).safeIncreaseAllowance(_cToken, _amount);\n\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(address(this));\n    require((balanceAfter - balanceBefore - _amount) == 0, \"Error Deposit: under/overflow\");\n\n    uint256 cTokenBefore = ICToken(_cToken).balanceOf(address(this));\n    require(ICToken(_cToken).mint(_amount) == 0, \"Error minting Compound\");\n    uint256 cTokenAfter = ICToken(_cToken).balanceOf(address(this));\n\n    uint cTokensReceived = cTokenAfter - cTokenBefore;\n    ICToken(_cToken).transfer(msg.sender, cTokensReceived);\n\n    return cTokensReceived;\n  }\n\n  /// @notice Withdraw the underlying asset from Compound\n  /// @dev Pulls cTokens from Vault, redeem them from Compound, send underlying back.\n  /// @param _amount Amount to withdraw\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @param _uToken Address of underlying Token eg USDC\n  /// @return Underlying tokens received and sent to vault e.g USDC\n  function withdraw(\n    uint256 _amount,\n    address _cToken,\n    address _uToken\n  ) external override returns (uint256) {\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(msg.sender);\n\n    uint256 balanceBeforeRedeem = IERC20(_uToken).balanceOf(address(this));\n\n    require(\n      ICToken(_cToken).transferFrom(msg.sender, address(this), _amount) == true,\n      \"Error: transferFrom\"\n    );\n    // Compound redeem: 0 on success, otherwise an Error code\n    require(ICToken(_cToken).redeem(_amount) == 0, \"Error: compound redeem\");\n\n    uint256 balanceAfterRedeem = IERC20(_uToken).balanceOf(address(this));\n    uint256 uTokensReceived = balanceAfterRedeem - balanceBeforeRedeem;\n\n    IERC20(_uToken).safeTransfer(msg.sender, uTokensReceived);\n\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(msg.sender);\n    require(\n      (balanceAfter - balanceBefore - uTokensReceived) == 0,\n      \"Error Withdraw: under/overflow\"\n    );\n\n    return uTokensReceived;\n  }\n\n  /// @notice Get balance from address in underlying token\n  /// @param _address Address to request balance from, most likely a Vault\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return balance in underlying token\n  function balanceUnderlying(\n    address _address,\n    address _cToken\n  ) public view override returns (uint256) {\n    uint256 balanceShares = balance(_address, _cToken);\n    // The returned exchange rate from comp is scaled by 1 * 10^(18 - 8 + Underlying Token Decimals).\n    uint256 price = exchangeRate(_cToken);\n    uint256 decimals = IERC20Metadata(ICToken(_cToken).underlying()).decimals();\n\n    return (balanceShares * price) / 10 ** (10 + decimals);\n  }\n\n  /// @notice Calculates how many shares are equal to the amount\n  /// @dev returned price from compound is scaled https://compound.finance/docs/ctokens#exchange-rate\n  /// @param _amount Amount in underyling token e.g USDC\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return number of shares i.e LP tokens\n  function calcShares(uint256 _amount, address _cToken) external view override returns (uint256) {\n    uint256 decimals = IERC20Metadata(ICToken(_cToken).underlying()).decimals();\n    uint256 shares = (_amount * (10 ** (10 + decimals))) / exchangeRate(_cToken);\n    return shares;\n  }\n\n  /// @notice Get balance of cToken from address\n  /// @param _address Address to request balance from\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return number of shares i.e LP tokens\n  function balance(address _address, address _cToken) public view override returns (uint256) {\n    uint256 _balanceShares = ICToken(_cToken).balanceOf(_address);\n    return _balanceShares;\n  }\n\n  /// @notice Exchange rate of underyling protocol token\n  /// @dev returned price from compound is scaled https://compound.finance/docs/ctokens#exchange-rate\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return price of LP token\n  function exchangeRate(address _cToken) public view override returns (uint256) {\n    uint256 _price = ICToken(_cToken).exchangeRateStored();\n    return _price;\n  }\n\n  /// @notice Claims/harvest COMP tokens from the Comptroller\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  function claim(address _cToken, address _claimer) external override returns (bool) {\n    address[] memory cTokens = new address[](1);\n    cTokens[0] = _cToken;\n    comptroller.claimComp(_claimer, cTokens);\n\n    return true;\n  }\n}"
    },
    {
      "filename": "derby-yield-optimiser/contracts/Providers/CompoundProvider.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../Interfaces/ExternalInterfaces/ICToken.sol\";\nimport \"../Interfaces/ExternalInterfaces/IComptroller.sol\";\nimport \"../Interfaces/IProvider.sol\";\n\ncontract CompoundProvider is IProvider {\n  using SafeERC20 for IERC20;\n\n  IComptroller public comptroller;\n\n  constructor(address _comptroller) {\n    comptroller = IComptroller(_comptroller);\n  }\n\n  /// @notice Deposit the underlying asset in Compound\n  /// @dev Pulls underlying asset from Vault, deposit them in Compound, send cTokens back.\n  /// @param _amount Amount to deposit\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @param _uToken Address of underlying Token eg USDC\n  /// @return Tokens received and sent to vault\n  function deposit(\n    uint256 _amount,\n    address _cToken,\n    address _uToken\n  ) external override returns (uint256) {\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(address(this));\n\n    IERC20(_uToken).safeTransferFrom(msg.sender, address(this), _amount);\n    IERC20(_uToken).safeIncreaseAllowance(_cToken, _amount);\n\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(address(this));\n    require((balanceAfter - balanceBefore - _amount) == 0, \"Error Deposit: under/overflow\");\n\n    uint256 cTokenBefore = ICToken(_cToken).balanceOf(address(this));\n    require(ICToken(_cToken).mint(_amount) == 0, \"Error minting Compound\");\n    uint256 cTokenAfter = ICToken(_cToken).balanceOf(address(this));\n\n    uint cTokensReceived = cTokenAfter - cTokenBefore;\n    ICToken(_cToken).transfer(msg.sender, cTokensReceived);\n\n    return cTokensReceived;\n  }\n\n  /// @notice Withdraw the underlying asset from Compound\n  /// @dev Pulls cTokens from Vault, redeem them from Compound, send underlying back.\n  /// @param _amount Amount to withdraw\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @param _uToken Address of underlying Token eg USDC\n  /// @return Underlying tokens received and sent to vault e.g USDC\n  function withdraw(\n    uint256 _amount,\n    address _cToken,\n    address _uToken\n  ) external override returns (uint256) {\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(msg.sender);\n\n    uint256 balanceBeforeRedeem = IERC20(_uToken).balanceOf(address(this));\n\n    require(\n      ICToken(_cToken).transferFrom(msg.sender, address(this), _amount) == true,\n      \"Error: transferFrom\"\n    );\n    // Compound redeem: 0 on success, otherwise an Error code\n    require(ICToken(_cToken).redeem(_amount) == 0, \"Error: compound redeem\");\n\n    uint256 balanceAfterRedeem = IERC20(_uToken).balanceOf(address(this));\n    uint256 uTokensReceived = balanceAfterRedeem - balanceBeforeRedeem;\n\n    IERC20(_uToken).safeTransfer(msg.sender, uTokensReceived);\n\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(msg.sender);\n    require(\n      (balanceAfter - balanceBefore - uTokensReceived) == 0,\n      \"Error Withdraw: under/overflow\"\n    );\n\n    return uTokensReceived;\n  }\n\n  /// @notice Get balance from address in underlying token\n  /// @param _address Address to request balance from, most likely a Vault\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return balance in underlying token\n  function balanceUnderlying(\n    address _address,\n    address _cToken\n  ) public view override returns (uint256) {\n    uint256 balanceShares = balance(_address, _cToken);\n    // The returned exchange rate from comp is scaled by 1 * 10^(18 - 8 + Underlying Token Decimals).\n    uint256 price = exchangeRate(_cToken);\n    uint256 decimals = IERC20Metadata(ICToken(_cToken).underlying()).decimals();\n\n    return (balanceShares * price) / 10 ** (10 + decimals);\n  }\n\n  /// @notice Calculates how many shares are equal to the amount\n  /// @dev returned price from compound is scaled https://compound.finance/docs/ctokens#exchange-rate\n  /// @param _amount Amount in underyling token e.g USDC\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return number of shares i.e LP tokens\n  function calcShares(uint256 _amount, address _cToken) external view override returns (uint256) {\n    uint256 decimals = IERC20Metadata(ICToken(_cToken).underlying()).decimals();\n    uint256 shares = (_amount * (10 ** (10 + decimals))) / exchangeRate(_cToken);\n    return shares;\n  }\n\n  /// @notice Get balance of cToken from address\n  /// @param _address Address to request balance from\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return number of shares i.e LP tokens\n  function balance(address _address, address _cToken) public view override returns (uint256) {\n    uint256 _balanceShares = ICToken(_cToken).balanceOf(_address);\n    return _balanceShares;\n  }\n\n  /// @notice Exchange rate of underyling protocol token\n  /// @dev returned price from compound is scaled https://compound.finance/docs/ctokens#exchange-rate\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return price of LP token\n  function exchangeRate(address _cToken) public view override returns (uint256) {\n    uint256 _price = ICToken(_cToken).exchangeRateStored();\n    return _price;\n  }\n\n  /// @notice Claims/harvest COMP tokens from the Comptroller\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  function claim(address _cToken, address _claimer) external override returns (bool) {\n    address[] memory cTokens = new address[](1);\n    cTokens[0] = _cToken;\n    comptroller.claimComp(_claimer, cTokens);\n\n    return true;\n  }\n}"
    },
    {
      "filename": "derby-yield-optimiser/contracts/Vault.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"./Interfaces/IController.sol\";\nimport \"./Interfaces/IProvider.sol\";\n\nimport \"./VaultToken.sol\";\nimport \"./libraries/Swap.sol\";\n\ncontract Vault is ReentrancyGuard {\n  using SafeERC20 for IERC20;\n\n  // state 0 Rebalance done and ready for xController to rebalance again\n  // state 1 Allocation amount received and ready to send funds over to xController\n  // state 2 Allocation amount 0 received => will receive funds from xController\n  // state 3 Allocation amount sent or received and ready to rebalance the vault itself\n  enum State {\n    Idle,\n    PushedUnderlying,\n    SendingFundsXChain,\n    WaitingForFunds,\n    RebalanceVault,\n    SendRewardsPerToken\n  }\n\n  IERC20 internal vaultCurrency;\n  IController internal controller;\n  State public state;\n\n  bool public deltaAllocationsReceived;\n\n  address private dao;\n  address private guardian;\n  address public vaultCurrencyAddr;\n  address public xController;\n\n  uint256 public vaultNumber;\n  uint256 public liquidityPerc;\n  uint256 public performanceFee;\n  uint256 public rebalancingPeriod;\n  uint256 public uScale;\n  uint256 public minimumPull;\n  int256 public marginScale;\n\n  // UNIX timestamp\n  uint256 public rebalanceInterval;\n  uint256 public lastTimeStamp;\n\n  // total underlying of all protocols in vault, excluding vault balance\n  uint256 public savedTotalUnderlying;\n\n  // total amount of funds the vault reserved for users that made a withdrawalRequest\n  uint256 internal reservedFunds;\n\n  // total number of allocated Derby tokens currently\n  int256 public totalAllocatedTokens;\n  // delta of the total number of Derby tokens allocated on next rebalancing\n  int256 private deltaAllocatedTokens;\n\n  string internal stateError = \"Wrong state\";\n\n  // (protocolNumber => currentAllocation): current allocations over the protocols\n  mapping(uint256 => int256) internal currentAllocations;\n\n  // (protocolNumber => deltaAllocation): delta of the portfolio on next rebalancing\n  mapping(uint256 => int256) internal deltaAllocations;\n\n  // historical reward per protocol per token, formula: TVL * yield * perfFee / totalLockedTokens\n  // (rebalancingPeriod => protocolId => rewardPerLockedToken)\n  mapping(uint256 => mapping(uint256 => int256)) public rewardPerLockedToken;\n\n  // (protocolNumber => lastPrice): last price of underlying protocol vault\n  mapping(uint256 => uint256) public lastPrices;\n\n  modifier onlyDao() {\n    require(msg.sender == dao, \"Vault: only DAO\");\n    _;\n  }\n\n  modifier onlyGuardian() {\n    require(msg.sender == guardian, \"only Guardian\");\n    _;\n  }\n\n  constructor(\n    uint256 _vaultNumber,\n    address _dao,\n    address _controller,\n    address _vaultCurrency,\n    uint256 _uScale\n  ) {\n    controller = IController(_controller);\n    vaultCurrency = IERC20(_vaultCurrency);\n\n    vaultNumber = _vaultNumber;\n    dao = _dao;\n    uScale = _uScale;\n    lastTimeStamp = block.timestamp;\n    minimumPull = 1_000_000;\n  }\n\n  /// @notice Withdraw from protocols on shortage in Vault\n  /// @dev Keeps on withdrawing until the Vault balance > _value\n  /// @param _value The total value of vaultCurrency an user is trying to withdraw.\n  /// @param _value The (value - current underlying value of this vault) is withdrawn from the underlying protocols.\n  function pullFunds(uint256 _value) internal {\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    for (uint i = 0; i < latestID; i++) {\n      if (currentAllocations[i] == 0) continue;\n\n      uint256 shortage = _value - vaultCurrency.balanceOf(address(this));\n      uint256 balanceProtocol = balanceUnderlying(i);\n\n      uint256 amountToWithdraw = shortage > balanceProtocol ? balanceProtocol : shortage;\n      savedTotalUnderlying -= amountToWithdraw;\n\n      if (amountToWithdraw < minimumPull) break;\n      withdrawFromProtocol(i, amountToWithdraw);\n\n      if (_value <= vaultCurrency.balanceOf(address(this))) break;\n    }\n  }\n\n  /// @notice Step 7 trigger, end; Vaults rebalance\n  /// @notice Rebalances i.e deposit or withdraw from all underlying protocols\n  /// @dev amountToProtocol = totalAmount * currentAllocation / totalAllocatedTokens\n  /// @dev amountToDeposit = amountToProtocol - currentBalanceProtocol\n  /// @dev if amountToDeposit < 0 => withdraw\n  /// @dev Execute all withdrawals before deposits\n  function rebalance() external nonReentrant {\n    require(state == State.RebalanceVault, stateError);\n    require(deltaAllocationsReceived, \"!Delta allocations\");\n\n    rebalancingPeriod++;\n\n    claimTokens();\n    settleDeltaAllocation();\n\n    uint256 underlyingIncBalance = calcUnderlyingIncBalance();\n    uint256[] memory protocolToDeposit = rebalanceCheckProtocols(underlyingIncBalance);\n\n    executeDeposits(protocolToDeposit);\n    setTotalUnderlying();\n\n    if (reservedFunds > vaultCurrency.balanceOf(address(this))) pullFunds(reservedFunds);\n\n    state = State.SendRewardsPerToken;\n    deltaAllocationsReceived = false;\n  }\n\n  /// @notice Helper to return underlying balance plus totalUnderlying - liquidty for the vault\n  /// @return underlying totalUnderlying - liquidityVault\n  function calcUnderlyingIncBalance() internal view returns (uint256) {\n    uint256 totalUnderlyingInclVaultBalance = savedTotalUnderlying +\n      getVaultBalance() -\n      reservedFunds;\n    uint256 liquidityVault = (totalUnderlyingInclVaultBalance * liquidityPerc) / 100;\n    return totalUnderlyingInclVaultBalance - liquidityVault;\n  }\n\n  /// @notice Adds deltaAllocatedTokens to totalAllocatedTokens\n  function settleDeltaAllocation() internal {\n    totalAllocatedTokens += deltaAllocatedTokens;\n    deltaAllocatedTokens = 0;\n  }\n\n  /// @notice Rebalances i.e deposit or withdraw from all underlying protocols\n  /// @dev Loops over all protocols in ETF, calculate new currentAllocation based on deltaAllocation\n  /// @dev Also calculate the performance fee here. This is an amount, based on the current TVL (before the rebalance),\n  /// @dev the performanceFee and difference between the current exchangeRate and the exchangeRate of the last rebalance of the vault.\n  /// @param _newTotalUnderlying this will be the new total underlying: Totalunderlying = TotalUnderlyingInProtocols - BalanceVault\n  /// @return uint256[] with amounts to deposit in protocols, the index being the protocol number.\n  function rebalanceCheckProtocols(\n    uint256 _newTotalUnderlying\n  ) internal returns (uint256[] memory) {\n    uint256[] memory protocolToDeposit = new uint[](controller.latestProtocolId(vaultNumber));\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    for (uint i = 0; i < latestID; i++) {\n      bool isBlacklisted = controller.getProtocolBlacklist(vaultNumber, i);\n\n      storePriceAndRewards(_newTotalUnderlying, i);\n\n      if (isBlacklisted) continue;\n      setAllocation(i);\n\n      int256 amountToProtocol = calcAmountToProtocol(_newTotalUnderlying, i);\n      uint256 currentBalance = balanceUnderlying(i);\n\n      int256 amountToDeposit = amountToProtocol - int(currentBalance);\n      uint256 amountToWithdraw = amountToDeposit < 0 ? currentBalance - uint(amountToProtocol) : 0;\n\n      if (amountToDeposit > marginScale) protocolToDeposit[i] = uint256(amountToDeposit);\n      if (amountToWithdraw > uint(marginScale) || currentAllocations[i] == 0)\n        withdrawFromProtocol(i, amountToWithdraw);\n    }\n\n    return protocolToDeposit;\n  }\n\n  /// @notice Calculates the amount to deposit or withdraw to protocol during a vault rebalance\n  /// @param _totalUnderlying Totalunderlying = TotalUnderlyingInProtocols - BalanceVault\n  /// @param _protocol Protocol id number\n  /// @return amountToProtocol amount to deposit or withdraw to protocol\n  function calcAmountToProtocol(\n    uint256 _totalUnderlying,\n    uint256 _protocol\n  ) internal view returns (int256 amountToProtocol) {\n    if (totalAllocatedTokens == 0) amountToProtocol = 0;\n    else\n      amountToProtocol =\n        (int(_totalUnderlying) * currentAllocations[_protocol]) /\n        totalAllocatedTokens;\n  }\n\n  /// @notice Stores the historical price and the reward per rounded locked token, ignoring decimals.\n  /// @dev formula yield protocol i at time t: y(it) = (P(it) - P(it-1)) / P(it-1).\n  /// @dev formula rewardPerLockedToken for protocol i at time t: r(it) = y(it) * TVL(t) * perfFee(t) / totalLockedTokens(t)\n  /// @dev later, when the total rewards are calculated for a game player we multiply this (r(it)) by the locked tokens on protocol i at time t\n  /// @param _totalUnderlying Totalunderlying = TotalUnderlyingInProtocols - BalanceVault.\n  /// @param _protocolId Protocol id number.\n  function storePriceAndRewards(uint256 _totalUnderlying, uint256 _protocolId) internal {\n    uint256 currentPrice = price(_protocolId);\n    if (lastPrices[_protocolId] == 0) {\n      lastPrices[_protocolId] = currentPrice;\n      return;\n    }\n\n    int256 priceDiff = int256(currentPrice - lastPrices[_protocolId]);\n    int256 nominator = (int256(_totalUnderlying * performanceFee) * priceDiff);\n    int256 totalAllocatedTokensRounded = totalAllocatedTokens / 1E18;\n    int256 denominator = totalAllocatedTokensRounded * int256(lastPrices[_protocolId]) * 100; // * 100 cause perfFee is in percentages\n\n    if (totalAllocatedTokensRounded == 0) {\n      rewardPerLockedToken[rebalancingPeriod][_protocolId] = 0;\n    } else {\n      rewardPerLockedToken[rebalancingPeriod][_protocolId] = nominator / denominator;\n    }\n\n    lastPrices[_protocolId] = currentPrice;\n  }\n\n  /// @notice Creates array out of the rewardsPerLockedToken mapping to send to the game\n  /// @return rewards Array with rewardsPerLockedToken of all protocols in vault => index matches protocolId\n  function rewardsToArray() internal view returns (int256[] memory rewards) {\n    uint256 latestId = controller.latestProtocolId(vaultNumber);\n\n    rewards = new int[](latestId);\n    for (uint256 i = 0; i < latestId; i++) {\n      rewards[i] = rewardPerLockedToken[rebalancingPeriod][i];\n    }\n  }\n\n  /// @notice Helper function to set allocations\n  /// @param _i Protocol number linked to an underlying protocol e.g compound_usdc_01\n  function setAllocation(uint256 _i) internal {\n    currentAllocations[_i] += deltaAllocations[_i];\n    deltaAllocations[_i] = 0;\n    require(currentAllocations[_i] >= 0, \"Allocation underflow\");\n  }\n\n  /// @notice Helper function so the rebalance will execute all withdrawals first\n  /// @dev Executes and resets all deposits set in mapping(protocolToDeposit) by rebalanceETF\n  /// @param protocolToDeposit array with amounts to deposit in protocols, the index being the protocol number.\n  function executeDeposits(uint256[] memory protocolToDeposit) internal {\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    for (uint i = 0; i < latestID; i++) {\n      uint256 amount = protocolToDeposit[i];\n      if (amount == 0) continue;\n      depositInProtocol(i, amount);\n    }\n  }\n\n  /// @notice Deposit amount to underlying protocol\n  /// @dev Deposits VaultCurrency in Protocol e.g USDC\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\n  /// @param _amount in VaultCurrency to deposit\n  function depositInProtocol(uint256 _protocolNum, uint256 _amount) internal {\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\n      vaultNumber,\n      _protocolNum\n    );\n\n    if (getVaultBalance() < _amount) _amount = getVaultBalance();\n\n    if (protocol.underlying != address(vaultCurrency)) {\n      _amount = Swap.swapStableCoins(\n        Swap.SwapInOut(_amount, address(vaultCurrency), protocol.underlying),\n        uScale,\n        controller.underlyingUScale(protocol.underlying),\n        controller.getCurveParams(address(vaultCurrency), protocol.underlying)\n      );\n    }\n\n    IERC20(protocol.underlying).safeIncreaseAllowance(protocol.provider, _amount);\n    IProvider(protocol.provider).deposit(_amount, protocol.LPToken, protocol.underlying);\n  }\n\n  /// @notice Withdraw amount from underlying protocol\n  /// @dev shares = amount / PricePerShare\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\n  /// @param _amount in VaultCurrency to withdraw\n  function withdrawFromProtocol(uint256 _protocolNum, uint256 _amount) internal {\n    if (_amount <= 0) return;\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\n      vaultNumber,\n      _protocolNum\n    );\n\n    _amount = (_amount * protocol.uScale) / uScale;\n    uint256 shares = IProvider(protocol.provider).calcShares(_amount, protocol.LPToken);\n    uint256 balance = IProvider(protocol.provider).balance(address(this), protocol.LPToken);\n\n    if (shares == 0) return;\n    if (balance < shares) shares = balance;\n\n    IERC20(protocol.LPToken).safeIncreaseAllowance(protocol.provider, shares);\n    uint256 amountReceived = IProvider(protocol.provider).withdraw(\n      shares,\n      protocol.LPToken,\n      protocol.underlying\n    );\n\n    if (protocol.underlying != address(vaultCurrency)) {\n      _amount = Swap.swapStableCoins(\n        Swap.SwapInOut(amountReceived, protocol.underlying, address(vaultCurrency)),\n        controller.underlyingUScale(protocol.underlying),\n        uScale,\n        controller.getCurveParams(protocol.underlying, address(vaultCurrency))\n      );\n    }\n  }\n\n  /// @notice Set total balance in VaultCurrency in all underlying protocols\n  function setTotalUnderlying() public {\n    uint totalUnderlying;\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    for (uint i = 0; i < latestID; i++) {\n      if (currentAllocations[i] == 0) continue;\n      totalUnderlying += balanceUnderlying(i);\n    }\n    savedTotalUnderlying = totalUnderlying;\n  }\n\n  /// @notice Get balance in VaultCurrency in underlying protocol\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\n  /// @return Balance in VaultCurrency e.g USDC\n  function balanceUnderlying(uint256 _protocolNum) public view returns (uint256) {\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\n      vaultNumber,\n      _protocolNum\n    );\n    uint256 underlyingBalance = (IProvider(protocol.provider).balanceUnderlying(\n      address(this),\n      protocol.LPToken\n    ) * uScale) / protocol.uScale;\n    return underlyingBalance;\n  }\n\n  /// @notice Calculates how many shares are equal to the amount in vault currency\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\n  /// @param _amount Amount in underyling token e.g USDC\n  /// @return number of shares i.e LP tokens\n  function calcShares(uint256 _protocolNum, uint256 _amount) public view returns (uint256) {\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\n      vaultNumber,\n      _protocolNum\n    );\n    uint256 shares = IProvider(protocol.provider).calcShares(\n      (_amount * protocol.uScale) / uScale,\n      protocol.LPToken\n    );\n\n    return shares;\n  }\n\n  /// @notice Get price for underlying protocol\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\n  /// @return protocolPrice Price per lp token\n  function price(uint256 _protocolNum) public view returns (uint256) {\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo("
    }
  ]
}