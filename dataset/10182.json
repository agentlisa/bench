{
  "Title": "[H-05] `IdleYieldSource` doesn't use mantissa calculations",
  "Content": "_Submitted by tensors_\n\nBecause mantissa calculations are not used in this case to account for decimals, the arithmetic can zero out the number of shares or tokens that should be given.\n\nFor example, say I deposit 1 token, expecting 1 share in return. On [L95](https://github.com/sunnyRK/IdleYieldSource-PoolTogether/blob/6dcc419e881a4f0f205c07c58f4db87520b6046d/contracts/IdleYieldSource.sol#L95), if the `totalUnderlyingAssets` is increased to be larger than the number of total shares, then the division would output 0 and I wouldn't get any shares.\n\nRecommend  implementing mantissa calculations like in the contract for the AAVE  yield.\n\n**[PierrickGT (PoolTogether) confirmed and patched](https://github.com/code-423n4/2021-06-pooltogether-findings/issues/103#issuecomment-873072563):**\n > PR: https://github.com/pooltogether/idle-yield-source/pull/5\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2021-06-pooltogether",
  "Code": [
    {
      "filename": "contracts/IdleYieldSource.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\"; \nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./interfaces/pooltogether/IProtocolYieldSource.sol\";\nimport \"./interfaces/idle/IIdleToken.sol\";\nimport \"./interfaces/idle/IIdleTokenHelper.sol\";\nimport \"./access/AssetManager.sol\";\n\n/// @title An pooltogether yield source for Idle token\n/// @author Sunny Radadiya\ncontract IdleYieldSource is IProtocolYieldSource, Initializable, ReentrancyGuardUpgradeable, ERC20Upgradeable, AssetManager  {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    address public idleToken;\n    address public underlyingAsset;\n    uint256 public totalUnderlyingAssets;\n\n    /// @notice Emitted when the yield source is initialized\n    event IdleYieldSourceInitialized(address indexed idleToken);\n\n    /// @notice Emitted when asset tokens are redeemed from the yield source\n    event RedeemedToken(\n        address indexed from,\n        uint256 shares,\n        uint256 amount\n    );\n\n    /// @notice Emitted when asset tokens are supplied to the yield source\n    event SuppliedTokenTo(\n        address indexed from,\n        uint256 shares,\n        uint256 amount,\n        address indexed to\n    );\n\n    /// @notice Emitted when asset tokens are supplied to sponsor the yield source\n    event Sponsored(\n        address indexed from,\n        uint256 amount\n    );\n\n    /// @notice Emitted when ERC20 tokens other than yield source's idleToken are withdrawn from the yield source\n    event TransferredERC20(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        address indexed token\n    );\n\n    /// @notice Initializes the yield source with Idle Token\n    /// @param _idleToken Idle Token address\n    function initialize(\n        address _idleToken\n    ) public initializer {\n\n        __Ownable_init();\n\n        idleToken = _idleToken;\n        underlyingAsset = IIdleToken(idleToken).token();\n\n        IERC20Upgradeable(underlyingAsset).safeApprove(idleToken, type(uint256).max);\n        emit IdleYieldSourceInitialized(idleToken);\n    }\n\n    /// @notice Returns the ERC20 asset token used for deposits.\n    /// @return The ERC20 asset token\n    function depositToken() external view override returns (address) {\n        return (underlyingAsset);\n    }\n\n    /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.\n    /// @return The underlying balance of asset tokens\n    function balanceOfToken(address addr) external view override returns (uint256) {\n        return _sharesToToken(balanceOf(addr));\n    }\n\n    /// @notice Calculates the balance of Total idle Tokens Contract hasv\n    /// @return balance of Idle Tokens\n    function _totalShare() internal view returns(uint256) {\n        return IIdleToken(idleToken).balanceOf(address(this));\n    }\n\n    /// @notice Calculates the number of shares that should be mint or burned when a user deposit or withdraw\n    /// @param tokens Amount of tokens\n    /// return Number of shares\n    function _tokenToShares(uint256 tokens) internal view returns (uint256 shares) {\n        if(_totalShare() == 0) {\n            shares = tokens;\n        } else {\n            shares = (tokens * _totalShare())  / totalUnderlyingAssets;\n        }\n    }\n\n    /// @notice Calculates the number of tokens a user has in the yield source\n    /// @param shares Amount of shares\n    /// return Number of tokens\n    function _sharesToToken(uint256 shares) internal view returns (uint256 tokens) { \n        if(_totalShare() == 0) {\n            tokens = shares;\n        } else {\n            tokens = (shares * totalUnderlyingAssets) / _totalShare();\n        }\n    }\n\n    /// @notice Deposit asset tokens to Idle\n    /// @param mintAmount The amount of asset tokens to be deposited\n    /// @return 0 if successful \n    function _depositToIdle(uint256 mintAmount) internal returns (uint256) {\n        IERC20Upgradeable(underlyingAsset).safeTransferFrom(msg.sender, address(this), mintAmount);\n        uint256 mintedTokens = IIdleToken(idleToken).mintIdleToken(mintAmount, false, address(0));\n        return mintedTokens;\n    }\n\n    /// @notice Allows assets to be supplied on other user's behalf using the `to` param.\n    /// @param mintAmount The amount of `token()` to be supplied\n    /// @param to The user whose balance will receive the tokens\n    function supplyTokenTo(uint256 mintAmount, address to) public nonReentrant override {\n        uint256 mintedTokenShares = _depositToIdle(mintAmount);\n        _mint(to, mintedTokenShares);\n        totalUnderlyingAssets = totalUnderlyingAssets + mintAmount;\n        emit SuppliedTokenTo(msg.sender, mintedTokenShares, mintAmount, to);\n    }\n\n    /// @notice Redeems tokens from the yield source from the msg.sender, it burn yield bearing tokens and return token to the sender.\n    /// @param redeemAmount The amount of `token()` to withdraw.  Denominated in `token()` as above.\n    /// @return The actual amount of tokens that were redeemed.\n    function redeemToken(uint256 redeemAmount) public override nonReentrant returns (uint256) {\n        uint256 _idleShare = _tokenToShares(redeemAmount);\n        _burn(msg.sender, _idleShare);\n        totalUnderlyingAssets = totalUnderlyingAssets - redeemAmount;\n        uint256 redeemedUnderlyingAsset = IIdleToken(idleToken).redeemIdleToken(_idleShare);\n        IERC20Upgradeable(underlyingAsset).safeTransfer(msg.sender, redeemedUnderlyingAsset);\n        emit RedeemedToken(msg.sender, _idleShare, redeemAmount);\n        return redeemedUnderlyingAsset;\n    }\n\n    /// @notice Transfer ERC20 tokens other than the idleTokens held by this contract to the recipient address\n    /// @dev This function is only callable by the owner or asset manager\n    /// @param erc20Token The ERC20 token to transfer\n    /// @param to The recipient of the tokens\n    /// @param amount The amount of tokens to transfer\n    function transferERC20(address erc20Token, address to, uint256 amount) external override onlyOwnerOrAssetManager {\n        require(address(erc20Token) != address(idleToken), \"IdleYieldSource/idleDai-transfer-not-allowed\");\n        IERC20Upgradeable(erc20Token).safeTransfer(to, amount);\n        emit TransferredERC20(msg.sender, to, amount, erc20Token);\n    }\n\n    /// @notice Allows someone to deposit into the yield source without receiving any shares\n    /// @dev This allows anyone to distribute tokens among the share holders\n    /// @param amount The amount of tokens to deposit\n    function sponsor(uint256 amount) external override {\n        _depositToIdle(amount);\n        emit Sponsored(msg.sender, amount);\n    }\n}"
    }
  ]
}