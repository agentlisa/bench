{
  "Title": "[H03] Affiliate fees are not accumulated in multiple trading operations",
  "Content": "In Augur v2, market creators can set an [`affiliateFeeDivisor`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L45) value which corresponds to the proportion of market creator fees that will be assigned to the [market’s affiliate](https://www.augur.net/blog/augur-v2/#affiliate) when trading occurs.\n\n\nFor this purpose, the `Market` contract implements the function [`recordMarketCreatorFees`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L295), which can only be called by [“known fee senders”](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L296) and is in charge of [calculating](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L297-L302) the amount of fees to be assigned to the creator and the affiliate (if exists). As trading can occur multiple times in a market, this function is expected to be called multiple times with fees for creator and affiliates [accumulating](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L302) each time, and it should distribute the fees to the corresponding parties [only when the market is finalized](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L303).\n\n\nHowever, while the fees are [correctly accumulated](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L302) for market creators, [affiliates’ fees are instead overwritten](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L299) (*i.e.* they are assigned to the `affiliateFeesAttoCash` mapping while they should be added using `affiliateFeesAttoCash[_affiliateAddress] = affiliateFeesAttoCash[_affiliateAddress].add(_affiliateFees);` ). As a consequence, if more than one trading operation of shares occurs in a market involving the same affiliate address, the affiliate will receive less fees than expected once the market is finalized.\n\n\nConsider accumulating affiliate fees the same way market creators fees are currently accumulated. Furthermore, it is highly recommended to include unit tests that cover the described scenario, so as to make sure this issue is not reintroduced in future changes to the code base.\n\n\n***Update****: fixed in* *[`1b07fa4`](https://github.com/AugurProject/augur/commit/1b07fa4ee7c763d2c85230a4d3eaeaae0077f884#diff-8ed676c60e9fab2fdbd79f09555a59be).* *Affiliate fees are now properly incremented.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "packages/augur-core/source/contracts/reporting/Market.sol",
      "content": "pragma solidity 0.5.4;\n\nimport 'ROOT/reporting/IMarket.sol';\nimport 'ROOT/libraries/Initializable.sol';\nimport 'ROOT/libraries/Ownable.sol';\nimport 'ROOT/libraries/collections/Map.sol';\nimport 'ROOT/reporting/IUniverse.sol';\nimport 'ROOT/reporting/IReportingParticipant.sol';\nimport 'ROOT/reporting/IDisputeCrowdsourcer.sol';\nimport 'ROOT/reporting/IV2ReputationToken.sol';\nimport 'ROOT/factories/DisputeCrowdsourcerFactory.sol';\nimport 'ROOT/trading/ICash.sol';\nimport 'ROOT/trading/IShareToken.sol';\nimport 'ROOT/factories/ShareTokenFactory.sol';\nimport 'ROOT/factories/InitialReporterFactory.sol';\nimport 'ROOT/factories/MapFactory.sol';\nimport 'ROOT/libraries/math/SafeMathUint256.sol';\nimport 'ROOT/libraries/math/SafeMathInt256.sol';\nimport 'ROOT/reporting/Reporting.sol';\nimport 'ROOT/reporting/IInitialReporter.sol';\nimport 'ROOT/reporting/IAuction.sol';\n\n\ncontract Market is Initializable, Ownable, IMarket {\n    using SafeMathUint256 for uint256;\n    using SafeMathInt256 for int256;\n\n    // Constants\n    uint256 private constant MAX_FEE_PER_CASH_IN_ATTOCASH = 15 * 10**16; // 15%\n    uint256 private constant APPROVAL_AMOUNT = 2 ** 256 - 1;\n    address private constant NULL_ADDRESS = address(0);\n    uint256 private constant MIN_OUTCOMES = 3; // Includes INVALID\n    uint256 private constant MAX_OUTCOMES = 8;\n\n    // Contract Refs\n    IUniverse private universe;\n    IDisputeWindow private disputeWindow;\n    ICash private cash;\n    IAugur public augur;\n    MapFactory public mapFactory;\n\n    // Attributes\n    uint256 private numTicks;\n    uint256 private feeDivisor;\n    uint256 public affiliateFeeDivisor;\n    uint256 private endTime;\n    uint256 private numOutcomes;\n    bytes32 private winningPayoutDistributionHash;\n    uint256 private validityBondAttoCash;\n    uint256 private finalizationTime;\n    uint256 private repBond;\n    bool private disputePacingOn;\n    address private repBondOwner;\n    uint256 public marketCreatorFeesAttoCash;\n    IDisputeCrowdsourcer public preemptiveDisputeCrowdsourcer;\n\n    // Collections\n    IReportingParticipant[] public participants;\n    IMap public crowdsourcers;\n    IShareToken[] private shareTokens;\n    mapping (address => uint256) public affiliateFeesAttoCash;\n\n    function initialize(IAugur _augur, IUniverse _universe, uint256 _endTime, uint256 _feePerCashInAttoCash, uint256 _affiliateFeeDivisor, address _designatedReporterAddress, address _creator, uint256 _numOutcomes, uint256 _numTicks) public beforeInitialized returns (bool _success) {\n        endInitialization();\n        augur = _augur;\n        _numOutcomes += 1; // The INVALID outcome is always first\n        require(MIN_OUTCOMES <= _numOutcomes && _numOutcomes <= MAX_OUTCOMES);\n        require(_designatedReporterAddress != NULL_ADDRESS);\n        require((_numTicks >= _numOutcomes));\n        require(_feePerCashInAttoCash <= MAX_FEE_PER_CASH_IN_ATTOCASH);\n        require(_creator != NULL_ADDRESS);\n        uint256 _timestamp = augur.getTimestamp();\n        require(_timestamp < _endTime);\n        require(_endTime < _timestamp + Reporting.getMaximumMarketDuration());\n        universe = _universe;\n        require(!universe.isForking());\n        cash = ICash(augur.lookup(\"Cash\"));\n        owner = _creator;\n        repBondOwner = owner;\n        assessFees();\n        endTime = _endTime;\n        numOutcomes = _numOutcomes;\n        numTicks = _numTicks;\n        feeDivisor = _feePerCashInAttoCash == 0 ? 0 : 1 ether / _feePerCashInAttoCash;\n        affiliateFeeDivisor = _affiliateFeeDivisor;\n        InitialReporterFactory _initialReporterFactory = InitialReporterFactory(augur.lookup(\"InitialReporterFactory\"));\n        participants.push(_initialReporterFactory.createInitialReporter(augur, this, _designatedReporterAddress));\n        mapFactory = MapFactory(augur.lookup(\"MapFactory\"));\n        clearCrowdsourcers();\n        for (uint256 _outcome = 0; _outcome < numOutcomes; _outcome++) {\n            shareTokens.push(createShareToken(_outcome));\n        }\n        approveSpenders();\n        return true;\n    }\n\n    function assessFees() private returns (bool) {\n        repBond = universe.getOrCacheMarketRepBond();\n        require(getReputationToken().balanceOf(address(this)) >= repBond);\n        validityBondAttoCash = cash.balanceOf(address(this));\n        require(validityBondAttoCash >= universe.getOrCacheValidityBond());\n        return true;\n    }\n\n    function increaseValidityBond(uint256 _attoCASH) public returns (bool) {\n        cash.transferFrom(msg.sender, address(this), _attoCASH);\n        validityBondAttoCash = validityBondAttoCash.add(_attoCASH);\n        return true;\n    }\n\n    function createShareToken(uint256 _outcome) private returns (IShareToken) {\n        return ShareTokenFactory(augur.lookup(\"ShareTokenFactory\")).createShareToken(augur, this, _outcome);\n    }\n\n    // This will need to be called manually for each open market if a spender contract is updated\n    function approveSpenders() public returns (bool) {\n        bytes32[5] memory _names = [bytes32(\"CancelOrder\"), bytes32(\"CompleteSets\"), bytes32(\"FillOrder\"), bytes32(\"ClaimTradingProceeds\"), bytes32(\"Orders\")];\n        for (uint256 i = 0; i < _names.length; i++) {\n            require(cash.approve(augur.lookup(_names[i]), APPROVAL_AMOUNT));\n        }\n        for (uint256 j = 0; j < numOutcomes; j++) {\n            require(shareTokens[j].approve(augur.lookup(\"FillOrder\"), APPROVAL_AMOUNT));\n        }\n        return true;\n    }\n\n    function doInitialReport(uint256[] memory _payoutNumerators, string memory _description) public returns (bool) {\n        doInitialReportInternal(msg.sender, _payoutNumerators, _description);\n        return true;\n    }\n\n    function doInitialReportInternal(address _reporter, uint256[] memory _payoutNumerators, string memory _description) private returns (bool) {\n        require(!universe.isForking());\n        IInitialReporter _initialReporter = getInitialReporter();\n        uint256 _timestamp = augur.getTimestamp();\n        require(_timestamp > endTime);\n        uint256 _initialReportStake = distributeInitialReportingRep(_reporter, _initialReporter);\n        // The derive call will validate that an Invalid report is entirely paid out on the Invalid outcome\n        bytes32 _payoutDistributionHash = derivePayoutDistributionHash(_payoutNumerators);\n        disputeWindow = universe.getOrCreateNextDisputeWindow(true);\n        _initialReporter.report(_reporter, _payoutDistributionHash, _payoutNumerators, _initialReportStake);\n        augur.logInitialReportSubmitted(universe, _reporter, address(this), _initialReportStake, _initialReporter.designatedReporterShowed(), _payoutNumerators, _description);\n        return true;\n    }\n\n    function distributeInitialReportingRep(address _reporter, IInitialReporter _initialReporter) private returns (uint256) {\n        IV2ReputationToken _reputationToken = getReputationToken();\n        uint256 _initialReportStake = repBond;\n        // If the designated reporter showed up and is not also the rep bond owner return the rep bond to the bond owner. Otherwise it will be used as stake in the first report.\n        if (_reporter == _initialReporter.getDesignatedReporter() && _reporter != repBondOwner) {\n            require(_reputationToken.transfer(repBondOwner, _initialReportStake));\n            _reputationToken.trustedMarketTransfer(_reporter, address(_initialReporter), _initialReportStake);\n        } else {\n            require(_reputationToken.transfer(address(_initialReporter), _initialReportStake));\n        }\n        repBond = 0;\n        return _initialReportStake;\n    }\n\n    function contributeToTentative(uint256[] memory _payoutNumerators, uint256 _amount, string memory _description) public returns (bool) {\n        require(!disputePacingOn);\n        // The derive call will validate that an Invalid report is entirely paid out on the Invalid outcome\n        bytes32 _payoutDistributionHash = derivePayoutDistributionHash(_payoutNumerators);\n        require(_payoutDistributionHash == getWinningReportingParticipant().getPayoutDistributionHash());\n        internalContribute(msg.sender, _payoutDistributionHash, _payoutNumerators, _amount, true, _description);\n        return true;\n    }\n\n    function contribute(uint256[] memory _payoutNumerators, uint256 _amount, string memory _description) public returns (bool) {\n        // The derive call will validate that an Invalid report is entirely paid out on the Invalid outcome\n        bytes32 _payoutDistributionHash = derivePayoutDistributionHash(_payoutNumerators);\n        require(_payoutDistributionHash != getWinningReportingParticipant().getPayoutDistributionHash());\n        internalContribute(msg.sender, _payoutDistributionHash, _payoutNumerators, _amount, false, _description);\n        return true;\n    }\n\n    function internalContribute(address _contributor, bytes32 _payoutDistributionHash, uint256[] memory _payoutNumerators, uint256 _amount, bool _overload, string memory _description) internal returns (bool) {\n        if (disputePacingOn) {\n            require(disputeWindow.isActive());\n        } else {\n            require(!disputeWindow.isOver());\n        }\n        require(!universe.isForking());\n        IDisputeCrowdsourcer _crowdsourcer = getOrCreateDisputeCrowdsourcer(_payoutDistributionHash, _payoutNumerators, _overload);\n        uint256 _actualAmount = _crowdsourcer.contribute(_contributor, _amount, _overload);\n        if (!_overload) {\n            uint256 _amountRemainingToFill = _crowdsourcer.getRemainingToFill();\n            if (_amountRemainingToFill == 0) {\n                finishedCrowdsourcingDisputeBond(_crowdsourcer);\n            } else {\n                require(_amountRemainingToFill >= getInitialReporter().getSize());\n            }\n        }\n        augur.logDisputeCrowdsourcerContribution(universe, _contributor, address(this), address(_crowdsourcer), _actualAmount, _description);\n        return true;\n    }\n\n    function finishedCrowdsourcingDisputeBond(IDisputeCrowdsourcer _crowdsourcer) private returns (bool) {\n        correctLastParticipantSize();\n        participants.push(_crowdsourcer);\n        clearCrowdsourcers(); // disavow other crowdsourcers\n        uint256 _crowdsourcerSize = IDisputeCrowdsourcer(_crowdsourcer).getSize();\n        if (_crowdsourcerSize >= universe.getDisputeThresholdForFork()) {\n            universe.fork();\n        } else {\n            if (_crowdsourcerSize >= universe.getDisputeThresholdForDisputePacing()) {\n                disputePacingOn = true;\n            }\n            disputeWindow = universe.getOrCreateNextDisputeWindow(false);\n        }\n        augur.logDisputeCrowdsourcerCompleted(universe, address(this), address(_crowdsourcer));\n        if (preemptiveDisputeCrowdsourcer != IDisputeCrowdsourcer(0)) {\n            IDisputeCrowdsourcer _newCrowdsourcer = preemptiveDisputeCrowdsourcer;\n            preemptiveDisputeCrowdsourcer = IDisputeCrowdsourcer(0);\n            bytes32 _payoutDistributionHash = _newCrowdsourcer.getPayoutDistributionHash();\n            uint256 _correctSize = getParticipantStake().mul(2).sub(getStakeInOutcome(_payoutDistributionHash).mul(3));\n            _newCrowdsourcer.setSize(_correctSize);\n            if (_newCrowdsourcer.getStake() >= _correctSize) {\n                finishedCrowdsourcingDisputeBond(_newCrowdsourcer);\n            } else {\n                crowdsourcers.add(_payoutDistributionHash, address(_newCrowdsourcer));\n            }\n        }\n        return true;\n    }\n\n    function correctLastParticipantSize() private returns (bool) {\n        if (participants.length < 2) {\n            return true;\n        }\n        IDisputeCrowdsourcer(address(getWinningReportingParticipant())).correctSize();\n        return true;\n    }\n\n    function finalize() public returns (bool) {\n        require(winningPayoutDistributionHash == bytes32(0));\n        if (universe.getForkingMarket() == this) {\n            IUniverse _winningUniverse = universe.getWinningChildUniverse();\n            winningPayoutDistributionHash = _winningUniverse.getParentPayoutDistributionHash();\n        } else {\n            require(disputeWindow.isOver());\n            require(!universe.isForking());\n            winningPayoutDistributionHash = participants[participants.length-1].getPayoutDistributionHash();\n            // Make sure the dispute window for which we record finalization is the standard cadence window and not an initial dispute window\n            disputeWindow = universe.getOrCreatePreviousDisputeWindow(false);\n            disputeWindow.onMarketFinalized();\n            universe.decrementOpenInterestFromMarket(this);\n            redistributeLosingReputation();\n        }\n        distributeValidityBondAndMarketCreatorFees();\n        finalizationTime = augur.getTimestamp();\n        augur.logMarketFinalized(universe);\n        return true;\n    }\n\n    function redistributeLosingReputation() private returns (bool) {\n        // If no disputes occurred early exit\n        if (participants.length == 1) {\n            return true;\n        }\n\n        IReportingParticipant _reportingParticipant;\n\n        // Initial pass is to liquidate losers so we have sufficient REP to pay the winners. Participants is implicitly bounded by the floor of the initial report REP cost to be no more than 21\n        for (uint256 i = 0; i < participants.length; i++) {\n            _reportingParticipant = participants[i];\n            if (_reportingParticipant.getPayoutDistributionHash() != winningPayoutDistributionHash) {\n                _reportingParticipant.liquidateLosing();\n            }\n        }\n\n        IV2ReputationToken _reputationToken = getReputationToken();\n\n        // Now redistribute REP. Participants is implicitly bounded by the floor of the initial report REP cost to be no more than 21.\n        for (uint256 j = 0; j < participants.length; j++) {\n            _reportingParticipant = participants[j];\n            if (_reportingParticipant.getPayoutDistributionHash() == winningPayoutDistributionHash) {\n                require(_reputationToken.transfer(address(_reportingParticipant), _reportingParticipant.getSize().mul(2) / 5));\n            }\n        }\n\n        // We burn 20% of the REP to prevent griefing attacks which rely on getting back lost REP\n        _reputationToken.burnForMarket(_reputationToken.balanceOf(address(this)));\n        return true;\n    }\n\n    function getMarketCreatorSettlementFeeDivisor() public view returns (uint256) {\n        return feeDivisor;\n    }\n\n    function deriveMarketCreatorFeeAmount(uint256 _amount) public view returns (uint256) {\n        return feeDivisor == 0 ? 0 : _amount / feeDivisor;\n    }\n\n    function recordMarketCreatorFees(uint256 _marketCreatorFees, address _affiliateAddress) public returns (bool) {\n        require(augur.isKnownFeeSender(msg.sender));\n        if (_affiliateAddress != NULL_ADDRESS && affiliateFeeDivisor != 0) {\n            uint256 _affiliateFees = _marketCreatorFees / affiliateFeeDivisor;\n            affiliateFeesAttoCash[_affiliateAddress] = _affiliateFees;\n            _marketCreatorFees = _marketCreatorFees.sub(_affiliateFees);\n        }\n        marketCreatorFeesAttoCash = marketCreatorFeesAttoCash.add(_marketCreatorFees);\n        if (isFinalized()) {\n            distributeMarketCreatorFees(_affiliateAddress);\n        }\n    }\n\n    function distributeValidityBondAndMarketCreatorFees() private returns (bool) {\n        // If the market resolved to invalid the bond gets sent to the auction. Otherwise it gets returned to the market creator.\n        marketCreatorFeesAttoCash = validityBondAttoCash.add(marketCreatorFeesAttoCash);\n        return distributeMarketCreatorFees(NULL_ADDRESS);\n    }\n\n    function distributeMarketCreatorFees(address _affiliateAddress) private returns (bool) {\n        if (!isInvalid()) {\n            cash.transfer(owner, marketCreatorFeesAttoCash);\n            if (_affiliateAddress != NULL_ADDRESS) {\n                withdrawAffiliateFees(_affiliateAddress);\n            }\n        } else {\n            cash.transfer(address(universe.getOrCreateNextDisputeWindow(false)), marketCreatorFeesAttoCash);\n        }\n        marketCreatorFeesAttoCash = 0;\n        return true;\n    }\n\n    function withdrawAffiliateFees(address _affiliate) public returns (bool) {\n        uint256 _affiliateBalance = affiliateFeesAttoCash[_affiliate];\n        if (_affiliateBalance == 0) {\n            return true;\n        }\n        affiliateFeesAttoCash[_affiliate] = 0;\n        cash.transfer(_affiliate, _affiliateBalance);\n        return true;\n    }\n\n    function getOrCreateDisputeCrowdsourcer(bytes32 _payoutDistributionHash, uint256[] memory _payoutNumerators, bool _overload) private returns (IDisputeCrowdsourcer) {\n        IDisputeCrowdsourcer _crowdsourcer = _overload ? preemptiveDisputeCrowdsourcer : IDisputeCrowdsourcer(crowdsourcers.getAsAddressOrZero(_payoutDistributionHash));\n        if (_crowdsourcer == IDisputeCrowdsourcer(0)) {\n            DisputeCrowdsourcerFactory _disputeCrowdsourcerFactory = DisputeCrowdsourcerFactory(augur.lookup(\"DisputeCrowdsourcerFactory\"));\n            uint256 _participantStake = getParticipantStake();\n            if (_overload) {\n                _participantStake = _participantStake.add(_participantStake.mul(2).sub(getHighestNonTentativeParticipantStake().mul(3)));\n            }\n            uint256 _size = _participantStake.mul(2).sub(getStakeInOutcome(_payoutDistributionHash).mul(3));\n            _crowdsourcer = _disputeCrowdsourcerFactory.createDisputeCrowdsourcer(augur, this, _size, _payoutDistributionHash, _payoutNumerators);\n            if (!_overload) {\n                crowdsourcers.add(_payoutDistributionHash, address(_crowdsourcer));\n            } else {\n                preemptiveDisputeCrowdsourcer = _crowdsourcer;\n            }\n            augur.disputeCrowdsourcerCreated(universe, address(this), address(_crowdsourcer), _payoutNumerators, _size);\n        }\n        return _crowdsourcer;\n    }\n\n    function migrateThroughOneFork(uint256[] memory _payoutNumerators, string memory _description) public returns (bool) {\n        // only proceed if the forking market is finalized\n        IMarket _forkingMarket = universe.getForkingMarket();\n        require(_forkingMarket.isFinalized());\n        require(!isFinalized());\n\n        disavowCrowdsourcers();\n\n        IUniverse _currentUniverse = universe;\n        bytes32 _winningForkPayoutDistributionHash = _forkingMarket.getWinningPayoutDistributionHash();\n        IUniverse _destinationUniverse = _currentUniverse.getChildUniverse(_winningForkPayoutDistributionHash);\n\n        universe.decrementOpenInterestFromMarket(this);\n\n        // follow the forking market to its universe\n        if (disputeWindow != IDisputeWindow(0)) {\n            // Markets go into the standard resolution period during fork migration even if they were in the initial dispute window. We want to give some time for REP to migrate.\n            disputeWindow = _destinationUniverse.getOrCreateNextDisputeWindow(false);\n        }\n        _destinationUniverse.addMarketTo();\n        _currentUniverse.removeMarketFrom();\n        universe = _destinationUniverse;\n\n        universe.incrementOpenInterestFromMarket(this);\n\n        // Pay the REP bond.\n        repBond = universe.getOrCacheMarketRepBond();\n        repBondOwner = msg.sender;\n        getReputationToken().trustedMarketTransfer(repBondOwner, address(this), repBond);\n\n        // Update the Initial Reporter\n        IInitialReporter _initialReporter = getInitialReporter();\n        _initialReporter.migrateToNewUniverse(msg.sender);\n\n        // If the market is past expiration use the reporting data to make an initial report\n        uint256 _timestamp = augur.getTimestamp();\n        if (_timestamp > endTime) {\n            doInitialReportInternal(msg.sender, _payoutNumerators, _description);\n        }\n\n        return true;\n    }\n\n    function disavowCrowdsourcers() public returns (bool) {\n        require(universe.isForking());\n        IMarket _forkingMarket = getForkingMarket();\n        require(_forkingMarket != this);\n        require(!isFinalized());\n        IInitialReporter _initialParticipant = getInitialReporter();\n        // Early out if already disavowed or nothing to disavow\n        if (_initialParticipant.getReportTimestamp() == 0) {\n            return true;\n        }\n        delete participants;\n        participants.push(_initialParticipant);\n        // Send REP from the rep bond back to the address that placed it. If a report has been made tell the InitialReporter to return that REP and reset\n        if (repBond > 0) {\n            IV2ReputationToken _reputationToken = getReputationToken();\n            require(_reputationToken.transfer(repBondOwner, repBond));\n            repBond = 0;\n        } else {\n            _initialParticipant.returnRepFromDisavow();\n        }\n        clearCrowdsourcers();\n        augur.logMarketParticipantsDisavowed(universe);\n        return true;\n    }\n\n    function clearCrowdsourcers() public returns (bool) {\n        crowdsourcers = mapFactory.createMap(augur, address(this));\n        return true;\n    }\n\n    function getHighestNonTentativeParticipantStake() public view returns (uint256) {\n        if (participants.length < 2) {\n            return 0;\n        }\n        bytes32 _payoutDistributionHash = participants[participants.length - 2].getPayoutDistributionHash();\n        return getStakeInOutcome(_payoutDistributionHash);\n    }\n\n    function getParticipantStake() public view returns (uint256) {\n        uint256 _sum;\n        // Participants is implicitly bounded by the floor of the initial report REP cost to be no more than 21\n        for (uint256 i = 0; i < participants.length; ++i) {\n            _sum += participants[i].getStake();\n        }\n        return _sum;\n    }\n\n    function getStakeInOutcome(bytes32 _payoutDistributionHash) public view returns (uint256) {\n        uint256 _sum;\n        // Participants is implicitly bounded by the floor of the initial report REP cost to be no more than 21\n        for (uint256 i = 0; i < participants.length; ++i) {\n            IReportingParticipant _reportingParticipant = participants[i];\n            if (_reportingParticipant.getPayoutDistributionHash() != _payoutDistributionHash) {\n                continue;\n            }\n            _sum += _reportingParticipant.getStake();\n        }\n        return _sum;\n    }\n\n    function getForkingMarket() public view returns (IMarket) {\n        return universe.getForkingMarket();\n    }\n\n    function getWinningPayoutDistributionHash() public view returns (bytes32) {\n        return winningPayoutDistributionHash;\n    }\n\n    function isFinalized() public view returns (bool) {\n        return winningPayoutDistributionHash != bytes32(0);\n    }\n\n    function getDesignatedReporter() public view returns (address) {\n        return getInitialReporter().getDesignatedReporter();\n    }\n\n    function designatedReporterShowed() public view returns (bool) {\n        return getInitialReporter().designatedReporterShowed();\n    }\n\n    function designatedReporterWasCorrect() public view returns (bool) {\n        return getInitialReporter().designatedReporterWasCorrect();\n    }\n\n    function getEndTime() public view returns (uint256) {\n        return endTime;\n    }\n\n    function isInvalid() public view returns (bool) {\n        require(isFinalized());\n        return getWinningReportingParticipant().getPayoutNumerator(0) > 0;\n    }\n\n    function getInitialReporter() public view returns (IInitialReporter) {\n        return IInitialReporter(address(participants[0]));\n    }\n\n    function getReportingParticipant(uint256 _index) public view returns (IReportingParticipant) {\n        return participants[_index];\n    }\n\n    function getCrowdsourcer(bytes32 _payoutDistributionHash) public view returns (IDisputeCrowdsourcer) {\n        return  IDisputeCrowdsourcer(crowdsourcers.getAsAddressOrZero(_payoutDistributionHash));\n    }\n\n    function getWinningReportingParticipant() public view returns (IReportingParticipant) {\n        return participants[participants.length-1];\n    }\n\n    function getWinningPayoutNumerator(uint256 _outcome) public view returns (uint256) {\n        require(isFinalized());\n        return getWinningReportingParticipant().getPayoutNumerator(_outcome);\n    }\n\n    function getUniverse() public view returns (IUniverse) {\n        return universe;\n    }\n\n    function getDisputeWindow() public view returns (IDisputeWindow) {\n        return disputeWindow;\n    }\n\n    function getFinalizationTime() public view returns (uint256) {\n        return finalizationTime;\n    }\n\n    function getReputationToken() public view returns (IV2ReputationToken) {\n        return universe.getReputationToken();\n    }\n\n    function getNumberOfOutcomes() public view returns (uint256) {\n        return numOutcomes;\n    }\n\n    function getNumTicks() public view returns (uint256) {\n        return numTicks;\n    }\n\n    function getShareToken(uint256 _outcome) public view returns (IShareToken) {\n        return shareTokens[_outcome];\n    }\n\n    function getDesignatedReportingEndTime() public view returns (uint256) {\n        return endTime.add(Reporting.getDesignatedReportingDurationSeconds());\n    }\n\n    function getNumParticipants() public view returns (uint256) {\n        return participants.length;\n    }\n\n    function getValidityBondAttoCash() public view returns (uint256) {\n        return validityBondAttoCash;\n    }\n\n    function getDisputePacingOn() public view returns (bool) {\n        return disputePacingOn;\n    }\n\n    function derivePayoutDistributionHash(uint256[] memory _payoutNumerators) public view returns (bytes32) {\n        uint256 _sum = 0;\n        // This is to force an Invalid report to be entirely payed out to Invalid\n        require(_payoutNumerators[0] == 0 || _payoutNumerators[0] == numTicks);\n        require(_payoutNumerators.length == numOutcomes);\n        for (uint256 i = 0; i < _payoutNumerators.length; i++) {\n            uint256 _value = _payoutNumerators[i];\n            _sum = _sum.add(_value);\n        }\n        require(_sum == numTicks);\n        return keccak256(abi.encodePacked(_payoutNumerators));\n    }\n\n    function isContainerForShareToken(IShareToken _shadyShareToken) public view returns (bool) {\n        return getShareToken(_shadyShareToken.getOutcome()) == _shadyShareToken;\n    }\n\n    function isContainerForReportingParticipant(IReportingParticipant _shadyReportingParticipant) public view returns (bool) {\n        require(_shadyReportingParticipant != IReportingParticipant(0));\n        if (address(preemptiveDisputeCrowdsourcer) == address(_shadyReportingParticipant)) {\n            return true;\n        }\n        if (crowdsourcers.getAsAddressOrZero(_shadyReportingParticipant.getPayoutDistributionHash()) == address(_shadyReportingParticipant)) {\n            return true;\n        }\n        // Participants is implicitly bounded by the floor of the initial report REP cost to be no more than 21\n        for (uint256 i = 0; i < participants.length; i++) {\n            if (_shadyReportingParticipant == participants[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function onTransferOwnership(address _owner, address _newOwner) internal returns (bool) {\n        augur.logMarketTransferred(getUniverse(), _owner, _newOwner);\n        return true;\n    }\n\n    function assertBalances() public view returns (bool) {\n        universe.assertMarketBalance();\n        return true;\n    }\n}"
    },
    {
      "filename": "packages/augur-core/source/contracts/reporting/Market.sol",
      "content": "pragma solidity 0.5.4;\n\nimport 'ROOT/reporting/IMarket.sol';\nimport 'ROOT/libraries/Initializable.sol';\nimport 'ROOT/libraries/Ownable.sol';\nimport 'ROOT/libraries/collections/Map.sol';\nimport 'ROOT/reporting/IUniverse.sol';\nimport 'ROOT/reporting/IReportingParticipant.sol';\nimport 'ROOT/reporting/IDisputeCrowdsourcer.sol';\nimport 'ROOT/reporting/IV2ReputationToken.sol';\nimport 'ROOT/factories/DisputeCrowdsourcerFactory.sol';\nimport 'ROOT/trading/ICash.sol';\nimport 'ROOT/trading/IShareToken.sol';\nimport 'ROOT/factories/ShareTokenFactory.sol';\nimport 'ROOT/factories/InitialReporterFactory.sol';\nimport 'ROOT/factories/MapFactory.sol';\nimport 'ROOT/libraries/math/SafeMathUint256.sol';\nimport 'ROOT/libraries/math/SafeMathInt256.sol';\nimport 'ROOT/reporting/Reporting.sol';\nimport 'ROOT/reporting/IInitialReporter.sol';\nimport 'ROOT/reporting/IAuction.sol';\n\n\ncontract Market is Initializable, Ownable, IMarket {\n    using SafeMathUint256 for uint256;\n    using SafeMathInt256 for int256;\n\n    // Constants\n    uint256 private constant MAX_FEE_PER_CASH_IN_ATTOCASH = 15 * 10**16; // 15%\n    uint256 private constant APPROVAL_AMOUNT = 2 ** 256 - 1;\n    address private constant NULL_ADDRESS = address(0);\n    uint256 private constant MIN_OUTCOMES = 3; // Includes INVALID\n    uint256 private constant MAX_OUTCOMES = 8;\n\n    // Contract Refs\n    IUniverse private universe;\n    IDisputeWindow private disputeWindow;\n    ICash private cash;\n    IAugur public augur;\n    MapFactory public mapFactory;\n\n    // Attributes\n    uint256 private numTicks;\n    uint256 private feeDivisor;\n    uint256 public affiliateFeeDivisor;\n    uint256 private endTime;\n    uint256 private numOutcomes;\n    bytes32 private winningPayoutDistributionHash;\n    uint256 private validityBondAttoCash;\n    uint256 private finalizationTime;\n    uint256 private repBond;\n    bool private disputePacingOn;\n    address private repBondOwner;\n    uint256 public marketCreatorFeesAttoCash;\n    IDisputeCrowdsourcer public preemptiveDisputeCrowdsourcer;\n\n    // Collections\n    IReportingParticipant[] public participants;\n    IMap public crowdsourcers;\n    IShareToken[] private shareTokens;\n    mapping (address => uint256) public affiliateFeesAttoCash;\n\n    function initialize(IAugur _augur, IUniverse _universe, uint256 _endTime, uint256 _feePerCashInAttoCash, uint256 _affiliateFeeDivisor, address _designatedReporterAddress, address _creator, uint256 _numOutcomes, uint256 _numTicks) public beforeInitialized returns (bool _success) {\n        endInitialization();\n        augur = _augur;\n        _numOutcomes += 1; // The INVALID outcome is always first\n        require(MIN_OUTCOMES <= _numOutcomes && _numOutcomes <= MAX_OUTCOMES);\n        require(_designatedReporterAddress != NULL_ADDRESS);\n        require((_numTicks >= _numOutcomes));\n        require(_feePerCashInAttoCash <= MAX_FEE_PER_CASH_IN_ATTOCASH);\n        require(_creator != NULL_ADDRESS);\n        uint256 _timestamp = augur.getTimestamp();\n        require(_timestamp < _endTime);\n        require(_endTime < _timestamp + Reporting.getMaximumMarketDuration());\n        universe = _universe;\n        require(!universe.isForking());\n        cash = ICash(augur.lookup(\"Cash\"));\n        owner = _creator;\n        repBondOwner = owner;\n        assessFees();\n        endTime = _endTime;\n        numOutcomes = _numOutcomes;\n        numTicks = _numTicks;\n        feeDivisor = _feePerCashInAttoCash == 0 ? 0 : 1 ether / _feePerCashInAttoCash;\n        affiliateFeeDivisor = _affiliateFeeDivisor;\n        InitialReporterFactory _initialReporterFactory = InitialReporterFactory(augur.lookup(\"InitialReporterFactory\"));\n        participants.push(_initialReporterFactory.createInitialReporter(augur, this, _designatedReporterAddress));\n        mapFactory = MapFactory(augur.lookup(\"MapFactory\"));\n        clearCrowdsourcers();\n        for (uint256 _outcome = 0; _outcome < numOutcomes; _outcome++) {\n            shareTokens.push(createShareToken(_outcome));\n        }\n        approveSpenders();\n        return true;\n    }\n\n    function assessFees() private returns (bool) {\n        repBond = universe.getOrCacheMarketRepBond();\n        require(getReputationToken().balanceOf(address(this)) >= repBond);\n        validityBondAttoCash = cash.balanceOf(address(this));\n        require(validityBondAttoCash >= universe.getOrCacheValidityBond());\n        return true;\n    }\n\n    function increaseValidityBond(uint256 _attoCASH) public returns (bool) {\n        cash.transferFrom(msg.sender, address(this), _attoCASH);\n        validityBondAttoCash = validityBondAttoCash.add(_attoCASH);\n        return true;\n    }\n\n    function createShareToken(uint256 _outcome) private returns (IShareToken) {\n        return ShareTokenFactory(augur.lookup(\"ShareTokenFactory\")).createShareToken(augur, this, _outcome);\n    }\n\n    // This will need to be called manually for each open market if a spender contract is updated\n    function approveSpenders() public returns (bool) {\n        bytes32[5] memory _names = [bytes32(\"CancelOrder\"), bytes32(\"CompleteSets\"), bytes32(\"FillOrder\"), bytes32(\"ClaimTradingProceeds\"), bytes32(\"Orders\")];"
    }
  ]
}