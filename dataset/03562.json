{
  "Title": "[L18] Implicit casting",
  "Content": "Implicit casting is used to convert the [`price`](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/oracle/OracleRouter.sol#L31) from `int256` to `uint256`. This could overflow if the price were negative, but the [require statements](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/oracle/OracleRouter.sol#L32-L33) should revert the function in such case, as the result would be outside this range.\n\n\nAlthough this cannot result in overflow because of the `require` statements, consider using [SafeCast](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/utils/SafeCast.sol) to safely convert between different integer types as a best practice.\n\n\n**Update:** *Acknowledged and retained by the Origin team.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/contracts/oracle/OracleRouter.sol",
      "content": "pragma solidity 0.5.11;\n\nimport \"../interfaces/chainlink/AggregatorV3Interface.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\n\ncontract OracleRouterBase is IOracle {\n    uint256 constant MIN_DRIFT = uint256(70000000);\n    uint256 constant MAX_DRIFT = uint256(130000000);\n\n    /**\n     * @dev The price feed contract to use for a particular asset.\n     * @param asset address of the asset\n     */\n    function feed(address asset) internal view returns (address);\n\n    /**\n     * @notice Returns the total price in 8 digit USD for a given asset.\n     * @param asset address of the asset\n     * @return uint256 USD price of 1 of the asset, in 8 decimal fixed\n     */\n    function price(address asset) external view returns (uint256) {\n        address _feed = feed(asset);\n        require(_feed != address(0), \"Asset not available\");\n        (\n            uint80 roundID,\n            int256 _iprice,\n            uint256 startedAt,\n            uint256 timeStamp,\n            uint80 answeredInRound\n        ) = AggregatorV3Interface(_feed).latestRoundData();\n        uint256 _price = uint256(_iprice);\n        require(_price <= MAX_DRIFT, \"Oracle: Price exceeds max\");\n        require(_price >= MIN_DRIFT, \"Oracle: Price under min\");\n        return uint256(_price);\n    }\n}\n\ncontract OracleRouter is OracleRouterBase {\n    /**\n     * @dev The price feed contract to use for a particular asset.\n     * @param asset address of the asset\n     */\n    function feed(address asset) internal view returns (address) {\n        // DAI\n        if (asset == address(0x6B175474E89094C44Da98b954EedeAC495271d0F)) {\n            return address(0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9);\n            // USDC\n        } else if (\n            asset == address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48)\n        ) {\n            return address(0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6);\n            // USDT\n        } else if (\n            asset == address(0xdAC17F958D2ee523a2206206994597C13D831ec7)\n        ) {\n            return address(0x3E7d1eAB13ad0104d2750B8863b489D65364e32D);\n        } else {\n            require(false, \"Asset not available\");\n        }\n    }\n}\n\ncontract OracleRouterDev is OracleRouterBase {\n    mapping(address => address) public assetToFeed;\n\n    function setFeed(address _asset, address _feed) external {\n        assetToFeed[_asset] = _feed;\n    }\n\n    /**\n     * @dev The price feed contract to use for a particular asset.\n     * @param asset address of the asset\n     */\n    function feed(address asset) internal view returns (address) {\n        return assetToFeed[asset];\n    }\n}"
    }
  ]
}