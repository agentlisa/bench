{
  "Title": "[M02] Rounds with no locked asset can lead to fee miscalculations",
  "Content": "In the [`_closeShort`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/RibbonThetaVault.sol#L246) function of [`RibbonThetaVault`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/RibbonThetaVault.sol), the state variable `vaultState.lastLockedAmount` [is set to](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/RibbonThetaVault.sol#L249-L252) `vaultState.lockedAmount` unless the latter is zero, in which case `lastLockedAmount` is just copied back on to itself. Aside from using gas for an unnecessary `SSTORE`, this has the effect of essentially skipping over recording rounds with no `lockedAmount` of asset.\n\n\nThis is problematic, because prior locked amounts are used to assess [performance fees](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/base/RibbonVault.sol#L520-L526) and [management fees](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/base/RibbonVault.sol#L527-L530) in the [`_collectVaultFees`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/base/RibbonVault.sol#L506) function.\n\n\nThe performance fee is directly impacted by the [difference between](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/base/RibbonVault.sol#L523) the amount of locked asset in the current round and the round immediately prior. Disregarding a round that legitimately had no `lockedAsset` (an empty round), distorts this calculation.\n\n\nIn some cases, the fee assessment will just be incorrectly skipped altogether.\n\n\nThe `_collectVaultFees` function relies on the [condition](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/base/RibbonVault.sol#L519) that the current round’s locked balance must be greater than the prior round’s locked balance to assess any fees at all. Since the empty round was not recorded, in the case where the round prior to the empty round had more asset than the current round after profits, *no* fees would be assessed.\n\n\nConsider keeping track of all actual amounts of locked asset to ensure that vault fees are always assessed correctly.\n\n\n**Update**: *Fixed in commit [`ce98d07920da508ee6ad4907d55bf4e901a0aa5b` of PR#81](https://github.com/ribbon-finance/ribbon-v2/pull/81/commits/ce98d07920da508ee6ad4907d55bf4e901a0aa5b). The code no longer skips recording rounds with no `lockedAmount` of asset. However, code to initialize the value of `vaultState.lastLockedAmount` was also removed. The latter removed code was not directly related to to the issue outlined above. Not initializing the value of `vaultState.lastLockedAmount` to the vaults’ balance of `asset` should not be problematic for the assessment of fees for the general case where the token balance at time of initialization is zero. Outside of that context, given the scope constraints of fix reviews, we have not considered the implications of that change.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/vaults/RibbonThetaVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.3;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport {GnosisAuction} from \"../libraries/GnosisAuction.sol\";\nimport {OptionsThetaVaultStorage} from \"../storage/OptionsVaultStorage.sol\";\nimport {Vault} from \"../libraries/Vault.sol\";\nimport {VaultLifecycle} from \"../libraries/VaultLifecycle.sol\";\nimport {ShareMath} from \"../libraries/ShareMath.sol\";\nimport {RibbonVault} from \"./base/RibbonVault.sol\";\n\ncontract RibbonThetaVault is RibbonVault, OptionsThetaVaultStorage {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using ShareMath for Vault.DepositReceipt;\n\n    /************************************************\n     *  IMMUTABLES & CONSTANTS\n     ***********************************************/\n\n    // oTokenFactory is the factory contract used to spawn otokens. Used to lookup otokens.\n    address public immutable OTOKEN_FACTORY;\n\n    /************************************************\n     *  EVENTS\n     ***********************************************/\n\n    event OpenShort(\n        address indexed options,\n        uint256 depositAmount,\n        address manager\n    );\n\n    event CloseShort(\n        address indexed options,\n        uint256 withdrawAmount,\n        address manager\n    );\n\n    event NewOptionStrikeSelected(uint256 strikePrice, uint256 delta);\n\n    event PremiumDiscountSet(\n        uint256 premiumDiscount,\n        uint256 newPremiumDiscount\n    );\n\n    event AuctionDurationSet(\n        uint256 auctionDuration,\n        uint256 newAuctionDuration\n    );\n\n    event InstantWithdraw(\n        address indexed account,\n        uint256 amount,\n        uint16 round\n    );\n\n    event InitiateGnosisAuction(\n        address auctioningToken,\n        address biddingToken,\n        uint256 auctionCounter,\n        address manager\n    );\n\n    /************************************************\n     *  CONSTRUCTOR & INITIALIZATION\n     ***********************************************/\n\n    /**\n     * @notice Initializes the contract with immutable variables\n     * @param _weth is the Wrapped Ether contract\n     * @param _usdc is the USDC contract\n     * @param _oTokenFactory is the contract address for minting new opyn option types (strikes, asset, expiry)\n     * @param _gammaController is the contract address for opyn actions\n     * @param _marginPool is the contract address for providing collateral to opyn\n     * @param _gnosisEasyAuction is the contract address that facilitates gnosis auctions\n     */\n    constructor(\n        address _weth,\n        address _usdc,\n        address _oTokenFactory,\n        address _gammaController,\n        address _marginPool,\n        address _gnosisEasyAuction\n    )\n        RibbonVault(\n            _weth,\n            _usdc,\n            _gammaController,\n            _marginPool,\n            _gnosisEasyAuction\n        )\n    {\n        require(_oTokenFactory != address(0), \"!_oTokenFactory\");\n        OTOKEN_FACTORY = _oTokenFactory;\n    }\n\n    /**\n     * @notice Initializes the OptionVault contract with storage variables.\n     */\n    function initialize(\n        address _owner,\n        address _feeRecipient,\n        uint256 _managementFee,\n        uint256 _performanceFee,\n        string memory tokenName,\n        string memory tokenSymbol,\n        address _optionsPremiumPricer,\n        address _strikeSelection,\n        uint32 _premiumDiscount,\n        uint256 _auctionDuration,\n        Vault.VaultParams calldata _vaultParams\n    ) external initializer {\n        baseInitialize(\n            _owner,\n            _feeRecipient,\n            _managementFee,\n            _performanceFee,\n            tokenName,\n            tokenSymbol,\n            _vaultParams\n        );\n        require(_optionsPremiumPricer != address(0), \"!_optionsPremiumPricer\");\n        require(_strikeSelection != address(0), \"!_strikeSelection\");\n        require(\n            _premiumDiscount > 0 && _premiumDiscount < 1000,\n            \"!_premiumDiscount\"\n        );\n        require(_auctionDuration >= 1 hours, \"!_auctionDuration\");\n        optionsPremiumPricer = _optionsPremiumPricer;\n        strikeSelection = _strikeSelection;\n        premiumDiscount = _premiumDiscount;\n        auctionDuration = _auctionDuration;\n    }\n\n    /************************************************\n     *  SETTERS\n     ***********************************************/\n\n    /**\n     * @notice Sets the new discount on premiums for options we are selling\n     * @param newPremiumDiscount is the premium discount\n     */\n    function setPremiumDiscount(uint16 newPremiumDiscount) external onlyOwner {\n        require(\n            newPremiumDiscount > 0 && newPremiumDiscount < 1000,\n            \"Invalid discount\"\n        );\n\n        emit PremiumDiscountSet(premiumDiscount, newPremiumDiscount);\n\n        premiumDiscount = newPremiumDiscount;\n    }\n\n    /**\n     * @notice Sets the new auction duration\n     * @param newAuctionDuration is the auction duration\n     */\n    function setAuctionDuration(uint256 newAuctionDuration) external onlyOwner {\n        require(newAuctionDuration >= 1 hours, \"Invalid auction duration\");\n\n        emit AuctionDurationSet(auctionDuration, newAuctionDuration);\n\n        auctionDuration = newAuctionDuration;\n    }\n\n    /**\n     * @notice Withdraws the assets on the vault using the outstanding `DepositReceipt.amount`\n     * @param amount is the amount to withdraw\n     */\n    function withdrawInstantly(uint256 amount) external nonReentrant {\n        Vault.DepositReceipt storage depositReceipt =\n            depositReceipts[msg.sender];\n\n        uint16 currentRound = vaultState.round;\n        require(amount > 0, \"!amount\");\n        require(depositReceipt.round == currentRound, \"Invalid round\");\n\n        uint104 receiptAmount = depositReceipt.amount;\n        require(receiptAmount >= amount, \"Exceed amount\");\n\n        // Subtraction underflow checks already ensure it is smaller than uint104\n        depositReceipt.amount = uint104(uint256(receiptAmount).sub(amount));\n        vaultState.totalPending = uint128(\n            uint256(vaultState.totalPending).sub(amount)\n        );\n\n        emit InstantWithdraw(msg.sender, amount, currentRound);\n\n        transferAsset(msg.sender, amount);\n    }\n\n    /************************************************\n     *  VAULT OPERATIONS\n     ***********************************************/\n\n    /**\n     * @notice Sets the next option the vault will be shorting, and closes the existing short.\n     *         This allows all the users to withdraw if the next option is malicious.\n     */\n    function commitAndClose() external onlyOwner nonReentrant {\n        address oldOption = optionState.currentOption;\n\n        VaultLifecycle.CloseParams memory closeParams =\n            VaultLifecycle.CloseParams({\n                OTOKEN_FACTORY: OTOKEN_FACTORY,\n                USDC: USDC,\n                currentOption: oldOption,\n                delay: delay,\n                lastStrikeOverride: lastStrikeOverride,\n                overriddenStrikePrice: overriddenStrikePrice\n            });\n\n        (\n            address otokenAddress,\n            uint256 premium,\n            uint256 strikePrice,\n            uint256 delta\n        ) =\n            VaultLifecycle.commitAndClose(\n                strikeSelection,\n                optionsPremiumPricer,\n                premiumDiscount,\n                closeParams,\n                vaultParams,\n                vaultState\n            );\n\n        emit NewOptionStrikeSelected(strikePrice, delta);\n\n        ShareMath.assertUint104(premium);\n        currentOtokenPremium = uint104(premium);\n        optionState.nextOption = otokenAddress;\n        optionState.nextOptionReadyAt = uint32(block.timestamp.add(delay));\n\n        _closeShort(oldOption);\n    }\n\n    /**\n     * @notice Closes the existing short position for the vault.\n     */\n    function _closeShort(address oldOption) private {\n        optionState.currentOption = address(0);\n\n        uint104 lockedAmount = vaultState.lockedAmount;\n        vaultState.lastLockedAmount = lockedAmount > 0\n            ? lockedAmount\n            : vaultState.lastLockedAmount;\n\n        vaultState.lockedAmount = 0;\n\n        if (oldOption != address(0)) {\n            uint256 withdrawAmount =\n                VaultLifecycle.settleShort(GAMMA_CONTROLLER);\n            emit CloseShort(oldOption, withdrawAmount, msg.sender);\n        }\n    }\n\n    /**\n     * @notice Rolls the vault's funds into a new short position.\n     */\n    function rollToNextOption() external nonReentrant {\n        (address newOption, uint256 lockedBalance) = _rollToNextOption();\n\n        vaultState.lockedAmount = uint104(lockedBalance);\n\n        emit OpenShort(newOption, lockedBalance, msg.sender);\n\n        VaultLifecycle.createShort(\n            GAMMA_CONTROLLER,\n            MARGIN_POOL,\n            newOption,\n            lockedBalance\n        );\n\n        startAuction();\n    }\n\n    /**\n     * @notice Initiate the gnosis auction.\n     */\n    function startAuction() public onlyOwner {\n        GnosisAuction.AuctionDetails memory auctionDetails;\n\n        uint256 currOtokenPremium = currentOtokenPremium;\n\n        require(currOtokenPremium > 0, \"!currentOtokenPremium\");\n\n        auctionDetails.oTokenAddress = optionState.currentOption;\n        auctionDetails.gnosisEasyAuction = GNOSIS_EASY_AUCTION;\n        auctionDetails.asset = vaultParams.asset;\n        auctionDetails.assetDecimals = vaultParams.decimals;\n        auctionDetails.oTokenPremium = currOtokenPremium;\n        auctionDetails.duration = auctionDuration;\n\n        optionAuctionID = VaultLifecycle.startAuction(auctionDetails);\n    }\n\n    /**\n     * @notice Burn the remaining oTokens left over from gnosis auction.\n     */\n    function burnRemainingOTokens() external onlyOwner nonReentrant {\n        uint256 numOTokensToBurn =\n            IERC20(optionState.currentOption).balanceOf(address(this));\n        require(numOTokensToBurn > 0, \"!otokens\");\n        uint256 unlockedAssedAmount =\n            VaultLifecycle.burnOtokens(GAMMA_CONTROLLER, numOTokensToBurn);\n        vaultState.lockedAmount = uint104(\n            uint256(vaultState.lockedAmount).sub(unlockedAssedAmount)\n        );\n    }\n\n    /**\n     * @notice Optionality to set strike price manually\n     * @param strikePrice is the strike price of the new oTokens (decimals = 8)\n     */\n    function setStrikePrice(uint128 strikePrice)\n        external\n        onlyOwner\n        nonReentrant\n    {\n        require(strikePrice > 0, \"!strikePrice\");\n        overriddenStrikePrice = strikePrice;\n        lastStrikeOverride = vaultState.round;\n    }\n}"
    },
    {
      "filename": "contracts/vaults/base/RibbonVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.3;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport {GnosisAuction} from \"../../libraries/GnosisAuction.sol\";\nimport {OptionsVaultStorage} from \"../../storage/OptionsVaultStorage.sol\";\nimport {Vault} from \"../../libraries/Vault.sol\";\nimport {VaultLifecycle} from \"../../libraries/VaultLifecycle.sol\";\nimport {ShareMath} from \"../../libraries/ShareMath.sol\";\nimport {IOtoken} from \"../../interfaces/GammaInterface.sol\";\nimport {IWETH} from \"../../interfaces/IWETH.sol\";\nimport {IGnosisAuction} from \"../../interfaces/IGnosisAuction.sol\";\nimport {\n    IStrikeSelection,\n    IOptionsPremiumPricer\n} from \"../../interfaces/IRibbon.sol\";\n\ncontract RibbonVault is OptionsVaultStorage {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using ShareMath for Vault.DepositReceipt;\n\n    /************************************************\n     *  IMMUTABLES & CONSTANTS\n     ***********************************************/\n\n    address public immutable WETH;\n    address public immutable USDC;\n\n    uint256 public constant delay = 1 hours;\n\n    uint256 public constant period = 7 days;\n\n    uint128 internal constant PLACEHOLDER_UINT = 1;\n\n    // Number of weeks per year = 52.142857 weeks * 10**6 = 52142857\n    // Dividing by weeks per year requires doing num.mul(10**6).div(WEEKS_PER_YEAR)\n    uint256 private constant WEEKS_PER_YEAR = 52142857;\n\n    // GAMMA_CONTROLLER is the top-level contract in Gamma protocol\n    // which allows users to perform multiple actions on their vaults\n    // and positions https://github.com/opynfinance/GammaProtocol/blob/master/contracts/Controller.sol\n    address public immutable GAMMA_CONTROLLER;\n\n    // MARGIN_POOL is Gamma protocol's collateral pool.\n    // Needed to approve collateral.safeTransferFrom for minting otokens.\n    // https://github.com/opynfinance/GammaProtocol/blob/master/contracts/MarginPool.sol\n    address public immutable MARGIN_POOL;\n\n    // GNOSIS_EASY_AUCTION is Gnosis protocol's contract for initiating auctions and placing bids\n    // https://github.com/gnosis/ido-contracts/blob/main/contracts/EasyAuction.sol\n    address public immutable GNOSIS_EASY_AUCTION;\n\n    /************************************************\n     *  EVENTS\n     ***********************************************/\n\n    event Deposit(address indexed account, uint256 amount, uint256 round);\n\n    event InitiateWithdraw(address account, uint256 shares, uint256 round);\n\n    event Redeem(address indexed account, uint256 share, uint16 round);\n\n    event ManagementFeeSet(uint256 managementFee, uint256 newManagementFee);\n\n    event PerformanceFeeSet(uint256 performanceFee, uint256 newPerformanceFee);\n\n    event CapSet(uint256 oldCap, uint256 newCap, address manager);\n\n    event Withdraw(address account, uint256 amount, uint256 shares);\n\n    event CollectVaultFees(\n        uint256 performanceFee,\n        uint256 vaultFee,\n        uint256 round\n    );\n\n    /************************************************\n     *  CONSTRUCTOR & INITIALIZATION\n     ***********************************************/\n\n    /**\n     * @notice Initializes the contract with immutable variables\n     * @param _weth is the Wrapped Ether contract\n     * @param _usdc is the USDC contract\n     * @param _gammaController is the contract address for opyn actions\n     * @param _marginPool is the contract address for providing collateral to opyn\n     * @param _gnosisEasyAuction is the contract address that facilitates gnosis auctions\n     */\n    constructor(\n        address _weth,\n        address _usdc,\n        address _gammaController,\n        address _marginPool,\n        address _gnosisEasyAuction\n    ) {\n        require(_weth != address(0), \"!_weth\");\n        require(_usdc != address(0), \"!_usdc\");\n        require(_gnosisEasyAuction != address(0), \"!_gnosisEasyAuction\");\n        require(_gammaController != address(0), \"!_gammaController\");\n        require(_marginPool != address(0), \"!_marginPool\");\n\n        WETH = _weth;\n        USDC = _usdc;\n        GAMMA_CONTROLLER = _gammaController;\n        MARGIN_POOL = _marginPool;\n        GNOSIS_EASY_AUCTION = _gnosisEasyAuction;\n    }\n\n    /**\n     * @notice Initializes the OptionVault contract with storage variables.\n     */\n    function baseInitialize(\n        address _owner,\n        address _feeRecipient,\n        uint256 _managementFee,\n        uint256 _performanceFee,\n        string memory tokenName,\n        string memory tokenSymbol,\n        Vault.VaultParams calldata _vaultParams\n    ) internal initializer {\n        VaultLifecycle.verifyConstructorParams(\n            _owner,\n            _feeRecipient,\n            _performanceFee,\n            tokenName,\n            tokenSymbol,\n            _vaultParams\n        );\n\n        __ReentrancyGuard_init();\n        __ERC20_init(tokenName, tokenSymbol);\n        __Ownable_init();\n        transferOwnership(_owner);\n\n        feeRecipient = _feeRecipient;\n        performanceFee = _performanceFee;\n        managementFee = _managementFee.mul(10**6).div(WEEKS_PER_YEAR);\n        vaultParams = _vaultParams;\n        vaultState.lastLockedAmount = uint104(\n            IERC20(vaultParams.asset).balanceOf(address(this))\n        );\n\n        vaultState.round = 1;\n    }\n\n    /************************************************\n     *  SETTERS\n     ***********************************************/\n\n    /**\n     * @notice Sets the new fee recipient\n     * @param newFeeRecipient is the address of the new fee recipient\n     */\n    function setFeeRecipient(address newFeeRecipient) external onlyOwner {\n        require(newFeeRecipient != address(0), \"!newFeeRecipient\");\n        feeRecipient = newFeeRecipient;\n    }\n\n    /**\n     * @notice Sets the management fee for the vault\n     * @param newManagementFee is the management fee (6 decimals). ex: 2 * 10 ** 6 = 2%\n     */\n    function setManagementFee(uint256 newManagementFee) external onlyOwner {\n        require(newManagementFee < 100 * 10**6, \"Invalid management fee\");\n\n        emit ManagementFeeSet(managementFee, newManagementFee);\n\n        // We are dividing annualized management fee by num weeks in a year\n        managementFee = newManagementFee.mul(10**6).div(WEEKS_PER_YEAR);\n    }\n\n    /**\n     * @notice Sets the performance fee for the vault\n     * @param newPerformanceFee is the performance fee (6 decimals). ex: 20 * 10 ** 6 = 20%\n     */\n    function setPerformanceFee(uint256 newPerformanceFee) external onlyOwner {\n        require(newPerformanceFee < 100 * 10**6, \"Invalid performance fee\");\n\n        emit PerformanceFeeSet(performanceFee, newPerformanceFee);\n\n        performanceFee = newPerformanceFee;\n    }\n\n    /**\n     * @notice Sets a new cap for deposits\n     * @param newCap is the new cap for deposits\n     */\n    function setCap(uint104 newCap) external onlyOwner {\n        require(newCap > 0, \"!newCap\");\n        uint256 oldCap = vaultParams.cap;\n        vaultParams.cap = newCap;\n        emit CapSet(oldCap, newCap, msg.sender);\n    }\n\n    /************************************************\n     *  DEPOSIT & WITHDRAWALS\n     ***********************************************/\n\n    /**\n     * @notice Deposits ETH into the contract and mint vault shares. Reverts if the asset is not WETH.\n     */\n    function depositETH() external payable nonReentrant {\n        require(vaultParams.asset == WETH, \"!WETH\");\n        require(msg.value > 0, \"!value\");\n\n        _depositFor(msg.value, msg.sender);\n\n        IWETH(WETH).deposit{value: msg.value}();\n    }\n\n    /**\n     * @notice Deposits the `asset` from msg.sender.\n     * @param amount is the amount of `asset` to deposit\n     */\n    function deposit(uint256 amount) external nonReentrant {\n        require(amount > 0, \"!amount\");\n\n        _depositFor(amount, msg.sender);\n\n        IERC20(vaultParams.asset).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n    }\n\n    /**\n     * @notice Deposits the `asset` from msg.sender added to `creditor`'s deposit.\n     * @notice Used for vault -> vault deposits on the user's behalf\n     * @param amount is the amount of `asset` to deposit\n     * @param creditor is the address that can claim/withdraw deposited amount\n     */\n    function depositFor(uint256 amount, address creditor)\n        external\n        nonReentrant\n    {\n        require(amount > 0, \"!amount\");\n        require(creditor != address(0));\n\n        _depositFor(amount, creditor);\n\n        IERC20(vaultParams.asset).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n    }\n\n    /**\n     * @notice Deposits the `asset` from msg.sender added to `creditor`'s deposit.\n     * @notice Used for vault -> vault deposits on the user's behalf\n     * @param amount is the amount of `asset` to deposit\n     * @param creditor is the address that can claim/withdraw deposited amount\n     */\n    function _depositFor(uint256 amount, address creditor) private {\n        uint256 currentRound = vaultState.round;\n        uint256 totalWithDepositedAmount = totalBalance().add(amount);\n\n        require(totalWithDepositedAmount <= vaultParams.cap, \"Exceed cap\");\n        require(\n            totalWithDepositedAmount >= vaultParams.minimumSupply,\n            \"Insufficient balance\"\n        );\n\n        emit Deposit(creditor, amount, currentRound);\n\n        Vault.DepositReceipt memory depositReceipt = depositReceipts[creditor];\n\n        // If we have an unprocessed pending deposit from the previous rounds, we have to process it.\n        uint128 unredeemedShares =\n            depositReceipt.getSharesFromReceipt(\n                currentRound,\n                roundPricePerShare[depositReceipt.round],\n                vaultParams.decimals\n            );\n\n        uint256 depositAmount = uint104(amount);\n        // If we have a pending deposit in the current round, we add on to the pending deposit\n        if (currentRound == depositReceipt.round) {\n            uint256 newAmount = uint256(depositReceipt.amount).add(amount);\n            depositAmount = newAmount;\n        }\n\n        ShareMath.assertUint104(depositAmount);\n\n        depositReceipts[creditor] = Vault.DepositReceipt({\n            processed: false,\n            round: uint16(currentRound),\n            amount: uint104(depositAmount),\n            unredeemedShares: unredeemedShares\n        });\n\n        vaultState.totalPending = uint128(\n            uint256(vaultState.totalPending).add(amount)\n        );\n    }\n\n    /**\n     * @notice Initiates a withdrawal that can be processed once the round completes\n     * @param shares is the number of shares to withdraw\n     */\n    function initiateWithdraw(uint128 shares) external nonReentrant {\n        require(shares > 0, \"!shares\");\n\n        // We do a max redeem before initiating a withdrawal\n        // But we check if they must first have unredeemed shares\n        if (\n            depositReceipts[msg.sender].amount > 0 ||\n            depositReceipts[msg.sender].unredeemedShares > 0\n        ) {\n            _redeem(0, true);\n        }\n\n        // This caches the `round` variable used in shareBalances\n        uint256 currentRound = vaultState.round;\n        Vault.Withdrawal storage withdrawal = withdrawals[msg.sender];\n\n        bool topup = withdrawal.round == currentRound;\n\n        emit InitiateWithdraw(msg.sender, shares, currentRound);\n\n        uint256 withdrawalShares = uint256(withdrawal.shares);\n\n        if (topup) {\n            uint256 increasedShares = withdrawalShares.add(shares);\n            ShareMath.assertUint128(increasedShares);\n            withdrawals[msg.sender].shares = uint128(increasedShares);\n        } else if (withdrawalShares == 0) {\n            withdrawals[msg.sender].shares = shares;\n            withdrawals[msg.sender].round = uint16(currentRound);\n        } else {\n            // If we have an old withdrawal, we revert\n            // The user has to process the withdrawal\n            revert(\"Existing withdraw\");\n        }\n\n        vaultState.queuedWithdrawShares = uint128(\n            uint256(vaultState.queuedWithdrawShares).add(shares)\n        );\n\n        _transfer(msg.sender, address(this), shares);\n    }\n\n    /**\n     * @notice Completes a scheduled withdrawal from a past round. Uses finalized pps for the round\n     */\n    function completeWithdraw() external nonReentrant {\n        Vault.Withdrawal storage withdrawal = withdrawals[msg.sender];\n\n        uint256 withdrawalShares = withdrawal.shares;\n        uint256 withdrawalRound = withdrawal.round;\n\n        // This checks if there is a withdrawal\n        require(withdrawalShares > 0, \"Not initiated\");\n\n        require(withdrawalRound < vaultState.round, \"Round not closed\");\n\n        // We leave the round number as non-zero to save on gas for subsequent writes\n        withdrawals[msg.sender].shares = 0;\n        vaultState.queuedWithdrawShares = uint128(\n            uint256(vaultState.queuedWithdrawShares).sub(withdrawalShares)\n        );\n\n        uint256 withdrawAmount =\n            ShareMath.sharesToUnderlying(\n                withdrawalShares,\n                roundPricePerShare[uint16(withdrawalRound)],\n                vaultParams.decimals\n            );\n\n        emit Withdraw(msg.sender, withdrawAmount, withdrawalShares);\n\n        _burn(address(this), withdrawalShares);\n\n        require(withdrawAmount > 0, \"!withdrawAmount\");\n        transferAsset(msg.sender, withdrawAmount);\n    }\n\n    /**\n     * @notice Redeems shares that are owed to the account\n     * @param shares is the number of shares to redeem\n     */\n    function redeem(uint256 shares) external nonReentrant {\n        require(shares > 0, \"!shares\");\n        _redeem(shares, false);\n    }\n\n    /**\n     * @notice Redeems the entire unredeemedShares balance that is owed to the account\n     */\n    function maxRedeem() external nonReentrant {\n        _redeem(0, true);\n    }\n\n    /**\n     * @notice Redeems shares that are owed to the account\n     * @param shares is the number of shares to redeem, could be 0 when isMax=true\n     * @param isMax is flag for when callers do a max redemption\n     */\n    function _redeem(uint256 shares, bool isMax) internal {\n        ShareMath.assertUint104(shares);\n\n        Vault.DepositReceipt memory depositReceipt =\n            depositReceipts[msg.sender];\n\n        // This handles the null case when depositReceipt.round = 0\n        // Because we start with round = 1 at `initialize`\n        uint16 currentRound = vaultState.round;\n        require(depositReceipt.round < currentRound, \"Round not closed\");\n\n        uint128 unredeemedShares =\n            depositReceipt.getSharesFromReceipt(\n                currentRound,\n                roundPricePerShare[depositReceipt.round],\n                vaultParams.decimals\n            );\n\n        shares = isMax ? unredeemedShares : shares;\n        require(shares > 0, \"!shares\");\n        require(shares <= unredeemedShares, \"Exceeds available\");\n\n        // This zeroes out any pending amount from depositReceipt\n        depositReceipts[msg.sender].amount = 0;\n        depositReceipts[msg.sender].processed = true;\n        depositReceipts[msg.sender].unredeemedShares = uint128(\n            uint256(unredeemedShares).sub(shares)\n        );\n\n        emit Redeem(msg.sender, shares, depositReceipt.round);\n\n        _transfer(address(this), msg.sender, shares);\n    }\n\n    /************************************************\n     *  VAULT OPERATIONS\n     ***********************************************/\n\n    /*\n     * @notice Helper function that helps to save gas for writing values into the roundPricePerShare map.\n     *         Writing `1` into the map makes subsequent writes warm, reducing the gas from 20k to 5k.\n     *         Having 1 initialized beforehand will not be an issue as long as we round down share calculations to 0.\n     * @param numRounds is the number of rounds to initialize in the map\n     */\n    function initRounds(uint256 numRounds) external nonReentrant {\n        require(numRounds < 52, \"numRounds >= 52\");\n\n        uint16 _round = vaultState.round;\n        for (uint16 i = 0; i < numRounds; i++) {\n            uint16 index = _round + i;\n            require(index >= _round, \"Overflow\");\n            require(roundPricePerShare[index] == 0, \"Initialized\"); // AVOID OVERWRITING ACTUAL VALUES\n            roundPricePerShare[index] = PLACEHOLDER_UINT;\n        }\n    }\n\n    /*\n     * @notice Helper function that performs most administrative tasks\n     * such as setting next option, minting new shares, getting vault fees, etc.\n     * @return newOption is the new option address\n     * @return lockedBalance is the new balance used to calculate next option purchase size or collateral size\n     */\n    function _rollToNextOption() internal returns (address, uint256) {\n        require(block.timestamp >= optionState.nextOptionReadyAt, \"!ready\");\n\n        address newOption = optionState.nextOption;\n        require(newOption != address(0), \"!nextOption\");\n\n        (uint256 lockedBalance, uint256 newPricePerShare, uint256 mintShares) =\n            VaultLifecycle.rollover(\n                totalSupply(),\n                vaultParams.asset,\n                vaultParams.decimals,\n                vaultParams.initialSharePrice,\n                uint256(vaultState.totalPending),\n                vaultState.queuedWithdrawShares\n            );\n\n        optionState.currentOption = newOption;\n        optionState.nextOption = address(0);\n\n        // Finalize the pricePerShare at the end of the round\n        uint16 currentRound = vaultState.round;\n        roundPricePerShare[currentRound] = newPricePerShare;\n\n        // Take management / performance fee from previous round and deduct\n        lockedBalance = lockedBalance.sub(_collectVaultFees(lockedBalance));\n\n        vaultState.totalPending = 0;\n        vaultState.round = currentRound + 1;\n\n        _mint(address(this), mintShares);\n\n        return (newOption, lockedBalance);\n    }\n\n    /*\n     * @notice Helper function that transfers management fees and performance fees from previous round.\n     * @param currentLockedBalance is the balance we are about to lock for next round\n     * @return vaultFee is the fee deducted\n     */\n    function _collectVaultFees(uint256 currentLockedBalance)\n        internal\n        returns (uint256 vaultFee)\n    {\n        uint256 prevLockedAmount = vaultState.lastLockedAmount;\n        uint256 lockedBalanceSansPending =\n            currentLockedBalance.sub(vaultState.totalPending);\n\n        // Take performance fee and management fee ONLY if difference between\n        // last week and this week's vault deposits, taking into account pending\n        // deposits and withdrawals, is positive. If it is negative, last week's\n        // option expired ITM past breakeven, and the vault took a loss so we\n        // do not collect performance fee for last week\n        if (lockedBalanceSansPending > prevLockedAmount) {\n            uint256 performanceFeeInAsset =\n                performanceFee > 0\n                    ? lockedBalanceSansPending\n                        .sub(prevLockedAmount)\n                        .mul(performanceFee)\n                        .div(100 * 10**6)\n                    : 0;\n            uint256 managementFeeInAsset =\n                managementFee > 0\n                    ? currentLockedBalance.mul(managementFee).div(100 * 10**6)\n                    : 0;\n\n            vaultFee = performanceFeeInAsset.add(managementFeeInAsset);\n        }\n\n        if (vaultFee > 0) {\n            transferAsset(payable(feeRecipient), vaultFee);\n            emit CollectVaultFees(performanceFee, vaultFee, vaultState.round);\n        }\n    }\n\n    /**\n     * @notice Helper function to make either an ETH transfer or ERC20 transfer\n     * @param recipient is the receiving address\n     * @param amount is the transfer amount\n     */\n    function transferAsset(address payable recipient, uint256 amount) internal {\n        address asset = vaultParams.asset;\n        if (asset == WETH) {\n            IWETH(WETH).withdraw(amount);\n            (bool success, ) = recipient.call{value: amount}(\"\");\n            require(success, \"!success\");\n            return;\n        }\n        IERC20(asset).safeTransfer(recipient, amount);\n    }\n\n    /************************************************\n     *  GETTERS\n     ***********************************************/\n\n    /**\n     * @notice Returns the underlying balance held on the vault for the account\n     * @param account is the address to lookup balance for\n     */\n    function accountVaultBalance(address account)\n        external\n        view\n        returns (uint256)\n    {\n        uint8 decimals = vaultParams.decimals;\n        uint256 numShares = shares(account);\n        uint256 pps =\n            totalBalance().sub(vaultState.totalPending).mul(10**decimals).div(\n                totalSupply()\n            );\n        return ShareMath.sharesToUnderlying(numShares, pps, decimals);\n    }\n\n    /**\n     * @notice Getter for returning the account's share balance including unredeemed shares\n     * @param account is the account to lookup share balance for\n     * @return the share balance\n     */\n    function shares(address account) public view returns (uint256) {\n        (uint256 heldByAccount, uint256 heldByVault) = shareBalances(account);\n        return heldByAccount.add(heldByVault);\n    }\n\n    /**\n     * @notice Getter for returning the account's share balance split between account and vault holdings\n     * @param account is the account to lookup share balance for\n     * @return heldByAccount is the shares held by account\n     * @return heldByVault is the shares held on the"
    }
  ]
}