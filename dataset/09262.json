{
  "Title": "[M-15] PermissionlessBasicPoolFactoryâ€™s withdraw can become frozen on zero reward token transfers",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L230-L230\n\n\n# Vulnerability details\n\nReward tokens that do not allow for zero amount transfers can prevent user pool exit.\n\nNow it is required that all reward amounts be successfully transferred to a receipt owner and the reward token amount isn't checked in the process.\n\nIf withdraw was called at the moment when some reward amount is zero (because either zero time passed or zero slope is set), the withdraw() will revert.\n\nSay once such reward token is there (say with no malicious intent, as it's just a specifics of some valid tokens), user cannot withdraw immediately after deposit as no rewards accrued yet and this token transfer will revert the whole call even if it is one of the many.\n\nAs withdraw() the only way for a user to exit pool, her funds will be frozen within.\n\nIf slope is set to zero for such a token, either maliciously or mistakenly, the withdrawals are impossible for all the users.\n\nAs this is user fund freeze case with external assumptions, setting the severity to medium.\n\n## Proof of Concept\n\nSome ERC20 tokens do not allow for zero amount transfers:\n\nhttps://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers\n\nwithdraw() iterates across the set of reward tokens, and requires all transfers to go through:\n\nhttps://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L230-L230\n\n```solidity\nsuccess = success && IERC20(pool.rewardTokens[i]).transfer(receipt.owner, transferAmount);\n```\n\nOnce some is not ok, the whole call reverts. As it's the only way for a user to exit the pool, her funds are frozen until non-zero reward is obtained.\n\nIt might never happen as rewardsWeiPerSecondPerToken is allowed to be zero:\n\nhttps://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L92-L112\n\n```solidity\n    function addPool (\n        uint startTime,\n        uint maxDeposit,\n        uint[] memory rewardsWeiPerSecondPerToken,\n        uint programLengthDays,\n        address depositTokenAddress,\n        address excessBeneficiary,\n        address[] memory rewardTokenAddresses,\n        bytes32 ipfsHash,\n        bytes32 name\n    ) external {\n        Pool storage pool = pools[++numPools];\n        pool.id = numPools;\n        pool.rewardsWeiPerSecondPerToken = rewardsWeiPerSecondPerToken;\n        pool.startTime = startTime > block.timestamp ? startTime : block.timestamp;\n        pool.endTime = pool.startTime + (programLengthDays * 1 days);\n        pool.depositToken = depositTokenAddress;\n        pool.excessBeneficiary = excessBeneficiary;\n        pool.taxPerCapita = globalTaxPerCapita;\n\n        require(rewardsWeiPerSecondPerToken.length == rewardTokenAddresses.length, 'Rewards and reward token arrays must be same length');\n```\n\nThis way, when one of the reward tokens doesn't allow for zero transfers:\n1) immediate withdraw after deposit is impossible\n2) factory allows for creation of malicious or misconfigured pools by adding such a reward token with zero rewardsWeiPerSecondPerToken, making withdraw impossible for all users\n\n## Recommended Mitigation Steps\n\nConsider controlling for zero amounts in reward transfer cycle:\n\n```solidity\n        for (uint i = 0; i < rewards.length; i++) {\n+\t        if (rewards[i] > 0) {\n\t            pool.rewardsWeiClaimed[i] += rewards[i];\n\t            pool.rewardFunding[i] -= rewards[i];\n\t            uint tax = (pool.taxPerCapita * rewards[i]) / 1000;\n\t            uint transferAmount = rewards[i] - tax;\n\t            taxes[poolId][i] += tax;\n\t            success = success && IERC20(pool.rewardTokens[i]).transfer(receipt.owner, transferAmount);\n+\t        }\n        }\n```\n\nhttps://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L224-L231\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-factorydao-contest",
  "Code": [
    {
      "filename": "contracts/PermissionlessBasicPoolFactory.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.12;\n\nimport \"../interfaces/IERC20.sol\";\n\n/// @title A factory pattern for basic staking, put tokens in, get more tokens (potentially multiple types) out\n/// @author metapriest, adrian.wachel, marek.babiarz, radoslaw.gorecki\n/// @notice This contract is permissionless and public facing. Anyone can create a pool, and fees are taken out of rewards\n/// @dev Maximum possible pool obligations are computed at pool-creation-time and taken from creator at that time\n/// @dev Any unclaimed rewards are claimable after the pool has ended, pool funds are accounted for separately\ncontract PermissionlessBasicPoolFactory {\n\n    // this represents a single deposit into a staking pool, used to withdraw as well\n    struct Receipt {\n        uint id;   // primary key\n        uint amountDepositedWei;  // amount of tokens originally deposited\n        uint timeDeposited;  // the time the deposit was made\n        uint timeWithdrawn;  // the time the deposit was withdrawn, or 0 if not withdrawn yet\n        address owner;  // the owner of the deposit\n    }\n\n    // this represents a single staking pool with >= 1 reward tokens\n    struct Pool {\n        uint id; // primary key\n        uint[] rewardsWeiPerSecondPerToken; // array of reward rates, this number gets multiplied by time and tokens (not wei) to determine rewards\n        uint[] rewardsWeiClaimed;  // bookkeeping of how many rewards have been paid out for each token\n        uint[] rewardFunding;  // bookkeeping of how many rewards have been supplied for each token\n        uint maximumDepositWei;  // the size of the pool, maximum sum of all deposits\n        uint totalDepositsWei;  // current sum of all deposits\n        uint numReceipts;  // number of receipts issued\n        uint startTime;  // the time that the pool begins\n        uint endTime;    // time that the pool ends\n        uint taxPerCapita;  // portion of rewards that go to the contract creator\n        address depositToken;  // token that user deposits (stakes)\n        address excessBeneficiary;  // address that is able to reclaim unused rewards\n        address[] rewardTokens;  // array of token contract addresses that stakers will receive as rewards\n        mapping (uint => Receipt) receipts;  // mapping of receipt ids to receipt structs\n    }\n\n    // simple struct for UI to display relevant data\n    struct Metadata {\n        bytes32 name;\n        bytes32 ipfsHash;\n    }\n\n    // the number of staking pools ever created\n    uint public numPools;\n\n    // the beneficiary of taxes\n    address public globalBeneficiary;\n\n    // this is the settable tax imposed on new pools, fixed at pool creation time\n    uint public globalTaxPerCapita;\n\n    // pools[poolId] = poolStruct\n    mapping (uint => Pool) public pools;\n    // metadatas[poolId] = metadataStruct\n    mapping (uint => Metadata) public metadatas;\n    // taxes[poolId] = taxesCollected[rewardIndex]\n    mapping (uint => uint[]) public taxes;\n\n    // every time a deposit happens\n    event DepositOccurred(uint indexed poolId, uint indexed receiptId, address indexed owner);\n    // every time a withdrawal happens\n    event WithdrawalOccurred(uint indexed poolId, uint indexed receiptId, address indexed owner);\n    // every time excess rewards are withdrawn\n    event ExcessRewardsWithdrawn(uint indexed poolId);\n    // every time a pool is added\n    event PoolAdded(uint indexed poolId, bytes32 indexed name, address indexed depositToken);\n\n    /// @notice Whoever deploys the contract decides who receives how much fees\n    /// @param _globalBeneficiary the address that receives the fees and can also set the fees\n    /// @param _globalTaxPerCapita the amount of the rewards that goes to the globalBeneficiary * 1000 (perCapita)\n    constructor(address _globalBeneficiary, uint _globalTaxPerCapita) {\n        globalBeneficiary = _globalBeneficiary;\n        globalTaxPerCapita = _globalTaxPerCapita;\n    }\n\n    /// @notice Create a pool and fund it\n    /// @dev Anyone may call this function, but they must fund it, having called approve on all contracts beforehand\n    /// @dev Any malicious token contracts included here will make the pool malicious, but not effect other pools\n    /// @param startTime time at which pool starts, if in past, it is set to block.timestamp \"now\"\n    /// @param maxDeposit the maximum amount of tokens that can be deposited in this pool\n    /// @param rewardsWeiPerSecondPerToken the amount of tokens given out per second per token (not wei) deposited\n    /// @param programLengthDays the amount of days the pool will be open, this with the start time determines the end time\n    /// @param depositTokenAddress the token that users will put into the pool to receive rewards\n    /// @param excessBeneficiary the recipient of any unclaimed funds in the pool\n    /// @param rewardTokenAddresses the list of token contracts that will be given out as rewards for staking\n    /// @param ipfsHash a hash of any metadata about the pool, may be incorporated into interfaces\n    /// @param name name of pool, to be used by interfaces\n    function addPool (\n        uint startTime,\n        uint maxDeposit,\n        uint[] memory rewardsWeiPerSecondPerToken,\n        uint programLengthDays,\n        address depositTokenAddress,\n        address excessBeneficiary,\n        address[] memory rewardTokenAddresses,\n        bytes32 ipfsHash,\n        bytes32 name\n    ) external {\n        Pool storage pool = pools[++numPools];\n        pool.id = numPools;\n        pool.rewardsWeiPerSecondPerToken = rewardsWeiPerSecondPerToken;\n        pool.startTime = startTime > block.timestamp ? startTime : block.timestamp;\n        pool.endTime = pool.startTime + (programLengthDays * 1 days);\n        pool.depositToken = depositTokenAddress;\n        pool.excessBeneficiary = excessBeneficiary;\n        pool.taxPerCapita = globalTaxPerCapita;\n\n        require(rewardsWeiPerSecondPerToken.length == rewardTokenAddresses.length, 'Rewards and reward token arrays must be same length');\n\n        // fill out the arrays with zeros\n        for (uint i = 0; i < rewardTokenAddresses.length; i++) {\n            pool.rewardTokens.push(rewardTokenAddresses[i]);\n            pool.rewardsWeiClaimed.push(0);\n            pool.rewardFunding.push(0);\n            taxes[numPools].push(0);\n        }\n        pool.maximumDepositWei = maxDeposit;\n\n        // this must be after pool initialization above\n        fundPool(pool.id);\n\n        {\n            Metadata storage metadata = metadatas[numPools];\n            metadata.ipfsHash = ipfsHash;\n            metadata.name = name;\n        }\n        emit PoolAdded(pool.id, name, depositTokenAddress);\n    }\n\n    /// @notice Add funds to a pool\n    /// @dev This function is internal because pools cannot be underfunded, liabilities are known at pool-creation-time\n    /// @param poolId index of pool that is being funded\n    function fundPool(uint poolId) internal {\n        Pool storage pool = pools[poolId];\n        bool success = true;\n        uint amount;\n        for (uint i = 0; i < pool.rewardFunding.length; i++) {\n            amount = getMaximumRewards(poolId, i);\n            // transfer the tokens from pool-creator to this contract\n            success = success && IERC20(pool.rewardTokens[i]).transferFrom(msg.sender, address(this), amount);\n            // bookkeeping to make sure pools don't share tokens\n            pool.rewardFunding[i] += amount;\n        }\n        require(success, 'Token deposits failed');\n    }\n\n    /// @notice Compute the rewards that would be received if the receipt was cashed out now\n    /// @dev This function does not inspect whether the receipt has already been cashed out\n    /// @param poolId which pool are we talking about?\n    /// @param receiptId the id of the receipt that we are querying\n    /// @return rewardsLocal array of rewards, one entry for each reward token\n    function getRewards(uint poolId, uint receiptId) public view returns (uint[] memory) {\n        Pool storage pool = pools[poolId];\n        Receipt memory receipt = pool.receipts[receiptId];\n        require(pool.id == poolId, 'Uninitialized pool');\n        require(receipt.id == receiptId, 'Uninitialized receipt');\n        uint nowish = block.timestamp;\n        if (nowish > pool.endTime) {\n            nowish = pool.endTime;\n        }\n\n        uint secondsDiff = nowish - receipt.timeDeposited;\n        uint[] memory rewardsLocal = new uint[](pool.rewardsWeiPerSecondPerToken.length);\n        for (uint i = 0; i < pool.rewardsWeiPerSecondPerToken.length; i++) {\n            rewardsLocal[i] = (secondsDiff * pool.rewardsWeiPerSecondPerToken[i] * receipt.amountDepositedWei) / 1e18;\n        }\n\n        return rewardsLocal;\n    }\n\n    /// @notice Add funds to a pool\n    /// @dev Anyone may call this function, it simply puts tokens in the pool and returns a receipt\n    /// @dev If deposit amount causes pool to overflow, amount is decreased so pool is full\n    /// @param poolId which pool are we talking about?\n    /// @param amount amount of tokens to deposit\n    function deposit(uint poolId, uint amount) external {\n        Pool storage pool = pools[poolId];\n        require(pool.id == poolId, 'Uninitialized pool');\n        require(block.timestamp > pool.startTime, 'Cannot deposit before pool start');\n        require(block.timestamp < pool.endTime, 'Cannot deposit after pool ends');\n        require(pool.totalDepositsWei < pool.maximumDepositWei, 'Maximum deposit already reached');\n        if (pool.totalDepositsWei + amount > pool.maximumDepositWei) {\n            amount = pool.maximumDepositWei - pool.totalDepositsWei;\n        }\n        pool.totalDepositsWei += amount;\n        pool.numReceipts++;\n\n        Receipt storage receipt = pool.receipts[pool.numReceipts];\n        receipt.id = pool.numReceipts;\n        receipt.amountDepositedWei = amount;\n        receipt.timeDeposited = block.timestamp;\n        receipt.owner = msg.sender;\n\n        bool success = IERC20(pool.depositToken).transferFrom(msg.sender, address(this), amount);\n        require(success, 'Token transfer failed');\n\n        emit DepositOccurred(poolId, pool.numReceipts, msg.sender);\n    }\n\n    /// @notice Withdraw funds from pool\n    /// @dev Only receipt owner may call this function\n    /// @dev If any of the reward tokens are malicious, this function may break\n    /// @param poolId which pool are we talking about?\n    /// @param receiptId which receipt is being cashed in\n    function withdraw(uint poolId, uint receiptId) external {\n        Pool storage pool = pools[poolId];\n        require(pool.id == poolId, 'Uninitialized pool');\n        Receipt storage receipt = pool.receipts[receiptId];\n        require(receipt.id == receiptId, 'Can only withdraw real receipts');\n        require(receipt.owner == msg.sender || block.timestamp > pool.endTime, 'Can only withdraw your own deposit');\n        require(receipt.timeWithdrawn == 0, 'Can only withdraw once per receipt');\n\n        // close re-entry gate\n        receipt.timeWithdrawn = block.timestamp;\n\n        uint[] memory rewards = getRewards(poolId, receiptId);\n        pool.totalDepositsWei -= receipt.amountDepositedWei;\n        bool success = true;\n\n        for (uint i = 0; i < rewards.length; i++) {\n            pool.rewardsWeiClaimed[i] += rewards[i];\n            pool.rewardFunding[i] -= rewards[i];\n            uint tax = (pool.taxPerCapita * rewards[i]) / 1000;\n            uint transferAmount = rewards[i] - tax;\n            taxes[poolId][i] += tax;\n            success = success && IERC20(pool.rewardTokens[i]).transfer(receipt.owner, transferAmount);\n        }\n\n        success = success && IERC20(pool.depositToken).transfer(receipt.owner, receipt.amountDepositedWei);\n        require(success, 'Token transfer failed');\n\n        emit WithdrawalOccurred(poolId, receiptId, receipt.owner);\n    }\n\n    /// @notice Withdraw any unused rewards from the pool, after it has ended\n    /// @dev Anyone can call this, as the excess beneficiary is set at pool-creation-time\n    /// @param poolId which pool are we talking about?\n    function withdrawExcessRewards(uint poolId) external {\n        Pool storage pool = pools[poolId];\n        require(pool.id == poolId, 'Uninitialized pool');\n        require(pool.totalDepositsWei == 0, 'Cannot withdraw until all deposits are withdrawn');\n        require(block.timestamp > pool.endTime, 'Contract must reach maturity');\n\n        bool success = true;\n        for (uint i = 0; i < pool.rewardTokens.length; i++) {\n            uint rewards = pool.rewardFunding[i];\n            pool.rewardFunding[i] = 0;\n            success = success && IERC20(pool.rewardTokens[i]).transfer(pool.excessBeneficiary, rewards);\n        }\n        require(success, 'Token transfer failed');\n        emit ExcessRewardsWithdrawn(poolId);\n    }\n\n    /// @notice Withdraw taxes from pool\n    /// @dev Anyone may call this, it just moves the taxes from this contract to the globalBeneficiary\n    /// @param poolId which pool are we talking about?\n    function withdrawTaxes(uint poolId) external {\n        Pool storage pool = pools[poolId];\n        require(pool.id == poolId, 'Uninitialized pool');\n\n        bool success = true;\n        for (uint i = 0; i < pool.rewardTokens.length; i++) {\n            uint tax = taxes[poolId][i];\n            taxes[poolId][i] = 0;\n            success = success && IERC20(pool.rewardTokens[i]).transfer(globalBeneficiary, tax);\n        }\n        require(success, 'Token transfer failed');\n    }\n\n    /// @notice Compute maximum rewards that could be given out by a given pool\n    /// @dev This is primarily used by fundPool to compute how many tokens to take from the pool-creator\n    /// @param poolId which pool are we talking about?\n    /// @param rewardIndex index into the rewards array, to avoid passing arrays around\n    /// @return maximumRewardAmount the theoretical maximum that will be paid from this reward token, if pool fills instantly\n    function getMaximumRewards(uint poolId, uint rewardIndex) public view returns (uint) {\n        Pool storage pool = pools[poolId];\n        // rewardsPerSecondPerToken * tokens * seconds\n        return pool.rewardsWeiPerSecondPerToken[rewardIndex] * pool.maximumDepositWei * (pool.endTime - pool.startTime) / 1e18;\n    }\n\n    /// @notice Get reward data about a pool\n    /// @dev This gets all the reward-relevant fields from the struct\n    /// @param poolId which pool are we talking about?\n    /// @return rewardsWeiPerSecondPerToken reward slope array\n    /// @return rewardsWeiClaimed rewards already claimed array\n    /// @return rewardTokens array of reward token contract addresses\n    /// @return rewardFunding array of amounts of reward tokens already dispensed\n    function getRewardData(uint poolId) external view returns (uint[] memory, uint[] memory, address[] memory, uint[] memory) {\n        Pool storage pool = pools[poolId];\n        return (pool.rewardsWeiPerSecondPerToken, pool.rewardsWeiClaimed, pool.rewardTokens, pool.rewardFunding);\n    }\n\n    /// @notice Get data about a specific receipt\n    /// @dev This gets all the fields from a receipt\n    /// @param poolId which pool are we talking about?\n    /// @param receiptId which receipt are we talking about?\n    /// @return amountDepositedWei original deposit amount\n    /// @return timeDeposited the time of original deposit\n    /// @return timeWithdrawn time when receipt was cashed in, if ever\n    /// @return owner the beneficiary of the receipt, who deposited the tokens originally?\n    function getReceipt(uint poolId, uint receiptId) external view returns (uint, uint, uint, address) {\n        Pool storage pool = pools[poolId];\n        Receipt storage receipt = pool.receipts[receiptId];\n        return (receipt.amountDepositedWei, receipt.timeDeposited, receipt.timeWithdrawn, receipt.owner);\n    }\n\n    /// @notice Change the fee factor\n    /// @dev This can only be called by the global beneficiary\n    /// @param newTaxPerCapita the new fee\n    function setGlobalTax(uint newTaxPerCapita) external {\n        require(msg.sender == globalBeneficiary, 'Only globalBeneficiary can set tax');\n        require(newTaxPerCapita < 1000, 'Tax too high');\n        globalTaxPerCapita = newTaxPerCapita;\n    }\n}"
    }
  ]
}