{
  "Title": "[01] Inconsistent usage of `hasNotSigned`",
  "Content": "\n`signAndClaimAndRedeem` has the modifier while `signAndClaim` doesn't.\n\n[RariMerkleRedeemer.sol#L108-L118](https://github.com/code-423n4/2022-09-tribe/blob/769b0586b4975270b669d7d1581aa5672d6999d5/contracts/shutdown/fuse/RariMerkleRedeemer.sol#L108-L118)\n\n```solidity\n    function signAndClaimAndRedeem(\n        bytes calldata signature,\n        address[] calldata cTokens,\n        uint256[] calldata amountsToClaim,\n        uint256[] calldata amountsToRedeem,\n        bytes32[][] calldata merkleProofs\n    ) external override hasNotSigned nonReentrant {\n        _sign(signature);\n        _multiClaim(cTokens, amountsToClaim, merkleProofs);\n        _multiRedeem(cTokens, amountsToRedeem);\n    }\n```\n\nDoesn't have the modifier<br>\n[RariMerkleRedeemer.sol#L88-L97](https://github.com/code-423n4/2022-09-tribe/blob/769b0586b4975270b669d7d1581aa5672d6999d5/contracts/shutdown/fuse/RariMerkleRedeemer.sol#L88-L97)\n\n```solidity\n    function signAndClaim(\n        bytes calldata signature,\n        address[] calldata cTokens,\n        uint256[] calldata amounts,\n        bytes32[][] calldata merkleProofs\n    ) external override nonReentrant {\n        // both sign and claim/multiclaim will revert on invalid signatures/proofs\n        _sign(signature);\n        _multiClaim(cTokens, amounts, merkleProofs);\n    }\n```\n\n### Mitigation Steps\n\nAdd the modifier `hasNotSigned` for consistency, or remove the modifier altogether and allow to sign multiple times the same message.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-09-tribe",
  "Code": [
    {
      "filename": "contracts/shutdown/fuse/RariMerkleRedeemer.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity =0.8.10;\n\nimport \"../../refs/CoreRef.sol\";\nimport \"./MultiMerkleRedeemer.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/// @title Contract for exchanging cTokens for a specific base token, permissioned via Merkle Roots\n/// @notice This implementation is specific to the Rari Redemption as described in TIP-121\n/// @dev See MultiMerkleRedeemer natspec for most public functions\n/// @author kryptoklob\ncontract RariMerkleRedeemer is MultiMerkleRedeemer, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    modifier hasSigned() {\n        require(keccak256(userSignatures[msg.sender]) != keccak256(userSignatures[address(0)]), \"User has not signed.\");\n        _;\n    }\n\n    modifier hasNotSigned() {\n        require(\n            keccak256(userSignatures[msg.sender]) == keccak256(userSignatures[address(0)]),\n            \"User has already signed\"\n        );\n        _;\n    }\n\n    /// @param token The token that will be received when exchanging cTokens\n    /// @param cTokens The supported cTokens; must be exactly 27 tokens\n    /// @param rates The exchange rate for each cToken; must be exactly 27 rates\n    /// @param roots The merkle root for each cToken; must be exactly 27 roots\n    constructor(\n        address token,\n        address[] memory cTokens,\n        uint256[] memory rates,\n        bytes32[] memory roots\n    ) {\n        _configureExchangeRates(cTokens, rates);\n        _configureMerkleRoots(cTokens, roots);\n        _configureBaseToken(token);\n    }\n\n    /** ---------- Public State-Changing Funcs ----------------- **/\n\n    function sign(bytes calldata signature) external override hasNotSigned nonReentrant {\n        _sign(signature);\n    }\n\n    function claim(\n        address _cToken,\n        uint256 _amount,\n        bytes32[] calldata _merkleProof\n    ) external override hasSigned nonReentrant {\n        _claim(_cToken, _amount, _merkleProof);\n    }\n\n    function multiClaim(\n        address[] calldata _cTokens,\n        uint256[] calldata _amounts,\n        bytes32[][] calldata _merkleProofs\n    ) external override hasSigned nonReentrant {\n        _multiClaim(_cTokens, _amounts, _merkleProofs);\n    }\n\n    function redeem(address cToken, uint256 cTokenAmount) external override hasSigned nonReentrant {\n        _redeem(cToken, cTokenAmount);\n    }\n\n    function multiRedeem(address[] calldata cTokens, uint256[] calldata cTokenAmounts)\n        external\n        override\n        hasSigned\n        nonReentrant\n    {\n        _multiRedeem(cTokens, cTokenAmounts);\n    }\n\n    function previewRedeem(address cToken, uint256 amount) public view override returns (uint256 baseTokenAmount) {\n        // Each ctoken exchange rate is stored as how much you should get for 1e18 of the particular cToken\n        // Thus, we divide by 1e18 when returning the amount that a person should get when they provide\n        // the amount of cTokens they're turning into the contract\n        return (cTokenExchangeRates[cToken] * amount) / 1e18;\n    }\n\n    function signAndClaim(\n        bytes calldata signature,\n        address[] calldata cTokens,\n        uint256[] calldata amounts,\n        bytes32[][] calldata merkleProofs\n    ) external override nonReentrant {\n        // both sign and claim/multiclaim will revert on invalid signatures/proofs\n        _sign(signature);\n        _multiClaim(cTokens, amounts, merkleProofs);\n    }\n\n    function claimAndRedeem(\n        address[] calldata cTokens,\n        uint256[] calldata amounts,\n        bytes32[][] calldata merkleProofs\n    ) external hasSigned nonReentrant {\n        _multiClaim(cTokens, amounts, merkleProofs);\n        _multiRedeem(cTokens, amounts);\n    }\n\n    function signAndClaimAndRedeem(\n        bytes calldata signature,\n        address[] calldata cTokens,\n        uint256[] calldata amountsToClaim,\n        uint256[] calldata amountsToRedeem,\n        bytes32[][] calldata merkleProofs\n    ) external override hasNotSigned nonReentrant {\n        _sign(signature);\n        _multiClaim(cTokens, amountsToClaim, merkleProofs);\n        _multiRedeem(cTokens, amountsToRedeem);\n    }\n\n    /** ---------- Internal Funcs --------------- **/\n\n    // The exchange rates provided should represent how much of the base token will be given\n    // in exchange for 1e18 cTokens. This increases precision.\n    function _configureExchangeRates(address[] memory _cTokens, uint256[] memory _exchangeRates) internal {\n        require(_cTokens.length == 27, \"Must provide exactly 27 exchange rates.\");\n        require(_cTokens.length == _exchangeRates.length, \"Exchange rates must be provided for each cToken\");\n\n        for (uint256 i = 0; i < _cTokens.length; i++) {\n            require(\n                _exchangeRates[i] > 1e10,\n                \"Exchange rate must be greater than 1e10. Did you forget to multiply by 1e18?\"\n            );\n            cTokenExchangeRates[_cTokens[i]] = _exchangeRates[i];\n        }\n    }\n\n    function _configureMerkleRoots(address[] memory _cTokens, bytes32[] memory _roots) internal {\n        require(_cTokens.length == 27, \"Must provide exactly 27 merkle roots\");\n        require(_cTokens.length == _roots.length, \"Merkle roots must be provided for each cToken\");\n\n        for (uint256 i = 0; i < _cTokens.length; i++) {\n            require(_roots[i] != bytes32(0), \"Merkle root must be non-zero\");\n            merkleRoots[_cTokens[i]] = _roots[i];\n        }\n    }\n\n    function _configureBaseToken(address _baseToken) internal {\n        require(_baseToken != address(0), \"Base token must be non-zero\");\n        baseToken = _baseToken;\n    }\n\n    // User provides signature, which is checked against their address and the string constant \"message\"\n    function _sign(bytes calldata _signature) internal virtual {\n        // check: to ensure the signature is a valid signature for the constant message string from msg.sender\n        require(ECDSA.recover(MESSAGE_HASH, _signature) == msg.sender, \"Signature not valid\");\n\n        // effect: update user's stored signature\n        userSignatures[msg.sender] = _signature;\n\n        emit Signed(msg.sender, _signature);\n    }\n\n    // User provides the the cToken & the amount they should get, and it is verified against the merkle root for that cToken\n    /// Should set the user's claim amount int he claims mapping for the provided cToken\n    function _claim(\n        address _cToken,\n        uint256 _amount,\n        bytes32[] calldata _merkleProof\n    ) internal virtual {\n        // check: verify that claimableAmount is zero, revert if not\n        require(claims[msg.sender][_cToken] == 0, \"User has already claimed for this cToken.\");\n\n        // check: verify cToken and amount and msg.sender against merkle root\n        bytes32 leafHash = keccak256(abi.encodePacked(msg.sender, _amount));\n        require(MerkleProof.verifyCalldata(_merkleProof, merkleRoots[_cToken], leafHash), \"Merkle proof not valid.\");\n\n        // effect: update claimableAmount for the user\n        claims[msg.sender][_cToken] = _amount;\n\n        emit Claimed(msg.sender, _cToken, _amount);\n    }\n\n    // User provides the cTokens & the amounts they should get, and it is verified against the merkle root for that cToken (for each cToken provided)\n    // Should set the user's claim amount in the claims mapping for each cToken provided\n    function _multiClaim(\n        address[] calldata _cTokens,\n        uint256[] calldata _amounts,\n        bytes32[][] calldata _merkleProofs\n    ) internal virtual {\n        require(_cTokens.length == _amounts.length, \"Number of cTokens and amounts must match\");\n        require(_cTokens.length == _merkleProofs.length, \"Number of cTokens and merkle proofs must match\");\n\n        for (uint256 i = 0; i < _cTokens.length; i++) {\n            _claim(_cTokens[i], _amounts[i], _merkleProofs[i]);\n        }\n\n        // no events needed here, they happen in _claim\n    }\n\n    // Transfers in a particular amount of the user's cToken, and increments their redeemed amount in the redemption mapping\n    function _redeem(address cToken, uint256 cTokenAmount) internal virtual {\n        // check: amount must be greater than 0\n        require(cTokenAmount != 0, \"Invalid amount\");\n\n        // check: verify that the user's claimedAmount+amount of this cToken doesn't exceed claimableAmount for this cToken\n        require(\n            redemptions[msg.sender][cToken] + cTokenAmount <= claims[msg.sender][cToken],\n            \"Amount exceeds available remaining claim.\"\n        );\n\n        // effect: increment the user's claimedAmount\n        redemptions[msg.sender][cToken] += cTokenAmount;\n\n        uint256 baseTokenAmountReceived = previewRedeem(cToken, cTokenAmount);\n\n        // interaction: safeTransferFrom the user \"amount\" of \"cToken\" to this contract\n        IERC20(cToken).safeTransferFrom(msg.sender, address(this), cTokenAmount);\n        IERC20(baseToken).safeTransfer(msg.sender, baseTokenAmountReceived);\n\n        emit Redeemed(msg.sender, cToken, cTokenAmount, baseTokenAmountReceived);\n    }\n\n    // Plural form of _redeem\n    // Doesn't actually call _redeem so that we can separate out the interactions into their own section\n    function _multiRedeem(address[] calldata cTokens, uint256[] calldata cTokenAmounts) internal virtual {\n        // check : cTokens.length must equal amounts.length\n        require(cTokens.length == cTokenAmounts.length, \"Length of cTokens and amounts must match.\");\n\n        for (uint256 i = 0; i < cTokens.length; i++) {\n            // check: cToken cannot be the zero address\n            require(cTokens[i] != address(0), \"Invalid cToken address\");\n\n            // check: amount must be greater than 0\n            require(cTokenAmounts[i] != 0, \"Invalid amount\");\n\n            // check: amount is less than or equal to the user's claimableAmount-claimedAmount for this cToken\n            require(\n                redemptions[msg.sender][cTokens[i]] + cTokenAmounts[i] <= claims[msg.sender][cTokens[i]],\n                \"Amount exceeds available remaining claim.\"\n            );\n\n            // effect: increment the user's claimedAmount\n            redemptions[msg.sender][cTokens[i]] += cTokenAmounts[i];\n        }\n\n        // We give the interactions (the safeTransferFroms) their own for loop, juuuuust to be safe\n        for (uint256 i = 0; i < cTokens.length; i++) {\n            uint256 baseTokenAmountReceived = previewRedeem(cTokens[i], cTokenAmounts[i]);\n            IERC20(cTokens[i]).safeTransferFrom(msg.sender, address(this), cTokenAmounts[i]);\n            IERC20(baseToken).safeTransfer(msg.sender, baseTokenAmountReceived);\n            emit Redeemed(msg.sender, cTokens[i], cTokenAmounts[i], baseTokenAmountReceived);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/shutdown/fuse/RariMerkleRedeemer.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity =0.8.10;\n\nimport \"../../refs/CoreRef.sol\";\nimport \"./MultiMerkleRedeemer.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/// @title Contract for exchanging cTokens for a specific base token, permissioned via Merkle Roots\n/// @notice This implementation is specific to the Rari Redemption as described in TIP-121\n/// @dev See MultiMerkleRedeemer natspec for most public functions\n/// @author kryptoklob\ncontract RariMerkleRedeemer is MultiMerkleRedeemer, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    modifier hasSigned() {\n        require(keccak256(userSignatures[msg.sender]) != keccak256(userSignatures[address(0)]), \"User has not signed.\");\n        _;\n    }\n\n    modifier hasNotSigned() {\n        require(\n            keccak256(userSignatures[msg.sender]) == keccak256(userSignatures[address(0)]),\n            \"User has already signed\"\n        );\n        _;\n    }\n\n    /// @param token The token that will be received when exchanging cTokens\n    /// @param cTokens The supported cTokens; must be exactly 27 tokens\n    /// @param rates The exchange rate for each cToken; must be exactly 27 rates\n    /// @param roots The merkle root for each cToken; must be exactly 27 roots\n    constructor(\n        address token,\n        address[] memory cTokens,\n        uint256[] memory rates,\n        bytes32[] memory roots\n    ) {\n        _configureExchangeRates(cTokens, rates);\n        _configureMerkleRoots(cTokens, roots);\n        _configureBaseToken(token);\n    }\n\n    /** ---------- Public State-Changing Funcs ----------------- **/\n\n    function sign(bytes calldata signature) external override hasNotSigned nonReentrant {\n        _sign(signature);\n    }\n\n    function claim(\n        address _cToken,\n        uint256 _amount,\n        bytes32[] calldata _merkleProof\n    ) external override hasSigned nonReentrant {\n        _claim(_cToken, _amount, _merkleProof);\n    }\n\n    function multiClaim(\n        address[] calldata _cTokens,\n        uint256[] calldata _amounts,\n        bytes32[][] calldata _merkleProofs\n    ) external override hasSigned nonReentrant {\n        _multiClaim(_cTokens, _amounts, _merkleProofs);\n    }\n\n    function redeem(address cToken, uint256 cTokenAmount) external override hasSigned nonReentrant {\n        _redeem(cToken, cTokenAmount);\n    }\n\n    function multiRedeem(address[] calldata cTokens, uint256[] calldata cTokenAmounts)\n        external\n        override\n        hasSigned\n        nonReentrant\n    {\n        _multiRedeem(cTokens, cTokenAmounts);\n    }\n\n    function previewRedeem(address cToken, uint256 amount) public view override returns (uint256 baseTokenAmount) {\n        // Each ctoken exchange rate is stored as how much you should get for 1e18 of the particular cToken\n        // Thus, we divide by 1e18 when returning the amount that a person should get when they provide\n        // the amount of cTokens they're turning into the contract\n        return (cTokenExchangeRates[cToken] * amount) / 1e18;\n    }\n\n    function signAndClaim(\n        bytes calldata signature,\n        address[] calldata cTokens,\n        uint256[] calldata amounts,\n        bytes32[][] calldata merkleProofs\n    ) external override nonReentrant {\n        // both sign and claim/multiclaim will revert on invalid signatures/proofs\n        _sign(signature);\n        _multiClaim(cTokens, amounts, merkleProofs);\n    }\n\n    function claimAndRedeem(\n        address[] calldata cTokens,\n        uint256[] calldata amounts,\n        bytes32[][] calldata merkleProofs\n    ) external hasSigned nonReentrant {\n        _multiClaim(cTokens, amounts, merkleProofs);\n        _multiRedeem(cTokens, amounts);\n    }\n\n    function signAndClaimAndRedeem(\n        bytes calldata signature,\n        address[] calldata cTokens,\n        uint256[] calldata amountsToClaim,\n        uint256[] calldata amountsToRedeem,\n        bytes32[][] calldata merkleProofs\n    ) external override hasNotSigned nonReentrant {\n        _sign(signature);\n        _multiClaim(cTokens, amountsToClaim, merkleProofs);\n        _multiRedeem(cTokens, amountsToRedeem);\n    }\n\n    /** ---------- Internal Funcs --------------- **/\n\n    // The exchange rates provided should represent how much of the base token will be given\n    // in exchange for 1e18 cTokens. This increases precision.\n    function _configureExchangeRates(address[] memory _cTokens, uint256[] memory _exchangeRates) internal {\n        require(_cTokens.length == 27, \"Must provide exactly 27 exchange rates.\");\n        require(_cTokens.length == _exchangeRates.length, \"Exchange rates must be provided for each cToken\");\n\n        for (uint256 i = 0; i < _cTokens.length; i++) {\n            require(\n                _exchangeRates[i] > 1e10,\n                \"Exchange rate must be greater than 1e10. Did you forget to multiply by 1e18?\"\n            );\n            cTokenExchangeRates[_cTokens[i]] = _exchangeRates[i];\n        }\n    }\n\n    function _configureMerkleRoots(address[] memory _cTokens, bytes32[] memory _roots) internal {\n        require(_cTokens.length == 27, \"Must provide exactly 27 merkle roots\");\n        require(_cTokens.length == _roots.length, \"Merkle roots must be provided for each cToken\");\n\n        for (uint256 i = 0; i < _cTokens.length; i++) {\n            require(_roots[i] != bytes32(0), \"Merkle root must be non-zero\");\n            merkleRoots[_cTokens[i]] = _roots[i];\n        }\n    }\n\n    function _configureBaseToken(address _baseToken) internal {\n        require(_baseToken != address(0), \"Base token must be non-zero\");\n        baseToken = _baseToken;\n    }\n\n    // User provides signature, which is checked against their address and the string constant \"message\"\n    function _sign(bytes calldata _signature) internal virtual {\n        // check: to ensure the signature is a valid signature for the constant message string from msg.sender\n        require(ECDSA.recover(MESSAGE_HASH, _signature) == msg.sender, \"Signature not valid\");\n\n        // effect: update user's stored signature\n        userSignatures[msg.sender] = _signature;\n\n        emit Signed(msg.sender, _signature);\n    }\n\n    // User provides the the cToken & the amount they should get, and it is verified against the merkle root for that cToken\n    /// Should set the user's claim amount int he claims mapping for the provided cToken\n    function _claim(\n        address _cToken,\n        uint256 _amount,\n        bytes32[] calldata _merkleProof\n    ) internal virtual {\n        // check: verify that claimableAmount is zero, revert if not\n        require(claims[msg.sender][_cToken] == 0, \"User has already claimed for this cToken.\");\n\n        // check: verify cToken and amount and msg.sender against merkle root\n        bytes32 leafHash = keccak256(abi.encodePacked(msg.sender, _amount));\n        require(MerkleProof.verifyCalldata(_merkleProof, merkleRoots[_cToken], leafHash), \"Merkle proof not valid.\");\n\n        // effect: update claimableAmount for the user\n        claims[msg.sender][_cToken] = _amount;\n\n        emit Claimed(msg.sender, _cToken, _amount);\n    }\n\n    // User provides the cTokens & the amounts they should get, and it is verified against the merkle root for that cToken (for each cToken provided)\n    // Should set the user's claim amount in the claims mapping for each cToken provided\n    function _multiClaim(\n        address[] calldata _cTokens,\n        uint256[] calldata _amounts,\n        bytes32[][] calldata _merkleProofs\n    ) internal virtual {\n        require(_cTokens.length == _amounts.length, \"Number of cTokens and amounts must match\");\n        require(_cTokens.length == _merkleProofs.length, \"Number of cTokens and merkle proofs must match\");\n\n        for (uint256 i = 0; i < _cTokens.length; i++) {\n            _claim(_cTokens[i], _amounts[i], _merkleProofs[i]);\n        }\n\n        // no events needed here, they happen in _claim\n    }\n\n    // Transfers in a particular amount of the user's cToken, and increments their redeemed amount in the redemption mapping\n    function _redeem(address cToken, uint256 cTokenAmount) internal virtual {\n        // check: amount must be greater than 0\n        require(cTokenAmount != 0, \"Invalid amount\");\n\n        // check: verify that the user's claimedAmount+amount of this cToken doesn't exceed claimableAmount for this cToken\n        require(\n            redemptions[msg.sender][cToken] + cTokenAmount <= claims[msg.sender][cToken],\n            \"Amount exceeds available remaining claim.\"\n        );\n\n        // effect: increment the user's claimedAmount\n        redemptions[msg.sender][cToken] += cTokenAmount;\n\n        uint256 baseTokenAmountReceived = previewRedeem(cToken, cTokenAmount);\n\n        // interaction: safeTransferFrom the user \"amount\" of \"cToken\" to this contract\n        IERC20(cToken).safeTransferFrom(msg.sender, address(this), cTokenAmount);\n        IERC20(baseToken).safeTransfer(msg.sender, baseTokenAmountReceived);\n\n        emit Redeemed(msg.sender, cToken, cTokenAmount, baseTokenAmountReceived);\n    }\n\n    // Plural form of _redeem\n    // Doesn't actually call _redeem so that we can separate out the interactions into their own section\n    function _multiRedeem(address[] calldata cTokens, uint256[] calldata cTokenAmounts) internal virtual {\n        // check : cTokens.length must equal amounts.length\n        require(cTokens.length == cTokenAmounts.length, \"Length of cTokens and amounts must match.\");\n\n        for (uint256 i = 0; i < cTokens.length; i++) {\n            // check: cToken cannot be the zero address\n            require(cTokens[i] != address(0), \"Invalid cToken address\");\n\n            // check: amount must be greater than 0\n            require(cTokenAmounts[i] != 0, \"Invalid amount\");\n\n            // check: amount is less than or equal to the user's claimableAmount-claimedAmount for this cToken\n            require(\n                redemptions[msg.sender][cTokens[i]] + cTokenAmounts[i] <= claims[msg.sender][cTokens[i]],\n                \"Amount exceeds available remaining claim.\"\n            );\n\n            // effect: increment the user's claimedAmount\n            redemptions[msg.sender][cTokens[i]] += cTokenAmounts[i];\n        }\n\n        // We give the interactions (the safeTransferFroms) their own for loop, juuuuust to be safe\n        for (uint256 i = 0; i < cTokens.length; i++) {\n            uint256 baseTokenAmountReceived = previewRedeem(cTokens[i], cTokenAmounts[i]);\n            IERC20(cTokens[i]).safeTransferFrom(msg.sender, address(this), cTokenAmounts[i]);\n            IERC20(baseToken).safeTransfer(msg.sender, baseTokenAmountReceived);\n            emit Redeemed(msg.sender, cTokens[i], cTokenAmounts[i], baseTokenAmountReceived);\n        }\n    }\n}"
    }
  ]
}