{
  "Title": "[L-07] Allow specifying `maximumPrice` for individual NFTs",
  "Content": "Currently it is only possible to specify a single `maximumPrice` for all NFTs in the `CollectionBatchBuyOperator` contract ([Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/operators/CollectionBatchBuyOperator.sol#L25-L26)).  \n\nI recommend that it should be possible to specify a `maximumPrice` for each NFT individually. Thereby it's possible for the party to enforce tighter limits to the amount of ETH that the executor can spend.  \n\nFor example the NFT with `id=1` might require a maximum price of `1 ETH` whereas for another NFT with `id=2` a maximum price of `0.1 ETH` can be sufficient.  \n\nCurrently both NFTs can only have the same maximum price and the executor is able to spend `2 ETH` at a maximum. This could be further restricted to minimize the trust that needs to be put into the executor.  \n\nThis can be implemented by introducing a new `mapping(uint256 => uint256) maximumPrices` mapping. If the entry for an NFT is `!= 0` it should be used as the maximum price. Otherwise `maximumPrice` can be used as a fallback.  \n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-04-party",
  "Code": [
    {
      "filename": "contracts/operators/CollectionBatchBuyOperator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./IOperator.sol\";\nimport \"../party/Party.sol\";\nimport \"../tokens/IERC721.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/LibAddress.sol\";\nimport \"../utils/LibSafeERC721.sol\";\nimport \"openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\n/// @notice A crowdfund that purchases a specific NFT (i.e., with a known token\n///         ID) listing for a known price.\ncontract CollectionBatchBuyOperator is IOperator {\n    using LibRawResult for bytes;\n    using LibSafeERC721 for IERC721;\n    using LibAddress for address payable;\n\n    struct CollectionBatchBuyOperationData {\n        /// The contract of NFTs to buy.\n        IERC721 nftContract;\n        /// The merkle root of the token IDs that can be bought. If null,\n        /// allow any token ID in the collection can be bought.\n        bytes32 nftTokenIdsMerkleRoot;\n        // Maximum amount this crowdfund will pay for an NFT.\n        uint256 maximumPrice;\n        // Minimum number of tokens that must be purchased. If this limit is\n        // not reached, the batch buy will fail.\n        uint256 minTokensBought;\n        // Minimum amount of ETH that must be used to buy the tokens. If this\n        // amount is not reached, the batch buy will fail.\n        uint256 minTotalEthUsed;\n    }\n\n    struct TokenToBuy {\n        // The token ID of the NFT to buy.\n        uint256 tokenId;\n        // The price of the token. This cannot be greater than `maximumPrice`.\n        uint96 price;\n        // The proof needed to verify that the token ID is included in the\n        // `nftTokenIdsMerkleRoot` (if it is not null).\n        bytes32[] proof;\n    }\n\n    struct BuyCall {\n        // The contract to call to buy the NFTs in `tokensToBuy`.\n        address payable target;\n        // The calldata to call `target` with to buy the NFTs in `tokensToBuy`.\n        bytes data;\n        // The tokens to try buying with this call.\n        TokenToBuy[] tokensToBuy;\n    }\n\n    struct CollectionBatchBuyExecutionData {\n        // The calls made to buy the NFTs. Each call has a target, data, and\n        // the tokens to buy in that call.\n        BuyCall[] calls;\n        // The total number of tokens that can be bought in this batch buy. This\n        // should be equal to the sum of the each `tokensToBuy` in `calls`.\n        uint256 numOfTokens;\n    }\n\n    event CollectionBatchBuyOperationExecuted(\n        Party party,\n        IERC721 token,\n        uint256[] tokenIdsBought,\n        uint256 totalEthUsed\n    );\n\n    error NothingBoughtError();\n    error InvalidMinTokensBoughtError(uint256 minTokensBought);\n    error InvalidTokenIdError();\n    error NotEnoughTokensBoughtError(uint256 tokensBought, uint256 minTokensBought);\n    error NotEnoughEthUsedError(uint256 ethUsed, uint256 minTotalEthUsed);\n    error MaximumPriceError(uint256 callValue, uint256 maximumPrice);\n    error CallProhibitedError(address target, bytes data);\n    error NumOfTokensCannotBeLessThanMin(uint256 numOfTokens, uint256 min);\n    error EthUsedForFailedBuyError(uint256 expectedEthUsed, uint256 actualEthUsed);\n\n    function execute(bytes memory operatorData, bytes memory executionData) external payable {\n        // Decode the operator data.\n        CollectionBatchBuyOperationData memory op = abi.decode(\n            operatorData,\n            (CollectionBatchBuyOperationData)\n        );\n\n        // Decode the execution data.\n        CollectionBatchBuyExecutionData memory ex = abi.decode(\n            executionData,\n            (CollectionBatchBuyExecutionData)\n        );\n\n        if (op.minTokensBought == 0) {\n            // Must buy at least one token.\n            revert InvalidMinTokensBoughtError(0);\n        }\n\n        if (ex.numOfTokens < op.minTokensBought) {\n            // The number of tokens to buy must be greater than or equal to the\n            // minimum number of tokens to buy.\n            revert NumOfTokensCannotBeLessThanMin(ex.numOfTokens, op.minTokensBought);\n        }\n\n        // Lengths of arrays are updated at the end.\n        uint256[] memory tokenIds = new uint256[](ex.numOfTokens);\n\n        uint96 totalEthUsed;\n        uint256 tokensBought;\n        for (uint256 i; i < ex.calls.length; ++i) {\n            BuyCall memory call = ex.calls[i];\n\n            uint96 callValue;\n            for (uint256 j; j < call.tokensToBuy.length; ++j) {\n                TokenToBuy memory tokenToBuy = call.tokensToBuy[j];\n\n                if (op.nftTokenIdsMerkleRoot != bytes32(0)) {\n                    // Verify the token ID is in the merkle tree.\n                    _verifyTokenId(tokenToBuy.tokenId, op.nftTokenIdsMerkleRoot, tokenToBuy.proof);\n                }\n\n                // Check that the call value is under the maximum price.\n                uint96 price = tokenToBuy.price;\n                if (price > op.maximumPrice) {\n                    revert MaximumPriceError(price, op.maximumPrice);\n                }\n\n                // Add the price to the total value used for the call.\n                callValue += price;\n            }\n\n            uint256 balanceBefore = address(this).balance;\n            {\n                // Execute the call to buy the NFT.\n                (bool success, ) = _buy(call.target, callValue, call.data);\n\n                if (!success) continue;\n            }\n\n            {\n                uint96 ethUsed;\n                for (uint256 j; j < call.tokensToBuy.length; ++j) {\n                    uint256 tokenId = call.tokensToBuy[j].tokenId;\n                    uint96 price = call.tokensToBuy[j].price;\n\n                    // Check whether the NFT was successfully bought.\n                    if (op.nftContract.safeOwnerOf(tokenId) == address(this)) {\n                        ethUsed += price;\n                        ++tokensBought;\n\n                        // Add the token to the list of tokens to finalize.\n                        tokenIds[tokensBought - 1] = tokenId;\n                    }\n                }\n\n                // Check ETH spent for call is what was expected.\n                uint256 actualEthUsed = balanceBefore - address(this).balance;\n                if (ethUsed != actualEthUsed) {\n                    revert EthUsedForFailedBuyError(ethUsed, actualEthUsed);\n                }\n\n                totalEthUsed += ethUsed;\n            }\n        }\n\n        // This is to prevent this crowdfund from finalizing a loss if nothing\n        // was attempted to be bought (ie. `tokenIds` is empty) or all NFTs were\n        // bought for free.\n        if (totalEthUsed == 0) revert NothingBoughtError();\n\n        // Check number of tokens bought is not less than the minimum.\n        if (tokensBought < op.minTokensBought) {\n            revert NotEnoughTokensBoughtError(tokensBought, op.minTokensBought);\n        }\n\n        // Check total ETH used is not less than the minimum.\n        if (totalEthUsed < op.minTotalEthUsed) {\n            revert NotEnoughEthUsedError(totalEthUsed, op.minTotalEthUsed);\n        }\n\n        assembly {\n            // Update length of `tokenIds`\n            mstore(mload(ex), tokensBought)\n        }\n\n        // Transfer the NFTs to the party.\n        for (uint256 i; i < tokenIds.length; ++i) {\n            op.nftContract.safeTransferFrom(address(this), msg.sender, tokenIds[i]);\n        }\n\n        // Transfer unused ETH to the party.\n        uint256 unusedEth = msg.value - totalEthUsed;\n        if (unusedEth > 0) payable(msg.sender).transferEth(unusedEth);\n\n        emit CollectionBatchBuyOperationExecuted(\n            Party(payable(msg.sender)),\n            op.nftContract,\n            tokenIds,\n            totalEthUsed\n        );\n    }\n\n    function _buy(\n        address payable callTarget,\n        uint96 callValue,\n        bytes memory callData\n    ) private returns (bool success, bytes memory revertData) {\n        // Check that call is not re-entering.\n        if (callTarget == address(this)) {\n            revert CallProhibitedError(callTarget, callData);\n        }\n        // Execute the call to buy the NFT.\n        (success, revertData) = callTarget.call{ value: callValue }(callData);\n    }\n\n    function _verifyTokenId(uint256 tokenId, bytes32 root, bytes32[] memory proof) private pure {\n        bytes32 leaf;\n        assembly {\n            mstore(0x00, tokenId)\n            leaf := keccak256(0x00, 0x20)\n        }\n\n        if (!MerkleProof.verify(proof, root, leaf)) revert InvalidTokenIdError();\n    }\n}"
    }
  ]
}