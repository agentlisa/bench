{
  "Title": "[L20] Deployment risks",
  "Content": "The following contracts have a public initializer function:\n\n\n* [`OVM_L1CrossDomainMessenger`](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/bridge/messaging/OVM_L1CrossDomainMessenger.sol#L45)\n* [`Abs_L2DepositedToken`](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/bridge/tokens/Abs_L2DepositedToken.sol#L59)\n* [`OVM_L1ETHGateway`](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/bridge/tokens/OVM_L1ETHGateway.sol#L55)\n* [`OVM_DeployerWhitelist`](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/predeploys/OVM_DeployerWhitelist.sol#L63)\n* [`OVM_ProxySequencerEntrypoint`](https://github.com/ben-chain/contracts-v2/blob/bc2995d9f4f00fb369d1868e81af9197113aaab9/contracts/optimistic-ethereum/OVM/predeploys/OVM_ProxySequencerEntrypoint.sol#L37)\n\n\nIn all cases, the first account to invoke the initializer is not authenticated and can set sensitive parameters, which leaves them open to potential front-running attacks that could invalidate the contracts. We understand that this is particularly relevant for the token bridge contracts, because the Optimism team intends to provide a factory that programmatically creates the contracts and adds them to a registry, so if a particular token bridge is invalidated, it may not be recoverable.\n\n\nOne reason for this pattern is that contracts may have circular deployment dependencies, which means some contracts have to be deployed before their dependencies. Nevertheless, since contract addresses are created deterministically, it should still be possible to predict all addresses before the deployment, and pass them to the relevant constructors. Consider using this method where appropriate to mitigate the risk of front-running during initial configuration transactions. Alternatively, consider implementing access controls to the initializer functions.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/optimistic-ethereum/OVM/bridge/messaging/OVM_L1CrossDomainMessenger.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\n/* Library Imports */\nimport { Lib_OVMCodec } from \"../../../libraries/codec/Lib_OVMCodec.sol\";\nimport { Lib_AddressResolver } from \"../../../libraries/resolver/Lib_AddressResolver.sol\";\nimport { Lib_AddressManager } from \"../../../libraries/resolver/Lib_AddressManager.sol\";\nimport { Lib_SecureMerkleTrie } from \"../../../libraries/trie/Lib_SecureMerkleTrie.sol\";\nimport { Lib_ReentrancyGuard } from \"../../../libraries/utils/Lib_ReentrancyGuard.sol\";\n\n/* Interface Imports */\nimport { iOVM_L1CrossDomainMessenger } from \"../../../iOVM/bridge/messaging/iOVM_L1CrossDomainMessenger.sol\";\nimport { iOVM_CanonicalTransactionChain } from \"../../../iOVM/chain/iOVM_CanonicalTransactionChain.sol\";\nimport { iOVM_StateCommitmentChain } from \"../../../iOVM/chain/iOVM_StateCommitmentChain.sol\";\n\n/* Contract Imports */\nimport { Abs_BaseCrossDomainMessenger } from \"./Abs_BaseCrossDomainMessenger.sol\";\n\n/**\n * @title OVM_L1CrossDomainMessenger\n * @dev The L1 Cross Domain Messenger contract sends messages from L1 to L2, and relays messages from L2 onto L1.\n * In the event that a message sent from L1 to L2 is rejected for exceeding the L2 epoch gas limit, it can be resubmitted\n * via this contract's replay function.\n *\n * Compiler used: solc\n * Runtime target: EVM\n */\ncontract OVM_L1CrossDomainMessenger is iOVM_L1CrossDomainMessenger, Abs_BaseCrossDomainMessenger, Lib_AddressResolver {\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * Pass a default zero address to the address resolver. This will be updated when initialized.\n     */\n    constructor()\n        Lib_AddressResolver(address(0))\n    {}\n\n    /**\n     * @param _libAddressManager Address of the Address Manager.\n     */\n    function initialize(\n        address _libAddressManager\n    )\n        public\n    {\n        require(address(libAddressManager) == address(0), \"L1CrossDomainMessenger already intialized.\");\n        libAddressManager = Lib_AddressManager(_libAddressManager);\n        xDomainMsgSender = DEFAULT_XDOMAIN_SENDER;\n    }\n\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    /**\n     * Modifier to enforce that, if configured, only the OVM_L2MessageRelayer contract may successfully call a method.\n     */\n    modifier onlyRelayer() {\n        address relayer = resolve(\"OVM_L2MessageRelayer\");\n        if (relayer != address(0)) {\n            require(\n                msg.sender == relayer,\n                \"Only OVM_L2MessageRelayer can relay L2-to-L1 messages.\"\n            );\n        }\n        _;\n    }\n\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Relays a cross domain message to a contract.\n     * @inheritdoc iOVM_L1CrossDomainMessenger\n     */\n    function relayMessage(\n        address _target,\n        address _sender,\n        bytes memory _message,\n        uint256 _messageNonce,\n        L2MessageInclusionProof memory _proof\n    )\n        override\n        public\n        nonReentrant\n        onlyRelayer()\n    {\n        bytes memory xDomainCalldata = _getXDomainCalldata(\n            _target,\n            _sender,\n            _message,\n            _messageNonce\n        );\n\n        require(\n            _verifyXDomainMessage(\n                xDomainCalldata,\n                _proof\n            ) == true,\n            \"Provided message could not be verified.\"\n        );\n\n        bytes32 xDomainCalldataHash = keccak256(xDomainCalldata);\n\n        require(\n            successfulMessages[xDomainCalldataHash] == false,\n            \"Provided message has already been received.\"\n        );\n\n        xDomainMsgSender = _sender;\n        (bool success, ) = _target.call(_message);\n        xDomainMsgSender = DEFAULT_XDOMAIN_SENDER;\n\n        // Mark the message as received if the call was successful. Ensures that a message can be\n        // relayed multiple times in the case that the call reverted.\n        if (success == true) {\n            successfulMessages[xDomainCalldataHash] = true;\n            emit RelayedMessage(xDomainCalldataHash);\n        }\n\n        // Store an identifier that can be used to prove that the given message was relayed by some\n        // user. Gives us an easy way to pay relayers for their work.\n        bytes32 relayId = keccak256(\n            abi.encodePacked(\n                xDomainCalldata,\n                msg.sender,\n                block.number\n            )\n        );\n        relayedMessages[relayId] = true;\n    }\n\n    /**\n     * Replays a cross domain message to the target messenger.\n     * @inheritdoc iOVM_L1CrossDomainMessenger\n     */\n    function replayMessage(\n        address _target,\n        address _sender,\n        bytes memory _message,\n        uint256 _messageNonce,\n        uint32 _gasLimit\n    )\n        override\n        public\n    {\n        bytes memory xDomainCalldata = _getXDomainCalldata(\n            _target,\n            _sender,\n            _message,\n            _messageNonce\n        );\n\n        require(\n            sentMessages[keccak256(xDomainCalldata)] == true,\n            \"Provided message has not already been sent.\"\n        );\n\n        _sendXDomainMessage(xDomainCalldata, _gasLimit);\n    }\n\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Verifies that the given message is valid.\n     * @param _xDomainCalldata Calldata to verify.\n     * @param _proof Inclusion proof for the message.\n     * @return Whether or not the provided message is valid.\n     */\n    function _verifyXDomainMessage(\n        bytes memory _xDomainCalldata,\n        L2MessageInclusionProof memory _proof\n    )\n        internal\n        view\n        returns (\n            bool\n        )\n    {\n        return (\n            _verifyStateRootProof(_proof)\n            && _verifyStorageProof(_xDomainCalldata, _proof)\n        );\n    }\n\n    /**\n     * Verifies that the state root within an inclusion proof is valid.\n     * @param _proof Message inclusion proof.\n     * @return Whether or not the provided proof is valid.\n     */\n    function _verifyStateRootProof(\n        L2MessageInclusionProof memory _proof\n    )\n        internal\n        view\n        returns (\n            bool\n        )\n    {\n        iOVM_StateCommitmentChain ovmStateCommitmentChain = iOVM_StateCommitmentChain(resolve(\"OVM_StateCommitmentChain\"));\n\n        return (\n            ovmStateCommitmentChain.insideFraudProofWindow(_proof.stateRootBatchHeader) == false\n            && ovmStateCommitmentChain.verifyStateCommitment(\n                _proof.stateRoot,\n                _proof.stateRootBatchHeader,\n                _proof.stateRootProof\n            )\n        );\n    }\n\n    /**\n     * Verifies that the storage proof within an inclusion proof is valid.\n     * @param _xDomainCalldata Encoded message calldata.\n     * @param _proof Message inclusion proof.\n     * @return Whether or not the provided proof is valid.\n     */\n    function _verifyStorageProof(\n        bytes memory _xDomainCalldata,\n        L2MessageInclusionProof memory _proof\n    )\n        internal\n        view\n        returns (\n            bool\n        )\n    {\n        bytes32 storageKey = keccak256(\n            abi.encodePacked(\n                keccak256(\n                    abi.encodePacked(\n                        _xDomainCalldata,\n                        resolve(\"OVM_L2CrossDomainMessenger\")\n                    )\n                ),\n                uint256(0)\n            )\n        );\n\n        (\n            bool exists,\n            bytes memory encodedMessagePassingAccount\n        ) = Lib_SecureMerkleTrie.get(\n            abi.encodePacked(0x4200000000000000000000000000000000000000),\n            _proof.stateTrieWitness,\n            _proof.stateRoot\n        );\n\n        require(\n            exists == true,\n            \"Message passing predeploy has not been initialized or invalid proof provided.\"\n        );\n\n        Lib_OVMCodec.EVMAccount memory account = Lib_OVMCodec.decodeEVMAccount(\n            encodedMessagePassingAccount\n        );\n\n        return Lib_SecureMerkleTrie.verifyInclusionProof(\n            abi.encodePacked(storageKey),\n            abi.encodePacked(uint8(1)),\n            _proof.storageTrieWitness,\n            account.storageRoot\n        );\n    }\n\n    /**\n     * Sends a cross domain message.\n     * @param _message Message to send.\n     * @param _gasLimit OVM gas limit for the message.\n     */\n    function _sendXDomainMessage(\n        bytes memory _message,\n        uint256 _gasLimit\n    )\n        override\n        internal\n    {\n        iOVM_CanonicalTransactionChain(resolve(\"OVM_CanonicalTransactionChain\")).enqueue(\n            resolve(\"OVM_L2CrossDomainMessenger\"),\n            _gasLimit,\n            _message\n        );\n    }\n}"
    },
    {
      "filename": "contracts/optimistic-ethereum/OVM/bridge/tokens/Abs_L2DepositedToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\n/* Interface Imports */\nimport { iOVM_L2DepositedToken } from \"../../../iOVM/bridge/tokens/iOVM_L2DepositedToken.sol\";\nimport { iOVM_L1TokenGateway } from \"../../../iOVM/bridge/tokens/iOVM_L1TokenGateway.sol\";\n\n/* Library Imports */\nimport { OVM_CrossDomainEnabled } from \"../../../libraries/bridge/OVM_CrossDomainEnabled.sol\";\n\n/**\n * @title Abs_L2DepositedToken\n * @dev An L2 Deposited Token is an L2 representation of funds which were deposited from L1.\n * Usually contract mints new tokens when it hears about deposits into the L1 ERC20 gateway.\n * This contract also burns the tokens intended for withdrawal, informing the L1 gateway to release L1 funds.\n *\n * NOTE: This abstract contract gives all the core functionality of a deposited token implementation except for the\n * token's internal accounting itself.  This gives developers an easy way to implement children with their own token code.\n *\n * Compiler used: optimistic-solc\n * Runtime target: OVM\n */\nabstract contract Abs_L2DepositedToken is iOVM_L2DepositedToken, OVM_CrossDomainEnabled {\n\n    /*******************\n     * Contract Events *\n     *******************/\n\n    event Initialized(iOVM_L1TokenGateway _l1TokenGateway);\n\n    /********************************\n     * External Contract References *\n     ********************************/\n\n    iOVM_L1TokenGateway public l1TokenGateway;\n\n    /********************************\n     * Constructor & Initialization *\n     ********************************/\n\n    /**\n     * @param _l2CrossDomainMessenger L1 Messenger address being used for cross-chain communications.\n     */\n    constructor(\n        address _l2CrossDomainMessenger\n    )\n        OVM_CrossDomainEnabled(_l2CrossDomainMessenger)\n    {}\n\n    /**\n     * @dev Initialize this contract with the L1 token gateway address.\n     * The flow: 1) this contract gets deployed on L2, 2) the L1\n     * gateway is deployed with addr from (1), 3) L1 gateway address passed here.\n     *\n     * @param _l1TokenGateway Address of the corresponding L1 gateway deployed to the main chain\n     */\n\n    function init(\n        iOVM_L1TokenGateway _l1TokenGateway\n    )\n        public\n    {\n        require(address(l1TokenGateway) == address(0), \"Contract has already been initialized\");\n\n        l1TokenGateway = _l1TokenGateway;\n        \n        emit Initialized(l1TokenGateway);\n    }\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier onlyInitialized() {\n        require(address(l1TokenGateway) != address(0), \"Contract has not yet been initialized\");\n        _;\n    }\n\n    /********************************\n     * Overridable Accounting logic *\n     ********************************/\n\n    // Default gas value which can be overridden if more complex logic runs on L2.\n    uint32 constant DEFAULT_FINALIZE_WITHDRAWAL_L1_GAS = 100000;\n\n    /**\n     * @dev Core logic to be performed when a withdrawal from L2 is initialized.\n     * In most cases, this will simply burn the withdrawn L2 funds.\n     *\n     * param _to Address being withdrawn to\n     * param _amount Amount being withdrawn\n     */\n\n    function _handleInitiateWithdrawal(\n        address, // _to,\n        uint // _amount\n    )\n        internal\n        virtual\n    {\n        revert(\"Accounting must be implemented by child contract.\");\n    }\n\n    /**\n     * @dev Core logic to be performed when a deposit from L2 is finalized on L2.\n     * In most cases, this will simply _mint() to credit L2 funds to the recipient.\n     *\n     * param _to Address being deposited to on L2\n     * param _amount Amount which was deposited on L1\n     */\n    function _handleFinalizeDeposit(\n        address, // _to\n        uint // _amount\n    )\n        internal\n        virtual\n    {\n        revert(\"Accounting must be implemented by child contract.\");\n    }\n\n    /**\n     * @dev Overridable getter for the *L1* gas limit of settling the withdrawal, in the case it may be\n     * dynamic, and the above public constant does not suffice.\n     *\n     */\n\n    function getFinalizeWithdrawalL1Gas()\n        public\n        view\n        virtual\n        returns(\n            uint32\n        )\n    {\n        return DEFAULT_FINALIZE_WITHDRAWAL_L1_GAS;\n    }\n\n\n    /***************\n     * Withdrawing *\n     ***************/\n\n    /**\n     * @dev initiate a withdraw of some tokens to the caller's account on L1\n     * @param _amount Amount of the token to withdraw\n     */\n    function withdraw(\n        uint _amount\n    )\n        external\n        override\n        onlyInitialized()\n    {\n        _initiateWithdrawal(msg.sender, _amount);\n    }\n\n    /**\n     * @dev initiate a withdraw of some token to a recipient's account on L1\n     * @param _to L1 adress to credit the withdrawal to\n     * @param _amount Amount of the token to withdraw\n     */\n    function withdrawTo(\n        address _to,\n        uint _amount\n    )\n        external\n        override\n        onlyInitialized()\n    {\n        _initiateWithdrawal(_to, _amount);\n    }\n\n    /**\n     * @dev Performs the logic for deposits by storing the token and informing the L2 token Gateway of the deposit.\n     *\n     * @param _to Account to give the withdrawal to on L1\n     * @param _amount Amount of the token to withdraw\n     */\n    function _initiateWithdrawal(\n        address _to,\n        uint _amount\n    )\n        internal\n    {\n        // Call our withdrawal accounting handler implemented by child contracts (usually a _burn)\n        _handleInitiateWithdrawal(_to, _amount);\n\n        // Construct calldata for l1TokenGateway.finalizeWithdrawal(_to, _amount)\n        bytes memory data = abi.encodeWithSelector(\n            iOVM_L1TokenGateway.finalizeWithdrawal.selector,\n            _to,\n            _amount\n        );\n\n        // Send message up to L1 gateway\n        sendCrossDomainMessage(\n            address(l1TokenGateway),\n            data,\n            getFinalizeWithdrawalL1Gas()\n        );\n\n        emit WithdrawalInitiated(msg.sender, _to, _amount);\n    }\n\n    /************************************\n     * Cross-chain Function: Depositing *\n     ************************************/\n\n    /**\n     * @dev Complete a deposit from L1 to L2, and credits funds to the recipient's balance of this \n     * L2 token. \n     * This call will fail if it did not originate from a corresponding deposit in OVM_l1TokenGateway. \n     *\n     * @param _to Address to receive the withdrawal at\n     * @param _amount Amount of the token to withdraw\n     */\n    function finalizeDeposit(\n        address _to,\n        uint _amount\n    )\n        external\n        override \n        onlyInitialized()\n        onlyFromCrossDomainAccount(address(l1TokenGateway))\n    {\n        _handleFinalizeDeposit(_to, _amount);\n        emit DepositFinalized(_to, _amount);\n    }\n}"
    },
    {
      "filename": "contracts/optimistic-ethereum/OVM/bridge/tokens/OVM_L1ETHGateway.sol",
      "content": "// SPDX-License-Identifier: MIT\n// @unsupported: ovm\npragma solidity >0.5.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\n/* Interface Imports */\nimport { iOVM_L1ETHGateway } from \"../../../iOVM/bridge/tokens/iOVM_L1ETHGateway.sol\";\nimport { iOVM_L2DepositedToken } from \"../../../iOVM/bridge/tokens/iOVM_L2DepositedToken.sol\";\n\n/* Library Imports */\nimport { OVM_CrossDomainEnabled } from \"../../../libraries/bridge/OVM_CrossDomainEnabled.sol\";\nimport { Lib_AddressResolver } from \"../../../libraries/resolver/Lib_AddressResolver.sol\";\nimport { Lib_AddressManager } from \"../../../libraries/resolver/Lib_AddressManager.sol\";\n\n/**\n * @title OVM_L1ETHGateway\n * @dev The L1 ETH Gateway is a contract which stores deposited ETH that is in use on L2.\n *\n * Compiler used: solc\n * Runtime target: EVM\n */\ncontract OVM_L1ETHGateway is iOVM_L1ETHGateway, OVM_CrossDomainEnabled, Lib_AddressResolver {\n\n    /********************\n     * Public Constants *\n     ********************/\n\n    uint32 public constant override getFinalizeDepositL2Gas = 1200000;\n\n    /********************************\n     * External Contract References *\n     ********************************/\n\n    address public ovmEth;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    // This contract lives behind a proxy, so the constructor parameters will go unused.\n    constructor()\n        OVM_CrossDomainEnabled(address(0))\n        Lib_AddressResolver(address(0))\n        public\n    {}\n\n    /******************\n     * Initialization *\n     ******************/\n\n    /**\n     * @param _libAddressManager Address manager for this OE deployment\n     * @param _ovmEth L2 OVM_ETH implementation of iOVM_DepositedToken\n     */\n    function initialize(\n        address _libAddressManager,\n        address _ovmEth\n    )\n        public\n    {\n        require(libAddressManager == Lib_AddressManager(0), \"Contract has already been initialized.\");\n        libAddressManager = Lib_AddressManager(_libAddressManager);\n        ovmEth = _ovmEth;\n        messenger = resolve(\"Proxy__OVM_L1CrossDomainMessenger\");\n    }\n\n    /**************\n     * Depositing *\n     **************/\n\n    receive()\n        external\n        payable\n    {\n        _initiateDeposit(msg.sender, msg.sender);\n    }\n\n    /**\n     * @dev deposit an amount of the ETH to the caller's balance on L2\n     */\n    function deposit() \n        external\n        override\n        payable\n    {\n        _initiateDeposit(msg.sender, msg.sender);\n    }\n\n    /**\n     * @dev deposit an amount of ETH to a recipients's balance on L2\n     * @param _to L2 address to credit the withdrawal to\n     */\n    function depositTo(\n        address _to\n    )\n        external\n        override\n        payable\n    {\n        _initiateDeposit(msg.sender, _to);\n    }\n\n    /**\n     * @dev Performs the logic for deposits by storing the ETH and informing the L2 ETH Gateway of the deposit.\n     *\n     * @param _from Account to pull the deposit from on L1\n     * @param _to Account to give the deposit to on L2\n     */\n    function _initiateDeposit(\n        address _from,\n        address _to\n    )\n        internal\n    {\n        // Construct calldata for l2ETHGateway.finalizeDeposit(_to, _amount)\n        bytes memory data =\n            abi.encodeWithSelector(\n                iOVM_L2DepositedToken.finalizeDeposit.selector,\n                _to,\n                msg.value\n            );\n\n        // Send calldata into L2\n        sendCrossDomainMessage(\n            ovmEth,\n            data,\n            getFinalizeDepositL2Gas\n        );\n\n        emit DepositInitiated(_from, _to, msg.value);\n    }\n\n    /*************************\n     * Cross-chain Functions *\n     *************************/\n\n    /**\n     * @dev Complete a withdrawal from L2 to L1, and credit funds to the recipient's balance of the\n     * L1 ETH token.\n     * Since only the xDomainMessenger can call this function, it will never be called before the withdrawal is finalized. \n     *\n     * @param _to L1 address to credit the withdrawal to\n     * @param _amount Amount of the ETH to withdraw\n     */\n    function finalizeWithdrawal(\n        address _to,\n        uint256 _amount\n    )\n        external\n        override\n        onlyFromCrossDomainAccount(ovmEth)\n    {\n        _safeTransferETH(_to, _amount);\n\n        emit WithdrawalFinalized(_to, _amount);\n    }\n\n    /**********************************\n     * Internal Functions: Accounting *\n     **********************************/\n\n    /**\n     * @dev Internal accounting function for moving around L1 ETH.\n     *\n     * @param _to L1 address to transfer ETH to\n     * @param _value Amount of ETH to send to\n     */\n    function _safeTransferETH(\n        address _to,\n        uint256 _value\n    )\n        internal\n    {\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\n    }\n}"
    },
    {
      "filename": "contracts/optimistic-ethereum/OVM/predeploys/OVM_DeployerWhitelist.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\n\n/* Library Imports */\nimport { Lib_Bytes32Utils } from \"../../libraries/utils/Lib_Bytes32Utils.sol\";\n\n/* Interface Imports */\nimport { iOVM_DeployerWhitelist } from \"../../iOVM/predeploys/iOVM_DeployerWhitelist.sol\";\nimport { Lib_SafeExecutionManagerWrapper } from \"../../libraries/wrappers/Lib_SafeExecutionManagerWrapper.sol\";\n\n/**\n * @title OVM_DeployerWhitelist\n * @dev The Deployer Whitelist is a temporary predeploy used to provide additional safety during the\n * initial phases of our mainnet roll out. It is owned by the Optimism team, and defines accounts\n * which are allowed to deploy contracts on Layer2. The Execution Manager will only allow an \n * ovmCREATE or ovmCREATE2 operation to proceed if the deployer's address whitelisted.\n * \n * Compiler used: solc\n * Runtime target: OVM\n */\ncontract OVM_DeployerWhitelist is iOVM_DeployerWhitelist {\n\n    /**********************\n     * Contract Constants *\n     **********************/\n\n    bytes32 internal constant KEY_INITIALIZED =                0x0000000000000000000000000000000000000000000000000000000000000010;\n    bytes32 internal constant KEY_OWNER =                      0x0000000000000000000000000000000000000000000000000000000000000011;\n    bytes32 internal constant KEY_ALLOW_ARBITRARY_DEPLOYMENT = 0x0000000000000000000000000000000000000000000000000000000000000012;\n\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n    \n    /**\n     * Blocks functions to anyone except the contract owner.\n     */\n    modifier onlyOwner() {\n        address owner = Lib_Bytes32Utils.toAddress(\n            Lib_SafeExecutionManagerWrapper.safeSLOAD(\n                KEY_OWNER\n            )\n        );\n\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(\n            Lib_SafeExecutionManagerWrapper.safeCALLER() == owner,\n            \"Function can only be called by the owner of this contract.\"\n        );\n        _;\n    }\n\n\n    /********************\n     * Public Functions *\n     ********************/\n    \n    /**\n     * Initializes the whitelist.\n     * @param _owner Address of the owner for this contract.\n     * @param _allowArbitraryDeployment Whether or not to allow arbitrary contract deployment.\n     */\n    function initialize(\n        address _owner,\n        bool _allowArbitraryDeployment\n    )\n        override\n        public\n    {\n        bool initialized = Lib_Bytes32Utils.toBool(\n            Lib_SafeExecutionManagerWrapper.safeSLOAD(KEY_INITIALIZED)\n        );\n\n        if (initialized == true) {\n            return;\n        }\n\n        Lib_SafeExecutionManagerWrapper.safeSSTORE(\n            KEY_INITIALIZED,\n            Lib_Bytes32Utils.fromBool(true)\n        );\n        Lib_SafeExecutionManagerWrapper.safeSSTORE(\n            KEY_OWNER,\n            Lib_Bytes32Utils.fromAddress(_owner)\n        );\n        Lib_SafeExecutionManagerWrapper.safeSSTORE(\n            KEY_ALLOW_ARBITRARY_DEPLOYMENT,\n            Lib_Bytes32Utils.fromBool(_allowArbitraryDeployment)\n        );\n    }\n\n    /**\n     * Gets the owner of the whitelist.\n     */\n    function getOwner()\n        override\n        public\n        returns(\n            address\n        )\n    {\n        return Lib_Bytes32Utils.toAddress(\n            Lib_SafeExecutionManagerWrapper.safeSLOAD(\n                KEY_OWNER\n            )\n        );\n    }\n\n    /**\n     * Adds or removes an address from the deployment whitelist.\n     * @param _deployer Address to update permissions for.\n     * @param _isWhitelisted Whether or not the address is whitelisted.\n     */\n    function setWhitelistedDeployer(\n        address _deployer,\n        bool _isWhitelisted\n    )\n        override\n        public\n        onlyOwner\n    {\n        Lib_SafeExecutionManagerWrapper.safeSSTORE(\n            Lib_Bytes32Utils.fromAddress(_deployer),\n            Lib_Bytes32Utils.fromBool(_isWhitelisted)\n        );\n    }\n\n    /**\n     * Updates the owner of this contract.\n     * @param _owner Address of the new owner.\n     */\n    function setOwner(\n        address _owner\n    )\n        override\n        public\n        onlyOwner\n    {\n        Lib_SafeExecutionManagerWrapper.safeSSTORE(\n            KEY_OWNER,\n            Lib_Bytes32Utils.fromAddress(_owner)\n        );\n    }\n\n    /**\n     * Updates the arbitrary deployment flag.\n     * @param _allowArbitraryDeployment Whether or not to allow arbitrary contract deployment.\n     */\n    function setAllowArbitraryDeployment(\n        bool _allowArbitraryDeployment\n    )\n        override\n        public\n        onlyOwner\n    {\n        Lib_SafeExecutionManagerWrapper.safeSSTORE(\n            KEY_ALLOW_ARBITRARY_DEPLOYMENT,\n            Lib_Bytes32Utils.fromBool(_allowArbitraryDeployment)\n        );\n    }\n\n    /**\n     * Permanently enables arbitrary contract deployment and deletes the owner.\n     */\n    function enableArbitraryContractDeployment()\n        override\n        public\n        onlyOwner\n    {\n        setAllowArbitraryDeployment(true);\n        setOwner(address(0));\n    }\n\n    /**\n     * Checks whether an address is allowed to deploy contracts.\n     * @param _deployer Address to check.\n     * @return _allowed Whether or not the address can deploy contracts.\n     */\n    function isDeployerAllowed(\n        address _deployer\n    )\n        override\n        public\n        returns (\n            bool _allowed\n        )\n    {\n        bool initialized = Lib_Bytes32Utils.toBool(\n            Lib_SafeExecutionManagerWrapper.safeSLOAD(KEY_INITIALIZED)\n        );\n\n        if (initialized == false) {\n            return true;\n        }\n\n        bool allowArbitraryDeployment = Lib_Bytes32Utils.toBool(\n            Lib_SafeExecutionManagerWrapper.safeSLOAD(KEY_ALLOW_ARBITRARY_DEPLOYMENT)\n        );\n\n        if (allowArbitraryDeployment == true) {\n            return true;\n        }\n\n        bool isWhitelisted = Lib_Bytes32Utils.toBool(\n            Lib_SafeExecutionManagerWrapper.safeSLOAD(\n                Lib_Bytes32Utils.fromAddress(_deployer)\n            )\n        );\n\n        return isWhitelisted;        \n    }\n}"
    },
    {
      "filename": "contracts/optimistic-ethereum/OVM/predeploys/OVM_ProxySequencerEntrypoint.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\n\n/* Library Imports */\nimport { Lib_SafeExecutionManagerWrapper } from \"../../libraries/wrappers/Lib_SafeExecutionManagerWrapper.sol\";\n\n/**\n * @title OVM_ProxySequencerEntrypoint \n * @dev The Proxy Sequencer Entrypoint is a predeployed proxy to the implementation of the \n * Sequencer Entrypoint. This will enable the Optimism team to upgrade the Sequencer Entrypoint \n * contract.\n * \n * Compiler used: solc\n * Runtime target: OVM\n */\ncontract OVM_ProxySequencerEntrypoint {\n\n    /*********************\n     * Fallback Function *\n     *********************/\n\n    fallback()\n        external\n    {\n        Lib_SafeExecutionManagerWrapper.safeDELEGATECALL(\n            gasleft(),\n            _getImplementation(),\n            msg.data\n        );\n    }\n\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    function init(\n        address _implementation,\n        address _owner\n    )\n        external\n    {\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(\n            _getOwner() == address(0),\n            \"ProxySequencerEntrypoint has already been inited\"\n        );\n        _setOwner(_owner);\n        _setImplementation(_implementation);\n    }\n\n    function upgrade(\n        address _implementation\n    )\n        external\n    {\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(\n            _getOwner() == Lib_SafeExecutionManagerWrapper.safeCALLER(),\n            \"Only owner can upgrade the Entrypoint\"\n        );\n\n        _setImplementation(_implementation);\n    }\n\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function _setImplementation(\n        address _implementation\n    )\n        internal\n    {\n        Lib_SafeExecutionManagerWrapper.safeSSTORE(\n            bytes32(uint256(0)),\n            bytes32(uint256(uint160(_implementation)))\n        );\n    }\n\n    function _getImplementation()\n        internal\n        returns (\n            address _implementation\n        )\n    {\n        return address(uint160(uint256(\n            Lib_SafeExecutionManagerWrapper.safeSLOAD(\n                bytes32(uint256(0))\n            )\n        )));\n    }\n\n    function _setOwner(\n        address _owner\n    )\n        internal\n    {\n        Lib_SafeExecutionManagerWrapper.safeSSTORE(\n            bytes32(uint256(1)),\n            bytes32(uint256(uint160(_owner)))\n        );\n    }\n\n    function _getOwner()\n        internal\n        returns (\n            address _owner\n        )\n    {\n        return address(uint160(uint256(\n            Lib_SafeExecutionManagerWrapper.safeSLOAD(\n                bytes32(uint256(1))\n            )\n        )));\n    }\n}"
    }
  ]
}