{
  "Title": "[G-04] Using storage instead of memory for structs/arrays saves gas",
  "Content": "Using a memory pointer for a storage struct/array will effectively load all the fields of that data type from storage (SLOAD) into memory (MSTORE). Using a storage pointer will allow you to read specific fields from storage as you need them. If you are not going to use all of the fields of your data type then you should use a storage pointer so that you don't incur extra `Gcoldsload (2100 gas)` for fields that you will never use.\n\n**Note: These are instances that the automated report missed**.\n\nTotal Instances: `12`\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-core/src/RewardsManager.sol#L440-L442\n\n*Gas Savings for `RewardsManager.claimRewards`, obtained via protocol's tests: Avg 3726 gas*\n\n|        |    Max   |\n| ------ | -------- |\n| Before |  393064  |  \n| After  |  389338  | \n\n```solidity\nFile: ajna-core/src/RewardsManager.sol\n440:       for (uint256 i = 0; i < positionIndexes_.length; ) {\n441:           bucketIndex = positionIndexes_[i];\n442:           BucketState memory bucketSnapshot = stakes[tokenId_].snapshot[bucketIndex];\n```\n```diff\ndiff --git a/src/RewardsManager.sol b/src/RewardsManager.sol\nindex 314b476..bec53c1 100644\n--- a/src/RewardsManager.sol\n+++ b/src/RewardsManager.sol\n@@ -439,7 +439,7 @@ contract RewardsManager is IRewardsManager, ReentrancyGuard {\n         // iterate through all buckets and calculate epoch rewards for\n         for (uint256 i = 0; i < positionIndexes_.length; ) {\n             bucketIndex = positionIndexes_[i];\n-            BucketState memory bucketSnapshot = stakes[tokenId_].snapshot[bucketIndex];\n+            BucketState storage bucketSnapshot = stakes[tokenId_].snapshot[bucketIndex];\n\n             uint256 bucketRate;\n             if (epoch_ != stakingEpoch_) {\n```\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/StandardFunding.sol#L236-L250\n\n*Gas Savings for `GrantFund.claimDelegateReward`, obtained via protocol's tests: Avg 926 gas*\n\n|        |    Max   |\n| ------ | -------- |\n| Before |   65340  |  \n| After  |   64414  | \n\n```solidity\nFile: ajna-grants/src/grants/base/StandardFunding.sol\n236:    function claimDelegateReward(\n237:        uint24 distributionId_\n238:    ) external override returns(uint256 rewardClaimed_) {\n239:        // Revert if delegatee didn't vote in screening stage\n240:        if(screeningVotesCast[distributionId_][msg.sender] == 0) revert DelegateRewardInvalid();\n241:\n242:        QuarterlyDistribution memory currentDistribution = _distributions[distributionId_];\n243:\n244:        // Check if Challenge Period is still active\n245:        if(block.number < _getChallengeStageEndBlock(currentDistribution.endBlock)) revert ChallengePeriodNotEnded();\n246:\n247:        // check rewards haven't already been claimed\n248:        if(hasClaimedReward[distributionId_][msg.sender]) revert RewardAlreadyClaimed();\n249:\n250:        QuadraticVoter memory voter = _quadraticVoters[distributionId_][msg.sender];\n```\n```diff\ndiff --git a/src/grants/base/StandardFunding.sol b/src/grants/base/StandardFunding.sol\nindex 928b337..6b3cc5e 100644\n--- a/src/grants/base/StandardFunding.sol\n+++ b/src/grants/base/StandardFunding.sol\n@@ -239,7 +239,7 @@ abstract contract StandardFunding is Funding, IStandardFunding {\n         // Revert if delegatee didn't vote in screening stage\n         if(screeningVotesCast[distributionId_][msg.sender] == 0) revert DelegateRewardInvalid();\n\n-        QuarterlyDistribution memory currentDistribution = _distributions[distributionId_];\n+        QuarterlyDistribution storage currentDistribution = _distributions[distributionId_];\n\n         // Check if Challenge Period is still active\n         if(block.number < _getChallengeStageEndBlock(currentDistribution.endBlock)) revert ChallengePeriodNotEnded();\n@@ -247,7 +247,7 @@ abstract contract StandardFunding is Funding, IStandardFunding {\n         // check rewards haven't already been claimed\n         if(hasClaimedReward[distributionId_][msg.sender]) revert RewardAlreadyClaimed();\n\n-        QuadraticVoter memory voter = _quadraticVoters[distributionId_][msg.sender];\n+        QuadraticVoter storage voter = _quadraticVoters[distributionId_][msg.sender];\n\n         // calculate rewards earned for voting\n         rewardClaimed_ = _getDelegateReward(currentDistribution, voter);\n@@ -272,9 +272,9 @@ abstract contract StandardFunding is Funding, IStandardFunding {\n      * @return rewards_             The delegate rewards accrued to the voter.\n      */\n     function _getDelegateReward(\n-        QuarterlyDistribution memory currentDistribution_,\n-        QuadraticVoter memory voter_\n-    ) internal pure returns (uint256 rewards_) {\n+        QuarterlyDistribution storage currentDistribution_,\n+        QuadraticVoter storage voter_\n+    ) internal view returns (uint256 rewards_) {\n         // calculate the total voting power available to the voter that was allocated in the funding stage\n         uint256 votingPowerAllocatedByDelegatee = voter_.votingPower - voter_.remainingVotingPower;\n\n@@ -918,8 +918,8 @@ abstract contract StandardFunding is Funding, IStandardFunding {\n         uint24 distributionId_,\n         address voter_\n     ) external view override returns (uint256 rewards_) {\n-        QuarterlyDistribution memory currentDistribution = _distributions[distributionId_];\n-        QuadraticVoter        memory voter               = _quadraticVoters[distributionId_][voter_];\n+        QuarterlyDistribution storage currentDistribution = _distributions[distributionId_];\n+        QuadraticVoter        storage voter               = _quadraticVoters[distributionId_][voter_];\n\n         rewards_ = _getDelegateReward(currentDistribution, voter);\n     }\n```\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/StandardFunding.sol#L434-L435\n\n*Gas Savings for `GrantFund.updateSlate`, obtained via protocol's tests: Avg 2387 gas*\n\n|        |    Max   |\n| ------ | -------- |\n| Before |   318329 |  \n| After  |   315942 | \n\n```solidity\nFile: ajna-grants/src/grants/base/StandardFunding.sol\n434:        for (uint i = 0; i < numProposalsInSlate_; ) {\n435:            Proposal memory proposal = _standardFundingProposals[proposalIds_[i]];\n```\n```diff\ndiff --git a/src/grants/base/StandardFunding.sol b/src/grants/base/StandardFunding.sol\nindex 928b337..115edd4 100644\n--- a/src/grants/base/StandardFunding.sol\n+++ b/src/grants/base/StandardFunding.sol\n@@ -432,7 +432,7 @@ abstract contract StandardFunding is Funding, IStandardFunding {\n\n         // check each proposal in the slate is valid\n         for (uint i = 0; i < numProposalsInSlate_; ) {\n-            Proposal memory proposal = _standardFundingProposals[proposalIds_[i]];\n+            Proposal storage proposal = _standardFundingProposals[proposalIds_[i]];\n\n             // check if Proposal is in the topTenProposals list\n             if (_findProposalIndex(proposalIds_[i], _topTenProposals[distributionId_]) == -1) revert InvalidProposalSlate();\n```\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/StandardFunding.sol#L763-L766\n\n*Gas Savings for `GrantFund.fundingVote`, obtained via protocol's tests: Avg 2372 gas*\n\n|        |    Max   |\n| ------ | -------- |\n| Before |   409345 |  \n| After  |   406973 | \n\n```solidity\nFile: ajna-grants/src/grants/base/StandardFunding.sol\n763:    function _findProposalIndex(\n764:        uint256 proposalId_,\n765:        uint256[] memory array_\n766:    ) internal pure returns (int256 index_) {\n```\n```diff\ndiff --git a/src/grants/base/StandardFunding.sol b/src/grants/base/StandardFunding.sol\nindex 928b337..ea0c1cd 100644\n--- a/src/grants/base/StandardFunding.sol\n+++ b/src/grants/base/StandardFunding.sol\n@@ -762,8 +762,8 @@ abstract contract StandardFunding is Funding, IStandardFunding {\n      */\n     function _findProposalIndex(\n         uint256 proposalId_,\n-        uint256[] memory array_\n-    ) internal pure returns (int256 index_) {\n+        uint256[] storage array_\n+    ) internal view returns (int256 index_) {\n         index_ = -1; // default value indicating proposalId not in the array\n         int256 arrayLength = int256(array_.length);\n```\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/StandardFunding.sol#L789-L792\n\n*Gas Savings for `GrantFund.fundingVote`, obtained via protocol's tests: Avg 3307 gas*\n\n|        |    Max   |\n| ------ | -------- |\n| Before |   409345 |  \n| After  |   406038 | \n\n```solidity\nFile: ajna-grants/src/grants/base/StandardFunding.sol\n789:    function _findProposalIndexOfVotesCast(\n790:        uint256 proposalId_,\n791:        FundingVoteParams[] memory voteParams_\n792:    ) internal pure returns (int256 index_) {\n```\n```diff\ndiff --git a/src/grants/base/StandardFunding.sol b/src/grants/base/StandardFunding.sol\nindex 928b337..64d1163 100644\n--- a/src/grants/base/StandardFunding.sol\n+++ b/src/grants/base/StandardFunding.sol\n@@ -788,8 +788,8 @@ abstract contract StandardFunding is Funding, IStandardFunding {\n      */\n     function _findProposalIndexOfVotesCast(\n         uint256 proposalId_,\n-        FundingVoteParams[] memory voteParams_\n-    ) internal pure returns (int256 index_) {\n+        FundingVoteParams[] storage voteParams_\n+    ) internal view returns (int256 index_) {\n         index_ = -1; // default value indicating proposalId not in the array\n```\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/StandardFunding.sol#L843-L845\n\n*Gas Savings for `GrantFund.fundingVote`, obtained via protocol's tests: Avg 4282 gas*\n\n|        |    Max   |\n| ------ | -------- |\n| Before |   409345 |  \n| After  |   405063 | \n\n```solidity\nFile: ajna-grants/src/grants/base/StandardFunding.sol\n843:    function _sumSquareOfVotesCast(\n844:        FundingVoteParams[] memory votesCast_\n845:    ) internal pure returns (uint256 votesCastSumSquared_) {\n```\n```diff\ndiff --git a/src/grants/base/StandardFunding.sol b/src/grants/base/StandardFunding.sol\nindex 928b337..b79bec9 100644\n--- a/src/grants/base/StandardFunding.sol\n+++ b/src/grants/base/StandardFunding.sol\n@@ -841,8 +841,8 @@ abstract contract StandardFunding is Funding, IStandardFunding {\n      * @return votesCastSumSquared_ The sum of the square of each vote cast.\n      */\n     function _sumSquareOfVotesCast(\n-        FundingVoteParams[] memory votesCast_\n-    ) internal pure returns (uint256 votesCastSumSquared_) {\n+        FundingVoteParams[] storage votesCast_\n+    ) internal view returns (uint256 votesCastSumSquared_) {\n         uint256 numVotesCast = votesCast_.length;\n\n         for (uint256 i = 0; i < numVotesCast; ) {\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-05-ajna",
  "Code": [
    {
      "filename": "ajna-core/src/RewardsManager.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport { IERC20 }          from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport { IERC721 }         from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport { ReentrancyGuard } from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport { SafeERC20 }       from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport { IPool }                        from './interfaces/pool/IPool.sol';\nimport { IPositionManager }             from './interfaces/position/IPositionManager.sol';\nimport { IPositionManagerOwnerActions } from './interfaces/position/IPositionManagerOwnerActions.sol';\nimport {\n    IRewardsManager,\n    IRewardsManagerOwnerActions,\n    IRewardsManagerState,\n    IRewardsManagerDerivedState\n} from './interfaces/rewards/IRewardsManager.sol';\nimport { StakeInfo, BucketState } from './interfaces/rewards/IRewardsManagerState.sol';\n\nimport { PositionManager } from './PositionManager.sol';\n\nimport { Maths } from './libraries/internal/Maths.sol';\n\n/**\n *  @title  Rewards (staking) Manager contract\n *  @notice Pool lenders can optionally mint `NFT` that represents their positions.\n *          The Rewards contract allows pool lenders with positions `NFT` to stake and earn `Ajna` tokens. \n *          Lenders with `NFT`s can:\n *          - `stake` token\n *          - `update bucket exchange rate` and earn rewards\n *          - `claim` rewards\n *          - `unstake` token\n */\ncontract RewardsManager is IRewardsManager, ReentrancyGuard {\n\n    using SafeERC20 for IERC20;\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    /**\n     * @notice Maximum percentage of tokens burned that can be claimed as `Ajna` token `LP` `NFT` rewards.\n     */\n    uint256 internal constant REWARD_CAP = 0.8 * 1e18;\n    /**\n     * @notice Maximum percentage of tokens burned that can be claimed as `Ajna` token update rewards.\n     */\n    uint256 internal constant UPDATE_CAP = 0.1 * 1e18;\n    /**\n     * @notice Reward factor by which to scale the total rewards earned.\n     * @dev ensures that rewards issued to staked lenders in a given pool are less than the `Ajna` tokens burned in that pool.\n     */\n    uint256 internal constant REWARD_FACTOR = 0.5 * 1e18;\n    /**\n     * @notice Reward factor by which to scale rewards earned for updating a buckets exchange rate.\n     */\n    uint256 internal constant UPDATE_CLAIM_REWARD = 0.05 * 1e18;\n    /**\n     * @notice Time period after a burn event in which buckets exchange rates can be updated.\n     */\n    uint256 internal constant UPDATE_PERIOD = 2 weeks;\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    /// @dev `tokenID => epoch => bool has claimed` mapping.\n    mapping(uint256 => mapping(uint256 => bool)) public override isEpochClaimed;\n    /// @dev `epoch => rewards claimed` mapping.\n    mapping(uint256 => uint256) public override rewardsClaimed;\n    /// @dev `epoch => update bucket rate rewards claimed` mapping.\n    mapping(uint256 => uint256) public override updateRewardsClaimed;\n\n    /// @dev Mapping of per pool bucket exchange rates at a given burn event `poolAddress => bucketIndex => epoch => bucket exchange rate`.\n    mapping(address => mapping(uint256 => mapping(uint256 => uint256))) internal bucketExchangeRates;\n\n    /// @dev Mapping `tokenID => Stake info`.\n    mapping(uint256 => StakeInfo) internal stakes;\n\n    /******************/\n    /*** Immutables ***/\n    /******************/\n\n    /// @dev Address of the `Ajna` token.\n    address public immutable ajnaToken;\n    /// @dev The `PositionManager` contract\n    IPositionManager public immutable positionManager;\n\n    /*******************/\n    /*** Constructor ***/\n    /*******************/\n\n    constructor(address ajnaToken_, IPositionManager positionManager_) {\n        if (ajnaToken_ == address(0)) revert DeployWithZeroAddress();\n\n        ajnaToken = ajnaToken_;\n        positionManager = positionManager_;\n    }\n\n    /**************************/\n    /*** External Functions ***/\n    /**************************/\n\n    /**\n     *  @inheritdoc IRewardsManagerOwnerActions\n     *  @dev    === Revert on ===\n     *  @dev    not owner `NotOwnerOfDeposit()`\n     *  @dev    already claimed `AlreadyClaimed()`\n     *  @dev    === Emit events ===\n     *  @dev    - `ClaimRewards`\n     */\n    function claimRewards(\n        uint256 tokenId_,\n        uint256 epochToClaim_\n    ) external override {\n        StakeInfo storage stakeInfo = stakes[tokenId_];\n\n        if (msg.sender != stakeInfo.owner) revert NotOwnerOfDeposit();\n\n        if (isEpochClaimed[tokenId_][epochToClaim_]) revert AlreadyClaimed();\n\n        _claimRewards(stakeInfo, tokenId_, epochToClaim_, true, stakeInfo.ajnaPool);\n    }\n\n    /**\n     *  @inheritdoc IRewardsManagerOwnerActions\n     *  @dev    === Revert on ===\n     *  @dev    not owner `NotOwnerOfDeposit()`\n     *  @dev    invalid index params `MoveStakedLiquidityInvalid()`\n     *  @dev    === Emit events ===\n     *  @dev    - `MoveStakedLiquidity`\n     */\n    function moveStakedLiquidity(\n        uint256 tokenId_,\n        uint256[] memory fromBuckets_,\n        uint256[] memory toBuckets_,\n        uint256 expiry_\n    ) external nonReentrant override {\n        StakeInfo storage stakeInfo = stakes[tokenId_];\n\n        if (msg.sender != stakeInfo.owner) revert NotOwnerOfDeposit();\n\n        // check move array sizes match to be able to match on index\n        uint256 fromBucketLength = fromBuckets_.length;\n        if (fromBucketLength != toBuckets_.length) revert MoveStakedLiquidityInvalid();\n\n        address ajnaPool = stakeInfo.ajnaPool;\n        uint256 curBurnEpoch = IPool(ajnaPool).currentBurnEpoch();\n\n        // claim rewards before moving liquidity, if any\n        _claimRewards(\n            stakeInfo,\n            tokenId_,\n            curBurnEpoch,\n            false,\n            ajnaPool\n        );\n\n        uint256 fromIndex;\n        uint256 toIndex;\n        for (uint256 i = 0; i < fromBucketLength; ) {\n            fromIndex = fromBuckets_[i];\n            toIndex = toBuckets_[i];\n\n            // call out to position manager to move liquidity between buckets\n            IPositionManagerOwnerActions.MoveLiquidityParams memory moveLiquidityParams = IPositionManagerOwnerActions.MoveLiquidityParams(\n                tokenId_,\n                ajnaPool,\n                fromIndex,\n                toIndex,\n                expiry_\n            );\n            positionManager.moveLiquidity(moveLiquidityParams);\n\n            // update to bucket state\n            BucketState storage toBucket = stakeInfo.snapshot[toIndex];\n            toBucket.lpsAtStakeTime  = uint128(positionManager.getLP(tokenId_, toIndex));\n            toBucket.rateAtStakeTime = uint128(IPool(ajnaPool).bucketExchangeRate(toIndex));\n            delete stakeInfo.snapshot[fromIndex];\n\n            // iterations are bounded by array length (which is itself bounded), preventing overflow / underflow\n            unchecked { ++i; }\n        }\n\n        emit MoveStakedLiquidity(tokenId_, fromBuckets_, toBuckets_);\n\n        // update to bucket list exchange rates, from buckets are aready updated on claim\n        // calculate rewards for updating exchange rates, if any\n        uint256 updateReward = _updateBucketExchangeRates(\n            ajnaPool,\n            toBuckets_\n        );\n\n        // transfer rewards to sender\n        _transferAjnaRewards(updateReward);\n    }\n\n    /**\n     *  @inheritdoc IRewardsManagerOwnerActions\n     *  @dev    === Revert on ===\n     *  @dev    not owner `NotOwnerOfDeposit()`\n     *  @dev    === Emit events ===\n     *  @dev    - `Stake`\n     */\n    function stake(\n        uint256 tokenId_\n    ) external override {\n        address ajnaPool = PositionManager(address(positionManager)).poolKey(tokenId_);\n\n        // check that msg.sender is owner of tokenId\n        if (IERC721(address(positionManager)).ownerOf(tokenId_) != msg.sender) revert NotOwnerOfDeposit();\n\n        StakeInfo storage stakeInfo = stakes[tokenId_];\n        stakeInfo.owner    = msg.sender;\n        stakeInfo.ajnaPool = ajnaPool;\n\n        uint256 curBurnEpoch = IPool(ajnaPool).currentBurnEpoch();\n\n        // record the staking epoch\n        stakeInfo.stakingEpoch = uint96(curBurnEpoch);\n\n        // initialize last time interaction at staking epoch\n        stakeInfo.lastClaimedEpoch = uint96(curBurnEpoch);\n\n        uint256[] memory positionIndexes = positionManager.getPositionIndexes(tokenId_);\n\n        for (uint256 i = 0; i < positionIndexes.length; ) {\n\n            uint256 bucketId = positionIndexes[i];\n\n            BucketState storage bucketState = stakeInfo.snapshot[bucketId];\n\n            // record the number of lps in bucket at the time of staking\n            bucketState.lpsAtStakeTime = uint128(positionManager.getLP(\n                tokenId_,\n                bucketId\n            ));\n            // record the bucket exchange rate at the time of staking\n            bucketState.rateAtStakeTime = uint128(IPool(ajnaPool).bucketExchangeRate(bucketId));\n\n            // iterations are bounded by array length (which is itself bounded), preventing overflow / underflow\n            unchecked { ++i; }\n        }\n\n        emit Stake(msg.sender, ajnaPool, tokenId_);\n\n        // transfer LP NFT to this contract\n        IERC721(address(positionManager)).transferFrom(msg.sender, address(this), tokenId_);\n\n        // calculate rewards for updating exchange rates, if any\n        uint256 updateReward = _updateBucketExchangeRates(\n            ajnaPool,\n            positionIndexes\n        );\n\n        // transfer rewards to sender\n        _transferAjnaRewards(updateReward);\n    }\n\n    /**\n     *  @inheritdoc IRewardsManagerOwnerActions\n     *  @dev    === Revert on ===\n     *  @dev    not owner `NotOwnerOfDeposit()`\n     *  @dev    === Emit events ===\n     *  @dev    - `ClaimRewards`\n     *  @dev    - `Unstake`\n     */\n    function unstake(\n        uint256 tokenId_\n    ) external override {\n        StakeInfo storage stakeInfo = stakes[tokenId_];\n\n        if (msg.sender != stakeInfo.owner) revert NotOwnerOfDeposit();\n\n        address ajnaPool = stakeInfo.ajnaPool;\n\n        // claim rewards, if any\n        _claimRewards(\n            stakeInfo,\n            tokenId_,\n            IPool(ajnaPool).currentBurnEpoch(),\n            false,\n            ajnaPool\n        );\n\n        // remove bucket snapshots recorded at the time of staking\n        uint256[] memory positionIndexes = positionManager.getPositionIndexes(tokenId_);\n        for (uint256 i = 0; i < positionIndexes.length; ) {\n            delete stakeInfo.snapshot[positionIndexes[i]]; // reset BucketState struct for current position\n\n            unchecked { ++i; }\n        }\n\n        // remove recorded stake info\n        delete stakes[tokenId_];\n\n        emit Unstake(msg.sender, ajnaPool, tokenId_);\n\n        // transfer LP NFT from contract to sender\n        IERC721(address(positionManager)).transferFrom(address(this), msg.sender, tokenId_);\n    }\n\n    /**\n     *  @inheritdoc IRewardsManagerOwnerActions\n     *  @dev    === Emit events ===\n     *  @dev    - `UpdateExchangeRates`\n     */\n    function updateBucketExchangeRatesAndClaim(\n        address pool_,\n        uint256[] calldata indexes_\n    ) external override returns (uint256 updateReward) {\n        updateReward = _updateBucketExchangeRates(pool_, indexes_);\n\n        // transfer rewards to sender\n        _transferAjnaRewards(updateReward);\n    }\n\n    /*******************************/\n    /*** External View Functions ***/\n    /*******************************/\n\n    /// @inheritdoc IRewardsManagerDerivedState\n    function calculateRewards(\n        uint256 tokenId_,\n        uint256 epochToClaim_\n    ) external view override returns (uint256 rewards_) {\n\n        address ajnaPool         = stakes[tokenId_].ajnaPool;\n        uint256 lastClaimedEpoch = stakes[tokenId_].lastClaimedEpoch;\n        uint256 stakingEpoch     = stakes[tokenId_].stakingEpoch;\n\n        uint256[] memory positionIndexes = positionManager.getPositionIndexesFiltered(tokenId_);\n\n        // iterate through all burn periods to calculate and claim rewards\n        for (uint256 epoch = lastClaimedEpoch; epoch < epochToClaim_; ) {\n\n            rewards_ += _calculateNextEpochRewards(\n                tokenId_,\n                epoch,\n                stakingEpoch,\n                ajnaPool,\n                positionIndexes\n            );\n\n            unchecked { ++epoch; }\n        }\n    }\n\n    /// @inheritdoc IRewardsManagerState\n    function getStakeInfo(\n        uint256 tokenId_\n    ) external view override returns (address, address, uint256) {\n        return (\n            stakes[tokenId_].owner,\n            stakes[tokenId_].ajnaPool,\n            stakes[tokenId_].lastClaimedEpoch\n        );\n    }\n\n    /// @inheritdoc IRewardsManagerState\n    function getBucketStateStakeInfo(\n        uint256 tokenId_,\n        uint256 bucketId_\n    ) external view override returns (uint256, uint256) {\n        return (\n            stakes[tokenId_].snapshot[bucketId_].lpsAtStakeTime,\n            stakes[tokenId_].snapshot[bucketId_].rateAtStakeTime\n        );\n    }\n\n    /**************************/\n    /*** Internal Functions ***/\n    /**************************/\n\n    /**\n     *  @notice Calculate the amount of rewards that have been accumulated by a staked `NFT`.\n     *  @dev    Rewards are calculated as the difference in exchange rates between the last interaction burn event and the current burn event.\n     *  @param  tokenId_      `ID` of the staked `LP` `NFT`.\n     *  @param  epochToClaim_ The burn epoch to claim rewards for (rewards calculation starts from the last claimed epoch).\n     *  @return rewards_      Amount of rewards earned by the `NFT`.\n     */\n    function _calculateAndClaimRewards(\n        uint256 tokenId_,\n        uint256 epochToClaim_\n    ) internal returns (uint256 rewards_) {\n\n        address ajnaPool         = stakes[tokenId_].ajnaPool;\n        uint256 lastClaimedEpoch = stakes[tokenId_].lastClaimedEpoch;\n        uint256 stakingEpoch     = stakes[tokenId_].stakingEpoch;\n\n        uint256[] memory positionIndexes = positionManager.getPositionIndexesFiltered(tokenId_);\n\n        // iterate through all burn periods to calculate and claim rewards\n        for (uint256 epoch = lastClaimedEpoch; epoch < epochToClaim_; ) {\n\n            uint256 nextEpochRewards = _calculateNextEpochRewards(\n                tokenId_,\n                epoch,\n                stakingEpoch,\n                ajnaPool,\n                positionIndexes\n            );\n\n            rewards_ += nextEpochRewards;\n\n            unchecked { ++epoch; }\n\n            // update epoch token claim trackers\n            rewardsClaimed[epoch]           += nextEpochRewards;\n            isEpochClaimed[tokenId_][epoch] = true;\n        }\n    }\n\n    /**\n     *  @notice Calculate the amount of rewards that have been accumulated by a staked `NFT` in next epoch.\n     *  @dev    Rewards are calculated as the difference in exchange rates between the last interaction burn event and the current burn event.\n     *  @param  tokenId_         `ID` of the staked `LP` `NFT`.\n     *  @param  epoch_           The current epoch.\n     *  @param  stakingEpoch_    The epoch in which token was staked.\n     *  @param  ajnaPool_        Address of the pool.\n     *  @param  positionIndexes_ Bucket ids associated with `NFT` staked.\n     *  @return epochRewards_    Calculated rewards in epoch.\n     */\n    function _calculateNextEpochRewards(\n        uint256 tokenId_,\n        uint256 epoch_,\n        uint256 stakingEpoch_,\n        address ajnaPool_,\n        uint256[] memory positionIndexes_\n    ) internal view returns (uint256 epochRewards_) {\n\n        uint256 nextEpoch = epoch_ + 1;\n        uint256 claimedRewardsInNextEpoch = rewardsClaimed[nextEpoch];\n        uint256 bucketIndex;\n        uint256 interestEarned;\n\n        // iterate through all buckets and calculate epoch rewards for\n        for (uint256 i = 0; i < positionIndexes_.length; ) {\n            bucketIndex = positionIndexes_[i];\n            BucketState memory bucketSnapshot = stakes[tokenId_].snapshot[bucketIndex];\n\n            uint256 bucketRate;\n            if (epoch_ != stakingEpoch_) {\n\n                // if staked in a previous epoch then use the initial exchange rate of epoch\n                bucketRate = bucketExchangeRates[ajnaPool_][bucketIndex][epoch_];\n            } else {\n\n                // if staked during the epoch then use the bucket rate at the time of staking\n                bucketRate = bucketSnapshot.rateAtStakeTime;\n            }\n\n            // calculate the amount of interest accrued in current epoch\n            interestEarned += _calculateExchangeRateInterestEarned(\n                ajnaPool_,\n                nextEpoch,\n                bucketIndex,\n                bucketSnapshot.lpsAtStakeTime,\n                bucketRate\n            ); \n            unchecked { ++i; }\n        }\n\n        // calculate and accumulate rewards if interest earned\n        if (interestEarned != 0) {\n            epochRewards_ = _calculateNewRewards(\n                ajnaPool_,\n                interestEarned,\n                nextEpoch,\n                epoch_,\n                claimedRewardsInNextEpoch\n            );\n        }\n    }\n\n    /**\n     *  @notice Calculate the amount of interest that has accrued to a lender in a bucket based upon their `LP`.\n     *  @param  pool_           Address of the pool whose exchange rates are being checked.\n     *  @param  nextEventEpoch_ The next event epoch to check the exchange rate for.\n     *  @param  bucketIndex_    Index of the bucket to check the exchange rate for.\n     *  @param  bucketLP_       Amount of `LP` in bucket.\n     *  @param  exchangeRate_   Exchange rate in current epoch.\n     *  @return interestEarned_ The amount of interest accrued.\n     */\n    function _calculateExchangeRateInterestEarned(\n        address pool_,\n        uint256 nextEventEpoch_,\n        uint256 bucketIndex_,\n        uint256 bucketLP_,\n        uint256 exchangeRate_\n    ) internal view returns (uint256 interestEarned_) {\n\n        if (exchangeRate_ != 0) {\n\n            uint256 nextExchangeRate = bucketExchangeRates[pool_][bucketIndex_][nextEventEpoch_];\n\n            // calculate interest earned only if next exchange rate is higher than current exchange rate\n            if (nextExchangeRate > exchangeRate_) {\n\n                // calculate the equivalent amount of quote tokens given the stakes lp balance,\n                // and the exchange rate at the next and current burn events\n                interestEarned_ = Maths.wmul(nextExchangeRate - exchangeRate_, bucketLP_);\n            }\n\n        }\n    }\n\n    /**\n     *  @notice Calculate new rewards between current and next epoch, based on earned interest.\n     *  @param  ajnaPool_              Address of the pool.\n     *  @param  interestEarned_        The amount of interest accrued to current epoch.\n     *  @param  nextEpoch_             The next burn event epoch to calculate new rewards.\n     *  @param  epoch_                 The current burn event epoch to calculate new rewards.\n     *  @param  rewardsClaimedInEpoch_ Rewards claimed in epoch.\n     *  @return newRewards_            New rewards between current and next burn event epoch.\n     */\n    function _calculateNewRewards(\n        address ajnaPool_,\n        uint256 interestEarned_,\n        uint256 nextEpoch_,\n        uint256 epoch_,\n        uint256 rewardsClaimedInEpoch_\n    ) internal view returns (uint256 newRewards_) {\n        (\n            ,\n            // total interest accumulated by the pool over the claim period\n            uint256 totalBurnedInPeriod,\n            // total tokens burned over the claim period\n            uint256 totalInterestEarnedInPeriod\n        ) = _getPoolAccumulators(ajnaPool_, nextEpoch_, epoch_);\n\n        // calculate rewards earned\n        newRewards_ = totalInterestEarnedInPeriod == 0 ? 0 : Maths.wmul(\n            REWARD_FACTOR,\n            Maths.wdiv(\n                Maths.wmul(interestEarned_, totalBurnedInPeriod),\n                totalInterestEarnedInPeriod\n            )\n        );\n\n        uint256 rewardsCapped = Maths.wmul(REWARD_CAP, totalBurnedInPeriod);\n\n        // Check rewards claimed - check that less than 80% of the tokens for a given burn event have been claimed.\n        if (rewardsClaimedInEpoch_ + newRewards_ > rewardsCapped) {\n\n            // set claim reward to difference between cap and reward\n            newRewards_ = rewardsCapped - rewardsClaimedInEpoch_;\n        }\n    }\n\n    /**\n     *  @notice Claim rewards that have been accumulated by a staked `NFT`.\n     *  @param  stakeInfo_     `StakeInfo` struct containing details of stake to claim rewards for.\n     *  @param  tokenId_       `ID` of the staked `LP` `NFT`.\n     *  @param  epochToClaim_  The burn epoch to claim rewards for (rewards calculation starts from the last claimed epoch)\n     *  @param  validateEpoch_ True if the epoch is received as a parameter and needs to be validated (lower or equal with latest epoch).\n     *  @param  ajnaPool_      Address of `Ajna` pool associated with the stake.\n     */\n    function _claimRewards(\n        StakeInfo storage stakeInfo_,\n        uint256 tokenId_,\n        uint256 epochToClaim_,\n        bool validateEpoch_,\n        address ajnaPool_\n    ) internal {\n\n        // revert if higher epoch to claim than current burn epoch\n        if (validateEpoch_ && epochToClaim_ > IPool(ajnaPool_).currentBurnEpoch()) revert EpochNotAvailable();\n\n        // update bucket exchange rates and claim associated rewards\n        uint256 rewardsEarned = _updateBucketExchangeRates(\n            ajnaPool_,\n            positionManager.getPositionIndexes(tokenId_)\n        );\n\n        rewardsEarned += _calculateAndClaimRewards(tokenId_, epochToClaim_);\n\n        uint256[] memory burnEpochsClaimed = _getBurnEpochsClaimed(\n            stakeInfo_.lastClaimedEpoch,\n            epochToClaim_\n        );\n\n        emit ClaimRewards(\n            msg.sender,\n            ajnaPool_,\n            tokenId_,\n            burnEpochsClaimed,\n            rewardsEarned\n        );\n\n        // update last interaction burn event\n        stakeInfo_.lastClaimedEpoch = uint96(epochToClaim_);\n\n        // transfer rewards to sender\n        _transferAjnaRewards(rewardsEarned);\n    }\n\n    /**\n     *  @notice Retrieve an array of burn epochs from which a depositor has claimed rewards.\n     *  @param  lastClaimedEpoch_      The last burn period in which a depositor claimed rewards.\n     *  @param  burnEpochToStartClaim_ The most recent burn period from a depositor earned rewards.\n     *  @return burnEpochsClaimed_     Array of burn epochs from which a depositor has claimed rewards.\n     */\n    function _getBurnEpochsClaimed(\n        uint256 lastClaimedEpoch_,\n        uint256 burnEpochToStartClaim_\n    ) internal pure returns (uint256[] memory burnEpochsClaimed_) {\n        uint256 numEpochsClaimed = burnEpochToStartClaim_ - lastClaimedEpoch_;\n\n        burnEpochsClaimed_ = new uint256[](numEpochsClaimed);\n\n        uint256 i;\n        uint256 claimEpoch = lastClaimedEpoch_ + 1;\n        while (claimEpoch <= burnEpochToStartClaim_) {\n            burnEpochsClaimed_[i] = claimEpoch;\n\n            // iterations are bounded by array length (which is itself bounded), preventing overflow / underflow\n            unchecked {\n                ++i;\n                ++claimEpoch;\n            }\n        }\n    }\n\n    /**\n     *  @notice Retrieve the total ajna tokens burned and total interest earned by a pool since a given block.\n     *  @param  pool_                  Address of the `Ajna` pool to retrieve accumulators of.\n     *  @param  currentBurnEventEpoch_ The latest burn event.\n     *  @param  lastBurnEventEpoch_    The burn event to use as checkpoint since which values have accumulated.\n     *  @return Timestamp of the latest burn event.\n     *  @return Total `Ajna` tokens burned by the pool since the last burn event.\n     *  @return Total interest earned by the pool since the last burn event.\n     */\n    function _getPoolAccumulators(\n        address pool_,\n        uint256 currentBurnEventEpoch_,\n        uint256 lastBurnEventEpoch_\n    ) internal view returns (uint256, uint256, uint256) {\n        (\n            uint256 currentBurnTime,\n            uint256 totalInterestLatest,\n            uint256 totalBurnedLatest\n        ) = IPool(pool_).burnInfo(currentBurnEventEpoch_);\n\n        (\n            ,\n            uint256 totalInterestAtBlock,\n            uint256 totalBurnedAtBlock\n        ) = IPool(pool_).burnInfo(lastBurnEventEpoch_);\n\n        uint256 totalBurned   = totalBurnedLatest   != 0 ? totalBurnedLatest   - totalBurnedAtBlock   : totalBurnedAtBlock;\n        uint256 totalInterest = totalInterestLatest != 0 ? totalInterestLatest - totalInterestAtBlock : totalInterestAtBlock;\n\n        return (\n            currentBurnTime,\n            totalBurned,\n            totalInterest\n        );\n    }\n\n    /**\n     *  @notice Update the exchange rate of a list of buckets.\n     *  @dev    Called as part of `stake`, `unstake`, and `claimRewards`, as well as `updateBucketExchangeRatesAndClaim`.\n     *  @dev    Caller can claim `5%` of the rewards that have accumulated to each bucket since the last burn event, if it hasn't already been updated.\n     *  @param  pool_           Address of the pool whose exchange rates are being updated.\n     *  @param  indexes_        List of bucket indexes to be updated.\n     *  @return updatedRewards_ Update exchange rate rewards.\n     */\n    function _updateBucketExchangeRates(\n        address pool_,\n        uint256[] memory indexes_\n    ) internal returns (uint256 updatedRewards_) {\n        // get the current burn epoch from the given pool\n        uint256 curBurnEpoch = IPool(pool_).currentBurnEpoch();\n\n        // update exchange rates only if the pool has not yet burned any tokens without calculating any reward\n        if (curBurnEpoch == 0) {\n            for (uint256 i = 0; i < indexes_.length; ) {\n\n                _updateBucketExchangeRate(\n                    pool_,\n                    indexes_[i],\n                    curBurnEpoch\n                );\n\n                // iterations are bounded by array length (which is itself bounded), preventing overflow / underflow\n                unchecked { ++i; }\n            }\n        }\n\n        else {\n            // retrieve accumulator values used to calculate rewards accrued\n            (\n                uint256 curBurnTime,\n                uint256 totalBurned,\n                uint256 totalInterestEarned\n            ) = _getPoolAccumulators(pool_, curBurnEpoch, curBurnEpoch - 1);\n\n            if (block.timestamp <= curBurnTime + UPDATE_PERIOD) {\n\n                // update exchange rates and calculate rewards if tokens were burned and within allowed time period\n                for (uint256 i = 0; i < indexes_.length; ) {\n\n                    // calculate rewards earned for updating bucket exchange rate\n                    updatedRewards_ += _updateBucketExchangeRateAndCalculateRewards(\n                        pool_,\n                        indexes_[i],\n                        curBurnEpoch,\n                        totalBurned,\n                        totalInterestEarned\n                    );\n\n                    // iterations are bounded by array length (which is itself bounded), preventing overflow / underflow\n                    unchecked { ++i; }\n                }\n\n                uint256 rewardsCap            = Maths.wmul(UPDATE_CAP, totalBurned);\n                uint256 rewardsClaimedInEpoch = updateRewardsClaimed[curBurnEpoch];\n\n                // update total tokens claimed for updating bucket exchange rates tracker\n                if (rewardsClaimedInEpoch + updatedRewards_ >= rewardsCap) {\n                    // if update reward is greater than cap, set to remaining difference\n                    updatedRewards_ = rewardsCap - rewardsClaimedInEpoch;\n                }\n\n                // accumulate the full amount of additional rewards\n                updateRewardsClaimed[curBurnEpoch] += updatedRewards_;\n            }\n        }\n\n        // emit event with the list of bucket indexes updated\n        emit UpdateExchangeRates(msg.sender, pool_, indexes_, updatedRewards_);\n    }\n\n    /**\n     *  @notice Update the exchange rate of a specific bucket.\n     *  @param  pool_        Address of the pool whose exchange rates are being updated.\n     *  @param  bucketIndex_ Bucket index to update exchange rate.\n     *  @param  burnEpoch_   Current burn epoch of the pool.\n     */\n    function _updateBucketExchangeRate(\n        address pool_,\n        uint256 bucketIndex_,\n        uint256 burnEpoch_\n    ) internal {\n        uint256 burnExchangeRate = bucketExchangeRates[pool_][bucketIndex_][burnEpoch_];\n\n        // update bucket exchange rate at epoch only if it wasn't previously updated\n        if (burnExchangeRate == 0) {\n            uint256 curBucketExchangeRate = IPool(pool_).bucketExchangeRate(bucketIndex_);\n\n            // record bucket exchange rate at epoch\n            bucketExchangeRates[pool_][bucketIndex_][burnEpoch_] = curBucketExchangeRate;\n        }\n    }\n\n    /**\n     *  @notice Update the exchange rate of a specific bucket and calculate rewards based on prev exchange rate.\n     *  @param  pool_           Address of the pool whose exchange rates are being updated.\n     *  @param  bucketIndex_    Bucket index to update exchange rate.\n     *  @param  burnEpoch_      Current burn epoch of the pool.\n     *  @param  totalBurned_    Total `Ajna` tokens burned in pool.\n     *  @param  interestEarned_ Total interest rate earned in pool.\n     *  @return rewards_        Rewards for bucket exchange rate update.\n     */\n    function _updateBucketExchangeRateAndCalculateRewards(\n        address pool_,\n        uint256 bucketIndex_,\n        uint256 burnEpoch_,\n        uint256 totalBurned_,\n        uint256 interestEarned_\n    ) internal returns (uint256 rewards_) {\n        uint256 burnExchangeRate = bucketExchangeRates[pool_][bucketIndex_][burnEpoch_];\n\n        // update bucket exchange rate at epoch only if it wasn't previously updated\n        if (burnExchangeRate == 0) {\n            uint256 curBucketExchangeRate = IPool(pool_).bucketExchangeRate(bucketIndex_);\n\n            // record bucket exchange rate at epoch\n            bucketExchangeRates[pool_][bucketIndex_][burnEpoch_] = curBucketExchangeRate;\n\n            // retrieve the bucket exchange rate at the previous epoch\n            uint256 prevBucketExchangeRate = bucketExchangeRates[pool_][bucketIndex_][burnEpoch_ - 1];\n\n            // skip reward calculation if update at the previous epoch was missed and if exchange rate decreased due to bad debt\n            // prevents excess rewards from being provided from using a 0 value as an input to the interestFactor calculation below.\n            if (prevBucketExchangeRate != 0 && prevBucketExchangeRate < curBucketExchangeRate) {\n\n                // retrieve current deposit of the bucket\n                (, , , uint256 bucketDeposit, ) = IPool(pool_).bucketInfo(bucketIndex_);\n\n                uint256 burnFactor     = Maths.wmul(totalBurned_, bucketDeposit);\n                uint256 interestFactor = interestEarned_ == 0 ? 0 : Maths.wdiv(\n                    Maths.WAD - Maths.wdiv(prevBucketExchangeRate, curBucketExchangeRate),\n                    interestEarned_\n                );\n\n                // calculate rewards earned for updating bucket exchange rate \n                rewards_ += Maths.wmul(UPDATE_CLAIM_REWARD, Maths.wmul(burnFactor, interestFactor));\n            }\n        }\n    }\n\n    /** @notice Utility method to transfer `Ajna` rewards to the sender\n     *  @dev   This method is used to transfer rewards to the `msg.sender` after a successful claim or update.\n     *  @dev   It is used to ensure that rewards claimers will be able to claim some portion of the remaining tokens if a claim would exceed the remaining contract balance.\n     *  @param rewardsEarned_ Amount of rewards earned by the caller.\n     */\n    function _transferAjnaRewards(uint256 rewardsEarned_) internal {\n        // check that rewards earned isn't greater than remaining balance\n        // if remaining balance is greater, set to remaining balance\n        uint256 ajnaBalance = IERC20(ajnaToken).balanceOf(address(this));\n        if (rewardsEarned_ > ajnaBalance) rewardsEarned_ = ajnaBalance;\n\n        if (rewardsEarned_ != 0) {\n            // transfer rewards to sender\n            IERC20(ajnaToken).safeTransfer(msg.sender, rewardsEarned_);\n        }\n    }\n\n}"
    },
    {
      "filename": "ajna-grants/src/grants/base/StandardFunding.so",
      "content": ""
    }
  ]
}