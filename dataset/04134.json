{
  "Title": "Ether temporarily held during transactions can be stolen via reentrancy ✓ Fixed",
  "Content": "\n\n#### Resolution\n\n\n\nThis is addressed in [0xProject/[email protected]`437a3b0`](https://github.com/0xProject/protocol/commit/437a3b048d2ca0b489fe581acd2b4578c7a557f8) by transferring exactly `msg.value` in `sellToLiquidityProvider()`. This adequately protects against this specific vulnerability.\n\n\nThe client team decided to leave the accounting in `MetaTransactionsFeature` as-is due to the complexity/expense of tracking ether consumption more strictly.\n\n\n\n\n#### Description\n\n\nThe exchange proxy typically holds no ether balance, but it can temporarily hold a balance *during* a transaction. This balance is vulnerable to theft if the following conditions are met:\n\n\n1. No check at the end of the transaction reverts if ether goes missing,\n2. reentrancy is possible during the transaction, and\n3. a mechanism exists to spend ether held by the exchange proxy.\n\n\nWe found one example where these conditions are met, but it’s possible that more exist.\n\n\n#### Example\n\n\n[`MetaTransactionsFeature.executeMetaTransaction()`](https://github.com/0xProject/protocol/blob/475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/features/MetaTransactionsFeature.sol#L137) accepts ether, which is used to pay protocol fees. It’s possible for less than the full amount in `msg.value` to be consumed, which is why the function uses the `refundsAttachedEth` modifier to return any remaining ether to the caller:\n\n\n**code/contracts/zero-ex/contracts/src/features/MetaTransactionsFeature.sol:L98-L106**\n\n\n\n```\n/// @dev Refunds up to `msg.value` leftover ETH at the end of the call.\nmodifier refundsAttachedEth() {\n    \\_;\n    uint256 remainingBalance =\n        LibSafeMathV06.min256(msg.value, address(this).balance);\n    if (remainingBalance > 0) {\n        msg.sender.transfer(remainingBalance);\n    }\n}\n\n```\nNotice that this modifier just returns the remaining ether balance (up to `msg.value`). It does not check for a specific amount of remaining ether. This meets condition (1) above.\n\n\nIt’s impossible to reenter the system with a second metatransaction because `executeMetaTransaction()` uses the modifier `nonReentrant`, but there’s nothing preventing reentrancy via a different feature. We can achieve reentrancy by trading a token that uses callbacks (e.g. ERC777’s hooks) during transfers. This meets condition (2).\n\n\nTo find a full exploit, we also need a way to extract the ether held by the exchange proxy. [`LiquidityProviderFeature.sellToLiquidityProvider()`](https://github.com/0xProject/protocol/blob/475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/features/LiquidityProviderFeature.sol#L96) provides such a mechanism. By passing `ETH_TOKEN_ADDRESS` as the `inputToken` and an address in the attacker’s control as the `provider`, an attacker can transfer out any ether held by the exchange proxy. Note that `sellToLiquidityProvider()` can transfer any amount of ether, not limited to the amount sent via `msg.value`:\n\n\n**code/contracts/zero-ex/contracts/src/features/LiquidityProviderFeature.sol:L114-L115**\n\n\n\n```\nif (inputToken == ETH\\_TOKEN\\_ADDRESS) {\n    provider.transfer(sellAmount);\n\n```\nThis meets condition (3).\n\n\nThe full steps to exploit this vulnerability are as follows:\n\n\n1. A maker/attacker signs a trade where one of the tokens will invoke a callback during the trade.\n2. A taker signs a metatransaction to take this trade.\n3. A relayer sends in the metatransaction, providing more ether than is necessary to pay the protocol fee. (It’s unclear how likely this situation is.)\n4. During the token callback, the attacker invokes `LiquidityProviderFeature.sellToLiquidityProvider()` to transfer the excess ether to their account.\n5. The metatransaction feature returns the remaining ether balance, which is now zero.\n\n\n#### Recommendation\n\n\nIn general, we recommend using strict accounting of ether throughout the system. If there’s ever a temporary balance, it should be accurately resolved at the end of the transaction, after any potential reentrancy opportunities.\n\n\nFor the example we specifically found, we recommend doing strict accounting in the metatransactions feature. This means features called via a metatransaction would need to return how much ether was consumed. The metatransactions feature could then refund exactly `msg.value - <consumed ether>`. The transaction should be reverted if this fails because it means ether went missing during the transaction.\n\n\nWe also recommend limiting `sellToLiquidityProvider()` to only transfer up to `msg.value`. This is a form of defense in depth in case other vectors for a similar attack exist.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/zero-ex/contracts/src/features/MetaTransactionsFeature.sol",
      "content": "/*\n\n  Copyright 2020 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.6.5;\npragma experimental ABIEncoderV2;\n\nimport \"@0x/contracts-utils/contracts/src/v06/errors/LibRichErrorsV06.sol\";\nimport \"@0x/contracts-utils/contracts/src/v06/LibBytesV06.sol\";\nimport \"@0x/contracts-utils/contracts/src/v06/LibSafeMathV06.sol\";\nimport \"../errors/LibMetaTransactionsRichErrors.sol\";\nimport \"../fixins/FixinCommon.sol\";\nimport \"../fixins/FixinReentrancyGuard.sol\";\nimport \"../fixins/FixinTokenSpender.sol\";\nimport \"../fixins/FixinEIP712.sol\";\nimport \"../migrations/LibMigrate.sol\";\nimport \"../storage/LibMetaTransactionsStorage.sol\";\nimport \"./IMetaTransactionsFeature.sol\";\nimport \"./ITransformERC20Feature.sol\";\nimport \"./libs/LibSignature.sol\";\nimport \"./ISignatureValidatorFeature.sol\";\nimport \"./IFeature.sol\";\nimport \"./INativeOrdersFeature.sol\";\n\n/// @dev MetaTransactions feature.\ncontract MetaTransactionsFeature is\n    IFeature,\n    IMetaTransactionsFeature,\n    FixinCommon,\n    FixinReentrancyGuard,\n    FixinEIP712,\n    FixinTokenSpender\n{\n    using LibBytesV06 for bytes;\n    using LibRichErrorsV06 for bytes;\n\n    /// @dev Describes the state of a meta transaction.\n    struct ExecuteState {\n        // Sender of the meta-transaction.\n        address sender;\n        // Hash of the meta-transaction data.\n        bytes32 hash;\n        // The meta-transaction data.\n        MetaTransactionData mtx;\n        // The meta-transaction signature (by `mtx.signer`).\n        LibSignature.Signature signature;\n        // The selector of the function being called.\n        bytes4 selector;\n        // The ETH balance of this contract before performing the call.\n        uint256 selfBalance;\n        // The block number at which the meta-transaction was executed.\n        uint256 executedBlockNumber;\n    }\n\n    /// @dev Arguments for a `TransformERC20.transformERC20()` call.\n    struct ExternalTransformERC20Args {\n        IERC20TokenV06 inputToken;\n        IERC20TokenV06 outputToken;\n        uint256 inputTokenAmount;\n        uint256 minOutputTokenAmount;\n        ITransformERC20Feature.Transformation[] transformations;\n    }\n\n    /// @dev Name of this feature.\n    string public constant override FEATURE_NAME = \"MetaTransactions\";\n    /// @dev Version of this feature.\n    uint256 public immutable override FEATURE_VERSION = _encodeVersion(1, 1, 0);\n    /// @dev EIP712 typehash of the `MetaTransactionData` struct.\n    bytes32 public immutable MTX_EIP712_TYPEHASH = keccak256(\n        \"MetaTransactionData(\"\n            \"address signer,\"\n            \"address sender,\"\n            \"uint256 minGasPrice,\"\n            \"uint256 maxGasPrice,\"\n            \"uint256 expirationTimeSeconds,\"\n            \"uint256 salt,\"\n            \"bytes callData,\"\n            \"uint256 value,\"\n            \"address feeToken,\"\n            \"uint256 feeAmount\"\n        \")\"\n    );\n\n    /// @dev Refunds up to `msg.value` leftover ETH at the end of the call.\n    modifier refundsAttachedEth() {\n        _;\n        uint256 remainingBalance =\n            LibSafeMathV06.min256(msg.value, address(this).balance);\n        if (remainingBalance > 0) {\n            msg.sender.transfer(remainingBalance);\n        }\n    }\n\n    constructor(address zeroExAddress, bytes32 greedyTokensBloomFilter)\n        public\n        FixinCommon()\n        FixinEIP712(zeroExAddress)\n        FixinTokenSpender(greedyTokensBloomFilter)\n    {\n        // solhint-disable-next-line no-empty-blocks\n    }\n\n    /// @dev Initialize and register this feature.\n    ///      Should be delegatecalled by `Migrate.migrate()`.\n    /// @return success `LibMigrate.SUCCESS` on success.\n    function migrate()\n        external\n        returns (bytes4 success)\n    {\n        _registerFeatureFunction(this.executeMetaTransaction.selector);\n        _registerFeatureFunction(this.batchExecuteMetaTransactions.selector);\n        _registerFeatureFunction(this._executeMetaTransaction.selector);\n        _registerFeatureFunction(this.getMetaTransactionExecutedBlock.selector);\n        _registerFeatureFunction(this.getMetaTransactionHashExecutedBlock.selector);\n        _registerFeatureFunction(this.getMetaTransactionHash.selector);\n        return LibMigrate.MIGRATE_SUCCESS;\n    }\n\n    /// @dev Execute a single meta-transaction.\n    /// @param mtx The meta-transaction.\n    /// @param signature The signature by `mtx.signer`.\n    /// @return returnResult The ABI-encoded result of the underlying call.\n    function executeMetaTransaction(\n        MetaTransactionData memory mtx,\n        LibSignature.Signature memory signature\n    )\n        public\n        payable\n        override\n        nonReentrant(REENTRANCY_MTX)\n        refundsAttachedEth\n        returns (bytes memory returnResult)\n    {\n        ExecuteState memory state;\n        state.sender = msg.sender;\n        state.mtx = mtx;\n        state.hash = getMetaTransactionHash(mtx);\n        state.signature = signature;\n\n        returnResult = _executeMetaTransactionPrivate(state);\n    }\n\n    /// @dev Execute multiple meta-transactions.\n    /// @param mtxs The meta-transactions.\n    /// @param signatures The signature by each respective `mtx.signer`.\n    /// @return returnResults The ABI-encoded results of the underlying calls.\n    function batchExecuteMetaTransactions(\n        MetaTransactionData[] memory mtxs,\n        LibSignature.Signature[] memory signatures\n    )\n        public\n        payable\n        override\n        nonReentrant(REENTRANCY_MTX)\n        refundsAttachedEth\n        returns (bytes[] memory returnResults)\n    {\n        if (mtxs.length != signatures.length) {\n            LibMetaTransactionsRichErrors.InvalidMetaTransactionsArrayLengthsError(\n                mtxs.length,\n                signatures.length\n            ).rrevert();\n        }\n        returnResults = new bytes[](mtxs.length);\n        for (uint256 i = 0; i < mtxs.length; ++i) {\n            ExecuteState memory state;\n            state.sender = msg.sender;\n            state.mtx = mtxs[i];\n            state.hash = getMetaTransactionHash(mtxs[i]);\n            state.signature = signatures[i];\n\n            returnResults[i] = _executeMetaTransactionPrivate(state);\n        }\n    }\n\n    /// @dev Execute a meta-transaction via `sender`. Privileged variant.\n    ///      Only callable from within.\n    /// @param sender Who is executing the meta-transaction.\n    /// @param mtx The meta-transaction.\n    /// @param signature The signature by `mtx.signer`.\n    /// @return returnResult The ABI-encoded result of the underlying call.\n    function _executeMetaTransaction(\n        address sender,\n        MetaTransactionData memory mtx,\n        LibSignature.Signature memory signature\n    )\n        public\n        payable\n        override\n        onlySelf\n        returns (bytes memory returnResult)\n    {\n        ExecuteState memory state;\n        state.sender = sender;\n        state.mtx = mtx;\n        state.hash = getMetaTransactionHash(mtx);\n        state.signature = signature;\n\n        return _executeMetaTransactionPrivate(state);\n    }\n\n    /// @dev Get the block at which a meta-transaction has been executed.\n    /// @param mtx The meta-transaction.\n    /// @return blockNumber The block height when the meta-transactioin was executed.\n    function getMetaTransactionExecutedBlock(MetaTransactionData memory mtx)\n        public\n        override\n        view\n        returns (uint256 blockNumber)\n    {\n        return getMetaTransactionHashExecutedBlock(getMetaTransactionHash(mtx));\n    }\n\n    /// @dev Get the block at which a meta-transaction hash has been executed.\n    /// @param mtxHash The meta-transaction hash.\n    /// @return blockNumber The block height when the meta-transactioin was executed.\n    function getMetaTransactionHashExecutedBlock(bytes32 mtxHash)\n        public\n        override\n        view\n        returns (uint256 blockNumber)\n    {\n        return LibMetaTransactionsStorage.getStorage().mtxHashToExecutedBlockNumber[mtxHash];\n    }\n\n    /// @dev Get the EIP712 hash of a meta-transaction.\n    /// @param mtx The meta-transaction.\n    /// @return mtxHash The EIP712 hash of `mtx`.\n    function getMetaTransactionHash(MetaTransactionData memory mtx)\n        public\n        override\n        view\n        returns (bytes32 mtxHash)\n    {\n        return _getEIP712Hash(keccak256(abi.encode(\n            MTX_EIP712_TYPEHASH,\n            mtx.signer,\n            mtx.sender,\n            mtx.minGasPrice,\n            mtx.maxGasPrice,\n            mtx.expirationTimeSeconds,\n            mtx.salt,\n            keccak256(mtx.callData),\n            mtx.value,\n            mtx.feeToken,\n            mtx.feeAmount\n        )));\n    }\n\n    /// @dev Execute a meta-transaction by `sender`. Low-level, hidden variant.\n    /// @param state The `ExecuteState` for this metatransaction, with `sender`,\n    ///              `hash`, `mtx`, and `signature` fields filled.\n    /// @return returnResult The ABI-encoded result of the underlying call.\n    function _executeMetaTransactionPrivate(ExecuteState memory state)\n        private\n        returns (bytes memory returnResult)\n    {\n        _validateMetaTransaction(state);\n\n        // Mark the transaction executed by storing the block at which it was executed.\n        // Currently the block number just indicates that the mtx was executed and\n        // serves no other purpose from within this contract.\n        LibMetaTransactionsStorage.getStorage()\n            .mtxHashToExecutedBlockNumber[state.hash] = block.number;\n\n        // Pay the fee to the sender.\n        if (state.mtx.feeAmount > 0) {\n            _transferERC20Tokens(\n                state.mtx.feeToken,\n                state.mtx.signer,\n                state.sender,\n                state.mtx.feeAmount\n            );\n        }\n\n        // Execute the call based on the selector.\n        state.selector = state.mtx.callData.readBytes4(0);\n        if (state.selector == ITransformERC20Feature.transformERC20.selector) {\n            returnResult = _executeTransformERC20Call(state);\n        } else if (state.selector == INativeOrdersFeature.fillLimitOrder.selector) {\n            returnResult = _executeFillLimitOrderCall(state);\n        } else if (state.selector == INativeOrdersFeature.fillRfqOrder.selector) {\n            returnResult = _executeFillRfqOrderCall(state);\n        } else {\n            LibMetaTransactionsRichErrors\n                .MetaTransactionUnsupportedFunctionError(state.hash, state.selector)\n                .rrevert();\n        }\n        emit MetaTransactionExecuted(\n            state.hash,\n            state.selector,\n            state.mtx.signer,\n            state.mtx.sender\n        );\n    }\n\n    /// @dev Validate that a meta-transaction is executable.\n    function _validateMetaTransaction(ExecuteState memory state)\n        private\n        view\n    {\n        // Must be from the required sender, if set.\n        if (state.mtx.sender != address(0) && state.mtx.sender != state.sender) {\n            LibMetaTransactionsRichErrors\n                .MetaTransactionWrongSenderError(\n                    state.hash,\n                    state.sender,\n                    state.mtx.sender\n                ).rrevert();\n        }\n        // Must not be expired.\n        if (state.mtx.expirationTimeSeconds <= block.timestamp) {\n            LibMetaTransactionsRichErrors\n                .MetaTransactionExpiredError(\n                    state.hash,\n                    block.timestamp,\n                    state.mtx.expirationTimeSeconds\n                ).rrevert();\n        }\n        // Must have a valid gas price.\n        if (state.mtx.minGasPrice > tx.gasprice || state.mtx.maxGasPrice < tx.gasprice) {\n            LibMetaTransactionsRichErrors\n                .MetaTransactionGasPriceError(\n                    state.hash,\n                    tx.gasprice,\n                    state.mtx.minGasPrice,\n                    state.mtx.maxGasPrice\n                ).rrevert();\n        }\n        // Must have enough ETH.\n        state.selfBalance  = address(this).balance;\n        if (state.mtx.value > state.selfBalance) {\n            LibMetaTransactionsRichErrors\n                .MetaTransactionInsufficientEthError(\n                    state.hash,\n                    state.selfBalance,\n                    state.mtx.value\n                ).rrevert();\n        }\n\n        if (LibSignature.getSignerOfHash(state.hash, state.signature) !=\n                state.mtx.signer) {\n            LibSignatureRichErrors.SignatureValidationError(\n                LibSignatureRichErrors.SignatureValidationErrorCodes.WRONG_SIGNER,\n                state.hash,\n                state.mtx.signer,\n                // TODO: Remove this field from SignatureValidationError\n                //       when rich reverts are part of the protocol repo.\n                \"\"\n            ).rrevert();\n        }\n        // Transaction must not have been already executed.\n        state.executedBlockNumber = LibMetaTransactionsStorage\n            .getStorage().mtxHashToExecutedBlockNumber[state.hash];\n        if (state.executedBlockNumber != 0) {\n            LibMetaTransactionsRichErrors\n                .MetaTransactionAlreadyExecutedError(\n                    state.hash,\n                    state.executedBlockNumber\n                ).rrevert();\n        }\n    }\n\n    /// @dev Execute a `ITransformERC20Feature.transformERC20()` meta-transaction call\n    ///      by decoding the call args and translating the call to the internal\n    ///      `ITransformERC20Feature._transformERC20()` variant, where we can override\n    ///      the taker address.\n    function _executeTransformERC20Call(ExecuteState memory state)\n        private\n        returns (bytes memory returnResult)\n    {\n        // HACK(dorothy-zbornak): `abi.decode()` with the individual args\n        // will cause a stack overflow. But we can prefix the call data with an\n        // offset to transform it into the encoding for the equivalent single struct arg,\n        // since decoding a single struct arg consumes far less stack space than\n        // decoding multiple struct args.\n\n        // Where the encoding for multiple args (with the selector ommitted)\n        // would typically look like:\n        // | argument                 |  offset |\n        // |--------------------------|---------|\n        // | inputToken               |       0 |\n        // | outputToken              |      32 |\n        // | inputTokenAmount         |      64 |\n        // | minOutputTokenAmount     |      96 |\n        // | transformations (offset) |     128 | = 32\n        // | transformations (data)   |     160 |\n\n        // We will ABI-decode a single struct arg copy with the layout:\n        // | argument                 |  offset |\n        // |--------------------------|---------|\n        // | (arg 1 offset)           |       0 | = 32\n        // | inputToken               |      32 |\n        // | outputToken              |      64 |\n        // | inputTokenAmount         |      96 |\n        // | minOutputTokenAmount     |     128 |\n        // | transformations (offset) |     160 | = 32\n        // | transformations (data)   |     192 |\n\n        ExternalTransformERC20Args memory args;\n        {\n            bytes memory encodedStructArgs = new bytes(state.mtx.callData.length - 4 + 32);\n            // Copy the args data from the original, after the new struct offset prefix.\n            bytes memory fromCallData = state.mtx.callData;\n            assert(fromCallData.length >= 160);\n            uint256 fromMem;\n            uint256 toMem;\n            assembly {\n                // Prefix the calldata with a struct offset,\n                // which points to just one word over.\n                mstore(add(encodedStructArgs, 32), 32)\n                // Copy everything after the selector.\n                fromMem := add(fromCallData, 36)\n                // Start copying after the struct offset.\n                toMem := add(encodedStructArgs, 64)\n            }\n            LibBytesV06.memCopy(toMem, fromMem, fromCallData.length - 4);\n            // Decode call args for `ITransformERC20Feature.transformERC20()` as a struct.\n            args = abi.decode(encodedStructArgs, (ExternalTransformERC20Args));\n        }\n        // Call `ITransformERC20Feature._transformERC20()` (internal variant).\n        return _callSelf(\n            state.hash,\n            abi.encodeWithSelector(\n                ITransformERC20Feature._transformERC20.selector,\n                ITransformERC20Feature.TransformERC20Args({\n                    taker: state.mtx.signer, // taker is mtx signer\n                    inputToken: args.inputToken,\n                    outputToken: args.outputToken,\n                    inputTokenAmount: args.inputTokenAmount,\n                    minOutputTokenAmount: args.minOutputTokenAmount,\n                    transformations: args.transformations\n              })\n            ),\n            state.mtx.value\n        );\n    }\n\n    /// @dev Extract arguments from call data by copying everything after the\n    ///      4-byte selector into a new byte array.\n    /// @param callData The call data from which arguments are to be extracted.\n    /// @return args The extracted arguments as a byte array.\n    function _extractArgumentsFromCallData(\n        bytes memory callData\n    )\n        private\n        pure\n        returns (bytes memory args)\n    {\n        args = new bytes(callData.length - 4);\n        uint256 fromMem;\n        uint256 toMem;\n\n        assembly {\n            fromMem := add(callData, 36) // skip length and 4-byte selector\n            toMem := add(args, 32)       // write after length prefix\n        }\n\n        LibBytesV06.memCopy(toMem, fromMem, args.length);\n\n        return args;\n    }\n\n    /// @dev Execute a `INativeOrdersFeature.fillLimitOrder()` meta-transaction call\n    ///      by decoding the call args and translating the call to the internal\n    ///      `INativeOrdersFeature._fillLimitOrder()` variant, where we can override\n    ///      the taker address.\n    function _executeFillLimitOrderCall(ExecuteState memory state)\n        private\n        returns (bytes memory returnResult)\n    {\n        LibNativeOrder.LimitOrder memory order;\n        LibSignature.Signature memory signature;\n        uint128 takerTokenFillAmount;\n\n        bytes memory args = _extractArgumentsFromCallData(state.mtx.callData);\n        (order, signature, takerTokenFillAmount) = abi.decode(args, (LibNativeOrder.LimitOrder, LibSignature.Signature, uint128));\n\n        return _callSelf(\n            state.hash,\n            abi.encodeWithSelector(\n                INativeOrdersFeature._fillLimitOrder.selector,\n                order,\n                signature,\n                takerTokenFillAmount,\n                state.mtx.signer, // taker is mtx signer\n                msg.sender\n            ),\n            state.mtx.value\n        );\n    }\n\n    /// @dev Execute a `INativeOrdersFeature.fillRfqOrder()` meta-transaction call\n    ///      by decoding the call args and translating the call to the internal\n    ///      `INativeOrdersFeature._fillRfqOrder()` variant, where we can overrideunimpleme\n    ///      the taker address.\n    function _executeFillRfqOrderCall(ExecuteState memory state)\n        private\n        returns (bytes memory returnResult)\n    {\n        LibNativeOrder.RfqOrder memory order;\n        LibSignature.Signature memory signature;\n        uint128 takerTokenFillAmount;\n\n        bytes memory args = _extractArgumentsFromCallData(state.mtx.callData);\n        (order, signature, takerTokenFillAmount) = abi.decode(args, (LibNativeOrder.RfqOrder, LibSignature.Signature, uint128));\n\n        return _callSelf(\n            state.hash,\n            abi.encodeWithSelector(\n                INativeOrdersFeature._fillRfqOrder.selector,\n                order,\n                signature,\n                takerTokenFillAmount,\n                state.mtx.signer // taker is mtx signer\n            ),\n            state.mtx.value\n        );\n    }\n\n    /// @dev Make an arbitrary internal, meta-transaction call.\n    ///      Warning: Do not let unadulterated `callData` into this function.\n    function _callSelf(bytes32 hash, bytes memory callData, uint256 value)\n        private\n        returns (bytes memory returnResult)\n    {\n        bool success;\n        (success, returnResult) = address(this).call{value: value}(callData);\n        if (!success) {\n            LibMetaTransactionsRichErrors.MetaTransactionCallFailedError(\n                hash,\n                callData,\n                returnResult\n            ).rrevert();\n        }\n    }\n}"
    },
    {
      "filename": "contracts/zero-ex/contracts/src/features/LiquidityProviderFeature.sol",
      "content": "/*\n\n  Copyright 2020 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.6.5;\npragma experimental ABIEncoderV2;\n\nimport \"@0x/contracts-erc20/contracts/src/v06/IERC20TokenV06.sol\";\nimport \"@0x/contracts-utils/contracts/src/v06/errors/LibRichErrorsV06.sol\";\nimport \"@0x/contracts-utils/contracts/src/v06/LibSafeMathV06.sol\";\nimport \"../errors/LibLiquidityProviderRichErrors.sol\";\nimport \"../external/ILiquidityProviderSandbox.sol\";\nimport \"../external/LiquidityProviderSandbox.sol\";\nimport \"../fixins/FixinCommon.sol\";\nimport \"../fixins/FixinTokenSpender.sol\";\nimport \"../migrations/LibMigrate.sol\";\nimport \"./IFeature.sol\";\nimport \"./ILiquidityProviderFeature.sol\";\n\n\ncontract LiquidityProviderFeature is\n    IFeature,\n    ILiquidityProviderFeature,\n    FixinCommon,\n    FixinTokenSpender\n{\n    using LibSafeMathV06 for uint256;\n    using LibRichErrorsV06 for bytes;\n\n    /// @dev Name of this feature.\n    string public constant override FEATURE_NAME = \"LiquidityProviderFeature\";\n    /// @dev Version of this feature.\n    uint256 public immutable override FEATURE_VERSION = _encodeVersion(1, 0, 1);\n\n    /// @dev ETH pseudo-token address.\n    address constant internal ETH_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    /// @dev The sandbox contract address.\n    ILiquidityProviderSandbox public immutable sandbox;\n\n    /// @dev Event for data pipeline.\n    event LiquidityProviderSwap(\n        address inputToken,\n        address outputToken,\n        uint256 inputTokenAmount,\n        uint256 outputTokenAmount,\n        address provider,\n        address recipient\n    );\n\n    constructor(LiquidityProviderSandbox sandbox_, bytes32 greedyTokensBloomFilter)\n        public\n        FixinCommon()\n        FixinTokenSpender(greedyTokensBloomFilter)\n    {\n        sandbox = sandbox_;\n    }\n\n    /// @dev Initialize and register this feature.\n    ///      Should be delegatecalled by `Migrate.migrate()`.\n    /// @return success `LibMigrate.SUCCESS` on success.\n    function migrate()\n        external\n        returns (bytes4 success)\n    {\n        _registerFeatureFunction(this.sellToLiquidityProvider.selector);\n        return LibMigrate.MIGRATE_SUCCESS;\n    }\n\n    /// @dev Sells `sellAmount` of `inputToken` to the liquidity provider\n    ///      at the given `provider` address.\n    /// @param inputToken The token being sold.\n    /// @param outputToken The token being bought.\n    /// @param provider The address of the on-chain liquidity provider\n    ///        to trade with.\n    /// @param recipient The recipient of the bought tokens. If equal to\n    ///        address(0), `msg.sender` is assumed to be the recipient.\n    /// @param sellAmount The amount of `inputToken` to sell.\n    /// @param minBuyAmount The minimum acceptable amount of `outputToken` to\n    ///        buy. Reverts if this amount is not satisfied.\n    /// @param auxiliaryData Auxiliary data supplied to the `provider` contract.\n    /// @return boughtAmount The amount of `outputToken` bought.\n    function sellToLiquidityProvider(\n        address inputToken,\n        address outputToken,\n        address payable provider,\n        address recipient,\n        uint256 sellAmount,\n        uint256 minBuyAmount,\n        bytes calldata auxiliaryData\n    )\n        external\n        override\n        payable\n        returns (uint256 boughtAmount)\n    {\n        if (recipient == address(0)) {\n            recipient = msg.sender;\n        }\n\n        if (inputToken == ETH_TOKEN_ADDRESS) {\n            provider.transfer(sellAmount);\n        } else {\n            _transferERC20Tokens(\n                IERC20TokenV06(inputToken),\n                msg.sender,\n                provider,\n                sellAmount\n            );\n        }\n\n        if (inputToken == ETH_TOKEN_ADDRESS) {\n            uint256 balanceBefore = IERC20TokenV06(outputToken).balanceOf(recipient);\n            sandbox.executeSellEthForToken(\n                provider,\n                outputToken,\n                recipient,\n                minBuyAmount,\n                auxiliaryData\n            );\n            boughtAmount = IERC20TokenV06(outputToken).balanceOf(recipient).safeSub(balanceBefore);\n        } else if (outputToken == ETH_TOKEN_ADDRESS) {\n            uint256 balanceBefore = recipient.balance;\n            sandbox.executeSellTokenForEth(\n                provider,\n                inputToken,\n                recipient,\n                minBuyAmount,\n                auxiliaryData\n            );\n            boughtAmount = recipient.balance.safeSub(balanceBefore);\n        } else {\n            uint256 balanceBefore = IERC20TokenV06(outputToken).balanceOf(recipient);\n            sandbox.executeSellTokenForToken(\n                provider,\n                inputToken,\n                outputToken,\n                recipient,\n                minBuyAmount,\n                auxiliaryData\n            );\n            boughtAmount = IERC20TokenV06(outputToken).balanceOf(recipient).safeSub(balanceBefore);\n        }\n\n        if (boughtAmount < minBuyAmount) {\n            LibLiquidityProviderRichErrors.LiquidityProviderIncompleteSellError(\n                provider,\n                outputToken,\n                inputToken,\n                sellAmount,\n                boughtAmount,\n                minBuyAmount\n            ).rrevert();\n        }\n\n        emit LiquidityProviderSwap(\n            inputToken,\n            outputToken,\n            sellAmount,\n            boughtAmount,\n            provider,\n            recipient\n        );\n    }\n}"
    }
  ]
}