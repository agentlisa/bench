{
  "Title": "[H-05] Redeemer.redeem() for Element withdraws PT to wrong address.",
  "Content": "_Submitted by auditor0517, also found by 0x52, cccz, datapunk, kenzo, and pashov_\n\nRedeemer.redeem() for Element withdraws PT to wrong address.\n\nThis might cause a result of loss of PT.\n\n### Proof of Concept\n\nAccording to the ReadMe.md, Redeemer should transfer external principal tokens from Lender.sol to Redeemer.sol.\n\nBut it transfers to the \"marketPlace\" and it would lose the PT.\n\n### Recommended Mitigation Steps\n\nModify [IElementToken(principal).withdrawPrincipal(amount, marketPlace);](https://github.com/code-423n4/2022-06-illuminate/blob/92cbb0724e594ce025d6b6ed050d3548a38c264b/redeemer/Redeemer.sol#L187) like this.\n\n    IElementToken(principal).withdrawPrincipal(amount, address(this));\n\n**[sourabhmarathe (Illuminate) confirmed](https://github.com/code-423n4/2022-06-illuminate-findings/issues/182)**\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2022-06-illuminate",
  "Code": [
    {
      "filename": "redeemer/Redeemer.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Interfaces.sol';\nimport './MarketPlace.sol';\nimport './Safe.sol';\n\n/// @title Redeemer\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice The Redeemer contract is used to redeem the underlying lent capital of a loan.\n/// @notice Users may redeem their ERC-5095 tokens for the underlying asset represented by that token after maturity.\ncontract Redeemer {\n    error Invalid(string);\n    error Unauthorized();\n    error Exists(string);\n\n    /// @notice address that is allowed to set the lender and marketplace\n    address public admin;\n    /// @notice address used to access the MarketPlace's markets mapping\n    address public marketPlace;\n    /// @notice address that custodies principal tokens for all markets\n    address public lender;\n\n\n    /// @notice third party contract needed to lend on Swivel\n    address public swivelAddr;\n    /// @notice third party contract needed to lend on Pendle\n    address public immutable pendleAddr;\n    /// @notice third party contract needed to lend on Tempus\n    address public immutable tempusAddr;\n    /// @notice third party contract needed to lend on APWine\n    address public apwineAddr;\n\n    /// @notice emitted upon redemption of a loan\n    event Redeem(uint8 principal, address indexed underlying, uint256 indexed maturity, uint256 amount);\n\n    /// @notice Initializes the Redeemer contract\n    /// @param l the lender contract\n    /// @param s the Swivel contract\n    /// @param p the Pendle contract\n    /// @param t the Tempus contract\n    /// @param a the APWine contract\n    constructor(\n        address l,\n        address s,\n        address p,\n        address t,\n        address a\n    ) {\n        admin = msg.sender;\n        lender = l;\n        swivelAddr = s;\n        pendleAddr = p;\n        tempusAddr = t;\n        apwineAddr = a;\n    }\n\n    /// @notice sets the admin address\n    /// @param a Address of a new admin\n    /// @return bool true if successful\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        return true;\n    }\n\n    /// @notice sets the address of the marketplace contract which contains the addresses of all the fixed rate markets\n    /// @param m the address of the marketplace contract\n    /// @return bool true if the address was set, false otherwise\n    function setMarketPlace(address m) external authorized(admin) returns (bool) {\n        if (marketPlace != address(0)) {\n            revert Exists('marketplace');\n        }\n        marketPlace = m;\n        return true;\n    }\n\n    /// @notice sets the address of the lender contract which contains the addresses of all the fixed rate markets\n    /// @param l the address of the lender contract\n    /// @return bool true if the address was set, false otherwise\n    function setLender(address l) external authorized(admin) returns (bool) {\n        if (lender != address(0)) {\n            revert Exists('lender');\n        }\n        lender = l;\n        return true;\n    }\n\n    /// @notice sets the feenominator to the given value\n    /// @param s the address of the Swivel.sol Router\n    /// @return bool true if successful\n    function setSwivel(address s) external authorized(admin) returns (bool) {\n        swivelAddr = s;\n        return true;\n    }\n\n    /// @notice redeems underlying token for Illuminate, APWine and Tempus protocols\n    /// @dev Illuminate burns its tokens prior to redemption, unlike APWine and\n    /// Tempus, which redeem PTs to the redeemer, transferring the underlying to\n    /// this redeemer contract. Consequently, only Illuminate's redeem returns funds\n    /// to the user.\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u the underlying token being redeemed\n    /// @param m the maturity of the market being redeemed\n    /// @param o address of the controller or contract that manages the underlying token\n    /// @return bool true if the redemption was successful\n    function redeem(\n        uint8 p,\n        address u,\n        uint256 m,\n        address o\n    ) public returns (bool) {\n        // Get the address of the principal token being redeemed\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n\n        if (p == uint8(MarketPlace.Principals.Illuminate)) {\n            // Get Illuminate's principal token\n            IERC5095 token = IERC5095(principal);\n            // Get the amount of tokens to be redeemed from the sender\n            uint256 amount = token.balanceOf(msg.sender);\n            // Make sure the market has matured\n            if (block.timestamp < token.maturity()) {\n                revert Invalid('not matured');\n            }\n            // Burn the prinicipal token from Illuminate\n            token.burn(o, amount);\n            // Transfer the original underlying token back to the user\n            Safe.transferFrom(IERC20(u), lender, address(this), amount);\n\n            emit Redeem(0, u, m, amount);\n        }\n        else {\n            // Get the amount of tokens to be redeemed from the principal token\n            uint256 amount = IERC20(principal).balanceOf(lender);\n            // Transfer the principal token from the lender contract to here\n            Safe.transferFrom(IERC20(u), lender, address(this), amount);\n\n            if (p == uint8(MarketPlace.Principals.Apwine)) {\n                // Redeem the underlying token from APWine to Illuminate\n                IAPWine(apwineAddr).withdraw(o, amount);\n            } else if (p == uint8(MarketPlace.Principals.Tempus)) {\n                // Redeem the tokens from the Tempus contract to Illuminate\n                ITempus(tempusAddr).redeemToBacking(o, amount, 0, address(this));\n            } else {\n                revert Invalid('principal');\n            }\n            emit Redeem(0, u, m, amount);\n        }\n\n        return true;\n    }\n\n    /// @notice redeem method for Swivel, Yield, Element and Notional protocols\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u underlying token being redeemed\n    /// @param m maturity of the market being redeemed\n    /// @return bool true if the redemption was successful\n    function redeem(\n        uint8 p,\n        address u,\n        uint256 m\n    ) public returns (bool) {\n        // Get the principal token that is being redeemed by the user\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n\n        // Make sure we have the correct principal\n        if (\n            p != uint8(MarketPlace.Principals.Swivel) &&\n            p != uint8(MarketPlace.Principals.Element) &&\n            p != uint8(MarketPlace.Principals.Yield) &&\n            p != uint8(MarketPlace.Principals.Notional)\n        ) {\n            revert Invalid('principal');\n        }\n\n        // The amount redeemed should be the balance of the principal token held by the Illuminate contract\n        uint256 amount = IERC20(principal).balanceOf(lender);\n\n        // Transfer the principal token from the lender contract to here\n        Safe.transferFrom(IERC20(principal), lender, address(this), amount);\n\n        if (p == uint8(MarketPlace.Principals.Swivel)) {\n            // Redeems zc tokens to the sender's address\n            ISwivel(swivelAddr).redeemZcToken(u, m, amount);\n        } else if (p == uint8(MarketPlace.Principals.Element)) {\n            // Redeems principal tokens from element\n            IElementToken(principal).withdrawPrincipal(amount, marketPlace);\n        } else if (p == uint8(MarketPlace.Principals.Yield)) {\n            // Redeems prinicipal tokens from yield\n            IYieldToken(principal).redeem(address(this), address(this), amount);\n        } else if (p == uint8(MarketPlace.Principals.Notional)) {\n            // Redeems the principal token from notional\n            amount = INotional(principal).maxRedeem(address(this));\n        }\n\n        emit Redeem(p, u, m, amount);\n        return true;\n    }\n\n    /// @notice redeem method signature for Pendle\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u underlying token being redeemed\n    /// @param m maturity of the market being redeemed\n    /// @param i forge id used by Pendle to redeem the underlying token\n    /// @return bool true if the redemption was successful\n    function redeem(\n        uint8 p,\n        address u,\n        uint256 m,\n        bytes32 i\n    ) public returns (bool) {\n        // Check the principal is Pendle\n        if (p != uint8(MarketPlace.Principals.Pendle)) {\n            revert Invalid('principal');\n        }\n\n        // Get the principal token that is being redeemed by the user\n        IERC20 token = IERC20(IMarketPlace(marketPlace).markets(u, m, p));\n\n        // Get the balance of tokens to be redeemed by the user\n        uint256 amount = token.balanceOf(lender);\n\n        // Transfer the user's tokens to the redeem contract\n        Safe.transferFrom(token, lender, address(this), amount);\n\n        // Redeem the tokens from the Pendle contract\n        IPendle(pendleAddr).redeemAfterExpiry(i, u, m);\n        \n        emit Redeem(p, u, m, amount);\n        return true;\n    }\n\n    /// @notice redeem method signature for Sense\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u underlying token being redeemed\n    /// @param m maturity of the market being redeemed\n    /// @param d Sense contract that splits the loan's prinicpal and yield\n    /// @param o Sense contract that [d] calls into to adapt the underlying to Sense\n    /// @return bool true if the redemption was successful\n    function redeem(\n        uint8 p,\n        address u,\n        uint256 m,\n        address d,\n        address o\n    ) public returns (bool) {\n        // Check the principal is Sense\n        if (p != uint8(MarketPlace.Principals.Sense)) {\n            revert Invalid('principal');\n        }\n\n        // Get the principal token for the given market\n        IERC20 token = IERC20(IMarketPlace(marketPlace).markets(u, m, p));\n\n        // Get the balance of tokens to be redeemed by the user\n        uint256 amount = token.balanceOf(lender);\n\n        // Transfer the user's tokens to the redeem contract\n        Safe.transferFrom(token, lender, address(this), amount);\n\n        // Redeem the tokens from the Sense contract\n        ISense(d).redeem(o, m, amount);\n\n        emit Redeem(p, u, m, amount);\n        return true;\n    }\n\n    /// @notice implements the redeem method for the contract to fulfill the ERC-5095 interface\n    /// @param u address of the underlying asset\n    /// @param m maturity of the market\n    /// @param f address from where the underlying asset will be burned\n    /// @param t address to where the underlying asset will be transferred\n    /// @param a amount of the underlying asset to be burned and sent to the to\n    /// @return bool true if the underlying asset was burned successfully\n    function authRedeem(\n        address u,\n        uint256 m,\n        address f,\n        address t,\n        uint256 a\n    ) public authorized(IMarketPlace(marketPlace).markets(u, m, 0)) returns (bool) {\n        // Get the principal token for the given market\n        IERC5095 pt = IERC5095(IMarketPlace(marketPlace).markets(u, m, 0));\n\n        // Make sure the market has matured\n        if (block.timestamp < pt.maturity()) {\n            revert Invalid('not matured');\n        }\n\n        // Burn the user's principal tokens\n        pt.burn(f, a);\n\n        // Transfer the original underlying token back to the user\n        Safe.transfer(IERC20(u), t, a);\n        return true;\n    }\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Unauthorized();\n        }\n        _;\n    }\n}"
    }
  ]
}