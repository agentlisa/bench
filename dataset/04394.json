{
  "Title": "[L02] Different behavior between ETH and Tokens collateral",
  "Content": "The project allows the usage of ETH or ERC20 tokens as collateral. Because ETH is a coin and not a token, it does not have a contract which keeps the account balances nor an address defined for that asset.\n\n\nThe project solves this by [pretending that ETH is an ERC20 compliant token in the zero address](https://github.com/opynfinance/Convexity-Protocol/blob/c34598565cba2bfcf824eb2da63d95c7f5dda4fa/contracts/OptionsFactory.sol#L133-L135).\n\n\nThis is a type of [semantic overload](https://forum.openzeppelin.com/t/watch-out-for-semantic-overloading/1088) over the zero address, which is used for two purposes. 1. to represent ‘ETH contract address’. 2. to show if a token asset [is supported or not](https://github.com/opynfinance/Convexity-Protocol/blob/c34598565cba2bfcf824eb2da63d95c7f5dda4fa/contracts/OptionsFactory.sol#L137) by checking if the desired asset has changed its address in the `tokens` mapping from the default zero address.\n\n\nAnother problem is that if in the future the project needs to support only ERC20 token collaterals, [ETH cannot be removed from the supported assets when the `deleteAsset` function is called](https://github.com/opynfinance/Convexity-Protocol/blob/c34598565cba2bfcf824eb2da63d95c7f5dda4fa/contracts/OptionsFactory.sol#L122).\n\n\nConsider treating ETH as a different collateral type instead of adapting it to a ERC20 compliant token or add the necessary functionalities to keep up with the token based ones.\n\n\n**Update**: *The Opyn team explained they always plan on supporting ETH as a collateral asset hence didn’t remove it.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/OptionsFactory.sol",
      "content": "pragma solidity 0.5.10;\n\nimport \"./OptionsContract.sol\";\nimport \"./OptionsUtils.sol\";\nimport \"./lib/StringComparator.sol\";\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract OptionsFactory is Ownable {\n    using StringComparator for string;\n\n    // keys saved in front-end -- look at the docs if needed\n    mapping (string => IERC20) public tokens;\n    address[] public optionsContracts;\n\n    // The contract which interfaces with the exchange + oracle\n    OptionsExchange public optionsExchange;\n\n    event OptionsContractCreated(address addr);\n    event AssetAdded(string indexed asset, address indexed addr);\n    event AssetChanged(string indexed asset, address indexed addr);\n    event AssetDeleted(string indexed asset);\n\n    /**\n     * @param _optionsExchangeAddr: The contract which interfaces with the exchange + oracle\n     */\n    constructor(OptionsExchange _optionsExchangeAddr) public {\n        optionsExchange = OptionsExchange(_optionsExchangeAddr);\n    }\n\n    /**\n     * @notice creates a new Option Contract\n     * @param _collateralType The collateral asset. Eg. \"ETH\"\n     * @param _collateralExp The number of decimals the collateral asset has\n     * @param _underlyingType The underlying asset. Eg. \"DAI\"\n     * @param _oTokenExchangeExp Units of underlying that 1 oToken protects\n     * @param _strikePrice The amount of strike asset that will be paid out\n     * @param _strikeExp The precision of the strike asset (-18 if ETH)\n     * @param _strikeAsset The asset in which the insurance is calculated\n     * @param _expiry The time at which the insurance expires\n     * @param _windowSize UNIX time. Exercise window is from `expiry - _windowSize` to `expiry`.\n     */\n    function createOptionsContract(\n        string memory _collateralType,\n        int32 _collateralExp,\n        string memory _underlyingType,\n        int32 _oTokenExchangeExp,\n        uint256 _strikePrice,\n        int32 _strikeExp,\n        string memory _strikeAsset,\n        uint256 _expiry,\n        uint256 _windowSize\n    )\n        public\n        returns (address)\n    {\n        require(supportsAsset(_collateralType), \"Collateral type not supported\");\n        require(supportsAsset(_underlyingType), \"Underlying type not supported\");\n        require(supportsAsset(_strikeAsset), \"Strike asset type not supported\");\n\n        OptionsContract optionsContract = new OptionsContract(\n            tokens[_collateralType],\n            _collateralExp,\n            tokens[_underlyingType],\n            _oTokenExchangeExp,\n            _strikePrice,\n            _strikeExp,\n            tokens[_strikeAsset],\n            _expiry,\n            optionsExchange,\n            _windowSize\n        );\n\n        optionsContracts.push(address(optionsContract));\n        emit OptionsContractCreated(address(optionsContract));\n\n        // Set the owner for the options contract.\n        optionsContract.transferOwnership(owner());\n\n        return address(optionsContract);\n    }\n\n    /**\n     * @notice The number of Option Contracts that the Factory contract has stored\n     */\n    function getNumberOfOptionsContracts() public view returns (uint256) {\n        return optionsContracts.length;\n    }\n\n    /**\n     * @notice The owner of the Factory Contract can add a new asset to be supported\n     * @dev admin don't add ETH. ETH is set to 0x0.\n     * @param _asset The ticker symbol for the asset\n     * @param _addr The address of the asset\n     */\n    function addAsset(string memory _asset, address _addr) public onlyOwner {\n        require(!supportsAsset(_asset), \"Asset already added\");\n        require(_addr != address(0), \"Cannot set to address(0)\");\n\n        tokens[_asset] = IERC20(_addr);\n        emit AssetAdded(_asset, _addr);\n    }\n\n    /**\n     * @notice The owner of the Factory Contract can change an existing asset's address\n     * @param _asset The ticker symbol for the asset\n     * @param _addr The address of the asset\n     */\n    function changeAsset(string memory _asset, address _addr) public onlyOwner {\n        require(tokens[_asset] != IERC20(0), \"Trying to replace a non-existent asset\");\n        require(_addr != address(0), \"Cannot set to address(0)\");\n\n        tokens[_asset] = IERC20(_addr);\n        emit AssetChanged(_asset, _addr);\n    }\n\n    /**\n     * @notice The owner of the Factory Contract can delete an existing asset's address\n     * @param _asset The ticker symbol for the asset\n     */\n    function deleteAsset(string memory _asset) public onlyOwner {\n        require(tokens[_asset] != IERC20(0), \"Trying to delete a non-existent asset\");\n\n        tokens[_asset] = IERC20(0);\n        emit AssetDeleted(_asset);\n    }\n\n    /**\n     * @notice Check if the Factory contract supports a specific asset\n     * @param _asset The ticker symbol for the asset\n     */\n    function supportsAsset(string memory _asset) public view returns (bool) {\n        if (_asset.compareStrings(\"ETH\")) {\n            return true;\n        }\n\n        return tokens[_asset] != IERC20(0);\n    }\n}"
    },
    {
      "filename": "contracts/OptionsFactory.sol",
      "content": "pragma solidity 0.5.10;\n\nimport \"./OptionsContract.sol\";\nimport \"./OptionsUtils.sol\";\nimport \"./lib/StringComparator.sol\";\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract OptionsFactory is Ownable {\n    using StringComparator for string;\n\n    // keys saved in front-end -- look at the docs if needed\n    mapping (string => IERC20) public tokens;\n    address[] public optionsContracts;\n\n    // The contract which interfaces with the exchange + oracle\n    OptionsExchange public optionsExchange;\n\n    event OptionsContractCreated(address addr);\n    event AssetAdded(string indexed asset, address indexed addr);\n    event AssetChanged(string indexed asset, address indexed addr);\n    event AssetDeleted(string indexed asset);\n\n    /**\n     * @param _optionsExchangeAddr: The contract which interfaces with the exchange + oracle\n     */\n    constructor(OptionsExchange _optionsExchangeAddr) public {\n        optionsExchange = OptionsExchange(_optionsExchangeAddr);\n    }\n\n    /**\n     * @notice creates a new Option Contract\n     * @param _collateralType The collateral asset. Eg. \"ETH\"\n     * @param _collateralExp The number of decimals the collateral asset has\n     * @param _underlyingType The underlying asset. Eg. \"DAI\"\n     * @param _oTokenExchangeExp Units of underlying that 1 oToken protects\n     * @param _strikePrice The amount of strike asset that will be paid out\n     * @param _strikeExp The precision of the strike asset (-18 if ETH)\n     * @param _strikeAsset The asset in which the insurance is calculated\n     * @param _expiry The time at which the insurance expires\n     * @param _windowSize UNIX time. Exercise window is from `expiry - _windowSize` to `expiry`.\n     */\n    function createOptionsContract(\n        string memory _collateralType,\n        int32 _collateralExp,\n        string memory _underlyingType,\n        int32 _oTokenExchangeExp,\n        uint256 _strikePrice,\n        int32 _strikeExp,\n        string memory _strikeAsset,\n        uint256 _expiry,\n        uint256 _windowSize\n    )\n        public\n        returns (address)\n    {\n        require(supportsAsset(_collateralType), \"Collateral type not supported\");\n        require(supportsAsset(_underlyingType), \"Underlying type not supported\");\n        require(supportsAsset(_strikeAsset), \"Strike asset type not supported\");\n\n        OptionsContract optionsContract = new OptionsContract(\n            tokens[_collateralType],\n            _collateralExp,\n            tokens[_underlyingType],\n            _oTokenExchangeExp,\n            _strikePrice,\n            _strikeExp,\n            tokens[_strikeAsset],\n            _expiry,\n            optionsExchange,\n            _windowSize\n        );\n\n        optionsContracts.push(address(optionsContract));\n        emit OptionsContractCreated(address(optionsContract));\n\n        // Set the owner for the options contract.\n        optionsContract.transferOwnership(owner());\n\n        return address(optionsContract);\n    }\n\n    /**\n     * @notice The number of Option Contracts that the Factory contract has stored\n     */\n    function getNumberOfOptionsContracts() public view returns (uint256) {\n        return optionsContracts.length;\n    }\n\n    /**\n     * @notice The owner of the Factory Contract can add a new asset to be supported\n     * @dev admin don't add ETH. ETH is set to 0x0.\n     * @param _asset The ticker symbol for the asset\n     * @param _addr The address of the asset\n     */\n    function addAsset(string memory _asset, address _addr) public onlyOwner {\n        require(!supportsAsset(_asset), \"Asset already added\");\n        require(_addr != address(0), \"Cannot set to address(0)\");\n\n        tokens[_asset] = IERC20(_addr);\n        emit AssetAdded(_asset, _addr);\n    }\n\n    /**\n     * @notice The owner of the Factory Contract can change an existing asset's address\n     * @param _asset The ticker symbol for the asset\n     * @param _addr The address of the asset\n     */\n    function changeAsset(string memory _asset, address _addr) public onlyOwner {\n        require(tokens[_asset] != IERC20(0), \"Trying to replace a non-existent asset\");\n        require(_addr != address(0), \"Cannot set to address(0)\");\n\n        tokens[_asset] = IERC20(_addr);\n        emit AssetChanged(_asset, _addr);\n    }\n\n    /**\n     * @notice The owner of the Factory Contract can delete an existing asset's address\n     * @param _asset The ticker symbol for the asset\n     */\n    function deleteAsset(string memory _asset) public onlyOwner {\n        require(tokens[_asset] != IERC20(0), \"Trying to delete a non-existent asset\");\n\n        tokens[_asset] = IERC20(0);\n        emit AssetDeleted(_asset);\n    }\n\n    /**\n     * @notice Check if the Factory contract supports a specific asset\n     * @param _asset The ticker symbol for the asset\n     */\n    function supportsAsset(string memory _asset) public view returns (bool) {\n        if (_asset.compareStrings(\"ETH\")) {\n            return true;\n        }\n\n        return tokens[_asset] != IERC20(0);\n    }\n}"
    },
    {
      "filename": "contracts/OptionsFactory.sol",
      "content": "pragma solidity 0.5.10;\n\nimport \"./OptionsContract.sol\";\nimport \"./OptionsUtils.sol\";\nimport \"./lib/StringComparator.sol\";\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract OptionsFactory is Ownable {\n    using StringComparator for string;\n\n    // keys saved in front-end -- look at the docs if needed\n    mapping (string => IERC20) public tokens;\n    address[] public optionsContracts;\n\n    // The contract which interfaces with the exchange + oracle\n    OptionsExchange public optionsExchange;\n\n    event OptionsContractCreated(address addr);\n    event AssetAdded(string indexed asset, address indexed addr);\n    event AssetChanged(string indexed asset, address indexed addr);\n    event AssetDeleted(string indexed asset);\n\n    /**\n     * @param _optionsExchangeAddr: The contract which interfaces with the exchange + oracle\n     */\n    constructor(OptionsExchange _optionsExchangeAddr) public {\n        optionsExchange = OptionsExchange(_optionsExchangeAddr);\n    }\n\n    /**\n     * @notice creates a new Option Contract\n     * @param _collateralType The collateral asset. Eg. \"ETH\"\n     * @param _collateralExp The number of decimals the collateral asset has\n     * @param _underlyingType The underlying asset. Eg. \"DAI\"\n     * @param _oTokenExchangeExp Units of underlying that 1 oToken protects\n     * @param _strikePrice The amount of strike asset that will be paid out\n     * @param _strikeExp The precision of the strike asset (-18 if ETH)\n     * @param _strikeAsset The asset in which the insurance is calculated\n     * @param _expiry The time at which the insurance expires\n     * @param _windowSize UNIX time. Exercise window is from `expiry - _windowSize` to `expiry`.\n     */\n    function createOptionsContract(\n        string memory _collateralType,\n        int32 _collateralExp,\n        string memory _underlyingType,\n        int32 _oTokenExchangeExp,\n        uint256 _strikePrice,\n        int32 _strikeExp,\n        string memory _strikeAsset,\n        uint256 _expiry,\n        uint256 _windowSize\n    )\n        public\n        returns (address)\n    {\n        require(supportsAsset(_collateralType), \"Collateral type not supported\");\n        require(supportsAsset(_underlyingType), \"Underlying type not supported\");\n        require(supportsAsset(_strikeAsset), \"Strike asset type not supported\");\n\n        OptionsContract optionsContract = new OptionsContract(\n            tokens[_collateralType],\n            _collateralExp,\n            tokens[_underlyingType],\n            _oTokenExchangeExp,\n            _strikePrice,\n            _strikeExp,\n            tokens[_strikeAsset],\n            _expiry,\n            optionsExchange,\n            _windowSize\n        );\n\n        optionsContracts.push(address(optionsContract));\n        emit OptionsContractCreated(address(optionsContract));\n\n        // Set the owner for the options contract.\n        optionsContract.transferOwnership(owner());\n\n        return address(optionsContract);\n    }\n\n    /**\n     * @notice The number of Option Contracts that the Factory contract has stored\n     */\n    function getNumberOfOptionsContracts() public view returns (uint256) {\n        return optionsContracts.length;\n    }\n\n    /**\n     * @notice The owner of the Factory Contract can add a new asset to be supported\n     * @dev admin don't add ETH. ETH is set to 0x0.\n     * @param _asset The ticker symbol for the asset\n     * @param _addr The address of the asset\n     */\n    function addAsset(string memory _asset, address _addr) public onlyOwner {\n        require(!supportsAsset(_asset), \"Asset already added\");\n        require(_addr != address(0), \"Cannot set to address(0)\");\n\n        tokens[_asset] = IERC20(_addr);\n        emit AssetAdded(_asset, _addr);\n    }\n\n    /**\n     * @notice The owner of the Factory Contract can change an existing asset's address\n     * @param _asset The ticker symbol for the asset\n     * @param _addr The address of the asset\n     */\n    function changeAsset(string memory _asset, address _addr) public onlyOwner {\n        require(tokens[_asset] != IERC20(0), \"Trying to replace a non-existent asset\");\n        require(_addr != address(0), \"Cannot set to address(0)\");\n\n        tokens[_asset] = IERC20(_addr);\n        emit AssetChanged(_asset, _addr);\n    }\n\n    /**\n     * @notice The owner of the Factory Contract can delete an existing asset's address\n     * @param _asset The ticker symbol for the asset\n     */\n    function deleteAsset(string memory _asset) public onlyOwner {\n        require(tokens[_asset] != IERC20(0), \"Trying to delete a non-existent asset\");\n\n        tokens[_asset] = IERC20(0);\n        emit AssetDeleted(_asset);\n    }\n\n    /**\n     * @notice Check if the Factory contract supports a specific asset\n     * @param _asset The ticker symbol for the asset\n     */\n    function supportsAsset(string memory _asset) public view returns (bool) {\n        if (_asset.compareStrings(\"ETH\")) {\n            return true;\n        }\n\n        return tokens[_asset] != IERC20(0);\n    }\n}"
    }
  ]
}