{
  "Title": "[M-04] Fallback oracle is using spot price in Uniswap liquidity pool, which is very vulnerable to flashloan price manipulation",
  "Content": "\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/ParaSpaceOracle.sol#L131><br>\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/ParaSpaceFallbackOracle.sol#L56><br>\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/ParaSpaceFallbackOracle.sol#L78>\n\nFallback oracle is using spot price in Uniswap liquidity pool, which is very vulnerable to flashloan price manipulation. Hacker can use flashloan to distort the price and overborrow or perform malicious liqudiation.\n\n### Proof of Concept\n\nIn the current implementation of the paraspace oracle, if the paraspace oracle has issue, the fallback oracle is used for ERC20 token.\n\n```solidity\n/// @inheritdoc IPriceOracleGetter\nfunction getAssetPrice(address asset)\n\tpublic\n\tview\n\toverride\n\treturns (uint256)\n{\n\tif (asset == BASE_CURRENCY) {\n\t\treturn BASE_CURRENCY_UNIT;\n\t}\n\n\tuint256 price = 0;\n\tIEACAggregatorProxy source = IEACAggregatorProxy(assetsSources[asset]);\n\tif (address(source) != address(0)) {\n\t\tprice = uint256(source.latestAnswer());\n\t}\n\tif (price == 0 && address(_fallbackOracle) != address(0)) {\n\t\tprice = _fallbackOracle.getAssetPrice(asset);\n\t}\n\n\trequire(price != 0, Errors.ORACLE_PRICE_NOT_READY);\n\treturn price;\n}\n```\n\nwhich calls:\n\n```solidity\nprice = _fallbackOracle.getAssetPrice(asset);\n```\n\nwhch use the spot price from Uniswap V2.\n\n```solidity\n\taddress pairAddress = IUniswapV2Factory(UNISWAP_FACTORY).getPair(\n\t\tWETH,\n\t\tasset\n\t);\n\trequire(pairAddress != address(0x00), \"pair not found\");\n\tIUniswapV2Pair pair = IUniswapV2Pair(pairAddress);\n\t(uint256 left, uint256 right, ) = pair.getReserves();\n\t(uint256 tokenReserves, uint256 ethReserves) = (asset < WETH)\n\t\t? (left, right)\n\t\t: (right, left);\n\tuint8 decimals = ERC20(asset).decimals();\n\t//returns price in 18 decimals\n\treturn\n\t\tIUniswapV2Router01(UNISWAP_ROUTER).getAmountOut(\n\t\t\t10**decimals,\n\t\t\ttokenReserves,\n\t\t\tethReserves\n\t\t);\n```\n\nand\n\n```solidity\nfunction getEthUsdPrice() public view returns (uint256) {\n\taddress pairAddress = IUniswapV2Factory(UNISWAP_FACTORY).getPair(\n\t\tUSDC,\n\t\tWETH\n\t);\n\trequire(pairAddress != address(0x00), \"pair not found\");\n\tIUniswapV2Pair pair = IUniswapV2Pair(pairAddress);\n\t(uint256 left, uint256 right, ) = pair.getReserves();\n\t(uint256 usdcReserves, uint256 ethReserves) = (USDC < WETH)\n\t\t? (left, right)\n\t\t: (right, left);\n\tuint8 ethDecimals = ERC20(WETH).decimals();\n\t//uint8 usdcDecimals = ERC20(USDC).decimals();\n\t//returns price in 6 decimals\n\treturn\n\t\tIUniswapV2Router01(UNISWAP_ROUTER).getAmountOut(\n\t\t\t10**ethDecimals,\n\t\t\tethReserves,\n\t\t\tusdcReserves\n\t\t);\n}\n```\n\nUsing flashloan to distort and manipulate the price is very damaging technique.\n\nConsider the POC below.\n\n1.  the User uses 10000 amount of tokenA as collateral, each token A worth 1 USD according to the paraspace oracle. the user borrow 3 ETH, the price of ETH is 1200 USD.\n\n2.  the paraspace oracle went down, the fallback price oracle is used, the user use borrows flashloan to distort the price of the tokenA in Uniswap pool from 1 USD to 10000 USD.\n\n3.  the user's collateral position worth 1000 token X 10000 USD, and borrow 1000 ETH.\n\n4.  User repay the flashloan using the overborrowed amount and recover the price of the tokenA in Uniswap liqudity pool to 1 USD, leaving bad debt and insolvent position in Paraspace.\n\n### Recommended Mitigation Steps\n\nWe recommend the project does not use the spot price in Uniswap V2, if the paraspace is down, it is safe to just revert the transaction.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-11-paraspace-contest",
  "Code": [
    {
      "filename": "paraspace-core/contracts/misc/ParaSpaceOracle.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {IEACAggregatorProxy} from \"../interfaces/IEACAggregatorProxy.sol\";\n\nimport {Errors} from \"../protocol/libraries/helpers/Errors.sol\";\nimport {IACLManager} from \"../interfaces/IACLManager.sol\";\nimport {IAtomicPriceAggregator} from \"../interfaces/IAtomicPriceAggregator.sol\";\nimport {IPoolAddressesProvider} from \"../interfaces/IPoolAddressesProvider.sol\";\nimport {IPriceOracleGetter} from \"../interfaces/IPriceOracleGetter.sol\";\nimport {IParaSpaceOracle} from \"../interfaces/IParaSpaceOracle.sol\";\n\n/**\n * @title ParaSpaceOracle\n *\n * @notice Contract to get asset prices, manage price sources and update the fallback oracle\n * - Use of Chainlink Aggregators as first source of price\n * - If the returned price by a Chainlink aggregator is <= 0, the call is forwarded to a fallback oracle\n * - Owned by the ParaSpace governance\n */\ncontract ParaSpaceOracle is IParaSpaceOracle {\n    IPoolAddressesProvider public immutable ADDRESSES_PROVIDER;\n\n    // Map of asset price sources (asset => priceSource)\n    mapping(address => address) private assetsSources;\n\n    IPriceOracleGetter private _fallbackOracle;\n    address public immutable override BASE_CURRENCY;\n    uint256 public immutable override BASE_CURRENCY_UNIT;\n\n    /**\n     * @dev Only asset listing or pool admin can call functions marked by this modifier.\n     **/\n    modifier onlyAssetListingOrPoolAdmins() {\n        _onlyAssetListingOrPoolAdmins();\n        _;\n    }\n\n    /**\n     * @notice Constructor\n     * @param provider The address of the new PoolAddressesProvider\n     * @param assets The addresses of the assets\n     * @param sources The address of the source of each asset\n     * @param fallbackOracle The address of the fallback oracle to use if the data of an\n     *        aggregator is not consistent\n     * @param baseCurrency The base currency used for the price quotes. If USD is used, base currency is 0x0\n     * @param baseCurrencyUnit The unit of the base currency\n     */\n    constructor(\n        IPoolAddressesProvider provider,\n        address[] memory assets,\n        address[] memory sources,\n        address fallbackOracle,\n        address baseCurrency,\n        uint256 baseCurrencyUnit\n    ) {\n        ADDRESSES_PROVIDER = provider;\n        BASE_CURRENCY = baseCurrency;\n        BASE_CURRENCY_UNIT = baseCurrencyUnit;\n        _setFallbackOracle(fallbackOracle);\n        _setAssetsSources(assets, sources);\n        emit BaseCurrencySet(baseCurrency, baseCurrencyUnit);\n    }\n\n    /// @inheritdoc IParaSpaceOracle\n    function setAssetSources(\n        address[] calldata assets,\n        address[] calldata sources\n    ) external override onlyAssetListingOrPoolAdmins {\n        _setAssetsSources(assets, sources);\n    }\n\n    /// @inheritdoc IParaSpaceOracle\n    function setFallbackOracle(address fallbackOracle)\n        external\n        override\n        onlyAssetListingOrPoolAdmins\n    {\n        _setFallbackOracle(fallbackOracle);\n    }\n\n    /**\n     * @notice Internal function to set the sources for each asset\n     * @param assets The addresses of the assets\n     * @param sources The address of the source of each asset\n     */\n    function _setAssetsSources(\n        address[] memory assets,\n        address[] memory sources\n    ) internal {\n        require(\n            assets.length == sources.length,\n            Errors.INCONSISTENT_PARAMS_LENGTH\n        );\n        for (uint256 i = 0; i < assets.length; i++) {\n            require(\n                assets[i] != BASE_CURRENCY,\n                Errors.SET_ORACLE_SOURCE_NOT_ALLOWED\n            );\n            assetsSources[assets[i]] = sources[i];\n            emit AssetSourceUpdated(assets[i], sources[i]);\n        }\n    }\n\n    /**\n     * @notice Internal function to set the fallback oracle\n     * @param fallbackOracle The address of the fallback oracle\n     */\n    function _setFallbackOracle(address fallbackOracle) internal {\n        _fallbackOracle = IPriceOracleGetter(fallbackOracle);\n        emit FallbackOracleUpdated(fallbackOracle);\n    }\n\n    /// @inheritdoc IPriceOracleGetter\n    function getAssetPrice(address asset)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        if (asset == BASE_CURRENCY) {\n            return BASE_CURRENCY_UNIT;\n        }\n\n        uint256 price = 0;\n        IEACAggregatorProxy source = IEACAggregatorProxy(assetsSources[asset]);\n        if (address(source) != address(0)) {\n            price = uint256(source.latestAnswer());\n        }\n        if (price == 0 && address(_fallbackOracle) != address(0)) {\n            price = _fallbackOracle.getAssetPrice(asset);\n        }\n\n        require(price != 0, Errors.ORACLE_PRICE_NOT_READY);\n        return price;\n    }\n\n    function getTokenPrice(address asset, uint256 tokenId)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        IAtomicPriceAggregator source = IAtomicPriceAggregator(\n            assetsSources[asset]\n        );\n\n        if (address(source) != address(0)) {\n            return source.getTokenPrice(tokenId);\n        }\n\n        revert(Errors.ORACLE_PRICE_NOT_READY);\n    }\n\n    function getTokensPrices(address asset, uint256[] calldata tokenIds)\n        external\n        view\n        override\n        returns (uint256[] memory)\n    {\n        IAtomicPriceAggregator source = IAtomicPriceAggregator(\n            assetsSources[asset]\n        );\n\n        if (address(source) != address(0)) {\n            return source.getTokensPrices(tokenIds);\n        }\n\n        revert(Errors.ORACLE_PRICE_NOT_READY);\n    }\n\n    function getTokensPricesSum(address asset, uint256[] calldata tokenIds)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        IAtomicPriceAggregator source = IAtomicPriceAggregator(\n            assetsSources[asset]\n        );\n\n        if (address(source) != address(0)) {\n            return source.getTokensPricesSum(tokenIds);\n        }\n\n        revert(Errors.ORACLE_PRICE_NOT_READY);\n    }\n\n    /// @inheritdoc IParaSpaceOracle\n    function getAssetsPrices(address[] calldata assets)\n        external\n        view\n        override\n        returns (uint256[] memory)\n    {\n        uint256[] memory prices = new uint256[](assets.length);\n        for (uint256 i = 0; i < assets.length; i++) {\n            prices[i] = getAssetPrice(assets[i]);\n        }\n        return prices;\n    }\n\n    /// @inheritdoc IParaSpaceOracle\n    function getSourceOfAsset(address asset)\n        external\n        view\n        override\n        returns (address)\n    {\n        return assetsSources[asset];\n    }\n\n    /// @inheritdoc IParaSpaceOracle\n    function getFallbackOracle() external view returns (address) {\n        return address(_fallbackOracle);\n    }\n\n    function _onlyAssetListingOrPoolAdmins() internal view {\n        IACLManager aclManager = IACLManager(\n            ADDRESSES_PROVIDER.getACLManager()\n        );\n        require(\n            aclManager.isAssetListingAdmin(msg.sender) ||\n                aclManager.isPoolAdmin(msg.sender),\n            Errors.CALLER_NOT_ASSET_LISTING_OR_POOL_ADMIN\n        );\n    }\n}"
    },
    {
      "filename": "paraspace-core/contracts/misc/ParaSpaceFallbackOracle.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {INFTOracle} from \"./interfaces/INFTOracle.sol\";\nimport {IUniswapV2Factory} from \"./interfaces/IUniswapV2Factory.sol\";\nimport {IUniswapV2Router01} from \"./interfaces/IUniswapV2Router01.sol\";\nimport {IUniswapV2Pair} from \"./interfaces/IUniswapV2Pair.sol\";\nimport {IERC165} from \"../dependencies/openzeppelin/contracts/IERC165.sol\";\nimport {ERC20} from \"../dependencies/openzeppelin/contracts/ERC20.sol\";\n\ncontract ParaSpaceFallbackOracle {\n    address public immutable BEND_DAO;\n    address public immutable UNISWAP_FACTORY;\n    address public immutable UNISWAP_ROUTER;\n    address public immutable WETH;\n    address public immutable USDC;\n\n    bytes4 private constant INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    constructor(\n        address bendDAO,\n        address uniswapFactory,\n        address uniswapRouter,\n        address weth,\n        address usdc\n    ) {\n        BEND_DAO = bendDAO;\n        UNISWAP_FACTORY = uniswapFactory;\n        UNISWAP_ROUTER = uniswapRouter;\n        WETH = weth;\n        USDC = usdc;\n    }\n\n    function getAssetPrice(address asset) public view returns (uint256) {\n        try IERC165(asset).supportsInterface(INTERFACE_ID_ERC721) returns (\n            bool supported\n        ) {\n            if (supported == true) {\n                return INFTOracle(BEND_DAO).getAssetPrice(asset);\n            }\n        } catch {}\n\n        address pairAddress = IUniswapV2Factory(UNISWAP_FACTORY).getPair(\n            WETH,\n            asset\n        );\n        require(pairAddress != address(0x00), \"pair not found\");\n        IUniswapV2Pair pair = IUniswapV2Pair(pairAddress);\n        (uint256 left, uint256 right, ) = pair.getReserves();\n        (uint256 tokenReserves, uint256 ethReserves) = (asset < WETH)\n            ? (left, right)\n            : (right, left);\n        uint8 decimals = ERC20(asset).decimals();\n        //returns price in 18 decimals\n        return\n            IUniswapV2Router01(UNISWAP_ROUTER).getAmountOut(\n                10**decimals,\n                tokenReserves,\n                ethReserves\n            );\n    }\n\n    function getEthUsdPrice() public view returns (uint256) {\n        address pairAddress = IUniswapV2Factory(UNISWAP_FACTORY).getPair(\n            USDC,\n            WETH\n        );\n        require(pairAddress != address(0x00), \"pair not found\");\n        IUniswapV2Pair pair = IUniswapV2Pair(pairAddress);\n        (uint256 left, uint256 right, ) = pair.getReserves();\n        (uint256 usdcReserves, uint256 ethReserves) = (USDC < WETH)\n            ? (left, right)\n            : (right, left);\n        uint8 ethDecimals = ERC20(WETH).decimals();\n        //uint8 usdcDecimals = ERC20(USDC).decimals();\n        //returns price in 6 decimals\n        return\n            IUniswapV2Router01(UNISWAP_ROUTER).getAmountOut(\n                10**ethDecimals,\n                ethReserves,\n                usdcReserves\n            );\n    }\n}"
    },
    {
      "filename": "paraspace-core/contracts/misc/ParaSpaceFallbackOracle.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {INFTOracle} from \"./interfaces/INFTOracle.sol\";\nimport {IUniswapV2Factory} from \"./interfaces/IUniswapV2Factory.sol\";\nimport {IUniswapV2Router01} from \"./interfaces/IUniswapV2Router01.sol\";\nimport {IUniswapV2Pair} from \"./interfaces/IUniswapV2Pair.sol\";\nimport {IERC165} from \"../dependencies/openzeppelin/contracts/IERC165.sol\";\nimport {ERC20} from \"../dependencies/openzeppelin/contracts/ERC20.sol\";\n\ncontract ParaSpaceFallbackOracle {\n    address public immutable BEND_DAO;\n    address public immutable UNISWAP_FACTORY;\n    address public immutable UNISWAP_ROUTER;\n    address public immutable WETH;\n    address public immutable USDC;\n\n    bytes4 private constant INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    constructor(\n        address bendDAO,\n        address uniswapFactory,\n        address uniswapRouter,\n        address weth,\n        address usdc\n    ) {\n        BEND_DAO = bendDAO;\n        UNISWAP_FACTORY = uniswapFactory;\n        UNISWAP_ROUTER = uniswapRouter;\n        WETH = weth;\n        USDC = usdc;\n    }\n\n    function getAssetPrice(address asset) public view returns (uint256) {\n        try IERC165(asset).supportsInterface(INTERFACE_ID_ERC721) returns (\n            bool supported\n        ) {\n            if (supported == true) {\n                return INFTOracle(BEND_DAO).getAssetPrice(asset);\n            }\n        } catch {}\n\n        address pairAddress = IUniswapV2Factory(UNISWAP_FACTORY).getPair(\n            WETH,\n            asset\n        );\n        require(pairAddress != address(0x00), \"pair not found\");\n        IUniswapV2Pair pair = IUniswapV2Pair(pairAddress);\n        (uint256 left, uint256 right, ) = pair.getReserves();\n        (uint256 tokenReserves, uint256 ethReserves) = (asset < WETH)\n            ? (left, right)\n            : (right, left);\n        uint8 decimals = ERC20(asset).decimals();\n        //returns price in 18 decimals\n        return\n            IUniswapV2Router01(UNISWAP_ROUTER).getAmountOut(\n                10**decimals,\n                tokenReserves,\n                ethReserves\n            );\n    }\n\n    function getEthUsdPrice() public view returns (uint256) {\n        address pairAddress = IUniswapV2Factory(UNISWAP_FACTORY).getPair(\n            USDC,\n            WETH\n        );\n        require(pairAddress != address(0x00), \"pair not found\");\n        IUniswapV2Pair pair = IUniswapV2Pair(pairAddress);\n        (uint256 left, uint256 right, ) = pair.getReserves();\n        (uint256 usdcReserves, uint256 ethReserves) = (USDC < WETH)\n            ? (left, right)\n            : (right, left);\n        uint8 ethDecimals = ERC20(WETH).decimals();\n        //uint8 usdcDecimals = ERC20(USDC).decimals();\n        //returns price in 6 decimals\n        return\n            IUniswapV2Router01(UNISWAP_ROUTER).getAmountOut(\n                10**ethDecimals,\n                ethReserves,\n                usdcReserves\n            );\n    }\n}"
    }
  ]
}