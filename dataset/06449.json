{
  "Title": "[H-25] `UlyssesToken` asset ID accounting error",
  "Content": "\nAsset IDs in the `UlyssesToken` contract are **1-based**, see [L49 in UlyssesToken.addAsset(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-amm/UlyssesToken.sol#L49) and [L55 in ERC4626MultiToken.constructor(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/erc-4626/ERC4626MultiToken.sol#L55) of the parent contract.\\\nHowever, when removing an asset from the `UlyssesToken` contract, the last added asset gets the **0-based** ID of the removed asset, see [L72 in UlyssesToken.removeAsset(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-amm/UlyssesToken.sol#L72).\n\nThis leads to the following consequences:\n\n1.  Duplicate IDs when removing an asset.<br>\nExample:<br>\nWe have assets with IDs `1,2,3,4`. Next, the asset with ID=2 is removed. Now, we have assets with IDs `1,1,3` because the last asset with ID=4 gets ID=2-1=1.<br>\n\n2. The last asset cannot be removed after removing the first asset.<br>\nExample:<br>\nOnce the first asset with ID=1 is removed, the last asset gets ID=0 instead of ID=1. When trying to remove the last asset [L62 in UlyssesToken.removeAsset(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-amm/UlyssesToken.sol#L62) will **revert** due to underflow.<br>\n\n3. The last asset can be added a second time after removing the first asset.<br>\nExample:<br>\nOnce the first asset with ID=1 is removed, the last asset gets ID=0 instead of ID=1. When trying to add the last asset again [L45 in UlyssesToken.addAsset(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-amm/UlyssesToken.sol#L45) will **not revert** since ID=0 indicates that the asset wasn't added yet. Therefore, the underlying vault can contain the same token twice with **different** weights.\n\nIn conclusion, the asset accounting of the `UlyssesToken` contract is broken after removing an asset (especially the first one). This was also highlighted as a special area of concern in the audit details: `ulysses AMM and token accounting`.\n\n### Proof of Concept\n\nThe above issues are demonstrated by the new test cases `test_UlyssesTokenAddAssetTwice` and `test_UlyssesTokenRemoveAssetFail`. Just apply the *diff* below and run the tests with `forge test --match-test test_UlyssesToken`:\n\n```diff\ndiff --git a/test/ulysses-amm/UlyssesTokenTest.t.sol b/test/ulysses-amm/UlyssesTokenTest.t.sol\nindex bdb4a7d..dcf6d45 100644\n--- a/test/ulysses-amm/UlyssesTokenTest.t.sol\n+++ b/test/ulysses-amm/UlyssesTokenTest.t.sol\n@@ -3,6 +3,7 @@ pragma solidity >=0.8.0 <0.9.0;\n\n import {MockERC20} from \"solmate/test/utils/mocks/MockERC20.sol\";\n import {UlyssesToken} from \"@ulysses-amm/UlyssesToken.sol\";\n+import {IUlyssesToken} from \"@ulysses-amm/interfaces/IUlyssesToken.sol\";\n\n import {UlyssesTokenHandler} from \"@test/test-utils/invariant/handlers/UlyssesTokenHandler.t.sol\";\n\n@@ -29,4 +30,28 @@ contract InvariantUlyssesToken is UlyssesTokenHandler {\n         _vaultMayBeEmpty = true;\n         _unlimitedAmount = false;\n     }\n+\n+    function test_UlyssesTokenRemoveAssetFail() public  {\n+        UlyssesToken token = UlyssesToken(_vault_);\n+\n+        // remove first asset with ID=1\n+        token.removeAsset(_underlyings_[0]);\n+        // due to accounting error, last asset now has ID=0 instead of ID=1\n+\n+        // remove last asset --> underflow error due to ID=0\n+        token.removeAsset(_underlyings_[NUM_ASSETS - 1]);\n+    }\n+\n+    function test_UlyssesTokenAddAssetTwice() public  {\n+        UlyssesToken token = UlyssesToken(_vault_);\n+\n+        // remove first asset with ID=1\n+        token.removeAsset(_underlyings_[0]);\n+        // due to accounting error, last asset now has ID=0 instead of ID=1\n+\n+        // add last asset again --> doesn't revert since it \"officially\" doesn't exist due to ID=1\n+        vm.expectRevert(IUlyssesToken.AssetAlreadyAdded.selector);\n+        token.addAsset(_underlyings_[NUM_ASSETS - 1], 1);\n+    }\n+\n }\n\n```\n\nWe can see that adding the last asset again does **not revert** but trying to remove it still **fails**:\n\n    Encountered 2 failing tests in test/ulysses-amm/UlyssesTokenTest.t.sol:InvariantUlyssesToken\n    [FAIL. Reason: Call did not revert as expected] test_UlyssesTokenAddAssetTwice() (gas: 169088)\n    [FAIL. Reason: Arithmetic over/underflow] test_UlyssesTokenRemoveAssetFail() (gas: 137184)\n\n### Tools Used\n\nVS Code, Foundry and MS Excel\n\n### Recommended Mitigation Steps\n\nFortunately, all of the above issues can be easily fixed by using an **1-based** asset ID in [L72 of UlyssesToken.removeAsset(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-amm/UlyssesToken.sol#L72):\n\n```diff\ndiff --git a/src/ulysses-amm/UlyssesToken.sol b/src/ulysses-amm/UlyssesToken.sol\nindex 552a125..0937e9f 100644\n--- a/src/ulysses-amm/UlyssesToken.sol\n+++ b/src/ulysses-amm/UlyssesToken.sol\n@@ -69,7 +69,7 @@ contract UlyssesToken is ERC4626MultiToken, Ownable, IUlyssesToken {\n\n         address lastAsset = assets[newAssetsLength];\n\n-        assetId[lastAsset] = assetIndex;\n+        assetId[lastAsset] = assetIndex + 1;\n         assets[assetIndex] = lastAsset;\n         weights[assetIndex] = weights[newAssetsLength];\n\n```\n\nAfter applying the recommended fix, both new test cases pass:\n\n    [PASS] test_UlyssesTokenAddAssetTwice() (gas: 122911)\n    [PASS] test_UlyssesTokenRemoveAssetFail() (gas: 134916)\n\n### Assessed type\n\nUnder/Overflow\n\n**[Trust (judge) increased severity to High](https://github.com/code-423n4/2023-05-maia-findings/issues/275#issuecomment-1631203217)**\n\n**[0xLightt (Maia) confirmed and commented](https://github.com/code-423n4/2023-05-maia-findings/issues/275#issuecomment-1655654603):**\n > We recognize the audit's findings on Ulysses Token. These will not be rectified due to the upcoming migration of this section to Balancer Stable Pools Wrapper.\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/ulysses-amm/UlyssesToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {ERC4626MultiToken, IERC4626MultiToken} from \"@ERC4626/ERC4626MultiToken.sol\";\n\nimport {IUlyssesToken} from \"./interfaces/IUlyssesToken.sol\";\n\n/// @title Ulysses Token - tokenized Vault multi asset implementation for Ulysses pools\ncontract UlyssesToken is ERC4626MultiToken, Ownable, IUlyssesToken {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n\n    uint256 public immutable id;\n\n    constructor(\n        uint256 _id,\n        address[] memory _assets,\n        uint256[] memory _weights,\n        string memory _name,\n        string memory _symbol,\n        address _owner\n    ) ERC4626MultiToken(_assets, _weights, _name, _symbol) {\n        _initializeOwner(_owner);\n        require(_id != 0);\n        id = _id;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626MultiToken\n    function totalAssets() public view override returns (uint256 _totalAssets) {\n        return totalSupply;\n    }\n\n    ///@inheritdoc IUlyssesToken\n    function addAsset(address asset, uint256 _weight) external nonReentrant onlyOwner {\n        if (assetId[asset] != 0) revert AssetAlreadyAdded();\n        require(ERC20(asset).decimals() == 18);\n        require(_weight > 0);\n\n        assetId[asset] = assets.length + 1;\n        assets.push(asset);\n        weights.push(_weight);\n        totalWeights += _weight;\n\n        emit AssetAdded(asset, _weight);\n\n        updateAssetBalances();\n    }\n\n    ///@inheritdoc IUlyssesToken\n    function removeAsset(address asset) external nonReentrant onlyOwner {\n        // No need to check if index is 0, it will underflow and revert if it is 0\n        uint256 assetIndex = assetId[asset] - 1;\n\n        uint256 newAssetsLength = assets.length - 1;\n\n        if (newAssetsLength == 0) revert CannotRemoveLastAsset();\n\n        totalWeights -= weights[assetIndex];\n\n        address lastAsset = assets[newAssetsLength];\n\n        assetId[lastAsset] = assetIndex;\n        assets[assetIndex] = lastAsset;\n        weights[assetIndex] = weights[newAssetsLength];\n\n        assets.pop();\n        weights.pop();\n        assetId[asset] = 0;\n\n        emit AssetRemoved(asset);\n\n        updateAssetBalances();\n\n        asset.safeTransfer(msg.sender, asset.balanceOf(address(this)));\n    }\n\n    ///@inheritdoc IUlyssesToken\n    function setWeights(uint256[] memory _weights) external nonReentrant onlyOwner {\n        if (_weights.length != assets.length) revert InvalidWeightsLength();\n\n        weights = _weights;\n\n        uint256 newTotalWeights;\n\n        for (uint256 i = 0; i < assets.length; i++) {\n            newTotalWeights += _weights[i];\n\n            emit AssetRemoved(assets[i]);\n            emit AssetAdded(assets[i], _weights[i]);\n        }\n\n        totalWeights = newTotalWeights;\n\n        updateAssetBalances();\n    }\n\n    /**\n     * @notice Update the balances of the underlying assets.\n     */\n    function updateAssetBalances() internal {\n        for (uint256 i = 0; i < assets.length; i++) {\n            uint256 assetBalance = assets[i].balanceOf(address(this));\n            uint256 newAssetBalance = totalSupply.mulDivUp(weights[i], totalWeights);\n\n            if (assetBalance > newAssetBalance) {\n                assets[i].safeTransfer(msg.sender, assetBalance - newAssetBalance);\n            } else {\n                assets[i].safeTransferFrom(msg.sender, address(this), newAssetBalance - assetBalance);\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/ulysses-amm/UlyssesToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {ERC4626MultiToken, IERC4626MultiToken} from \"@ERC4626/ERC4626MultiToken.sol\";\n\nimport {IUlyssesToken} from \"./interfaces/IUlyssesToken.sol\";\n\n/// @title Ulysses Token - tokenized Vault multi asset implementation for Ulysses pools\ncontract UlyssesToken is ERC4626MultiToken, Ownable, IUlyssesToken {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n\n    uint256 public immutable id;\n\n    constructor(\n        uint256 _id,\n        address[] memory _assets,\n        uint256[] memory _weights,\n        string memory _name,\n        string memory _symbol,\n        address _owner\n    ) ERC4626MultiToken(_assets, _weights, _name, _symbol) {\n        _initializeOwner(_owner);\n        require(_id != 0);\n        id = _id;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626MultiToken\n    function totalAssets() public view override returns (uint256 _totalAssets) {\n        return totalSupply;\n    }\n\n    ///@inheritdoc IUlyssesToken\n    function addAsset(address asset, uint256 _weight) external nonReentrant onlyOwner {\n        if (assetId[asset] != 0) revert AssetAlreadyAdded();\n        require(ERC20(asset).decimals() == 18);\n        require(_weight > 0);\n\n        assetId[asset] = assets.length + 1;\n        assets.push(asset);\n        weights.push(_weight);\n        totalWeights += _weight;\n\n        emit AssetAdded(asset, _weight);\n\n        updateAssetBalances();\n    }\n\n    ///@inheritdoc IUlyssesToken\n    function removeAsset(address asset) external nonReentrant onlyOwner {\n        // No need to check if index is 0, it will underflow and revert if it is 0\n        uint256 assetIndex = assetId[asset] - 1;\n\n        uint256 newAssetsLength = assets.length - 1;\n\n        if (newAssetsLength == 0) revert CannotRemoveLastAsset();\n\n        totalWeights -= weights[assetIndex];\n\n        address lastAsset = assets[newAssetsLength];\n\n        assetId[lastAsset] = assetIndex;\n        assets[assetIndex] = lastAsset;\n        weights[assetIndex] = weights[newAssetsLength];\n\n        assets.pop();\n        weights.pop();\n        assetId[asset] = 0;\n\n        emit AssetRemoved(asset);\n\n        updateAssetBalances();\n\n        asset.safeTransfer(msg.sender, asset.balanceOf(address(this)));\n    }\n\n    ///@inheritdoc IUlyssesToken\n    function setWeights(uint256[] memory _weights) external nonReentrant onlyOwner {\n        if (_weights.length != assets.length) revert InvalidWeightsLength();\n\n        weights = _weights;\n\n        uint256 newTotalWeights;\n\n        for (uint256 i = 0; i < assets.length; i++) {\n            newTotalWeights += _weights[i];\n\n            emit AssetRemoved(assets[i]);\n            emit AssetAdded(assets[i], _weights[i]);\n        }\n\n        totalWeights = newTotalWeights;\n\n        updateAssetBalances();\n    }\n\n    /**\n     * @notice Update the balances of the underlying assets.\n     */\n    function updateAssetBalances() internal {\n        for (uint256 i = 0; i < assets.length; i++) {\n            uint256 assetBalance = assets[i].balanceOf(address(this));\n            uint256 newAssetBalance = totalSupply.mulDivUp(weights[i], totalWeights);\n\n            if (assetBalance > newAssetBalance) {\n                assets[i].safeTransfer(msg.sender, assetBalance - newAssetBalance);\n            } else {\n                assets[i].safeTransferFrom(msg.sender, address(this), newAssetBalance - assetBalance);\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/ulysses-amm/UlyssesToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {ERC4626MultiToken, IERC4626MultiToken} from \"@ERC4626/ERC4626MultiToken.sol\";\n\nimport {IUlyssesToken} from \"./interfaces/IUlyssesToken.sol\";\n\n/// @title Ulysses Token - tokenized Vault multi asset implementation for Ulysses pools\ncontract UlyssesToken is ERC4626MultiToken, Ownable, IUlyssesToken {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n\n    uint256 public immutable id;\n\n    constructor(\n        uint256 _id,\n        address[] memory _assets,\n        uint256[] memory _weights,\n        string memory _name,\n        string memory _symbol,\n        address _owner\n    ) ERC4626MultiToken(_assets, _weights, _name, _symbol) {\n        _initializeOwner(_owner);\n        require(_id != 0);\n        id = _id;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626MultiToken\n    function totalAssets() public view override returns (uint256 _totalAssets) {\n        return totalSupply;\n    }\n\n    ///@inheritdoc IUlyssesToken\n    function addAsset(address asset, uint256 _weight) external nonReentrant onlyOwner {\n        if (assetId[asset] != 0) revert AssetAlreadyAdded();\n        require(ERC20(asset).decimals() == 18);\n        require(_weight > 0);\n\n        assetId[asset] = assets.length + 1;\n        assets.push(asset);\n        weights.push(_weight);\n        totalWeights += _weight;\n\n        emit AssetAdded(asset, _weight);\n\n        updateAssetBalances();\n    }\n\n    ///@inheritdoc IUlyssesToken\n    function removeAsset(address asset) external nonReentrant onlyOwner {\n        // No need to check if index is 0, it will underflow and revert if it is 0\n        uint256 assetIndex = assetId[asset] - 1;\n\n        uint256 newAssetsLength = assets.length - 1;\n\n        if (newAssetsLength == 0) revert CannotRemoveLastAsset();\n\n        totalWeights -= weights[assetIndex];\n\n        address lastAsset = assets[newAssetsLength];\n\n        assetId[lastAsset] = assetIndex;\n        assets[assetIndex] = lastAsset;\n        weights[assetIndex] = weights[newAssetsLength];\n\n        assets.pop();\n        weights.pop();\n        assetId[asset] = 0;\n\n        emit AssetRemoved(asset);\n\n        updateAssetBalances();\n\n        asset.safeTransfer(msg.sender, asset.balanceOf(address(this)));\n    }\n\n    ///@inheritdoc IUlyssesToken\n    function setWeights(uint256[] memory _weights) external nonReentrant onlyOwner {\n        if (_weights.length != assets.length) revert InvalidWeightsLength();\n\n        weights = _weights;\n\n        uint256 newTotalWeights;\n\n        for (uint256 i = 0; i < assets.length; i++) {\n            newTotalWeights += _weights[i];\n\n            emit AssetRemoved(assets[i]);\n            emit AssetAdded(assets[i], _weights[i]);\n        }\n\n        totalWeights = newTotalWeights;\n\n        updateAssetBalances();\n    }\n\n    /**\n     * @notice Update the balances of the underlying assets.\n     */\n    function updateAssetBalances() internal {\n        for (uint256 i = 0; i < assets.length; i++) {\n            uint256 assetBalance = assets[i].balanceOf(address(this));\n            uint256 newAssetBalance = totalSupply.mulDivUp(weights[i], totalWeights);\n\n            if (assetBalance > newAssetBalance) {\n                assets[i].safeTransfer(msg.sender, assetBalance - newAssetBalance);\n            } else {\n                assets[i].safeTransferFrom(msg.sender, address(this), newAssetBalance - assetBalance);\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/ulysses-amm/UlyssesToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {ERC4626MultiToken, IERC4626MultiToken} from \"@ERC4626/ERC4626MultiToken.sol\";\n\nimport {IUlyssesToken} from \"./interfaces/IUlyssesToken.sol\";\n\n/// @title Ulysses Token - tokenized Vault multi asset implementation for Ulysses pools\ncontract UlyssesToken is ERC4626MultiToken, Ownable, IUlyssesToken {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n\n    uint256 public immutable id;\n\n    constructor(\n        uint256 _id,\n        address[] memory _assets,\n        uint256[] memory _weights,\n        string memory _name,\n        string memory _symbol,\n        address _owner\n    ) ERC4626MultiToken(_assets, _weights, _name, _symbol) {\n        _initializeOwner(_owner);\n        require(_id != 0);\n        id = _id;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626MultiToken\n    function totalAssets() public view override returns (uint256 _totalAssets) {\n        return totalSupply;\n    }\n\n    ///@inheritdoc IUlyssesToken\n    function addAsset(address asset, uint256 _weight) external nonReentrant onlyOwner {\n        if (assetId[asset] != 0) revert AssetAlreadyAdded();\n        require(ERC20(asset).decimals() == 18);\n        require(_weight > 0);\n\n        assetId[asset] = assets.length + 1;\n        assets.push(asset);\n        weights.push(_weight);\n        totalWeights += _weight;\n\n        emit AssetAdded(asset, _weight);\n\n        updateAssetBalances();\n    }\n\n    ///@inheritdoc IUlyssesToken\n    function removeAsset(address asset) external nonReentrant onlyOwner {\n        // No need to check if index is 0, it will underflow and revert if it is 0\n        uint256 assetIndex = assetId[asset] - 1;\n\n        uint256 newAssetsLength = assets.length - 1;\n\n        if (newAssetsLength == 0) revert CannotRemoveLastAsset();\n\n        totalWeights -= weights[assetIndex];\n\n        address lastAsset = assets[newAssetsLength];\n\n        assetId[lastAsset] = assetIndex;\n        assets[assetIndex] = lastAsset;\n        weights[assetIndex] = weights[newAssetsLength];\n\n        assets.pop();\n        weights.pop();\n        assetId[asset] = 0;\n\n        emit AssetRemoved(asset);\n\n        updateAssetBalances();\n\n        asset.safeTransfer(msg.sender, asset.balanceOf(address(this)));\n    }\n\n    ///@inheritdoc IUlyssesToken\n    function setWeights(uint256[] memory _weights) external nonReentrant onlyOwner {\n        if (_weights.length != assets.length) revert InvalidWeightsLength();\n\n        weights = _weights;\n\n        uint256 newTotalWeights;\n\n        for (uint256 i = 0; i < assets.length; i++) {\n            newTotalWeights += _weights[i];\n\n            emit AssetRemoved(assets[i]);\n            emit AssetAdded(assets[i], _weights[i]);\n        }\n\n        totalWeights = newTotalWeights;\n\n        updateAssetBalances();\n    }\n\n    /**\n     * @notice Update the balances of the underlying assets.\n     */\n    function updateAssetBalances() internal {\n        for (uint256 i = 0; i < assets.length; i++) {\n            uint256 assetBalance = assets[i].balanceOf(address(this));\n            uint256 newAssetBalance = totalSupply.mulDivUp(weights[i], totalWeights);\n\n            if (assetBalance > newAssetBalance) {\n                assets[i].safeTransfer(msg.sender, assetBalance - newAssetBalance);\n            } else {\n                assets[i].safeTransferFrom(msg.sender, address(this), newAssetBalance - assetBalance);\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/ulysses-amm/UlyssesToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {ERC4626MultiToken, IERC4626MultiToken} from \"@ERC4626/ERC4626MultiToken.sol\";\n\nimport {IUlyssesToken} from \"./interfaces/IUlyssesToken.sol\";\n\n/// @title Ulysses Token - tokenized Vault multi asset implementation for Ulysses pools\ncontract UlyssesToken is ERC4626MultiToken, Ownable, IUlyssesToken {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n\n    uint256 public immutable id;\n\n    constructor(\n        uint256 _id,\n        address[] memory _assets,\n        uint256[] memory _weights,\n        string memory _name,\n        string memory _symbol,\n        address _owner\n    ) ERC4626MultiToken(_assets, _weights, _name, _symbol) {\n        _initializeOwner(_owner);\n        require(_id != 0);\n        id = _id;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626MultiToken\n    function totalAssets() public view override returns (uint256 _totalAssets) {\n        return totalSupply;\n    }\n\n    ///@inheritdoc IUlyssesToken\n    function addAsset(address asset, uint256 _weight) external nonReentrant onlyOwner {\n        if (assetId[asset] != 0) revert AssetAlreadyAdded();\n        require(ERC20(asset).decimals() == 18);\n        require(_weight > 0);\n\n        assetId[asset] = assets.length + 1;\n        assets.push(asset);\n        weights.push(_weight);\n        totalWeights += _weight;\n\n        emit AssetAdded(asset, _weight);\n\n        updateAssetBalances();\n    }\n\n    ///@inheritdoc IUlyssesToken\n    function removeAsset(address asset) external nonReentrant onlyOwner {\n        // No need to check if index is 0, it will underflow and revert if it is 0\n        uint256 assetIndex = assetId[asset] - 1;\n\n        uint256 newAssetsLength = assets.length - 1;\n\n        if (newAssetsLength == 0) revert CannotRemoveLastAsset();\n\n        totalWeights -= weights[assetIndex];\n\n        address lastAsset = assets[newAssetsLength];\n\n        assetId[lastAsset] = assetIndex;\n        assets[assetIndex] = lastAsset;\n        weights[assetIndex] = weights[newAssetsLength];\n\n        assets.pop();\n        weights.pop();\n        assetId[asset] = 0;\n\n        emit AssetRemoved(asset);\n\n        updateAssetBalances();\n\n        asset.safeTransfer(msg.sender, asset.balanceOf(address(this)));\n    }\n\n    ///@inheritdoc IUlyssesToken\n    function setWeights(uint256[] memory _weights) external nonReentrant onlyOwner {\n        if (_weights.length != assets.length) revert InvalidWeightsLength();\n\n        weights = _weights;\n\n        uint256 newTotalWeights;\n\n        for (uint256 i = 0; i < assets.length; i++) {\n            newTotalWeights += _weights[i];\n\n            emit AssetRemoved(assets[i]);\n            emit AssetAdded(assets[i], _weights[i]);\n        }\n\n        totalWeights = newTotalWeights;\n\n        updateAssetBalances();\n    }\n\n    /**\n     * @notice Update the balances of the underlying assets.\n     */\n    function updateAssetBalances() internal {\n        for (uint256 i = 0; i < assets.length; i++) {\n            uint256 assetBalance = assets[i].balanceOf(address(this));\n            uint256 newAssetBalance = totalSupply.mulDivUp(weights[i], totalWeights);\n\n            if (assetBalance > newAssetBalance) {\n                assets[i].safeTransfer(msg.sender, assetBalance - newAssetBalance);\n            } else {\n                assets[i].safeTransferFrom(msg.sender, address(this), newAssetBalance - assetBalance);\n            }\n        }\n    }\n}"
    }
  ]
}