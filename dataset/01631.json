{
  "Title": "M-20: Liquidating a turned solvent Party A does not credit the profits to Party A",
  "Content": "# Issue M-20: Liquidating a turned solvent Party A does not credit the profits to Party A \n\nSource: https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/290 \n\n## Found by \nberndartmueller, libratus\n## Summary\n\nParty A can turn solvent again mid-way through the multi-step liquidation process. While Party B will have its [losses deducted from its allocated balance](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol#L170), Party A will not receive any profits. Instead, its allocated balance is [reset to 0](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol#L216).\n\n## Vulnerability Detail\n\nIf Party A turns solvent again, i.e., its available balance (`availableBalance`) is positive, after a liquidator has started the liquidation and calls the `setSymbolsPrice` to initialize the symbol prices as well as Party A's liquidation details, the liquidation will proceed as usual. Liquidating the individual open positions of Party A with the `liquidatePositionsPartyA` function deducts the losses from the trading counterparty B's allocated balance in line 170.\n\nHowever, the profits made by Party A are not credited to Party A's allocated balance. Instead, Party A's allocated balance is reset to 0 in line 216 once all positions are liquidated.\n\n## Impact\n\nParty A's realized profits during the liquidation are retained by the protocol instead of credited to Party A's allocated balance.\n\n## Code Snippet\n\n[contracts/facets/liquidation/LiquidationFacetImpl.sol#L65-L67](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol#L65-L67)\n\nParty A, who turned solvent, will have the liquidation proceed as usual, with the `liquidationType` set to `NORMAL`.\n\n```solidity\n34: function setSymbolsPrice(address partyA, PriceSig memory priceSig) internal {\n...     // [...]\n51:\n52:     int256 availableBalance = LibAccount.partyAAvailableBalanceForLiquidation(\n53:         priceSig.upnl,\n54:         partyA\n55:     );\n56:     if (accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.NONE) {\n57:         accountLayout.liquidationDetails[partyA] = LiquidationDetail({\n58:             liquidationType: LiquidationType.NONE,\n59:             upnl: priceSig.upnl,\n60:             totalUnrealizedLoss: priceSig.totalUnrealizedLoss,\n61:             deficit: 0,\n62:             liquidationFee: 0\n63:         });\n64: @>      if (availableBalance >= 0) {\n65: @>          uint256 remainingLf = accountLayout.lockedBalances[partyA].lf;\n66: @>          accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.NORMAL;\n67: @>          accountLayout.liquidationDetails[partyA].liquidationFee = remainingLf;\n68:         } else if (uint256(-availableBalance) < accountLayout.lockedBalances[partyA].lf) {\n...     // [...]\n97: }\n```\n\n[contracts/facets/liquidation/LiquidationFacetImpl.sol#L170](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol#L170)\n\nLiquidating Party A's positions, which are in a profit (and thus a loss for Party B), deducts the losses from Party B's allocated balance in line 170. The profit is **not** credited to Party A.\n\n```solidity\nFile: LiquidationFacetImpl.sol\n126: function liquidatePositionsPartyA(\n127:     address partyA,\n128:     uint256[] memory quoteIds\n129: ) internal returns (bool) {\n130:     AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n131:     MAStorage.Layout storage maLayout = MAStorage.layout();\n132:     QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n133:\n134:     require(maLayout.liquidationStatus[partyA], \"LiquidationFacet: PartyA is solvent\");\n135:     for (uint256 index = 0; index < quoteIds.length; index++) {\n136:         Quote storage quote = quoteLayout.quotes[quoteIds[index]];\n...          // [...]\n162:\n163:         if (\n164:             accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.NORMAL\n165:         ) {\n166:             accountLayout.partyBAllocatedBalances[quote.partyB][partyA] += quote\n167:                 .lockedValues\n168:                 .cva;\n169:             if (hasMadeProfit) {\n170: @>              accountLayout.partyBAllocatedBalances[quote.partyB][partyA] -= amount; // @audit-info Party B's allocated balance is decreased by the amount of profit made by party A\n171:             } else {\n172:                 accountLayout.partyBAllocatedBalances[quote.partyB][partyA] += amount;\n173:             }\n```\n\n[contracts/facets/liquidation/LiquidationFacetImpl.sol#L216](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol#L216)\n\nOnce all of Party A's positions are liquidated, Party A's allocated balance is reset to 0 in line 216.\n\n```solidity\n126: function liquidatePositionsPartyA(\n127:     address partyA,\n128:     uint256[] memory quoteIds\n129: ) internal returns (bool) {\n...   // [...]\n211:  if (quoteLayout.partyAPositionsCount[partyA] == 0) {\n212:      require(\n213:          quoteLayout.partyAPendingQuotes[partyA].length == 0,\n214:          \"LiquidationFacet: Pending quotes should be liquidated first\"\n215:      );\n216:  @>  accountLayout.allocatedBalances[partyA] = 0;\n217:      accountLayout.lockedBalances[partyA].makeZero();\n218:\n219:      uint256 lf = accountLayout.liquidationDetails[partyA].liquidationFee;\n220:      if (lf > 0) {\n221:          accountLayout.allocatedBalances[accountLayout.liquidators[partyA][0]] += lf / 2;\n222:          accountLayout.allocatedBalances[accountLayout.liquidators[partyA][1]] += lf / 2;\n223:      }\n224:      delete accountLayout.liquidators[partyA];\n225:      maLayout.liquidationStatus[partyA] = false;\n226:      maLayout.liquidationTimestamp[partyA] = 0;\n227:      accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.NONE;\n228:      if (\n229:          accountLayout.totalUnplForLiquidation[partyA] !=\n230:          accountLayout.liquidationDetails[partyA].upnl\n231:      ) {\n232:          accountLayout.totalUnplForLiquidation[partyA] = 0;\n233:          return false;\n234:      }\n235:      accountLayout.totalUnplForLiquidation[partyA] = 0;\n236:  }\n237:  return true;\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adding Party A's realized profits during the liquidation to Party A's allocated balance.\n\n\n\n\n## Discussion\n\n**mstpr**\n\nEscalate\n\nThis works as intended. Liquidation should happen when the price reaches the liq threshold this is how the leverage trading works. Even a small wick touching the liq threshold price should initiate an immediate liquidation for the partyA. If the price goes immediately back up to liq threshold then this account should still be liquidated because the price touched to the liquidation threshold already even for a single second. \n\nLeverage trading between two parties are basically contracts, if partyA is liquidatable for even a millisecond it should be liquidated and partyB should be compensated because the agreement is settled already. \n\n**sherlock-admin2**\n\n > Escalate\n> \n> This works as intended. Liquidation should happen when the price reaches the liq threshold this is how the leverage trading works. Even a small wick touching the liq threshold price should initiate an immediate liquidation for the partyA. If the price goes immediately back up to liq threshold then this account should still be liquidated because the price touched to the liquidation threshold already even for a single second. \n> \n> Leverage trading between two parties are basically contracts, if partyA is liquidatable for even a millisecond it should be liquidated and partyB should be compensated because the agreement is settled already. \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**berndartmueller**\n\nI agree that Party A should always be liquidated, even if the liquidation threshold was touched just for a very short time.\n\nHowever, the demonstrated issue here is that if Party A has multiple positions, those which are in profit are not considered in party A's balance (while Party B will have it deducted). Instead, the protocol amasses the funds while not having the ability to withdraw them. \n\n**JeffCX**\n\n> I agree that Party A should always be liquidated, even if the liquidation threshold was touched just for a very short time.\n> \n> However, the demonstrated issue here is that if Party A has multiple positions, those which are in profit are not considered in party A's balance (while Party B will have it deducted). Instead, the protocol amasses the funds while not having the ability to withdraw them.\n\nI have to agree with the submitter's comment and recommend maintaining the medium severtiy\n\n**mstpr**\n\nPartyA is trading cross not isolated like partyB's. PartyA can have 5 trades going on with 5 different partyB's where 4 of them could be in profit but 1 of them is in huge loss that leads to liquidation. As you can also see in the contracts the total available balance for partyA is the cumulative locked balances + cumulative pnl which indicates that partyA is actually responsible for the overall balance of its position not individual positions as in isolated trading. Hence, this should be invalid \n\n**Evert0x**\n\n> Party A's realized profits during the liquidation are retained by the protocol instead of credited to Party A's allocated balance.\n\nThis does seem like intended behavior and can count as a loss for other parties involved\n\n**berndartmueller**\n\nIf Party A turned solvent mid-way through the liquidation process (between calling `setSymbolsPrice` and `liquidatePositionsPartyA`), i.e., cumulative locked balances + cumulative PnL is positive, the profits from the profitable positions are not credited to Party A, while the losses for Party B are accounted for in [L170](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol#L170).\n\nThose retained profits from Party A sit in the protocol's contract and remain unutilized. Besides, it seems the sponsor confirmed the issue as well. Curious to hear their thoughts.\n\n**MoonKnightDev**\n\nFixed code PR link:\nhttps://github.com/SYMM-IO/symmio-core/pull/22\n\n**mstpr**\n\n> If Party A turned solvent mid-way through the liquidation process (between calling `setSymbolsPrice` and `liquidatePositionsPartyA`), i.e., cumulative locked balances + cumulative PnL is positive, the profits from the profitable positions are not credited to Party A, while the losses for Party B are accounted for in [L170](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol#L170).\n> \n> Those retained profits from Party A sit in the protocol's contract and remain unutilized. Besides, it seems the sponsor confirmed the issue as well. Curious to hear their thoughts.\n\nI think MM is almost always idle and retained in the protocol contract in NORMAL liquidations\n\nsay cva = 180, lf = 20,  mm = 200, pnl = -201\n\n400 - 200 - 201 = -1, partyA is liqable.\n\nNow, say partyA is solvent midway as you said, the pnl is +1 now. \n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/6d2b64b6732fcfbd07c8217897dd233dbb6cd1f5/symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol#L166-L173\npartyBLockedBalances += 180\npartyBLockedBalances -= 1\n\npartyBLockedBalances = 400 + 180 - 1 = 579\n\nnow, partyA's cva went to partyB\npartyA's lf went to liquidator\npartyA's mm is ?? I think this is left in the contract anyways\n\nso we can say in a normal liquidation mm is always stucks in contract? Am I missing something? \n\n\n\n\n\n**panprog**\n\n> so we can say in a normal liquidation mm is always stucks in contract? Am I missing something?\n\nIt's not mm that the protocol \"steals\", it's the partyA balance after it turns solvent. In your example if pnl changed from -201 to +1, that means partyA balance becomes:\n400-200+1 = +201 - so 201 is stolen by the protocol (but it has nothing to do with mm - it's just a close number in your example).\nIf pnl of partyA changes from -201 to -199, then partyA balance becomes\n400-200-199=+1 - partyA is solvent.\npartyBallocatedBalance += 180 + 199 = +379\nliquidator will get +20\npartyA balance will be set to 0 (from 400) (-400)\nSo the balances for all parties are: +379+20-400=-1\nSo 1 is retained (stolen) by the protocol.\n\n**mstpr**\n\n> > so we can say in a normal liquidation mm is always stucks in contract? Am I missing something?\n> \n> It's not mm that the protocol \"steals\", it's the partyA balance after it turns solvent. In your example if pnl changed from -201 to +1, that means partyA balance becomes: 400-200+1 = +201 - so 201 is stolen by the protocol (but it has nothing to do with mm - it's just a close number in your example). If pnl of partyA changes from -201 to -199, then partyA balance becomes 400-200-199=+1 - partyA is solvent. partyBallocatedBalance += 180 + 199 = +379 liquidator will get +20 partyA balance will be set to 0 (from 400) (-400) So the balances for all parties are: +379+20-400=-1 So 1 is retained (stolen) by the protocol.\n\nyes correct! Thanks for the correction!\n\nSo overall, the intended behavior was to make locked balances of partyA 0 if liquidation happens to partyA and credit loss/profit to partyB. \n\nIn this edge case you describe its true that if pnl changes like that the excess amount will be retained in protocol. However, I think the intended behaviour is to make partyA balance 0 all the time in partyA liquidations, maybe this excess can go to somewhere else I am not sure. Also, the fix implemented above is not addressing this issue.\n\nIn theory everything works supposed to and considering this issue is very unlikely to happen in normal operations (liquidators would call liquidatePartyA and setSymbols in same tx or right away to get both fees) makes this a low issue imo. However, it is clear that protocol team did not know about the stuck token part.\nOn the other hand, if liquidations are supposed to make partyA's balance 0 regardless, then we can't really say that there is a \"loss of funds\" which makes the issue low/informational on Sherlock standards.  I think sponsor team should say the last word here. \n\n**hrishibhat**\n\nAdditonal Sponsor comment:\n> These funds belong to PartyB. Therefore, I believe it should be considered a medium.\n\n\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\nConsidering this a valid medium based on the above comments\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [mstpr](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/290/#issuecomment-1653408945): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/85",
  "Code": [
    {
      "filename": "symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../../libraries/LibLockedValues.sol\";\nimport \"../../libraries/LibMuon.sol\";\nimport \"../../libraries/LibAccount.sol\";\nimport \"../../libraries/LibQuote.sol\";\nimport \"../../storages/MAStorage.sol\";\nimport \"../../storages/QuoteStorage.sol\";\nimport \"../../storages/MuonStorage.sol\";\nimport \"../../storages/AccountStorage.sol\";\nimport \"../../storages/SymbolStorage.sol\";\n\nlibrary LiquidationFacetImpl {\n    using LockedValuesOps for LockedValues;\n\n    function liquidatePartyA(address partyA, SingleUpnlSig memory upnlSig) internal {\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n\n        LibMuon.verifyPartyAUpnl(upnlSig, partyA);\n        int256 availableBalance = LibAccount.partyAAvailableBalanceForLiquidation(\n            upnlSig.upnl,\n            partyA\n        );\n        require(availableBalance < 0, \"LiquidationFacet: PartyA is solvent\");\n        maLayout.liquidationStatus[partyA] = true;\n        maLayout.liquidationTimestamp[partyA] = upnlSig.timestamp;\n        AccountStorage.layout().liquidators[partyA].push(msg.sender);\n    }\n\n    function setSymbolsPrice(address partyA, PriceSig memory priceSig) internal {\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        LibMuon.verifyPrices(priceSig, partyA);\n        require(maLayout.liquidationStatus[partyA], \"LiquidationFacet: PartyA is solvent\");\n        require(\n            priceSig.timestamp <=\n                maLayout.liquidationTimestamp[partyA] + maLayout.liquidationTimeout,\n            \"LiquidationFacet: Expired signature\"\n        );\n        for (uint256 index = 0; index < priceSig.symbolIds.length; index++) {\n            accountLayout.symbolsPrices[partyA][priceSig.symbolIds[index]] = Price(\n                priceSig.prices[index],\n                maLayout.liquidationTimestamp[partyA]\n            );\n        }\n\n        int256 availableBalance = LibAccount.partyAAvailableBalanceForLiquidation(\n            priceSig.upnl,\n            partyA\n        );\n        if (accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.NONE) {\n            accountLayout.liquidationDetails[partyA] = LiquidationDetail({\n                liquidationType: LiquidationType.NONE,\n                upnl: priceSig.upnl,\n                totalUnrealizedLoss: priceSig.totalUnrealizedLoss,\n                deficit: 0,\n                liquidationFee: 0\n            });\n            if (availableBalance >= 0) {\n                uint256 remainingLf = accountLayout.lockedBalances[partyA].lf;\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.NORMAL;\n                accountLayout.liquidationDetails[partyA].liquidationFee = remainingLf;\n            } else if (uint256(-availableBalance) < accountLayout.lockedBalances[partyA].lf) {\n                uint256 remainingLf = accountLayout.lockedBalances[partyA].lf -\n                    uint256(-availableBalance);\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.NORMAL;\n                accountLayout.liquidationDetails[partyA].liquidationFee = remainingLf;\n            } else if (\n                uint256(-availableBalance) <=\n                accountLayout.lockedBalances[partyA].lf + accountLayout.lockedBalances[partyA].cva\n            ) {\n                uint256 deficit = uint256(-availableBalance) -\n                    accountLayout.lockedBalances[partyA].lf;\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.LATE;\n                accountLayout.liquidationDetails[partyA].deficit = deficit;\n            } else {\n                uint256 deficit = uint256(-availableBalance) -\n                    accountLayout.lockedBalances[partyA].lf -\n                    accountLayout.lockedBalances[partyA].cva;\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.OVERDUE;\n                accountLayout.liquidationDetails[partyA].deficit = deficit;\n            }\n            AccountStorage.layout().liquidators[partyA].push(msg.sender);\n        } else {\n            require(\n                accountLayout.liquidationDetails[partyA].upnl == priceSig.upnl &&\n                    accountLayout.liquidationDetails[partyA].totalUnrealizedLoss ==\n                    priceSig.totalUnrealizedLoss,\n                \"LiquidationFacet: Invalid upnl sig\"\n            );\n        }\n    }\n\n    function liquidatePendingPositionsPartyA(address partyA) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        require(\n            MAStorage.layout().liquidationStatus[partyA],\n            \"LiquidationFacet: PartyA is solvent\"\n        );\n        for (uint256 index = 0; index < quoteLayout.partyAPendingQuotes[partyA].length; index++) {\n            Quote storage quote = quoteLayout.quotes[\n                quoteLayout.partyAPendingQuotes[partyA][index]\n            ];\n            if (\n                (quote.quoteStatus == QuoteStatus.LOCKED ||\n                    quote.quoteStatus == QuoteStatus.CANCEL_PENDING) &&\n                quoteLayout.partyBPendingQuotes[quote.partyB][partyA].length > 0\n            ) {\n                delete quoteLayout.partyBPendingQuotes[quote.partyB][partyA];\n                AccountStorage\n                .layout()\n                .partyBPendingLockedBalances[quote.partyB][partyA].makeZero();\n            }\n            quote.quoteStatus = QuoteStatus.LIQUIDATED;\n            quote.modifyTimestamp = block.timestamp;\n        }\n        AccountStorage.layout().pendingLockedBalances[partyA].makeZero();\n        delete quoteLayout.partyAPendingQuotes[partyA];\n    }\n\n    function liquidatePositionsPartyA(\n        address partyA,\n        uint256[] memory quoteIds\n    ) internal returns (bool) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n\n        require(maLayout.liquidationStatus[partyA], \"LiquidationFacet: PartyA is solvent\");\n        for (uint256 index = 0; index < quoteIds.length; index++) {\n            Quote storage quote = quoteLayout.quotes[quoteIds[index]];\n            require(\n                quote.quoteStatus == QuoteStatus.OPENED ||\n                    quote.quoteStatus == QuoteStatus.CLOSE_PENDING ||\n                    quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n                \"LiquidationFacet: Invalid state\"\n            );\n            require(quote.partyA == partyA, \"LiquidationFacet: Invalid party\");\n            require(\n                accountLayout.symbolsPrices[partyA][quote.symbolId].timestamp ==\n                    maLayout.liquidationTimestamp[partyA],\n                \"LiquidationFacet: Price should be set\"\n            );\n            quote.quoteStatus = QuoteStatus.LIQUIDATED;\n            quote.modifyTimestamp = block.timestamp;\n\n            (bool hasMadeProfit, uint256 amount) = LibQuote.getValueOfQuoteForPartyA(\n                accountLayout.symbolsPrices[partyA][quote.symbolId].price,\n                LibQuote.quoteOpenAmount(quote),\n                quote\n            );\n            if (hasMadeProfit) {\n                accountLayout.totalUnplForLiquidation[partyA] += int256(amount);\n            } else {\n                accountLayout.totalUnplForLiquidation[partyA] -= int256(amount);\n            }\n\n            if (\n                accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.NORMAL\n            ) {\n                accountLayout.partyBAllocatedBalances[quote.partyB][partyA] += quote\n                    .lockedValues\n                    .cva;\n                if (hasMadeProfit) {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] -= amount;\n                } else {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] += amount;\n                }\n            } else if (\n                accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.LATE\n            ) {\n                accountLayout.partyBAllocatedBalances[quote.partyB][partyA] +=\n                    quote.lockedValues.cva -\n                    ((quote.lockedValues.cva * accountLayout.liquidationDetails[partyA].deficit) /\n                        accountLayout.lockedBalances[partyA].cva);\n                if (hasMadeProfit) {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] -= amount;\n                } else {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] += amount;\n                }\n            } else if (\n                accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.OVERDUE\n            ) {\n                if (hasMadeProfit) {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] -= amount;\n                } else {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] +=\n                        amount -\n                        ((amount * accountLayout.liquidationDetails[partyA].deficit) /\n                            uint256(-accountLayout.liquidationDetails[partyA].totalUnrealizedLoss));\n                }\n            }\n            accountLayout.partyBLockedBalances[quote.partyB][partyA].subQuote(quote);\n            quote.avgClosedPrice =\n                (quote.avgClosedPrice *\n                    quote.closedAmount +\n                    LibQuote.quoteOpenAmount(quote) *\n                    accountLayout.symbolsPrices[partyA][quote.symbolId].price) /\n                (quote.closedAmount + LibQuote.quoteOpenAmount(quote));\n            quote.closedAmount = quote.quantity;\n\n            LibQuote.removeFromOpenPositions(quote.id);\n            quoteLayout.partyAPositionsCount[partyA] -= 1;\n            quoteLayout.partyBPositionsCount[quote.partyB][partyA] -= 1;\n        }\n        if (quoteLayout.partyAPositionsCount[partyA] == 0) {\n            require(\n                quoteLayout.partyAPendingQuotes[partyA].length == 0,\n                \"LiquidationFacet: Pending quotes should be liquidated first\"\n            );\n            accountLayout.allocatedBalances[partyA] = 0;\n            accountLayout.lockedBalances[partyA].makeZero();\n\n            uint256 lf = accountLayout.liquidationDetails[partyA].liquidationFee;\n            if (lf > 0) {\n                accountLayout.allocatedBalances[accountLayout.liquidators[partyA][0]] += lf / 2;\n                accountLayout.allocatedBalances[accountLayout.liquidators[partyA][1]] += lf / 2;\n            }\n            delete accountLayout.liquidators[partyA];\n            maLayout.liquidationStatus[partyA] = false;\n            maLayout.liquidationTimestamp[partyA] = 0;\n            accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.NONE;\n            if (\n                accountLayout.totalUnplForLiquidation[partyA] !=\n                accountLayout.liquidationDetails[partyA].upnl\n            ) {\n                accountLayout.totalUnplForLiquidation[partyA] = 0;\n                return false;\n            }\n            accountLayout.totalUnplForLiquidation[partyA] = 0;\n        }\n        return true;\n    }\n\n    function liquidatePartyB(\n        address partyB,\n        address partyA,\n        SingleUpnlSig memory upnlSig\n    ) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n\n        LibMuon.verifyPartyBUpnl(upnlSig, partyB, partyA);\n        int256 availableBalance = LibAccount.partyBAvailableBalanceForLiquidation(\n            upnlSig.upnl,\n            partyB,\n            partyA\n        );\n\n        require(availableBalance < 0, \"LiquidationFacet: partyB is solvent\");\n        uint256 liquidatorShare;\n        uint256 remainingLf;\n        if (uint256(-availableBalance) < accountLayout.partyBLockedBalances[partyB][partyA].lf) {\n            remainingLf =\n                accountLayout.partyBLockedBalances[partyB][partyA].lf -\n                uint256(-availableBalance);\n            liquidatorShare = (remainingLf * maLayout.liquidatorShare) / 1e18;\n\n            maLayout.partyBPositionLiquidatorsShare[partyB][partyA] =\n                (remainingLf - liquidatorShare) /\n                quoteLayout.partyBPositionsCount[partyB][partyA];\n        } else {\n            maLayout.partyBPositionLiquidatorsShare[partyB][partyA] = 0;\n        }\n\n        maLayout.partyBLiquidationStatus[partyB][partyA] = true;\n        maLayout.partyBLiquidationTimestamp[partyB][partyA] = upnlSig.timestamp;\n\n        uint256[] storage pendingQuotes = quoteLayout.partyAPendingQuotes[partyA];\n\n        for (uint256 index = 0; index < pendingQuotes.length; ) {\n            Quote storage quote = quoteLayout.quotes[pendingQuotes[index]];\n            if (\n                quote.partyB == partyB &&\n                (quote.quoteStatus == QuoteStatus.LOCKED ||\n                    quote.quoteStatus == QuoteStatus.CANCEL_PENDING)\n            ) {\n                accountLayout.pendingLockedBalances[partyA].subQuote(quote);\n\n                pendingQuotes[index] = pendingQuotes[pendingQuotes.length - 1];\n                pendingQuotes.pop();\n                quote.quoteStatus = QuoteStatus.LIQUIDATED;\n                quote.modifyTimestamp = block.timestamp;\n            } else {\n                index++;\n            }\n        }\n        accountLayout.allocatedBalances[partyA] +=\n            accountLayout.partyBAllocatedBalances[partyB][partyA] -\n            remainingLf;\n\n        delete quoteLayout.partyBPendingQuotes[partyB][partyA];\n        accountLayout.partyBAllocatedBalances[partyB][partyA] = 0;\n        accountLayout.partyBLockedBalances[partyB][partyA].makeZero();\n        accountLayout.partyBPendingLockedBalances[partyB][partyA].makeZero();\n\n        if (liquidatorShare > 0) {\n            accountLayout.allocatedBalances[msg.sender] += liquidatorShare;\n        }\n    }\n\n    function liquidatePositionsPartyB(\n        address partyB,\n        address partyA,\n        QuotePriceSig memory priceSig\n    ) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n\n        LibMuon.verifyQuotePrices(priceSig);\n        require(\n            priceSig.timestamp <=\n                maLayout.partyBLiquidationTimestamp[partyB][partyA] + maLayout.liquidationTimeout,\n            \"LiquidationFacet: Expired signature\"\n        );\n        require(\n            maLayout.partyBLiquidationStatus[partyB][partyA],\n            \"LiquidationFacet: PartyB is solvent\"\n        );\n        require(\n            block.timestamp <= priceSig.timestamp + maLayout.liquidationTimeout,\n            \"LiquidationFacet: Expired price sig\"\n        );\n        for (uint256 index = 0; index < priceSig.quoteIds.length; index++) {\n            Quote storage quote = quoteLayout.quotes[priceSig.quoteIds[index]];\n            require(\n                quote.quoteStatus == QuoteStatus.OPENED ||\n                    quote.quoteStatus == QuoteStatus.CLOSE_PENDING ||\n                    quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n                \"LiquidationFacet: Invalid state\"\n            );\n            require(\n                quote.partyA == partyA && quote.partyB == partyB,\n                \"LiquidationFacet: Invalid party\"\n            );\n\n            quote.quoteStatus = QuoteStatus.LIQUIDATED;\n            quote.modifyTimestamp = block.timestamp;\n\n            // accountLayout.allocatedBalances[partyA] += quote.lockedValues.cva;\n            accountLayout.lockedBalances[partyA].subQuote(quote);\n\n            // (bool hasMadeProfit, uint256 amount) = LibQuote.getValueOfQuoteForPartyA(\n            //     priceSig.prices[index],\n            //     LibQuote.quoteOpenAmount(quote),\n            //     quote\n            // );\n\n            // if (hasMadeProfit) {\n            //     accountLayout.allocatedBalances[partyA] += amount;\n            // } else {\n            //     accountLayout.allocatedBalances[partyA] -= amount;\n            // }\n            quote.avgClosedPrice =\n                (quote.avgClosedPrice *\n                    quote.closedAmount +\n                    LibQuote.quoteOpenAmount(quote) *\n                    priceSig.prices[index]) /\n                (quote.closedAmount + LibQuote.quoteOpenAmount(quote));\n            quote.closedAmount = quote.quantity;\n\n            LibQuote.removeFromOpenPositions(quote.id);\n            quoteLayout.partyAPositionsCount[partyA] -= 1;\n            quoteLayout.partyBPositionsCount[partyB][partyA] -= 1;\n        }\n        if (maLayout.partyBPositionLiquidatorsShare[partyB][partyA] > 0) {\n            accountLayout.allocatedBalances[msg.sender] +=\n                maLayout.partyBPositionLiquidatorsShare[partyB][partyA] *\n                priceSig.quoteIds.length;\n        }\n\n        if (quoteLayout.partyBPositionsCount[partyB][partyA] == 0) {\n            maLayout.partyBLiquidationStatus[partyB][partyA] = false;\n            maLayout.partyBLiquidationTimestamp[partyB][partyA] = 0;\n        }\n    }\n}"
    },
    {
      "filename": "symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../../libraries/LibLockedValues.sol\";\nimport \"../../libraries/LibMuon.sol\";\nimport \"../../libraries/LibAccount.sol\";\nimport \"../../libraries/LibQuote.sol\";\nimport \"../../storages/MAStorage.sol\";\nimport \"../../storages/QuoteStorage.sol\";\nimport \"../../storages/MuonStorage.sol\";\nimport \"../../storages/AccountStorage.sol\";\nimport \"../../storages/SymbolStorage.sol\";\n\nlibrary LiquidationFacetImpl {\n    using LockedValuesOps for LockedValues;\n\n    function liquidatePartyA(address partyA, SingleUpnlSig memory upnlSig) internal {\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n\n        LibMuon.verifyPartyAUpnl(upnlSig, partyA);\n        int256 availableBalance = LibAccount.partyAAvailableBalanceForLiquidation(\n            upnlSig.upnl,\n            partyA\n        );\n        require(availableBalance < 0, \"LiquidationFacet: PartyA is solvent\");\n        maLayout.liquidationStatus[partyA] = true;\n        maLayout.liquidationTimestamp[partyA] = upnlSig.timestamp;\n        AccountStorage.layout().liquidators[partyA].push(msg.sender);\n    }\n\n    function setSymbolsPrice(address partyA, PriceSig memory priceSig) internal {\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        LibMuon.verifyPrices(priceSig, partyA);\n        require(maLayout.liquidationStatus[partyA], \"LiquidationFacet: PartyA is solvent\");\n        require(\n            priceSig.timestamp <=\n                maLayout.liquidationTimestamp[partyA] + maLayout.liquidationTimeout,\n            \"LiquidationFacet: Expired signature\"\n        );\n        for (uint256 index = 0; index < priceSig.symbolIds.length; index++) {\n            accountLayout.symbolsPrices[partyA][priceSig.symbolIds[index]] = Price(\n                priceSig.prices[index],\n                maLayout.liquidationTimestamp[partyA]\n            );\n        }\n\n        int256 availableBalance = LibAccount.partyAAvailableBalanceForLiquidation(\n            priceSig.upnl,\n            partyA\n        );\n        if (accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.NONE) {\n            accountLayout.liquidationDetails[partyA] = LiquidationDetail({\n                liquidationType: LiquidationType.NONE,\n                upnl: priceSig.upnl,\n                totalUnrealizedLoss: priceSig.totalUnrealizedLoss,\n                deficit: 0,\n                liquidationFee: 0\n            });\n            if (availableBalance >= 0) {\n                uint256 remainingLf = accountLayout.lockedBalances[partyA].lf;\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.NORMAL;\n                accountLayout.liquidationDetails[partyA].liquidationFee = remainingLf;\n            } else if (uint256(-availableBalance) < accountLayout.lockedBalances[partyA].lf) {\n                uint256 remainingLf = accountLayout.lockedBalances[partyA].lf -\n                    uint256(-availableBalance);\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.NORMAL;\n                accountLayout.liquidationDetails[partyA].liquidationFee = remainingLf;\n            } else if (\n                uint256(-availableBalance) <=\n                accountLayout.lockedBalances[partyA].lf + accountLayout.lockedBalances[partyA].cva\n            ) {\n                uint256 deficit = uint256(-availableBalance) -\n                    accountLayout.lockedBalances[partyA].lf;\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.LATE;\n                accountLayout.liquidationDetails[partyA].deficit = deficit;\n            } else {\n                uint256 deficit = uint256(-availableBalance) -\n                    accountLayout.lockedBalances[partyA].lf -\n                    accountLayout.lockedBalances[partyA].cva;\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.OVERDUE;\n                accountLayout.liquidationDetails[partyA].deficit = deficit;\n            }\n            AccountStorage.layout().liquidators[partyA].push(msg.sender);\n        } else {\n            require(\n                accountLayout.liquidationDetails[partyA].upnl == priceSig.upnl &&\n                    accountLayout.liquidationDetails[partyA].totalUnrealizedLoss ==\n                    priceSig.totalUnrealizedLoss,\n                \"LiquidationFacet: Invalid upnl sig\"\n            );\n        }\n    }\n\n    function liquidatePendingPositionsPartyA(address partyA) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        require(\n            MAStorage.layout().liquidationStatus[partyA],\n            \"LiquidationFacet: PartyA is solvent\"\n        );\n        for (uint256 index = 0; index < quoteLayout.partyAPendingQuotes[partyA].length; index++) {\n            Quote storage quote = quoteLayout.quotes[\n                quoteLayout.partyAPendingQuotes[partyA][index]\n            ];\n            if (\n                (quote.quoteStatus == QuoteStatus.LOCKED ||\n                    quote.quoteStatus == QuoteStatus.CANCEL_PENDING) &&\n                quoteLayout.partyBPendingQuotes[quote.partyB][partyA].length > 0\n            ) {\n                delete quoteLayout.partyBPendingQuotes[quote.partyB][partyA];\n                AccountStorage\n                .layout()\n                .partyBPendingLockedBalances[quote.partyB][partyA].makeZero();\n            }\n            quote.quoteStatus = QuoteStatus.LIQUIDATED;\n            quote.modifyTimestamp = block.timestamp;\n        }\n        AccountStorage.layout().pendingLockedBalances[partyA].makeZero();\n        delete quoteLayout.partyAPendingQuotes[partyA];\n    }\n\n    function liquidatePositionsPartyA(\n        address partyA,\n        uint256[] memory quoteIds\n    ) internal returns (bool) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n\n        require(maLayout.liquidationStatus[partyA], \"LiquidationFacet: PartyA is solvent\");\n        for (uint256 index = 0; index < quoteIds.length; index++) {\n            Quote storage quote = quoteLayout.quotes[quoteIds[index]];\n            require(\n                quote.quoteStatus == QuoteStatus.OPENED ||\n                    quote.quoteStatus == QuoteStatus.CLOSE_PENDING ||\n                    quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n                \"LiquidationFacet: Invalid state\"\n            );\n            require(quote.partyA == partyA, \"LiquidationFacet: Invalid party\");\n            require(\n                accountLayout.symbolsPrices[partyA][quote.symbolId].timestamp ==\n                    maLayout.liquidationTimestamp[partyA],\n                \"LiquidationFacet: Price should be set\"\n            );\n            quote.quoteStatus = QuoteStatus.LIQUIDATED;\n            quote.modifyTimestamp = block.timestamp;\n\n            (bool hasMadeProfit, uint256 amount) = LibQuote.getValueOfQuoteForPartyA(\n                accountLayout.symbolsPrices[partyA][quote.symbolId].price,\n                LibQuote.quoteOpenAmount(quote),\n                quote\n            );\n            if (hasMadeProfit) {\n                accountLayout.totalUnplForLiquidation[partyA] += int256(amount);\n            } else {\n                accountLayout.totalUnplForLiquidation[partyA] -= int256(amount);\n            }\n\n            if (\n                accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.NORMAL\n            ) {\n                accountLayout.partyBAllocatedBalances[quote.partyB][partyA] += quote\n                    .lockedValues\n                    .cva;\n                if (hasMadeProfit) {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] -= amount;\n                } else {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] += amount;\n                }\n            } else if (\n                accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.LATE\n            ) {\n                accountLayout.partyBAllocatedBalances[quote.partyB][partyA] +=\n                    quote.lockedValues.cva -\n                    ((quote.lockedValues.cva * accountLayout.liquidationDetails[partyA].deficit) /\n                        accountLayout.lockedBalances[partyA].cva);\n                if (hasMadeProfit) {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] -= amount;\n                } else {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] += amount;\n                }\n            } else if (\n                accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.OVERDUE\n            ) {\n                if (hasMadeProfit) {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] -= amount;\n                } else {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] +=\n                        amount -\n                        ((amount * accountLayout.liquidationDetails[partyA].deficit) /\n                            uint256(-accountLayout.liquidationDetails[partyA].totalUnrealizedLoss));\n                }\n            }\n            accountLayout.partyBLockedBalances[quote.partyB][partyA].subQuote(quote);\n            quote.avgClosedPrice =\n                (quote.avgClosedPrice *\n                    quote.closedAmount +\n                    LibQuote.quoteOpenAmount(quote) *\n                    accountLayout.symbolsPrices[partyA][quote.symbolId].price) /\n                (quote.closedAmount + LibQuote.quoteOpenAmount(quote));\n            quote.closedAmount = quote.quantity;\n\n            LibQuote.removeFromOpenPositions(quote.id);\n            quoteLayout.partyAPositionsCount[partyA] -= 1;\n            quoteLayout.partyBPositionsCount[quote.partyB][partyA] -= 1;\n        }\n        if (quoteLayout.partyAPositionsCount[partyA] == 0) {\n            require(\n                quoteLayout.partyAPendingQuotes[partyA].length == 0,\n                \"LiquidationFacet: Pending quotes should be liquidated first\"\n            );\n            accountLayout.allocatedBalances[partyA] = 0;\n            accountLayout.lockedBalances[partyA].makeZero();\n\n            uint256 lf = accountLayout.liquidationDetails[partyA].liquidationFee;\n            if (lf > 0) {\n                accountLayout.allocatedBalances[accountLayout.liquidators[partyA][0]] += lf / 2;\n                accountLayout.allocatedBalances[accountLayout.liquidators[partyA][1]] += lf / 2;\n            }\n            delete accountLayout.liquidators[partyA];\n            maLayout.liquidationStatus[partyA] = false;\n            maLayout.liquidationTimestamp[partyA] = 0;\n            accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.NONE;\n            if (\n                accountLayout.totalUnplForLiquidation[partyA] !=\n                accountLayout.liquidationDetails[partyA].upnl\n            ) {\n                accountLayout.totalUnplForLiquidation[partyA] = 0;\n                return false;\n            }\n            accountLayout.totalUnplForLiquidation[partyA] = 0;\n        }\n        return true;\n    }\n\n    function liquidatePartyB(\n        address partyB,\n        address partyA,\n        SingleUpnlSig memory upnlSig\n    ) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n\n        LibMuon.verifyPartyBUpnl(upnlSig, partyB, partyA);\n        int256 availableBalance = LibAccount.partyBAvailableBalanceForLiquidation(\n            upnlSig.upnl,\n            partyB,\n            partyA\n        );\n\n        require(availableBalance < 0, \"LiquidationFacet: partyB is solvent\");\n        uint256 liquidatorShare;\n        uint256 remainingLf;\n        if (uint256(-availableBalance) < accountLayout.partyBLockedBalances[partyB][partyA].lf) {\n            remainingLf =\n                accountLayout.partyBLockedBalances[partyB][partyA].lf -\n                uint256(-availableBalance);\n            liquidatorShare = (remainingLf * maLayout.liquidatorShare) / 1e18;\n\n            maLayout.partyBPositionLiquidatorsShare[partyB][partyA] =\n                (remainingLf - liquidatorShare) /\n                quoteLayout.partyBPositionsCount[partyB][partyA];\n        } else {\n            maLayout.partyBPositionLiquidatorsShare[partyB][partyA] = 0;\n        }\n\n        maLayout.partyBLiquidationStatus[partyB][partyA] = true;\n        maLayout.partyBLiquidationTimestamp[partyB][partyA] = upnlSig.timestamp;\n\n        uint256[] storage pendingQuotes = quoteLayout.partyAPendingQuotes[partyA];\n\n        for (uint256 index = 0; index < pendingQuotes.length; ) {\n            Quote storage quote = quoteLayout.quotes[pendingQuotes[index]];\n            if (\n                quote.partyB == partyB &&\n                (quote.quoteStatus == QuoteStatus.LOCKED ||\n                    quote.quoteStatus == QuoteStatus.CANCEL_PENDING)\n            ) {\n                accountLayout.pendingLockedBalances[partyA].subQuote(quote);\n\n                pendingQuotes[index] = pendingQuotes[pendingQuotes.length - 1];\n                pendingQuotes.pop();\n                quote.quoteStatus = QuoteStatus.LIQUIDATED;\n                quote.modifyTimestamp = block.timestamp;\n            } else {\n                index++;\n            }\n        }\n        accountLayout.allocatedBalances[partyA] +=\n            accountLayout.partyBAllocatedBalances[partyB][partyA] -\n            remainingLf;\n\n        delete quoteLayout.partyBPendingQuotes[partyB][partyA];\n        accountLayout.partyBAllocatedBalances[partyB][partyA] = 0;\n        accountLayout.partyBLockedBalances[partyB][partyA].makeZero();\n        accountLayout.partyBPendingLockedBalances[partyB][partyA].makeZero();\n\n        if (liquidatorShare > 0) {\n            accountLayout.allocatedBalances[msg.sender] += liquidatorShare;\n        }\n    }\n\n    function liquidatePositionsPartyB(\n        address partyB,\n        address partyA,\n        QuotePriceSig memory priceSig\n    ) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n\n        LibMuon.verifyQuotePrices(priceSig);\n        require(\n            priceSig.timestamp <=\n                maLayout.partyBLiquidationTimestamp[partyB][partyA] + maLayout.liquidationTimeout,"
    }
  ]
}