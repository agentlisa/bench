{
  "Title": "[C-03] Decimals are incorrectly handled in DivReducerNode",
  "Content": "**Severity**\n\n**Impact:** High\n\n**Likelihood:** High\n\n**Description**\n\nNode DivReducer is supposed to have 2 parents which are Redstone oracles and combine 2 prices. For example, to price ETH/USDC it will fetch 2 prices and divide `(ETH/USD) / (USDC/USD)`.\n\nThe problem is that Redstone oracles have 8 decimals by default, but the code uses 1e18 arithmetic:\n\n```solidity\n    function process(NodeOutput.Data[] memory parentNodeOutputs) internal pure returns (NodeOutput.Data memory) {\n        if (parentNodeOutputs[1].price == 0) {\n            revert InvalidPrice();\n        }\n\n@>      uint256 price = divUintUint(parentNodeOutputs[0].price, parentNodeOutputs[1].price).unwrap();\n        uint256 timestamp = (parentNodeOutputs[0].timestamp + parentNodeOutputs[1].timestamp) / 2;\n\n        return NodeOutput.Data({ price: price, timestamp: timestamp });\n    }\n\n\nfunction divUintUint(uint256 a, uint256 b) pure returns (UD60x18) {\n    return UD60x18.wrap(a).div(UD60x18.wrap(b));\n}\n```\n\nHere you can see the default decimals is 8:\n[link](https://github.com/redstone-finance/redstone-oracles-monorepo/blob/9d10a48aad7a2ccb5f3f48396d970fd63761dbce/packages/on-chain-relayer/contracts/price-feeds/PriceFeedBase.sol#L46-L53)\n\n**Recommendations**\n\nNormalize the price from RedstoneOracle by decimals of that oracle. Only after using it in internal calculations",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "packages/on-chain-relayer/contracts/price-feeds/PriceFeedBase.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.14;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {IRedstoneAdapter} from \"../core/IRedstoneAdapter.sol\";\nimport {IPriceFeed} from \"./interfaces/IPriceFeed.sol\";\n\n/**\n * @title Main logic of the price feed contract\n * @author The Redstone Oracles team\n * @dev Implementation of common functions for the PriceFeed contract\n * that queries data from the specified PriceFeedAdapter\n * \n * It can be used by projects that have already implemented with Chainlink-like\n * price feeds and would like to minimise changes in their existing codebase.\n * \n * If you are flexible, it's much better (and cheaper in terms of gas) to query\n * the PriceFeedAdapter contract directly\n */\nabstract contract PriceFeedBase is IPriceFeed, Initializable {\n  uint256 internal constant INT256_MAX = uint256(type(int256).max);\n\n  error UnsafeUintToIntConversion(uint256 value);\n\n  /**\n   * @dev Helpful function for upgradable contracts\n   */\n  function initialize() public virtual initializer {\n    // We don't have storage variables, but we keep this function\n    // Because it is used for contract setup in upgradable contracts\n  }\n\n  /**\n   * @notice Returns data feed identifier for the PriceFeed contract\n   * @return dataFeedId The identifier of the data feed\n   */\n  function getDataFeedId() public view virtual returns (bytes32);\n\n  /**\n   * @notice Returns the address of the price feed adapter\n   * @return address The address of the price feed adapter\n   */\n  function getPriceFeedAdapter() public view virtual returns (IRedstoneAdapter);\n\n\n  /**\n   * @notice Returns the number of decimals for the price feed\n   * @dev By default, RedStone uses 8 decimals for data feeds\n   * @return decimals The number of decimals in the price feed values\n   */\n  function decimals() public virtual pure override returns (uint8) {\n    return 8;\n  }\n\n\n  /**\n   * @notice Description of the Price Feed\n   * @return description\n   */\n  function description() public view virtual override returns (string memory) {\n    return \"Redstone Price Feed\";\n  }\n\n  /**\n   * @notice Version of the Price Feed\n   * @dev Currently it has no specific motivation and was added\n   * only to be compatible with the Chainlink interface\n   * @return version\n   */\n  function version() public virtual pure override returns (uint256) {\n    return 1;\n  }\n\n\n  /**\n   * @notice Returns details of the latest successful update round\n   * @dev It uses few helpful functions to abstract logic of getting\n   * latest round id and value\n   * @return roundId The number of the latest round\n   * @return answer The latest reported value\n   * @return startedAt Block timestamp when the latest successful round started\n   * @return updatedAt Block timestamp of the latest successful round\n   * @return answeredInRound The number of the latest round\n   */\n  function latestRoundData()\n    public\n    view\n    override\n    virtual\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    roundId = latestRound();\n    answer = latestAnswer();\n\n    uint256 blockTimestamp = getPriceFeedAdapter().getBlockTimestampFromLatestUpdate();\n\n    // These values are equal after chainlinkâ€™s OCR update\n    startedAt = blockTimestamp;\n    updatedAt = blockTimestamp;\n\n    // We want to be compatible with Chainlink's interface\n    // And in our case the roundId is always equal to answeredInRound\n    answeredInRound = roundId;\n  }\n\n  /**\n   * @notice Old Chainlink function for getting the latest successfully reported value\n   * @return latestAnswer The latest successfully reported value\n   */\n  function latestAnswer() public virtual view returns (int256) {\n    bytes32 dataFeedId = getDataFeedId();\n\n    uint256 uintAnswer = getPriceFeedAdapter().getValueForDataFeed(dataFeedId);\n\n    if (uintAnswer > INT256_MAX) {\n      revert UnsafeUintToIntConversion(uintAnswer);\n    }\n\n    return int256(uintAnswer);\n  }\n\n  /**\n   * @notice Old Chainlink function for getting the number of latest round\n   * @return latestRound The number of the latest update round\n   */\n  function latestRound() public view virtual returns (uint80);\n}"
    }
  ]
}