{
  "Title": "[L-03] The `gasLeft()` after gas-limited external call might not be enough to complete the transaction",
  "Content": "In `StargateArbitrum::sgReceive` we have the following piece of code\n\n```solidity\ntry IArbitrumSwaps(payable(address(this))).arbitrumSwaps{gas: 200000}(steps, data) {}\n        catch (bytes memory) {\n            IERC20(_token).safeTransfer(to, amountLD);\n            failed = true;\n        }\n```\n\nNow if the `arbitrumSwaps` call took up all of the gas it is possible that there is not enough gas left for the `safeTransfer` call, as well for the code below it. Consider a different approach, that will check `gasleft()` and make sure that there will be enough, something like in [this method](https://github.com/sushiswap/sushiswap/blob/9a85946574135d57194c44bf27376732091974cc/protocols/sushixswap/contracts/adapters/StargateAdapter.sol#L114-L171)",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "protocols/sushixswap/contracts/adapters/StargateAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.11;\n\nimport \"../interfaces/stargate/IStargateAdapter.sol\";\n\n/// @title StargateAdapter\n/// @notice Adapter for function used by Stargate Bridge\nabstract contract StargateAdapter is ImmutableState, IStargateReceiver {\n    using SafeERC20 for IERC20;\n\n    // Custom Error\n    error NotStargateRouter();\n    error InsufficientGas();\n\n    // events\n    event StargateSushiXSwapSrc(bytes32 indexed srcContext);\n    event StargateSushiXSwapDst(bytes32 indexed srcContext, bool failed);\n\n    struct StargateTeleportParams {\n        uint16 dstChainId; // stargate dst chain id\n        address token; // token getting bridged\n        uint256 srcPoolId; // stargate src pool id\n        uint256 dstPoolId; // stargate dst pool id\n        uint256 amount; // amount to bridge\n        uint256 amountMin; // amount to bridge minimum\n        uint256 dustAmount; // native token to be received on dst chain\n        address receiver; // sushiXswap on dst chain\n        address to; // receiver bridge token incase of transaction reverts on dst chain\n        uint256 gas; // extra gas to be sent for dst chain operations\n        bytes32 srcContext; // random bytes32 as source context\n    }\n\n    /// @notice Approves token to the Stargate Router\n    /// @param token token to approve\n    function approveToStargateRouter(IERC20 token) external {\n        token.safeApprove(address(stargateRouter), type(uint256).max);\n    }\n\n    /// @notice Bridges the token to dst chain using Stargate Router\n    /// @dev It is hardcoded to use all the contract balance. Only call this as the last step.\n    /// The refund address for extra fees sent it msg.sender.\n    /// @param params required by the Stargate, can be found at StargateTeleportParams struct.\n    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).\n    /// @param values A one-to-one mapped array to `actions`. Native token amount to send along action.\n    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.\n    function _stargateTeleport(\n        StargateTeleportParams memory params,\n        uint8[] memory actions,\n        uint256[] memory values,\n        bytes[] memory datas\n    ) internal {\n        bytes memory payload = abi.encode(params.to, actions, values, datas, params.srcContext);\n\n        /// @dev dst gas should be more than 100k\n        if(params.gas < 100000) revert InsufficientGas();\n\n        stargateRouter.swap{value: address(this).balance}(\n            params.dstChainId,\n            params.srcPoolId,\n            params.dstPoolId,\n            payable(msg.sender), // refund address\n            params.amount != 0\n                ? params.amount\n                : IERC20(params.token).balanceOf(address(this)),\n            params.amountMin,\n            IStargateRouter.lzTxObj(\n                params.gas, // extra gas to be sent for dst execution\n                params.dustAmount,\n                abi.encodePacked(params.receiver)\n            ),\n            abi.encodePacked(params.receiver), // sushiXswap on the dst chain\n            payload\n        );\n\n        stargateWidget.partnerSwap(0x0001);\n\n        emit StargateSushiXSwapSrc(params.srcContext);\n    }\n\n    /// @notice Get the fees to be paid in native token for the swap\n    /// @param _dstChainId stargate dst chainId\n    /// @param _functionType stargate Function type 1 for swap.\n    /// See more at https://stargateprotocol.gitbook.io/stargate/developers/function-types\n    /// @param _receiver sushiXswap on the dst chain\n    /// @param _gas extra gas being sent\n    /// @param _dustAmount dust amount to be received at the dst chain\n    /// @param _payload payload being sent at the dst chain\n    function getFee(\n        uint16 _dstChainId,\n        uint8 _functionType,\n        address _receiver,\n        uint256 _gas,\n        uint256 _dustAmount,\n        bytes memory _payload\n    ) external view returns (uint256 a, uint256 b) {\n        (a, b) = stargateRouter.quoteLayerZeroFee(\n            _dstChainId,\n            _functionType,\n            abi.encodePacked(_receiver),\n            abi.encode(_payload),\n            IStargateRouter.lzTxObj(\n                _gas,\n                _dustAmount,\n                abi.encodePacked(_receiver)\n            )\n        );\n    }\n\n    /// @notice Receiver function on dst chain\n    /// @param _token bridge token received\n    /// @param amountLD amount received\n    /// @param payload ABI-Encoded data received from src chain\n    function sgReceive(\n        uint16,\n        bytes memory,\n        uint256,\n        address _token,\n        uint256 amountLD,\n        bytes memory payload\n    ) external override {\n        if (msg.sender != address(stargateRouter)) revert NotStargateRouter();\n\n        (\n            address to,\n            uint8[] memory actions,\n            uint256[] memory values,\n            bytes[] memory datas,\n            bytes32 srcContext\n        ) = abi.decode(payload, (address, uint8[], uint256[], bytes[], bytes32));\n\n        uint256 reserveGas = 100000;\n        bool failed;\n\n        if(gasleft() < reserveGas) {\n            if(_token != SGETH) {\n                IERC20(_token).safeTransfer(to, amountLD);\n            }\n            /// @dev transfer any native token received as dust to the to address\n            if (address(this).balance > 0)\n                to.call{value: (address(this).balance)}(\"\");\n\n            failed = true;\n            emit StargateSushiXSwapDst(srcContext, failed);\n            return;\n        }\n\n        // 100000 -> exit gas\n        uint256 limit = gasleft() - reserveGas;\n\n        /// @dev incase the actions fail, transfer bridge token to the to address\n        try\n            ISushiXSwap(payable(address(this))).cook{gas: limit}(\n                actions,\n                values,\n                datas\n            )\n        {} catch (bytes memory) {\n            if(_token != SGETH) {\n                IERC20(_token).safeTransfer(to, amountLD);\n            }\n            failed = true;\n        }\n\n        /// @dev transfer any native token received as dust to the to address\n        if (address(this).balance > 0)\n            to.call{value: (address(this).balance)}(\"\");\n\n        emit StargateSushiXSwapDst(srcContext, failed);\n\n    }\n}"
    }
  ]
}