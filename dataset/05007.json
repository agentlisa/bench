{
  "Title": "[02] Setters should always have equality checkers",
  "Content": "\nUsing [this](https://github.com/search?q=repo%3Acode-423n4%2F2024-03-revert-lend%20function%20set&type=code) search prompt code, we can see that multiple setter functions exist in scope, with them not having any check that the new accepted value is not equal to the previously stored value.\n\nFor example, [setReward()](https://github.com/code-423n4/2024-03-revert-lend/blob/ac520c5fedf4e1654c597a46efaf5a7c27295de1/src/transformers/AutoCompound.sol#L243-L247) checks that the new value is `<=` whereas it should only check `<` leading to an unnecessary update of `totalRewardX64` if `_totalRewardX64 is already == totalRewardX64`.\n\n```solidity\n    function setReward(uint64 _totalRewardX64) external onlyOwner {\n        require(_totalRewardX64 <= totalRewardX64, \">totalRewardX64\");\n        totalRewardX64 = _totalRewardX64;\n        emit RewardUpdated(msg.sender, _totalRewardX64);\n    }\n```\n\nAnother example would be the below, that does not implement any checks whatsoever:\n\n```\n function setWithdrawer(address _withdrawer) public onlyOwner {\n emit WithdrawerChanged(_withdrawer);\nwithdrawer = _withdrawer;\n}\n```\n\n### Impact\n\nUnnecessary code execution.\n\n### Recommended Mitigation Steps\n\nIntroduce equality checkers for setter functions.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-revert-lend",
  "Code": [
    {
      "filename": "src/transformers/AutoCompound.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Multicall.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"v3-periphery/interfaces/INonfungiblePositionManager.sol\";\n\nimport \"../automators/Automator.sol\";\n\n/// @title AutoCompound\n/// @notice Allows operator of AutoCompound contract (Revert controlled bot) to compound a position\n/// Positions need to be approved (approve or setApprovalForAll) for the contract when outside vault\n/// When position is inside Vault - owner needs to approve the position to be transformed by the contract\ncontract AutoCompound is Automator, Multicall, ReentrancyGuard {\n    // autocompound event\n    event AutoCompounded(\n        address account,\n        uint256 tokenId,\n        uint256 amountAdded0,\n        uint256 amountAdded1,\n        uint256 reward0,\n        uint256 reward1,\n        address token0,\n        address token1\n    );\n\n    // config changes\n    event RewardUpdated(address account, uint64 totalRewardX64);\n\n    // balance movements\n    event BalanceAdded(uint256 tokenId, address token, uint256 amount);\n    event BalanceRemoved(uint256 tokenId, address token, uint256 amount);\n    event BalanceWithdrawn(uint256 tokenId, address token, address to, uint256 amount);\n\n    constructor(\n        INonfungiblePositionManager _npm,\n        address _operator,\n        address _withdrawer,\n        uint32 _TWAPSeconds,\n        uint16 _maxTWAPTickDifference\n    ) Automator(_npm, _operator, _withdrawer, _TWAPSeconds, _maxTWAPTickDifference, address(0), address(0)) {}\n\n    mapping(uint256 => mapping(address => uint256)) public positionBalances;\n\n    uint64 public constant MAX_REWARD_X64 = uint64(Q64 / 50); // 2%\n    uint64 public totalRewardX64 = MAX_REWARD_X64; // 2%\n\n    /// @notice params for execute()\n    struct ExecuteParams {\n        // tokenid to autocompound\n        uint256 tokenId;\n        // swap direction - calculated off-chain\n        bool swap0To1;\n        // swap amount - calculated off-chain - if this is set to 0 no swap happens\n        uint256 amountIn;\n    }\n\n    // state used during autocompound execution\n    struct ExecuteState {\n        uint256 amount0;\n        uint256 amount1;\n        uint256 maxAddAmount0;\n        uint256 maxAddAmount1;\n        uint256 amount0Fees;\n        uint256 amount1Fees;\n        uint256 priceX96;\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 compounded0;\n        uint256 compounded1;\n        int24 tick;\n        uint160 sqrtPriceX96;\n        uint256 amountInDelta;\n        uint256 amountOutDelta;\n    }\n\n    /**\n     * @notice Adjust token (which is in a Vault) - via transform method\n     * Can only be called from configured operator account - vault must be configured as well\n     * Swap needs to be done with max price difference from current pool price - otherwise reverts\n     */\n    function executeWithVault(ExecuteParams calldata params, address vault) external {\n        if (!operators[msg.sender] || !vaults[vault]) {\n            revert Unauthorized();\n        }\n        IVault(vault).transform(\n            params.tokenId, address(this), abi.encodeWithSelector(AutoCompound.execute.selector, params)\n        );\n    }\n\n    /**\n     * @notice Adjust token directly (must be in correct state)\n     * Can only be called only from configured operator account, or vault via transform\n     * Swap needs to be done with max price difference from current pool price - otherwise reverts\n     */\n    function execute(ExecuteParams calldata params) external nonReentrant {\n        if (!operators[msg.sender] && !vaults[msg.sender]) {\n            revert Unauthorized();\n        }\n        ExecuteState memory state;\n\n        // collect fees - if the position doesn't have operator set or is called from vault - it won't work\n        (state.amount0, state.amount1) = nonfungiblePositionManager.collect(\n            INonfungiblePositionManager.CollectParams(\n                params.tokenId, address(this), type(uint128).max, type(uint128).max\n            )\n        );\n\n        // get position info\n        (,, state.token0, state.token1, state.fee, state.tickLower, state.tickUpper,,,,,) =\n            nonfungiblePositionManager.positions(params.tokenId);\n\n        // add previous balances from given tokens\n        state.amount0 = state.amount0 + positionBalances[params.tokenId][state.token0];\n        state.amount1 = state.amount1 + positionBalances[params.tokenId][state.token1];\n\n        // only if there are balances to work with - start autocompounding process\n        if (state.amount0 > 0 || state.amount1 > 0) {\n            uint256 amountIn = params.amountIn;\n\n            // if a swap is requested - check TWAP oracle\n            if (amountIn > 0) {\n                IUniswapV3Pool pool = _getPool(state.token0, state.token1, state.fee);\n                (state.sqrtPriceX96, state.tick,,,,,) = pool.slot0();\n\n                // how many seconds are needed for TWAP protection\n                uint32 tSecs = TWAPSeconds;\n                if (tSecs > 0) {\n                    if (!_hasMaxTWAPTickDifference(pool, tSecs, state.tick, maxTWAPTickDifference)) {\n                        // if there is no valid TWAP - disable swap\n                        amountIn = 0;\n                    }\n                }\n                // if still needed - do swap\n                if (amountIn > 0) {\n                    // no slippage check done - because protected by TWAP check\n                    (state.amountInDelta, state.amountOutDelta) = _poolSwap(\n                        Swapper.PoolSwapParams(\n                            pool, IERC20(state.token0), IERC20(state.token1), state.fee, params.swap0To1, amountIn, 0\n                        )\n                    );\n                    state.amount0 =\n                        params.swap0To1 ? state.amount0 - state.amountInDelta : state.amount0 + state.amountOutDelta;\n                    state.amount1 =\n                        params.swap0To1 ? state.amount1 + state.amountOutDelta : state.amount1 - state.amountInDelta;\n                }\n            }\n\n            uint256 rewardX64 = totalRewardX64;\n\n            state.maxAddAmount0 = state.amount0 * Q64 / (rewardX64 + Q64);\n            state.maxAddAmount1 = state.amount1 * Q64 / (rewardX64 + Q64);\n\n            // deposit liquidity into tokenId\n            if (state.maxAddAmount0 > 0 || state.maxAddAmount1 > 0) {\n                _checkApprovals(state.token0, state.token1);\n\n                (, state.compounded0, state.compounded1) = nonfungiblePositionManager.increaseLiquidity(\n                    INonfungiblePositionManager.IncreaseLiquidityParams(\n                        params.tokenId, state.maxAddAmount0, state.maxAddAmount1, 0, 0, block.timestamp\n                    )\n                );\n\n                // fees are always calculated based on added amount (to incentivize optimal swap)\n                state.amount0Fees = state.compounded0 * rewardX64 / Q64;\n                state.amount1Fees = state.compounded1 * rewardX64 / Q64;\n            }\n\n            // calculate remaining tokens for owner\n            _setBalance(params.tokenId, state.token0, state.amount0 - state.compounded0 - state.amount0Fees);\n            _setBalance(params.tokenId, state.token1, state.amount1 - state.compounded1 - state.amount1Fees);\n\n            // add reward to protocol balance (token 0)\n            _increaseBalance(0, state.token0, state.amount0Fees);\n            _increaseBalance(0, state.token1, state.amount1Fees);\n        }\n\n        emit AutoCompounded(\n            msg.sender,\n            params.tokenId,\n            state.compounded0,\n            state.compounded1,\n            state.amount0Fees,\n            state.amount1Fees,\n            state.token0,\n            state.token1\n        );\n    }\n\n    /**\n     * @notice Withdraws leftover token balance for a token\n     * @param tokenId Id of position to withdraw\n     * @param to Address to send to\n     */\n    function withdrawLeftoverBalances(uint256 tokenId, address to) external nonReentrant {\n        address owner = nonfungiblePositionManager.ownerOf(tokenId);\n        if (vaults[owner]) {\n            owner = IVault(owner).ownerOf(tokenId);\n        }\n        if (owner != msg.sender) {\n            revert Unauthorized();\n        }\n\n        (,, address token0, address token1,,,,,,,,) = nonfungiblePositionManager.positions(tokenId);\n\n        uint256 balance0 = positionBalances[tokenId][token0];\n        if (balance0 > 0) {\n            _withdrawBalanceInternal(tokenId, token0, to, balance0, balance0);\n        }\n        uint256 balance1 = positionBalances[tokenId][token1];\n        if (balance1 > 0) {\n            _withdrawBalanceInternal(tokenId, token1, to, balance1, balance1);\n        }\n    }\n\n    /**\n     * @notice Withdraws token balance (accumulated protocol fee)\n     * @dev The method is overriden, because it differs from standard automator fee handling\n     * @param tokens Addresses of tokens to withdraw\n     * @param to Address to send to\n     */\n    function withdrawBalances(address[] calldata tokens, address to) external override nonReentrant {\n        if (msg.sender != withdrawer) {\n            revert Unauthorized();\n        }\n        uint256 i;\n        uint256 count = tokens.length;\n        for (; i < count; ++i) {\n            uint256 balance = positionBalances[0][tokens[i]];\n            _withdrawBalanceInternal(0, tokens[i], to, balance, balance);\n        }\n    }\n\n    /**\n     * @notice Management method to lower reward(onlyOwner)\n     * @param _totalRewardX64 new total reward (can't be higher than current total reward)\n     */\n    function setReward(uint64 _totalRewardX64) external onlyOwner {\n        require(_totalRewardX64 <= totalRewardX64, \">totalRewardX64\");\n        totalRewardX64 = _totalRewardX64;\n        emit RewardUpdated(msg.sender, _totalRewardX64);\n    }\n\n    function _increaseBalance(uint256 tokenId, address token, uint256 amount) internal {\n        positionBalances[tokenId][token] = positionBalances[tokenId][token] + amount;\n        emit BalanceAdded(tokenId, token, amount);\n    }\n\n    function _setBalance(uint256 tokenId, address token, uint256 amount) internal {\n        uint256 currentBalance = positionBalances[tokenId][token];\n        if (amount != currentBalance) {\n            positionBalances[tokenId][token] = amount;\n            if (amount > currentBalance) {\n                emit BalanceAdded(tokenId, token, amount - currentBalance);\n            } else {\n                emit BalanceRemoved(tokenId, token, currentBalance - amount);\n            }\n        }\n    }\n\n    function _withdrawBalanceInternal(uint256 tokenId, address token, address to, uint256 balance, uint256 amount)\n        internal\n    {\n        require(amount <= balance, \"amount>balance\");\n        positionBalances[tokenId][token] = positionBalances[tokenId][token] - amount;\n        emit BalanceRemoved(tokenId, token, amount);\n        SafeERC20.safeTransfer(IERC20(token), to, amount);\n        emit BalanceWithdrawn(tokenId, token, to, amount);\n    }\n\n    function _checkApprovals(address token0, address token1) internal {\n        // approve tokens once if not yet approved - to save gas during compounds\n        uint256 allowance0 = IERC20(token0).allowance(address(this), address(nonfungiblePositionManager));\n        if (allowance0 == 0) {\n            SafeERC20.safeApprove(IERC20(token0), address(nonfungiblePositionManager), type(uint256).max);\n        }\n        uint256 allowance1 = IERC20(token1).allowance(address(this), address(nonfungiblePositionManager));\n        if (allowance1 == 0) {\n            SafeERC20.safeApprove(IERC20(token1), address(nonfungiblePositionManager), type(uint256).max);\n        }\n    }\n}"
    }
  ]
}