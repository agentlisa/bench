{
  "Title": "[M14] The relations between loops and their boundaries are not clear",
  "Content": "There are several occurrences in the codebase where `for` loops are used to iterate an entire array.\n\n\nThis is a [widely known problem in the Ethereum ecosystem](https://solidity.readthedocs.io/en/v0.5.3/security-considerations.html?highlight=loops#gas-limit-and-loops), as it is common that loops in Smart Contracts result in an `out of gas` error when the number of iterations that the loop needs to execute is too big.\n\n\nSome examples of this behavior are:\n\n\n* In the [`Accounts`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/Accounts.sol#L13) contract: [L353](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/Accounts.sol#L353)\n* In the [`Attestations`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Attestations.sol#L22) contract: [L133](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Attestations.sol#L133), [L358](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Attestations.sol#L358), [L360](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Attestations.sol#L360), [L420](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Attestations.sol#L420), [L430](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Attestations.sol#L430), [L543](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Attestations.sol#L543)\n* In the [`DowntimeSlasher`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/DowntimeSlasher.sol#L8) contract: [L82](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/DowntimeSlasher.sol#L82)\n* In the [`Election`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol) contract: [L224](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol#L224), [L397](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol#L397), [L848](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol#L848), [L854](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol#L854), [L878](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol#L878), [L902](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol#L902), [L944](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol#L944)\n* In the [`Governance`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Governance.sol#L21) contract: [L917](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Governance.sol#L917), [L1026](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Governance.sol#L1026)\n* In the [`Proposals`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Proposals.sol#L12) library: [L82](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Proposals.sol#L82), [L121](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Proposals.sol#L121)\n* In the [`Reserve`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/Reserve.sol#L18) contract: [L116](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/Reserve.sol#L116), [L275](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/Reserve.sol#L275), [L294](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/Reserve.sol#L294)\n* In the [`SortedOracles`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/SortedOracles.sol#L14) contract: [L112](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/SortedOracles.sol#L112)\n* In the [`StableToken`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/StableToken.sol#L18) contract: [L124](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/StableToken.sol#L124)\n* In the [`Validators`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Validators.sol#L22) contract: [L341](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Validators.sol#L341), [L380](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Validators.sol#L380), [L804](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Validators.sol#L804), [L912](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Validators.sol#L912), [L929](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Validators.sol#L929), [L974](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Validators.sol#L974)\n\n\nAlso, the [family of LinkedLists libraries](https://github.com/celo-org/celo-monorepo/tree/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/linkedlists) makes heavy use of for loops for iterating the lists, as seen in the `popN`, `headN`, `getElements` and `numElementsGreaterThan` functions. This could also generate problems in other parts of the protocol that are using these functions under the hood.\n\n\nSome examples of this behavior are:\n\n\n* In the [`Election`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol#L16) contract: [L805](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol#L805), [L822](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol#L822), [L826](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol#L826)\n* In the [`Governance`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Governance.sol#L21) contract: [L879](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Governance.sol#L879), [L965](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Governance.sol#L965)\n* In the [`SortedOracles`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/SortedOracles.sol#L14) contract: [L201](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/SortedOracles.sol#L201), [L232](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/SortedOracles.sol#L232)\n* In the [`Validators`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Validators.sol#L22) contract: [L910](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Validators.sol#L910)\n\n\nSome examples of the implications arising from this issue are:\n\n\n* In the `Governance` contract, if the [`concurrentProposals` is set as a big enough number](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Governance.sol#L964-L973), the `propose`,`execute`, `upvote`, `revokeUpvote`, `approve` and `vote` functions will be unusable.\n* In the `Proposals` and `Governance` contracts, a proposal [can be made](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Proposals.sol#L60-L88) with a transaction array which is determined by user input and it is not being validated in the Smart Contract layer. Later on, when [these transactions are being validated](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Governance.sol#L1022) and gas consumptions of the functions called are higher, [the proposal may not be able to execute](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Governance.sol#L642).\n* In the `Elections` contract, it could result in the impossibility of further voting for a user [if the amount of groups it has voted on is too big](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol#L223-L224).\n* In the `Reserve` contract, `getOrComputeTobinTax` can run out of gas if the `_tokens` array is big enough, as its length is used as the break condition in a for loop.\n* In the `DowntimeSlasher` contract, if the [`slashableDowntime` variable](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/DowntimeSlasher.sol#L13) is big enough, the [`isDown` function](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/DowntimeSlasher.sol#L61) will be rendered unusable and it will not be able to slash byzantine validators.\n\n\nConsider setting a hard cap on the number of iterations that the smart contracts should execute. Likewise, when the iteration limit is bounded by invariant properties in the code, consider enforcing that those properties are invariant. Finally, consider thoroughly reviewing the usage of `for` loops in the protocol and closely analyzing the effects of failures that may arise from the lack of limits in these loops.\n\n\n****Update:*** Not Fixed. [Issue #3420](https://github.com/celo-org/celo-monorepo/issues/3420) was created to keep track of this. cLabs’ statement for this issue:*\n\n\n\n> \n> All of the listed “unbounded” loops are either bounded by input arguments, are external view calls intended to be called via RPC, or are bounded governable parameters.  \n> \n> In the first case, the caller is responsible for setting the arguments appropriately. For example, the “unbounded” loop in batchGetMetadataURL is bounded by the length of the input array. Clients that want to query metadata URLs (e.g. the Celo Wallet mobile application) can reduce the size of the batches being fetched if larger batches consume too much gas.  \n> \n> Examples:  \n> \n> \\* In the [`Accounts`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/Accounts.sol#L13) contract: [L353](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/Accounts.sol#L353)  \n> \n> \\* In the [`Attestations`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Attestations.sol#L22) contract: [L133](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Attestations.sol#L133), [L358](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Attestations.sol#L358), [L360](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Attestations.sol#L360), [L543](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Attestations.sol#L543)  \n> \n> \\* In the [`Governance`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Governance.sol#L21) contract: [L1026 (transaction array length set by proposer)](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Governance.sol#L1026)  \n> \n> \\* In the [`Proposals`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Proposals.sol#L12) library: [L82](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Proposals.sol#L82), [L121 ( (transaction array length set by proposer)](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Proposals.sol#L121)  \n> \n> \\* In the [`Reserve`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/Reserve.sol#L18) contract: [L116](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/Reserve.sol#L116)  \n> \n> \\* In the [`SortedOracles`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/SortedOracles.sol#L14) contract: [L112](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/SortedOracles.sol#L112)  \n> \n> \\* In the [`StableToken`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/StableToken.sol#L18) contract: [L124](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/StableToken.sol#L124)  \n> \n> \\* In the [`Validators`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Validators.sol#L22) contract [L380](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Validators.sol#L380), [L912](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Validators.sol#L912), [L929](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Validators.sol#L929)  \n> \n> In the second case, the function exposes smart contract storage state via a view function. All of these functions were written to be called via RPC by a trusted client, in which gas provided can be made to exceed the block gas limit.  \n> \n> Examples:  \n> \n> \\* In the [`Accounts`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/Accounts.sol#L13) contract: [L353](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/Accounts.sol#L353)  \n> \n> \\* In the [`Attestations`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Attestations.sol#L22) contract: [L420](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Attestations.sol#L420), [L430](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Attestations.sol#L430)  \n> \n> \\* In the [`Election`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol#L16) contract: [L805](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol#L805)  \n> \n> \\* In the [`Governance`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Governance.sol#L21) contract: [L879](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Governance.sol#L879)  \n> \n> \\* In the [`SortedOracles`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/SortedOracles.sol#L14) contract: [L201](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/SortedOracles.sol#L201), [L232](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/SortedOracles.sol#L232)  \n> \n> \\* In the [`Validators`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Validators.sol#L22) contract: [L341](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Validators.sol#L341), [L380](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Validators.sol#L380), [L804](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Validators.sol#L804), [L910](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Validators.sol#L910), [L912](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Validators.sol#L912), [L974](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Validators.sol#L974), [L929](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Validators.sol#L929)  \n> \n> In the third case, the length of the loop is bounded by a storage variable set via on-chain governance. Should the gas consumed by the loop grow too large, it can be lowered via on-chain governance.  \n> \n> Examples:  \n> \n> \\* In the [`DowntimeSlasher`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/DowntimeSlasher.sol#L8) contract: [L82](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/DowntimeSlasher.sol#L82)  \n> \n> \\* In the [`Election`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol) contract: [L224](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol#L224), [L397](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol#L397), [L848](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol#L848), [L854](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol#L854), [L878](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol#L878), [L902](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol#L902), [L944](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol#L944)  \n> \n> \\* In the [`Governance`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Governance.sol#L21) contract: [L917](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Governance.sol#L917)  \n> \n> \\* In the [`Reserve`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/Reserve.sol#L18) contract: [L116](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/Reserve.sol#L116), [L275](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/Reserve.sol#L275), [L294](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/Reserve.sol#L294)  \n> \n> \\* In the [`Validators`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Validators.sol#L22) contract: [L341](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Validators.sol#L341), [L380](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Validators.sol#L380) (where needed, limited by the max group size), [L804](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Validators.sol#L804), [L910](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Validators.sol#L910) (where needed, limited by the max group size), [L912](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Validators.sol#L912) (where needed, limited by the max group size), [L929](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Validators.sol#L929) (where needed, limited by electableValidators.max)  \n> \n> \\* In the [`Election`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol) contract: [L822](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol#L822), [L826](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol#L826)  \n> \n> \\* In the [`Governance`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Governance.sol#L21) contract: [L965](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Governance.sol#L965)\n> \n> \n> \n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/common/Accounts.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\";\n\nimport \"./interfaces/IAccounts.sol\";\n\nimport \"../common/Initializable.sol\";\nimport \"../common/Signatures.sol\";\nimport \"../common/UsingRegistry.sol\";\n\ncontract Accounts is IAccounts, Ownable, ReentrancyGuard, Initializable, UsingRegistry {\n  using SafeMath for uint256;\n\n  struct Signers {\n    // The address that is authorized to vote in governance and validator elections on behalf of the\n    // account. The account can vote as well, whether or not a vote signing key has been specified.\n    address vote;\n    // The address that is authorized to manage a validator or validator group and sign consensus\n    // messages on behalf of the account. The account can manage the validator, whether or not a\n    // validator signing key has been specified. However, if a validator signing key has been\n    // specified, only that key may actually participate in consensus.\n    address validator;\n    // The address of the key with which this account wants to sign attestations on the Attestations\n    // contract\n    address attestation;\n  }\n\n  struct Account {\n    bool exists;\n    // Each account may authorize signing keys to use for voting, valdiating or attestation.\n    // These keys may not be keys of other accounts, and may not be authorized by any other\n    // account for any purpose.\n    Signers signers;\n    // The address at which the account expects to receive transfers. If it's empty/0x0, the\n    // account indicates that an address exchange should be initiated with the dataEncryptionKey\n    address walletAddress;\n    // An optional human readable identifier for the account\n    string name;\n    // The ECDSA public key used to encrypt and decrypt data for this account\n    bytes dataEncryptionKey;\n    // The URL under which an account adds metadata and claims\n    string metadataURL;\n  }\n\n  mapping(address => Account) private accounts;\n  // Maps authorized signers to the account that provided the authorization.\n  mapping(address => address) public authorizedBy;\n\n  event AttestationSignerAuthorized(address indexed account, address signer);\n  event VoteSignerAuthorized(address indexed account, address signer);\n  event ValidatorSignerAuthorized(address indexed account, address signer);\n  event AccountDataEncryptionKeySet(address indexed account, bytes dataEncryptionKey);\n  event AccountNameSet(address indexed account, string name);\n  event AccountMetadataURLSet(address indexed account, string metadataURL);\n  event AccountWalletAddressSet(address indexed account, address walletAddress);\n  event AccountCreated(address indexed account);\n\n  function initialize(address registryAddress) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n  }\n\n  /**\n   * @notice Convenience Setter for the dataEncryptionKey and wallet address for an account\n   * @param name A string to set as the name of the account\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   * @param walletAddress The wallet address to set for the account\n   */\n  function setAccount(string calldata name, bytes calldata dataEncryptionKey, address walletAddress)\n    external\n  {\n    if (!isAccount(msg.sender)) {\n      createAccount();\n    }\n    setName(name);\n    setAccountDataEncryptionKey(dataEncryptionKey);\n    setWalletAddress(walletAddress);\n  }\n\n  /**\n   * @notice Creates an account.\n   * @return True if account creation succeeded.\n   */\n  function createAccount() public returns (bool) {\n    require(isNotAccount(msg.sender) && isNotAuthorizedSigner(msg.sender), \"Account exists\");\n    Account storage account = accounts[msg.sender];\n    account.exists = true;\n    emit AccountCreated(msg.sender);\n    return true;\n  }\n\n  /**\n   * @notice Setter for the name of an account.\n   * @param name The name to set.\n   */\n  function setName(string memory name) public {\n    require(isAccount(msg.sender), \"Unknown account\");\n    accounts[msg.sender].name = name;\n    emit AccountNameSet(msg.sender, name);\n  }\n\n  /**\n   * @notice Setter for the wallet address for an account\n   * @param walletAddress The wallet address to set for the account\n   */\n  function setWalletAddress(address walletAddress) public {\n    require(isAccount(msg.sender), \"Unknown account\");\n    accounts[msg.sender].walletAddress = walletAddress;\n    emit AccountWalletAddressSet(msg.sender, walletAddress);\n  }\n\n  /**\n   * @notice Setter for the data encryption key and version.\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function setAccountDataEncryptionKey(bytes memory dataEncryptionKey) public {\n    require(dataEncryptionKey.length >= 33, \"data encryption key length <= 32\");\n    accounts[msg.sender].dataEncryptionKey = dataEncryptionKey;\n    emit AccountDataEncryptionKeySet(msg.sender, dataEncryptionKey);\n  }\n\n  /**\n   * @notice Setter for the metadata of an account.\n   * @param metadataURL The URL to access the metadata.\n   */\n  function setMetadataURL(string calldata metadataURL) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    accounts[msg.sender].metadataURL = metadataURL;\n    emit AccountMetadataURLSet(msg.sender, metadataURL);\n  }\n\n  /**\n   * @notice Authorizes an address to sign votes on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeVoteSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    Account storage account = accounts[msg.sender];\n    authorize(signer, v, r, s);\n    account.signers.vote = signer;\n    emit VoteSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    Account storage account = accounts[msg.sender];\n    authorize(signer, v, r, s);\n    account.signers.validator = signer;\n    require(!getValidators().isValidator(msg.sender), \"Cannot authorize validator signer\");\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSigner(\n    address signer,\n    bytes calldata ecdsaPublicKey,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external nonReentrant {\n    Account storage account = accounts[msg.sender];\n    authorize(signer, v, r, s);\n    account.signers.validator = signer;\n    require(\n      getValidators().updateEcdsaPublicKey(msg.sender, signer, ecdsaPublicKey),\n      \"Failed to update ECDSA public key\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign attestations on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeAttestationSigner(address signer, uint8 v, bytes32 r, bytes32 s) public {\n    Account storage account = accounts[msg.sender];\n    authorize(signer, v, r, s);\n    account.signers.attestation = signer;\n    emit AttestationSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized attestation signer.\n   * @dev Fails if the `signer` is not an account or currently authorized attestation signer.\n   * @return The associated account.\n   */\n  function attestationSignerToAccount(address signer) external view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      require(\n        accounts[authorizingAccount].signers.attestation == signer,\n        \"not active authorized attestation signer\"\n      );\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"not an account\");\n      return signer;\n    }\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of an account or currently authorized validator signer.\n   * @dev Fails if the `signer` is not an account or currently authorized validator.\n   * @return The associated account.\n   */\n  function validatorSignerToAccount(address signer) public view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      require(\n        accounts[authorizingAccount].signers.validator == signer,\n        \"not active authorized validator signer\"\n      );\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"not an account\");\n      return signer;\n    }\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized vote signer.\n   * @dev Fails if the `signer` is not an account or currently authorized vote signer.\n   * @return The associated account.\n   */\n  function voteSignerToAccount(address signer) external view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      require(\n        accounts[authorizingAccount].signers.vote == signer,\n        \"not active authorized vote signer\"\n      );\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"not an account\");\n      return signer;\n    }\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or previously authorized signer.\n   * @dev Fails if the `signer` is not an account or previously authorized signer.\n   * @return The associated account.\n   */\n  function signerToAccount(address signer) external view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"Not an account\");\n      return signer;\n    }\n  }\n\n  /**\n   * @notice Returns the vote signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign votes.\n   */\n  function getVoteSigner(address account) public view returns (address) {\n    require(isAccount(account), \"Unknown account\");\n    address signer = accounts[account].signers.vote;\n    return signer == address(0) ? account : signer;\n  }\n\n  /**\n   * @notice Returns the validator signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can register a validator or group.\n   */\n  function getValidatorSigner(address account) public view returns (address) {\n    require(isAccount(account), \"Unknown account\");\n    address signer = accounts[account].signers.validator;\n    return signer == address(0) ? account : signer;\n  }\n\n  /**\n   * @notice Returns the attestation signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign attestations.\n   */\n  function getAttestationSigner(address account) public view returns (address) {\n    require(isAccount(account), \"Unknown account\");\n    address signer = accounts[account].signers.attestation;\n    return signer == address(0) ? account : signer;\n  }\n\n  /**\n   * @notice Getter for the name of an account.\n   * @param account The address of the account to get the name for.\n   * @return name The name of the account.\n   */\n  function getName(address account) external view returns (string memory) {\n    return accounts[account].name;\n  }\n\n  /**\n   * @notice Getter for the metadata of an account.\n   * @param account The address of the account to get the metadata for.\n   * @return metadataURL The URL to access the metadata.\n   */\n  function getMetadataURL(address account) external view returns (string memory) {\n    return accounts[account].metadataURL;\n  }\n\n  /**\n   * @notice Getter for the metadata of multiple accounts.\n   * @param accountsToQuery The addresses of the accounts to get the metadata for.\n   * @return (stringLengths[] - the length of each string in bytes\n   *          data - all strings concatenated\n   *         )\n   */\n  function batchGetMetadataURL(address[] calldata accountsToQuery)\n    external\n    view\n    returns (uint256[] memory, bytes memory)\n  {\n    uint256 totalSize = 0;\n    uint256[] memory sizes = new uint256[](accountsToQuery.length);\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      sizes[i] = bytes(accounts[accountsToQuery[i]].metadataURL).length;\n      totalSize = totalSize.add(sizes[i]);\n    }\n\n    bytes memory data = new bytes(totalSize);\n    uint256 pointer = 0;\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      for (uint256 j = 0; j < sizes[i]; j = j.add(1)) {\n        data[pointer] = bytes(accounts[accountsToQuery[i]].metadataURL)[j];\n        pointer = pointer.add(1);\n      }\n    }\n    return (sizes, data);\n  }\n\n  /**\n   * @notice Getter for the data encryption key and version.\n   * @param account The address of the account to get the key for\n   * @return dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function getDataEncryptionKey(address account) external view returns (bytes memory) {\n    return accounts[account].dataEncryptionKey;\n  }\n\n  /**\n   * @notice Getter for the wallet address for an account\n   * @param account The address of the account to get the wallet address for\n   * @return Wallet address\n   */\n  function getWalletAddress(address account) external view returns (address) {\n    return accounts[account].walletAddress;\n  }\n\n  /**\n   * @notice Check if an account already exists.\n   * @param account The address of the account\n   * @return Returns `true` if account exists. Returns `false` otherwise.\n   */\n  function isAccount(address account) public view returns (bool) {\n    return (accounts[account].exists);\n  }\n\n  /**\n   * @notice Check if an account already exists.\n   * @param account The address of the account\n   * @return Returns `false` if account exists. Returns `true` otherwise.\n   */\n  function isNotAccount(address account) internal view returns (bool) {\n    return (!accounts[account].exists);\n  }\n\n  /**\n   * @notice Check if an address has been an authorized signer for an account.\n   * @param signer The possibly authorized address.\n   * @return Returns `true` if authorized. Returns `false` otherwise.\n   */\n  function isAuthorizedSigner(address signer) external view returns (bool) {\n    return (authorizedBy[signer] != address(0));\n  }\n\n  /**\n   * @notice Check if an address has been an authorized signer for an account.\n   * @param signer The possibly authorized address.\n   * @return Returns `false` if authorized. Returns `true` otherwise.\n   */\n  function isNotAuthorizedSigner(address signer) internal view returns (bool) {\n    return (authorizedBy[signer] == address(0));\n  }\n\n  /**\n   * @notice Authorizes some role of of `msg.sender`'s account to another address.\n   * @param authorized The address to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Fails if the address is already authorized or is an account.\n   * @dev Note that once an address is authorized, it may never be authorized again.\n   * @dev v, r, s constitute `current`'s signature on `msg.sender`.\n   */\n  function authorize(address authorized, uint8 v, bytes32 r, bytes32 s) private {\n    require(isAccount(msg.sender), \"Unknown account\");\n    require(\n      isNotAccount(authorized) && isNotAuthorizedSigner(authorized),\n      \"delegate or account exists\"\n    );\n\n    address signer = Signatures.getSignerOfAddress(msg.sender, v, r, s);\n    require(signer == authorized, \"Invalid signature\");\n\n    authorizedBy[authorized] = msg.sender;\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/identity/Attestations.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./interfaces/IAttestations.sol\";\nimport \"./interfaces/IRandom.sol\";\nimport \"../common/interfaces/IERC20Token.sol\";\nimport \"../common/interfaces/IAccounts.sol\";\nimport \"../governance/interfaces/IValidators.sol\";\n\nimport \"../common/Initializable.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/Signatures.sol\";\nimport \"../common/SafeCast.sol\";\nimport \"../common/UsingPrecompiles.sol\";\n\n/**\n * @title Contract mapping identifiers to accounts\n */\ncontract Attestations is\n  IAttestations,\n  Ownable,\n  Initializable,\n  UsingRegistry,\n  ReentrancyGuard,\n  UsingPrecompiles\n{\n  using SafeMath for uint256;\n  using SafeCast for uint256;\n\n  enum AttestationStatus { None, Incomplete, Complete }\n\n  struct Attestation {\n    AttestationStatus status;\n    // For outstanding attestations, this is the block number of the request.\n    // For completed attestations, this is the block number of the attestation completion.\n    uint32 blockNumber;\n    // The token with which attestation request fees were paid.\n    address attestationRequestFeeToken;\n  }\n\n  // Stores attestations state for a single (identifier, account address) pair.\n  struct AttestedAddress {\n    // Total number of requested attestations.\n    uint32 requested;\n    // Total number of completed attestations.\n    uint32 completed;\n    // List of selected issuers responsible for attestations. The length of this list\n    // might be smaller than `requested` (which represents the total number of requested\n    // attestations) if users are not calling `selectIssuers` on unselected requests.\n    address[] selectedIssuers;\n    // State of each attestation keyed by issuer.\n    mapping(address => Attestation) issuedAttestations;\n  }\n\n  struct UnselectedRequest {\n    // The block at which the attestations were requested.\n    uint32 blockNumber;\n    // The number of attestations that were requested.\n    uint32 attestationsRequested;\n    // The token with which attestation request fees were paid in this request.\n    address attestationRequestFeeToken;\n  }\n\n  struct IdentifierState {\n    // All account addresses associated with this identifier.\n    address[] accounts;\n    // Keeps the state of attestations for account addresses for this identifier.\n    mapping(address => AttestedAddress) attestations;\n    // Temporarily stores attestation requests for which issuers should be selected by the account.\n    mapping(address => UnselectedRequest) unselectedRequests;\n  }\n\n  mapping(bytes32 => IdentifierState) identifiers;\n\n  // The duration in blocks in which an attestation can be completed from the block in which the\n  // attestation was requested.\n  uint256 public attestationExpiryBlocks;\n\n  // The duration to wait until selectIssuers can be called for an attestation request.\n  uint256 public selectIssuersWaitBlocks;\n\n  // The fees that are associated with attestations for a particular token.\n  mapping(address => uint256) public attestationRequestFees;\n\n  // Maps a token and attestation issuer to the amount that they're owed.\n  mapping(address => mapping(address => uint256)) public pendingWithdrawals;\n\n  event AttestationsRequested(\n    bytes32 indexed identifier,\n    address indexed account,\n    uint256 attestationsRequested,\n    address attestationRequestFeeToken\n  );\n\n  event AttestationIssuerSelected(\n    bytes32 indexed identifier,\n    address indexed account,\n    address indexed issuer,\n    address attestationRequestFeeToken\n  );\n\n  event AttestationCompleted(\n    bytes32 indexed identifier,\n    address indexed account,\n    address indexed issuer\n  );\n\n  event Withdrawal(address indexed account, address indexed token, uint256 amount);\n  event AttestationExpiryBlocksSet(uint256 value);\n  event AttestationRequestFeeSet(address indexed token, uint256 value);\n  event SelectIssuersWaitBlocksSet(uint256 value);\n\n  function initialize(\n    address registryAddress,\n    uint256 _attestationExpiryBlocks,\n    uint256 _selectIssuersWaitBlocks,\n    address[] calldata attestationRequestFeeTokens,\n    uint256[] calldata attestationRequestFeeValues\n  ) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setAttestationExpiryBlocks(_attestationExpiryBlocks);\n    setSelectIssuersWaitBlocks(_selectIssuersWaitBlocks);\n\n    require(\n      attestationRequestFeeTokens.length > 0 &&\n        attestationRequestFeeTokens.length == attestationRequestFeeValues.length,\n      \"attestationRequestFeeTokens specification was invalid\"\n    );\n    for (uint256 i = 0; i < attestationRequestFeeTokens.length; i = i.add(1)) {\n      setAttestationRequestFee(attestationRequestFeeTokens[i], attestationRequestFeeValues[i]);\n    }\n  }\n\n  /**\n   * @notice Commit to the attestation request of a hashed identifier.\n   * @param identifier The hash of the identifier to be attested.\n   * @param attestationsRequested The number of requested attestations for this request.\n   * @param attestationRequestFeeToken The address of the token with which the attestation fee will\n   * be paid.\n   */\n  function request(\n    bytes32 identifier,\n    uint256 attestationsRequested,\n    address attestationRequestFeeToken\n  ) external nonReentrant {\n    require(\n      attestationRequestFees[attestationRequestFeeToken] > 0,\n      \"Invalid attestationRequestFeeToken\"\n    );\n    require(\n      IERC20Token(attestationRequestFeeToken).transferFrom(\n        msg.sender,\n        address(this),\n        attestationRequestFees[attestationRequestFeeToken].mul(attestationsRequested)\n      ),\n      \"Transfer of attestation request fees failed\"\n    );\n\n    require(attestationsRequested > 0, \"You have to request at least 1 attestation\");\n\n    IdentifierState storage state = identifiers[identifier];\n\n    require(\n      state.unselectedRequests[msg.sender].blockNumber == 0 ||\n        isAttestationExpired(state.unselectedRequests[msg.sender].blockNumber) ||\n        !isAttestationRequestSelectable(state.unselectedRequests[msg.sender].blockNumber),\n      \"There exists an unexpired, unselected attestation request\"\n    );\n\n    state.unselectedRequests[msg.sender].blockNumber = block.number.toUint32();\n    state.unselectedRequests[msg.sender].attestationsRequested = attestationsRequested.toUint32();\n    state.unselectedRequests[msg.sender].attestationRequestFeeToken = attestationRequestFeeToken;\n\n    state.attestations[msg.sender].requested = uint256(state.attestations[msg.sender].requested)\n      .add(attestationsRequested)\n      .toUint32();\n\n    emit AttestationsRequested(\n      identifier,\n      msg.sender,\n      attestationsRequested,\n      attestationRequestFeeToken\n    );\n  }\n\n  /**\n   * @notice Selects the issuers for the most recent attestation request.\n   * @param identifier The hash of the identifier to be attested.\n   */\n  function selectIssuers(bytes32 identifier) external {\n    IdentifierState storage state = identifiers[identifier];\n\n    require(\n      state.unselectedRequests[msg.sender].blockNumber > 0,\n      \"No unselected attestation request to select issuers for\"\n    );\n\n    require(\n      !isAttestationExpired(state.unselectedRequests[msg.sender].blockNumber),\n      \"The attestation request has expired\"\n    );\n\n    addIncompleteAttestations(identifier);\n    delete state.unselectedRequests[msg.sender];\n  }\n\n  /**\n   * @notice Submit the secret message sent by the issuer to complete the attestation request.\n   * @param identifier The hash of the identifier for this attestation.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Throws if there is no matching outstanding attestation request.\n   * @dev Throws if the attestation window has passed.\n   */\n  function complete(bytes32 identifier, uint8 v, bytes32 r, bytes32 s) external {\n    address issuer = validateAttestationCode(identifier, msg.sender, v, r, s);\n\n    Attestation storage attestation = identifiers[identifier].attestations[msg.sender]\n      .issuedAttestations[issuer];\n\n    address token = attestation.attestationRequestFeeToken;\n\n    // solhint-disable-next-line not-rely-on-time\n    attestation.blockNumber = block.number.toUint32();\n    attestation.status = AttestationStatus.Complete;\n    delete attestation.attestationRequestFeeToken;\n    identifiers[identifier].attestations[msg.sender].completed++;\n\n    pendingWithdrawals[token][issuer] = pendingWithdrawals[token][issuer].add(\n      attestationRequestFees[token]\n    );\n\n    IdentifierState storage state = identifiers[identifier];\n    if (identifiers[identifier].attestations[msg.sender].completed == 1) {\n      state.accounts.push(msg.sender);\n    }\n\n    emit AttestationCompleted(identifier, msg.sender, issuer);\n  }\n\n  /**\n   * @notice Revokes an account for an identifier.\n   * @param identifier The identifier for which to revoke.\n   * @param index The index of the account in the accounts array.\n   */\n  function revoke(bytes32 identifier, uint256 index) external {\n    uint256 numAccounts = identifiers[identifier].accounts.length;\n    require(index < numAccounts, \"Index is invalid\");\n    require(\n      msg.sender == identifiers[identifier].accounts[index],\n      \"Index does not match msg.sender\"\n    );\n\n    uint256 newNumAccounts = numAccounts.sub(1);\n    if (index != newNumAccounts) {\n      identifiers[identifier].accounts[index] = identifiers[identifier].accounts[newNumAccounts];\n    }\n    identifiers[identifier].accounts[newNumAccounts] = address(0x0);\n    identifiers[identifier].accounts.length--;\n  }\n\n  /**\n   * @notice Allows issuers to withdraw accumulated attestation rewards.\n   * @param token The address of the token that will be withdrawn.\n   * @dev Throws if msg.sender does not have any rewards to withdraw.\n   */\n  function withdraw(address token) external {\n    uint256 value = pendingWithdrawals[token][msg.sender];\n    require(value > 0, \"value was negative/zero\");\n    pendingWithdrawals[token][msg.sender] = 0;\n    require(IERC20Token(token).transfer(msg.sender, value), \"token transfer failed\");\n    emit Withdrawal(msg.sender, token, value);\n  }\n\n  /**\n   * @notice Returns the unselected attestation request for an identifier/account pair, if any.\n   * @param identifier Hash of the identifier.\n   * @param account Address of the account.\n   * @return [\n   *           Block number at which was requested,\n   *           Number of unselected requests,\n   *           Address of the token with which this attestation request was paid for\n   *         ]\n   */\n  function getUnselectedRequest(bytes32 identifier, address account)\n    external\n    view\n    returns (uint32, uint32, address)\n  {\n    return (\n      identifiers[identifier].unselectedRequests[account].blockNumber,\n      identifiers[identifier].unselectedRequests[account].attestationsRequested,\n      identifiers[identifier].unselectedRequests[account].attestationRequestFeeToken\n    );\n  }\n\n  /**\n   * @notice Returns selected attestation issuers for a identifier/account pair.\n   * @param identifier Hash of the identifier.\n   * @param account Address of the account.\n   * @return Addresses of the selected attestation issuers.\n   */\n  function getAttestationIssuers(bytes32 identifier, address account)\n    external\n    view\n    returns (address[] memory)\n  {\n    return identifiers[identifier].attestations[account].selectedIssuers;\n  }\n\n  /**\n   * @notice Returns attestation stats for a identifier/account pair.\n   * @param identifier Hash of the identifier.\n   * @param account Address of the account.\n   * @return [Number of completed attestations, Number of total requested attestations]\n   */\n  function getAttestationStats(bytes32 identifier, address account)\n    external\n    view\n    returns (uint32, uint32)\n  {\n    return (\n      identifiers[identifier].attestations[account].completed,\n      identifiers[identifier].attestations[account].requested\n    );\n  }\n\n  /**\n   * @notice Batch lookup function to determine attestation stats for a list of identifiers.\n   * @param identifiersToLookup Array of n identifiers.\n   * @return [0] Array of number of matching accounts per identifier.\n   * @return [1] Array of sum([0]) matching walletAddresses.\n   * @return [2] Array of sum([0]) numbers indicating the completions for each account.\n   * @return [3] Array of sum([0]) numbers indicating the total number of requested\n                 attestations for each account.\n   */\n  function batchGetAttestationStats(bytes32[] calldata identifiersToLookup)\n    external\n    view\n    returns (uint256[] memory, address[] memory, uint64[] memory, uint64[] memory)\n  {\n    require(identifiersToLookup.length > 0, \"You have to pass at least one identifier\");\n\n    uint256[] memory matches;\n    address[] memory addresses;\n\n    (matches, addresses) = batchlookupAccountsForIdentifier(identifiersToLookup);\n\n    uint64[] memory completed = new uint64[](addresses.length);\n    uint64[] memory total = new uint64[](addresses.length);\n\n    uint256 currentIndex = 0;\n    for (uint256 i = 0; i < identifiersToLookup.length; i++) {\n      address[] memory addrs = identifiers[identifiersToLookup[i]].accounts;\n      for (uint256 matchIndex = 0; matchIndex < matches[i]; matchIndex++) {\n        addresses[currentIndex] = getAccounts().getWalletAddress(addrs[matchIndex]);\n        completed[currentIndex] = identifiers[identifiersToLookup[i]]\n          .attestations[addrs[matchIndex]]\n          .completed;\n        total[currentIndex] = identifiers[identifiersToLookup[i]].attestations[addrs[matchIndex]]\n          .requested;\n\n        currentIndex++;\n      }\n    }\n\n    return (matches, addresses, completed, total);\n  }\n\n  /**\n   * @notice Returns the state of a specific attestation.\n   * @param identifier Hash of the identifier.\n   * @param account Address of the account.\n   * @param issuer Address of the issuer.\n   * @return [\n   *           Status of the attestation,\n   *           Block number of request/completion the attestation,\n   *           Address of the token with which this attestation request was paid for\n   *         ]\n   */\n  function getAttestationState(bytes32 identifier, address account, address issuer)\n    external\n    view\n    returns (uint8, uint32, address)\n  {\n    Attestation storage attestation = identifiers[identifier].attestations[account]\n      .issuedAttestations[issuer];\n    return (\n      uint8(attestation.status),\n      attestation.blockNumber,\n      attestation.attestationRequestFeeToken\n    );\n\n  }\n\n  /**\n    * @notice Returns the state of all attestations that are completable\n    * @param identifier Hash of the identifier.\n    * @param account Address of the account.\n    * @return ( blockNumbers[] - Block number of request/completion the attestation,\n    *           issuers[] - Address of the issuer,\n    *           stringLengths[] - The length of each metadataURL string for each issuer,\n    *           stringData - All strings concatenated\n    *         )\n    */\n  function getCompletableAttestations(bytes32 identifier, address account)\n    external\n    view\n    returns (uint32[] memory, address[] memory, uint256[] memory, bytes memory)\n  {\n    AttestedAddress storage state = identifiers[identifier].attestations[account];"
    }
  ]
}