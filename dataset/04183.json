{
  "Title": "Uncontrolled call of functions",
  "Content": "\n- [crv-locker.sol#L84](https://github.com/pickle-finance/protocol/blob/9b0f330a16bc35c964211feae3b335ab398c01b6/src/strategies/curve/crv-locker.sol#L84) \n\n    Uncontrolled call of functions of another contract on behalf of this contract with the possibility of transferring ETH. Such a call can be made both by the user `governance` and by other users from the map `voters`.\n    In the contract [scrv-voter.sol#L150](https://github.com/pickle-finance/protocol/blob/9b0f330a16bc35c964211feae3b335ab398c01b6/src/strategies/curve/scrv-voter.sol#L150) and [scrv-voter.sol#L169](https://github.com/pickle-finance/protocol/blob/9b0f330a16bc35c964211feae3b335ab398c01b6/src/strategies/curve/scrv-voter.sol#L169) there is a reference to such a possibility.\n    But you can call other functions of this contract from any other contract. This can lead to unpredictable consequences.\n\n- [strategy-base.sol#L196](https://github.com/pickle-finance/protocol/blob/9b0f330a16bc35c964211feae3b335ab398c01b6/src/strategies/strategy-base.sol#L196)\n\n    The `timelock` user in the `_data` parameter can pass any value, which can lead to unpredictable consequences when accessing the contract with the `_target` address.\n    This particular issue qualified as a warning due to the security model assuming that voters are trusted persons/contracts. \n    Anyway we recommend limiting the use of such functionality because uncontrolled calls have very high risks.\n\nStatus: *Acknowledged*.\n\nClient's comment: *The team is aware of this issue, but would like to state that this is necessary since Curve will not whitelist proxy contracts (i.e. we cannot easily change our implementation).\nUse of the `execute` function is reserved for emergency situations. If it is used in an adversarial manner, there is a 12 hour timelock for participants to exit the system.\nBeyond this, control of this function is handled by a 3 of 6 community controlled multisig wallet. The original team is no longer in majority control and power has been transferred to community participants to ensure good faith outcomes.*\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/strategies/curve/crv-locker.sol",
      "content": "// CurveYCRVVoter: https://etherscan.io/address/0xF147b8125d2ef93FB6965Db97D6746952a133934#code\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\n\nimport \"../../lib/erc20.sol\";\nimport \"../../lib/safe-math.sol\";\n\nimport \"../../interfaces/curve.sol\";\n\ncontract CRVLocker {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address public constant mintr = 0xd061D61a4d941c39E5453435B6345Dc261C2fcE0;\n    address public constant crv = 0xD533a949740bb3306d119CC777fa900bA034cd52;\n\n    address public constant escrow = 0x5f3b5DfEb7B28CDbD7FAba78963EE202a494e2A2;\n\n    address public governance;\n    mapping(address => bool) public voters;\n\n    constructor(address _governance) public {\n        governance = _governance;\n    }\n\n    function getName() external pure returns (string memory) {\n        return \"CRVLocker\";\n    }\n\n    function addVoter(address _voter) external {\n        require(msg.sender == governance, \"!governance\");\n        voters[_voter] = true;\n    }\n\n    function removeVoter(address _voter) external {\n        require(msg.sender == governance, \"!governance\");\n        voters[_voter] = false;\n    }\n\n    function withdraw(address _asset) external returns (uint256 balance) {\n        require(voters[msg.sender], \"!voter\");\n        balance = IERC20(_asset).balanceOf(address(this));\n        IERC20(_asset).safeTransfer(msg.sender, balance);\n    }\n\n    function createLock(uint256 _value, uint256 _unlockTime) external {\n        require(voters[msg.sender] || msg.sender == governance, \"!authorized\");\n        IERC20(crv).safeApprove(escrow, 0);\n        IERC20(crv).safeApprove(escrow, _value);\n        ICurveVotingEscrow(escrow).create_lock(_value, _unlockTime);\n    }\n\n    function increaseAmount(uint256 _value) external {\n        require(voters[msg.sender] || msg.sender == governance, \"!authorized\");\n        IERC20(crv).safeApprove(escrow, 0);\n        IERC20(crv).safeApprove(escrow, _value);\n        ICurveVotingEscrow(escrow).increase_amount(_value);\n    }\n\n    function increaseUnlockTime(uint256 _unlockTime) external {\n        require(voters[msg.sender] || msg.sender == governance, \"!authorized\");\n        ICurveVotingEscrow(escrow).increase_unlock_time(_unlockTime);\n    }\n\n    function release() external {\n        require(voters[msg.sender] || msg.sender == governance, \"!authorized\");\n        ICurveVotingEscrow(escrow).withdraw();\n    }\n\n    function setGovernance(address _governance) external {\n        require(msg.sender == governance, \"!governance\");\n        governance = _governance;\n    }\n\n    function execute(\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bool, bytes memory) {\n        require(voters[msg.sender] || msg.sender == governance, \"!governance\");\n\n        (bool success, bytes memory result) = to.call{value: value}(data);\n        require(success, \"!execute-success\");\n\n        return (success, result);\n    }\n}"
    },
    {
      "filename": "src/strategies/curve/scrv-voter.sol",
      "content": "// StrategyProxy: https://etherscan.io/address/0x5886e475e163f78cf63d6683abc7fe8516d12081#code\npragma solidity ^0.6.7;\n\nimport \"../../lib/erc20.sol\";\nimport \"../../lib/safe-math.sol\";\n\nimport \"./crv-locker.sol\";\n\nimport \"../../interfaces/curve.sol\";\n\ncontract SCRVVoter {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    CRVLocker public crvLocker;\n\n    address public constant want = 0xC25a3A3b969415c80451098fa907EC722572917F;\n    address public constant mintr = 0xd061D61a4d941c39E5453435B6345Dc261C2fcE0;\n    address public constant crv = 0xD533a949740bb3306d119CC777fa900bA034cd52;\n    address public constant snx = 0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F;\n    address\n        public constant gaugeController = 0x2F50D538606Fa9EDD2B11E2446BEb18C9D5846bB;\n    address\n        public constant scrvGauge = 0xA90996896660DEcC6E997655E065b23788857849;\n\n    mapping(address => bool) public strategies;\n    address public governance;\n\n    constructor(address _governance, address _crvLocker) public {\n        governance = _governance;\n        crvLocker = CRVLocker(_crvLocker);\n    }\n\n    function setGovernance(address _governance) external {\n        require(msg.sender == governance, \"!governance\");\n        governance = _governance;\n    }\n\n    function approveStrategy(address _strategy) external {\n        require(msg.sender == governance, \"!governance\");\n        strategies[_strategy] = true;\n    }\n\n    function revokeStrategy(address _strategy) external {\n        require(msg.sender == governance, \"!governance\");\n        strategies[_strategy] = false;\n    }\n\n    function lock() external {\n        crvLocker.increaseAmount(IERC20(crv).balanceOf(address(crvLocker)));\n    }\n\n    function vote(address _gauge, uint256 _amount) public {\n        require(strategies[msg.sender], \"!strategy\");\n        crvLocker.execute(\n            gaugeController,\n            0,\n            abi.encodeWithSignature(\n                \"vote_for_gauge_weights(address,uint256)\",\n                _gauge,\n                _amount\n            )\n        );\n    }\n\n    function max() external {\n        require(strategies[msg.sender], \"!strategy\");\n        vote(scrvGauge, 10000);\n    }\n\n    function withdraw(\n        address _gauge,\n        address _token,\n        uint256 _amount\n    ) public returns (uint256) {\n        require(strategies[msg.sender], \"!strategy\");\n        uint256 _before = IERC20(_token).balanceOf(address(crvLocker));\n        crvLocker.execute(\n            _gauge,\n            0,\n            abi.encodeWithSignature(\"withdraw(uint256)\", _amount)\n        );\n        uint256 _after = IERC20(_token).balanceOf(address(crvLocker));\n        uint256 _net = _after.sub(_before);\n        crvLocker.execute(\n            _token,\n            0,\n            abi.encodeWithSignature(\n                \"transfer(address,uint256)\",\n                msg.sender,\n                _net\n            )\n        );\n        return _net;\n    }\n\n    function balanceOf(address _gauge) public view returns (uint256) {\n        return IERC20(_gauge).balanceOf(address(crvLocker));\n    }\n\n    function withdrawAll(address _gauge, address _token)\n        external\n        returns (uint256)\n    {\n        require(strategies[msg.sender], \"!strategy\");\n        return withdraw(_gauge, _token, balanceOf(_gauge));\n    }\n\n    function deposit(address _gauge, address _token) external {\n        uint256 _balance = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransfer(address(crvLocker), _balance);\n\n        _balance = IERC20(_token).balanceOf(address(crvLocker));\n        crvLocker.execute(\n            _token,\n            0,\n            abi.encodeWithSignature(\"approve(address,uint256)\", _gauge, 0)\n        );\n        crvLocker.execute(\n            _token,\n            0,\n            abi.encodeWithSignature(\n                \"approve(address,uint256)\",\n                _gauge,\n                _balance\n            )\n        );\n        crvLocker.execute(\n            _gauge,\n            0,\n            abi.encodeWithSignature(\"deposit(uint256)\", _balance)\n        );\n    }\n\n    function harvest(address _gauge) external {\n        require(strategies[msg.sender], \"!strategy\");\n        uint256 _before = IERC20(crv).balanceOf(address(crvLocker));\n        crvLocker.execute(\n            mintr,\n            0,\n            abi.encodeWithSignature(\"mint(address)\", _gauge)\n        );\n        uint256 _after = IERC20(crv).balanceOf(address(crvLocker));\n        uint256 _balance = _after.sub(_before);\n        crvLocker.execute(\n            crv,\n            0,\n            abi.encodeWithSignature(\n                \"transfer(address,uint256)\",\n                msg.sender,\n                _balance\n            )\n        );\n    }\n\n    function claimRewards() external {\n        require(strategies[msg.sender], \"!strategy\");\n\n        uint256 _before = IERC20(snx).balanceOf(address(crvLocker));\n        crvLocker.execute(scrvGauge, 0, abi.encodeWithSignature(\"claim_rewards()\"));\n        uint256 _after = IERC20(snx).balanceOf(address(crvLocker));\n        uint256 _balance = _after.sub(_before);\n\n        crvLocker.execute(\n            snx,\n            0,\n            abi.encodeWithSignature(\n                \"transfer(address,uint256)\",\n                msg.sender,\n                _balance\n            )\n        );\n    }\n}"
    },
    {
      "filename": "src/strategies/strategy-base.sol",
      "content": "pragma solidity ^0.6.7;\n\nimport \"../lib/erc20.sol\";\nimport \"../lib/safe-math.sol\";\n\nimport \"../interfaces/jar.sol\";\nimport \"../interfaces/staking-rewards.sol\";\nimport \"../interfaces/uniswapv2.sol\";\nimport \"../interfaces/controller.sol\";\n\n// Strategy Contract Basics\n\nabstract contract StrategyBase {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    // Perfomance fee 4.5%\n    uint256 public performanceFee = 450;\n    uint256 public constant performanceMax = 10000;\n\n    // Withdrawal fee 0.5%\n    // - 0.325% to treasury\n    // - 0.175% to dev fund\n    uint256 public treasuryFee = 325;\n    uint256 public constant treasuryMax = 100000;\n\n    uint256 public devFundFee = 175;\n    uint256 public constant devFundMax = 100000;\n\n    // Tokens\n    address public want;\n    address public constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    // User accounts\n    address public governance;\n    address public controller;\n    address public strategist;\n    address public timelock;\n\n    // Dex\n    address public univ2Router2 = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n\n    constructor(\n        address _want,\n        address _governance,\n        address _strategist,\n        address _controller,\n        address _timelock\n    ) public {\n        require(_want != address(0));\n        require(_governance != address(0));\n        require(_strategist != address(0));\n        require(_controller != address(0));\n        require(_timelock != address(0));\n\n        want = _want;\n        governance = _governance;\n        strategist = _strategist;\n        controller = _controller;\n        timelock = _timelock;\n    }\n\n    // **** Modifiers **** //\n\n    modifier onlyBenevolent {\n        require(\n            msg.sender == tx.origin ||\n                msg.sender == governance ||\n                msg.sender == strategist\n        );\n        _;\n    }\n\n    // **** Views **** //\n\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    function balanceOfPool() public virtual view returns (uint256);\n\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    function getName() external virtual pure returns (string memory);\n\n    // **** Setters **** //\n\n    function setDevFundFee(uint256 _devFundFee) external {\n        require(msg.sender == timelock, \"!timelock\");\n        devFundFee = _devFundFee;\n    }\n\n    function setTreasuryFee(uint256 _treasuryFee) external {\n        require(msg.sender == timelock, \"!timelock\");\n        treasuryFee = _treasuryFee;\n    }\n\n    function setPerformanceFee(uint256 _performanceFee) external {\n        require(msg.sender == timelock, \"!timelock\");\n        performanceFee = _performanceFee;\n    }\n\n    function setStrategist(address _strategist) external {\n        require(msg.sender == governance, \"!governance\");\n        strategist = _strategist;\n    }\n\n    function setGovernance(address _governance) external {\n        require(msg.sender == governance, \"!governance\");\n        governance = _governance;\n    }\n\n    function setTimelock(address _timelock) external {\n        require(msg.sender == timelock, \"!timelock\");\n        timelock = _timelock;\n    }\n\n    function setController(address _controller) external {\n        require(msg.sender == timelock, \"!timelock\");\n        controller = _controller;\n    }\n\n    // **** State mutations **** //\n    function deposit() public virtual;\n\n    // Controller only function for creating additional rewards from dust\n    function withdraw(IERC20 _asset) external returns (uint256 balance) {\n        require(msg.sender == controller, \"!controller\");\n        require(want != address(_asset), \"want\");\n        balance = _asset.balanceOf(address(this));\n        _asset.safeTransfer(controller, balance);\n    }\n\n    // Withdraw partial funds, normally used with a jar withdrawal\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == controller, \"!controller\");\n        uint256 _balance = IERC20(want).balanceOf(address(this));\n        if (_balance < _amount) {\n            _amount = _withdrawSome(_amount.sub(_balance));\n            _amount = _amount.add(_balance);\n        }\n\n        uint256 _feeDev = _amount.mul(devFundFee).div(devFundMax);\n        IERC20(want).safeTransfer(IController(controller).devfund(), _feeDev);\n\n        uint256 _feeTreasury = _amount.mul(treasuryFee).div(treasuryMax);\n        IERC20(want).safeTransfer(\n            IController(controller).treasury(),\n            _feeTreasury\n        );\n\n        address _jar = IController(controller).jars(address(want));\n        require(_jar != address(0), \"!jar\"); // additional protection so we don't burn the funds\n\n        IERC20(want).safeTransfer(_jar, _amount.sub(_feeDev).sub(_feeTreasury));\n    }\n\n    // Withdraw all funds, normally used when migrating strategies\n    function withdrawAll() external returns (uint256 balance) {\n        require(msg.sender == controller, \"!controller\");\n        _withdrawAll();\n\n        balance = IERC20(want).balanceOf(address(this));\n\n        address _jar = IController(controller).jars(address(want));\n        require(_jar != address(0), \"!jar\"); // additional protection so we don't burn the funds\n        IERC20(want).safeTransfer(_jar, balance);\n    }\n\n    function _withdrawAll() internal {\n        _withdrawSome(balanceOfPool());\n    }\n\n    function _withdrawSome(uint256 _amount) internal virtual returns (uint256);\n\n    function harvest() public virtual;\n\n    // **** Emergency functions ****\n\n    function execute(address _target, bytes memory _data)\n        public\n        payable\n        returns (bytes memory response)\n    {\n        require(msg.sender == timelock, \"!timelock\");\n        require(_target != address(0), \"!target\");\n\n        // call contract in current context\n        assembly {\n            let succeeded := delegatecall(\n                sub(gas(), 5000),\n                _target,\n                add(_data, 0x20),\n                mload(_data),\n                0,\n                0\n            )\n            let size := returndatasize()\n\n            response := mload(0x40)\n            mstore(\n                0x40,\n                add(response, and(add(add(size, 0x20), 0x1f), not(0x1f)))\n            )\n            mstore(response, size)\n            returndatacopy(add(response, 0x20), 0, size)\n\n            switch iszero(succeeded)\n                case 1 {\n                    // throw if delegatecall failed\n                    revert(add(response, 0x20), size)\n                }\n        }\n    }\n\n    // **** Internal functions ****\n    function _swapUniswap(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        require(_to != address(0));\n\n        // Swap with uniswap\n        IERC20(_from).safeApprove(univ2Router2, 0);\n        IERC20(_from).safeApprove(univ2Router2, _amount);\n\n        address[] memory path;\n\n        if (_from == weth || _to == weth) {\n            path = new address[](2);\n            path[0] = _from;\n            path[1] = _to;\n        } else {\n            path = new address[](3);\n            path[0] = _from;\n            path[1] = weth;\n            path[2] = _to;\n        }\n\n        UniswapRouterV2(univ2Router2).swapExactTokensForTokens(\n            _amount,\n            0,\n            path,\n            address(this),\n            now.add(60)\n        );\n    }\n}"
    }
  ]
}