{
  "Title": "[H-02] `TimeswapConvenience.sol#borrowGivenDebt()` Attacker can increase `state.y` to an extremely large value with a dust amount of `assetOut`",
  "Content": "_Submitted by WatchPug_\n\n<https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/BorrowMath.sol#L19-L53>\n\nThis issue is similar to the two previous issues related to `state.y` manipulation. Unlike the other two issues, this function is not on `TimeswapPair.sol` but on `TimeswapConvenience.sol`, therefore this can not be solved by adding `onlyConvenience` modifier.\n\nActually, we believe that it does not make sense for the caller to specify the interest they want to pay, we recommend removing this function.\n\n#### Impact\n\n*   When `pool.state.y` is extremely large, many core features of the protocol will malfunction, as the arithmetic related to `state.y` can overflow. For example:\n\nLendMath.check(): <https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/LendMath.sol#L28-L28>\n\nBorrowMath.check(): <https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/BorrowMath.sol#L31-L31>\n\n*   An attacker can set `state.y` to a near overflow value, then `lend()` to get a large amount of extra interest (as Bond tokens) with a small amount of asset tokens. This way, the attacker can steal funds from other lenders and liquidity providers.\n\n**[Mathepreneur (Timeswap) confirmed](https://github.com/code-423n4/2022-01-timeswap-findings/issues/169)**\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2022-01-timeswap",
  "Code": [
    {
      "filename": "Timeswap/Timeswap-V1-Convenience/contracts/libraries/BorrowMath.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';\nimport {Math} from '@timeswap-labs/timeswap-v1-core/contracts/libraries/Math.sol';\nimport {SquareRoot} from './SquareRoot.sol';\nimport {FullMath} from '@timeswap-labs/timeswap-v1-core/contracts/libraries/FullMath.sol';\nimport {ConstantProduct} from './ConstantProduct.sol';\nimport {SafeCast} from '@timeswap-labs/timeswap-v1-core/contracts/libraries/SafeCast.sol';\n\nlibrary BorrowMath {\n    using Math for uint256;\n    using SquareRoot for uint256;\n    using FullMath for uint256;\n    using ConstantProduct for IPair;\n    using ConstantProduct for ConstantProduct.CP;\n    using SafeCast for uint256;\n\n    function givenDebt(\n        IPair pair,\n        uint256 maturity,\n        uint112 assetOut,\n        uint112 debtIn\n    ) internal view returns (uint112 yIncrease, uint112 zIncrease) {\n        uint256 feeBase = 0x10000 - pair.fee();\n\n        ConstantProduct.CP memory cp = pair.get(maturity);\n\n        uint256 _yIncrease = debtIn;\n        _yIncrease -= assetOut;\n        _yIncrease <<= 32;\n        _yIncrease /= maturity - block.timestamp;\n        yIncrease = _yIncrease.toUint112();\n\n        uint256 xAdjust = cp.x;\n        xAdjust -= assetOut;\n\n        uint256 yAdjust = cp.y;\n        yAdjust <<= 16;\n        yAdjust += _yIncrease * feeBase;\n\n        uint256 _zIncrease = cp.x;\n        _zIncrease *= cp.y;\n        _zIncrease <<= 16;\n        uint256 subtrahend = xAdjust;\n        subtrahend *= yAdjust;\n        _zIncrease -= subtrahend;\n        uint256 denominator = xAdjust;\n        denominator *= yAdjust;\n        denominator *= feeBase;\n        _zIncrease = _zIncrease.mulDivUp(uint256(cp.z) << 16, denominator);\n        zIncrease = _zIncrease.toUint112();\n    }\n\n    function givenCollateral(\n        IPair pair,\n        uint256 maturity,\n        uint112 assetOut,\n        uint112 collateralIn\n    ) internal view returns (uint112 yIncrease, uint112 zIncrease) {\n        uint256 feeBase = 0x10000 - pair.fee();\n\n        ConstantProduct.CP memory cp = pair.get(maturity);\n\n        uint256 xAdjust = cp.x;\n        xAdjust -= assetOut;\n\n        uint256 _zIncrease = collateralIn;\n        _zIncrease *= xAdjust;\n        uint256 subtrahend = cp.z;\n        subtrahend *= assetOut;\n        _zIncrease -= subtrahend;\n        _zIncrease <<= 25;\n        uint256 denominator = maturity;\n        denominator -= block.timestamp;\n        denominator *= xAdjust;\n        _zIncrease /= denominator;\n        zIncrease = _zIncrease.toUint112();\n\n        uint256 zAdjust = cp.z;\n        zAdjust <<= 16;\n        zAdjust += _zIncrease * feeBase;\n        uint256 _yIncrease = cp.x;\n        _yIncrease *= cp.z;\n        _yIncrease <<= 16;\n        subtrahend = xAdjust;\n        subtrahend *= zAdjust;\n        _yIncrease -= subtrahend;\n        denominator = xAdjust;\n        denominator *= zAdjust;\n        denominator *= feeBase;\n        _yIncrease = _yIncrease.mulDivUp(uint256(cp.y) << 16, denominator);\n        yIncrease = _yIncrease.toUint112();\n    }\n\n    function givenPercent(\n        IPair pair,\n        uint256 maturity,\n        uint112 assetOut,\n        uint40 percent\n    ) internal view returns (uint112 yIncrease, uint112 zIncrease) {\n        uint256 feeBase = 0x10000 - pair.fee();\n\n        ConstantProduct.CP memory cp = pair.get(maturity);\n\n        uint256 xAdjust = cp.x;\n        xAdjust -= assetOut;\n\n        if (percent <= 0x80000000) {\n            uint256 yMid = cp.y;\n            yMid *= cp.y;\n            yMid <<= 32;\n            uint256 denominator = xAdjust;\n            denominator *= feeBase;\n            denominator *= feeBase;\n            yMid = yMid.mulDivUp(cp.x, denominator);\n            yMid = yMid.sqrtUp();\n            uint256 subtrahend = cp.y;\n            subtrahend <<= 16;\n            subtrahend /= feeBase;\n            yMid -= subtrahend;\n\n            uint256 yMin = assetOut;\n            yMin *= cp.y;\n            yMin <<= 12;\n            denominator = xAdjust;\n            denominator *= feeBase;\n            yMin = yMin.divUp(denominator);\n\n            uint256 _yIncrease = yMid;\n            _yIncrease -= yMin;\n            _yIncrease *= percent;\n            _yIncrease = _yIncrease.shiftRightUp(31);\n            _yIncrease += yMin;\n            yIncrease = _yIncrease.toUint112();\n\n            uint256 yAdjust = cp.y;\n            yAdjust <<= 16;\n            yAdjust += _yIncrease * feeBase;\n\n            uint256 _zIncrease = cp.x;\n            _zIncrease *= cp.y;\n            _zIncrease <<= 16;\n            subtrahend = xAdjust;\n            subtrahend *= yAdjust;\n            _zIncrease -= subtrahend;\n            denominator = xAdjust;\n            denominator *= yAdjust;\n            denominator *= feeBase;\n            _zIncrease = _zIncrease.mulDivUp(uint256(cp.z) << 16, denominator);\n            zIncrease = _zIncrease.toUint112();\n        } else {\n            uint256 zMid = cp.z;\n            zMid *= cp.z;\n            zMid <<= 32;\n            uint256 denominator = xAdjust;\n            denominator *= feeBase;\n            denominator *= feeBase;\n            zMid = zMid.mulDivUp(cp.x, denominator);\n            zMid = zMid.sqrtUp();\n            uint256 subtrahend = cp.z;\n            subtrahend <<= 16;\n            subtrahend /= feeBase;\n            zMid -= subtrahend;\n\n            percent = 0x100000000 - percent;\n\n            uint256 _zIncrease = zMid;\n            _zIncrease *= percent;\n            _zIncrease = _zIncrease.shiftRightUp(31);\n            zIncrease = _zIncrease.toUint112();\n\n            uint256 zAdjust = cp.z;\n            zAdjust <<= 16;\n            zAdjust += _zIncrease * feeBase;\n            uint256 _yIncrease = cp.x;\n            _yIncrease *= cp.z;\n            _yIncrease <<= 16;\n            subtrahend = xAdjust;\n            subtrahend *= zAdjust;\n            _yIncrease -= subtrahend;\n            denominator = xAdjust;\n            denominator *= zAdjust;\n            denominator *= feeBase;\n            _yIncrease = _yIncrease.mulDivUp(uint256(cp.y) << 16, denominator);\n            yIncrease = _yIncrease.toUint112();\n        }\n    }\n}"
    },
    {
      "filename": "Timeswap/Timeswap-V1-Core/contracts/libraries/LendMath.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {IPair} from '../interfaces/IPair.sol';\nimport {FullMath} from './FullMath.sol';\nimport {ConstantProduct} from './ConstantProduct.sol';\nimport {SafeCast} from './SafeCast.sol';\n\nlibrary LendMath {\n    using FullMath for uint256;\n    using ConstantProduct for IPair.State;\n    using SafeCast for uint256;\n\n    function check(\n        IPair.State memory state,\n        uint112 xIncrease,\n        uint112 yDecrease,\n        uint112 zDecrease,\n        uint16 fee\n    ) internal pure {\n        uint128 feeBase = 0x10000 + fee;\n        uint112 xReserve = state.x + xIncrease;\n        uint128 yAdjusted = adjust(state.y, yDecrease, feeBase);\n        uint128 zAdjusted = adjust(state.z, zDecrease, feeBase);\n        state.checkConstantProduct(xReserve, yAdjusted, zAdjusted);\n\n        uint256 minimum = xIncrease;\n        minimum *= state.y;\n        minimum <<= 12;\n        uint256 denominator = xReserve;\n        denominator *= feeBase;\n        minimum /= denominator;\n        require(yDecrease >= minimum, 'E302');\n    }\n\n    function adjust(\n        uint112 reserve,\n        uint112 decrease,\n        uint128 feeBase\n    ) private pure returns (uint128 adjusted) {\n        adjusted = reserve;\n        adjusted <<= 16;\n        adjusted -= feeBase * decrease;\n    }\n\n    function getBond(\n        uint256 maturity,\n        uint112 xIncrease,\n        uint112 yDecrease\n    ) internal view returns (uint128 bondOut) {\n        uint256 _bondOut = maturity;\n        _bondOut -= block.timestamp;\n        _bondOut *= yDecrease;\n        _bondOut >>= 32;\n        _bondOut += xIncrease;\n        bondOut = _bondOut.toUint128();\n    }\n\n    function getInsurance(\n        uint256 maturity,\n        IPair.State memory state,\n        uint112 xIncrease,\n        uint112 zDecrease\n    ) internal view returns (uint128 insuranceOut) {\n        uint256 _insuranceOut = maturity;\n        _insuranceOut -= block.timestamp;\n        _insuranceOut *= zDecrease;\n        _insuranceOut >>= 25;\n        uint256 minimum = state.z;\n        minimum *= xIncrease;\n        uint256 denominator = state.x;\n        denominator += xIncrease;\n        minimum /= denominator;\n        _insuranceOut += minimum;\n        insuranceOut = _insuranceOut.toUint128();\n    }\n}"
    },
    {
      "filename": "Timeswap/Timeswap-V1-Core/contracts/libraries/BorrowMath.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {IPair} from '../interfaces/IPair.sol';\nimport {Math} from './Math.sol';\nimport {FullMath} from './FullMath.sol';\nimport {ConstantProduct} from './ConstantProduct.sol';\nimport {SafeCast} from './SafeCast.sol';\n\n\nlibrary BorrowMath {\n    using Math for uint256;\n    using FullMath for uint256;\n    using ConstantProduct for IPair.State;\n    using SafeCast for uint256;\n\n    function check(\n        IPair.State memory state,\n        uint112 xDecrease,\n        uint112 yIncrease,\n        uint112 zIncrease,\n        uint16 fee\n    ) internal pure {\n        uint128 feeBase = 0x10000 - fee;\n        uint112 xReserve = state.x - xDecrease;\n        uint128 yAdjusted = adjust(state.y, yIncrease, feeBase);\n        uint128 zAdjusted = adjust(state.z, zIncrease, feeBase);\n        state.checkConstantProduct(xReserve, yAdjusted, zAdjusted);\n\n        uint256 minimum = xDecrease;\n        minimum *= state.y;\n        minimum <<= 12;\n        uint256 denominator = xReserve;\n        denominator *= feeBase;\n        minimum = minimum.divUp(denominator);\n        require(yIncrease >= minimum, 'E302');\n    }\n\n    function adjust(\n        uint112 reserve,\n        uint112 increase,\n        uint128 feeBase\n    ) private pure returns (uint128 adjusted) {\n        adjusted = reserve;\n        adjusted <<= 16;\n        adjusted += feeBase * increase;\n    }\n\n    function getDebt(\n        uint256 maturity,\n        uint112 xDecrease,\n        uint112 yIncrease\n    ) internal view returns (uint112 debtIn) {\n        uint256 _debtIn = maturity;\n        _debtIn -= block.timestamp;\n        _debtIn *= yIncrease;\n        _debtIn = _debtIn.shiftRightUp(32);\n        _debtIn += xDecrease;\n        debtIn = _debtIn.toUint112();\n    }\n\n    function getCollateral(\n        uint256 maturity,\n        IPair.State memory state,\n        uint112 xDecrease,\n        uint112 zIncrease\n    ) internal view returns (uint112 collateralIn) {\n        uint256 _collateralIn = maturity;\n        _collateralIn -= block.timestamp;\n        _collateralIn *= zIncrease;\n        _collateralIn = _collateralIn.shiftRightUp(25);\n        uint256 minimum = state.z;\n        minimum *= xDecrease;\n        uint256 denominator = state.x;\n        denominator -= xDecrease;\n        minimum = minimum.divUp(denominator);\n        _collateralIn += minimum;\n        collateralIn = _collateralIn.toUint112();\n    }\n}"
    }
  ]
}