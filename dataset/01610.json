{
  "Title": "H-6: Accounting error in PartyB's pending locked balance led to loss of funds",
  "Content": "# Issue H-6: Accounting error in PartyB's pending locked balance led to loss of funds \n\nSource: https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/226 \n\n## Found by \nCh\\_301, Yuki, nican0r, tvdung94, xiaoming90\n## Summary\n\nAccounting error in the PartyB's pending locked balance during the partial filling of a position could lead to a loss of assets for PartyB.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/PartyB/PartyBFacet.sol#L150\n\n```solidity\nFile: PartyBFacetImpl.sol\n112:     function openPosition(\n113:         uint256 quoteId,\n114:         uint256 filledAmount,\n115:         uint256 openedPrice,\n116:         PairUpnlAndPriceSig memory upnlSig\n117:     ) internal returns (uint256 currentId) {\n..SNIP..\n155: \n156:         LibQuote.removeFromPendingQuotes(quote);\n157: \n..SNIP..\n225:             quoteLayout.quoteIdsOf[quote.partyA].push(currentId);\n..SNIP..\n237:             } else {\n238:                 accountLayout.pendingLockedBalances[quote.partyA].sub(filledLockedValues);\n239:                 accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].sub(\n240:                     filledLockedValues\n241:                 );\n242:             }\n```\n\n| Parameter                  | Description                                                  |\n| -------------------------- | ------------------------------------------------------------ |\n| $quote_{current}$          | Current quote (Quote ID = 1)                                 |\n| $quote_{new}$              | Newly created quote (Quote ID = 2) due to partially filling  |\n| $lockedValue_{total}$      | 100 USD. The locked values of $quote_{current}$              |\n| $lockedValue_{filled}$     | 30 USD. $lockedValue_{filled} = lockedValue_{total}\\times\\frac{filledAmount}{quote.quantity}$ |\n| $lockedValue_{unfilled}$   | 70 USD. $lockedValue_{unfilled} = lockedValue_{total}-lockedValue_{filled}$ |\n| $pendingLockedBalance_{a}$ | 100 USD. PartyA's pending locked balance                     |\n| $pendingLockedBalance_{b}$ | 100 USD. PartyB's pending locked balance                     |\n| $pendingQuotes_a$          | PartyA's pending quotes. $pendingQuotes_a = [quote_{current}]$ |\n| $pendingQuotes_b$          | PartyB's pending quotes. $pendingQuotes_b = [quote_{current}]$ |\n\nAssume the following states before the execution of the `openPosition` function:\n\n- $pendingQuotes_a = [quote_{current}]$\n- $pendingQuotes_b = [quote_{current}]$\n- $pendingLockedBalance_{a} = 100\\ USD$\n- $pendingLockedBalance_{b} = 100\\ USD$\n\nWhen the `openPosition` function is executed, $quote_{current}$ will be removed from $pendingQuotes_a$ and $pendingQuotes_b$ in Line 156. \n\nIf the position is partially filled, $quote_{current}$ will be filled, and $quote_{new}$ will be created with the unfilled amount ($lockedValue_{unfilled}$). The $quote_{new}$ is automatically added to PartyA's pending quote list in Line 225.\n\nThe states at this point are as follows:\n\n- $pendingQuotes_a = [quote_{new}]$\n- $pendingQuotes_b = []$\n- $pendingLockedBalance_{a} = 100\\ USD$\n- $pendingLockedBalance_{b} = 100\\ USD$\n\nLine 238 removes the balance already filled ($lockedValue_{filled}$) from $pendingLockedBalance_{a}$ . The unfilled balance ($lockedValue_{unfilled}$) does not need to be removed from $pendingLockedBalance_{a}$ because it is now the balance of $quote_{new}$ that belong to PartyA. The value in $pendingLockedBalance_a$ is correct.\n\nThe states at this point are as follows:\n\n- $pendingQuotes_a = [quote_{new}]$\n- $pendingQuotes_b = []$\n- $pendingLockedBalance_{a} = 70\\ USD$\n- $pendingLockedBalance_{b} = 100\\ USD$\n\nIn Line 239, the code removes the balance already filled ($lockedValue_{filled}$) from $pendingLockedBalance_{b}$ \n\nThe end state is as follows:\n\n- $pendingQuotes_a = [quote_{new}]$\n- $pendingQuotes_b = []$\n- $pendingLockedBalance_{a} = 70\\ USD$\n- $pendingLockedBalance_{b} = 70\\ USD$\n\nAs shown above, the value of $pendingLockedBalance_{b}$ is incorrect. Even though PartyB has no pending quote, 70 USD is still locked in the pending balance.\n\nThere are three (3) important points to note:\n\n1) $quote_{current}$ has already been removed from $pendingQuotes_b$ in Line 156\n2) $quote_{new}$ is not automatically added to $pendingQuotes_b$. When $quote_{new}$ is created, it is not automatically locked to PartyB.\n3) $pendingQuotes_b$ is empty\n\nAs such, $lockedValue_{total}$ should be removed from the $pendingLockedBalance_{b}$ instead of only $lockedvalue_{filled}$.\n\n## Impact\n\nEvery time PartyB partially fill a position, their $pendingLockedBalance_b$ will silently increase and become inflated. The pending locked balance plays a key role in the protocol's accounting system. Thus, an error in the accounting breaks many of the computations and invariants of the protocol.\n\nFor instance, it is used to compute the available balance of an account in `partyBAvailableForQuote` function. Assuming that the allocated balance remains the same. If the pending locked balance increases silently due to the bug, the available balance returned from the `partyBAvailableForQuote` function will decrease. Eventually, it will \"consume\" all the allocated balance, and there will be no available funds left for PartyB to open new positions or to deallocate+withdraw funds. Thus, leading to lost of assets for PartyB.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/PartyB/PartyBFacet.sol#L150\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUpdate the affected function to remove $lockedValue_{total}$ from the $pendingLockedBalance_{b}$ instead of only $lockedvalue_{filled}$.\n\n```diff\naccountLayout.pendingLockedBalances[quote.partyA].sub(filledLockedValues);\naccountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].sub(\n-    filledLockedValues\n+    quote.lockedValues\n);\n```\n\n\n\n## Discussion\n\n**MoonKnightDev**\n\nIn this scenario, only the pending locks of Party B would be incorrect, resulting in an accounting error for Party B. However, no funds would be stolen. so we don't consider it as \"High\"\n\n**ctf-sec**\n\nThis issue does break accounting, recommend maintaining high severity hereï¼š\n\n> For instance, it is used to compute the available balance of an account in partyBAvailableForQuote function. Assuming that the allocated balance remains the same. If the pending locked balance increases silently due to the bug, the available balance returned from the partyBAvailableForQuote function will decrease. Eventually, it will \"consume\" all the allocated balance, and there will be no available funds left for PartyB to open new positions or to deallocate+withdraw funds. Thus, leading to lost of assets for PartyB.\n\n**MoonKnightDev**\n\nFixed code PR link:\nhttps://github.com/SYMM-IO/symmio-core/pull/4\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/85",
  "Code": [
    {
      "filename": "symmio-core/contracts/facets/PartyB/PartyBFacet.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\nimport \"./PartyBFacetImpl.sol\";\nimport \"../../utils/Accessibility.sol\";\nimport \"../../utils/Pausable.sol\";\nimport \"./IPartyBEvents.sol\";\nimport \"../../storages/MuonStorage.sol\";\nimport \"../Account/IAccountEvents.sol\";\nimport \"../Account/AccountFacetImpl.sol\";\n\ncontract PartyBFacet is Accessibility, Pausable, IPartyBEvents, IAccountEvents {\n    using LockedValuesOps for LockedValues;\n\n    function lockQuote(\n        uint256 quoteId,\n        SingleUpnlSig memory upnlSig\n    ) external whenNotPartyBActionsPaused onlyPartyB notLiquidated(quoteId) {\n        PartyBFacetImpl.lockQuote(quoteId, upnlSig, true);\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        emit LockQuote(quote.partyB, quoteId, quote.quoteStatus);\n    }\n\n    function allocateAndLockQuote(\n        uint256 quoteId,\n        uint256 amount,\n        SingleUpnlSig memory upnlSig\n    ) external whenNotPartyBActionsPaused onlyPartyB notLiquidated(quoteId) {\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        AccountFacetImpl.allocateForPartyB(amount, quote.partyA, false);\n        PartyBFacetImpl.lockQuote(quoteId, upnlSig, true);\n        emit AllocateForPartyB(msg.sender, quote.partyA, amount);\n        emit LockQuote(quote.partyB, quoteId, quote.quoteStatus);\n    }\n\n    function lockAndOpenQuote(\n        uint256 quoteId,\n        uint256 filledAmount,\n        uint256 openedPrice,\n        SingleUpnlSig memory upnlSig,\n        PairUpnlAndPriceSig memory pairUpnlSig\n    ) external whenNotPartyBActionsPaused onlyPartyB notLiquidated(quoteId) {\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        PartyBFacetImpl.lockQuote(quoteId, upnlSig, false);\n        emit LockQuote(quote.partyB, quoteId, quote.quoteStatus);\n        uint256 newId = PartyBFacetImpl.openPosition(quoteId, filledAmount, openedPrice, pairUpnlSig);\n        emit OpenPosition(\n            quoteId,\n            quote.partyA,\n            quote.partyB,\n            filledAmount,\n            openedPrice,\n            QuoteStatus.OPENED\n        );\n        if (newId != 0) {\n            Quote storage newQuote = QuoteStorage.layout().quotes[newId];\n            if (newQuote.quoteStatus == QuoteStatus.PENDING) {\n                emit SendQuote(\n                    newQuote.partyA,\n                    newQuote.id,\n                    newQuote.partyBsWhiteList,\n                    newQuote.symbolId,\n                    newQuote.positionType,\n                    newQuote.orderType,\n                    newQuote.requestedOpenPrice,\n                    newQuote.marketPrice,\n                    newQuote.quantity,\n                    newQuote.lockedValues.cva,\n                    newQuote.lockedValues.mm,\n                    newQuote.lockedValues.lf,\n                    newQuote.maxInterestRate,\n                    newQuote.deadline,\n                    newQuote.quoteStatus\n                );\n            } else if (newQuote.quoteStatus == QuoteStatus.CANCELED) {\n                emit AcceptCancelRequest(newQuote.id, QuoteStatus.CANCELED);\n            }\n        }\n    }\n\n    function allocateAndLockAndOpenQuote(\n        uint256 quoteId,\n        uint256 allocateAmount,\n        uint256 filledAmount,\n        uint256 openedPrice,\n        SingleUpnlSig memory upnlSig,\n        PairUpnlAndPriceSig memory pairUpnlSig\n    ) external whenNotPartyBActionsPaused onlyPartyB notLiquidated(quoteId) {\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        AccountFacetImpl.allocateForPartyB(allocateAmount, quote.partyA, false);\n        PartyBFacetImpl.lockQuote(quoteId, upnlSig, false);\n        emit AllocateForPartyB(msg.sender, quote.partyA, allocateAmount);\n        emit LockQuote(quote.partyB, quoteId, quote.quoteStatus);\n        uint256 newId = PartyBFacetImpl.openPosition(quoteId, filledAmount, openedPrice, pairUpnlSig);\n        emit OpenPosition(\n            quoteId,\n            quote.partyA,\n            quote.partyB,\n            filledAmount,\n            openedPrice,\n            QuoteStatus.OPENED\n        );\n        if (newId != 0) {\n            Quote storage newQuote = QuoteStorage.layout().quotes[newId];\n            if (newQuote.quoteStatus == QuoteStatus.PENDING) {\n                emit SendQuote(\n                    newQuote.partyA,\n                    newQuote.id,\n                    newQuote.partyBsWhiteList,\n                    newQuote.symbolId,\n                    newQuote.positionType,\n                    newQuote.orderType,\n                    newQuote.requestedOpenPrice,\n                    newQuote.marketPrice,\n                    newQuote.quantity,\n                    newQuote.lockedValues.cva,\n                    newQuote.lockedValues.mm,\n                    newQuote.lockedValues.lf,\n                    newQuote.maxInterestRate,\n                    newQuote.deadline,\n                    newQuote.quoteStatus\n                );\n            } else if (newQuote.quoteStatus == QuoteStatus.CANCELED) {\n                emit AcceptCancelRequest(newQuote.id, QuoteStatus.CANCELED);\n            }\n        }\n    }\n\n    function unlockQuote(\n        uint256 quoteId\n    ) external whenNotPartyBActionsPaused onlyPartyBOfQuote(quoteId) notLiquidated(quoteId) {\n        QuoteStatus res = PartyBFacetImpl.unlockQuote(quoteId);\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        if (res == QuoteStatus.EXPIRED) {\n            emit ExpireQuote(res, quoteId);\n        } else if (res == QuoteStatus.PENDING) {\n            emit UnlockQuote(quote.partyB, quoteId, QuoteStatus.PENDING);\n        }\n    }\n\n    function acceptCancelRequest(\n        uint256 quoteId\n    ) external whenNotPartyBActionsPaused onlyPartyBOfQuote(quoteId) notLiquidated(quoteId) {\n        PartyBFacetImpl.acceptCancelRequest(quoteId);\n        emit AcceptCancelRequest(quoteId, QuoteStatus.CANCELED);\n    }\n\n    function openPosition(\n        uint256 quoteId,\n        uint256 filledAmount,\n        uint256 openedPrice,\n        PairUpnlAndPriceSig memory upnlSig\n    ) external whenNotPartyBActionsPaused onlyPartyBOfQuote(quoteId) notLiquidated(quoteId) {\n        uint256 newId = PartyBFacetImpl.openPosition(quoteId, filledAmount, openedPrice, upnlSig);\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        emit OpenPosition(\n            quoteId,\n            quote.partyA,\n            quote.partyB,\n            filledAmount,\n            openedPrice,\n            QuoteStatus.OPENED\n        );\n        if (newId != 0) {\n            Quote storage newQuote = QuoteStorage.layout().quotes[newId];\n            if (newQuote.quoteStatus == QuoteStatus.PENDING) {\n                emit SendQuote(\n                    newQuote.partyA,\n                    newQuote.id,\n                    newQuote.partyBsWhiteList,\n                    newQuote.symbolId,\n                    newQuote.positionType,\n                    newQuote.orderType,\n                    newQuote.requestedOpenPrice,\n                    newQuote.marketPrice,\n                    newQuote.quantity,\n                    newQuote.lockedValues.cva,\n                    newQuote.lockedValues.mm,\n                    newQuote.lockedValues.lf,\n                    newQuote.maxInterestRate,\n                    newQuote.deadline,\n                    newQuote.quoteStatus\n                );\n            } else if (newQuote.quoteStatus == QuoteStatus.CANCELED) {\n                emit AcceptCancelRequest(newQuote.id, QuoteStatus.CANCELED);\n            }\n        }\n    }\n\n    function fillCloseRequest(\n        uint256 quoteId,\n        uint256 filledAmount,\n        uint256 closedPrice,\n        PairUpnlAndPriceSig memory upnlSig\n    ) external whenNotPartyBActionsPaused onlyPartyBOfQuote(quoteId) notLiquidated(quoteId) {\n        PartyBFacetImpl.fillCloseRequest(quoteId, filledAmount, closedPrice, upnlSig);\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        emit FillCloseRequest(\n            quoteId,\n            quote.partyA,\n            quote.partyB,\n            filledAmount,\n            closedPrice,\n            quote.quoteStatus\n        );\n    }\n\n    function acceptCancelCloseRequest(\n        uint256 quoteId\n    ) external whenNotPartyBActionsPaused onlyPartyBOfQuote(quoteId) notLiquidated(quoteId) {\n        PartyBFacetImpl.acceptCancelCloseRequest(quoteId);\n        emit AcceptCancelCloseRequest(quoteId, QuoteStatus.OPENED);\n    }\n\n    function emergencyClosePosition(\n        uint256 quoteId,\n        PairUpnlAndPriceSig memory upnlSig\n    )\n        external\n        whenNotPartyBActionsPaused\n        onlyPartyBOfQuote(quoteId)\n        whenEmergencyMode(msg.sender)\n        notLiquidated(quoteId)\n    {\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        uint256 filledAmount = LibQuote.quoteOpenAmount(quote);\n        PartyBFacetImpl.emergencyClosePosition(quoteId, upnlSig);\n        emit EmergencyClosePosition(\n            quoteId,\n            quote.partyA,\n            quote.partyB,\n            filledAmount,\n            upnlSig.price,\n            quote.quoteStatus\n        );\n    }\n}"
    },
    {
      "filename": "symmio-core/contracts/facets/PartyB/PartyBFacet.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\nimport \"./PartyBFacetImpl.sol\";\nimport \"../../utils/Accessibility.sol\";\nimport \"../../utils/Pausable.sol\";\nimport \"./IPartyBEvents.sol\";\nimport \"../../storages/MuonStorage.sol\";\nimport \"../Account/IAccountEvents.sol\";\nimport \"../Account/AccountFacetImpl.sol\";\n\ncontract PartyBFacet is Accessibility, Pausable, IPartyBEvents, IAccountEvents {\n    using LockedValuesOps for LockedValues;\n\n    function lockQuote(\n        uint256 quoteId,\n        SingleUpnlSig memory upnlSig\n    ) external whenNotPartyBActionsPaused onlyPartyB notLiquidated(quoteId) {\n        PartyBFacetImpl.lockQuote(quoteId, upnlSig, true);\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        emit LockQuote(quote.partyB, quoteId, quote.quoteStatus);\n    }\n\n    function allocateAndLockQuote(\n        uint256 quoteId,\n        uint256 amount,\n        SingleUpnlSig memory upnlSig\n    ) external whenNotPartyBActionsPaused onlyPartyB notLiquidated(quoteId) {\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        AccountFacetImpl.allocateForPartyB(amount, quote.partyA, false);\n        PartyBFacetImpl.lockQuote(quoteId, upnlSig, true);\n        emit AllocateForPartyB(msg.sender, quote.partyA, amount);\n        emit LockQuote(quote.partyB, quoteId, quote.quoteStatus);\n    }\n\n    function lockAndOpenQuote(\n        uint256 quoteId,\n        uint256 filledAmount,\n        uint256 openedPrice,\n        SingleUpnlSig memory upnlSig,\n        PairUpnlAndPriceSig memory pairUpnlSig\n    ) external whenNotPartyBActionsPaused onlyPartyB notLiquidated(quoteId) {\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        PartyBFacetImpl.lockQuote(quoteId, upnlSig, false);\n        emit LockQuote(quote.partyB, quoteId, quote.quoteStatus);\n        uint256 newId = PartyBFacetImpl.openPosition(quoteId, filledAmount, openedPrice, pairUpnlSig);\n        emit OpenPosition(\n            quoteId,\n            quote.partyA,\n            quote.partyB,\n            filledAmount,\n            openedPrice,\n            QuoteStatus.OPENED\n        );\n        if (newId != 0) {\n            Quote storage newQuote = QuoteStorage.layout().quotes[newId];\n            if (newQuote.quoteStatus == QuoteStatus.PENDING) {\n                emit SendQuote(\n                    newQuote.partyA,\n                    newQuote.id,\n                    newQuote.partyBsWhiteList,\n                    newQuote.symbolId,\n                    newQuote.positionType,\n                    newQuote.orderType,\n                    newQuote.requestedOpenPrice,\n                    newQuote.marketPrice,\n                    newQuote.quantity,\n                    newQuote.lockedValues.cva,\n                    newQuote.lockedValues.mm,\n                    newQuote.lockedValues.lf,\n                    newQuote.maxInterestRate,\n                    newQuote.deadline,\n                    newQuote.quoteStatus\n                );\n            } else if (newQuote.quoteStatus == QuoteStatus.CANCELED) {\n                emit AcceptCancelRequest(newQuote.id, QuoteStatus.CANCELED);\n            }\n        }\n    }\n\n    function allocateAndLockAndOpenQuote(\n        uint256 quoteId,\n        uint256 allocateAmount,\n        uint256 filledAmount,\n        uint256 openedPrice,\n        SingleUpnlSig memory upnlSig,\n        PairUpnlAndPriceSig memory pairUpnlSig\n    ) external whenNotPartyBActionsPaused onlyPartyB notLiquidated(quoteId) {\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        AccountFacetImpl.allocateForPartyB(allocateAmount, quote.partyA, false);\n        PartyBFacetImpl.lockQuote(quoteId, upnlSig, false);\n        emit AllocateForPartyB(msg.sender, quote.partyA, allocateAmount);\n        emit LockQuote(quote.partyB, quoteId, quote.quoteStatus);\n        uint256 newId = PartyBFacetImpl.openPosition(quoteId, filledAmount, openedPrice, pairUpnlSig);\n        emit OpenPosition(\n            quoteId,\n            quote.partyA,\n            quote.partyB,\n            filledAmount,\n            openedPrice,\n            QuoteStatus.OPENED\n        );\n        if (newId != 0) {\n            Quote storage newQuote = QuoteStorage.layout().quotes[newId];\n            if (newQuote.quoteStatus == QuoteStatus.PENDING) {\n                emit SendQuote(\n                    newQuote.partyA,\n                    newQuote.id,\n                    newQuote.partyBsWhiteList,\n                    newQuote.symbolId,\n                    newQuote.positionType,\n                    newQuote.orderType,\n                    newQuote.requestedOpenPrice,\n                    newQuote.marketPrice,\n                    newQuote.quantity,\n                    newQuote.lockedValues.cva,\n                    newQuote.lockedValues.mm,\n                    newQuote.lockedValues.lf,\n                    newQuote.maxInterestRate,\n                    newQuote.deadline,\n                    newQuote.quoteStatus\n                );\n            } else if (newQuote.quoteStatus == QuoteStatus.CANCELED) {\n                emit AcceptCancelRequest(newQuote.id, QuoteStatus.CANCELED);\n            }\n        }\n    }\n\n    function unlockQuote(\n        uint256 quoteId\n    ) external whenNotPartyBActionsPaused onlyPartyBOfQuote(quoteId) notLiquidated(quoteId) {\n        QuoteStatus res = PartyBFacetImpl.unlockQuote(quoteId);\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        if (res == QuoteStatus.EXPIRED) {\n            emit ExpireQuote(res, quoteId);\n        } else if (res == QuoteStatus.PENDING) {\n            emit UnlockQuote(quote.partyB, quoteId, QuoteStatus.PENDING);\n        }\n    }\n\n    function acceptCancelRequest(\n        uint256 quoteId\n    ) external whenNotPartyBActionsPaused onlyPartyBOfQuote(quoteId) notLiquidated(quoteId) {\n        PartyBFacetImpl.acceptCancelRequest(quoteId);\n        emit AcceptCancelRequest(quoteId, QuoteStatus.CANCELED);\n    }\n\n    function openPosition(\n        uint256 quoteId,\n        uint256 filledAmount,\n        uint256 openedPrice,\n        PairUpnlAndPriceSig memory upnlSig\n    ) external whenNotPartyBActionsPaused onlyPartyBOfQuote(quoteId) notLiquidated(quoteId) {\n        uint256 newId = PartyBFacetImpl.openPosition(quoteId, filledAmount, openedPrice, upnlSig);\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        emit OpenPosition(\n            quoteId,\n            quote.partyA,\n            quote.partyB,\n            filledAmount,\n            openedPrice,\n            QuoteStatus.OPENED\n        );\n        if (newId != 0) {\n            Quote storage newQuote = QuoteStorage.layout().quotes[newId];\n            if (newQuote.quoteStatus == QuoteStatus.PENDING) {\n                emit SendQuote(\n                    newQuote.partyA,\n                    newQuote.id,\n                    newQuote.partyBsWhiteList,\n                    newQuote.symbolId,\n                    newQuote.positionType,\n                    newQuote.orderType,\n                    newQuote.requestedOpenPrice,\n                    newQuote.marketPrice,\n                    newQuote.quantity,\n                    newQuote.lockedValues.cva,\n                    newQuote.lockedValues.mm,\n                    newQuote.lockedValues.lf,\n                    newQuote.maxInterestRate,\n                    newQuote.deadline,\n                    newQuote.quoteStatus\n                );\n            } else if (newQuote.quoteStatus == QuoteStatus.CANCELED) {\n                emit AcceptCancelRequest(newQuote.id, QuoteStatus.CANCELED);\n            }\n        }\n    }\n\n    function fillCloseRequest(\n        uint256 quoteId,\n        uint256 filledAmount,\n        uint256 closedPrice,\n        PairUpnlAndPriceSig memory upnlSig\n    ) external whenNotPartyBActionsPaused onlyPartyBOfQuote(quoteId) notLiquidated(quoteId) {\n        PartyBFacetImpl.fillCloseRequest(quoteId, filledAmount, closedPrice, upnlSig);\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        emit FillCloseRequest(\n            quoteId,\n            quote.partyA,\n            quote.partyB,\n            filledAmount,\n            closedPrice,\n            quote.quoteStatus\n        );\n    }\n\n    function acceptCancelCloseRequest(\n        uint256 quoteId\n    ) external whenNotPartyBActionsPaused onlyPartyBOfQuote(quoteId) notLiquidated(quoteId) {\n        PartyBFacetImpl.acceptCancelCloseRequest(quoteId);\n        emit AcceptCancelCloseRequest(quoteId, QuoteStatus.OPENED);\n    }\n\n    function emergencyClosePosition(\n        uint256 quoteId,\n        PairUpnlAndPriceSig memory upnlSig\n    )\n        external\n        whenNotPartyBActionsPaused\n        onlyPartyBOfQuote(quoteId)\n        whenEmergencyMode(msg.sender)\n        notLiquidated(quoteId)\n    {\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        uint256 filledAmount = LibQuote.quoteOpenAmount(quote);\n        PartyBFacetImpl.emergencyClosePosition(quoteId, upnlSig);\n        emit EmergencyClosePosition(\n            quoteId,\n            quote.partyA,\n            quote.partyB,\n            filledAmount,\n            upnlSig.price,\n            quote.quoteStatus\n        );\n    }\n}"
    }
  ]
}