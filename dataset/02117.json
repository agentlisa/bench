{
  "Title": "M-33: when execute deposit fails, cancel deposit will be called which means that execution fee for keeper will be little for executing the cancellation depending on where the executeDeposit fails",
  "Content": "# Issue M-33: when execute deposit fails, cancel deposit will be called which means that execution fee for keeper will be little for executing the cancellation depending on where the executeDeposit fails \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/89 \n\n## Found by \nkoxuan\n\n## Summary\nWhen execute deposit fails, the deposit will be automatically cancelled. However, since executeDeposit has taken up a portion of the execution fee,  execution fee left for cancellation might be little and keeper will lose out on execution fee.\n\n## Vulnerability Detail\nIn `executeDeposit` when an error is thrown, `_handleDepositError` is called.\n```solidity\n            _handleDepositError(\n                key,\n                startingGas,\n                reasonBytes\n            );\n```\nNotice that in `_handleDepositError` that `cancelDeposit` is called which will pay execution fee to the keeper. However, since the failure can have failed at the late stage of executeDeposit, the execution fee left for the cancellation will be little for the keeper. \n```solidity\n    function _handleDepositError(\n        bytes32 key,\n        uint256 startingGas,\n        bytes memory reasonBytes\n    ) internal {\n        (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n\n\n        bytes4 errorSelector = ErrorUtils.getErrorSelectorFromData(reasonBytes);\n\n\n        if (OracleUtils.isEmptyPriceError(errorSelector)) {\n            ErrorUtils.revertWithCustomError(reasonBytes);\n        }\n\n\n        DepositUtils.cancelDeposit(\n            dataStore,\n            eventEmitter,\n            depositVault,\n            key,\n            msg.sender,\n            startingGas,\n            reason,\n            reasonBytes\n        );\n    }\n}\n```\n\nNote: This also applies to failed `executeWithdrawal`.\n\n## Impact\nKeeper will lose out on execution fee in the event of a failed deposit.\n\n## Code Snippet\n[DepositHandler.sol#L109-L113](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/exchange/DepositHandler.sol#L109-L113)\n[DepositHandler.sol#L181-L205](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/exchange/DepositHandler.sol#L181-L205)\n## Tool used\n\nManual Review\n\n## Recommendation\nRecommend increasing the minimum required execution fee to account for failed deposit and refund the excess to the user when a deposit succeeds. \n\n\n\n## Discussion\n\n**xvi10**\n\nthis is a valid issue, no code changed, the configuration for gas estimation should be updated to account for this\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/exchange/DepositHandler.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../utils/GlobalReentrancyGuard.sol\";\n\nimport \"./ExchangeUtils.sol\";\nimport \"../role/RoleModule.sol\";\nimport \"../event/EventEmitter.sol\";\nimport \"../feature/FeatureUtils.sol\";\n\nimport \"../market/Market.sol\";\nimport \"../market/MarketToken.sol\";\n\nimport \"../deposit/Deposit.sol\";\nimport \"../deposit/DepositVault.sol\";\nimport \"../deposit/DepositUtils.sol\";\nimport \"../deposit/ExecuteDepositUtils.sol\";\nimport \"../oracle/Oracle.sol\";\nimport \"../oracle/OracleModule.sol\";\n\n// @title DepositHandler\n// @dev Contract to handle creation, execution and cancellation of deposits\ncontract DepositHandler is GlobalReentrancyGuard, RoleModule, OracleModule {\n    using Deposit for Deposit.Props;\n\n    EventEmitter public immutable eventEmitter;\n    DepositVault public immutable depositVault;\n    Oracle public immutable oracle;\n\n    constructor(\n        RoleStore _roleStore,\n        DataStore _dataStore,\n        EventEmitter _eventEmitter,\n        DepositVault _depositVault,\n        Oracle _oracle\n    ) RoleModule(_roleStore) GlobalReentrancyGuard(_dataStore) {\n        eventEmitter = _eventEmitter;\n        depositVault = _depositVault;\n        oracle = _oracle;\n    }\n\n    // @dev creates a deposit in the deposit store\n    // @param account the depositing account\n    // @param params DepositUtils.CreateDepositParams\n    function createDeposit(\n        address account,\n        DepositUtils.CreateDepositParams calldata params\n    ) external globalNonReentrant onlyController returns (bytes32) {\n        FeatureUtils.validateFeature(dataStore, Keys.createDepositFeatureDisabledKey(address(this)));\n\n        return DepositUtils.createDeposit(\n            dataStore,\n            eventEmitter,\n            depositVault,\n            account,\n            params\n        );\n    }\n\n    // @dev cancels a deposit\n    // @param key the deposit key\n    function cancelDeposit(bytes32 key) external globalNonReentrant onlyController {\n        uint256 startingGas = gasleft();\n\n        DataStore _dataStore = dataStore;\n        Deposit.Props memory deposit = DepositStoreUtils.get(_dataStore, key);\n\n        FeatureUtils.validateFeature(_dataStore, Keys.cancelDepositFeatureDisabledKey(address(this)));\n\n        ExchangeUtils.validateRequestCancellation(\n            _dataStore,\n            deposit.updatedAtBlock(),\n            \"Deposit\"\n        );\n\n        DepositUtils.cancelDeposit(\n            _dataStore,\n            eventEmitter,\n            depositVault,\n            key,\n            deposit.account(),\n            startingGas,\n            Keys.USER_INITIATED_CANCEL,\n            \"\"\n        );\n    }\n\n    // @dev executes a deposit\n    // @param key the key of the deposit to execute\n    // @param oracleParams OracleUtils.SetPricesParams\n    function executeDeposit(\n        bytes32 key,\n        OracleUtils.SetPricesParams calldata oracleParams\n    ) external\n        globalNonReentrant\n        onlyOrderKeeper\n        withOraclePrices(oracle, dataStore, eventEmitter, oracleParams)\n    {\n        uint256 startingGas = gasleft();\n\n        try this._executeDeposit(\n            key,\n            oracleParams,\n            msg.sender,\n            startingGas\n        ) {\n        } catch (bytes memory reasonBytes) {\n            _handleDepositError(\n                key,\n                startingGas,\n                reasonBytes\n            );\n        }\n    }\n\n    // @dev simulate execution of a deposit to check for any errors\n    // @param key the deposit key\n    // @param params OracleUtils.SimulatePricesParams\n    function simulateExecuteDeposit(\n        bytes32 key,\n        OracleUtils.SimulatePricesParams memory params\n    ) external\n        onlyController\n        withSimulatedOraclePrices(oracle, params)\n        globalNonReentrant\n    {\n\n        uint256 startingGas = gasleft();\n        OracleUtils.SetPricesParams memory oracleParams;\n\n        this._executeDeposit(\n            key,\n            oracleParams,\n            msg.sender,\n            startingGas\n        );\n    }\n\n    // @dev executes a deposit\n    // @param oracleParams OracleUtils.SetPricesParams\n    // @param keeper the keeper executing the deposit\n    // @param startingGas the starting gas\n    function _executeDeposit(\n        bytes32 key,\n        OracleUtils.SetPricesParams memory oracleParams,\n        address keeper,\n        uint256 startingGas\n    ) external onlySelf {\n        FeatureUtils.validateFeature(dataStore, Keys.executeDepositFeatureDisabledKey(address(this)));\n\n        uint256[] memory minOracleBlockNumbers = OracleUtils.getUncompactedOracleBlockNumbers(\n            oracleParams.compactedMinOracleBlockNumbers,\n            oracleParams.tokens.length\n        );\n\n        uint256[] memory maxOracleBlockNumbers = OracleUtils.getUncompactedOracleBlockNumbers(\n            oracleParams.compactedMaxOracleBlockNumbers,\n            oracleParams.tokens.length\n        );\n\n        ExecuteDepositUtils.ExecuteDepositParams memory params = ExecuteDepositUtils.ExecuteDepositParams(\n            dataStore,\n            eventEmitter,\n            depositVault,\n            oracle,\n            key,\n            minOracleBlockNumbers,\n            maxOracleBlockNumbers,\n            keeper,\n            startingGas\n        );\n\n        ExecuteDepositUtils.executeDeposit(params);\n    }\n\n    // @dev handle errors from deposits\n    // @param key the deposit key\n    // @param startingGas the starting gas of the txn\n    // @param reasonBytes the reason bytes of the error\n    function _handleDepositError(\n        bytes32 key,\n        uint256 startingGas,\n        bytes memory reasonBytes\n    ) internal {\n        (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n\n        bytes4 errorSelector = ErrorUtils.getErrorSelectorFromData(reasonBytes);\n\n        if (OracleUtils.isEmptyPriceError(errorSelector)) {\n            ErrorUtils.revertWithCustomError(reasonBytes);\n        }\n\n        DepositUtils.cancelDeposit(\n            dataStore,\n            eventEmitter,\n            depositVault,\n            key,\n            msg.sender,\n            startingGas,\n            reason,\n            reasonBytes\n        );\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/exchange/DepositHandler.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../utils/GlobalReentrancyGuard.sol\";\n\nimport \"./ExchangeUtils.sol\";\nimport \"../role/RoleModule.sol\";\nimport \"../event/EventEmitter.sol\";\nimport \"../feature/FeatureUtils.sol\";\n\nimport \"../market/Market.sol\";\nimport \"../market/MarketToken.sol\";\n\nimport \"../deposit/Deposit.sol\";\nimport \"../deposit/DepositVault.sol\";\nimport \"../deposit/DepositUtils.sol\";\nimport \"../deposit/ExecuteDepositUtils.sol\";\nimport \"../oracle/Oracle.sol\";\nimport \"../oracle/OracleModule.sol\";\n\n// @title DepositHandler\n// @dev Contract to handle creation, execution and cancellation of deposits\ncontract DepositHandler is GlobalReentrancyGuard, RoleModule, OracleModule {\n    using Deposit for Deposit.Props;\n\n    EventEmitter public immutable eventEmitter;\n    DepositVault public immutable depositVault;\n    Oracle public immutable oracle;\n\n    constructor(\n        RoleStore _roleStore,\n        DataStore _dataStore,\n        EventEmitter _eventEmitter,\n        DepositVault _depositVault,\n        Oracle _oracle\n    ) RoleModule(_roleStore) GlobalReentrancyGuard(_dataStore) {\n        eventEmitter = _eventEmitter;\n        depositVault = _depositVault;\n        oracle = _oracle;\n    }\n\n    // @dev creates a deposit in the deposit store\n    // @param account the depositing account\n    // @param params DepositUtils.CreateDepositParams\n    function createDeposit(\n        address account,\n        DepositUtils.CreateDepositParams calldata params\n    ) external globalNonReentrant onlyController returns (bytes32) {\n        FeatureUtils.validateFeature(dataStore, Keys.createDepositFeatureDisabledKey(address(this)));\n\n        return DepositUtils.createDeposit(\n            dataStore,\n            eventEmitter,\n            depositVault,\n            account,\n            params\n        );\n    }\n\n    // @dev cancels a deposit\n    // @param key the deposit key\n    function cancelDeposit(bytes32 key) external globalNonReentrant onlyController {\n        uint256 startingGas = gasleft();\n\n        DataStore _dataStore = dataStore;\n        Deposit.Props memory deposit = DepositStoreUtils.get(_dataStore, key);\n\n        FeatureUtils.validateFeature(_dataStore, Keys.cancelDepositFeatureDisabledKey(address(this)));\n\n        ExchangeUtils.validateRequestCancellation(\n            _dataStore,\n            deposit.updatedAtBlock(),\n            \"Deposit\"\n        );\n\n        DepositUtils.cancelDeposit(\n            _dataStore,\n            eventEmitter,\n            depositVault,\n            key,\n            deposit.account(),\n            startingGas,\n            Keys.USER_INITIATED_CANCEL,\n            \"\"\n        );\n    }\n\n    // @dev executes a deposit\n    // @param key the key of the deposit to execute\n    // @param oracleParams OracleUtils.SetPricesParams\n    function executeDeposit(\n        bytes32 key,\n        OracleUtils.SetPricesParams calldata oracleParams\n    ) external\n        globalNonReentrant\n        onlyOrderKeeper\n        withOraclePrices(oracle, dataStore, eventEmitter, oracleParams)\n    {\n        uint256 startingGas = gasleft();\n\n        try this._executeDeposit(\n            key,\n            oracleParams,\n            msg.sender,\n            startingGas\n        ) {\n        } catch (bytes memory reasonBytes) {\n            _handleDepositError(\n                key,\n                startingGas,\n                reasonBytes\n            );\n        }\n    }\n\n    // @dev simulate execution of a deposit to check for any errors\n    // @param key the deposit key\n    // @param params OracleUtils.SimulatePricesParams\n    function simulateExecuteDeposit(\n        bytes32 key,\n        OracleUtils.SimulatePricesParams memory params\n    ) external\n        onlyController\n        withSimulatedOraclePrices(oracle, params)\n        globalNonReentrant\n    {\n\n        uint256 startingGas = gasleft();\n        OracleUtils.SetPricesParams memory oracleParams;\n\n        this._executeDeposit(\n            key,\n            oracleParams,\n            msg.sender,\n            startingGas\n        );\n    }\n\n    // @dev executes a deposit\n    // @param oracleParams OracleUtils.SetPricesParams\n    // @param keeper the keeper executing the deposit\n    // @param startingGas the starting gas\n    function _executeDeposit(\n        bytes32 key,\n        OracleUtils.SetPricesParams memory oracleParams,\n        address keeper,\n        uint256 startingGas\n    ) external onlySelf {\n        FeatureUtils.validateFeature(dataStore, Keys.executeDepositFeatureDisabledKey(address(this)));\n\n        uint256[] memory minOracleBlockNumbers = OracleUtils.getUncompactedOracleBlockNumbers(\n            oracleParams.compactedMinOracleBlockNumbers,\n            oracleParams.tokens.length\n        );\n\n        uint256[] memory maxOracleBlockNumbers = OracleUtils.getUncompactedOracleBlockNumbers(\n            oracleParams.compactedMaxOracleBlockNumbers,\n            oracleParams.tokens.length\n        );\n\n        ExecuteDepositUtils.ExecuteDepositParams memory params = ExecuteDepositUtils.ExecuteDepositParams(\n            dataStore,\n            eventEmitter,\n            depositVault,\n            oracle,\n            key,\n            minOracleBlockNumbers,\n            maxOracleBlockNumbers,\n            keeper,\n            startingGas\n        );\n\n        ExecuteDepositUtils.executeDeposit(params);\n    }\n\n    // @dev handle errors from deposits\n    // @param key the deposit key\n    // @param startingGas the starting gas of the txn\n    // @param reasonBytes the reason bytes of the error\n    function _handleDepositError(\n        bytes32 key,\n        uint256 startingGas,\n        bytes memory reasonBytes\n    ) internal {\n        (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n\n        bytes4 errorSelector = ErrorUtils.getErrorSelectorFromData(reasonBytes);\n\n        if (OracleUtils.isEmptyPriceError(errorSelector)) {\n            ErrorUtils.revertWithCustomError(reasonBytes);\n        }\n\n        DepositUtils.cancelDeposit(\n            dataStore,\n            eventEmitter,\n            depositVault,\n            key,\n            msg.sender,\n            startingGas,\n            reason,\n            reasonBytes\n        );\n    }\n}"
    }
  ]
}