{
  "Title": "[H-02] Validity and contests bond ca be incorrectly burned for the correct and ultimately verified transition",
  "Content": "\n<https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/libs/LibProving.sol#L387-L392> \n\n<https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/libs/LibProving.sol#L189-L199> \n\n<https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/libs/LibVerifying.sol#L178-L189>\n\nBoth validity and contests bonds can be wrongfully slashed even if the transition ends up being the correct and verified one.\n\nThe issue comes from the fact that the history of the final verified transition is not taken into account.\n\nExample 1: Validity bond is wrongfully burned:\n\n1.  Bob Proves transition T1 for parent P1\n2.  Alice contests and proves T2 for parent P1 with higher tier proof.\n3.  Guardians steps in to correctly prove T1 for parent P2.\n\nAt step 2 Bob loses his bond and is permanentley written out of the history of P1 <br><https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/libs/LibProving.sol#L387-L392>\n\n```solidity\n    _ts.validityBond = _tier.validityBond; \n    _ts.contestBond = 1; \n    _ts.contester = address(0);\n    _ts.prover = msg.sender;\n    _ts.tier = _proof.tier; \n```\n\nExample 2: Contest bond wrongfully slashed:\n\n1.  Alice proves T1 for parent P1 with SGX\n2.  Bob contests T1 for parent P1\n3.  Alice proves T1 with SGX_ZK parent P1\n4.  Guardian steps in to correctly disprove T1 with T2 for parent P1\n\nBob was correct and T1 was ultimately proven false. Bob still loses his contest bond.\n\nWhen the guardian overrides the proof they can not pay back Bob's validity or contesting bond. They are only able to pay back a liveness bond <br><https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/libs/LibProving.sol#L189-L199>\n\n```solidity\nif (isTopTier) { \n\t// A special return value from the top tier prover can signal this\n\t// contract to return all liveness bond.\n\tbool returnLivenessBond = blk.livenessBond > 0 && _proof.data.length == 32\n\t\t&& bytes32(_proof.data) == RETURN_LIVENESS_BOND;\n\n\tif (returnLivenessBond) {\n\t\ttko.transfer(blk.assignedProver, blk.livenessBond);\n\t\tblk.livenessBond = 0;\n\t} \n}\n```\n\nThese funds are now frozen since they are sent to the Guardian contract which has no ability to recover them.\n\n<https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/libs/LibVerifying.sol#L178-L189>\n\n```solidity\n                uint256 bondToReturn = uint256(ts.validityBond) + blk.livenessBond;\n\n                if (ts.prover != blk.assignedProver) {\n                    bondToReturn -= blk.livenessBond >> 1;\n                }\n\n                IERC20 tko = IERC20(_resolver.resolve(\"taiko_token\", false));\n                tko.transfer(ts.prover, bondToReturn)\n```\n\n`ts.prover` will be the Guardian since they are the last to prove the block\n\n### Proof of Concept\n\nPOC for example 1. Paste the below code into the `TaikoL1LibProvingWithTiers.t` file and run `forge test --match-test testProverLoss -vv`\n\n<details>\n\n```solidity\n\n    function testProverLoss() external{\n        giveEthAndTko(Alice, 1e7 ether, 1000 ether);\n        giveEthAndTko(Carol, 1e7 ether, 1000 ether);\n        giveEthAndTko(Bob, 1e6 ether, 100 ether);\n        console2.log(\"Bob balance:\", tko.balanceOf(Bob));\n        uint256 bobBalanceBefore = tko.balanceOf(Bob);\n        vm.prank(Bob, Bob);\n\n        bytes32 parentHash = GENESIS_BLOCK_HASH;\n        uint256 blockId = 1;\n        \n        (TaikoData.BlockMetadata memory meta,) = proposeBlock(Alice, Bob, 1_000_000, 1024);\n\n        console2.log(\"Bob balance After propose:\", tko.balanceOf(Bob));\n        mine(1);\n\n        bytes32 blockHash = bytes32(1e10 + blockId);\n        bytes32 stateRoot = bytes32(1e9 + blockId);\n\n        (, TaikoData.SlotB memory b) = L1.getStateVariables();\n        uint64 lastVerifiedBlockBefore = b.lastVerifiedBlockId;\n\n        // Bob proves transition T1 for parent P1\n        proveBlock(Bob, Bob, meta, parentHash, blockHash, stateRoot, meta.minTier, \"\");\n        console2.log(\"Bob balance After proof:\", tko.balanceOf(Bob));\n\n        uint16 minTier = meta.minTier;\n\n        // Higher Tier contests by proving transition T2 for same parent P1\n        proveHigherTierProof(meta, parentHash, bytes32(uint256(1)), bytes32(uint256(1)), minTier);\n\n        // Guardian steps in to prove T1 is correct transition for parent P1\n        proveBlock(\n            David, David, meta, parentHash, blockHash, stateRoot, LibTiers.TIER_GUARDIAN, \"\"\n        );\n\n        vm.roll(block.number + 15 * 12);\n\n        vm.warp(\n            block.timestamp + tierProvider().getTier(LibTiers.TIER_GUARDIAN).cooldownWindow * 60\n                + 1\n        );\n\n        vm.roll(block.number + 15 * 12);\n        vm.warp(\n            block.timestamp + tierProvider().getTier(LibTiers.TIER_GUARDIAN).cooldownWindow * 60\n                + 1\n        );\n\n        // When the correct transition T1 is verified Bob does permantley loses his validitybond\n        // even though it is the correct transition for the verified parent P1.\n        verifyBlock(Carol, 1);\n        parentHash = blockHash;\n\n        (, b) = L1.getStateVariables();\n        uint64 lastVerifiedBlockAfter = b.lastVerifiedBlockId;\n        assertEq(lastVerifiedBlockAfter, lastVerifiedBlockBefore + 1 ); // Verification completed\n\n        uint256 bobBalanceAfter = tko.balanceOf(Bob);\n        assertLt(bobBalanceAfter, bobBalanceBefore);\n\n        console2.log(\"Bob Loss:\", bobBalanceBefore - bobBalanceAfter);\n        console2.log(\"Bob Loss without couting livenessbond:\", bobBalanceBefore - bobBalanceAfter - 1e18); // Liveness bond is 1 ETH in tests\n    }\n\n```\n</details>\n\n### Tools Used\n\nFoundry, VScode\n\n### Recommended Mitigation Steps\n\nThe simplest solution is to allow the guardian to pay back validity and contest bonds in the same manner as for liveness bonds. This keeps the simple design while allowing bonds to be recovered if a prover or contesters action is ultimately proven correct.\n\nGuardian will pass in data in `_proof.data` that specifies the address, tiers and bond type that should be refunded. Given that Guardians already can verify any proof this does not increase centralization.\n\nWe also need to not to not recover any reward when we prove with Guardian and `_overrideWithHigherProof()` is called. If the `ts.validityBond` reward is sent to the Guardian it will be locked. Instead we need to keep it in TaikoL1 such that it can be recovered as described above\n\n```diff\n+if (_tier.contestBond != 0){\n\tunchecked {\n\t\tif (reward > _tier.validityBond) {\n\t\t\t_tko.transfer(msg.sender, reward - _tier.validityBond);\n\t\t} else {\n\t\t\t_tko.transferFrom(msg.sender, address(this), _tier.validityBond - reward);\n\t\t}\n\t}\n+}\n```\n\n**[dantaik (Taiko) commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/266#issuecomment-2033385962):**\n > This is a valid report but we knew this \"flaw\" and the current behavior is by design.\n> \n> - The odd that a valid transition is proven, then contested and overwritten by another proof, then proven again with even a higher tier should be rare, if this happens even once, we should know the second prover is buggy and shall change the tier configuration to remove it.\n> - For provers who suffer a loss due to such prover bugs, Taiko foundation may send them compensation to cover there loss. We do not want to handle cover-your-loss payment in the protocol.\n\n**[adaki2004 (Taiko) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/266#issuecomment-2033985576):**\n> This is an attack on the tier system, right ? But the economical disincentives doing so shall be granted by the bonds - not to challenge proofs which we do know are correct, just to make someone lose money as there is no advantage. The challenger would lose even more money - and the correct prover would be refunded by Taiko Foundation.\n>\n > Severity: medium, (just as: https://github.com/code-423n4/2024-03-taiko-findings/issues/227)\n\n\n**[0xean (Judge) commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/266#issuecomment-2045155377):**\n > I am going to leave as H, I think there is a direct loss of funds here.  \n> \n> This comment:\n> \n> > The challenger would lose even more money \n> \n> Makes me second guess that slightly, but still think H is correct.\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2024-03-taiko",
  "Code": [
    {
      "filename": "packages/protocol/contracts/L1/libs/LibProving.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../common/IAddressResolver.sol\";\nimport \"../../libs/LibMath.sol\";\nimport \"../../verifiers/IVerifier.sol\";\nimport \"../tiers/ITierProvider.sol\";\nimport \"../TaikoData.sol\";\nimport \"./LibUtils.sol\";\n\n/// @title LibProving\n/// @notice A library for handling block contestation and proving in the Taiko\n/// protocol.\n/// @custom:security-contact security@taiko.xyz\nlibrary LibProving {\n    using LibMath for uint256;\n\n    /// @notice Keccak hash of the string \"RETURN_LIVENESS_BOND\".\n    bytes32 public constant RETURN_LIVENESS_BOND = keccak256(\"RETURN_LIVENESS_BOND\");\n\n    /// @notice The tier name for optimistic proofs.\n    bytes32 public constant TIER_OP = bytes32(\"tier_optimistic\");\n\n    // Warning: Any events defined here must also be defined in TaikoEvents.sol.\n    /// @notice Emitted when a transition is proved.\n    /// @param blockId The block ID.\n    /// @param tran The transition data.\n    /// @param prover The prover's address.\n    /// @param validityBond The validity bond amount.\n    /// @param tier The tier of the proof.\n    event TransitionProved(\n        uint256 indexed blockId,\n        TaikoData.Transition tran,\n        address prover,\n        uint96 validityBond,\n        uint16 tier\n    );\n\n    /// @notice Emitted when a transition is contested.\n    /// @param blockId The block ID.\n    /// @param tran The transition data.\n    /// @param contester The contester's address.\n    /// @param contestBond The contest bond amount.\n    /// @param tier The tier of the proof.\n    event TransitionContested(\n        uint256 indexed blockId,\n        TaikoData.Transition tran,\n        address contester,\n        uint96 contestBond,\n        uint16 tier\n    );\n\n    /// @notice Emitted when proving is paused or unpaused.\n    /// @param paused The pause status.\n    event ProvingPaused(bool paused);\n\n    // Warning: Any errors defined here must also be defined in TaikoErrors.sol.\n    error L1_ALREADY_CONTESTED();\n    error L1_ALREADY_PROVED();\n    error L1_ASSIGNED_PROVER_NOT_ALLOWED();\n    error L1_BLOCK_MISMATCH();\n    error L1_INVALID_BLOCK_ID();\n    error L1_INVALID_PAUSE_STATUS();\n    error L1_INVALID_TIER();\n    error L1_INVALID_TRANSITION();\n    error L1_MISSING_VERIFIER();\n    error L1_NOT_ASSIGNED_PROVER();\n\n    /// @notice Pauses or unpauses the proving process.\n    /// @param _state Current TaikoData.State.\n    /// @param _pause The pause status.\n    function pauseProving(TaikoData.State storage _state, bool _pause) external {\n        if (_state.slotB.provingPaused == _pause) revert L1_INVALID_PAUSE_STATUS();\n        _state.slotB.provingPaused = _pause;\n\n        if (!_pause) {\n            _state.slotB.lastUnpausedAt = uint64(block.timestamp);\n        }\n        emit ProvingPaused(_pause);\n    }\n\n    /// @dev Proves or contests a block transition.\n    /// @param _state Current TaikoData.State.\n    /// @param _config Actual TaikoData.Config.\n    /// @param _resolver Address resolver interface.\n    /// @param _meta The block's metadata.\n    /// @param _tran The transition data.\n    /// @param _proof The proof.\n    /// @param maxBlocksToVerify_ The number of blocks to be verified with this transaction.\n    function proveBlock(\n        TaikoData.State storage _state,\n        TaikoData.Config memory _config,\n        IAddressResolver _resolver,\n        TaikoData.BlockMetadata memory _meta,\n        TaikoData.Transition memory _tran,\n        TaikoData.TierProof memory _proof\n    )\n        internal\n        returns (uint8 maxBlocksToVerify_)\n    {\n        // Make sure parentHash is not zero\n        // To contest an existing transition, simply use any non-zero value as\n        // the blockHash and stateRoot.\n        if (_tran.parentHash == 0 || _tran.blockHash == 0 || _tran.stateRoot == 0) {\n            revert L1_INVALID_TRANSITION();\n        }\n\n        // Check that the block has been proposed but has not yet been verified.\n        TaikoData.SlotB memory b = _state.slotB;\n        if (_meta.id <= b.lastVerifiedBlockId || _meta.id >= b.numBlocks) {\n            revert L1_INVALID_BLOCK_ID();\n        }\n\n        uint64 slot = _meta.id % _config.blockRingBufferSize;\n        TaikoData.Block storage blk = _state.blocks[slot];\n\n        // Check the integrity of the block data. It's worth noting that in\n        // theory, this check may be skipped, but it's included for added\n        // caution.\n        if (blk.blockId != _meta.id || blk.metaHash != keccak256(abi.encode(_meta))) {\n            revert L1_BLOCK_MISMATCH();\n        }\n\n        // Each transition is uniquely identified by the parentHash, with the\n        // blockHash and stateRoot open for later updates as higher-tier proofs\n        // become available. In cases where a transition with the specified\n        // parentHash does not exist, the transition ID (tid) will be set to 0.\n        (uint32 tid, TaikoData.TransitionState storage ts) =\n            _createTransition(_state, blk, _tran, slot);\n\n        // The new proof must meet or exceed the minimum tier required by the\n        // block or the previous proof; it cannot be on a lower tier.\n        if (_proof.tier == 0 || _proof.tier < _meta.minTier || _proof.tier < ts.tier) {\n            revert L1_INVALID_TIER();\n        }\n\n        // Retrieve the tier configurations. If the tier is not supported, the\n        // subsequent action will result in a revert.\n        ITierProvider.Tier memory tier =\n            ITierProvider(_resolver.resolve(\"tier_provider\", false)).getTier(_proof.tier);\n\n        // Check if this prover is allowed to submit a proof for this block\n        _checkProverPermission(_state, blk, ts, tid, tier);\n\n        // We must verify the proof, and any failure in proof verification will\n        // result in a revert.\n        //\n        // It's crucial to emphasize that the proof can be assessed in two\n        // potential modes: \"proving mode\" and \"contesting mode.\" However, the\n        // precise verification logic is defined within each tier's IVerifier\n        // contract implementation. We simply specify to the verifier contract\n        // which mode it should utilize - if the new tier is higher than the\n        // previous tier, we employ the proving mode; otherwise, we employ the\n        // contesting mode (the new tier cannot be lower than the previous tier,\n        // this has been checked above).\n        //\n        // It's obvious that proof verification is entirely decoupled from\n        // Taiko's core protocol.\n        {\n            address verifier = _resolver.resolve(tier.verifierName, true);\n\n            if (verifier != address(0)) {\n                bool isContesting = _proof.tier == ts.tier && tier.contestBond != 0;\n\n                IVerifier.Context memory ctx = IVerifier.Context({\n                    metaHash: blk.metaHash,\n                    blobHash: _meta.blobHash,\n                    // Separate msgSender to allow the prover to be any address in the future.\n                    prover: msg.sender,\n                    msgSender: msg.sender,\n                    blockId: blk.blockId,\n                    isContesting: isContesting,\n                    blobUsed: _meta.blobUsed\n                });\n\n                IVerifier(verifier).verifyProof(ctx, _tran, _proof);\n            } else if (tier.verifierName != TIER_OP) {\n                // The verifier can be address-zero, signifying that there are no\n                // proof checks for the tier. In practice, this only applies to\n                // optimistic proofs.\n                revert L1_MISSING_VERIFIER();\n            }\n        }\n\n        bool isTopTier = tier.contestBond == 0;\n        IERC20 tko = IERC20(_resolver.resolve(\"taiko_token\", false));\n\n        if (isTopTier) {\n            // A special return value from the top tier prover can signal this\n            // contract to return all liveness bond.\n            bool returnLivenessBond = blk.livenessBond > 0 && _proof.data.length == 32\n                && bytes32(_proof.data) == RETURN_LIVENESS_BOND;\n\n            if (returnLivenessBond) {\n                tko.transfer(blk.assignedProver, blk.livenessBond);\n                blk.livenessBond = 0;\n            }\n        }\n\n        bool sameTransition = _tran.blockHash == ts.blockHash && _tran.stateRoot == ts.stateRoot;\n\n        if (_proof.tier > ts.tier) {\n            // Handles the case when an incoming tier is higher than the current transition's tier.\n            // Reverts when the incoming proof tries to prove the same transition\n            // (L1_ALREADY_PROVED).\n            _overrideWithHigherProof(ts, _tran, _proof, tier, tko, sameTransition);\n\n            emit TransitionProved({\n                blockId: blk.blockId,\n                tran: _tran,\n                prover: msg.sender,\n                validityBond: tier.validityBond,\n                tier: _proof.tier\n            });\n        } else {\n            // New transition and old transition on the same tier - and if this transaction tries to\n            // prove the same, it reverts\n            if (sameTransition) revert L1_ALREADY_PROVED();\n\n            if (isTopTier) {\n                // The top tier prover re-proves.\n                assert(tier.validityBond == 0);\n                assert(ts.validityBond == 0 && ts.contestBond == 0 && ts.contester == address(0));\n\n                ts.prover = msg.sender;\n                ts.blockHash = _tran.blockHash;\n                ts.stateRoot = _tran.stateRoot;\n\n                emit TransitionProved({\n                    blockId: blk.blockId,\n                    tran: _tran,\n                    prover: msg.sender,\n                    validityBond: 0,\n                    tier: _proof.tier\n                });\n            } else {\n                // Contesting but not on the highest tier\n                if (ts.contester != address(0)) revert L1_ALREADY_CONTESTED();\n\n                // Burn the contest bond from the prover.\n                tko.transferFrom(msg.sender, address(this), tier.contestBond);\n\n                // We retain the contest bond within the transition, just in\n                // case this configuration is altered to a different value\n                // before the contest is resolved.\n                //\n                // It's worth noting that the previous value of ts.contestBond\n                // doesn't have any significance.\n                ts.contestBond = tier.contestBond;\n                ts.contester = msg.sender;\n                ts.contestations += 1;\n\n                emit TransitionContested({\n                    blockId: blk.blockId,\n                    tran: _tran,\n                    contester: msg.sender,\n                    contestBond: tier.contestBond,\n                    tier: _proof.tier\n                });\n            }\n        }\n\n        ts.timestamp = uint64(block.timestamp);\n        return tier.maxBlocksToVerifyPerProof;\n    }\n\n    /// @dev Handle the transition initialization logic\n    function _createTransition(\n        TaikoData.State storage _state,\n        TaikoData.Block storage _blk,\n        TaikoData.Transition memory _tran,\n        uint64 slot\n    )\n        private\n        returns (uint32 tid_, TaikoData.TransitionState storage ts_)\n    {\n        tid_ = LibUtils.getTransitionId(_state, _blk, slot, _tran.parentHash);\n\n        if (tid_ == 0) {\n            // In cases where a transition with the provided parentHash is not\n            // found, we must essentially \"create\" one and set it to its initial\n            // state. This initial state can be viewed as a special transition\n            // on tier-0.\n            //\n            // Subsequently, we transform this tier-0 transition into a\n            // non-zero-tier transition with a proof. This approach ensures that\n            // the same logic is applicable for both 0-to-non-zero transition\n            // updates and non-zero-to-non-zero transition updates.\n            unchecked {\n                // Unchecked is safe:  Not realistic 2**32 different fork choice\n                // per block will be proven and none of them is valid\n                tid_ = _blk.nextTransitionId++;\n            }\n\n            // Keep in mind that state.transitions are also reusable storage\n            // slots, so it's necessary to reinitialize all transition fields\n            // below.\n            ts_ = _state.transitions[slot][tid_];\n            ts_.blockHash = 0;\n            ts_.stateRoot = 0;\n            ts_.validityBond = 0;\n            ts_.contester = address(0);\n            ts_.contestBond = 1; // to save gas\n            ts_.timestamp = _blk.proposedAt;\n            ts_.tier = 0;\n            ts_.contestations = 0;\n\n            if (tid_ == 1) {\n                // This approach serves as a cost-saving technique for the\n                // majority of blocks, where the first transition is expected to\n                // be the correct one. Writing to `tran` is more economical\n                // since it resides in the ring buffer, whereas writing to\n                // `transitionIds` is not as cost-effective.\n                ts_.key = _tran.parentHash;\n\n                // In the case of this first transition, the block's assigned\n                // prover has the privilege to re-prove it, but only when the\n                // assigned prover matches the previous prover. To ensure this,\n                // we establish the transition's prover as the block's assigned\n                // prover. Consequently, when we carry out a 0-to-non-zero\n                // transition update, the previous prover will consistently be\n                // the block's assigned prover.\n                //\n                // While alternative implementations are possible, introducing\n                // such changes would require additional if-else logic.\n                ts_.prover = _blk.assignedProver;\n            } else {\n                // In scenarios where this transition is not the first one, we\n                // straightforwardly reset the transition prover to address\n                // zero.\n                ts_.prover = address(0);\n\n                // Furthermore, we index the transition for future retrieval.\n                // It's worth emphasizing that this mapping for indexing is not\n                // reusable. However, given that the majority of blocks will\n                // only possess one transition — the correct one — we don't need\n                // to be concerned about the cost in this case.\n                _state.transitionIds[_blk.blockId][_tran.parentHash] = tid_;\n\n                // There is no need to initialize ts.key here because it's only used when tid == 1\n            }\n        } else {\n            // A transition with the provided parentHash has been located.\n            ts_ = _state.transitions[slot][tid_];\n        }\n    }\n\n    /// @dev Handles what happens when there is a higher proof incoming\n    function _overrideWithHigherProof(\n        TaikoData.TransitionState storage _ts,\n        TaikoData.Transition memory _tran,\n        TaikoData.TierProof memory _proof,\n        ITierProvider.Tier memory _tier,\n        IERC20 _tko,\n        bool _sameTransition\n    )\n        private\n    {\n        // Higher tier proof overwriting lower tier proof\n        uint256 reward;\n\n        if (_ts.contester != address(0)) {\n            if (_sameTransition) {\n                // The contested transition is proven to be valid, contestor loses the game\n                reward = _ts.contestBond >> 2;\n                _tko.transfer(_ts.prover, _ts.validityBond + reward);\n            } else {\n                // The contested transition is proven to be invalid, contestor wins the game\n                reward = _ts.validityBond >> 2;\n                _tko.transfer(_ts.contester, _ts.contestBond + reward);\n            }\n        } else {\n            if (_sameTransition) revert L1_ALREADY_PROVED();\n            // Contest the existing transition and prove it to be invalid\n            reward = _ts.validityBond >> 1;\n            _ts.contestations += 1;\n        }\n\n        unchecked {\n            if (reward > _tier.validityBond) {\n                _tko.transfer(msg.sender, reward - _tier.validityBond);\n            } else {\n                _tko.transferFrom(msg.sender, address(this), _tier.validityBond - reward);\n            }\n        }\n\n        _ts.validityBond = _tier.validityBond;\n        _ts.contestBond = 1; // to save gas\n        _ts.contester = address(0);\n        _ts.prover = msg.sender;\n        _ts.tier = _proof.tier;\n\n        if (!_sameTransition) {\n            _ts.blockHash = _tran.blockHash;\n            _ts.stateRoot = _tran.stateRoot;\n        }\n    }\n\n    /// @dev Check the msg.sender (the new prover) against the block's assigned prover.\n    function _checkProverPermission(\n        TaikoData.State storage _state,\n        TaikoData.Block storage _blk,\n        TaikoData.TransitionState storage _ts,\n        uint32 _tid,\n        ITierProvider.Tier memory _tier\n    )\n        private\n        view\n    {\n        // The highest tier proof can always submit new proofs\n        if (_tier.contestBond == 0) return;\n\n        bool inProvingWindow = uint256(_ts.timestamp).max(_state.slotB.lastUnpausedAt)\n            + _tier.provingWindow * 60 >= block.timestamp;\n        bool isAssignedPover = msg.sender == _blk.assignedProver;\n\n        // The assigned prover can only submit the very first transition.\n        if (_tid == 1 && _ts.tier == 0 && inProvingWindow) {\n            if (!isAssignedPover) revert L1_NOT_ASSIGNED_PROVER();\n        } else {\n            // Disallow the same address to prove the block so that we can detect that the\n            // assigned prover should not receive his liveness bond back\n            if (isAssignedPover) revert L1_ASSIGNED_PROVER_NOT_ALLOWED();\n        }\n    }\n}"
    },
    {
      "filename": "packages/protocol/contracts/L1/libs/LibProving.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../common/IAddressResolver.sol\";\nimport \"../../libs/LibMath.sol\";\nimport \"../../verifiers/IVerifier.sol\";\nimport \"../tiers/ITierProvider.sol\";\nimport \"../TaikoData.sol\";\nimport \"./LibUtils.sol\";\n\n/// @title LibProving\n/// @notice A library for handling block contestation and proving in the Taiko\n/// protocol.\n/// @custom:security-contact security@taiko.xyz\nlibrary LibProving {\n    using LibMath for uint256;\n\n    /// @notice Keccak hash of the string \"RETURN_LIVENESS_BOND\".\n    bytes32 public constant RETURN_LIVENESS_BOND = keccak256(\"RETURN_LIVENESS_BOND\");\n\n    /// @notice The tier name for optimistic proofs.\n    bytes32 public constant TIER_OP = bytes32(\"tier_optimistic\");\n\n    // Warning: Any events defined here must also be defined in TaikoEvents.sol.\n    /// @notice Emitted when a transition is proved.\n    /// @param blockId The block ID.\n    /// @param tran The transition data.\n    /// @param prover The prover's address.\n    /// @param validityBond The validity bond amount.\n    /// @param tier The tier of the proof.\n    event TransitionProved(\n        uint256 indexed blockId,\n        TaikoData.Transition tran,\n        address prover,\n        uint96 validityBond,\n        uint16 tier\n    );\n\n    /// @notice Emitted when a transition is contested.\n    /// @param blockId The block ID.\n    /// @param tran The transition data.\n    /// @param contester The contester's address.\n    /// @param contestBond The contest bond amount.\n    /// @param tier The tier of the proof.\n    event TransitionContested(\n        uint256 indexed blockId,\n        TaikoData.Transition tran,\n        address contester,\n        uint96 contestBond,\n        uint16 tier\n    );\n\n    /// @notice Emitted when proving is paused or unpaused.\n    /// @param paused The pause status.\n    event ProvingPaused(bool paused);\n\n    // Warning: Any errors defined here must also be defined in TaikoErrors.sol.\n    error L1_ALREADY_CONTESTED();\n    error L1_ALREADY_PROVED();\n    error L1_ASSIGNED_PROVER_NOT_ALLOWED();\n    error L1_BLOCK_MISMATCH();\n    error L1_INVALID_BLOCK_ID();\n    error L1_INVALID_PAUSE_STATUS();\n    error L1_INVALID_TIER();\n    error L1_INVALID_TRANSITION();\n    error L1_MISSING_VERIFIER();\n    error L1_NOT_ASSIGNED_PROVER();\n\n    /// @notice Pauses or unpauses the proving process.\n    /// @param _state Current TaikoData.State.\n    /// @param _pause The pause status.\n    function pauseProving(TaikoData.State storage _state, bool _pause) external {\n        if (_state.slotB.provingPaused == _pause) revert L1_INVALID_PAUSE_STATUS();\n        _state.slotB.provingPaused = _pause;\n\n        if (!_pause) {\n            _state.slotB.lastUnpausedAt = uint64(block.timestamp);\n        }\n        emit ProvingPaused(_pause);\n    }\n\n    /// @dev Proves or contests a block transition.\n    /// @param _state Current TaikoData.State.\n    /// @param _config Actual TaikoData.Config.\n    /// @param _resolver Address resolver interface.\n    /// @param _meta The block's metadata.\n    /// @param _tran The transition data.\n    /// @param _proof The proof.\n    /// @param maxBlocksToVerify_ The number of blocks to be verified with this transaction.\n    function proveBlock(\n        TaikoData.State storage _state,\n        TaikoData.Config memory _config,\n        IAddressResolver _resolver,\n        TaikoData.BlockMetadata memory _meta,\n        TaikoData.Transition memory _tran,\n        TaikoData.TierProof memory _proof\n    )\n        internal\n        returns (uint8 maxBlocksToVerify_)\n    {\n        // Make sure parentHash is not zero\n        // To contest an existing transition, simply use any non-zero value as\n        // the blockHash and stateRoot.\n        if (_tran.parentHash == 0 || _tran.blockHash == 0 || _tran.stateRoot == 0) {\n            revert L1_INVALID_TRANSITION();\n        }\n\n        // Check that the block has been proposed but has not yet been verified.\n        TaikoData.SlotB memory b = _state.slotB;\n        if (_meta.id <= b.lastVerifiedBlockId || _meta.id >= b.numBlocks) {\n            revert L1_INVALID_BLOCK_ID();\n        }\n\n        uint64 slot = _meta.id % _config.blockRingBufferSize;\n        TaikoData.Block storage blk = _state.blocks[slot];\n\n        // Check the integrity of the block data. It's worth noting that in\n        // theory, this check may be skipped, but it's included for added\n        // caution.\n        if (blk.blockId != _meta.id || blk.metaHash != keccak256(abi.encode(_meta))) {\n            revert L1_BLOCK_MISMATCH();\n        }\n\n        // Each transition is uniquely identified by the parentHash, with the\n        // blockHash and stateRoot open for later updates as higher-tier proofs\n        // become available. In cases where a transition with the specified\n        // parentHash does not exist, the transition ID (tid) will be set to 0.\n        (uint32 tid, TaikoData.TransitionState storage ts) =\n            _createTransition(_state, blk, _tran, slot);\n\n        // The new proof must meet or exceed the minimum tier required by the\n        // block or the previous proof; it cannot be on a lower tier.\n        if (_proof.tier == 0 || _proof.tier < _meta.minTier || _proof.tier < ts.tier) {\n            revert L1_INVALID_TIER();\n        }\n\n        // Retrieve the tier configurations. If the tier is not supported, the\n        // subsequent action will result in a revert.\n        ITierProvider.Tier memory tier =\n            ITierProvider(_resolver.resolve(\"tier_provider\", false)).getTier(_proof.tier);\n\n        // Check if this prover is allowed to submit a proof for this block\n        _checkProverPermission(_state, blk, ts, tid, tier);\n\n        // We must verify the proof, and any failure in proof verification will\n        // result in a revert.\n        //\n        // It's crucial to emphasize that the proof can be assessed in two\n        // potential modes: \"proving mode\" and \"contesting mode.\" However, the\n        // precise verification logic is defined within each tier's IVerifier\n        // contract implementation. We simply specify to the verifier contract\n        // which mode it should utilize - if the new tier is higher than the\n        // previous tier, we employ the proving mode; otherwise, we employ the\n        // contesting mode (the new tier cannot be lower than the previous tier,\n        // this has been checked above).\n        //\n        // It's obvious that proof verification is entirely decoupled from\n        // Taiko's core protocol.\n        {\n            address verifier = _resolver.resolve(tier.verifierName, true);\n\n            if (verifier != address(0)) {\n                bool isContesting = _proof.tier == ts.tier && tier.contestBond != 0;\n\n                IVerifier.Context memory ctx = IVerifier.Context({\n                    metaHash: blk.metaHash,\n                    blobHash: _meta.blobHash,\n                    // Separate msgSender to allow the prover to be any address in the future.\n                    prover: msg.sender,\n                    msgSender: msg.sender,\n                    blockId: blk.blockId,\n                    isContesting: isContesting,\n                    blobUsed: _meta.blobUsed\n                });\n\n                IVerifier(verifier).verifyProof(ctx, _tran, _proof);\n            } else if (tier.verifierName != TIER_OP) {\n                // The verifier can be address-zero, signifying that there are no\n                // proof checks for the tier. In practice, this only applies to\n                // optimistic proofs.\n                revert L1_MISSING_VERIFIER();\n            }\n        }\n\n        bool isTopTier = tier.contestBond == 0;\n        IERC20 tko = IERC20(_resolver.resolve(\"taiko_token\", false));\n\n        if (isTopTier) {\n            // A special return value from the top tier prover can signal this\n            // contract to return all liveness bond.\n            bool returnLivenessBond = blk.livenessBond > 0 && _proof.data.length == 32\n                && bytes32(_proof.data) == RETURN_LIVENESS_BOND;\n\n            if (returnLivenessBond) {\n                tko.transfer(blk.assignedProver, blk.livenessBond);\n                blk.livenessBond = 0;\n            }\n        }\n\n        bool sameTransition = _tran.blockHash == ts.blockHash && _tran.stateRoot == ts.stateRoot;\n\n        if (_proof.tier > ts.tier) {\n            // Handles the case when an incoming tier is higher than the current transition's tier.\n            // Reverts when the incoming proof tries to prove the same transition\n            // (L1_ALREADY_PROVED).\n            _overrideWithHigherProof(ts, _tran, _proof, tier, tko, sameTransition);\n\n            emit TransitionProved({\n                blockId: blk.blockId,\n                tran: _tran,\n                prover: msg.sender,\n                validityBond: tier.validityBond,\n                tier: _proof.tier\n            });\n        } else {\n            // New transition and old transition on the same tier - and if this transaction tries to\n            // prove the same, it reverts\n            if (sameTransition) revert L1_ALREADY_PROVED();\n\n            if (isTopTier) {\n                // The top tier prover re-proves.\n                assert(tier.validityBond == 0);\n                assert(ts.validityBond == 0 && ts.contestBond == 0 && ts.contester == address(0));\n\n                ts.prover = msg.sender;\n                ts.blockHash = _tran.blockHash;\n                ts.stateRoot = _tran.stateRoot;\n\n                emit TransitionProved({\n                    blockId: blk.blockId,\n                    tran: _tran,\n                    prover: msg.sender,\n                    validityBond: 0,\n                    tier: _proof.tier\n                });\n            } else {\n                // Contesting but not on the highest tier\n                if (ts.contester != address(0)) revert L1_ALREADY_CONTESTED();\n\n                // Burn the contest bond from the prover.\n                tko.transferFrom(msg.sender, address(this), tier.contestBond);\n\n                // We retain the contest bond within the transition, just in\n                // case this configuration is altered to a different value\n                // before the contest is resolved.\n                //\n                // It's worth noting that the previous value of ts.contestBond\n                // doesn't have any significance.\n                ts.contestBond = tier.contestBond;\n                ts.contester = msg.sender;\n                ts.contestations += 1;\n\n                emit TransitionContested({\n                    blockId: blk.blockId,\n                    tran: _tran,\n                    contester: msg.sender,\n                    contestBond: tier.contestBond,\n                    tier: _proof.tier\n                });\n            }\n        }\n\n        ts.timestamp = uint64(block.timestamp);\n        return tier.maxBlocksToVerifyPerProof;\n    }\n\n    /// @dev Handle the transition initialization logic\n    function _createTransition(\n        TaikoData.State storage _state,\n        TaikoData.Block storage _blk,\n        TaikoData.Transition memory _tran,\n        uint64 slot\n    )\n        private\n        returns (uint32 tid_, TaikoData.TransitionState storage ts_)\n    {\n        tid_ = LibUtils.getTransitionId(_state, _blk, slot, _tran.parentHash);\n\n        if (tid_ == 0) {\n            // In cases where a transition with the provided parentHash is not\n            // found, we must essentially \"create\" one and set it to its initial\n            // state. This initial state can be viewed as a special transition\n            // on tier-0.\n            //\n            // Subsequently, we transform this tier-0 transition into a\n            // non-zero-tier transition with a proof. This approach ensures that\n            // the same logic is applicable for both 0-to-non-zero transition\n            // updates and non-zero-to-non-zero transition updates.\n            unchecked {\n                // Unchecked is safe:  Not realistic 2**32 different fork choice\n                // per block will be proven and none of them is valid\n                tid_ = _blk.nextTransitionId++;\n            }\n\n            // Keep in mind that state.transitions are also reusable storage\n            // slots, so it's necessary to reinitialize all transition fields\n            // below.\n            ts_ = _state.transitions[slot][tid_];\n            ts_.blockHash = 0;\n            ts_.stateRoot = 0;\n            ts_.validityBond = 0;\n            ts_.contester = address(0);\n            ts_.contestBond = 1; // to save gas\n            ts_.timestamp = _blk.proposedAt;\n            ts_.tier = 0;\n            ts_.contestations = 0;\n\n            if (tid_ == 1) {\n                // This approach serves as a cost-saving technique for the\n                // majority of blocks, where the first transition is expected to\n                // be the correct one. Writing to `tran` is more economical\n                // since it resides in the ring buffer, whereas writing to\n                // `transitionIds` is not as cost-effective.\n                ts_.key = _tran.parentHash;\n\n                // In the case of this first transition, the block's assigned\n                // prover has the privilege to re-prove it, but only when the\n                // assigned prover matches the previous prover. To ensure this,\n                // we establish the transition's prover as the block's assigned\n                // prover. Consequently, when we carry out a 0-to-non-zero\n                // transition update, the previous prover will consistently be\n                // the block's assigned prover.\n                //\n                // While alternative implementations are possible, introducing\n                // such changes would require additional if-else logic.\n                ts_.prover = _blk.assignedProver;\n            } else {\n                // In scenarios where this transition is not the first one, we\n                // straightforwardly reset the transition prover to address\n                // zero.\n                ts_.prover = address(0);\n\n                // Furthermore, we index the transition for future retrieval.\n                // It's worth emphasizing that this mapping for indexing is not\n                // reusable. However, given that the majority of blocks will\n                // only possess one transition — the correct one — we don't need\n                // to be concerned about the cost in this case.\n                _state.transitionIds[_blk.blockId][_tran.parentHash] = tid_;\n\n                // There is no need to initialize ts.key here because it's only used when tid == 1\n            }\n        } else {\n            // A transition with the provided parentHash has been loc"
    }
  ]
}