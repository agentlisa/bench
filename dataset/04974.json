{
  "Title": "[G-33] Use `uint256(1)`/`uint256(2)` instead of `true`/`false` to save gas for changes",
  "Content": "\nBoolean variables in Solidity are more expensive than `uint256` or any type that takes up a full word, due to additional gas costs associated with write operations. When using boolean variables, each write operation emits an extra SLOAD to read the slot's contents, replace the bits taken up by the boolean, and then write back. This process cannot be disabled and leads to extra gas consumption.\n\nBy using `uint256(1)` and `uint256(2)` for representing true and false states, you can avoid a `Gwarmaccess` (100 gas) cost and also avoid a `Gsset` (20000 gas) cost when changing from `false` to `true`, after having been `true` in the past.\nThis approach helps in optimizing gas usage, making your contract more cost-effective.\n\n[Usage in OpenZeppelin ReentrancyGuard.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27)\n\n1 issue instance in 1 file:\n\n```solidity\nFile: pt-v5-vault/src/PrizeVaultFactory.sol\n69: mapping(address vault => bool deployedByFactory) public deployedVaults;\n```\n\n[69](https://github.com/code-423n4/2024-03-pooltogether/blob/main/pt-v5-vault/src/PrizeVaultFactory.sol#L69)\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-03-pooltogether",
  "Code": [
    {
      "filename": "contracts/security/ReentrancyGuard.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}"
    },
    {
      "filename": "pt-v5-vault/src/PrizeVaultFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { IERC20, IERC4626 } from \"openzeppelin/token/ERC20/extensions/ERC4626.sol\";\n\nimport { PrizePool } from \"pt-v5-prize-pool/PrizePool.sol\";\n\nimport { PrizeVault } from \"./PrizeVault.sol\";\n\n/// @title  PoolTogether V5 Prize Vault Factory\n/// @author PoolTogether Inc. & G9 Software Inc.\n/// @notice Factory contract for deploying new prize vaults using a standard underlying ERC4626 yield vault.\ncontract PrizeVaultFactory {\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Events\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Emitted when a new PrizeVault has been deployed by this factory.\n    /// @param vault The vault that was deployed\n    /// @param yieldVault The underlying yield vault\n    /// @param prizePool The prize pool the vault contributes to\n    /// @param name The name of the vault token\n    /// @param symbol The symbol for the vault token\n    event NewPrizeVault(\n        PrizeVault indexed vault,\n        IERC4626 indexed yieldVault,\n        PrizePool indexed prizePool,\n        string name,\n        string symbol\n    );\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Variables\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice The yield buffer to use for vault deployments.\n    /// @dev The yield buffer is expected to be of insignificant value and is used to cover rounding\n    /// errors on deposits and withdrawals. Yield is expected to accrue faster than the yield buffer\n    /// can be reasonably depleted.\n    ///\n    /// The yield buffer should be set as high as possible while still being considered\n    /// insignificant for the lowest precision per dollar asset that is expected to be supported.\n    /// \n    /// Precision per dollar (PPD) can be calculated by: (10 ^ DECIMALS) / ($ value of 1 asset).\n    /// For example, USDC has a PPD of (10 ^ 6) / ($1) = 10e6 p/$.\n    /// \n    /// As a rule of thumb, assets with lower PPD than USDC should not be assumed to be compatible since\n    /// the potential loss of a single unit rounding error is likely too high to be made up by yield at \n    /// a reasonable rate. Actual results may vary based on expected gas costs, asset fluctuation, and\n    /// yield accrual rates.\n    ///\n    /// The yield buffer of vaults deployed by this factory is 1e5. This means that if you deploy a \n    /// vault with USDC as the underlying asset, you will have to approve this factory to spend 1e5\n    /// USDC ($0.10) to be sent to the prize vault during deployment. This value will cover the first\n    /// 100k rounding errors on deposits and withdraws to the vault and is not recoverable by the \n    /// deployer.\n    ///\n    /// If the yield buffer is depleted on a vault, the vault will prevent any further \n    /// deposits if it would result in a rounding error and any rounding errors incurred by withdrawals\n    /// will not be covered by yield. The yield buffer will be replenished automatically as yield accrues\n    /// on deposits.\n    uint256 public constant YIELD_BUFFER = 1e5;\n\n    /// @notice List of all vaults deployed by this factory.\n    PrizeVault[] public allVaults;\n\n    /// @notice Mapping to verify if a Vault has been deployed via this factory.\n    mapping(address vault => bool deployedByFactory) public deployedVaults;\n\n    /// @notice Mapping to store deployer nonces for CREATE2\n    mapping(address deployer => uint256 nonce) public deployerNonces;\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // External Functions\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Deploy a new vault\n    /// @dev Emits a `NewPrizeVault` event with the vault details.\n    /// @dev `claimer` can be set to address zero if none is available yet.\n    /// @dev The caller MUST approve this factory to spend underlying assets equal to `YIELD_BUFFER` so the yield\n    /// buffer can be filled on deployment. This value is unrecoverable and is expected to be insignificant.\n    /// @param _name Name of the ERC20 share minted by the vault\n    /// @param _symbol Symbol of the ERC20 share minted by the vault\n    /// @param _yieldVault Address of the ERC4626 vault in which assets are deposited to generate yield\n    /// @param _prizePool Address of the PrizePool that computes prizes\n    /// @param _claimer Address of the claimer\n    /// @param _yieldFeeRecipient Address of the yield fee recipient\n    /// @param _yieldFeePercentage Yield fee percentage\n    /// @param _owner Address that will gain ownership of this contract\n    /// @return PrizeVault The newly deployed PrizeVault\n    function deployVault(\n      string memory _name,\n      string memory _symbol,\n      IERC4626 _yieldVault,\n      PrizePool _prizePool,\n      address _claimer,\n      address _yieldFeeRecipient,\n      uint32 _yieldFeePercentage,\n      address _owner\n    ) external returns (PrizeVault) {\n        PrizeVault _vault = new PrizeVault{\n            salt: keccak256(abi.encode(msg.sender, deployerNonces[msg.sender]++))\n        }(\n            _name,\n            _symbol,\n            _yieldVault,\n            _prizePool,\n            _claimer,\n            _yieldFeeRecipient,\n            _yieldFeePercentage,\n            YIELD_BUFFER,\n            _owner\n        );\n\n        // A donation to fill the yield buffer is made to ensure that early depositors have\n        // rounding errors covered in the time before yield is actually generated.\n        IERC20(_vault.asset()).transferFrom(msg.sender, address(_vault), YIELD_BUFFER);\n\n        allVaults.push(_vault);\n        deployedVaults[address(_vault)] = true;\n\n        emit NewPrizeVault(\n            _vault,\n            _yieldVault,\n            _prizePool,\n            _name,\n            _symbol\n        );\n\n        return _vault;\n    }\n\n    /// @notice Total number of vaults deployed by this factory.\n    /// @return uint256 Number of vaults deployed by this factory.\n    function totalVaults() external view returns (uint256) {\n        return allVaults.length;\n    }\n}"
    }
  ]
}