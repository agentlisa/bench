{
  "Title": "M-2: No check for `initialEth` in `GoatV1Pair.takeOverPool()`.",
  "Content": "# Issue M-2: No check for `initialEth` in `GoatV1Pair.takeOverPool()`. \n\nSource: https://github.com/sherlock-audit/2024-03-goat-trading-judging/issues/43 \n\n## Found by \nwhitehair0330\n## Summary\n\n[GoatV1Pair.takeOverPool()](https://github.com/sherlock-audit/2024-03-goat-trading/blob/main/goat-trading/contracts/exchange/GoatV1Pair.sol#L452-L538) only checks the amount of `token` for initialization, not `initialETH`.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2024-03-goat-trading/blob/main/goat-trading/contracts/exchange/GoatV1Pair.sol#L452-L538\n\n```javascript\n    function takeOverPool(GoatTypes.InitParams memory initParams) external {\n        if (_vestingUntil != _MAX_UINT32) {\n            revert GoatErrors.ActionNotAllowed();\n        }\n\n        GoatTypes.InitialLPInfo memory initialLpInfo = _initialLPInfo;\n\n        GoatTypes.LocalVariables_TakeOverPool memory localVars;\n        address to = msg.sender;\n        localVars.virtualEthOld = _virtualEth;\n        localVars.bootstrapEthOld = _bootstrapEth;\n        localVars.initialTokenMatchOld = _initialTokenMatch;\n\n        (localVars.tokenAmountForPresaleOld, localVars.tokenAmountForAmmOld) = _tokenAmountsForLiquidityBootstrap(\n            localVars.virtualEthOld,\n            localVars.bootstrapEthOld,\n            initialLpInfo.initialWethAdded,\n            localVars.initialTokenMatchOld\n        );\n\n        // new token amount for bootstrap if no swaps would have occured\n        (localVars.tokenAmountForPresaleNew, localVars.tokenAmountForAmmNew) = _tokenAmountsForLiquidityBootstrap(\n            initParams.virtualEth, initParams.bootstrapEth, initParams.initialEth, initParams.initialTokenMatch\n        );\n\n        // team needs to add min 10% more tokens than the initial lp to take over\n        localVars.minTokenNeeded =\n            ((localVars.tokenAmountForPresaleOld + localVars.tokenAmountForAmmOld) * 11000) / 10000;\n\n481     if ((localVars.tokenAmountForAmmNew + localVars.tokenAmountForPresaleNew) < localVars.minTokenNeeded) {\n            revert GoatErrors.InsufficientTakeoverTokenAmount();\n        }\n\n        localVars.reserveEth = _reserveEth;\n\n        // Actual token amounts needed if the reserves have updated after initial lp mint\n        (localVars.tokenAmountForPresaleNew, localVars.tokenAmountForAmmNew) = _tokenAmountsForLiquidityBootstrap(\n            initParams.virtualEth, initParams.bootstrapEth, localVars.reserveEth, initParams.initialTokenMatch\n        );\n        localVars.reserveToken = _reserveToken;\n\n        // amount of tokens transferred by the new team\n        uint256 tokenAmountIn = IERC20(_token).balanceOf(address(this)) - localVars.reserveToken;\n\n        if (\n            tokenAmountIn\n                < (\n                    localVars.tokenAmountForPresaleOld + localVars.tokenAmountForAmmOld - localVars.reserveToken\n                        + localVars.tokenAmountForPresaleNew + localVars.tokenAmountForAmmNew\n                )\n        ) {\n            revert GoatErrors.IncorrectTokenAmount();\n        }\n\n        localVars.pendingLiquidityFees = _pendingLiquidityFees;\n        localVars.pendingProtocolFees = _pendingProtocolFees;\n\n        // amount of weth transferred by the new team\n        uint256 wethAmountIn = IERC20(_weth).balanceOf(address(this)) - localVars.reserveEth\n            - localVars.pendingLiquidityFees - localVars.pendingProtocolFees;\n\n        if (wethAmountIn < localVars.reserveEth) {\n            revert GoatErrors.IncorrectWethAmount();\n        }\n\n        _handleTakeoverTransfers(\n            IERC20(_weth), IERC20(_token), initialLpInfo.liquidityProvider, localVars.reserveEth, localVars.reserveToken\n        );\n\n        uint256 lpBalance = balanceOf(initialLpInfo.liquidityProvider);\n        _burn(initialLpInfo.liquidityProvider, lpBalance);\n\n        // new lp balance\n        lpBalance = Math.sqrt(uint256(initParams.virtualEth) * initParams.initialTokenMatch) - MINIMUM_LIQUIDITY;\n        _mint(to, lpBalance);\n\n        _updateStateAfterTakeover(\n            initParams.virtualEth,\n            initParams.bootstrapEth,\n            initParams.initialTokenMatch,\n            wethAmountIn,\n            tokenAmountIn,\n            lpBalance,\n            to,\n            initParams.initialEth\n        );\n    }\n```\n\nAlthough there is a check for the amount of `token` at [L481](https://github.com/sherlock-audit/2024-03-goat-trading/blob/main/goat-trading/contracts/exchange/GoatV1Pair.sol#L481), if the caller sets `initParams.initialEth` to 0, it can easily pass [L481](https://github.com/sherlock-audit/2024-03-goat-trading/blob/main/goat-trading/contracts/exchange/GoatV1Pair.sol#L481) because a smaller `initParams.initialEth` results in a larger `localVars.tokenAmountForAmmNew + localVars.tokenAmountForPresaleNew`.\nThis is due to the fact that the former initial provider's `initialEth` does not have any effect in preventing takeovers.\n\n## Impact\n\nA pool could be unfairly taken over because the former initial provider's `initialEth` does not have any effect in preventing takeovers.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-03-goat-trading/blob/main/goat-trading/contracts/exchange/GoatV1Pair.sol#L452-L538\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThere should be a check for `initParams.initialEth`.\n\n\n\n## Discussion\n\n**chiranz**\n\nEven if check is bypassed [L481](https://github.com/sherlock-audit/2024-03-goat-trading/blob/main/goat-trading/contracts/exchange/GoatV1Pair.sol#L481)  it will revert here [L510-L515](https://github.com/sherlock-audit/2024-03-goat-trading/blob/main/goat-trading/contracts/exchange/GoatV1Pair.sol#L510-L515) \n\n**chiranz**\n\n> Even if check is bypassed [L481](https://github.com/sherlock-audit/2024-03-goat-trading/blob/main/goat-trading/contracts/exchange/GoatV1Pair.sol#L481) it will revert here [L510-L515](https://github.com/sherlock-audit/2024-03-goat-trading/blob/main/goat-trading/contracts/exchange/GoatV1Pair.sol#L510-L515)\n\nI misread your finding.. It's valid when initialEth used by someone is non zero but the one who is taking over can pass initialEth as 0 and take over pool.\n\n**zzykxx**\n\nEscalate\n\nI'm not 100% sure about this, but there is a good chance this is a duplicate of #46. Escalating for further discussion.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> I'm not 100% sure about this, but there is a good chance this is a duplicate of #46. Escalating for further discussion.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**whitehair0330**\n\nIn issue #46, they also mentioned L481 a bit; however, it only discussed checking `virtualEth` and not `initialEth`.\n\n**chiranz**\n\nI agree that this bug is independent of #46. So, not a duplicate. \n\n**cvetanovv**\n\nI agree with the @chiranz \n\n**whitehair0330**\n\nHello everyone, please review this issue again. I think that it is a high severity issue.\n\n**Evert0x**\n\nPlanning to reject escalation and keep issue state as is\n\n**Evert0x**\n\nResult:\nMedium\nUnique\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [zzykxx](https://github.com/sherlock-audit/2024-03-goat-trading-judging/issues/43/#issuecomment-2041378803): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/178",
  "Code": [
    {
      "filename": "goat-trading/contracts/exchange/GoatV1Pair.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// library imports\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n// local imports\nimport {GoatErrors} from \"../library/GoatErrors.sol\";\nimport {GoatTypes} from \"../library/GoatTypes.sol\";\nimport {GoatV1ERC20} from \"./GoatV1ERC20.sol\";\n\n// interfaces\nimport {IGoatV1Factory} from \"../interfaces/IGoatV1Factory.sol\";\n\n/**\n * @title Goat Trading V1 Pair\n * @notice Main contract for Goat Trading V1 and should be called from contract with safety checks.\n * @dev This contract is a pair of two tokens that are traded against each other.\n *  The pair is deployed by the factory contract.\n * Mint, Burn, Swap, and Takeover are handled in this contract.\n * @author Goat Trading -- Chiranjibi Poudyal, Robert M.C. Forster\n */\ncontract GoatV1Pair is GoatV1ERC20, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    uint256 public constant MINIMUM_LIQUIDITY = 10 ** 3;\n    uint32 private constant _MIN_LOCK_PERIOD = 2 days;\n    uint32 public constant VESTING_PERIOD = 7 days;\n    uint32 private constant _MAX_UINT32 = type(uint32).max;\n    uint32 private constant _THIRTY_DAYS = 30 days;\n\n    address public immutable factory;\n    uint32 private immutable _genesis;\n    // Figure out a way to use excess 12 bytes in here to store something\n    address private _token;\n    address private _weth;\n\n    uint112 private _virtualEth;\n    uint112 private _initialTokenMatch;\n    uint32 private _vestingUntil;\n\n    // this is the real amount of eth in the pool\n    uint112 private _reserveEth;\n    // token reserve in the pool\n    uint112 private _reserveToken;\n    // variable used to check for mev\n    uint32 private _lastTrade;\n\n    // Amounts of eth needed to turn pool into an amm\n    uint112 private _bootstrapEth;\n    // total lp fees that are not withdrawn\n    uint112 private _pendingLiquidityFees;\n\n    // Fees per token scaled by 1e18\n    uint184 public feesPerTokenStored;\n    // Can store >4500 ether which is more than enough\n    uint72 private _pendingProtocolFees;\n\n    mapping(address => uint256) private _presaleBalances;\n    mapping(address => uint256) public lpFees;\n    mapping(address => uint256) public feesPerTokenPaid;\n\n    GoatTypes.InitialLPInfo private _initialLPInfo;\n\n    event Mint(address, uint256, uint256);\n    event Burn(address, uint256, uint256, address);\n    event Swap(address, uint256, uint256, uint256, uint256, address);\n\n    constructor() {\n        factory = msg.sender;\n        _genesis = uint32(block.timestamp);\n    }\n\n    /* ----------------------------- EXTERNAL FUNCTIONS ----------------------------- */\n    function initialize(address token, address weth, string memory baseName, GoatTypes.InitParams memory params)\n        external\n    {\n        if (msg.sender != factory) revert GoatErrors.GoatV1Forbidden();\n        _token = token;\n        _weth = weth;\n        // setting non zero value so that swap will not incur new storage write on update\n        _vestingUntil = _MAX_UINT32;\n        // Is there a token without a name that may result in revert in this case?\n        string memory tokenName = IERC20Metadata(_token).name();\n        name = string(abi.encodePacked(\"GoatTradingV1: \", baseName, \"/\", tokenName));\n        symbol = string(abi.encodePacked(\"GoatV1-\", baseName, \"-\", tokenName));\n        _initialTokenMatch = params.initialTokenMatch;\n        _virtualEth = params.virtualEth;\n        _bootstrapEth = params.bootstrapEth;\n    }\n\n    /**\n     * @notice Should be called from a contract with safety checks\n     * @notice Mints liquidity tokens in exchange for ETH and tokens deposited into the pool.\n     * @dev This function allows users to add liquidity to the pool,\n     *      receiving liquidity tokens in return. It includes checks for\n     *      the presale period and calculates liquidity based on virtual amounts at presale\n     *      and deposited ETH and tokens when it's an amm.\n     * @param to The address to receive the minted liquidity tokens.\n     * @return liquidity The amount of liquidity tokens minted.\n     * Requirements:\n     * - Cannot add liquidity during the presale period if the total supply is greater than 0.\n     * - The amount of ETH deposited must not exceed the bootstrap ETH amount on first mint.\n     * - Ensures the deposited token amount matches the required amount for liquidity bootstrapping.\n     * Emits:\n     * - A `Mint` event with details for the mint transaction.\n     * Security:\n     * - Uses `nonReentrant` modifier to prevent reentrancy attacks.\n     */\n    function mint(address to) external nonReentrant returns (uint256 liquidity) {\n        uint256 totalSupply_ = totalSupply();\n        uint256 amountWeth;\n        uint256 amountToken;\n        uint256 balanceEth = IERC20(_weth).balanceOf(address(this));\n        uint256 balanceToken = IERC20(_token).balanceOf(address(this));\n\n        GoatTypes.LocalVariables_MintLiquidity memory mintVars;\n\n        mintVars.virtualEth = _virtualEth;\n        mintVars.initialTokenMatch = _initialTokenMatch;\n        mintVars.bootstrapEth = _bootstrapEth;\n\n        if (_vestingUntil == _MAX_UINT32) {\n            // Do not allow to add liquidity in presale period\n            if (totalSupply_ > 0) revert GoatErrors.PresalePeriod();\n            // don't allow to send more eth than bootstrap eth\n            if (balanceEth > mintVars.bootstrapEth) {\n                revert GoatErrors.SupplyMoreThanBootstrapEth();\n            }\n\n            if (balanceEth < mintVars.bootstrapEth) {\n                (uint256 tokenAmtForPresale, uint256 tokenAmtForAmm) = _tokenAmountsForLiquidityBootstrap(\n                    mintVars.virtualEth, mintVars.bootstrapEth, balanceEth, mintVars.initialTokenMatch\n                );\n                if (balanceToken != (tokenAmtForPresale + tokenAmtForAmm)) {\n                    revert GoatErrors.InsufficientTokenAmount();\n                }\n                liquidity =\n                    Math.sqrt(uint256(mintVars.virtualEth) * uint256(mintVars.initialTokenMatch)) - MINIMUM_LIQUIDITY;\n            } else {\n                // This means that user is willing to make this pool an amm pool in first liquidity mint\n                liquidity = Math.sqrt(balanceEth * balanceToken) - MINIMUM_LIQUIDITY;\n                uint32 timestamp = uint32(block.timestamp);\n                _vestingUntil = timestamp + VESTING_PERIOD;\n            }\n            mintVars.isFirstMint = true;\n        } else {\n            // at this point in time we will get the actual reserves\n            (uint256 reserveEth, uint256 reserveToken) = getReserves();\n            amountWeth = balanceEth - reserveEth - _pendingLiquidityFees - _pendingProtocolFees;\n            amountToken = balanceToken - reserveToken;\n            liquidity = Math.min((amountWeth * totalSupply_) / reserveEth, (amountToken * totalSupply_) / reserveToken);\n        }\n\n        // @note can this be an attack area to grief initial lp by using to as initial lp?\n        if (mintVars.isFirstMint || to == _initialLPInfo.liquidityProvider) {\n            _updateInitialLpInfo(liquidity, balanceEth, to, false, false);\n        }\n        if (!mintVars.isFirstMint) _updateFeeRewards(to);\n\n        if (totalSupply_ == 0) {\n            _mint(address(0), MINIMUM_LIQUIDITY);\n        }\n\n        _mint(to, liquidity);\n\n        _update(balanceEth, balanceToken, true);\n\n        emit Mint(msg.sender, amountWeth, amountToken);\n    }\n\n    /**\n     * @notice Should be called from a contract with safety checks\n     * @notice Burns liquidity tokens to remove liquidity from the pool and withdraw ETH and tokens.\n     * @dev This function allows liquidity providers to burn their liquidity\n     *         tokens in exchange for the underlying assets (ETH and tokens).\n     *         It updates the initial liquidity provider information,\n     *         applies fee rewards, and performs necessary state updates.\n     * @param to The address to which the withdrawn ETH and tokens will be sent.\n     * @return amountWeth The amount of WETH withdrawn from the pool.\n     * @return amountToken The amount of tokens withdrawn from the pool.\n     * Reverts:\n     * - If the function is called by the initial liquidity provider during the presale period.\n     * Emits:\n     * - A `Burn` event with necessary details of the burn.\n     */\n    function burn(address to) external returns (uint256 amountWeth, uint256 amountToken) {\n        uint256 liquidity = balanceOf(address(this));\n\n        // initial lp can bypass this check by using different\n        // to address so _lastPoolTokenSender is used\n        if (_vestingUntil == _MAX_UINT32) revert GoatErrors.PresalePeriod();\n\n        uint256 totalSupply_ = totalSupply();\n        amountWeth = (liquidity * _reserveEth) / totalSupply_;\n        amountToken = (liquidity * _reserveToken) / totalSupply_;\n        if (amountWeth == 0 || amountToken == 0) {\n            revert GoatErrors.InsufficientLiquidityBurned();\n        }\n\n        _updateFeeRewards(to);\n        _burn(address(this), liquidity);\n\n        // Transfer liquidity tokens to the user\n        IERC20(_weth).safeTransfer(to, amountWeth);\n        IERC20(_token).safeTransfer(to, amountToken);\n        uint256 balanceEth = IERC20(_weth).balanceOf(address(this));\n        uint256 balanceToken = IERC20(_token).balanceOf(address(this));\n\n        _update(balanceEth, balanceToken, true);\n\n        emit Burn(msg.sender, amountWeth, amountToken, to);\n    }\n\n    /**\n     * @notice Should be called from a contract with safety checks\n     * @notice Executes a swap from ETH to tokens or tokens to ETH.\n     * @dev This function handles the swapping logic, including MEV\n     *  checks, fee application, and updating reserves.\n     * @param amountTokenOut The amount of tokens to be sent out.\n     * @param amountWethOut The amount of WETH to be sent out.\n     * @param to The address to receive the output of the swap.\n     * Requirements:\n     * - Either `amountTokenOut` or `amountWethOut` must be greater than 0, but not both.\n     * - The output amount must not exceed the available reserves in the pool.\n     * - If the swap occurs in vesting period (presale included),\n     *   it updates the presale balance for the buyer.\n     * - Applies fees and updates reserves accordingly.\n     * - Ensures the K invariant holds after the swap,\n     *   adjusting for virtual reserves during the presale period.\n     * - Transfers the specified `amountTokenOut` or `amountWethOut` to the address `to`.\n     * - In case of a presale swap, adds LP fees to the reserve ETH.\n     * Emits:\n     * - A `Swap` event with details about the amounts swapped.\n     * Security:\n     * - Uses `nonReentrant` modifier to prevent reentrancy attacks.\n     */\n    function swap(uint256 amountTokenOut, uint256 amountWethOut, address to) external nonReentrant {\n        if (amountTokenOut == 0 && amountWethOut == 0) {\n            revert GoatErrors.InsufficientOutputAmount();\n        }\n        if (amountTokenOut != 0 && amountWethOut != 0) {\n            revert GoatErrors.MultipleOutputAmounts();\n        }\n        GoatTypes.LocalVariables_Swap memory swapVars;\n        swapVars.isBuy = amountWethOut > 0 ? false : true;\n        // check for mev\n        _handleMevCheck(swapVars.isBuy);\n\n        (swapVars.initialReserveEth, swapVars.initialReserveToken) = _getActualReserves();\n\n        if (amountTokenOut > swapVars.initialReserveToken || amountWethOut > swapVars.initialReserveEth) {\n            revert GoatErrors.InsufficientAmountOut();\n        }\n\n        if (swapVars.isBuy) {\n            swapVars.amountWethIn = IERC20(_weth).balanceOf(address(this)) - swapVars.initialReserveEth\n                - _pendingLiquidityFees - _pendingProtocolFees;\n            // optimistically send tokens out\n            IERC20(_token).safeTransfer(to, amountTokenOut);\n        } else {\n            swapVars.amountTokenIn = IERC20(_token).balanceOf(address(this)) - swapVars.initialReserveToken;\n            // optimistically send weth out\n            IERC20(_weth).safeTransfer(to, amountWethOut);\n        }\n        swapVars.vestingUntil = _vestingUntil;\n        swapVars.isPresale = swapVars.vestingUntil == _MAX_UINT32;\n\n        (swapVars.feesCollected, swapVars.lpFeesCollected) =\n            _handleFees(swapVars.amountWethIn, amountWethOut, swapVars.isPresale);\n\n        swapVars.tokenAmount = swapVars.isBuy ? amountTokenOut : swapVars.amountTokenIn;\n\n        // We store details of participants so that we only allow users who have\n        // swap back tokens who have bought in the vesting period.\n        if (swapVars.vestingUntil > block.timestamp) {\n            _updatePresale(to, swapVars.tokenAmount, swapVars.isBuy);\n        }\n\n        if (swapVars.isBuy) {\n            swapVars.amountWethIn -= swapVars.feesCollected;\n        } else {\n            unchecked {\n                amountWethOut += swapVars.feesCollected;\n            }\n        }\n        swapVars.finalReserveEth = swapVars.isBuy\n            ? swapVars.initialReserveEth + swapVars.amountWethIn\n            : swapVars.initialReserveEth - amountWethOut;\n        swapVars.finalReserveToken = swapVars.isBuy\n            ? swapVars.initialReserveToken - amountTokenOut\n            : swapVars.initialReserveToken + swapVars.amountTokenIn;\n\n        swapVars.bootstrapEth = _bootstrapEth;\n        // presale lp fees should go to reserve eth\n        if (swapVars.isPresale && ((swapVars.finalReserveEth + swapVars.lpFeesCollected) > swapVars.bootstrapEth)) {\n            // at this point pool should be changed to an AMM\n            _checkAndConvertPool(swapVars.finalReserveEth + swapVars.lpFeesCollected, swapVars.finalReserveToken);\n        } else {\n            // check for K\n\n            (swapVars.virtualEthReserveBefore, swapVars.virtualTokenReserveBefore) =\n                _getReserves(swapVars.vestingUntil, swapVars.initialReserveEth, swapVars.initialReserveToken);\n            (swapVars.virtualEthReserveAfter, swapVars.virtualTokenReserveAfter) =\n                _getReserves(swapVars.vestingUntil, swapVars.finalReserveEth, swapVars.finalReserveToken);\n            if (\n                swapVars.virtualEthReserveBefore * swapVars.virtualTokenReserveBefore\n                    > swapVars.virtualEthReserveAfter * swapVars.virtualTokenReserveAfter\n            ) {\n                revert GoatErrors.KInvariant();\n            }\n        }\n\n        if (swapVars.isPresale) {\n            swapVars.finalReserveEth += swapVars.lpFeesCollected;\n        }\n        _update(swapVars.finalReserveEth, swapVars.finalReserveToken, false);\n\n        emit Swap(\n            msg.sender,\n            swapVars.amountWethIn + swapVars.feesCollected,\n            swapVars.amountTokenIn,\n            amountWethOut,\n            amountTokenOut,\n            to\n        );\n    }\n\n    /**\n     * @notice Synchronizes the reserves of the pool with the current balances.\n     * @dev This function updates the reserves to reflect the current reserve of WETH and token\n     */\n    function sync() external nonReentrant {\n        uint256 tokenBalance = IERC20(_token).balanceOf(address(this));\n        uint256 wethBalance = IERC20(_weth).balanceOf(address(this));\n        _update(wethBalance, tokenBalance, true);\n    }\n\n    function _getActualReserves() internal view returns (uint112 reserveEth, uint112 reserveToken) {\n        reserveEth = _reserveEth;\n        reserveToken = _reserveToken;\n    }\n\n    function _getReserves(uint32 vestingUntil_, uint256 ethReserve, uint256 tokenReserve)\n        internal\n        view\n        returns (uint112 reserveEth, uint112 reserveToken)\n    {\n        // just pass eth reserve and token reserve here only use virtual eth and initial token match\n        // if pool has not turned into an AMM\n        if (vestingUntil_ != _MAX_UINT32) {\n            // Actual reserves\n            reserveEth = uint112(ethReserve);\n            reserveToken = uint112(tokenReserve);\n        } else {\n            uint256 initialTokenMatch = _initialTokenMatch;\n            uint256 virtualEth = _virtualEth;\n            uint256 virtualToken = _getVirtualTokenAmt(virtualEth, _bootstrapEth, initialTokenMatch);\n            // Virtual reserves\n            reserveEth = uint112(virtualEth + ethReserve);\n            reserveToken = uint112(virtualToken + tokenReserve);\n        }\n    }\n\n    /// @notice returns real reserves if pool has turned into an AMM else returns virtual reserves\n    function getReserves() public view returns (uint112 reserveEth, uint112 reserveToken) {\n        (reserveEth, reserveToken) = _getReserves(_vestingUntil, _reserveEth, _reserveToken);\n    }\n\n    /**\n     * @notice Withdraws excess tokens from the pool and converts it into an AMM.\n     * @dev Allows the initial liquidity provider to withdraw tokens if\n     *  bootstrap goals are not met even after 1 month of launching the pool and\n     *  forces the pool to transition to an AMM with the real reserve of with and\n     *  matching tokens required at that point.\n     * Requirements:\n     * - Can only be called by the initial liquidity provider.\n     * - Can only be called 30 days after the contract's genesis.\n     * - Pool should transition to an AMM after successful exectuion of this function.\n     * Post-Conditions:\n     * - Excess tokens are returned to the initial liquidity provider.\n     * - The pool transitions to an AMM with the real reserves of ETH and tokens.\n     * - Deletes the pair from the factory if eth raised is zero.\n     */\n    function withdrawExcessToken() external {\n        uint256 timestamp = block.timestamp;\n        // initial liquidty provider can call this function after 30 days from genesis\n        if (_genesis + _THIRTY_DAYS > timestamp) revert GoatErrors.PresaleDeadlineActive();\n        if (_vestingUntil != _MAX_UINT32) {\n            revert GoatErrors.ActionNotAllowed();\n        }\n\n        address initialLiquidityProvider = _initialLPInfo.liquidityProvider;\n        if (msg.sender != initialLiquidityProvider) {\n            revert GoatErrors.Unauthorized();\n        }\n\n        // as bootstrap eth is not met we consider reserve eth as bootstrap eth\n        // and turn presale into an amm with less liquidity.\n        uint256 reserveEth = _reserveEth;\n\n        uint256 bootstrapEth = reserveEth;\n\n        // if we know token amount for AMM we can remove excess tokens that are staying in this contract\n        (, uint256 tokenAmtForAmm) =\n            _tokenAmountsForLiquidityBootstrap(_virtualEth, bootstrapEth, 0, _initialTokenMatch);\n\n        IERC20 token = IERC20(_token);\n        uint256 poolTokenBalance = token.balanceOf(address(this));\n\n        uint256 amountToTransferBack = poolTokenBalance - tokenAmtForAmm;\n        // transfer excess token to the initial liquidity provider\n        token.safeTransfer(initialLiquidityProvider, amountToTransferBack);\n\n        if (reserveEth != 0) {\n            _updateLiquidityAndConvertToAmm(reserveEth, tokenAmtForAmm);\n            // update bootstrap eth because original bootstrap eth was not met and\n            // eth we raised until this point should be considered as bootstrap eth\n            _bootstrapEth = uint112(bootstrapEth);\n            _update(reserveEth, tokenAmtForAmm, false);\n        } else {\n            IGoatV1Factory(factory).removePair(_token);\n        }\n    }\n\n    /**\n     * @notice Allows a team to take over a pool from malicious actors.\n     * @dev Prevents malicious actors from griefing the pool by setting unfavorable\n     *   initial conditions. It requires the new team to match the pool reserves of\n     *   WETH amount and exceed their token contribution by at least 10%.\n     *   This function also resets the pool's initial liquidity parameters.\n     * @param initParams The new initial parameters for the pool.\n     * Requirements:\n     * - Pool must be in presale period.\n     * - The `tokenAmount` must be at least 10% greater and equal to bootstrap token needed for new params.\n     * - Tokens must be transferred to the pool before calling this function.\n     * Reverts:\n     * - If the pool has already transitioned to an AMM.\n     * - If `tokenAmountIn` is less than the minimum required to take over the pool.\n     * - If `wethAmountIn` is less than the reserve ETH.\n     * Post-Conditions:\n     * - Transfers the amount of token and weth after penalty to initial lp.\n     * - Burns the initial liquidity provider's tokens and\n     *   mints new liquidity tokens to the new team based on the new `initParams`.\n     * - Resets the pool's initial liquidity parameters to the new `initParams`.\n     * - Updates the pool's reserves to reflect the new token balance.\n     */\n    function takeOverPool(GoatTypes.InitParams memory initParams) external {\n        if (_vestingUntil != _MAX_UINT32) {\n            revert GoatErrors.ActionNotAllowed();\n        }\n\n        GoatTypes.InitialLPInfo memory initialLpInfo = _initialLPInfo;\n\n        GoatTypes.LocalVariables_TakeOverPool memory localVars;\n        address to = msg.sender;\n        localVars.virtualEthOld = _virtualEth;\n        localVars.bootstrapEthOld = _bootstrapEth;\n        localVars.initialTokenMatchOld = _initialTokenMatch;\n\n        (localVars.tokenAmountForPresaleOld, localVars.tokenAmountForAmmOld) = _tokenAmountsForLiquidityBootstrap(\n            localVars.virtualEthOld,\n            localVars.bootstrapEthOld,\n            initialLpInfo.initialWethAdded,\n            localVars.initialTokenMatchOld\n        );\n\n        // new token amount for bootstrap if no swaps would have occured\n        (localVars.tokenAmountForPresaleNew, localVars.tokenAmountForAmmNew) = _tokenAmountsForLiquidityBootstrap(\n            initParams.virtualEth, initParams.bootstrapEth, initParams.initialEth, initParams.initialTokenMatch\n        );\n\n        // team needs to add min 10% more tokens than the initial lp to take over\n        localVars.minTokenNeeded =\n            ((localVars.tokenAmountForPresaleOld + localVars.tokenAmountForAmmOld) * 11000) / 10000;\n\n        if ((localVars.tokenAmountForAmmNew + localVars.tokenAmountForPresaleNew) < localVars.minTokenNeeded) {\n            revert GoatErrors.InsufficientTakeoverTokenAmount();\n        }\n\n        localVars.reserveEth = _reserveEth;\n\n        // Actual token amounts needed if the reserves have updated after initial lp mint\n        (localVars.tokenAmountForPresaleNew, localVars.tokenAmountForAmmNew) = _tokenAmountsForLiquidityBootstrap(\n            initParams.virtualEth, initParams.bootstrapEth, localVars.reserveEth, initParams.initialTokenMatch\n        );\n        localVars.reserveToken = _reserveToken;\n\n        // amount of tokens transferred by the new team\n        uint256 tokenAmountIn = IERC20(_token).balanceOf(address(this)) - localVars.reserveToken;\n\n        if (\n            tokenAmountIn\n                < (\n                    localVars.tokenAmountForPresaleOld + localVars.tokenAmountForAmmOld - localVars.reserveToken\n                        + localVars.tokenAmountForPresaleNew + localVars.tokenAmountForAmmNew\n                )\n        ) {\n            revert GoatErrors.IncorrectTokenAmount();\n        }\n\n        localVars.pendingLiquidityFees = _pendingLiquidityFees;\n        localVars.pendingProtocolFees = _pendingProtocolFees;\n\n        // amount of weth transferred by the new team\n        uint256 wethAmountIn = IERC20(_weth).balanceOf(address(this)) - localVars.reserveEth\n            - localVars.pendingLiquidityFees - localVars.pendingProtocolFees;\n\n        if (wethAmountIn < localVars.reserveEth) {\n            revert GoatErrors.IncorrectWethAmount();\n        }\n\n        _handleTakeoverTransfers(\n            IERC20(_weth), IERC20(_token), initialLpInfo.liquidityProvider, localVars.reserveEth, localVars.reserveToken\n        );\n\n        uint256 lpBalance = balanceOf(initialLpInfo.liquidityProvider);\n        _burn(initialLpInfo.liquidityProvider, lpBalance);\n\n        // new lp balance\n        lpBalance = Math.sqrt(uint256(initParams.virtualEth) * initParams.initialTokenMatch) - MINIMUM_LIQUIDITY;\n        _mint(to, lpBalance);\n\n        _updateStateAfterTakeover(\n            initParams.virtualEth,\n            initParams.bootstrapEth,\n            initParams.initialTokenMatch,\n            wethAmountIn,\n            tokenAmountIn,\n            lpBalance,\n            to,\n            initParams.initialEth\n        );\n    }\n\n    /**\n     * @notice Updates contract state following a successful pool takeover.\n     * @dev Resets pool parameters with new values provided by the\n     *  new liquidity provider and updates the pool's reserves and initial lp info.\n     * @param virtualEth The new virtual Ether amount for the pool.\n     * @param bootstrapEth The new bootstrap Ether amount for the pool.\n     * @param initialTokenMatch The new initial token match amount for the pool.\n     * @param finalReserveWeth The final WETH reserve amount after the takeover.\n     * @param finalReserveToken The final token reserve amount after the takeover.\n     * @param liquidity The liquidity amount minted to the new liquidity provider.\n     * @param newLp The address of the new liquidity provider.\n     * @param initialWeth The initial WETH amount added by the new liquidity provider.\n     * Post-Conditions:\n     * - Sets the pool's virtual ETH, bootstrap ETH, and initial token match to the new values.\n     * - Updates the initial liquidity provider information with the new liquidity provider's details.\n     * - Updates the pool's WETH and token reserves to reflect the final state after the takeover.\n     */\n    function _updateStateAfterTakeover(\n        uint256 virtualEth,\n        uint256 bootstrapEth,\n        uint256 initialTokenMatch,\n        uint256 finalReserveWeth,\n        uint256 finalReserveToken,\n        uint256 liquidity,\n        address newLp,\n        uint256 initialWeth\n    ) internal {\n        _virtualEth = uint112(virtualEth);\n        _bootstrapEth = uint112(bootstrapEth);\n        _initialTokenMatch = uint112(initialTokenMatch);\n\n        // delete initial lp info\n        delete _initialLPInfo;\n\n        // update lp info as if it was first mint\n        _updateInitialLpInfo(liquidity, initialWeth, newLp, false, false);\n\n        _update(finalReserveWeth, finalReserveToken, false);\n    }\n\n    /**\n     * @notice Handles asset transfers during a pool takeover.\n     * @dev Transfers WETH and tokens back to the initial liquidity provider (lp) with a penalty\n     *      for potential frontrunners. This mechanism aims to discourage malicious frontrunning by\n     *      applying 5% penalty to the WETH amount being transferred.\n     * @param weth The WETH token contract.\n     * @param token The token contract associated with the pool.\n     * @param lp The address of the initial liquidity provider to receive the transferred assets.\n     * @param wethAmount Total amount of weth to be transferred. (lp share + penalty)\n     * @param tokenAmount The amount of tokens to be transferred to the lp.\n     */\n    function _handleTakeoverTransfers(IERC20 weth, IERC20 token, address lp, uint256 wethAmount, uint256 tokenAmount)\n        internal\n    {\n        if (wethAmount != 0) {\n            // Malicious frontrunners can create cheaper pools buy tokens cheap\n            // and make it costly for the teams to take over. So, we need to have penalty\n            // for the frontrunner.\n            uint256 penalty = (wethAmount * 5) / 100;\n            // actual amount to transfer\n            wethAmount -= penalty;\n            weth.safeTransfer(lp, wethAmount);\n            weth.safeTransfer(IGoatV1Factory(factory).treasury(), penalty);\n        }\n        token.safeTransfer(lp, tokenAmount);\n    }\n\n    /**\n     * @notice Withdraws the fees accrued to the address `to`.\n     * @dev Transfers the accumulated fees in weth of the liquidty proivder\n     * @param to The address to which the fees will be withdrawn.\n     * Post-conditions:\n     * - The `feesPerTokenPaid` should reflect the latest `feesPerTokenStored` value for the address `to`.\n     * - The `lpFees` owed to the address `to` are reset to 0.\n     * - The `_pendingLiquidityFees` state variable is decreased by the amount of fees withdrawn.\n     */\n    function withdrawFees(address to) external {\n        uint256 totalFees = _earned(to, feesPerTokenStored);\n\n        if (totalFees != 0) {\n            feesPerTokenPaid[to] = feesPerTokenStored;\n            lpFees[to] = 0;\n            _pendingLiquidityFees -= uint112(totalFees);\n            IERC20(_weth).safeTransfer(to, totalFees);\n        }\n        // is there a need to check if weth balance is in sync with reserve and fees?\n    }\n\n    /* ----------------------------- INTERNAL FUNCTIONS ----------------------------- */\n\n    /**\n     * @notice Updates the reserve amounts.\n     */\n    function _update(uint256 balanceEth, uint256 balanceToken, bool deductFees) internal {\n        // Update token reserves and other necessary data\n        if (deductFees) {\n            _reserveEth = uint112(balanceEth - (_pendingLiquidityFees + _pendingProtocolFees));\n        } else {\n            _reserveEth = uint112(balanceEth);\n        }\n        _reserveToken = uint112(balanceToken);\n    }\n\n    /**\n     * @notice Updates the initial liquidity provider information.\n     * @dev This function updates the `_initialLPInfo` storage variable based on the provided parameters.\n     * @param liquidity The amount of liquidity to update.\n     * @param wethAmt The amount of WETH added by the initial liquidity provider.\n     * @param lp The address of the liquidity provider.\n     * @param isBurn A flag indicating whether the update is a burn operation.\n     * @param internalBurn A flag indicating whether the update is because or pool transition (from presale to amm)\n     */\n    function _updateInitialLpInfo(uint256 liquidity, uint256 wethAmt, address lp, bool isBurn, bool internalBurn)\n        internal\n    {\n        GoatTypes.InitialLPInfo memory info = _initialLPInfo;\n\n        if (internalBurn) {\n            // update from from swap when pool converts to an amm\n            info.fractionalBalance = uint112(liquidity) / 4;\n        } else if (isBurn) {\n            if (lp == info.liquidityProvider) {\n                info.lastWithdraw = uint32(block.timestamp);\n                info.withdrawalLeft -= 1;\n            }\n        } else {\n            info.fractionalBalance = uint112(((info.fractionalBalance * info.withdrawalLeft) + liquidity) / 4);\n            info.withdrawalLeft = 4;\n            info.liquidityProvider = lp;\n            if (wethAmt != 0) {\n                info.initialWethAdded = uint104(wethAmt);\n            }\n        }\n\n        // Update initial liquidity provider info\n        _initialLPInfo = info;\n    }\n\n    /**\n     * @dev Calculates and handles the distribution of fees for each swap transaction.\n     * Fees are updated based on the amount of WETH entering or exiting the pool,\n     *  - 99 bps fees are collected of which 60% goes to the treasury\n     *  - Allocates 40% to LPs (added to reserves during presale, otherwise distributed per SNX logic).\n     *  - If protocol fees exceed a predefined threshold, they are transferred to the treasury.\n     * @param amountWethIn amount of weth entering the pool (0 if it's a sell)\n     * @param amountWethOut amount of weth exiting the pool (0 if it's a buy)\n     * @param isPresale boolean indicating if the swap is in the presale period.\n     * @return feesCollected 99bps on the amount of weth entering or exiting the pool.\n     * @return feesLp amount of lp fees share\n     * Post-conditions:\n     * - Updates the `_pendingProtocolFees` by 60% of the fees collected or resets it to 0.\n     * - Updates the `_feesPerTokenStored` if pool is not in presale.\n     */\n    function _handleFees(uint256 amountWethIn, uint256 amountWethOut, bool isPresale)\n        internal\n        returns (uint256 feesCollected, uint256 feesLp)\n    {\n        // here either amountWethIn or amountWethOut will be zero\n\n        // fees collected will be 99 bps of the weth amount\n        if (amountWethIn != 0) {\n            feesCollected = (amountWethIn * 99) / 10000;\n        } else {\n            feesCollected = (amountWethOut * 10000) / 9901 - amountWethOut;\n        }\n        // lp fess is fixed 40% of the fees collected of total 99 bps\n        feesLp = (feesCollected * 40) / 100;\n\n        uint256 pendingProtocolFees = _pendingProtocolFees;\n\n        // lp fees only updated if it's not a presale\n        if ("
    }
  ]
}