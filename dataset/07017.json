{
  "Title": "[M-16] MaltRepository._revokeRole may not work correctly",
  "Content": "\nMaltRepository inherits from AccessControl and adds validation of validRoles to the hasRole function, which means that even if super.hasRole(role, account) == true, if validRoles\\[role] == false hasRole will return false, which will cause `\\_revokeRole` to not work correctly.\n\n```solidity\n  function hasRole(bytes32 role, address account)\n    public\n    view\n    override\n    returns (bool)\n  {\n    // Timelock has all possible permissions\n    return\n      (super.hasRole(role, account) && validRoles[role]) ||\n      super.hasRole(TIMELOCK_ROLE, account);\n  }\n```\n\nConsider the case where Alice is granted ADMIN_ROLE, then ADMIN_ROLE is removed in the removeRole function, validRoles\\[ADMIN_ROLE] == false.\n\n```solidity\n  function removeRole(bytes32 role) external onlyRole(getRoleAdmin(role)) {\n    validRoles[role] = false;\n    emit RemoveRole(role);\n  }\n```\n\nNow if the revokeRole function is called on Alice, in the `\\_revokeRole`, since hasRole returns false, Alice's ADMIN_ROLE will not be revoked.\n\nSince removeRole ends silently, this may actually cause the caller to incorrectly assume that Alice's ADMIN_ROLE has been revoked:\n\n```solidity\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n```\n\nIn addition, the renounceRole and `\\_transferRole` functions will also be affected.\n\nIn particular, the `\\_transferRole` function, if you want to transfer Alice's role to Bob, both Alice and Bob will have the role if validRoles\\[role]==false.\n\n```solidity\n  function _transferRole(\n    address newAccount,\n    address oldAccount,\n    bytes32 role\n  ) internal {\n    _revokeRole(role, oldAccount);\n    _grantRole(role, newAccount);\n  }\n...\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n```\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/Repository.sol#L64-L74> \n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/Repository.sol#L99-L102>\n\n### Recommended Mitigation Steps\n\nOverride renounceRole and removeRole in the MaltRepository and modify them as follows:\n\n```diff\n    function renounceRole(bytes32 role, address account) public virtual override {\n+     require(validRoles[role], \"Unknown role\");\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n...\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n+     require(validRoles[role], \"Unknown role\");\n        _revokeRole(role, account);\n    }\n...\n  function _transferRole(\n    address newAccount,\n    address oldAccount,\n    bytes32 role\n  ) internal {\n+  require(validRoles[role], \"Unknown role\");\n    _revokeRole(role, oldAccount);\n    _grantRole(role, newAccount);\n  }\n```\n\n**[0xScotch (Malt) confirmed](https://github.com/code-423n4/2023-02-malt-findings/issues/5)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-02-malt-protocol-versus-contest",
  "Code": [
    {
      "filename": "contracts/Repository.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport \"openzeppelin/access/AccessControl.sol\";\nimport \"openzeppelin/token/ERC20/ERC20.sol\";\nimport \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\n\nstruct Contract {\n  address contractAddress;\n  uint256 index;\n}\n\n/// @title Repository\n/// @author 0xScotch <scotch@malt.money>\n/// @notice A global repository of Malt contracts and global access control\ncontract MaltRepository is AccessControl {\n  using SafeERC20 for ERC20;\n\n  // Timelock has absolute power across the system\n  bytes32 public immutable TIMELOCK_ROLE;\n  bytes32 public immutable ADMIN_ROLE;\n  bytes32 public immutable KEEPER_ROLE;\n\n  mapping(bytes32 => bool) public validRoles;\n  mapping(bytes32 => Contract) public globalContracts;\n  string[] public contracts;\n  address internal immutable deployer;\n\n  event AddRole(bytes32 role);\n  event RemoveRole(bytes32 role);\n  event AddContract(bytes32 indexed hashedName, address contractAddress);\n  event RemoveContract(bytes32 indexed hashedName);\n  event UpdateContract(bytes32 indexed hashedName, address contractAddress);\n\n  constructor(address _deployer) {\n    // keccak256(\"TIMELOCK_ROLE\");\n    TIMELOCK_ROLE = 0xf66846415d2bf9eabda9e84793ff9c0ea96d87f50fc41e66aa16469c6a442f05;\n    // keccak256(\"ADMIN_ROLE\");\n    ADMIN_ROLE = 0xa49807205ce4d355092ef5a8a18f56e8913cf4a201fbe287825b095693c21775;\n    // keccak256(\"KEEPER_ROLE\");\n    KEEPER_ROLE = 0xfc8737ab85eb45125971625a9ebdb75cc78e01d5c1fa80c4c6e5203f47bc4fab;\n    deployer = _deployer;\n  }\n\n  function setupContracts(\n    address _timelock,\n    address[] memory _admins,\n    address _malt,\n    address _timekeeper,\n    address _transferService,\n    address _globalIC,\n    address _poolFactory\n  ) external {\n    require(msg.sender == deployer, \"Must be deployer\");\n    _setup(_timelock, _admins);\n    _contractSetup(\"timelock\", _timelock);\n    _contractSetup(\"malt\", _malt);\n    _contractSetup(\"timekeeper\", _timekeeper);\n    _contractSetup(\"transferService\", _transferService);\n    _contractSetup(\"globalIC\", _globalIC);\n    _contractSetup(\"poolFactory\", _poolFactory);\n  }\n\n  function hasRole(bytes32 role, address account)\n    public\n    view\n    override\n    returns (bool)\n  {\n    // Timelock has all possible permissions\n    return\n      (super.hasRole(role, account) && validRoles[role]) ||\n      super.hasRole(TIMELOCK_ROLE, account);\n  }\n\n  function checkRole(string memory _role) public view returns (bool) {\n    bytes32 hashedRole = keccak256(abi.encodePacked(_role));\n    return validRoles[hashedRole];\n  }\n\n  function getContract(string memory _contract) public view returns (address) {\n    bytes32 hashedContract = keccak256(abi.encodePacked(_contract));\n    return globalContracts[hashedContract].contractAddress;\n  }\n\n  function grantRole(bytes32 role, address account)\n    public\n    override\n    onlyRole(getRoleAdmin(role))\n  {\n    require(validRoles[role], \"Unknown role\");\n    _grantRole(role, account);\n  }\n\n  function addNewRole(bytes32 role) external onlyRole(TIMELOCK_ROLE) {\n    _roleSetup(role, msg.sender);\n  }\n\n  function removeRole(bytes32 role) external onlyRole(getRoleAdmin(role)) {\n    validRoles[role] = false;\n    emit RemoveRole(role);\n  }\n\n  function addNewContract(string memory _name, address _contract)\n    external\n    onlyRole(TIMELOCK_ROLE)\n  {\n    _contractSetup(_name, _contract);\n  }\n\n  function removeContract(string memory _name)\n    external\n    onlyRole(TIMELOCK_ROLE)\n  {\n    _removeContract(_name);\n  }\n\n  function updateContract(string memory _name, address _contract)\n    external\n    onlyRole(TIMELOCK_ROLE)\n  {\n    _updateContract(_name, _contract);\n  }\n\n  function grantRoleMultiple(bytes32 role, address[] calldata addresses)\n    external\n    onlyRole(getRoleAdmin(role))\n  {\n    require(validRoles[role], \"Unknown role\");\n    uint256 length = addresses.length; // gas\n\n    for (uint256 i; i < length; ++i) {\n      address account = addresses[i];\n      require(account != address(0), \"0x0\");\n      _grantRole(role, account);\n    }\n  }\n\n  function emergencyWithdrawGAS(address payable destination)\n    external\n    onlyRole(TIMELOCK_ROLE)\n  {\n    require(destination != address(0), \"Withdraw: addr(0)\");\n    // Transfers the entire balance of the Gas token to destination\n    (bool success, ) = destination.call{value: address(this).balance}(\"\");\n    require(success, \"emergencyWithdrawGAS error\");\n  }\n\n  function emergencyWithdraw(address _token, address destination)\n    external\n    onlyRole(TIMELOCK_ROLE)\n  {\n    require(destination != address(0), \"Withdraw: addr(0)\");\n    // Transfers the entire balance of an ERC20 token at _token to destination\n    ERC20 token = ERC20(_token);\n    token.safeTransfer(destination, token.balanceOf(address(this)));\n  }\n\n  function partialWithdrawGAS(address payable destination, uint256 amount)\n    external\n    onlyRole(TIMELOCK_ROLE)\n  {\n    require(destination != address(0), \"Withdraw: addr(0)\");\n    (bool success, ) = destination.call{value: amount}(\"\");\n    require(success, \"partialWithdrawGAS error\");\n  }\n\n  function partialWithdraw(\n    address _token,\n    address destination,\n    uint256 amount\n  ) external onlyRole(TIMELOCK_ROLE) {\n    require(destination != address(0), \"Withdraw: addr(0)\");\n    ERC20 token = ERC20(_token);\n    token.safeTransfer(destination, amount);\n  }\n\n  /*\n   * INTERNAL METHODS\n   */\n  function _setup(address _timelock, address[] memory _admins) internal {\n    _roleSetup(TIMELOCK_ROLE, _timelock);\n    _roleSetup(ADMIN_ROLE, _timelock);\n    _roleSetup(KEEPER_ROLE, _timelock);\n\n    uint256 length = _admins.length; // gas\n\n    for (uint256 i; i < length; ++i) {\n      address account = _admins[i];\n      require(account != address(0), \"0x0\");\n      _grantRole(ADMIN_ROLE, account);\n      _grantRole(KEEPER_ROLE, account);\n    }\n  }\n\n  function _transferRole(\n    address newAccount,\n    address oldAccount,\n    bytes32 role\n  ) internal {\n    _revokeRole(role, oldAccount);\n    _grantRole(role, newAccount);\n  }\n\n  function _roleSetup(bytes32 role, address account) internal {\n    _grantRole(role, account);\n    _setRoleAdmin(role, TIMELOCK_ROLE);\n    validRoles[role] = true;\n    emit AddRole(role);\n  }\n\n  function _contractSetup(string memory _name, address _contract) internal {\n    require(_contract != address(0), \"0x0\");\n    bytes32 hashedName = keccak256(abi.encodePacked(_name));\n    Contract storage currentContract = globalContracts[hashedName];\n    require(currentContract.contractAddress == address(0), \"Contract exists\");\n    currentContract.contractAddress = _contract;\n    currentContract.index = contracts.length;\n    contracts.push(_name);\n    emit AddContract(hashedName, _contract);\n  }\n\n  function _removeContract(string memory _name) internal {\n    bytes32 hashedName = keccak256(abi.encodePacked(_name));\n    Contract storage currentContract = globalContracts[hashedName];\n    currentContract.contractAddress = address(0);\n    currentContract.index = 0;\n\n    uint256 index = currentContract.index;\n    string memory lastContract = contracts[contracts.length - 1];\n    contracts[index] = lastContract;\n    contracts.pop();\n    emit RemoveContract(hashedName);\n  }\n\n  function _updateContract(string memory _name, address _newContract) internal {\n    require(_newContract != address(0), \"0x0\");\n    bytes32 hashedName = keccak256(abi.encodePacked(_name));\n    Contract storage currentContract = globalContracts[hashedName];\n    currentContract.contractAddress = _newContract;\n    emit UpdateContract(hashedName, _newContract);\n  }\n}"
    },
    {
      "filename": "contracts/Repository.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport \"openzeppelin/access/AccessControl.sol\";\nimport \"openzeppelin/token/ERC20/ERC20.sol\";\nimport \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\n\nstruct Contract {\n  address contractAddress;\n  uint256 index;\n}\n\n/// @title Repository\n/// @author 0xScotch <scotch@malt.money>\n/// @notice A global repository of Malt contracts and global access control\ncontract MaltRepository is AccessControl {\n  using SafeERC20 for ERC20;\n\n  // Timelock has absolute power across the system\n  bytes32 public immutable TIMELOCK_ROLE;\n  bytes32 public immutable ADMIN_ROLE;\n  bytes32 public immutable KEEPER_ROLE;\n\n  mapping(bytes32 => bool) public validRoles;\n  mapping(bytes32 => Contract) public globalContracts;\n  string[] public contracts;\n  address internal immutable deployer;\n\n  event AddRole(bytes32 role);\n  event RemoveRole(bytes32 role);\n  event AddContract(bytes32 indexed hashedName, address contractAddress);\n  event RemoveContract(bytes32 indexed hashedName);\n  event UpdateContract(bytes32 indexed hashedName, address contractAddress);\n\n  constructor(address _deployer) {\n    // keccak256(\"TIMELOCK_ROLE\");\n    TIMELOCK_ROLE = 0xf66846415d2bf9eabda9e84793ff9c0ea96d87f50fc41e66aa16469c6a442f05;\n    // keccak256(\"ADMIN_ROLE\");\n    ADMIN_ROLE = 0xa49807205ce4d355092ef5a8a18f56e8913cf4a201fbe287825b095693c21775;\n    // keccak256(\"KEEPER_ROLE\");\n    KEEPER_ROLE = 0xfc8737ab85eb45125971625a9ebdb75cc78e01d5c1fa80c4c6e5203f47bc4fab;\n    deployer = _deployer;\n  }\n\n  function setupContracts(\n    address _timelock,\n    address[] memory _admins,\n    address _malt,\n    address _timekeeper,\n    address _transferService,\n    address _globalIC,\n    address _poolFactory\n  ) external {\n    require(msg.sender == deployer, \"Must be deployer\");\n    _setup(_timelock, _admins);\n    _contractSetup(\"timelock\", _timelock);\n    _contractSetup(\"malt\", _malt);\n    _contractSetup(\"timekeeper\", _timekeeper);\n    _contractSetup(\"transferService\", _transferService);\n    _contractSetup(\"globalIC\", _globalIC);\n    _contractSetup(\"poolFactory\", _poolFactory);\n  }\n\n  function hasRole(bytes32 role, address account)\n    public\n    view\n    override\n    returns (bool)\n  {\n    // Timelock has all possible permissions\n    return\n      (super.hasRole(role, account) && validRoles[role]) ||\n      super.hasRole(TIMELOCK_ROLE, account);\n  }\n\n  function checkRole(string memory _role) public view returns (bool) {\n    bytes32 hashedRole = keccak256(abi.encodePacked(_role));\n    return validRoles[hashedRole];\n  }\n\n  function getContract(string memory _contract) public view returns (address) {\n    bytes32 hashedContract = keccak256(abi.encodePacked(_contract));\n    return globalContracts[hashedContract].contractAddress;\n  }\n\n  function grantRole(bytes32 role, address account)\n    public\n    override\n    onlyRole(getRoleAdmin(role))\n  {\n    require(validRoles[role], \"Unknown role\");\n    _grantRole(role, account);\n  }\n\n  function addNewRole(bytes32 role) external onlyRole(TIMELOCK_ROLE) {\n    _roleSetup(role, msg.sender);\n  }\n\n  function removeRole(bytes32 role) external onlyRole(getRoleAdmin(role)) {\n    validRoles[role] = false;\n    emit RemoveRole(role);\n  }\n\n  function addNewContract(string memory _name, address _contract)\n    external\n    onlyRole(TIMELOCK_ROLE)\n  {\n    _contractSetup(_name, _contract);\n  }\n\n  function removeContract(string memory _name)\n    external\n    onlyRole(TIMELOCK_ROLE)\n  {\n    _removeContract(_name);\n  }\n\n  function updateContract(string memory _name, address _contract)\n    external\n    onlyRole(TIMELOCK_ROLE)\n  {\n    _updateContract(_name, _contract);\n  }\n\n  function grantRoleMultiple(bytes32 role, address[] calldata addresses)\n    external\n    onlyRole(getRoleAdmin(role))\n  {\n    require(validRoles[role], \"Unknown role\");\n    uint256 length = addresses.length; // gas\n\n    for (uint256 i; i < length; ++i) {\n      address account = addresses[i];\n      require(account != address(0), \"0x0\");\n      _grantRole(role, account);\n    }\n  }\n\n  function emergencyWithdrawGAS(address payable destination)\n    external\n    onlyRole(TIMELOCK_ROLE)\n  {\n    require(destination != address(0), \"Withdraw: addr(0)\");\n    // Transfers the entire balance of the Gas token to destination\n    (bool success, ) = destination.call{value: address(this).balance}(\"\");\n    require(success, \"emergencyWithdrawGAS error\");\n  }\n\n  function emergencyWithdraw(address _token, address destination)\n    external\n    onlyRole(TIMELOCK_ROLE)\n  {\n    require(destination != address(0), \"Withdraw: addr(0)\");\n    // Transfers the entire balance of an ERC20 token at _token to destination\n    ERC20 token = ERC20(_token);\n    token.safeTransfer(destination, token.balanceOf(address(this)));\n  }\n\n  function partialWithdrawGAS(address payable destination, uint256 amount)\n    external\n    onlyRole(TIMELOCK_ROLE)\n  {\n    require(destination != address(0), \"Withdraw: addr(0)\");\n    (bool success, ) = destination.call{value: amount}(\"\");\n    require(success, \"partialWithdrawGAS error\");\n  }\n\n  function partialWithdraw(\n    address _token,\n    address destination,\n    uint256 amount\n  ) external onlyRole(TIMELOCK_ROLE) {\n    require(destination != address(0), \"Withdraw: addr(0)\");\n    ERC20 token = ERC20(_token);\n    token.safeTransfer(destination, amount);\n  }\n\n  /*\n   * INTERNAL METHODS\n   */\n  function _setup(address _timelock, address[] memory _admins) internal {\n    _roleSetup(TIMELOCK_ROLE, _timelock);\n    _roleSetup(ADMIN_ROLE, _timelock);\n    _roleSetup(KEEPER_ROLE, _timelock);\n\n    uint256 length = _admins.length; // gas\n\n    for (uint256 i; i < length; ++i) {\n      address account = _admins[i];\n      require(account != address(0), \"0x0\");\n      _grantRole(ADMIN_ROLE, account);\n      _grantRole(KEEPER_ROLE, account);\n    }\n  }\n\n  function _transferRole(\n    address newAccount,\n    address oldAccount,\n    bytes32 role\n  ) internal {\n    _revokeRole(role, oldAccount);\n    _grantRole(role, newAccount);\n  }\n\n  function _roleSetup(bytes32 role, address account) internal {\n    _grantRole(role, account);\n    _setRoleAdmin(role, TIMELOCK_ROLE);\n    validRoles[role] = true;\n    emit AddRole(role);\n  }\n\n  function _contractSetup(string memory _name, address _contract) internal {\n    require(_contract != address(0), \"0x0\");\n    bytes32 hashedName = keccak256(abi.encodePacked(_name));\n    Contract storage currentContract = globalContracts[hashedName];\n    require(currentContract.contractAddress == address(0), \"Contract exists\");\n    currentContract.contractAddress = _contract;\n    currentContract.index = contracts.length;\n    contracts.push(_name);\n    emit AddContract(hashedName, _contract);\n  }\n\n  function _removeContract(string memory _name) internal {\n    bytes32 hashedName = keccak256(abi.encodePacked(_name));\n    Contract storage currentContract = globalContracts[hashedName];\n    currentContract.contractAddress = address(0);\n    currentContract.index = 0;\n\n    uint256 index = currentContract.index;\n    string memory lastContract = contracts[contracts.length - 1];\n    contracts[index] = lastContract;\n    contracts.pop();\n    emit RemoveContract(hashedName);\n  }\n\n  function _updateContract(string memory _name, address _newContract) internal {\n    require(_newContract != address(0), \"0x0\");\n    bytes32 hashedName = keccak256(abi.encodePacked(_name));\n    Contract storage currentContract = globalContracts[hashedName];\n    currentContract.contractAddress = _newContract;\n    emit UpdateContract(hashedName, _newContract);\n  }\n}"
    }
  ]
}