{
  "Title": "[M-02] Incorrect balance computed in `getUsersConfirmedButNotSettledSynthBalance()`",
  "Content": "_Submitted by hack3r-0m and cmichel_\n\nConsider the following state:\n```solidity\nlong_synth_balace = 300;\nshort_synth_balace = 200;\n\nmarketUpdateIndex[1] = x;\nuserNextPrice_currentUpdateIndex = 0;\nuserNextPrice_syntheticToken_toShiftAwayFrom_marketSide[1][true] = 0;\nbatched_amountSyntheticToken_toShiftAwayFrom_marketSide[1][true] = 0;\n```\n\nUser calls `shiftPositionFromLongNextPrice(marketIndex=1, amountSyntheticTokensToShift=100)`\n\nThis results in following state changes:\n```solidity\nlong_synth_balace = 200;\nshort_synth_balace = 200;\nuserNextPrice_syntheticToken_toShiftAwayFrom_marketSide[1][true] = 100;\nbatched_amountSyntheticToken_toShiftAwayFrom_marketSide[1][true] = 100;\nuserNextPrice_currentUpdateIndex = x+1 ;\n```\n\nDue to some other transactions, oracle updates twice, and now the `marketUpdateIndex[1]` is x+2 and also updating price snapshots.\n\nWhen User calls `getUsersConfirmedButNotSettledSynthBalance(user, 1)`\n\ninitial condition:\n```solidity\nif (\n  userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&\n  userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex\n)\n```\nwill be true;\n[`LongShort.sol` L532](https://github.com/hack3r-0m/2021-08-floatcapital/blob/main/contracts/contracts/LongShort.sol#L532)\n```solidity\nsyntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex]\n```\n\nThis uses price of current x+2 th update while it should balance of accounting for price of x+1 th update.\n\n**[JasoonS (Float) confirmed and disagreed with severity](https://github.com/code-423n4/2021-08-floatcapital-findings/issues/142#issuecomment-897368280):**\n > Yes good spot.\n>\n> This function is view only, and is only used for view only purposes. The rest of the system will always operate correctly because it rather uses `_executeOutstandingNextPriceSettlements` than the `getUsersConfirmedButNotSettledSynthBalance`. Therefore I propose this as a **1 Low Risk** vulnerability.\n\n**[0xean (judge) (judge) commented](https://github.com/code-423n4/2021-08-floatcapital-findings/issues/142#issuecomment-905007960):**\n > I am going to align with the 2 (Med Risk) severity.  Reporting the incorrect position in a UI to a user could definitely lead unexpected loss of funds in a sharp market move where a user is intending on hedging elsewhere.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2021-08-floatcapital",
  "Code": [
    {
      "filename": "contracts/contracts/LongShort.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./interfaces/ITokenFactory.sol\";\nimport \"./interfaces/ISyntheticToken.sol\";\nimport \"./interfaces/IStaker.sol\";\nimport \"./interfaces/ILongShort.sol\";\nimport \"./interfaces/IYieldManager.sol\";\nimport \"./interfaces/IOracleManager.sol\";\n\n/**\n **** visit https://float.capital *****\n */\n\n/// @title Core logic of Float Protocal markets\n/// @author float.capital\n/// @notice visit https://float.capital for more info\n/// @dev All functions in this file are currently `virtual`. This is NOT to encourage inheritance.\n/// It is merely for convenince when unit testing.\n/// @custom:auditors This contract balances long and short sides.\ncontract LongShort is ILongShort, Initializable {\n  /*╔═════════════════════════════╗\n    ║          VARIABLES          ║\n    ╚═════════════════════════════╝*/\n\n  /* ══════ Fixed-precision constants ══════ */\n  /// @notice this is the address that permanently locked initial liquidity for markets is held by.\n  /// These tokens will never move so market can never have zero liquidity on a side.\n  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.\n  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;\n\n  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:\n  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361\n  uint256[45] private __constantsGap;\n\n  /* ══════ Global state ══════ */\n  address public admin;\n  address public treasury;\n  uint32 public latestMarket;\n\n  address public staker;\n  address public tokenFactory;\n  uint256[45] private __globalStateGap;\n\n  /* ══════ Market specific ══════ */\n  mapping(uint32 => bool) public marketExists;\n  mapping(uint32 => uint256) public assetPrice;\n  mapping(uint32 => uint256) public marketUpdateIndex;\n  mapping(uint32 => address) public paymentTokens;\n  mapping(uint32 => address) public yieldManagers;\n  mapping(uint32 => address) public oracleManagers;\n  mapping(uint32 => uint256) public marketTreasurySplitGradient_e18; // (0 < value < 1e18)\n\n  /* ══════ Market + position (long/short) specific ══════ */\n  mapping(uint32 => mapping(bool => address)) public syntheticTokens;\n  mapping(uint32 => mapping(bool => uint256)) public marketSideValueInPaymentToken;\n\n  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update\n  mapping(uint32 => mapping(bool => mapping(uint256 => uint256))) public syntheticToken_priceSnapshot;\n\n  mapping(uint32 => mapping(bool => uint256)) public batched_amountPaymentToken_deposit;\n  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_redeem;\n  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;\n\n  /* ══════ User specific ══════ */\n  mapping(uint32 => mapping(address => uint256)) public userNextPrice_currentUpdateIndex;\n\n  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_paymentToken_depositAmount;\n  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_syntheticToken_redeemAmount;\n  mapping(uint32 => mapping(bool => mapping(address => uint256)))\n    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;\n\n  /*╔════════════════════════════╗\n    ║           EVENTS           ║\n    ╚════════════════════════════╝*/\n\n  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);\n\n  event SystemStateUpdated(\n    uint32 marketIndex,\n    uint256 updateIndex,\n    int256 underlyingAssetPrice,\n    uint256 longValue,\n    uint256 shortValue,\n    uint256 longPrice,\n    uint256 shortPrice\n  );\n\n  event SyntheticMarketCreated(\n    uint32 marketIndex,\n    address longTokenAddress,\n    address shortTokenAddress,\n    address paymentToken,\n    uint256 initialAssetPrice,\n    string name,\n    string symbol,\n    address oracleAddress,\n    address yieldManagerAddress\n  );\n\n  event NextPriceRedeem(\n    uint32 marketIndex,\n    bool isLong,\n    uint256 synthRedeemed,\n    address user,\n    uint256 oracleUpdateIndex\n  );\n\n  event NextPriceSyntheticPositionShift(\n    uint32 marketIndex,\n    bool isShiftFromLong,\n    uint256 synthShifted,\n    address user,\n    uint256 oracleUpdateIndex\n  );\n\n  event NextPriceDeposit(\n    uint32 marketIndex,\n    bool isLong,\n    uint256 depositAdded,\n    address user,\n    uint256 oracleUpdateIndex\n  );\n\n  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);\n\n  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);\n\n  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);\n\n  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);\n\n  event ExecuteNextPriceMarketSideShiftSettlementUser(\n    address user,\n    uint32 marketIndex,\n    bool isShiftFromLong,\n    uint256 amount\n  );\n\n  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);\n\n  /*╔═════════════════════════════╗\n    ║          MODIFIERS          ║\n    ╚═════════════════════════════╝*/\n\n  function adminOnlyModifierLogic() internal virtual {\n    require(msg.sender == admin, \"only admin\");\n  }\n\n  modifier adminOnly() {\n    adminOnlyModifierLogic();\n    _;\n  }\n\n  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {\n    require(marketExists[marketIndex], \"market doesn't exist\");\n  }\n\n  modifier requireMarketExists(uint32 marketIndex) {\n    requireMarketExistsModifierLogic(marketIndex);\n    _;\n  }\n\n  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {\n    _executeOutstandingNextPriceSettlements(user, marketIndex);\n    _;\n  }\n\n  modifier updateSystemStateMarket(uint32 marketIndex) {\n    _updateSystemStateInternal(marketIndex);\n    _;\n  }\n\n  /*╔═════════════════════════════╗\n    ║       CONTRACT SET-UP       ║\n    ╚═════════════════════════════╝*/\n\n  /// @notice Initializes the contract.\n  /// @dev Calls OpenZeppelin's initializer modifier.\n  /// @param _admin Address of the admin role.\n  /// @param _treasury Address of the treasury.\n  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.\n  /// @param _staker Address of the contract which handles synthetic asset stakes.\n  function initialize(\n    address _admin,\n    address _treasury,\n    address _tokenFactory,\n    address _staker\n  ) external virtual initializer {\n    admin = _admin;\n    treasury = _treasury;\n    tokenFactory = _tokenFactory;\n    staker = _staker;\n\n    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);\n  }\n\n  /*╔═══════════════════╗\n    ║       ADMIN       ║\n    ╚═══════════════════╝*/\n\n  /// @notice Changes the admin address for this contract.\n  /// @dev Can only be called by the current admin.\n  /// @param _admin Address of the new admin.\n  function changeAdmin(address _admin) external adminOnly {\n    admin = _admin;\n  }\n\n  /// @notice Changes the treasury contract address for this contract.\n  /// @dev Can only be called by the current admin.\n  /// @param _treasury Address of the treasury contract\n  function changeTreasury(address _treasury) external adminOnly {\n    treasury = _treasury;\n  }\n\n  /// @notice Update oracle for a market\n  /// @dev Can only be called by the current admin.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param _newOracleManager Address of the replacement oracle manager.\n  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {\n    // If not a oracle contract this would break things.. Test's arn't validating this\n    // Ie require isOracle interface - ERC165\n    address previousOracleManager = oracleManagers[marketIndex];\n    oracleManagers[marketIndex] = _newOracleManager;\n    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);\n  }\n\n  /// @notice changes the gradient of the line for determining the yield split between market and treasury.\n  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)\n    external\n    adminOnly\n  {\n    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;\n  }\n\n  /*╔═════════════════════════════╗\n    ║       MARKET CREATION       ║\n    ╚═════════════════════════════╝*/\n\n  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.\n  ///  Make sure the synthetic names/symbols are unique.\n  /// @dev This does not make the market active.\n  /// The `initializeMarket` function was split out separately to this function to reduce costs.\n  /// @param syntheticName Name of the synthetic asset\n  /// @param syntheticSymbol Symbol for the synthetic asset\n  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset\n  /// this will likely always be DAI\n  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market\n  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol\n  function createNewSyntheticMarket(\n    string calldata syntheticName,\n    string calldata syntheticSymbol,\n    address _paymentToken,\n    address _oracleManager,\n    address _yieldManager\n  ) external adminOnly {\n    latestMarket++;\n\n    // Create new synthetic long token.\n    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(\n      string(abi.encodePacked(\"Float Up \", syntheticName)),\n      string(abi.encodePacked(\"fu\", syntheticSymbol)),\n      staker,\n      latestMarket,\n      true\n    );\n\n    // Create new synthetic short token.\n    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(\n      string(abi.encodePacked(\"Float Down \", syntheticName)),\n      string(abi.encodePacked(\"fd\", syntheticSymbol)),\n      staker,\n      latestMarket,\n      false\n    );\n\n    // Initial market state.\n    paymentTokens[latestMarket] = _paymentToken;\n    yieldManagers[latestMarket] = _yieldManager;\n    oracleManagers[latestMarket] = _oracleManager;\n    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());\n\n    emit SyntheticMarketCreated(\n      latestMarket,\n      syntheticTokens[latestMarket][true],\n      syntheticTokens[latestMarket][false],\n      _paymentToken,\n      assetPrice[latestMarket],\n      syntheticName,\n      syntheticSymbol,\n      _oracleManager,\n      _yieldManager\n    );\n  }\n\n  /// @notice Seeds a new market with initial capital.\n  /// @dev Only called when initializing a market.\n  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {\n    require(\n      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.\n      initialMarketSeedForEachMarketSide >= 1e18,\n      \"Insufficient market seed\"\n    );\n\n    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;\n    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);\n    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);\n\n    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(\n      PERMANENT_INITIAL_LIQUIDITY_HOLDER,\n      initialMarketSeedForEachMarketSide\n    );\n    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(\n      PERMANENT_INITIAL_LIQUIDITY_HOLDER,\n      initialMarketSeedForEachMarketSide\n    );\n\n    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;\n    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;\n\n    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);\n  }\n\n  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.\n  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.\n  /// @param marketIndex An int32 which uniquely identifies the market.\n  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.\n  /// @param kPeriod Time which kInitialMultiplier will last\n  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.\n  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs\n  /// for market sides in unbalanced markets. See Staker.sol\n  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets\n  /// when Float token issuance should differ for market sides. See Staker.sol\n  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.\n  function initializeMarket(\n    uint32 marketIndex,\n    uint256 kInitialMultiplier,\n    uint256 kPeriod,\n    uint256 unstakeFee_e18,\n    uint256 initialMarketSeedForEachMarketSide,\n    uint256 balanceIncentiveCurve_exponent,\n    int256 balanceIncentiveCurve_equilibriumOffset,\n    uint256 _marketTreasurySplitGradient_e18\n  ) external adminOnly {\n    require(!marketExists[marketIndex], \"already initialized\");\n    require(marketIndex <= latestMarket, \"index too high\");\n\n    marketExists[marketIndex] = true;\n\n    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;\n\n    // Set this value to one initially - 0 is a null value and thus potentially bug prone.\n    marketUpdateIndex[marketIndex] = 1;\n\n    // Add new staker funds with fresh synthetic tokens.\n    IStaker(staker).addNewStakingFund(\n      latestMarket,\n      syntheticTokens[latestMarket][true],\n      syntheticTokens[latestMarket][false],\n      kInitialMultiplier,\n      kPeriod,\n      unstakeFee_e18,\n      balanceIncentiveCurve_exponent,\n      balanceIncentiveCurve_equilibriumOffset\n    );\n\n    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);\n  }\n\n  /*╔══════════════════════════════╗\n    ║       GETTER FUNCTIONS       ║\n    ╚══════════════════════════════╝*/\n\n  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.\n  /// @param a Any uint256\n  /// @param b Any uint256\n  /// @return min The minimum of the 2 parameters.\n  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {\n    if (a > b) {\n      return b;\n    } else {\n      return a;\n    }\n  }\n\n  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.\n  /// @dev Synth tokens have a fixed 18 decimals.\n  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.\n  /// @param amountSyntheticToken Amount of synth token in wei.\n  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.\n  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)\n    internal\n    pure\n    virtual\n    returns (uint256 syntheticTokenPrice)\n  {\n    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;\n  }\n\n  /// @notice Converts synth token amounts to payment token amounts at a synth token price.\n  /// @dev Price assumed base 1e18.\n  /// @param amountSyntheticToken Amount of synth token in wei.\n  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.\n  /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.\n  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)\n    internal\n    pure\n    virtual\n    returns (uint256 amountPaymentToken)\n  {\n    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;\n  }\n\n  /// @notice Converts payment token amounts to synth token amounts at a synth token price.\n  /// @dev  Price assumed base 1e18.\n  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.\n  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.\n  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.\n  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)\n    internal\n    pure\n    virtual\n    returns (uint256 amountSyntheticToken)\n  {\n    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;\n  }\n\n  /**\n  @notice Calculate the amount of target side synthetic tokens that are worth the same\n          amount of payment tokens as X many synthetic tokens on origin side.\n          The resulting equation comes from simplifying this function\n\n            _getAmountSyntheticToken(\n              _getAmountPaymentToken(\n                amountOriginSynth,\n                priceOriginSynth\n              ),\n              priceTargetSynth)\n\n            Unpacking the function we get:\n            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth\n              And simplifying this we get:\n            (amountOriginSynth * priceOriginSynth) / priceTargetSynth\n  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side\n  @param syntheticTokenPrice_originSide Price of origin side's synthetic token\n  @param syntheticTokenPrice_targetSide Price of target side's synthetic token\n  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side\n  */\n  function _getEquivalentAmountSyntheticTokensOnTargetSide(\n    uint256 amountSyntheticTokens_originSide,\n    uint256 syntheticTokenPrice_originSide,\n    uint256 syntheticTokenPrice_targetSide\n  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {\n    equivalentAmountSyntheticTokensOnTargetSide =\n      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /\n      syntheticTokenPrice_targetSide;\n  }\n\n  /// @notice Given an executed next price shift from tokens on one market side to the other,\n  /// determines how many other side tokens the shift was worth.\n  /// @dev Intended for use primarily by Staker.sol\n  /// @param marketIndex An uint32 which uniquely identifies a market.\n  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.\n  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).\n  /// @param priceSnapshotIndex Index which identifies which synth prices to use.\n  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.\n  function getAmountSyntheticTokenToMintOnTargetSide(\n    uint32 marketIndex,\n    uint256 amountSyntheticToken_redeemOnOriginSide,\n    bool isShiftFromLong,\n    uint256 priceSnapshotIndex\n  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {\n    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][\n      priceSnapshotIndex\n    ];\n    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][\n      priceSnapshotIndex\n    ];\n\n    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(\n      amountSyntheticToken_redeemOnOriginSide,\n      syntheticTokenPriceOnOriginSide,\n      syntheticTokenPriceOnTargetSide\n    );\n  }\n\n  /**\n  @notice The amount of a synth token a user is owed following a batch execution.\n    4 possible states for next price actions:\n        - \"Pending\" - means the next price update hasn't happened or been enacted on by the updateSystemState function.\n        - \"Confirmed\" - means the next price has been updated by the updateSystemState function. There is still\n        -               outstanding (lazy) computation that needs to be executed per user in the batch.\n        - \"Settled\" - there is no more computation left for the user.\n        - \"Non-existant\" - user has no next price actions.\n    This function returns a calculated value only in the case of 'confirmed' next price actions.\n    It should return zero for all other types of next price actions.\n  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.\n  @param user The address of the user for whom to execute the function for.\n  @param marketIndex An int32 which uniquely identifies a market.\n  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.\n  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.\n  */\n  function getUsersConfirmedButNotSettledSynthBalance(\n    address user,\n    uint32 marketIndex,\n    bool isLong\n  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {\n    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];\n    if (\n      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&\n      userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex\n    ) {\n      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];\n\n      if (amountPaymentTokenDeposited > 0) {\n        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];\n\n        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);\n      }\n\n\n        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide\n       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];\n\n      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide > 0) {\n        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][\n          currentMarketUpdateIndex\n        ];\n        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][\n          currentMarketUpdateIndex\n        ];\n\n        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(\n          amountSyntheticTokensToBeShiftedAwayFromOriginSide,\n          syntheticTokenPriceOnOriginSide,\n          syntheticTokenPriceOnTargetSide\n        );\n      }\n    }\n  }\n\n  /**\n   @notice Calculates the percentage in base 1e18 of how much of the accrued yield\n   for a market should be allocated to treasury.\n   @dev For gas considerations also returns whether the long side is imbalanced.\n   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function\n   calling this function has pre calculated the value\n   @param longValue The current total payment token value of the long side of the market.\n   @param shortValue The current total payment token value of the short side of the market.\n   @param totalValueLockedInMarket Total payment token value of both sides of the market.\n   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.\n   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield\n   for a market should be allocated to treasury.\n   */\n  function _getYieldSplit(\n    uint32 marketIndex,\n    uint256 longValue,\n    uint256 shortValue,\n    uint256 totalValueLockedInMarket\n  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {\n    isLongSideUnderbalanced = longValue < shortValue;\n    uint256 imbalance;\n\n    if (isLongSideUnderbalanced) {\n      imbalance = shortValue - longValue;\n    } else {\n      imbalance = longValue - shortValue;\n    }\n\n    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given\n    // to the market at a desired rate e.g. if a market tends to become imbalanced\n    // frequently then the gradient can be increased to funnel yield to the market\n    // quicker.\n    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x\n    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b\n    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /\n      totalValueLockedInMarket;\n\n    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);\n\n    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;\n  }\n\n  /*╔══════════════════════════════╗\n    ║       HELPER FUNCTIONS       ║\n    ╚══════════════════════════════╝*/\n\n  /// @notice First gets yield from the yield manager and allocates it to market and treasury.\n  /// It then allocates the full market yield portion to the underbalanced side of the market.\n  /// NB this function also adjusts the value of the long and short side based on the latest\n  /// price of the underlying asset received from the oracle. This function should ideally be\n  /// called everytime there is an price update from the oracle. We have built a bot that does this.\n  /// The system is still perectly safe if not called every price update, the synthetic will just\n  /// less closely track the underlying asset.\n  /// @dev In one function as yield should be allocated before rebalancing.\n  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.\n  /// @param marketIndex The market for which to execute the function for.\n  /// @param newAssetPrice The new asset price.\n  /// @param oldAssetPrice The old asset price.\n  /// @return longValue The value of the long side after rebalancing.\n  /// @return shortValue The value of the short side after rebalancing.\n  function _claimAndDistributeYieldThenRebalanceMarket(\n    uint32 marketIndex,\n    int256 newAssetPrice,\n    int256 oldAssetPrice\n  ) internal virtual returns (uint256 longValue, uint256 shortValue) {\n    // Claiming and distributing the yield\n    longValue = marketSideValueInPaymentToken[marketIndex][true];\n    shortValue = marketSideValueInPaymentToken[marketIndex][false];\n    uint256 totalValueLockedInMarket = longValue + shortValue;\n\n    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(\n      marketIndex,\n      longValue,\n      shortValue,\n      totalValueLockedInMarket\n    );\n\n    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])\n    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);\n\n    if (marketAmount > 0) {\n      if (isLongSideUnderbalanced) {\n        longValue += marketAmount;\n      } else {\n        shortValue += marketAmount;\n      }\n    }\n\n    // Adjusting value of long and short pool based on price movement\n    // The side/position with less liquidity has 100% percent exposure to the price movement.\n    // The side/position with more liquidity will have exposure < 100% to the price movement.\n    // I.e. Imagine $100 in longValue and $50 shortValue\n    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.\n    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then\n    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.\n    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));\n\n    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE\n    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq\n    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;\n\n    if (valueChange > 0) {\n      longValue += uint256(valueChange);\n      shortValue -= uint256(valueChange);\n    } else {\n      longValue -= uint256(-valueChange);\n      shortValue += uint256(-valueChange);\n    }\n  }\n\n  /*╔═══════════════════════════════╗\n    ║     UPDATING SYSTEM STATE     ║\n    ╚═══════════════════════════════╝*/\n\n  /// @notice Updates the value of the long and short sides to account for latest oracle price updates\n  /// and batches all next price actions.\n  /// @dev To prevent front-running only executes on price change from an oracle.\n  /// We assume the function will be called for each market at least once per price update.\n  /// Note Even if not called on every price update, this won't affect security, it will only affect how closely\n  /// the synthetic asset actually tracks the underlying asset.\n  /// @param marketIndex The market index for which to update.\n  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {\n    // If a negative int is return this should fail.\n    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();\n    int256 oldAssetPrice = int256(assetPrice[marketIndex]);\n\n    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;\n\n    if (assetPriceHasChanged || msg.sender == staker) {\n      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][\n        marketUpdateIndex[marketIndex]\n      ];\n      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][\n        marketUpdateIndex[marketIndex]\n      ];\n      // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker\n      // (so the staker can handle its internal accounting)\n      if (\n        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &&\n        assetPriceHasChanged\n      ) {\n        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n          marketIndex,\n          syntheticTokenPrice_inPaymentTokens_long,\n          syntheticTokenPrice_inPaymentTokens_short,\n          marketSideValueInPaymentToken[marketIndex][true],\n          marketSideValueInPaymentToken[marketIndex][false],\n          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)\n          userNextPrice_currentUpdateIndex[marketIndex][staker]\n        );\n      } else {\n        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n          marketIndex,\n          syntheticTokenPrice_inPaymentTokens_long,\n          syntheticTokenPrice_inPaymentTokens_short,\n          marketSideValueInPaymentToken[marketIndex][true],\n          marketSideValueInPaymentToken[marketIndex][false],\n          0\n        );\n      }\n\n      // function will return here if the staker called this simply for the\n      // purpose of adding a state point required in staker.sol for our rewards calculation\n      if (!assetPriceHasChanged) {\n        return;\n      }\n\n      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(\n        marketIndex,\n        newAssetPrice,\n        oldAssetPrice\n      );\n\n      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(\n        newLongPoolValue,\n        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()\n      );\n      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(\n        newShortPoolValue,\n        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()\n      );\n\n      assetPrice[marketIndex] = uint256(newAssetPrice);\n      marketUpdateIndex[marketIndex] += 1;\n\n      syntheticToken_priceSnapshot[marketIndex][true][\n        marketUpdateIndex[marketIndex]\n      ] = syntheticTokenPrice_inPaymentTokens_long;\n\n      syntheticToken_priceSnapshot[marketIndex][false][\n        marketUpdateIndex[marketIndex]\n      ] = syntheticTokenPrice_inPaymentTokens_short;\n\n      (\n        int256 long_changeInMarketValue_inPaymentToken,\n        int256 short_changeInMarketValue_inPaymentToken\n      ) = _batchConfirmOutstandingPendingActions(\n        marketIndex,\n        syntheticTokenPrice_inPaymentTokens_long,\n        syntheticTokenPrice_inPaymentTokens_short\n      );\n\n      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);\n      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);\n      marketSideValueInPaymentToke"
    }
  ]
}