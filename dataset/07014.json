{
  "Title": "[M-13] Function `stabilize()` might always revert because of overflow since Malt contract use solidity 0.8",
  "Content": "\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L161> \n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/DataFeed/MaltDataLab.sol#L326>\n\n### Impact\n\nMaltDataLab fetched `priceCumulative` directly from Uniswap V2 pool to calculate price of Malt token. However, it is noticed that Uniswap V2 pool use Solidity 0.5.16, which does not revert when overflow happen. In addition, it is actually commented in Uniswap code that\n\n> *   never overflows, and + overflow is desired\n\n<https://github.com/Uniswap/v2-core/blob/ee547b17853e71ed4e0101ccfd52e70d5acded58/contracts/UniswapV2Pair.sol#L77-L81>\n\n```solidity\nif (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n    // * never overflows, and + overflow is desired\n    price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\n    price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\n}\n```\n\nHowever, MaltDataLab contracts use Solidity 0.8 and will revert when overflow. It will break the `stabilize()` function and always revert since `stabilize()` call to MaltDataLab contract to get state.\n\nPlease note that, with Solidity 0.5.16, when result of addition bigger than `max(uint256)`, it will overflow without any errors. For example, `max(uint256) + 2 = 1`.\n\nSo when `price0CumulativeLast` is overflow, the new value of `price0CumulativeLast` will be smaller than old value. As the result, when MaltDataLab doing a subtraction to calculate current price, it might get revert.\n\n### Proof of Concept\n\nFunction `stabilize()` will call to `MaltDataLab.trackPool()` first:\n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L163>\n\n```solidity\nfunction stabilize() external nonReentrant onlyEOA onlyActive whenNotPaused {\n    // Ensure data consistency\n    maltDataLab.trackPool();\n    ...\n}\n```\n\nFunction `trackPool()` used a formula that will revert when `priceCumulative` overflow in Uniswap pool. \n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/DataFeed/MaltDataLab.sol#L323-L329>\n\n```solidity\nprice = FixedPoint\n    .uq112x112(\n      uint224(  \n        // @audit might overflow with solidity 0.8.0\n        (priceCumulative - maltPriceCumulativeLast) / \n          (blockTimestampLast - maltPriceTimestampLast)\n      )\n    )\n```\n\nScenario:\n\n1.  `maltPriceCumulativeLast = max(uint256 - 10)` and `price = 10, timeElapsed = 10`. So the new `priceCumulative = max(uint256 - 10) + 10 * 10 = 99 (overflow)`\n\n2.  When doing calculation in Malt protocol, `priceCumulative < maltPriceCumulativeLast`, so `priceCumulative - maltPriceCumulativeLast` will revert and fail\n\n### Recommended Mitigation Steps\n\nConsider using `unchecked` block to match handle overflow calculation in Uniswap V2.\n\n**[0xScotch (Malt) confirmed](https://github.com/code-423n4/2023-02-malt-findings/issues/15)**\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-02-malt-protocol-versus-contest",
  "Code": [
    {
      "filename": "contracts/StabilityPod/StabilizerNode.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport \"openzeppelin/token/ERC20/ERC20.sol\";\nimport \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin/security/Pausable.sol\";\n\nimport \"../StabilizedPoolExtensions/StabilizedPoolUnit.sol\";\nimport \"../StabilizedPoolExtensions/AuctionExtension.sol\";\nimport \"../StabilizedPoolExtensions/DexHandlerExtension.sol\";\nimport \"../StabilizedPoolExtensions/DataLabExtension.sol\";\nimport \"../StabilizedPoolExtensions/ProfitDistributorExtension.sol\";\nimport \"../StabilizedPoolExtensions/SwingTraderManagerExtension.sol\";\nimport \"../StabilizedPoolExtensions/ImpliedCollateralServiceExtension.sol\";\nimport \"../interfaces/IAuction.sol\";\nimport \"../interfaces/IMaltDataLab.sol\";\nimport \"../interfaces/ITimekeeper.sol\";\nimport \"../interfaces/IRewardThrottle.sol\";\nimport \"../interfaces/IImpliedCollateralService.sol\";\nimport \"../interfaces/IDexHandler.sol\";\nimport \"../interfaces/ISwingTrader.sol\";\nimport \"../interfaces/IBurnMintableERC20.sol\";\nimport \"../interfaces/ISupplyDistributionController.sol\";\nimport \"../interfaces/IAuctionStartController.sol\";\nimport \"../interfaces/IProfitDistributor.sol\";\nimport \"../interfaces/IGlobalImpliedCollateralService.sol\";\n\n/// @title Stabilizer Node\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The backbone of the Malt stability system. In charge of triggering actions to stabilize price\ncontract StabilizerNode is\n  StabilizedPoolUnit,\n  AuctionExtension,\n  DexHandlerExtension,\n  DataLabExtension,\n  ProfitDistributorExtension,\n  SwingTraderManagerExtension,\n  ImpliedCollateralServiceExtension,\n  Pausable\n{\n  using SafeERC20 for ERC20;\n\n  uint256 internal stabilizeWindowEnd;\n  uint256 public stabilizeBackoffPeriod = 5 * 60; // 5 minutes\n  uint256 public upperStabilityThresholdBps = 100; // 1%\n  uint256 public lowerStabilityThresholdBps = 100;\n  uint256 public priceAveragePeriod = 5 minutes;\n  uint256 public fastAveragePeriod = 30; // 30 seconds\n  uint256 public overrideDistanceBps = 200; // 2%\n  uint256 public callerRewardCutBps = 30; // 0.3%\n\n  uint256 public expansionDampingFactor = 1;\n\n  uint256 public defaultIncentive = 100; // in Malt\n  uint256 public trackingIncentive = 20; // in 100ths of a Malt\n\n  uint256 public upperBandLimitBps = 100000; // 1000%\n  uint256 public lowerBandLimitBps = 1000; // 10%\n  uint256 public sampleSlippageBps = 2000; // 20%\n  uint256 public skipAuctionThreshold;\n  uint256 public preferAuctionThreshold;\n\n  uint256 public lastStabilize;\n  uint256 public lastTracking;\n  uint256 public trackingBackoff = 30; // 30 seconds\n  uint256 public primedBlock;\n  uint256 public primedWindow = 10; // blocks\n\n  bool internal trackAfterStabilize = true;\n  bool public onlyStabilizeToPeg = false;\n  bool public usePrimedWindow;\n\n  address public supplyDistributionController;\n  address public auctionStartController;\n\n  event MintMalt(uint256 amount);\n  event Stabilize(uint256 timestamp, uint256 exchangeRate);\n  event SetStabilizeBackoff(uint256 period);\n  event SetDefaultIncentive(uint256 incentive);\n  event SetTrackingIncentive(uint256 incentive);\n  event SetExpansionDamping(uint256 amount);\n  event SetPriceAveragePeriod(uint256 period);\n  event SetOverrideDistance(uint256 distance);\n  event SetFastAveragePeriod(uint256 period);\n  event SetStabilityThresholds(uint256 upper, uint256 lower);\n  event SetSupplyDistributionController(address _controller);\n  event SetAuctionStartController(address _controller);\n  event SetBandLimits(uint256 _upper, uint256 _lower);\n  event SetSlippageBps(uint256 _slippageBps);\n  event SetSkipAuctionThreshold(uint256 _skipAuctionThreshold);\n  event SetEmergencyMintThresholdBps(uint256 thresholdBps);\n  event Tracking();\n  event SetTrackingBackoff(uint256 backoff);\n  event SetCallerCut(uint256 callerCutBps);\n  event SetPreferAuctionThreshold(uint256 preferAuctionThreshold);\n  event SetTrackAfterStabilize(bool track);\n  event SetOnlyStabilizeToPeg(bool stabilize);\n  event SetPrimedWindow(uint256 primedWindow);\n  event SetUsePrimedWindow(bool usePrimedWindow);\n\n  constructor(\n    address timelock,\n    address repository,\n    address poolFactory,\n    uint256 _skipAuctionThreshold,\n    uint256 _preferAuctionThreshold\n  ) StabilizedPoolUnit(timelock, repository, poolFactory) {\n    skipAuctionThreshold = _skipAuctionThreshold;\n    preferAuctionThreshold = _preferAuctionThreshold;\n\n    lastStabilize = block.timestamp;\n  }\n\n  function setupContracts(\n    address _malt,\n    address _collateralToken,\n    address _dexHandler,\n    address _maltDataLab,\n    address _impliedCollateralService,\n    address _auction,\n    address _swingTraderManager,\n    address _profitDistributor,\n    address pool\n  ) external onlyRoleMalt(POOL_FACTORY_ROLE, \"Must have pool factory role\") {\n    require(!contractActive, \"StabilizerNode: Already setup\");\n    require(_malt != address(0), \"StabilizerNode: Malt addr(0)\");\n    require(_collateralToken != address(0), \"StabilizerNode: Col addr(0)\");\n    require(_dexHandler != address(0), \"StabilizerNode: DexHandler addr(0)\");\n    require(_maltDataLab != address(0), \"StabilizerNode: DataLab addr(0)\");\n    require(\n      _swingTraderManager != address(0),\n      \"StabilizerNode: Swing Manager addr(0)\"\n    );\n    require(\n      _impliedCollateralService != address(0),\n      \"StabilizerNode: ImpCol addr(0)\"\n    );\n    require(_auction != address(0), \"StabilizerNode: Auction addr(0)\");\n    require(\n      _profitDistributor != address(0),\n      \"StabilizerNode: ProfitDistributor addr(0)\"\n    );\n\n    contractActive = true;\n\n    collateralToken = ERC20(_collateralToken);\n    malt = IBurnMintableERC20(_malt);\n    dexHandler = IDexHandler(_dexHandler);\n    maltDataLab = IMaltDataLab(_maltDataLab);\n    swingTraderManager = ISwingTrader(_swingTraderManager);\n    impliedCollateralService = IImpliedCollateralService(\n      _impliedCollateralService\n    );\n    auction = IAuction(_auction);\n    profitDistributor = IProfitDistributor(_profitDistributor);\n\n    (, address updater, ) = poolFactory.getPool(pool);\n    _setPoolUpdater(updater);\n  }\n\n  function stabilize() external nonReentrant onlyEOA onlyActive whenNotPaused {\n    // Ensure data consistency\n    maltDataLab.trackPool();\n\n    // Finalize auction if possible before potentially starting a new one\n    auction.checkAuctionFinalization();\n\n    require(\n      block.timestamp >= stabilizeWindowEnd || _stabilityWindowOverride(),\n      \"Can't call stabilize\"\n    );\n    stabilizeWindowEnd = block.timestamp + stabilizeBackoffPeriod;\n\n    // used in 3 location.\n    uint256 exchangeRate = maltDataLab.maltPriceAverage(priceAveragePeriod);\n    bool stabilizeToPeg = onlyStabilizeToPeg; // gas\n\n    if (!_shouldAdjustSupply(exchangeRate, stabilizeToPeg)) {\n      lastStabilize = block.timestamp;\n      impliedCollateralService.syncGlobalCollateral();\n      return;\n    }\n\n    emit Stabilize(block.timestamp, exchangeRate);\n\n    (uint256 livePrice, ) = dexHandler.maltMarketPrice();\n\n    uint256 priceTarget = maltDataLab.getActualPriceTarget();\n    // The upper and lower bands here avoid any issues with price\n    // descrepency between the TWAP and live market price.\n    // This avoids starting auctions too quickly into a big selloff\n    // and also reduces risk of flashloan vectors\n    address sender = _msgSender();\n    if (exchangeRate > priceTarget) {\n      if (\n        !hasRole(ADMIN_ROLE, sender) &&\n        !hasRole(INTERNAL_WHITELIST_ROLE, sender)\n      ) {\n        uint256 upperBand = exchangeRate +\n          ((exchangeRate * upperBandLimitBps) / 10000);\n        uint256 latestSample = maltDataLab.maltPriceAverage(0);\n        uint256 minThreshold = latestSample -\n          (((latestSample - priceTarget) * sampleSlippageBps) / 10000);\n\n        require(livePrice < upperBand, \"Stabilize: Beyond upper bound\");\n        require(livePrice > minThreshold, \"Stabilize: Slippage threshold\");\n      }\n\n      _distributeSupply(livePrice, priceTarget, stabilizeToPeg);\n    } else {\n      if (\n        !hasRole(ADMIN_ROLE, sender) &&\n        !hasRole(INTERNAL_WHITELIST_ROLE, sender)\n      ) {\n        uint256 lowerBand = exchangeRate -\n          ((exchangeRate * lowerBandLimitBps) / 10000);\n        require(livePrice > lowerBand, \"Stabilize: Beyond lower bound\");\n      }\n\n      uint256 stEntryPrice = maltDataLab.getSwingTraderEntryPrice();\n      if (exchangeRate <= stEntryPrice) {\n        if (_validateSwingTraderTrigger(livePrice, stEntryPrice)) {\n          // Reset primedBlock\n          primedBlock = 0;\n          _triggerSwingTrader(priceTarget, livePrice);\n        }\n      } else {\n        _startAuction(priceTarget);\n      }\n    }\n\n    if (trackAfterStabilize) {\n      maltDataLab.trackPool();\n    }\n    impliedCollateralService.syncGlobalCollateral();\n    lastStabilize = block.timestamp;\n  }\n\n  function endAuctionEarly() external onlyActive whenNotPaused {\n    // This call reverts if the auction isn't ended\n    auction.endAuctionEarly();\n\n    // It hasn't reverted so the auction was ended. Pay the incentive\n    malt.mint(msg.sender, defaultIncentive * (10**malt.decimals()));\n    emit MintMalt(defaultIncentive * (10**malt.decimals()));\n  }\n\n  function trackPool() external onlyActive {\n    require(block.timestamp >= lastTracking + trackingBackoff, \"Too early\");\n    bool success = maltDataLab.trackPool();\n    require(success, \"Too early\");\n    malt.mint(msg.sender, (trackingIncentive * (10**malt.decimals())) / 100); // div 100 because units are cents\n    lastTracking = block.timestamp;\n    emit Tracking();\n  }\n\n  function primedWindowData() public view returns (bool, uint256) {\n    return (usePrimedWindow, primedBlock + primedWindow);\n  }\n\n  /*\n   * INTERNAL VIEW FUNCTIONS\n   */\n  function _stabilityWindowOverride() internal view returns (bool) {\n    address sender = _msgSender();\n    if (\n      hasRole(ADMIN_ROLE, sender) || hasRole(INTERNAL_WHITELIST_ROLE, sender)\n    ) {\n      // Admin can always stabilize\n      return true;\n    }\n    // Must have elapsed at least one period of the moving average before we stabilize again\n    if (block.timestamp < lastStabilize + fastAveragePeriod) {\n      return false;\n    }\n\n    uint256 priceTarget = maltDataLab.getActualPriceTarget();\n    uint256 exchangeRate = maltDataLab.maltPriceAverage(fastAveragePeriod);\n\n    uint256 upperThreshold = (priceTarget * (10000 + overrideDistanceBps)) /\n      10000;\n\n    return exchangeRate >= upperThreshold;\n  }\n\n  function _shouldAdjustSupply(uint256 exchangeRate, bool stabilizeToPeg)\n    internal\n    view\n    returns (bool)\n  {\n    uint256 decimals = collateralToken.decimals();\n    uint256 priceTarget;\n\n    if (stabilizeToPeg) {\n      priceTarget = maltDataLab.priceTarget();\n    } else {\n      priceTarget = maltDataLab.getActualPriceTarget();\n    }\n\n    uint256 upperThreshold = (priceTarget * upperStabilityThresholdBps) / 10000;\n    uint256 lowerThreshold = (priceTarget * lowerStabilityThresholdBps) / 10000;\n\n    return\n      (exchangeRate <= (priceTarget - lowerThreshold) &&\n        !auction.auctionExists(auction.currentAuctionId())) ||\n      exchangeRate >= (priceTarget + upperThreshold);\n  }\n\n  /*\n   * INTERNAL FUNCTIONS\n   */\n  function _validateSwingTraderTrigger(uint256 livePrice, uint256 entryPrice)\n    internal\n    returns (bool)\n  {\n    if (usePrimedWindow) {\n      if (livePrice > entryPrice) {\n        return false;\n      }\n\n      if (block.number > primedBlock + primedWindow) {\n        primedBlock = block.number;\n        malt.mint(msg.sender, defaultIncentive * (10**malt.decimals()));\n        emit MintMalt(defaultIncentive * (10**malt.decimals()));\n        return false;\n      }\n\n      if (primedBlock == block.number) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function _triggerSwingTrader(uint256 priceTarget, uint256 exchangeRate)\n    internal\n  {\n    uint256 decimals = collateralToken.decimals();\n    uint256 unity = 10**decimals;\n    IGlobalImpliedCollateralService globalIC = maltDataLab.globalIC();\n    uint256 icTotal = maltDataLab.maltToRewardDecimals(\n      globalIC.collateralRatio()\n    );\n\n    if (icTotal >= unity) {\n      icTotal = unity;\n    }\n\n    uint256 originalPriceTarget = priceTarget;\n\n    // TODO StabilizerNode.sol these checks won't work when working with pools not pegged to 1 Wed 26 Oct 2022 16:40:25 BST\n    if (exchangeRate < icTotal) {\n      priceTarget = icTotal;\n    }\n\n    uint256 purchaseAmount = dexHandler.calculateBurningTradeSize(priceTarget);\n\n    if (purchaseAmount > preferAuctionThreshold) {\n      uint256 capitalUsed = swingTraderManager.buyMalt(purchaseAmount);\n\n      uint256 callerCut = (capitalUsed * callerRewardCutBps) / 10000;\n\n      if (callerCut != 0) {\n        malt.mint(msg.sender, callerCut);\n        emit MintMalt(callerCut);\n      }\n    } else {\n      _startAuction(originalPriceTarget);\n    }\n  }\n\n  function _distributeSupply(\n    uint256 livePrice,\n    uint256 priceTarget,\n    bool stabilizeToPeg\n  ) internal {\n    if (supplyDistributionController != address(0)) {\n      bool success = ISupplyDistributionController(supplyDistributionController)\n        .check();\n      if (!success) {\n        return;\n      }\n    }\n\n    uint256 pegPrice = maltDataLab.priceTarget();\n\n    uint256 lowerThreshold = (pegPrice * lowerStabilityThresholdBps) / 10000;\n    if (stabilizeToPeg || livePrice >= pegPrice - lowerThreshold) {\n      priceTarget = pegPrice;\n    }\n\n    uint256 tradeSize = dexHandler.calculateMintingTradeSize(priceTarget) /\n      expansionDampingFactor;\n\n    if (tradeSize == 0) {\n      return;\n    }\n\n    uint256 swingAmount = swingTraderManager.sellMalt(tradeSize);\n\n    if (swingAmount >= tradeSize) {\n      return;\n    }\n\n    tradeSize = tradeSize - swingAmount;\n\n    malt.mint(address(dexHandler), tradeSize);\n    emit MintMalt(tradeSize);\n    // Transfer verification ensure any attempt to\n    // sandwhich will trigger stabilize first\n    uint256 rewards = dexHandler.sellMalt(tradeSize, 10000);\n\n    uint256 callerCut = (rewards * callerRewardCutBps) / 10000;\n\n    if (callerCut != 0) {\n      rewards -= callerCut;\n      collateralToken.safeTransfer(msg.sender, callerCut);\n    }\n\n    collateralToken.safeTransfer(address(profitDistributor), rewards);\n\n    profitDistributor.handleProfit(rewards);\n  }\n\n  function _startAuction(uint256 priceTarget) internal {\n    if (auctionStartController != address(0)) {\n      bool success = IAuctionStartController(auctionStartController)\n        .checkForStart();\n      if (!success) {\n        return;\n      }\n    }\n\n    uint256 purchaseAmount = dexHandler.calculateBurningTradeSize(priceTarget);\n\n    if (purchaseAmount < skipAuctionThreshold) {\n      return;\n    }\n\n    // TODO StabilizerNode.sol invert priceTarget? Fri 21 Oct 2022 11:02:43 BST\n    bool success = auction.triggerAuction(priceTarget, purchaseAmount);\n\n    if (success) {\n      malt.mint(msg.sender, defaultIncentive * (10**malt.decimals()));\n      emit MintMalt(defaultIncentive * (10**malt.decimals()));\n    }\n  }\n\n  /*\n   * PRIVILEDGED FUNCTIONS\n   */\n\n  function setStabilizeBackoff(uint256 _period)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_period > 0, \"Must be greater than 0\");\n    stabilizeBackoffPeriod = _period;\n    emit SetStabilizeBackoff(_period);\n  }\n\n  function setDefaultIncentive(uint256 _incentive)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_incentive != 0 && _incentive <= 1000, \"Incentive out of range\");\n\n    defaultIncentive = _incentive;\n\n    emit SetDefaultIncentive(_incentive);\n  }\n\n  function setTrackingIncentive(uint256 _incentive)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    // Priced in cents. Must be less than 1000 Malt\n    require(_incentive != 0 && _incentive <= 100000, \"Incentive out of range\");\n\n    trackingIncentive = _incentive;\n\n    emit SetTrackingIncentive(_incentive);\n  }\n\n  /// @notice Only callable by Admin address.\n  /// @dev Sets the Expansion Damping units.\n  /// @param amount: Amount to set Expansion Damping units to.\n  function setExpansionDamping(uint256 amount)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(amount > 0, \"No negative damping\");\n\n    expansionDampingFactor = amount;\n    emit SetExpansionDamping(amount);\n  }\n\n  function setStabilityThresholds(uint256 _upper, uint256 _lower)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_upper != 0 && _lower != 0, \"Must be above 0\");\n    require(_lower < 10000, \"Lower to large\");\n\n    upperStabilityThresholdBps = _upper;\n    lowerStabilityThresholdBps = _lower;\n    emit SetStabilityThresholds(_upper, _lower);\n  }\n\n  function setSupplyDistributionController(address _controller)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    // This is allowed to be set to address(0) as its checked before calling methods on it\n    supplyDistributionController = _controller;\n    emit SetSupplyDistributionController(_controller);\n  }\n\n  function setAuctionStartController(address _controller)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    // This is allowed to be set to address(0) as its checked before calling methods on it\n    auctionStartController = _controller;\n    emit SetAuctionStartController(_controller);\n  }\n\n  function setPriceAveragePeriod(uint256 _period)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_period > 0, \"Cannot have 0 period\");\n    priceAveragePeriod = _period;\n    emit SetPriceAveragePeriod(_period);\n  }\n\n  function setOverrideDistance(uint256 _distance)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(\n      _distance != 0 && _distance < 10000,\n      \"Override must be between 0-100%\"\n    );\n    overrideDistanceBps = _distance;\n    emit SetOverrideDistance(_distance);\n  }\n\n  function setFastAveragePeriod(uint256 _period)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_period > 0, \"Cannot have 0 period\");\n    fastAveragePeriod = _period;\n    emit SetFastAveragePeriod(_period);\n  }\n\n  function setBandLimits(uint256 _upper, uint256 _lower)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_upper != 0 && _lower != 0, \"Cannot have 0 band limit\");\n    upperBandLimitBps = _upper;\n    lowerBandLimitBps = _lower;\n    emit SetBandLimits(_upper, _lower);\n  }\n\n  function setSlippageBps(uint256 _slippageBps)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_slippageBps <= 10000, \"slippage: Must be <= 100%\");\n    sampleSlippageBps = _slippageBps;\n    emit SetSlippageBps(_slippageBps);\n  }\n\n  function setSkipAuctionThreshold(uint256 _skipAuctionThreshold)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    skipAuctionThreshold = _skipAuctionThreshold;\n    emit SetSkipAuctionThreshold(_skipAuctionThreshold);\n  }\n\n  function setPreferAuctionThreshold(uint256 _preferAuctionThreshold)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    preferAuctionThreshold = _preferAuctionThreshold;\n    emit SetPreferAuctionThreshold(_preferAuctionThreshold);\n  }\n\n  function setTrackingBackoff(uint256 _backoff)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_backoff != 0, \"Cannot be 0\");\n    trackingBackoff = _backoff;\n    emit SetTrackingBackoff(_backoff);\n  }\n\n  function setTrackAfterStabilize(bool _track)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    trackAfterStabilize = _track;\n    emit SetTrackAfterStabilize(_track);\n  }\n\n  function setOnlyStabilizeToPeg(bool _stabilize)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    onlyStabilizeToPeg = _stabilize;\n    emit SetOnlyStabilizeToPeg(_stabilize);\n  }\n\n  function setCallerCut(uint256 _callerCut)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_callerCut <= 1000, \"Must be less than 10%\");\n    callerRewardCutBps = _callerCut;\n    emit SetCallerCut(_callerCut);\n  }\n\n  function togglePause()\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    if (paused()) {\n      _unpause();\n    } else {\n      _pause();\n    }\n  }\n\n  function setPrimedWindow(uint256 _primedWindow)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_primedWindow != 0, \"Cannot be 0\");\n    primedWindow = _primedWindow;\n    emit SetPrimedWindow(_primedWindow);\n  }\n\n  function setUsePrimedWindow(bool _usePrimedWindow)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    usePrimedWindow = _usePrimedWindow;\n    emit SetUsePrimedWindow(_usePrimedWindow);\n  }\n\n  function _accessControl()\n    internal\n    override(\n      AuctionExtension,\n      DexHandlerExtension,\n      DataLabExtension,\n      ProfitDistributorExtension,\n      SwingTraderManagerExtension,\n      ImpliedCollateralServiceExtension\n    )\n  {\n    _onlyRoleMalt(POOL_UPDATER_ROLE, \"Must have pool updater role\");\n  }\n}"
    },
    {
      "filename": "contracts/DataFeed/MaltDataLab.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport \"openzeppelin/token/ERC20/ERC20.sol\";\n\nimport \"../interfaces/IDualMovingAverage.sol\";\nimport \"../interfaces/IMovingAverage.sol\";\nimport \"../interfaces/IBurnMintableERC20.sol\";\nimport \"../interfaces/IImpliedCollateralService.sol\";\nimport \"../interfaces/IGlobalImpliedCollateralService.sol\";\nimport \"../interfaces/ISwingTrader.sol\";\n\nimport \"../libraries/uniswap/IUniswapV2Pair.sol\";\nimport \"../libraries/SafeBurnMintableERC20.sol\";\nimport \"../libraries/uniswap/FixedPoint.sol\";\nimport \"../libraries/ABDKMath64x64.sol\";\n\nimport \"../StabilizedPoolExtensions/StabilizedPoolUnit.sol\";\nimport \"../StabilizedPoolExtensions/ImpliedCollateralServiceExtension.sol\";\nimport \"../StabilizedPoolExtensions/SwingTraderManagerExtension.sol\";\nimport \"../StabilizedPoolExtensions/GlobalICExtension.sol\";\n\n/// @title Malt Data Lab\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The central source of all of Malt protocol's internal data needs\n/// @dev Over time usage of MovingAverage will likely be replaced with more reliable oracles\ncontract MaltDataLab is\n  StabilizedPoolUnit,\n  ImpliedCollateralServiceExtension,\n  SwingTraderManagerExtension,\n  GlobalICExtension\n{\n  using FixedPoint for *;\n  using ABDKMath64x64 for *;\n  using SafeBurnMintableERC20 for IBurnMintableERC20;\n\n  bytes32 public immutable UPDATER_ROLE;\n\n  // The dual values will be the pool price and the square root of the invariant k\n  IDualMovingAverage public poolMA;\n  IMovingAverage public ratioMA;\n\n  uint256 public priceTarget = 10**18; // $1\n  uint256 public maltPriceLookback = 10 minutes;\n  uint256 public reserveLookback = 15 minutes;\n  uint256 public kLookback = 30 minutes;\n  uint256 public maltRatioLookback = 4 hours;\n\n  uint256 public z = 20;\n  uint256 public swingTraderLowBps = 1000; // 10%\n  uint256 public auctionLowBps = 7000; // 70%\n  uint256 public breakpointBps = 5000; // 50%\n\n  uint256 public maltPriceCumulativeLast;\n  uint256 public maltPriceTimestampLast;\n\n  event TrackPool(uint256 price, uint256 rootK);\n\n  constructor(\n    address timelock,\n    address repository,\n    address poolFactory\n  ) StabilizedPoolUnit(timelock, repository, poolFactory) {\n    UPDATER_ROLE = 0x73e573f9566d61418a34d5de3ff49360f9c51fec37f7486551670290f6285dab;\n  }\n\n  function setupContracts(\n    address _malt,\n    address _collateralToken,\n    address _stakeToken,\n    address _poolMA,\n    address _ratioMA,\n    address _impliedCollateralService,\n    address _swingTraderManager,\n    address _globalIC,\n    address _trustedUpdater\n  ) external onlyRoleMalt(POOL_FACTORY_ROLE, \"Must be pool factory\") {\n    require(!contractActive, \"MaltDataLab: Already setup\");\n    require(_malt != address(0), \"MaltDataLab: Malt addr(0)\");\n    require(_collateralToken != address(0), \"MaltDataLab: Col addr(0)\");\n    require(_stakeToken != address(0), \"MaltDataLab: LP Token addr(0)\");\n    require(_poolMA != address(0), \"MaltDataLab: PoolMA addr(0)\");\n    require(\n      _impliedCollateralService != address(0),\n      \"MaltDataLab: ImpColSvc addr(0)\"\n    );\n    require(\n      _swingTraderManager != address(0),\n      \"MaltDataLab: STManager addr(0)\"\n    );\n    require(_globalIC != address(0), \"MaltDataLab: GlobalIC addr(0)\");\n    require(_ratioMA != address(0), \"MaltDataLab: RatioMA addr(0)\");\n\n    contractActive = true;\n\n    _roleSetup(UPDATER_ROLE, _trustedUpdater);\n\n    malt = IBurnMintableERC20(_malt);\n    collateralToken = ERC20(_collateralToken);\n    stakeToken = IUniswapV2Pair(_stakeToken);\n    poolMA = IDualMovingAverage(_poolMA);\n    impliedCollateralService = IImpliedCollateralService(\n      _impliedCollateralService\n    );\n    swingTraderManager = ISwingTrader(_swingTraderManager);\n    globalIC = IGlobalImpliedCollateralService(_globalIC);\n    ratioMA = IMovingAverage(_ratioMA);\n\n    (, address updater, ) = poolFactory.getPool(_stakeToken);\n    _setPoolUpdater(updater);\n  }\n\n  function smoothedMaltPrice() public view returns (uint256 price) {\n    (price, ) = poolMA.getValueWithLookback(maltPriceLookback);\n  }\n\n  function smoothedK() public view returns (uint256) {\n    (, uint256 rootK) = poolMA.getValueWithLookback(kLookback);\n    return rootK * rootK;\n  }\n\n  function smoothedReserves()\n    public\n    view\n    returns (uint256 maltReserves, uint256 collateralReserves)\n  {\n    // Malt reserves = sqrt(k / malt price)\n    (uint256 price, uint256 rootK) = poolMA.getValueWithLookback(\n      reserveLookback\n    );\n    uint256 unity = 10**collateralToken.decimals();\n\n    // maltReserves = sqrt(k * 1 / price);\n    maltReserves = Babylonian.sqrt((rootK * rootK * unity) / price);\n    collateralReserves = (maltReserves * price) / unity;\n  }\n\n  function smoothedMaltRatio() public view returns (uint256) {\n    return ratioMA.getValueWithLookback(maltRatioLookback);\n  }\n\n  function maltPriceAverage(uint256 _lookback)\n    public\n    view\n    returns (uint256 price)\n  {\n    (price, ) = poolMA.getValueWithLookback(_lookback);\n  }\n\n  function kAverage(uint256 _lookback) public view returns (uint256) {\n    (, uint256 rootK) = poolMA.getValueWithLookback(_lookback);\n    return rootK * rootK;\n  }\n\n  function poolReservesAverage(uint256 _lookback)\n    public\n    view\n    returns (uint256 maltReserves, uint256 collateralReserves)\n  {\n    // Malt reserves = sqrt(k / malt price)\n    (uint256 price, uint256 rootK) = poolMA.getValueWithLookback(_lookback);\n\n    uint256 unity = 10**collateralToken.decimals();\n\n    // maltReserves = sqrt(k * 1 / price);\n    maltReserves = Babylonian.sqrt((rootK * rootK * unity) / price);\n    collateralReserves = (maltReserves * price) / unity;\n  }\n\n  function lastMaltPrice()\n    public\n    view\n    returns (uint256 price, uint64 timestamp)\n  {\n    (timestamp, , , , , price, ) = poolMA.getLiveSample();\n  }\n\n  function lastPoolReserves()\n    public\n    view\n    returns (\n      uint256 maltReserves,\n      uint256 collateralReserves,\n      uint64 timestamp\n    )\n  {\n    // Malt reserves = sqrt(k / malt price)\n    (uint64 timestamp, , , , , uint256 price, uint256 rootK) = poolMA\n      .getLiveSample();\n\n    uint256 unity = 10**collateralToken.decimals();\n\n    // maltReserves = sqrt(k * 1 / price);\n    maltReserves = Babylonian.sqrt((rootK * rootK * unity) / price);\n    collateralReserves = (maltReserves * price) / unity;\n  }\n\n  function lastK() public view returns (uint256 kLast, uint64 timestamp) {\n    // Malt reserves = sqrt(k / malt price)\n    (uint64 timestamp, , , , , , uint256 rootK) = poolMA.getLiveSample();\n\n    kLast = rootK * rootK;\n  }\n\n  function realValueOfLPToken(uint256 amount) external view returns (uint256) {\n    (uint256 maltPrice, uint256 rootK) = poolMA.getValueWithLookback(\n      reserveLookback\n    );\n\n    uint256 unity = 10**collateralToken.decimals();\n\n    // TODO MaltDataLab.sol will this work with other decimals? Sat 22 Oct 2022 18:44:07 BST\n\n    // maltReserves = sqrt(k * 1 / price);\n    uint256 maltReserves = Babylonian.sqrt((rootK * rootK * unity) / maltPrice);\n    uint256 collateralReserves = (maltReserves * maltPrice) / unity;\n\n    if (maltReserves == 0) {\n      return 0;\n    }\n\n    uint256 totalLPSupply = stakeToken.totalSupply();\n\n    uint256 maltValue = (amount * maltReserves) / totalLPSupply;\n    uint256 rewardValue = (amount * collateralReserves) / totalLPSupply;\n\n    return rewardValue + ((maltValue * maltPrice) / unity);\n  }\n\n  function getRealBurnBudget(uint256 maxBurnSpend, uint256 premiumExcess)\n    external\n    view\n    returns (uint256)\n  {\n    if (maxBurnSpend > premiumExcess) {\n      uint256 diff = maxBurnSpend - premiumExcess;\n\n      int128 stMaltRatioInt = ABDKMath64x64\n        .fromUInt(swingTraderManager.calculateSwingTraderMaltRatio())\n        .div(ABDKMath64x64.fromUInt(10**collateralToken.decimals()))\n        .mul(ABDKMath64x64.fromUInt(100));\n      int128 purchaseParityInt = ABDKMath64x64.fromUInt(z);\n\n      if (stMaltRatioInt >= purchaseParityInt) {\n        return maxBurnSpend;\n      }\n\n      uint256 bps = stMaltRatioInt\n        .div(purchaseParityInt)\n        .mul(ABDKMath64x64.fromUInt(10000))\n        .toUInt();\n      uint256 additional = (diff * bps) / 10000;\n\n      return premiumExcess + additional;\n    }\n\n    return maxBurnSpend;\n  }\n\n  function maltToRewardDecimals(uint256 maltAmount)\n    public\n    view\n    returns (uint256)\n  {\n    uint256 rewardDecimals = collateralToken.decimals();\n    uint256 maltDecimals = malt.decimals();\n\n    if (rewardDecimals == maltDecimals) {\n      return maltAmount;\n    } else if (rewardDecimals > maltDecimals) {\n      uint256 diff = rewardDecimals - maltDecimals;\n      return maltAmount * (10**diff);\n    } else {\n      uint256 diff = maltDecimals - rewardDecimals;\n      return maltAmount / (10**diff);\n    }\n  }\n\n  function rewardToMaltDecimals(uint256 amount) public view returns (uint256) {\n    uint256 rewardDecimals = collateralToken.decimals();\n    uint256 maltDecimals = malt.decimals();\n\n    if (rewardDecimals == maltDecimals) {\n      return amount;\n    } else if (rewardDecimals > maltDecimals) {\n      uint256 diff = rewardDecimals - maltDecimals;\n      return amount / (10**diff);\n    } else {\n      uint256 diff = maltDecimals - rewardDecimals;\n      return amount * (10**diff);\n    }\n  }\n\n  /*\n   * Public mutation methods\n   */\n  function trackPool() external onlyActive returns (bool) {\n    (uint256 reserve0, uint256 reserve1, uint32 blockTimestampLast) = stakeToken\n      .getReserves();\n\n    if (blockTimestampLast < maltPriceTimestampLast) {\n      // stale data\n      return false;\n    }\n\n    uint256 kLast = reserve0 * reserve1;\n\n    uint256 rootK = Babylonian.sqrt(kLast);\n\n    uint256 price;\n    uint256 priceCumulative;\n\n    if (address(malt) < address(collateralToken)) {\n      priceCumulative = stakeToken.price0CumulativeLast();\n    } else {\n      priceCumulative = stakeToken.price1CumulativeLast();\n    }\n\n    if (\n      blockTimestampLast > maltPriceTimestampLast &&\n      maltPriceCumulativeLast != 0\n    ) {\n      price = FixedPoint\n        .uq112x112(\n          uint224(\n            (priceCumulative - maltPriceCumulativeLast) /\n              (blockTimestampLast - maltPriceTimestampLast)\n          )\n        )\n        .mul(priceTarget)\n        .decode144();\n    } else if (\n      maltPriceCumulativeLast > 0 && priceCumulative == maltPriceCumulativeLast\n    ) {\n      (, , , , , price, ) = poolMA.getLiveSample();\n    }\n\n    if (price != 0) {\n      // Use rootK to slow down growth of cumulativeValue\n      poolMA.update(price, rootK);\n      emit TrackPool(price, rootK);\n    }\n\n    maltPriceCumulativeLast = priceCumulative;\n    maltPriceTimestampLast = blockTimestampLast;\n\n    return true;\n  }\n\n  function getSwingTraderEntryPrice()\n    external\n    view\n    returns (uint256 stEntryPrice)\n  {\n    /*\n     * Note that in this method there are two separate units in play\n     *\n     * 1. Values from other contracts are uint256 denominated in collateralToken.decimals()\n     * 2. int128 values are ABDKMath64x64 values. These can be thought of as regular decimals\n     *\n     * This means that all the values denominated in collateralToken.decimals need to be divided by\n     * that decimal value to turn them into \"real\" decimals. This is why the conversion between\n     * the two always contains a \"unityInt\" value (either division when going to 64x64 and\n     * multiplication when going to collateralToken.decimal() value)\n     */\n\n    /*\n     * Get all the values we need\n     */\n    uint256 unity = 10**collateralToken.decimals();\n    uint256 icTotal = maltToRewardDecimals(globalIC.collateralRatio());\n\n    if (icTotal == 0) {\n      return 0;\n    }\n\n    if (icTotal >= unit"
    }
  ]
}