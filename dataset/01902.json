{
  "Title": "H-3: `VaultAccountSecondaryDebtShareStorage.maturity` will be cleared prematurely",
  "Content": "# Issue H-3: `VaultAccountSecondaryDebtShareStorage.maturity` will be cleared prematurely \n\nSource: https://github.com/sherlock-audit/2023-03-notional-judging/issues/183 \n\n## Found by \nxiaoming90\n## Summary\n\n`VaultAccountSecondaryDebtShareStorage.maturity` will be cleared prematurely during liquidation\n\n## Vulnerability Detail\n\nIf both the `accountDebtOne` and `accountDebtTwo` of secondary currencies are zero, Notional will consider both debt shares to be cleared to zero, and the maturity will be cleared as well as shown below.\n\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/internal/vaults/VaultSecondaryBorrow.sol#L495\n\n```solidity\nFile: VaultSecondaryBorrow.sol\n495:     function _setAccountMaturity(\n496:         VaultAccountSecondaryDebtShareStorage storage accountStorage,\n497:         int256 accountDebtOne,\n498:         int256 accountDebtTwo,\n499:         uint40 maturity\n500:     ) private {\n501:         if (accountDebtOne == 0 && accountDebtTwo == 0) {\n502:             // If both debt shares are cleared to zero, clear the maturity as well.\n503:             accountStorage.maturity = 0;\n504:         } else {\n505:             // In all other cases, set the account to the designated maturity\n506:             accountStorage.maturity = maturity;\n507:         }\n508:     }\n```\n\n**`VaultLiquidationAction.deleverageAccount` function**\n\nWithin the `VaultLiquidationAction.deleverageAccount` function, it will call the `_reduceAccountDebt` function.\n\nReferring to the `_reduceAccountDebt` function below. Assume that the `currencyIndex` reference to a secondary currency. In this case, the else logic in Line 251 will be executed. An important point to take note of that is critical to understand this bug is that only ONE of the prime rates will be set as it assumes that the other prime rate will not be used (Refer to Line 252 - 255). However, this assumption is incorrect.\n\nAssume that the `currencyIndex` is `1`. Then `netUnderlyingDebtOne` parameter will be set to a non-zero value (`depositUnderlyingInternal`) at Line 261 while `netUnderlyingDebtTwo` parameter will be set to zero at Line 262. This is because, in Line 263 of the `_reduceAccountDebt` function, the `pr[0]` will be set to the prime rate, while the `pr[1]` will be zero or empty. It will then proceed to call the `VaultSecondaryBorrow.updateAccountSecondaryDebt` \n\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/external/actions/VaultLiquidationAction.sol#L239\n\n```solidity\nFile: VaultLiquidationAction.sol\n239:     function _reduceAccountDebt(\n240:         VaultConfig memory vaultConfig,\n241:         VaultState memory vaultState,\n242:         VaultAccount memory vaultAccount,\n243:         PrimeRate memory primeRate,\n244:         uint256 currencyIndex,\n245:         int256 depositUnderlyingInternal,\n246:         bool checkMinBorrow\n247:     ) private {\n248:         if (currencyIndex == 0) {\n249:             vaultAccount.updateAccountDebt(vaultState, depositUnderlyingInternal, 0);\n250:             vaultState.setVaultState(vaultConfig);\n251:         } else {\n252:             // Only set one of the prime rates, the other prime rate is not used since\n253:             // the net debt amount is set to zero\n254:             PrimeRate[2] memory pr;\n255:             pr[currencyIndex - 1] = primeRate;\n256: \n257:             VaultSecondaryBorrow.updateAccountSecondaryDebt(\n258:                 vaultConfig,\n259:                 vaultAccount.account,\n260:                 vaultAccount.maturity,\n261:                 currencyIndex == 1 ? depositUnderlyingInternal : 0,\n262:                 currencyIndex == 2 ? depositUnderlyingInternal : 0,\n263:                 pr,\n264:                 checkMinBorrow\n265:             );\n266:         }\n267:     }\n```\n\nWithin the `updateAccountSecondaryDebt` function, at Line 272, assume that `accountStorage.accountDebtTwo` is `100`. However, since `pr[1]` is not initialized, the `VaultStateLib.readDebtStorageToUnderlying` will return a zero value and set the `accountDebtTwo` to zero.\n\nAssume that the liquidator calls the `deleverageAccount` function to clear all the debt of the `currencyIndex` secondary currency. Line 274 will be executed, and `accountDebtOne` will be set to zero.\n\nNote that at this point, both `accountDebtOne` and `accountDebtTwo` are zero. At Line 301, the `_setAccountMaturity` will set the `accountStorage.maturity = 0` , which clears the vault account's maturity.\n\nAn important point here is that the liquidator did not clear the `accountDebtTwo`. Yet, `accountDebtTwo` became zero in memory during the execution and caused Notional to wrongly assume that both debt shares had been cleared to zero.\n\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/internal/vaults/VaultSecondaryBorrow.sol#L256\n\n```solidity\nFile: VaultSecondaryBorrow.sol\n256:     function updateAccountSecondaryDebt(\n257:         VaultConfig memory vaultConfig,\n258:         address account,\n259:         uint256 maturity,\n260:         int256 netUnderlyingDebtOne,\n261:         int256 netUnderlyingDebtTwo,\n262:         PrimeRate[2] memory pr,\n263:         bool checkMinBorrow\n264:     ) internal {\n265:         VaultAccountSecondaryDebtShareStorage storage accountStorage = \n266:             LibStorage.getVaultAccountSecondaryDebtShare()[account][vaultConfig.vault];\n267:         // Check maturity\n268:         uint256 accountMaturity = accountStorage.maturity;\n269:         require(accountMaturity == maturity || accountMaturity == 0);\n270:         \n271:         int256 accountDebtOne = VaultStateLib.readDebtStorageToUnderlying(pr[0], maturity, accountStorage.accountDebtOne); \n272:         int256 accountDebtTwo = VaultStateLib.readDebtStorageToUnderlying(pr[1], maturity, accountStorage.accountDebtTwo);\n273:         if (netUnderlyingDebtOne != 0) {\n274:             accountDebtOne = accountDebtOne.add(netUnderlyingDebtOne);\n\n276:             _updateTotalSecondaryDebt(\n277:                 vaultConfig, account, vaultConfig.secondaryBorrowCurrencies[0], maturity, netUnderlyingDebtOne, pr[0]\n278:             );\n279: \n280:             accountStorage.accountDebtOne = VaultStateLib.calculateDebtStorage(pr[0], maturity, accountDebtOne)\n281:                 .neg().toUint().toUint80();\n282:         }\n283: \n284:         if (netUnderlyingDebtTwo != 0) {\n285:             accountDebtTwo = accountDebtTwo.add(netUnderlyingDebtTwo);\n286: \n287:             _updateTotalSecondaryDebt(\n288:                 vaultConfig, account, vaultConfig.secondaryBorrowCurrencies[1], maturity, netUnderlyingDebtTwo, pr[1]\n289:             );\n290: \n291:             accountStorage.accountDebtTwo = VaultStateLib.calculateDebtStorage(pr[1], maturity, accountDebtTwo)\n292:                 .neg().toUint().toUint80();\n293:         }\n294: \n295:         if (checkMinBorrow) {\n296:             // No overflow on negation due to overflow checks above\n297:             require(accountDebtOne == 0 || vaultConfig.minAccountSecondaryBorrow[0] <= -accountDebtOne, \"min borrow\");\n298:             require(accountDebtTwo == 0 || vaultConfig.minAccountSecondaryBorrow[1] <= -accountDebtTwo, \"min borrow\");\n299:         }\n300: \n301:         _setAccountMaturity(accountStorage, accountDebtOne, accountDebtTwo, maturity.toUint40());\n302:     }\n```\n\nThe final state will be `VaultAccountSecondaryDebtShareStorage` as follows:\n\n- `maturity` and `accountDebtOne` are zero\n- `accountDebtTwo` = 100\n\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/global/Types.sol#L551\n\n```solidity\nstruct VaultAccountSecondaryDebtShareStorage {\n    // Maturity for the account's secondary borrows. This is stored separately from\n    // the vault account maturity to ensure that we have access to the proper state\n    // during a roll borrow position. It should never be allowed to deviate from the\n    // vaultAccount.maturity value (unless it is cleared to zero).\n    uint40 maturity;\n    // Account debt for the first secondary currency in either fCash or pCash denomination\n    uint80 accountDebtOne;\n    // Account debt for the second secondary currency in either fCash or pCash denomination\n    uint80 accountDebtTwo;\n}\n```\n\nFirstly, it does not make sense to have `accountDebtTwo` but no maturity in storage, which also means the vault account data is corrupted. Secondly, when `maturity` is zero, it also means that the vault account did not borrow anything from Notional. Lastly, many vault logic would break since it relies on the maturity value.\n\n**`VaultLiquidationAction.liquidateVaultCashBalance` function**\n\nThe root cause lies in the implementation of the `_reduceAccountDebt` function. Since `liquidateVaultCashBalance` function calls the `_reduceAccountDebt` function to reduce the debt of the vault account being liquidated, the same issue will occur here.\n\n## Impact\n\nAny vault logic that relies on the `VaultAccountSecondaryDebtShareStorage`'s maturity value would break since it has been cleared (set to zero). For instance, a vault account cannot be settled anymore as the following `settleSecondaryBorrow` function will always revert. Since `storedMaturity == 0` but `accountDebtTwo` is not zero, Line 399 below will always revert.\n\nAs a result, a vault account with secondary currency debt cannot be settled. This also means that the vault account cannot exit since a vault account needs to be settled before exiting, causing users' assets to be stuck within the protocol.\n\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/internal/vaults/VaultSecondaryBorrow.sol#L385\n\n```solidity\nFile: VaultSecondaryBorrow.sol\n385:     function settleSecondaryBorrow(VaultConfig memory vaultConfig, address account) internal returns (bool) {\n386:         if (!vaultConfig.hasSecondaryBorrows()) return false;\n387: \n388:         VaultAccountSecondaryDebtShareStorage storage accountStorage = \n389:             LibStorage.getVaultAccountSecondaryDebtShare()[account][vaultConfig.vault];\n390:         uint256 storedMaturity = accountStorage.maturity;\n391: \n392:         // NOTE: we can read account debt directly since prime cash maturities never enter this block of code.\n393:         int256 accountDebtOne = -int256(uint256(accountStorage.accountDebtOne));\n394:         int256 accountDebtTwo = -int256(uint256(accountStorage.accountDebtTwo));\n395:         \n396:         if (storedMaturity == 0) {\n397:             // Handles edge condition where an account is holding vault shares past maturity without\n398:             // any debt position.\n399:             require(accountDebtOne == 0 && accountDebtTwo == 0); \n400:         } else {\n```\n\nIn addition, the vault account data is corrupted as there is a secondary debt without maturity, which might affect internal accounting and tracking.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/external/actions/VaultLiquidationAction.sol#L239\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nFetch the prime rate of both secondary currencies because they are both needed within the `updateAccountSecondaryDebt` function when converting debt storage to underlying.\n\n```diff\n    function _reduceAccountDebt(\n        VaultConfig memory vaultConfig,\n        VaultState memory vaultState,\n        VaultAccount memory vaultAccount,\n        PrimeRate memory primeRate,\n        uint256 currencyIndex,\n        int256 depositUnderlyingInternal,\n        bool checkMinBorrow\n    ) private {\n        if (currencyIndex == 0) {\n            vaultAccount.updateAccountDebt(vaultState, depositUnderlyingInternal, 0);\n            vaultState.setVaultState(vaultConfig);\n        } else {\n            // Only set one of the prime rates, the other prime rate is not used since\n            // the net debt amount is set to zero\n            PrimeRate[2] memory pr;\n-           pr[currencyIndex - 1] = primeRate;\n+\t    pr = VaultSecondaryBorrow.getSecondaryPrimeRateStateful(vaultConfig);\n\n            VaultSecondaryBorrow.updateAccountSecondaryDebt(\n                vaultConfig,\n                vaultAccount.account,\n                vaultAccount.maturity,\n                currencyIndex == 1 ? depositUnderlyingInternal : 0,\n                currencyIndex == 2 ? depositUnderlyingInternal : 0,\n                pr,\n                checkMinBorrow\n            );\n        }\n    }\n```\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/59",
  "Code": [
    {
      "filename": "contracts-v2/contracts/internal/vaults/VaultSecondaryBorrow.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport {\n    VaultConfig,\n    VaultAccount,\n    VaultAccountStorage,\n    VaultState,\n    VaultStateStorage,\n    VaultAccountSecondaryDebtShareStorage,\n    ETHRate,\n    PrimeRate\n} from \"../../global/Types.sol\";\nimport {LibStorage} from \"../../global/LibStorage.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {SafeUint256} from \"../../math/SafeUint256.sol\";\nimport {SafeInt256} from \"../../math/SafeInt256.sol\";\n\nimport {Emitter} from \"../Emitter.sol\";\nimport {ExchangeRate} from \"../valuation/ExchangeRate.sol\";\nimport {PrimeRateLib} from \"../pCash/PrimeRateLib.sol\";\nimport {PrimeCashExchangeRate} from \"../pCash/PrimeCashExchangeRate.sol\";\n\nimport {VaultConfiguration} from \"./VaultConfiguration.sol\";\nimport {VaultStateLib} from \"./VaultState.sol\";\nimport {VaultAccountLib} from \"./VaultAccount.sol\";\nimport {VaultValuation} from \"./VaultValuation.sol\";\n\n/// @notice Handles all the logic related to secondary borrow currencies\nlibrary VaultSecondaryBorrow {\n    using SafeUint256 for uint256;\n    using SafeInt256 for int256;\n    using PrimeRateLib for PrimeRate;\n    using VaultConfiguration for VaultConfig;\n\n    /// @notice Emitted when a vault executes a secondary borrow\n    event VaultSecondaryTransaction(\n        address indexed vault,\n        address indexed account,\n        uint16 indexed currencyId,\n        uint256 maturity,\n        int256 netUnderlyingDebt,\n        int256 netPrimeSupply\n    );\n\n    struct SecondaryExchangeRates {\n        int256 rateDecimals;\n        int256 exchangeRateOne;\n        int256 exchangeRateTwo;\n    }\n\n    /**** Secondary Borrow Getters ****/\n\n    /// @notice Returns prime rates for secondary borrows\n    function getSecondaryPrimeRateStateful(VaultConfig memory vaultConfig) internal returns (PrimeRate[2] memory pr) {\n        if (vaultConfig.secondaryBorrowCurrencies[0] != 0)\n            pr[0] = PrimeRateLib.buildPrimeRateStateful(vaultConfig.secondaryBorrowCurrencies[0]);\n        if (vaultConfig.secondaryBorrowCurrencies[1] != 0)\n            pr[1] = PrimeRateLib.buildPrimeRateStateful(vaultConfig.secondaryBorrowCurrencies[1]);\n    }\n\n    /// @notice Returns prime rates for secondary borrows\n    function getSecondaryPrimeRateView(\n        VaultConfig memory vaultConfig,\n        uint256 blockTime\n    ) internal view returns (PrimeRate[2] memory pr) {\n        if (vaultConfig.secondaryBorrowCurrencies[0] != 0)\n            (pr[0], /* */) = PrimeCashExchangeRate.getPrimeCashRateView(vaultConfig.secondaryBorrowCurrencies[0], blockTime);\n        if (vaultConfig.secondaryBorrowCurrencies[1] != 0)\n            (pr[1], /* */) = PrimeCashExchangeRate.getPrimeCashRateView(vaultConfig.secondaryBorrowCurrencies[1], blockTime);\n    }\n\n    /// @notice Returns exchange rates back to the primary for secondary borrows\n    function getExchangeRates(\n        VaultConfig memory vaultConfig\n    ) internal view returns (SecondaryExchangeRates memory er) {\n        ETHRate memory primaryER = ExchangeRate.buildExchangeRate(vaultConfig.borrowCurrencyId);\n        er.rateDecimals = primaryER.rateDecimals;\n\n        if (vaultConfig.secondaryBorrowCurrencies[0] != 0){\n            er.exchangeRateOne = ExchangeRate.exchangeRate(\n                primaryER, \n                ExchangeRate.buildExchangeRate(vaultConfig.secondaryBorrowCurrencies[0])\n            );\n        }\n\n        if (vaultConfig.secondaryBorrowCurrencies[1] != 0){\n            er.exchangeRateTwo = ExchangeRate.exchangeRate(\n                primaryER, \n                ExchangeRate.buildExchangeRate(vaultConfig.secondaryBorrowCurrencies[1])\n            );\n        }\n    }\n\n    /**** Secondary Borrow Debt ****/\n\n    function getSecondaryBorrowCollateralFactors(\n        VaultConfig memory vaultConfig,\n        PrimeRate[2] memory primeRates,\n        VaultState memory vaultState,\n        address account\n    ) internal view returns (\n        int256 secondaryDebtInPrimary,\n        VaultSecondaryBorrow.SecondaryExchangeRates memory er,\n        int256 debtOutstandingOne,\n        int256 debtOutstandingTwo\n    ) {\n        er = getExchangeRates(vaultConfig);\n        (debtOutstandingOne, debtOutstandingTwo, secondaryDebtInPrimary) = _getSecondaryAccountDebtsInPrimary(\n            vaultConfig, primeRates, er, account, vaultState.maturity\n        );\n    }\n\n    function getAccountSecondaryDebt(\n        VaultConfig memory vaultConfig,\n        address account,\n        PrimeRate[2] memory pr\n    ) internal view returns (uint256 maturity, int256 accountDebtOne, int256 accountDebtTwo) {\n        VaultAccountSecondaryDebtShareStorage storage s = \n            LibStorage.getVaultAccountSecondaryDebtShare()[account][vaultConfig.vault];\n\n        maturity = s.maturity;\n        accountDebtOne = VaultStateLib.readDebtStorageToUnderlying(pr[0], maturity, s.accountDebtOne);\n        accountDebtTwo = VaultStateLib.readDebtStorageToUnderlying(pr[1], maturity, s.accountDebtTwo);\n    }\n\n    function getSecondaryCashHeld(\n        address account,\n        address vault\n    ) internal view returns (int256 secondaryCashOne, int256 secondaryCashTwo) {\n        VaultAccountStorage storage a = LibStorage.getVaultAccount()[account][vault];\n        secondaryCashOne = int256(uint256(a.secondaryCashOne));\n        secondaryCashTwo = int256(uint256(a.secondaryCashTwo));\n    }\n\n    /// @notice Converts any two given secondary cash balances to primary valuation\n    function _convertSecondaryUnderlyingToPrimary(\n        SecondaryExchangeRates memory er,\n        int256 secondaryUnderlyingOne,\n        int256 secondaryUnderlyingTwo\n    ) private pure returns (int256 primaryValue) {\n        if (secondaryUnderlyingOne != 0) {\n            primaryValue = secondaryUnderlyingOne.mul(er.rateDecimals).div(er.exchangeRateOne);\n        }\n\n        if (secondaryUnderlyingTwo != 0) {\n            primaryValue = primaryValue.add(\n                secondaryUnderlyingTwo.mul(er.rateDecimals).div(er.exchangeRateTwo)\n            );\n        }\n    }\n\n    function _getSecondaryAccountDebtsInPrimary(\n        VaultConfig memory vaultConfig,\n        PrimeRate[2] memory primeRates,\n        SecondaryExchangeRates memory er,\n        address account,\n        uint256 maturity\n    ) private view returns (\n        int256 debtOutstandingOne,\n        int256 debtOutstandingTwo,\n        int256 totalDebtOutstandingInPrimary\n    ) {\n        (int256 secondaryCashOne, int256 secondaryCashTwo) = getSecondaryCashHeld(\n            account, vaultConfig.vault\n        );\n        (/* */, debtOutstandingOne, debtOutstandingTwo) = getAccountSecondaryDebt(\n            vaultConfig, account, primeRates\n        );\n\n        bool enableDiscount = vaultConfig.getFlag(VaultConfiguration.ENABLE_FCASH_DISCOUNT);\n        if (vaultConfig.secondaryBorrowCurrencies[0] != 0) {\n            debtOutstandingOne = VaultValuation.getPresentValue(\n                primeRates[0],\n                vaultConfig.secondaryBorrowCurrencies[0],\n                maturity,\n                debtOutstandingOne,\n                enableDiscount\n            ).add(primeRates[0].convertToUnderlying(secondaryCashOne));\n        }\n\n        if (vaultConfig.secondaryBorrowCurrencies[1] != 0) {\n            debtOutstandingTwo = VaultValuation.getPresentValue(\n                primeRates[1],\n                vaultConfig.secondaryBorrowCurrencies[1],\n                maturity,\n                debtOutstandingTwo,\n                enableDiscount\n            ).add(primeRates[1].convertToUnderlying(secondaryCashTwo));\n        }\n\n        // Debt outstanding is reported in underlying denomination\n        totalDebtOutstandingInPrimary = _convertSecondaryUnderlyingToPrimary(\n            er, debtOutstandingOne, debtOutstandingTwo\n        );\n    }\n        \n    /**** Secondary Borrow Trade Execution ****/\n\n    /// @notice Executes a secondary borrow transaction\n    /// @param vaultConfig vault config\n    /// @param account address of account executing the secondary borrow (this may be the vault itself)\n    /// @param maturity the maturity of the fCash\n    /// @param netUnderlyingDebtOne net amount of debt for the first currency\n    /// @param netUnderlyingDebtTwo net amount of debt for the second currency\n    /// @param slippageLimits maximum annualized rate of fCash to borrow\n    /// @return netPrimeCashOne net amount of prime cash to transfer\n    /// @return netPrimeCashTwo net amount of prime cash to transfer\n    function executeSecondary(\n        VaultConfig memory vaultConfig,\n        address account,\n        uint256 maturity,\n        int256 netUnderlyingDebtOne,\n        int256 netUnderlyingDebtTwo,\n        PrimeRate[2] memory pr,\n        uint32[2] calldata slippageLimits\n    ) internal returns (int256 netPrimeCashOne, int256 netPrimeCashTwo) {\n        // Updates debt accounting, checks capacity and min borrow\n        updateAccountSecondaryDebt(\n            vaultConfig, account, maturity, netUnderlyingDebtOne, netUnderlyingDebtTwo, pr, true\n        );\n\n        if (netUnderlyingDebtOne != 0) {\n            uint16 currencyId = vaultConfig.secondaryBorrowCurrencies[0];\n            netPrimeCashOne = _executeSecondaryCurrencyTrade(\n                vaultConfig, pr[0], currencyId, maturity, netUnderlyingDebtOne, slippageLimits[0] \n            );\n\n            emit VaultSecondaryTransaction(\n                vaultConfig.vault, account, currencyId, maturity, netUnderlyingDebtOne, netPrimeCashOne\n            );\n        }\n\n        if (netUnderlyingDebtTwo != 0) {\n            uint16 currencyId = vaultConfig.secondaryBorrowCurrencies[1];\n            netPrimeCashTwo = _executeSecondaryCurrencyTrade(\n                vaultConfig, pr[1], currencyId, maturity, netUnderlyingDebtTwo, slippageLimits[1]\n            );\n\n            emit VaultSecondaryTransaction(\n                vaultConfig.vault, account, currencyId, maturity, netUnderlyingDebtTwo, netPrimeCashTwo\n            );\n        }\n\n        // Clears any refunds on the vault account and applies them to the transaction\n        (int256 primeCashRefundOne, int256 primeCashRefundTwo) = VaultAccountLib.clearVaultAccountSecondaryCash(\n            account, vaultConfig.vault\n        );\n\n        Emitter.emitVaultBurnSecondaryCash(account, vaultConfig, maturity, primeCashRefundOne, primeCashRefundTwo);\n        netPrimeCashOne = netPrimeCashOne.add(primeCashRefundOne);\n        netPrimeCashTwo = netPrimeCashTwo.add(primeCashRefundTwo);\n    }\n\n    function updateAccountSecondaryDebt(\n        VaultConfig memory vaultConfig,\n        address account,\n        uint256 maturity,\n        int256 netUnderlyingDebtOne,\n        int256 netUnderlyingDebtTwo,\n        PrimeRate[2] memory pr,\n        bool checkMinBorrow\n    ) internal {\n        VaultAccountSecondaryDebtShareStorage storage accountStorage = \n            LibStorage.getVaultAccountSecondaryDebtShare()[account][vaultConfig.vault];\n        // Check maturity\n        uint256 accountMaturity = accountStorage.maturity;\n        require(accountMaturity == maturity || accountMaturity == 0);\n\n        int256 accountDebtOne = VaultStateLib.readDebtStorageToUnderlying(pr[0], maturity, accountStorage.accountDebtOne);\n        int256 accountDebtTwo = VaultStateLib.readDebtStorageToUnderlying(pr[1], maturity, accountStorage.accountDebtTwo);\n        if (netUnderlyingDebtOne != 0) {\n            accountDebtOne = accountDebtOne.add(netUnderlyingDebtOne);\n\n            _updateTotalSecondaryDebt(\n                vaultConfig, account, vaultConfig.secondaryBorrowCurrencies[0], maturity, netUnderlyingDebtOne, pr[0]\n            );\n\n            accountStorage.accountDebtOne = VaultStateLib.calculateDebtStorage(pr[0], maturity, accountDebtOne)\n                .neg().toUint().toUint80();\n        }\n\n        if (netUnderlyingDebtTwo != 0) {\n            accountDebtTwo = accountDebtTwo.add(netUnderlyingDebtTwo);\n\n            _updateTotalSecondaryDebt(\n                vaultConfig, account, vaultConfig.secondaryBorrowCurrencies[1], maturity, netUnderlyingDebtTwo, pr[1]\n            );\n\n            accountStorage.accountDebtTwo = VaultStateLib.calculateDebtStorage(pr[1], maturity, accountDebtTwo)\n                .neg().toUint().toUint80();\n        }\n\n        if (checkMinBorrow) {\n            // No overflow on negation due to overflow checks above\n            require(accountDebtOne == 0 || vaultConfig.minAccountSecondaryBorrow[0] <= -accountDebtOne, \"min borrow\");\n            require(accountDebtTwo == 0 || vaultConfig.minAccountSecondaryBorrow[1] <= -accountDebtTwo, \"min borrow\");\n        }\n\n        _setAccountMaturity(accountStorage, accountDebtOne, accountDebtTwo, maturity.toUint40());\n    }\n\n    function _updateTotalSecondaryDebt(\n        VaultConfig memory vaultConfig,\n        address account,\n        uint16 currencyId,\n        uint256 maturity,\n        int256 netUnderlyingDebt,\n        PrimeRate memory pr\n    ) private {\n        VaultStateStorage storage balance = LibStorage.getVaultSecondaryBorrow()\n            [vaultConfig.vault][maturity][currencyId];\n        int256 totalDebtUnderlying = VaultStateLib.readDebtStorageToUnderlying(pr, maturity, balance.totalDebt);\n        \n        // Set the new debt underlying to storage\n        totalDebtUnderlying = totalDebtUnderlying.add(netUnderlyingDebt);\n        VaultStateLib.setTotalDebtStorage(\n            balance, pr, vaultConfig, currencyId, maturity, totalDebtUnderlying, false // not settled\n        );\n\n        // Emit a mint or burn event for the account's secondary debt\n        int256 vaultDebtAmount;\n        if (netUnderlyingDebt > 0 && maturity == Constants.PRIME_CASH_VAULT_MATURITY) {\n            // Calculate debt storage for prime cash requires the underlying value to be negative\n            vaultDebtAmount = VaultStateLib.calculateDebtStorage(pr, maturity, netUnderlyingDebt.neg()).neg();\n        } else {\n            vaultDebtAmount = VaultStateLib.calculateDebtStorage(pr, maturity, netUnderlyingDebt);\n        }\n\n        Emitter.emitVaultSecondaryDebt(\n            account, vaultConfig.vault, currencyId, maturity, vaultDebtAmount\n        );\n    }\n\n    /// @notice Executes a secondary currency lend or borrow\n    function _executeSecondaryCurrencyTrade(\n        VaultConfig memory vaultConfig,\n        PrimeRate memory pr,\n        uint16 currencyId,\n        uint256 maturity,\n        int256 netDebtInUnderlying,\n        uint32 slippageLimit\n    ) private returns (int256 netPrimeCash) {\n        require(currencyId != vaultConfig.borrowCurrencyId);\n        if (netDebtInUnderlying == 0) return 0;\n\n        if (maturity != Constants.PRIME_CASH_VAULT_MATURITY) {\n            netPrimeCash = VaultConfiguration.executeTrade(\n                currencyId,\n                vaultConfig.vault,\n                maturity,\n                netDebtInUnderlying,\n                slippageLimit,\n                vaultConfig.maxBorrowMarketIndex,\n                block.timestamp\n            );\n\n            // Require that borrows always succeed\n            if (netDebtInUnderlying < 0) require(netPrimeCash > 0, \"Borrow Failed\");\n        }\n\n        // If netPrimeCash is zero then either lending has failed (due to 0% interest) or the maturity\n        // specified is the prime cash maturity. In both cases, calculate the netPrimeCash using the\n        // the prime rate.\n        if (netPrimeCash == 0) {\n            netPrimeCash = pr.convertFromUnderlying(netDebtInUnderlying).neg();\n\n            // See reasoning in VaultAccountLib.lendToExitVault\n            if (maturity != Constants.PRIME_CASH_VAULT_MATURITY) {\n                // Updates some state to track lending at zero for off chain accounting.\n                PrimeCashExchangeRate.updateSettlementReserveForVaultsLendingAtZero(\n                    vaultConfig.vault,\n                    currencyId,\n                    maturity,\n                    netPrimeCash.neg(),\n                    netDebtInUnderlying\n                );\n            }\n        }\n    }\n\n    /**** Secondary Borrow Settlement ****/\n\n    function settleSecondaryBorrow(VaultConfig memory vaultConfig, address account) internal returns (bool) {\n        if (!vaultConfig.hasSecondaryBorrows()) return false;\n\n        VaultAccountSecondaryDebtShareStorage storage accountStorage = \n            LibStorage.getVaultAccountSecondaryDebtShare()[account][vaultConfig.vault];\n        uint256 storedMaturity = accountStorage.maturity;\n\n        // NOTE: we can read account debt directly since prime cash maturities never enter this block of code.\n        int256 accountDebtOne = -int256(uint256(accountStorage.accountDebtOne));\n        int256 accountDebtTwo = -int256(uint256(accountStorage.accountDebtTwo));\n        \n        if (storedMaturity == 0) {\n            // Handles edge condition where an account is holding vault shares past maturity without\n            // any debt position.\n            require(accountDebtOne == 0 && accountDebtTwo == 0);\n        } else {\n            // Prime Cash maturity is uint40.max which means it will revert at this require statement\n            require(storedMaturity <= block.timestamp); // dev: invalid maturity\n        }\n\n        (int256 primeCashRefundOne, int256 primeCashRefundTwo) = VaultAccountLib.clearVaultAccountSecondaryCash(\n            account, vaultConfig.vault\n        );\n\n        bool didTransferOne;\n        if (vaultConfig.secondaryBorrowCurrencies[0] != 0) {\n            (accountDebtOne, didTransferOne) = _settleTotalSecondaryBalance(\n                vaultConfig.vault,\n                account,\n                vaultConfig.secondaryBorrowCurrencies[0],\n                storedMaturity,\n                accountDebtOne,\n                primeCashRefundOne\n            );\n            accountStorage.accountDebtOne = accountDebtOne.neg().toUint().toUint80();\n        }\n\n        bool didTransferTwo;\n        if (vaultConfig.secondaryBorrowCurrencies[1] != 0) {\n            (accountDebtTwo, didTransferTwo) = _settleTotalSecondaryBalance(\n                vaultConfig.vault,\n                account,\n                vaultConfig.secondaryBorrowCurrencies[1],\n                storedMaturity,\n                accountDebtTwo,\n                primeCashRefundTwo\n            );\n            accountStorage.accountDebtTwo = accountDebtTwo.neg().toUint().toUint80();\n        }\n\n        _setAccountMaturity(accountStorage, accountDebtOne, accountDebtTwo, Constants.PRIME_CASH_VAULT_MATURITY);\n\n        return (didTransferOne || didTransferTwo);\n    }\n\n    /// @notice The first account to settle a secondary balance will trigger an update of the total\n    /// borrow capacity on the prime cash vault. This does not affect prime cash utilization, it exists\n    /// to properly update the accounting for the maxBorrowCapacity.\n    function _settleTotalSecondaryBalance(\n        address vault,\n        address account,\n        uint16 currencyId,\n        uint256 maturity,\n        int256 accountfCashDebt,\n        int256 primeCashRefund\n    ) private returns (int256 accountPrimeDebt, bool didTransfer) {\n        PrimeRate memory pr = PrimeRateLib.buildPrimeRateStateful(currencyId);\n\n        VaultStateStorage storage primeSecondaryState = LibStorage.getVaultSecondaryBorrow()\n            [vault][Constants.PRIME_CASH_VAULT_MATURITY][currencyId];\n\n        // NOTE: maturity may be zero in the edge condition of a liquidator who holds vault shares\n        if (maturity != 0) {\n            VaultStateStorage storage totalBalance = \n                LibStorage.getVaultSecondaryBorrow()[vault][maturity][currencyId];\n            int256 totalfCashDebt = -int256(totalBalance.totalDebt);\n\n            if (!totalBalance.isSettled) {\n                VaultStateLib.settleTotalDebtToPrimeCash(\n                    primeSecondaryState, vault, currencyId, maturity, totalfCashDebt\n                );\n\n                totalBalance.isSettled = true;\n                totalBalance.totalDebt = 0;\n            }\n        }\n\n        // address(0) is used here to suppress the emitted event\n        if (maturity != 0) {\n            // When maturity is zero, accountPrimeDebt is zero\n            accountPrimeDebt = PrimeRateLib.convertSettledfCashInVault(\n                currencyId, maturity, accountfCashDebt, address(0)\n            );\n        }\n\n        (accountPrimeDebt, didTransfer) = VaultAccountLib.repayAccountPrimeDebtAtSettlement(\n            pr, primeSecondaryState, currencyId, vault, account, primeCashRefund, accountPrimeDebt\n        );\n\n        // Burn the fCash debt amount\n        Emitter.emitVaultSecondaryDebt(\n            account, vault, currencyId, maturity, accountfCashDebt.neg()\n        );\n\n        // Mint the prime debt amount\n        Emitter.emitVaultSecondaryDebt(\n            account, vault, currencyId, Constants.PRIME_CASH_VAULT_MATURITY, accountPrimeDebt\n        );\n    }\n\n    function _setAccountMaturity(\n        VaultAccountSecondaryDebtShareStorage storage accountStorage,\n        int256 accountDebtOne,\n        int256 accountDebtTwo,\n        uint40 maturity\n    ) private {\n        if (accountDebtOne == 0 && accountDebtTwo == 0) {\n            // If both debt shares are cleared to zero, clear the maturity as well.\n            accountStorage.maturity = 0;\n        } else {\n            // In all other cases, set the account to the designated maturity\n            accountStorage.maturity = maturity;\n        }\n    }\n}"
    },
    {
      "filename": "contracts-v2/contracts/external/actions/VaultLiquidationAction.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport {\n    Token,\n    VaultState,\n    VaultAccountHealthFactors,\n    VaultConfig,\n    VaultAccount,\n    PrimeRate\n} from \"../../global/Types.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {SafeUint256} from \"../../math/SafeUint256.sol\";\nimport {SafeInt256} from \"../../math/SafeInt256.sol\";\n\nimport {ActionGuards} from \"./ActionGuards.sol\";\nimport {Emitter} from \"../../internal/Emitter.sol\";\nimport {PrimeRateLib} from \"../../internal/pCash/PrimeRateLib.sol\";\nimport {VaultConfiguration} from \"../../internal/vaults/VaultConfiguration.sol\";\nimport {VaultAccountLib} from \"../../internal/vaults/VaultAccount.sol\";\nimport {VaultValuation} from \"../../internal/vaults/VaultValuation.sol\";\nimport {VaultSecondaryBorrow} from \"../../internal/vaults/VaultSecondaryBorrow.sol\";\nimport {VaultStateLib} from \"../../internal/vaults/VaultState.sol\";\nimport {TokenHandler} from \"../../internal/balances/TokenHandler.sol\";\n\nimport {SettleAssetsExternal} from \"../SettleAssetsExternal.sol\";\nimport {FreeCollateralExternal} from \"../FreeCollateralExternal.sol\";\n\nimport {\n    IVaultLiquidationAction,\n    IVaultAccountHealth\n} from \"../../../interfaces/notional/IVaultController.sol\";\n\ncontract VaultLiquidationAction is ActionGuards, IVaultLiquidationAction {\n    using VaultConfiguration for VaultConfig;\n    using VaultAccountLib for VaultAccount;\n    using VaultStateLib for VaultState;\n    using PrimeRateLib for PrimeRate;\n    using TokenHandler for Token;\n    using SafeInt256 for int256;\n    using SafeUint256 for uint256;\n\n\n    /// @notice If an account is below the minimum collateral ratio, this method wil deleverage (liquidate)\n    /// that account. `depositAmountPrimeCash` in the borrow currency will be transferred from the liquidator\n    /// and used to offset the account's debt position. The liquidator will receive either vaultShares or\n    /// cash depending.\n    /// @param account the address that will exit the vault\n    /// @param vault the vault to enter\n    /// @param liquidator the address that will receive profits from liquidation\n    /// @param currencyIndex 0 refers to primary borrow, 1 or 2 will refer to one of the secondary\n    /// currencies (if any)\n    /// @param depositUnderlyingInternal amount of underlying to deposit, in 8 decimal underlying precision\n    /// @return vaultSharesToLiquidator amount of vaultShares received from liquidation\n    /// @return depositAmountPrimeCash amount of prime cash deposited from liquidation\n    function deleverageAccount(\n        address account,\n        address vault,\n        address liquidator,\n        uint16 currencyIndex,\n        int256 depositUnderlyingInternal\n    ) external payable nonReentrant override returns (\n        uint256 vaultSharesToLiquidator,\n        int256 depositAmountPrimeCash\n    ) {\n        require(currencyIndex < 3);\n        (\n            VaultConfig memory vaultConfig,\n            VaultAccount memory vaultAccount,\n            VaultState memory vaultState\n        ) = _authenticateDeleverage(account, vault, liquidator);\n\n        PrimeRate memory pr;\n        // Currency Index is validated in this method\n        (\n            depositUnderlyingInternal,\n            vaultSharesToLiquidator,\n            pr\n        ) = IVaultAccountHealth(address(this)).calculateDepositAmountInDeleverage(\n            currencyIndex, vaultAccount, vaultConfig, vaultState, depositUnderlyingInternal\n        );\n\n        uint16 currencyId = vaultConfig.borrowCurrencyId;\n        if (currencyIndex == 1) currencyId = vaultConfig.secondaryBorrowCurrencies[0];\n        else if (currencyIndex == 2) currencyId = vaultConfig.secondaryBorrowCurrencies[1];\n\n        Token memory token = TokenHandler.getUnderlyingToken(currencyId);\n        // Excess ETH is returned to the liquidator natively\n        (/* */, depositAmountPrimeCash) = TokenHandler.depositUnderlyingExternal(\n            liquidator, currencyId, token.convertToExternal(depositUnderlyingInternal), pr, false \n        );\n\n        // Do not skip the min borrow check here\n        vaultAccount.vaultShares = vaultAccount.vaultShares.sub(vaultSharesToLiquidator);\n        if (vaultAccount.maturity == Constants.PRIME_CASH_VAULT_MATURITY) {\n            // Vault account will not incur a cash balance if they are in the prime cash maturity, their debts\n            // will be paid down directly.\n            _reduceAccountDebt(\n                vaultConfig, vaultState, vaultAccount, pr, currencyIndex, depositUnderlyingInternal, true\n            );\n            depositAmountPrimeCash = 0;\n        }\n\n        // Check min borrow in this liquidation method, the deleverage calculation should adhere to the min borrow\n        vaultAccount.setVaultAccountForLiquidation(vaultConfig, currencyIndex, depositAmountPrimeCash, true);\n\n        emit VaultDeleverageAccount(vault, account, currencyId, vaultSharesToLiquidator, depositAmountPrimeCash);\n        emit VaultLiquidatorProfit(vault, account, liquidator, vaultSharesToLiquidator, true);\n\n        _transferVaultSharesToLiquidator(\n            liquidator, vaultConfig, vaultSharesToLiquidator, vaultAccount.maturity\n        );\n\n        Emitter.emitVaultDeleverage(\n            liquidator, account, vault, currencyId, vaultState.maturity,\n            depositAmountPrimeCash, vaultSharesToLiquidator\n        );\n    }\n\n    /// @notice If an account has a cash balance, a liquidator can purchase the cash and provide\n    /// fCash to the account to reduce it's debt balance.\n    function liquidateVaultCashBalance(\n        address account,\n        address vault,\n        address liquidator,\n        uint256 currencyIndex,\n        int256 fCashDeposit\n    ) external nonReentrant override returns (int256 cashToLiquidator) {\n        (\n            VaultConfig memory vaultConfig,\n            VaultAccount memory vaultAccount,\n            VaultState memory vaultState\n        ) = _authenticateDeleverage(account, vault, liquidator);\n\n        uint16 currencyId;\n        PrimeRate memory pr;\n        int256 fCashBalance;\n        int256 cashBalance;\n\n        if (currencyIndex == 0) {\n            currencyId = vaultConfig.borrowCurrencyId;\n            pr = vaultConfig.primeRate;\n            fCashBalance = vaultAccount.accountDebtUnderlying;\n            cashBalance = vaultAccount.tempCashBalance;\n        } else if (currencyIndex < 3) {\n            (currencyId, pr, fCashBalance, cashBalance) = _getSecondaryCashFactors(\n                vaultConfig, currencyIndex, account\n            );\n        } else {\n            revert(); // dev: invalid currency index\n        }\n\n        int256 discountFactor = VaultValuation.getLiquidateCashDiscountFactor(\n            pr, currencyId, vaultAccount.maturity\n        );\n\n        cashToLiquidator = pr.convertFromUnderlying(fCashDeposit.mulInRatePrecision(discountFactor));\n        if (cashToLiquidator > cashBalance) {\n            // Cap the fCash deposit to the cash balance available at the discount factor\n            fCashDeposit = pr.convertToUnderlying(cashBalance).divInRatePrecision(discountFactor);\n            cashToLiquidator = cashBalance;\n        }\n\n        // Cap the fCash deposit to the fcash balance held by the account\n        require(0 < fCashDeposit && fCashDeposit <= fCashBalance.neg());\n\n        _transferCashToVault(\n            vaultAccount, liquidator, vault, currencyId, fCashDeposit, cashToLiquidator\n        );\n\n        _reduceAccountDebt(vaultConfig, vaultState, vaultAccount, pr, currencyIndex, fCashDeposit, false);\n        vaultAccount.setVaultAccountForLiquidation(vaultConfig, currencyIndex, cashToLiquidator.neg(), false);\n    }\n\n    function _transferCashToVault(\n        VaultAccount memory vaultAccount,\n        address liquidator,\n        address vault,\n        uint16 currencyId,\n        int256 fCashDeposit,\n        int256 cashToLiquidator\n    ) internal {\n        bool mustCheckFC = SettleAssetsExternal.transferCashToVaultLiquidator(\n            liquidator, vault, vaultAccount.account, currencyId, vaultAccount.maturity, fCashDeposit, cashToLiquidator\n        );\n\n        if (mustCheckFC) {\n            FreeCollateralExternal.checkFreeCollateralAndRevert(liquidator);\n        }\n        emit VaultAccountCashLiquidation(\n            vault, vaultAccount.account, liquidator, currencyId, fCashDeposit, cashToLiquidator\n        );\n    }\n\n    /// @notice Authenticates a call to the deleverage method\n    function _authenticateDeleverage(\n        address account,\n        address vault,\n        address liquidator\n    ) private returns (\n        VaultConfig memory vaultConfig,\n        VaultAccount memory vaultAccount,\n        VaultState memory vaultState\n    ) {\n        // Do not allow invalid accounts to liquidate\n        requireValidAccount(liquidator);\n        require(liquidator != vault);\n\n        // Cannot liquidate self, if a vault needs to deleverage itself as a whole it has other methods \n        // in VaultAction to do so.\n        require(account != msg.sender);\n        require(account != liquidator);\n\n        vaultConfig = VaultConfiguration.getVaultConfigStateful(vault);\n        require(vaultConfig.getFlag(VaultConfiguration.DISABLE_DELEVERAGE) == false);\n\n        // Authorization rules for deleveraging\n        if (vaultConfig.getFlag(VaultConfiguration.ONLY_VAULT_DELEVERAGE)) {\n            require(msg.sender == vault);\n        } else {\n            require(msg.sender == liquidator);\n        }\n\n        vaultAccount = VaultAccountLib.getVaultAccount(account, vaultConfig);\n\n        // Vault accounts that are not settled must be settled first by calling settleVaultAccount\n        // before liquidation. settleVaultAccount is not permissioned so anyone may settle the account.\n        require(block.timestamp < vaultAccount.maturity, \"Must Settle\");\n\n        if (vaultAccount.maturity == Constants.PRIME_CASH_VAULT_MATURITY) {\n            // Returns the updated prime vault state\n            vaultState = vaultAccount.accruePrimeCashFeesToDebtInLiquidation(vaultConfig);\n        } else {\n            vaultState = VaultStateLib.getVaultState(vaultConfig, vaultAccount.maturity);\n        }\n    }\n\n    function _reduceAccountDebt(\n        VaultConfig memory vaultConfig,\n        VaultState memory vaultState,\n        VaultAccount memory vaultAccount,\n        PrimeRate memory primeRate,\n        uint256 currencyIndex,\n        int256 depositUnderlyingInternal,\n        bool checkMinBorrow\n    ) private {\n        if (currencyIndex == 0) {\n            vaultAccount.updateAccountDebt(vaultState, depositUnderlyingInternal, 0);\n            vaultState.setVaultState(vaultConfig);\n        } else {\n            // Only set one of the prime rates, the other prime rate is not used since\n            // the net debt amount is set to zero\n            PrimeRate[2] memory pr;\n            pr[currencyIndex - 1] = primeRate;\n\n            VaultSecondaryBorrow.updateAccountSecondaryDebt(\n                vaultConfig,\n                vaultAccount.account,\n                vaultAccount.maturity,\n                currencyIndex == 1 ? depositUnderlyingInternal : 0,\n                currencyIndex == 2 ? depositUnderlyingInternal : 0,\n                pr,\n                checkMinBorrow\n            );\n        }\n    }\n\n    /// @notice Transfers l"
    }
  ]
}