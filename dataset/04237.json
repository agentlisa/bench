{
  "Title": "[M01] Complicated state updates",
  "Content": "When stake balances are modified (through [`delegateStake`](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/DelegateManager.sol#L116), [`requestUndelegateStake`](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/DelegateManager.sol#L183), [`cancelUndelegateStake`](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/DelegateManager.sol#L222), [`undelegateStake`](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/DelegateManager.sol#L239), and [`slash`](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/DelegateManager.sol#L432)), multiple operations are executed to increase or decrease the values of the state variables related to the updated stake status. This is error prone, as shown by the critical issue *“A malicious delegator can permanently lock all stake and rewards for a victim service provider and all of its honest delegators”* where one of the values was not correctly updated.\n\n\nA similar pattern is implemented to track the number of votes for [`Governance`](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/Governance.sol) proposals.\n\n\nConsider encapsulating these operations into separate functions, one for each type of state update. This way it will be clearer to review that the operations are complete, consistent, and complementary. Some duplication can be removed, and these functions can be thoroughly tested in isolation.\n\n\nConsider [formal verification](https://en.wikipedia.org/wiki/Formal_verification) to prove that these critical state variables will always behave as expected and keep the system in a consistent state.\n\n\n***Update:** Fixed in [pull request #539](https://github.com/AudiusProject/audius-protocol/pull/539). Most of the logic was encapsulated in new internal functions, such as the [`_updateDelegatorStake`](https://github.com/AudiusProject/audius-protocol/blob/e16dd3e8af4587bacad902bb66a718b60658b972/eth-contracts/contracts/DelegateManager.sol#L150) and the [`_updateServiceProviderLockupAmount`](https://github.com/AudiusProject/audius-protocol/blob/e16dd3e8af4587bacad902bb66a718b60658b972/eth-contracts/contracts/DelegateManager.sol#L813) functions of the `DelegateManager` contract, and the [`_decreaseVoteMagnitudeNo`](https://github.com/AudiusProject/audius-protocol/blob/e16dd3e8af4587bacad902bb66a718b60658b972/eth-contracts/contracts/Governance.sol#L689) and the [`_increaseVoteMagnitudeYes`](https://github.com/AudiusProject/audius-protocol/blob/e16dd3e8af4587bacad902bb66a718b60658b972/eth-contracts/contracts/Governance.sol#L671) functions of the `Governance` contract.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "eth-contracts/contracts/DelegateManager.sol",
      "content": "pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Mintable.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol\";\n/// @notice SafeMath imported via ServiceProviderFactory.sol\n\nimport \"./Staking.sol\";\nimport \"./ServiceProviderFactory.sol\";\nimport \"./ClaimsManager.sol\";\n\n\n/**\n * Designed to manage delegation to staking contract\n */\ncontract DelegateManager is InitializableV2 {\n    using SafeMath for uint256;\n\n    address private tokenAddress;\n    address private governanceAddress;\n    address private stakingAddress;\n    address private serviceProviderFactoryAddress;\n    address private claimsManagerAddress;\n\n    /**\n     * Number of blocks an undelegate operation has to wait\n     * @notice must be >= Governance.votingPeriod\n     */\n    uint private undelegateLockupDuration;\n\n    // Maximum number of delegators a single account can handle\n    uint private maxDelegators;\n\n    // Minimum amount of delegation allowed\n    uint minDelegationAmount;\n\n    // Staking contract ref\n    ERC20Mintable internal audiusToken;\n\n    // Struct representing total delegated to SP and list of delegators\n    struct ServiceProviderDelegateInfo {\n        uint totalDelegatedStake;\n        uint totalLockedUpStake;\n        address[] delegators;\n    }\n\n    // Data structures for lockup during withdrawal\n    struct UndelegateStakeRequest {\n        address serviceProvider;\n        uint amount;\n        uint lockupExpiryBlock;\n    }\n\n    // Service provider address -> ServiceProviderDelegateInfo\n    mapping (address => ServiceProviderDelegateInfo) spDelegateInfo;\n\n    // Total staked for a given delegator\n    mapping (address => uint) delegatorStakeTotal;\n\n    // Delegator stake by address delegated to\n    // delegator -> (service provider -> delegatedStake)\n    mapping (address => mapping(address => uint)) delegateInfo;\n\n    // Requester to pending undelegate request\n    mapping (address => UndelegateStakeRequest) undelegateRequests;\n\n    event IncreaseDelegatedStake(\n      address _delegator,\n      address _serviceProvider,\n      uint _increaseAmount\n    );\n\n    event DecreaseDelegatedStake(\n      address _delegator,\n      address _serviceProvider,\n      uint _decreaseAmount\n    );\n\n    event Claim(\n      address _claimer,\n      uint _rewards,\n      uint newTotal\n    );\n\n    event Slash(\n      address _target,\n      uint _amount,\n      uint _newTotal\n    );\n\n    /**\n     * @notice Function to initialize the contract\n     * @param _tokenAddress - address of ERC20 token that will be claimed\n     * @param _governanceAddress - Governance proxy address\n     */\n    function initialize (\n        address _tokenAddress,\n        address _governanceAddress\n    ) public initializer\n    {\n        tokenAddress = _tokenAddress;\n        governanceAddress = _governanceAddress;\n        audiusToken = ERC20Mintable(tokenAddress);\n        undelegateLockupDuration = 10;\n        maxDelegators = 175;\n        // Default minimum delegation amount set to 100AUD\n        minDelegationAmount = 100 * 10**uint256(18);\n        InitializableV2.initialize();\n    }\n\n    /**\n     * @notice Allow a delegator to delegate stake to a service provider\n     * @param _targetSP - address of service provider to delegate to\n     * @param _amount - amount in wei to delegate\n     * @return Updated total amount delegated to the service provider by delegator\n     */\n    function delegateStake(\n        address _targetSP,\n        uint _amount\n    ) external returns (uint delegatedAmount)\n    {\n        _requireIsInitialized();\n        require(\n            !_claimPending(_targetSP),\n            \"Delegation not permitted for SP pending claim\"\n        );\n        address delegator = msg.sender;\n        Staking stakingContract = Staking(stakingAddress);\n\n        // Stake on behalf of target service provider\n        stakingContract.delegateStakeFor(\n            _targetSP,\n            delegator,\n            _amount\n        );\n\n        // Update list of delegators to SP if necessary\n        if (!_delegatorExistsForSP(delegator, _targetSP)) {\n            // If not found, update list of delegates\n            spDelegateInfo[_targetSP].delegators.push(delegator);\n            require(\n                spDelegateInfo[_targetSP].delegators.length <= maxDelegators,\n                \"Maximum delegators exceeded\"\n            );\n        }\n\n        // Update total delegated for SP\n        spDelegateInfo[_targetSP].totalDelegatedStake = (\n            spDelegateInfo[_targetSP].totalDelegatedStake.add(_amount)\n        );\n\n        // Update amount staked from this delegator to targeted service provider\n        delegateInfo[delegator][_targetSP] = delegateInfo[delegator][_targetSP].add(_amount);\n\n        // Update total delegated stake\n        delegatorStakeTotal[delegator] = delegatorStakeTotal[delegator].add(_amount);\n\n        require(\n            delegatorStakeTotal[delegator] >= minDelegationAmount,\n            \"Minimum delegation amount\"\n        );\n\n        // Validate balance\n        ServiceProviderFactory(\n            serviceProviderFactoryAddress\n        ).validateAccountStakeBalance(_targetSP);\n\n        emit IncreaseDelegatedStake(\n            delegator,\n            _targetSP,\n            _amount\n        );\n\n        // Return new total\n        return delegateInfo[delegator][_targetSP];\n    }\n\n    /**\n     * @notice Submit request for undelegation\n     * @param _target - address of service provider to undelegate stake from\n     * @param _amount - amount in wei to undelegate\n     * @return Updated total amount delegated to the service provider by delegator\n     */\n    function requestUndelegateStake(\n        address _target,\n        uint _amount\n    ) external returns (uint newDelegateAmount)\n    {\n        _requireIsInitialized();\n        require(\n            !_claimPending(_target),\n            \"Undelegate request not permitted for SP pending claim\"\n        );\n        address delegator = msg.sender;\n        require(_delegatorExistsForSP(delegator, _target), \"Delegator must be staked for SP\");\n\n        // Confirm no pending delegation request\n        require(!_undelegateRequestIsPending(delegator), \"No pending lockup expected\");\n\n        // Ensure valid bounds\n        uint currentlyDelegatedToSP = delegateInfo[delegator][_target];\n        require(\n            _amount <= currentlyDelegatedToSP,\n            \"Cannot decrease greater than currently staked for this ServiceProvider\");\n\n        undelegateRequests[delegator] = UndelegateStakeRequest({\n            lockupExpiryBlock: block.number.add(undelegateLockupDuration),\n            amount: _amount,\n            serviceProvider: _target\n        });\n\n        // Update total locked for this service provider\n        spDelegateInfo[_target].totalLockedUpStake = (\n            spDelegateInfo[_target].totalLockedUpStake.add(_amount)\n        );\n\n        return delegatorStakeTotal[delegator].sub(_amount);\n    }\n\n    /**\n     * @notice Cancel undelegation request\n     */\n    function cancelUndelegateStake() external {\n        _requireIsInitialized();\n        address delegator = msg.sender;\n        // Confirm pending delegation request\n        require(_undelegateRequestIsPending(delegator), \"Pending lockup expected\");\n        // Remove pending request\n        undelegateRequests[delegator] = UndelegateStakeRequest({\n            lockupExpiryBlock: 0,\n            amount: 0,\n            serviceProvider: address(0)\n        });\n    }\n\n    /**\n     * @notice Finalize undelegation request and withdraw stake\n     * @return New total amount currently staked after stake has been undelegated\n     */\n    function undelegateStake() external returns (uint newTotal) {\n        _requireIsInitialized();\n        address delegator = msg.sender;\n\n        // Confirm pending delegation request\n        require(_undelegateRequestIsPending(delegator), \"Pending lockup expected\");\n\n        // Confirm lockup expiry has expired\n        require(\n            undelegateRequests[delegator].lockupExpiryBlock <= block.number, \"Lockup must be expired\");\n\n        // Confirm no pending claim for this service provider\n        require(\n            !_claimPending(undelegateRequests[delegator].serviceProvider),\n            \"Undelegate not permitted for SP pending claim\"\n        );\n\n        address serviceProvider = undelegateRequests[delegator].serviceProvider;\n        uint unstakeAmount = undelegateRequests[delegator].amount;\n\n        // Stake on behalf of target service provider\n        Staking(stakingAddress).undelegateStakeFor(\n            serviceProvider,\n            delegator,\n            unstakeAmount\n        );\n\n        // Update amount staked from this delegator to targeted service provider\n        delegateInfo[delegator][serviceProvider] = (\n            delegateInfo[delegator][serviceProvider].sub(unstakeAmount)\n        );\n\n        // Update total delegated stake\n        delegatorStakeTotal[delegator] = delegatorStakeTotal[delegator].sub(unstakeAmount);\n        require(\n            (delegatorStakeTotal[delegator] >= minDelegationAmount ||\n             delegatorStakeTotal[delegator] == 0),\n            \"Minimum delegation amount\"\n        );\n\n        // Update total delegated for SP\n        spDelegateInfo[serviceProvider].totalDelegatedStake = (\n            spDelegateInfo[serviceProvider].totalDelegatedStake.sub(unstakeAmount)\n        );\n\n        // Remove from delegators list if no delegated stake remaining\n        if (delegateInfo[delegator][serviceProvider] == 0) {\n            for (uint i = 0; i < spDelegateInfo[serviceProvider].delegators.length; i++) {\n                if (spDelegateInfo[serviceProvider].delegators[i] == delegator) {\n                    // Overwrite and shrink delegators list\n                    spDelegateInfo[serviceProvider].delegators[i] = spDelegateInfo[serviceProvider].delegators[spDelegateInfo[serviceProvider].delegators.length - 1];\n                    spDelegateInfo[serviceProvider].delegators.length--;\n                    break;\n                }\n            }\n        }\n\n        // Update total locked for this service provider\n        spDelegateInfo[serviceProvider].totalLockedUpStake = (\n            spDelegateInfo[serviceProvider].totalLockedUpStake.sub(unstakeAmount)\n        );\n\n        // Reset lockup information\n        undelegateRequests[delegator] = UndelegateStakeRequest({\n            lockupExpiryBlock: 0,\n            amount: 0,\n            serviceProvider: address(0)\n        });\n\n        // Validate balance\n        ServiceProviderFactory(\n            serviceProviderFactoryAddress\n        ).validateAccountStakeBalance(serviceProvider);\n\n        emit DecreaseDelegatedStake(\n            delegator,\n            serviceProvider,\n            unstakeAmount);\n\n        // Return new total\n        return delegateInfo[delegator][serviceProvider];\n    }\n\n    /**\n     * @notice Claim and distribute rewards to delegators and service provider as necessary\n     * @dev Only callable by service provider. msg.sender is passed into processClaim\n     * @dev Also factors in service provider rewards from delegator and transfers deployer cut\n     */\n    function claimRewards() external {\n        _requireIsInitialized();\n        require(\n            serviceProviderFactoryAddress != address(0x00),\n            \"serviceProviderFactoryAddress not set\"\n        );\n        require(claimsManagerAddress != address(0x00), \"claimsManagerAddress not set\");\n        require(stakingAddress != address(0x00), \"stakingAddress not set\");\n\n        ServiceProviderFactory spFactory = ServiceProviderFactory(serviceProviderFactoryAddress);\n\n        (\n            uint totalBalanceInStaking,\n            uint totalBalanceInSPFactory,\n            uint totalBalanceOutsideStaking\n        ) = _validateClaimRewards(spFactory);\n\n        // No-op if balance is already equivalent\n        // This case can occur if no rewards due to bound violation or all stake is locked\n        if (totalBalanceInStaking == totalBalanceOutsideStaking) {\n            return;\n        }\n\n        // Total rewards\n        // Equal to (balance in staking) - ((balance in sp factory) + (balance in delegate manager))\n        uint totalRewards = totalBalanceInStaking.sub(totalBalanceOutsideStaking);\n\n        // Emit claim event\n        emit Claim(msg.sender, totalRewards, totalBalanceInStaking);\n\n        ( ,uint deployerCut, , , , ) = spFactory.getServiceProviderDetails(msg.sender);\n        uint deployerCutBase = spFactory.getServiceProviderDeployerCutBase();\n        uint spDeployerCutRewards = 0;\n        uint totalDelegatedStakeIncrease = 0;\n\n        // Total valid funds used to calculate rewards distribution\n        uint totalActiveFunds = (\n            totalBalanceOutsideStaking.sub(spDelegateInfo[msg.sender].totalLockedUpStake)\n        );\n\n        // Traverse all delegates and calculate their rewards\n        // As each delegate reward is calculated, increment SP cut reward accordingly\n        for (uint i = 0; i < spDelegateInfo[msg.sender].delegators.length; i++) {\n            address delegator = spDelegateInfo[msg.sender].delegators[i];\n            uint delegateStakeToSP = delegateInfo[delegator][msg.sender];\n\n            // Subtract any locked up stake\n            if (undelegateRequests[delegator].serviceProvider == msg.sender) {\n                delegateStakeToSP = delegateStakeToSP.sub(undelegateRequests[delegator].amount);\n            }\n\n            // Calculate rewards by ((delegateStakeToSP / totalActiveFunds) * totalRewards)\n            uint rewardsPriorToSPCut = (\n              delegateStakeToSP.mul(totalRewards)\n            ).div(totalActiveFunds);\n\n            // Multiply by deployer cut fraction to calculate reward for SP\n            // Operation constructed to perform all multiplication prior to division\n            // uint spDeployerCut = (rewardsPriorToSPCut * deployerCut ) / (deployerCutBase);\n            //                    = ((delegateStakeToSP * totalRewards) / totalActiveFunds) * deployerCut ) / (deployerCutBase);\n            //                    = ((delegateStakeToSP * totalRewards * deployerCut) / totalActiveFunds ) / (deployerCutBase);\n            //                    = (delegateStakeToSP * totalRewards * deployerCut) / (deployerCutBase * totalActiveFunds);\n            uint spDeployerCut = (\n                (delegateStakeToSP.mul(totalRewards)).mul(deployerCut)\n            ).div(\n                totalActiveFunds.mul(deployerCutBase)\n            );\n            spDeployerCutRewards = spDeployerCutRewards.add(spDeployerCut);\n            // Increase total delegate reward in DelegateManager\n            // Subtract SP reward from rewards to calculate delegate reward\n            // delegateReward = rewardsPriorToSPCut - spDeployerCut;\n            delegateInfo[delegator][msg.sender] = (\n                delegateInfo[delegator][msg.sender].add(rewardsPriorToSPCut.sub(spDeployerCut))\n            );\n            delegatorStakeTotal[delegator] = (\n                delegatorStakeTotal[delegator].add(rewardsPriorToSPCut.sub(spDeployerCut))\n            );\n            totalDelegatedStakeIncrease = (\n                totalDelegatedStakeIncrease.add(rewardsPriorToSPCut.sub(spDeployerCut))\n            );\n        }\n\n        // Update total delegated to this SP\n        spDelegateInfo[msg.sender].totalDelegatedStake = (\n            spDelegateInfo[msg.sender].totalDelegatedStake.add(totalDelegatedStakeIncrease)\n        );\n\n        // Rewards directly allocated to service provider for their stake\n        uint spRewardShare = (\n          totalBalanceInSPFactory.mul(totalRewards)\n        ).div(totalActiveFunds);\n\n        spFactory.updateServiceProviderStake(\n            msg.sender,\n            /// newSpBalance = totalBalanceInSPFactory + spRewardShare + spDeployerCutRewards;\n            totalBalanceInSPFactory.add(spRewardShare.add(spDeployerCutRewards))\n        );\n    }\n\n    /**\n     * @notice Reduce current stake amount\n     * @dev Only callable by governance. Slashes service provider and delegators equally\n     * @param _amount - amount in wei to slash\n     * @param _slashAddress - address of service provider to slash\n     */\n    function slash(uint _amount, address _slashAddress)\n    external\n    {\n        _requireIsInitialized();\n\n        require(\n            msg.sender == governanceAddress,\n            \"Only callable by Governance contract\"\n        );\n\n        Staking stakingContract = Staking(stakingAddress);\n        ServiceProviderFactory spFactory = ServiceProviderFactory(serviceProviderFactoryAddress);\n\n        // Amount stored in staking contract for owner\n        uint totalBalanceInStakingPreSlash = stakingContract.totalStakedFor(_slashAddress);\n        require(\n            (totalBalanceInStakingPreSlash >= _amount),\n            \"Cannot slash more than total currently staked\");\n\n        // Cancel any withdrawal request for this service provider\n        (uint spLockedStake,) = spFactory.getPendingDecreaseStakeRequest(_slashAddress);\n        if (spLockedStake > 0) {\n            spFactory.cancelDecreaseStakeRequest(_slashAddress);\n        }\n\n        // Amount in sp factory for slash target\n        (uint totalBalanceInSPFactory,,,,,) = spFactory.getServiceProviderDetails(_slashAddress);\n        require(totalBalanceInSPFactory > 0, \"Service Provider stake required\");\n\n        // Decrease value in Staking contract\n        // A value of zero slash will fail in staking, reverting this transaction\n        stakingContract.slash(_amount, _slashAddress);\n        uint totalBalanceInStakingAfterSlash = stakingContract.totalStakedFor(_slashAddress);\n\n        // Emit slash event\n        emit Slash(_slashAddress, _amount, totalBalanceInStakingAfterSlash);\n\n        uint totalDelegatedStakeDecrease = 0;\n        // For each delegator and deployer, recalculate new value\n        // newStakeAmount = newStakeAmount * (oldStakeAmount / totalBalancePreSlash)\n        for (uint i = 0; i < spDelegateInfo[_slashAddress].delegators.length; i++) {\n            address delegator = spDelegateInfo[_slashAddress].delegators[i];\n            uint preSlashDelegateStake = delegateInfo[delegator][_slashAddress];\n            uint newDelegateStake = (\n             totalBalanceInStakingAfterSlash.mul(preSlashDelegateStake)\n            ).div(totalBalanceInStakingPreSlash);\n            // uint slashAmountForDelegator = preSlashDelegateStake.sub(newDelegateStake);\n            delegateInfo[delegator][_slashAddress] = (\n                delegateInfo[delegator][_slashAddress].sub(preSlashDelegateStake.sub(newDelegateStake))\n            );\n            delegatorStakeTotal[delegator] = (\n                delegatorStakeTotal[delegator].sub(preSlashDelegateStake.sub(newDelegateStake))\n            );\n            // Update total decrease amount\n            totalDelegatedStakeDecrease = (\n                totalDelegatedStakeDecrease.add(preSlashDelegateStake.sub(newDelegateStake))\n            );\n            // Check for any locked up funds for this slashed delegator\n            // Slash overrides any pending withdrawal requests\n            if (undelegateRequests[delegator].amount != 0) {\n                address unstakeSP = undelegateRequests[delegator].serviceProvider;\n                uint unstakeAmount = undelegateRequests[delegator].amount;\n                // Reset total locked up stake\n                spDelegateInfo[unstakeSP].totalLockedUpStake = (\n                    spDelegateInfo[unstakeSP].totalLockedUpStake.sub(unstakeAmount)\n                );\n                // Remove pending request\n                undelegateRequests[delegator] = UndelegateStakeRequest({\n                    lockupExpiryBlock: 0,\n                    amount: 0,\n                    serviceProvider: address(0)\n                });\n            }\n        }\n\n        // Update total delegated to this SP\n        spDelegateInfo[_slashAddress].totalDelegatedStake = (\n            spDelegateInfo[_slashAddress].totalDelegatedStake.sub(totalDelegatedStakeDecrease)\n        );\n\n        // Recalculate SP direct stake\n        uint newSpBalance = (\n          totalBalanceInStakingAfterSlash.mul(totalBalanceInSPFactory)\n        ).div(totalBalanceInStakingPreSlash);\n        spFactory.updateServiceProviderStake(_slashAddress, newSpBalance);\n    }\n\n    /**\n     * @notice Update duration for undelegate request lockup\n     * @param _duration - new lockup duration\n     */\n    function updateUndelegateLockupDuration(uint _duration) external {\n        _requireIsInitialized();\n\n        require(\n            msg.sender == governanceAddress,\n            \"Only callable by Governance contract\"\n        );\n\n        undelegateLockupDuration = _duration;\n    }\n\n    /**\n     * @notice Update maximum delegators allowed\n     * @param _maxDelegators - new max delegators\n     */\n    function updateMaxDelegators(uint _maxDelegators) external {\n        _requireIsInitialized();\n\n        require(\n            msg.sender == governanceAddress,\n            \"Only callable by Governance contract\"\n        );\n\n        maxDelegators = _maxDelegators;\n    }\n\n    /**\n     * @notice Update minimum delegation amount\n     * @param _minDelegationAmount - min new min delegation amount\n     */\n    function updateMinDelegationAmount(uint _minDelegationAmount) external {\n        _requireIsInitialized();\n\n        require(\n            msg.sender == governanceAddress,\n            \"Only callable by Governance contract\"\n        );\n\n        minDelegationAmount = _minDelegationAmount;\n    }\n\n    /**\n     * @notice Set the Governance address\n     * @dev Only callable by Governance address\n     * @param _governanceAddress - address for new Governance contract\n     */\n    function setGovernanceAddress(address _governanceAddress) external {\n        require(msg.sender == governanceAddress, \"Only governance\");\n        governanceAddress = _governanceAddress;\n    }\n\n    /**\n     * @notice Set the Staking address\n     * @dev Only callable by Governance address\n     * @param _address - address for new Staking contract\n     */\n    function setStakingAddress(address _address) external {\n        require(msg.sender == governanceAddress, \"Only governance\");\n        stakingAddress = _address;\n    }\n\n    /**\n     * @notice Set the ServiceProviderFactory address\n     * @dev Only callable by Governance address\n     * @param _spFactory - address for new ServiceProviderFactory contract\n     */\n    function setServiceProviderFactoryAddress(address _spFactory) external {\n        require(msg.sender == governanceAddress, \"Only governance\");\n        serviceProviderFactoryAddress = _spFactory;\n    }\n\n    /**\n     * @notice Set the ClaimsManager address\n     * @dev Only callable by Governance address\n     * @param _claimsManagerAddress - address for new ClaimsManager contract\n     */\n    function setClaimsManagerAddress(address _claimsManagerAddress) external {\n        require(msg.sender == governanceAddress, \"Only governance\");\n        claimsManagerAddress = _claimsManagerAddress;\n    }\n\n    // ========================================= View Functions =========================================\n\n    /**\n     * @notice Get list of delegators for a given service provider\n     * @param _sp - service provider address\n     */\n    function getDelegatorsList(address _sp)\n    external view returns (address[] memory dels)\n    {\n        return spDelegateInfo[_sp].delegators;\n    }\n\n    /// @notice Get total amount delegated to a service provider\n    function getTotalDelegatedToServiceProvider(address _sp)\n    external view returns (uint total)\n    {\n        return spDelegateInfo[_sp].totalDelegatedStake;\n    }\n\n    /// @notice Get total delegated stake locked up for a service provider\n    function getTotalLockedDelegationForServiceProvider(address _sp)\n    external view returns (uint total)\n    {\n        return spDelegateInfo[_sp].totalLockedUpStake;\n    }\n\n    /// @notice Get total currently staked for a delegator, across service providers\n    function getTotalDelegatorStake(address _delegator)\n    external view returns (uint amount)\n    {\n        return delegatorStakeTotal[_delegator];\n    }\n\n    /// @notice Get total currently staked for a delegator, for a given service provider\n    function getDelegatorStakeForServiceProvider(address _delegator, address _serviceProvider)\n    external view returns (uint amount)\n    {\n        return delegateInfo[_delegator][_serviceProvider];\n    }\n\n    /**\n     * @notice Get status of pending undelegate request for a given address\n     * @param _delegator - address of the delegator\n     */\n    function getPendingUndelegateRequest(address _delegator)\n    external view returns (address target, uint amount, uint lockupExpiryBlock)\n    {\n        UndelegateStakeRequest memory req = undelegateRequests[_delegator];\n        return (req.serviceProvider, req.amount, req.lockupExpiryBlock);\n    }\n\n    /// @notice Get current undelegate lockup duration\n    function getUndelegateLockupDuration()\n    external view returns (uint duration)\n    {\n        return undelegateLockupDuration;\n    }\n\n    /// @notice Current maximum delegators\n    function getMaxDelegators()\n    external view returns (uint numDelegators)\n    {\n        return maxDelegators;\n    }\n\n    /// @notice Get minimum delegation amount\n    function getMinDelegationAmount()\n    external view returns (uint minDelegation)\n    {\n        return minDelegationAmount;\n    }\n\n    /// @notice Get the Governance address\n    function getGovernanceAddress() external view returns (address addr) {\n        return governanceAddress;\n    }\n\n    /// @notice Get the ServiceProviderFactory address\n    function getServiceProviderFactoryAddress() external view returns (address addr) {\n        return serviceProviderFactoryAddress;\n    }\n\n    /// @notice Get the ClaimsManager address\n    function getClaimsManagerAddress() external view returns (address addr) {\n        return claimsManagerAddress;\n    }\n\n    /// @notice Get the Staking address\n    function getStakingAddress() external view returns (address addr)\n    {\n        return stakingAddress;\n    }\n\n    // ========================================= Internal functions =========================================\n\n    /**\n     * @notice Helper function for claimRewards to get balances from Staking contract\n               and do validation\n     * @param spFactory - reference to ServiceProviderFactory contract\n     * @return (totalBalanceInStaking, totalBalanceInSPFactory, totalBalanceOutsideStaking)\n     */\n    function _validateClaimRewards(ServiceProviderFactory spFactory)\n    internal returns (uint totalBalanceInStaking, uint totalBalanceInSPFactory, uint totalBalanceOutsideStaking)\n        {\n\n        // Account for any pending locked up stake for the service provider\n        (uint spLockedStake,) = spFactory.getPendingDecreaseStakeRequest(msg.sender);\n\n        // Process claim for msg.sender\n        // Total locked parameter is equal to delegate locked up stake + service provider locked up stake\n        ClaimsManager(claimsManagerAddress).processClaim(\n            msg.sender,\n            (spDelegateInfo[msg.sender].totalLockedUpStake.add(spLockedStake))\n        );\n\n        // Amount stored in staking contract for owner\n        uint _totalBalanceInStaking = Staking(stakingAddress).totalStakedFor(msg.sender);\n        require(_totalBalanceInStaking > 0, \"Stake required for claim\");\n\n        // Amount in sp factory for claimer\n        (uint _totalBalanceInSPFactory,,,,,) = spFactory.getServiceProviderDetails(msg.sender);\n\n        // Decrease total balance by any locked up stake\n        _totalBalanceInSPFactory = _totalBalanceInSPFactory.sub(spLockedStake);\n\n        // Require active stake to claim any rewards\n        require(_totalBalanceInSPFactory > 0, \"Service Provider stake required\");\n\n        // Amount in delegate manager staked to service provider\n        uint _totalBalanceOutsideStaking = (\n            _totalBalanceInSPFactory.add(spDelegateInfo[msg.sender].totalDelegatedStake)\n        );\n\n        return (_totalBalanceInStaking, _totalBalanceInSPFactory, _totalBalanceOutsideStaking);\n    }\n\n    /**\n     * @notice Returns if delegator has delegated to a service provider\n     * @param _delegator - address of delegator\n     * @param _serviceProvider - address of service provider\n     */\n    function _delegatorExistsForSP(\n        address _delegator,\n        address _serviceProvider\n    ) internal view returns (bool exists)\n    {\n        for (uint i = 0; i < spDelegateInfo[_serviceProvider].delegators.length; i++) {\n            if (spDelegateInfo[_serviceProvider].delegators[i] == _delegator) {\n                return true;\n            }\n        }\n        // Not found\n        return false;\n    }\n\n    /**\n     * @notice Boolean indicating whether a claim is pending for this service provider\n     * @param _sp - address of service provider\n     */\n    function _claimPending(address _sp) internal view returns (bool pending) {\n        ClaimsManager claimsManager = ClaimsManager(claimsManagerAddress);\n        return claimsManager.claimPending(_sp);\n    }\n\n    /**\n     * @notice Boolean indicating whether a decrease request has been initiated\n     * @param _delegator - address of delegator\n     */\n    function _undelegateRequestIsPending(address _delegator) internal view returns (bool pending)\n    {\n        return (\n            (undelegateRequests[_delegator].lockupExpiryBlock != 0) &&\n            (undelegateRequests[_delegator].amount != 0) &&\n            (undelegateRequests[_delegator].serviceProvider != address(0))\n        );\n    }\n}"
    }
  ]
}