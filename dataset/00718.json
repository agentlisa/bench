{
  "Title": "M-4: High-risk actions aren't all covered by the existing checks",
  "Content": "# Issue M-4: High-risk actions aren't all covered by the existing checks \n\nSource: https://github.com/sherlock-audit/2024-01-olympus-on-chain-governance-judging/issues/104 \n\n## Found by \nIllIllI, LTDingZhen, cawfree, ck\n## Summary\n\nThings such as changing the list of high risk operations, or migrating kernels are not counted as high risk, even though they are high-risk\n\n\n## Vulnerability Detail\n\nHigh risk modules are checked against a mapping, but the changing of values within the mapping is not marked as high risk.\n\nIn addition, the `MigrateKernel` action is not protected, even though it can [brick the protocol](https://github.com/sherlock-audit/2024-01-olympus-on-chain-governance/blob/main/bophades/src/Kernel.sol#L338)\n\n\n## Impact\n\nAllows an attacker to brick the protocol with a low threshold, or to remove the high-risk modules from the list of high risk modules, resulting in a lower threshold\nViolates invariant of high-risk actions needing to be behind a higher quorum\n\n\n## Code Snippet\n\n`MigrateKernel` isn't considered high-risk, and neither are calls to [`_setModuleRiskLevel()`](https://github.com/sherlock-audit/2024-01-olympus-on-chain-governance/blob/main/bophades/src/external/governance/GovernorBravoDelegate.sol#L593-L602):\n```solidity\n// File: src/external/governance/GovernorBravoDelegate.sol : GovernorBravoDelegate._isHighRiskProposal()   #1\n\n647 @>                     // If the action is upgrading a module (1)\n648                        if (action == 1) {\n649                            // Check if the module has a high risk keycode\n650                            if (isKeycodeHighRisk[Module(actionTarget).KEYCODE()]) return true;\n651                        }\n652 @>                     // If the action is installing (2) or deactivating (3) a policy, pull the list of dependencies\n653                        else if (action == 2 || action == 3) {\n654                            // Call `configureDependencies` on the policy\n655                            Keycode[] memory dependencies = Policy(actionTarget)\n656                                .configureDependencies();\n657    \n658                            // Iterate over dependencies and looks for high risk keycodes\n659                            uint256 numDeps = dependencies.length;\n660                            for (uint256 j; j < numDeps; j++) {\n661                                Keycode dep = dependencies[j];\n662                                if (isKeycodeHighRisk[dep]) return true;\n663                            }\n664:                       }\n```\nhttps://github.com/sherlock-audit/2024-01-olympus-on-chain-governance/blob/main/bophades/src/external/governance/GovernorBravoDelegate.sol#L647-L664\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nAdd those operations to the high risk category\n\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**haxatron** commented:\n> Medium. Bypass of a non-critical security feature for MigrateKernel(). I would say setModuleRiskLevel() part doesn't count because it requires 2 proposals to succeed. Nice catch!\n\n\n\n**0xLienid**\n\nFix: https://github.com/OlympusDAO/bophades/pull/298\n\n**IllIllI000**\n\nThe [PR](https://github.com/OlympusDAO/bophades/pull/298) properly adds the operations in the recommendation to the list of what's considered high risk, as well as the recommendations from all of the duplicates. This is done by returning `true` for anything with a target of the timelock or delegator, or for any kernel migration or executor change. The PR also adds tests.\n\n**s1ce**\n\nEscalate\n\nThis is an informational issue. There are comments in the code which specifically describe the modules that the sponsors consider to be high risk , so would consider this to be a design decision. \n\nFor example, the following comments: \n\n`// If the action is upgrading a module (1)`\n\n`// If the action is installing (2) or deactivating (3) a policy, pull the list of dependencies`\n\n**sherlock-admin2**\n\n> Escalate\n> \n> This is an informational issue. There are comments in the code which specifically describe the modules that the sponsors consider to be high risk , so would consider this to be a design decision. \n> \n> For example, the following comments: \n> \n> `// If the action is upgrading a module (1)`\n> \n> `// If the action is installing (2) or deactivating (3) a policy, pull the list of dependencies`\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**nevillehuang**\n\n@IllIllI000 any comments? I think this is not informational, because sensitive actions like this should consistently have appropriate quorums in place and not break the [high risk invariant](https://github.com/sherlock-audit/2024-01-olympus-on-chain-governance/blob/main/bophades/audit/2024-01_governance/README.md#proposal-quorum-threshold) allowing for execution with lower votes than normal. This cannot be seen as a documentation and design decision error given an explicit fix has been made.\n\nHowever, considering the veto mechanism, I can see where @s1ce is coming from.\n\n**IllIllI000**\n\nI think the Sherlock team will need to decide what they want to do for this sort of case, since bricking the protocol is an unambiguously dangerous ability, and the purpose of the feature is to prevent that sort of thing (or else why not just rely on vetos for everything). The readme also says `The proposal can be vetoed at any time (before execution) by the veto guardian. Initially, this role will belong to the DAO multisig. However, once the system matures, it could be set to the zero address.`, so at some point in the future, there will be nobody to veto anything.\n\n**0xLienid**\n\nPersonally think this is a medium. These are definitionally high risk changes.\n\n**nevillehuang**\n\n> I think the Sherlock team will need to decide what they want to do for this sort of case, since bricking the protocol is an unambiguously dangerous ability, and the purpose of the feature is to prevent that sort of thing (or else why not just rely on vetos for everything). The readme also says `The proposal can be vetoed at any time (before execution) by the veto guardian. Initially, this role will belong to the DAO multisig. However, once the system matures, it could be set to the zero address.`, so at some point in the future, there will be nobody to veto anything.\n\nExtremely good point, I think this should remain as medium severity.\n\n**Czar102**\n\nAgree with @nevillehuang, @0xLienid and @IllIllI000. It seems managing policies is strictly safer than migrating the whole kernel.\n\nPlanning to reject the escalation and leave the issue as is.\n\n**Czar102**\n\nResult:\nMedium\nHas duplicates\n\n**sherlock-admin**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [s1ce](https://github.com/sherlock-audit/2024-01-olympus-on-chain-governance-judging/issues/104/#issuecomment-1917422380): rejected\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/155",
  "Code": [
    {
      "filename": "bophades/src/Kernel.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n//     ███████    █████       █████ █████ ██████   ██████ ███████████  █████  █████  █████████\n//   ███░░░░░███ ░░███       ░░███ ░░███ ░░██████ ██████ ░░███░░░░░███░░███  ░░███  ███░░░░░███\n//  ███     ░░███ ░███        ░░███ ███   ░███░█████░███  ░███    ░███ ░███   ░███ ░███    ░░░\n// ░███      ░███ ░███         ░░█████    ░███░░███ ░███  ░██████████  ░███   ░███ ░░█████████\n// ░███      ░███ ░███          ░░███     ░███ ░░░  ░███  ░███░░░░░░   ░███   ░███  ░░░░░░░░███\n// ░░███     ███  ░███      █    ░███     ░███      ░███  ░███         ░███   ░███  ███    ░███\n//  ░░░███████░   ███████████    █████    █████     █████ █████        ░░████████  ░░█████████\n//    ░░░░░░░    ░░░░░░░░░░░    ░░░░░    ░░░░░     ░░░░░ ░░░░░          ░░░░░░░░    ░░░░░░░░░\n\n//============================================================================================//\n//                                        GLOBAL TYPES                                        //\n//============================================================================================//\n\n/// @notice Actions to trigger state changes in the kernel. Passed by the executor\nenum Actions {\n    InstallModule,\n    UpgradeModule,\n    ActivatePolicy,\n    DeactivatePolicy,\n    ChangeExecutor,\n    MigrateKernel\n}\n\n/// @notice Used by executor to select an action and a target contract for a kernel action\nstruct Instruction {\n    Actions action;\n    address target;\n}\n\n/// @notice Used to define which module functions a policy needs access to\nstruct Permissions {\n    Keycode keycode;\n    bytes4 funcSelector;\n}\n\ntype Keycode is bytes5;\n\n//============================================================================================//\n//                                       UTIL FUNCTIONS                                       //\n//============================================================================================//\n\nerror TargetNotAContract(address target_);\nerror InvalidKeycode(Keycode keycode_);\n\n// solhint-disable-next-line func-visibility\nfunction toKeycode(bytes5 keycode_) pure returns (Keycode) {\n    return Keycode.wrap(keycode_);\n}\n\n// solhint-disable-next-line func-visibility\nfunction fromKeycode(Keycode keycode_) pure returns (bytes5) {\n    return Keycode.unwrap(keycode_);\n}\n\n// solhint-disable-next-line func-visibility\nfunction ensureContract(address target_) view {\n    if (target_.code.length == 0) revert TargetNotAContract(target_);\n}\n\n// solhint-disable-next-line func-visibility\nfunction ensureValidKeycode(Keycode keycode_) pure {\n    bytes5 unwrapped = Keycode.unwrap(keycode_);\n    for (uint256 i = 0; i < 5; ) {\n        bytes1 char = unwrapped[i];\n        if (char < 0x41 || char > 0x5A) revert InvalidKeycode(keycode_); // A-Z only\n        unchecked {\n            i++;\n        }\n    }\n}\n\n//============================================================================================//\n//                                        COMPONENTS                                          //\n//============================================================================================//\n\n/// @notice Generic adapter interface for kernel access in modules and policies.\nabstract contract KernelAdapter {\n    error KernelAdapter_OnlyKernel(address caller_);\n\n    Kernel public kernel;\n\n    constructor(Kernel kernel_) {\n        kernel = kernel_;\n    }\n\n    /// @notice Modifier to restrict functions to be called only by kernel.\n    modifier onlyKernel() {\n        if (msg.sender != address(kernel)) revert KernelAdapter_OnlyKernel(msg.sender);\n        _;\n    }\n\n    /// @notice Function used by kernel when migrating to a new kernel.\n    function changeKernel(Kernel newKernel_) external onlyKernel {\n        kernel = newKernel_;\n    }\n}\n\n/// @notice Base level extension of the kernel. Modules act as independent state components to be\n///         interacted with and mutated through policies.\n/// @dev    Modules are installed and uninstalled via the executor.\nabstract contract Module is KernelAdapter {\n    error Module_PolicyNotPermitted(address policy_);\n\n    constructor(Kernel kernel_) KernelAdapter(kernel_) {}\n\n    /// @notice Modifier to restrict which policies have access to module functions.\n    modifier permissioned() {\n        if (\n            msg.sender == address(kernel) ||\n            !kernel.modulePermissions(KEYCODE(), Policy(msg.sender), msg.sig)\n        ) revert Module_PolicyNotPermitted(msg.sender);\n        _;\n    }\n\n    /// @notice 5 byte identifier for a module.\n    function KEYCODE() public pure virtual returns (Keycode) {}\n\n    /// @notice Returns which semantic version of a module is being implemented.\n    /// @return major - Major version upgrade indicates breaking change to the interface.\n    /// @return minor - Minor version change retains backward-compatible interface.\n    function VERSION() external pure virtual returns (uint8 major, uint8 minor) {}\n\n    /// @notice Initialization function for the module\n    /// @dev    This function is called when the module is installed or upgraded by the kernel.\n    /// @dev    MUST BE GATED BY onlyKernel. Used to encompass any initialization or upgrade logic.\n    function INIT() external virtual onlyKernel {}\n}\n\n/// @notice Policies are application logic and external interface for the kernel and installed modules.\n/// @dev    Policies are activated and deactivated in the kernel by the executor.\n/// @dev    Module dependencies and function permissions must be defined in appropriate functions.\nabstract contract Policy is KernelAdapter {\n    error Policy_ModuleDoesNotExist(Keycode keycode_);\n    error Policy_WrongModuleVersion(bytes expected_);\n\n    constructor(Kernel kernel_) KernelAdapter(kernel_) {}\n\n    /// @notice Easily accessible indicator for if a policy is activated or not.\n    function isActive() external view returns (bool) {\n        return kernel.isPolicyActive(this);\n    }\n\n    /// @notice Function to grab module address from a given keycode.\n    function getModuleAddress(Keycode keycode_) internal view returns (address) {\n        address moduleForKeycode = address(kernel.getModuleForKeycode(keycode_));\n        if (moduleForKeycode == address(0)) revert Policy_ModuleDoesNotExist(keycode_);\n        return moduleForKeycode;\n    }\n\n    /// @notice Define module dependencies for this policy.\n    /// @return dependencies - Keycode array of module dependencies.\n    function configureDependencies() external virtual returns (Keycode[] memory dependencies) {}\n\n    /// @notice Function called by kernel to set module function permissions.\n    /// @return requests - Array of keycodes and function selectors for requested permissions.\n    function requestPermissions() external view virtual returns (Permissions[] memory requests) {}\n}\n\n/// @notice Main contract that acts as a central component registry for the protocol.\n/// @dev    The kernel manages modules and policies. The kernel is mutated via predefined Actions,\n/// @dev    which are input from any address assigned as the executor. The executor can be changed as needed.\ncontract Kernel {\n    // =========  EVENTS ========= //\n\n    event PermissionsUpdated(\n        Keycode indexed keycode_,\n        Policy indexed policy_,\n        bytes4 funcSelector_,\n        bool granted_\n    );\n    event ActionExecuted(Actions indexed action_, address indexed target_);\n\n    // =========  ERRORS ========= //\n\n    error Kernel_OnlyExecutor(address caller_);\n    error Kernel_ModuleAlreadyInstalled(Keycode module_);\n    error Kernel_InvalidModuleUpgrade(Keycode module_);\n    error Kernel_PolicyAlreadyActivated(address policy_);\n    error Kernel_PolicyNotActivated(address policy_);\n\n    // =========  PRIVILEGED ADDRESSES ========= //\n\n    /// @notice Address that is able to initiate Actions in the kernel. Can be assigned to a multisig or governance contract.\n    address public executor;\n\n    // =========  MODULE MANAGEMENT ========= //\n\n    /// @notice Array of all modules currently installed.\n    Keycode[] public allKeycodes;\n\n    /// @notice Mapping of module address to keycode.\n    mapping(Keycode => Module) public getModuleForKeycode;\n\n    /// @notice Mapping of keycode to module address.\n    mapping(Module => Keycode) public getKeycodeForModule;\n\n    /// @notice Mapping of a keycode to all of its policy dependents. Used to efficiently reconfigure policy dependencies.\n    mapping(Keycode => Policy[]) public moduleDependents;\n\n    /// @notice Helper for module dependent arrays. Prevents the need to loop through array.\n    mapping(Keycode => mapping(Policy => uint256)) public getDependentIndex;\n\n    /// @notice Module <> Policy Permissions.\n    /// @dev    Keycode -> Policy -> Function Selector -> bool for permission\n    mapping(Keycode => mapping(Policy => mapping(bytes4 => bool))) public modulePermissions;\n\n    // =========  POLICY MANAGEMENT ========= //\n\n    /// @notice List of all active policies\n    Policy[] public activePolicies;\n\n    /// @notice Helper to get active policy quickly. Prevents need to loop through array.\n    mapping(Policy => uint256) public getPolicyIndex;\n\n    //============================================================================================//\n    //                                       CORE FUNCTIONS                                       //\n    //============================================================================================//\n\n    constructor() {\n        executor = msg.sender;\n    }\n\n    /// @notice Modifier to check if caller is the executor.\n    modifier onlyExecutor() {\n        if (msg.sender != executor) revert Kernel_OnlyExecutor(msg.sender);\n        _;\n    }\n\n    function isPolicyActive(Policy policy_) public view returns (bool) {\n        return activePolicies.length > 0 && activePolicies[getPolicyIndex[policy_]] == policy_;\n    }\n\n    /// @notice Main kernel function. Initiates state changes to kernel depending on Action passed in.\n    function executeAction(Actions action_, address target_) external onlyExecutor {\n        if (action_ == Actions.InstallModule) {\n            ensureContract(target_);\n            ensureValidKeycode(Module(target_).KEYCODE());\n            _installModule(Module(target_));\n        } else if (action_ == Actions.UpgradeModule) {\n            ensureContract(target_);\n            ensureValidKeycode(Module(target_).KEYCODE());\n            _upgradeModule(Module(target_));\n        } else if (action_ == Actions.ActivatePolicy) {\n            ensureContract(target_);\n            _activatePolicy(Policy(target_));\n        } else if (action_ == Actions.DeactivatePolicy) {\n            ensureContract(target_);\n            _deactivatePolicy(Policy(target_));\n        } else if (action_ == Actions.ChangeExecutor) {\n            executor = target_;\n        } else if (action_ == Actions.MigrateKernel) {\n            ensureContract(target_);\n            _migrateKernel(Kernel(target_));\n        }\n\n        emit ActionExecuted(action_, target_);\n    }\n\n    function _installModule(Module newModule_) internal {\n        Keycode keycode = newModule_.KEYCODE();\n\n        if (address(getModuleForKeycode[keycode]) != address(0))\n            revert Kernel_ModuleAlreadyInstalled(keycode);\n\n        getModuleForKeycode[keycode] = newModule_;\n        getKeycodeForModule[newModule_] = keycode;\n        allKeycodes.push(keycode);\n\n        newModule_.INIT();\n    }\n\n    function _upgradeModule(Module newModule_) internal {\n        Keycode keycode = newModule_.KEYCODE();\n        Module oldModule = getModuleForKeycode[keycode];\n\n        if (address(oldModule) == address(0) || oldModule == newModule_)\n            revert Kernel_InvalidModuleUpgrade(keycode);\n\n        getKeycodeForModule[oldModule] = Keycode.wrap(bytes5(0));\n        getKeycodeForModule[newModule_] = keycode;\n        getModuleForKeycode[keycode] = newModule_;\n\n        newModule_.INIT();\n\n        _reconfigurePolicies(keycode);\n    }\n\n    function _activatePolicy(Policy policy_) internal {\n        if (isPolicyActive(policy_)) revert Kernel_PolicyAlreadyActivated(address(policy_));\n\n        // Add policy to list of active policies\n        activePolicies.push(policy_);\n        getPolicyIndex[policy_] = activePolicies.length - 1;\n\n        // Record module dependencies\n        Keycode[] memory dependencies = policy_.configureDependencies();\n        uint256 depLength = dependencies.length;\n\n        for (uint256 i; i < depLength; ) {\n            Keycode keycode = dependencies[i];\n\n            moduleDependents[keycode].push(policy_);\n            getDependentIndex[keycode][policy_] = moduleDependents[keycode].length - 1;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Grant permissions for policy to access restricted module functions\n        Permissions[] memory requests = policy_.requestPermissions();\n        _setPolicyPermissions(policy_, requests, true);\n    }\n\n    function _deactivatePolicy(Policy policy_) internal {\n        if (!isPolicyActive(policy_)) revert Kernel_PolicyNotActivated(address(policy_));\n\n        // Revoke permissions\n        Permissions[] memory requests = policy_.requestPermissions();\n        _setPolicyPermissions(policy_, requests, false);\n\n        // Remove policy from all policy data structures\n        uint256 idx = getPolicyIndex[policy_];\n        Policy lastPolicy = activePolicies[activePolicies.length - 1];\n\n        activePolicies[idx] = lastPolicy;\n        activePolicies.pop();\n        getPolicyIndex[lastPolicy] = idx;\n        delete getPolicyIndex[policy_];\n\n        // Remove policy from module dependents\n        _pruneFromDependents(policy_);\n    }\n\n    /// @notice All functionality will move to the new kernel. WARNING: ACTION WILL BRICK THIS KERNEL.\n    /// @dev    New kernel must add in all of the modules and policies via executeAction.\n    /// @dev    NOTE: Data does not get cleared from this kernel.\n    function _migrateKernel(Kernel newKernel_) internal {\n        uint256 keycodeLen = allKeycodes.length;\n        for (uint256 i; i < keycodeLen; ) {\n            Module module = Module(getModuleForKeycode[allKeycodes[i]]);\n            module.changeKernel(newKernel_);\n            unchecked {\n                ++i;\n            }\n        }\n\n        uint256 policiesLen = activePolicies.length;\n        for (uint256 j; j < policiesLen; ) {\n            Policy policy = activePolicies[j];\n\n            // Deactivate before changing kernel\n            policy.changeKernel(newKernel_);\n            unchecked {\n                ++j;\n            }\n        }\n    }\n\n    function _reconfigurePolicies(Keycode keycode_) internal {\n        Policy[] memory dependents = moduleDependents[keycode_];\n        uint256 depLength = dependents.length;\n\n        for (uint256 i; i < depLength; ) {\n            dependents[i].configureDependencies();\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _setPolicyPermissions(\n        Policy policy_,\n        Permissions[] memory requests_,\n        bool grant_\n    ) internal {\n        uint256 reqLength = requests_.length;\n        for (uint256 i = 0; i < reqLength; ) {\n            Permissions memory request = requests_[i];\n            modulePermissions[request.keycode][policy_][request.funcSelector] = grant_;\n\n            emit PermissionsUpdated(request.keycode, policy_, request.funcSelector, grant_);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _pruneFromDependents(Policy policy_) internal {\n        Keycode[] memory dependencies = policy_.configureDependencies();\n        uint256 depcLength = dependencies.length;\n\n        for (uint256 i; i < depcLength; ) {\n            Keycode keycode = dependencies[i];\n            Policy[] storage dependents = moduleDependents[keycode];\n\n            uint256 origIndex = getDependentIndex[keycode][policy_];\n            Policy lastPolicy = dependents[dependents.length - 1];\n\n            // Swap with last and pop\n            dependents[origIndex] = lastPolicy;\n            dependents.pop();\n\n            // Record new index and delete deactivated policy index\n            getDependentIndex[keycode][lastPolicy] = origIndex;\n            delete getDependentIndex[keycode][policy_];\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "bophades/src/external/governance/GovernorBravoDelegate.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.15;\n\nimport {IgOHM} from \"src/interfaces/IgOHM.sol\";\nimport {ITimelock} from \"./interfaces/ITimelock.sol\";\nimport {IGovernorBravoEventsAndErrors} from \"./interfaces/IGovernorBravoEvents.sol\";\n\nimport {GovernorBravoDelegateStorageV2} from \"./abstracts/GovernorBravoStorage.sol\";\n\nimport \"src/Kernel.sol\";\n\ncontract GovernorBravoDelegate is GovernorBravoDelegateStorageV2, IGovernorBravoEventsAndErrors {\n    // --- CONSTANTS ---------------------------------------------------------------\n\n    /// @notice The name of this contract\n    string public constant name = \"Olympus Governor Bravo\";\n\n    /// @notice The minimum setable proposal threshold\n    uint256 public constant MIN_PROPOSAL_THRESHOLD_PCT = 1_000; // 1% (out of 100_000)\n\n    /// @notice The maximum setable proposal threshold\n    uint256 public constant MAX_PROPOSAL_THRESHOLD_PCT = 90_000; // 90% (out of 100_000)\n\n    /// @notice The minimum setable voting period\n    uint256 public constant MIN_VOTING_PERIOD = 21600; // About 3 days (12s block time)\n\n    /// @notice The max setable voting period\n    uint256 public constant MAX_VOTING_PERIOD = 100800; // About 2 weeks (12s block time)\n\n    /// @notice The min setable voting delay\n    uint256 public constant MIN_VOTING_DELAY = 21600; // About 3 days (12s block time)\n\n    /// @notice The max setable voting delay\n    uint256 public constant MAX_VOTING_DELAY = 50400; // About 1 week (12s block time)\n\n    /// @notice The percentage of total supply in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n    /// @dev    Olympus has a variable supply system, that actively fluctuates fairly significantly, so it is better to use\n    ///         a percentage of total supply, rather than a fixed number of tokens.\n    uint256 public constant quorumPct = 20_000; // 20% (out of 100_000)\n\n    /// @notice The percentage of total supply in support of a proposal related to a high risk module in the Default system required\n    ///         in order for a quorum to be reached and for a vote to succeed\n    /// @dev    Olympus has a variable supply system, that actively fluctuates fairly significantly, so it is better to use\n    ///         a percentage of total supply, rather than a fixed number of tokens.\n    uint256 public constant highRiskQuorum = 30_000; // 30% (out of 100_000)\n\n    /// @notice The percentage of votes that must be in favor of a proposal for it to succeed\n    uint256 public constant approvalThresholdPct = 55_000; // 55% (out of 100_000)\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    uint256 public constant proposalMaxOperations = 10; // 10 actions\n\n    /// @notice The central hub of the Default Framework system that manages modules and policies\n    /// @dev    Used in this adaptation of Governor Bravo to identify high risk proposals\n    address public kernel;\n\n    /// @notice Modules in the Default system that are considered high risk\n    /// @dev    In Default Framework, Keycodes are used to uniquely identify modules. They are a\n    ///         wrapper over the bytes5 data type, and allow us to easily check if a proposal is\n    ///         touching any specific modules\n    mapping(Keycode => bool) public isKeycodeHighRisk;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,uint8 support)\");\n\n    // --- INITIALIZE --------------------------------------------------------------\n\n    /**\n     * @notice Used to initialize the contract during delegator constructor\n     * @param timelock_ The address of the Timelock\n     * @param gohm_ The address of the gOHM token\n     * @param kernel_ The address of the kernel\n     * @param votingPeriod_ The initial voting period\n     * @param votingDelay_ The initial voting delay\n     * @param proposalThreshold_ The initial proposal threshold (percentage of total supply. out of 1000)\n     */\n    function initialize(\n        address timelock_,\n        address gohm_,\n        address kernel_,\n        uint256 votingPeriod_,\n        uint256 votingDelay_,\n        uint256 proposalThreshold_\n    ) public virtual {\n        if (msg.sender != admin) revert GovernorBravo_OnlyAdmin();\n        if (address(timelock) != address(0)) revert GovernorBravo_AlreadyInitialized();\n        if (timelock_ == address(0) || gohm_ == address(0) || kernel_ == address(0))\n            revert GovernorBravo_AddressZero();\n        if (votingPeriod_ < MIN_VOTING_PERIOD || votingPeriod_ > MAX_VOTING_PERIOD)\n            revert GovernorBravo_InvalidPeriod();\n        if (votingDelay_ < MIN_VOTING_DELAY || votingDelay_ > MAX_VOTING_DELAY)\n            revert GovernorBravo_InvalidDelay();\n        if (\n            proposalThreshold_ < MIN_PROPOSAL_THRESHOLD_PCT ||\n            proposalThreshold_ > MAX_PROPOSAL_THRESHOLD_PCT\n        ) revert GovernorBravo_InvalidThreshold();\n\n        // Set up contract dependencies\n        timelock = ITimelock(timelock_);\n        gohm = IgOHM(gohm_);\n        kernel = kernel_;\n\n        // Configure voting parameters\n        vetoGuardian = msg.sender;\n        votingDelay = votingDelay_;\n        votingPeriod = votingPeriod_;\n        proposalThreshold = proposalThreshold_;\n        isKeycodeHighRisk[toKeycode(bytes5(\"TRSRY\"))] = true;\n        isKeycodeHighRisk[toKeycode(bytes5(\"MINTR\"))] = true;\n    }\n\n    // --- GOVERNANCE LOGIC --------------------------------------------------------\n\n    /**\n     * @notice Function used to propose a new proposal. Sender must have delegates above the proposal threshold\n     * @param targets Target addresses for proposal calls\n     * @param values Eth values for proposal calls\n     * @param signatures Function signatures for proposal calls\n     * @param calldatas Calldatas for proposal calls\n     * @param description String description of the proposal\n     * @return Proposal id of new proposal\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) public returns (uint256) {\n        // Allow addresses above proposal threshold and whitelisted addresses to propose\n        if (\n            gohm.getPriorVotes(msg.sender, block.number - 1) <= getProposalThresholdVotes() &&\n            !isWhitelisted(msg.sender)\n        ) revert GovernorBravo_Proposal_ThresholdNotMet();\n        if (\n            targets.length != values.length ||\n            targets.length != signatures.length ||\n            targets.length != calldatas.length\n        ) revert GovernorBravo_Proposal_LengthMismatch();\n        if (targets.length == 0) revert GovernorBravo_Proposal_NoActions();\n        if (targets.length > proposalMaxOperations) revert GovernorBravo_Proposal_TooManyActions();\n\n        uint256 latestProposalId = latestProposalIds[msg.sender];\n        if (latestProposalId != 0) {\n            ProposalState proposersLatestProposalState = state(latestProposalId);\n            if (proposersLatestProposalState == ProposalState.Active)\n                revert GovernorBravo_Proposal_AlreadyActive();\n            if (proposersLatestProposalState == ProposalState.Pending)\n                revert GovernorBravo_Proposal_AlreadyPending();\n        }\n\n        uint256 startBlock = block.number + votingDelay;\n        uint256 endBlock = startBlock + votingPeriod;\n\n        proposalCount++;\n        uint256 newProposalID = proposalCount;\n\n        {\n            // Given Olympus's dynamic supply, we need to capture quorum and proposal thresholds in terms\n            // of the total supply at the time of proposal creation.\n            uint256 quorumVotes;\n            uint256 proposalThresholdVotes = getProposalThresholdVotes();\n\n            // Identify the quorum level to use\n            if (_isHighRiskProposal(targets, signatures, calldatas)) {\n                quorumVotes = getHighRiskQuorumVotes();\n            } else {\n                quorumVotes = getQuorumVotes();\n            }\n\n            Proposal storage newProposal = proposals[newProposalID];\n            // This should never happen but add a check in case.\n            if (newProposal.id != 0) revert GovernorBravo_Proposal_IdCollision();\n\n            newProposal.id = newProposalID;\n            newProposal.proposer = msg.sender;\n            newProposal.proposalThreshold = proposalThresholdVotes;\n            newProposal.quorumVotes = quorumVotes;\n            newProposal.targets = targets;\n            newProposal.values = values;\n            newProposal.signatures = signatures;\n            newProposal.calldatas = calldatas;\n            newProposal.startBlock = startBlock;\n            newProposal.endBlock = endBlock;\n\n            latestProposalIds[newProposal.proposer] = newProposal.id;\n        }\n\n        emit ProposalCreated(\n            newProposalID,\n            msg.sender,\n            targets,\n            values,\n            signatures,\n            calldatas,\n            startBlock,\n            endBlock,\n            description\n        );\n        return newProposalID;\n    }\n\n    /**\n     * @notice Queues a successful proposal\n     * @param proposalId The id of the proposal to queue\n     */\n    function queue(uint256 proposalId) external {\n        if (state(proposalId) != ProposalState.Succeeded)\n            revert GovernorBravo_Queue_FailedProposal();\n\n        Proposal storage proposal = proposals[proposalId];\n        uint256 eta = block.timestamp + timelock.delay();\n\n        // Check that proposer has not fallen below proposal threshold since proposal creation\n        // If proposer is whitelisted, they can queue regardless of threshold\n        if (\n            !isWhitelisted(proposal.proposer) &&\n            gohm.getPriorVotes(proposal.proposer, block.number - 1) < proposal.proposalThreshold\n        ) revert GovernorBravo_Queue_BelowThreshold();\n\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            _queueOrRevertInternal(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                eta\n            );\n        }\n        proposal.eta = eta;\n        emit ProposalQueued(proposalId, eta);\n    }\n\n    function _queueOrRevertInternal(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        if (timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))))\n            revert GovernorBravo_Queue_AlreadyQueued();\n\n        timelock.queueTransaction(target, value, signature, data, eta);\n    }\n\n    /**\n     * @notice Executes a queued proposal if eta has passed\n     * @param proposalId The id of the proposal to execute\n     */\n    function execute(uint256 proposalId) external payable {\n        if (state(proposalId) != ProposalState.Queued) revert GovernorBravo_Execute_NotQueued();\n\n        Proposal storage proposal = proposals[proposalId];\n\n        // Check that proposer has not fallen below proposal threshold since proposal creation\n        // If proposer is whitelisted, they can execute regardless of threshold\n        if (\n            !isWhitelisted(proposal.proposer) &&\n            gohm.getPriorVotes(proposal.proposer, block.number - 1) < proposal.proposalThreshold\n        ) revert GovernorBravo_Execute_BelowThreshold();\n\n        proposal.executed = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.executeTransaction{value: proposal.values[i]}(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n        emit ProposalExecuted(proposalId);\n    }\n\n    /**\n     * @notice Cancels a proposal only if sender is the proposer, or proposer delegates dropped below proposal threshold\n     * @param proposalId The id of the proposal to cancel\n     */\n    function cancel(uint256 proposalId) external {\n        if (state(proposalId) == ProposalState.Executed)\n            revert GovernorBravo_Cancel_AlreadyExecuted();\n\n        Proposal storage proposal = proposals[proposalId];\n\n        // Proposer can cancel\n        if (msg.sender != proposal.proposer) {\n            // Whitelisted proposers can't be canceled for falling below proposal threshold\n            if (isWhitelisted(proposal.proposer)) {\n                if (\n                    (gohm.getPriorVotes(proposal.proposer, block.number - 1) >=\n                        proposal.proposalThreshold) || msg.sender != whitelistGuardian\n                ) revert GovernorBravo_Cancel_WhitelistedProposer();\n            } else {\n                if (\n                    gohm.getPriorVotes(proposal.proposer, block.number - 1) >=\n                    proposal.proposalThreshold\n                ) revert GovernorBravo_Cancel_AboveThreshold();\n            }\n        }\n\n        proposal.canceled = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.cancelTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n\n        emit ProposalCanceled(proposalId);\n    }\n\n    /**\n     * @notice Vetoes a proposal only if sender is the veto guardian\n     * @param proposalId The id of the proposal to veto\n     */\n    function veto(uint256 proposalId) external {\n        if (msg.sender != vetoGuardian) revert GovernorBravo_OnlyVetoGuardian();\n        if (state(proposalId) == ProposalState.Executed)\n            revert GovernorBravo_Veto_AlreadyExecuted();\n\n        Proposal storage proposal = proposals[proposalId];\n\n        proposal.vetoed = true;\n        for (uint256 i; i < proposal.targets.length; ) {\n            // If the proposal has been queued, cancel on the timelock\n            if (\n                timelock.queuedTransactions(\n                    keccak256(\n                        abi.encode(\n                            proposal.targets[i],\n                            proposal.values[i],\n                            proposal.signatures[i],\n                            proposal.calldatas[i],\n                            proposal.eta\n                        )\n                    )\n                )\n            ) {\n                timelock.cancelTransaction(\n                    proposal.targets[i],\n                    proposal.values[i],\n                    proposal.signatures[i],\n                    proposal.calldatas[i],\n                    proposal.eta\n                );\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ProposalVetoed(proposalId);\n    }\n\n    /**\n     * @notice Cast a vote for a proposal\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     */\n    function castVote(uint256 proposalId, uint8 support) external {\n        emit VoteCast(\n            msg.sender,\n            proposalId,\n            support,\n            castVoteInternal(msg.sender, proposalId, support),\n            \"\"\n        );\n    }\n\n    /**\n     * @notice Cast a vote for a proposal with a reason\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @param reason The reason given for the vote by the voter\n     */\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) external {\n        emit VoteCast(\n            msg.sender,\n            proposalId,\n            support,\n            castVoteInternal(msg.sender, proposalId, support),\n            reason\n        );\n    }\n\n    /**\n     * @notice Cast a vote for a proposal by signature\n     * @dev External function that accepts EIP-712 signatures for v"
    }
  ]
}