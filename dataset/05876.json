{
  "Title": "[H-01] Underflow in `updateTranscoderWithFees` can cause corrupted data and loss of winning tickets",
  "Content": "\n`updateTranscoderWtihFees` can underflow because MathUtils is used instead of PreciseMathUtils.\n\n### Proof of Concept\n\nAccording to [LIP-92](https://github.com/livepeer/LIPs/blob/master/LIPs/LIP-92.md) the initial `treasuryRewardCutRate` will be set to `10%`.\n\n`treasuryRewardCutRate` is set with the `setTreasuryRewardCutRate()`function, which calls the internal function `_setTreasuryRewardCutRate()`.\n\n```javascript\nfile: 2023-08-livepeer/contracts/bonding/BondingManager.sol\n\nfunction _setTreasuryRewardCutRate(uint256 _cutRate) internal {\n        require(PreciseMathUtils.validPerc(_cutRate), \"_cutRate is invalid precise percentage\");\n```\n\nIn this function the value will be checked if it's a valid `PreciseMathUtils` percentage (<`100%` specified with 27-digits precision):\n\n```javascript\nfile: 2023-08-livepeer/contracts/libraries/PreciseMathUtils.sol\nlibrary PreciseMathUtils {\n// ...\n    // Divisor used for representing percentages\n    uint256 public constant PERC_DIVISOR = 10**27;\n\tfunction validPerc(uint256 _amount) internal pure returns (bool) {\n        return _amount <= PERC_DIVISOR;\n    }\n// ...\n```\n\nHowever, in `updateTranscoderWithFees`, to calculate `treasuryRewards`, `MathUtils` is used instead of `PreciseMathUtils`.\n\n```javascript\nfile: 2023-08-livepeer/contracts/bonding/BondingManager.sol\n\nfunction updateTranscoderWithFees(\n        address _transcoder,\n        uint256 _fees,\n        uint256 _round\n    ) external whenSystemNotPaused onlyTicketBroker {\n// ...\nuint256 treasuryRewards = MathUtils.percOf(rewards, treasuryRewardCutRate);\nrewards = rewards.sub(treasuryRewards);\n// ...\n}\n```\n\n`MathUtils` uses a `PREC_DIVISOR` of `1000000` instead of `10 ** 27` from the `PreciseMathUtils`:\n\n```javascript\nfile: 2023-08-livepeer/contracts/libraries/MathUtils.sol\nlibrary MathUtils {\n// ...\n    uint256 public constant PERC_DIVISOR = 1000000;\n// ...\n```\n\nThis leads to `treasuryRewards` value being bigger than expected. Here is a [gist of the POC](https://gist.github.com/bronzepickaxe/60063c47c327a1f2d4ee3dbd6361049b). Running the POC it shows that the current usage of `MathUtils` when calculating `treasuryRewards` will always cause an underflow in the next line of code.\n\n`updateTranscoderWithFees` is called every time a winning ticket is redeemed. Whenever the transcoder has skipped the previous round reward call, this function has to re-calculate the rewards, as documented in [LIP-92](https://github.com/livepeer/LIPs/blob/master/LIPs/LIP-92.md?plain=1#L130). This re-calculation will always fail due to the underflow shown above.\n\n### Impact\n\nThis will lead to accounting errors, unexpected behaviours and can cause a loss of winning tickets.\n\nFirstly, the accounting errors and unexpected behaviours: these are all the storage values getting updated in `updateTranscoderWithFees`:\n\n```javascript\nfile: 2023-08-livepeer/contracts/bonding/BondingManager.sol\n\nfunction updateTranscoderWithFees( address _transcoder,\n        uint256 _fees,\n        uint256 _round\n    ) external whenSystemNotPaused onlyTicketBroker {\n// ...\n// transcoder & earningsPool.data\nL314: Transcoder storage t = transcoders[_transcoder];\nL321: EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[currentRound];\n\n//accounting updates happen here\nL377: t.cumulativeFees = t.cumulativeFees.add(transcoderRewardStakeFees)\n\t  .add(transcoderCommissionFees);\nL382: earningsPool.updateCumulativeFeeFactor(prevEarningsPool,delegatorsFees);\nL384: t.lastFeeRound = currentRound;\n```\n\n*   Let `currentRound() - 1` be the previous round where the transcoder skipped the reward call\n*   Let `currentRound()` be current round\n*   Let `currentRound() + 1` be the next round\n\nDuring `currentRound()` it won't be possible to update the `Transcoder` storage or `earningsPool.data` storage because of the underflow that will happen because `currentRound() - 1` reward call has been skipped by the transcoder.\n\nDuring `currentRound() + 1` it will be possible to call `updateTranscoderWithFees`, however, L382 will only update the `prevEarningsPool`, which in this case will be `currentRound()`, not `currentRound - 1`. Therefor, the `EarningsPool.data.cumulativeRewardFactor` won't be updated for `currentRound() - 1`.\n\nLastly, the validity of a ticket is two rounds as per the [specs](https://github.com/livepeer/wiki/blob/master/spec/streamflow/pm.md?plain=1#L107). This means that a transcoder that receives a winning ticket in `currentRound() - 1` should be able to redeem it in `currentRound() - 1` and `currentRound()`. However, a transcoder that receives a winning ticket in `currentRound() - 1` wont be able to redeem it in `currentRound()` because of the underflow that happens while redeeming a winning ticket in `currentRound()`. The transcoder wont be able to redeem it after `currentRound + 1..N` because the ticket will be expired.\n\n### Recommended Mitigation Steps\n\nUse `PreciseMathLib` instead of `MathLib`:\n\n```javascript\nfile: 2023-08-livepeer/contracts/bonding/BondingManager.sol\n\nL355: \n- uint256 treasuryRewards = MathUtils.percOf(rewards, treasuryRewardCutRate);\n+ uint256 treasuryRewards = PreciseMathUtils.percOf(rewards, treasuryRewardCutRate);\n```\n\n### Assessed type\n\nLibrary\n\n**[victorges (Livepeer) commented](https://github.com/code-423n4/2023-08-livepeer-findings/issues/165#issuecomment-1714255659):**\n > Can confirm this issue!\n\n**[victorges (Livepeer) mitigated](https://github.com/code-423n4/2023-08-livepeer-findings/issues/165):**\n > https://github.com/livepeer/protocol/pull/624\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-08-livepeer",
  "Code": [
    {
      "filename": "LIPs/LIP-92.md?plain=1",
      "content": "---\nlip: 92\ntitle: Treasury Contribution Percentage\nauthor: Doug Petkanics (@dob), Victor Elias (@victorges)\ntype: Standard Track\nstatus: Proposed\ncreated: 2023-06-14\ndiscussions-to: https://forum.livepeer.org/t/lip-treasury-contribution-percentage-discussion-thread/2116\nrequires: 91\n---\n\n## Abstract\n\nThis proposal, one piece of the larger set of changes codenamed Livepeer Delta, describes a mechanism for populating the Livepeer Treasury via a parameterized percentage of the per round mintable tokens that the Livepeer protocol generates. It includes implementation details, and also includes a governable maximum treasury balance parameter, such that treasury contributions would stop should the treasury balance exceed this value.\n\n## Motivation\n\nHow public goods get funded on an ongoing basis is a common challenge across traditional societies, as well as onchain decentralized networks. Typically, this funding is accomplished through the combination of tax, philanthropy, and self-motivated contributions. With the creation of the Livepeer Treasury, representing the pool of public goods funding available, the question remains how it should get populated. Some of the principles that this proposal strives to maintain are:\n\n1. Some portion of public goods should be funded by the commons.\n2. The community should have governance control over how much public goods funding is being routed towards the treasury, versus distributed out as rewards.\n3. The community should be forced to re-evaluate this public goods funding at certain thresholds of available funding, rather than just passively accepting unlimited funding.\n4. The supply expectations of the Livepeer Token should be preserved if possible, without any radical changes to people's existing expectations.\n\nWhile additional methods of funding public goods are available, such as philanthropy, this proposal addresses one mechanism for the commons funding public goods: a portion of the round-based inflationary rewards will be routed into the treasury, prior to the rest of the rewards being distributed to the Orchestrators and their delegators.\n\n## Specification\n\n### Background and Requirements\n\nThis proposal requires [LIP-91](https://github.com/livepeer/LIPs/blob/master/LIPs/LIP-91.md) to have passed in order to be enabled. For the purposes of this LIP, we'll assume \"The Livepeer Treasury\" refers to the onchain treasury deployed as part of the above LIP.\n\n### New Protocol Parameters\n\nWe introduce two new parameters to the protocol's `BondingManager`:\n\n- `treasuryRewardCutRate`: The % of newly minted rewards to be routed into the Livepeer Treasury.\n- `treasuryBalanceCeiling`: If the balance of the treasury in LPT is above this value, automatic treasury contributions will halt.\n\nEach of these parameters should have a setter in the `BondingManager` which is invokable only by `onlyControllerOwner`.\n\nThe `treasuryRewardCutRate` should conform to the protocols standard representation of percent values represented as uints with maximum precision flexibility, and the `treasuryBalanceCeiling` should be a uint value representing an amount of LPT with max precision using the standard 18 decimal places to account for LPTu.\n\n### Routing LPT into the treasury\n\nLPT will be routed into the treasury during the `reward()` transaction invoked by Orchestrators each round.\n\n- In the `BondingManager`'s `rewardWithHint()` function:\n  - Check the current LPT balance on the Livepeer Treasury. If the balance > `treasuryBalanceCeiling`, set `treasuryRewardCutRate = 0`.\n  - Calculate the totalRewards available and mint them based on the Orchestrator's delegate stake as usual.\n  - Calculate the treasuryRewards as a % of the totalRewards based upon the `treasuryRewardCutRate`. Calculate the transcoderRewards by subtracting the treasuryRewards from the totalRewards.\n  - Route the treasuryRewards into the Livepeer Treasury.\n  - Route the transcoderRewards to the orchestrator as usual.\n\n### Initial Values\n\n- `treasuryRewardCutRate`: 10%\n- `treasuryBalanceCeiling`: 750000 LPT\n\n## Specification Rationale\n\nThis method of deducting a % from the round-based rewards out of current protocol inflation based on a governance controlled parameter meets requirements one and two of the specified principles: namely that public goods will be funded by the commons and the community will have governance control over the level of contribution. The `treasuryBalanceCeiling` ensures that the community will be forced to take proactive action to re-enable any contribution percentage value greater than zero if the treasury is not being distributed efficiently and there is \"enough\" LPT already within the treasury. Finally, the supply expectations of the Livepeer protocol, amongst the wide number of stakeholders who have already made participation decisions based upon these assumptions, will not be violated, as they would be in an alternative implementation for funding the treasury such as an additional token mint.\n\n### Funding within reward call\n\nIt was considered whether to fund the treasury within the `reward()` call transaction or within the `initializeRound()` transaction. Doing so within `initializeRound()` would have been more predictable, in that all of the treasury funds would be routed each round with predictability, whereas the treasury will not be funded fully when reward calls are missed. However, it came with a much more complicated state management implementation, and because the inflationary reward distribution state management is the most complex, important, and error prone aspect of the protocol, a simpler specification was selected which will minimize the chance of any errors being introduced.\n\n### Initial Values Rationale\n\nThe discussion for this proposal in [the forum](https://forum.livepeer.org/t/livepeer-delta-phase-pre-proposal-sustainability-public-goods-funding-treasury-and-decentralization/2056/1) and community calls yielded quite a bit discourse and modeling on this topic, and there's clearly no value which will satisfy everyone. If you look at the average tax-to-GDP ratio of productive nation states, you'll see that it often falls at around the 10-25% range. Decentralized, blockchain based, digital communities should be more efficient than many beurocraticly-heavy nation states, however it could also be argued that Livepeer is more \"pre-product-market-fit\" than many nation states, hasn't achieved sustainability in terms of its fee market yet, and requires significant public goods funding to decentralize and enable many forms of contribution as the bootstrapping phase continues.\n\nWhile 10% proposed is a bit arbitrary, coupled with the `treasuryBalanceCeiling` parameter it creates an automatic cutoff that will force the community to re-enable a rate above 0% should the treasury ever exceed this value. Further, because the `treasuryRewardCutRate` gets set to 0% when this occurs, any governance proposal to re-activate it can use a new rate, rather than it being required that the 10% be the only available value.\n\nAs for the proposed value of the `treasuryBalanceCeiling`, this represents a bit over 2.5% of the LPT in circulation. If the only source of LPT for the treasury were the inflationary LPT generated by the updates in this LIP, and none were ever distributed, it would take about 900 rounds to meet this value. However, it is hoped there are additional sources of treasury contribution including grants, philanthropy, a portion of the grants node treasury, and even ecosystem programs run by proposers to the treasury, so in practice, this value would give the community confidence that the treasury can build up meaningful public goods funding for a year+ before it would be automatically cut off via the protocol.\n\nI will leave the modeling and guesswork of the representative $ value of this treasury based on LPT price outside of this proposal, because 1) we know that that swings with the markets and is unpredictable, and 2) these values can be easily changed via governance should the community wish to react to changing market conditions and evidenced based performance of the treasury.\n\n### Backwards Compatibility\n\nThere are no backwards incompatibilities introduced by this proposal.\n\n## Technical Specification\n\nThis requires changes a couple changes in `BondingManager`. The core of it being an update to the reward calculation functions to take a cut rate and mint the treasury rewards before getting to the transcoder/delegators actual rewards.\n\nThe cut rate and the balance ceiling are configured as parameters on `BondingManager` and can only be updated by the controller owner. When the `treasuryRewardCutRate` is updated, it only takes effect on the next round initialization, to avoid any gambling opportunities with timing your transactions within a round â€“ e.g. reward calls or redeeming tickets before/after cut rate changes.\n\n### Parameters\n\n```solidity\ncontract BondingManager {\n    function treasuryRewardCutRate() external view returns (uint256);\n    function setTreasuryRewardCutRate(uint256 _cutRate) external;\n\n    function nextRoundTreasuryRewardCutRate() external view returns (uint256);\n\n    function treasuryBalanceCeiling() external view returns (uint256);\n    function setTreasuryBalanceCeiling(uint256 _ceiling) external;\n}\n```\n\n- `treasuryRewardCutRate`: The percentage that the treasury should receive from the protocol inflationary rewards.\n  - Initial value: `1e26` (on the next round after the setting param)\n  - This value represents a 10% percentage as per [the rationale above](#initial-values-rationale).\n  - Represented in 27-digit decimal precision corresponding to reward calculations precision since [LIP-71](https://github.com/livepeer/LIPs/issues/71).\n- `setTreasuryRewardCutRate`: Sets `treasuryRewardCutRate` indirectly on the next round.\n  - Should revert if the caller is not the protocol controller owner.\n  - Notice that this setter should not change the value of `treasuryRewardCutRate` directly but only the `nextRoundTreasuryRewardCutRate` below.\n- `nextRoundTreasuryRewardCutRate`: Parameter that gets set on the setter for reward cut, only propagating to the actual\n  reward cut on the next round initialization.\n  - Initial value: `1e26`\n  - Same as above.\n- `treasuryBalanceCeiling`: Limit that if reached by the LPT balance of the treasury should automatically halt treasury contributions (`treasuryRewardCut=0`) on the next round.\n  - Initial value: `750000e18`\n  - This value represents 750000 LPT as per [the rationale above](#initial-values-rationale).\n- `setTreasuryBalanceCeiling`: Sets `treasuryBalanceCeiling` parameter immediately..\n  - Should revert if the caller is not the protocol controller owner.\n  - The value of `treasuryBalanceCeiling` parameter should be updated immediately, not on the next round.\n\n### Behavior changes\n\n- `setCurrentRoundTotalActiveStake`: which is the function called during round initialization on the `BondingManager`.\n  - After this change, it should start propagating the `nextRoundTreasuryRewardCutRate` value to the `treasuryRewardCutRate` parameter, which is the value actually used on the reward calculations below.\n  - It sould emit the `ParameterUpdate` event for `treasuryRewardCutRate` if it changed.\n- `rewardWithHint`: where rewards are claimed by a transcoder and actually minted to the bond.\n  - After this change, the actual rewards provided to the transcoders delegators (including itself), should be reduced by exactly the `treasuryRewardCutRate` percentage.\n  - It should also mint and transfer tokens to the treasury corresponding to the reduction above.\n  - If the balance of the treasury after the transfer is higher than the ceiling, it should also set the `treasuryRewardCutRate` to `0` starting in the next round.\n- `updateTranscoderWithFees`: called by `TicketBroker` when a winning ticket is redeemed.\n  - When the transcoder has skipped the previous round reward call, this function has to re-calculate the rewards from the current round, so it needs to take the treasury contributions in consideration as well.\n  - This function doesn't actually claim any rewards, so there's no token minting/transferring nor ceiling checks.\n\n## Implementation\n\nThis LIP was implemented in conjunction with [LIP-91](./LIP-91.md) as part of the Livepeer Delta upgrade. The combined implementation can be found [here](https://github.com/livepeer/protocol/compare/confluence...delta), while a cherry-picked branch with only the specific changes from this LIP can be found [here](https://github.com/livepeer/protocol/compare/delta-lip91...delta-lip92). This LIP depends on a `Treasury` contract created by LIP-91, so it cannot be deployed separately.\n\nThe individual change for this specific LIP was:\n\n- [#616 Treasury rewards contribution](https://github.com/livepeer/protocol/pull/616)\n\n### Audit\n\nThe code has gone through an audit contest with [code4rena](https://code4rena.com/). The contest and results can be found [here](https://code4rena.com/contests/2023-08-livepeer-onchain-treasury-upgrade).\n\nThere was only 1 issue found regarding the treasury contribution, which was mitigated in the following PR:\n\n- [#624 Fix treasury cut precision on fee withdrawal](https://github.com/livepeer/protocol/pull/624)\n\n## Testing\n\n### Test Cases\n\nRefer to the automated tests included in the [implementation](#implementation) above. Specifically:\n\n- [`test/unit/BondingManager.js`](https://github.com/livepeer/protocol/pull/616/files#diff-e4a2ded9b6167d11fbd067efcb78ed9b7b3c19666dfa741da3ff17911c907bd7).\n\n### Devnet\n\nThere is also a devnet deployed on Arbitrum Goerli:\n\n- Recorded deployment on [PR #620](https://github.com/livepeer/protocol/pull/620)\n- Explorer available on [goerli-explorer.livepeer.monster](https://goerli-explorer.livepeer.monster/treasury)\n- Treasury contributions can be validated from [transactions like this](https://testnet.arbiscan.io/tx/0x13c3a48b54bc1c63522a1c75c96bd832ca0980db15bcdaa44d392e9fc7092187#eventlog).\n\n## Copyright\n\nCopyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/)."
    },
    {
      "filename": "spec/streamflow/pm.md?plain=1",
      "content": "# Probabilistic Micropayments\n\n## Introduction \n\nIn the Streamflow release of the Livepeer protocol, broadcasters use a probabilistic micropayment protocol in order to pay for transcoding work done by orchestrators. Broadcasters send lottery tickets to orchestrators off-chain with video segments that need to be transcoded and orchestrators redeem winning lottery tickets on-chain in order to claim payments. Regardless of whether a ticket wins or not, an orchestrator accepts a ticket as a payment of the expected value of the ticket which is calculated from the ticket's face value and winning probability. While not every ticket is going to win, in the long run after receiving many tickets, orchestrators will be paid correctly and fairly due to the [law of large numbers](https://en.wikipedia.org/wiki/Law_of_large_numbers).\n\nThe probabilistic micropayment protocol consists of:\n\n- A `TicketBroker` Ethereum smart contract that holds funds and processes winning tickets\n- An off-chain protocol between broadcasters and orchestrators for creating and sending tickets\n\nThis specification will describe both the `TicketBroker` contract and the off-chain protocol between broadcasters and orchestrators.\n\n## Data Structures \n\n### Ticket\n\nA `Ticket` represents a payment from a broadcaster to an orchestrator for transcoding work. Tickets are sent to orchestrators off-chain and winning tickets are redeemed on-chain with the `TicketBroker` contract.\n\n| Field                      | Type    | Description                                                                                                  |\n| -------------------------- | ------- | ------------------------------------------------------------------------------------------------------------ |\n| **recipient**              | address | The ETH address of the orchestrator                                                                          |\n| **sender**                 | address | The ETH address of the broadcaster                                                                           |\n| **faceValue**              | uint256 | The face value of the ticket which is paid to `recipient` if the ticket wins                                 |\n| **winProb**                | uint256 | The probability that a ticket will win represented as `winProb / (2^256 - 1)`                                |\n| **senderNonce**            | uint256 | A monotonically increasing counter that makes a ticket unique for a `recipientRandHash` value                |\n| **recipientRandHash**      | bytes32 | The orchestrator's commitment to `recipientRand` represented as `keccak256(abi.encodePacked(recipientRand))` |\n| **creationRound**          | uint256 | The last initialized round during which the ticket was created                                               |\n| **creationRoundBlockHash** | bytes32 | The Ethereum block hash corresponding to `creationRound`                                                     |\n\nThe hash for a ticket `T` is computed as:\n\n```\n// auxData format:\n// Bytes [0:31] = creationRound\n// Bytes [32:63] = creationRoundBlockHash\nbytes auxData = abi.encodePacked(T.creationRound, T.creationRoundBlockHash)\nbytes32 ticketHash = keccak256(abi.encodePacked(\n    T.recipient,\n    T.sender,\n    T.faceValue,\n    T.winProb,\n    T.senderNonce,\n    T.recipientRandHash,\n    auxData\n))\n```\n\n`winProb` can be a value from 0 to `2^256 - 1`. \n\n`recipientRand` is a random value generated by the orchestrator. Prior to sending tickets to an orchestrator, a broadcaster will request `recipientRandHash` from the orchestrator so that it can be included in tickets. Whenever an orchestrator reveals `recipientRand` (i.e. when the orchestrator redeems a winning ticket on-chain), the orchestrator must generate a new `recipientRand` and provide the corresponding `recipientRandHash` to broadcasters in order to ensure that broadcasters have no knowledge of `recipientRand` when creating tickets.\n\nA broadcaster needs to produce an unpredictable value that can be combined with `recipientRand` in order to create a random value that neither the broadcaster nor the orchestrator can bias. In this specification we choose to use the broadcaster's signature `senderSig` over the ticket hash as the unpredictable value and in order to ensure that each ticket hash is unique we let `senderNonce` be a monotonically increasing counter that is reset whenever a new `recipientRandHash` value is used for a ticket.\n\nThe pay out from a winning ticket should compensate not only the receiving orchestrator, but also the orchestrator's delegators that staked toward the orchestrator when the ticket was sent to the orchestrator. The `TicketBroker` contract can send the face value of winning tickets to the orchestrator's fee pool for `creationRound` such that the orchestrator's delegators during `creationRound` can claim their share of the fees. `creationRound` is also used to determine the expiration round for a ticket. Since `TicketBroker` enforces a specific ticket validity period based off of a ticket's `creationRound`, broadcasters that create tickets with `creationRound` less than the current round will effectively reduce the ticket's validity period. Thus, while broadcasters can create tickets with `creationRound` set to a past round, orchestrators will likely reject such tickets due to their shorter effective validity period which means less time for the orchestrators to redeem winning tickets. \n\nThe ticket also includes `creationRoundBlockHash` in order to prevent a broadcaster from creating tickets that specify a creation round in the future. This specification assumes that the broadcaster, orchestrator and `TicketBroker` have access to a `RoundsManager` contract that stores an Ethereum block hash for each new round. Since the Ethereum block hash for a round is only stored when the round is initialized, a broadcaster would be unable to set `creationRound` to a future round unless it is able to predict the Ethereum block hash that will be stored when the future round is initialized.\n\nWhen calculating the hash of a ticket, `creationRound` and `creationRoundBlockHash` are encoded in a byte array `auxData` following the behavior of the Solidity `abi.encodePacked()` built-in. These parameters are encoded into a byte array that is passed into `keccak256` hash function instead of passing the `creationRound` and `creationRoundBlockHash` individually because the `TicketBroker` contract defines the `Ticket` struct with a byte array `auxData` field. The motivation behind this byte array `auxData` field is to add/remove extra data in a ticket without changing the on-chain `Ticket` struct definition - the `TicketBroker` contract just needs to be upgraded to interpret updated extra data in submitted tickets. Another way that this could be accomplished without upgrading the `TicketBroker` contract itself is to encode a contract address in `auxData` and then call a validation function on the contract using the Soldity `STATICCALL` opcode with the other arguments encoded in `auxData`.\n\nGiven a ticket `T`, a broadcaster will use the ECDSA algorithm to sign the ticket hash to produce `senderSig`, a Ethereum specific signature calculated following the [eth_sign JSON-RPC method](https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign) specification. Then, a broadcaster will send both `T` and `senderSig` to an orchestrator.\n\n### Sender\n\nA `Sender` represents a ticket sender, identified by ETH address, with on-chain funds deposited that can be used to pay for winning tickets. A ticket sender may also have [Reserve](#reserve) associated with it.\n\n| Field             | Type    | Description                                                 |\n| ----------------- | ------- | ----------------------------------------------------------- |\n| **deposit**       | uint256 | Amount of funds deposited.                                  |\n| **withdrawRound** | uint256 | Round that the sender can withdraw its deposit and reserve. |\n\nFunds can only move from a sender's deposit and/or reserve (see the [Reserve](#reserve) section for additional rules for claiming funds from\nthe reserve) if:\n\n- The sender initiates an unlock, waits through the unlock period and withdraws\n- A valid winning ticket is redeemed via [TicketBroker.redeemWinningTicket()](#redeemWinningTicket) that specifies the sender's ETH address in the ticket\n\n### Reserve\n\nA `Reserve` represents locked on-chain funds that are separate from a broadcaster's deposit. Unlike deposit funds which can be used to pay for an arbitrary amount of winning tickets sent to any orchestrator, reserve funds are split into equal allocations, each of which is committed to one of the active orchestrators in the current round. An active orchestrator is guaranteed the allocation value even if the broadcaster overspends such that its deposit is insufficient to pay for outstanding winning tickets. At this point, any winning ticket redemptions would claim from the broadcaster's reserve up to the value of the allocation. As rounds progress, a broadcaster's reserve is automatically committed to the active orchestrators for the current round without any intervention by the broadcaster. \n\nThe allocation value is also the maximum amount that an active orchestrator will be willing to \"float\" for a broadcaster. When an orchestrator receives a winning ticket it treats the ticket face value as float since the broadcaster may or may not have sufficient deposit funds to cover the ticket face value at the time of redemption. An orchestrator can safely receive winning tickets and add to its float for a broadcaster up to the allocation value committed to the orchestrator from the broadcaster's reserve. Whenever an orchestrator successfully redeems a winning ticket which draws from a broadcaster's deposit, it can subtract the ticket face value from its float for a broadcaster.\n\n| Field                | Type                                             | Description                                                          |\n| -------------------- | ------------------------------------------------ | -------------------------------------------------------------------- |\n| **funds**            | uint256                                          | Funds remaining in the reserve.                                      |\n| **claimedForRound**  | mapping (uint256 => uint256)                     | Total amount claimed from reserve during a particular round.         |\n| **claimedByAddress** | mapping (uint256 => mapping (address => uint256)) | Amount claimed from reserve by an address during a particular round. |\n\nA broadcaster (identified by ETH address) only has a single reserve at any given point in time.\n\nA broadcaster's reserve can be thought of as a fixed amount of funds that is committed to the set of orchestrators which is updated each round. So, at the beginning of each round, the reserve is split into equal allocations based on the current orchestrator set. Thus, without adding additional funds to a reserve, it will be split into smaller allocations as the orchestrator set approaches its maximum size and it will be split into larger allocations as the orchestrator set shrinks in size. Since each allocation represents an orchestrator's max float for the broadcaster, as the allocation size increase, an orchestrator will be able to safely receive winning tickets with higher face values or more winning tickets with lower face values prior to having to redeem them.\n\nAn orchestrator can accept or reject work from a broadcaster based upon the broadcaster's reserve and the value of the allocation from the reserve committed to the orchestrator. For example, since the value of the allocation affects the maximum face value that can be used for tickets, lower reserves would require lower ticket face values and higher winning probabilities - if the winning probability is too high such that an orchestrator would need to redeem winning tickets too frequently (potentially contributing to network congestion), then an orchestrator might reject work from the broadaster.\n\n![reserve](images/reserve.png)\n\n## Global Parameters \n\n| Field                      | Type    | Description                                                                                                |\n| -------------------------- | ------- | ---------------------------------------------------------------------------------------------------------- |\n| **UNLOCK_PERIOD**          | uint256 | The number of rounds that a sender must wait in order to unlock funds for withdrawal                       |\n| **TICKET_VALIDITY_PERIOD** | uint256 | The number of rounds that a ticket is valid for starting from the ticket's `creationRound`                 |\n\n**UNLOCK_PERIOD** corresponds to the unlock period that a broadcaster must wait through in order to unlock funds for withdrawal. A broadcaster can cancel an unlock at any time either via an explicit cancellation or by adding more funds to its deposit and/or reserve.\n\n**TICKET_VALIDITY_PERIOD** corresponds to the validity period for a ticket starting from its `creationRound`. In practice, this value should be >= 2 rounds because if it is 1 round then there is an edge case where a winning ticket is created close to the end of a round and then quickly expires before an orchestrator can redeem it.\n\n## Contracts\n\n### TicketBroker\n\nThe `TicketBroker` contract serves as a transparent trusted third party that:\n\n- Holds deposit and reserve funds for parties that wish to send tickets as payments\n- Processes winning ticket redemptions for parties that receive tickets as payments\n\n#### redeemWinningTicket\n\nOrchestrators call `redeemWinningTicket` when they want to claim payments associated with received winning tickets. If a broadcaster's deposit is insufficient to cover the full face value of a winning ticket, the uncovered portion of the ticket face value will be claimed from the broadcaster's reserve up to the maximum allocation guaranteed to the orchestrator.\n\n```\n/**\n * @dev Redeems a winning ticket that has been signed by a broadcaster and reveals the recipientRand that corresponds\n * to the recipientRandHash included in the ticket. Successful redemption will send the ticket's faceValue\n * to the receiving orchestrator's fee pool for the ticket's creationRound\n * If the broadcaster's deposit >= the ticket faceValue, the ticket faceValue will be claimed from the broadcaster's deposit\n * If the broadcaster's deposit < the ticket faceValue, the broadcaster's reserve will be frozen and the portion of the ticket faceValue\n * not covered by the broadcaster's deposit will be claimed from the broadcaster's reserve\n * @param _ticket Winning ticket to be redeemed in order to claim payment \n * @param _senderSig Broadcaster's signature over the hash of _ticket\n * @param _recipientRand The pre-image for the recipientRandHash included in _ticket\n */\nfunction redeemWinningTicket(\n    Ticket memory _ticket\n    bytes _senderSig\n    uint256 _recipientRand\n)\n    public;\n```\n\n`redeemWinningTicket` will revert under the following conditions:\n\n- The `Controller` is paused\n- The current round is not initialized\n- The ticket's recipient is the null address\n- The ticket's sender is the null address\n- `_recipientRand` is not the pre-image for the ticket's `recipientRandHash`\n- The ticket's `creationRoundHash` is not a valid Ethereum block hash that has been stored for `creationRound`\n- The ticket has already been redeemed previously\n- `_senderSig` is not a valid signature over the ticket hash from the ticket's sender\n- The ticket did not win i.e. `uint256(keccak256(abi.encodePacked(_senderSig, _recipientRand))) >= _ticket.winProb`\n- The sender is unlocked\n- The ticket's sender's deposit and reserve are both zero\n- The ticket's recipient is not a registered orchestrator\n\nIf the ticket's recipient is not an active orchestrator in the current round, the broadcaster's deposit is greater than zero and the broadcaster's deposit is less than the ticket's face value, then the orchestrator claims the entirety of the broadcaster's deposit, but does not receive the remainder of the ticket's face value not covered by the broadcaster's deposit.\n\nFunds for a successful winning ticket redemption are added to the ticket recipient's fee pool for the ticket's `creationRound` via the `BondingManager.updateTranscoderWithFees()` function. The state accounting to track funds ownership is then managed by the `BondingManager` and the actual ETH is held by the `Minter`.\n\nReserve claiming is triggered when `T.faceValue > B.deposit` for a ticket `T` sent by a broadcaster `B` with `reserve` in round `N` with `numRecipients` active orchestrators. The reserve claiming calculations work as follows:\n\n1. `owed = T.faceValue - B.deposit`\n2. `reserveAlloc = (reserve.funds + reserve.claimedForRound[N]) / numRecipients`\n3. `claimable = reserveAlloc - reserve.claimedByAddress[O]`\n4. `claimAmount = owed`\n5. If `claimAmount > claimable`:\n   - `claimAmount = claimable`\n6. If `claimAmount == 0`:\n   - Return\n7. `reserve.claimedForRound[N] += claimAmount`\n8. `reserve.claimedByAddress[O] += claimAmount`\n9. `reserve.funds -= claimAmount`\n\nWhen calculating `reserveAlloc`, the `TicketBroker` takes the sum of `reserve.funds` and `reserve.claimedForRound[N]` because `B`'s reserve funds are committed to the active orchestrator set at the beginning of the current round. Active orchestrators in the current round are guaranteed *at least* the reserve funds available at the beginning of the round divided by the number of active orchestrators. If `B` adds more reserve funds during the round, then active orchestrators are guaranteed a greater amount. `reserve.funds + reserve.claimedForRound[N]` will equal the amount available at the beginning of the round plus any additional funds added to the reserve during the round. Each orchestrator starts off with a guaranteed allocation based on this amount. As `O` claims from the reserve, the `TicketBroker` keeps track of the amount claimed by `O` in the round thus far and subtracts the amount claimed from `O`'s maximum guaranteed allocation to determine the amount that is still claimable by `O` from `B`'s reserve.\n\n#### batchRedeemWinningTickets\n\nOrchestrators can call `batchRedeemWinningTickets` when they want to claim payments associated with multiple received winning tickets in a single atomic transaction.\n\n```\n/**\n * @dev Redeems multiple winning tickets. The function will redeem all of the provided\n * tickets and handle"
    }
  ]
}