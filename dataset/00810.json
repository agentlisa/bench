{
  "Title": "M-1: TrufVesting.cancelVesting calculates end of vesting incorrectly",
  "Content": "# Issue M-1: TrufVesting.cancelVesting calculates end of vesting incorrectly \n\nSource: https://github.com/sherlock-audit/2023-12-truflation-judging/issues/11 \n\n## Found by \nUbiquitousComputing, fnanni, nobody2018, rvierdiiev\n## Summary\nTrufVesting.cancelVesting calculates end of vesting incorrectly and because of that owner can't stop vesting for the account.\n## Vulnerability Detail\n`TrufVesting.cancelVesting` function allows owner to stop vesting for some account.\n\nIn case if vesting already finished, [then function reverts](https://github.com/sherlock-audit/2023-12-truflation/blob/main/truflation-contracts/src/token/TrufVesting.sol#L358-L360).\n\nThe problem is that `vestingInfos[categoryId][vestingId].period` is just [period for token distribution after cliff](https://github.com/sherlock-audit/2023-12-truflation/blob/main/truflation-contracts/src/token/TrufVesting.sol#L186).\n\nAs you can see in `claimable` function the vesting starts on `startTime`, then when [`initialReleasePeriod` has passed](https://github.com/sherlock-audit/2023-12-truflation/blob/main/truflation-contracts/src/token/TrufVesting.sol#L168), then `initialRelease` is distributed. Then [after `cliff` has passed](https://github.com/sherlock-audit/2023-12-truflation/blob/main/truflation-contracts/src/token/TrufVesting.sol#L178), only then [final distribution starts](https://github.com/sherlock-audit/2023-12-truflation/blob/main/truflation-contracts/src/token/TrufVesting.sol#L184).\n\nThus check if vesting already finished is incorrect in the `TrufVesting.cancelVesting` and it doesn't allow owner to cancel vesting when it is still going.\n## Impact\nOngoing vesting can't be canceled.\n## Code Snippet\nProvided above\n## Tool used\n\nManual Review\n\n## Recommendation\nThis check should be correct.\n```solidity\nif (userVesting.startTime + vestingInfos[categoryId][vestingId].initialReleasePeriod + vestingInfos[categoryId][vestingId].cliff + vestingInfos[categoryId][vestingId].period <= block.timestamp) {\n            revert AlreadyVested(categoryId, vestingId, user);\n}\n```\n\n\n\n## Discussion\n\n**ryuheimat**\n\nhttps://github.com/truflation/truflation-contracts/pull/4\n\n**mstpr**\n\nNice catch by the Watson! Fix LGTM\n\n**ryuheimat**\n\nMerged\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/151",
  "Code": [
    {
      "filename": "truflation-contracts/src/token/TrufVesting.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IVotingEscrow} from \"../interfaces/IVotingEscrow.sol\";\n\n/**\n * @title TRUF vesting contract\n * @author Ryuhei Matsuda\n * @notice Admin registers vesting information for users,\n *      and users could claim or lock vesting to veTRUF to get voting power and TRUF staking rewards\n */\ncontract TrufVesting is Ownable {\n    using SafeERC20 for IERC20;\n\n    error ZeroAddress();\n    error ZeroAmount();\n    error Forbidden(address sender);\n    error InvalidTimestamp();\n    error InvalidAmount();\n    error VestingStarted(uint64 tge);\n    error InvalidVestingCategory(uint256 id);\n    error InvalidEmissions();\n    error InvalidVestingInfo(uint256 categoryIdx, uint256 id);\n    error InvalidUserVesting();\n    error ClaimAmountExceed();\n    error UserVestingAlreadySet(uint256 categoryIdx, uint256 vestingId, address user);\n    error UserVestingDoesNotExists(uint256 categoryIdx, uint256 vestingId, address user);\n    error MaxAllocationExceed();\n    error AlreadyVested(uint256 categoryIdx, uint256 vestingId, address user);\n    error LockExist();\n    error LockDoesNotExist();\n\n    /// @dev Emitted when vesting category is set\n    event VestingCategorySet(uint256 indexed id, string category, uint256 maxAllocation, bool adminClaimable);\n\n    /// @dev Emitted when emission schedule is set\n    event EmissionScheduleSet(uint256 indexed categoryId, uint256[] emissions);\n\n    /// @dev Emitted when vesting info is set\n    event VestingInfoSet(uint256 indexed categoryId, uint256 indexed id, VestingInfo info);\n\n    /// @dev Emitted when user vesting info is set\n    event UserVestingSet(\n        uint256 indexed categoryId, uint256 indexed vestingId, address indexed user, uint256 amount, uint64 startTime\n    );\n\n    /// @dev Emitted when admin migrates user's vesting to another address\n    event MigrateUser(\n        uint256 indexed categoryId, uint256 indexed vestingId, address prevUser, address newUser, uint256 newLockupId\n    );\n\n    /// @dev Emitted when admin cancel user's vesting\n    event CancelVesting(\n        uint256 indexed categoryId, uint256 indexed vestingId, address indexed user, bool giveUnclaimed\n    );\n\n    /// @dev Emitted when user claimed vested TRUF tokens\n    event Claimed(uint256 indexed categoryId, uint256 indexed vestingId, address indexed user, uint256 amount);\n\n    /// @dev Emitted when veTRUF token has been set\n    event VeTrufSet(address indexed veTRUF);\n\n    /// @dev Emitted when user stakes vesting to veTRUF\n    event Staked(\n        uint256 indexed categoryId,\n        uint256 indexed vestingId,\n        address indexed user,\n        uint256 amount,\n        uint256 duration,\n        uint256 lockupId\n    );\n\n    /// @dev Emitted when user extended veTRUF staking period\n    event ExtendedStaking(\n        uint256 indexed categoryId, uint256 indexed vestingId, address indexed user, uint256 duration\n    );\n\n    /// @dev Emitted when user unstakes from veTRUF\n    event Unstaked(uint256 indexed categoryId, uint256 indexed vestingId, address indexed user, uint256 amount);\n\n    /// @dev Vesting Category struct\n    struct VestingCategory {\n        string category; // Category name\n        uint256 maxAllocation; // Maximum allocation for this category\n        uint256 allocated; // Current allocated amount\n        bool adminClaimable; // Allow admin to claim if value is true\n        uint256 totalClaimed; // Total claimed amount\n    }\n\n    /// @dev Vesting info struct\n    struct VestingInfo {\n        uint64 initialReleasePct; // Initial Release percentage\n        uint64 initialReleasePeriod; // Initial release period after TGE\n        uint64 cliff; // Cliff period\n        uint64 period; // Total period\n        uint64 unit; // The period to claim. ex. montlhy or 6 monthly\n    }\n\n    /// @dev User vesting info struct\n    struct UserVesting {\n        uint256 amount; // Total vesting amount\n        uint256 claimed; // Total claimed amount\n        uint256 locked; // Locked amount at VotingEscrow\n        uint64 startTime; // Vesting start time\n    }\n\n    uint256 public constant DENOMINATOR = 10000;\n    uint64 public constant ONE_MONTH = 30 days;\n\n    /// @dev TRUF token address\n    IERC20 public immutable trufToken;\n\n    /// @dev veTRUF token address\n    IVotingEscrow public veTRUF;\n\n    /// @dev TGE timestamp\n    uint64 public immutable tgeTime;\n\n    /// @dev Vesting categories\n    VestingCategory[] public categories;\n\n    // @dev Emission schedule per category. x index item of array indicates emission limit on x+1 months after TGE time.\n    mapping(uint256 => uint256[]) public emissionSchedule;\n\n    /// @dev Vesting info per category\n    mapping(uint256 => VestingInfo[]) public vestingInfos;\n\n    /// @dev User vesting information (category => info => user address => user vesting)\n    mapping(uint256 => mapping(uint256 => mapping(address => UserVesting))) public userVestings;\n\n    /// @dev Vesting lockup ids (category => info => user address => lockup id)\n    mapping(uint256 => mapping(uint256 => mapping(address => uint256))) public lockupIds;\n\n    /**\n     * @notice TRUF Vesting constructor\n     * @param _trufToken TRUF token address\n     */\n    constructor(IERC20 _trufToken, uint64 _tgeTime) {\n        if (address(_trufToken) == address(0)) revert ZeroAddress();\n\n        trufToken = _trufToken;\n\n        if (_tgeTime < block.timestamp) {\n            revert InvalidTimestamp();\n        }\n        tgeTime = _tgeTime;\n    }\n\n    /**\n     * @notice Calcualte claimable amount (total vested amount - previously claimed amount - locked amount)\n     * @param categoryId Vesting category id\n     * @param vestingId Vesting id\n     * @param user user address\n     * @return claimableAmount Claimable amount\n     */\n    function claimable(uint256 categoryId, uint256 vestingId, address user)\n        public\n        view\n        returns (uint256 claimableAmount)\n    {\n        UserVesting memory userVesting = userVestings[categoryId][vestingId][user];\n\n        VestingInfo memory info = vestingInfos[categoryId][vestingId];\n\n        uint64 startTime = userVesting.startTime + info.initialReleasePeriod;\n\n        if (startTime > block.timestamp) {\n            return 0;\n        }\n\n        uint256 totalAmount = userVesting.amount;\n\n        uint256 initialRelease = (totalAmount * info.initialReleasePct) / DENOMINATOR;\n\n        startTime += info.cliff;\n\n        if (startTime > block.timestamp) {\n            return initialRelease;\n        }\n\n        uint64 timeElapsed = ((uint64(block.timestamp) - startTime) / info.unit) * info.unit;\n\n        uint256 vestedAmount = ((totalAmount - initialRelease) * timeElapsed) / info.period + initialRelease;\n\n        uint256 maxClaimable = userVesting.amount - userVesting.locked;\n        if (vestedAmount > maxClaimable) {\n            vestedAmount = maxClaimable;\n        }\n        if (vestedAmount <= userVesting.claimed) {\n            return 0;\n        }\n\n        claimableAmount = vestedAmount - userVesting.claimed;\n        uint256 emissionLeft = getEmission(categoryId) - categories[categoryId].totalClaimed;\n\n        if (claimableAmount > emissionLeft) {\n            claimableAmount = emissionLeft;\n        }\n    }\n\n    /**\n     * @notice Claim available amount\n     * @dev Owner is able to claim for admin claimable categories.\n     * @param user user account(For non-admin claimable categories, it must be msg.sender)\n     * @param categoryId category id\n     * @param vestingId vesting id\n     * @param claimAmount token amount to claim\n     */\n    function claim(address user, uint256 categoryId, uint256 vestingId, uint256 claimAmount) public {\n        if (user != msg.sender && (!categories[categoryId].adminClaimable || msg.sender != owner())) {\n            revert Forbidden(msg.sender);\n        }\n\n        uint256 claimableAmount = claimable(categoryId, vestingId, user);\n        if (claimAmount == type(uint256).max) {\n            claimAmount = claimableAmount;\n        } else if (claimAmount > claimableAmount) {\n            revert ClaimAmountExceed();\n        }\n        if (claimAmount == 0) {\n            revert ZeroAmount();\n        }\n\n        categories[categoryId].totalClaimed += claimAmount;\n        userVestings[categoryId][vestingId][user].claimed += claimAmount;\n        trufToken.safeTransfer(user, claimAmount);\n\n        emit Claimed(categoryId, vestingId, user, claimAmount);\n    }\n\n    /**\n     * @notice Stake vesting to veTRUF to get voting power and get staking TRUF rewards\n     * @param categoryId category id\n     * @param vestingId vesting id\n     * @param amount amount to stake\n     * @param duration lock period in seconds\n     */\n    function stake(uint256 categoryId, uint256 vestingId, uint256 amount, uint256 duration) external {\n        if (amount == 0) {\n            revert ZeroAmount();\n        }\n        if (lockupIds[categoryId][vestingId][msg.sender] != 0) {\n            revert LockExist();\n        }\n\n        UserVesting storage userVesting = userVestings[categoryId][vestingId][msg.sender];\n\n        if (amount > userVesting.amount - userVesting.claimed - userVesting.locked) {\n            revert InvalidAmount();\n        }\n\n        userVesting.locked += amount;\n\n        trufToken.safeIncreaseAllowance(address(veTRUF), amount);\n        uint256 lockupId = veTRUF.stakeVesting(amount, duration, msg.sender) + 1;\n        lockupIds[categoryId][vestingId][msg.sender] = lockupId;\n\n        emit Staked(categoryId, vestingId, msg.sender, amount, duration, lockupId);\n    }\n\n    /**\n     * @notice Extend veTRUF staking period\n     * @param categoryId category id\n     * @param vestingId vesting id\n     * @param duration lock period from now\n     */\n    function extendStaking(uint256 categoryId, uint256 vestingId, uint256 duration) external {\n        uint256 lockupId = lockupIds[categoryId][vestingId][msg.sender];\n        if (lockupId == 0) {\n            revert LockDoesNotExist();\n        }\n\n        veTRUF.extendVestingLock(msg.sender, lockupId - 1, duration);\n\n        emit ExtendedStaking(categoryId, vestingId, msg.sender, duration);\n    }\n\n    /**\n     * @notice Unstake vesting from veTRUF\n     * @param categoryId category id\n     * @param vestingId vesting id\n     */\n    function unstake(uint256 categoryId, uint256 vestingId) external {\n        uint256 lockupId = lockupIds[categoryId][vestingId][msg.sender];\n        if (lockupId == 0) {\n            revert LockDoesNotExist();\n        }\n\n        uint256 amount = veTRUF.unstakeVesting(msg.sender, lockupId - 1, false);\n\n        UserVesting storage userVesting = userVestings[categoryId][vestingId][msg.sender];\n\n        userVesting.locked -= amount;\n        delete lockupIds[categoryId][vestingId][msg.sender];\n\n        emit Unstaked(categoryId, vestingId, msg.sender, amount);\n    }\n\n    /**\n     * @notice Migrate owner of vesting. Used when user lost his private key\n     * @dev Only admin can migrate users vesting\n     * @param categoryId Category id\n     * @param vestingId Vesting id\n     * @param prevUser previous user address\n     * @param newUser new user address\n     */\n    function migrateUser(uint256 categoryId, uint256 vestingId, address prevUser, address newUser) external onlyOwner {\n        UserVesting storage prevVesting = userVestings[categoryId][vestingId][prevUser];\n        UserVesting storage newVesting = userVestings[categoryId][vestingId][newUser];\n\n        if (newVesting.amount != 0) {\n            revert UserVestingAlreadySet(categoryId, vestingId, newUser);\n        }\n        if (prevVesting.amount == 0) {\n            revert UserVestingDoesNotExists(categoryId, vestingId, prevUser);\n        }\n\n        newVesting.amount = prevVesting.amount;\n        newVesting.claimed = prevVesting.claimed;\n        newVesting.startTime = prevVesting.startTime;\n\n        uint256 lockupId = lockupIds[categoryId][vestingId][prevUser];\n        uint256 newLockupId;\n\n        if (lockupId != 0) {\n            newLockupId = veTRUF.migrateVestingLock(prevUser, newUser, lockupId - 1) + 1;\n            lockupIds[categoryId][vestingId][newUser] = newLockupId;\n            delete lockupIds[categoryId][vestingId][prevUser];\n\n            newVesting.locked = prevVesting.locked;\n        }\n        delete userVestings[categoryId][vestingId][prevUser];\n\n        emit MigrateUser(categoryId, vestingId, prevUser, newUser, newLockupId);\n    }\n\n    /**\n     * @notice Cancel vesting and force cancel from voting escrow\n     * @dev Only admin can cancel users vesting\n     * @param categoryId Category id\n     * @param vestingId Vesting id\n     * @param user user address\n     * @param giveUnclaimed Send currently vested, but unclaimed amount to use or not\n     */\n    function cancelVesting(uint256 categoryId, uint256 vestingId, address user, bool giveUnclaimed)\n        external\n        onlyOwner\n    {\n        UserVesting memory userVesting = userVestings[categoryId][vestingId][user];\n\n        if (userVesting.amount == 0) {\n            revert UserVestingDoesNotExists(categoryId, vestingId, user);\n        }\n\n        if (userVesting.startTime + vestingInfos[categoryId][vestingId].period <= block.timestamp) {\n            revert AlreadyVested(categoryId, vestingId, user);\n        }\n\n        uint256 lockupId = lockupIds[categoryId][vestingId][user];\n\n        if (lockupId != 0) {\n            veTRUF.unstakeVesting(user, lockupId - 1, true);\n            delete lockupIds[categoryId][vestingId][user];\n            userVesting.locked = 0;\n        }\n\n        VestingCategory storage category = categories[categoryId];\n\n        uint256 claimableAmount = claimable(categoryId, vestingId, user);\n        if (giveUnclaimed && claimableAmount != 0) {\n            trufToken.safeTransfer(user, claimableAmount);\n\n            userVesting.claimed += claimableAmount;\n            category.totalClaimed += claimableAmount;\n            emit Claimed(categoryId, vestingId, user, claimableAmount);\n        }\n\n        uint256 unvested = userVesting.amount - userVesting.claimed;\n\n        delete userVestings[categoryId][vestingId][user];\n\n        category.allocated -= unvested;\n\n        emit CancelVesting(categoryId, vestingId, user, giveUnclaimed);\n    }\n\n    /**\n     * @notice Add or modify vesting category\n     * @dev Only admin can set vesting category\n     * @param id id to modify or uint256.max to add new category\n     * @param category new vesting category\n     * @param maxAllocation Max allocation amount for this category\n     * @param adminClaimable Admin claimable flag\n     */\n    function setVestingCategory(uint256 id, string calldata category, uint256 maxAllocation, bool adminClaimable)\n        public\n        onlyOwner\n    {\n        if (block.timestamp >= tgeTime) {\n            revert VestingStarted(tgeTime);\n        }\n        if (maxAllocation == 0) {\n            revert ZeroAmount();\n        }\n\n        int256 tokenMove;\n        if (id == type(uint256).max) {\n            id = categories.length;\n            categories.push(VestingCategory(category, maxAllocation, 0, adminClaimable, 0));\n            tokenMove = int256(maxAllocation);\n        } else {\n            if (categories[id].allocated > maxAllocation) {\n                revert MaxAllocationExceed();\n            }\n            tokenMove = int256(maxAllocation) - int256(categories[id].maxAllocation);\n            categories[id].maxAllocation = maxAllocation;\n            categories[id].category = category;\n            categories[id].adminClaimable = adminClaimable;\n        }\n\n        if (tokenMove > 0) {\n            trufToken.safeTransferFrom(msg.sender, address(this), uint256(tokenMove));\n        } else if (tokenMove < 0) {\n            trufToken.safeTransfer(msg.sender, uint256(-tokenMove));\n        }\n\n        emit VestingCategorySet(id, category, maxAllocation, adminClaimable);\n    }\n\n    /**\n     * @notice Set emission schedule\n     * @dev Only admin can set emission schedule\n     * @param categoryId category id\n     * @param emissions Emission schedule\n     */\n    function setEmissionSchedule(uint256 categoryId, uint256[] memory emissions) public onlyOwner {\n        if (block.timestamp >= tgeTime) {\n            revert VestingStarted(tgeTime);\n        }\n\n        uint256 maxAllocation = categories[categoryId].maxAllocation;\n\n        if (emissions.length == 0 || emissions[emissions.length - 1] != maxAllocation) {\n            revert InvalidEmissions();\n        }\n\n        delete emissionSchedule[categoryId];\n        emissionSchedule[categoryId] = emissions;\n\n        emit EmissionScheduleSet(categoryId, emissions);\n    }\n\n    /**\n     * @notice Add or modify vesting information\n     * @dev Only admin can set vesting info\n     * @param categoryIdx category id\n     * @param id id to modify or uint256.max to add new info\n     * @param info new vesting info\n     */\n    function setVestingInfo(uint256 categoryIdx, uint256 id, VestingInfo calldata info) public onlyOwner {\n        if (id == type(uint256).max) {\n            id = vestingInfos[categoryIdx].length;\n            vestingInfos[categoryIdx].push(info);\n        } else {\n            vestingInfos[categoryIdx][id] = info;\n        }\n\n        emit VestingInfoSet(categoryIdx, id, info);\n    }\n\n    /**\n     * @notice Set user vesting amount\n     * @dev Only admin can set user vesting\n     * @dev It will be failed if it exceeds max allocation\n     * @param categoryId category id\n     * @param vestingId vesting id\n     * @param user user address\n     * @param startTime zero to start from TGE or non-zero to set up custom start time\n     * @param amount vesting amount\n     */\n    function setUserVesting(uint256 categoryId, uint256 vestingId, address user, uint64 startTime, uint256 amount)\n        public\n        onlyOwner\n    {\n        if (amount == 0) {\n            revert ZeroAmount();\n        }\n        if (categoryId >= categories.length) {\n            revert InvalidVestingCategory(categoryId);\n        }\n        if (vestingId >= vestingInfos[categoryId].length) {\n            revert InvalidVestingInfo(categoryId, vestingId);\n        }\n\n        VestingCategory storage category = categories[categoryId];\n        UserVesting storage userVesting = userVestings[categoryId][vestingId][user];\n\n        category.allocated += amount;\n        category.allocated -= userVesting.amount;\n        if (category.allocated > category.maxAllocation) {\n            revert MaxAllocationExceed();\n        }\n\n        if (amount < userVesting.claimed + userVesting.locked) {\n            revert InvalidUserVesting();\n        }\n        if (startTime != 0 && startTime < tgeTime) revert InvalidTimestamp();\n\n        userVesting.amount = amount;\n        userVesting.startTime = startTime == 0 ? tgeTime : startTime;\n\n        emit UserVestingSet(categoryId, vestingId, user, amount, userVesting.startTime);\n    }\n\n    /**\n     * @notice Set veTRUF token\n     * @dev Only admin can set veTRUF\n     * @param _veTRUF veTRUF token address\n     */\n    function setVeTruf(address _veTRUF) external onlyOwner {\n        if (_veTRUF == address(0)) {\n            revert ZeroAddress();\n        }\n        veTRUF = IVotingEscrow(_veTRUF);\n\n        emit VeTrufSet(_veTRUF);\n    }\n\n    /**\n     * @notice Multicall several functions in single transaction\n     * @dev Could be for setting vesting categories, vesting info, and user vesting in single transaction at once\n     * @param payloads list of payloads\n     */\n    function multicall(bytes[] calldata payloads) external {\n        uint256 len = payloads.length;\n        for (uint256 i; i < len;) {\n            (bool success, bytes memory result) = address(this).delegatecall(payloads[i]);\n            if (!success) {\n                if (result.length < 68) revert();\n                assembly {\n                    result := add(result, 0x04)\n                }\n                revert(abi.decode(result, (string)));\n            }\n\n            unchecked {\n                i += 1;\n            }\n        }\n    }\n\n    /**\n     * @return emissions returns emission schedule of category\n     */\n    function getEmissionSchedule(uint256 categoryId) external view returns (uint256[] memory emissions) {\n        emissions = emissionSchedule[categoryId];\n    }\n\n    /**\n     * @return emissionLimit returns current emission limit of category\n     */\n    function getEmission(uint256 categoryId) public view returns (uint256 emissionLimit) {\n        uint64 _tgeTime = tgeTime;\n\n        if (block.timestamp >= _tgeTime) {\n            uint256 maxAllocation = categories[categoryId].maxAllocation;\n\n            if (emissionSchedule[categoryId].length == 0) {\n                return maxAllocation;\n            }\n            uint64 elapsedTime = uint64(block.timestamp) - _tgeTime;\n            uint64 elapsedMonth = elapsedTime / ONE_MONTH;\n\n            if (elapsedMonth >= emissionSchedule[categoryId].length) {\n                return maxAllocation;\n            }\n\n            uint256 lastMonthEmission = elapsedMonth == 0 ? 0 : emissionSchedule[categoryId][elapsedMonth - 1];\n            uint256 thisMonthEmission = emissionSchedule[categoryId][elapsedMonth];\n\n            uint64 elapsedTimeOfLastMonth = elapsedTime % ONE_MONTH;\n            emissionLimit =\n                (thisMonthEmission - lastMonthEmission) * elapsedTimeOfLastMonth / ONE_MONTH + lastMonthEmission;\n            if (emissionLimit > maxAllocation) {\n                emissionLimit = maxAllocation;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "truflation-contracts/src/token/TrufVesting.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IVotingEscrow} from \"../interfaces/IVotingEscrow.sol\";\n\n/**\n * @title TRUF vesting contract\n * @author Ryuhei Matsuda\n * @notice Admin registers vesting information for users,\n *      and users could claim or lock vesting to veTRUF to get voting power and TRUF staking rewards\n */\ncontract TrufVesting is Ownable {\n    using SafeERC20 for IERC20;\n\n    error ZeroAddress();\n    error ZeroAmount();\n    error Forbidden(address sender);\n    error InvalidTimestamp();\n    error InvalidAmount();\n    error VestingStarted(uint64 tge);\n    error InvalidVestingCategory(uint256 id);\n    error InvalidEmissions();\n    error InvalidVestingInfo(uint256 categoryIdx, uint256 id);\n    error InvalidUserVesting();\n    error ClaimAmountExceed();\n    error UserVestingAlreadySet(uint256 categoryIdx, uint256 vestingId, address user);\n    error UserVestingDoesNotExists(uint256 categoryIdx, uint256 vestingId, address user);\n    error MaxAllocationExceed();\n    error AlreadyVested(uint256 categoryIdx, uint256 vestingId, address user);\n    error LockExist();\n    error LockDoesNotExist();\n\n    /// @dev Emitted when vesting category is set\n    event VestingCategorySet(uint256 indexed id, string category, uint256 maxAllocation, bool adminClaimable);\n\n    /// @dev Emitted when emission schedule is set\n    event EmissionScheduleSet(uint256 indexed categoryId, uint256[] emissions);\n\n    /// @dev Emitted when vesting info is set\n    event VestingInfoSet(uint256 indexed categoryId, uint256 indexed id, VestingInfo info);\n\n    /// @dev Emitted when user vesting info is set\n    event UserVestingSet(\n        uint256 indexed categoryId, uint256 indexed vestingId, address indexed user, uint256 amount, uint64 startTime\n    );\n\n    /// @dev Emitted when admin migrates user's vesting to another address\n    event MigrateUser(\n        uint256 indexed categoryId, uint256 indexed vestingId, address prevUser, address newUser, uint256 newLockupId\n    );\n\n    /// @dev Emitted when admin cancel user's vesting\n    event CancelVesting(\n        uint256 indexed categoryId, uint256 indexed vestingId, address indexed user, bool giveUnclaimed\n    );\n\n    /// @dev Emitted when user claimed vested TRUF tokens\n    event Claimed(uint256 indexed categoryId, uint256 indexed vestingId, address indexed user, uint256 amount);\n\n    /// @dev Emitted when veTRUF token has been set\n    event VeTrufSet(address indexed veTRUF);\n\n    /// @dev Emitted when user stakes vesting to veTRUF\n    event Staked(\n        uint256 indexed categoryId,\n        uint256 indexed vestingId,\n        address indexed user,\n        uint256 amount,\n        uint256 duration,\n        uint256 lockupId\n    );\n\n    /// @dev Emitted when user extended veTRUF staking period\n    event ExtendedStaking(\n        uint256 indexed categoryId, uint256 indexed vestingId, address indexed user, uint256 duration\n    );\n\n    /// @dev Emitted when user unstakes from veTRUF\n    event Unstaked(uint256 indexed categoryId, uint256 indexed vestingId, address indexed user, uint256 amount);\n\n    /// @dev Vesting Category struct\n    struct VestingCategory {\n        string category; // Category name\n        uint256 maxAllocation; // Maximum allocation for this category\n        uint256 allocated; // Current allocated amount\n        bool adminClaimable; // Allow admin to claim if value is true\n        uint256 totalClaimed; // Total claimed amount\n    }\n\n    /// @dev Vesting info struct\n    struct VestingInfo {\n        uint64 initialReleasePct; // Initial Release percentage\n        uint64 initialReleasePeriod; // Initial release period after TGE\n        uint64 cliff; // Cliff period\n        uint64 period; // Total period\n        uint64 unit; // The period to claim. ex. montlhy or 6 monthly\n    }\n\n    /// @dev User vesting info struct\n    struct UserVesting {\n        uint256 amount; // Total vesting amount\n        uint256 claimed; // Total claimed amount\n        uint256 locked; // Locked amount at VotingEscrow\n        uint64 startTime; // Vesting start time\n    }\n\n    uint256 public constant DENOMINATOR = 10000;\n    uint64 public constant ONE_MONTH = 30 days;\n\n    /// @dev TRUF token address\n    IERC20 public immutable trufToken;\n\n    /// @dev veTRUF token address\n    IVotingEscrow public veTRUF;\n\n    /// @dev TGE timestamp\n    uint64 public immutable tgeTime;\n\n    /// @dev Vesting categories\n    VestingCategory[] public categories;\n\n    // @dev Emission schedule per category. x index item of array indicates emission limit on x+1 months after TGE time.\n    mapping(uint256 => uint256[]) public emissionSchedule;\n\n    /// @dev Vesting info per category\n    mapping(uint256 => VestingInfo[]) public vestingInfos;\n\n    /// @dev User vesting information (category => info => user address => user vesting)\n    mapping(uint256 => mapping(uint256 => mapping(address => UserVesting))) public userVestings;\n\n    /// @dev Vesting lockup ids (category => info => user address => lockup id)\n    mapping(uint256 => mapping(uint256 => mapping(address => uint256))) public lockupIds;\n\n    /**\n     * @notice TRUF Vesting constructor\n     * @param _trufToken TRUF token address\n     */\n    constructor(IERC20 _trufToken, uint64 _tgeTime) {\n        if (address(_trufToken) == address(0)) revert ZeroAddress();\n\n        trufToken = _trufToken;\n\n        if (_tgeTime < block.timestamp) {\n            revert InvalidTimestamp();\n        }\n        tgeTime = _tgeTime;\n    }\n\n    /**\n     * @notice Calcualte claimable amount (total vested amount - previously claimed amount - locked amount)\n     * @param categoryId Vesting category id\n     * @param vestingId Vesting id\n     * @param user user address\n     * @return claimableAmount Claimable amount\n     */\n    function claimable(uint256 categoryId, uint256 vestingId, address user)\n        public\n        view\n        returns (uint256 claimableAmount)\n    {\n        UserVesting memory userVesting = userVestings[categoryId][vestingId][user];\n\n        VestingInfo memory info = vestingInfos[categoryId][vestingId];\n\n        uint64 startTime = userVesting.startTime + info.initialReleasePeriod;\n\n        if (startTime > block.timestamp) {\n            return 0;\n        }\n\n        uint256 totalAmount = userVesting.amount;\n\n        uint256 initialRelease = (totalAmount * info.initialReleasePct) / DENOMINATOR;\n\n        startTime += info.cliff;\n\n        if (startTime > block.timestamp) {\n            return initialRelease;\n        }\n\n        uint64 timeElapsed = ((uint64(block.timestamp) - startTime) / info.unit) * info.unit;\n\n        uint256 vestedAmount = ((totalAmount - initialRelease) * timeElapsed) / info.period + initialRelease;\n\n        uint256 maxClaimable = userVesting.amount - userVesting.locked;\n        if (vestedAmount > maxClaimable) {\n            vestedAmount = maxClaimable;\n        }\n        if (vestedAmount <= userVesting.claimed) {\n            return 0;\n        }\n\n        claimableAmount = vestedAmount - userVesting.claimed;\n        uint256 emissionLeft = getEmission(categoryId) - categories[categoryId].totalClaimed;\n\n        if (claimableAmount > emissionLeft) {\n            claimableAmount = emissionLeft;\n        }\n    }\n\n    /**\n     * @notice Claim available amount\n     * @dev Owner is able to claim for admin claimable categories.\n     * @param user user account(For non-admin claimable categories, it must be msg.sender)\n     * @param categoryId category id\n     * @param vestingId vesting id\n     * @param claimAmount token amount to claim\n     */\n    function claim(address user, uint256 categoryId, uint256 vestingId, uint256 claimAmount) public {\n        if (user != msg.sender && (!categories[categoryId].adminClaimable || msg.sender != owner())) {\n            revert Forbidden(msg.sender);\n        }\n\n        uint256 claimableAmount = claimable(categoryId, vestingId, user);\n        if (claimAmount == type(uint256).max) {\n            claimAmount = claimableAmount;\n        } else if (claimAmount > claimableAmount) {\n            revert ClaimAmountExceed();\n        }\n        if (claimAmount == 0) {\n            revert ZeroAmount();\n        }\n\n        categories[categoryId].totalClaimed += claimAmount;\n        userVestings[categoryId][vestingId][user].claimed += claimAmount;\n        trufToken.safeTransfer(user, claimAmount);\n\n        emit Claimed(categoryId, vestingId, user, claimAmount);\n    }\n\n    /**\n     * @notice Stake vesting to veTRUF to get voting power and get staking TRUF rewards\n     * @param categoryId category id\n     * @param vestingId vesting id\n     * @param amount amount to stake\n     * @param duration lock period in seconds\n     */\n    function stake(uint256 categoryId, uint256 vestingId, uint256 amount, uint256 duration) external {\n        if (amount == 0) {\n            revert ZeroAmount();\n        }\n        if (lockupIds[categoryId][vestingId][msg.sender] != 0) {\n            revert LockExist();\n        }\n\n        UserVesting storage userVesting = userVestings[categoryId][vestingId][msg.sender];\n\n        if (amount > userVesting.amount - userVesting.claimed - userVesting.locked) {\n            revert InvalidAmount();\n        }\n\n        userVesting.locked += amount;\n\n        trufToken.safeIncreaseAllowance(address(veTRUF), amount);\n        uint256 lockupId = veTRUF.stakeVesting(amount, duration, msg.sender) + 1;\n        lockupIds[categoryId][vestingId][msg.sender] = lockupId;\n\n        emit Staked(categoryId, vestingId, msg.sender, amount, duration, lockupId);\n    }\n\n    /**\n     * @notice Extend veTRUF staking period\n     * @param categoryId category id\n     * @param vestingId vesting id\n     * @param duration lock period from now\n     */\n    function extendStaking(uint256 categoryId, uint256 vestingId, uint256 duration) external {\n        uint256 lockupId = lockupIds[categoryId][vestingId][msg.sender];\n        if (lockupId == 0) {\n            revert LockDoesNotExist();\n        }\n\n        veTRUF.extendVestingLock(msg.sender, lockupId - 1, duration);\n\n        emit ExtendedStaking(categoryId, vestingId, msg.sender, duration);\n    }\n\n    /**\n     * @notice Unstake vesting from veTRUF\n     * @param categoryId category id\n     * @param vestingId vesting id\n     */\n    function unstake(uint256 categoryId, uint256 vestingId) external {\n        uint256 lockupId = lockupIds[categoryId][vestingId][msg.sender];\n        if (lockupId == 0) {\n            revert LockDoesNotExist();\n        }\n\n        uint256 amount = veTRUF.unstakeVesting(msg.sender, lockupId - 1, false);\n\n        UserVesting storage userVesting = userVestings[categoryId][vestingId][msg.sender];\n\n        userVesting.locked -= amount;\n        delete lockupIds[categoryId][vestingId][msg.sender];\n\n        emit Unstaked(categoryId, vestingId, msg.sender, amount);\n    }\n\n    /**\n     * @notice Migrate owner of vesting. Used when user lost his pr"
    }
  ]
}