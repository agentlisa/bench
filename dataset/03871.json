{
  "Title": "[H01] Inconsistent and erroneous handling of ERC20 tokens",
  "Content": "The [ERC20 token specification](https://eips.ethereum.org/EIPS/eip-20) defined the required interface of an ERC20 token. This included defining the functions `transfer`, `transferFrom`, and `approve` such that they return a `bool` signalling whether the function was successful or not. The specification goes on to say that functions *should* throw on failure, however throwing is not a requirement. This specification has lead to the development of 3 different types of ERC20 tokens:\n\n\n1. Tokens that `throw` on failure, and return `true` on success. One example is DAI.\n2. Tokens that return `false` on failure, and return `true` on success. One example is ZRX.\n3. Tokens that `throw` on failure, and *do not* return a boolean. One example is USDT.\n\n\nThroughout the codebase, ERC20 token transfers and approvals are handled inconsistently. This leads to a variety of different errors when handling ERC20 tokens. This list is not exhaustive:\n\n\n* [Line 94 of `_takeUnderlying`](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/blob/943df3a8fcd8dd128af3beb0c85a0480c0e95ead/contracts/providers/CompoundProvider.sol#L94) in the `CompoundProvider` contract reverts if the `transferFrom` returns false. While this works with tokens of types 1 and 2, the `require` statement assumes the transfer is going to return a boolean. This means that for tokens of type 3, the code is trying to read return data that does not exist. This leads to successful transfers of token type 3 reverting. In turn, this means tokens of this type cannot be deposited into the protocol at all.\n* [Line 213 of `harvest`](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/blob/943df3a8fcd8dd128af3beb0c85a0480c0e95ead/contracts/providers/CompoundProvider.sol#L213) in the `CompoundProvider` contract does not check the returned result of a `transfer` call. While tokens of type 1 and type 3 would have thrown if the transfer failed, it is vital to check the return value of tokens of type 2. In this example, the protocol assumes it has successfully paid the `msg.sender` of the `harvest` function, when it may have failed and returned false. This issue is also faced when `CompoundProvider`â€˜s [\\_sendUnderlying](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/blob/943df3a8fcd8dd128af3beb0c85a0480c0e95ead/contracts/providers/CompoundProvider.sol#L100) is called.\n\n\nDue to the complexities of adapting code for all 3 types of ERC20 tokens, consider instead using the `safeTransfer`, `safeTransferFrom`, and `safeApprove` functions from the [OpenZeppelin library `SafeERC20`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.4/contracts/token/ERC20/SafeERC20.sol). This library safely handles ERC20 tokens that behave in different ways, and ensures that all calls revert on failure, whether or not the underlying token does.\n\n\n**Update**: *Fixed in [PR#41](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/pull/41). In the same PR, additional checks were added to verify the transfer amounts of `uTokens`; those checks are not compatible with `uTokens` that assess fees on transfer. The referenced PR is based on commits that include other changes to the codebase which have not been reviewed by OpenZeppelin.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/providers/CompoundProvider.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./../external-interfaces/uniswap/IUniswapV2Router.sol\";\nimport \"./../external-interfaces/compound-finance/ICToken.sol\";\nimport \"./../external-interfaces/compound-finance/IComptroller.sol\";\n\nimport \"./../lib/math/MathUtils.sol\";\n\nimport \"./CompoundController.sol\";\nimport \"./../oracle/IYieldOracle.sol\";\nimport \"./../IProvider.sol\";\n\ncontract CompoundProvider is IProvider {\n    using SafeMath for uint256;\n\n    // underlying token (ie. DAI)\n    address public uToken; // IERC20\n\n    // claim token (ie. cDAI)\n    address public cToken;\n\n    // compound.finance Comptroller\n    address public comptroller; // IComptroller\n\n    // deposit reward token (ie. COMP)\n    address public rewardCToken; // IERC20\n\n    // cToken.balanceOf(this) measuring only deposits by users (excludes dirrect cToken transfers to pool)\n    uint256 public cTokenBalance;\n\n    // --- COMP reward checkpoint\n    // saved comptroller.compSupplyState(cToken) value @ the moment the pool harvested\n    uint256 public compSupplierIndexLast;\n\n    // cumulative balanceOf @ last harvest\n    uint256 public cumulativeUnderlyingBalanceHarvestedLast;\n\n    // when we last harvested\n    uint256 public harvestedLast;\n    // --- /COMP reward checkpoint\n\n    bool public _setup;\n\n    modifier accountYield {\n        _accountYieldInternal();\n        IYieldOracle(IController(this.controller()).oracle()).update();\n\n        _;\n\n        underlyingBalanceLast = this.underlyingBalance();\n    }\n\n    function setup(\n        address smartYield_,\n        address controller_,\n        address cToken_\n    )\n      external\n    {\n        require(\n          false == _setup,\n          \"PPC: already setup\"\n        );\n\n        smartYield = smartYield_;\n        controller = controller_;\n        cToken = cToken_;\n        uToken = ICToken(cToken_).underlying();\n        comptroller = ICToken(cToken_).comptroller();\n        rewardCToken = IComptroller(comptroller).getCompAddress();\n\n        _enterMarket();\n\n        _setup = true;\n    }\n\n  // externals\n\n    // take underlyingAmount_ from from_\n    function _takeUnderlying(address from_, uint256 underlyingAmount_)\n      external override\n      onlySmartYield\n    {\n        require(\n            underlyingAmount_ <= IERC20(uToken).allowance(from_, address(this)),\n            \"PPC: _takeUnderlying allowance\"\n        );\n        require(\n            IERC20(uToken).transferFrom(from_, address(this), underlyingAmount_),\n            \"PPC: _takeUnderlying transferFrom\"\n        );\n    }\n\n    // transfer away underlyingAmount_ to to_\n    function _sendUnderlying(address to_, uint256 underlyingAmount_)\n      external override\n      onlySmartYield\n      returns (bool)\n    {\n        return IERC20(uToken).transfer(to_, underlyingAmount_);\n    }\n\n    // deposit underlyingAmount_ with the liquidity provider adds resulting cTokens to cTokenBalance\n    // on the very first call enters the compound.finance market and saves the checkpoint needed for compRewardExpected\n    function _depositProvider(uint256 underlyingAmount_, uint256 takeFees_)\n      external override\n      onlySmartYield\n    {\n        _depositProviderInternal(underlyingAmount_, takeFees_);\n    }\n\n    // withdraw underlyingAmount_ from the liquidity provider, substract the lost cTokens from cTokenBalance\n    function _withdrawProvider(uint256 underlyingAmount_, uint256 takeFees_)\n      external override\n      onlySmartYield\n      accountYield\n    {\n        underlyingFees += takeFees_;\n\n        uint256 cTokensBefore = ICTokenErc20(cToken).balanceOf(address(this));\n        uint256 err = ICToken(cToken).redeemUnderlying(underlyingAmount_);\n        require(0 == err, \"PPC: _withdrawProvider redeemUnderlying\");\n        cTokenBalance -= cTokensBefore - ICTokenErc20(cToken).balanceOf(address(this));\n    }\n\n    // called by anyone to convert pool's COMP -> underlying and then deposit it. caller gets HARVEST_REWARD of the harvest\n    function harvest()\n      external override\n    {\n        require(\n          harvestedLast < this.currentTime(),\n          \"PPC: harvest later\"\n        );\n\n        // this is 0 unless someone transfers underlying to the contract\n        uint256 underlyingBefore = IERC20(uToken).balanceOf(address(this));\n\n        // COMP gets on the pool when:\n        // 1) pool calls comptroller.claimComp()\n        // 2) anyone calls comptroller.claimComp()\n        // 3) anyone transfers COMP to the pool\n        // we want to yield closest to 1+2 but not 3\n        uint256 rewardExpected = compRewardExpected(); // COMP\n\n        address[] memory holders = new address[](1);\n        holders[0] = address(this);\n        address[] memory markets = new address[](1);\n        markets[0] = cToken;\n\n        IComptroller(comptroller).claimComp(holders, markets, false, true);\n\n        _updateCompState();\n\n        uint256 rewardGot = IERC20(rewardCToken).balanceOf(address(this)); // COMP\n\n        if (rewardGot > 0) {\n            address uniswap = CompoundController(controller).uniswap();\n\n            // should be like:\n            // address[] memory path = new address[](3);\n            // path[0] = address(rewardCToken);\n            // path[1] = address(wethToken);\n            // path[2] = address(uToken);\n            address[] memory path = CompoundController(controller).getUniswapPath();\n\n            // TODO: optimize pre-approve uniswap, gas\n            IERC20(rewardCToken).approve(address(uniswap), rewardGot);\n\n            IUniswapV2Router(uniswap).swapExactTokensForTokens(\n                rewardGot,\n                uint256(0),\n                path,\n                address(this),\n                this.currentTime() + 1800\n            );\n        }\n\n        uint256 underlyingGot = IERC20(uToken).balanceOf(address(this));\n\n        if (underlyingGot == 0) {\n          // got no goodies :(\n          return;\n        }\n\n        uint256 extra;\n\n        if (underlyingBefore > 0) {\n          // someone sent us a present as underlying -> add it to the fees\n          extra = underlyingBefore;\n          underlyingGot -= extra;\n        }\n\n        if (rewardGot > rewardExpected) {\n          // moar present as COMP reward -> add it to the fees\n          // throw event\n          uint256 rExtra = MathUtils.fractionOf(underlyingGot, (rewardGot - rewardExpected) * 1e18 / rewardGot);\n          extra += rExtra;\n          underlyingGot -= rExtra;\n        }\n\n        uint256 toCaller = MathUtils.fractionOf(underlyingGot, CompoundController(controller).HARVEST_REWARD());\n\n        // deposit pool reward to compound - harvest reward + any goodies we received\n        // any extra goodies go to fees\n        _depositProviderInternal(underlyingGot - toCaller + extra, extra);\n\n        // pay this man\n        IERC20(uToken).transfer(msg.sender, IERC20(uToken).balanceOf(address(this)));\n    }\n\n    function transferFees()\n      external\n      override\n      accountYield\n    {\n      // cleanup any cTokens dust or cTokens that may have been dumped on the pool\n      if (ICTokenErc20(cToken).balanceOf(address(this)) > cTokenBalance) {\n        underlyingFees += ICToken(cToken).exchangeRateStored() * (ICTokenErc20(cToken).balanceOf(address(this)) - cTokenBalance) / 1e18;\n      }\n      uint256 ctokensToPay = underlyingFees * 1e18 / ICToken(cToken).exchangeRateStored();\n      uint256 err = ICToken(cToken).redeem(\n          MathUtils.min(ctokensToPay, ICTokenErc20(cToken).balanceOf(address(this)))\n      );\n      require(0 == err, \"PPC: transferFees redeem\");\n      underlyingFees = 0;\n      cTokenBalance = ICTokenErc20(cToken).balanceOf(address(this));\n      IERC20(uToken).transfer(IController(controller).feesOwner(), IERC20(uToken).balanceOf(address(this)));\n    }\n\n    // returns cumulatives and accumulates/updates internal state\n    // oracle should call this when updating\n    function cumulatives()\n      external override\n    returns(uint256 cumulativeSecondlyYield, uint256 cumulativeUnderlyingBalance) {\n        _accountYieldInternal();\n        underlyingBalanceLast = this.underlyingBalance();\n        return (cumulativeSecondlyYieldLast, cumulativeUnderlyingBalanceLast);\n    }\n\n    // returns cumulated yield per 1 underlying coin (ie 1 DAI, 1 ETH) times 1e18\n    // per https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/libraries/UniswapV2OracleLibrary.sol#L16\n    function currentCumulatives()\n      external view override\n    returns (uint256 cumulativeSecondlyYield, uint256 cumulativeUnderlyingBalance)\n    {\n        uint32 blockTimestamp = uint32(this.currentTime() % 2**32);\n        cumulativeSecondlyYield = cumulativeSecondlyYieldLast;\n        cumulativeUnderlyingBalance = cumulativeUnderlyingBalanceLast;\n\n        uint32 timeElapsed = blockTimestamp - cumulativeTimestampLast; // overflow is desired\n        if (timeElapsed > 0) {\n            if (underlyingBalanceLast > 0) {\n              // cumulativeSecondlyYield overflows eventually,\n              // due to the way it is used in the oracle that's ok,\n              // as long as it doesn't overflow twice during the windowSize\n              // see OraclelizedMock.cumulativeOverflowProof() for proof\n              cumulativeSecondlyYield +=\n                  // (this.underlyingBalance() - underlyingBalanceLast) * 1e18 -> overflows only if (this.underlyingBalance() - underlyingBalanceLast) >~ 10^41 ETH, DAI, USDC etc\n                  // (this.underlyingBalance() - underlyingBalanceLast) never underflows\n                  ((this.underlyingBalance() - underlyingBalanceLast) * 1e18) / underlyingBalanceLast;\n            }\n            cumulativeUnderlyingBalance += this.underlyingBalance() * timeElapsed;\n        }\n        return (cumulativeSecondlyYield, cumulativeUnderlyingBalance);\n    }\n\n    // current total underlying balance, as measured by pool\n    function underlyingBalance()\n      external view virtual override\n    returns (uint256)\n    {\n        // https://compound.finance/docs#protocol-math\n        return\n            cTokenBalance * ICToken(cToken).exchangeRateStored() / 1e18;\n    }\n\n  // /externals\n\n    function currentTime()\n      public view virtual override\n      returns (uint256)\n    {\n        // mockable\n        return block.timestamp;\n    }\n\n    // computes how much COMP tokens compound.finance will give us at comptroller.claimComp()\n    // note: have to do it because comptroller.claimComp() is callable by anyone\n    // source: https://github.com/compound-finance/compound-protocol/blob/master/contracts/Comptroller.sol#L1145\n    function compRewardExpected()\n      public view virtual\n      returns (uint256)\n    {\n        (uint224 supplyStateIndex, ) = IComptroller(comptroller).compSupplyState(cToken);\n        uint256 supplyIndex = uint256(supplyStateIndex);\n        uint256 supplierIndex = compSupplierIndexLast;\n\n        uint256 deltaIndex = (supplyIndex).sub(supplierIndex); // a - b\n        (, uint256 cumulativeUnderlyingBalanceNow) = this.currentCumulatives();\n        uint256 timeElapsed = this.currentTime() - harvestedLast; // harvest() has require\n\n        uint256 waUnderlyingTotal = ((cumulativeUnderlyingBalanceNow - cumulativeUnderlyingBalanceHarvestedLast) * 1e18 / timeElapsed);\n        // uint256 supplierTokens = ICTokenErc20(cToken).balanceOf(address(this))\n        uint256 supplierTokens = waUnderlyingTotal / ICToken(cToken).exchangeRateStored();\n        return (supplierTokens).mul(deltaIndex).div(1e36); // a * b / doubleScale => uint\n    }\n\n  // internals\n\n    function _depositProviderInternal(uint256 underlyingAmount_, uint256 takeFees_)\n      internal\n      accountYield\n    {\n        if (0 == cTokenBalance && 0 == compSupplierIndexLast) {\n          // this will be called once only for the first comp deposit after pool deploy\n          _updateCompState();\n        }\n        underlyingFees += takeFees_;\n\n        uint256 cTokensBefore = ICTokenErc20(cToken).balanceOf(address(this));\n        // TODO: optimization, pre-approve provider: gas\n        IERC20(uToken).approve(address(cToken), underlyingAmount_);\n        uint256 err = ICToken(cToken).mint(underlyingAmount_);\n        require(0 == err, \"PPC: _depositProvider mint\");\n        cTokenBalance += ICTokenErc20(cToken).balanceOf(address(this)) - cTokensBefore;\n    }\n\n    function _accountYieldInternal()\n      internal\n    {\n        uint32 blockTimestamp = uint32(this.currentTime() % 2**32);\n        uint32 timeElapsed = blockTimestamp - cumulativeTimestampLast; // overflow is desired\n        // only for the first time in the block\n        if (timeElapsed > 0) {\n            // if there's underlying\n            if (underlyingBalanceLast > 0) {\n              // cumulativeSecondlyYieldLast overflows eventually,\n              // due to the way it is used in the oracle that's ok,\n              // as long as it doesn't overflow twice during the windowSize\n              // see OraclelizedMock.cumulativeOverflowProof() for proof\n              cumulativeSecondlyYieldLast +=\n                  // (this.underlyingBalance() - underlyingBalanceLast) * 1e18 -> overflows only if (this.underlyingBalance() - underlyingBalanceLast) >~ 10^41 ETH, DAI, USDC etc\n                  // (this.underlyingBalance() - underlyingBalanceLast) never underflows\n                  ((this.underlyingBalance() - underlyingBalanceLast) * 1e18) / underlyingBalanceLast;\n            }\n\n            cumulativeUnderlyingBalanceLast += this.underlyingBalance() * timeElapsed;\n\n            cumulativeTimestampLast = blockTimestamp;\n        }\n    }\n\n    // call comptroller.enterMarkets()\n    // needs to be called only once BUT before any interactions with the provider\n    function _enterMarket()\n      internal\n    {\n        address[] memory markets = new address[](1);\n        markets[0] = cToken;\n        uint256[] memory err = IComptroller(comptroller).enterMarkets(markets);\n        require(err[0] == 0, \"PPC: _enterMarket\");\n    }\n\n\n    // creates checkpoint items needed to compute compRewardExpected()\n    // needs to be called right after each claimComp(), and just before the first ever deposit\n    function _updateCompState()\n      internal\n    {\n        (uint224 supplyStateIndex, ) = IComptroller(comptroller).compSupplyState(cToken);\n        compSupplierIndexLast = uint256(supplyStateIndex);\n        (, cumulativeUnderlyingBalanceHarvestedLast) = this.currentCumulatives();\n        harvestedLast = this.currentTime();\n    }\n\n    // /internals\n\n}"
    },
    {
      "filename": "contracts/providers/CompoundProvider.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./../external-interfaces/uniswap/IUniswapV2Router.sol\";\nimport \"./../external-interfaces/compound-finance/ICToken.sol\";\nimport \"./../external-interfaces/compound-finance/IComptroller.sol\";\n\nimport \"./../lib/math/MathUtils.sol\";\n\nimport \"./CompoundController.sol\";\nimport \"./../oracle/IYieldOracle.sol\";\nimport \"./../IProvider.sol\";\n\ncontract CompoundProvider is IProvider {\n    using SafeMath for uint256;\n\n    // underlying token (ie. DAI)\n    address public uToken; // IERC20\n\n    // claim token (ie. cDAI)\n    address public cToken;\n\n    // compound.finance Comptroller\n    address public comptroller; // IComptroller\n\n    // deposit reward token (ie. COMP)\n    address public rewardCToken; // IERC20\n\n    // cToken.balanceOf(this) measuring only deposits by users (excludes dirrect cToken transfers to pool)\n    uint256 public cTokenBalance;\n\n    // --- COMP reward checkpoint\n    // saved comptroller.compSupplyState(cToken) value @ the moment the pool harvested\n    uint256 public compSupplierIndexLast;\n\n    // cumulative balanceOf @ last harvest\n    uint256 public cumulativeUnderlyingBalanceHarvestedLast;\n\n    // when we last harvested\n    uint256 public harvestedLast;\n    // --- /COMP reward checkpoint\n\n    bool public _setup;\n\n    modifier accountYield {\n        _accountYieldInternal();\n        IYieldOracle(IController(this.controller()).oracle()).update();\n\n        _;\n\n        underlyingBalanceLast = this.underlyingBalance();\n    }\n\n    function setup(\n        address smartYield_,\n        address controller_,\n        address cToken_\n    )\n      external\n    {\n        require(\n          false == _setup,\n          \"PPC: already setup\"\n        );\n\n        smartYield = smartYield_;\n        controller = controller_;\n        cToken = cToken_;\n        uToken = ICToken(cToken_).underlying();\n        comptroller = ICToken(cToken_).comptroller();\n        rewardCToken = IComptroller(comptroller).getCompAddress();\n\n        _enterMarket();\n\n        _setup = true;\n    }\n\n  // externals\n\n    // take underlyingAmount_ from from_\n    function _takeUnderlying(address from_, uint256 underlyingAmount_)\n      external override\n      onlySmartYield\n    {\n        require(\n            underlyingAmount_ <= IERC20(uToken).allowance(from_, address(this)),\n            \"PPC: _takeUnderlying allowance\"\n        );\n        require(\n            IERC20(uToken).transferFrom(from_, address(this), underlyingAmount_),\n            \"PPC: _takeUnderlying transferFrom\"\n        );\n    }\n\n    // transfer away underlyingAmount_ to to_\n    function _sendUnderlying(address to_, uint256 underlyingAmount_)\n      external override\n      onlySmartYield\n      returns (bool)\n    {\n        return IERC20(uToken).transfer(to_, underlyingAmount_);\n    }\n\n    // deposit underlyingAmount_ with the liquidity provider adds resulting cTokens to cTokenBalance\n    // on the very first call enters the compound.finance market and saves the checkpoint needed for compRewardExpected\n    function _depositProvider(uint256 underlyingAmount_, uint256 takeFees_)\n      external override\n      onlySmartYield\n    {\n        _depositProviderInternal(underlyingAmount_, takeFees_);\n    }\n\n    // withdraw underlyingAmount_ from the liquidity provider, substract the lost cTokens from cTokenBalance\n    function _withdrawProvider(uint256 underlyingAmount_, uint256 takeFees_)\n      external override\n      onlySmartYield\n      accountYield\n    {\n        underlyingFees += takeFees_;\n\n        uint256 cTokensBefore = ICTokenErc20(cToken).balanceOf(address(this));\n        uint256 err = ICToken(cToken).redeemUnderlying(underlyingAmount_);\n        require(0 == err, \"PPC: _withdrawProvider redeemUnderlying\");\n        cTokenBalance -= cTokensBefore - ICTokenErc20(cToken).balanceOf(address(this));\n    }\n\n    // called by anyone to convert pool's COMP -> underlying and then deposit it. caller gets HARVEST_REWARD of the harvest\n    function harvest()\n      external override\n    {\n        require(\n          harvestedLast < this.currentTime(),\n          \"PPC: harvest later\"\n        );\n\n        // this is 0 unless someone transfers underlying to the contract\n        uint256 underlyingBefore = IERC20(uToken).balanceOf(address(this));\n\n        // COMP gets on the pool when:\n        // 1) pool calls comptroller.claimComp()\n        // 2) anyone calls comptroller.claimComp()\n        // 3) anyone transfers COMP to the pool\n        // we want to yield closest to 1+2 but not 3\n        uint256 rewardExpected = compRewardExpected(); // COMP\n\n        address[] memory holders = new address[](1);\n        holders[0] = address(this);\n        address[] memory markets = new address[](1);\n        markets[0] = cToken;\n\n        IComptroller(comptroller).claimComp(holders, markets, false, true);\n\n        _updateCompState();\n\n        uint256 rewardGot = IERC20(rewardCToken).balanceOf(address(this)); // COMP\n\n        if (rewardGot > 0) {\n            address uniswap = CompoundController(controller).uniswap();\n\n            // should be like:\n            // address[] memory path = new address[](3);\n            // path[0] = address(rewardCToken);\n            // path[1] = address(wethToken);\n            // path[2] = address(uToken);\n            address[] memory path = CompoundController(controller).getUniswapPath();\n\n            // TODO: optimize pre-approve uniswap, gas\n            IERC20(rewardCToken).approve(address(uniswap), rewardGot);\n\n            IUniswapV2Router(uniswap).swapExactTokensForTokens(\n                rewardGot,\n                uint256(0),\n                path,\n                address(this),\n                this.currentTime() + 1800\n            );\n        }\n\n        uint256 underlyingGot = IERC20(uToken).balanceOf(address(this));\n\n        if (underlyingGot == 0) {\n          // got no goodies :(\n          return;\n        }\n\n        uint256 extra;\n\n        if (underlyingBefore > 0) {\n          // someone sent us a present as underlying -> add it to the fees\n          extra = underlyingBefore;\n          underlyingGot -= extra;\n        }\n\n        if (rewardGot > rewardExpected) {\n          // moar present as COMP reward -> add it to the fees\n          // throw event\n          uint256 rExtra = MathUtils.fractionOf(underlyingGot, (rewardGot - rewardExpected) * 1e18 / rewardGot);\n          extra += rExtra;\n          underlyingGot -= rExtra;\n        }\n\n        uint256 toCaller = MathUtils.fractionOf(underlyingGot, CompoundController(controller).HARVEST_REWARD());\n\n        // deposit pool reward to compound - harvest reward + any goodies we received\n        // any extra goodies go to fees\n        _depositProviderInternal(underlyingGot - toCaller + extra, extra);\n\n        // pay this man\n        IERC20(uToken).transfer(msg.sender, IERC20(uToken).balanceOf(address(this)));\n    }\n\n    function transferFees()\n      external\n      override\n      accountYield\n    {\n      // cleanup any cTokens dust or cTokens that may have been dumped on the pool\n      if (ICTokenErc20(cToken).balanceOf(address(this)) > cTokenBalance) {\n        underlyingFees += ICToken(cToken).exchangeRateStored() * (ICTokenErc20(cToken).balanceOf(address(this)) - cTokenBalance) / 1e18;\n      }\n      uint256 ctokensToPay = underlyingFees * 1e18 / ICToken(cToken).exchangeRateStored();\n      uint256 err = ICToken(cToken).redeem(\n          MathUtils.min(ctokensToPay, ICTokenErc20(cToken).balanceOf(address(this)))\n      );\n      require(0 == err, \"PPC: transferFees redeem\");\n      underlyingFees = 0;\n      cTokenBalance = ICTokenErc20(cToken).balanceOf(address(this));\n      IERC20(uToken).transfer(IController(controller).feesOwner(), IERC20(uToken).balanceOf(address(this)));\n    }\n\n    // returns cumulatives and accumulates/updates internal state\n    // oracle should call this when updating\n    function cumulatives()\n      external override\n    returns(uint256 cumulativeSecondlyYield, uint256 cumulativeUnderlyingBalance) {\n        _accountYieldInternal();\n        underlyingBalanceLast = this.underlyingBalance();\n        return (cumulativeSecondlyYieldLast, cumulativeUnderlyingBalanceLast);\n    }\n\n    // returns cumulated yield per 1 underlying coin (ie 1 DAI, 1 ETH) times 1e18\n    // per https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/libraries/UniswapV2OracleLibrary.sol#L16\n    function currentCumulatives()\n      external view override\n    returns (uint256 cumulativeSecondlyYield, uint256 cumulativeUnderlyingBalance)\n    {\n        uint32 blockTimestamp = uint32(this.currentTime() % 2**32);\n        cumulativeSecondlyYield = cumulativeSecondlyYieldLast;\n        cumulativeUnderlyingBalance = cumulativeUnderlyingBalanceLast;\n\n        uint32 timeElapsed = blockTimestamp - cumulativeTimestampLast; // overflow is desired\n        if (timeElapsed > 0) {\n            if (underlyingBalanceLast > 0) {\n              // cumulativeSecondlyYield overflows eventually,\n              // due to the way it is used in the oracle that's ok,\n              // as long as it doesn't overflow twice during the windowSize\n              // see OraclelizedMock.cumulativeOverflowProof() for proof\n              cumulativeSecondlyYield +=\n                  // (this.underlyingBalance() - underlyingBalanceLast) * 1e18 -> overflows only if (this.underlyingBalance() - underlyingBalanceLast) >~ 10^41 ETH, DAI, USDC etc\n                  // (this.underlyingBalance() - underlyingBalanceLast) never underflows\n                  ((this.underlyingBalance() - underlyingBalanceLast) * 1e18) / underlyingBalanceLast;\n            }\n            cumulativeUnderlyingBalance += this.underlyingBalance() * timeElapsed;\n        }\n        return (cumulativeSecondlyYield, cumulativeUnderlyingBalance);\n    }\n\n    // current total underlying balance, as measured by pool\n    function underlyingBalance()\n      external view virtual override\n    returns (uint256)\n    {\n        // https://compound.finance/docs#protocol-math\n        return\n            cTokenBalance * ICToken(cToken).exchangeRateStored() / 1e18;\n    }\n\n  // /externals\n\n    function currentTime()\n      public view virtual override\n      returns (uint256)\n    {\n        // mockable\n        return block.timestamp;\n    }\n\n    // computes how much COMP tokens compound.finance will give us at comptroller.claimComp()\n    // note: have to do it because comptroller.claimComp() is callable by anyone\n    // source: https://github.com/compound-finance/compound-protocol/blob/master/contracts/Comptroller.sol#L1145\n    function compRewardExpected()\n      public view virtual\n      returns (uint256)\n    {\n        (uint224 supplyStateIndex, ) = IComptroller(comptroller).compSupplyState(cToken);\n        uint256 supplyIndex = uint256(supplyStateIndex);\n        uint256 supplierIndex = compSupplierIndexLast;\n\n        uint256 deltaIndex = (supplyIndex).sub(supplierIndex); // a - b\n        (, uint256 cumulativeUnderlyingBalanceNow) = this.currentCumulatives();\n        uint256 timeElapsed = this.currentTime() - harvestedLast; // harvest() has require\n\n        uint256 waUnderlyingTotal = ((cumulativeUnderlyingBalanceNow - cumulativeUnderlyingBalanceHarvestedLast) * 1e18 / timeElapsed);\n        // uint256 supplierTokens = ICTokenErc20(cToken).balanceOf(address(this))\n        uint256 supplierTokens = waUnderlyingTotal / ICToken(cToken).exchangeRateStored();\n        return (supplierTokens).mul(deltaIndex).div(1e36); // a * b / doubleScale => uint\n    }\n\n  // internals\n\n    function _depositProviderInternal(uint256 underlyingAmount_, uint256 takeFees_)\n      internal\n      accountYield\n    {\n        if (0 == cTokenBalance && 0 == compSupplierIndexLast) {\n          // this will be called once only for the first comp deposit after pool deploy\n          _updateCompState();\n        }\n        underlyingFees += takeFees_;\n\n        uint256 cTokensBefore = ICTokenErc20(cToken).balanceOf(address(this));\n        // TODO: optimization, pre-approve provider: gas\n        IERC20(uToken).approve(address(cToken), underlyingAmount_);\n        uint256 err = ICToken(cToken).mint(underlyingAmount_);\n        require(0 == err, \"PPC: _depositProvider mint\");\n        cTokenBalance += ICTokenErc20(cToken).balanceOf(address(this)) - cTokensBefore;\n    }\n\n    function _accountYieldInternal()\n      internal\n    {\n        uint32 blockTimestamp = uint32(this.currentTime() % 2**32);\n        uint32 timeElapsed = blockTimestamp - cumulativeTimestampLast; // overflow is desired\n        // only for the first time in the block\n        if (timeElapsed > 0) {\n            // if there's underlying\n            if (underlyingBalanceLast > 0) {\n              // cumulativeSecondlyYieldLast overflows eventually,\n              // due to the way it is used in the oracle that's ok,\n              // as long as it doesn't overflow twice during the windowSize\n              // see OraclelizedMock.cumulativeOverflowProof() for proof\n              cumulativeSecondlyYieldLast +=\n                  // (this.underlyingBalance() - underlyingBalanceLast) * 1e18 -> overflows only if (this.underlyingBalance() - underlyingBalanceLast) >~ 10^41 ETH, DAI, USDC etc\n                  // (this.underlyingBalance() - underlyingBalanceLast) never underflows\n                  ((this.underlyingBalance() - underlyingBalanceLast) * 1e18) / underlyingBalanceLast;\n            }\n\n            cumulativeUnderlyingBalanceLast += this.underlyingBalance() * timeElapsed;\n\n            cumulativeTimestampLast = blockTimestamp;\n        }\n    }\n\n    // call comptroller.enterMarkets()\n    // needs to be called only once BUT before any interactions with the provider\n    function _enterMarket()\n      internal\n    {\n        address[] memory markets = new address[](1);\n        markets[0] = cToken;\n        uint256[] memory err = IComptroller(comptroller).enterMarkets(markets);\n        require(err[0] == 0, \"PPC: _enterMarket\");\n    }\n\n\n    // creates checkpoint items needed to compute compRewardExpected()\n    // needs to be called right after each claimComp(), and just before the first ever deposit\n    function _updateCompState()\n      internal\n    {\n        (uint224 supplyStateIndex, ) = IComptroller(comptroller).compSupplyState(cToken);\n        compSupplierIndexLast = uint256(supplyStateIndex);\n        (, cumulativeUnderlyingBalanceHarvestedLast) = this.currentCumulatives();\n        harvestedLast = this.currentTime();\n    }\n\n    // /internals\n\n}"
    }
  ]
}