{
  "Title": "[G-10] Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` statement",
  "Content": "\n1.  File: contracts/IndexLogic.sol (line [76](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/IndexLogic.sol#L76))\n\n```solidity\n            require(lastAssetBalanceInBase > 0, \"Index: INSUFFICIENT_AMOUNT\");\n```\n\n2.  File: contracts/IndexLogic.sol (line [98](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/IndexLogic.sol#L98))\n\n```solidity\n        require(value > 0, \"Index: INSUFFICIENT_AMOUNT\");\n```\n\n3.  File: contracts/libraries/FullMath.sol (line [35](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/libraries/FullMath.sol#L35))\n\n```solidity\n                require(denominator > 0);\n```\n\n4.  File: contracts/libraries/IndexLibrary.sol (line [29](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/libraries/IndexLibrary.sol#L29))\n\n```solidity\n        require(_assetPerBaseInUQ > 0, \"IndexLibrary: ORACLE\");\n```\n\n5.  File: contracts/libraries/NAV.sol (line [49](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/libraries/NAV.sol#L49))\n\n```solidity\n        require(shares > 0, \"NAV: INSUFFICIENT_AMOUNT\");\n```\n\n6.  File: contracts/libraries/NAV.sol (line [59](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/libraries/NAV.sol#L59))\n\n```solidity\n        require(amount > 0, \"NAV: INSUFFICIENT_SHARES_BURNED\");\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-04-phuture-finance-contest",
  "Code": [
    {
      "filename": "contracts/IndexLogic.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.8.7;\n\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\nimport \"./libraries/BP.sol\";\nimport \"./libraries/IndexLibrary.sol\";\n\nimport \"./interfaces/IvToken.sol\";\nimport \"./interfaces/IOrderer.sol\";\nimport \"./interfaces/IIndexLogic.sol\";\nimport \"./interfaces/IvTokenFactory.sol\";\nimport \"./interfaces/IPhuturePriceOracle.sol\";\n\nimport \"./PhutureIndex.sol\";\n\n/// @title Index logic\n/// @notice Contains common logic for index minting and burning\ncontract IndexLogic is PhutureIndex, IIndexLogic {\n    using FullMath for uint;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice Asset role\n    bytes32 internal constant ASSET_ROLE = keccak256(\"ASSET_ROLE\");\n    /// @notice Role granted for asset which should be skipped during burning\n    bytes32 internal constant SKIPPED_ASSET_ROLE = keccak256(\"SKIPPED_ASSET_ROLE\");\n\n    /// @notice Mints index to `_recipient` address\n    /// @param _recipient Recipient address\n    function mint(address _recipient) external override {\n        address feePool = IIndexRegistry(registry).feePool();\n        _chargeAUMFee(feePool);\n\n        IPhuturePriceOracle oracle = IPhuturePriceOracle(IIndexRegistry(registry).priceOracle());\n\n        uint lastAssetBalanceInBase;\n        uint minAmountInBase = type(uint).max;\n        for (uint i; i < assets.length(); ++i) {\n            require(IAccessControl(registry).hasRole(ASSET_ROLE, assets.at(i)), \"Index: INVALID_ASSET\");\n            if (weightOf[assets.at(i)] == 0) {\n                continue;\n            }\n            uint assetPerBaseInUQ = oracle.refreshedAssetPerBaseInUQ(assets.at(i));\n            // Q_b * w_i * p_i = Q_i\n            // Q_b = Q_i / (w_i * p_i)\n            IvToken vToken = IvToken(IvTokenFactory(vTokenFactory).createOrReturnVTokenOf(assets.at(i)));\n            uint amountInAsset = IERC20(assets.at(i)).balanceOf(address(vToken)) - vToken.lastBalance();\n            uint weightedPrice = assetPerBaseInUQ * weightOf[assets.at(i)];\n            uint _minAmountInBase = amountInAsset.mulDiv(FixedPoint112.Q112 * IndexLibrary.MAX_WEIGHT, weightedPrice);\n            if (_minAmountInBase < minAmountInBase) {\n                minAmountInBase = _minAmountInBase;\n            }\n            uint lastBalanceInAsset = vToken.lastAssetBalanceOf(address(this));\n            vToken.mint();\n            uint balanceInBase = lastBalanceInAsset.mulDiv(FixedPoint112.Q112, assetPerBaseInUQ);\n            lastAssetBalanceInBase += balanceInBase;\n        }\n\n        for (uint i; i < inactiveAssets.length(); ++i) {\n            if (!IAccessControl(registry).hasRole(SKIPPED_ASSET_ROLE, inactiveAssets.at(i))) {\n                uint lastBalanceInAsset = IvToken(\n                    IvTokenFactory(vTokenFactory).createOrReturnVTokenOf(inactiveAssets.at(i))\n                ).lastAssetBalanceOf(address(this));\n                lastAssetBalanceInBase += lastBalanceInAsset.mulDiv(\n                    FixedPoint112.Q112,\n                    oracle.refreshedAssetPerBaseInUQ(inactiveAssets.at(i))\n                );\n            }\n        }\n\n        assert(minAmountInBase != type(uint).max);\n\n        uint value;\n        if (totalSupply() != 0) {\n            require(lastAssetBalanceInBase > 0, \"Index: INSUFFICIENT_AMOUNT\");\n            value =\n                (oracle.convertToIndex(minAmountInBase, decimals()) * totalSupply()) /\n                oracle.convertToIndex(lastAssetBalanceInBase, decimals());\n        } else {\n            value = oracle.convertToIndex(minAmountInBase, decimals()) - IndexLibrary.INITIAL_QUANTITY;\n            _mint(address(0xdead), IndexLibrary.INITIAL_QUANTITY);\n        }\n\n        uint fee = (value * IFeePool(feePool).mintingFeeInBPOf(address(this))) / BP.DECIMAL_FACTOR;\n        if (fee > 0) {\n            _mint(feePool, fee);\n            value -= fee;\n        }\n\n        _mint(_recipient, value);\n    }\n\n    /// @notice Burns index and transfers assets to `_recipient` address\n    /// @param _recipient Recipient address\n    function burn(address _recipient) external override {\n        uint value = balanceOf(address(this));\n        require(value > 0, \"Index: INSUFFICIENT_AMOUNT\");\n        uint length = assets.length();\n\n        bool containsBlacklistedAssets;\n        for (uint i; i < length; ++i) {\n            if (!IAccessControl(registry).hasRole(ASSET_ROLE, assets.at(i))) {\n                containsBlacklistedAssets = true;\n                break;\n            }\n        }\n\n        if (!containsBlacklistedAssets) {\n            address feePool = IIndexRegistry(registry).feePool();\n\n            uint fee = (value * IFeePool(feePool).burningFeeInBPOf(address(this))) / BP.DECIMAL_FACTOR;\n\n            if (fee > 0) {\n                // AUM charged in _transfer method\n                _transfer(address(this), feePool, fee);\n                value -= fee;\n            } else {\n                _chargeAUMFee(feePool);\n            }\n        }\n\n        address orderer = IIndexRegistry(registry).orderer();\n        uint lastOrderId = IOrderer(orderer).lastOrderIdOf(address(this));\n        for (uint i; i < length + inactiveAssets.length(); ++i) {\n            address asset = i < length ? assets.at(i) : inactiveAssets.at(i - length);\n            if (containsBlacklistedAssets && IAccessControl(registry).hasRole(SKIPPED_ASSET_ROLE, asset)) {\n                continue;\n            }\n\n            IvToken vToken = IvToken(IvTokenFactory(vTokenFactory).vTokenOf(asset));\n            uint indexAssetBalance = vToken.balanceOf(address(this));\n            uint accountBalance = (value * indexAssetBalance) / totalSupply();\n            if (accountBalance == 0) {\n                continue;\n            }\n\n            // calculate index value in vault to be burned\n            vToken.transfer(address(vToken), accountBalance);\n            vToken.burn(_recipient);\n            if (lastOrderId > 0) {\n                IOrderer(orderer).reduceOrderAsset(asset, totalSupply() - value, totalSupply());\n            }\n        }\n\n        _burn(address(this), value);\n    }\n}"
    },
    {
      "filename": "contracts/IndexLogic.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.8.7;\n\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\nimport \"./libraries/BP.sol\";\nimport \"./libraries/IndexLibrary.sol\";\n\nimport \"./interfaces/IvToken.sol\";\nimport \"./interfaces/IOrderer.sol\";\nimport \"./interfaces/IIndexLogic.sol\";\nimport \"./interfaces/IvTokenFactory.sol\";\nimport \"./interfaces/IPhuturePriceOracle.sol\";\n\nimport \"./PhutureIndex.sol\";\n\n/// @title Index logic\n/// @notice Contains common logic for index minting and burning\ncontract IndexLogic is PhutureIndex, IIndexLogic {\n    using FullMath for uint;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice Asset role\n    bytes32 internal constant ASSET_ROLE = keccak256(\"ASSET_ROLE\");\n    /// @notice Role granted for asset which should be skipped during burning\n    bytes32 internal constant SKIPPED_ASSET_ROLE = keccak256(\"SKIPPED_ASSET_ROLE\");\n\n    /// @notice Mints index to `_recipient` address\n    /// @param _recipient Recipient address\n    function mint(address _recipient) external override {\n        address feePool = IIndexRegistry(registry).feePool();\n        _chargeAUMFee(feePool);\n\n        IPhuturePriceOracle oracle = IPhuturePriceOracle(IIndexRegistry(registry).priceOracle());\n\n        uint lastAssetBalanceInBase;\n        uint minAmountInBase = type(uint).max;\n        for (uint i; i < assets.length(); ++i) {\n            require(IAccessControl(registry).hasRole(ASSET_ROLE, assets.at(i)), \"Index: INVALID_ASSET\");\n            if (weightOf[assets.at(i)] == 0) {\n                continue;\n            }\n            uint assetPerBaseInUQ = oracle.refreshedAssetPerBaseInUQ(assets.at(i));\n            // Q_b * w_i * p_i = Q_i\n            // Q_b = Q_i / (w_i * p_i)\n            IvToken vToken = IvToken(IvTokenFactory(vTokenFactory).createOrReturnVTokenOf(assets.at(i)));\n            uint amountInAsset = IERC20(assets.at(i)).balanceOf(address(vToken)) - vToken.lastBalance();\n            uint weightedPrice = assetPerBaseInUQ * weightOf[assets.at(i)];\n            uint _minAmountInBase = amountInAsset.mulDiv(FixedPoint112.Q112 * IndexLibrary.MAX_WEIGHT, weightedPrice);\n            if (_minAmountInBase < minAmountInBase) {\n                minAmountInBase = _minAmountInBase;\n            }\n            uint lastBalanceInAsset = vToken.lastAssetBalanceOf(address(this));\n            vToken.mint();\n            uint balanceInBase = lastBalanceInAsset.mulDiv(FixedPoint112.Q112, assetPerBaseInUQ);\n            lastAssetBalanceInBase += balanceInBase;\n        }\n\n        for (uint i; i < inactiveAssets.length(); ++i) {\n            if (!IAccessControl(registry).hasRole(SKIPPED_ASSET_ROLE, inactiveAssets.at(i))) {\n                uint lastBalanceInAsset = IvToken(\n                    IvTokenFactory(vTokenFactory).createOrReturnVTokenOf(inactiveAssets.at(i))\n                ).lastAssetBalanceOf(address(this));\n                lastAssetBalanceInBase += lastBalanceInAsset.mulDiv(\n                    FixedPoint112.Q112,\n                    oracle.refreshedAssetPerBaseInUQ(inactiveAssets.at(i))\n                );\n            }\n        }\n\n        assert(minAmountInBase != type(uint).max);\n\n        uint value;\n        if (totalSupply() != 0) {\n            require(lastAssetBalanceInBase > 0, \"Index: INSUFFICIENT_AMOUNT\");\n            value =\n                (oracle.convertToIndex(minAmountInBase, decimals()) * totalSupply()) /\n                oracle.convertToIndex(lastAssetBalanceInBase, decimals());\n        } else {\n            value = oracle.convertToIndex(minAmountInBase, decimals()) - IndexLibrary.INITIAL_QUANTITY;\n            _mint(address(0xdead), IndexLibrary.INITIAL_QUANTITY);\n        }\n\n        uint fee = (value * IFeePool(feePool).mintingFeeInBPOf(address(this))) / BP.DECIMAL_FACTOR;\n        if (fee > 0) {\n            _mint(feePool, fee);\n            value -= fee;\n        }\n\n        _mint(_recipient, value);\n    }\n\n    /// @notice Burns index and transfers assets to `_recipient` address\n    /// @param _recipient Recipient address\n    function burn(address _recipient) external override {\n        uint value = balanceOf(address(this));\n        require(value > 0, \"Index: INSUFFICIENT_AMOUNT\");\n        uint length = assets.length();\n\n        bool containsBlacklistedAssets;\n        for (uint i; i < length; ++i) {\n            if (!IAccessControl(registry).hasRole(ASSET_ROLE, assets.at(i))) {\n                containsBlacklistedAssets = true;\n                break;\n            }\n        }\n\n        if (!containsBlacklistedAssets) {\n            address feePool = IIndexRegistry(registry).feePool();\n\n            uint fee = (value * IFeePool(feePool).burningFeeInBPOf(address(this))) / BP.DECIMAL_FACTOR;\n\n            if (fee > 0) {\n                // AUM charged in _transfer method\n                _transfer(address(this), feePool, fee);\n                value -= fee;\n            } else {\n                _chargeAUMFee(feePool);\n            }\n        }\n\n        address orderer = IIndexRegistry(registry).orderer();\n        uint lastOrderId = IOrderer(orderer).lastOrderIdOf(address(this));\n        for (uint i; i < length + inactiveAssets.length(); ++i) {\n            address asset = i < length ? assets.at(i) : inactiveAssets.at(i - length);\n            if (containsBlacklistedAssets && IAccessControl(registry).hasRole(SKIPPED_ASSET_ROLE, asset)) {\n                continue;\n            }\n\n            IvToken vToken = IvToken(IvTokenFactory(vTokenFactory).vTokenOf(asset));\n            uint indexAssetBalance = vToken.balanceOf(address(this));\n            uint accountBalance = (value * indexAssetBalance) / totalSupply();\n            if (accountBalance == 0) {\n                continue;\n            }\n\n            // calculate index value in vault to be burned\n            vToken.transfer(address(vToken), accountBalance);\n            vToken.burn(_recipient);\n            if (lastOrderId > 0) {\n                IOrderer(orderer).reduceOrderAsset(asset, totalSupply() - value, totalSupply());\n            }\n        }\n\n        _burn(address(this), value);\n    }\n}"
    },
    {
      "filename": "contracts/libraries/FullMath.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = a * b\n            // Compute the product mod 2**256 and mod 2**256 - 1\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2**256 + prod0\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(a, b, not(0))\n                prod0 := mul(a, b)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division\n            if (prod1 == 0) {\n                require(denominator > 0);\n                assembly {\n                    result := div(prod0, denominator)\n                }\n                return result;\n            }\n\n            // Make sure the result is less than 2**256.\n            // Also prevents denominator == 0\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0]\n            // Compute remainder using mulmod\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(a, b, denominator)\n            }\n            // Subtract 256 bit number from 512 bit number\n            assembly {\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator\n            // Compute largest power of two divisor of denominator.\n            // Always >= 1.\n            uint256 twos = (~denominator + 1) & denominator;\n            // Divide denominator by power of two\n            assembly {\n                denominator := div(denominator, twos)\n            }\n\n            // Divide [prod1 prod0] by the factors of two\n            assembly {\n                prod0 := div(prod0, twos)\n            }\n            // Shift in bits from prod1 into prod0. For this we need\n            // to flip `twos` such that it is 2**256 / twos.\n            // If twos is zero, then it becomes one\n            assembly {\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2**256\n            // Now that denominator is an odd number, it has an inverse\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n            // Compute the inverse by starting with a seed that is correct\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\n            uint256 inv = (3 * denominator) ^ 2;\n            // Now use Newton-Raphson iteration to improve the precision.\n            // Thanks to Hensel's lifting lemma, this also works in modular\n            // arithmetic, doubling the correct bits in each step.\n            inv *= 2 - denominator * inv; // inverse mod 2**8\n            inv *= 2 - denominator * inv; // inverse mod 2**16\n            inv *= 2 - denominator * inv; // inverse mod 2**32\n            inv *= 2 - denominator * inv; // inverse mod 2**64\n            inv *= 2 - denominator * inv; // inverse mod 2**128\n            inv *= 2 - denominator * inv; // inverse mod 2**256\n\n            // Because the division is now exact we can divide by multiplying\n            // with the modular inverse of denominator. This will give us the\n            // correct result modulo 2**256. Since the precoditions guarantee\n            // that the outcome is less than 2**256, this is the final result.\n            // We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inv;\n            return result;\n        }\n    }\n\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            result = mulDiv(a, b, denominator);\n            if (mulmod(a, b, denominator) > 0) {\n                require(result < type(uint256).max);\n                result++;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/libraries/IndexLibrary.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.8.7;\n\nimport \"./FullMath.sol\";\nimport \"./FixedPoint112.sol\";\n\n/// @title Index library\n/// @notice Provides various utilities for indexes\nlibrary IndexLibrary {\n    using FullMath for uint;\n\n    /// @notice Initial index quantity to mint\n    uint constant INITIAL_QUANTITY = 10000;\n\n    /// @notice Total assets weight within an index\n    uint8 constant MAX_WEIGHT = type(uint8).max;\n\n    /// @notice Returns amount of asset equivalent to the given parameters\n    /// @param _assetPerBaseInUQ Asset per base price in UQ\n    /// @param _weight Weight of the given asset\n    /// @param _amountInBase Total assets amount in base\n    /// @return Amount of asset\n    function amountInAsset(\n        uint _assetPerBaseInUQ,\n        uint8 _weight,\n        uint _amountInBase\n    ) internal pure returns (uint) {\n        require(_assetPerBaseInUQ > 0, \"IndexLibrary: ORACLE\");\n\n        return ((_amountInBase * _weight) / MAX_WEIGHT).mulDiv(_assetPerBaseInUQ, FixedPoint112.Q112);\n    }\n}"
    },
    {
      "filename": "contracts/libraries/NAV.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.8.7;\n\n/// @title NAV library\n/// @notice Library for transfer, mint, burn and distribute vToken shares\n/// @dev Used in conjunction with vToken\nlibrary NAV {\n    /// @notice Initial shares quantity\n    uint internal constant INITIAL_QUANTITY = 10000;\n\n    struct Data {\n        uint lastBalance;\n        uint totalSupply;\n        mapping(address => uint) balanceOf;\n    }\n\n    /// @notice Transfer `_amount` of shares between given addresses\n    /// @param _from Account to send shares from\n    /// @param _to Account to send shares to\n    /// @param _amount Amount of shares to send\n    function transfer(\n        Data storage self,\n        address _from,\n        address _to,\n        uint _amount\n    ) internal {\n        self.balanceOf[_from] -= _amount;\n        self.balanceOf[_to] += _amount;\n    }\n\n    /// @notice Mints shares to the `_recipient` account\n    /// @param self Data structure reference\n    /// @param _balance New shares maximum limit\n    /// @param _recipient Recipient that will receive minted shares\n    function mint(\n        Data storage self,\n        uint _balance,\n        address _recipient\n    ) internal returns (uint shares) {\n        uint amount = _balance - self.lastBalance;\n        uint _totalSupply = self.totalSupply;\n        if (_totalSupply != 0) {\n            shares = (amount * _totalSupply) / self.lastBalance;\n        } else {\n            shares = amount - INITIAL_QUANTITY;\n            _mint(self, address(0), INITIAL_QUANTITY);\n        }\n        require(shares > 0, \"NAV: INSUFFICIENT_AMOUNT\");\n        _mint(self, _recipient, shares);\n    }\n\n    /// @notice Burns shares from the `_recipient` account\n    /// @param self Data structure reference\n    /// @param _balance Shares balance\n    function burn(Data storage self, uint _balance) internal returns (uint amount) {\n        uint value = self.balanceOf[address(this)];\n        amount = (value * _balance) / self.totalSupply;\n        require(amount > 0, \"NAV: INSUFFICIENT_SHARES_BURNED\");\n        _burn(self, address(this), value);\n    }\n\n    /// @notice Synchronizes token balances\n    /// @param self Data structure reference\n    /// @param _newBalance Total asset amount\n    function sync(Data storage self, uint _newBalance) internal {\n        if (self.lastBalance != _newBalance) {\n            self.lastBalance = _newBalance;\n        }\n    }\n\n    /// @notice Returns amount of tokens corresponding to the given `_shares` amount\n    /// @param self Data structure reference\n    /// @param _shares Amount of shares\n    /// @param _balance Shares balance\n    /// @return Amount of tokens corresponding to given shares\n    function assetBalanceForShares(\n        Data storage self,\n        uint _shares,\n        uint _balance\n    ) internal view returns (uint) {\n        uint _totalSupply = self.totalSupply;\n        if (_totalSupply != 0) {\n            return (_shares * _balance) / _totalSupply;\n        }\n\n        return 0;\n    }\n\n    /// @notice Returns amount of shares that will be minted for the given tokens amount\n    /// @param self Data structure reference\n    /// @param _amount Tokens amount\n    /// @return Amount of mintable shares\n    function mintableShares(Data storage self, uint _amount) internal view returns (uint) {\n        uint _totalSupply = self.totalSupply;\n        if (_totalSupply != 0) {\n            return (_amount * _totalSupply) / self.lastBalance;\n        }\n\n        return _amount - INITIAL_QUANTITY;\n    }\n\n    /// @notice Mints shares for the given account\n    /// @param self Data structure reference\n    /// @param _account Account to mint shares for\n    /// @param _amount Amount shares to mint\n    function _mint(\n        Data storage self,\n        address _account,\n        uint _amount\n    ) private {\n        self.balanceOf[_account] += _amount;\n        self.totalSupply += _amount;\n    }\n\n    /// @notice Burns shares of the given account\n    /// @param self Data structure reference\n    /// @param _account Account to burn shares of\n    /// @param _amount Amount shares to burn\n    function _burn(\n        Data storage self,\n        address _account,\n        uint _amount\n    ) private {\n        self.balanceOf[_account] -= _amount;\n        self.totalSupply -= _amount;\n    }\n}"
    },
    {
      "filename": "contracts/libraries/NAV.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.8.7;\n\n/// @title NAV library\n/// @notice Library for transfer, mint, burn and distribute vToken shares\n/// @dev Used in conjunction with vToken\nlibrary NAV {\n    /// @notice Initial shares quantity\n    uint internal constant INITIAL_QUANTITY = 10000;\n\n    struct Data {\n        uint lastBalance;\n        uint totalSupply;\n        mapping(address => uint) balanceOf;\n    }\n\n    /// @notice Transfer `_amount` of shares between given addresses\n    /// @param _from Account to send shares from\n    /// @param _to Account to send shares to\n    /// @param _amount Amount of shares to send\n    function transfer(\n        Data storage self,\n        address _from,\n        address _to,\n        uint _amount\n    ) internal {\n        self.balanceOf[_from] -= _amount;\n        self.balanceOf[_to] += _amount;\n    }\n\n    /// @notice Mints shares to the `_recipient` account\n    /// @param self Data structure reference\n    /// @param _balance New shares maximum limit\n    /// @param _recipient Recipient that will receive minted shares\n    function mint(\n        Data storage self,\n        uint _balance,\n        address _recipient\n    ) internal returns (uint shares) {\n        uint amount = _balance - self.lastBalance;\n        uint _totalSupply = self.totalSupply;\n        if (_totalSupply != 0) {\n            shares = (amount * _totalSupply) / self.lastBalance;\n        } else {\n            shares = amount - INITIAL_QUANTITY;\n            _mint(self, address(0), INITIAL_QUANTITY);\n        }\n        require(shares > 0, \"NAV: INSUFFICIENT_AMOUNT\");\n        _mint(self, _recipient, shares);\n    }\n\n    /// @notice Burns shares from the `_recipient` account\n    /// @param self Data structure reference\n    /// @param _balance Shares balance\n    function burn(Data storage self, uint _balance) internal returns (uint amount) {\n        uint value = self.balanceOf[address(this)];\n        amount = (value * _balance) / self.totalSupply;\n        require(amount > 0, \"NAV: INSUFFICIENT_SHARES_BURNED\");\n        _burn(self, address(this), value);\n    }\n\n    /// @notice Synchronizes token balances\n    /// @param self Data structure reference\n    /// @param _newBalance Total asset amount\n    function sync(Data storage self, uint _newBalance) internal {\n        if (self.lastBalance != _newBalance) {\n            self.lastBalance = _newBalance;\n        }\n    }\n\n    /// @notice Returns amount of tokens corresponding to the given `_shares` amount\n    /// @param self Data structure reference\n    /// @param _shares Amount of shares\n    /// @param _balance Shares balance\n    /// @return Amount of tokens corresponding to given shares\n    function assetBalanceForShares(\n        Data storage self,\n        uint _shares,\n        uint _balance\n    ) internal view returns (uint) {\n        uint _totalSupply = self.totalSupply;\n        if (_totalSupply != 0) {\n            return (_shares * _balance) / _totalSupply;\n        }\n\n        return 0;\n    }\n\n    /// @notice Returns amount of shares that will be minted for the given tokens amount\n    /// @param self Data structure reference\n    /// @param _amount Tokens amount\n    /// @return Amount of mintable shares\n    function mintableShares(Data storage self, uint _amount) internal view returns (uint) {\n        uint _totalSupply = self.totalSupply;\n        if (_totalSupply != 0) {\n            return (_amount * _totalSupply) / self.lastBalance;\n        }\n\n        return _amount - INITIAL_QUANTITY;\n    }\n\n    /// @notice Mints shares for the given account\n    /// @param self Data structure reference\n    /// @param _account Account to mint shares for\n    /// @param _amount Amount shares to mint\n    function _mint(\n        Data storage self,\n        address _account,\n        uint _amount\n    ) private {\n        self.balanceOf[_account] += _amount;\n        self.totalSupply += _amount;\n    }\n\n    /// @notice Burns shares of the given account\n    /// @param self Data structure reference\n    /// @param _account Account to burn shares of\n    /// @param _amount Amount shares to burn\n    function _burn(\n        Data storage self,\n        address _account,\n        uint _amount\n    ) private {\n        self.balanceOf[_account] -= _amount;\n        self.totalSupply -= _amount;\n    }\n}"
    }
  ]
}