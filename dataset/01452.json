{
  "Title": "Potential Irreversibility in venusVAIVaultRate Adjustments",
  "Content": "If the `venusVAIVaultRate` is mistakenly changed to a very high number in [`_setVenusVAIVaultRate()`](https://github.com/VenusProtocol/venus-protocol/blob/94bc2e414e33ebf6c05d35c1605dcbd48fa932f5/contracts/Comptroller/Diamond/facets/SetterFacet.sol#L388), `releaseToVault()` will [overflow](https://github.com/VenusProtocol/venus-protocol/blob/94bc2e414e33ebf6c05d35c1605dcbd48fa932f5/contracts/Comptroller/Diamond/facets/FacetBase.sol#L94).\n\n\nIf there is an attempt to correct the `venusVAIVaultRate`, [`releaseToVault`](https://github.com/VenusProtocol/venus-protocol/blob/94bc2e414e33ebf6c05d35c1605dcbd48fa932f5/contracts/Comptroller/Diamond/facets/SetterFacet.sol#L391) will revert due to overflow, impeding any further change to the `venusVAIVaultRate`.\n\n\nConsider adding input checks to prevent overflows.\n\n\n***Update:** Acknowledged, not resolved. The Venus team stated:*\n\n\n\n> *`venusVAIVaultRate` is set by the governance so the chances of setting it wrong are negligible. For now, we will just acknowledge the issue and no actions are needed from us.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Comptroller/Diamond/facets/SetterFacet.sol",
      "content": "pragma solidity 0.5.16;\n\nimport \"../../../Oracle/PriceOracle.sol\";\nimport \"../../../Tokens/VTokens/VToken.sol\";\nimport \"../../../Utils/ErrorReporter.sol\";\nimport \"./FacetBase.sol\";\n\n/**\n * @dev This facet contains all the setters for the states\n */\ncontract SetterFacet is ComptrollerErrorReporter, ExponentialNoError, FacetBase {\n    /// @notice Emitted when close factor is changed by admin\n    event NewCloseFactor(uint oldCloseFactorMantissa, uint newCloseFactorMantissa);\n\n    /// @notice Emitted when a collateral factor is changed by admin\n    event NewCollateralFactor(VToken vToken, uint oldCollateralFactorMantissa, uint newCollateralFactorMantissa);\n\n    /// @notice Emitted when liquidation incentive is changed by admin\n    event NewLiquidationIncentive(uint oldLiquidationIncentiveMantissa, uint newLiquidationIncentiveMantissa);\n\n    /// @notice Emitted when price oracle is changed\n    event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);\n\n    /// @notice Emitted when borrow cap for a vToken is changed\n    event NewBorrowCap(VToken indexed vToken, uint newBorrowCap);\n\n    /// @notice Emitted when VAIController is changed\n    event NewVAIController(VAIControllerInterface oldVAIController, VAIControllerInterface newVAIController);\n\n    /// @notice Emitted when VAI mint rate is changed by admin\n    event NewVAIMintRate(uint oldVAIMintRate, uint newVAIMintRate);\n\n    /// @notice Emitted when protocol state is changed by admin\n    event ActionProtocolPaused(bool state);\n\n    /// @notice Emitted when treasury guardian is changed\n    event NewTreasuryGuardian(address oldTreasuryGuardian, address newTreasuryGuardian);\n\n    /// @notice Emitted when treasury address is changed\n    event NewTreasuryAddress(address oldTreasuryAddress, address newTreasuryAddress);\n\n    /// @notice Emitted when treasury percent is changed\n    event NewTreasuryPercent(uint oldTreasuryPercent, uint newTreasuryPercent);\n\n    /// @notice Emitted when liquidator adress is changed\n    event NewLiquidatorContract(address oldLiquidatorContract, address newLiquidatorContract);\n\n    /// @notice Emitted when ComptrollerLens address is changed\n    event NewComptrollerLens(address oldComptrollerLens, address newComptrollerLens);\n\n    /// @notice Emitted when supply cap for a vToken is changed\n    event NewSupplyCap(VToken indexed vToken, uint newSupplyCap);\n\n    /// @notice Emitted when access control address is changed by admin\n    event NewAccessControl(address oldAccessControlAddress, address newAccessControlAddress);\n\n    /// @notice Emitted when pause guardian is changed\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\n\n    /// @notice Emitted when an action is paused on a market\n    event ActionPausedMarket(VToken indexed vToken, Action indexed action, bool pauseState);\n\n    /// @notice Emitted when VAI Vault info is changed\n    event NewVAIVaultInfo(address vault_, uint releaseStartBlock_, uint releaseInterval_);\n\n    /// @notice Emitted when Venus VAI Vault rate is changed\n    event NewVenusVAIVaultRate(uint oldVenusVAIVaultRate, uint newVenusVAIVaultRate);\n\n    /**\n     * @notice Sets a new price oracle for the comptroller\n     * @dev Admin function to set a new price oracle\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setPriceOracle(PriceOracle newOracle) external returns (uint) {\n        // Check caller is admin\n        ensureAdmin();\n        ensureNonzeroAddress(address(newOracle));\n\n        // Track the old oracle for the comptroller\n        PriceOracle oldOracle = oracle;\n\n        // Set comptroller's oracle to newOracle\n        oracle = newOracle;\n\n        // Emit NewPriceOracle(oldOracle, newOracle)\n        emit NewPriceOracle(oldOracle, newOracle);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the closeFactor used when liquidating borrows\n     * @dev Admin function to set closeFactor\n     * @param newCloseFactorMantissa New close factor, scaled by 1e18\n     * @return uint 0=success, otherwise will revert\n     */\n    function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint) {\n        // Check caller is admin\n        ensureAdmin();\n\n        uint oldCloseFactorMantissa = closeFactorMantissa;\n        closeFactorMantissa = newCloseFactorMantissa;\n        emit NewCloseFactor(oldCloseFactorMantissa, newCloseFactorMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the address of the access control of this contract\n     * @dev Admin function to set the access control address\n     * @param newAccessControlAddress New address for the access control\n     * @return uint 0=success, otherwise will revert\n     */\n    function _setAccessControl(address newAccessControlAddress) external returns (uint) {\n        // Check caller is admin\n        ensureAdmin();\n        ensureNonzeroAddress(newAccessControlAddress);\n\n        address oldAccessControlAddress = accessControl;\n        accessControl = newAccessControlAddress;\n        emit NewAccessControl(oldAccessControlAddress, newAccessControlAddress);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the collateralFactor for a market\n     * @dev Restricted function to set per-market collateralFactor\n     * @param vToken The market to set the factor on\n     * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\n     * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function _setCollateralFactor(VToken vToken, uint newCollateralFactorMantissa) external returns (uint) {\n        // Check caller is allowed by access control manager\n        ensureAllowed(\"_setCollateralFactor(address,uint256)\");\n        ensureNonzeroAddress(address(vToken));\n\n        // Verify market is listed\n        Market storage market = markets[address(vToken)];\n        ensureListed(market);\n\n        Exp memory newCollateralFactorExp = Exp({ mantissa: newCollateralFactorMantissa });\n\n        //-- Check collateral factor <= 0.9\n        Exp memory highLimit = Exp({ mantissa: collateralFactorMaxMantissa });\n        if (lessThanExp(highLimit, newCollateralFactorExp)) {\n            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\n        }\n\n        // If collateral factor != 0, fail if price == 0\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(vToken) == 0) {\n            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n        }\n\n        // Set market's collateral factor to new collateral factor, remember old value\n        uint oldCollateralFactorMantissa = market.collateralFactorMantissa;\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\n\n        // Emit event with asset, old collateral factor, and new collateral factor\n        emit NewCollateralFactor(vToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets liquidationIncentive\n     * @dev Admin function to set liquidationIncentive\n     * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\n     * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint) {\n        ensureAllowed(\"_setLiquidationIncentive(uint256)\");\n\n        require(newLiquidationIncentiveMantissa >= 1e18, \"incentive must be over 1e18\");\n\n        // Save current value for use in log\n        uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\n        // Set liquidation incentive to new incentive\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n\n        // Emit event with old incentive, new incentive\n        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    function _setLiquidatorContract(address newLiquidatorContract_) external {\n        // Check caller is admin\n        ensureAdmin();\n        address oldLiquidatorContract = liquidatorContract;\n        liquidatorContract = newLiquidatorContract_;\n        emit NewLiquidatorContract(oldLiquidatorContract, newLiquidatorContract_);\n    }\n\n    /**\n     * @notice Admin function to change the Pause Guardian\n     * @param newPauseGuardian The address of the new Pause Guardian\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function _setPauseGuardian(address newPauseGuardian) external returns (uint) {\n        ensureAdmin();\n        ensureNonzeroAddress(newPauseGuardian);\n\n        // Save current value for inclusion in log\n        address oldPauseGuardian = pauseGuardian;\n        // Store pauseGuardian with value newPauseGuardian\n        pauseGuardian = newPauseGuardian;\n\n        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\n        emit NewPauseGuardian(oldPauseGuardian, newPauseGuardian);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set the given borrow caps for the given vToken market Borrowing that brings total borrows to or above borrow cap will revert.\n     * @dev Access is controled by ACM. A borrow cap of 0 corresponds to unlimited borrowing.\n     * @param vTokens The addresses of the markets (tokens) to change the borrow caps for\n     * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to unlimited borrowing.\n     */\n    function _setMarketBorrowCaps(VToken[] calldata vTokens, uint[] calldata newBorrowCaps) external {\n        ensureAllowed(\"_setMarketBorrowCaps(address[],uint256[])\");\n\n        uint numMarkets = vTokens.length;\n        uint numBorrowCaps = newBorrowCaps.length;\n\n        require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\n\n        for (uint i; i < numMarkets; ++i) {\n            borrowCaps[address(vTokens[i])] = newBorrowCaps[i];\n            emit NewBorrowCap(vTokens[i], newBorrowCaps[i]);\n        }\n    }\n\n    /**\n     * @notice Set the given supply caps for the given vToken market Supply that brings total Supply to or above supply cap will revert.\n     * @dev Admin function to set the supply cap A supply cap of 0 corresponds to Minting NotAllowed.\n     * @param vTokens The addresses of the markets (tokens) to change the supply caps for\n     * @param newSupplyCaps The new supply cap values in underlying to be set. A value of 0 corresponds to Minting NotAllowed.\n     */\n    function _setMarketSupplyCaps(VToken[] calldata vTokens, uint256[] calldata newSupplyCaps) external {\n        ensureAllowed(\"_setMarketSupplyCaps(address[],uint256[])\");\n\n        uint numMarkets = vTokens.length;\n        uint numSupplyCaps = newSupplyCaps.length;\n\n        require(numMarkets != 0 && numMarkets == numSupplyCaps, \"invalid input\");\n\n        for (uint i; i < numMarkets; ++i) {\n            supplyCaps[address(vTokens[i])] = newSupplyCaps[i];\n            emit NewSupplyCap(vTokens[i], newSupplyCaps[i]);\n        }\n    }\n\n    /**\n     * @notice Set whole protocol pause/unpause state\n     */\n    function _setProtocolPaused(bool state) external returns (bool) {\n        ensureAllowed(\"_setProtocolPaused(bool)\");\n\n        protocolPaused = state;\n        emit ActionProtocolPaused(state);\n        return state;\n    }\n\n    /**\n     * @notice Pause/unpause certain actions\n     * @param markets_ Markets to pause/unpause the actions on\n     * @param actions_ List of action ids to pause/unpause\n     * @param paused_ The new paused state (true=paused, false=unpaused)\n     */\n    function _setActionsPaused(address[] calldata markets_, Action[] calldata actions_, bool paused_) external {\n        ensureAllowed(\"_setActionsPaused(address[],uint256[],bool)\");\n\n        uint256 numMarkets = markets_.length;\n        uint256 numActions = actions_.length;\n        for (uint marketIdx; marketIdx < numMarkets; ++marketIdx) {\n            for (uint actionIdx; actionIdx < numActions; ++actionIdx) {\n                setActionPausedInternal(markets_[marketIdx], actions_[actionIdx], paused_);\n            }\n        }\n    }\n\n    /**\n     * @dev Pause/unpause an action on a market\n     * @param market Market to pause/unpause the action on\n     * @param action Action id to pause/unpause\n     * @param paused The new paused state (true=paused, false=unpaused)\n     */\n    function setActionPausedInternal(address market, Action action, bool paused) internal {\n        ensureListed(markets[market]);\n        _actionPaused[market][uint(action)] = paused;\n        emit ActionPausedMarket(VToken(market), action, paused);\n    }\n\n    /**\n     * @notice Sets a new VAI controller\n     * @dev Admin function to set a new VAI controller\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setVAIController(VAIControllerInterface vaiController_) external returns (uint) {\n        // Check caller is admin\n        ensureAdmin();\n        ensureNonzeroAddress(address(vaiController_));\n\n        VAIControllerInterface oldVaiController = vaiController;\n        vaiController = vaiController_;\n        emit NewVAIController(oldVaiController, vaiController_);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    function _setVAIMintRate(uint newVAIMintRate) external returns (uint) {\n        // Check caller is admin\n        ensureAdmin();\n        uint oldVAIMintRate = vaiMintRate;\n        vaiMintRate = newVAIMintRate;\n        emit NewVAIMintRate(oldVAIMintRate, newVAIMintRate);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set the minted VAI amount of the `owner`\n     * @param owner The address of the account to set\n     * @param amount The amount of VAI to set to the account\n     * @return The number of minted VAI by `owner`\n     */\n    function setMintedVAIOf(address owner, uint amount) external returns (uint) {\n        checkProtocolPauseState();\n\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!mintVAIGuardianPaused && !repayVAIGuardianPaused, \"VAI is paused\");\n        // Check caller is vaiController\n        if (msg.sender != address(vaiController)) {\n            return fail(Error.REJECTION, FailureInfo.SET_MINTED_VAI_REJECTION);\n        }\n        mintedVAIs[owner] = amount;\n        return uint(Error.NO_ERROR);\n    }\n\n    function _setTreasuryData(\n        address newTreasuryGuardian,\n        address newTreasuryAddress,\n        uint newTreasuryPercent\n    ) external returns (uint) {\n        // Check caller is admin\n        ensureAdminOr(treasuryGuardian);\n\n        require(newTreasuryPercent < 1e18, \"treasury percent cap overflow\");\n        ensureNonzeroAddress(newTreasuryGuardian);\n        ensureNonzeroAddress(newTreasuryAddress);\n\n        address oldTreasuryGuardian = treasuryGuardian;\n        address oldTreasuryAddress = treasuryAddress;\n        uint oldTreasuryPercent = treasuryPercent;\n\n        treasuryGuardian = newTreasuryGuardian;\n        treasuryAddress = newTreasuryAddress;\n        treasuryPercent = newTreasuryPercent;\n\n        emit NewTreasuryGuardian(oldTreasuryGuardian, newTreasuryGuardian);\n        emit NewTreasuryAddress(oldTreasuryAddress, newTreasuryAddress);\n        emit NewTreasuryPercent(oldTreasuryPercent, newTreasuryPercent);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /*** Venus Distribution ***/\n\n    /**\n     * @dev Set ComptrollerLens contract address\n     */\n    function _setComptrollerLens(ComptrollerLensInterface comptrollerLens_) external returns (uint) {\n        ensureAdmin();\n        ensureNonzeroAddress(address(comptrollerLens_));\n        address oldComptrollerLens = address(comptrollerLens);\n        comptrollerLens = comptrollerLens_;\n        emit NewComptrollerLens(oldComptrollerLens, address(comptrollerLens));\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set the amount of XVS distributed per block to VAI Vault\n     * @param venusVAIVaultRate_ The amount of XVS wei per block to distribute to VAI Vault\n     */\n    function _setVenusVAIVaultRate(uint venusVAIVaultRate_) external {\n        ensureAdmin();\n        if (vaiVaultAddress != address(0)) {\n            releaseToVault();\n        }\n        uint oldVenusVAIVaultRate = venusVAIVaultRate;\n        venusVAIVaultRate = venusVAIVaultRate_;\n        emit NewVenusVAIVaultRate(oldVenusVAIVaultRate, venusVAIVaultRate_);\n    }\n\n    /**\n     * @notice Set the VAI Vault infos\n     * @param vault_ The address of the VAI Vault\n     * @param releaseStartBlock_ The start block of release to VAI Vault\n     * @param minReleaseAmount_ The minimum release amount to VAI Vault\n     */\n    function _setVAIVaultInfo(address vault_, uint256 releaseStartBlock_, uint256 minReleaseAmount_) external {\n        ensureAdmin();\n        ensureNonzeroAddress(vault_);\n        if (vaiVaultAddress != address(0)) {\n            releaseToVault();\n        }\n\n        vaiVaultAddress = vault_;\n        releaseStartBlock = releaseStartBlock_;\n        minReleaseAmount = minReleaseAmount_;\n        emit NewVAIVaultInfo(vault_, releaseStartBlock_, minReleaseAmount_);\n    }\n}"
    },
    {
      "filename": "contracts/Comptroller/Diamond/facets/SetterFacet.sol",
      "content": "pragma solidity 0.5.16;\n\nimport \"../../../Oracle/PriceOracle.sol\";\nimport \"../../../Tokens/VTokens/VToken.sol\";\nimport \"../../../Utils/ErrorReporter.sol\";\nimport \"./FacetBase.sol\";\n\n/**\n * @dev This facet contains all the setters for the states\n */\ncontract SetterFacet is ComptrollerErrorReporter, ExponentialNoError, FacetBase {\n    /// @notice Emitted when close factor is changed by admin\n    event NewCloseFactor(uint oldCloseFactorMantissa, uint newCloseFactorMantissa);\n\n    /// @notice Emitted when a collateral factor is changed by admin\n    event NewCollateralFactor(VToken vToken, uint oldCollateralFactorMantissa, uint newCollateralFactorMantissa);\n\n    /// @notice Emitted when liquidation incentive is changed by admin\n    event NewLiquidationIncentive(uint oldLiquidationIncentiveMantissa, uint newLiquidationIncentiveMantissa);\n\n    /// @notice Emitted when price oracle is changed\n    event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);\n\n    /// @notice Emitted when borrow cap for a vToken is changed\n    event NewBorrowCap(VToken indexed vToken, uint newBorrowCap);\n\n    /// @notice Emitted when VAIController is changed\n    event NewVAIController(VAIControllerInterface oldVAIController, VAIControllerInterface newVAIController);\n\n    /// @notice Emitted when VAI mint rate is changed by admin\n    event NewVAIMintRate(uint oldVAIMintRate, uint newVAIMintRate);\n\n    /// @notice Emitted when protocol state is changed by admin\n    event ActionProtocolPaused(bool state);\n\n    /// @notice Emitted when treasury guardian is changed\n    event NewTreasuryGuardian(address oldTreasuryGuardian, address newTreasuryGuardian);\n\n    /// @notice Emitted when treasury address is changed\n    event NewTreasuryAddress(address oldTreasuryAddress, address newTreasuryAddress);\n\n    /// @notice Emitted when treasury percent is changed\n    event NewTreasuryPercent(uint oldTreasuryPercent, uint newTreasuryPercent);\n\n    /// @notice Emitted when liquidator adress is changed\n    event NewLiquidatorContract(address oldLiquidatorContract, address newLiquidatorContract);\n\n    /// @notice Emitted when ComptrollerLens address is changed\n    event NewComptrollerLens(address oldComptrollerLens, address newComptrollerLens);\n\n    /// @notice Emitted when supply cap for a vToken is changed\n    event NewSupplyCap(VToken indexed vToken, uint newSupplyCap);\n\n    /// @notice Emitted when access control address is changed by admin\n    event NewAccessControl(address oldAccessControlAddress, address newAccessControlAddress);\n\n    /// @notice Emitted when pause guardian is changed\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\n\n    /// @notice Emitted when an action is paused on a market\n    event ActionPausedMarket(VToken indexed vToken, Action indexed action, bool pauseState);\n\n    /// @notice Emitted when VAI Vault info is changed\n    event NewVAIVaultInfo(address vault_, uint releaseStartBlock_, uint releaseInterval_);\n\n    /// @notice Emitted when Venus VAI Vault rate is changed\n    event NewVenusVAIVaultRate(uint oldVenusVAIVaultRate, uint newVenusVAIVaultRate);\n\n    /**\n     * @notice Sets a new price oracle for the comptroller\n     * @dev Admin function to set a new price oracle\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setPriceOracle(PriceOracle newOracle) external returns (uint) {\n        // Check caller is admin\n        ensureAdmin();\n        ensureNonzeroAddress(address(newOracle));\n\n        // Track the old oracle for the comptroller\n        PriceOracle oldOracle = oracle;\n\n        // Set comptroller's oracle to newOracle\n        oracle = newOracle;\n\n        // Emit NewPriceOracle(oldOracle, newOracle)\n        emit NewPriceOracle(oldOracle, newOracle);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the closeFactor used when liquidating borrows\n     * @dev Admin function to set closeFactor\n     * @param newCloseFactorMantissa New close factor, scaled by 1e18\n     * @return uint 0=success, otherwise will revert\n     */\n    function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint) {\n        // Check caller is admin\n        ensureAdmin();\n\n        uint oldCloseFactorMantissa = closeFactorMantissa;\n        closeFactorMantissa = newCloseFactorMantissa;\n        emit NewCloseFactor(oldCloseFactorMantissa, newCloseFactorMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the address of the access control of this contract\n     * @dev Admin function to set the access control address\n     * @param newAccessControlAddress New address for the access control\n     * @return uint 0=success, otherwise will revert\n     */\n    function _setAccessControl(address newAccessControlAddress) external returns (uint) {\n        // Check caller is admin\n        ensureAdmin();\n        ensureNonzeroAddress(newAccessControlAddress);\n\n        address oldAccessControlAddress = accessControl;\n        accessControl = newAccessControlAddress;\n        emit NewAccessControl(oldAccessControlAddress, newAccessControlAddress);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the collateralFactor for a market\n     * @dev Restricted function to set per-market collateralFactor\n     * @param vToken The market to set the factor on\n     * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\n     * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function _setCollateralFactor(VToken vToken, uint newCollateralFactorMantissa) external returns (uint) {\n        // Check caller is allowed by access control manager\n        ensureAllowed(\"_setCollateralFactor(address,uint256)\");\n        ensureNonzeroAddress(address(vToken));\n\n        // Verify market is listed\n        Market storage market = markets[address(vToken)];\n        ensureListed(market);\n\n        Exp memory newCollateralFactorExp = Exp({ mantissa: newCollateralFactorMantissa });\n\n        //-- Check collateral factor <= 0.9\n        Exp memory highLimit = Exp({ mantissa: collateralFactorMaxMantissa });\n        if (lessThanExp(highLimit, newCollateralFactorExp)) {\n            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\n        }\n\n        // If collateral factor != 0, fail if price == 0\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(vToken) == 0) {\n            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n        }\n\n        // Set market's collateral factor to new collateral factor, remember old value\n        uint oldCollateralFactorMantissa = market.collateralFactorMantissa;\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\n\n        // Emit event with asset, old collateral factor, and new collateral factor\n        emit NewCollateralFactor(vToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets liquidationIncentive\n     * @dev Admin function to set liquidationIncentive\n     * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\n     * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint) {\n        ensureAllowed(\"_setLiquidationIncentive(uint256)\");\n\n        require(newLiquidationIncentiveMantissa >= 1e18, \"incentive must be over 1e18\");\n\n        // Save current value for use in log\n        uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\n        // Set liquidation incentive to new incentive\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n\n        // Emit event with old incentive, new incentive\n        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    function _setLiquidatorContract(address newLiquidatorContract_) external {\n        // Check caller is admin\n        ensureAdmin();\n        address oldLiquidatorContract = liquidatorContract;\n        liquidatorContract = newLiquidatorContract_;\n        emit NewLiquidatorContract(oldLiquidatorContract, newLiquidatorContract_);\n    }\n\n    /**\n     * @notice Admin function to change the Pause Guardian\n     * @param newPauseGuardian The address of the new Pause Guardian\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function _setPauseGuardian(address newPauseGuardian) external returns (uint) {\n        ensureAdmin();\n        ensureNonzeroAddress(newPauseGuardian);\n\n        // Save current value for inclusion in log\n        address oldPauseGuardian = pauseGuardian;\n        // Store pauseGuardian with value newPauseGuardian\n        pauseGuardian = newPauseGuardian;\n\n        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\n        emit NewPauseGuardian(oldPauseGuardian, newPauseGuardian);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set the given borrow caps for the given vToken market Borrowing that brings total borrows to or above borrow cap will revert.\n     * @dev Access is controled by ACM. A borrow cap of 0 corresponds to unlimited borrowing.\n     * @param vTokens The addresses of the markets (tokens) to change the borrow caps for\n     * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to unlimited borrowing.\n     */\n    function _setMarketBorrowCaps(VToken[] calldata vTokens, uint[] calldata newBorrowCaps) external {\n        ensureAllowed(\"_setMarketBorrowCaps(address[],uint256[])\");\n\n        uint numMarkets = vTokens.length;\n        uint numBorrowCaps = newBorrowCaps.length;\n\n        require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\n\n        for (uint i; i < numMarkets; ++i) {\n            borrowCaps[address(vTokens[i])] = newBorrowCaps[i];\n            emit NewBorrowCap(vTokens[i], newBorrowCaps[i]);\n        }\n    }\n\n    /**\n     * @notice Set the given supply caps for the given vToken market Supply that brings total Supply to or above supply cap will revert.\n     * @dev Admin function to set the supply cap A supply cap of 0 corresponds to Minting NotAllowed.\n     * @param vTokens The addresses of the markets (tokens) to change the supply caps for\n     * @param newSupplyCaps The new supply cap values in underlying to be set. A value of 0 corresponds to Minting NotAllowed.\n     */\n    function _setMarketSupplyCaps(VToken[] calldata vTokens, uint256[] calldata newSupplyCaps) external {\n        ensureAllowed(\"_setMarketSupplyCaps(address[],uint256[])\");\n\n        uint numMarkets = vTokens.length;\n        uint numSupplyCaps = newSupplyCaps.length;\n\n        require(numMarkets != 0 && numMarkets == numSupplyCaps, \"invalid input\");\n\n        for (uint i; i < numMarkets; ++i) {\n            supplyCaps[address(vTokens[i])] = newSupplyCaps[i];\n            emit NewSupplyCap(vTokens[i], newSupplyCaps[i]);\n        }\n    }\n\n    /**\n     * @notice Set whole protocol pause/unpause state\n     */\n    function _setProtocolPaused(bool state) external returns (bool) {\n        ensureAllowed(\"_setProtocolPaused(bool)\");\n\n        protocolPaused = state;\n        emit ActionProtocolPaused(state);\n        return state;\n    }\n\n    /**\n     * @notice Pause/unpause certain actions\n     * @param markets_ Markets to pause/unpause the actions on\n     * @param actions_ List of action ids to pause/unpause\n     * @param paused_ The new paused state (true=paused, false=unpaused)\n     */\n    function _setActionsPaused(address[] calldata markets_, Action[] calldata actions_, bool paused_) external {\n        ensureAllowed(\"_setActionsPaused(address[],uint256[],bool)\");\n\n        uint256 numMarkets = markets_.length;\n        uint256 numActions = actions_.length;\n        for (uint marketIdx; marketIdx < numMarkets; ++marketIdx) {\n            for (uint actionIdx; actionIdx < numActions; ++actionIdx) {\n                setActionPausedInternal(markets_[marketIdx], actions_[actionIdx], paused_);\n            }\n        }\n    }\n\n    /**\n     * @dev Pause/unpause an action on a market\n     * @param market Market to pause/unpause the action on\n     * @param action Action id to pause/unpause\n     * @param paused The new paused state (true=paused, false=unpaused)\n     */\n    function setActionPausedInternal(address market, Action action, bool paused) internal {\n        ensureListed(markets[market]);\n        _actionPaused[market][uint(action)] = paused;\n        emit ActionPausedMarket(VToken(market), action, paused);\n    }\n\n    /**\n     * @notice Sets a new VAI controller\n     * @dev Admin function to set a new VAI controller\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setVAIController(VAIControllerInterface vaiController_) external returns (uint) {\n        // Check caller is admin\n        ensureAdmin();\n        ensureNonzeroAddress(address(vaiController_));\n\n        VAIControllerInterface oldVaiController = vaiController;\n        vaiController = vaiController_;\n        emit NewVAIController(oldVaiController, vaiController_);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    function _setVAIMintRate(uint newVAIMintRate) external returns (uint) {\n        // Check caller is admin\n        ensureAdmin();\n        uint oldVAIMintRate = vaiMintRate;\n        vaiMintRate = newVAIMintRate;\n        emit NewVAIMintRate(oldVAIMintRate, newVAIMintRate);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set the minted VAI amount of the `owner`\n     * @param owner The address of the account to set\n     * @param amount The amount of VAI to set to the account\n     * @return The number of minted VAI by `owner`\n     */\n    function setMintedVAIOf(address owner, uint amount) external returns (uint) {\n        checkProtocolPauseState();\n\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!mintVAIGuardianPaused && !repayVAIGuardianPaused, \"VAI is paused\");\n        // Check caller is vaiController\n        if (msg.sender != address(vaiController)) {\n            return fail(Error.REJECTION, FailureInfo.SET_MINTED_VAI_REJECTION);\n        }\n        mintedVAIs[owner] = amount;\n        return uint(Error.NO_ERROR);\n    }\n\n    function _setTreasuryData(\n        address newTreasuryGuardian,\n        address newTreasuryAddress,\n        uint newTreasuryPercent\n    ) external returns (uint) {\n        // Check caller is admin\n        ensureAdminOr(treasuryGuardian);\n\n        require(newTreasuryPercent < 1e18, \"treasury percent cap overflow\");\n        ensureNonzeroAddress(newTreasuryGuardian);\n        ensureNonzeroAddress(newTreasuryAddress);\n\n        address oldTreasuryGuardian = treasuryGuardian;\n        address oldTreasuryAddress = treasuryAddress;\n        uint oldTreasuryPercent = treasuryPercent;\n\n        treasuryGuardian = newTreasuryGuardian;\n        treasuryAddress = newTreasuryAddress;\n        treasuryPercent = newTreasuryPercent;\n\n        emit NewTreasuryGuardian(oldTreasuryGuardian, newTreasuryGuardian);\n        emit NewTreasuryAddress(oldTreasuryAddress, newTreasuryAddress);\n        emit NewTreasuryPercent(old"
    }
  ]
}