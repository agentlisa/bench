{
  "Title": "Incorrect function name",
  "Content": "##### Description\nIncorrect function of Uniswap-V2 pool is called:\nhttps://github.com/Gearbox-protocol/gearbox-contracts/blob/0ac33ba87212ce056ac6b6357ad74161d417158a/contracts/adapters/UniswapV2.sol#L387\n##### Recommendation\nWe recommend changing the function name.",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/adapters/UniswapV2.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox. Generalized leverage protocol that allows to take leverage and then use it across other DeFi protocols and platforms in a composable way.\n// (c) Gearbox.fi, 2021\npragma solidity ^0.7.4;\n\nimport {ICreditFilter} from \"../interfaces/ICreditFilter.sol\";\nimport {ICreditManager} from \"../interfaces/ICreditManager.sol\";\nimport {CreditManager} from \"../credit/CreditManager.sol\";\nimport {Constants} from \"../libraries/helpers/Constants.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"hardhat/console.sol\";\nimport \"../integrations/uniswap/IUniswapV2Router02.sol\";\n\n/// @title UniswapV2 Router adapter\ncontract UniswapV2Adapter is IUniswapV2Router02 {\n    ICreditManager public creditManager;\n    ICreditFilter public creditFilter;\n    using SafeMath for uint256;\n    address public swapContract;\n\n    /// @dev Constructor\n    /// @param _creditManager Address Credit manager\n    /// @param _swapContract Address of swap contract\n    constructor(address _creditManager, address _swapContract) {\n        creditManager = ICreditManager(_creditManager);\n        creditFilter = ICreditFilter(creditManager.creditFilter());\n        swapContract = _swapContract;\n    }\n\n    /**\n     * @dev Swap tokens to exact tokens using Uniswap-compatible protocol\n     * - checks that swap contract is allowed\n     * - checks that in/out tokens are in allowed list\n     * - checks that required allowance is enough, if not - set it to MAX_INT\n     * - call swap function on credit account contracts\n     * @param amountOut The amount of output tokens to receive.\n     * @param amountInMax The maximum amount of input tokens that can be required before the transaction reverts.\n     * @param path An array of token addresses. path.length must be >= 2. Pools for each consecutive pair of\n     *        addresses must exist and have liquidity.\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * for more information check uniswap documentation: https://uniswap.org/docs/v2/smart-contracts/router02/\n     */\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address,\n        uint256 deadline\n    ) external override returns (uint256[] memory amounts) {\n        address creditAccount = creditManager.getCreditAccountOrRevert(\n            msg.sender\n        );\n\n        creditManager.provideCreditAccountAllowance(\n            creditAccount,\n            swapContract,\n            path[0]\n        );\n\n        bytes memory data = abi.encodeWithSelector(\n            bytes4(0x8803dbee), // \"swapTokensForExactTokens(uint256,uint256,address[],address,uint256)\",\n            amountOut,\n            amountInMax,\n            path,\n            creditAccount,\n            deadline\n        );\n\n        amounts = abi.decode(\n            creditManager.executeOrder(msg.sender, swapContract, data),\n            (uint256[])\n        );\n\n\n        creditFilter.checkCollateralChange(\n            creditAccount,\n            path[0],\n            path[path.length - 1],\n            amounts[0],\n            amounts[amounts.length - 1]\n        );\n    }\n\n    /**\n     * Swaps exact tokens to tokens on Uniswap compatible protocols\n     * - checks that swap contract is allowed\n     * - checks that in/out tokens are in allowed list\n     * - checks that required allowance is enough, if not - set it to MAX_INT\n     * - call swap function on credit account contracts\n     * @param amountIn The amount of input tokens to send.\n     * @param amountOutMin The minimum amount of output tokens that must be received for the transaction not to revert.\n     * @param path An array of token addresses. path.length must be >= 2. Pools for each consecutive pair of\n     *        addresses must exist and have liquidity.\n     * deadline Unix timestamp after which the transaction will revert.\n     * for more information check uniswap documentation: https://uniswap.org/docs/v2/smart-contracts/router02/\n     */\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address,\n        uint256 deadline\n    ) external override returns (uint256[] memory amounts) {\n        address creditAccount = creditManager.getCreditAccountOrRevert(\n            msg.sender\n        );\n\n        creditManager.provideCreditAccountAllowance(\n            creditAccount,\n            swapContract,\n            path[0]\n        );\n\n        bytes memory data = abi.encodeWithSelector(\n            bytes4(0x38ed1739), // \"swapExactTokensForTokens(uint256,uint256,address[],address,uint256)\",\n            amountIn,\n            amountOutMin,\n            path,\n            creditAccount,\n            deadline\n        );\n\n        amounts = abi.decode(\n            creditManager.executeOrder(msg.sender, swapContract, data),\n            (uint256[])\n        );\n\n        creditFilter.checkCollateralChange(\n            creditAccount,\n            path[0],\n            path[path.length - 1],\n            amounts[0],\n            amounts[amounts.length - 1]\n        ); // ToDo: CHECK(!)\n    }\n\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external override returns (uint256 amountETH) {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override returns (uint256 amountETH) {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external override {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable override {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external override {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function factory() external view override returns (address) {\n        return IUniswapV2Router02(swapContract).factory();\n    }\n\n    function WETH() external view override returns (address) {\n        return IUniswapV2Router02(swapContract).WETH();\n    }\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        override\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        )\n    {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        override\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        )\n    {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external override returns (uint256 amountA, uint256 amountB) {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external override returns (uint256 amountToken, uint256 amountETH) {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override returns (uint256 amountA, uint256 amountB) {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override returns (uint256 amountToken, uint256 amountETH) {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable override returns (uint256[] memory amounts) {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external override returns (uint256[] memory amounts) {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external override returns (uint256[] memory amounts) {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable override returns (uint256[] memory amounts) {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external view override returns (uint256 amountB) {\n        return\n            IUniswapV2Router02(swapContract).quote(amountA, reserveA, reserveB);\n    }\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external view override returns (uint256 amountOut) {\n        return\n            IUniswapV2Router02(swapContract).getAmountOut(\n                amountIn,\n                reserveIn,\n                reserveOut\n            );\n    }\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external view override returns (uint256 amountIn) {\n        return\n            IUniswapV2Router02(swapContract).getAmountIn(\n                amountOut,\n                reserveIn,\n                reserveOut\n            );\n    }\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\n        external\n        view\n        override\n        returns (uint256[] memory amounts)\n    {\n        return IUniswapV2Router02(swapContract).getAmountsOut(amountIn, path);\n    }\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\n        external\n        view\n        override\n        returns (uint256[] memory amounts)\n    {\n        return IUniswapV2Router02(swapContract).getAmountsOut(amountOut, path);\n    }\n}"
    }
  ]
}