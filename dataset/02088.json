{
  "Title": "M-3: A single precision value may not work for both the min and max prices",
  "Content": "# Issue M-3: A single precision value may not work for both the min and max prices \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/182 \n\n## Found by \nIllIllI\n\n## Summary\n\nThe same precision may not work for the min and max prices\n\n\n## Vulnerability Detail\n\nIf the min price reaches the maximum value possible for the specified level of precision, the max price won't be able to use the same precision.\n\n## Impact\n\nDepending on how the order keepers and oracle archive work, either the fetching the price from the oracle will fail, or the user will get less than they deserve. This may happen when a user is at the border of being liquidated, and it would be unfair to liquidate the user.\n\n## Code Snippet\n\nThe same precision is required to be used for both the min and max prices:\n```solidity\n// File: gmx-synthetics/contracts/oracle/OracleUtils.sol : OracleUtils.validateSigner()   #1\n\n254        ) internal pure {\n255            bytes32 digest = ECDSA.toEthSignedMessageHash(\n256                keccak256(abi.encode(\n257                    SALT,\n258                    info.minOracleBlockNumber,\n259                    info.maxOracleBlockNumber,\n260                    info.oracleTimestamp,\n261                    info.blockHash,\n262                    info.token,\n263                    info.tokenOracleType,\n264 @>                 info.precision,\n265 @>                 info.minPrice,\n266 @>                 info.maxPrice\n267                ))\n268            );\n269    \n270:           address recoveredSigner = ECDSA.recover(digest, signature);\n```\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/oracle/OracleUtils.sol#L254-L274\n\nThe example from the source [comments](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/oracle/Oracle.sol#L194-L196) show that legitimate values feasibly can occur on precision boundaries.\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nProvide separate precision values for min and max prices\n\n\n\n\n## Discussion\n\n**xvi10**\n\nWill reference the ETH example, as the numbers are a bit simpler to reason with\n\nThe price of ETH is 5000, and ETH has 18 decimals.\nPrice would be stored as 5000 / (10 ^ 18) * (10 ^ 30) => 5000 * (10 ^ 12)\nIf the decimal multiplier value is set to 8, the uint32 value would be 5000 * (10 ^ 12) / (10 ^ 8) => 5000 * (10 ^ 4)\n\nWith this config, ETH prices can have a maximum value of `(2 ^ 32) / (10 ^ 4) => 4,294,967,296 / (10 ^ 4) => 429,496.7296` with 4 decimals of precision.\n\nIf the price of ETH changes to be above 429,496.7296, e.g. 450,000  \n\nThe decimal multiplier value can be set to 9, the uint32 value would be 450,000 * (10 ^ 12) / (10 ^ 9) => 450,000 * (10 ^ 3)\n\nWith this config, ETH prices can have a maximum value of `(2 ^ 32) / (10 ^ 3) => 4,294,967,296 / (10 ^ 3) => 4,294,967.296` with 3 decimals of precision.\n\nThe mentioned case of requiring different decimals could occur if the min price of ETH is 5000 and the max price of ETH is 450,000, in case that occurs the decimal multiplier value can be set to 9 which may lead to a small amount of precision loss but we feel it is an acceptable outcome.\n\nIn case the precision difference required is too large, e.g. 2 decimals or more, we think the oracles should stop signing prices for this case, there could be a need for manual intervention to settle the market as there may be an issue with the price sources in case that occurs.\n\n\n**IllIllI000**\n\n@xvi10 can you elaborate on why this is disputed rather than no-fix? The last sentence seems to indicate a problem that needs to be worked around\n\n**xvi10**\n\nagree that confirmed and no-fix would be a more accurate label\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/oracle/OracleUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\nimport \"../utils/Array.sol\";\nimport \"../utils/Bits.sol\";\nimport \"../price/Price.sol\";\n\n// @title OracleUtils\n// @dev Library for oracle functions\nlibrary OracleUtils {\n    using Array for uint256[];\n\n    // @dev SetPricesParams struct for values required in Oracle.setPrices\n    // @param signerInfo compacted indexes of signers, the index is used to retrieve\n    // the signer address from the OracleStore\n    // @param tokens list of tokens to set prices for\n    // @param compactedOracleBlockNumbers compacted oracle block numbers\n    // @param compactedOracleTimestamps compacted oracle timestamps\n    // @param compactedDecimals compacted decimals for prices\n    // @param compactedMinPrices compacted min prices\n    // @param compactedMinPricesIndexes compacted min price indexes\n    // @param compactedMaxPrices compacted max prices\n    // @param compactedMaxPricesIndexes compacted max price indexes\n    // @param signatures signatures of the oracle signers\n    // @param priceFeedTokens tokens to set prices for based on an external price feed value\n    struct SetPricesParams {\n        uint256 signerInfo;\n        address[] tokens;\n        uint256[] compactedMinOracleBlockNumbers;\n        uint256[] compactedMaxOracleBlockNumbers;\n        uint256[] compactedOracleTimestamps;\n        uint256[] compactedDecimals;\n        uint256[] compactedMinPrices;\n        uint256[] compactedMinPricesIndexes;\n        uint256[] compactedMaxPrices;\n        uint256[] compactedMaxPricesIndexes;\n        bytes[] signatures;\n        address[] priceFeedTokens;\n    }\n\n    struct SimulatePricesParams {\n        address[] primaryTokens;\n        Price.Props[] primaryPrices;\n        address[] secondaryTokens;\n        Price.Props[] secondaryPrices;\n    }\n\n    struct ReportInfo {\n        uint256 minOracleBlockNumber;\n        uint256 maxOracleBlockNumber;\n        uint256 oracleTimestamp;\n        bytes32 blockHash;\n        address token;\n        bytes32 tokenOracleType;\n        uint256 precision;\n        uint256 minPrice;\n        uint256 maxPrice;\n    }\n\n    // compacted prices have a length of 32 bits\n    uint256 public constant COMPACTED_PRICE_BIT_LENGTH = 32;\n    uint256 public constant COMPACTED_PRICE_BITMASK = Bits.BITMASK_32;\n\n    // compacted precisions have a length of 8 bits\n    uint256 public constant COMPACTED_PRECISION_BIT_LENGTH = 8;\n    uint256 public constant COMPACTED_PRECISION_BITMASK = Bits.BITMASK_8;\n\n    // compacted block numbers have a length of 64 bits\n    uint256 public constant COMPACTED_BLOCK_NUMBER_BIT_LENGTH = 64;\n    uint256 public constant COMPACTED_BLOCK_NUMBER_BITMASK = Bits.BITMASK_64;\n\n    // compacted timestamps have a length of 64 bits\n    uint256 public constant COMPACTED_TIMESTAMP_BIT_LENGTH = 64;\n    uint256 public constant COMPACTED_TIMESTAMP_BITMASK = Bits.BITMASK_64;\n\n    // compacted price indexes have a length of 8 bits\n    uint256 public constant COMPACTED_PRICE_INDEX_BIT_LENGTH = 8;\n    uint256 public constant COMPACTED_PRICE_INDEX_BITMASK = Bits.BITMASK_8;\n\n    error EmptyPrimaryPrice(address token);\n    error EmptySecondaryPrice(address token);\n    error EmptyLatestPrice(address token);\n    error EmptyCustomPrice(address token);\n\n    error EmptyCompactedPrice(uint256 index);\n    error EmptyCompactedBlockNumber(uint256 index);\n    error EmptyCompactedTimestamp(uint256 index);\n\n    error OracleBlockNumbersAreNotEqual(uint256[] oracleBlockNumbers, uint256 expectedBlockNumber);\n    error OracleBlockNumbersAreSmallerThanRequired(uint256[] oracleBlockNumbers, uint256 expectedBlockNumber);\n    error OracleBlockNumberNotWithinRange(\n        uint256[] minOracleBlockNumbers,\n        uint256[] maxOracleBlockNumbers,\n        uint256 blockNumber\n    );\n\n    error InvalidSignature(address recoveredSigner, address expectedSigner);\n\n    function validateBlockNumberWithinRange(\n        uint256[] memory minOracleBlockNumbers,\n        uint256[] memory maxOracleBlockNumbers,\n        uint256 blockNumber\n    ) internal pure {\n        if (!isBlockNumberWithinRange(\n                minOracleBlockNumbers,\n                maxOracleBlockNumbers,\n                blockNumber\n        )) {\n            revertOracleBlockNumberNotWithinRange(\n                minOracleBlockNumbers,\n                maxOracleBlockNumbers,\n                blockNumber\n            );\n        }\n    }\n\n    function isBlockNumberWithinRange(\n        uint256[] memory minOracleBlockNumbers,\n        uint256[] memory maxOracleBlockNumbers,\n        uint256 blockNumber\n    ) internal pure returns (bool) {\n        if (!minOracleBlockNumbers.areLessThanOrEqualTo(blockNumber)) {\n            return false;\n        }\n\n        if (!maxOracleBlockNumbers.areGreaterThanOrEqualTo(blockNumber)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    // @dev get the uncompacted price at the specified index\n    // @param compactedPrices the compacted prices\n    // @param index the index to get the uncompacted price at\n    // @return the uncompacted price at the specified index\n    function getUncompactedPrice(uint256[] memory compactedPrices, uint256 index) internal pure returns (uint256) {\n        uint256 price = Array.getUncompactedValue(\n            compactedPrices,\n            index,\n            COMPACTED_PRICE_BIT_LENGTH,\n            COMPACTED_PRICE_BITMASK,\n            \"getUncompactedPrice\"\n        );\n\n        if (price == 0) { revert EmptyCompactedPrice(index); }\n\n        return price;\n    }\n\n    // @dev get the uncompacted decimal at the specified index\n    // @param compactedDecimals the compacted decimals\n    // @param index the index to get the uncompacted decimal at\n    // @return the uncompacted decimal at the specified index\n    function getUncompactedDecimal(uint256[] memory compactedDecimals, uint256 index) internal pure returns (uint256) {\n        uint256 decimal = Array.getUncompactedValue(\n            compactedDecimals,\n            index,\n            COMPACTED_PRECISION_BIT_LENGTH,\n            COMPACTED_PRECISION_BITMASK,\n            \"getUncompactedDecimal\"\n        );\n\n        return decimal;\n    }\n\n\n    // @dev get the uncompacted price index at the specified index\n    // @param compactedPriceIndexes the compacted indexes\n    // @param index the index to get the uncompacted price index at\n    // @return the uncompacted price index at the specified index\n    function getUncompactedPriceIndex(uint256[] memory compactedPriceIndexes, uint256 index) internal pure returns (uint256) {\n        uint256 priceIndex = Array.getUncompactedValue(\n            compactedPriceIndexes,\n            index,\n            COMPACTED_PRICE_INDEX_BIT_LENGTH,\n            COMPACTED_PRICE_INDEX_BITMASK,\n            \"getUncompactedPriceIndex\"\n        );\n\n        return priceIndex;\n\n    }\n\n    // @dev get the uncompacted oracle block numbers\n    // @param compactedOracleBlockNumbers the compacted oracle block numbers\n    // @param length the length of the uncompacted oracle block numbers\n    // @return the uncompacted oracle block numbers\n    function getUncompactedOracleBlockNumbers(uint256[] memory compactedOracleBlockNumbers, uint256 length) internal pure returns (uint256[] memory) {\n        uint256[] memory blockNumbers = new uint256[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            blockNumbers[i] = getUncompactedOracleBlockNumber(compactedOracleBlockNumbers, i);\n        }\n\n        return blockNumbers;\n    }\n\n    // @dev get the uncompacted oracle block number\n    // @param compactedOracleBlockNumbers the compacted oracle block numbers\n    // @param index the index to get the uncompacted oracle block number at\n    // @return the uncompacted oracle block number\n    function getUncompactedOracleBlockNumber(uint256[] memory compactedOracleBlockNumbers, uint256 index) internal pure returns (uint256) {\n        uint256 blockNumber = Array.getUncompactedValue(\n            compactedOracleBlockNumbers,\n            index,\n            COMPACTED_BLOCK_NUMBER_BIT_LENGTH,\n            COMPACTED_BLOCK_NUMBER_BITMASK,\n            \"getUncompactedOracleBlockNumber\"\n        );\n\n        if (blockNumber == 0) { revert EmptyCompactedBlockNumber(index); }\n\n        return blockNumber;\n    }\n\n    // @dev get the uncompacted oracle timestamp\n    // @param compactedOracleTimestamps the compacted oracle timestamps\n    // @param index the index to get the uncompacted oracle timestamp at\n    // @return the uncompacted oracle timestamp\n    function getUncompactedOracleTimestamp(uint256[] memory compactedOracleTimestamps, uint256 index) internal pure returns (uint256) {\n        uint256 blockNumber = Array.getUncompactedValue(\n            compactedOracleTimestamps,\n            index,\n            COMPACTED_TIMESTAMP_BIT_LENGTH,\n            COMPACTED_TIMESTAMP_BITMASK,\n            \"getUncompactedOracleTimestamp\"\n        );\n\n        if (blockNumber == 0) { revert EmptyCompactedTimestamp(index); }\n\n        return blockNumber;\n    }\n\n    // @dev validate the signer of a price\n    // @param minOracleBlockNumber the min block number used for the signed message hash\n    // @param maxOracleBlockNumber the max block number used for the signed message hash\n    // @param oracleTimestamp the timestamp used for the signed message hash\n    // @param blockHash the block hash used for the signed message hash\n    // @param token the token used for the signed message hash\n    // @param precision the precision used for the signed message hash\n    // @param minPrice the min price used for the signed message hash\n    // @param maxPrice the max price used for the signed message hash\n    // @param signature the signer's signature\n    // @param expectedSigner the address of the expected signer\n    function validateSigner(\n        bytes32 SALT,\n        ReportInfo memory info,\n        bytes memory signature,\n        address expectedSigner\n    ) internal pure {\n        bytes32 digest = ECDSA.toEthSignedMessageHash(\n            keccak256(abi.encode(\n                SALT,\n                info.minOracleBlockNumber,\n                info.maxOracleBlockNumber,\n                info.oracleTimestamp,\n                info.blockHash,\n                info.token,\n                info.tokenOracleType,\n                info.precision,\n                info.minPrice,\n                info.maxPrice\n            ))\n        );\n\n        address recoveredSigner = ECDSA.recover(digest, signature);\n        if (recoveredSigner != expectedSigner) {\n            revert InvalidSignature(recoveredSigner, expectedSigner);\n        }\n    }\n\n    function revertOracleBlockNumbersAreNotEqual(uint256[] memory oracleBlockNumbers, uint256 expectedBlockNumber) internal pure {\n        revert OracleBlockNumbersAreNotEqual(oracleBlockNumbers, expectedBlockNumber);\n    }\n\n    function revertOracleBlockNumbersAreSmallerThanRequired(uint256[] memory oracleBlockNumbers, uint256 expectedBlockNumber) internal pure {\n        revert OracleBlockNumbersAreSmallerThanRequired(oracleBlockNumbers, expectedBlockNumber);\n    }\n\n    function revertOracleBlockNumberNotWithinRange(\n        uint256[] memory minOracleBlockNumbers,\n        uint256[] memory maxOracleBlockNumbers,\n        uint256 blockNumber\n    ) internal pure {\n        revert OracleBlockNumberNotWithinRange(minOracleBlockNumbers, maxOracleBlockNumbers, blockNumber);\n    }\n\n    function isEmptyPriceError(bytes4 errorSelector) internal pure returns (bool) {\n        if (errorSelector == EmptyPrimaryPrice.selector) {\n            return true;\n        }\n\n        if (errorSelector == EmptySecondaryPrice.selector) {\n            return true;\n        }\n\n        if (errorSelector == EmptyLatestPrice.selector) {\n            return true;\n        }\n\n        if (errorSelector == EmptyCustomPrice.selector) {\n            return true;\n        }\n\n        return false;\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/oracle/Oracle.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"../role/RoleModule.sol\";\n\nimport \"./OracleStore.sol\";\nimport \"./OracleUtils.sol\";\nimport \"./IPriceFeed.sol\";\nimport \"../price/Price.sol\";\n\nimport \"../chain/Chain.sol\";\nimport \"../data/DataStore.sol\";\nimport \"../data/Keys.sol\";\nimport \"../event/EventEmitter.sol\";\nimport \"../event/EventUtils.sol\";\n\nimport \"../utils/Bits.sol\";\nimport \"../utils/Array.sol\";\nimport \"../utils/Precision.sol\";\nimport \"../utils/Cast.sol\";\n\n// @title Oracle\n// @dev Contract to validate and store signed values\ncontract Oracle is RoleModule {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableValues for EnumerableSet.AddressSet;\n    using Price for Price.Props;\n\n    using EventUtils for EventUtils.AddressItems;\n    using EventUtils for EventUtils.UintItems;\n    using EventUtils for EventUtils.IntItems;\n    using EventUtils for EventUtils.BoolItems;\n    using EventUtils for EventUtils.Bytes32Items;\n    using EventUtils for EventUtils.BytesItems;\n    using EventUtils for EventUtils.StringItems;\n\n    // @dev SetPricesCache struct used in setPrices to avoid stack too deep errors\n    // @param prevMinOracleBlockNumber the previous oracle block number of the loop\n    // @param priceIndex the current price index to retrieve from compactedMinPrices and compactedMaxPrices\n    // to construct the minPrices and maxPrices array\n    // @param signatureIndex the current signature index to retrieve from the signatures array\n    // @param maxPriceAge the max allowed age of price values\n    // @param minPriceIndex the index of the min price in minPrices for the current signer\n    // @param maxPriceIndex the index of the max price in maxPrices for the current signer\n    // @param minPrices the min prices\n    // @param maxPrices the max prices\n    struct SetPricesCache {\n        OracleUtils.ReportInfo info;\n        uint256 minBlockConfirmations;\n        uint256 maxPriceAge;\n        uint256 prevMinOracleBlockNumber;\n        uint256 priceIndex;\n        uint256 signatureIndex;\n        uint256 minPriceIndex;\n        uint256 maxPriceIndex;\n        uint256[] minPrices;\n        uint256[] maxPrices;\n    }\n\n    bytes32 public immutable SALT;\n\n    uint256 public constant SIGNER_INDEX_LENGTH = 16;\n    // subtract 1 as the first slot is used to store number of signers\n    uint256 public constant MAX_SIGNERS = 256 / SIGNER_INDEX_LENGTH - 1;\n    // signer indexes are recorded in a signerIndexFlags uint256 value to check for uniqueness\n    uint256 public constant MAX_SIGNER_INDEX = 256;\n\n    OracleStore public oracleStore;\n\n    // tokensWithPrices stores the tokens with prices that have been set\n    // this is used in clearAllPrices to help ensure that all token prices\n    // set in setPrices are cleared after use\n    EnumerableSet.AddressSet internal tokensWithPrices;\n    // prices for the same token can be sent multiple times in one txn\n    // the prices can be for different block numbers\n    // the first occurrence of the token's price will be stored in primaryPrices\n    // the second occurrence will be stored in secondaryPrices\n    mapping(address => Price.Props) public primaryPrices;\n    mapping(address => Price.Props) public secondaryPrices;\n    // customPrices can be used to store custom price values\n    // these prices will be cleared in clearAllPrices\n    mapping(address => Price.Props) public customPrices;\n\n    error EmptyTokens();\n    error InvalidBlockNumber(uint256 blockNumber);\n    error InvalidMinMaxBlockNumber(uint256 minOracleBlockNumber, uint256 maxOracleBlockNumber);\n    error MaxPriceAgeExceeded(uint256 oracleTimestamp);\n    error MinOracleSigners(uint256 oracleSigners, uint256 minOracleSigners);\n    error MaxOracleSigners(uint256 oracleSigners, uint256 maxOracleSigners);\n    error BlockNumbersNotSorted(uint256 minOracleBlockNumber, uint256 prevMinOracleBlockNumber);\n    error MinPricesNotSorted(address token, uint256 price, uint256 prevPrice);\n    error MaxPricesNotSorted(address token, uint256 price, uint256 prevPrice);\n    error EmptyPriceFeedMultiplier(address token);\n    error EmptyFeedPrice(address token);\n    error MaxSignerIndex(uint256 signerIndex, uint256 maxSignerIndex);\n    error DuplicateSigner(uint256 signerIndex);\n    error InvalidOraclePrice(address token);\n    error InvalidSignerMinMaxPrice(uint256 minPrice, uint256 maxPrice);\n    error InvalidMedianMinMaxPrice(uint256 minPrice, uint256 maxPrice);\n    error NonEmptyTokensWithPrices(uint256 tokensWithPricesLength);\n    error EmptyPriceFeed(address token);\n    error PriceAlreadySet(address token, uint256 minPrice, uint256 maxPrice);\n\n    constructor(\n        RoleStore _roleStore,\n        OracleStore _oracleStore\n    ) RoleModule(_roleStore) {\n        oracleStore = _oracleStore;\n\n        // sign prices with only the chainid and oracle name so that there is\n        // less config required in the oracle nodes\n        SALT = keccak256(abi.encode(block.chainid, \"xget-oracle-v1\"));\n    }\n\n    // @dev validate and store signed prices\n    //\n    // The setPrices function is used to set the prices of tokens in the Oracle contract.\n    // It accepts an array of tokens and a signerInfo parameter. The signerInfo parameter\n    // contains information about the signers that have signed the transaction to set the prices.\n    // The first 16 bits of the signerInfo parameter contain the number of signers, and the following\n    // bits contain the index of each signer in the oracleStore. The function checks that the number\n    // of signers is greater than or equal to the minimum number of signers required, and that\n    // the signer indices are unique and within the maximum signer index. The function then calls\n    // _setPrices and _setPricesFromPriceFeeds to set the prices of the tokens.\n    //\n    // Oracle prices are signed as a value together with a precision, this allows\n    // prices to be compacted as uint32 values.\n    //\n    // The signed prices represent the price of one unit of the token using a value\n    // with 30 decimals of precision.\n    //\n    // Representing the prices in this way allows for conversions between token amounts\n    // and fiat values to be simplified, e.g. to calculate the fiat value of a given\n    // number of tokens the calculation would just be: `token amount * oracle price`,\n    // to calculate the token amount for a fiat value it would be: `fiat value / oracle price`.\n    //\n    // The trade-off of this simplicity in calculation is that tokens with a small USD\n    // price and a lot of decimals may have precision issues it is also possible that\n    // a token's price changes significantly and results in requiring higher precision.\n    //\n    // ## Example 1\n    //\n    // The price of ETH is 5000, and ETH has 18 decimals.\n    //\n    // The price of one unit of ETH is `5000 / (10 ^ 18), 5 * (10 ^ -15)`.\n    //\n    // To handle the decimals, multiply the value by `(10 ^ 30)`.\n    //\n    // Price would be stored as `5000 / (10 ^ 18) * (10 ^ 30) => 5000 * (10 ^ 12)`.\n    //\n    // For gas optimization, these prices are sent to the oracle in the form of a uint8\n    // decimal multiplier value and uint32 price value.\n    //\n    // If the decimal multiplier value is set to 8, the uint32 value would be `5000 * (10 ^ 12) / (10 ^ 8) => 5000 * (10 ^ 4)`.\n    //\n    // With this config, ETH prices can have a maximum value of `(2 ^ 32) / (10 ^ 4) => 4,294,967,296 / (10 ^ 4) => 429,496.7296` with 4 decimals of precision.\n    //\n    // ## Example 2\n    //\n    // The price of BTC is 60,000, and BTC has 8 decimals.\n    //\n    // The price of one unit of BTC is `60,000 / (10 ^ 8), 6 * (10 ^ -4)`.\n    //\n    // Price would be stored as `60,000 / (10 ^ 8) * (10 ^ 30) => 6 * (10 ^ 26) => 60,000 * (10 ^ 22)`.\n    //\n    // BTC prices maximum value: `(2 ^ 64) / (10 ^ 2) => 4,294,967,296 / (10 ^ 2) => 42,949,672.96`.\n    //\n    // Decimals of precision: 2.\n    //\n    // ## Example 3\n    //\n    // The price of USDC is 1, and USDC has 6 decimals.\n    //\n    // The price of one unit of USDC is `1 / (10 ^ 6), 1 * (10 ^ -6)`.\n    //\n    // Price would be stored as `1 / (10 ^ 6) * (10 ^ 30) => 1 * (10 ^ 24)`.\n    //\n    // USDC prices maximum value: `(2 ^ 64) / (10 ^ 6) => 4,294,967,296 / (10 ^ 6) => 4294.967296`.\n    //\n    // Decimals of precision: 6.\n    //\n    // ## Example 4\n    //\n    // The price of DG is 0.00000001, and DG has 18 decimals.\n    //\n    // The price of one unit of DG is `0.00000001 / (10 ^ 18), 1 * (10 ^ -26)`.\n    //\n    // Price would be stored as `1 * (10 ^ -26) * (10 ^ 30) => 1 * (10 ^ 3)`.\n    //\n    // DG prices maximum value: `(2 ^ 64) / (10 ^ 11) => 4,294,967,296 / (10 ^ 11) => 0.04294967296`.\n    //\n    // Decimals of precision: 11.\n    //\n    // ## Decimal Multiplier\n    //\n    // The formula to calculate what the decimal multiplier value should be set to:\n    //\n    // Decimals: 30 - (token decimals) - (number of decimals desired for precision)\n    //\n    // - ETH: 30 - 18 - 4 => 8\n    // - BTC: 30 - 8 - 2 => 20\n    // - USDC: 30 - 6 - 6 => 18\n    // - DG: 30 - 18 - 11 => 1\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param params OracleUtils.SetPricesParams\n    function setPrices(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        OracleUtils.SetPricesParams memory params\n    ) external onlyController {\n        if (tokensWithPrices.length() != 0) {\n            revert NonEmptyTokensWithPrices(tokensWithPrices.length());\n        }\n\n        if (params.tokens.length == 0) { revert EmptyTokens(); }\n\n        // first 16 bits of signer info contains the number of signers\n        address[] memory signers = new address[](params.signerInfo & Bits.BITMASK_16);\n\n        if (signers.length < dataStore.getUint(Keys.MIN_ORACLE_SIGNERS)) {\n            revert MinOracleSigners(signers.length, dataStore.getUint(Keys.MIN_ORACLE_SIGNERS));\n        }\n\n        if (signers.length > MAX_SIGNERS) {\n            revert MaxOracleSigners(signers.length, MAX_SIGNERS);\n        }\n\n        uint256 signerIndexFlags;\n\n        for (uint256 i = 0; i < signers.length; i++) {\n            uint256 signerIndex = params.signerInfo >> (16 + 16 * i) & Bits.BITMASK_16;\n\n            if (signerIndex >= MAX_SIGNER_INDEX) {\n                revert MaxSignerIndex(signerIndex, MAX_SIGNER_INDEX);\n            }\n\n            uint256 signerIndexBit = 1 << signerIndex;\n\n            if (signerIndexFlags & signerIndexBit != 0) {\n                revert DuplicateSigner(signerIndex);\n            }\n\n            signerIndexFlags = signerIndexFlags | signerIndexBit;\n\n            signers[i] = oracleStore.getSigner(signerIndex);\n        }\n\n        _setPrices(\n            dataStore,\n            eventEmitter,\n            signers,\n            params\n        );\n\n        _setPricesFromPriceFeeds(dataStore, eventEmitter, params.priceFeedTokens);\n    }\n\n    // @dev set the primary price\n    // @param token the token to set the price for\n    // @param price the price value to set to\n    function setPrimaryPrice(address token, Price.Props memory price) external onlyController {\n        primaryPrices[token] = price;\n    }\n\n    // @dev set the secondary price\n    // @param token the token to set the price for\n    // @param price the price value to set to\n    function setSecondaryPrice(address token, Price.Props memory price) external onlyController {\n        secondaryPrices[token] = price;\n    }\n\n    // @dev set a custom price\n    // @param token the token to set the price for\n    // @param price the price value to set to\n    function setCustomPrice(address token, Price.Props memory price) external onlyController {\n        customPrices[token] = price;\n    }\n\n    // @dev clear all prices\n    function clearAllPrices() external onlyController {\n        uint256 length = tokensWithPrices.length();\n        for (uint256 i = 0; i < length; i++) {\n            address token = tokensWithPrices.at(0);\n            delete primaryPrices[token];\n            delete secondaryPrices[token];\n            delete customPrices[token];\n            tokensWithPrices.remove(token);\n        }\n    }\n\n    // @dev get the length of tokensWithPrices\n    // @return the length of tokensWithPrices\n    function getTokensWithPricesCount() external view returns (uint256) {\n        return tokensWithPrices.length();\n    }\n\n    // @dev get the tokens of tokensWithPrices for the specified indexes\n    // @param start the start index, the value for this index will be included\n    // @param end the end index, the value for this index will not be included\n    // @return the tokens of tokensWithPrices for the specified indexes\n    function getTokensWithPrices(uint256 start, uint256 end) external view returns (address[] memory) {\n        return tokensWithPrices.valuesAt(start, end);\n    }\n\n    // @dev get the primary price of a token\n    // @param token the token to get the price for\n    // @return the primary price of a token\n    function getPrimaryPrice(address token) external view returns (Price.Props memory) {\n        if (token == address(0)) { return Price.Props(0, 0); }\n\n        Price.Props memory price = primaryPrices[token];\n        if (price.isEmpty()) {\n            revert OracleUtils.EmptyPrimaryPrice(token);\n        }\n\n        return price;\n    }\n\n    // @dev get the secondary price of a token\n    // @param token the token to get the price for\n    // @return the secondary price of a token\n    function getSecondaryPrice(address token) external view returns (Price.Props memory) {\n        if (token == address(0)) { return Price.Props(0, 0); }\n\n        Price.Props memory price = secondaryPrices[token];\n        if (price.isEmpty()) {\n            revert OracleUtils.EmptySecondaryPrice(token);\n        }\n\n        return price;\n    }\n\n    // @dev get the latest price of a token\n    // @param token the token to get the price for\n    // @return the latest price of a token\n    function getLatestPrice(address token) external view returns (Price.Props memory) {\n        if (token == address(0)) { return Price.Props(0, 0); }\n\n        Price.Props memory secondaryPrice = secondaryPrices[token];\n\n        if (!secondaryPrice.isEmpty()) {\n            return secondaryPrice;\n        }\n\n        Price.Props memory primaryPrice = primaryPrices[token];\n        if (!primaryPrice.isEmpty()) {\n            return primaryPrice;\n        }\n\n        revert OracleUtils.EmptyLatestPrice(token);\n    }\n\n    // @dev get the custom price of a token\n    // @param token the token to get the price for\n    // @return the custom price of a token\n    function getCustomPrice(address token) external view returns (Price.Props memory) {\n        Price.Props memory price = customPrices[token];\n        if (price.isEmpty()) {\n            revert OracleUtils.EmptyCustomPrice(token);\n        }\n        return price;\n    }\n\n    // @dev get the price feed address for a token\n    // @param dataStore DataStore\n    // @param token the token to get the price feed for\n    // @return the price feed for the token\n    function getPriceFeed(DataStore dataStore, address token) public view returns (IPriceFeed) {\n        address priceFeedAddress = dataStore.getAddress(Keys.priceFeedKey(token));\n        if (priceFeedAddress == address(0)) {\n            revert EmptyPriceFeed(token);\n        }\n\n        return IPriceFeed(priceFeedAddress);\n    }\n\n    // @dev get the stable price of a token\n    // @param dataStore DataStore\n    // @param token the token to get the price for\n    // @return the stable price of the token\n    function getStablePrice(DataStore dataStore, address token) public view returns (uint256) {\n        return dataStore.getUint(Keys.stablePriceKey(token));\n    }\n\n    // @dev get the multiplier value to convert the external price feed price to the price of 1 unit of the token\n    // represented with 30 decimals\n    // for example, if USDC has 6 decimals and a price of 1 USD, one unit of USDC would have a price of\n    // 1 / (10 ^ 6) * (10 ^ 30) => 1 * (10 ^ 24)\n    // if the external price feed has 8 decimals, the price feed price would be 1 * (10 ^ 8)\n    // in this case the priceFeedMultiplier should be 10 ^ 46\n    // the conversion of the price feed price would be 1 * (10 ^ 8) * (10 ^ 46) / (10 ^ 30) => 1 * (10 ^ 24)\n    // formula for decimals for price feed multiplier: 60 - (external price feed decimals) - (token decimals)\n    //\n    // @param dataStore DataStore\n    // @param token the token to get the price feed multiplier for\n    // @return the price feed multipler\n    function getPriceFeedMultiplier(DataStore dataStore, address token) public view returns (uint256) {\n        uint256 multiplier = dataStore.getUint(Keys.priceFeedMultiplierKey(token));\n\n        if (multiplier == 0) {\n            revert EmptyPriceFeedMultiplier(token);\n        }\n\n        return multiplier;\n    }\n\n    // @dev validate and set prices\n    // The _setPrices() function is a helper function that is called by the\n    // setPrices() function. It takes in several parameters: a DataStore contract\n    // instance, an EventEmitter contract instance, an array of signers, and an\n    // OracleUtils.SetPricesParams struct containing information about the tokens\n    // and their prices.\n    // The function first initializes a SetPricesCache struct to store some temporary\n    // values that will be used later in the function. It then loops through the array\n    // of tokens and sets the corresponding values in the cache struct. For each token,\n    // the function also loops through the array of signers and validates the signatures\n    // for the min and max prices for that token. If the signatures are valid, the\n    // function calculates the median min and max prices and sets them in the DataStore\n    // contract.\n    // Finally, the function emits an event to signal that the prices have been set.\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param signers the signers of the prices\n    // @param params OracleUtils.SetPricesParams\n    function _setPrices(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        address[] memory signers,\n        OracleUtils.SetPricesParams memory params\n    ) internal {\n        SetPricesCache memory cache;\n        cache.minBlockConfirmations = dataStore.getUint(Keys.MIN_ORACLE_BLOCK_CONFIRMATIONS);\n        cache.maxPriceAge = dataStore.getUint(Keys.MAX_ORACLE_PRICE_AGE);\n\n        for (uint256 i = 0; i < params.tokens.length; i++) {\n            cache.info.minOracleBlockNumber = OracleUtils.getUncompactedOracleBlockNumber(params.compactedMinOracleBlockNumbers, i);\n            cache.info.maxOracleBlockNumber = OracleUtils.getUncompactedOracleBlockNumber(params.compactedMaxOracleBlockNumbers, i);\n\n            if (cache.info.minOracleBlockNumber > cache.info.maxOracleBlockNumber) {\n                revert InvalidMinMaxBlockNumber(cache.info.minOracleBlockNumber, cache.info.maxOracleBlockNumber);\n            }\n\n            cache.info.oracleTimestamp = OracleUtils.getUncompactedOracleTimestamp(params.compactedOracleTimestamps, i);\n\n            if (cache.info.minOracleBlockNumber > Chain.currentBlockNumber()) {\n                revert InvalidBlockNumber(cache.info.minOracleBlockNumber);\n            }\n\n            if (cache.info.oracleTimestamp + cache.maxPriceAge < Chain.currentTimestamp()) {\n                revert MaxPriceAgeExceeded(cache.info.oracleTimestamp);\n            }\n\n            // block numbers must be in ascending order\n            if (cache.info.minOracleBlockNumber < cache.prevMinOracleBlockNumber) {\n                revert BlockNumbersNotSorted(cache.info.minOracleBlockNumber, cache.prevMinOracleBlockNumber);\n            }\n            cache.prevMinOracleBlockNumber = cache.info.minOracleBlockNumber;\n\n            cache.info.blockHash = bytes32(0);\n            if (Chain.currentBlockNumber() - cache.info.minOracleBlockNumber <= cache.minBlockConfirmations) {\n                cache.info.blockHash = Chain.getBlockHash(cache.info.minOracleBlockNumber);\n            }\n\n            cache.info.token = params.tokens[i];\n            cache.info.precision = 10 ** OracleUtils.getUncompactedDecimal(params.compactedDecimals, i);\n            cache.info.tokenOracleType = dataStore.getBytes32(Keys.oracleTypeKey(cache.info.token));\n\n            cache.minPrices = new uint256[](signers.length);\n            cache.maxPrices = new uint256[](signers.length);\n\n            for (uint256 j = 0; j < signers.length; j++) {\n                cache.priceIndex = i * signers.length + j;\n                cache.minPrices[j] = OracleUtils.getUncompactedPrice(params.compactedMinPrices, cache.priceInd"
    }
  ]
}