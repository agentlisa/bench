{
  "Title": "H-2: All funds can be stolen from FixedStrikeOptionTeller using a token with malicious decimals",
  "Content": "# Issue H-2: All funds can be stolen from FixedStrikeOptionTeller using a token with malicious decimals \n\nSource: https://github.com/sherlock-audit/2023-06-bond-judging/issues/90 \n\n## Found by \nJuntao, berndartmueller, bin2chen, ctf\\_sec\n## Summary\n\n`FixedStrikeOptionTeller` is a single contract which deploys multiple option tokens. Hence this single contract holds significant payout/quote tokens as collateral. Also the `deploy`, `create` & `exercise` functions of this contract can be called by anyone.\n\nThis mechanism can be exploited to drain `FixedStrikeOptionTeller` of all tokens.\n\n\n## Vulnerability Detail\nThis is how the create functions looks like:\n```solidity\n    function create(\n        FixedStrikeOptionToken optionToken_,\n        uint256 amount_\n    ) external override nonReentrant {\n        ...\n        if (call) {\n            ...\n        } else {\n            uint256 quoteAmount = amount_.mulDiv(strikePrice, 10 ** payoutToken.decimals());\n            ...\n            quoteToken.safeTransferFrom(msg.sender, address(this), quoteAmount);\n            ...\n        }\n\n        optionToken.mint(msg.sender, amount_);\n    }\n```\n\nexercise function:\n```solidity\n    function exercise(\n        FixedStrikeOptionToken optionToken_,\n        uint256 amount_\n    ) external override nonReentrant {\n        ...\n        uint256 quoteAmount = amount_.mulDiv(strikePrice, 10 ** payoutToken.decimals());\n\n        if (msg.sender != receiver) {\n            ...\n        }\n\n        optionToken.burn(msg.sender, amount_);\n\n        if (call) {\n            ...\n        } else {\n            quoteToken.safeTransfer(msg.sender, quoteAmount);\n        }\n    }\n```\n\nConsider this attack scenario:\n\nLet's suppose the `FixedStrikeOptionTeller` holds some DAI tokens.\n\n- An attacker can create a malicious payout token of which he can control the `decimals`.\n\n- The attacker calls `deploy` to create an option token with malicious payout token and DAI as quote token and `put` option type\n\n- Make `payoutToken.decimals` return a large number and call `FixedStrikeOptionTeller.create` with input X. [Here `quoteAmount` will be calculated as `0`](https://github.com/sherlock-audit/2023-06-bond/blob/fce1809f83728561dc75078d41ead6d60e15d065/options/src/fixed-strike/FixedStrikeOptionTeller.sol#L283). \n\n```solidity\n// Calculate amount of quote tokens required to mint\nuint256 quoteAmount = amount_.mulDiv(strikePrice, 10 ** payoutToken.decimals());\n\n// Transfer quote tokens from user\n// Check that amount received is not less than amount expected\n// Handles edge cases like fee-on-transfer tokens (which are not supported)\nuint256 startBalance = quoteToken.balanceOf(address(this));\nquoteToken.safeTransferFrom(msg.sender, address(this), quoteAmount);\n```\n\nSo 0 DAI will be pulled from the attacker's account but he will receive X option token.\n\n- Make `payoutToken.decimals` return a small value and call `FixedStrikeOptionTeller.exercise` with X input. Here `quoteAmount` will be calculated as a very high number (which represents number of DAI tokens). So he will receive huge amount of DAI against his X option tokens when [exercise the option](https://github.com/sherlock-audit/2023-06-bond/blob/fce1809f83728561dc75078d41ead6d60e15d065/options/src/fixed-strike/FixedStrikeOptionTeller.sol#L339) or when [reclaim the token](https://github.com/sherlock-audit/2023-06-bond/blob/fce1809f83728561dc75078d41ead6d60e15d065/options/src/fixed-strike/FixedStrikeOptionTeller.sol#L434)\n\n```solidity\n// Transfer remaining collateral to receiver\nuint256 amount = optionToken.totalSupply();\nif (call) {\n\tpayoutToken.safeTransfer(receiver, amount);\n} else {\n\t// Calculate amount of quote tokens equivalent to amount at strike price\n\tuint256 quoteAmount = amount.mulDiv(strikePrice, 10 ** payoutToken.decimals());\n\tquoteToken.safeTransfer(receiver, quoteAmount);\n}\n```\n\nHence, the attacker was able to drain all DAI tokens from the `FixedStrikeOptionTeller` contract. The same mechanism can be repeated to drain all other ERC20 tokens from the `FixedStrikeOptionTeller` contract by changing the return value of the decimal external call\n\n## Impact\n\nAnyone can drain `FixedStrikeOptionTeller` contract of all ERC20 tokens. The cost of attack is negligible (only gas cost). \n\nHigh impact, high likelyhood.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-06-bond/blob/main/options/src/fixed-strike/FixedStrikeOptionTeller.sol#L283\n\nhttps://github.com/sherlock-audit/2023-06-bond/blob/main/options/src/fixed-strike/FixedStrikeOptionTeller.sol#L339\n\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider storing the `payoutToken.decimals` value locally instead of fetching it real-time on all `exercise` or `reclaim` calls.\n\nor support payout token and quote token whitelist, if the payout token and quote token are permissionless created, there will always be high risk\n\n\n\n\n## Discussion\n\n**ctf-sec**\n\nhttps://github.com/sherlock-audit/2023-06-bond-judging/issues/8 is the duplicate of this issue\n\n**Oighty**\n\nAgree with this issue. The simplest solution seems to be stored the decimal values used when the option token is deployed.\n\n**Oighty**\n\nFix implemented at https://github.com/Bond-Protocol/options/pull/3\n\n**ctf-sec**\n\nThis is a big one and a important one, will look into the fix\n\n**ctf-sec**\n\nThe fix looks good, the decimals call is properly cached, I highly recommend adding a test to make sure it is working as intended\n\n**Oighty**\n\nI added some tests to confirm the cached decimal behavior on create and exercise to the PR.\n\n**ctf-sec**\n\nThanks for adding the test cases! All good!\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/99",
  "Code": [
    {
      "filename": "options/src/fixed-strike/FixedStrikeOptionTeller.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {ClonesWithImmutableArgs} from \"src/lib/clones/ClonesWithImmutableArgs.sol\";\n\nimport {IFixedStrikeOptionTeller, IOptionTeller} from \"src/interfaces/IFixedStrikeOptionTeller.sol\";\nimport {FixedStrikeOptionToken} from \"src/fixed-strike/FixedStrikeOptionToken.sol\";\n\nimport {TransferHelper} from \"src/lib/TransferHelper.sol\";\nimport {FullMath} from \"src/lib/FullMath.sol\";\n\n/// @title Fixed Strike Option Teller\n/// @notice Fixed Strike Option Teller Contract\n/// @dev Option Teller contracts handle the deployment, creation, and exercise of option tokens.\n///      Option Tokens are ERC20 tokens that represent the right to buy (call) or sell (put) a fixed\n///      amount of an asset (payout token) for an amount of another asset (quote token) between two\n///      timestamps (eligible and expiry). Option Tokens are denominated in units of the payout token\n///      and are created at a 1:1 ratio for the amount of payout tokens to buy or sell.\n///      The amount of quote tokens required to exercise (call) or collateralize (put) an option token\n///      is called the strike price. Strike prices are denominated in units of the quote token.\n///      The Fixed Strike Option Teller implementation creates option tokens that have a fixed strike\n///      price that is set at the time of creation.\n///\n///      In order to create option tokens, an issuer must deploy the specific token configuration on\n///      the teller, and then provide collateral to the teller to mint option tokens. The collateral is\n///      required to guarantee that the option tokens can be exercised. The collateral required depends on\n///      the option type. For call options, the collateral required is an amount of payout tokens equivalent\n///      to the amount of option tokens being minted. For put options, the collateral required is an amount\n///      of quote tokens equivalent to the amount of option tokens being minted multipled by the strike price.\n///      As the name \"option\" suggests, the holder of an option token has the right, but not the obligation,\n///      to exercise the option token within the eligible time window. If the option token is not exercised,\n///      the designated \"receiver\" of the option token exercise proceeds can reclaim the collateral after\n///      the expiry timestamp. If an option token is exercised, the holder receives the collateral and the\n///      receiver receives the exercise proceeds.\n///\n/// @author Bond Protocol\ncontract FixedStrikeOptionTeller is IFixedStrikeOptionTeller, Auth, ReentrancyGuard {\n    using TransferHelper for ERC20;\n    using FullMath for uint256;\n    using ClonesWithImmutableArgs for address;\n\n    /* ========== ERRORS ========== */\n\n    error Teller_NotAuthorized();\n    error Teller_TokenDoesNotExist(bytes32 optionHash);\n    error Teller_UnsupportedToken(address token);\n    error Teller_InvalidParams(uint256 index, bytes value);\n    error Teller_OptionExpired(uint48 expiry);\n    error Teller_NotEligible(uint48 eligible);\n    error Teller_NotExpired(uint48 expiry);\n    error Teller_PriceOutOfBounds();\n\n    /* ========== EVENTS ========== */\n    event WroteOption(uint256 indexed id, address indexed referrer, uint256 amount, uint256 payout);\n    event OptionTokenCreated(\n        FixedStrikeOptionToken optionToken,\n        ERC20 indexed payoutToken,\n        ERC20 quoteToken,\n        uint48 eligible,\n        uint48 indexed expiry,\n        address indexed receiver,\n        bool call,\n        uint256 strikePrice\n    );\n\n    /* ========== STATE VARIABLES ========== */\n\n    /// @notice Fee paid to protocol when options are exercised in basis points (3 decimal places).\n    uint48 public protocolFee;\n\n    /// @notice Base value used to scale fees. 1e5 = 100%\n    uint48 public constant FEE_DECIMALS = 1e5; // one percent equals 1000.\n\n    /// @notice FixedStrikeOptionToken reference implementation (deployed on creation to clone from)\n    FixedStrikeOptionToken public immutable optionTokenImplementation;\n\n    /// @notice Minimum duration an option must be eligible to exercise (in seconds)\n    uint48 public minOptionDuration;\n\n    /// @notice Fees earned by protocol, by token\n    mapping(ERC20 => uint256) public fees;\n\n    /// @notice Fixed strike option tokens (hash of parameters to address)\n    mapping(bytes32 => FixedStrikeOptionToken) public optionTokens;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /// @param guardian_    Address of the guardian for Auth\n    /// @param authority_   Address of the authority for Auth\n    constructor(address guardian_, Authority authority_) Auth(guardian_, authority_) {\n        // Explicitly setting protocol fee to zero initially\n        protocolFee = 0;\n\n        // Set minimum option duration initially to 1 day (the absolute minimum given timestamp rounding)\n        minOptionDuration = uint48(1 days);\n\n        // Deploy option token implementation that clones proxy to\n        optionTokenImplementation = new FixedStrikeOptionToken();\n    }\n\n    /* ========== CREATE OPTION TOKENS ========== */\n\n    /// @inheritdoc IFixedStrikeOptionTeller\n    function deploy(\n        ERC20 payoutToken_,\n        ERC20 quoteToken_,\n        uint48 eligible_,\n        uint48 expiry_,\n        address receiver_,\n        bool call_,\n        uint256 strikePrice_\n    ) external override nonReentrant returns (FixedStrikeOptionToken) {\n        // If eligible is zero, use current timestamp\n        if (eligible_ == 0) eligible_ = uint48(block.timestamp);\n\n        // Eligible and Expiry are rounded to the nearest day at 0000 UTC (in seconds) since\n        // option tokens are only unique to a day, not a specific timestamp.\n        eligible_ = uint48(eligible_ / 1 days) * 1 days;\n        expiry_ = uint48(expiry_ / 1 days) * 1 days;\n\n        // Revert if eligible is in the past, we do this to avoid duplicates tokens with the same parameters otherwise\n        // Truncate block.timestamp to the nearest day for comparison\n        if (eligible_ < uint48(block.timestamp / 1 days) * 1 days)\n            revert Teller_InvalidParams(2, abi.encodePacked(eligible_));\n\n        // Revert if the difference between eligible and expiry is less than min duration or eligible is after expiry\n        // Don't need to check expiry against current timestamp since eligible is already checked\n        if (eligible_ > expiry_ || expiry_ - eligible_ < minOptionDuration)\n            revert Teller_InvalidParams(3, abi.encodePacked(expiry_));\n\n        // Revert if any addresses are zero or the tokens are not contracts\n        if (address(payoutToken_) == address(0) || address(payoutToken_).code.length == 0)\n            revert Teller_InvalidParams(0, abi.encodePacked(payoutToken_));\n        if (address(quoteToken_) == address(0) || address(quoteToken_).code.length == 0)\n            revert Teller_InvalidParams(1, abi.encodePacked(quoteToken_));\n        if (receiver_ == address(0)) revert Teller_InvalidParams(4, abi.encodePacked(receiver_));\n\n        // Revert if strike price is zero or out of bounds\n        int8 priceDecimals = _getPriceDecimals(strikePrice_, quoteToken_.decimals()); // @audit determine if this external call to provided quote token is an issue\n        if (strikePrice_ == 0 || priceDecimals > int8(9) || priceDecimals < int8(-9))\n            revert Teller_InvalidParams(6, abi.encodePacked(strikePrice_));\n\n        // Create option token if one doesn't already exist\n        // Timestamps are truncated above to give canonical version of hash\n        bytes32 optionHash = _getOptionTokenHash(\n            payoutToken_,\n            quoteToken_,\n            eligible_,\n            expiry_,\n            receiver_,\n            call_,\n            strikePrice_\n        );\n\n        FixedStrikeOptionToken optionToken = optionTokens[optionHash];\n\n        // If option token doesn't exist, deploy it\n        if (address(optionToken) == address(0)) {\n            optionToken = _deploy(\n                payoutToken_,\n                quoteToken_,\n                eligible_,\n                expiry_,\n                receiver_,\n                call_,\n                strikePrice_\n            );\n\n            // Set the domain separator for the option token on creation to save gas on permit approvals\n            optionToken.updateDomainSeparator();\n\n            // Store option token against computed hash\n            optionTokens[optionHash] = optionToken;\n\n            // Emit event\n            emit OptionTokenCreated(\n                optionToken,\n                payoutToken_,\n                quoteToken_,\n                eligible_,\n                expiry_,\n                receiver_,\n                call_,\n                strikePrice_\n            );\n        }\n        return optionToken;\n    }\n\n    function _deploy(\n        ERC20 payoutToken_,\n        ERC20 quoteToken_,\n        uint48 eligible_,\n        uint48 expiry_,\n        address receiver_,\n        bool call_,\n        uint256 strikePrice_\n    ) internal returns (FixedStrikeOptionToken) {\n        // All data has been validated prior to entering this function\n        // Option token does not exist yet\n\n        // Get name and symbol for option token\n        (bytes32 name, bytes32 symbol) = _getNameAndSymbol(\n            payoutToken_,\n            quoteToken_,\n            expiry_,\n            call_,\n            strikePrice_\n        );\n\n        // Deploy option token\n        return\n            FixedStrikeOptionToken(\n                address(optionTokenImplementation).clone(\n                    abi.encodePacked(\n                        name,\n                        symbol,\n                        uint8(payoutToken_.decimals()),\n                        payoutToken_,\n                        quoteToken_,\n                        eligible_,\n                        expiry_,\n                        receiver_,\n                        call_,\n                        address(this),\n                        strikePrice_\n                    )\n                )\n            );\n    }\n\n    /// @inheritdoc IFixedStrikeOptionTeller\n    function create(\n        FixedStrikeOptionToken optionToken_,\n        uint256 amount_\n    ) external override nonReentrant {\n        // Load option parameters\n        (\n            ERC20 payoutToken,\n            ERC20 quoteToken,\n            uint48 eligible,\n            uint48 expiry,\n            address receiver,\n            bool call,\n            uint256 strikePrice\n        ) = optionToken_.getOptionParameters();\n\n        // Retrieve the internally stored option token with this configuration\n        // Reverts internally if token doesn't exist\n        FixedStrikeOptionToken optionToken = getOptionToken(\n            payoutToken,\n            quoteToken,\n            eligible,\n            expiry,\n            receiver,\n            call,\n            strikePrice\n        );\n\n        // Revert if provided token address does not match stored token address\n        if (optionToken_ != optionToken) revert Teller_UnsupportedToken(address(optionToken_));\n\n        // Revert if expiry is in the past\n        if (uint256(expiry) < block.timestamp) revert Teller_OptionExpired(expiry);\n\n        // Transfer in collateral\n        // If call option, transfer in payout tokens equivalent to the amount of option tokens being issued\n        // If put option, transfer in quote tokens equivalent to the amount of option tokens being issued * strike price\n        if (call) {\n            // Transfer payout tokens from user\n            // Check that amount received is not less than amount expected\n            // Handles edge cases like fee-on-transfer tokens (which are not supported)\n            uint256 startBalance = payoutToken.balanceOf(address(this));\n            payoutToken.safeTransferFrom(msg.sender, address(this), amount_);\n            uint256 endBalance = payoutToken.balanceOf(address(this));\n            if (endBalance < startBalance + amount_)\n                revert Teller_UnsupportedToken(address(payoutToken));\n        } else {\n            // Calculate amount of quote tokens required to mint\n            uint256 quoteAmount = amount_.mulDiv(strikePrice, 10 ** payoutToken.decimals());\n\n            // Transfer quote tokens from user\n            // Check that amount received is not less than amount expected\n            // Handles edge cases like fee-on-transfer tokens (which are not supported)\n            uint256 startBalance = quoteToken.balanceOf(address(this));\n            quoteToken.safeTransferFrom(msg.sender, address(this), quoteAmount);\n            uint256 endBalance = quoteToken.balanceOf(address(this));\n            if (endBalance < startBalance + quoteAmount)\n                revert Teller_UnsupportedToken(address(quoteToken));\n        }\n\n        // Mint new option tokens to sender\n        optionToken.mint(msg.sender, amount_);\n    }\n\n    /* ========== EXERCISE OPTION TOKENS ========== */\n\n    /// @inheritdoc IFixedStrikeOptionTeller\n    function exercise(\n        FixedStrikeOptionToken optionToken_,\n        uint256 amount_\n    ) external override nonReentrant {\n        // Load option parameters\n        (\n            ERC20 payoutToken,\n            ERC20 quoteToken,\n            uint48 eligible,\n            uint48 expiry,\n            address receiver,\n            bool call,\n            uint256 strikePrice\n        ) = optionToken_.getOptionParameters();\n\n        // Retrieve the internally stored option token with this configuration\n        // Reverts internally if token doesn't exist\n        FixedStrikeOptionToken optionToken = getOptionToken(\n            payoutToken,\n            quoteToken,\n            eligible,\n            expiry,\n            receiver,\n            call,\n            strikePrice\n        );\n\n        // Revert if token does not match stored token\n        if (optionToken_ != optionToken) revert Teller_UnsupportedToken(address(optionToken_));\n\n        // Validate that option token is eligible to be exercised\n        if (uint48(block.timestamp) < eligible) revert Teller_NotEligible(eligible);\n\n        // Validate that option token is not expired\n        if (uint48(block.timestamp) >= expiry) revert Teller_OptionExpired(expiry);\n\n        // Calculate amount of quote tokens equivalent to amount at strike price\n        uint256 quoteAmount = amount_.mulDiv(strikePrice, 10 ** payoutToken.decimals());\n\n        // If not receiver, require payment\n        if (msg.sender != receiver) {\n            // If call, transfer in quote tokens equivalent to the amount of option tokens being exercised * strike price\n            // If put, transfer in payout tokens equivalent to the amount of option tokens being exercised\n            if (call) {\n                // Calculate protocol fee\n                uint256 fee = (quoteAmount * protocolFee) / FEE_DECIMALS;\n                fees[quoteToken] += fee;\n\n                // Transfer proceeds from user\n                // Check balances before and after transfer to ensure that the correct amount was transferred\n                // @audit this does enable potential malicious option tokens that can't be exercised\n                // However, we view it as a \"buyer beware\" situation that can handled on the front-end\n                uint256 startBalance = quoteToken.balanceOf(address(this));\n                quoteToken.safeTransferFrom(msg.sender, address(this), quoteAmount);\n                uint256 endBalance = quoteToken.balanceOf(address(this));\n                if (endBalance < startBalance + quoteAmount)\n                    revert Teller_UnsupportedToken(address(quoteToken));\n\n                // Transfer proceeds minus fee to receiver\n                quoteToken.safeTransfer(receiver, quoteAmount - fee);\n            } else {\n                // Calculate protocol fee (in payout tokens)\n                uint256 fee = (amount_ * protocolFee) / FEE_DECIMALS;\n                fees[payoutToken] += fee;\n\n                // Transfer proceeds from user\n                // Check balances before and after transfer to ensure that the correct amount was transferred\n                // @audit this does enable potential malicious option tokens that can't be exercised\n                // However, we view it as a \"buyer beware\" situation that can handled on the front-end\n                uint256 startBalance = payoutToken.balanceOf(address(this));\n                payoutToken.safeTransferFrom(msg.sender, address(this), amount_);\n                uint256 endBalance = payoutToken.balanceOf(address(this));\n                if (endBalance < startBalance + amount_)\n                    revert Teller_UnsupportedToken(address(payoutToken));\n\n                // Transfer proceeds minus fee to receiver\n                payoutToken.safeTransfer(receiver, amount_ - fee);\n            }\n        }\n\n        // Burn option tokens\n        optionToken.burn(msg.sender, amount_);\n\n        if (call) {\n            // Transfer payout tokens to user\n            payoutToken.safeTransfer(msg.sender, amount_);\n        } else {\n            // Transfer quote tokens to user\n            quoteToken.safeTransfer(msg.sender, quoteAmount);\n        }\n    }\n\n    /// @inheritdoc IFixedStrikeOptionTeller\n    function reclaim(FixedStrikeOptionToken optionToken_) external override nonReentrant {\n        // Load option parameters\n        (\n            ERC20 payoutToken,\n            ERC20 quoteToken,\n            uint48 eligible,\n            uint48 expiry,\n            address receiver,\n            bool call,\n            uint256 strikePrice\n        ) = optionToken_.getOptionParameters();\n\n        // Retrieve the internally stored option token with this configuration\n        // Reverts internally if token doesn't exist\n        FixedStrikeOptionToken optionToken = getOptionToken(\n            payoutToken,\n            quoteToken,\n            eligible,\n            expiry,\n            receiver,\n            call,\n            strikePrice\n        );\n\n        // Revert if token does not match stored token\n        if (optionToken_ != optionToken) revert Teller_UnsupportedToken(address(optionToken_));\n\n        // Revert if not expired\n        if (uint48(block.timestamp) < expiry) revert Teller_NotExpired(expiry);\n\n        // Revert if caller is not receiver\n        if (msg.sender != receiver) revert Teller_NotAuthorized();\n\n        // Transfer remaining collateral to receiver\n        uint256 amount = optionToken.totalSupply();\n        if (call) {\n            payoutToken.safeTransfer(receiver, amount);\n        } else {\n            // Calculate amount of quote tokens equivalent to amount at strike price\n            uint256 quoteAmount = amount.mulDiv(strikePrice, 10 ** payoutToken.decimals());\n            quoteToken.safeTransfer(receiver, quoteAmount);\n        }\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /// @inheritdoc IFixedStrikeOptionTeller\n    function exerciseCost(\n        FixedStrikeOptionToken optionToken_,\n        uint256 amount_\n    ) external view returns (ERC20, uint256) {\n        // Load option parameters\n        (\n            ERC20 payoutToken,\n            ERC20 quoteToken,\n            uint48 eligible,\n            uint48 expiry,\n            address receiver,\n            bool call,\n            uint256 strikePrice\n        ) = optionToken_.getOptionParameters();\n\n        // Retrieve the internally stored option token with this configuration\n        // Reverts internally if token doesn't exist\n        FixedStrikeOptionToken optionToken = getOptionToken(\n            payoutToken,\n            quoteToken,\n            eligible,\n            expiry,\n            receiver,\n            call,\n            strikePrice\n        );\n\n        // Revert if token does not match stored token\n        if (optionToken_ != optionToken) revert Teller_UnsupportedToken(address(optionToken_));\n\n        // If option is a call, calculate quote tokens required to exercise\n        // If option is a put, exercise cost is the same as the option token amount in payout tokens\n        if (call) {\n            return (quoteToken, amount_.mulDiv(strikePrice, 10 ** payoutToken.decimals()));\n        } else {\n            return (payoutToken, amount_);\n        }\n    }\n\n    /// @inheritdoc IFixedStrikeOptionTeller\n    function getOptionToken(\n        ERC20 payoutToken_,\n        ERC20 quoteToken_,\n        uint48 eligible_,\n        uint48 expiry_,\n        address receiver_,\n        bool call_,\n        uint256 strikePrice_\n    ) public view returns (FixedStrikeOptionToken) {\n        // Eligible and Expiry are rounded to the nearest day at 0000 UTC (in seconds) since\n        // option tokens are only unique to a day, not a specific timestamp.\n        uint48 eligible = uint48(eligible_ / 1 days) * 1 days;\n        uint48 expiry = uint48(expiry_ / 1 days) * 1 days;\n\n        // Calculate a hash from the normalized inputs\n        bytes32 optionHash = _getOptionTokenHash(\n            payoutToken_,\n            quoteToken_,\n            eligible,\n            expiry,\n            receiver_,\n            call_,\n            strikePrice_\n        );\n\n        FixedStrikeOptionToken optionToken = optionTokens[optionHash];\n\n        // Revert if token does not exist\n        if (address(optionToken) == address(0)) revert Teller_TokenDoesNotExist(optionHash);\n\n        return optionToken;\n    }\n\n    /// @inheritdoc IFixedStrikeOptionTeller\n    function getOptionTokenHash(\n        ERC20 payoutToken_,\n        ERC20 quoteToken_,\n        uint48 eligible_,\n        uint48 expiry_,\n        address receiver_,\n        bool call_,\n        uint256 strikePrice_\n    ) external pure returns (bytes32) {\n        // Eligible and Expiry are rounded to the nearest day at 0000 UTC (in seconds) since\n        // option tokens are only unique to a day, not a specific timestamp.\n        uint48 eligible = uint48(eligible_ / 1 days) * 1 days;\n        uint48 expiry = uint48(expiry_ / 1 days) * 1 days;\n\n        return\n            _getOptionTokenHash(\n                payoutToken_,\n                quoteToken_,\n                eligible,\n                expiry,\n                receiver_,\n                call_,\n                strikePrice_\n            );\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function _getOptionTokenHash(\n        ERC20 payoutToken_,\n        ERC20 quoteToken_,\n        uint48 eligible_,\n        uint48 expiry_,\n        address receiver_,\n        bool call_,\n        uint256 strikePrice_\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    payoutToken_,\n                    quoteToken_,\n                    eligible_,\n                    expiry_,\n                    receiver_,\n                    call_,\n                    strikePrice_\n                )\n            );\n    }\n\n    /// @notice Derive name and symbol of option token\n    function _getNameAndSymbol(\n        ERC20 payoutToken_,\n        ERC20 quoteToken_,\n        uint256 expiry_,\n        bool call_,\n        uint256 strikePrice_\n    ) internal view returns (bytes32, bytes32) {\n        // Examples\n        // WETH call option expiring on 2100-01-01 with strike price of 10_010.50 DAI would be formatted as:\n        // Name: \"WETH/DAI C 1.001e4 2100-01-01\"\n        // Symbol: \"WETH/DAI-C-21000101\"\n        //\n        // WETH put option expiring on 2100-01-01 with strike price of 10.546 DAI would be formatted as:\n        // Name: \"WETH/DAI P 1.054e1 2100-01-01\"\n        // Symbol: \"WETH/DAI-P-21000101\"\n\n        // Get the date format from the expiry timestamp.\n        // Convert a number of days into a human-readable date, courtesy of BokkyPooBah.\n        // Source: https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary/blob/master/contracts/BokkyPooBahsDateTimeLibrary.sol\n        string memory yearStr;\n        string memory monthStr;\n        string memory dayStr;\n        {\n            int256 __days = int256(expiry_ / 1 days);\n\n            int256 num1 = __days + 68569 + 2440588; // 2440588 = OFFSET19700101\n            int256 num2 = (4 * num1) / 146097;\n            num1 = num1 - (146097 * num2 + 3) / 4;\n            int256 _year = (4000 * (num1 + 1)) / 1461001;\n            num1 = num1 - (1461 * _year) / 4 + 31;\n            int256 _month = (80 * num1) / 2447;\n            int256 _day = num1 - (2447 * _month) / 80;\n            num1 = _month / 11;\n            _month = _month + 2 - 12 * num1;\n            _year = 100 * (num2 - 49) + _year + num1;\n\n            yearStr = _uint2str(uint256(_year) % 10000);\n            monthStr = uint256(_month) < 10\n                ? string(abi.encodePacked(\"0\", _uint2str(uint256(_month))))\n                : _uint2str(uint256(_month));\n            dayStr = uint256(_day) < 10\n                ? string(abi.encodePacked(\"0\", _uint2str(uint256(_day))))\n                : _uint2str(uint256(_day));\n        }\n\n        // Format token symbols\n        // Symbols longer than 5 characters are truncated, min length would be 1 if tokens have no symbols, max length is 11\n        bytes memory tokenSymbols;\n        {\n            bytes memory payoutSymbol = bytes(payoutToken_.symbol());\n            if (payoutSymbol.length > 5) payoutSymbol = abi.encodePacked(bytes5(payoutSymbol));\n            bytes memory quoteSymbol = bytes(quoteToken_.symbol());\n            if (quoteSymbol.length > 5) quoteSymbol = abi.encodePacked(bytes5(quoteSymbol));\n\n            tokenSymbols = abi.encodePacked(payoutSymbol, \"/\", quoteSymbol);\n        }\n\n        // Format option type\n        bytes1 callPut = call_ ? bytes1(\"C\") : bytes1(\"P\");\n\n        // Format strike price\n        // Strike price is formatted as scientific notation to 3 significant figures\n        // Will either be 7 or 8 bytes, e.g. 1.056e1 (7) or 9.745e-2 (8)\n        bytes memory strike = _getScientificNotation(strikePrice_, quoteToken_.decimals());\n\n        // Construct name/symbol strings.\n\n        // Name is formatted as \"payoutSymbol/quoteSymbol callPut strikePrice expiry\" with the following constraints: // Name and symbol can each be at most 32 bytes since it is stored as a bytes32\n        // quoteSymbol - 5 bytes\n        // \" \" - 1 byte\n        // callPut - 1 byte\n        // \" \" - 1 byte\n        // strikePrice - 7 or 8 bytes, scientific notation to 3 significant figures, e.g. 1.056e1 (7) or 9.745e-2 (8)\n        // \" \" - 1 byte\n        // expiry - 8 bytes, YYYYMMDD\n        // Total is 30 or 31 bytes\n\n        // Symbol is formatted as \"payoutSymbol/quoteSymbol-callPut-expiry\" with the following constraints:\n        // payoutSymbol - 5 bytes\n        // \"/\" - 1 byte\n        // quoteSymbol - 5 bytes\n        // \"-\" - 1 byte\n        // callPut - 1 byte\n        // \"-\" - 1 byte\n        // expiry - 8 bytes, YYYYMMDD\n        // Total is 22 bytes\n\n        bytes32 name = bytes32(\n            abi.encodePacked(\n                tokenSymbols,\n                \" \",\n                callPut,\n                \" \",\n                strike,\n                \" \",\n                yearStr,\n                monthStr,\n                dayStr\n            )\n        );\n        bytes32 symbol = bytes32(\n            abi.encodePacked(tokenSymbols, \"-\", callPut, \"-\", yearStr, monthStr, dayStr)\n        );\n\n        return (name, symbol);\n    }\n\n    /// @notice Helper function to calculate number of price decimals in the provided price\n    /// @param price_   The price to calculate the number of decimals for\n    /// @return         The number of decimals\n    function _getPriceDecimals(uint256 price_, uint8 tokenDecimals_) internal pure returns (int8) {\n        int8 decimals;\n        while (price_ >= 10) {\n            price_ = price_ / 10;\n            decimals++;\n        }\n\n        // Subtract the stated decimals from the calculated decimals to get the relative price decimals.\n        // Required to do it this way vs. normalizing at the beginning since price decimals can be negative.\n        return decimals - int8(tokenDecimals_);\n    }\n\n    /// @notice Helper function to format a uint256 into scientific notation to 3 significant figures\n    /// @param price_           The price to format\n    /// @param tokenDecimals_   The number of decimals in the token\n    function _getScientificNotation(\n        uint256 price_,\n        uint8 tokenDecimals_\n    ) internal pure returns (bytes memory) {\n        // Get a bytes representation of the price in scientific notation to 3 significant figures.\n        // 1. Get the number of price decimals\n        int8 priceDecimals = _getPriceDecimals(price_, tokenDecimals_);\n\n        // If priceDecimals are >= 10 or <= -10, then it will be too large to fit in the byte limit\n        // However, this is already checked when an option token is deployed\n\n        // 2. Get a string of the price decimals and exponent figure\n        uint256 decimals = priceDecimals < 0\n            ? uint256(uint8(-priceDecimals))\n            : uint256(uint8(priceDecimals));\n        bytes memory decStr = bytes.concat(\"e\", bytes(_uint2str(decimals)));\n\n        // 3. Get a string of the leading digits with decimal point\n        uint8 priceMagnitude = uint8(int8(tokenDecimals_) + priceDecimals);\n        uint256 digits = price_ / (10 ** (priceMagnitude < 3 ? 0 : priceMagnitude - 3));\n        bytes memory digitStr = bytes(_uint2str(digits));\n        uint256 len = bytes(digitStr).length;\n        bytes memory leadingStr = bytes.concat(digitStr[0], \".\");\n        for (uint256 i = 1; i < len; ++i) {\n            leadingStr = bytes.concat(leadingStr, digitStr[i]);\n        }\n\n        // 4. Combine and return\n        // The bytes string should be at most 8 bytes (e.g. 1.056e-1)\n        return bytes.concat(leadingStr, decStr);\n    }\n\n    // Some fancy math to convert a uint into a string, courtesy of Provable Things.\n    // Updated to work with solc 0.8.0.\n    // https://github.com/provable-things/ethereum-api/blob/master/provableAPI_0.6.sol\n    function _uint2str(uint256 _i) internal pure returns (string memory) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint256 j = _i;\n        uint256 len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint256 k = len;\n        while (_i != 0) {\n            k = k - 1;\n            uint8 temp = (48 + uint8(_i - (_i / 10) * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n\n    /* ========== ADMIN & FEES ========== */\n\n    /// @inheritdoc IOptionTeller\n    function setMinOptionDuration(uint48 duration_) external override requiresAuth {\n        // Must be a minimum of 1 day due to timestamp rounding\n        if (duration_ < uint48(1 days)) revert Teller_InvalidParams(0, abi.encodePacked(duration_));\n        minOptionDuration = duration_;\n    }\n\n    /// @inheritdoc IOptionTeller\n    function setProtocolFee(uint48 fee_) external override requiresAuth {\n        if (fee_ > 5e3) revert Teller_InvalidParams(0, abi.encodePacked(fee_)); // 5% max\n        protocolFee = fee_;\n    }\n\n    /// @inheritdoc IOptionTeller\n    function claimFees(\n        ERC20[] memory tokens_,\n        address to_\n    ) external override nonReentrant requiresAuth {\n        uint256 len = tokens_.length;\n        for (uint256 i; i < len; ++i) {\n            ERC20 token = tokens_[i];\n            uint256 send = fees[token];\n\n            if (send != 0) {\n                fees[token] = 0;\n                token.safeTransfer(to_, send);\n            }\n        }\n    }\n}"
    },
    {
      "filename": "options/src/fixed-strike/FixedStrikeOptionTeller.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {ClonesWithImmutableArgs} from \"src/lib/clones/ClonesWithImmutableArgs.sol\";\n\nimport {IFixedStrikeOptionTeller, IOptionTeller} from \"src/interfaces/IFixedStrikeOptionTeller.sol\";\nimport {FixedStrikeOptionToken} from \"src/fixed-strike/FixedStrikeOptionToken.sol\";\n\nimport {TransferHelper} from \"src/lib/TransferHelper.sol\";\nimport {FullMath} from \"src/lib/FullMath.sol\";\n\n/// @title Fixed Strike Option Teller\n/// @notice Fixed Strike Option Teller Contract\n/// @dev Option Teller contracts handle the deployment, creation, and exercise of option tokens.\n///      Option Tokens are ERC20 tokens that represent the right to buy (call) or sell (put) a fixed\n///      amount of an asset (payout token) for an amount of another asset (quote token) between two\n///      timestamps (eli"
    }
  ]
}