{
  "Title": "[N-03] Missing Vault Input Validation",
  "Content": "\nDuring the code review, It has been observed that vault is not validated. The address check should be added into the function.\n\n### Proof Of Concept\n\n[SingleStrategyController.sol#L75](https://github.com/code-423n4/2022-03-prepo/blob/d62d7146b27fd39a5f1358ffde08766724886cf5/contracts/core/SingleStrategyController.sol#L75)<br>\n\n### Recommended Mitigation Steps\n\nAdd address check on the function.\n\n**[ramenforbreakfast (prePO) disputed and commented](https://github.com/code-423n4/2022-03-prepo-findings/issues/113#issuecomment-1077282340):**\n \n> **[L-01]** Two step ownership is unnecessarily complex considering we are using timelocked execution and proposed execution can be withdrawn.<br>\n> **[N-02]** This issue is too vague to be of any use.<br>\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-03-prepo-findings/issues/113#issuecomment-1086863731):**\n > I think **[L-01]** is valid because it ensures someone can sign from the new owner address.\n\n\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-03-prepo",
  "Code": [
    {
      "filename": "contracts/core/SingleStrategyController.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.7;\n\nimport \"./interfaces/IStrategy.sol\";\nimport \"./interfaces/IStrategyController.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract SingleStrategyController is\n    IStrategyController,\n    Ownable,\n    ReentrancyGuard\n{\n    using SafeERC20 for IERC20;\n\n    address private _vault;\n    IStrategy private _strategy;\n    IERC20 private immutable _baseToken;\n\n    modifier onlyVault() {\n        require(msg.sender == _vault, \"Caller is not the vault\");\n        _;\n    }\n\n    constructor(IERC20 _token) {\n        require(address(_token) != address(0), \"Zero address\");\n        _baseToken = _token;\n    }\n\n    // Assumes approval to take `_amount` has already been given by vault\n    function deposit(uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _baseToken.safeTransferFrom(_vault, address(this), _amount);\n        _strategy.deposit(_baseToken.balanceOf(address(this)));\n    }\n\n    function withdraw(address _recipient, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _strategy.withdraw(_recipient, _amount);\n    }\n\n    function migrate(IStrategy _newStrategy)\n        external\n        override\n        onlyOwner\n        nonReentrant\n    {\n        uint256 _oldStrategyBalance;\n        IStrategy _oldStrategy = _strategy;\n        _strategy = _newStrategy;\n        _baseToken.approve(address(_newStrategy), type(uint256).max);\n        if (address(_oldStrategy) != address(0)) {\n            _baseToken.approve(address(_oldStrategy), 0);\n            _oldStrategyBalance = _oldStrategy.totalValue();\n            _oldStrategy.withdraw(address(this), _oldStrategyBalance);\n            _newStrategy.deposit(_baseToken.balanceOf(address(this)));\n        }\n        emit StrategyMigrated(\n            address(_oldStrategy),\n            address(_newStrategy),\n            _oldStrategyBalance\n        );\n    }\n\n    function setVault(address _newVault) external override onlyOwner {\n        _vault = _newVault;\n        emit VaultChanged(_newVault);\n    }\n\n    function totalValue() external view override returns (uint256) {\n        return _baseToken.balanceOf(address(this)) + _strategy.totalValue();\n    }\n\n    function getVault() external view override returns (address) {\n        return _vault;\n    }\n\n    function getStrategy() external view override returns (IStrategy) {\n        return _strategy;\n    }\n\n    function getBaseToken() external view override returns (IERC20) {\n        return _baseToken;\n    }\n}"
    }
  ]
}