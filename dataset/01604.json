{
  "Title": "M-13: Potential accounting problems due to issue in `ClearingHouse.updatePositions()`",
  "Content": "# Issue M-13: Potential accounting problems due to issue in `ClearingHouse.updatePositions()` \n\nSource: https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/248 \n\n## Found by \nlemonmon\n## Summary\n\nPotential issue in `ClearingHouse.updatePositions()` when lastFundingTime is not being updated by `ClearingHouse.settleFunding`.\n\n## Vulnerability Detail\n\n`ClearingHouse.lastFundingTime` is only updated, when `_nextFundingTime` is not zero:\n\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/ClearingHouse.sol#L281-L282\n\n`_nextFundingTime` is determined a few lines above by a call to `amms[i].settleFunding()`:\n\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/ClearingHouse.sol#L267\n\nThe return value of `amms[i].settleFunding()` can be zero for `_nextFundingTime`, if the `block.timestamp` is smaller than the next funding time:\n\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/AMM.sol#L236-L249\n\nThat means that if the last market inside the `amms` array has not reached the next funding time at `block.timestamp`, `_nextFundingTime` will be zero and `lastFundingTime` will not be updated.\n\nThen when `ClearingHouse.updatePositions()` is called, it will not process `fundingPayment` because `lastFundingTime` was not updated:\n\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/ClearingHouse.sol#L241-L250\n\n## Impact\n\nUnrealized funding payments are not settled correctly, potentially leading to incorrect margin accounting when opening a position. Also `marginAccount.realizePnL()` (line 255 ClearingHouse.sol) won't get called, so the trader won't receive funds that they should receive.\n\nNote: `ClearingHouse.updatePositions()` is called by `ClearingHouse._openPosition` (line 141 ClearingHouse.sol).\n\nNote: `ClearingHouse.liquidate` -> `ClearingHouse.openPosition` -> `ClearingHouse._openPosition`\n\nThere can be multiple potential issues with accounting that can result due to this issue, both when liquidating and when opening a position.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/ClearingHouse.sol#L281-L282\n\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/ClearingHouse.sol#L267\n\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/AMM.sol#L236-L249\n\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/ClearingHouse.sol#L241-L250\n\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/ClearingHouse.sol#L140-L141\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adjusting the code inside `ClearingHouse.settleFunding()` to account for the case where the last market inside the `amms` array returns zero for `_nextFundingTime` when `Amm.settleFunding()` is called (line 267 ClearingHouse.sol). For example introduce a boolean variable that tracks whether a market inside `amms` array didn't return zero for `_nextFundingTime`.\n\n```solidity\n// ClearingHouse\n// settleFunding\n268            if (_nextFundingTime != 0) {\n269                _marketReachedNextFundingTime = true; // <-- @audit new boolean to track\n\n281        if (_marketReachedNextFundingTime) {\n282            lastFundingTime = _blockTimestamp();\n283        }\n```\n\n\n\n## Discussion\n\n**asquare08**\n\nAll amms will have the same `nextFundingTime` as `amm.settleFunding` is called together for all amms in a single tx. So _nextFundingTime will either be 0 or none for all amms.\n```solidity\n    function settleFunding() override external onlyDefaultOrderBook {\n        uint numAmms = amms.length;\n        uint _nextFundingTime;\n        for (uint i; i < numAmms; ++i) {\n            int _premiumFraction;\n            int _underlyingPrice;\n            int _cumulativePremiumFraction;\n            (_premiumFraction, _underlyingPrice, _cumulativePremiumFraction, _nextFundingTime) = amms[i].settleFunding();\n            if (_nextFundingTime != 0) {\n                emit FundingRateUpdated(\n                    i,\n                    _premiumFraction,\n                    _underlyingPrice.toUint256(),\n                    _cumulativePremiumFraction,\n                    _nextFundingTime,\n                    _blockTimestamp(),\n                    block.number\n                );\n            }\n        }\n        // nextFundingTime will be same for all amms\n        if (_nextFundingTime != 0) {\n            lastFundingTime = _blockTimestamp();\n        }\n    }\n   \n\n\n**ctf-sec**\n\nClosed this issue based on sponsor's comment,\n\nthe watson is welcome to escalate with a more clear impact and more proof\n\n**lemonmon1984**\n\nEscalate\n> All amms will have the same nextFundingTime as amm.settleFunding is called together for all amms in a single tx.\n\nIt is not neccessarily true for certain conditions, in which ClearingHouse.whitelistAmm() is involved.\nOne possible scenario would be:\n1. A couple of AMMs are whitelisted via ClearingHouse.whitelistAmm() where a nextFundingTime is assigned to them.\n1. After the nextFundingTime was reached, ClearingHouse.whitelistAmm() is called again to add another AMM.\n1. Then the ClearingHouse.settleFunding() is called and returns 0 for the last AMM that was just added in the previous step, because its nextFundingTime is in the future and ClearingHouse.sol line 248 is true and returns 0 for nextFundingTime, which then leads to the issue described here.\n\nNote: ClearingHouse.whitelistAmm() and ClearingHouse.settleFunding() is likely to be initiated by separate entities. Therefore, the order of transactions is not guaranteed. Also the tx execution can be delayed due to network congestions. That's why this scenario may occur.\n\n**Example:**\n\nfundingPeriod: 3h\ncall ClearingHouse.whitelistAmm():  at 16:00 (block.timestamp)\n\nthen AMM.startFunding()  gets called l521 in ClearingHouse.sol\n    here it calculates:\n        nextFundingTime = ((16 + 3) / 3) * 3 = 18\n\n\nat 19:00 another AMM is added:\n    call ClearingHouse.whitelistAmm():  at 19:00 (block.timestamp)\n    then AMM.startFunding()  gets called l521 in ClearingHouse.sol\n        here it calculates:\n            nextFundingTime = ((19 + 3) / 3) * 3 = 21\n\nthen also at 19:00 after another AMM was just added:\n    call ClearingHouse.settleFunding()\n        which calls AMM.settleFunding, and the last index of AMMs contains the added AMM from 19:00 with nextFundingTime 21\n            so AMM.settleFunding will return 0,0,0,0 l249 because nextFundingTime is in the future.\n                This leads to exactly the issue described that then on line 281 in ClearingHouse.sol _nextFundingTime will be 0.\n\n\n### Other scenario\nIn another scenario, if the ClearingHouse.settleFunding() is called past the nextFundingTime due to network congestion,\nthe nextFundingTime will shift from the fixed schedule. While it is shifted, if the ClearingHouse.whitelistAmm() is called, then it gives a certain window for the ClearingHouse.settleFunding() call will face the same issue.\n\n**sherlock-admin2**\n\n > Escalate\n> > All amms will have the same nextFundingTime as amm.settleFunding is called together for all amms in a single tx.\n> \n> It is not neccessarily true for certain conditions, in which ClearingHouse.whitelistAmm() is involved.\n> One possible scenario would be:\n> 1. A couple of AMMs are whitelisted via ClearingHouse.whitelistAmm() where a nextFundingTime is assigned to them.\n> 1. After the nextFundingTime was reached, ClearingHouse.whitelistAmm() is called again to add another AMM.\n> 1. Then the ClearingHouse.settleFunding() is called and returns 0 for the last AMM that was just added in the previous step, because its nextFundingTime is in the future and ClearingHouse.sol line 248 is true and returns 0 for nextFundingTime, which then leads to the issue described here.\n> \n> Note: ClearingHouse.whitelistAmm() and ClearingHouse.settleFunding() is likely to be initiated by separate entities. Therefore, the order of transactions is not guaranteed. Also the tx execution can be delayed due to network congestions. That's why this scenario may occur.\n> \n> **Example:**\n> \n> fundingPeriod: 3h\n> call ClearingHouse.whitelistAmm():  at 16:00 (block.timestamp)\n> \n> then AMM.startFunding()  gets called l521 in ClearingHouse.sol\n>     here it calculates:\n>         nextFundingTime = ((16 + 3) / 3) * 3 = 18\n> \n> \n> at 19:00 another AMM is added:\n>     call ClearingHouse.whitelistAmm():  at 19:00 (block.timestamp)\n>     then AMM.startFunding()  gets called l521 in ClearingHouse.sol\n>         here it calculates:\n>             nextFundingTime = ((19 + 3) / 3) * 3 = 21\n> \n> then also at 19:00 after another AMM was just added:\n>     call ClearingHouse.settleFunding()\n>         which calls AMM.settleFunding, and the last index of AMMs contains the added AMM from 19:00 with nextFundingTime 21\n>             so AMM.settleFunding will return 0,0,0,0 l249 because nextFundingTime is in the future.\n>                 This leads to exactly the issue described that then on line 281 in ClearingHouse.sol _nextFundingTime will be 0.\n> \n> \n> ### Other scenario\n> In another scenario, if the ClearingHouse.settleFunding() is called past the nextFundingTime due to network congestion,\n> the nextFundingTime will shift from the fixed schedule. While it is shifted, if the ClearingHouse.whitelistAmm() is called, then it gives a certain window for the ClearingHouse.settleFunding() call will face the same issue.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**asquare08**\n\nA good corner case is described. It's a valid issue and can be marked as medium severity \n\n**IAm0x52**\n\nAgreed with escalation, valid corner case\n\n**hrishibhat**\n\nResult:\nMedium\nUnique\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [lemonmon1984](https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/248/#issuecomment-1642709772): accepted\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/72",
  "Code": [
    {
      "filename": "hubble-protocol/contracts/ClearingHouse.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { HubbleBase } from \"./legos/HubbleBase.sol\";\nimport { IAMM, IMarginAccount, IClearingHouse, IHubbleReferral, IOrderBook } from \"./Interfaces.sol\";\nimport { VUSD } from \"./VUSD.sol\";\nimport { IHubbleBibliophile } from \"./precompiles/IHubbleBibliophile.sol\";\n\n/**\n * @title Gets instructions from the orderbook contract and executes them.\n * Routes various actions (realizePnL, update/Liquidate Positions etc) to corresponding contracts like margin account, amm, referral etc.\n * @dev At several places we are using something called a bibliophile. This is a special contract (precompile) that is deployed at a specific address.\n * But there is identical code in this contract that can be used as a fallback if the precompile is not available.\n*/\ncontract ClearingHouse is IClearingHouse, HubbleBase {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    modifier onlyOrderBook() {\n        require(isWhitelistedOrderBook[msg.sender], \"Only orderBook\");\n        _;\n    }\n\n    modifier onlyDefaultOrderBook() {\n        require(msg.sender == address(defaultOrderBook), \"Only orderBook\");\n        _;\n    }\n\n    modifier onlyMySelf() {\n        require(msg.sender == address(this), \"Only myself\");\n        _;\n    }\n\n    uint256 constant PRECISION = 1e6;\n    bytes32 constant public LIQUIDATION_FAILED = keccak256(\"LIQUIDATION_FAILED\");\n    int256 constant PRECISION_INT = 1e6;\n\n    int256 override public maintenanceMargin; // SLOT_1 !!! used in precompile !!!\n    int256 public minAllowableMargin; // SLOT_2 !!! used in precompile !!!\n    int256 override public takerFee; // defining as int for consistency with makerFee\n    int256 override public makerFee;\n    uint override public liquidationPenalty;\n    uint public referralShare;\n    uint public tradingFeeDiscount;\n\n    VUSD public vusd;\n    address override public feeSink;\n    IMarginAccount public marginAccount;\n    IOrderBook public defaultOrderBook;\n    IAMM[] override public amms;  // SLOT_12 !!! used in precompile !!!\n    IHubbleReferral public hubbleReferral;\n    uint public lastFundingTime;\n    // trader => lastFundingPaid timestamp\n    mapping(address => uint) public lastFundingPaid;\n    IHubbleBibliophile public bibliophile;\n    mapping(address => bool) public isWhitelistedOrderBook;\n\n    uint256[50] private __gap;\n\n    function initialize(\n        address _governance,\n        address _feeSink,\n        address _marginAccount,\n        address _defaultOrderBook,\n        address _vusd,\n        address _hubbleReferral\n    ) external\n      initializer\n    {\n        _setGovernace(_governance);\n\n        feeSink = _feeSink;\n        marginAccount = IMarginAccount(_marginAccount);\n        defaultOrderBook = IOrderBook(_defaultOrderBook);\n        vusd = VUSD(_vusd);\n        hubbleReferral = IHubbleReferral(_hubbleReferral);\n        isWhitelistedOrderBook[_defaultOrderBook] = true;\n    }\n\n    /* ****************** */\n    /*     Positions      */\n    /* ****************** */\n\n    /**\n     * @notice Pass instructions to the AMM contract to open/close/modify the position in a market.\n     * Can only be called by the orderBook contract.\n     * @dev reverts the all the state storage updates within the context of this call (and sub-calls) if an intermediate step of the call fails\n     * @param orders orders[0] is the long order and orders[1] is the short order\n     * @param matchInfo intermediate information about which order came first and which eventually decides what fee to charge\n     * @param fillAmount Amount of base asset to be traded between the two orders. Should be +ve. Scaled by 1e18\n     * @param fulfillPrice Price at which the orders should be matched. Scaled by 1e6.\n     * @return openInterest The total open interest in the market after the trade is executed\n    */\n    function openComplementaryPositions(\n        IOrderBook.Order[2] calldata orders,\n        IOrderBook.MatchInfo[2] calldata matchInfo,\n        int256 fillAmount,\n        uint fulfillPrice\n    )   external\n        onlyOrderBook\n        returns (uint256 openInterest)\n    {\n\n        try this.openPosition(orders[0], fillAmount, fulfillPrice, matchInfo[0].mode, false) {\n            // only executed if the above doesn't revert\n            try this.openPosition(orders[1], -fillAmount, fulfillPrice, matchInfo[1].mode, true) returns(uint256 _openInterest) {\n                openInterest = _openInterest;\n                // only executed if the above doesn't revert\n            } catch Error(string memory reason) {\n                // will revert all state changes including those made in this.openPosition(orders[0])\n                revert(string(abi.encode(matchInfo[1].orderHash, reason)));\n            }\n        } catch Error(string memory reason) {\n            // surface up the error to the calling contract\n            revert(string(abi.encode(matchInfo[0].orderHash, reason)));\n        }\n    }\n\n    // to avoid stack too deep error\n    struct VarGroup {\n        int256 feeCharged;\n        int realizedPnl;\n        bool isPositionIncreased;\n    }\n\n   /**\n    * @notice Open/Modify/Close Position\n    * @dev uses \"onlyMySelf\" modifier to make sure the calls come from within the same contract.\n    * This function was designed in a manner that helps us use the try-catch feature of solidity to revert all state changes if any of the sub-calls revert.\n    * @param mode Whether we are executing is a maker, taker order or a liquidation\n    * @param is2ndTrade Whether this is the second trade in a pair of trades that are executed together, which is used to update the twap in the AMM contract\n    */\n    function openPosition(IOrderBook.Order calldata order, int256 fillAmount, uint256 fulfillPrice, IOrderBook.OrderExecutionMode mode, bool is2ndTrade) public onlyMySelf returns(uint openInterest) {\n        return _openPosition(order, fillAmount, fulfillPrice, mode, is2ndTrade);\n    }\n\n    function _openPosition(IOrderBook.Order memory order, int256 fillAmount, uint256 fulfillPrice, IOrderBook.OrderExecutionMode mode, bool is2ndTrade) internal returns(uint openInterest) {\n        updatePositions(order.trader); // settle funding payments\n        uint quoteAsset = abs(fillAmount).toUint256() * fulfillPrice / 1e18;\n        int size;\n        uint openNotional;\n        VarGroup memory varGroup;\n        (\n            varGroup.realizedPnl,\n            varGroup.isPositionIncreased,\n            size,\n            openNotional,\n            openInterest\n        ) = amms[order.ammIndex].openPosition(order, fillAmount, fulfillPrice, is2ndTrade);\n\n        {\n            int toFeeSink;\n            (toFeeSink, varGroup.feeCharged) = _chargeFeeAndRealizePnL(order.trader, varGroup.realizedPnl, quoteAsset, mode);\n            if (toFeeSink != 0) {\n                marginAccount.transferOutVusd(feeSink, toFeeSink.toUint256());\n            }\n        }\n        {\n            // isPositionIncreased is true when the position is increased or reversed\n            if (varGroup.isPositionIncreased) {\n                assertMarginRequirement(order.trader);\n                require(order.reduceOnly == false, \"CH: reduceOnly order can only reduce position\");\n            }\n            emit PositionModified(order.trader, order.ammIndex, fillAmount, fulfillPrice, varGroup.realizedPnl, size, openNotional, varGroup.feeCharged, mode, _blockTimestamp());\n        }\n    }\n\n    /* ****************** */\n    /*    Liquidations    */\n    /* ****************** */\n\n    /**\n     * @notice Pass instructions to the AMM contract to the liquidate 1 position and open/close/modify the other in a market.\n     * Can only be called by the orderBook contract.\n     * @dev reverts the all the state storage updates within the context of this call (and sub-calls) if an intermediate step of the call fails\n     * @param order long order if liquidating a long position, short order if liquidating a short position\n     * @param matchInfo intermediate information about the order being matched\n     * @param liquidationAmount -ve if liquidating a short pos, +ve if long. Scaled by 1e18\n     * @param price Price at which the liquidation should be executed. Scaled by 1e6.\n     * @param trader Trader being liquidated\n     * @return openInterest The total open interest in the market after the liquidation is executed\n    */\n    function liquidate(\n        IOrderBook.Order calldata order,\n        IOrderBook.MatchInfo calldata matchInfo,\n        int256 liquidationAmount,\n        uint price,\n        address trader\n    )\n        override\n        external\n        onlyOrderBook\n        returns (uint256 openInterest)\n    {\n        try this.liquidateSingleAmm(trader, order.ammIndex, price, liquidationAmount) {\n            // only executed if the above doesn't revert\n            try this.openPosition(order, liquidationAmount, price, matchInfo.mode, true) returns(uint256 _openInterest) {\n                openInterest = _openInterest;\n            } catch Error(string memory reason) {\n                // will revert all state changes including those made in this.liquidateSingleAmm\n                revert(string(abi.encode(matchInfo.orderHash, reason)));\n            }\n        } catch Error(string memory reason) {\n            // surface up the error to the calling contract\n            revert(string(abi.encode(LIQUIDATION_FAILED, reason)));\n        }\n    }\n\n    function liquidateSingleAmm(address trader, uint ammIndex, uint price, int toLiquidate) external onlyMySelf {\n        _liquidateSingleAmm(trader, ammIndex, price, toLiquidate);\n    }\n\n    function _liquidateSingleAmm(address trader, uint ammIndex, uint price, int toLiquidate) internal {\n        updatePositions(trader); // settle funding payments\n        _assertLiquidationRequirement(trader);\n        (\n            int realizedPnl,\n            uint quoteAsset,\n            int size,\n            uint openNotional\n        ) = amms[ammIndex].liquidatePosition(trader, price, toLiquidate);\n\n        (int liquidationFee,) = _chargeFeeAndRealizePnL(trader, realizedPnl, quoteAsset, IOrderBook.OrderExecutionMode.Liquidation);\n        marginAccount.transferOutVusd(feeSink, liquidationFee.toUint256()); // will revert if liquidationFee is negative\n        emit PositionLiquidated(trader, ammIndex, toLiquidate, price, realizedPnl, size, openNotional, liquidationFee, _blockTimestamp());\n    }\n\n    /* ****************** */\n    /*  Funding Payments  */\n    /* ****************** */\n\n    /**\n     * @notice Settle unrealized funding payments for a trader\n     * @dev Interestingly, anyone can call this function to settle funding payments for a trader\n     * Note, that as long as this function is called before the user attempts to remove margin;\n     * it is not strictly necessary to call this function on every trade for a trader, however we still currently do so. Might explore avoiding this in the future.\n    */\n    function updatePositions(address trader) override public whenNotPaused {\n        require(address(trader) != address(0), 'CH: 0x0 trader Address');\n        // lastFundingTime will always be >= lastFundingPaid[trader]\n        if (lastFundingPaid[trader] != lastFundingTime) {\n            int256 fundingPayment;\n            uint numAmms = amms.length;\n            for (uint i; i < numAmms; ++i) {\n                (int256 _fundingPayment, int256 cumulativePremiumFraction) = amms[i].updatePosition(trader);\n                if (_fundingPayment != 0) {\n                    fundingPayment += _fundingPayment;\n                    emit FundingPaid(trader, i, _fundingPayment, cumulativePremiumFraction);\n                }\n            }\n            // -ve fundingPayment means trader should receive funds\n            marginAccount.realizePnL(trader, -fundingPayment);\n            lastFundingPaid[trader] = lastFundingTime;\n        }\n    }\n\n    function settleFunding() override external onlyDefaultOrderBook {\n        uint numAmms = amms.length;\n        uint _nextFundingTime;\n        for (uint i; i < numAmms; ++i) {\n            int _premiumFraction;\n            int _underlyingPrice;\n            int _cumulativePremiumFraction;\n            (_premiumFraction, _underlyingPrice, _cumulativePremiumFraction, _nextFundingTime) = amms[i].settleFunding();\n            if (_nextFundingTime != 0) {\n                emit FundingRateUpdated(\n                    i,\n                    _premiumFraction,\n                    _underlyingPrice.toUint256(),\n                    _cumulativePremiumFraction,\n                    _nextFundingTime,\n                    _blockTimestamp(),\n                    block.number\n                );\n            }\n        }\n        // nextFundingTime will be same for all amms\n        if (_nextFundingTime != 0) {\n            lastFundingTime = _blockTimestamp();\n        }\n    }\n\n    /* ********************* */\n    /*        Internal       */\n    /* ********************* */\n\n    /**\n    * @notice calculate trade/liquidatin fee\n    * referral bonus and fee discount is applied when positive fee is charged from either maker or taker\n    * @param realizedPnl realized PnL of the trade, only sent in so that call an extra call to marginAccount.realizePnL can be saved\n    * @return toFeeSink fee to be sent to fee sink, always >= 0\n    * @return feeCharged total fee including referral bonus and maker fee, can be positive or negative. -ve implies maker rebate.\n    */\n    function _chargeFeeAndRealizePnL(\n        address trader,\n        int realizedPnl,\n        uint quoteAsset,\n        IOrderBook.OrderExecutionMode mode\n    )\n        internal\n        returns (int toFeeSink, int feeCharged)\n    {\n        if (mode == IOrderBook.OrderExecutionMode.Taker) {\n            feeCharged = _calculateTakerFee(quoteAsset);\n            if (makerFee < 0) {\n                // when maker fee is -ve, don't send to fee sink\n                // it will be credited to the maker when processing the other side of the trade\n                toFeeSink = _calculateMakerFee(quoteAsset); // toFeeSink is now -ve\n            }\n        } else if (mode == IOrderBook.OrderExecutionMode.SameBlock) {\n            // charge taker fee without expecting a corresponding maker component\n            feeCharged = _calculateTakerFee(quoteAsset);\n        } else if (mode == IOrderBook.OrderExecutionMode.Maker) {\n            feeCharged = _calculateMakerFee(quoteAsset); // can be -ve or +ve\n        }  else if (mode == IOrderBook.OrderExecutionMode.Liquidation){\n            feeCharged = _calculateLiquidationPenalty(quoteAsset);\n            if (makerFee < 0) {\n                // when maker fee is -ve, don't send to fee sink\n                // it will be credited to the maker when processing the other side of the trade\n                toFeeSink = _calculateMakerFee(quoteAsset);\n            }\n        }\n\n        if (feeCharged > 0) {\n            toFeeSink += feeCharged;\n            if (mode != IOrderBook.OrderExecutionMode.Liquidation) {\n                (uint discount, uint referralBonus) = _payReferralBonus(trader, feeCharged.toUint256());\n                feeCharged -= discount.toInt256();\n                // deduct referral bonus (already credit to referrer) from fee sink share\n                toFeeSink = toFeeSink - discount.toInt256() - referralBonus.toInt256();\n            }\n        }\n\n        marginAccount.realizePnL(trader, realizedPnl - feeCharged);\n    }\n\n    /**\n     * @param feeCharged fee charged to the trader, caller makes sure that this is positive\n    */\n    function _payReferralBonus(address trader, uint feeCharged) internal returns(uint discount, uint referralBonus) {\n        address referrer = hubbleReferral.getTraderRefereeInfo(trader);\n        if (referrer != address(0x0)) {\n            referralBonus = feeCharged * referralShare / PRECISION;\n            // add margin to the referrer\n            // note that this fee will be deducted from the fee sink share in the calling function\n            marginAccount.realizePnL(referrer, referralBonus.toInt256());\n            emit ReferralBonusAdded(referrer, referralBonus);\n\n            discount = feeCharged * tradingFeeDiscount / PRECISION;\n        }\n    }\n\n    /* ****************** */\n    /*        View        */\n    /* ****************** */\n\n    function calcMarginFraction(address trader, bool includeFundingPayments, Mode mode) public view returns(int256) {\n        (uint256 notionalPosition, int256 margin) = getNotionalPositionAndMargin(trader, includeFundingPayments, mode);\n        return _getMarginFraction(margin, notionalPosition);\n    }\n\n    function getTotalFunding(address trader) override public view returns(int256 totalFunding) {\n        int256 fundingPayment;\n        uint numAmms = amms.length;\n        for (uint i; i < numAmms; ++i) {\n            (fundingPayment,) = amms[i].getPendingFundingPayment(trader);\n            totalFunding += fundingPayment;\n        }\n    }\n\n    function getTotalNotionalPositionAndUnrealizedPnl(address trader, int256 margin, Mode mode)\n        override\n        public\n        view\n        returns(uint256 notionalPosition, int256 unrealizedPnl)\n    {\n        uint256 _notionalPosition;\n        int256 _unrealizedPnl;\n        uint numAmms = amms.length;\n        for (uint i; i < numAmms; ++i) {\n            (_notionalPosition, _unrealizedPnl) = amms[i].getOptimalPnl(trader, margin, mode);\n            notionalPosition += _notionalPosition;\n            unrealizedPnl += _unrealizedPnl;\n        }\n    }\n\n    function getNotionalPositionAndMargin(address trader, bool includeFundingPayments, Mode mode)\n        override\n        public\n        view\n        returns(uint256 notionalPosition, int256 margin)\n    {\n        if (address(bibliophile) != address(0x0)) {\n            // precompile magic allows us to execute this for a fixed 1k gas\n            return bibliophile.getNotionalPositionAndMargin(trader, includeFundingPayments, uint8(mode));\n        }\n        return getNotionalPositionAndMarginVanilla(trader, includeFundingPayments, mode);\n    }\n\n    /**\n     * @dev fallback if the precompile is not available\n    */\n    function getNotionalPositionAndMarginVanilla(address trader, bool includeFundingPayments, Mode mode)\n        public\n        view\n        returns(uint256 notionalPosition, int256 margin)\n    {\n        int256 unrealizedPnl;\n        margin = marginAccount.getNormalizedMargin(trader);\n        if (includeFundingPayments) {\n            margin -= getTotalFunding(trader); // -ve fundingPayment means trader should receive funds\n        }\n        (notionalPosition, unrealizedPnl) = getTotalNotionalPositionAndUnrealizedPnl(trader, margin, mode);\n        margin += unrealizedPnl;\n    }\n\n    /**\n    * @dev This method assumes that pending funding has been settled\n    */\n    function assertMarginRequirement(address trader) public view {\n        require(\n            calcMarginFraction(trader, false, Mode.Min_Allowable_Margin) >= minAllowableMargin,\n            \"CH: Below Minimum Allowable Margin\"\n        );\n    }\n\n    function getAmmsLength() override public view returns(uint) {\n        return amms.length;\n    }\n\n    function getAMMs() external view returns (IAMM[] memory) {\n        return amms;\n    }\n\n    /* ****************** */\n    /*   Test/UI Helpers  */\n    /* ****************** */\n\n    function isAboveMaintenanceMargin(address trader) override external view returns(bool) {\n        return calcMarginFraction(trader, true, Mode.Maintenance_Margin) >= maintenanceMargin;\n    }\n\n    function orderBook() external view returns(IOrderBook) {\n        return defaultOrderBook;\n    }\n\n    /**\n     * @notice Get the underlying price of the AMMs\n    */\n    function getUnderlyingPrice() override public view returns(uint[] memory prices) {\n        uint numAmms = amms.length;\n        prices = new uint[](numAmms);\n        for (uint i; i < numAmms; ++i) {\n            prices[i] = amms[i].getUnderlyingPrice();\n        }\n    }\n\n    /* ****************** */\n    /*   Internal View    */\n    /* ****************** */\n\n    /**\n    * @dev This method assumes that pending funding has been credited\n    */\n    function _assertLiquidationRequirement(address trader) internal view {\n        require(calcMarginFraction(trader, false, Mode.Maintenance_Margin) < maintenanceMargin, \"CH: Above Maintenance Margin\");\n    }\n\n    function _calculateTradeFee(uint quoteAsset, bool isMakerOrder) internal view returns (int) {\n        if (isMakerOrder) {\n            return _calculateMakerFee(quoteAsset);\n        }\n        return quoteAsset.toInt256() * takerFee / PRECISION_INT;\n    }\n\n    function _calculateTakerFee(uint quoteAsset) internal view returns (int) {\n        return quoteAsset.toInt256() * takerFee / PRECISION_INT;\n    }\n\n    function _calculateMakerFee(uint quoteAsset) internal view returns (int) {\n        return quoteAsset.toInt256() * makerFee / PRECISION_INT;\n    }\n\n    function _calculateLiquidationPenalty(uint quoteAsset) internal view returns (int) {\n        return (quoteAsset * liquidationPenalty / PRECISION).toInt256();\n    }\n\n    /* ****************** */\n    /*        Pure        */\n    /* ****************** */\n\n    function _getMarginFraction(int256 accountValue, uint notionalPosition) private pure returns(int256) {\n        if (notionalPosition == 0) {\n            return type(int256).max;\n        }\n        return accountValue * PRECISION.toInt256() / notionalPosition.toInt256();\n    }\n\n    function abs(int x) internal pure returns (int) {\n        return x >= 0 ? x : -x;\n    }\n\n    /* ****************** */\n    /*     Governance     */\n    /* ****************** */\n\n    function whitelistAmm(address _amm) external virtual onlyGovernance {\n        require(address(IAMM(_amm).oracle()) != address(0), \"ch.whitelistAmm.oracle_not_set\");\n        uint minSize = IAMM(_amm).minSizeRequirement();\n        require(minSize > 0, \"ch.whitelistAmm.minSizeRequirement_not_set\");\n\n        uint l = amms.length;\n        for (uint i; i < l; ++i) {\n            require(address(amms[i]) != _amm, \"ch.whitelistAmm.duplicate_amm\");\n        }\n        emit MarketAdded(l, _amm);\n        amms.push(IAMM(_amm));\n        uint nextFundingTime = IAMM(_amm).startFunding();\n        // to start funding in vm\n        emit FundingRateUpdated(\n            l,\n            0,\n            IAMM(_amm).lastPrice(),\n            0,\n            nextFundingTime,\n            _blockTimestamp(),\n            block.number\n        );\n    }\n\n    function setParams(\n        int _maintenanceMargin,\n        int _minAllowableMargin,\n        int _takerFee,\n        int _makerFee,\n        uint _referralShare,\n        uint _tradingFeeDiscount,\n        uint _liquidationPenalty\n    ) external onlyGovernance {\n        require(_maintenanceMargin > 0, \"_maintenanceMargin <= 0\");\n        require(_liquidationPenalty > 0, \"_liquidationPenalty < 0\");\n\n        maintenanceMargin = _maintenanceMargin;\n        minAllowableMargin = _minAllowableMargin;\n        takerFee = _takerFee;\n        makerFee = _makerFee;\n        referralShare = _referralShare;\n        tradingFeeDiscount = _tradingFeeDiscount;\n        liquidationPenalty = _liquidationPenalty;\n\n        defaultOrderBook.updateParams(_minAllowableMargin.toUint256(), _takerFee.toUint256());\n        marginAccount.updateParams(_minAllowableMargin.toUint256());\n    }\n\n    function setBibliophile(address _bibliophile) external onlyGovernance {\n        bibliophile = IHubbleBibliophile(_bibliophile);\n    }\n}"
    },
    {
      "filename": "hubble-protocol/contracts/ClearingHouse.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { HubbleBase } from \"./legos/HubbleBase.sol\";\nimport { IAMM, IMarginAccount, IClearingHouse, IHubbleReferral, IOrderBook } from \"./Interfaces.sol\";\nimport { VUSD } from \"./VUSD.sol\";\nimport { IHubbleBibliophile } from \"./precompiles/IHubbleBibliophile.sol\";\n\n/**\n * @title Gets instructions from the orderbook contract and executes them.\n * Routes various actions (realizePnL, update/Liquidate Positions etc) to corresponding contracts like margin account, amm, referral etc.\n * @dev At several places we are using something called a bibliophile. This is a special contract (precompile) that is deployed at a specific address.\n * But there is identical code in this contract that can be used as a fallback if the precompile is not available.\n*/\ncontract ClearingHouse is IClearingHouse, HubbleBase {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    modifier onlyOrderBook() {\n        require(isWhitelistedOrderBook[msg.sender], \"Only orderBook\");\n        _;\n    }\n\n    modifier onlyDefaultOrderBook() {\n        require(msg.sender == address(defaultOrderBook), \"Only orderBook\");\n        _;\n    }\n\n    modifier onlyMySelf() {\n        require(msg.sender == address(this), \"Only myself\");\n        _;\n    }\n\n    uint256 constant PRECISION = 1e6;\n    bytes32 constant public LIQUIDATION_FAILED = keccak256(\"LIQUIDATION_FAILED\");\n    int256 constant PRECISION_INT = 1e6;\n\n    int256 override public maintenanceMargin; // SLOT_1 !!! used in precompile !!!\n    int256 public minAllowableMargin; // SLOT_2 !!! used in precompile !!!\n    int256 override public takerFee; // defining as int for consistency with makerFee\n    int256 override public makerFee;\n    uint override public liquidationPenalty;\n    uint public referralShare;\n    uint public tradingFeeDiscount;\n\n    VUSD public vusd;\n    address override public feeSink;\n    IMarginAccount public marginAccount;\n    IOrderBook public defaultOrderBook;\n    IAMM[] override public amms;  // SLOT_12 !!! used in precompile !!!\n    IHubbleReferral public hubbleReferral;\n    uint public lastFundingTime;\n    // trader => lastFundingPaid timestamp\n    mapping(address => uint) public lastFundingPaid;\n    IHubbleBibliophile public bibliophile;\n    mapping(address => bool) public isWhitelistedOrderBook;\n\n    uint256[50] private __gap;\n\n    function initialize(\n        address _governance,\n        address _feeSink,\n        address _marginAccount,\n        address _defaultOrderBook,\n        address _vusd,\n        address _hubbleReferral\n    ) external\n      initializer\n    {\n        _setGovernace(_governance);\n\n        feeSink = _feeSink;\n        marginAccount = IMarginAccount(_marginAccount);\n        defaultOrderBook = IOrderBook(_defaultOrderBook);\n        vusd = VUSD(_vusd);\n        hubbleReferral = IHubbleReferral(_hubbleReferral);\n        isWhitelistedOrderBook[_defaultOrderBook] = true;\n    }\n\n    /* ****************** */\n    /*     Positions      */\n    /* ****************** */\n\n    /**\n     * @notice Pass instructions to the AMM contract to open/close/modify the position in a market.\n     * Can only be called by the orderBook contract.\n     * @dev reverts the all the state storage updates within the context of this call (and sub-calls) if an intermediate step of the call fails\n     * @param orders orders[0] is the long order and orders[1] is the short order\n     * @param matchInfo intermediate information about which order came first and which eventually decides what fee to charge\n     * @param fillAmount Amount of base asset to be traded between the two orders. Should be +ve. Scaled by 1e18\n     * @param fulfillPrice Price at which the orders should be matched. Scaled by 1e6.\n     * @return openInterest The total open interest in the market after the trade is executed\n    */\n    function openComplementaryPositions(\n        IOrderBook.Order[2] calldata orders,\n        IOrderBook.MatchInfo[2] calldata matchInfo,\n        int256 fillAmount,\n        uint fulfillPrice\n    )   external\n        onlyOrderBook\n        returns (uint256 openInterest)\n    {\n\n        try this.openPosition(orders[0], fillAmount, fulfillPrice, matchInfo[0].mode, false) {\n            // only executed if the above doesn't revert\n            try this.openPosition(orders[1], -fillAmount, fulfillPrice, matchInfo[1].mode, true) returns(uint256 _openInterest) {\n                openInterest = _openInterest;\n                // only executed if the above doesn't revert\n            } catch Error(string memory reason) {\n                // will revert all state changes including those made in this.openPosition(orders[0])\n                revert(string(abi.encode(matchInfo[1].orderHash, reason)));\n            }\n        } catch Error(string memory reason) {\n            // surface up the error to the calling contract\n            revert(string(abi.encode(matchInfo[0].orderHash, reason)));\n        }\n    }\n\n    // to avoid stack too deep error\n    struct VarGroup {\n        int256 feeCharged;\n        int realizedPnl;\n        bool isPositionIncreased;\n    }\n\n   /**\n    * @notice Open/Modify/Close Position\n    * @dev uses \"onlyMySelf\" modifier to make sure the calls come from within the same contract.\n    * This function was designed in a manner that helps us use the try-catch feature of solidity to revert all state changes if any of the sub-calls revert.\n    * @param mode Whether we are executing is a maker, taker order or a liquidation\n    * @param is2ndTrade Whether this is the second trade in a pair of trades that are executed together, which is used to update the twap in the AMM contract\n    */\n    function openPosition(IOrderBook.Order calldata order, int256 fillAmount, uint256 fulfillPrice, IOrderBook.OrderExecutionMode mode, bool is2ndTrade) public onlyMySelf returns(uint openInterest) {\n        return _openPosition(order, fillAmount, fulfillPrice, mode, is2ndTrade);\n    }\n\n    function _openPosition(IOrderBook.Order memory order, int256 fillAmount, uint256 fulfillPrice, IOrderBook.OrderExecutionMode mode, bool is2ndTrade) internal returns(uint openInterest) {\n        updatePositions(order.trader); // settle funding payments\n        uint quoteAsset = abs(fillAmount).toUint256() * fulfillPrice / 1e18;\n        int size;\n        uint openNotional;\n        VarGroup memory varGroup;\n        (\n            varGroup.realizedPnl,\n            varGroup.isPositionIncreased,\n            size,\n            openNotional,\n            openInterest\n        ) = amms[order.ammIndex].openPosition(order, fillAmount, fulfillPrice, is2ndTrade);\n\n        {\n            int toFeeSink;\n            (toFeeSink, varGroup.feeCharged) = _chargeFeeAndRealizePnL(order.trader, varGroup.realizedPnl, quoteAsset, mode);\n            if (toFeeSink != 0) {\n                marginAccount.transferOutVusd(feeSink, toFeeSink.toUint256());\n            }\n        }\n        {\n            // isPositionIncreased is true when the position is increased or reversed\n            if (varGroup.isPositionIncreased) {\n                assertMarginRequirement(order.trader);\n                require(order.reduceOnly == false, \"CH: reduceOnly order can only reduce position\");\n            }\n            emit PositionModified(order.trader, order.ammIndex, fillAmount, fulfillPrice, varGroup.realizedPnl, size, openNotional, varGroup.feeCharged, mode, _blockTimestamp());\n        }\n    }\n\n    /* ****************** */\n    /*    Liquidations    */\n    /* ****************** */\n\n    /**\n     * @notice Pass instructions to the AMM contract to the liquidate 1 position and open/close/modify the other in a market.\n     * Can only be called by the orderBook contract.\n     * @dev reverts the all the state storage updates within the context of this call (and sub-calls) if an intermediate step of the call fails\n     * @param order long order if liquidating a long position, short order if liquidating a short position\n     * @param matchInfo intermediate information about the order being matched\n     * @param liquidationAmount -ve if liquidating a short pos, +ve if long. Scaled by 1e18\n     * @param price Price at which the liquidation should be executed. Scaled by 1e6.\n     * @param trader Trader being liquidated\n     * @return openInterest The total open interest in the market after the liquidation is executed\n    */\n    function liquidate(\n        IOrderBook.Order calldata order,\n        IOrderBook.MatchInfo calldata matchInfo,\n        int256 liquidationAmount,\n        uint price,\n        address trader\n    )\n        override\n        external\n        onlyOrderBook\n        returns (uint256 openInterest)\n    {\n        try this.liquidateSingleAmm(trader, order.ammIndex, price, liquidationAmount) {\n            // only executed if the above doesn't revert\n            try this.openPosition(order, liquidationAmount, price, matchInfo.mode, true) returns(uint256 _openInterest) {\n                openInterest = _openInterest;\n            } catch Error(string memory reason) {\n                // will revert all state changes including those made in this.liquidateSingleAmm\n                revert(string(abi"
    }
  ]
}