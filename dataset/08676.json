{
  "Title": "[H-13] Illuminate PT redeeming allows for burning from other accounts",
  "Content": "_Submitted by hyh, also found by 0x1f8b, 0x29A, cccz, Chom, csanuragjain, hansfriese, itsmeSTYJ, kenzo, pashov, shenwilly, Soosh, and unforgiven_\n\nIlluminate PT burns shares from a user supplied address account instead of user's account. With such a discrepancy a malicious user can burn all other's user shares by having the necessary shares on her balance, while burning them from everyone else.\n\nSetting the severity to be high as this allows for system-wide stealing of user's funds.\n\n### Proof of Concept\n\nRedeemer's Illuminate redeem() checks the balance of msg.sender, but burns from the balance of user supplied `o` address:\n\n<https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L114-L128>\n\nL120:\n\n```solidity\nuint256 amount = token.balanceOf(msg.sender);\n```\n\nL126:\n\n```solidity\ntoken.burn(o, amount);\n```\n\n```solidity\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n\n        if (p == uint8(MarketPlace.Principals.Illuminate)) {\n            // Get Illuminate's principal token\n            IERC5095 token = IERC5095(principal);\n            // Get the amount of tokens to be redeemed from the sender\n            uint256 amount = token.balanceOf(msg.sender);\n            // Make sure the market has matured\n            if (block.timestamp < token.maturity()) {\n                revert Invalid('not matured');\n            }\n            // Burn the prinicipal token from Illuminate\n            token.burn(o, amount);\n            // Transfer the original underlying token back to the user\n            Safe.transferFrom(IERC20(u), lender, address(this), amount);\n```\n\n`o` address isn't validated and used as provided.\n\nBurning proceeds as usual, Illuminate PT burns second argument `a` from the first argument `f`, i.e. `f`'s balance to be reduced by `a`:\n\n<https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/marketplace/ERC5095.sol#L121-L127>\n\n```solidity\n    /// @param f Address to burn from\n    /// @param a Amount to burn\n    /// @return bool true if successful\n    function burn(address f, uint256 a) external onlyAdmin(redeemer) returns (bool) {\n        _burn(f, a);\n        return true;\n    }\n```\n\n<https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/marketplace/ERC5095.sol#L7>\n\n```solidity\ncontract ERC5095 is ERC20Permit, IERC5095 {\n```\n\n<https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/marketplace/ERC20.sol#L187-L196>\n\n```solidity\n    function _burn(address src, uint wad) internal virtual returns (bool) {\n        unchecked {\n            require(_balanceOf[src] >= wad, \"ERC20: Insufficient balance\");\n            _balanceOf[src] = _balanceOf[src] - wad;\n            _totalSupply = _totalSupply - wad;\n            emit Transfer(src, address(0), wad);\n        }\n\n        return true;\n    }\n```\n\nThis way a malicious user owning some Illuminate PT can burn the same amount of PT as she owns from any another account, that is essentially from all other accounts, obtaining all the underlying tokens from the system. The behavior is somewhat similar to the public burn case.\n\n### Recommended Mitigation Steps\n\n`o` address looks to be not needed in Illuminate PT case.\n\nConsider burning the shares from `msg.sender`, for example:\n\n<https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L125-L126>\n\n```solidity\n            // Burn the prinicipal token from Illuminate\n-           token.burn(o, amount);\n+           token.burn(msg.sender, amount);\n```\n\n**[sourabhmarathe (Illuminate) confirmed](https://github.com/code-423n4/2022-06-illuminate-findings/issues/387)**\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2022-06-illuminate",
  "Code": [
    {
      "filename": "redeemer/Redeemer.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Interfaces.sol';\nimport './MarketPlace.sol';\nimport './Safe.sol';\n\n/// @title Redeemer\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice The Redeemer contract is used to redeem the underlying lent capital of a loan.\n/// @notice Users may redeem their ERC-5095 tokens for the underlying asset represented by that token after maturity.\ncontract Redeemer {\n    error Invalid(string);\n    error Unauthorized();\n    error Exists(string);\n\n    /// @notice address that is allowed to set the lender and marketplace\n    address public admin;\n    /// @notice address used to access the MarketPlace's markets mapping\n    address public marketPlace;\n    /// @notice address that custodies principal tokens for all markets\n    address public lender;\n\n\n    /// @notice third party contract needed to lend on Swivel\n    address public swivelAddr;\n    /// @notice third party contract needed to lend on Pendle\n    address public immutable pendleAddr;\n    /// @notice third party contract needed to lend on Tempus\n    address public immutable tempusAddr;\n    /// @notice third party contract needed to lend on APWine\n    address public apwineAddr;\n\n    /// @notice emitted upon redemption of a loan\n    event Redeem(uint8 principal, address indexed underlying, uint256 indexed maturity, uint256 amount);\n\n    /// @notice Initializes the Redeemer contract\n    /// @param l the lender contract\n    /// @param s the Swivel contract\n    /// @param p the Pendle contract\n    /// @param t the Tempus contract\n    /// @param a the APWine contract\n    constructor(\n        address l,\n        address s,\n        address p,\n        address t,\n        address a\n    ) {\n        admin = msg.sender;\n        lender = l;\n        swivelAddr = s;\n        pendleAddr = p;\n        tempusAddr = t;\n        apwineAddr = a;\n    }\n\n    /// @notice sets the admin address\n    /// @param a Address of a new admin\n    /// @return bool true if successful\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        return true;\n    }\n\n    /// @notice sets the address of the marketplace contract which contains the addresses of all the fixed rate markets\n    /// @param m the address of the marketplace contract\n    /// @return bool true if the address was set, false otherwise\n    function setMarketPlace(address m) external authorized(admin) returns (bool) {\n        if (marketPlace != address(0)) {\n            revert Exists('marketplace');\n        }\n        marketPlace = m;\n        return true;\n    }\n\n    /// @notice sets the address of the lender contract which contains the addresses of all the fixed rate markets\n    /// @param l the address of the lender contract\n    /// @return bool true if the address was set, false otherwise\n    function setLender(address l) external authorized(admin) returns (bool) {\n        if (lender != address(0)) {\n            revert Exists('lender');\n        }\n        lender = l;\n        return true;\n    }\n\n    /// @notice sets the feenominator to the given value\n    /// @param s the address of the Swivel.sol Router\n    /// @return bool true if successful\n    function setSwivel(address s) external authorized(admin) returns (bool) {\n        swivelAddr = s;\n        return true;\n    }\n\n    /// @notice redeems underlying token for Illuminate, APWine and Tempus protocols\n    /// @dev Illuminate burns its tokens prior to redemption, unlike APWine and\n    /// Tempus, which redeem PTs to the redeemer, transferring the underlying to\n    /// this redeemer contract. Consequently, only Illuminate's redeem returns funds\n    /// to the user.\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u the underlying token being redeemed\n    /// @param m the maturity of the market being redeemed\n    /// @param o address of the controller or contract that manages the underlying token\n    /// @return bool true if the redemption was successful\n    function redeem(\n        uint8 p,\n        address u,\n        uint256 m,\n        address o\n    ) public returns (bool) {\n        // Get the address of the principal token being redeemed\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n\n        if (p == uint8(MarketPlace.Principals.Illuminate)) {\n            // Get Illuminate's principal token\n            IERC5095 token = IERC5095(principal);\n            // Get the amount of tokens to be redeemed from the sender\n            uint256 amount = token.balanceOf(msg.sender);\n            // Make sure the market has matured\n            if (block.timestamp < token.maturity()) {\n                revert Invalid('not matured');\n            }\n            // Burn the prinicipal token from Illuminate\n            token.burn(o, amount);\n            // Transfer the original underlying token back to the user\n            Safe.transferFrom(IERC20(u), lender, address(this), amount);\n\n            emit Redeem(0, u, m, amount);\n        }\n        else {\n            // Get the amount of tokens to be redeemed from the principal token\n            uint256 amount = IERC20(principal).balanceOf(lender);\n            // Transfer the principal token from the lender contract to here\n            Safe.transferFrom(IERC20(u), lender, address(this), amount);\n\n            if (p == uint8(MarketPlace.Principals.Apwine)) {\n                // Redeem the underlying token from APWine to Illuminate\n                IAPWine(apwineAddr).withdraw(o, amount);\n            } else if (p == uint8(MarketPlace.Principals.Tempus)) {\n                // Redeem the tokens from the Tempus contract to Illuminate\n                ITempus(tempusAddr).redeemToBacking(o, amount, 0, address(this));\n            } else {\n                revert Invalid('principal');\n            }\n            emit Redeem(0, u, m, amount);\n        }\n\n        return true;\n    }\n\n    /// @notice redeem method for Swivel, Yield, Element and Notional protocols\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u underlying token being redeemed\n    /// @param m maturity of the market being redeemed\n    /// @return bool true if the redemption was successful\n    function redeem(\n        uint8 p,\n        address u,\n        uint256 m\n    ) public returns (bool) {\n        // Get the principal token that is being redeemed by the user\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n\n        // Make sure we have the correct principal\n        if (\n            p != uint8(MarketPlace.Principals.Swivel) &&\n            p != uint8(MarketPlace.Principals.Element) &&\n            p != uint8(MarketPlace.Principals.Yield) &&\n            p != uint8(MarketPlace.Principals.Notional)\n        ) {\n            revert Invalid('principal');\n        }\n\n        // The amount redeemed should be the balance of the principal token held by the Illuminate contract\n        uint256 amount = IERC20(principal).balanceOf(lender);\n\n        // Transfer the principal token from the lender contract to here\n        Safe.transferFrom(IERC20(principal), lender, address(this), amount);\n\n        if (p == uint8(MarketPlace.Principals.Swivel)) {\n            // Redeems zc tokens to the sender's address\n            ISwivel(swivelAddr).redeemZcToken(u, m, amount);\n        } else if (p == uint8(MarketPlace.Principals.Element)) {\n            // Redeems principal tokens from element\n            IElementToken(principal).withdrawPrincipal(amount, marketPlace);\n        } else if (p == uint8(MarketPlace.Principals.Yield)) {\n            // Redeems prinicipal tokens from yield\n            IYieldToken(principal).redeem(address(this), address(this), amount);\n        } else if (p == uint8(MarketPlace.Principals.Notional)) {\n            // Redeems the principal token from notional\n            amount = INotional(principal).maxRedeem(address(this));\n        }\n\n        emit Redeem(p, u, m, amount);\n        return true;\n    }\n\n    /// @notice redeem method signature for Pendle\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u underlying token being redeemed\n    /// @param m maturity of the market being redeemed\n    /// @param i forge id used by Pendle to redeem the underlying token\n    /// @return bool true if the redemption was successful\n    function redeem(\n        uint8 p,\n        address u,\n        uint256 m,\n        bytes32 i\n    ) public returns (bool) {\n        // Check the principal is Pendle\n        if (p != uint8(MarketPlace.Principals.Pendle)) {\n            revert Invalid('principal');\n        }\n\n        // Get the principal token that is being redeemed by the user\n        IERC20 token = IERC20(IMarketPlace(marketPlace).markets(u, m, p));\n\n        // Get the balance of tokens to be redeemed by the user\n        uint256 amount = token.balanceOf(lender);\n\n        // Transfer the user's tokens to the redeem contract\n        Safe.transferFrom(token, lender, address(this), amount);\n\n        // Redeem the tokens from the Pendle contract\n        IPendle(pendleAddr).redeemAfterExpiry(i, u, m);\n        \n        emit Redeem(p, u, m, amount);\n        return true;\n    }\n\n    /// @notice redeem method signature for Sense\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u underlying token being redeemed\n    /// @param m maturity of the market being redeemed\n    /// @param d Sense contract that splits the loan's prinicpal and yield\n    /// @param o Sense contract that [d] calls into to adapt the underlying to Sense\n    /// @return bool true if the redemption was successful\n    function redeem(\n        uint8 p,\n        address u,\n        uint256 m,\n        address d,\n        address o\n    ) public returns (bool) {\n        // Check the principal is Sense\n        if (p != uint8(MarketPlace.Principals.Sense)) {\n            revert Invalid('principal');\n        }\n\n        // Get the principal token for the given market\n        IERC20 token = IERC20(IMarketPlace(marketPlace).markets(u, m, p));\n\n        // Get the balance of tokens to be redeemed by the user\n        uint256 amount = token.balanceOf(lender);\n\n        // Transfer the user's tokens to the redeem contract\n        Safe.transferFrom(token, lender, address(this), amount);\n\n        // Redeem the tokens from the Sense contract\n        ISense(d).redeem(o, m, amount);\n\n        emit Redeem(p, u, m, amount);\n        return true;\n    }\n\n    /// @notice implements the redeem method for the contract to fulfill the ERC-5095 interface\n    /// @param u address of the underlying asset\n    /// @param m maturity of the market\n    /// @param f address from where the underlying asset will be burned\n    /// @param t address to where the underlying asset will be transferred\n    /// @param a amount of the underlying asset to be burned and sent to the to\n    /// @return bool true if the underlying asset was burned successfully\n    function authRedeem(\n        address u,\n        uint256 m,\n        address f,\n        address t,\n        uint256 a\n    ) public authorized(IMarketPlace(marketPlace).markets(u, m, 0)) returns (bool) {\n        // Get the principal token for the given market\n        IERC5095 pt = IERC5095(IMarketPlace(marketPlace).markets(u, m, 0));\n\n        // Make sure the market has matured\n        if (block.timestamp < pt.maturity()) {\n            revert Invalid('not matured');\n        }\n\n        // Burn the user's principal tokens\n        pt.burn(f, a);\n\n        // Transfer the original underlying token back to the user\n        Safe.transfer(IERC20(u), t, a);\n        return true;\n    }\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Unauthorized();\n        }\n        _;\n    }\n}"
    },
    {
      "filename": "marketplace/ERC5095.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./Interfaces.sol\";\nimport \"./ERC20Permit.sol\";\n\ncontract ERC5095 is ERC20Permit, IERC5095 {\n    /// @dev unix timestamp when the ERC5095 token can be redeemed\n    uint256 public override immutable maturity;\n    /// @dev address of the ERC20 token that is returned on ERC5095 redemption\n    address public override immutable underlying;\n    /// @dev address of the minting authority\n    address public immutable lender;\n    \n    /////////////OPTIONAL///////////////// (Allows the calculation and distribution of yield post maturity)\n    /// @dev address and interface for an external custody contract (necessary for some project's backwards compatability)\n    address public immutable redeemer;\n\n    error Maturity(uint256 timestamp);  \n\n    constructor(address _underlying, uint256 _maturity, address _redeemer, address l, string memory name_, string memory symbol_, uint8 decimals_) ERC20Permit(name_, symbol_, decimals_) {\n        underlying = _underlying;\n        maturity = _maturity;\n        redeemer = _redeemer;\n        lender = l;\n    }\n\n    /// @notice Post maturity converts an amount of principal tokens to an amount of underlying that would be returned. Returns 0 pre-maturity.\n    /// @param principalAmount The amount of principal tokens to convert\n    /// @return underlyingAmount The amount of underlying tokens returned by the conversion\n    function convertToUnderlying(uint256 principalAmount) external override view returns (uint256 underlyingAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (principalAmount);\n    }\n\n    /// @notice Post maturity converts a desired amount of underlying tokens returned to principal tokens needed. Returns 0 pre-maturity.\n    /// @param underlyingAmount The amount of underlying tokens to convert\n    /// @return principalAmount The amount of principal tokens returned by the conversion\n    function convertToPrincipal(uint256 underlyingAmount) external override view returns (uint256 principalAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (underlyingAmount);\n    }\n\n    /// @notice Post maturity calculates the amount of principal tokens that `owner` can redeem. Returns 0 pre-maturity.\n    /// @param owner The address of the owner for which redemption is calculated\n    /// @return maxPrincipalAmount The maximum amount of principal tokens that `owner` can redeem.\n    function maxRedeem(address owner) external override view returns (uint256 maxPrincipalAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (_balanceOf[owner]);\n    }\n\n    /// @notice Post maturity simulates the effects of redeemption at the current block. Returns 0 pre-maturity.\n    /// @param principalAmount the amount of principal tokens redeemed in the simulation\n    /// @return underlyingAmount The maximum amount of underlying returned by `principalAmount` of PT redemption\n    function previewRedeem(uint256 principalAmount) external override view returns (uint256 underlyingAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (principalAmount);\n    }\n\n    /// @notice Post maturity calculates the amount of underlying tokens that `owner` can withdraw. Returns 0 pre-maturity.\n    /// @param  owner The address of the owner for which withdrawal is calculated\n    /// @return maxUnderlyingAmount The maximum amount of underlying tokens that `owner` can withdraw.\n    function maxWithdraw(address owner) external override view returns (uint256 maxUnderlyingAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (_balanceOf[owner]);\n    }\n\n    /// @notice Post maturity simulates the effects of withdrawal at the current block. Returns 0 pre-maturity.\n    /// @param underlyingAmount the amount of underlying tokens withdrawn in the simulation\n    /// @return principalAmount The amount of principal tokens required for the withdrawal of `underlyingAmount`\n    function previewWithdraw(uint256 underlyingAmount) external override view returns (uint256 principalAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (underlyingAmount);\n    }\n\n    /// @notice At or after maturity, Burns principalAmount from `owner` and sends exactly `underlyingAmount` of underlying tokens to `receiver`.\n    /// @param underlyingAmount The amount of underlying tokens withdrawn\n    /// @param receiver The receiver of the underlying tokens being withdrawn\n    /// @return principalAmount The amount of principal tokens burnt by the withdrawal\n    function withdraw(uint256 underlyingAmount, address receiver, address holder) external override returns (uint256 principalAmount){\n        if (block.timestamp < maturity) {\n            revert Maturity(maturity);\n        }\n        if (holder == msg.sender) {\n            return IRedeemer(redeemer).authRedeem(underlying, maturity, msg.sender, receiver, underlyingAmount);\n        }\n        else {\n            require(_allowance[holder][msg.sender] >= underlyingAmount, 'not enough approvals');\n            return IRedeemer(redeemer).authRedeem(underlying, maturity, holder, receiver, underlyingAmount);     \n        }\n    }\n\n    /// @notice At or after maturity, burns exactly `principalAmount` of Principal Tokens from `owner` and sends underlyingAmount of underlying tokens to `receiver`.\n    /// @param receiver The receiver of the underlying tokens being withdrawn\n    /// @return underlyingAmount The amount of underlying tokens distributed by the redemption\n    function redeem(uint256 principalAmount, address receiver, address holder) external override returns (uint256 underlyingAmount){\n        if (block.timestamp < maturity) {\n            revert Maturity(maturity);\n        }\n        if (holder == msg.sender) {\n            return IRedeemer(redeemer).authRedeem(underlying, maturity, msg.sender, receiver, principalAmount);\n        }\n        else {\n            require(_allowance[holder][msg.sender] >= underlyingAmount, 'not enough approvals');\n            return IRedeemer(redeemer).authRedeem(underlying, maturity, holder, receiver, principalAmount);     \n        }\n    }\n\n    /// @param f Address to burn from\n    /// @param a Amount to burn\n    /// @return bool true if successful\n    function burn(address f, uint256 a) external onlyAdmin(redeemer) returns (bool) {\n        _burn(f, a);\n        return true;\n    }\n\n    /// @param t Address recieving the minted amount\n    /// @param a The amount to mint\n    /// @return bool true if successful\n    function mint(address t, uint256 a) external onlyAdmin(lender) returns (bool) {\n        _mint(t, a);\n        return true;\n    }\n\n    /// @param a Admin address\n    modifier onlyAdmin(address a) {\n    require(msg.sender == a, 'sender must be admin');\n    _;\n    }\n}"
    },
    {
      "filename": "marketplace/ERC5095.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./Interfaces.sol\";\nimport \"./ERC20Permit.sol\";\n\ncontract ERC5095 is ERC20Permit, IERC5095 {\n    /// @dev unix timestamp when the ERC5095 token can be redeemed\n    uint256 public override immutable maturity;\n    /// @dev address of the ERC20 token that is returned on ERC5095 redemption\n    address public override immutable underlying;\n    /// @dev address of the minting authority\n    address public immutable lender;\n    \n    /////////////OPTIONAL///////////////// (Allows the calculation and distribution of yield post maturity)\n    /// @dev address and interface for an external custody contract (necessary for some project's backwards compatability)\n    address public immutable redeemer;\n\n    error Maturity(uint256 timestamp);  \n\n    constructor(address _underlying, uint256 _maturity, address _redeemer, address l, string memory name_, string memory symbol_, uint8 decimals_) ERC20Permit(name_, symbol_, decimals_) {\n        underlying = _underlying;\n        maturity = _maturity;\n        redeemer = _redeemer;\n        lender = l;\n    }\n\n    /// @notice Post maturity converts an amount of principal tokens to an amount of underlying that would be returned. Returns 0 pre-maturity.\n    /// @param principalAmount The amount of principal tokens to convert\n    /// @return underlyingAmount The amount of underlying tokens returned by the conversion\n    function convertToUnderlying(uint256 principalAmount) external override view returns (uint256 underlyingAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (principalAmount);\n    }\n\n    /// @notice Post maturity converts a desired amount of underlying tokens returned to principal tokens needed. Returns 0 pre-maturity.\n    /// @param underlyingAmount The amount of underlying tokens to convert\n    /// @return principalAmount The amount of principal tokens returned by the conversion\n    function convertToPrincipal(uint256 underlyingAmount) external override view returns (uint256 principalAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (underlyingAmount);\n    }\n\n    /// @notice Post maturity calculates the amount of principal tokens that `owner` can redeem. Returns 0 pre-maturity.\n    /// @param owner The address of the owner for which redemption is calculated\n    /// @return maxPrincipalAmount The maximum amount of principal tokens that `owner` can redeem.\n    function maxRedeem(address owner) external override view returns (uint256 maxPrincipalAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (_balanceOf[owner]);\n    }\n\n    /// @notice Post maturity simulates the effects of redeemption at the current block. Returns 0 pre-maturity.\n    /// @param principalAmount the amount of principal tokens redeemed in the simulation\n    /// @return underlyingAmount The maximum amount of underlying returned by `principalAmount` of PT redemption\n    function previewRedeem(uint256 principalAmount) external override view returns (uint256 underlyingAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (principalAmount);\n    }\n\n    /// @notice Post maturity calculates the amount of underlying tokens that `owner` can withdraw. Returns 0 pre-maturity.\n    /// @param  owner The address of the owner for which withdrawal is calculated\n    /// @return maxUnderlyingAmount The maximum amount of underlying tokens that `owner` can withdraw.\n    function maxWithdraw(address owner) external override view returns (uint256 maxUnderlyingAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (_balanceOf[owner]);\n    }\n\n    /// @notice Post maturity simulates the effects of withdrawal at the current block. Returns 0 pre-maturity.\n    /// @param underlyingAmount the amount of underlying tokens withdrawn in the simulation\n    /// @return principalAmount The amount of principal tokens required for the withdrawal of `underlyingAmount`\n    function previewWithdraw(uint256 underlyingAmount) external override view returns (uint256 principalAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (underlyingAmount);\n    }\n\n    /// @notice At or after maturity, Burns principalAmount from `owner` and sends exactly `underlyingAmount` of underlying tokens to `receiver`.\n    /// @param underlyingAmount The amount of underlying tokens withdrawn\n    /// @param receiver The receiver of the underlying tokens being withdrawn\n    /// @return principalAmount The amount of principal tokens burnt by the withdrawal\n    function withdraw(uint256 underlyingAmount, address receiver, address holder) external override returns (uint256 principalAmount){\n        if (block.timestamp < maturity) {\n            revert Maturity(maturity);\n        }\n        if (holder == msg.sender) {\n            return IRedeemer(redeemer).authRedeem(underlying, maturity, msg.sender, receiver, underlyingAmount);\n        }\n        else {\n            require(_allowance[holder][msg.sender] >= underlyingAmount, 'not enough approvals');\n            return IRedeemer(redeemer).authRedeem(underlying, maturity, holder, receiver, underlyingAmount);     \n        }\n    }\n\n    /// @notice At or after maturity, burns exactly `principalAmount` of Principal Tokens from `owner` and sends underlyingAmount of underlying tokens to `receiver`.\n    /// @param receiver The receiver of the underlying tokens being withdrawn\n    /// @return underlyingAmount The amount of underlying tokens distributed by the redemption\n    function redeem(uint256 principalAmount, address receiver, address holder) external override returns (uint256 underlyingAmount){\n        if (block.timestamp < maturity) {\n            revert Maturity(maturity);\n        }\n        if (holder == msg.sender) {\n            return IRedeemer(redeemer).authRedeem(underlying, maturity, msg.sender, receiver, principalAmount);\n        }\n        else {\n            require(_allowance[holder][msg.sender] >= underlyingAmount, 'not enough approvals');\n            return IRedeemer(redeemer).authRedeem(underlying, maturity, holder, receiver, principalAmount);     \n        }\n    }\n\n    /// @param f Address to burn from\n    /// @param a Amount to burn\n    /// @return bool true if successful\n    function burn(address f, uint256 a) external onlyAdmin(redeemer) returns (bool) {\n        _burn(f, a);\n        return true;\n    }\n\n    /// @param t Address recieving the minted amount\n    /// @param a The amount to mint\n    /// @return bool true if successful\n    function mint(address t, uint256 a) external onlyAdmin(lender) returns (bool) {\n        _mint(t, a);\n        return true;\n    }\n\n    /// @param a Admin address\n    modifier onlyAdmin(address a) {\n    require(msg.sender == a, 'sender must be admin');\n    _;\n    }\n}"
    },
    {
      "filename": "marketplace/ERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Inspired on token.sol from DappHub. Natspec adpated from OpenZeppelin.\npragma solidity ^0.8.0;\n\nimport \"./Interfaces.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n * \n * Calls to {transferFrom} do not check for allowance if the caller is the owner\n * of the funds. This allows to reduce the number of approvals that are necessary.\n *\n * Finally, {transferFrom} does not decrease the allowance if it is set to\n * type(uint256).max. This reduces the gas costs without any likely impact.\n */\ncontract ERC20 is IERC20Metadata {\n    uint256                                           internal  _totalSupply;\n    mapping (address => uint256)                      internal  _balanceOf;\n    mapping (address => mapping (address => uint256)) internal  _allowance;\n    string                                            public override name = \"???\";\n    string                                            public override symbol = \"???\";\n    uint8                                             public override decimals = 18;\n\n    /**\n     *  @dev Sets the values for {name}, {symbol} and {decimals}.\n     */\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) {\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() external view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address guy) external view virtual override returns (uint256) {\n        return _balanceOf[guy];\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) external view virtual override returns (uint256) {\n        return _allowance[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     */\n    function approve(address spender, uint wad) external virtual override returns (bool) {\n        return _setAllowance(msg.sender, spender, wad);\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - the caller must have a balance of at least `wad`.\n     */\n    function transfer(address dst, uint wad) external virtual override returns (bool) {\n        return _transfer(msg.sender, dst, wad);\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `src` must have a balance of at least `wad`.\n     * - the caller is not `src`, it must have allowance for ``src``'s tokens of at least\n     * `wad`.\n     */\n    /// if_succeeds {:msg \"TransferFrom - decrease allowance\"} msg.sender != src ==> old(_allowance[src][msg.sender]) >= wad;\n    function transferFrom(address src, address dst, uint wad) external virtual override returns (bool) {\n        _decreaseAllowance(src, wad);\n\n        return _transfer(src, dst, wad);\n    }\n\n    /**\n     * @dev Moves tokens `wad` from `src` to `dst`.\n     * \n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `src` must have a balance of at least `amount`.\n     */\n    /// if_succeeds {:msg \"Transfer - src decrease\"} old(_balanceOf[src]) >= _balanceOf[src];\n    /// if_succeeds {:msg \"Transfer - dst increase\"} _balanceOf[dst] >= old(_balanceOf[dst]);\n    /// if_succeeds {:msg \"Transfer - supply\"} old(_balanceOf[src]) + old(_balanceOf[dst]) == _balanceOf[src] + _balanceOf[dst];\n    function _transfer(address src, address dst, uint wad) internal virtual returns (bool) {\n        require(_balanceOf[src] >= wad, \"ERC20: Insufficient balance\");\n        unchecked { _balanceOf[src] = _balanceOf[src] - wad; }\n        _balanceOf[dst] = _balanceOf[dst] + wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n\n    /**\n     * @dev Sets the allowance granted to `spender` by `owner`.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     */\n    function _setAllowance(address owner, address spender, uint wad) internal virtual returns (bool) {\n        _allowance[owner][spender] = wad;\n        emit Approval(owner, spender, wad);\n\n        return true;\n    }\n\n    /**\n     * @dev Decreases the allowance granted to the caller by `src`, unless src == msg.sender or _allowance[src][msg.sender] == MAX\n     *\n     * Emits an {Approval} event indicating the updated allowance, if the allowance is updated.\n     *\n     * Requirements:\n     *\n     * - `spender` must have allowance for the caller of at least\n     * `wad`, unless src == msg.sender\n     */\n    /// if_succeeds {:msg \"Decrease allowance - underflow\"} old(_allowance[src][msg.sender]) <= _allowance[src][msg.sender];\n    function _decreaseAllowance(address src, uint wad) internal virtual returns (bool) {\n        if (src != msg.sender) {\n            uint256 allowed = _allowance[src][msg.sender];\n            if (allowed != type(uint).max) {\n                require(allowed >= wad, \"ERC20: Insufficient approval\");\n                unchecked { _setAllowance(src, msg.sender, allowed - wad); }\n            }\n        }\n\n        return true;\n    }\n\n    /** @dev Creates `wad` tokens and assigns them to `dst`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     */\n    /// if_succeeds {:msg \"Mint - balance overflow\"} old(_balanceOf[dst]) >= _balanceOf[dst];\n    /// if_succeeds {:msg \"Mint - supply overflow\"} old(_totalSupply) >= _totalSupply;\n    function _mint(address dst, uint wad) internal virtual returns (bool) {\n        _balanceOf[dst] = _balanceOf[dst] + wad;\n        _totalSupply = _totalSupply + wad;\n        emit Transfer(address(0), dst, wad);\n\n        return true;\n    }\n\n    /**\n     * @dev Destroys `wad` tokens from `src`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `src` must have at least `wad` tokens.\n     */"
    }
  ]
}