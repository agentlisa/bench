{
  "Title": "M-1: `earlyExitById()` and `exitLateById()` calls near the end of `lockPeriod` are vulnerable to attacks.",
  "Content": "# Issue M-1: `earlyExitById()` and `exitLateById()` calls near the end of `lockPeriod` are vulnerable to attacks. \n\nSource: https://github.com/sherlock-audit/2024-05-gamma-staking-judging/issues/65 \n\n## Found by \n0xRajkumar, 0xreadyplayer1, EgisSecurity, HChang26, KupiaSec, T\\_F\\_E, denzi\\_, emrekocak, h2134, kennedy1030, no, petro1912, pkqs90, samuraii77, yamato, zraxx\n## Summary\n`earlyExitById()` and `exitLateById()` calls near the end of `lockPeriod` are vulnerable to attacks.\n## Vulnerability Detail\nLocks are automatically re-locked at the end of the `lockPeriod` for the lesser of `lockPeriod` or `defaultRelockTime`.\n\nThe protocol offers 2 methods for stakers to unstake, `earlyExitById()` and `exitLateById()`. Both methods use `calcRemainUnlockPeriod()` to calculate `unlockTime`.\n\n```solidity\n    function calcRemainUnlockPeriod(LockedBalance memory userLock) public view returns (uint256) {\n        uint256 lockTime = userLock.lockTime;\n        uint256 lockPeriod = userLock.lockPeriod;\n\n        if (lockPeriod <= defaultRelockTime || (block.timestamp - lockTime) < lockPeriod) {\n            return lockPeriod - (block.timestamp - lockTime) % lockPeriod;\n        } else {\n            return defaultRelockTime - (block.timestamp - lockTime) % defaultRelockTime;\n        }\n    }\n```\n\n`exitLateById()` is the default method, where the lock `id` stops accumulating rewards immediately. The `unlockTime`/cool-down period is calculated by `calcRemainUnlockPeriod()`. Funds are only available for withdrawal after `unlockTime`.\n\nFor example:\nThe `unlockTime` is dictated by modulo logic in function `calcRemainUnlockPeriod()`. So if the lock time were 30 days, and the user staked for 50 days, he would have been deemed to lock for a full cycle of 30 days, followed by 20 days into the second cycle of 30 days, and thus will have 10 days left before he can withdraw his funds.\n\nBased on this design, it is in stakers' best interest to invoke `exitLateById()` towards the end of a `lockPeriod` when there are only a few seconds left before it auto re-locks for another 30 days. This maximizes rewards and minimizes the cool-down period.\n\nIf a staker invokes `exitLateById()` 1 minute before auto re-lock, two scenarios can occur depending on when the transaction is mined:\n1. If the transaction is mined before the auto re-lock, the staker's funds become available after a 1-minute cool-down period.\n2. If the transaction is mined after the auto re-lock, the staker's funds will not be available for another 30 days.\n\nAttackers can grief honest stakers by front-running `exitLateById()` with a series of dummy transactions to fill up the block. If `exitLateById()` is mined after the auto re-lock, the staker must wait another 30 days. The only way to avoid this is to call `exitLateById()` well before the end of the `lockPeriod` when block stuffing is not feasible, reducing the potential reward earned by the staker.\n\n```solidity\n    function exitLateById(uint256 id) external {\n        _updateReward(msg.sender);\n\n        LockedBalance memory lockedBalance = locklist.getLockById(msg.sender, id); // Retrieves the lock details from the lock list as a storage reference to modify.\n\n     ->uint256 coolDownSecs = calcRemainUnlockPeriod(lockedBalance);\n        locklist.updateUnlockTime(msg.sender, id, block.timestamp + coolDownSecs);\n\n        uint256 multiplierBalance = lockedBalance.amount * lockedBalance.multiplier;\n        lockedSupplyWithMultiplier -= multiplierBalance;\n        lockedSupply -= lockedBalance.amount;\n        Balances storage bal = balances[msg.sender];\n        bal.lockedWithMultiplier -= multiplierBalance;\n        bal.locked -= lockedBalance.amount;\n\n        locklist.setExitedLateToTrue(msg.sender, id);\n\n        _updateRewardDebt(msg.sender); // Recalculates reward debt after changing the locked balance.\n\n        emit ExitLateById(id, msg.sender, lockedBalance.amount); // Emits an event logging the details of the late exit.\n    }\n```\n\n\n\n`earlyExitById()` is the second method to unstake. In this function, the staker pays a penalty but can access funds immediately. The penalty consists of a base penalty plus a time penalty, which decreases linearly over time. The current configuration sets the minimum penalty at 15% and the maximum penalty at 50%.\n```solidity\n    function earlyExitById(uint256 lockId) external whenNotPaused {\n        if (isEarlyExitDisabled) {\n            revert EarlyExitDisabled();\n        }\n        _updateReward(msg.sender);\n        LockedBalance memory lock = locklist.getLockById(msg.sender, lockId);\n\n        if (lock.unlockTime != 0)\n            revert InvalidLockId();\n\n        uint256 coolDownSecs = calcRemainUnlockPeriod(lock);\n        lock.unlockTime = block.timestamp + coolDownSecs;\n        uint256 penaltyAmount = calcPenaltyAmount(lock);\n        locklist.removeFromList(msg.sender, lockId);\n        Balances storage bal = balances[msg.sender];\n        lockedSupplyWithMultiplier -= lock.amount * lock.multiplier;\n        lockedSupply -= lock.amount;\n        bal.locked -= lock.amount;\n        bal.lockedWithMultiplier -= lock.amount * lock.multiplier;\n        _updateRewardDebt(msg.sender);\n\n        if (lock.amount > penaltyAmount) {\n            IERC20(stakingToken).safeTransfer(msg.sender, lock.amount - penaltyAmount);\n            IERC20(stakingToken).safeTransfer(treasury, penaltyAmount);\n            emit EarlyExitById(lockId, msg.sender, lock.amount - penaltyAmount, penaltyAmount);\n        } else {\n            IERC20(stakingToken).safeTransfer(treasury, lock.amount);\n        emit EarlyExitById(lockId, msg.sender, 0, penaltyAmount);\n        }\n    }\n```\nThe penalty is calculated in `calcPenaltyAmount()`, using `unlockTime` from `calcRemainUnlockPeriod()`.\n```solidity\n    function calcPenaltyAmount(LockedBalance memory userLock) public view returns (uint256 penaltyAmount) {\n        if (userLock.amount == 0) return 0; // Return zero if there is no amount locked to avoid unnecessary calculations.\n        uint256 unlockTime = userLock.unlockTime;\n        uint256 lockPeriod = userLock.lockPeriod;\n        uint256 penaltyFactor;\n\n\n        if (lockPeriod <= defaultRelockTime || (block.timestamp - userLock.lockTime) < lockPeriod) {\n\n            penaltyFactor = (unlockTime - block.timestamp) * timePenaltyFraction / lockPeriod + basePenaltyPercentage;\n        }\n        else {\n            penaltyFactor = (unlockTime - block.timestamp) * timePenaltyFraction / defaultRelockTime + basePenaltyPercentage;\n        }\n\n        // Apply the calculated penalty factor to the locked amount.\n        penaltyAmount = userLock.amount * penaltyFactor / WHOLE;\n    }\n```\nUsing the sample example above, if a user invokes `earlyExitById()` on day 50, the penalty is as follows:\n\nTime penalty = (10 / 30) * 35%\nBase penalty = 15%\nTotal penalty = 26.66%\n\nHowever, an issue arises when `earlyExitById()` is triggered near the end of the `lockPeriod`. Depending on when the transaction is mined, two scenarios can occur(extreme numbers were used to demonstrate impact):\n\n1. If `earlyExitById()` is mined at 59 days, 23 hours, 59 minutes, and 59 seconds, the time penalty is essentially 0%.\n2. If `earlyExitById()` is mined exactly at 60 days, this results in 100% of the time penalty.\n\nThe 1-second difference can mean the difference between the minimum penalty and the maximum penalty. An unexpectedly high penalty can occur if the transaction is sent with lower-than-average gas, causing it not to be picked up immediately. Attackers can cause stakers to incur the maximum penalty by block stuffing and delaying their transaction.\n\n## Impact\nFunds may be locked for longer than expected in `exitLateById()`\nPenalty may be greater than expected in `earlyExitById()` \n## Code Snippet\nhttps://github.com/sherlock-audit/2024-05-gamma-staking/blob/main/StakingV2/src/Lock.sol#L313\nhttps://github.com/sherlock-audit/2024-05-gamma-staking/blob/main/StakingV2/src/Lock.sol#L349\nhttps://github.com/sherlock-audit/2024-05-gamma-staking/blob/main/StakingV2/src/Lock.sol#L596\nhttps://github.com/sherlock-audit/2024-05-gamma-staking/blob/main/StakingV2/src/Lock.sol#L569\n## Tool used\n\nManual Review\n\n## Recommendation\nNo recommendation for `exitLateById()` since the optimal way to use this function is near the end of a `lockPeriod`.\n\nConsider adding slippage protection to `earlyExitById()`. \n```solidity\n-   function earlyExitById(uint256 lockId) external whenNotPaused {\n+   function earlyExitById(uint256 lockId, uint256 expectedAmount) external whenNotPaused {\n        if (isEarlyExitDisabled) {\n            revert EarlyExitDisabled();\n        }\n        _updateReward(msg.sender);\n        LockedBalance memory lock = locklist.getLockById(msg.sender, lockId);\n\n        if (lock.unlockTime != 0)\n            revert InvalidLockId();\n\n        uint256 coolDownSecs = calcRemainUnlockPeriod(lock);\n        lock.unlockTime = block.timestamp + coolDownSecs;\n        uint256 penaltyAmount = calcPenaltyAmount(lock);\n        locklist.removeFromList(msg.sender, lockId);\n        Balances storage bal = balances[msg.sender];\n        lockedSupplyWithMultiplier -= lock.amount * lock.multiplier;\n        lockedSupply -= lock.amount;\n        bal.locked -= lock.amount;\n        bal.lockedWithMultiplier -= lock.amount * lock.multiplier;\n        _updateRewardDebt(msg.sender);\n\n+       require(expectedAmount >= lock.amount - penaltyAmount);\n        if (lock.amount > penaltyAmount) {\n            IERC20(stakingToken).safeTransfer(msg.sender, lock.amount - penaltyAmount);\n            IERC20(stakingToken).safeTransfer(treasury, penaltyAmount);\n            emit EarlyExitById(lockId, msg.sender, lock.amount - penaltyAmount, penaltyAmount);\n        } else {\n            IERC20(stakingToken).safeTransfer(treasury, lock.amount);\n        emit EarlyExitById(lockId, msg.sender, 0, penaltyAmount);\n        }\n    }\n```\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/GammaStrategies/StakingV2/commit/001c056122874fe0e3fa6ece8383f2eafaf12cf5\n\n\n**0xreadyplayer1**\n\nHi @santipu03 , i hope you are good.\nI've following concerns on the cited dups .\n\n#45 is not a valid duplicate as it takes about user's action of calling exitlatebyId multiple times\n\n#307 is does not show any loss of funds and vaguely states and do not clarify how does the issue actually cause loss of funds\n\n#59 demonstrates the `use of block stuffing` `to force staker into another cycle` and does not lead to user losing funds - also as you mentioned in my issue `This isn't a feasible attack because the attacker would be losing tens of thousands of dollars each day (gas prices would go to the moon when an address is filling all blocks) just to gain nothing but to grieve others.`\nalthough not for days but tons of blocks would be needed to be filled to force the victim into new cycle which is also infeasible \nadditionally since there is `no loss of funds due to getting higher penalty` i don't believe this is a valid duplicate and even valid in the first place\n\nThe above mentioned according my reasons above are invalid and should not be duplicates`\n\nhowever i would be looking forward to what others think.\n\n\n\n\n\n\n**omar-ahsan**\n\nEscalate\n\nI would like to escalate regarding the grouping of these issues\n\nThere are two impacts caused in two different functions by not having a protection parameter.\n\n1. Causes loss of funds for the user through greater penalty amount.\n2. Causes locking of funds for the user.\n\nSubmissions that identify both impacts\n\n#65\n#42\n#228\n#294 \n#62 (0xRajKumar)\n#115 (0xRajKumar)\n#209 (pkqs90)\n#212 (pkqs90)\n\nSubmissions that only identify one impact\n\n#15 \n#16\n#41 \n#95 \n#97 \n#111\n#150\n#202 \n\nFurthermore I am not sure if #59 and #307 should be placed in any of these groups because I believe they are [invalid](https://github.com/sherlock-audit/2024-05-gamma-staking-judging/issues/65#issuecomment-2138707588)\n\nI believe it is only fair for the Watsons who have identified both impacts to be treated in a separate group, I do agree that the fix is the same for both functions, but the underlying functions and impacts are different.\n\n**sherlock-admin3**\n\n> Escalate\n> \n> I would like to escalate regarding the grouping of these issues\n> \n> There are two impacts caused in two different functions by not having a protection parameter.\n> \n> 1. Causes loss of funds for the user through greater penalty amount.\n> 2. Causes locking of funds for the user.\n> \n> Submissions that identify both impacts\n> \n> #65\n> #42\n> #228\n> #294 \n> #62 (0xRajKumar)\n> #115 (0xRajKumar)\n> #209 (pkqs90)\n> #212 (pkqs90)\n> \n> Submissions that only identify one impact\n> \n> #15 \n> #16\n> #41 \n> #95 \n> #97 \n> #111\n> #150\n> #202 \n> \n> Furthermore I am not sure if #59 and #307 should be placed in any of these groups because I believe they are [invalid](https://github.com/sherlock-audit/2024-05-gamma-staking-judging/issues/65#issuecomment-2138707588)\n> \n> I believe it is only fair for the Watsons who have identified both impacts to be treated in a separate group, I do agree that the fix is the same for both functions, but the underlying functions and impacts are different.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**0xreadyplayer1**\n\nHi there, \n\nThe issue MUST be HIGH @santipu03 \n\nbecause the issue causes `Definite loss of funds `\n\nAdditionally due to high likelihood and impact , the issue clearly deems to be a valid high..\n\nlooking forward to know what others think.\n\n**santipu03**\n\nRegarding the escalation of @omar-ahsan: \n\nI considered the root cause of this issue to be the following: **The lack of slippage parameters on exit functions will cause an unexpected loss or a lock of funds**. \n\nI agree that there are two impacts that will be caused by two functions, however, the root cause is still the same. According to the Sherlock guidelines, all issues that identify the same root cause with a valid attack path and impact should be considered duplicates, and that's why I grouped all those issues under this report. \n\nIssue #59 I considered valid because it identifies the root cause and describes a valid attack path and impact. Issue #307 also describes a correct scenario where a user may have his transaction delayed and pay extra penalties. \n\n------\n\nRegarding @0xreadyplayer1 comment, please don't try to chop definitions so they fit in your argument, the definition of a high-severity issue includes that it must not require extensive requirements or external states. For this issue to be triggered, a user must exit a lock within the last minutes of their period, which is already an unlikely scenario overall. \n\nMoreover, most of Ethereum nodes discard a transaction when it has been in the mempool for some time and is still not confirmed, if I remember correctly it was about 2 hours for Geth. This means that if a transaction hasn't been confirmed for 2 hours, it won't get executed at all. Taking this into account, this issue will only be triggered when a user tries to exit a lock with a low-gas transaction less than 2 hours before the lock period finishes, which I consider an extensive external condition. \n\nFor this reason, this issue warrants medium severity. \n\n**0xreadyplayer1**\n\nAgree @santipu03 will take care next time sir ðŸ’¯\n\n**samuraii77**\n\n@santipu03 While I wouldn't necessarily argue this issue is definitely a high, I disagree with your argument. You said that a user exiting a lock within the last minutes of the period is unlikely but that is not the case. As a matter of fact, especially for exiting late, every user would try to exit as late as possible, even in the last second if they could in order to not miss out on new potential rewards.\n\n**omar-ahsan**\n\n@santipu03 I agree the root cause is the same that there exists a lack of slippage parameters on both functions\n\nThere is also a statement in the rules guideline which states \n\n> In case the same vulnerability appears across multiple places in different contracts, they can be considered duplicates.\nThe exception to this would be if underlying code implementations, impact, and the fixes are different, then they can be treated separately.\n\nMy escalation stems from the recent judgement made in Zivoe Content on this particular group of [issues](https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/477#issuecomment-2113529960) where the above statement was used to group certain issues\n\nThe head agreed that the `core issue` is the same, the function containing the vulnerability is the same but the the impact and fixes are different hence the issues were regrouped accordingly. I believe that not all 3 are required i.e. `code implementations`, `impact`, and the `fixes` to be different. In this case the functions and impacts are different while the fix is the same for both functions.\n\nI would like to hear the opinion of the head on this and accept the decision which will be made by them.\n\n**petro1912**\n\n@omar-ahsan\nHave you looked at my issue carefully?\nTwo impacts of early and late exit were mentioned.\nâ€œUser may not withdraw at expectation time, or pay more penalty than expected.â€\nIt involves executing a transaction almost at the nearly unlock time.\nPaying more penalty means losing user's funds.\nI don't understand why my issue is not valid.\n\n\n\n**omar-ahsan**\n\n@petro1912 Your submission targets the `calcRemainUnlockPeriod()` function but does not explain through which functions the user can face these impacts, so the path is not defined, only the function through which the time is calculated.\n\n**santipu03**\n\n> In case the same vulnerability appears across multiple places in different contracts, they can be considered duplicates.\nThe exception to this would be if underlying code implementations, impact, and the fixes are different, then they can be treated separately.\n\n@omar-ahsan In this case, the impact is different but the fixes are the same, so following the above rules, all reports should be considered duplicates. The rules declare an exception, but this issue here doesn't meet the requirements for that exception. \n\n**omar-ahsan**\n\n@santipu03 like I mentioned, the head made a ruling in Zivoe when the function was same, impact was different and the fixes were different, this leads me to believe that not all 3 are required to be different. Here in this case the functions and impacts are different but fixes are same.\n\n\n**nevillehuang**\n\nI believe medium severity is appropriate here, since early exits will be an uncommon occurence and users executing an early exit for a lock within the last minutes.seconds of their period, further reduces likelihood.\n\n@omar-ahsan I also agree with lead judge comments [here](https://github.com/sherlock-audit/2024-05-gamma-staking-judging/issues/65#issuecomment-2142487086) regarding duplication, since it is clear within sherlock rules for duplication of issues with same root cause and fixes.\n\n**guhu95**\n\n@nevillehuang if #45 is a user mistake, why is this one not a user mistake? Submitting a transaction minutes or seconds before expiry is done knowingly, so the user is accepting the risk - all users know that blockhain transactions aren't immediate, and in this case they know their lock will be re-locked if not included in time.\n\nThere is no vulnerability here, the contract works as intended, and all that happened is that the user took a reckless risk for likely 0 reward. \n\nThey gain 0 reward form this because a reward distribution must happen in the few seconds / minutes before the lock expiry (because rewards are immediately distributed) - making this behavior not only a user mistake, but also a highly unlikely one due to lack of incentive.\n\n**nevillehuang**\n\n@guhu95 This issue describes a scenario where the user is calling the functions correctly before lock expires but is forced to suffer a higher penalty from early exits (a difference as large as 45% penalty). There is a loss of fund here and there is a fix that could prevent this from occuring.\n\nIn issue #45, as long as user waits for finality and not call late exits twice, their funds will never be locked, and relocks will be performed as intended per code logic (since their late exit would apply for an expired lock), so they will not lose their funds, and in fact would have the possibility to gain more rewards from the reward while retaining multiplier. After discussions with sherlocks internal judge, we conclude it is invalid/low severity based on user error.\n\n**guhu95**\n\n@nevillehuang \n\n> .. but is forced to suffer a higher penalty from early exits\n\nThey are not forced, they take the risk knowingly by submitting the tx seconds before the re-lock. They know they will be relocked if the transaction executes late. \n\nFurthermore, there's no incentive to do so as explained above. The only chance of any reward is if a distribution by the admin happens in these few seconds, and if e.g., they will happen every two weeks it means there - so if they submit 10 seconds before - there's a 0.0008% chance a distribution will happen in these 10 seconds.\n\n> There is a loss of fund here and there is a fix that could prevent this from occuring.\n\nThere is no loss of funds since a user exiting seconds before will not call \"early\" exit, they will call \"late\" exit. So this is exactly the same situation - they will just get relocked.\n\n**guhu95**\n\nThe reason a user exiting seconds before will not call \"early\" exit, is exactly because they lose some of their stake (a tiny amount) for no gain. That's because calling \"late\" will lose nothing, and will result in all of the stake returned immediately (because it's seconds before expiry). \n\nIf the user is so sensitive to a minuscule chance of a reward distribution happening in the last few seconds, they will also avoid losing part of their stake to the penalty, so will call \"late\".\n\nThis issue is entirely a user mistake, that the user commits with full knowledge, for no gain, and then just gets relocked for 30 days. Everything works as intended.\n\n**nevillehuang**\n\nAt the point when user calls an early exit, the state at which he expects it to be included is correct, that is he should not be penalized for an early exit/should not be penalized so heavily for an early exit, so he is using the function correctly. This is not user mistake to me, so I believe medium severity is appropriate.\n\nHowever, for issue #45 to be true, the user must have called late exit twice, which goes against the intended use case of the functionality. So my final decision would still be to reject escalation and keep this issue a valid medium severity.\n\n**guhu95**\n\n> At the point when user calls an early exit, the state at which he expects it to be included is correct, that is he should not be penalized for an early exit/should not be penalized so heavily for an early exit, so he is using the function correctly. This is not user mistake to me, so I believe medium severity is appropriate.\n\nA user will not call early exit in this issue, please have another look at https://github.com/sherlock-audit/2024-05-gamma-staking-judging/issues/65#issuecomment-2143623709 . The \"early exit\", with penalty, is an incorrect scenario in this case. The user will only call \"late exit\".\n\n> the state at which he expects it to be included is correct\n\nWhy is that correct? The users knows that they will be auto-relocked, and they know how penalties work, and they know blockchains execution happens with a delay. The user knows they have a very high chance of being relocked if calling seconds before, so they are aware. \n\n**joicygiore**\n\nThe project itself has a complete exit mechanism (of course, we can think that the exit conditions are unfriendly, but you have accepted this setting when you choose to enter.). Users have the right to choose to maximize their benefits to execute the exit, and they should also bear the risk of failure, which is normal. We can assume that adding exit protection will still result in the following two situations:\n1. The same operation of maximizing benefits will eventually be rolled back and continued to deposit, the difference is that there is a return, so the question is, since you can accept continuous deposits, why do you want to exit?\n2. If you want to exit, it is impossible to maximize your profits. Execute early and exit successfully.\nI don't think anyone would pay off their credit card at the last minute, as they will also be fined.\n\n**nevillehuang**\n\nI still stand by my comments [here](https://github.com/sherlock-audit/2024-05-gamma-staking-judging/issues/65#issuecomment-2143625421), at the point where user calls an early exit, they should expect to not be penalized, so this is not considered them not utilizing the protocol inappropriately. Still planning to reject escalation and leave issue as it is.\n\n**WangSecurity**\n\nResult:\nMedium\nHas duplicates\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [omar-ahsan](https://github.com/sherlock-audit/2024-05-gamma-staking-judging/issues/65/#issuecomment-2140509966): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/330",
  "Code": [
    {
      "filename": "StakingV2/src/Lock.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport {ILock, LockedBalance, Balances, Reward, RewardData} from \"./interfaces/ILock.sol\";\nimport {ILockList} from \"./interfaces/ILockList.sol\";\n\n/// @title Multi Fee Distribution Contract\n/// @author Gamma\n/// @dev All function calls are currently implemented without side effects\n\ncontract Lock is\n    ILock,\n    Initializable,\n    PausableUpgradeable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    // using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /********************** State Info ***********************/\n\n    uint256 public basePenaltyPercentage; //  15% - Represents the fixed penalty amount for unlocking early\n    uint256 public timePenaltyFraction; //  35% - Time-based penalty which decreases linearly with the passage of time\n    uint256 public constant WHOLE = 100000; // 100%\n    uint256 public defaultRelockTime;\n    bool public isEarlyExitDisabled;\n\n    /********************** Lock & Earn Info ***********************/\n\n    // Private mappings for balance data\n    mapping(address => Balances) private balances;\n\n    uint256 public lockedSupply;\n    uint256 public lockedSupplyWithMultiplier;\n\n    /********************** Reward Info ***********************/\n\n    address[] public rewardTokens;\n    mapping(address => bool) public rewardTokenAdded;\n    mapping(address => Reward) public rewardData;\n\n    uint256[] internal lockPeriod;\n    uint256[] internal rewardMultipliers;\n\n    /// @notice user -> reward token -> amount; reward amount for users\n    mapping(address => mapping(address => uint256)) public rewards;\n    /// @notice user -> reward token -> amount; paid reward amount for users\n    mapping(address => mapping(address => uint256)) public rewardPaid;\n    /// @notice user -> reward token -> amount; reward debt amount\n    mapping(address => mapping(address => uint256)) internal rewardDebt;\n\n\n    /********************** Other Info ***********************/\n\n    address public override stakingToken;\n    address public treasury;\n\n    /// @notice Users list\n    ILockList public locklist;\n\n\n    /// @notice Initializes contract with lock list, base penalty percentage, and time penalty fraction.\n    /// @dev Sets up the contract with initial configuration necessary for operation. This function acts as a substitute for a constructor in upgradeable contracts and can only be called once.\n    /// @param _locklist Address of the lock list contract, which manages lock details.\n    /// @param _basePenaltyPercentage The base penalty percentage applied for early exits, scaled by 100000 for precision.\n    /// @param _timePenaltyFraction The additional penalty fraction based on time, also scaled by 100000.\n\n    function initialize(\n        address _locklist,\n        uint128 _basePenaltyPercentage,\n        uint128 _timePenaltyFraction,\n        address _owner\n    ) public initializer {\n        __Ownable_init(_owner);\n        if (_locklist == address(0)) revert AddressZero();\n        if (_basePenaltyPercentage > WHOLE || _timePenaltyFraction > WHOLE)\n            revert WrongScaledPenaltyAmount();\n\n        locklist = ILockList(_locklist);\n        basePenaltyPercentage = _basePenaltyPercentage;\n        timePenaltyFraction = _timePenaltyFraction;\n        defaultRelockTime = 30 days;\n    }\n\n    /********************** Setters ***********************/\n\n\n    /// @notice Sets the base penalty percentage and time penalty fraction for early exits.\n    /// @dev This function can only be called by the owner of the contract and updates penalty attributes.\n    /// @param _basePenaltyPercentage The new base penalty percentage, scaled by 100000 for precision.\n    /// @param _timePenaltyFraction The new time penalty fraction, also scaled by 100000 for precision.\n    function setPenaltyCalcAttributes(uint256 _basePenaltyPercentage, uint256 _timePenaltyFraction) external onlyOwner {\n        if (_basePenaltyPercentage > WHOLE || _timePenaltyFraction > WHOLE)\n            revert WrongScaledPenaltyAmount();\n        basePenaltyPercentage = _basePenaltyPercentage;\n        timePenaltyFraction = _timePenaltyFraction;\n        emit SetPenaltyCalcAttribute(_basePenaltyPercentage, _timePenaltyFraction);\n    }\n\n    /// @notice Sets the minimum relock time after a late exit.\n    /// @dev This function can only be called by the contract owner and updates the default relock time.\n    /// @param _defaultRelockTime The new default relock time in seconds.\n    function setDefaultRelockTime(uint256 _defaultRelockTime) external onlyOwner {\n        defaultRelockTime = _defaultRelockTime;\n    }\n\n\n    /// @notice Enables or disables the ability for users to perform early exits from locks.\n    /// @dev This function can only be called by the contract owner and updates the state that controls early exits.\n    /// @param _isEarlyExitDisabled A boolean value indicating whether early exits should be disabled (`true` to disable, `false` to enable).\n    function setIsEarlyExitDisabled(bool _isEarlyExitDisabled) external onlyOwner {\n        isEarlyExitDisabled = _isEarlyExitDisabled;\n    }\n\n\n    /// @notice Configures lock periods and their corresponding reward multipliers for staking.\n    /// @dev This function can only be called by the contract owner and is used to set or update the lock periods and reward multipliers arrays.\n    /// @param _lockPeriod An array of lock periods in seconds.\n    /// @param _rewardMultipliers An array of multipliers corresponding to each lock period; these multipliers enhance the rewards for longer lock periods.\n    function setLockTypeInfo(\n        uint256[] calldata _lockPeriod,\n        uint256[] calldata _rewardMultipliers\n    ) external onlyOwner {\n        if (_lockPeriod.length != _rewardMultipliers.length)\n            revert InvalidLockPeriod();\n        delete lockPeriod;\n        delete rewardMultipliers;\n        uint256 length = _lockPeriod.length;\n        for (uint256 i; i < length; ) {\n            lockPeriod.push(_lockPeriod[i]);\n            rewardMultipliers.push(_rewardMultipliers[i]);\n            unchecked {\n                i++;\n            }\n        }\n\n        emit SetLockTypeInfo(lockPeriod, rewardMultipliers);\n    }\n\n\n    /// @notice Sets the token address that will be used for staking purposes.\n    /// @dev This function can only be called by the contract owner and will set the staking token \n    /// @param _stakingToken The address of the token to be used as the staking token.\n    function setStakingToken(address _stakingToken) external onlyOwner {\n        if (_stakingToken == address(0) || stakingToken != address(0)) revert AddressZero();\n        stakingToken = _stakingToken;\n\n        emit SetStakingToken(_stakingToken);\n    }\n\n\n    /// @notice Assigns the specified address as the treasury for the contract.\n    /// @dev This function can only be called by the contract owner to set the treasury address.\n    /// @param _treasury The address to be designated as the treasury.\n    function setTreasury(address _treasury) external onlyOwner {\n        treasury = _treasury;\n        emit SetTreasury(_treasury);\n    }\n\n\n    /// @notice Adds a new token to the list of reward tokens that will be distributed to stakers.\n    /// @dev This function can only be called by the contract owner and checks for validity of the reward token before adding.\n    /// @param _rewardToken The address of the token to be added as a reward token.\n    function addReward(address _rewardToken) external override onlyOwner {\n        if (_rewardToken == address(0)) revert InvalidBurn();\n        if (rewardData[_rewardToken].lastUpdateTime != 0) revert AlreadyAdded();\n        if (_rewardToken == stakingToken || rewardTokenAdded[_rewardToken]) revert InvalidRewardToken();\n        rewardTokens.push(_rewardToken);\n        rewardTokenAdded[_rewardToken] = true;\n\n        Reward storage reward = rewardData[_rewardToken];\n        reward.lastUpdateTime = block.timestamp;\n        emit AddReward(_rewardToken);\n    }\n\n    /********************** View functions ***********************/\n\n    /**\n     * @notice Return lock duration.\n     */\n    function getLockDurations() external view returns (uint256[] memory) {\n        return lockPeriod;\n    }\n\n    /**\n     * @notice Return reward multipliers.\n     */\n    function getLockMultipliers() external view returns (uint256[] memory) {\n        return rewardMultipliers;\n    }\n    /**\n     * @notice Total balance of an account, including unlocked, locked and earned tokens.\n     */\n    function getBalances(\n        address _user\n    ) external view returns (Balances memory) {\n        return balances[_user];\n    }\n\n\n    /// @notice Retrieves the address and claimable amount of all reward tokens for the specified account.\n    /// @dev This function computes claimable rewards based on stored reward balances and newly earned amounts.\n    /// @param account The address of the account for which reward information is being requested.\n    /// @return rewardsData An array of RewardData structs, each containing a token address and the amount claimable by the account.\n    function claimableRewards(\n        address account\n    )\n        external\n        view\n        override\n        returns (RewardData[] memory rewardsData)\n    {\n        uint256 length = rewardTokens.length;\n        rewardsData = new RewardData[](length);\n        for (uint256 i; i < length; ) {\n            rewardsData[i].token = rewardTokens[i];\n\n            rewardsData[i].amount = (_earned(\n                account,\n                rewardsData[i].token\n            ) + rewards[account][rewardTokens[i]]) / 1e36;\n            unchecked {\n                i++;\n            }\n        }\n        return rewardsData;\n    }\n\n    /********************** Operate functions ***********************/\n\n\n    /// @notice Allows a user to stake tokens on behalf of another address, specifying the lock type to determine reward eligibility and lock duration.\n    /// @dev Calls an internal function to handle the staking logic with `isRelock` set to `false`.\n    /// @param amount The amount of tokens to be staked.\n    /// @param onBehalfOf The address on behalf of which tokens are being staked. On frontend, this will be set to the msg.sender's address by default.\n    /// @param typeIndex An index referring to the type of lock to be applied, which affects reward calculations and lock duration.\n    function stake(\n        uint256 amount,\n        address onBehalfOf,\n        uint256 typeIndex\n    ) external override {\n        _stake(amount, onBehalfOf, typeIndex, false);\n    }\n\n    /// @notice Handles the internal logic for staking tokens, applying specified lock types and managing reward eligibility.\n    /// @dev This function updates rewards, manages balances, and logs the staking process through events.\n    ///      It ensures the amount and lock type are valid, adjusts token balances, and optionally handles token transfers for re-staking.\n    /// @param amount The amount of tokens to be staked.\n    /// @param onBehalfOf The address for which tokens are being staked.\n    /// @param typeIndex The index of the lock type to apply, affecting reward multipliers and lock durations.\n    /// @param isRelock Specifies whether the staking is for relocking already staked tokens.\n    function _stake(\n        uint256 amount,\n        address onBehalfOf,\n        uint256 typeIndex,\n        bool isRelock\n    ) internal whenNotPaused {\n        if (typeIndex >= lockPeriod.length || amount == 0) revert InvalidAmount();\n\n        _updateReward(onBehalfOf);\n        \n        Balances storage bal = balances[onBehalfOf];\n\n        bal.locked += amount;\n        lockedSupply += amount;\n\n        uint256 multiplier = rewardMultipliers[typeIndex];\n        bal.lockedWithMultiplier += amount * multiplier;\n        lockedSupplyWithMultiplier += amount * multiplier;\n        _updateRewardDebt(onBehalfOf);\n\n\n        locklist.addToList(\n            onBehalfOf, \n            LockedBalance({\n                lockId: 0, // This will be set inside the addToList function\n                amount: amount,\n                unlockTime: 0, \n                multiplier: multiplier,\n                lockTime: block.timestamp,\n                lockPeriod: lockPeriod[typeIndex],\n                exitedLate: false\n            })\n        );\n\n        if (!isRelock) {\n            IERC20(stakingToken).safeTransferFrom(\n                msg.sender,\n                address(this),\n                amount\n            );\n        }\n\n        emit Locked(\n            onBehalfOf,\n            amount,\n            balances[onBehalfOf].locked\n        );\n    }\n\n\n    /// @notice Allows a staker to perform an early exit from a locked position using the specified lock ID.\n    /// @dev This function handles the early exit process, calculating penalties, updating balances, and transferring funds.\n    /// @param lockId The unique identifier of the lock from which the user wishes to exit early.\n    function earlyExitById(uint256 lockId) external whenNotPaused {\n        if (isEarlyExitDisabled) {\n            revert EarlyExitDisabled();\n        }\n        _updateReward(msg.sender);\n\n        LockedBalance memory lock = locklist.getLockById(msg.sender, lockId);\n\n        if (lock.unlockTime != 0)\n            revert InvalidLockId();\n        uint256 coolDownSecs = calcRemainUnlockPeriod(lock);\n        lock.unlockTime = block.timestamp + coolDownSecs;\n        uint256 penaltyAmount = calcPenaltyAmount(lock);\n        locklist.removeFromList(msg.sender, lockId);\n        Balances storage bal = balances[msg.sender];\n        lockedSupplyWithMultiplier -= lock.amount * lock.multiplier;\n        lockedSupply -= lock.amount;\n        bal.locked -= lock.amount;\n        bal.lockedWithMultiplier -= lock.amount * lock.multiplier;\n\n        _updateRewardDebt(msg.sender);\n\n        if (lock.amount > penaltyAmount) {\n            IERC20(stakingToken).safeTransfer(msg.sender, lock.amount - penaltyAmount);\n            IERC20(stakingToken).safeTransfer(treasury, penaltyAmount);\n            emit EarlyExitById(lockId, msg.sender, lock.amount - penaltyAmount, penaltyAmount);\n        } else {\n            IERC20(stakingToken).safeTransfer(treasury, lock.amount);\n        emit EarlyExitById(lockId, msg.sender, 0, penaltyAmount);\n        }\n    }\n\n\n    /// @notice Allows a user to execute a late exit from a lock by specifying the lock ID, updating unlock times and reducing locked balances.\n    /// @dev This function adjusts the unlock time based on the remaining cooldown period, updates the locked balances, flags the lock as exited late, and logs the exit.\n    /// @param id The unique identifier of the lock from which the user wishes to exit late.\n    function exitLateById(uint256 id) external {\n        _updateReward(msg.sender); // Updates any pending rewards for the caller before proceeding.\n\n        LockedBalance memory lockedBalance = locklist.getLockById(msg.sender, id); // Retrieves the lock details from the lock list as a storage reference to modify.\n\n        // Calculate and set the new unlock time based on the remaining cooldown period.\n        uint256 coolDownSecs = calcRemainUnlockPeriod(lockedBalance);\n        locklist.updateUnlockTime(msg.sender, id, block.timestamp + coolDownSecs);\n\n        // Reduce the locked supply and the user's locked balance with and without multiplier.\n        uint256 multiplierBalance = lockedBalance.amount * lockedBalance.multiplier;\n        lockedSupplyWithMultiplier -= multiplierBalance;\n        lockedSupply -= lockedBalance.amount;\n        Balances storage bal = balances[msg.sender];\n        bal.lockedWithMultiplier -= multiplierBalance;\n        bal.locked -= lockedBalance.amount;\n\n        locklist.setExitedLateToTrue(msg.sender, id);\n\n        _updateRewardDebt(msg.sender); // Recalculates reward debt after changing the locked balance.\n\n        emit ExitLateById(id, msg.sender, lockedBalance.amount); // Emits an event logging the details of the late exit.\n    }\n\n\n    /// @notice Allows a user to restake funds after exiting late by mistake.\n    /// @dev Enforces restrictions on the new lock period based on the current lock period and default relock time.\n    /// @param id The ID of the lock that was exited late and needs to be re-staked.\n    /// @param typeIndex The new lock type index to apply for the restake.\n    function restakeAfterLateExit(uint256 id, uint256 typeIndex) external {\n        // Retrieve the lock details for the specified ID.\n        LockedBalance memory lockedBalance = locklist.getLockById(msg.sender, id);\n        require(lockedBalance.exitedLate, \"This lock was not exited late or is ineligible for restaking.\");\n\n        uint256 newLockPeriod = lockPeriod[typeIndex]; // Get the new lock period based on the type index.\n        uint256 currentLockPeriod = lockedBalance.lockPeriod;\n\n        // Enforce that the new lock period must be valid based on the current conditions.\n        if (currentLockPeriod <= defaultRelockTime || (block.timestamp - lockedBalance.lockTime) < currentLockPeriod) {\n            require(newLockPeriod >= currentLockPeriod, \"New lock period must be greater than or equal to the current lock period\");\n        } else {\n            require(newLockPeriod >= defaultRelockTime, \"New lock period must be greater than or equal to the default relock time\");\n        }\n\n        // Proceed to restake the funds using the new lock type.\n        _stake(lockedBalance.amount, msg.sender, typeIndex, true);\n\n        // Remove the old lock record to prevent any further operations on it.\n        locklist.removeFromList(msg.sender, id);\n\n        emit RestakedAfterLateExit(msg.sender, id, lockedBalance.amount, typeIndex);\n    }\n\n\n\n\n\n\n    /// @notice Withdraws all currently unlocked tokens where the unlock time has passed for the calling user.\n    /// @dev Iterates through the list of all locks for the user, checks if the unlock time has passed, and withdraws the total unlocked amount.\n    function withdrawAllUnlockedToken() external override nonReentrant {\n        uint256 lockCount = locklist.lockCount(msg.sender); // Fetch the total number of locks for the caller.\n        uint256 page;\n        uint256 limit;\n        uint256 totalUnlocked;\n        \n        while (limit < lockCount) {\n            LockedBalance[] memory lockedBals = locklist.getLocks(msg.sender, page, lockCount); // Retrieves a page of locks for the user.\n            for (uint256 i = 0; i < lockedBals.length; i++) {\n                if (lockedBals[i].unlockTime != 0 && lockedBals[i].unlockTime < block.timestamp) {\n                    totalUnlocked += lockedBals[i].amount; // Adds up the amount from all unlocked balances.\n                    locklist.removeFromList(msg.sender, lockedBals[i].lockId); // Removes the lock from the list.\n                }\n            }\n\n            limit += 10; // Moves to the next page of locks.\n            page++;\n        }\n\n        IERC20(stakingToken).safeTransfer(msg.sender, totalUnlocked); // Transfers the total unlocked amount to the user.\n        emit WithdrawAllUnlocked(msg.sender, totalUnlocked); // Emits an event logging the withdrawal.\n    }\n\n\n\n    /// @notice Withdraws a specific unlocked token amount using the given lock ID, if the unlock time has passed.\n    /// @dev Retrieves the lock details by ID, checks if it is unlocked, and transfers the unlocked amount to the user.\n    /// @param id The unique identifier of the lock to check for unlocked tokens.\n    function withdrawUnlockedTokenById(uint256 id) external nonReentrant {\n        LockedBalance memory lockedBal = locklist.getLockById(msg.sender, id); // Retrieves the lock details for the specified ID.\n        if (lockedBal.unlockTime != 0 && lockedBal.unlockTime < block.timestamp) {\n            IERC20(stakingToken).safeTransfer(msg.sender, lockedBal.amount); // Transfers the unlocked amount to the user.\n            locklist.removeFromList(msg.sender, id); // Removes the lock from the lock list.\n            emit WithdrawUnlockedById(id, msg.sender, lockedBal.amount); // Emits an event logging the withdrawal of the unlocked tokens.\n        }\n    }\n\n\n    /********************** Reward functions ***********************/\n\n\n    /// @notice Calculates the earnings accumulated for a given user and reward token.\n    /// @dev Calculates the net earnings by multiplying the accumulated reward with the userâ€™s locked multiplier and subtracting the reward debt.\n    /// @param _user The address of the user for whom to calculate earnings.\n    /// @param _rewardToken The token address for which earnings are calculated.\n    /// @return earnings The calculated amount of earnings for the user in terms of the specified reward token.\n    function _earned(\n        address _user,\n        address _rewardToken\n    ) internal view returns (uint256 earnings) {\n        Reward memory rewardInfo = rewardData[_rewardToken]; // Retrieves reward data for the specified token.\n        Balances memory balance = balances[_user]; // Retrieves balance information for the user.\n        earnings = rewardInfo.cumulatedReward * balance.lockedWithMultiplier - rewardDebt[_user][_rewardToken]; // Calculates earnings by considering the accumulated reward and the reward debt.\n    }\n\n\n\n    /// @notice Checks for and registers any rewards sent to the contract that have not yet been accounted for.\n    /// @dev This function is used to update the contract's state with rewards received but not yet recorded, \n    ///      for example, tokens sent directly to the contract's address \n    ///      It should be called periodically, ideally every 24 hours, to ensure all external rewards are captured.\n    /// @param token The address of the reward token to check for new, unseen rewards.\n    function _notifyUnseenReward(address token) internal {\n        if (token == address(0)) revert AddressZero(); // Ensures the token address is not zero.\n        Reward storage r = rewardData[token]; // Accesses the reward data for the given token.\n        uint256 unseen = IERC20(token).balanceOf(address(this)) - r.balance; // Calculates the amount of new, unseen rewards.\n\n        if (unseen > 0) {\n            _notifyReward(token, unseen); // Updates the reward data if there are new rewards.\n        }\n\n        emit NotifyUnseenReward(token, unseen); // Emits an event to log the notification of unseen rewards.\n    }\n\n\n    /// @notice Updates the reward data for a specific token with a new reward amount.\n    /// @dev Adds the specified reward to the cumulative reward for the token, adjusting for the total locked supply with multiplier.\n    /// @param _rewardToken The address of the reward token for which to update the reward data.\n    /// @param reward The amount of the new reward to be added.\n    function _notifyReward(address _rewardToken, uint256 reward) internal {\n        if (lockedSupplyWithMultiplier == 0)\n            return; // If there is no locked supply with multiplier, exit without adding rewards (prevents division by zero).\n\n        Reward storage r = rewardData[_rewardToken]; // Accesses the reward structure for the specified token.\n        uint256 newReward = reward * 1e36 / lockedSupplyWithMultiplier; // Calculates the reward per token, scaled up for precision.\n        r.cumulatedReward += newReward; // Updates the cumulative reward for the token.\n        r.lastUpdateTime = block.timestamp; // Sets the last update time to now.\n        r.balance += reward; // Increments the balance of the token by the new reward amount.\n    }\n\n\n\n    /// @notice Checks and updates unseen rewards for a list of reward tokens.\n    /// @dev Iterates through the provided list of reward tokens and triggers the _notifyUnseenReward function for each if it has been previously added to the contract.\n    /// @param _rewardTokens An array of reward token addresses to check and update for unseen rewards.\n    function notifyUnseenReward(address[] memory _rewardTokens) external {\n        uint256 length = rewardTokens.length; // Gets the number of reward tokens currently recognized by the contract.\n        for (uint256 i = 0; i < length; ++i) {\n            if (rewardTokenAdded[_rewardTokens[i]]) {\n                _notifyUnseenReward(_rewardTokens[i]); // Processes each token to update any unseen rewards.\n            }\n        }\n    }\n\n\n\n    /// @notice Retrieves and claims all pending staking rewards for the caller across all reward tokens.\n    /// @dev This function serves as a convenience wrapper around the `getReward` function, applying it to all reward tokens currently recognized by the contract.\n    function getAllRewards() external {\n        getReward(rewardTokens); // Calls the getReward function with the list of all reward tokens to claim all pending rewards.\n    }\n\n\n\n    /// @notice Claims pending staking rewards for the caller for specified reward tokens.\n    /// @dev Updates reward calculations for the caller, then processes claims for the provided list of reward tokens.\n    /// @param _rewardTokens An array of reward token addresses from which rewards are to be claimed.\n    function getReward(address[] memory _rewardTokens) public nonReentrant {\n        _updateReward(msg.sender); // Updates any accrued rewards up to the current point for the caller.\n        _getReward(msg.sender, _rewardTokens); // Calls the internal _getReward function to process the actual reward claim.\n    }\n\n\n\n    /// @notice Transfers accrued rewards for specified tokens to the user.\n    /// @dev Iterates through the list of reward tokens and transfers each accrued reward to the user's address, provided the reward amount is greater than zero.\n    ///      This function also updates the reward balances and logs the reward payments.\n    /// @param _user The address of the user receiving the rewards.\n    /// @param _rewardTokens An array of reward token addresses from which the user is claiming rewards.\n    function _getReward(\n        address _user,\n        address[] memory _rewardTokens\n    ) internal whenNotPaused {\n        uint256 length = _rewardTokens.length; // Get the number of reward tokens to process.\n        for (uint256 i = 0; i < length; ) {\n            address token = _rewardTokens[i]; // Get the current token address.\n\n            uint256 reward = rewards[_user][token]; // Retrieve the amount of reward due for the user and the token.\n            if (reward > 0) {\n                rewards[_user][token] = 0; // Reset the reward to zero after claiming.\n                rewardData[token].balance -= reward / 1e36; // Deduct the reward from the stored balance, adjusting for decimals.\n\n                IERC20(token).safeTransfer(_user, reward / 1e36); // Transfer the reward to the user.\n                rewardPaid[_user][token] += reward / 1e36; // Update the total reward paid to the user for this token.\n                emit RewardPaid(_user, token, reward / 1e36); // Emit an event documenting the reward payment.\n            }\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n\n    /********************** Eligibility + Disqualification ***********************/\n\n\n    /// @notice Calculates the penalty amount for an early exit from a locked position based on the remaining time until the scheduled unlock.\n    /// @dev The penalty is computed as a percentage of the locked amount, which is scaled by a base penalty percentage plus a time-dependent penalty fraction.\n    /// @param userLock A struct containing details about the user's locked balance, including the amount, lock period, and unlock time.\n    /// @return penaltyAmount The amount of penalty to be applied if the user decides to exit early from the lock.\n    function calcPenaltyAmount(LockedBalance memory userLock) public view returns (uint256 penaltyAmount) {\n        if (userLock.amount == 0) return 0; // Return zero if there is no amount locked to avoid unnecessary calculations.\n        uint256 unlockTime = userLock.unlockTime;\n        uint256 lockPeriod = userLock.lockPeriod;\n        uint256 penaltyFactor;\n\n\n        if (lockPeriod <= defaultRelockTime || (block.timestamp - userLock.lockTime) < lockPeriod) {\n\n            penaltyFactor = (unlockTime - block.timestamp) * timePenaltyFraction / lockPeriod + basePenaltyPercentage;\n        }\n        else {\n            penaltyFactor = (unlockTime - block.timestamp) * timePenaltyFraction / defaultRelockTime + basePenaltyPercentage;\n        }\n\n        // Apply the calculated penalty factor to the locked amount.\n        penaltyAmount = userLock.amount * penaltyFactor / WHOLE;\n    }\n\n\n\n    /// @notice Determines the remaining time until a user's locked balance can be unlocked.\n    /// @dev Calculates the remaining unlock period based on either the lock's specific period or the default relock time, depending on which is relevant.\n    ///      The function checks if the lock period is still applicable, or if the default relock time should be used instead.\n    ///      The lock period should always be the lesser of the user's own lock period or the default lock period.   \n    /// @param userLock A struct containing the lock's details, including the lock period, multiplier, and the timestamp when the lock was initiated.\n    /// @return uint256 of remaining time in seconds until the lock can be unlocked.\n    function calcRemainUnlockPeriod(LockedBalance memory userLock) public view returns (uint256) {\n        uint256 lockTime = userLock.lockTime;\n        uint256 lockPeriod = userLock.lockPeriod;\n        \n        if (lockPeriod <= defaultRelockTime || (block.timestamp - lockTime) < lockPeriod) {\n            // If the adjusted lock period is less than or equal to the default relock time, or if the current time is still within the adjusted lock period, return the remaining time based on the adjusted lock period.\n            return lockPeriod - (block.timestamp - lockTime) % lockPeriod;\n        } else {\n            // If the current time exceeds the adjusted lock period, return the remaining time based on the default relock time.\n            return defaultRelockTime - (block.timestamp - lockTime) % defaultRelockTime;\n        }\n    }\n\n\n\n    /// @notice Updates the accumulated rewards and reward debts for all tokens for a specific user account.\n    /// @dev Iterates over all reward tokens, updates each token's accrued rewards for the given account, and adjusts the reward debt accordingly.\n    /// @param account The address of the user for whom rewards are being updated.\n    function _updateReward(address account) internal {\n        uint256 length = rewardTokens.length; // Determine the number of reward tokens.\n        Balances storage bal = balances[account]; // Access the balance record for the user.\n\n        for (uint256 i = 0; i < length; ) {\n            address token = rewardTokens[i]; // Access each token.\n            Reward memory rewardInfo = rewardData[token]; // Get the reward data for the token.\n\n            rewards[account][token] += _earned(account, token); // Update the rewards for the user based on what has been earned so far.\n            rewardDebt[account][token] = rewardInfo.cumulatedReward * bal.lockedWithMultiplier; // Update the reward debt based on the latest reward information.\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n\n\n    /// @notice Updates the reward debt for all reward tokens based on the current cumulated rewards and the user's locked balances.\n    /// @dev Iterates over all reward tokens and recalculates the reward debt for the specified user, based on their locked balances multiplied by the accumulated rewards for each token.\n    /// @param _user The address of the user for whom the reward debt is being recalculated.\n    function _updateRewardDebt(address _user) internal {\n        Balances memory bal = balances[_user]; // Retrieve the current balance information for the user.\n\n        for (uint i = 0; i < rewardTokens.length; ++i) {\n            address rewardToken = rewardTokens[i]; // Access each reward token.\n            Reward memory rewardInfo = rewardData[rewardToken]; // Get the current reward data for each token.\n\n            // Recalculate the reward debt for the user based on their locked balances and the"
    }
  ]
}