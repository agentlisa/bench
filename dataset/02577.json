{
  "Title": "M-1: Boosted3TokenPoolUtils.sol : _redeem - updating the `totalBPTHeld , totalStrategyTokenGlobal` after `_unstakeAndExitPool` is not safe",
  "Content": "# Issue M-1: Boosted3TokenPoolUtils.sol : _redeem - updating the `totalBPTHeld , totalStrategyTokenGlobal` after `_unstakeAndExitPool` is not safe \n\nSource: https://github.com/sherlock-audit/2022-12-notional-judging/issues/30 \n\n## Found by \nak1\n\n## Summary\n\n_redeem function is used to claim the BPT amount using the strategy tokens.\n\nIt is first calling the `_unstakeAndExitPool` function and then updating the `totalBPTHeld , totalStrategyTokenGlobal`\n\n## Vulnerability Detail\n\n        function _redeem(\n        ThreeTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        uint256 strategyTokens,\n        uint256 minPrimary\n    ) internal returns (uint256 finalPrimaryBalance) {\n        uint256 bptClaim = strategyContext._convertStrategyTokensToBPTClaim(strategyTokens);\n\n\n        if (bptClaim == 0) return 0;\n\n\n        finalPrimaryBalance = _unstakeAndExitPool({\n            stakingContext: stakingContext,\n            poolContext: poolContext,\n            bptClaim: bptClaim,\n            minPrimary: minPrimary\n        });\n\n\n        strategyContext.vaultState.totalBPTHeld -= bptClaim;\n        strategyContext.vaultState.totalStrategyTokenGlobal -= strategyTokens.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n\nFirst _unstakeAndExitPool is called and then totalBPTHeld and totalStrategyTokenGlobal  are updated.\n\n## Impact\n\nReentering during any of the function call inside `_unstakeAndExitPool` could be problematic.\n `stakingContext.auraRewardPool.withdrawAndUnwrap(bptClaim, false)`\n` BalancerUtils._swapGivenIn`\n\nWell it need deep study to analyze the impact, but I would suggest to update the balance first and then call the `_unstakeAndExitPool`\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-12-notional/blob/main/contracts/vaults/balancer/internal/pool/Boosted3TokenPoolUtils.sol#L432-L453\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nFirst update `totalBPTHeld and totalStrategyTokenGlobal` and then call the `_unstakeAndExitPool`\n\n\n## Discussion\n\n**weitianjie2000**\n\ninvalid: we have disallow re-entrancy on the vault controller side\n\n**weitianjie2000**\n\nvalid: we've decided to make the fix just in case\n\n**jeffywu**\n\nAgree, we can mark this issue as valid although I disagree with the High severity rating here. There is no clear re-entrancy vector that has been articulated and the code being called in _unstakeAndExitPool is both known and trusted (both Balancer and Aura).\n\n**hrishibhat**\n\nAgree with the sponsor about the issue being medium as there is no re-entrancy attack described in the issue. \nConsidering this a medium severity issue. \n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/31",
  "Code": [
    {
      "filename": "contracts/vaults/balancer/internal/pool/Boosted3TokenPoolUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {\n    ThreeTokenPoolContext,\n    TwoTokenPoolContext,\n    BoostedOracleContext,\n    UnderlyingPoolContext,\n    AuraStakingContext,\n    StrategyContext,\n    StrategyVaultSettings,\n    StrategyVaultState\n} from \"../../BalancerVaultTypes.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {Deployments} from \"../../../../global/Deployments.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {BalancerUtils} from \"../pool/BalancerUtils.sol\";\nimport {Boosted3TokenPoolUtils} from \"../pool/Boosted3TokenPoolUtils.sol\";\nimport {StableMath} from \"../math/StableMath.sol\";\nimport {LinearMath} from \"../math/LinearMath.sol\";\nimport {AuraStakingUtils} from \"../staking/AuraStakingUtils.sol\";\nimport {StrategyUtils} from \"../strategy/StrategyUtils.sol\";\nimport {BalancerVaultStorage} from \"../BalancerVaultStorage.sol\";\nimport {ITradingModule} from \"../../../../../interfaces/trading/ITradingModule.sol\";\nimport {ILinearPool} from \"../../../../../interfaces/balancer/IBalancerPool.sol\";\nimport {TokenUtils, IERC20} from \"../../../../utils/TokenUtils.sol\";\nimport {TwoTokenPoolUtils} from \"./TwoTokenPoolUtils.sol\";\nimport {FixedPoint} from \"../math/FixedPoint.sol\";\n\nlibrary Boosted3TokenPoolUtils {\n    using TypeConvert for uint256;\n    using FixedPoint for uint256;\n    using TypeConvert for int256;\n    using TokenUtils for IERC20;\n    using TwoTokenPoolUtils for TwoTokenPoolContext;\n    using Boosted3TokenPoolUtils for ThreeTokenPoolContext;\n    using AuraStakingUtils for AuraStakingContext;\n    using StrategyUtils for StrategyContext;\n    using BalancerVaultStorage for StrategyVaultSettings;\n    using BalancerVaultStorage for StrategyVaultState;\n\n    // Preminted BPT is sometimes called Phantom BPT, as the preminted BPT (which is deposited in the Vault as balance of\n    // the Pool) doesn't belong to any entity until transferred out of the Pool. The Pool's arithmetic behaves as if it\n    // didn't exist, and the BPT total supply is not a useful value: we rely on the 'virtual supply' (how much BPT is\n    // actually owned by some entity) instead.\n    uint256 private constant _MAX_TOKEN_BALANCE = 2**(112) - 1;\n\n    function _getScaleFactor(\n        ThreeTokenPoolContext memory poolContext,\n        uint8 tokenIndex\n    ) private pure returns(uint256 scaleFactor) {\n        if (tokenIndex == 0) {\n            scaleFactor = poolContext.basePool.primaryScaleFactor;\n        } else if (tokenIndex == 1) {\n            scaleFactor = poolContext.basePool.secondaryScaleFactor;\n        } else if (tokenIndex == 2) {\n            scaleFactor = poolContext.tertiaryScaleFactor;\n        }\n    }\n\n    function _getPrecision(\n        ThreeTokenPoolContext memory poolContext,\n        uint8 tokenIndex\n    ) private pure returns(uint256 precision) {\n        if (tokenIndex == 0) {\n            precision = 10**poolContext.basePool.primaryDecimals;\n        } else if (tokenIndex == 1) {\n            precision = 10**poolContext.basePool.secondaryDecimals;\n        } else if (tokenIndex == 2) {\n            precision = 10**poolContext.tertiaryDecimals;\n        }\n    }\n\n    /// @notice Spot price is always expressed in terms of the primary currency\n    function _getSpotPrice(\n        ThreeTokenPoolContext memory poolContext, \n        BoostedOracleContext memory oracleContext,\n        uint8 tokenIndex\n    ) internal pure returns (uint256 spotPrice) {\n        require(tokenIndex < 3);  /// @dev invalid token index\n\n        // Exchange rate of primary currency = 1\n        if (tokenIndex == 0) {\n            return BalancerConstants.BALANCER_PRECISION;\n        }\n\n        uint256[] memory balances = _getScaledBalances(poolContext);\n        uint256 invariant = StableMath._calculateInvariant(\n            oracleContext.ampParam, balances, true // roundUp = true\n        );\n        spotPrice = _getSpotPriceWithInvariant({\n            poolContext: poolContext,\n            oracleContext: oracleContext,\n            balances: balances, \n            invariant: invariant,\n            tokenIndex: tokenIndex\n        });\n    }\n\n    function _getUnderlyingBPTOut(\n        UnderlyingPoolContext memory pool,\n        uint256 mainIn\n    ) private pure returns (uint256) {\n        uint256 scaledMainBalance = pool.mainBalance * pool.mainScaleFactor /\n            BalancerConstants.BALANCER_PRECISION;\n        uint256 scaledWrappedBalance = pool.wrappedBalance * pool.wrappedScaleFactor /\n            BalancerConstants.BALANCER_PRECISION;\n\n        // Convert from linear pool BPT to primary Amount\n        return LinearMath._calcBptOutPerMainIn({\n            mainIn: mainIn,\n            mainBalance: scaledMainBalance,\n            wrappedBalance: scaledWrappedBalance,\n            bptSupply: pool.virtualSupply,\n            params: LinearMath.Params({\n                fee: pool.fee,\n                lowerTarget: pool.lowerTarget,\n                upperTarget: pool.upperTarget\n            }) \n        });\n    }\n\n    function _getUnderlyingMainOut(\n        UnderlyingPoolContext memory pool,\n        uint256 bptIn\n    ) private pure returns (uint256) {\n        uint256 scaledMainBalance = pool.mainBalance * pool.mainScaleFactor /\n            BalancerConstants.BALANCER_PRECISION;\n        uint256 scaledWrappedBalance = pool.wrappedBalance * pool.wrappedScaleFactor /\n            BalancerConstants.BALANCER_PRECISION;\n\n        // Convert from linear pool BPT to primary Amount\n        return LinearMath._calcMainOutPerBptIn({\n            bptIn: bptIn,\n            mainBalance: scaledMainBalance,\n            wrappedBalance: scaledWrappedBalance,\n            bptSupply: pool.virtualSupply,\n            params: LinearMath.Params({\n                fee: pool.fee,\n                lowerTarget: pool.lowerTarget,\n                upperTarget: pool.upperTarget\n            }) \n        });\n    }\n\n    /// @notice Spot price is always expressed in terms of the primary currency\n    function _getSpotPriceWithInvariant(\n        ThreeTokenPoolContext memory poolContext, \n        BoostedOracleContext memory oracleContext,\n        uint256[] memory balances,\n        uint256 invariant,\n        uint8 tokenIndex\n    ) private pure returns (uint256 spotPrice) {\n        // Trade 1 unit of tokenIn for tokenOut to get the spot price\n        // AmountIn needs to be in underlying precision because mainScaleFactor\n        // will convert it to 1e18\n        uint256 amountIn = _getPrecision(poolContext, tokenIndex);\n\n        UnderlyingPoolContext memory inPool = oracleContext.underlyingPools[tokenIndex];\n        amountIn = amountIn * inPool.mainScaleFactor / BalancerConstants.BALANCER_PRECISION;\n        uint256 linearBPTIn = _getUnderlyingBPTOut(inPool, amountIn);\n\n        linearBPTIn = linearBPTIn * _getScaleFactor(poolContext, tokenIndex) / BalancerConstants.BALANCER_PRECISION;\n\n        uint256 linearBPTOut = StableMath._calcOutGivenIn({\n            amplificationParameter: oracleContext.ampParam,\n            balances: balances,\n            tokenIndexIn: tokenIndex,\n            tokenIndexOut: 0, // Primary index\n            tokenAmountIn: linearBPTIn,\n            invariant: invariant\n        });\n\n        linearBPTOut = linearBPTOut * BalancerConstants.BALANCER_PRECISION / _getScaleFactor(poolContext, 0);\n\n        UnderlyingPoolContext memory outPool = oracleContext.underlyingPools[0];\n        spotPrice = _getUnderlyingMainOut(outPool, linearBPTOut);\n        spotPrice = spotPrice * BalancerConstants.BALANCER_PRECISION / outPool.mainScaleFactor;\n\n        // Convert precision back to 1e18 after downscaling by mainScaleFactor\n        // primary currency = index 0\n        spotPrice = spotPrice * BalancerConstants.BALANCER_PRECISION / _getPrecision(poolContext, 0);\n    }\n\n    function _validateSpotPrice(\n        ThreeTokenPoolContext memory poolContext, \n        BoostedOracleContext memory oracleContext,\n        StrategyContext memory context,\n        address tokenIn,\n        address tokenOut,\n        uint8 tokenIndex,\n        uint256[] memory balances,\n        uint256 invariant\n    ) private view {\n        (int256 answer, int256 decimals) = context.tradingModule.getOraclePrice(tokenOut, tokenIn);\n        require(decimals == int256(BalancerConstants.BALANCER_PRECISION));\n        \n        uint256 spotPrice = _getSpotPriceWithInvariant({\n            poolContext: poolContext,\n            oracleContext: oracleContext,\n            balances: balances, \n            invariant: invariant,\n            tokenIndex: tokenIndex\n        });\n\n        uint256 oraclePrice = answer.toUint();\n        uint256 lowerLimit = (oraclePrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS - context.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n        uint256 upperLimit = (oraclePrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS + context.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n\n        // Check spot price against oracle price to make sure it hasn't been manipulated\n        if (spotPrice < lowerLimit || upperLimit < spotPrice) {\n            revert Errors.InvalidPrice(oraclePrice, spotPrice);\n        }\n    }\n\n    function _validateTokenPrices(\n        ThreeTokenPoolContext memory poolContext, \n        BoostedOracleContext memory oracleContext,\n        StrategyContext memory strategyContext,\n        uint256[] memory balances,\n        uint256 invariant\n    ) private view {\n        address primaryUnderlying = ILinearPool(address(poolContext.basePool.primaryToken)).getMainToken();\n        address secondaryUnderlying = ILinearPool(address(poolContext.basePool.secondaryToken)).getMainToken();\n        address tertiaryUnderlying = ILinearPool(address(poolContext.tertiaryToken)).getMainToken();\n\n        _validateSpotPrice({\n            poolContext: poolContext,\n            oracleContext: oracleContext,\n            context: strategyContext,\n            tokenIn: primaryUnderlying,\n            tokenOut: secondaryUnderlying,\n            tokenIndex: 1, // secondary index\n            balances: balances,\n            invariant: invariant\n        });\n\n        _validateSpotPrice({\n            poolContext: poolContext,\n            oracleContext: oracleContext,\n            context: strategyContext,\n            tokenIn: primaryUnderlying,\n            tokenOut: tertiaryUnderlying,\n            tokenIndex: 2, // tertiary index\n            balances: balances,\n            invariant: invariant\n        });\n    }\n\n    function _getVirtualSupply(\n        ThreeTokenPoolContext memory poolContext, \n        BoostedOracleContext memory oracleContext\n    ) internal view returns (uint256 virtualSupply) {\n        // The initial amount of BPT pre-minted is _PREMINTED_TOKEN_BALANCE, and it goes entirely to the pool balance in\n        // the vault. So the virtualSupply (the amount of BPT supply in circulation) is defined as:\n        // virtualSupply = totalSupply() - _balances[_bptIndex]\n        virtualSupply = poolContext.basePool.basePool.pool.totalSupply() - oracleContext.bptBalance;\n    }\n\n    function _getScaledBalances(ThreeTokenPoolContext memory poolContext) \n        private pure returns (uint256[] memory amountsWithoutBpt) {\n        amountsWithoutBpt = new uint256[](3);\n        amountsWithoutBpt[0] = poolContext.basePool.primaryBalance * poolContext.basePool.primaryScaleFactor \n            / BalancerConstants.BALANCER_PRECISION;\n        amountsWithoutBpt[1] = poolContext.basePool.secondaryBalance * poolContext.basePool.secondaryScaleFactor\n            / BalancerConstants.BALANCER_PRECISION;\n        amountsWithoutBpt[2] = poolContext.tertiaryBalance * poolContext.tertiaryScaleFactor\n            / BalancerConstants.BALANCER_PRECISION;        \n    }\n\n    function _getVirtualSupplyAndBalances(\n        ThreeTokenPoolContext memory poolContext, \n        BoostedOracleContext memory oracleContext\n    ) private view returns (uint256 virtualSupply, uint256[] memory amountsWithoutBpt) {\n        virtualSupply = _getVirtualSupply(poolContext, oracleContext);\n        amountsWithoutBpt = _getScaledBalances(poolContext);\n    }\n\n    function _getValidatedPoolData(\n        ThreeTokenPoolContext memory poolContext,\n        BoostedOracleContext memory oracleContext,\n        StrategyContext memory strategyContext\n    ) internal view returns (uint256 virtualSupply, uint256[] memory balances, uint256 invariant) {\n        (virtualSupply, balances) = \n            _getVirtualSupplyAndBalances(poolContext, oracleContext);\n\n        // Get the current and new invariants. Since we need a bigger new invariant, we round the current one up.\n        invariant = StableMath._calculateInvariant(\n            oracleContext.ampParam, balances, true // roundUp = true\n        );\n\n        // validate spot prices against oracle prices\n        _validateTokenPrices({\n            poolContext: poolContext,\n            oracleContext: oracleContext,\n            strategyContext: strategyContext,\n            balances: balances,\n            invariant: invariant\n        });\n    }\n\n    /// @notice Gets the time-weighted primary token balance for a given bptAmount\n    /// @dev Boosted pool can't use the Balancer oracle, using Chainlink instead\n    /// @param poolContext pool context variables\n    /// @param oracleContext oracle context variables\n    /// @param bptAmount amount of balancer pool lp tokens\n    /// @return primaryAmount primary token balance\n    function _getTimeWeightedPrimaryBalance(\n        ThreeTokenPoolContext memory poolContext,\n        BoostedOracleContext memory oracleContext,\n        StrategyContext memory strategyContext,\n        uint256 bptAmount\n    ) internal view returns (uint256 primaryAmount) {\n        (\n           uint256 virtualSupply, \n           uint256[] memory balances, \n           uint256 invariant\n        ) = _getValidatedPoolData(poolContext, oracleContext, strategyContext);\n\n        // NOTE: For Boosted 3 token pools, the LP token (BPT) is just another\n        // token in the pool. So, we first use _calcTokenOutGivenExactBptIn\n        // to calculate the value of 1 BPT. Then, we scale it to the BPT\n        // amount to get the value in terms of the primary currency.\n        // Use virtual total supply and zero swap fees for joins\n        uint256 linearBPTAmount = StableMath._calcTokenOutGivenExactBptIn({\n            amp: oracleContext.ampParam, \n            balances: balances, \n            tokenIndex: 0, // Primary index\n            bptAmountIn: BalancerConstants.BALANCER_PRECISION, // 1 BPT \n            bptTotalSupply: virtualSupply, \n            swapFeePercentage: oracleContext.swapFeePercentage, \n            currentInvariant: invariant\n        });\n\n        // Downscale BPT out\n        linearBPTAmount = linearBPTAmount * BalancerConstants.BALANCER_PRECISION / poolContext.basePool.primaryScaleFactor;\n\n        // Primary underlying pool = index 0\n        primaryAmount = _getUnderlyingMainOut(oracleContext.underlyingPools[0], linearBPTAmount);\n\n        uint256 primaryPrecision = 10 ** poolContext.basePool.primaryDecimals;\n        primaryAmount = (primaryAmount * bptAmount * primaryPrecision) / BalancerConstants.BALANCER_PRECISION_SQUARED;\n    }\n\n    function _approveBalancerTokens(ThreeTokenPoolContext memory poolContext, address bptSpender) internal {\n        poolContext.basePool._approveBalancerTokens(bptSpender);\n\n        IERC20(poolContext.tertiaryToken).checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n\n        // For boosted pools, the tokens inside pool context are AaveLinearPool tokens.\n        // So, we need to approve the _underlyingToken (primary borrow currency) for trading.\n        ILinearPool underlyingPool = ILinearPool(poolContext.basePool.primaryToken);\n        address primaryUnderlyingAddress = BalancerUtils.getTokenAddress(underlyingPool.getMainToken());\n        IERC20(primaryUnderlyingAddress).checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n    }\n\n    function _joinPoolExactTokensIn(ThreeTokenPoolContext memory context, uint256 primaryAmount, uint256 minBPT)\n        private returns (uint256 bptAmount) {\n        ILinearPool underlyingPool = ILinearPool(address(context.basePool.primaryToken));\n\n        // Swap underlyingToken for LinearPool BPT\n        uint256 linearPoolBPT = BalancerUtils._swapGivenIn({\n            poolId: underlyingPool.getPoolId(),\n            tokenIn: underlyingPool.getMainToken(),\n            tokenOut: address(underlyingPool),\n            amountIn: primaryAmount,\n            limit: 0 // slippage checked on the second swap\n        });\n\n        // Swap LinearPool BPT for Boosted BPT\n        bptAmount = BalancerUtils._swapGivenIn({\n            poolId: context.basePool.basePool.poolId,\n            tokenIn: address(underlyingPool),\n            tokenOut: address(context.basePool.basePool.pool), // Boosted pool\n            amountIn: linearPoolBPT,\n            limit: minBPT\n        });\n    }\n\n    function _exitPoolExactBPTIn(ThreeTokenPoolContext memory context, uint256 bptExitAmount, uint256 minPrimary)\n        private returns (uint256 primaryBalance) {\n        ILinearPool underlyingPool = ILinearPool(address(context.basePool.primaryToken));\n\n        // Swap Boosted BPT for LinearPool BPT\n        uint256 linearPoolBPT = BalancerUtils._swapGivenIn({\n            poolId: context.basePool.basePool.poolId,\n            tokenIn: address(context.basePool.basePool.pool), // Boosted pool\n            tokenOut: address(underlyingPool),\n            amountIn: bptExitAmount,\n            limit: 0 // slippage checked on the second swap\n        });\n\n        // Swap LinearPool BPT for underlyingToken\n        primaryBalance = BalancerUtils._swapGivenIn({\n            poolId: underlyingPool.getPoolId(),\n            tokenIn: address(underlyingPool),\n            tokenOut: underlyingPool.getMainToken(),\n            amountIn: linearPoolBPT,\n            limit: minPrimary\n        }); \n    }\n\n    function _deposit(\n        ThreeTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        BoostedOracleContext memory oracleContext,\n        uint256 deposit,\n        uint256 minBPT\n    ) internal returns (uint256 strategyTokensMinted) {\n        uint256 bptMinted = poolContext._joinPoolAndStake({\n            strategyContext: strategyContext,\n            stakingContext: stakingContext,\n            oracleContext: oracleContext,\n            deposit: deposit,\n            minBPT: minBPT\n        });\n\n        strategyTokensMinted = strategyContext._convertBPTClaimToStrategyTokens(bptMinted);\n\n        strategyContext.vaultState.totalBPTHeld += bptMinted;\n        // Update global supply count\n        strategyContext.vaultState.totalStrategyTokenGlobal += strategyTokensMinted.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n\n    function _redeem(\n        ThreeTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        uint256 strategyTokens,\n        uint256 minPrimary\n    ) internal returns (uint256 finalPrimaryBalance) {\n        uint256 bptClaim = strategyContext._convertStrategyTokensToBPTClaim(strategyTokens);\n\n        if (bptClaim == 0) return 0;\n\n        finalPrimaryBalance = _unstakeAndExitPool({\n            stakingContext: stakingContext,\n            poolContext: poolContext,\n            bptClaim: bptClaim,\n            minPrimary: minPrimary\n        });\n\n        strategyContext.vaultState.totalBPTHeld -= bptClaim;\n        strategyContext.vaultState.totalStrategyTokenGlobal -= strategyTokens.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n\n    function _joinPoolAndStake(\n        ThreeTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        BoostedOracleContext memory oracleContext,\n        uint256 deposit,\n        uint256 minBPT\n    ) internal returns (uint256 bptMinted) {\n        bptMinted = _joinPoolExactTokensIn(poolContext, deposit, minBPT);\n\n        // Check BPT threshold to make sure our share of the pool is\n        // below maxBalancerPoolShare\n        uint256 bptThreshold = strategyContext.vaultSettings._bptThreshold(\n            poolContext._getVirtualSupply(oracleContext)\n        );\n        uint256 bptHeldAfterJoin = strategyContext.vaultState.totalBPTHeld + bptMinted;\n        if (bptHeldAfterJoin > bptThreshold)\n            revert Errors.BalancerPoolShareTooHigh(bptHeldAfterJoin, bptThreshold);\n\n        // Transfer token to Aura protocol for boosted staking\n        bool success = stakingContext.auraBooster.deposit(stakingContext.auraPoolId, bptMinted, true); // stake = true\n        if (!success) revert Errors.StakeFailed();\n    }\n\n    function _unstakeAndExitPool(\n        ThreeTokenPoolContext memory poolContext,\n        AuraStakingContext memory stakingContext,\n        uint256 bptClaim,\n        uint256 minPrimary\n    ) internal returns (uint256 primaryBalance) {\n        // Withdraw BPT tokens back to the vault for redemption\n        bool success = stakingContext.auraRewardPool.withdrawAndUnwrap(bptClaim, false); // claimRewards = false\n        if (!success) revert Errors.UnstakeFailed();\n\n        primaryBalance = _exitPoolExactBPTIn(poolContext, bptClaim, minPrimary); \n    }\n\n    /// @notice We value strategy tokens in terms of the primary balance. The time weighted\n    /// primary balance is used in order to prevent pool manipulation.\n    /// @param poolContext pool context variables\n    /// @param oracleContext oracle context variables\n    /// @param strategyTokenAmount amount of strategy tokens\n    /// @return underlyingValue underlying value of strategy tokens\n    function _convertStrategyToUnderlying(\n        ThreeTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        BoostedOracleContext memory oracleContext,\n        uint256 strategyTokenAmount\n    ) internal view returns (int256 underlyingValue) {\n        uint256 bptClaim = strategyContext._convertStrategyTokensToBPTClaim(strategyTokenAmount);\n        \n        underlyingValue = poolContext._getTimeWeightedPrimaryBalance(\n            oracleContext, strategyContext, bptClaim\n        ).toInt();\n    }\n}"
    }
  ]
}