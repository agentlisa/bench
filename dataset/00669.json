{
  "Title": "Inaccuracy in rounding",
  "Content": "##### Description\n\n- https://github.com/ConicFinance/protocol/blob/7a66d26ef84f93059a811a189655e17c11d95f5c/contracts/adapters/CurveAdapter.sol#L103\n\n```\nunderlyingAmount = \n    usdAmount.convertScale(18, decimals).divDown(underlyingPrice);\n```\n\nIn the `computePoolValueInUnderlying` method, if `decimals` is small, accuracy in rounding is lost.\n\n##### Recommendation\nWe recommend calling `convertScale` after `divDown`.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/adapters/CurveAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../../interfaces/IPoolAdapter.sol\";\nimport \"../../interfaces/IController.sol\";\nimport \"../../interfaces/IConvexHandler.sol\";\nimport \"../../interfaces/ICurveHandler.sol\";\nimport \"../../interfaces/vendor/IBaseRewardPool.sol\";\n\nimport \"../../libraries/ScaledMath.sol\";\n\ncontract CurveAdapter is IPoolAdapter {\n    using Address for address;\n    using ScaledMath for uint256;\n\n    IController public immutable controller;\n\n    constructor(IController _controller) {\n        controller = _controller;\n    }\n\n    function deposit(\n        address curvePool,\n        address underlying,\n        uint256 underlyingAmount\n    ) external override {\n        if (underlyingAmount == 0) return;\n\n        controller.curveHandler().functionDelegateCall(\n            abi.encodeWithSignature(\n                \"deposit(address,address,uint256)\",\n                curvePool,\n                underlying,\n                underlyingAmount\n            )\n        );\n\n        uint256 depositAmount = _getDepositAmount(address(this), curvePool);\n        if (depositAmount > 0) {\n            controller.convexHandler().functionDelegateCall(\n                abi.encodeWithSignature(\"deposit(address,uint256)\", curvePool, depositAmount)\n            );\n        }\n    }\n\n    function withdraw(\n        address pool,\n        address underlying,\n        uint256 underlyingAmount\n    ) external override {\n        ICurveRegistryCache registryCache = controller.curveRegistryCache();\n        address curveLpToken = registryCache.lpToken(pool);\n\n        uint256 lpToWithdraw = controller.priceOracle().underlyingToCurveLp(\n            underlying,\n            curveLpToken,\n            underlyingAmount\n        );\n        if (lpToWithdraw == 0) return;\n\n        uint256 totalAvailableLp = _totalCurveLpBalance(address(this), pool);\n\n        uint256 idleCurveLpBalance = _idleCurveLpBalance(address(this), pool);\n\n        // Due to rounding errors with the conversion of underlying to LP tokens,\n        // we may not have the precise amount of LP tokens to withdraw from the pool.\n        // In this case, we withdraw the maximum amount of LP tokens available.\n        if (totalAvailableLp < lpToWithdraw) {\n            lpToWithdraw = totalAvailableLp;\n        }\n\n        if (lpToWithdraw > idleCurveLpBalance) {\n            controller.convexHandler().functionDelegateCall(\n                abi.encodeWithSignature(\n                    \"withdraw(address,uint256)\",\n                    pool,\n                    lpToWithdraw - idleCurveLpBalance\n                )\n            );\n        }\n\n        controller.curveHandler().functionDelegateCall(\n            abi.encodeWithSignature(\n                \"withdraw(address,address,uint256)\",\n                pool,\n                underlying,\n                lpToWithdraw\n            )\n        );\n    }\n\n    function computePoolValueInUnderlying(\n        address conicPool,\n        address pool,\n        address underlying,\n        uint256 underlyingPrice\n    ) external view override returns (uint256 underlyingAmount) {\n        uint8 decimals = IERC20Metadata(underlying).decimals();\n        uint256 usdAmount = computePoolValueInUSD(conicPool, pool);\n        underlyingAmount = usdAmount.convertScale(18, decimals).divDown(underlyingPrice);\n    }\n\n    function computePoolValueInUSD(\n        address conicPool,\n        address pool\n    ) public view override returns (uint256 usdAmount) {\n        IGenericOracle priceOracle = controller.priceOracle();\n        address curveLpToken = controller.curveRegistryCache().lpToken(pool);\n        uint8 lpDecimals = IERC20Metadata(curveLpToken).decimals();\n        uint256 lpBalance = _totalCurveLpBalance(conicPool, pool);\n        uint256 lpPrice = priceOracle.getUSDPrice(curveLpToken);\n        usdAmount = lpBalance.convertScale(lpDecimals, 18).mulDown(lpPrice);\n    }\n\n    function _getDepositAmount(\n        address conicPool,\n        address curvePool\n    ) internal view returns (uint256) {\n        uint256 maxIdleCurveLpRatio = IConicPool(conicPool).maxIdleCurveLpRatio();\n        uint256 idleCurveLpBalance = _idleCurveLpBalance(conicPool, curvePool);\n        uint256 totalCurveLpBalance = _stakedCurveLpBalance(conicPool, curvePool) +\n            idleCurveLpBalance;\n\n        if (idleCurveLpBalance.divDown(totalCurveLpBalance) >= maxIdleCurveLpRatio) {\n            return idleCurveLpBalance;\n        }\n        return 0;\n    }\n\n    function _idleCurveLpBalance(\n        address conicPool_,\n        address curvePool_\n    ) internal view returns (uint256) {\n        return IERC20(controller.curveRegistryCache().lpToken(curvePool_)).balanceOf(conicPool_);\n    }\n\n    function _stakedCurveLpBalance(\n        address conicPool_,\n        address curvePool_\n    ) internal view returns (uint256) {\n        address rewardPool = IConvexHandler(controller.convexHandler()).getRewardPool(curvePool_);\n        return IBaseRewardPool(rewardPool).balanceOf(conicPool_);\n    }\n\n    function _totalCurveLpBalance(\n        address conicPool_,\n        address curvePool_\n    ) internal view returns (uint256) {\n        return\n            _stakedCurveLpBalance(conicPool_, curvePool_) +\n            _idleCurveLpBalance(conicPool_, curvePool_);\n    }\n\n    function claimEarnings(address conicPool, address pool) external override {\n        IConvexHandler(controller.convexHandler()).claimEarnings(pool, conicPool);\n    }\n\n    function lpToken(address pool) external view override returns (address) {\n        return controller.curveRegistryCache().lpToken(pool);\n    }\n\n    function supportsAsset(address pool, address asset) external view override returns (bool) {\n        return controller.curveRegistryCache().hasCoinAnywhere(pool, asset);\n    }\n\n    function getCRVEarnedOnConvex(\n        address account,\n        address curvePool\n    ) external view override returns (uint256) {\n        return IConvexHandler(controller.convexHandler()).getCrvEarned(account, curvePool);\n    }\n\n    function executeSanityCheck(address pool) external override {\n        ICurveHandler(controller.curveHandler()).reentrancyCheck(pool);\n    }\n}"
    }
  ]
}