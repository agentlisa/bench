{
  "Title": "Confusing Revert Messages",
  "Content": "The current revert messages [`!SX:DETECTED`](https://github.com/spherex-collab/spherex-protect/blob/5b134b2b176deb94e75417ed9b9d3670444a4167/src/SphereXEngine.sol#LL159C53-L159C65), [`!SX:SENDERS`](https://github.com/spherex-collab/spherex-protect/blob/5b134b2b176deb94e75417ed9b9d3670444a4167/src/SphereXEngine.sol#L38) and [`!SX:SPHEREX`](https://github.com/spherex-collab/spherex-protect/blob/5b134b2b176deb94e75417ed9b9d3670444a4167/src/SphereXProtected.sol#L81) may confuse users of the integrating protocols due to their lack of descriptiveness. It is recommended to revise these messages to more accurately depict the corresponding issues and context (e.g., `\"SphereX error: disallowed tx pattern\"`). This change will enhance user understanding and facilitate troubleshooting of contract interaction issues.\n\n\n***Update**: Resolved in [pull request #22](https://github.com/spherex-collab/spherex-protect/pull/22) at commit [b533a0b](https://github.com/spherex-collab/spherex-protect/pull/22/commits/b533a0bfaa8080d9a577e3c000c9c45616e0ff82).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/SphereXEngine.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// (c) SphereX 2023 Terms&Conditions\n\npragma solidity >=0.6.0;\n\nimport \"./Ownable.sol\";\nimport \"./ISphereXEngine.sol\";\n\n/**\n * @title SphereX Engine\n * @notice Gathers information about an ongoing transaction and reverts if it seems malicious\n */\ncontract SphereXEngine is Ownable, ISphereXEngine {\n    bytes8 private _engineRules; // By default the contract will be deployed with no guarding rules activated\n    mapping(address => bool) private _allowedSenders;\n    mapping(uint256 => bool) private _allowedPatterns;\n\n    // We initialize the next variables to 1 and not 0 to save gas costs on future transactions\n    uint256 private _currentPattern = PATTERN_START;\n    uint256 private _callDepth = DEPTH_START;\n\n    // Represent keccak256(abi.encode(block.number, tx.origin))\n    bytes32 private _currentBlockOriginHash = bytes32(uint256(1));\n\n    uint256 private constant PATTERN_START = 1;\n    uint256 private constant DEPTH_START = 1;\n    bytes32 private constant DEACTIVATED = bytes32(0);\n\n    modifier returnsIfNotActivated() {\n        if (_engineRules == DEACTIVATED) {\n            return;\n        }\n\n        _;\n    }\n\n    modifier onlyApprovedSenders() {\n        require(_allowedSenders[msg.sender], \"!SX:SENDERS\");\n        _;\n    }\n\n    // ============ Management ============\n\n    /**\n     * Activate the guardian rules\n     * @param rules bytes8 representing the new rules to activate.\n     */\n    function activateRules(bytes8 rules) external onlyOwner {\n        _engineRules = rules;\n    }\n\n    /**\n     * Deactivates the engine, the calls will return without being checked\n     */\n    function deactivateRules() external onlyOwner {\n        _engineRules = bytes8(uint64(0));\n    }\n\n    /**\n     * Adds addresses that will be served by this engine. An address that was never added will get a revert if it tries to call the engine.\n     * @param senders list of address to add to the set of allowed addresses\n     */\n    function addAllowedSender(address[] calldata senders) external onlyOwner {\n        for (uint256 i = 0; i < senders.length; ++i) {\n            _allowedSenders[senders[i]] = true;\n        }\n    }\n\n    /**\n     * Removes address so that they will not get served when calling the engine. Transaction from these addresses will get reverted.\n     * @param senders list of address to stop service.\n     */\n    function removeAllowedSender(address[] calldata senders) external onlyOwner {\n        for (uint256 i = 0; i < senders.length; ++i) {\n            _allowedSenders[senders[i]] = false;\n        }\n    }\n\n    /**\n     * Add allowed patterns - these are representation of allowed flows of transactions, and prefixes of these flows\n     * @param patterns list of flows to allow as valid and non-malicious flows\n     */\n    function addAllowedPatterns(uint256[] calldata patterns) external onlyOwner {\n        for (uint256 i = 0; i < patterns.length; ++i) {\n            _allowedPatterns[patterns[i]] = true;\n        }\n    }\n\n    /**\n     * Remove allowed patterns - these are representation flows of transactions, and prefixes of these flows,\n     * that are no longer considered valid and benign\n     * @param patterns list of flows that no longer considered valid and non-malicious\n     */\n    function removeAllowedPatterns(uint256[] calldata patterns) external onlyOwner {\n        for (uint256 i = 0; i < patterns.length; ++i) {\n            _allowedPatterns[patterns[i]] = false;\n        }\n    }\n\n    // ============ CF ============\n\n    /**\n     * Checks if rule1 is activated.\n     */\n    function _isRule1Activated() private view returns (bool) {\n        return (_engineRules & bytes8(uint64(1))) > 0;\n    }\n\n    /**\n     * Checks if rule2 us activated.\n     */\n    function _isRule2Activated() private view returns (bool) {\n        return (_engineRules & bytes8(uint64(2))) > 0;\n    }\n\n    /**\n     * update the current CF pattern with a new number, \n     * when exiting a function we check the validity of the pattern.\n     * @param num element to add to the flow. Poistive number represents start of function, negative exit.\n     * @param forceCheck force the check of the current pattern, even if normal test conditions don't exist.\n     */\n    function _addCFElement(int16 num, bool forceCheck) private {\n        // Upon entry to a new function if we are configured to PrefixTxFlow we should check if we are at the same transaction\n        // or a new one. in case of a new one we need to reinit the _currentPattern, and save\n        // the new transaction \"hash\" (block.number+tx.origin)\n        if (num > 0 && _isRule2Activated()) {\n            bytes32 currentBlockOriginHash = keccak256(abi.encode(block.number, tx.origin));\n            if (currentBlockOriginHash != _currentBlockOriginHash) {\n                _currentPattern = PATTERN_START;\n                _currentBlockOriginHash = currentBlockOriginHash;\n            }\n        }\n\n        _currentPattern = uint256(keccak256(abi.encode(num, _currentPattern)));\n\n        if (num > 0) {\n            ++_callDepth;\n        } else if (num < 0) {\n            --_callDepth;\n        } else {\n            revert(\"!SX:ERROR\");\n        }\n\n        if ((_callDepth == DEPTH_START) || (forceCheck)) {\n            _checkCallFlow();\n        }\n\n        // If we are configured to CF then if we reach depth == DEPTH_START we should reinit the\n        // _currentPattern\n        if (_isRule1Activated() && _callDepth == DEPTH_START) {\n            _currentPattern = PATTERN_START;\n        }\n    }\n\n    /**\n     * Check if the current call flow pattern (that is, the result of the rolling hash) is an allowed pattern.\n     */\n    function _checkCallFlow() private view {\n        require(_allowedPatterns[_currentPattern], \"!SX:DETECTED\");\n    }\n\n    /**\n     * This is the function that is actually called by the modifier of the protected contract before the body of the function.\n     * This is used only for external call functions.\n     * @param num id of function to add. Should be positive\n     * @param sender For future use\n     * @param data For future use\n     * @return result in the future will return insturction on what storage slots to gather, but not used for now\n     */\n    function sphereXValidatePre(int16 num, address sender, bytes calldata data)\n        external\n        override\n        returnsIfNotActivated // may return empty bytes32[]\n        onlyApprovedSenders\n        returns (bytes32[] memory result)\n    {\n        _addCFElement(num, false);\n        return result;\n    }\n\n    /**\n     * This is the function that is actually called by the modifier of the protected contract after the body of the function.\n     * This is used only for external call functions (that is, external, and public when called outside the contract).\n     * @param num id of function to add. Should be negative\n     * @param valuesBefore For future use\n     * @param valuesAfter For future use\n     */\n    function sphereXValidatePost(int16 num, uint256 gas, bytes32[] calldata valuesBefore, bytes32[] calldata valuesAfter)\n        external\n        override\n        returnsIfNotActivated\n        onlyApprovedSenders\n    {\n        _addCFElement(num, true);\n    }\n\n    /**\n     * This is the function that is actually called by the modifier of the protected contract before and after the body of the function.\n     * This is used only for internal function calls (internal and private functions).\n     * @param num id of function to add.\n     */\n    function sphereXValidateInternalPre(int16 num) external override returnsIfNotActivated onlyApprovedSenders {\n        _addCFElement(num, false);\n    }\n\n    /**\n     * This is the function that is actually called by the modifier of the protected contract before and after the body of the function.\n     * This is used only for internal function calls (internal and private functions).\n     * @param num id of function to add.\n     */\n    function sphereXValidateInternalPost(int16 num, uint256 gas) external override returnsIfNotActivated onlyApprovedSenders {\n        _addCFElement(num, false);\n    }\n}"
    }
  ]
}