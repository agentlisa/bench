{
  "Title": "Omission of the transfer in disburseJob leads to inconsistent balance state",
  "Content": "The [`RenderToken`](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/RenderToken.sol) contract interacts with the `Escrow` contract by funding jobs, transferring tokens to increase the different jobs’ balances, which are tracked by the `Escrow`. The [`disburseJob`](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/Escrow.sol#L69) function later takes care of redistributing these funds among the `recipients`.\n\n\nThis function, however, does not actually transfer the tokens to the recipients, but simply sets an allowance, which the recipients can then use to transfer the tokens themselves. While there is merit in using a pattern where the beneficiaries are in charge of withdrawing their funds, the `disburseJob`function will leave the `Escrow` in an inconsistent state where the sum of the total [`jobBalances`](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/Escrow.sol#L69) is different from its total token balance, since the former are depleted by the function but the latter isn’t.\n\n\nEven if the `jobBalances` mapping cannot be traversed to get the total balance without an external listing of jobs, consider implementing the `Escrow`balance tracking in a way that doesn’t lead to inconsistencies, or using the `PullPayment/Escrow` solution provided in the OpenZeppelin suite.\n\n\n***Update:** the `disburseJob` function [now performs](https://github.com/jeualvarez/Token-Audit/blob/master/contracts/Escrow.sol#L103) the token transfers.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Escrow.sol",
      "content": "pragma solidity ^0.4.18;\n\nimport \"../node_modules/openzeppelin-zos/contracts/token/ERC20/MintableToken.sol\";\n\n/**\n * @title Escrow\n * @dev Escrow contract that works with RNDR token\n * This contract holds tokens while render jobs are being completed\n * and information on token allottment per job\n */\ncontract Escrow is Migratable, Ownable {\n  using SafeMath for uint256;\n\n  // This is a mapping of job IDs to the number of tokens allotted to the job\n  mapping(string => uint256) jobBalances;\n  // This is the address of the render token contract\n  address public renderTokenAddress;\n  // This is the address with authority to call the disburseJob function\n  address public disbursalAddress;\n\n  // Emit the jobId along with the new balance of the job\n  // Used on job creation, additional funding added to jobs, and job disbursal\n  // Internal systems for assigning jobs will watch this event to determine balances available\n  event JobBalanceUpdate (string _jobId, uint256 _balance);\n\n  /**\n   * @dev Constructor\n   * @param _owner because this contract uses proxies, owner must be passed in as a param\n   * @param _renderTokenAddress see renderTokenAddress\n   */\n  function initialize (address _owner, address _renderTokenAddress) public isInitializer(\"Escrow\", \"0\") {\n    Ownable.initialize(_owner);\n    disbursalAddress = _owner;\n    renderTokenAddress = _renderTokenAddress;\n  }\n\n  /**\n   * @dev Change the address authorized to distribute tokens for completed jobs\n   *\n   * Because there are no on-chain details to indicate who performed a render, an outside\n   * system must call the disburseJob function with the information needed to properly\n   * distribute tokens. This function updates the address with the authority to perform distributions\n   * @param _newDisbursalAddress see disbursalAddress\n   */\n  function changeDisbursalAddress(address _newDisbursalAddress) public onlyOwner {\n    disbursalAddress = _newDisbursalAddress;\n  }\n\n  /**\n   * @dev Change the address allowances will be sent to after job completion\n   *\n   * Ideally, this will not be used, but is included as a failsafe\n   * @param _newRenderTokenAddress see renderTokenAddress\n   */\n  function changeRenderTokenAddress(address _newRenderTokenAddress) public onlyOwner {\n    renderTokenAddress = _newRenderTokenAddress;\n  }\n\n  /**\n   * @dev Send allowances to node(s) that performed a job\n   *\n   * This can only be called by the disbursalAddress, an accound owned\n   * by OTOY, and it provides the number of tokens to send to each node\n   * @param _jobId the ID of the job used in the jobBalances mapping\n   * @param _recipients the address(es) of the nodes that performed rendering\n   * @param _amounts the amount(s) to send to each address. These must be in the same\n   * order as the recipient addresses\n   */\n  function disburseJob(string _jobId, address[] _recipients, uint256[] _amounts) public canDisburse {\n    require(jobBalances[_jobId] > 0);\n\n    for(uint i = 0; i < _recipients.length; i++) {\n      jobBalances[_jobId] = jobBalances[_jobId].sub(_amounts[i]);\n      StandardToken(renderTokenAddress).increaseApproval(_recipients[i], _amounts[i]);\n    }\n\n    emit JobBalanceUpdate(_jobId, jobBalances[_jobId]);\n  }\n\n  /**\n   * @dev Add RNDR tokens to a job\n   *\n   * This can only be called by a function on the RNDR token contract\n   * @param _jobId the ID of the job used in the jobBalances mapping\n   * @param _tokens the number of tokens sent by the artist to fund the job\n   */\n  function fundJob(string _jobId, uint256 _tokens) public {\n    // Jobs can only be created through the RNDR contract\n    require(msg.sender == renderTokenAddress);\n\n    jobBalances[_jobId] = jobBalances[_jobId].add(_tokens);\n\n    emit JobBalanceUpdate(_jobId, jobBalances[_jobId]);\n  }\n\n  /**\n   * @dev See the tokens available for a job\n   *\n   * @param _jobId the ID used to lookup the job balance\n   */\n  function jobBalance(string _jobId) public view returns(uint256) {\n    return jobBalances[_jobId];\n  }\n\n  /**\n   * @dev Modifier to check if the message sender can call the disburseJob function\n   */\n  modifier canDisburse() {\n    require(msg.sender == disbursalAddress);\n    _;\n  }\n\n}"
    },
    {
      "filename": "contracts/Escrow.sol",
      "content": "pragma solidity ^0.4.24;\n\nimport { ERC20, SafeERC20 } from \"../node_modules/openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\";\nimport { Migratable } from \"../node_modules/zos-lib/contracts/migrations/Migratable.sol\";\nimport { Ownable } from \"../node_modules/openzeppelin-zos/contracts/ownership/Ownable.sol\";\nimport { SafeMath } from \"../node_modules/openzeppelin-zos/contracts/math/SafeMath.sol\";\n\n/**\n * @title Escrow\n * @dev Escrow contract that works with RNDR token\n * This contract holds tokens while render jobs are being completed\n * and information on token allottment per job\n */\ncontract Escrow is Migratable, Ownable {\n  using SafeERC20 for ERC20;\n  using SafeMath for uint256;\n\n  // This is a mapping of job IDs to the number of tokens allotted to the job\n  mapping(string => uint256) private jobBalances;\n  // This is the address of the render token contract\n  address public renderTokenAddress;\n  // This is the address with authority to call the disburseJob function\n  address public disbursalAddress;\n\n  // Emit new disbursal address when disbursalAddress has been changed\n  event DisbursalAddressUpdate(address disbursalAddress);\n  // Emit the jobId along with the new balance of the job\n  // Used on job creation, additional funding added to jobs, and job disbursal\n  // Internal systems for assigning jobs will watch this event to determine balances available\n  event JobBalanceUpdate(string _jobId, uint256 _balance);\n  // Emit new contract address when renderTokenAddress has been changed\n  event RenderTokenAddressUpdate(address renderTokenAddress);\n\n  /**\n   * @dev Modifier to check if the message sender can call the disburseJob function\n   */\n  modifier canDisburse() {\n    require(msg.sender == disbursalAddress, \"message sender not authorized to disburse funds\");\n    _;\n  }\n\n  /**\n   * @dev Initailization\n   * @param _owner because this contract uses proxies, owner must be passed in as a param\n   * @param _renderTokenAddress see renderTokenAddress\n   */\n  function initialize (address _owner, address _renderTokenAddress) public isInitializer(\"Escrow\", \"0\") {\n    require(_owner != address(0), \"_owner must not be null\");\n    require(_renderTokenAddress != address(0), \"_renderTokenAddress must not be null\");\n    Ownable.initialize(_owner);\n    disbursalAddress = _owner;\n    renderTokenAddress = _renderTokenAddress;\n  }\n\n  /**\n   * @dev Change the address authorized to distribute tokens for completed jobs\n   *\n   * Because there are no on-chain details to indicate who performed a render, an outside\n   * system must call the disburseJob function with the information needed to properly\n   * distribute tokens. This function updates the address with the authority to perform distributions\n   * @param _newDisbursalAddress see disbursalAddress\n   */\n  function changeDisbursalAddress(address _newDisbursalAddress) external onlyOwner {\n    disbursalAddress = _newDisbursalAddress;\n\n    emit DisbursalAddressUpdate(disbursalAddress);\n  }\n\n  /**\n   * @dev Change the address allowances will be sent to after job completion\n   *\n   * Ideally, this will not be used, but is included as a failsafe.\n   * RNDR is still in its infancy, and changes may need to be made to this\n   * contract and / or the renderToken contract. Including methods to update the\n   * addresses allows the contracts to update independently.\n   * If the RNDR token contract is ever migrated to another address for\n   * either added security or functionality, this will need to be called.\n   * @param _newRenderTokenAddress see renderTokenAddress\n   */\n  function changeRenderTokenAddress(address _newRenderTokenAddress) external onlyOwner {\n    require(_newRenderTokenAddress != address(0), \"_newRenderTokenAddress must not be null\");\n    renderTokenAddress = _newRenderTokenAddress;\n\n    emit RenderTokenAddressUpdate(renderTokenAddress);\n  }\n\n  /**\n   * @dev Send allowances to node(s) that performed a job\n   *\n   * This can only be called by the disbursalAddress, an accound owned\n   * by OTOY, and it provides the number of tokens to send to each node\n   * @param _jobId the ID of the job used in the jobBalances mapping\n   * @param _recipients the address(es) of the nodes that performed rendering\n   * @param _amounts the amount(s) to send to each address. These must be in the same\n   * order as the recipient addresses\n   */\n  function disburseJob(string _jobId, address[] _recipients, uint256[] _amounts) external canDisburse {\n    require(jobBalances[_jobId] > 0, \"_jobId has no available balance\");\n    require(_recipients.length == _amounts.length, \"_recipients and _amounts must be the same length\");\n\n    for(uint256 i = 0; i < _recipients.length; i++) {\n      jobBalances[_jobId] = jobBalances[_jobId].sub(_amounts[i]);\n      ERC20(renderTokenAddress).safeTransfer(_recipients[i], _amounts[i]);\n    }\n\n    emit JobBalanceUpdate(_jobId, jobBalances[_jobId]);\n  }\n\n  /**\n   * @dev Add RNDR tokens to a job\n   *\n   * This can only be called by a function on the RNDR token contract\n   * @param _jobId the ID of the job used in the jobBalances mapping\n   * @param _tokens the number of tokens sent by the artist to fund the job\n   */\n  function fundJob(string _jobId, uint256 _tokens) external {\n    // Jobs can only be created by the address stored in the renderTokenAddress variable\n    require(msg.sender == renderTokenAddress, \"message sender not authorized\");\n    jobBalances[_jobId] = jobBalances[_jobId].add(_tokens);\n\n    emit JobBalanceUpdate(_jobId, jobBalances[_jobId]);\n  }\n\n  /**\n   * @dev See the tokens available for a job\n   *\n   * @param _jobId the ID used to lookup the job balance\n   */\n  function jobBalance(string _jobId) external view returns(uint256) {\n    return jobBalances[_jobId];\n  }\n\n}"
    }
  ]
}