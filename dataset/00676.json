{
  "Title": "`InflationManager.lastUpdate` is not used",
  "Content": "##### Description\n\nIt only is set once on deployment, works as a timestamp of deployment, and is never used by other contracts.\n- https://github.com/ConicFinance/protocol/blob/7a66d26ef84f93059a811a189655e17c11d95f5c/contracts/tokenomics/InflationManager.sol#L43\n\n##### Recommendation\n\nWe recommend removing `lastUpdate`.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/tokenomics/InflationManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport \"../../interfaces/tokenomics/IRebalancingRewardsHandler.sol\";\nimport \"../../interfaces/tokenomics/IInflationManager.sol\";\nimport \"../../interfaces/IController.sol\";\nimport \"../../interfaces/tokenomics/ICNCToken.sol\";\nimport \"../../interfaces/pools/IConicPool.sol\";\nimport \"../../interfaces/pools/ILpToken.sol\";\n\nimport \"../../libraries/ScaledMath.sol\";\n\ncontract InflationManager is IInflationManager, Ownable {\n    using ScaledMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    ICNCToken public constant CNC = ICNCToken(0x9aE380F0272E2162340a5bB646c354271c0F5cFC);\n\n    IController public immutable controller;\n\n    uint256 internal constant _INITIAL_INFLATION_RATE = 1_500_000 * 1e18;\n    uint256 internal constant _INFLATION_RATE_DECAY = 0.3999999 * 1e18;\n    uint256 internal constant _INFLATION_RATE_PERIOD = 365 days;\n\n    /// @dev mapping from conic pool to their rebalancing reward handlers\n    mapping(address => EnumerableSet.AddressSet) internal _rebalancingRewardHandlers;\n\n    uint256 public override currentInflationRate;\n    uint256 public lastInflationRateDecay;\n    uint256 public lastUpdate;\n    uint256 public totalLpInflationMinted;\n\n    mapping(address => uint256) public currentPoolWeights;\n\n    constructor(address _controller) Ownable() {\n        require(_controller != address(0), \"Cannot use zero address for controller\");\n        controller = IController(_controller);\n\n        currentInflationRate = _INITIAL_INFLATION_RATE / _INFLATION_RATE_PERIOD;\n        lastUpdate = block.timestamp;\n        lastInflationRateDecay = block.timestamp;\n    }\n\n    /// @notice returns the weights of the Conic pools to know how much inflation\n    /// each of them will receive. totalUSDValue only accounts for funds in active pools\n    function computePoolWeights()\n        public\n        view\n        override\n        returns (address[] memory pools, uint256[] memory poolWeights, uint256 totalUSDValue)\n    {\n        IOracle oracle = controller.priceOracle();\n        pools = controller.listPools();\n        uint256[] memory poolUSDValues = new uint256[](pools.length);\n        for (uint256 i; i < pools.length; i++) {\n            if (controller.isActivePool(pools[i])) {\n                IConicPool pool = IConicPool(pools[i]);\n                IERC20Metadata underlying = pool.underlying();\n                uint256 price = oracle.getUSDPrice(address(underlying));\n                uint256 poolUSDValue = pool\n                    .cachedTotalUnderlying()\n                    .convertScale(underlying.decimals(), 18)\n                    .mulDown(price);\n                poolUSDValues[i] = poolUSDValue;\n                totalUSDValue += poolUSDValue;\n            }\n        }\n\n        poolWeights = new uint256[](pools.length);\n\n        if (totalUSDValue == 0) {\n            for (uint256 i; i < pools.length; i++) {\n                poolWeights[i] = ScaledMath.ONE / pools.length;\n            }\n        } else {\n            for (uint256 i; i < pools.length; i++) {\n                poolWeights[i] = poolUSDValues[i].divDown(totalUSDValue);\n            }\n        }\n    }\n\n    /// @notice Same as `computePoolWeights` but only returns the value for a single pool\n    /// totalUSDValue only accounts for funds in active pools\n    function computePoolWeight(\n        address pool\n    ) public view returns (uint256 poolWeight, uint256 totalUSDValue) {\n        require(controller.isPool(pool), \"pool not found\");\n        IOracle oracle = controller.priceOracle();\n        address[] memory pools = controller.listPools();\n        uint256 poolUSDValue;\n        for (uint256 i; i < pools.length; i++) {\n            if (controller.isActivePool(pools[i])) {\n                IConicPool currentPool = IConicPool(pools[i]);\n                IERC20Metadata underlying = currentPool.underlying();\n                uint256 price = oracle.getUSDPrice(address(underlying));\n                uint256 usdValue = currentPool\n                    .cachedTotalUnderlying()\n                    .convertScale(underlying.decimals(), 18)\n                    .mulDown(price);\n                totalUSDValue += usdValue;\n                if (address(currentPool) == pool) poolUSDValue = usdValue;\n            }\n        }\n\n        if (!controller.isActivePool(pool)) {\n            return (0, totalUSDValue);\n        }\n        poolWeight = totalUSDValue == 0\n            ? ScaledMath.ONE / pools.length\n            : poolUSDValue.divDown(totalUSDValue);\n    }\n\n    function executeInflationRateUpdate() external override {\n        _executeInflationRateUpdate();\n    }\n\n    function handleRebalancingRewards(\n        address account,\n        uint256 deviationBefore,\n        uint256 deviationAfter\n    ) external {\n        require(controller.isPool(msg.sender), \"only pools can call this function\");\n        for (uint256 i; i < _rebalancingRewardHandlers[msg.sender].length(); i++) {\n            address handler = _rebalancingRewardHandlers[msg.sender].at(i);\n            IRebalancingRewardsHandler(handler).handleRebalancingRewards(\n                IConicPool(msg.sender),\n                account,\n                deviationBefore,\n                deviationAfter\n            );\n        }\n    }\n\n    function addPoolRebalancingRewardHandler(\n        address poolAddress,\n        address rebalancingRewardHandler\n    ) external override onlyOwner {\n        require(controller.isPool(poolAddress), \"invalid pool\");\n        require(\n            _rebalancingRewardHandlers[poolAddress].add(rebalancingRewardHandler),\n            \"handler already set\"\n        );\n\n        emit RebalancingRewardHandlerAdded(poolAddress, rebalancingRewardHandler);\n    }\n\n    function removePoolRebalancingRewardHandler(\n        address poolAddress,\n        address rebalancingRewardHandler\n    ) external override onlyOwner {\n        require(controller.isPool(poolAddress), \"invalid pool\");\n        require(\n            _rebalancingRewardHandlers[poolAddress].remove(rebalancingRewardHandler),\n            \"handler not set\"\n        );\n        emit RebalancingRewardHandlerRemoved(poolAddress, rebalancingRewardHandler);\n    }\n\n    function hasPoolRebalancingRewardHandlers(\n        address poolAddress,\n        address handler\n    ) external view returns (bool) {\n        return _rebalancingRewardHandlers[poolAddress].contains(handler);\n    }\n\n    function rebalancingRewardHandlers(\n        address poolAddress\n    ) external view returns (address[] memory) {\n        return _rebalancingRewardHandlers[poolAddress].values();\n    }\n\n    function updatePoolWeights() public override {\n        (address[] memory _pools, uint256[] memory poolWeights, ) = computePoolWeights();\n        uint256 numPools = _pools.length;\n        ILpTokenStaker lpTokenStaker = controller.lpTokenStaker();\n        for (uint256 i; i < numPools; i++) {\n            address curPool = _pools[i];\n            IRewardManager(IConicPool(curPool).rewardManager()).poolCheckpoint();\n            lpTokenStaker.checkpoint(curPool);\n            currentPoolWeights[curPool] = poolWeights[i];\n        }\n        emit PoolWeightsUpdated();\n    }\n\n    /// @dev Pool weights will be updated periodically\n    function getCurrentPoolInflationRate(address pool) external view override returns (uint256) {\n        return currentInflationRate.mulDown(currentPoolWeights[pool]);\n    }\n\n    function _executeInflationRateUpdate() internal {\n        if (block.timestamp >= lastInflationRateDecay + _INFLATION_RATE_PERIOD) {\n            updatePoolWeights();\n            currentInflationRate = currentInflationRate.mulDown(_INFLATION_RATE_DECAY);\n            lastInflationRateDecay = block.timestamp;\n        }\n    }\n}"
    }
  ]
}