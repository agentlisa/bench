{
  "Title": "Lack of validation",
  "Content": "Throughout the codebase, there are places where a proper input/output validation is lacking. In particular:\n\n\n* The [`inverse`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/utility/FractionLibrary.sol#L52-L73) and [`fromFraction112`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/utility/FractionLibrary.sol#L87) functions in [`FractionLibrary`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/utility/FractionLibrary.sol) do not check if they were provided an invalid fraction.\n* The [`_mulMod`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/utility/MathEx.sol#L332), [`mulDivC`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/utility/MathEx.sol#L202), [`mulDivF`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/utility/MathEx.sol#L168) functions in the [`MathEx`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/utility/MathEx.sol) library do not check that `z` in non-zero. In such cases they revert with a Panic, rather than a more helpful error message.\n* The [`isInRange`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/utility/MathEx.sol#L140) and [`weightedAverage`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/utility/MathEx.sol#L123) functions in the [`MathEx`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/utility/MathEx.sol) library do not check that the input fractions are valid. The latter also does not ensure it is returning a valid fraction.\n\n\nA lack of validation on user-controlled parameters may result in erroneous or failing transactions that are difficult to debug. This is especially true in the case of libraries that are capable of being reused across different codebases. To avoid this, consider adding input and output validation to address the concerns raised above.\n\n\n**Update:** *Acknowledged without code changes. The client expressed that the lack of reversion on invalid inputs is intentional. In some cases it is desirable behavior to turn divide by zero inputs into zero outputs. In other cases, error messages will be raised somewhere else along the call chain in practice.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/utility/FractionLibrary.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { Fraction, Fraction112, InvalidFraction } from \"./Fraction.sol\";\nimport { MathEx } from \"./MathEx.sol\";\n\n// solhint-disable-next-line func-visibility\nfunction zeroFraction() pure returns (Fraction memory) {\n    return Fraction({ n: 0, d: 1 });\n}\n\n// solhint-disable-next-line func-visibility\nfunction zeroFraction112() pure returns (Fraction112 memory) {\n    return Fraction112({ n: 0, d: 1 });\n}\n\n/**\n * @dev this library provides a set of fraction operations\n */\nlibrary FractionLibrary {\n    /**\n     * @dev returns whether a standard fraction is valid\n     */\n    function isValid(Fraction memory fraction) internal pure returns (bool) {\n        return fraction.d != 0;\n    }\n\n    /**\n     * @dev returns whether a 112-bit fraction is valid\n     */\n    function isValid(Fraction112 memory fraction) internal pure returns (bool) {\n        return fraction.d != 0;\n    }\n\n    /**\n     * @dev returns whether a standard fraction is positive\n     */\n    function isPositive(Fraction memory fraction) internal pure returns (bool) {\n        return isValid(fraction) && fraction.n != 0;\n    }\n\n    /**\n     * @dev returns whether a 112-bit fraction is positive\n     */\n    function isPositive(Fraction112 memory fraction) internal pure returns (bool) {\n        return isValid(fraction) && fraction.n != 0;\n    }\n\n    /**\n     * @dev returns the inverse of a given fraction\n     */\n    function inverse(Fraction memory fraction) internal pure returns (Fraction memory) {\n        Fraction memory invFraction = Fraction({ n: fraction.d, d: fraction.n });\n\n        if (!isValid(invFraction)) {\n            revert InvalidFraction();\n        }\n\n        return invFraction;\n    }\n\n    /**\n     * @dev returns the inverse of a given fraction\n     */\n    function inverse(Fraction112 memory fraction) internal pure returns (Fraction112 memory) {\n        Fraction112 memory invFraction = Fraction112({ n: fraction.d, d: fraction.n });\n\n        if (!isValid(invFraction)) {\n            revert InvalidFraction();\n        }\n\n        return invFraction;\n    }\n\n    /**\n     * @dev reduces a standard fraction to a 112-bit fraction\n     */\n    function toFraction112(Fraction memory fraction) internal pure returns (Fraction112 memory) {\n        Fraction memory reducedFraction = MathEx.reducedFraction(fraction, type(uint112).max);\n\n        return Fraction112({ n: uint112(reducedFraction.n), d: uint112(reducedFraction.d) });\n    }\n\n    /**\n     * @dev expands a 112-bit fraction to a standard fraction\n     */\n    function fromFraction112(Fraction112 memory fraction) internal pure returns (Fraction memory) {\n        return Fraction({ n: fraction.n, d: fraction.d });\n    }\n}"
    },
    {
      "filename": "contracts/utility/MathEx.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { Fraction, InvalidFraction } from \"./Fraction.sol\";\n\nimport { PPM_RESOLUTION } from \"./Constants.sol\";\n\nuint256 constant ONE = 0x80000000000000000000000000000000;\nuint256 constant LN2 = 0x58b90bfbe8e7bcd5e4f1d9cc01f97b57;\n\nstruct Uint512 {\n    uint256 hi; // 256 most significant bits\n    uint256 lo; // 256 least significant bits\n}\n\nstruct Sint256 {\n    uint256 value;\n    bool isNeg;\n}\n\n/**\n * @dev this library provides a set of complex math operations\n */\nlibrary MathEx {\n    error Overflow();\n\n    /**\n     * @dev returns `2 ^ f` by calculating `e ^ (f * ln(2))`, where `e` is Euler's number:\n     * - Rewrite the input as a sum of binary exponents and a single residual r, as small as possible\n     * - The exponentiation of each binary exponent is given (pre-calculated)\n     * - The exponentiation of r is calculated via Taylor series for e^x, where x = r\n     * - The exponentiation of the input is calculated by multiplying the intermediate results above\n     * - For example: e^5.521692859 = e^(4 + 1 + 0.5 + 0.021692859) = e^4 * e^1 * e^0.5 * e^0.021692859\n     */\n    function exp2(Fraction memory f) internal pure returns (Fraction memory) {\n        uint256 x = MathEx.mulDivF(LN2, f.n, f.d);\n        uint256 y;\n        uint256 z;\n        uint256 n;\n\n        if (x >= (ONE << 4)) {\n            revert Overflow();\n        }\n\n        unchecked {\n            z = y = x % (ONE >> 3); // get the input modulo 2^(-3)\n            z = (z * y) / ONE;\n            n += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\n            z = (z * y) / ONE;\n            n += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\n            z = (z * y) / ONE;\n            n += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\n            z = (z * y) / ONE;\n            n += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\n            z = (z * y) / ONE;\n            n += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\n            z = (z * y) / ONE;\n            n += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\n            z = (z * y) / ONE;\n            n += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\n            z = (z * y) / ONE;\n            n += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\n            z = (z * y) / ONE;\n            n += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\n            z = (z * y) / ONE;\n            n += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\n            z = (z * y) / ONE;\n            n += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\n            z = (z * y) / ONE;\n            n += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\n            z = (z * y) / ONE;\n            n += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\n            z = (z * y) / ONE;\n            n += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\n            z = (z * y) / ONE;\n            n += z * 0x000000000001c638; // add y^16 * (20! / 16!)\n            z = (z * y) / ONE;\n            n += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\n            z = (z * y) / ONE;\n            n += z * 0x000000000000017c; // add y^18 * (20! / 18!)\n            z = (z * y) / ONE;\n            n += z * 0x0000000000000014; // add y^19 * (20! / 19!)\n            z = (z * y) / ONE;\n            n += z * 0x0000000000000001; // add y^20 * (20! / 20!)\n            n = n / 0x21c3677c82b40000 + y + ONE; // divide by 20! and then add y^1 / 1! + y^0 / 0!\n\n            if ((x & (ONE >> 3)) != 0)\n                n = (n * 0x1c3d6a24ed82218787d624d3e5eba95f9) / 0x18ebef9eac820ae8682b9793ac6d1e776; // multiply by e^(2^-3)\n            if ((x & (ONE >> 2)) != 0)\n                n = (n * 0x18ebef9eac820ae8682b9793ac6d1e778) / 0x1368b2fc6f9609fe7aceb46aa619baed4; // multiply by e^(2^-2)\n            if ((x & (ONE >> 1)) != 0)\n                n = (n * 0x1368b2fc6f9609fe7aceb46aa619baed5) / 0x0bc5ab1b16779be3575bd8f0520a9f21f; // multiply by e^(2^-1)\n            if ((x & (ONE << 0)) != 0)\n                n = (n * 0x0bc5ab1b16779be3575bd8f0520a9f21e) / 0x0454aaa8efe072e7f6ddbab84b40a55c9; // multiply by e^(2^+0)\n            if ((x & (ONE << 1)) != 0)\n                n = (n * 0x0454aaa8efe072e7f6ddbab84b40a55c5) / 0x00960aadc109e7a3bf4578099615711ea; // multiply by e^(2^+1)\n            if ((x & (ONE << 2)) != 0)\n                n = (n * 0x00960aadc109e7a3bf4578099615711d7) / 0x0002bf84208204f5977f9a8cf01fdce3d; // multiply by e^(2^+2)\n            if ((x & (ONE << 3)) != 0)\n                n = (n * 0x0002bf84208204f5977f9a8cf01fdc307) / 0x0000003c6ab775dd0b95b4cbee7e65d11; // multiply by e^(2^+3)\n        }\n\n        return Fraction({ n: n, d: ONE });\n    }\n\n    /**\n     * @dev returns a fraction with reduced components\n     */\n    function reducedFraction(Fraction memory fraction, uint256 max) internal pure returns (Fraction memory) {\n        uint256 scale = Math.ceilDiv(Math.max(fraction.n, fraction.d), max);\n        Fraction memory reduced = Fraction({ n: fraction.n / scale, d: fraction.d / scale });\n        if (reduced.d == 0) {\n            revert InvalidFraction();\n        }\n\n        return reduced;\n    }\n\n    /**\n     * @dev returns the weighted average of two fractions\n     */\n    function weightedAverage(\n        Fraction memory fraction1,\n        Fraction memory fraction2,\n        uint256 weight1,\n        uint256 weight2\n    ) internal pure returns (Fraction memory) {\n        return\n            Fraction({\n                n: fraction1.n * fraction2.d * weight1 + fraction1.d * fraction2.n * weight2,\n                d: fraction1.d * fraction2.d * (weight1 + weight2)\n            });\n    }\n\n    /**\n     * @dev returns whether or not the deviation of an offset sample from a base sample is within a permitted range\n     * for example, if the maximum permitted deviation is 5%, then evaluate `95% * base <= offset <= 105% * base`\n     */\n    function isInRange(\n        Fraction memory baseSample,\n        Fraction memory offsetSample,\n        uint32 maxDeviationPPM\n    ) internal pure returns (bool) {\n        Uint512 memory min = mul512(baseSample.n, offsetSample.d * (PPM_RESOLUTION - maxDeviationPPM));\n        Uint512 memory mid = mul512(baseSample.d, offsetSample.n * PPM_RESOLUTION);\n        Uint512 memory max = mul512(baseSample.n, offsetSample.d * (PPM_RESOLUTION + maxDeviationPPM));\n        return lte512(min, mid) && lte512(mid, max);\n    }\n\n    /**\n     * @dev returns an `Sint256` positive representation of an unsigned integer\n     */\n    function toPos256(uint256 n) internal pure returns (Sint256 memory) {\n        return Sint256({ value: n, isNeg: false });\n    }\n\n    /**\n     * @dev returns an `Sint256` negative representation of an unsigned integer\n     */\n    function toNeg256(uint256 n) internal pure returns (Sint256 memory) {\n        return Sint256({ value: n, isNeg: true });\n    }\n\n    /**\n     * @dev returns the largest integer smaller than or equal to `x * y / z`\n     */\n    function mulDivF(\n        uint256 x,\n        uint256 y,\n        uint256 z\n    ) internal pure returns (uint256) {\n        Uint512 memory xy = mul512(x, y);\n\n        // if `x * y < 2 ^ 256`\n        if (xy.hi == 0) {\n            return xy.lo / z;\n        }\n\n        // assert `x * y / z < 2 ^ 256`\n        if (xy.hi >= z) {\n            revert Overflow();\n        }\n\n        uint256 m = _mulMod(x, y, z); // `m = x * y % z`\n        Uint512 memory n = _sub512(xy, m); // `n = x * y - m` hence `n / z = floor(x * y / z)`\n\n        // if `n < 2 ^ 256`\n        if (n.hi == 0) {\n            return n.lo / z;\n        }\n\n        uint256 p = _unsafeSub(0, z) & z; // `p` is the largest power of 2 which `z` is divisible by\n        uint256 q = _div512(n, p); // `n` is divisible by `p` because `n` is divisible by `z` and `z` is divisible by `p`\n        uint256 r = _inv256(z / p); // `z / p = 1 mod 2` hence `inverse(z / p) = 1 mod 2 ^ 256`\n        return _unsafeMul(q, r); // `q * r = (n / p) * inverse(z / p) = n / z`\n    }\n\n    /**\n     * @dev returns the smallest integer larger than or equal to `x * y / z`\n     */\n    function mulDivC(\n        uint256 x,\n        uint256 y,\n        uint256 z\n    ) internal pure returns (uint256) {\n        uint256 w = mulDivF(x, y, z);\n        if (_mulMod(x, y, z) > 0) {\n            if (w >= type(uint256).max) {\n                revert Overflow();\n            }\n\n            return w + 1;\n        }\n        return w;\n    }\n\n    /**\n     * @dev returns the maximum of `n1 - n2` and 0\n     */\n    function subMax0(uint256 n1, uint256 n2) internal pure returns (uint256) {\n        return n1 > n2 ? n1 - n2 : 0;\n    }\n\n    /**\n     * @dev returns the value of `x > y`\n     */\n    function gt512(Uint512 memory x, Uint512 memory y) internal pure returns (bool) {\n        return x.hi > y.hi || (x.hi == y.hi && x.lo > y.lo);\n    }\n\n    /**\n     * @dev returns the value of `x < y`\n     */\n    function lt512(Uint512 memory x, Uint512 memory y) internal pure returns (bool) {\n        return x.hi < y.hi || (x.hi == y.hi && x.lo < y.lo);\n    }\n\n    /**\n     * @dev returns the value of `x >= y`\n     */\n    function gte512(Uint512 memory x, Uint512 memory y) internal pure returns (bool) {\n        return !lt512(x, y);\n    }\n\n    /**\n     * @dev returns the value of `x <= y`\n     */\n    function lte512(Uint512 memory x, Uint512 memory y) internal pure returns (bool) {\n        return !gt512(x, y);\n    }\n\n    /**\n     * @dev returns the value of `x * y`\n     */\n    function mul512(uint256 x, uint256 y) internal pure returns (Uint512 memory) {\n        uint256 p = _mulModMax(x, y);\n        uint256 q = _unsafeMul(x, y);\n        if (p >= q) {\n            return Uint512({ hi: p - q, lo: q });\n        }\n        return Uint512({ hi: _unsafeSub(p, q) - 1, lo: q });\n    }\n\n    /**\n     * @dev returns the value of `x - y`, given that `x >= y`\n     */\n    function _sub512(Uint512 memory x, uint256 y) private pure returns (Uint512 memory) {\n        if (x.lo >= y) {\n            return Uint512({ hi: x.hi, lo: x.lo - y });\n        }\n        return Uint512({ hi: x.hi - 1, lo: _unsafeSub(x.lo, y) });\n    }\n\n    /**\n     * @dev returns the value of `x / pow2n`, given that `x` is divisible by `pow2n`\n     */\n    function _div512(Uint512 memory x, uint256 pow2n) private pure returns (uint256) {\n        uint256 pow2nInv = _unsafeAdd(_unsafeSub(0, pow2n) / pow2n, 1); // `1 << (256 - n)`\n        return _unsafeMul(x.hi, pow2nInv) | (x.lo / pow2n); // `(x.hi << (256 - n)) | (x.lo >> n)`\n    }\n\n    /**\n     * @dev returns the inverse of `d` modulo `2 ^ 256`, given that `d` is congruent to `1` modulo `2`\n     */\n    function _inv256(uint256 d) private pure returns (uint256) {\n        // approximate the root of `f(x) = 1 / x - d` using the newton–raphson convergence method\n        uint256 x = 1;\n        for (uint256 i = 0; i < 8; i++) {\n            x = _unsafeMul(x, _unsafeSub(2, _unsafeMul(x, d))); // `x = x * (2 - x * d) mod 2 ^ 256`\n        }\n        return x;\n    }\n\n    /**\n     * @dev returns `(x + y) % 2 ^ 256`\n     */\n    function _unsafeAdd(uint256 x, uint256 y) private pure returns (uint256) {\n        unchecked {\n            return x + y;\n        }\n    }\n\n    /**\n     * @dev returns `(x - y) % 2 ^ 256`\n     */\n    function _unsafeSub(uint256 x, uint256 y) private pure returns (uint256) {\n        unchecked {\n            return x - y;\n        }\n    }\n\n    /**\n     * @dev returns `(x * y) % 2 ^ 256`\n     */\n    function _unsafeMul(uint256 x, uint256 y) private pure returns (uint256) {\n        unchecked {\n            return x * y;\n        }\n    }\n\n    /**\n     * @dev returns `x * y % (2 ^ 256 - 1)`\n     */\n    function _mulModMax(uint256 x, uint256 y) private pure returns (uint256) {\n        return mulmod(x, y, type(uint256).max);\n    }\n\n    /**\n     * @dev returns `x * y % z`\n     */\n    function _mulMod(\n        uint256 x,\n        uint256 y,\n        uint256 z\n    ) private pure returns (uint256) {\n        return mulmod(x, y, z);\n    }\n}"
    },
    {
      "filename": "contracts/utility/MathEx.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { Fraction, InvalidFraction } from \"./Fraction.sol\";\n\nimport { PPM_RESOLUTION } from \"./Constants.sol\";\n\nuint256 constant ONE = 0x80000000000000000000000000000000;\nuint256 constant LN2 = 0x58b90bfbe8e7bcd5e4f1d9cc01f97b57;\n\nstruct Uint512 {\n    uint256 hi; // 256 most significant bits\n    uint256 lo; // 256 least significant bits\n}\n\nstruct Sint256 {\n    uint256 value;\n    bool isNeg;\n}\n\n/**\n * @dev this library provides a set of complex math operations\n */\nlibrary MathEx {\n    error Overflow();\n\n    /**\n     * @dev returns `2 ^ f` by calculating `e ^ (f * ln(2))`, where `e` is Euler's number:\n     * - Rewrite the input as a sum of binary exponents and a single residual r, as small as possible\n     * - The exponentiation of each binary exponent is given (pre-calculated)\n     * - The exponentiation of r is calculated via Taylor series for e^x, where x = r\n     * - The exponentiation of the input is calculated by multiplying the intermediate results above\n     * - For example: e^5.521692859 = e^(4 + 1 + 0.5 + 0.021692859) = e^4 * e^1 * e^0.5 * e^0.021692859\n     */\n    function exp2(Fraction memory f) internal pure returns (Fraction memory) {\n        uint256 x = MathEx.mulDivF(LN2, f.n, f.d);\n        uint256 y;\n        uint256 z;\n        uint256 n;\n\n        if (x >= (ONE << 4)) {\n            revert Overflow();\n        }\n\n        unchecked {\n            z = y = x % (ONE >> 3); // get the input modulo 2^(-3)\n            z = (z * y) / ONE;\n            n += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\n            z = (z * y) / ONE;\n            n += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\n            z = (z * y) / ONE;\n            n += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\n            z = (z * y) / ONE;\n            n += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\n            z = (z * y) / ONE;\n            n += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\n            z = (z * y) / ONE;\n            n += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\n            z = (z * y) / ONE;\n            n += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\n            z = (z * y) / ONE;\n            n += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\n            z = (z * y) / ONE;\n            n += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\n            z = (z * y) / ONE;\n            n += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\n            z = (z * y) / ONE;\n            n += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\n            z = (z * y) / ONE;\n            n += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\n            z = (z * y) / ONE;\n            n += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\n            z = (z * y) / ONE;\n            n += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\n            z = (z * y) / ONE;\n            n += z * 0x000000000001c638; // add y^16 * (20! / 16!)\n            z = (z * y) / ONE;\n            n += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\n            z = (z * y) / ONE;\n            n += z * 0x000000000000017c; // add y^18 * (20! / 18!)\n            z = (z * y) / ONE;\n            n += z * 0x0000000000000014; // add y^19 * (20! / 19!)\n            z = (z * y) / ONE;\n            n += z * 0x0000000000000001; // add y^20 * (20! / 20!)\n            n = n / 0x21c3677c82b40000 + y + ONE; // divide by 20! and then add y^1 / 1! + y^0 / 0!\n\n            if ((x & (ONE >> 3)) != 0)\n                n = (n * 0x1c3d6a24ed82218787d624d3e5eba95f9) / 0x18ebef9eac820ae8682b9793ac6d1e776; // multiply by e^(2^-3)\n            if ((x & (ONE >> 2)) != 0)\n                n = (n * 0x18ebef9eac820ae8682b9793ac6d1e778) / 0x1368b2fc6f9609fe7aceb46aa619baed4; // multiply by e^(2^-2)\n            if ((x & (ONE >> 1)) != 0)\n                n = (n * 0x1368b2fc6f9609fe7aceb46aa619baed5) / 0x0bc5ab1b16779be3575bd8f0520a9f21f; // multiply by e^(2^-1)\n            if ((x & (ONE << 0)) != 0)\n                n = (n * 0x0bc5ab1b16779be3575bd8f0520a9f21e) / 0x0454aaa8efe072e7f6ddbab84b40a55c9; // multiply by e^(2^+0)\n            if ((x & (ONE << 1)) != 0)\n                n = (n * 0x0454aaa8efe072e7f6ddbab84b40a55c5) / 0x00960aadc109e7a3bf4578099615711ea; // multiply by e^(2^+1)\n            if ((x & (ONE << 2)) != 0)\n                n = (n * 0x00960aadc109e7a3bf4578099615711d7) / 0x0002bf84208204f5977f9a8cf01fdce3d; // multiply by e^(2^+2)\n            if ((x & (ONE << 3)) != 0)\n                n = (n * 0x0002bf84208204f5977f9a8cf01fdc307) / 0x0000003c6ab775dd0b95b4cbee7e65d11; // multiply by e^(2^+3)\n        }\n\n        return Fraction({ n: n, d: ONE });\n    }\n\n    /**\n     * @dev returns a fraction with reduced components\n     */\n    function reducedFraction(Fraction memory fraction, uint256 max) internal pure returns (Fraction memory) {\n        uint256 scale = Math.ceilDiv(Math.max(fraction.n, fraction.d), max);\n        Fraction memory reduced = Fraction({ n: fraction.n / scale, d: fraction.d / scale });\n        if (reduced.d == 0) {\n            revert InvalidFraction();\n        }\n\n        return reduced;\n    }\n\n    /**\n     * @dev returns the weighted average of two fractions\n     */\n    function weightedAverage(\n        Fraction memory fraction1,\n        Fraction memory fraction2,\n        uint256 weight1,\n        uint256 weight2\n    ) internal pure returns (Fraction memory) {\n        return\n            Fraction({\n                n: fraction1.n * fraction2.d * weight1 + fraction1.d * fraction2.n * weight2,\n                d: fraction1.d * fraction2.d * (weight1 + weight2)\n            });\n    }\n\n    /**\n     * @dev returns whether or not the deviation of an offset sample from a base sample is within a permitted range\n     * for example, if the maximum permitted deviation is 5%, then evaluate `95% * base <= offset <= 105% * base`\n     */\n    function isInRange(\n        Fraction memory baseSample,\n        Fraction memory offsetSample,\n        uint32 maxDeviationPPM\n    ) internal pure returns (bool) {\n        Uint512 memory min = mul512(baseSample.n, offsetSample.d * (PPM_RESOLUTION - maxDeviationPPM));\n        Uint512 memory mid = mul512(baseSample.d, offsetSample.n * PPM_RESOLUTION);\n        Uint512 memory max = mul512(baseSample.n, offsetSample.d * (PPM_RESOLUTION + maxDeviationPPM));\n        return lte512(min, mid) && lte512(mid, max);\n    }\n\n    /**\n     * @dev returns an `Sint256` positive representation of an unsigned integer\n     */\n    function toPos256(uint256 n) internal pure returns (Sint256 memory) {\n        return Sint256({ value: n, isNeg: false });\n    }\n\n    /**\n     * @dev returns an `Sint256` negative representation of an unsigned integer\n     */\n    function toNeg256(uint256 n) internal pure returns (Sint256 memory) {\n        return Sint256({ value: n, isNeg: true });\n    }\n\n    /**\n     * @dev returns the largest integer smaller than or equal to `x * y / z`\n     */\n    function mulDivF(\n        uint256 x,\n        uint256 y,\n        uint256 z\n    ) internal pure returns (uint256) {\n        Uint512 memory xy = mul512(x, y);\n\n        // if `x * y < 2 ^ 256`\n        if (xy.hi == 0) {\n            return xy.lo / z;\n        }\n\n        // assert `x * y / z < 2 ^ 256`\n        if (xy.hi >= z) {\n            revert Overflow();\n        }\n\n        uint256 m = _mulMod(x, y, z); // `m = x * y % z`\n        Uint512 memory n = _sub512(xy, m); // `n = x * y - m` hence `n / z = floor(x * y / z)`\n\n        // if `n < 2 ^ 256`\n        if (n.hi == 0) {\n            return n.lo / z;\n        }\n\n        uint256 p = _unsafeSub(0, z) & z; // `p` is the largest power of 2 which `z` is divisible by\n        uint256 q = _div512(n, p); // `n` is divisible by `p` because `n` is divisible by `z` and `z` is divisible by `p`\n        uint256 r = _inv256(z / p); // `z / p = 1 mod 2` hence `inverse(z / p) = 1 mod 2 ^ 256`\n        return _unsafeMul(q, r); // `q * r = (n / p) * inverse(z / p) = n / z`\n    }\n\n    /**\n     * @dev returns the smallest integer larger than or equal to `x * y / z`\n     */\n    function mulDivC(\n        uint256 x,\n        uint256 y,\n        uint256 z\n    ) internal pure returns (uint256) {\n        uint256 w = mulDivF(x, y, z);\n        if (_mulMod(x, y, z) > 0) {\n            if (w >= type(uint256).max) {\n                revert Overflow();\n            }\n\n            return w + 1;\n        }\n        return w;\n    }\n\n    /**\n     * @dev returns the maximum of `n1 - n2` and 0\n     */\n    function subMax0(uint256 n1, uint256 n2) internal pure returns (uint256) {\n        return n1 > n2 ? n1 - n2 : 0;\n    }\n\n    /**\n     * @dev returns the value of `x > y`\n     */\n    function gt512(Uint512 memory x, Uint512 memory y) internal pure returns (bool) {\n        return x.hi > y.hi || (x.hi == y.hi && x.lo > y.lo);\n    }\n\n    /**\n     * @dev returns the value of `x < y`\n     */\n    function lt512(Uint512 memory x, Uint512 memory y) internal pure returns (bool) {\n        return x.hi < y.hi || (x.hi == y.hi && x.lo < y.lo);\n    }\n\n    /**\n     * @dev returns the value of `x >= y`\n     */\n    function gte512(Uint512 memory x, Uint512 memory y) internal pure returns (bool) {\n        return !lt512(x, y);\n    }\n\n    /**\n     * @dev returns the value of `x <= y`\n     */\n    function lte512(Uint512 memory x, Uint512 memory y) internal pure returns (bool) {\n        return !gt512(x, y);\n    }\n\n    /**\n     * @dev returns the value of `x * y`\n     */\n    function mul512(uint256 x, uint256 y) internal pure returns (Uint512 memory) {\n        uint256 p = _mulModMax(x, y);\n        uint256 q = _unsafeMul(x, y);\n        if (p >= q) {\n            return Uint512({ hi: p - q, lo: q });\n        }\n        return Uint512({ hi: _unsafeSub(p, q) - 1, lo: q });\n    }\n\n    /**\n     * @dev returns the value of `x - y`, given that `x >= y`\n     */\n    function _sub512(Uint512 memory x, uint256 y) private pure returns (Uint512 memory) {\n        if (x.lo >= y) {\n            return Uint512({ hi: x.hi, lo: x.lo - y });\n        }\n        return Uint512({ hi: x.hi - 1, lo: _unsafeSub(x.lo, y) });\n    }\n\n    /**\n     * @dev returns the value of `x / pow2n`, given that `x` is divisible by `pow2n`\n     */\n    function _div512(Uint512 memory x, uint256 pow2n) private pure returns (uint256) {\n        uint256 pow2nInv = _unsafeAdd(_unsafeSub(0, pow2n) / pow2n, 1); // `1 << (256 - n)`\n        return _unsafeMul(x.hi, pow2nInv) | (x.lo / pow2n); // `(x.hi << (256 - n)) | (x.lo >> n)`\n    }\n\n    /**\n     * @dev returns the inverse of `d` modulo `2 ^ 256`, given that `d` is congruent to `1` modulo `2`\n     */\n    function _inv256(uint256 d) private pure returns (uint256) {\n        // approximate the root of `f(x) = 1 / x - d` using the newton–raphson convergence method\n        uint256 x = 1;\n        for (uint256 i = 0; i < 8; i++) {\n            x = _unsafeMul(x, _unsafeSub(2, _unsafeMul(x, d))); // `x = x * (2 - x * d) mod 2 ^ 256`\n        }\n        return x;\n    }\n\n    /**\n     * @dev returns `(x + y) % 2 ^ 256`\n     */\n    function _unsafeAdd(uint256 x, uint256 y) private pure returns (uint256) {\n        unchecked {\n            return x + y;\n        }\n    }\n\n    /**\n     * @dev returns `(x - y) % 2 ^ 256`\n     */\n    function _unsafeSub(uint256 x, uint256 y) private pure returns (uint256) {\n        unchecked {\n            return x - y;\n        }\n    }\n\n    /**\n     * @dev returns `(x * y) % 2 ^ 256`\n     */\n    function _unsafeMul(uint256 x, uint256 y) private pure returns (uint256) {\n        unchecked {\n            return x * y;\n        }\n    }\n\n    /**\n     * @dev returns `x * y % (2 ^ 256 - 1)`\n     */\n    function _mulModMax(uint256 x, uint256 y) private pure returns (uint256) {\n        return mulmod(x, y, type(uint256).max);\n    }\n\n    /**\n     * @dev returns `x * y % z`\n     */\n    function _mulMod(\n        uint256 x,\n        uint256 y,\n        uint256 z\n    ) private pure returns (uint256) {\n        return mulmod(x, y, z);\n    }\n}"
    }
  ]
}