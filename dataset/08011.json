{
  "Title": "[M-01] Oracle is tracked per token instead of per pair, leading to surprise results",
  "Content": "\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/VaultFactory.sol#L121>\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/VaultFactory.sol#L221-L223>\n\n### Impact\n\nOracles are tracked by individual token, instead of by pair. Because for some tokens (ie BTC) it is unclear which implementation is the canonical one to compare others to, this can result in a situation where different pairs (ie ibBTC-wBTC and ibBC-renBTC) using the same oracle, which will be incorrect for one of them.\n\n### Proof of Concept\n\nThe protocol assumes that there is a canonical asset to compare pegged assets to, so oracles are tracked only by the pegged asset. However, for some assets (like BTC), there is no clear canonical asset, and the result is that tracking `tokenToOracle` is not sufficient.\n\nWhen there is a conflict in `tokenToOracle`, the protocol responds by skipping the assignment and keeping the old value:\n\n    if (tokenToOracle[_token] == address(0)) {\n        tokenToOracle[_token] = _oracle;\n    }\n\nThe result of this is that the protocol may define a new pair with a new oracle, and have it silently skip it and use a non-matching oracle. As an example:\n\n*   The admins start with an implementation of ibBTC-wBTC, deploying the oracle\n*   This is set as `tokenToOracle[ibBTC]`\n*   Later, the admins create a new pair for ibBTC-renBTC, deploying a new oracle\n*   The protocol silently skips this assignment and uses the ibBTC-wBTC oracle\n\nThis can produce incorrect results, for example if wBTC appreciates relative to the other two, or if both ibBTC and renBTC depeg.\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nChange `tokenToOracle` to represent the pair of tokens, either by creating a `Pair` struct as the key, or by nesting a mapping inside of another mapping.\n\n**[MiguelBit (Y2K Finance) disputed](https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/100)** \n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-09-y2k-finance-contest",
  "Code": [
    {
      "filename": "src/VaultFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {Vault} from \"./Vault.sol\";\n\ninterface IController {\n    function getVaultFactory() external view returns (address);\n}\n\ncontract VaultFactory {\n    // solhint-disable var-name-mixedcase\n    address public immutable Admin;\n    address public immutable WETH;\n    // solhint-enable var-name-mixedcase\n    address public treasury;\n    address public controller;\n    uint256 public marketIndex;\n\n    struct MarketVault{\n        uint256 index;\n        uint256 epochBegin;\n        uint256 epochEnd;\n        Vault hedge;\n        Vault risk;\n        uint256 withdrawalFee;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error MarketDoesNotExist(uint256 marketIndex);\n    error AddressNotAdmin(address addr);\n    error AddressZero();\n    error AddressNotController();\n    error AddressFactoryNotInController();\n    error ControllerNotSet();\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    \n    /** @notice Market is created when event is emitted\n      * @param mIndex Current market index\n      * @param hedge Hedge vault address\n      * @param risk Risk vault address\n      * @param token Token address\n      * @param name Market name\n      */ \n    event MarketCreated(\n        uint256 indexed mIndex,\n        address hedge,\n        address risk,\n        address token,\n        string name,\n        int256 strikePrice\n    );\n\n    /** @notice Epoch is created when event is emitted\n      * @param marketEpochId Current market epoch id\n      * @param mIndex Current market index\n      * @param startEpoch Epoch start time\n      * @param endEpoch Epoch end time\n      * @param hedge Hedge vault address\n      * @param risk Risk vault address\n      * @param token Token address\n      * @param name Market name\n      * @param strikePrice Vault strike price\n      */\n    event EpochCreated(\n        bytes32 indexed marketEpochId,\n        uint256 indexed mIndex,\n        uint256 startEpoch,\n        uint256 endEpoch,\n        address hedge,\n        address risk,\n        address token,\n        string name,\n        int256 strikePrice,\n        uint256 withdrawalFee\n    );\n\n    /** @notice Controller is set when event is emitted\n      * @param newController Address for new controller\n      */ \n    event controllerSet(address indexed newController);\n\n    /** @notice Treasury is changed when event is emitted\n      * @param _treasury Treasury address\n      * @param _marketIndex Target market index\n      */ \n    event changedTreasury(address _treasury, uint256 indexed _marketIndex);\n\n    /** @notice Vault fee is changed when event is emitted\n      * @param _marketIndex Target market index\n      * @param _feeRate Target fee rate\n      */ \n    event changedVaultFee(uint256 indexed _marketIndex, uint256 _feeRate);\n\n    /** @notice Vault time window is changed when event is emitted\n      * @param _marketIndex Target market index\n      * @param _timeWindow Target time window\n      */ \n    event changedTimeWindow(uint256 indexed _marketIndex, uint256 _timeWindow);\n    \n    /** @notice Controller is changed when event is emitted\n      * @param _marketIndex Target market index\n      * @param controller Target controller address\n      */ \n    event changedController(\n        uint256 indexed _marketIndex,\n        address indexed controller\n    );\n    event changedOracle(address indexed _token, address _oracle);\n\n    /*//////////////////////////////////////////////////////////////\n                                MAPPINGS\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address[]) public indexVaults; //[0] hedge and [1] risk vault\n    mapping(uint256 => uint256[]) public indexEpochs; //all epochs in the market\n    mapping(address => address) public tokenToOracle; //token address to respective oracle smart contract address\n\n    /*//////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Only admin addresses can call functions that use this modifier\n      */\n    modifier onlyAdmin() {\n        if(msg.sender != Admin)\n            revert AddressNotAdmin(msg.sender);\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Contract constructor\n      * @param _treasury Treasury address\n      * @param _weth Wrapped Ether token address\n      * @param _admin Admin address\n      */ \n    constructor(\n        address _treasury,\n        address _weth,\n        address _admin\n    ) {\n        if(_admin == address(0))\n            revert AddressZero();\n        if(_weth == address(0))\n            revert AddressZero();\n\n        if(_treasury == address(0))\n            revert AddressZero();\n\n        Admin = _admin;\n        WETH = _weth;\n        marketIndex = 0;\n        treasury = _treasury;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n    @notice Function to create two new vaults, hedge and risk, with the respective params, and storing the oracle for the token provided\n    @param _withdrawalFee uint256 of the fee value, multiply your % value by 10, Example: if you want fee of 0.5% , insert 5\n    @param _token Address of the oracle to lookup the price in chainlink oracles\n    @param _strikePrice uint256 representing the price to trigger the depeg event, needs to be 18 decimals\n    @param  epochBegin uint256 in UNIX timestamp, representing the begin date of the epoch. Example: Epoch begins in 31/May/2022 at 00h 00min 00sec: 1654038000\n    @param  epochEnd uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1656630000\n    @param  _oracle Address representing the smart contract to lookup the price of the given _token param\n    @return insr    Address of the deployed hedge vault\n    @return rsk     Address of the deployed risk vault\n     */\n    function createNewMarket(\n        uint256 _withdrawalFee,\n        address _token,\n        int256 _strikePrice,\n        uint256 epochBegin,\n        uint256 epochEnd,\n        address _oracle,\n        string memory _name\n    ) public onlyAdmin returns (address insr, address rsk) {\n        if(\n            IController(controller).getVaultFactory() != address(this)\n            )\n            revert AddressFactoryNotInController();\n\n        if(controller == address(0))\n            revert ControllerNotSet();\n\n        marketIndex += 1;\n\n        //y2kUSDC_99*RISK or y2kUSDC_99*HEDGE\n\n        Vault hedge = new Vault(\n            WETH,\n            string(abi.encodePacked(_name,\"HEDGE\")),\n            \"hY2K\",\n            treasury,\n            _token,\n            _strikePrice,\n            controller\n        );\n\n        Vault risk = new Vault(\n            WETH,\n            string(abi.encodePacked(_name,\"RISK\")),\n            \"rY2K\",\n            treasury,\n            _token,\n            _strikePrice,\n            controller\n        );\n\n        indexVaults[marketIndex] = [address(hedge), address(risk)];\n\n        if (tokenToOracle[_token] == address(0)) {\n            tokenToOracle[_token] = _oracle;\n        }\n\n        emit MarketCreated(\n            marketIndex,\n            address(hedge),\n            address(risk),\n            _token,\n            _name,\n            _strikePrice\n        );\n\n        MarketVault memory marketVault = MarketVault(marketIndex, epochBegin, epochEnd, hedge, risk, _withdrawalFee);\n\n        _createEpoch(marketVault);\n\n        return (address(hedge), address(risk));\n    }\n\n    /**    \n    @notice Function to deploy hedge assets for given epochs, after the creation of this vault, where the Index is the date of the end of epoch\n    @param  index uint256 of the market index to create more assets in\n    @param  epochBegin uint256 in UNIX timestamp, representing the begin date of the epoch. Example: Epoch begins in 31/May/2022 at 00h 00min 00sec: 1654038000\n    @param  epochEnd uint256 in UNIX timestamp, representing the end date of the epoch and also the ID for the minting functions. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1656630000\n    @param _withdrawalFee uint256 of the fee value, multiply your % value by 10, Example: if you want fee of 0.5% , insert 5\n     */\n    function deployMoreAssets(\n        uint256 index,\n        uint256 epochBegin,\n        uint256 epochEnd,\n        uint256 _withdrawalFee\n    ) public onlyAdmin {\n        if(controller == address(0))\n            revert ControllerNotSet();\n\n        if (index > marketIndex) {\n            revert MarketDoesNotExist(index);\n        }\n        address hedge = indexVaults[index][0];\n        address risk = indexVaults[index][1];\n\n        MarketVault memory marketVault = MarketVault(index, epochBegin, epochEnd, Vault(hedge), Vault(risk), _withdrawalFee);\n\n        _createEpoch(marketVault);\n    }\n\n    function _createEpoch(\n        MarketVault memory _marketVault\n    ) internal {\n        \n        _marketVault.hedge.createAssets(_marketVault.epochBegin, _marketVault.epochEnd, _marketVault.withdrawalFee);\n        _marketVault.risk.createAssets(_marketVault.epochBegin, _marketVault.epochEnd, _marketVault.withdrawalFee);\n\n        indexEpochs[_marketVault.index].push(_marketVault.epochEnd);\n\n        emit EpochCreated(\n            keccak256(abi.encodePacked(_marketVault.index, _marketVault.epochBegin, _marketVault.epochEnd)),\n            _marketVault.index,\n            _marketVault.epochBegin,\n            _marketVault.epochEnd,\n            address(_marketVault.hedge),\n            address(_marketVault.risk),\n            _marketVault.hedge.tokenInsured(),\n            _marketVault.hedge.name(),\n            _marketVault.hedge.strikePrice(),\n            _marketVault.withdrawalFee\n        );\n    }\n\n    /**\n    @notice Admin function, sets the controller address\n    @param  _controller Address of the controller smart contract\n     */\n    function setController(address _controller) public onlyAdmin {\n        if(_controller == address(0))\n            revert AddressZero();\n        controller = _controller;\n\n        emit controllerSet(_controller);\n    }\n\n    /**\n    @notice Admin function, changes the assigned treasury address\n    @param _treasury Treasury address\n    @param  _marketIndex Target market index\n     */\n    function changeTreasury(address _treasury, uint256 _marketIndex)\n        public\n        onlyAdmin\n    {\n        treasury = _treasury;\n        address[] memory vaults = indexVaults[_marketIndex];\n        Vault insr = Vault(vaults[0]);\n        Vault risk = Vault(vaults[1]);\n        insr.changeTreasury(_treasury);\n        risk.changeTreasury(_treasury);\n\n        emit changedTreasury(_treasury, _marketIndex);\n    }\n\n    /**\n    @notice Admin function, changes vault time window\n    @param _marketIndex Target market index\n    @param  _timewindow New time window\n     */\n    function changeTimewindow(uint256 _marketIndex, uint256 _timewindow)\n        public\n        onlyAdmin\n    {\n        address[] memory vaults = indexVaults[_marketIndex];\n        Vault insr = Vault(vaults[0]);\n        Vault risk = Vault(vaults[1]);\n        insr.changeTimewindow(_timewindow);\n        risk.changeTimewindow(_timewindow);\n\n        emit changedTimeWindow(_marketIndex, _timewindow);\n    }\n\n    /**\n    @notice Admin function, changes controller address\n    @param _marketIndex Target market index\n    @param  _controller Address of the controller smart contract\n     */\n    function changeController(uint256 _marketIndex, address _controller)\n        public\n        onlyAdmin\n    {\n        if(_controller == address(0))\n            revert AddressZero();\n\n        address[] memory vaults = indexVaults[_marketIndex];\n        Vault insr = Vault(vaults[0]);\n        Vault risk = Vault(vaults[1]);\n        insr.changeController(_controller);\n        risk.changeController(_controller);\n\n        emit changedController(_marketIndex, _controller);\n    }\n\n    /**\n    @notice Admin function, changes oracle address for a given token\n    @param _token Target token address\n    @param  _oracle Oracle address\n     */\n    function changeOracle(address _token, address _oracle) public onlyAdmin {\n        if(_oracle == address(0))\n            revert AddressZero();\n        if(_token == address(0))\n            revert AddressZero();\n            \n        tokenToOracle[_token] = _oracle;\n        emit changedOracle(_token, _oracle);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                GETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n    @notice Function the retrieve the addresses of the hedge and risk vaults, in an array, in the respective order\n    @param index uint256 of the market index which to the vaults are associated to\n    @return vaults Address array of two vaults addresses, [0] being the hedge vault, [1] being the risk vault\n     */\n    function getVaults(uint256 index)\n        public\n        view\n        returns (address[] memory vaults)\n    {\n        return indexVaults[index];\n    }\n}"
    },
    {
      "filename": "src/VaultFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {Vault} from \"./Vault.sol\";\n\ninterface IController {\n    function getVaultFactory() external view returns (address);\n}\n\ncontract VaultFactory {\n    // solhint-disable var-name-mixedcase\n    address public immutable Admin;\n    address public immutable WETH;\n    // solhint-enable var-name-mixedcase\n    address public treasury;\n    address public controller;\n    uint256 public marketIndex;\n\n    struct MarketVault{\n        uint256 index;\n        uint256 epochBegin;\n        uint256 epochEnd;\n        Vault hedge;\n        Vault risk;\n        uint256 withdrawalFee;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error MarketDoesNotExist(uint256 marketIndex);\n    error AddressNotAdmin(address addr);\n    error AddressZero();\n    error AddressNotController();\n    error AddressFactoryNotInController();\n    error ControllerNotSet();\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    \n    /** @notice Market is created when event is emitted\n      * @param mIndex Current market index\n      * @param hedge Hedge vault address\n      * @param risk Risk vault address\n      * @param token Token address\n      * @param name Market name\n      */ \n    event MarketCreated(\n        uint256 indexed mIndex,\n        address hedge,\n        address risk,\n        address token,\n        string name,\n        int256 strikePrice\n    );\n\n    /** @notice Epoch is created when event is emitted\n      * @param marketEpochId Current market epoch id\n      * @param mIndex Current market index\n      * @param startEpoch Epoch start time\n      * @param endEpoch Epoch end time\n      * @param hedge Hedge vault address\n      * @param risk Risk vault address\n      * @param token Token address\n      * @param name Market name\n      * @param strikePrice Vault strike price\n      */\n    event EpochCreated(\n        bytes32 indexed marketEpochId,\n        uint256 indexed mIndex,\n        uint256 startEpoch,\n        uint256 endEpoch,\n        address hedge,\n        address risk,\n        address token,\n        string name,\n        int256 strikePrice,\n        uint256 withdrawalFee\n    );\n\n    /** @notice Controller is set when event is emitted\n      * @param newController Address for new controller\n      */ \n    event controllerSet(address indexed newController);\n\n    /** @notice Treasury is changed when event is emitted\n      * @param _treasury Treasury address\n      * @param _marketIndex Target market index\n      */ \n    event changedTreasury(address _treasury, uint256 indexed _marketIndex);\n\n    /** @notice Vault fee is changed when event is emitted\n      * @param _marketIndex Target market index\n      * @param _feeRate Target fee rate\n      */ \n    event changedVaultFee(uint256 indexed _marketIndex, uint256 _feeRate);\n\n    /** @notice Vault time window is changed when event is emitted\n      * @param _marketIndex Target market index\n      * @param _timeWindow Target time window\n      */ \n    event changedTimeWindow(uint256 indexed _marketIndex, uint256 _timeWindow);\n    \n    /** @notice Controller is changed when event is emitted\n      * @param _marketIndex Target market index\n      * @param controller Target controller address\n      */ \n    event changedController(\n        uint256 indexed _marketIndex,\n        address indexed controller\n    );\n    event changedOracle(address indexed _token, address _oracle);\n\n    /*//////////////////////////////////////////////////////////////\n                                MAPPINGS\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address[]) public indexVaults; //[0] hedge and [1] risk vault\n    mapping(uint256 => uint256[]) public indexEpochs; //all epochs in the market\n    mapping(address => address) public tokenToOracle; //token address to respective oracle smart contract address\n\n    /*//////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Only admin addresses can call functions that use this modifier\n      */\n    modifier onlyAdmin() {\n        if(msg.sender != Admin)\n            revert AddressNotAdmin(msg.sender);\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Contract constructor\n      * @param _treasury Treasury address\n      * @param _weth Wrapped Ether token address\n      * @param _admin Admin address\n      */ \n    constructor(\n        address _treasury,\n        address _weth,\n        address _admin\n    ) {\n        if(_admin == address(0))\n            revert AddressZero();\n        if(_weth == address(0))\n            revert AddressZero();\n\n        if(_treasury == address(0))\n            revert AddressZero();\n\n        Admin = _admin;\n        WETH = _weth;\n        marketIndex = 0;\n        treasury = _treasury;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n    @notice Function to create two new vaults, hedge and risk, with the respective params, and storing the oracle for the token provided\n    @param _withdrawalFee uint256 of the fee value, multiply your % value by 10, Example: if you want fee of 0.5% , insert 5\n    @param _token Address of the oracle to lookup the price in chainlink oracles\n    @param _strikePrice uint256 representing the price to trigger the depeg event, needs to be 18 decimals\n    @param  epochBegin uint256 in UNIX timestamp, representing the begin date of the epoch. Example: Epoch begins in 31/May/2022 at 00h 00min 00sec: 1654038000\n    @param  epochEnd uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1656630000\n    @param  _oracle Address representing the smart contract to lookup the price of the given _token param\n    @return insr    Address of the deployed hedge vault\n    @return rsk     Address of the deployed risk vault\n     */\n    function createNewMarket(\n        uint256 _withdrawalFee,\n        address _token,\n        int256 _strikePrice,\n        uint256 epochBegin,\n        uint256 epochEnd,\n        address _oracle,\n        string memory _name\n    ) public onlyAdmin returns (address insr, address rsk) {\n        if(\n            IController(controller).getVaultFactory() != address(this)\n            )\n            revert AddressFactoryNotInController();\n\n        if(controller == address(0))\n            revert ControllerNotSet();\n\n        marketIndex += 1;\n\n        //y2kUSDC_99*RISK or y2kUSDC_99*HEDGE\n\n        Vault hedge = new Vault(\n            WETH,\n            string(abi.encodePacked(_name,\"HEDGE\")),\n            \"hY2K\",\n            treasury,\n            _token,\n            _strikePrice,\n            controller\n        );\n\n        Vault risk = new Vault(\n            WETH,\n            string(abi.encodePacked(_name,\"RISK\")),\n            \"rY2K\",\n            treasury,\n            _token,\n            _strikePrice,\n            controller\n        );\n\n        indexVaults[marketIndex] = [address(hedge), address(risk)];\n\n        if (tokenToOracle[_token] == address(0)) {\n            tokenToOracle[_token] = _oracle;\n        }\n\n        emit MarketCreated(\n            marketIndex,\n            address(hedge),\n            address(risk),\n            _token,\n            _name,\n            _strikePrice\n        );\n\n        MarketVault memory marketVault = MarketVault(marketIndex, epochBegin, epochEnd, hedge, risk, _withdrawalFee);\n\n        _createEpoch(marketVault);\n\n        return (address(hedge), address(risk));\n    }\n\n    /**    \n    @notice Function to deploy hedge assets for given epochs, after the creation of this vault, where the Index is the date of the end of epoch\n    @param  index uint256 of the market index to create more assets in\n    @param  epochBegin uint256 in UNIX timestamp, representing the begin date of the epoch. Example: Epoch begins in 31/May/2022 at 00h 00min 00sec: 1654038000\n    @param  epochEnd uint256 in UNIX timestamp, representing the end date of the epoch and also the ID for the minting functions. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1656630000\n    @param _withdrawalFee uint256 of the fee value, multiply your % value by 10, Example: if you want fee of 0.5% , insert 5\n     */\n    function deployMoreAssets(\n        uint256 index,\n        uint256 epochBegin,\n        uint256 epochEnd,\n        uint256 _withdrawalFee\n    ) public onlyAdmin {\n        if(controller == address(0))\n            revert ControllerNotSet();\n\n        if (index > marketIndex) {\n            revert MarketDoesNotExist(index);\n        }\n        address hedge = indexVaults[index][0];\n        address risk = indexVaults[index][1];\n\n        MarketVault memory marketVault = MarketVault(index, epochBegin, epochEnd, Vault(hedge), Vault(risk), _withdrawalFee);\n\n        _createEpoch(marketVault);\n    }\n\n    function _createEpoch(\n        MarketVault memory _marketVault\n    ) internal {\n        \n        _marketVault.hedge.createAssets(_marketVault.epochBegin, _marketVault.epochEnd, _marketVault.withdrawalFee);\n        _marketVault.risk.createAssets(_marketVault.epochBegin, _marketVault.epochEnd, _marketVault.withdrawalFee);\n\n        indexEpochs[_marketVault.index].push(_marketVault.epochEnd);\n\n        emit EpochCreated(\n            keccak256(abi.encodePacked(_marketVault.index, _marketVault.epochBegin, _marketVault.epochEnd)),\n            _marketVault.index,\n            _marketVault.epochBegin,\n            _marketVault.epochEnd,\n            address(_marketVault.hedge),\n            address(_marketVault.risk),\n            _marketVault.hedge.tokenInsured(),\n            _marketVault.hedge.name(),\n            _marketVault.hedge.strikePrice(),\n            _marketVault.withdrawalFee\n        );\n    }\n\n    /**\n    @notice Admin function, sets the controller address\n    @param  _controller Address of the controller smart contract\n     */\n    function setController(address _controller) public onlyAdmin {\n        if(_controller == address(0))\n            revert AddressZero();\n        controller = _controller;\n\n        emit controllerSet(_controller);\n    }\n\n    /**\n    @notice Admin function, changes the assigned treasury address\n    @param _treasury Treasury address\n    @param  _marketIndex Target market index\n     */\n    function changeTreasury(address _treasury, uint256 _marketIndex)\n        public\n        onlyAdmin\n    {\n        treasury = _treasury;\n        address[] memory vaults = indexVaults[_marketIndex];\n        Vault insr = Vault(vaults[0]);\n        Vault risk = Vault(vaults[1]);\n        insr.changeTreasury(_treasury);\n        risk.changeTreasury(_treasury);\n\n        emit changedTreasury(_treasury, _marketIndex);\n    }\n\n    /**\n    @notice Admin function, changes vault time window\n    @param _marketIndex Target market index\n    @param  _timewindow New time window\n     */\n    function changeTimewindow(uint256 _marketIndex, uint256 _timewindow)\n        public\n        onlyAdmin\n    {\n        address[] memory vaults = indexVaults[_marketIndex];\n        Vault insr = Vault(vaults[0]);\n        Vault risk = Vault(vaults[1]);\n        insr.changeTimewindow(_timewindow);\n        risk.changeTimewindow(_timewindow);\n\n        emit changedTimeWindow(_marketIndex, _timewindow);\n    }\n\n    /**\n    @notice Admin function, changes controller address\n    @param _marketIndex Target market index\n    @param  _controller Address of the controller smart contract\n     */\n    function changeController(uint256 _marketIndex, address _controller)\n        public\n        onlyAdmin\n    {\n        if(_controller == address(0))\n            revert AddressZero();\n\n        address[] memory vaults = indexVaults[_marketIndex];\n        Vault insr = Vault(vaults[0]);\n        Vault risk = Vault(vaults[1]);\n        insr.changeController(_controller);\n        risk.changeController(_controller);\n\n        emit changedController(_marketIndex, _controller);\n    }\n\n    /**\n    @notice Admin function, changes oracle address for a given token\n    @param _token Target token address\n    @param  _oracle Oracle address\n     */\n    function changeOracle(address _token, address _oracle) public onlyAdmin {\n        if(_oracle == address(0))\n            revert AddressZero();\n        if(_token == address(0))\n            revert AddressZero();\n            \n        tokenToOracle[_token] = _oracle;\n        emit changedOracle(_token, _oracle);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                GETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n    @notice Function the retrieve the addresses of the hedge and risk vaults, in an array, in the respective order\n    @param index uint256 of the market index which to the vaults are associated to\n    @return vaults Address array of two vaults addresses, [0] being the hedge vault, [1] being the risk vault\n     */\n    function getVaults(uint256 index)\n        public\n        view\n        returns (address[] memory vaults)\n    {\n        return indexVaults[index];\n    }\n}"
    }
  ]
}