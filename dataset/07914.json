{
  "Title": "[M-09] It is possible that, after swapping, extra input token amount is transferred from user to pool but pool does not give user output token amount that corresponds to the extra input token amount",
  "Content": "\nWhen calling the `swap` function below, the following `_swapCallback` function is further called for calling the `algebraSwapCallback` function in the callee contract, which is `msg.sender`; such contract could be implemented by a third party especially for non-technical users. There is no guarantee that such contract will not send more input token amount than required to the pool. When this happens, the output token amount corresponding to the extra input token amount will not be transferred from the pool to the recipient after the swap. As a result, the user sends extra input token amount to the pool but does not receive any output token amount corresponding to the extra input token amount. Disputes between the user and protocol can occur because of this.\n\n[AlgebraPool.sol#L580-L586](https://github.com/code-423n4/2022-09-quickswap/blob/main/src/core/contracts/AlgebraPool.sol#L580-L586)\n\n```solidity\n  function _swapCallback(\n    int256 amount0,\n    int256 amount1,\n    bytes calldata data\n  ) private {\n    IAlgebraSwapCallback(msg.sender).algebraSwapCallback(amount0, amount1, data);\n  }\n```\n\n[AlgebraPool.sol#L589-L623](https://github.com/code-423n4/2022-09-quickswap/blob/main/src/core/contracts/AlgebraPool.sol#L589-L623)\n\n```solidity\n  function swap(\n    address recipient,\n    bool zeroToOne,\n    int256 amountRequired,\n    uint160 limitSqrtPrice,\n    bytes calldata data\n  ) external override returns (int256 amount0, int256 amount1) {\n    uint160 currentPrice;\n    int24 currentTick;\n    uint128 currentLiquidity;\n    uint256 communityFee;\n    // function _calculateSwapAndLock locks globalState.unlocked and does not release\n    (amount0, amount1, currentPrice, currentTick, currentLiquidity, communityFee) = _calculateSwapAndLock(zeroToOne, amountRequired, limitSqrtPrice);\n\n    if (zeroToOne) {\n      if (amount1 < 0) TransferHelper.safeTransfer(token1, recipient, uint256(-amount1)); // transfer to recipient\n\n      uint256 balance0Before = balanceToken0();\n      _swapCallback(amount0, amount1, data); // callback to get tokens from the caller\n      require(balance0Before.add(uint256(amount0)) <= balanceToken0(), 'IIA');\n    } else {\n      if (amount0 < 0) TransferHelper.safeTransfer(token0, recipient, uint256(-amount0)); // transfer to recipient\n\n      uint256 balance1Before = balanceToken1();\n      _swapCallback(amount0, amount1, data); // callback to get tokens from the caller\n      require(balance1Before.add(uint256(amount1)) <= balanceToken1(), 'IIA');\n    }\n\n    if (communityFee > 0) {\n      _payCommunityFee(zeroToOne ? token0 : token1, communityFee);\n    }\n\n    emit Swap(msg.sender, recipient, amount0, amount1, currentPrice, currentLiquidity, currentTick);\n    globalState.unlocked = true; // release after lock in _calculateSwapAndLock\n  }\n```\n\n### Proof of Concept\n\nFirst, in `src\\core\\contracts\\test\\`, please add the following test callee contract.\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.7.6;\n\nimport '../interfaces/IERC20Minimal.sol';\nimport '../libraries/SafeCast.sol';\nimport '../interfaces/callback/IAlgebraMintCallback.sol';\nimport '../interfaces/callback/IAlgebraSwapCallback.sol';\nimport '../interfaces/IAlgebraPool.sol';\n\ncontract TestCalleeForSendingExtraTokenAmount is IAlgebraMintCallback, IAlgebraSwapCallback {\n  using SafeCast for uint256;\n\n  function swapExact0For1(\n    address pool,\n    uint256 amount0In,\n    address recipient,\n    uint160 limitSqrtPrice\n  ) external {\n    IAlgebraPool(pool).swap(recipient, true, amount0In.toInt256(), limitSqrtPrice, abi.encode(msg.sender));\n  }\n\n  event SwapCallback(int256 amount0Delta, int256 amount1Delta);\n\n  function algebraSwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external override {\n    address sender = abi.decode(data, (address));\n\n    emit SwapCallback(amount0Delta, amount1Delta);\n\n    // simulate a situation where extra token amount is sent to the pool\n    if (amount0Delta > 0) {\n      IERC20Minimal(IAlgebraPool(msg.sender).token0()).transferFrom(sender, msg.sender, uint256(amount0Delta) + 1e9);\n    } else if (amount1Delta > 0) {\n      IERC20Minimal(IAlgebraPool(msg.sender).token1()).transferFrom(sender, msg.sender, uint256(amount1Delta) + 1e9);\n    } else {\n      assert(amount0Delta == 0 && amount1Delta == 0);\n    }\n  }\n\n  event MintResult(uint256 amount0Owed, uint256 amount1Owed, uint256 resultLiquidity);\n\n  function mint(\n    address pool,\n    address recipient,\n    int24 bottomTick,\n    int24 topTick,\n    uint128 amount\n  )\n    external\n    returns (\n      uint256 amount0Owed,\n      uint256 amount1Owed,\n      uint256 resultLiquidity\n    )\n  {\n    (amount0Owed, amount1Owed, resultLiquidity) = IAlgebraPool(pool).mint(msg.sender, recipient, bottomTick, topTick, amount, abi.encode(msg.sender));\n    emit MintResult(amount0Owed, amount1Owed, resultLiquidity);\n  }\n\n  event MintCallback(uint256 amount0Owed, uint256 amount1Owed);\n\n  function algebraMintCallback(\n    uint256 amount0Owed,\n    uint256 amount1Owed,\n    bytes calldata data\n  ) external override {\n    address sender = abi.decode(data, (address));\n\n    if (amount0Owed > 0) IERC20Minimal(IAlgebraPool(msg.sender).token0()).transferFrom(sender, msg.sender, amount0Owed);\n    if (amount1Owed > 0) IERC20Minimal(IAlgebraPool(msg.sender).token1()).transferFrom(sender, msg.sender, amount1Owed);\n\n    emit MintCallback(amount0Owed, amount1Owed);\n  }\n}\n```\n\nThen, please add the following test in the `AlgebraPool` `describe` block in `src\\core\\test\\AlgebraPool.spec.ts`. This test will pass to demonstrate the described scenario.\n\n```typescript\ndescribe('POC', () => {\n    it('It is possible that, after swapping, extra input token amount is transferred from user to pool but pool does not give user output token amount that corresponds to the extra input token amount', async () => {\n        /** set up contracts */\n        const PoolDeployerFactory = await ethers.getContractFactory('AlgebraPoolDeployer');\n        const poolDeployer = await PoolDeployerFactory.deploy();\n  \n        const FactoryFactory = await ethers.getContractFactory('AlgebraFactory');\n        const factory = await FactoryFactory.deploy(poolDeployer.address, vaultAddress);\n  \n        const TokenFactory = await ethers.getContractFactory('TestERC20');\n        const token0 = await TokenFactory.deploy(BigNumber.from(2).pow(255));\n        const token1 = await TokenFactory.deploy(BigNumber.from(2).pow(255));\n      \n        const calleeContractFactory = await ethers.getContractFactory('TestCalleeForSendingExtraTokenAmount');\n        const swapTargetCallee = await calleeContractFactory.deploy();\n  \n        const MockTimeAlgebraPoolDeployerFactory = await ethers.getContractFactory('MockTimeAlgebraPoolDeployer')\n        const mockTimePoolDeployer = await MockTimeAlgebraPoolDeployerFactory.deploy();\n        const tx = await mockTimePoolDeployer.deployMock(\n          factory.address,\n          token0.address,\n          token1.address\n        )\n        const receipt = await tx.wait()\n        const poolAddress = receipt.events?.[1].args?.pool;\n  \n        const MockTimeAlgebraPoolFactory = await ethers.getContractFactory('MockTimeAlgebraPool');\n        const pool = MockTimeAlgebraPoolFactory.attach(poolAddress);\n  \n        await pool.initialize(encodePriceSqrt(1, 1));\n  \n        await token0.approve(swapTargetCallee.address, constants.MaxUint256);\n        await token1.approve(swapTargetCallee.address, constants.MaxUint256);\n        await swapTargetCallee.mint(pool.address, wallet.address, minTick, maxTick, expandTo18Decimals(1));\n        /** */\n  \n        // set up user\n        const user = other;\n        await token0.connect(user).mint(user.address, expandTo18Decimals(1));\n        await token0.connect(user).approve(swapTargetCallee.address, constants.MaxUint256);\n  \n        const token0BalancePoolBefore = await token0.balanceOf(pool.address);\n        const token0BalanceUserBefore = await token0.balanceOf(user.address);\n  \n        const token1BalancePoolBefore = await token1.balanceOf(pool.address);\n        const token1BalanceUserBefore = await token1.balanceOf(user.address);\n  \n        // amountIn and amountOut are the expected token amounts to be in and out after the upcoming swap\n        const amountIn = expandTo18Decimals(1).div(1000000000);\n        const amountOut = -999899999;\n  \n        await expect(\n          // the TestCalleeForSendingExtraTokenAmount contract's algebraSwapCallback function simulates a situation where extra token0 amount is transferred from user to pool\n          swapTargetCallee.connect(user).swapExact0For1(pool.address, amountIn, user.address, MIN_SQRT_RATIO.add(1))\n        ).to.be.emit(swapTargetCallee, 'SwapCallback').withArgs(amountIn, amountOut);\n  \n        // after the swap, pool has received the extra token0 amount that was transferred from user\n        const token0BalancePoolAfter = await token0.balanceOf(pool.address);\n        const token0BalanceUserAfter = await token0.balanceOf(user.address);\n        expect(token0BalancePoolAfter).to.be.gt(token0BalancePoolBefore.add(amountIn));\n        expect(token0BalanceUserAfter).to.be.lt(token0BalanceUserBefore.sub(amountIn));\n  \n        // yet, pool does not give user the token1 amount that corresponds to the extra token0 amount\n        const token1BalancePoolAfter = await token1.balanceOf(pool.address);\n        const token1BalanceUserAfter = await token1.balanceOf(user.address);\n        expect(token1BalancePoolAfter).to.be.eq(token1BalancePoolBefore.add(amountOut));\n        expect(token1BalanceUserAfter).to.be.eq(token1BalanceUserBefore.sub(amountOut));\n    })\n})\n```\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\n[AlgebraPool.sol#L608](https://github.com/code-423n4/2022-09-quickswap/blob/main/src/core/contracts/AlgebraPool.sol#L608) can be updated to the following code.\n\n```solidity\n      require(balance0Before.add(uint256(amount0)) == balanceToken0(), 'IIA');\n```\n\nAlso, [AlgebraPool.sol#L614](https://github.com/code-423n4/2022-09-quickswap/blob/main/src/core/contracts/AlgebraPool.sol#L614) can be updated to the following code.\n\n```solidity\n      require(balance1Before.add(uint256(amount1)) == balanceToken1(), 'IIA');\n```\n\n**[debych (Quickswap & Stellaswap) confirmed](https://github.com/code-423n4/2022-09-quickswap-findings/issues/255)**\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-09-quickswap-findings/issues/255#issuecomment-1270563895):**\n > Going to award as Medium due to sponsor confirming. I think this is more reasonably a QA issue since it assumes a bad integration. Will mark other similar issues as dupe. \n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-09-quickswap",
  "Code": [
    {
      "filename": "src/core/contracts/AlgebraPool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.7.6;\n\nimport './interfaces/IAlgebraPool.sol';\nimport './interfaces/IDataStorageOperator.sol';\nimport './interfaces/IAlgebraVirtualPool.sol';\n\nimport './base/PoolState.sol';\nimport './base/PoolImmutables.sol';\n\nimport './libraries/TokenDeltaMath.sol';\nimport './libraries/PriceMovementMath.sol';\nimport './libraries/TickManager.sol';\nimport './libraries/TickTable.sol';\n\nimport './libraries/LowGasSafeMath.sol';\nimport './libraries/SafeCast.sol';\n\nimport './libraries/FullMath.sol';\nimport './libraries/Constants.sol';\nimport './libraries/TransferHelper.sol';\nimport './libraries/TickMath.sol';\nimport './libraries/LiquidityMath.sol';\n\nimport './interfaces/IAlgebraPoolDeployer.sol';\nimport './interfaces/IAlgebraFactory.sol';\nimport './interfaces/IERC20Minimal.sol';\nimport './interfaces/callback/IAlgebraMintCallback.sol';\nimport './interfaces/callback/IAlgebraSwapCallback.sol';\nimport './interfaces/callback/IAlgebraFlashCallback.sol';\n\ncontract AlgebraPool is PoolState, PoolImmutables, IAlgebraPool {\n  using LowGasSafeMath for uint256;\n  using LowGasSafeMath for int256;\n  using LowGasSafeMath for uint128;\n  using SafeCast for uint256;\n  using SafeCast for int256;\n  using TickTable for mapping(int16 => uint256);\n  using TickManager for mapping(int24 => TickManager.Tick);\n\n  struct Position {\n    uint128 liquidity; // The amount of liquidity concentrated in the range\n    uint32 lastLiquidityAddTimestamp; // Timestamp of last adding of liquidity\n    uint256 innerFeeGrowth0Token; // The last updated fee growth per unit of liquidity\n    uint256 innerFeeGrowth1Token;\n    uint128 fees0; // The amount of token0 owed to a LP\n    uint128 fees1; // The amount of token1 owed to a LP\n  }\n\n  /// @inheritdoc IAlgebraPoolState\n  mapping(bytes32 => Position) public override positions;\n\n  /// @dev Restricts everyone calling a function except factory owner\n  modifier onlyFactoryOwner() {\n    require(msg.sender == IAlgebraFactory(factory).owner());\n    _;\n  }\n\n  modifier onlyValidTicks(int24 bottomTick, int24 topTick) {\n    require(topTick < TickMath.MAX_TICK + 1, 'TUM');\n    require(topTick > bottomTick, 'TLU');\n    require(bottomTick > TickMath.MIN_TICK - 1, 'TLM');\n    _;\n  }\n\n  constructor() PoolImmutables(msg.sender) {\n    globalState.fee = Constants.BASE_FEE;\n  }\n\n  function balanceToken0() private view returns (uint256) {\n    return IERC20Minimal(token0).balanceOf(address(this));\n  }\n\n  function balanceToken1() private view returns (uint256) {\n    return IERC20Minimal(token1).balanceOf(address(this));\n  }\n\n  /// @inheritdoc IAlgebraPoolState\n  function timepoints(uint256 index)\n    external\n    view\n    override\n    returns (\n      bool initialized,\n      uint32 blockTimestamp,\n      int56 tickCumulative,\n      uint160 secondsPerLiquidityCumulative,\n      uint88 volatilityCumulative,\n      int24 averageTick,\n      uint144 volumePerLiquidityCumulative\n    )\n  {\n    return IDataStorageOperator(dataStorageOperator).timepoints(index);\n  }\n\n  struct Cumulatives {\n    int56 tickCumulative;\n    uint160 outerSecondPerLiquidity;\n    uint32 outerSecondsSpent;\n  }\n\n  /// @inheritdoc IAlgebraPoolDerivedState\n  function getInnerCumulatives(int24 bottomTick, int24 topTick)\n    external\n    view\n    override\n    onlyValidTicks(bottomTick, topTick)\n    returns (\n      int56 innerTickCumulative,\n      uint160 innerSecondsSpentPerLiquidity,\n      uint32 innerSecondsSpent\n    )\n  {\n    Cumulatives memory lower;\n    {\n      TickManager.Tick storage _lower = ticks[bottomTick];\n      (lower.tickCumulative, lower.outerSecondPerLiquidity, lower.outerSecondsSpent) = (\n        _lower.outerTickCumulative,\n        _lower.outerSecondsPerLiquidity,\n        _lower.outerSecondsSpent\n      );\n      require(_lower.initialized);\n    }\n\n    Cumulatives memory upper;\n    {\n      TickManager.Tick storage _upper = ticks[topTick];\n      (upper.tickCumulative, upper.outerSecondPerLiquidity, upper.outerSecondsSpent) = (\n        _upper.outerTickCumulative,\n        _upper.outerSecondsPerLiquidity,\n        _upper.outerSecondsSpent\n      );\n\n      require(_upper.initialized);\n    }\n\n    (int24 currentTick, uint16 currentTimepointIndex) = (globalState.tick, globalState.timepointIndex);\n\n    if (currentTick < bottomTick) {\n      return (\n        lower.tickCumulative - upper.tickCumulative,\n        lower.outerSecondPerLiquidity - upper.outerSecondPerLiquidity,\n        lower.outerSecondsSpent - upper.outerSecondsSpent\n      );\n    }\n\n    if (currentTick < topTick) {\n      uint32 globalTime = _blockTimestamp();\n      (int56 globalTickCumulative, uint160 globalSecondsPerLiquidityCumulative, , ) = _getSingleTimepoint(\n        globalTime,\n        0,\n        currentTick,\n        currentTimepointIndex,\n        liquidity\n      );\n      return (\n        globalTickCumulative - lower.tickCumulative - upper.tickCumulative,\n        globalSecondsPerLiquidityCumulative - lower.outerSecondPerLiquidity - upper.outerSecondPerLiquidity,\n        globalTime - lower.outerSecondsSpent - upper.outerSecondsSpent\n      );\n    }\n\n    return (\n      upper.tickCumulative - lower.tickCumulative,\n      upper.outerSecondPerLiquidity - lower.outerSecondPerLiquidity,\n      upper.outerSecondsSpent - lower.outerSecondsSpent\n    );\n  }\n\n  /// @inheritdoc IAlgebraPoolDerivedState\n  function getTimepoints(uint32[] calldata secondsAgos)\n    external\n    view\n    override\n    returns (\n      int56[] memory tickCumulatives,\n      uint160[] memory secondsPerLiquidityCumulatives,\n      uint112[] memory volatilityCumulatives,\n      uint256[] memory volumePerAvgLiquiditys\n    )\n  {\n    return\n      IDataStorageOperator(dataStorageOperator).getTimepoints(\n        _blockTimestamp(),\n        secondsAgos,\n        globalState.tick,\n        globalState.timepointIndex,\n        liquidity\n      );\n  }\n\n  /// @inheritdoc IAlgebraPoolActions\n  function initialize(uint160 initialPrice) external override {\n    require(globalState.price == 0, 'AI');\n    // getTickAtSqrtRatio checks validity of initialPrice inside\n    int24 tick = TickMath.getTickAtSqrtRatio(initialPrice);\n\n    uint32 timestamp = _blockTimestamp();\n    IDataStorageOperator(dataStorageOperator).initialize(timestamp, tick);\n\n    globalState.price = initialPrice;\n    globalState.unlocked = true;\n    globalState.tick = tick;\n\n    emit Initialize(initialPrice, tick);\n  }\n\n  /**\n   * @notice Increases amounts of tokens owed to owner of the position\n   * @param _position The position object to operate with\n   * @param liquidityDelta The amount on which to increase\\decrease the liquidity\n   * @param innerFeeGrowth0Token Total fee token0 fee growth per 1/liquidity between position's lower and upper ticks\n   * @param innerFeeGrowth1Token Total fee token1 fee growth per 1/liquidity between position's lower and upper ticks\n   */\n  function _recalculatePosition(\n    Position storage _position,\n    int128 liquidityDelta,\n    uint256 innerFeeGrowth0Token,\n    uint256 innerFeeGrowth1Token\n  ) internal {\n    (uint128 currentLiquidity, uint32 lastLiquidityAddTimestamp) = (_position.liquidity, _position.lastLiquidityAddTimestamp);\n\n    if (liquidityDelta == 0) {\n      require(currentLiquidity > 0, 'NP'); // Do not recalculate the empty ranges\n    } else {\n      if (liquidityDelta < 0) {\n        uint32 _liquidityCooldown = liquidityCooldown;\n        if (_liquidityCooldown > 0) {\n          require((_blockTimestamp() - lastLiquidityAddTimestamp) >= _liquidityCooldown);\n        }\n      }\n\n      // change position liquidity\n      uint128 liquidityNext = LiquidityMath.addDelta(currentLiquidity, liquidityDelta);\n      (_position.liquidity, _position.lastLiquidityAddTimestamp) = (\n        liquidityNext,\n        liquidityNext > 0 ? (liquidityDelta > 0 ? _blockTimestamp() : lastLiquidityAddTimestamp) : 0\n      );\n    }\n\n    // update the position\n    uint256 _innerFeeGrowth0Token = _position.innerFeeGrowth0Token;\n    uint256 _innerFeeGrowth1Token = _position.innerFeeGrowth1Token;\n    uint128 fees0;\n    if (innerFeeGrowth0Token != _innerFeeGrowth0Token) {\n      _position.innerFeeGrowth0Token = innerFeeGrowth0Token;\n      fees0 = uint128(FullMath.mulDiv(innerFeeGrowth0Token - _innerFeeGrowth0Token, currentLiquidity, Constants.Q128));\n    }\n    uint128 fees1;\n    if (innerFeeGrowth1Token != _innerFeeGrowth1Token) {\n      _position.innerFeeGrowth1Token = innerFeeGrowth1Token;\n      fees1 = uint128(FullMath.mulDiv(innerFeeGrowth1Token - _innerFeeGrowth1Token, currentLiquidity, Constants.Q128));\n    }\n\n    // To avoid overflow owner has to collect fee before it\n    if (fees0 | fees1 != 0) {\n      _position.fees0 += fees0;\n      _position.fees1 += fees1;\n    }\n  }\n\n  struct UpdatePositionCache {\n    uint160 price; // The square root of the current price in Q64.96 format\n    int24 tick; // The current tick\n    uint16 timepointIndex; // The index of the last written timepoint\n  }\n\n  /**\n   * @dev Updates position's ticks and its fees\n   * @return position The Position object to operate with\n   * @return amount0 The amount of token0 the caller needs to send, negative if the pool needs to send it\n   * @return amount1 The amount of token1 the caller needs to send, negative if the pool needs to send it\n   */\n  function _updatePositionTicksAndFees(\n    address owner,\n    int24 bottomTick,\n    int24 topTick,\n    int128 liquidityDelta\n  )\n    private\n    returns (\n      Position storage position,\n      int256 amount0,\n      int256 amount1\n    )\n  {\n    UpdatePositionCache memory cache = UpdatePositionCache(globalState.price, globalState.tick, globalState.timepointIndex);\n\n    position = getOrCreatePosition(owner, bottomTick, topTick);\n\n    (uint256 _totalFeeGrowth0Token, uint256 _totalFeeGrowth1Token) = (totalFeeGrowth0Token, totalFeeGrowth1Token);\n\n    bool toggledBottom;\n    bool toggledTop;\n    if (liquidityDelta != 0) {\n      uint32 time = _blockTimestamp();\n      (int56 tickCumulative, uint160 secondsPerLiquidityCumulative, , ) = _getSingleTimepoint(time, 0, cache.tick, cache.timepointIndex, liquidity);\n\n      if (\n        ticks.update(\n          bottomTick,\n          cache.tick,\n          liquidityDelta,\n          _totalFeeGrowth0Token,\n          _totalFeeGrowth1Token,\n          secondsPerLiquidityCumulative,\n          tickCumulative,\n          time,\n          false // isTopTick\n        )\n      ) {\n        toggledBottom = true;\n        tickTable.toggleTick(bottomTick);\n      }\n\n      if (\n        ticks.update(\n          topTick,\n          cache.tick,\n          liquidityDelta,\n          _totalFeeGrowth0Token,\n          _totalFeeGrowth1Token,\n          secondsPerLiquidityCumulative,\n          tickCumulative,\n          time,\n          true // isTopTick\n        )\n      ) {\n        toggledTop = true;\n        tickTable.toggleTick(topTick);\n      }\n    }\n\n    (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) = ticks.getInnerFeeGrowth(\n      bottomTick,\n      topTick,\n      cache.tick,\n      _totalFeeGrowth0Token,\n      _totalFeeGrowth1Token\n    );\n\n    _recalculatePosition(position, liquidityDelta, feeGrowthInside0X128, feeGrowthInside1X128);\n\n    if (liquidityDelta != 0) {\n      // if liquidityDelta is negative and the tick was toggled, it means that it should not be initialized anymore, so we delete it\n      if (liquidityDelta < 0) {\n        if (toggledBottom) delete ticks[bottomTick];\n        if (toggledTop) delete ticks[topTick];\n      }\n\n      int128 globalLiquidityDelta;\n      (amount0, amount1, globalLiquidityDelta) = _getAmountsForLiquidity(bottomTick, topTick, liquidityDelta, cache.tick, cache.price);\n      if (globalLiquidityDelta != 0) {\n        uint128 liquidityBefore = liquidity;\n        uint16 newTimepointIndex = _writeTimepoint(cache.timepointIndex, _blockTimestamp(), cache.tick, liquidityBefore, volumePerLiquidityInBlock);\n        if (cache.timepointIndex != newTimepointIndex) {\n          globalState.fee = _getNewFee(_blockTimestamp(), cache.tick, newTimepointIndex, liquidityBefore);\n          globalState.timepointIndex = newTimepointIndex;\n          volumePerLiquidityInBlock = 0;\n        }\n        liquidity = LiquidityMath.addDelta(liquidityBefore, liquidityDelta);\n      }\n    }\n  }\n\n  function _getAmountsForLiquidity(\n    int24 bottomTick,\n    int24 topTick,\n    int128 liquidityDelta,\n    int24 currentTick,\n    uint160 currentPrice\n  )\n    private\n    pure\n    returns (\n      int256 amount0,\n      int256 amount1,\n      int128 globalLiquidityDelta\n    )\n  {\n    // If current tick is less than the provided bottom one then only the token0 has to be provided\n    if (currentTick < bottomTick) {\n      amount0 = TokenDeltaMath.getToken0Delta(TickMath.getSqrtRatioAtTick(bottomTick), TickMath.getSqrtRatioAtTick(topTick), liquidityDelta);\n    } else if (currentTick < topTick) {\n      amount0 = TokenDeltaMath.getToken0Delta(currentPrice, TickMath.getSqrtRatioAtTick(topTick), liquidityDelta);\n      amount1 = TokenDeltaMath.getToken1Delta(TickMath.getSqrtRatioAtTick(bottomTick), currentPrice, liquidityDelta);\n\n      globalLiquidityDelta = liquidityDelta;\n    }\n    // If current tick is greater than the provided top one then only the token1 has to be provided\n    else {\n      amount1 = TokenDeltaMath.getToken1Delta(TickMath.getSqrtRatioAtTick(bottomTick), TickMath.getSqrtRatioAtTick(topTick), liquidityDelta);\n    }\n  }\n\n  /**\n   * @notice This function fetches certain position object\n   * @param owner The address owing the position\n   * @param bottomTick The position's bottom tick\n   * @param topTick The position's top tick\n   * @return position The Position object\n   */\n  function getOrCreatePosition(\n    address owner,\n    int24 bottomTick,\n    int24 topTick\n  ) private view returns (Position storage) {\n    bytes32 key;\n    assembly {\n      key := or(shl(24, or(shl(24, owner), and(bottomTick, 0xFFFFFF))), and(topTick, 0xFFFFFF))\n    }\n    return positions[key];\n  }\n\n  /// @inheritdoc IAlgebraPoolActions\n  function mint(\n    address sender,\n    address recipient,\n    int24 bottomTick,\n    int24 topTick,\n    uint128 liquidityDesired,\n    bytes calldata data\n  )\n    external\n    override\n    lock\n    onlyValidTicks(bottomTick, topTick)\n    returns (\n      uint256 amount0,\n      uint256 amount1,\n      uint128 liquidityActual\n    )\n  {\n    require(liquidityDesired > 0, 'IL');\n    {\n      (int256 amount0Int, int256 amount1Int, ) = _getAmountsForLiquidity(\n        bottomTick,\n        topTick,\n        int256(liquidityDesired).toInt128(),\n        globalState.tick,\n        globalState.price\n      );\n\n      amount0 = uint256(amount0Int);\n      amount1 = uint256(amount1Int);\n    }\n\n    uint256 receivedAmount0;\n    uint256 receivedAmount1;\n    {\n      if (amount0 > 0) receivedAmount0 = balanceToken0();\n      if (amount1 > 0) receivedAmount1 = balanceToken1();\n      IAlgebraMintCallback(msg.sender).algebraMintCallback(amount0, amount1, data);\n      if (amount0 > 0) require((receivedAmount0 = balanceToken0() - receivedAmount0) > 0, 'IIAM');\n      if (amount1 > 0) require((receivedAmount1 = balanceToken1() - receivedAmount1) > 0, 'IIAM');\n    }\n\n    liquidityActual = liquidityDesired;\n    if (receivedAmount0 < amount0) {\n      liquidityActual = uint128(FullMath.mulDiv(uint256(liquidityActual), receivedAmount0, amount0));\n    }\n    if (receivedAmount1 < amount1) {\n      uint128 liquidityForRA1 = uint128(FullMath.mulDiv(uint256(liquidityActual), receivedAmount1, amount1));\n      if (liquidityForRA1 < liquidityActual) {\n        liquidityActual = liquidityForRA1;\n      }\n    }\n\n    require(liquidityActual > 0, 'IIL2');\n\n    {\n      (, int256 amount0Int, int256 amount1Int) = _updatePositionTicksAndFees(recipient, bottomTick, topTick, int256(liquidityActual).toInt128());\n\n      require((amount0 = uint256(amount0Int)) <= receivedAmount0, 'IIAM2');\n      require((amount1 = uint256(amount1Int)) <= receivedAmount1, 'IIAM2');\n    }\n\n    if (receivedAmount0 > amount0) {\n      TransferHelper.safeTransfer(token0, sender, receivedAmount0 - amount0);\n    }\n    if (receivedAmount1 > amount1) {\n      TransferHelper.safeTransfer(token1, sender, receivedAmount1 - amount1);\n    }\n    emit Mint(msg.sender, recipient, bottomTick, topTick, liquidityActual, amount0, amount1);\n  }\n\n  /// @inheritdoc IAlgebraPoolActions\n  function collect(\n    address recipient,\n    int24 bottomTick,\n    int24 topTick,\n    uint128 amount0Requested,\n    uint128 amount1Requested\n  ) external override lock returns (uint128 amount0, uint128 amount1) {\n    Position storage position = getOrCreatePosition(msg.sender, bottomTick, topTick);\n    (uint128 positionFees0, uint128 positionFees1) = (position.fees0, position.fees1);\n\n    amount0 = amount0Requested > positionFees0 ? positionFees0 : amount0Requested;\n    amount1 = amount1Requested > positionFees1 ? positionFees1 : amount1Requested;\n\n    if (amount0 | amount1 != 0) {\n      position.fees0 = positionFees0 - amount0;\n      position.fees1 = positionFees1 - amount1;\n\n      if (amount0 > 0) TransferHelper.safeTransfer(token0, recipient, amount0);\n      if (amount1 > 0) TransferHelper.safeTransfer(token1, recipient, amount1);\n    }\n\n    emit Collect(msg.sender, recipient, bottomTick, topTick, amount0, amount1);\n  }\n\n  /// @inheritdoc IAlgebraPoolActions\n  function burn(\n    int24 bottomTick,\n    int24 topTick,\n    uint128 amount\n  ) external override lock onlyValidTicks(bottomTick, topTick) returns (uint256 amount0, uint256 amount1) {\n    (Position storage position, int256 amount0Int, int256 amount1Int) = _updatePositionTicksAndFees(\n      msg.sender,\n      bottomTick,\n      topTick,\n      -int256(amount).toInt128()\n    );\n\n    amount0 = uint256(-amount0Int);\n    amount1 = uint256(-amount1Int);\n\n    if (amount0 | amount1 != 0) {\n      (position.fees0, position.fees1) = (position.fees0.add128(uint128(amount0)), position.fees1.add128(uint128(amount1)));\n    }\n\n    emit Burn(msg.sender, bottomTick, topTick, amount, amount0, amount1);\n  }\n\n  /// @dev Returns new fee according combination of sigmoids\n  function _getNewFee(\n    uint32 _time,\n    int24 _tick,\n    uint16 _index,\n    uint128 _liquidity\n  ) private returns (uint16 newFee) {\n    newFee = IDataStorageOperator(dataStorageOperator).getFee(_time, _tick, _index, _liquidity);\n    emit Fee(newFee);\n  }\n\n  function _payCommunityFee(address token, uint256 amount) private {\n    address vault = IAlgebraFactory(factory).vaultAddress();\n    TransferHelper.safeTransfer(token, vault, amount);\n  }\n\n  function _writeTimepoint(\n    uint16 timepointIndex,\n    uint32 blockTimestamp,\n    int24 tick,\n    uint128 liquidity,\n    uint128 volumePerLiquidityInBlock\n  ) private returns (uint16 newTimepointIndex) {\n    return IDataStorageOperator(dataStorageOperator).write(timepointIndex, blockTimestamp, tick, liquidity, volumePerLiquidityInBlock);\n  }\n\n  function _getSingleTimepoint(\n    uint32 blockTimestamp,\n    uint32 secondsAgo,\n    int24 startTick,\n    uint16 timepointIndex,\n    uint128 liquidityStart\n  )\n    private\n    view\n    returns (\n      int56 tickCumulative,\n      uint160 secondsPerLiquidityCumulative,\n      uint112 volatilityCumulative,\n      uint256 volumePerAvgLiquidity\n    )\n  {\n    return IDataStorageOperator(dataStorageOperator).getSingleTimepoint(blockTimestamp, secondsAgo, startTick, timepointIndex, liquidityStart);\n  }\n\n  function _swapCallback(\n    int256 amount0,\n    int256 amount1,\n    bytes calldata data\n  ) private {\n    IAlgebraSwapCallback(msg.sender).algebraSwapCallback(amount0, amount1, data);\n  }\n\n  /// @inheritdoc IAlgebraPoolActions\n  function swap(\n    address recipient,\n    bool zeroToOne,\n    int256 amountRequired,\n    uint160 limitSqrtPrice,\n    bytes calldata data\n  ) external override returns (int256 amount0, int256 amount1) {\n    uint160 currentPrice;\n    int24 currentTick;\n    uint128 currentLiquidity;\n    uint256 communityFee;\n    // function _calculateSwapAndLock locks globalState.unlocked and does not release\n    (amount0, amount1, currentPrice, currentTick, currentLiquidity, communityFee) = _calculateSwapAndLock(zeroToOne, amountRequired, limitSqrtPrice);\n\n    if (zeroToOne) {\n      if (amount1 < 0) TransferHelper.safeTransfer(token1, recipient, uint256(-amount1)); // transfer to recipient\n\n      uint256 balance0Before = balanceToken0();\n      _swapCallback(amount0, amount1, data); // callback to get tokens from the caller\n      require(balance0Before.add(uint256(amount0)) <= balanceToken0(), 'IIA');\n    } else {\n      if (amount0 < 0) TransferHelper.safeTransfer(token0, recipient, uint256(-amount0)); // transfer to recipient\n\n      uint256 balance1Before = balanceToken1();\n      _swapCallback(amount0, amount1, data); // callback to get tokens from the caller\n      require(balance1Before.add(uint256(amount1)) <= balanceToken1(), 'IIA');\n    }\n\n    if (communityFee > 0) {\n      _payCommunityFee(zeroToOne ? token0 : token1, communityFee);\n    }\n\n    emit Swap(msg.sender, recipient, amount0, amount1, currentPrice, currentLiquidity, currentTick);\n    globalState.unlocked = true; // release after lock in _calculateSwapAndLock\n  }\n\n  /// @inheritdoc IAlgebraPoolActions\n  function swapSupportingFeeOnInputTokens(\n    address sender,\n    address recipient,\n    bool zeroToOne,\n    int256 amountRequired,\n    uint160 limitSqrtPrice,\n    bytes calldata data\n  ) external override returns (int256 amount0, int256 amount1) {\n    // Since the pool can get less tokens then sent, firstly we are getting tokens from the\n    // original caller of the transaction. And change the _amountRequired_\n    require(globalState.unlocked, 'LOK');\n    globalState.unlocked = false;\n    if (zeroToOne) {\n      uint256 balance0Before = balanceToken0();\n      _swapCallback(amountRequired, 0, data);\n      require((amountRequired = int256(balanceToken0().sub(balance0Before))) > 0, 'IIA');\n    } else {\n      uint256 balance1Before = balanceToken1();\n      _swapCallback(0, amountRequired, data);\n      require((amountRequired = int256(balanceToken1().sub(balance1Before))) > 0, 'IIA');\n    }\n    globalState.unlocked = true;\n\n    uint160 currentPrice;\n    int24 currentTick;\n    uint128 currentLiquidity;\n    uint256 communityFee;\n    // function _calculateSwapAndLock locks 'globalState.unlocked' and does not release\n    (amount0, amount1, currentPrice, currentTick, currentLiquidity, communityFee) = _calculateSwapAndLock(zeroToOne, amountRequired, limitSqrtPrice);\n\n    // only transfer to the recipient\n    if (zeroToOne) {\n      if (amount1 < 0) TransferHelper.safeTransfer(token1, recipient, uint256(-amount1));\n      // return the leftovers\n      if (amount0 < amountRequired) TransferHelper.safeTransfer(token0, sender, uint256(amountRequired.sub(amount0)));\n    } else {\n      if (amount0 < 0) TransferHelper.safeTransfer(token0, recipient, uint256(-amount0));\n      // return the leftovers\n      if (amount1 < amountRequired) TransferHelper.safeTransfer(token1, sender, uint256(amountRequired.sub(amount1)));\n    }\n\n    if (communityFee > 0) {\n      _payCommunityFee(zeroToOne ? token0 : token1, communityFee);\n    }\n\n    emit Swap(msg.sender, recipient, amount0, amount1, currentPrice, currentLiquidity, currentTick);\n    globalState.unlocked = true; // release after lock in _calculateSwapAndLock\n  }\n\n  struct SwapCalculationCache {\n    uint256 communityFee; // The community fee of the selling token, uint256 to minimize casts\n    uint128 volumePerLiquidityInBlock;\n    int56 tickCumulative; // The global tickCumulative at the moment\n    uint160 secondsPerLiquidityCumulative; // The global secondPerLiquidity at the moment\n    bool computedLatestTimepoint; //  if we have already fetched _tickCumulative_ and _secondPerLiquidity_ from the DataOperator\n    int256 amountRequiredInitial; // The initial value of the exact input\\output amount\n    int256 amountCalculated; // The additive amount of total output\\input calculated trough the swap\n    uint256 totalFeeGrowth; // The initial totalFeeGrowth + the fee growth during a swap\n    uint256 totalFeeGrowthB;\n    IAlgebraVirtualPool.Status incentiveStatus; // If there is an active incentive at the moment\n    bool exactInput; // Whether the exact input or output is specified\n    uint16 fee; // The current dynamic fee\n    int24 startTick; // The tick at the start of a swap\n    uint16 timepointIndex; // The index of last written timepoint\n  }\n\n  struct PriceMovementCache {\n    uint160 stepSqrtPrice; // The Q64.96 sqrt of the price at the start of the step\n    int24 nextTick; // The tick till the current step goes\n    bool initialized; // True if the _nextTick is initialized\n    uint160 nextTickPrice; // The Q64.96 sqrt of the price calculated from the _nextTick\n    uint256 input; // The additive amount of tokens that have been provided\n    uint256 output; // The additive amount of token that have been withdrawn\n    uint256 feeAmount; // The total amount of fee earned within a current step\n  }\n\n  /// @notice For gas optimization, locks 'globalState.unlocked' and does not release.\n  function _calculateSwapAndLock(\n    bool zeroToOne,\n    int256 amountRequired,\n    uint160 limitSqrtPrice\n  )\n    private\n    returns (\n      int256 amount0,\n      int256 amount1,\n      uint160 currentPrice,\n      int24 currentTick,\n      uint128 currentLiquidity,\n      uint256 communityFeeAmount\n    )\n  {\n    uint32 blockTimestamp;\n    SwapCalculationCache memory cache;\n    {\n      // load from one storage slot\n      currentPrice = globalState.price;\n      currentTick = globalState.tick;\n      cache.fee = globalState.fee;\n      cache.timepointIndex = globalState.timepointIndex;\n      uint256 _communityFeeToken0 = globalState.communityFeeToken0;\n      uint256 _communityFeeToken1 = globalState.communityFeeToken1;\n      bool unlocked = globalState.unlocked;\n\n      globalState.unlocked = false; // lock will not be released in this function\n      require(unlocked, 'LOK');\n\n      require(amountRequired != 0, 'AS');\n      (cache.amountRequiredInitial, cache.exactInput) = (amountRequired, amountRequired > 0);\n\n      (currentLiquidity, cache.volumePerLiquidityInBlock) = (liquidity, volumePerLiquidityInBlock);\n\n      if (zeroToOne) {\n        require(limitSqrtPrice < currentPrice && limitSqrtPrice > TickMath.MIN_SQRT_RATIO, 'SPL');\n        cache.totalFeeGrowth = totalFeeGrowth0Token;\n        cache.communityFee = _communityFeeToken0;\n      } else {\n        require(limitSqrtPrice > currentPrice && limitSqrtPrice < TickMath.MAX_SQRT_RATIO, 'SPL');\n        cache.totalFeeGrowth = totalFeeGrowth1Token;\n        cache.communityFee = _communityFeeToken1;\n      }\n\n      cache.startTick = currentTick;\n\n      blockTimestamp = _blockTimestamp();\n\n      if (activeIncentive != address(0)) {\n        IAlgebraVirtualPool.Status _status = IAlgebraVirtualPool(activeIncentive).increaseCumulative(blockTimestamp);\n        if (_status == IAlgebraVirtualPool.Status.NOT_EXIST) {\n          activeIncentive = address(0);\n        } else if (_status == IAlgebraVirtualPool.Status.ACTIVE) {\n          cache.incentiveStatus = IAlgebraVirtualPool.Status.ACTIVE;\n        } else if (_status == IAlgebraVirtualPool.Status.NOT_STARTED) {\n          cache.incentiveStatus = IAlgebraVirtualPool.Status.NOT_STARTED;\n        }\n      }\n\n      uint16 newTimepointIndex = _writeTimepoint(\n        cache.timepointIndex,\n        blockTimestamp,\n        cache.startTick,\n        currentLiquidity,\n        cache.volumePerLiquidityInBlock\n      );\n\n      // new timepoint appears only for first swap in block\n      if (newTimepointIndex != cache.timepointIndex) {\n        cache.timepointIndex = newTimepointIndex;\n        cache.volumePerLiquidityInBlock = 0;\n        cache.fee = _getNewFee(blockTimestamp, currentTick, newTimepointIndex, currentLiquidity);\n      }\n    }\n\n    PriceMovementCache memory step;\n    // swap until there is remaining input or output tokens or we reach the price limit\n    while (true) {\n      step.stepSqrtPrice = currentPrice;\n\n      (step.nextTick, step.initialized) = tickTable.nextTickInTheSameRow(currentTick, zeroToOne);\n\n      step.nextTickPrice = TickMath.getSqrtRatioAtTick(step.nextTick);\n\n      // calculate the amounts needed to move the price to the next target if it is possible or as much as possible\n      (currentPrice, step.input, step.output, step.feeAmount) = PriceMovementMath.movePriceTowardsTarget(\n        zeroToOne,\n        currentPrice,\n        (zeroToOne == (step.nextTickPrice < limitSqrtPrice)) // move the price to the target or to the limit\n          ? limitSqrtPrice\n          : step.nextTickPrice,\n        currentLiquidity,\n        amountRequired,\n        cache.fee\n      );\n\n      if (cache.exactInput) {\n        amountRequired -= (step.input + step.feeAmount).toInt256(); // decrease remaining input amount\n        cache.amountCalculated = cache.amountCalculated.sub(step.output.toInt256()); // decrease calculated output amount\n      } else {\n        amountRequired += step.output.toInt256(); // increase remaining output amount (since its negative)\n        cache.amountCalculated = cache.amountCalculated.add((step.input + step.feeAmount).toInt256()); // increase calculated input amount\n      }\n\n      if (cache.communityFee > 0) {\n        uint256 delta = (step.feeAmount.mul(cache.communityFee)) / Constants.COMMUNITY_FEE_DENOMINATOR;\n        step.feeAmount -= delta;\n        communityFeeAmount += delta;\n      }\n\n      if (currentLiquidity > 0) cache.totalFeeGrowth += FullMath.mulDiv(step.feeAmount, Constants.Q128, currentLiquidity);\n\n      if (currentPrice == step.nextTickPrice) {\n        // if the reached tick is initialized then we need to cross it\n        if (step.initialized) {\n          // once at a swap we have to get the last timepoint of the observation\n          if (!cache.computedLatestTimepoint) {\n            (cache.tickCumulative, cache.secondsPerLiquidityCumulative, , ) = _getSingleTimepoint(\n              blockTimestamp,\n              0,\n              cache.startTick,\n              cache.timepointIndex,\n              currentLiquidity // currentLiquidity can be changed only after computedLatestTimepoint\n            );\n            cache.computedLatestTimepoint = true;\n            cache.totalFeeGrowthB = zeroToOne ? totalFeeGrowth1Token : totalFeeGrowth0Token;\n          }\n          // every tick cross is needed to be duplicated in a virtual pool\n          if (cache.incentiveStatus != IAlgebraVirtualPool.Status.NOT_EXIST) {\n            IAlgebraVirtualPool(activeIncentive).cross(step.nextTick, zeroToOne);\n          }\n          int128 liquidityDelta;\n          if (zeroToOne) {\n            liquidityDelta = -ticks.cross(\n              step.nextTick,\n              cache.totalFeeGrowth, // A == 0\n              cache.totalFeeGrowthB, // B == 1\n              cache.secondsPerLiquidityCumulative,\n              cache.tickCumulative,\n              blockTimestamp\n            );\n          } else {\n            liquidityDelta = ticks.cross(\n              step.nextTick,\n              cache.totalFeeGrowthB, // B == 0\n              cache.totalFeeGrowth, // A == 1\n              cache.secondsPerLiquidityCumulative,\n              cache.tickCumulative,\n              blockTimestamp\n            );\n          }\n\n          currentLiquidity = LiquidityMath.addDelta(currentLiquidity, liquidityDelta);\n        }\n\n        currentTick = zeroToOne ? step.nextTick - 1 : step.nextTick;\n      } else if (currentPrice != step.stepSqrtPrice) {\n        // if the price has changed but hasn't reached the target\n        currentTick = TickMath.getTickAtSqrtRatio(currentPrice);\n        break; // since the price hasn't reached the target, amountRequired should be 0\n      }\n\n      // check stop condition\n      if (amountRequired == 0 || currentPrice == limitSqrtPrice) {\n        break;\n      }\n    }\n\n    (amount0, amount1) = zeroToOne == cache.exactInput // the amount to provide could be less then initially specified (e.g. reached limit)\n      ? (cache.amountRequiredInitial - amountRequired, cache.amountCalculated) // the amount to get could be less then initially specified (e.g. reached limit)\n      : (cache.amountCalculated, cache.amountRequiredInitial - amountRequired);\n\n    (globalState.price, globalState.tick, globalState.fee, globalState.timepointIndex) = (currentPrice, currentTick, cache.fee, cache.timepointIndex);\n\n    (liquidity, volumePerLiquidityInBlock) = (\n      currentLiquidity,\n      cache.volumePerLiquidityInBlock + IDataStorageOperator(dataStorageOperator).calculateVolumePerLiquidity(currentLiquidity, amount0, amount1)\n    );\n\n    if (zeroToOne) {\n      totalFeeGrowth0Token = cache.totalFeeGrowth;\n    } else {\n      totalFeeGrowth1Token = cache.totalFeeGrowth;\n    }\n  }\n\n  /// @inheritdoc IAlgebraPoolActions\n  function flash(\n    address recipient,\n    uint256 amount0,\n    u"
    }
  ]
}