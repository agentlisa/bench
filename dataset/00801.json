{
  "Title": "Audit Report for SDLPool.sol - Scalability Concern",
  "Content": "# Audit Report for SDLPool.sol - Scalability Concern\n\n### Severity\nLow Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/sdlPool/base/SDLPool.sol#L177\">https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/sdlPool/base/SDLPool.sol#L177</a>\n\n\n## Summary\n\nThis report highlights a potential scalability issue in the `SDLPool.sol` smart contract, specifically within the `getLockIdsByOwner` function. The current storage and retrieval method for lock IDs will become increasingly expensive over time.\n\n## Vulnerability Details\n\nIn `SDLPool.sol:177`, the `getLockIdsByOwner` function iterates through all lock IDs from 1 to `lastLockId` to determine which locks belong to a specific owner. This approach, while functional, becomes inefficient as the number of lock IDs grows, leading to increased gas costs and slower execution times.\n\n## Impact\n\nThe linear search methodology employed in the function poses the following risks:\n\n1. **High Gas Costs**: As the `lastLockId` increases, the cost of iterating through all lock IDs grows, resulting in expensive read operations.\n2. **Scalability Issues**: The function's performance degrades over time as the dataset grows, potentially making it impractical or too costly to use in the long term.\n3. **Reduced User Experience**: Slower execution times and higher costs can negatively impact the user experience, especially for accounts with a large number of locks.\n\nSince the protocol itself doesn't use the function there is no risk of it affecting it but being a user facing function is it worth to be aware of it.\n\n## Tools Used\n\nManual Review\n\n## Recommendations\n\nTo address these issues, consider implementing a more efficient storage solution:\n\n- **Indexing Locks by Owner**: Maintain a mapping of owner addresses to an array of their lock IDs. This approach enables direct access to an owner's locks without iterating through the entire dataset.\n",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clqf7mgla0001yeyfah59c674",
  "Code": [
    {
      "filename": "contracts/core/sdlPool/base/SDLPool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\";\n\nimport \"../../base/RewardsPoolController.sol\";\nimport \"../../interfaces/IBoostController.sol\";\nimport \"../../interfaces/IERC721Receiver.sol\";\n\n/**\n * @title SDL Pool\n * @notice Base SDL Pool contract to inherit from\n */\ncontract SDLPool is RewardsPoolController, IERC721Upgradeable, IERC721MetadataUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    struct Lock {\n        uint256 amount;\n        uint256 boostAmount;\n        uint64 startTime;\n        uint64 duration;\n        uint64 expiry;\n    }\n\n    string public name;\n    string public symbol;\n\n    mapping(address => mapping(address => bool)) internal operatorApprovals;\n    mapping(uint256 => address) internal tokenApprovals;\n\n    IERC20Upgradeable public sdlToken;\n    IBoostController public boostController;\n\n    uint256 public lastLockId;\n    mapping(uint256 => Lock) internal locks;\n    mapping(uint256 => address) internal lockOwners;\n    mapping(address => uint256) internal balances;\n\n    uint256 public totalEffectiveBalance;\n    mapping(address => uint256) internal effectiveBalances;\n\n    address public ccipController;\n\n    string public baseURI;\n\n    event InitiateUnlock(address indexed owner, uint256 indexed lockId, uint64 expiry);\n    event Withdraw(address indexed owner, uint256 indexed lockId, uint256 amount);\n    event CreateLock(\n        address indexed owner,\n        uint256 indexed lockId,\n        uint256 amount,\n        uint256 boostAmount,\n        uint64 lockingDuration\n    );\n    event UpdateLock(\n        address indexed owner,\n        uint256 indexed lockId,\n        uint256 amount,\n        uint256 boostAmount,\n        uint64 lockingDuration\n    );\n    event OutgoingRESDL(address indexed sender, uint256 indexed lockId);\n    event IncomingRESDL(address indexed receiver, uint256 indexed lockId);\n\n    error SenderNotAuthorized();\n    error InvalidLockId();\n    error InvalidLockingDuration();\n    error TransferFromIncorrectOwner();\n    error TransferToZeroAddress();\n    error TransferToNonERC721Implementer();\n    error TransferToCCIPController();\n    error ApprovalToCurrentOwner();\n    error ApprovalToCaller();\n    error InvalidValue();\n    error InvalidParams();\n    error UnauthorizedToken();\n    error TotalDurationNotElapsed();\n    error HalfDurationNotElapsed();\n    error InsufficientBalance();\n    error UnlockNotInitiated();\n    error DuplicateContract();\n    error ContractNotFound();\n    error UnlockAlreadyInitiated();\n\n    /**\n     * @notice initializes contract\n     * @param _name name of the staking derivative token\n     * @param _symbol symbol of the staking derivative token\n     * @param _sdlToken address of the SDL token\n     * @param _boostController address of the boost controller\n     **/\n    function __SDLPoolBase_init(\n        string memory _name,\n        string memory _symbol,\n        address _sdlToken,\n        address _boostController\n    ) public onlyInitializing {\n        __RewardsPoolController_init();\n        name = _name;\n        symbol = _symbol;\n        sdlToken = IERC20Upgradeable(_sdlToken);\n        boostController = IBoostController(_boostController);\n    }\n\n    /**\n     * @notice reverts if `_owner` is not the owner of `_lockId`\n     **/\n    modifier onlyLockOwner(uint256 _lockId, address _owner) {\n        _onlyLockOwner(_lockId, _owner);\n        _;\n    }\n\n    /**\n     * @notice reverts if sender is not the CCIP controller\n     **/\n    modifier onlyCCIPController() {\n        if (msg.sender != ccipController) revert SenderNotAuthorized();\n        _;\n    }\n\n    /**\n     * @notice returns the effective stake balance of an account\n     * @dev the effective stake balance includes the actual amount of tokens an\n     * account has staked across all locks plus any applicable boost gained by locking\n     * @param _account address of account\n     * @return effective stake balance\n     **/\n    function effectiveBalanceOf(address _account) external view returns (uint256) {\n        return effectiveBalances[_account];\n    }\n\n    /**\n     * @notice returns the number of locks owned by an account\n     * @param _account address of account\n     * @return total number of locks owned by account\n     **/\n    function balanceOf(address _account) public view returns (uint256) {\n        return balances[_account];\n    }\n\n    /**\n     * @notice returns the owner of a lock\n     * @dev reverts if `_lockId` is invalid\n     * @param _lockId id of the lock\n     * @return lock owner\n     **/\n    function ownerOf(uint256 _lockId) public view returns (address) {\n        address owner = lockOwners[_lockId];\n        if (owner == address(0)) revert InvalidLockId();\n        return owner;\n    }\n\n    /**\n     * @notice returns the list of locks that corresponds to `_lockIds`\n     * @dev reverts if any lockId is invalid\n     * @param _lockIds list of lock ids\n     * @return list of locks\n     **/\n    function getLocks(uint256[] calldata _lockIds) external view returns (Lock[] memory) {\n        Lock[] memory retLocks = new Lock[](_lockIds.length);\n\n        for (uint256 i = 0; i < _lockIds.length; ++i) {\n            uint256 lockId = _lockIds[i];\n            if (lockOwners[lockId] == address(0)) revert InvalidLockId();\n            retLocks[i] = locks[lockId];\n        }\n\n        return retLocks;\n    }\n\n    /**\n     * @notice returns a list of lockIds owned by an account\n     * @param _owner address of account\n     * @return list of lockIds\n     **/\n    function getLockIdsByOwner(address _owner) external view returns (uint256[] memory) {\n        uint256 maxLockId = lastLockId;\n        uint256 lockCount = balanceOf(_owner);\n        uint256 lockIdsFound;\n        uint256[] memory lockIds = new uint256[](lockCount);\n\n        for (uint256 i = 1; i <= maxLockId; ++i) {\n            if (lockOwners[i] == _owner) {\n                lockIds[lockIdsFound] = i;\n                lockIdsFound++;\n                if (lockIdsFound == lockCount) break;\n            }\n        }\n\n        assert(lockIdsFound == lockCount);\n\n        return lockIds;\n    }\n\n    /**\n     * @notice transfers a lock between accounts\n     * @dev reverts if sender is not the owner of and not approved to transfer the lock\n     * @param _from address to transfer from\n     * @param _to address to transfer to\n     * @param _lockId id of lock to transfer\n     **/\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _lockId\n    ) external {\n        if (!_isApprovedOrOwner(msg.sender, _lockId)) revert SenderNotAuthorized();\n        _transfer(_from, _to, _lockId);\n    }\n\n    /**\n     * @notice transfers a lock between accounts and validates that the receiver supports ERC721\n     * @dev\n     * - calls onERC721Received on `_to` if it is a contract or reverts if it is a contract\n     *   and does not implemement onERC721Received\n     * - reverts if sender is not the owner of and not approved to transfer the lock\n     * - reverts if `_lockId` is invalid\n     * @param _from address to transfer from\n     * @param _to address to transfer to\n     * @param _lockId id of lock to transfer\n     **/\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _lockId\n    ) external {\n        safeTransferFrom(_from, _to, _lockId, \"\");\n    }\n\n    /**\n     * @notice transfers a lock between accounts and validates that the receiver supports ERC721\n     * @dev\n     * - calls onERC721Received on `_to` if it is a contract or reverts if it is a contract\n     *   and does not implemement onERC721Received\n     * - reverts if sender is not the owner of and not approved to transfer the lock\n     * - reverts if `_lockId` is invalid\n     * @param _from address to transfer from\n     * @param _to address to transfer to\n     * @param _lockId id of lock to transfer\n     * @param _data optional data to pass to receiver\n     **/\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _lockId,\n        bytes memory _data\n    ) public {\n        if (!_isApprovedOrOwner(msg.sender, _lockId)) revert SenderNotAuthorized();\n        _transfer(_from, _to, _lockId);\n        if (!_checkOnERC721Received(_from, _to, _lockId, _data)) revert TransferToNonERC721Implementer();\n    }\n\n    /**\n     * @notice approves `_to` to transfer `_lockId` to another address\n     * @dev\n     * - approval is revoked on transfer and can also be revoked by approving zero address\n     * - reverts if sender is not owner of lock and not an approved operator for the owner\n     * - reverts if `_to` is owner of lock\n     * - reverts if `_lockId` is invalid\n     * @param _to address approved to transfer\n     * @param _lockId id of lock\n     **/\n    function approve(address _to, uint256 _lockId) external {\n        address owner = ownerOf(_lockId);\n\n        if (_to == owner) revert ApprovalToCurrentOwner();\n        if (msg.sender != owner && !isApprovedForAll(owner, msg.sender)) revert SenderNotAuthorized();\n\n        tokenApprovals[_lockId] = _to;\n        emit Approval(owner, _to, _lockId);\n    }\n\n    /**\n     * @notice returns the address approved to transfer a lock\n     * @param _lockId id of lock\n     * @return approved address\n     **/\n    function getApproved(uint256 _lockId) public view returns (address) {\n        if (lockOwners[_lockId] == address(0)) revert InvalidLockId();\n\n        return tokenApprovals[_lockId];\n    }\n\n    /**\n     * @notice approves _operator to transfer all tokens owned by sender\n     * @dev\n     * - approval will not be revoked until this function is called again with\n     *   `_approved` set to false\n     * - reverts if sender is `_operator`\n     * @param _operator address to approve/unapprove\n     * @param _approved whether address is approved or not\n     **/\n    function setApprovalForAll(address _operator, bool _approved) external {\n        address owner = msg.sender;\n        if (owner == _operator) revert ApprovalToCaller();\n\n        operatorApprovals[owner][_operator] = _approved;\n        emit ApprovalForAll(owner, _operator, _approved);\n    }\n\n    /**\n     * @notice returns whether `_operator` is approved to transfer all tokens owned by `_owner`\n     * @param _owner owner of tokens\n     * @param _operator address approved to transfer\n     * @return whether address is approved or not\n     **/\n    function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\n        return operatorApprovals[_owner][_operator];\n    }\n\n    /**\n     * @notice returns an account's staked amount for use by reward pools\n     * controlled by this contract\n     * @param _account account address\n     * @return account's staked amount\n     */\n    function staked(address _account) external view override returns (uint256) {\n        return effectiveBalances[_account];\n    }\n\n    /**\n     * @notice returns the total staked amount for use by reward pools\n     * controlled by this contract\n     * @return total staked amount\n     */\n    function totalStaked() external view override returns (uint256) {\n        return totalEffectiveBalance;\n    }\n\n    /**\n     * @notice adds a new token\n     * @param _token token to add\n     * @param _rewardsPool token rewards pool to add\n     **/\n    function addToken(address _token, address _rewardsPool) public override onlyOwner {\n        if (_token == address(sdlToken)) revert InvalidToken();\n        super.addToken(_token, _rewardsPool);\n    }\n\n    /**\n     * @notice returns whether this contract supports an interface\n     * @param _interfaceId id of interface\n     * @return whether contract supports interface or not\n     */\n    function supportsInterface(bytes4 _interfaceId) external view returns (bool) {\n        return\n            _interfaceId == type(IERC721Upgradeable).interfaceId ||\n            _interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            _interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev returns the URI for a token\n     */\n    function tokenURI(uint256) external view returns (string memory) {\n        return baseURI;\n    }\n\n    /**\n     * @dev sets the base URI for all tokens\n     */\n    function setBaseURI(string calldata _baseURI) external onlyOwner {\n        baseURI = _baseURI;\n    }\n\n    /**\n     * @notice sets the boost controller\n     * @dev this contract handles boost calculations for locking SDL\n     * @param _boostController address of boost controller\n     */\n    function setBoostController(address _boostController) external onlyOwner {\n        boostController = IBoostController(_boostController);\n    }\n\n    /**\n     * @notice sets the CCIP controller\n     * @dev this contract interfaces with CCIP\n     * @param _ccipController address of CCIP controller\n     */\n    function setCCIPController(address _ccipController) external onlyOwner {\n        ccipController = _ccipController;\n    }\n\n    /**\n     * @notice creates a new lock\n     * @dev reverts if `_lockingDuration` exceeds maximum\n     * @param _amount amount to stake\n     * @param _lockingDuration duration of lock\n     */\n    function _createLock(uint256 _amount, uint64 _lockingDuration) internal view returns (Lock memory) {\n        uint256 boostAmount = boostController.getBoostAmount(_amount, _lockingDuration);\n        uint64 startTime = _lockingDuration != 0 ? uint64(block.timestamp) : 0;\n\n        return Lock(_amount, boostAmount, startTime, _lockingDuration, 0);\n    }\n\n    /**\n     * @notice updates an existing lock\n     * @dev\n     * - reverts if `_lockId` is invalid\n     * - reverts if `_lockingDuration` is less than current locking duration of lock\n     * - reverts if `_lockingDuration` exceeds maximum\n     * @param _lock lock to update\n     * @param _amount additional amount to stake\n     * @param _lockingDuration duration of lock\n     */\n    function _updateLock(\n        Lock memory _lock,\n        uint256 _amount,\n        uint64 _lockingDuration\n    ) internal view returns (Lock memory) {\n        if ((_lock.expiry == 0 || _lock.expiry > block.timestamp) && _lockingDuration < _lock.duration) {\n            revert InvalidLockingDuration();\n        }\n\n        Lock memory lock = Lock(_lock.amount, _lock.boostAmount, _lock.startTime, _lock.duration, _lock.expiry);\n\n        uint256 baseAmount = _lock.amount + _amount;\n        uint256 boostAmount = boostController.getBoostAmount(baseAmount, _lockingDuration);\n\n        if (_lockingDuration != 0) {\n            lock.startTime = uint64(block.timestamp);\n        } else {\n            delete lock.startTime;\n        }\n\n        lock.amount = baseAmount;\n        lock.boostAmount = boostAmount;\n        lock.duration = _lockingDuration;\n        lock.expiry = 0;\n\n        return lock;\n    }\n\n    /**\n     * @notice checks if a lock is owned by an certain account\n     * @dev reverts if lock is not owner by account\n     * @param _lockId id of lock\n     * @param _owner owner address\n     **/\n    function _onlyLockOwner(uint256 _lockId, address _owner) internal view {\n        if (_owner != ownerOf(_lockId)) revert SenderNotAuthorized();\n    }\n\n    /**\n     * @notice transfers a lock between accounts\n     * @dev\n     * - reverts if `_from` is not the owner of the lock\n     * - reverts if `to` is zero address\n     * @param _from address to transfer from\n     * @param _to address to transfer to\n     * @param _lockId id of lock to transfer\n     **/\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _lockId\n    ) internal virtual {\n        if (_from != ownerOf(_lockId)) revert TransferFromIncorrectOwner();\n        if (_to == address(0)) revert TransferToZeroAddress();\n        if (_to == ccipController) revert TransferToCCIPController();\n\n        delete tokenApprovals[_lockId];\n\n        _updateRewards(_from);\n        _updateRewards(_to);\n\n        uint256 effectiveBalanceChange = locks[_lockId].amount + locks[_lockId].boostAmount;\n        effectiveBalances[_from] -= effectiveBalanceChange;\n        effectiveBalances[_to] += effectiveBalanceChange;\n\n        balances[_from] -= 1;\n        balances[_to] += 1;\n        lockOwners[_lockId] = _to;\n\n        emit Transfer(_from, _to, _lockId);\n    }\n\n    /**\n     * taken from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol\n     * @notice verifies that an address supports ERC721 and calls onERC721Received if applicable\n     * @dev\n     * - called after a lock is safe transferred\n     * - calls onERC721Received on `_to` if it is a contract or reverts if it is a contract\n     *   and does not implemement onERC721Received\n     * @param _from address that lock is being transferred from\n     * @param _to address that lock is being transferred to\n     * @param _lockId id of lock\n     * @param _data optional data to be passed to receiver\n     */\n    function _checkOnERC721Received(\n        address _from,\n        address _to,\n        uint256 _lockId,\n        bytes memory _data\n    ) internal returns (bool) {\n        if (_to.code.length > 0) {\n            try IERC721Receiver(_to).onERC721Received(msg.sender, _from, _lockId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert TransferToNonERC721Implementer();\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @notice returns whether an account is authorized to transfer a lock\n     * @dev returns true if `_spender` is approved to transfer `_lockId` or if `_spender` is\n     * approved to transfer all locks owned by the owner of `_lockId`\n     * @param _spender address of account\n     * @param _lockId id of lock\n     * @return whether address is authorized ot not\n     **/\n    function _isApprovedOrOwner(address _spender, uint256 _lockId) internal view returns (bool) {\n        address owner = ownerOf(_lockId);\n        return (_spender == owner || isApprovedForAll(owner, _spender) || getApproved(_lockId) == _spender);\n    }\n}"
    }
  ]
}