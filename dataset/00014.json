{
  "Title": "M-2: DEPOSIT_VAULT_ADMIN_ROLE/REDEMPTION_VAULT_ADMIN_ROLE have larger permission than expected: they shouldn't be able to pause vaults",
  "Content": "# Issue M-2: DEPOSIT_VAULT_ADMIN_ROLE/REDEMPTION_VAULT_ADMIN_ROLE have larger permission than expected: they shouldn't be able to pause vaults \n\nSource: https://github.com/sherlock-audit/2024-05-midas-judging/issues/112 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nAfriaudit, pkqs90\n## Summary\n\nThe accessibility of DEPOSIT_VAULT_ADMIN_ROLE and REDEMPTION_VAULT_ADMIN_ROLE has larger permission than what the contest readme claims: they can pause the vault and stop users from depositing/redeeming.\n\n## Vulnerability Detail\n\nAccording to the contest readme:\n\n- `DEPOSIT_VAULT_ADMIN_ROLE` has the role of `Handles freeFromMinDeposit, setMinAmountToDeposit, withdrawToken, addPaymentToken, removePaymentToken in DepositVault`.\n- `REDEMPTION_VAULT_ADMIN_ROLE` has the role of `Handles withdrawToken, addPaymentToken, removePaymentToken in RedemptionVault`.\n\nHowever, these two roles are also capable of pausing the depositVault/redemptionVault, which is unexpected.\n\nhttps://github.com/sherlock-audit/2024-05-midas/blob/main/midas-contracts/contracts/access/Pausable.sol#L18-L38\n```solidity\n    modifier onlyPauseAdmin() {\n>       _onlyRole(pauseAdminRole(), msg.sender);\n        _;\n    }\n\n    /**\n     * @dev upgradeable pattern contract`s initializer\n     * @param _accessControl MidasAccessControl contract address\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __Pausable_init(address _accessControl) internal onlyInitializing {\n        __WithMidasAccessControl_init(_accessControl);\n    }\n\n    function pause() external onlyPauseAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyPauseAdmin {\n        _unpause();\n    }\n```\n\nhttps://github.com/sherlock-audit/2024-05-midas/blob/main/midas-contracts/contracts/abstract/ManageableVault.sol#L139-L141\n```solidity\n    function pauseAdminRole() public view override returns (bytes32) {\n        return vaultRole();\n    }\n```\n\nhttps://github.com/sherlock-audit/2024-05-midas/blob/main/midas-contracts/contracts/DepositVault.sol\n```solidity\n    function vaultRole() public pure override returns (bytes32) {\n        return DEPOSIT_VAULT_ADMIN_ROLE;\n    }\n```\n\nhttps://github.com/sherlock-audit/2024-05-midas/blob/main/midas-contracts/contracts/RedemptionVault.sol\n```solidity\n    function vaultRole() public pure override returns (bytes32) {\n        return REDEMPTION_VAULT_ADMIN_ROLE;\n    }\n```\n\n## Impact\n\nThe two roles DEPOSIT_VAULT_ADMIN_ROLE/REDEMPTION_VAULT_ADMIN_ROLE have larger permission than they are expected to have.\n\n## Code Snippet\n\n- https://github.com/sherlock-audit/2024-05-midas/blob/main/midas-contracts/contracts/abstract/ManageableVault.sol#L139-L141\n- https://github.com/sherlock-audit/2024-05-midas/blob/main/midas-contracts/contracts/access/Pausable.sol#L18-L38\n\n## Tool used\n\nManual review\n\n## Recommendation\n\nRemove the pausability permission for DEPOSIT_VAULT_ADMIN_ROLE and REDEMPTION_VAULT_ADMIN_ROLE.\n\n\n\n## Discussion\n\n**nevillehuang**\n\nEscalate, this issue has no impact given all listed roles are trusted except `GREENLISTED_ROLE` and `BLACKLISTED_ROLE`. Notice that in `MidasAccessControl.sol` all roles are delegated to the `admin`, so in fact `admin` has the power of all trusted roles. The contest READ.ME simply states the role purpose, not the only permission it can perform, but the code logic indicates the `admin` role can perform all the trusted actions.\n\n```solidity\n    function _setupRoles() private {\n        address admin = msg.sender;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, admin);\n\n        _setupRole(DEPOSIT_VAULT_ADMIN_ROLE, admin);\n        _setupRole(REDEMPTION_VAULT_ADMIN_ROLE, admin);\n\n        _setRoleAdmin(BLACKLISTED_ROLE, BLACKLIST_OPERATOR_ROLE);\n        _setRoleAdmin(GREENLISTED_ROLE, GREENLIST_OPERATOR_ROLE);\n\n        _setupRole(GREENLIST_OPERATOR_ROLE, admin);\n        _setupRole(BLACKLIST_OPERATOR_ROLE, admin);\n\n        _setupRole(M_TBILL_MINT_OPERATOR_ROLE, admin);\n        _setupRole(M_TBILL_BURN_OPERATOR_ROLE, admin);\n        _setupRole(M_TBILL_PAUSE_OPERATOR_ROLE, admin);\n```\n\n\n**sherlock-admin3**\n\n> Escalate, this issue has no impact given all listed roles are trusted except `GREENLISTED_ROLE` and `BLACKLISTED_ROLE`. Notice that in `MidasAccessControl.sol` all roles are delegated to the `admin`, so in fact `admin` has the power of all trusted roles. The contest READ.ME simply states the role purpose, not the only permission it can perform, but the code logic indicates the `admin` role can perform all the trusted actions.\n> \n> ```solidity\n>     function _setupRoles() private {\n>         address admin = msg.sender;\n> \n>         _setupRole(DEFAULT_ADMIN_ROLE, admin);\n> \n>         _setupRole(DEPOSIT_VAULT_ADMIN_ROLE, admin);\n>         _setupRole(REDEMPTION_VAULT_ADMIN_ROLE, admin);\n> \n>         _setRoleAdmin(BLACKLISTED_ROLE, BLACKLIST_OPERATOR_ROLE);\n>         _setRoleAdmin(GREENLISTED_ROLE, GREENLIST_OPERATOR_ROLE);\n> \n>         _setupRole(GREENLIST_OPERATOR_ROLE, admin);\n>         _setupRole(BLACKLIST_OPERATOR_ROLE, admin);\n> \n>         _setupRole(M_TBILL_MINT_OPERATOR_ROLE, admin);\n>         _setupRole(M_TBILL_BURN_OPERATOR_ROLE, admin);\n>         _setupRole(M_TBILL_PAUSE_OPERATOR_ROLE, admin);\n> ```\n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**pronobis4**\n\nI agree with escalation, these are trusted roles.\n\n**amankakar**\n\nI think it is about the difference between the readMe and the code. that's why it should be accepted.\nreamMe  does not stated that the `DEPOSIT_VAULT_ADMIN_ROLE/REDEMPTION_VAULT_ADMIN_ROLE` can pause/unpasue the deposits/redemption.\n\n**Afriaudit**\n\nThe entire protocol uses a role-based access control to manage permissions, a significant part of the code base is ensuring that each role can only execute the functions they are specifically permitted to, and nothing more or less. The README specifically asked. ''provide a more comprehensive description of what a role can and can't do/impact'', a comprehensive list was provided and roles of `DEPOSIT_VAULT_ADMIN_ROLE/REDEMPTION_VAULT_ADMIN_ROLE` didn't include pausing deposits and redeem.\n\nThe README was also asked;\n\"For permissioned functions, please list all checks and requirements that will be made before calling the function.\"\nand the response is:\n \"onlyRole() - Checks if the permissioned function is being called by an address with its respective admin role \" This is to underscore that each admin Is only supposed to execute only functions they are permitted to. functions which are stated on the readme.\n\nThe statement made here by @nevillehuang  \"The contest READ.ME simply states the role purpose, not the only permission it can perform, but the code logic indicates the admin role can perform all the trusted actions.\" Is actually inaccurate here is why:\n\n1. \"admin role can perform all the trusted actions\": Its only the default admin that has all functions according to the code logic after launch. Its because its literarily the admin by default and according to the README default admin is expected to Grants and revokes roles even to other admins. The code even has a logic implementation for this. showing that the admins of each role is expected to change from default admin after launch.\n\n2. \"The contest READ.ME simply states the role purpose, not the only permission it can perform\": I dont agree with this as the README shows a comprehensive list of all permissioned functions and exactly who is to call them except for this particular role. \nFrom all being said it's reasonable to conclude that admins are trusted to manage only the roles they are specifically authorized to control, and nothing beyond that. The whole point of the role-based access control will be pointless if an admin role can just arbitrarily call a function outside its own permissioned function because it trusted with its own permitted roles.\n\nI think I have made my point here for the sherlock judge to make final verdict. \n\n**MxAxM**\n\n> Escalate, this issue has no impact given all listed roles are trusted except `GREENLISTED_ROLE` and `BLACKLISTED_ROLE`. Notice that in `MidasAccessControl.sol` all roles are delegated to the `admin`, so in fact `admin` has the power of all trusted roles. The contest READ.ME simply states the role purpose, not the only permission it can perform, but the code logic indicates the `admin` role can perform all the trusted actions.\n> \n> ```solidity\n>     function _setupRoles() private {\n>         address admin = msg.sender;\n> \n>         _setupRole(DEFAULT_ADMIN_ROLE, admin);\n> \n>         _setupRole(DEPOSIT_VAULT_ADMIN_ROLE, admin);\n>         _setupRole(REDEMPTION_VAULT_ADMIN_ROLE, admin);\n> \n>         _setRoleAdmin(BLACKLISTED_ROLE, BLACKLIST_OPERATOR_ROLE);\n>         _setRoleAdmin(GREENLISTED_ROLE, GREENLIST_OPERATOR_ROLE);\n> \n>         _setupRole(GREENLIST_OPERATOR_ROLE, admin);\n>         _setupRole(BLACKLIST_OPERATOR_ROLE, admin);\n> \n>         _setupRole(M_TBILL_MINT_OPERATOR_ROLE, admin);\n>         _setupRole(M_TBILL_BURN_OPERATOR_ROLE, admin);\n>         _setupRole(M_TBILL_PAUSE_OPERATOR_ROLE, admin);\n> ```\n\nI assumed they're different roles with different permissions and they shouldn't have more permission than what described in docs, also saying admins are trusted means they won't perform malicious actions by having defined permissions and it doesn't mean they can perform actions that they don't have permission to \n\n**CarlosAlegreUr**\n\n> a significant part of the code base is ensuring that each role can only execute the functions they are specifically permitted to, and nothing more or less\n\nJust to add another point of view. I would say this issue is valid or not depending on the definition of `TRUSTED` in Sherlock. As @MxAxM defined it here:\n\n```text\ntrusted means they won't perform malicious actions by having defined permissions and it doesn't mean they can perform actions that they don't have permission to\n```\n\nThen I think it is valid. Personally I thought of `TRUSTED` as: Someone who whatever it can do it doesnt matter because it is assumed it will never do something malicious. Thus when auditing I didnt even check what `TRUSTED` roles could or could not do. I would appreciate a clear definition of what a `TRUSTED` actor is in Sherlock, could not find it on their docs.\n\nTo conclude, if the definition is the one said by @MxAxM , I think the issue is valid, if it is the one I said, I think it is invalid.\n\n**pronobis4**\n\nAll this will not change the fact that the admin is TRUSTED, he cannot be treated as someone who will do something bad, which reduces the impact of this \"issue\".\n\n>''provide a more comprehensive description of what a role can and can't do/impact''\n\nJust as it is not written that \"he can pause\", it is also not written that \"he cannot pause\".\n\nIf the project contains a hierarchy ofÂ permissions, then each role would have to list all the roles it inherits, which would be crazy.\n\n**Afriaudit**\n\nJust to add to the comments I made earlier\n\nIn the README \"Additional audit information\" section, sponsor specifically mentioned that one of the attack vectors they would want watson's to look out for is ensuring roles work properly. Which means verify that only authorized roles can execute their respective functions. Which also goes to underscore the fact that each admin should only be able to execute their specified functions as outlined in the README.\n\nThe list of what a role can do was clearly stated and its logical to assume what was not in the list of what a role can do are things it can't do. There is no point to having a hierarchy of permissions. every role has its own explicit permissioned function. \n\n**WangSecurity**\n\nAs said above, indeed, the Additional audit information specifically asks Watsons to see if all the roles work properly. Hence, I believe the question about the roles gave a full explanation what each role should do and they should be able to do nothing less or more.\n\nYes, they're TRUSTED and we have to assume they won't harm the protocol in any way. But, I don't believe this issue is about completing malicious actions and the report doesn't talk about it. The problem is that under Sherlock's rules, if there is an issue breaking the statement/invariant explicitly mentioned in the README, it will be assigned Medium severity, regardless of the impact. Hence, I believe this issue has to stay valid.\n\nPlanning to reject the escalation and leave the issue as it is.\n\n**Afriaudit**\n\nAlso #83 is not a duplicate of this issue but an independent issue on its own that is worth looking into\n\n**blutorque**\n\nHey @WangSecurity, this finding says , \"High permission role can pause vaults\". And if they could do so, there is nothing wrong to assume `mint`/`burn` actions can also be performed irrespective of your user action. \n\nI specifically want to highlight issue [F-2023-0290](https://2732961456-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FsPjk0ggBxEJCCnVFFkDR%2Fuploads%2F38N1bo36K8FLriRrPDXb%2FHacken_Midas_%5BSCA%5D%20Midas_Vault_Dec2023_P-2023-076_1_20240118%2016_22.pdf?alt=media&token=2c58f6f7-889e-4c64-ac84-35bad59eb51a), which represent the same issue as this one, in one of previous audit report of Midas. \n\nAlso, Readme, \n\n> A note for Sherlock Watsons: Anything in the following section is considered a known issue and will be inelgible for rewards.\n> \n> Our most recent audit can be found [here](https://2732961456-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FsPjk0ggBxEJCCnVFFkDR%2Fuploads%2F38N1bo36K8FLriRrPDXb%2FHacken_Midas_%5BSCA%5D%20Midas_Vault_Dec2023_P-2023-076_1_20240118%2016_22.pdf?alt=media&token=2c58f6f7-889e-4c64-ac84-35bad59eb51a).\n\n**WangSecurity**\n\nThank you for sharing, but I don't see how this issue is connected to this report. The issue from Hacken is about the Burner role easily accessing user's funds, this report is about several roles having permission for functions they shouldn't have.\n\nHence, the decision remains the same. Planning to reject the escalation and leave the issue as it is.\n\n**nevillehuang**\n\n@WangSecurity The `DEFAULT_ADMIN_ROLE` which is set as the `admin` inherently holds the right to change these admins at any time. Is this really a security issue that goes against the contest details? The admin will likely never renounce this role.\n\nAnyways feel free to resolve this issue will respect your decision\n\n**Afriaudit**\n\nThe README(contest details) asked watsons to ensure the roles work properly. The only way watson can do this is to check each role against it permissioned function as described by the contest details, And this issue is describing a role which has access to a function its not permitted by the README. This indeed goes against the contest details.\n\n**WangSecurity**\n\n@nevillehuang fair point, but still it doesn't change the fact that in fact DEPOSIT_VAULT_ADMIN_ROLE/REDEMPTIOJ_VAULT_ADMIN_ROLE have more rights then stated in the README. And README specifically asked to check the roles being set properly. I agree it's low, but under rules, since it breaks assumption from the README, it indeed should be Medium.\n\nThe decision remains the same, reject the escalation and leave the issue as it is.\n\n**WangSecurity**\n\nResult:\nMedium\nHas duplicates\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [nevillehuang](https://github.com/sherlock-audit/2024-05-midas-judging/issues/112/#issuecomment-2155452077): rejected\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/332",
  "Code": [
    {
      "filename": "midas-contracts/contracts/access/Pausable.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"../access/WithMidasAccessControl.sol\";\n\n/**\n * @title Pausable\n * @notice Base contract that implements basic functions and modifiers\n * with pause functionality\n * @author RedDuck Software\n */\nabstract contract Pausable is WithMidasAccessControl, PausableUpgradeable {\n    /**\n     * @dev checks that a given `account`\n     * has a determinedPauseAdminRole\n     */\n    modifier onlyPauseAdmin() {\n        _onlyRole(pauseAdminRole(), msg.sender);\n        _;\n    }\n\n    /**\n     * @dev upgradeable pattern contract`s initializer\n     * @param _accessControl MidasAccessControl contract address\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __Pausable_init(address _accessControl) internal onlyInitializing {\n        __WithMidasAccessControl_init(_accessControl);\n    }\n\n    function pause() external onlyPauseAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyPauseAdmin {\n        _unpause();\n    }\n\n    /**\n     * @dev virtual function to determine pauseAdmin role\n     */\n    function pauseAdminRole() public view virtual returns (bytes32);\n}"
    },
    {
      "filename": "midas-contracts/contracts/abstract/ManageableVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {IERC20MetadataUpgradeable as IERC20Metadata} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n\nimport {SafeERC20Upgradeable as SafeERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {EnumerableSetUpgradeable as EnumerableSet} from \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\n\nimport \"../interfaces/IManageableVault.sol\";\nimport \"../interfaces/IMTbill.sol\";\nimport \"../interfaces/IDataFeed.sol\";\n\nimport \"../access/Greenlistable.sol\";\n\nimport \"../libraries/DecimalsCorrectionLibrary.sol\";\nimport \"../access/Pausable.sol\";\n\n/**\n * @title ManageableVault\n * @author RedDuck Software\n * @notice Contract with base Vault methods\n */\nabstract contract ManageableVault is Greenlistable, Pausable, IManageableVault {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using DecimalsCorrectionLibrary for uint256;\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice address that represents off-chain USD bank transfer\n     */\n    address public constant MANUAL_FULLFILMENT_TOKEN = address(0x0);\n\n    /**\n     * @notice 100 percent with base 100\n     * @dev for example, 10% will be (10 * 100)%\n     */\n    uint256 public constant ONE_HUNDRED_PERCENT = 100 * 100;\n    /**\n     * @notice mTBILL token\n     */\n    IMTbill public mTBILL;\n\n    /**\n     * @notice address to which USD and mTokens will be sent\n     */\n    address public tokensReceiver;\n\n    /**\n     * @dev tokens that can be used as USD representation\n     */\n    EnumerableSet.AddressSet internal _paymentTokens;\n\n    /**\n     * @dev checks that msg.sender do have a vaultRole() role\n     */\n    modifier onlyVaultAdmin() {\n        _onlyRole(vaultRole(), msg.sender);\n        _;\n    }\n\n    /**\n     * @dev upgradeable pattern contract`s initializer\n     * @param _ac address of MidasAccessControll contract\n     * @param _mTBILL address of mTBILL token\n     * @param _tokensReceiver address to which USD and mTokens will be sent\n     */\n    // solhint-disable func-name-mixedcase\n    function __ManageableVault_init(\n        address _ac,\n        address _mTBILL,\n        address _tokensReceiver\n    ) internal onlyInitializing {\n        require(_mTBILL != address(0), \"zero address\");\n        require(_tokensReceiver != address(0), \"zero address\");\n        require(_tokensReceiver != address(this), \"invalid address\");\n\n        mTBILL = IMTbill(_mTBILL);\n        __Greenlistable_init(_ac);\n        __Pausable_init(_ac);\n\n        tokensReceiver = _tokensReceiver;\n    }\n\n    /**\n     * @notice withdraws `amount` of a given `token` from the contract.\n     * can be called only from permissioned actor.\n     * @param token token address\n     * @param amount token amount\n     * @param withdrawTo withdraw destination address\n     */\n    function withdrawToken(\n        address token,\n        uint256 amount,\n        address withdrawTo\n    ) external onlyVaultAdmin {\n        IERC20(token).safeTransfer(withdrawTo, amount);\n\n        emit WithdrawToken(msg.sender, token, withdrawTo, amount);\n    }\n\n    /**\n     * @inheritdoc IManageableVault\n     * @dev reverts if token is already added\n     */\n    function addPaymentToken(address token) external onlyVaultAdmin {\n        require(_paymentTokens.add(token), \"MV: already added\");\n        emit AddPaymentToken(token, msg.sender);\n    }\n\n    /**\n     * @inheritdoc IManageableVault\n     * @dev reverts if token is not presented\n     */\n    function removePaymentToken(address token) external onlyVaultAdmin {\n        require(_paymentTokens.remove(token), \"MV: not exists\");\n        emit RemovePaymentToken(token, msg.sender);\n    }\n\n    /**\n     * @notice returns array of stablecoins supported by the vault\n     * can be called only from permissioned actor.\n     * @return paymentTokens array of payment tokens\n     */\n    function getPaymentTokens() external view returns (address[] memory) {\n        return _paymentTokens.values();\n    }\n\n    /**\n     * @notice AC role of vault administrator\n     * @return role bytes32 role\n     */\n    function vaultRole() public view virtual returns (bytes32);\n\n    /**\n     * @notice AC role of vault`s pauser\n     * @return role bytes32 role\n     */\n    function pauseAdminRole() public view override returns (bytes32) {\n        return vaultRole();\n    }\n\n    /**\n     * @dev do safeTransferFrom on a given token\n     * and converts `amount` from base18\n     * to amount with a correct precision. Sends tokens\n     * from `msg.sender` to `tokensReceiver`\n     * @param token address of token\n     * @param amount amount of `token` to transfer from `user`\n     */\n    function _tokenTransferFromUser(address token, uint256 amount) internal {\n        IERC20(token).safeTransferFrom(\n            msg.sender,\n            tokensReceiver,\n            amount.convertFromBase18(_tokenDecimals(token))\n        );\n    }\n\n    /**\n     * @dev retreives decimals of a given `token`\n     * @param token address of token\n     * @return decimals decinmals value of a given `token`\n     */\n    function _tokenDecimals(address token) internal view returns (uint8) {\n        return IERC20Metadata(token).decimals();\n    }\n\n    /**\n     * @dev checks that `token` is presented in `_paymentTokens`\n     * @param token address of token\n     */\n    function _requireTokenExists(address token) internal view virtual {\n        require(_paymentTokens.contains(token), \"MV: token not exists\");\n    }\n}"
    },
    {
      "filename": "midas-contracts/contracts/abstract/ManageableVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {IERC20MetadataUpgradeable as IERC20Metadata} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n\nimport {SafeERC20Upgradeable as SafeERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {EnumerableSetUpgradeable as EnumerableSet} from \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\n\nimport \"../interfaces/IManageableVault.sol\";\nimport \"../interfaces/IMTbill.sol\";\nimport \"../interfaces/IDataFeed.sol\";\n\nimport \"../access/Greenlistable.sol\";\n\nimport \"../libraries/DecimalsCorrectionLibrary.sol\";\nimport \"../access/Pausable.sol\";\n\n/**\n * @title ManageableVault\n * @author RedDuck Software\n * @notice Contract with base Vault methods\n */\nabstract contract ManageableVault is Greenlistable, Pausable, IManageableVault {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using DecimalsCorrectionLibrary for uint256;\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice address that represents off-chain USD bank transfer\n     */\n    address public constant MANUAL_FULLFILMENT_TOKEN = address(0x0);\n\n    /**\n     * @notice 100 percent with base 100\n     * @dev for example, 10% will be (10 * 100)%\n     */\n    uint256 public constant ONE_HUNDRED_PERCENT = 100 * 100;\n    /**\n     * @notice mTBILL token\n     */\n    IMTbill public mTBILL;\n\n    /**\n     * @notice address to which USD and mTokens will be sent\n     */\n    address public tokensReceiver;\n\n    /**\n     * @dev tokens that can be used as USD representation\n     */\n    EnumerableSet.AddressSet internal _paymentTokens;\n\n    /**\n     * @dev checks that msg.sender do have a vaultRole() role\n     */\n    modifier onlyVaultAdmin() {\n        _onlyRole(vaultRole(), msg.sender);\n        _;\n    }\n\n    /**\n     * @dev upgradeable pattern contract`s initializer\n     * @param _ac address of MidasAccessControll contract\n     * @param _mTBILL address of mTBILL token\n     * @param _tokensReceiver address to which USD and mTokens will be sent\n     */\n    // solhint-disable func-name-mixedcase\n    function __ManageableVault_init(\n        address _ac,\n        address _mTBILL,\n        address _tokensReceiver\n    ) internal onlyInitializing {\n        require(_mTBILL != address(0), \"zero address\");\n        require(_tokensReceiver != address(0), \"zero address\");\n        require(_tokensReceiver != address(this), \"invalid address\");\n\n        mTBILL = IMTbill(_mTBILL);\n        __Greenlistable_init(_ac);\n        __Pausable_init(_ac);\n\n        tokensReceiver = _tokensReceiver;\n    }\n\n    /**\n     * @notice withdraws `amount` of a given `token` from the contract.\n     * can be called only from permissioned actor.\n     * @param token token address\n     * @param amount token amount\n     * @param withdrawTo withdraw destination address\n     */\n    function withdrawToken(\n        address token,\n        uint256 amount,\n        address withdrawTo\n    ) external onlyVaultAdmin {\n        IERC20(token).safeTransfer(withdrawTo, amount);\n\n        emit WithdrawToken(msg.sender, token, withdrawTo, amount);\n    }\n\n    /**\n     * @inheritdoc IManageableVault\n     * @dev reverts if token is already added\n     */\n    function addPaymentToken(address token) external onlyVaultAdmin {\n        require(_paymentTokens.add(token), \"MV: already added\");\n        emit AddPaymentToken(token, msg.sender);\n    }\n\n    /**\n     * @inheritdoc IManageableVault\n     * @dev reverts if token is not presented\n     */\n    function removePaymentToken(address token) external onlyVaultAdmin {\n        require(_paymentTokens.remove(token), \"MV: not exists\");\n        emit RemovePaymentToken(token, msg.sender);\n    }\n\n    /**\n     * @notice returns array of stablecoins supported by the vault\n     * can be called only from permissioned actor.\n     * @return paymentTokens array of payment tokens\n     */\n    function getPaymentTokens() external view returns (address[] memory) {\n        return _paymentTokens.values();\n    }\n\n    /**\n     * @notice AC role of vault administrator\n     * @return role bytes32 role\n     */\n    function vaultRole() public view virtual returns (bytes32);\n\n    /**\n     * @notice AC role of vault`s pauser\n     * @return role bytes32 role\n     */\n    function pauseAdminRole() public view override returns (bytes32) {\n        return vaultRole();\n    }\n\n    /**\n     * @dev do safeTransferFrom on a given token\n     * and converts `amount` from base18\n     * to amount with a correct precision. Sends tokens\n     * from `msg.sender` to `tokensReceiver`\n     * @param token address of token\n     * @param amount amount of `token` to transfer from `user`\n     */\n    function _tokenTransferFromUser(address token, uint256 amount) internal {\n        IERC20(token).safeTransferFrom(\n            msg.sender,\n            tokensReceiver,\n            amount.convertFromBase18(_tokenDecimals(token))\n        );\n    }\n\n    /**\n     * @dev retreives decimals of a given `token`\n     * @param token address of token\n     * @return decimals decinmals value of a given `token`\n     */\n    function _tokenDecimals(address token) internal view returns (uint8) {\n        return IERC20Metadata(token).decimals();\n    }\n\n    /**\n     * @dev checks that `token` is presented in `_paymentTokens`\n     * @param token address of token\n     */\n    function _requireTokenExists(address token) internal view virtual {\n        require(_paymentTokens.contains(token), \"MV: token not exists\");\n    }\n}"
    },
    {
      "filename": "midas-contracts/contracts/access/Pausable.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"../access/WithMidasAccessControl.sol\";\n\n/**\n * @title Pausable\n * @notice Base contract that implements basic functions and modifiers\n * with pause functionality\n * @author RedDuck Software\n */\nabstract contract Pausable is WithMidasAccessControl, PausableUpgradeable {\n    /**\n     * @dev checks that a given `account`\n     * has a determinedPauseAdminRole\n     */\n    modifier onlyPauseAdmin() {\n        _onlyRole(pauseAdminRole(), msg.sender);\n        _;\n    }\n\n    /**\n     * @dev upgradeable pattern contract`s initializer\n     * @param _accessControl MidasAccessControl contract address\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __Pausable_init(address _accessControl) internal onlyInitializing {\n        __WithMidasAccessControl_init(_accessControl);\n    }\n\n    function pause() external onlyPauseAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyPauseAdmin {\n        _unpause();\n    }\n\n    /**\n     * @dev virtual function to determine pauseAdmin role\n     */\n    function pauseAdminRole() public view virtual returns (bytes32);\n}"
    }
  ]
}