{
  "Title": "Missing Deadline Check for Functions Which Call Uniswap v3 FlashSwap",
  "Content": "There is no option to set a `deadline` for the [`flashswapLeverage`](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/flash/handlers/base/UniswapFlashswapHandler.sol#L82), [`flashswapDeleverage`](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/flash/handlers/base/UniswapFlashswapHandler.sol#L127), [`flashLeverageWethAndSwap`](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/flash/handlers/base/UniswapFlashloanBalancerSwapHandler.sol#L59) and [`flashDeleverageWethAndSwap`](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/flash/handlers/base/UniswapFlashloanBalancerSwapHandler.sol#L115) functions. The transaction can still be stuck in the mempool and be executed a long time after the transaction is initially called. During this time, the price in the Uniswap pool can change. In this case, the slippage parameters can become outdated and the swap will become vulnerable to sandwich attacks.\n\n\nConsider adding a deadline check to the [`flashswapLeverage`](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/flash/handlers/base/UniswapFlashswapHandler.sol#L82), [`flashswapDeleverage`](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/flash/handlers/base/UniswapFlashswapHandler.sol#L127), [`flashLeverageWethAndSwap`](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/flash/handlers/base/UniswapFlashloanBalancerSwapHandler.sol#L59) and [`flashDeleverageWethAndSwap`](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/flash/handlers/base/UniswapFlashloanBalancerSwapHandler.sol#L115) functions.\n\n\n***Update:** Resolved in [pull request #25](https://github.com/Ion-Protocol/ion-protocol/pull/25).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/flash/handlers/base/UniswapFlashswapHandler.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IonHandlerBase } from \"./IonHandlerBase.sol\";\nimport { WadRayMath } from \"src/libraries/math/WadRayMath.sol\";\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IUniswapV3Pool } from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport { IUniswapV3Factory } from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\";\nimport { IUniswapV3SwapCallback } from \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\";\n\n/**\n * @dev When using the `UniswapFlashSwapHandler`, the `IUniswapV3Pool pool` fed to the\n * constructor should be the WETH/[LST] pool.\n *\n * Unlike Balancer flashloans, there is no concern here that somebody else could\n * initiate a flashswap, then direct the callback to be called on this contract.\n * Uniswap enforces that callback is only called on `msg.sender`.\n */\nabstract contract UniswapFlashswapHandler is IonHandlerBase, IUniswapV3SwapCallback {\n    using WadRayMath for *;\n    using SafeCast for uint256;\n    using SafeERC20 for IERC20;\n\n    error InvalidFactoryAddress();\n    error InvalidUniswapPool();\n    error InvalidZeroLiquidityRegionSwap();\n\n    error ExternalFlashswapNotAllowed();\n    error FlashswapRepaymentTooExpensive(uint256 amountIn, uint256 maxAmountIn);\n    error CallbackOnlyCallableByPool(address unauthorizedCaller);\n    error InsufficientBalance(uint256 necessaryBalance, uint256 currentBalance);\n    error OutputAmountNotReceived(uint256 amountReceived, uint256 amountRequired);\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4_295_128_739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1_461_446_703_485_210_103_287_273_052_203_988_822_378_723_970_342;\n\n    IUniswapV3Factory immutable FACTORY;\n    IUniswapV3Pool immutable UNISWAP_POOL;\n    bool immutable WETH_IS_TOKEN0;\n    uint24 immutable POOL_FEE;\n\n    constructor(IUniswapV3Factory _factory, IUniswapV3Pool _pool, uint24 _poolFee, bool _wethIsToken0) {\n        if (address(_factory) == address(0)) revert InvalidFactoryAddress();\n        if (address(_pool) == address(0)) revert InvalidUniswapPool();\n\n        address token0 = _pool.token0();\n        address token1 = _pool.token1();\n\n        if (token0 != address(WETH) && token1 != address(WETH)) revert InvalidUniswapPool();\n\n        FACTORY = _factory;\n        UNISWAP_POOL = _pool;\n        WETH_IS_TOKEN0 = _wethIsToken0;\n        POOL_FEE = _poolFee;\n    }\n\n    struct FlashSwapData {\n        address user;\n        // This value will be used for change in collateral during leveraging and change in (normalized) debt during\n        // deleveraging\n        uint256 changeInCollateralOrDebt;\n        bool zeroForOne;\n    }\n\n    /**\n     *\n     * @param initialDeposit in terms of swEth\n     * @param resultingAdditionalCollateral in terms of swEth. How much\n     * collateral to add to the position in the vault.\n     * @param maxResultingAdditionalDebt in terms of WETH. How much debt to add\n     * to the position in the vault.\n     * @param sqrtPriceLimitX96 for the swap. Recommended value is the current\n     * exchange rate to ensure the swap never costs more than a direct mint\n     * would.\n     */\n    function flashswapLeverage(\n        uint256 initialDeposit,\n        uint256 resultingAdditionalCollateral,\n        uint256 maxResultingAdditionalDebt,\n        uint160 sqrtPriceLimitX96\n    )\n        external\n    {\n        LST_TOKEN.safeTransferFrom(msg.sender, address(this), initialDeposit);\n\n        uint256 amountToLeverage = resultingAdditionalCollateral - initialDeposit; // in swEth\n\n        if (amountToLeverage == 0) {\n            // AmountToBorrow.IS_MAX because we don't want to create any new debt here\n            _depositAndBorrow(msg.sender, address(this), resultingAdditionalCollateral, 0, AmountToBorrow.IS_MAX);\n            return;\n        }\n\n        // Flashswap WETH for collateral. We will return the WETH inside the Uniswap\n        // callback\n        // zeroForOne is WETH -> collateral\n        bool zeroForOne = WETH_IS_TOKEN0;\n\n        FlashSwapData memory flashswapData = FlashSwapData({\n            user: msg.sender,\n            changeInCollateralOrDebt: resultingAdditionalCollateral,\n            zeroForOne: zeroForOne\n        });\n\n        uint256 amountIn =\n            _initiateFlashSwap(zeroForOne, amountToLeverage, address(this), sqrtPriceLimitX96, flashswapData);\n\n        // This protects against a potential sandwhich attack\n        if (amountIn > maxResultingAdditionalDebt) {\n            revert FlashswapRepaymentTooExpensive(amountIn, maxResultingAdditionalDebt);\n        }\n    }\n\n    /**\n     * @dev The two function parameters must be chosen carefully. If `maxCollateralToRemove` were higher then\n     * `debtToRemove`, it would theoretically be possible TODO: to do what?\n     * @param maxCollateralToRemove in terms of swEth\n     * @param debtToRemove in terms of WETH [wad]\n     * @param sqrtPriceLimitX96 for the swap\n     */\n    function flashswapDeleverage(\n        uint256 maxCollateralToRemove,\n        uint256 debtToRemove,\n        uint160 sqrtPriceLimitX96\n    )\n        external\n    {\n        if (debtToRemove == 0) return;\n\n        // collateral -> WETH\n        bool zeroForOne = !WETH_IS_TOKEN0;\n\n        FlashSwapData memory flashswapData =\n            FlashSwapData({ user: msg.sender, changeInCollateralOrDebt: debtToRemove, zeroForOne: zeroForOne });\n\n        uint256 amountIn = _initiateFlashSwap(zeroForOne, debtToRemove, address(this), sqrtPriceLimitX96, flashswapData);\n\n        if (amountIn > maxCollateralToRemove) revert FlashswapRepaymentTooExpensive(amountIn, maxCollateralToRemove);\n    }\n\n    function _initiateFlashSwap(\n        bool zeroForOne,\n        uint256 amountOut,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        FlashSwapData memory data\n    )\n        private\n        returns (uint256 amountIn)\n    {\n        (int256 amount0Delta, int256 amount1Delta) = UNISWAP_POOL.swap(\n            recipient,\n            zeroForOne,\n            -amountOut.toInt256(),\n            sqrtPriceLimitX96 == 0 ? (zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1) : sqrtPriceLimitX96,\n            abi.encode(data)\n        );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n\n        // it's technically possible to not receive the full output amount,\n        // so if no price limit has been specified, require this possibility away\n        if (sqrtPriceLimitX96 == 0 && amountOutReceived != amountOut) {\n            revert OutputAmountNotReceived(amountOutReceived, amountOut);\n        }\n    }\n\n    /**\n     * @dev From the perspective of the pool i.e. Negative amount means pool is\n     * sending. This function is intended to never be called directly. It should\n     * only be called by the Uniswap pool during a swap initiated by this\n     * contract.\n     *\n     * One thing to note from a security perspective is that the pool only calls\n     * the callback on `msg.sender`. So a theoretical attacker cannot call this\n     * function by directing where to call the callback.\n     *\n     * @param amount0Delta change in token0\n     * @param amount1Delta change in token1\n     * @param _data arbitrary data\n     */\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata _data) external override {\n        if (msg.sender != address(UNISWAP_POOL)) revert CallbackOnlyCallableByPool(msg.sender);\n\n        // swaps entirely within 0-liquidity regions are not supported\n        if (amount0Delta == 0 && amount1Delta == 0) revert InvalidZeroLiquidityRegionSwap();\n        FlashSwapData memory data = abi.decode(_data, (FlashSwapData));\n\n        (address tokenIn, address tokenOut) =\n            data.zeroForOne ? (address(WETH), address(LST_TOKEN)) : (address(LST_TOKEN), address(WETH));\n\n        // Code below this if statement will always assume token0 is WETH. If it\n        // is not actually the case, we will flip the vars\n        if (!WETH_IS_TOKEN0) {\n            (amount0Delta, amount1Delta) = (amount1Delta, amount0Delta);\n            (tokenIn, tokenOut) = (tokenOut, tokenIn);\n        }\n\n        uint256 amountToPay;\n        if (amount0Delta > 0) {\n            amountToPay = uint256(amount0Delta);\n\n            // Received `amountToLeverage` collateral from flashswap, will borrow\n            // necessary WETH from IonPool position to pay back flashswap\n\n            // AmountToBorrow.IS_MIN because we want to make sure enough is borrowed to cover flashloan\n            _depositAndBorrow(\n                data.user, address(this), data.changeInCollateralOrDebt, amountToPay, AmountToBorrow.IS_MIN\n            );\n        } else {\n            amountToPay = uint256(amount1Delta);\n\n            // Received `debtToRemove` WETH from flashswap, will\n            // withdraw necessary collateral from IonPool position to pay back flashswap\n            _repayAndWithdraw(data.user, address(this), amountToPay, data.changeInCollateralOrDebt);\n        }\n\n        IERC20(tokenIn).safeTransfer(msg.sender, amountToPay);\n    }\n}"
    },
    {
      "filename": "src/flash/handlers/base/UniswapFlashswapHandler.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IonHandlerBase } from \"./IonHandlerBase.sol\";\nimport { WadRayMath } from \"src/libraries/math/WadRayMath.sol\";\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IUniswapV3Pool } from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport { IUniswapV3Factory } from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\";\nimport { IUniswapV3SwapCallback } from \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\";\n\n/**\n * @dev When using the `UniswapFlashSwapHandler`, the `IUniswapV3Pool pool` fed to the\n * constructor should be the WETH/[LST] pool.\n *\n * Unlike Balancer flashloans, there is no concern here that somebody else could\n * initiate a flashswap, then direct the callback to be called on this contract.\n * Uniswap enforces that callback is only called on `msg.sender`.\n */\nabstract contract UniswapFlashswapHandler is IonHandlerBase, IUniswapV3SwapCallback {\n    using WadRayMath for *;\n    using SafeCast for uint256;\n    using SafeERC20 for IERC20;\n\n    error InvalidFactoryAddress();\n    error InvalidUniswapPool();\n    error InvalidZeroLiquidityRegionSwap();\n\n    error ExternalFlashswapNotAllowed();\n    error FlashswapRepaymentTooExpensive(uint256 amountIn, uint256 maxAmountIn);\n    error CallbackOnlyCallableByPool(address unauthorizedCaller);\n    error InsufficientBalance(uint256 necessaryBalance, uint256 currentBalance);\n    error OutputAmountNotReceived(uint256 amountReceived, uint256 amountRequired);\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4_295_128_739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1_461_446_703_485_210_103_287_273_052_203_988_822_378_723_970_342;\n\n    IUniswapV3Factory immutable FACTORY;\n    IUniswapV3Pool immutable UNISWAP_POOL;\n    bool immutable WETH_IS_TOKEN0;\n    uint24 immutable POOL_FEE;\n\n    constructor(IUniswapV3Factory _factory, IUniswapV3Pool _pool, uint24 _poolFee, bool _wethIsToken0) {\n        if (address(_factory) == address(0)) revert InvalidFactoryAddress();\n        if (address(_pool) == address(0)) revert InvalidUniswapPool();\n\n        address token0 = _pool.token0();\n        address token1 = _pool.token1();\n\n        if (token0 != address(WETH) && token1 != address(WETH)) revert InvalidUniswapPool();\n\n        FACTORY = _factory;\n        UNISWAP_POOL = _pool;\n        WETH_IS_TOKEN0 = _wethIsToken0;\n        POOL_FEE = _poolFee;\n    }\n\n    struct FlashSwapData {\n        address user;\n        // This value will be used for change in collateral during leveraging and change in (normalized) debt during\n        // deleveraging\n        uint256 changeInCollateralOrDebt;\n        bool zeroForOne;\n    }\n\n    /**\n     *\n     * @param initialDeposit in terms of swEth\n     * @param resultingAdditionalCollateral in terms of swEth. How much\n     * collateral to add to the position in the vault.\n     * @param maxResultingAdditionalDebt in terms of WETH. How much debt to add\n     * to the position in the vault.\n     * @param sqrtPriceLimitX96 for the swap. Recommended value is the current\n     * exchange rate to ensure the swap never costs more than a direct mint\n     * would.\n     */\n    function flashswapLeverage(\n        uint256 initialDeposit,\n        uint256 resultingAdditionalCollateral,\n        uint256 maxResultingAdditionalDebt,\n        uint160 sqrtPriceLimitX96\n    )\n        external\n    {\n        LST_TOKEN.safeTransferFrom(msg.sender, address(this), initialDeposit);\n\n        uint256 amountToLeverage = resultingAdditionalCollateral - initialDeposit; // in swEth\n\n        if (amountToLeverage == 0) {\n            // AmountToBorrow.IS_MAX because we don't want to create any new debt here\n            _depositAndBorrow(msg.sender, address(this), resultingAdditionalCollateral, 0, AmountToBorrow.IS_MAX);\n            return;\n        }\n\n        // Flashswap WETH for collateral. We will return the WETH inside the Uniswap\n        // callback\n        // zeroForOne is WETH -> collateral\n        bool zeroForOne = WETH_IS_TOKEN0;\n\n        FlashSwapData memory flashswapData = FlashSwapData({\n            user: msg.sender,\n            changeInCollateralOrDebt: resultingAdditionalCollateral,\n            zeroForOne: zeroForOne\n        });\n\n        uint256 amountIn =\n            _initiateFlashSwap(zeroForOne, amountToLeverage, address(this), sqrtPriceLimitX96, flashswapData);\n\n        // This protects against a potential sandwhich attack\n        if (amountIn > maxResultingAdditionalDebt) {\n            revert FlashswapRepaymentTooExpensive(amountIn, maxResultingAdditionalDebt);\n        }\n    }\n\n    /**\n     * @dev The two function parameters must be chosen carefully. If `maxCollateralToRemove` were higher then\n     * `debtToRemove`, it would theoretically be possible TODO: to do what?\n     * @param maxCollateralToRemove in terms of swEth\n     * @param debtToRemove in terms of WETH [wad]\n     * @param sqrtPriceLimitX96 for the swap\n     */\n    function flashswapDeleverage(\n        uint256 maxCollateralToRemove,\n        uint256 debtToRemove,\n        uint160 sqrtPriceLimitX96\n    )\n        external\n    {\n        if (debtToRemove == 0) return;\n\n        // collateral -> WETH\n        bool zeroForOne = !WETH_IS_TOKEN0;\n\n        FlashSwapData memory flashswapData =\n            FlashSwapData({ user: msg.sender, changeInCollateralOrDebt: debtToRemove, zeroForOne: zeroForOne });\n\n        uint256 amountIn = _initiateFlashSwap(zeroForOne, debtToRemove, address(this), sqrtPriceLimitX96, flashswapData);\n\n        if (amountIn > maxCollateralToRemove) revert FlashswapRepaymentTooExpensive(amountIn, maxCollateralToRemove);\n    }\n\n    function _initiateFlashSwap(\n        bool zeroForOne,\n        uint256 amountOut,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        FlashSwapData memory data\n    )\n        private\n        returns (uint256 amountIn)\n    {\n        (int256 amount0Delta, int256 amount1Delta) = UNISWAP_POOL.swap(\n            recipient,\n            zeroForOne,\n            -amountOut.toInt256(),\n            sqrtPriceLimitX96 == 0 ? (zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1) : sqrtPriceLimitX96,\n            abi.encode(data)\n        );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n\n        // it's technically possible to not receive the full output amount,\n        // so if no price limit has been specified, require this possibility away\n        if (sqrtPriceLimitX96 == 0 && amountOutReceived != amountOut) {\n            revert OutputAmountNotReceived(amountOutReceived, amountOut);\n        }\n    }\n\n    /**\n     * @dev From the perspective of the pool i.e. Negative amount means pool is\n     * sending. This function is intended to never be called directly. It should\n     * only be called by the Uniswap pool during a swap initiated by this\n     * contract.\n     *\n     * One thing to note from a security perspective is that the pool only calls\n     * the callback on `msg.sender`. So a theoretical attacker cannot call this\n     * function by directing where to call the callback.\n     *\n     * @param amount0Delta change in token0\n     * @param amount1Delta change in token1\n     * @param _data arbitrary data\n     */\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata _data) external override {\n        if (msg.sender != address(UNISWAP_POOL)) revert CallbackOnlyCallableByPool(msg.sender);\n\n        // swaps entirely within 0-liquidity regions are not supported\n        if (amount0Delta == 0 && amount1Delta == 0) revert InvalidZeroLiquidityRegionSwap();\n        FlashSwapData memory data = abi.decode(_data, (FlashSwapData));\n\n        (address tokenIn, address tokenOut) =\n            data.zeroForOne ? (address(WETH), address(LST_TOKEN)) : (address(LST_TOKEN), address(WETH));\n\n        // Code below this if statement will always assume token0 is WETH. If it\n        // is not actually the case, we will flip the vars\n        if (!WETH_IS_TOKEN0) {\n            (amount0Delta, amount1Delta) = (amount1Delta, amount0Delta);\n            (tokenIn, tokenOut) = (tokenOut, tokenIn);\n        }\n\n        uint256 amountToPay;\n        if (amount0Delta > 0) {\n            amountToPay = uint256(amount0Delta);\n\n            // Received `amountToLeverage` collateral from flashswap, will borrow\n            // necessary WETH from IonPool position to pay back flashswap\n\n            // AmountToBorrow.IS_MIN because we want to make sure enough is borrowed to cover flashloan\n            _depositAndBorrow(\n                data.user, address(this), data.changeInCollateralOrDebt, amountToPay, AmountToBorrow.IS_MIN\n            );\n        } else {\n            amountToPay = uint256(amount1Delta);\n\n            // Received `debtToRemove` WETH from flashswap, will\n            // withdraw necessary collateral from IonPool position to pay back flashswap\n            _repayAndWithdraw(data.user, address(this), amountToPay, data.changeInCollateralOrDebt);\n        }\n\n        IERC20(tokenIn).safeTransfer(msg.sender, amountToPay);\n    }\n}"
    }
  ]
}