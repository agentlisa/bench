{
  "Title": "[L07] Misleading comments",
  "Content": "The following comments are potentially misleading or errant:\n\n\n* Throughout [`AggregatorOracle.sol`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/oracle/AggregatorOracle.sol) there are comments that say `maxPriceDeviation` is [measured in basis points](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/oracle/AggregatorOracle.sol#L24). However, it is not. It is a number between `1e18` and `1.5e18`, where `1e18` is 0% price deviation accepted, and `1.5e18` is 50% price deviation accepted.\n* [Lines 127 and 128 of `ProxyOracle.sol`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/oracle/ProxyOracle.sol#L127-L128) should each say `ERC20` not `ERC1155`.\n\n\nConsider correcting these comments to improve the readability of the codebase and reduce unnecessary confusion.\n\n\n***Update:** Fixed in [PR#102](https://github.com/AlphaFinanceLab/homora-v2/pull/102).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/oracle/ProxyOracle.sol",
      "content": "pragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/math/SafeMath.sol';\n\nimport '../Governable.sol';\nimport '../../interfaces/IOracle.sol';\nimport '../../interfaces/IBaseOracle.sol';\nimport '../../interfaces/IERC20Wrapper.sol';\n\ncontract ProxyOracle is IOracle, Governable {\n  using SafeMath for uint;\n\n  /// The governor sets oracle information for a token.\n  event SetOracle(address token, Oracle info);\n  /// The governor unsets oracle information for a token.\n  event UnsetOracle(address token);\n  /// The governor sets token whitelist for an ERC1155 token.\n  event SetWhitelist(address token, bool ok);\n\n  struct Oracle {\n    uint16 borrowFactor; // The borrow factor for this token, multiplied by 1e4.\n    uint16 collateralFactor; // The collateral factor for this token, multiplied by 1e4.\n    uint16 liqIncentive; // The liquidation incentive, multiplied by 1e4.\n  }\n\n  IBaseOracle public immutable source; // Main oracle source\n  mapping(address => Oracle) public oracles; // Mapping from token address to oracle info.\n  mapping(address => bool) public whitelistERC1155; // Mapping from token address to whitelist status\n\n  /// @dev Create the contract and initialize the first governor.\n  constructor(IBaseOracle _source) public {\n    source = _source;\n    __Governable__init();\n  }\n\n  /// @dev Set oracle information for the given list of token addresses.\n  /// @param tokens List of tokens to set info\n  /// @param info List of oracle info\n  function setOracles(address[] memory tokens, Oracle[] memory info) external onlyGov {\n    require(tokens.length == info.length, 'inconsistent length');\n    for (uint idx = 0; idx < tokens.length; idx++) {\n      require(info[idx].borrowFactor >= 10000, 'borrow factor must be at least 100%');\n      require(info[idx].collateralFactor <= 10000, 'collateral factor must be at most 100%');\n      require(info[idx].liqIncentive >= 10000, 'incentive must be at least 100%');\n      require(info[idx].liqIncentive <= 20000, 'incentive must be at most 200%');\n      oracles[tokens[idx]] = info[idx];\n      emit SetOracle(tokens[idx], info[idx]);\n    }\n  }\n\n  /// @dev Unset oracle information for the given list of token addresses\n  /// @param tokens List of tokens to unset info\n  function unsetOracles(address[] memory tokens) external onlyGov {\n    for (uint idx = 0; idx < tokens.length; idx++) {\n      oracles[tokens[idx]] = Oracle(0, 0, 0);\n      emit UnsetOracle(tokens[idx]);\n    }\n  }\n\n  /// @dev Set whitelist status for the given list of token addresses.\n  /// @param tokens List of tokens to set whitelist status\n  /// @param ok Whitelist status\n  function setWhitelistERC1155(address[] memory tokens, bool ok) external onlyGov {\n    for (uint idx = 0; idx < tokens.length; idx++) {\n      whitelistERC1155[tokens[idx]] = ok;\n      emit SetWhitelist(tokens[idx], ok);\n    }\n  }\n\n  /// @dev Return whether the oracle supports evaluating collateral value of the given token.\n  /// @param token Token address to check for support\n  /// @param id Token id to check for support\n  function support(address token, uint id) external view override returns (bool) {\n    if (!whitelistERC1155[token]) return false;\n    address tokenUnderlying = IERC20Wrapper(token).getUnderlyingToken(id);\n    return oracles[tokenUnderlying].liqIncentive != 0;\n  }\n\n  /// @dev Return the amount of token out as liquidation reward for liquidating token in.\n  /// @param tokenIn Input ERC20 token\n  /// @param tokenOut Output ERC1155 token\n  /// @param tokenOutId Output ERC1155 token id\n  /// @param amountIn Input ERC20 token amount\n  function convertForLiquidation(\n    address tokenIn,\n    address tokenOut,\n    uint tokenOutId,\n    uint amountIn\n  ) external view override returns (uint) {\n    require(whitelistERC1155[tokenOut], 'bad token');\n    address tokenOutUnderlying = IERC20Wrapper(tokenOut).getUnderlyingToken(tokenOutId);\n    uint rateUnderlying = IERC20Wrapper(tokenOut).getUnderlyingRate(tokenOutId);\n    Oracle memory oracleIn = oracles[tokenIn];\n    Oracle memory oracleOut = oracles[tokenOutUnderlying];\n    require(oracleIn.liqIncentive != 0, 'bad underlying in');\n    require(oracleOut.liqIncentive != 0, 'bad underlying out');\n    uint pxIn = source.getETHPx(tokenIn);\n    uint pxOut = source.getETHPx(tokenOutUnderlying);\n    uint amountOut = amountIn.mul(pxIn).div(pxOut);\n    amountOut = amountOut.mul(2**112).div(rateUnderlying);\n    return amountOut.mul(oracleIn.liqIncentive).mul(oracleOut.liqIncentive).div(10000 * 10000);\n  }\n\n  /// @dev Return the value of the given input as ETH for collateral purpose.\n  /// @param token ERC1155 token address to get collateral value\n  /// @param id ERC1155 token id to get collateral value\n  /// @param amount Token amount to get collateral value\n  /// @param owner Token owner address (currently unused by this implementation)\n  function asETHCollateral(\n    address token,\n    uint id,\n    uint amount,\n    address owner\n  ) external view override returns (uint) {\n    require(whitelistERC1155[token], 'bad token');\n    address tokenUnderlying = IERC20Wrapper(token).getUnderlyingToken(id);\n    uint rateUnderlying = IERC20Wrapper(token).getUnderlyingRate(id);\n    uint amountUnderlying = amount.mul(rateUnderlying).div(2**112);\n    Oracle memory oracle = oracles[tokenUnderlying];\n    require(oracle.liqIncentive != 0, 'bad underlying collateral');\n    uint ethValue = source.getETHPx(tokenUnderlying).mul(amountUnderlying).div(2**112);\n    return ethValue.mul(oracle.collateralFactor).div(10000);\n  }\n\n  /// @dev Return the value of the given input as ETH for borrow purpose.\n  /// @param token ERC1155 token address to get borrow value\n  /// @param amount ERC1155 token amount to get borrow value\n  /// @param owner Token owner address (currently unused by this implementation)\n  function asETHBorrow(\n    address token,\n    uint amount,\n    address owner\n  ) external view override returns (uint) {\n    Oracle memory oracle = oracles[token];\n    require(oracle.liqIncentive != 0, 'bad underlying borrow');\n    uint ethValue = source.getETHPx(token).mul(amount).div(2**112);\n    return ethValue.mul(oracle.borrowFactor).div(10000);\n  }\n}"
    }
  ]
}