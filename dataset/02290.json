{
  "Title": "M-6: The Hats contract needs to override the ERC1155.balanceOfBatch function",
  "Content": "# Issue M-6: The Hats contract needs to override the ERC1155.balanceOfBatch function \n\nSource: https://github.com/sherlock-audit/2023-02-hats-judging/issues/85 \n\n## Found by \ncccz, ktg, roguereddwarf, GimelSec\n\n## Summary\nThe Hats contract does not override the ERC1155.balanceOfBatch function\n## Vulnerability Detail\nThe Hats contract overrides the ERC1155.balanceOf function to return a balance of 0 when the hat is inactive or the wearer is ineligible.\n```solidity\n    function balanceOf(address _wearer, uint256 _hatId)\n        public\n        view\n        override(ERC1155, IHats)\n        returns (uint256 balance)\n    {\n        Hat storage hat = _hats[_hatId];\n\n        balance = 0;\n\n        if (_isActive(hat, _hatId) && _isEligible(_wearer, hat, _hatId)) {\n            balance = super.balanceOf(_wearer, _hatId);\n        }\n    }\n```\nBut the Hats contract does not override the ERC1155.balanceOfBatch function, which causes balanceOfBatch to return the actual balance no matter what the circumstances.\n```solidity\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, \"LENGTH_MISMATCH\");\n\n        balances = new uint256[](owners.length);\n\n        // Unchecked because the only math done is incrementing\n        // the array index counter which cannot possibly overflow.\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = _balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n```\n## Impact\nThis will make balanceOfBatch return a different result than balanceOf, which may cause errors when integrating with other projects\n## Code Snippet\nhttps://github.com/Hats-Protocol/hats-protocol/blob/main/src/Hats.sol#L1149-L1162\nhttps://github.com/Hats-Protocol/hats-protocol/blob/main/lib/ERC1155/ERC1155.sol#L118-L139\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider overriding the ERC1155.balanceOfBatch function in Hats contract to return 0 when the hat is inactive or the wearer is ineligible.\n\n## Discussion\n\n**spengrah**\n\nhttps://github.com/Hats-Protocol/hats-protocol/pull/102\n\n**zobront**\n\nReverting solves the problem, but I'm curious why revert instead of just replacing:\n\n```solidity\nbalances[i] = _balanceOf[owners[i]][ids[i]];\n```\n\nwith...\n```solidity\nbalances[i] = balanceOf(owners[i], ids[i]);\n```\n\n**zobront**\n\nReverting solves the problem, but I'm curious why revert instead of just replacing:\n\n```solidity\nbalances[i] = _balanceOf[owners[i]][ids[i]];\n```\n\nwith...\n```solidity\nbalances[i] = balanceOf(owners[i], ids[i]);\n```\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/48",
  "Code": [
    {
      "filename": "src/Hats.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\n// Copyright (C) 2023 Haberdasher Labs\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.13;\n\nimport { ERC1155 } from \"lib/ERC1155/ERC1155.sol\";\n// import { console2 } from \"forge-std/Test.sol\"; //remove after testing\nimport \"./Interfaces/IHats.sol\";\nimport \"./HatsIdUtilities.sol\";\nimport \"./Interfaces/IHatsToggle.sol\";\nimport \"./Interfaces/IHatsEligibility.sol\";\nimport \"solbase/utils/Base64.sol\";\nimport \"solbase/utils/LibString.sol\";\nimport \"solady/utils/Multicallable.sol\";\n\n/// @title Hats Protocol v1\n/// @notice Hats are DAO-native, revocable, and programmable roles that are represented as non-transferable ERC-1155-similar tokens for composability\n/// @dev This is a multi-tenant contract that can manage all hats for a given chain. While it fully implements the ERC1155 interface, it does not fully comply with the ERC1155 standard.\n/// @author Haberdasher Labs\ncontract Hats is IHats, ERC1155, Multicallable, HatsIdUtilities {\n    /// @notice This contract's version is labeled v1. Previous versions labeled similarly as v1 and v1.0 are deprecated,\n    ///         and should be treated as beta deployments.\n\n    /*//////////////////////////////////////////////////////////////\n                              HATS DATA MODELS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice A Hat object containing the hat's properties\n    /// @dev The members are packed to minimize storage costs\n    /// @custom:member eligibility Module that rules on wearer eligibiliy and standing\n    /// @custom:member maxSupply The max number of hats with this id that can exist\n    /// @custom:member supply The number of this hat that currently exist\n    /// @custom:member lastHatId Indexes how many different child hats an admin has\n    /// @custom:member toggle Module that sets the hat's status\n    /**\n     * @custom:member config Holds status and other settings, with this bitwise schema:\n     *\n     *  0th bit  | `active` status; can be altered by toggle\n     *  1        | `mutable` setting\n     *  2 - 95   | unassigned\n     */\n    /// @custom:member details Holds arbitrary metadata about the hat\n    /// @custom:member imageURI A uri pointing to an image for the hat\n    struct Hat {\n        // 1st storage slot\n        address eligibility; // ─┐ 20\n        uint32 maxSupply; //     │ 4\n        uint32 supply; //        │ 4\n        uint16 lastHatId; //    ─┘ 2\n        // 2nd slot\n        address toggle; //      ─┐ 20\n        uint96 config; //       ─┘ 12\n        // 3rd+ slot (optional)\n        string details;\n        string imageURI;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              HATS STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The name of the contract, typically including the version\n    string public name;\n\n    /// @notice The first 4 bytes of the id of the last tophat created.\n    uint32 public lastTopHatId; // first tophat id starts at 1\n\n    /// @notice The fallback image URI for hat tokens with no `imageURI` specified in their branch\n    string public baseImageURI;\n\n    /// @dev Internal mapping of hats to hat ids. See HatsIdUtilities.sol for more info on how hat ids work\n    mapping(uint256 => Hat) internal _hats; // key: hatId => value: Hat struct\n\n    /// @notice Mapping of wearers in bad standing for certain hats\n    /// @dev Used by external contracts to trigger penalties for wearers in bad standing\n    ///      hatId => wearer => !standing\n    mapping(uint256 => mapping(address => bool)) public badStandings;\n\n    /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice All arguments are immutable; they can only be set once during construction\n    /// @param _name The name of this contract, typically including the version\n    /// @param _baseImageURI The fallback image URI\n    constructor(string memory _name, string memory _baseImageURI) {\n        name = _name;\n        baseImageURI = _baseImageURI;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              HATS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Creates and mints a Hat that is its own admin, i.e. a \"topHat\"\n    /// @dev A topHat has no eligibility and no toggle\n    /// @param _target The address to which the newly created topHat is minted\n    /// @param _details A description of the Hat [optional]. Should not be larger than 7000 bytes\n    ///                 (enforced in changeHatDetails)\n    /// @param _imageURI The image uri for this top hat and the fallback for its\n    ///                  downstream hats [optional]. Should not be large than 7000 bytes\n    ///                  (enforced in changeHatImageURI)\n    /// @return topHatId The id of the newly created topHat\n    function mintTopHat(address _target, string calldata _details, string calldata _imageURI)\n        public\n        returns (uint256 topHatId)\n    {\n        // create hat\n\n        topHatId = uint256(++lastTopHatId) << 224;\n\n        _createHat(\n            topHatId,\n            _details, // details\n            1, // maxSupply = 1\n            address(0), // there is no eligibility\n            address(0), // it has no toggle\n            false, // its immutable\n            _imageURI\n        );\n\n        _mintHat(_target, topHatId);\n    }\n\n    /// @notice Creates a new hat. The msg.sender must wear the `_admin` hat.\n    /// @dev Initializes a new Hat struct, but does not mint any tokens.\n    /// @param _details A description of the Hat. Should not be larger than 7000 bytes (enforced in changeHatDetails)\n    /// @param _maxSupply The total instances of the Hat that can be worn at once\n    /// @param _admin The id of the Hat that will control who wears the newly created hat\n    /// @param _eligibility The address that can report on the Hat wearer's status\n    /// @param _toggle The address that can deactivate the Hat\n    /// @param _mutable Whether the hat's properties are changeable after creation\n    /// @param _imageURI The image uri for this hat and the fallback for its\n    ///                  downstream hats [optional]. Should not be larger than 7000 bytes (enforced in changeHatImageURI)\n    /// @return newHatId The id of the newly created Hat\n    function createHat(\n        uint256 _admin,\n        string calldata _details,\n        uint32 _maxSupply,\n        address _eligibility,\n        address _toggle,\n        bool _mutable,\n        string calldata _imageURI\n    ) public returns (uint256 newHatId) {\n        if (uint16(_admin) > 0) {\n            revert MaxLevelsReached();\n        }\n\n        if (_eligibility == address(0)) revert ZeroAddress();\n        if (_toggle == address(0)) revert ZeroAddress();\n        // check that the admin id is valid, ie does not contain empty levels between filled levels\n        if (!isValidHatId(_admin)) revert InvalidHatId();\n        // construct the next hat id\n        newHatId = getNextId(_admin);\n        // to create a hat, you must be wearing one of its admin hats\n        _checkAdmin(newHatId);\n        // create the new hat\n        _createHat(newHatId, _details, _maxSupply, _eligibility, _toggle, _mutable, _imageURI);\n        // increment _admin.lastHatId\n        // use the overflow check to constrain to correct number of hats per level\n        ++_hats[_admin].lastHatId;\n    }\n\n    /// @notice Creates new hats in batch. The msg.sender must be an admin of each hat.\n    /// @dev This is a convenience function that loops through the arrays and calls `createHat`.\n    /// @param _admins Array of ids of admins for each hat to create\n    /// @param _details Array of details for each hat to create\n    /// @param _maxSupplies Array of supply caps for each hat to create\n    /// @param _eligibilityModules Array of eligibility module addresses for each hat to\n    /// create\n    /// @param _toggleModules Array of toggle module addresses for each hat to create\n    /// @param _mutables Array of mutable flags for each hat to create\n    /// @param _imageURIs Array of imageURIs for each hat to create\n    /// @return success True if all createHat calls succeeded\n    function batchCreateHats(\n        uint256[] calldata _admins,\n        string[] calldata _details,\n        uint32[] calldata _maxSupplies,\n        address[] memory _eligibilityModules,\n        address[] memory _toggleModules,\n        bool[] calldata _mutables,\n        string[] calldata _imageURIs\n    ) public returns (bool success) {\n        // check if array lengths are the same\n        uint256 length = _admins.length; // save an MLOAD\n\n        {\n            bool sameLengths = (\n                length == _details.length // details\n                    && length == _maxSupplies.length // supplies\n                    && length == _eligibilityModules.length // eligibility\n                    && length == _toggleModules.length // toggle\n                    && length == _mutables.length // mutable\n                    && length == _imageURIs.length\n            ); // imageURI\n            if (!sameLengths) revert BatchArrayLengthMismatch();\n        }\n\n        // loop through and create each hat\n        for (uint256 i = 0; i < length;) {\n            createHat(\n                _admins[i],\n                _details[i],\n                _maxSupplies[i],\n                _eligibilityModules[i],\n                _toggleModules[i],\n                _mutables[i],\n                _imageURIs[i]\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        success = true;\n    }\n\n    /// @notice Gets the id of the next child hat of the hat `_admin`\n    /// @dev Does not incrememnt lastHatId\n    /// @param _admin The id of the hat to serve as the admin for the next child hat\n    /// @return nextId The new hat id\n    function getNextId(uint256 _admin) public view returns (uint256 nextId) {\n        uint16 nextHatId = _hats[_admin].lastHatId + 1;\n        nextId = buildHatId(_admin, nextHatId);\n    }\n\n    /// @notice Mints an ERC1155-similar token of the Hat to an eligible recipient, who then \"wears\" the hat\n    /// @dev The msg.sender must wear an admin Hat of `_hatId`, and the recipient must be eligible to wear `_hatId`\n    /// @param _hatId The id of the Hat to mint\n    /// @param _wearer The address to which the Hat is minted\n    /// @return success Whether the mint succeeded\n    function mintHat(uint256 _hatId, address _wearer) public returns (bool success) {\n        Hat storage hat = _hats[_hatId];\n        if (hat.maxSupply == 0) revert HatDoesNotExist(_hatId);\n        // only eligible wearers can receive minted hats\n        if (!isEligible(_wearer, _hatId)) revert NotEligible();\n        // only active hats can be minted\n        if (!_isActive(hat, _hatId)) revert HatNotActive();\n        // only the wearer of one of a hat's admins can mint it\n        _checkAdmin(_hatId);\n        // hat supply cannot exceed maxSupply\n        if (hat.supply >= hat.maxSupply) revert AllHatsWorn(_hatId);\n        // wearers cannot wear the same hat more than once\n        if (_staticBalanceOf(_wearer, _hatId) > 0) revert AlreadyWearingHat(_wearer, _hatId);\n        // if we've made it through all the checks, mint the hat\n        _mintHat(_wearer, _hatId);\n\n        success = true;\n    }\n\n    /// @notice Mints new hats in batch. The msg.sender must be an admin of each hat.\n    /// @dev This is a convenience function that loops through the arrays and calls `mintHat`.\n    /// @param _hatIds Array of ids of hats to mint\n    /// @param _wearers Array of addresses to which the hats will be minted\n    /// @return success True if all mintHat calls succeeded\n    function batchMintHats(uint256[] calldata _hatIds, address[] calldata _wearers) public returns (bool success) {\n        uint256 length = _hatIds.length;\n        if (length != _wearers.length) revert BatchArrayLengthMismatch();\n\n        for (uint256 i = 0; i < length;) {\n            mintHat(_hatIds[i], _wearers[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        success = true;\n    }\n\n    /// @notice Toggles a Hat's status from active to deactive, or vice versa\n    /// @dev The msg.sender must be set as the hat's toggle\n    /// @param _hatId The id of the Hat for which to adjust status\n    /// @param _newStatus The new status to set\n    /// @return toggled Whether the status was toggled\n    function setHatStatus(uint256 _hatId, bool _newStatus) external returns (bool toggled) {\n        Hat storage hat = _hats[_hatId];\n\n        if (msg.sender != hat.toggle) {\n            revert NotHatsToggle();\n        }\n\n        toggled = _processHatStatus(_hatId, _newStatus);\n    }\n\n    /// @notice Checks a hat's toggle module and processes the returned status\n    /// @dev May change the hat's status in storage\n    /// @param _hatId The id of the Hat whose toggle we are checking\n    /// @return toggled Whether there was a new status\n    function checkHatStatus(uint256 _hatId) public returns (bool toggled) {\n        Hat storage hat = _hats[_hatId];\n\n        // attempt to retrieve the hat's status from the toggle module\n        (bool success, bool newStatus) = _pullHatStatus(hat, _hatId);\n\n        // if unsuccessful (ie toggle was humanistic), process the new status\n        if (!success) revert NotHatsToggle();\n\n        // if successful (ie toggle was mechanistic), process the new status\n        toggled = _processHatStatus(_hatId, newStatus);\n    }\n\n    function _pullHatStatus(Hat storage _hat, uint256 _hatId) internal view returns (bool success, bool newStatus) {\n        bytes memory data = abi.encodeWithSignature(\"getHatStatus(uint256)\", _hatId);\n        bytes memory returndata;\n        (success, returndata) = _hat.toggle.staticcall(data);\n\n        /* \n        * if function call succeeds with data of length == 32, then we know the contract exists \n        * and has the getHatStatus function.\n        * But — since function selectors don't include return types — we still can't assume that the return data is a boolean, \n        * so we treat it as a uint so it will always safely decode without throwing.\n        */\n        if (success && returndata.length == 32) {\n            // check the returndata manually\n            uint256 uintReturndata = abi.decode(returndata, (uint256));\n            // false condition\n            if (uintReturndata == 0) {\n                newStatus = false;\n                // true condition\n            } else if (uintReturndata == 1) {\n                newStatus = true;\n            }\n            // invalid condition\n            else {\n                success = false;\n            }\n        } else {\n            success = false;\n        }\n    }\n\n    /// @notice Report from a hat's eligibility on the status of one of its wearers and, if `false`, revoke their hat\n    /// @dev Burns the wearer's hat, if revoked\n    /// @param _hatId The id of the hat\n    /// @param _wearer The address of the hat wearer whose status is being reported\n    /// @param _eligible Whether the wearer is eligible for the hat (will be revoked if\n    /// false)\n    /// @param _standing False if the wearer is no longer in good standing (and potentially should be penalized)\n    /// @return updated Whether the report succeeded\n    function setHatWearerStatus(uint256 _hatId, address _wearer, bool _eligible, bool _standing)\n        external\n        returns (bool updated)\n    {\n        Hat storage hat = _hats[_hatId];\n\n        if (msg.sender != hat.eligibility) {\n            revert NotHatsEligibility();\n        }\n\n        updated = _processHatWearerStatus(_hatId, _wearer, _eligible, _standing);\n    }\n\n    /// @notice Check a hat's eligibility for a report on the status of one of the hat's wearers and, if `false`, revoke their hat\n    /// @dev Burns the wearer's hat, if revoked\n    /// @param _hatId The id of the hat\n    /// @param _wearer The address of the Hat wearer whose status report is being requested\n    /// @return updated Whether the wearer's status was altered\n    function checkHatWearerStatus(uint256 _hatId, address _wearer) public returns (bool updated) {\n        bool eligible;\n        bool standing;\n\n        (bool success, bytes memory returndata) = _hats[_hatId].eligibility.staticcall(\n            abi.encodeWithSignature(\"getWearerStatus(address,uint256)\", _wearer, _hatId)\n        );\n\n        /* \n        * if function call succeeds with data of length == 64, then we know the contract exists \n        * and has the getWearerStatus function (which returns two words).\n        * But — since function selectors don't include return types — we still can't assume that the return data is two booleans, \n        * so we treat it as a uint so it will always safely decode without throwing.\n        */\n        if (success && returndata.length == 64) {\n            // check the returndata manually\n            (uint256 firstWord, uint256 secondWord) = abi.decode(returndata, (uint256, uint256));\n            // returndata is valid\n            if (firstWord < 2 && secondWord < 2) {\n                standing = (secondWord == 1) ? true : false;\n                // never eligible if in bad standing\n                eligible = (standing && firstWord == 1) ? true : false;\n            }\n            // returndata is invalid\n            else {\n                revert NotHatsEligibility();\n            }\n        } else {\n            revert NotHatsEligibility();\n        }\n\n        updated = _processHatWearerStatus(_hatId, _wearer, eligible, standing);\n    }\n\n    /// @notice Stop wearing a hat, aka \"renounce\" it\n    /// @dev Burns the msg.sender's hat\n    /// @param _hatId The id of the Hat being renounced\n    function renounceHat(uint256 _hatId) external {\n        if (_staticBalanceOf(msg.sender, _hatId) < 1) {\n            revert NotHatWearer();\n        }\n        // remove the hat\n        _burnHat(msg.sender, _hatId);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              HATS INTERNAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Internal call for creating a new hat\n    /// @dev Initializes a new Hat in storage, but does not mint any tokens\n    /// @param _id ID of the hat to be stored\n    /// @param _details A description of the hat\n    /// @param _maxSupply The total instances of the Hat that can be worn at once\n    /// @param _eligibility The address that can report on the Hat wearer's status\n    /// @param _toggle The address that can deactivate the hat [optional]\n    /// @param _mutable Whether the hat's properties are changeable after creation\n    /// @param _imageURI The image uri for this top hat and the fallback for its\n    ///                  downstream hats [optional]\n    function _createHat(\n        uint256 _id,\n        string calldata _details,\n        uint32 _maxSupply,\n        address _eligibility,\n        address _toggle,\n        bool _mutable,\n        string calldata _imageURI\n    ) internal {\n        /* \n          We write directly to storage instead of first building the Hat struct in memory.\n          This allows us to cheaply use the existing lastHatId value in case it was incremented by creating a hat while skipping admin levels.\n          (Resetting it to 0 would be bad since this hat's child hat(s) would overwrite the previously created hat(s) at that level.)\n        */\n        Hat storage hat = _hats[_id];\n        hat.details = _details;\n        hat.maxSupply = _maxSupply;\n        hat.eligibility = _eligibility;\n        hat.toggle = _toggle;\n        hat.imageURI = _imageURI;\n        // config is a concatenation of the status and mutability properties\n        hat.config = _mutable ? uint96(3 << 94) : uint96(1 << 95);\n\n        emit HatCreated(_id, _details, _maxSupply, _eligibility, _toggle, _mutable, _imageURI);\n    }\n\n    /// @notice Internal function to process hat status\n    /// @dev Updates a hat's status if different from current\n    /// @param _hatId The id of the Hat in quest\n    /// @param _newStatus The status to potentially change to\n    /// @return updated - Whether the status was updated\n    function _processHatStatus(uint256 _hatId, bool _newStatus) internal returns (bool updated) {\n        // optimize later\n        Hat storage hat = _hats[_hatId];\n\n        if (_newStatus != _getHatStatus(hat)) {\n            _setHatStatus(hat, _newStatus);\n            emit HatStatusChanged(_hatId, _newStatus);\n            updated = true;\n        }\n    }\n\n    /// @notice Internal call to process wearer status from the eligibility module\n    /// @dev Burns the wearer's Hat token if _eligible is false, and updates badStandings\n    /// state if necessary\n    /// @param _hatId The id of the Hat to revoke\n    /// @param _wearer The address of the wearer in question\n    /// @param _eligible Whether _wearer is eligible for the Hat (if false, this function\n    /// will revoke their Hat)\n    /// @param _standing Whether _wearer is in good standing (to be recorded in storage)\n    /// @return updated Whether the wearer standing was updated\n    function _processHatWearerStatus(uint256 _hatId, address _wearer, bool _eligible, bool _standing)\n        internal\n        returns (bool updated)\n    {\n        // revoke/burn the hat if _wearer has a positive balance\n        if (_staticBalanceOf(_wearer, _hatId) > 0) {\n            // always ineligible if in bad standing\n            if (!_eligible || !_standing) {\n                _burnHat(_wearer, _hatId);\n            }\n        }\n\n        // record standing for use by other contracts\n        // note: here, standing and badStandings are opposite\n        // i.e. if standing (true = good standing)\n        // then badStandings[_hatId][wearer] will be false\n        // if they are different, then something has changed, and we need to update\n        // badStandings marker\n        if (_standing == badStandings[_hatId][_wearer]) {\n            badStandings[_hatId][_wearer] = !_standing;\n            updated = true;\n\n            emit WearerStandingChanged(_hatId, _wearer, _standing);\n        }\n    }\n\n    /// @notice Internal function to set a hat's status in storage\n    /// @dev Flips the 0th bit of _hat.config via bitwise operation\n    /// @param _hat The hat object\n    /// @param _status The status to set for the hat\n    function _setHatStatus(Hat storage _hat, bool _status) internal {\n        if (_status) {\n            _hat.config |= uint96(1 << 95);\n        } else {\n            _hat.config &= ~uint96(1 << 95);\n        }\n    }\n\n    /**\n     * @notice Internal function to retrieve an account's internal \"static\" balance directly from internal storage,\n     * @dev This function bypasses the dynamic `_isActive` and `_isEligible` checks\n     * @param _account The account to check\n     * @param _hatId The hat to check\n     * @return staticBalance The account's static of the hat, from internal storage\n     */\n    function _staticBalanceOf(address _account, uint256 _hatId) internal view returns (uint256 staticBalance) {\n        staticBalance = _balanceOf[_account][_hatId];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              HATS ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Checks whether msg.sender is an admin of a hat, and reverts if not\n    function _checkAdmin(uint256 _hatId) internal view {\n        if (!isAdminOfHat(msg.sender, _hatId)) {\n            revert NotAdmin(msg.sender, _hatId);\n        }\n    }\n\n    /// @notice checks whether the msg.sender is either an admin or wearer or a hat, and reverts the appropriate error if not\n    function _checkAdminOrWearer(uint256 _hatId) internal view {\n        if (!isAdminOfHat(msg.sender, _hatId) && !isWearerOfHat(msg.sender, _hatId)) {\n            revert NotAdminOrWearer();\n        }\n    }\n\n    /// @notice Transfers a hat from one wearer to another eligible wearer\n    /// @dev The hat must be mutable, and the transfer must be initiated by an admin\n    /// @param _hatId The hat in question\n    /// @param _from The current wearer\n    /// @param _to The new wearer\n    function transferHat(uint256 _hatId, address _from, address _to) public {\n        _checkAdmin(_hatId);\n        // cannot transfer immutable hats, except for tophats, which can always transfer themselves\n        if (!isTopHat(_hatId)) {\n            if (!_isMutable(_hats[_hatId])) revert Immutable();\n        }\n        // Checks storage instead of `isWearerOfHat` since admins may want to transfer revoked Hats to new wearers\n        if (_staticBalanceOf(_from, _hatId) < 1) revert NotHatWearer();\n        // Check if recipient is already wearing hat; also checks storage to maintain balance == 1 invariant\n        if (_staticBalanceOf(_to, _hatId) > 0) revert AlreadyWearingHat(_to, _hatId);\n        // only eligible wearers can receive transferred hats\n        if (!isEligible(_to, _hatId)) revert NotEligible();\n        // only active hats can be transferred\n        if (!_isActive(_hats[_hatId], _hatId)) revert HatNotActive();\n        // we've made it passed all the checks, so adjust balances to execute the transfer\n        _balanceOf[_from][_hatId] = 0;\n        _balanceOf[_to][_hatId] = 1;\n        // emit the ERC1155 standard transfer event\n        emit TransferSingle(msg.sender, _from, _to, _hatId, 1);\n    }\n\n    /// @notice Set a mutable hat to immutable\n    /// @dev Sets the second bit of hat.config to 0\n    /// @param _hatId The id of the Hat to make immutable\n    function makeHatImmutable(uint256 _hatId) external {\n        _checkAdmin(_hatId);\n\n        Hat storage hat = _hats[_hatId];\n\n        if (!_isMutable(hat)) {\n            revert Immutable();\n        }\n\n        hat.config &= ~uint96(1 << 94);\n\n        emit HatMutabilityChanged(_hatId);\n    }\n\n    /// @notice Change a hat's details\n    /// @dev Hat must be mutable, except for tophats.\n    /// @param _hatId The id of the Hat to change\n    /// @param _newDetails The new details. Must not be larger than 7000 bytes.\n    function changeHatDetails(uint256 _hatId, string calldata _newDetails) external {\n        if (bytes(_newDetails).length > 7000) revert StringTooLong();\n\n        _checkAdmin(_hatId);\n\n        Hat storage hat = _hats[_hatId];\n\n        // a tophat can change its own details, but otherwise only mutable hat details can be changed\n        if (!isTopHat(_hatId)) {\n            if (!_isMutable(hat)) revert Immutable();\n        }\n\n        hat.details = _newDetails;\n\n        emit HatDetailsChanged(_hatId, _newDetails);\n    }\n\n    /// @notice Change a hat's details\n    /// @dev Hat must be mutable\n    /// @param _hatId The id of the Hat to change\n    /// @param _newEligibility The new eligibility module\n    function changeHatEligibility(uint256 _hatId, address _newEligibility) external {\n        if (_newEligibility == address(0)) revert ZeroAddress();\n\n        _checkAdmin(_hatId);\n        Hat storage hat = _hats[_hatId];\n\n        if (!_isMutable(hat)) {\n            revert Immutable();\n        }\n\n        hat.eligibility = _newEligibility;\n\n        emit HatEligibilityChanged(_hatId, _newEligibility);\n    }\n\n    /// @notice Change a hat's details\n    /// @dev Hat must be mutable\n    /// @param _hatId The id of the Hat to change\n    /// @param _newToggle The new toggle module\n    function changeHatToggle(uint256 _hatId, address _newToggle) external {\n        if (_newToggle == address(0)) revert ZeroAddress();\n\n        _checkAdmin(_hatId);\n        Hat storage hat = _hats[_hatId];\n\n        if (!_isMutable(hat)) {\n            revert Immutable();\n        }\n\n        // record hat status from old toggle before changing; ensures smooth transition to new toggle,\n        // especially in case of switching from mechanistic to humanistic toggle\n        // a) attempt to retrieve hat status from old toggle\n        (bool success, bool newStatus) = _pullHatStatus(hat, _hatId);\n        // b) if succeeded, (ie if old toggle was mechanistic), store the retrieved status\n        if (success) _processHatStatus(_hatId, newStatus);\n\n        // set the new toggle\n        hat.toggle = _newToggle;\n\n        emit HatToggleChanged(_hatId, _newToggle);\n    }\n\n    /// @notice Change a hat's details\n    /// @dev Hat must be mutable, except for tophats\n    /// @param _hatId The id of the Hat to change\n    /// @param _newImageURI The new imageURI. Must not be larger than 7000 bytes.\n    function changeHatImageURI(uint256 _hatId, string calldata _newImageURI) external {\n        if (bytes(_newImageURI).length > 7000) revert StringTooLong();\n\n        _checkAdmin(_hatId);\n        Hat storage hat = _hats[_hatId];\n\n        // a tophat can change its own imageURI, but otherwise only mutable hat imageURIs can be changed\n        if (!isTopHat(_hatId)) {\n            if (!_isMutable(hat)) revert Immutable();\n        }\n\n        hat.imageURI = _newImageURI;\n\n        emit HatImageURIChanged(_hatId, _newImageURI);\n    }\n\n    /// @notice Change a hat's details\n    /// @dev Hat must be mutable; new max supply cannot be less than current supply\n    /// @param _hatId The id of the Hat to change\n    /// @param _newMaxSupply The new max supply\n    function changeHatMaxSupply(uint256 _hatId, uint32 _newMaxSupply) external {\n        _checkAdmin(_hatId);\n        Hat storage hat = _hats[_hatId];\n\n        if (!_isMutable(hat)) {\n            revert Immutable();\n        }\n\n        if (_newMaxSupply < hat.supply) {\n            revert NewMaxSupplyTooLow();\n        }\n\n        if (_newMaxSupply != hat.maxSupply) {\n            hat.maxSupply = _newMaxSupply;\n            emit HatMaxSupplyChanged(_hatId, _newMaxSupply);\n        }\n    }\n\n    /// @notice Submits a request to link a Hat Tree under a parent tree. Requests can be\n    /// submitted by either...\n    ///     a) the wearer of a topHat, previous to any linkage, or\n    ///     b) the admin(s) of an already-linked topHat (aka tree root), where such a\n    ///        request is to move the tree root to another admin within the same parent\n    ///        tree\n    /// @dev A topHat can have at most 1 request at a time. Submitting a new request will\n    ///      replace the existing request.\n    /// @param _topHatDomain The domain of the topHat to link\n    /// @param _requestedAdminHat The hat that will administer the linked tree\n    function requestLinkTopHatToTree(uint32 _topHatDomain, uint256 _requestedAdminHat) external {\n        uint256 fullTopHatId = uint256(_topHatDomain) << 224; // (256 - TOPHAT_ADDRESS_SPACE);\n\n        // The wearer of an unlinked tophat is also the admin of same; once a tophat is linked, its wearer is no longer its admin\n        _checkAdmin(fullTopHatId);\n\n        linkedTreeRequests[_topHatDomain] = _requestedAdminHat;\n        emit TopHatLinkRequested(_topHatDomain, _requestedAdminHat);\n    }\n\n    /// @notice Approve a request to link a Tree under a parent tree, with options to add eligibility or toggle modules and change its metadata\n    /// @dev Requests can only be approved by wearer or an admin of the `_newAdminHat`, and there\n    ///      can only be one link per tree root at a given time.\n    /// @param _topHatDomain The 32 bit domain of the topHat to link\n    /// @param _newAdminHat The hat that will administer the linked tree\n    /// @param _eligibility Optional new eligibility module for the linked topHat\n    /// @param _toggle Optional new toggle module for the linked topHat\n    /// @param _details Optional new details for the linked topHat\n    /// @param _imageURI Optional new imageURI for the linked topHat\n    function approveLinkTopHatToTree(\n        uint32 _topHatDomain,\n        uint256 _newAdminHat,\n        address _eligibility,\n        address _toggle,\n        string calldata _details,\n        string calldata _imageURI\n    ) external {\n        // for everything but the last hat level, check the admin of `_newAdminHat`'s theoretical child hat, since either wearer or admin of `_newAdminHat` c"
    }
  ]
}