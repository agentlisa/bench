{
  "Title": "[H05] Incorrect gas price [core]",
  "Content": "**Client reported:** *The Ethereum Foundation identified this issue during the audit.*\n\n\nThe gas price to charge the user (potentially through the paymaster) for the operation is [calculated](https://github.com/eth-infinitism/account-abstraction/blob/8832d6e04b9f4f706f612261c6e46b3f1745d61a/contracts/UserOperation.sol#L34-L38) as the minimum of the transaction gas price and the user-specified gas price (after accounting for any `basefee`). However, the user should always pay their specified price so the bundler can receive the excess, which provides the incentive to process the user operation in the first place. Consider allowing the user’s gas price to exceed the transaction gas price.\n\n\n***Update**: Fixed in pull request [#55](https://github.com/eth-infinitism/account-abstraction/pull/55/files). The `tx.gasprice` value has been removed from the gas price calculation.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/UserOperation.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.7;\n\nimport \"hardhat/console.sol\";\n\n    struct UserOperation {\n\n        address sender;\n        uint256 nonce;\n        bytes initCode;\n        bytes callData;\n        uint callGas;\n        uint verificationGas;\n        uint preVerificationGas;\n        uint maxFeePerGas;\n        uint maxPriorityFeePerGas;\n        address paymaster;\n        bytes paymasterData;\n        bytes signature;\n    }\n\nlibrary UserOperationLib {\n\n    function getSender(UserOperation calldata userOp) internal pure returns (address ret) {\n        assembly {ret := calldataload(userOp)}\n    }\n\n    //relayer/miner might submit the TX with higher priorityFee, but the user should not\n    // pay above what he signed for.\n    function gasPrice(UserOperation calldata userOp) internal view returns (uint) {\n    unchecked {\n        uint maxFeePerGas = userOp.maxFeePerGas;\n        uint maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\n        if (maxFeePerGas == maxPriorityFeePerGas) {\n            //legacy mode (for networks that don't support basefee opcode)\n            return min(tx.gasprice, maxFeePerGas);\n        }\n        return min(tx.gasprice, min(maxFeePerGas, maxPriorityFeePerGas + block.basefee));\n    }\n    }\n\n    function requiredGas(UserOperation calldata userOp) internal pure returns (uint) {\n    unchecked {\n        //when using a Paymaster, the verificationGas is used also to cover the postOp call.\n        // our security model might call postOp eventually twice\n        uint mul = userOp.paymaster != address(0) ? 1 : 3;\n        return userOp.callGas + userOp.verificationGas * mul + userOp.preVerificationGas;\n    }\n    }\n\n    function requiredPreFund(UserOperation calldata userOp) internal view returns (uint prefund) {\n    unchecked {\n        return requiredGas(userOp) * gasPrice(userOp);\n    }\n    }\n\n    function hasPaymaster(UserOperation calldata userOp) internal pure returns (bool) {\n        return userOp.paymaster != address(0);\n    }\n\n    function pack(UserOperation calldata userOp) internal pure returns (bytes memory ret) {\n        //lighter signature scheme. must match UserOp.ts#packUserOp\n        bytes calldata sig = userOp.signature;\n        assembly {\n            let ofs := userOp\n            let len := sub(sub(sig.offset, ofs), 32)\n            ret := mload(0x40)\n            mstore(0x40, add(ret, add(len, 32)))\n            mstore(ret, len)\n            calldatacopy(add(ret, 32), ofs, len)\n        }\n        return ret;\n    }\n\n    function hash(UserOperation calldata userOp) internal pure returns (bytes32) {\n        return keccak256(pack(userOp));\n    }\n\n    function min(uint a, uint b) internal pure returns (uint) {\n        return a < b ? a : b;\n    }\n}"
    }
  ]
}