{
  "Title": "[G-03] Caching storage variables in local variables to save gas",
  "Content": "\nAnytime you are reading from storage more than once, it is cheaper in gas cost to cache the variable: a SLOAD cost 100gas, while MLOAD and MSTORE cost 3 gas.\n\nIn particular, in `for` loops, when using the length of a storage array as the condition being checked after each loop, caching the array length can yield significant gas savings if the array length is high\n\n### Proof of Concept\n\n15 instances:\n\n##### src/modules/Buyout.sol\n\nscope: `end()`\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L186>\n\n*   `registry` is read twice:\n\n```cpp\n186:         (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n210:                IVaultRegistry(registry)\n```\n\nscope: `cash()`\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L246>\n\n*   `registry` is read twice:\n\n```cpp\n246:         (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n267:        uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);\n```\n\nscope: `redeem()`\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L280>\n\n*   `registry` is read twice:\n\n```cpp\n280:         (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n288:         uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);\n```\n\nscope: `getPermissions()`\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L476>\n\n*   `supply` is read twice:\n\n```cpp\n476:             supply,\n477:             ISupply(supply).burn.selector\n```\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L482>\n\n*   `transfer` is read 8 times:\n\n```cpp\n482:             transfer,\n483:             ITransfer(transfer).ERC20Transfer.selector\n488:             transfer,\n489:             ITransfer(transfer).ERC721TransferFrom.selector\n494:             transfer,\n495:             ITransfer(transfer).ERC1155TransferFrom.selector\n500:             transfer,\n501:             ITransfer(transfer).ERC1155BatchTransferFrom.selector\n```\n\n##### src/modules/Migrations.sol\n\nscope: `propose()`\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L81>\n\n*   `registry` is read twice:\n\n```cpp\n81:         (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n95:         proposal.oldFractionSupply = IVaultRegistry(registry).totalSupply(_vault);\n```\n\nscope: `commit()`\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L184>\n\n*   `registry` is read twice:\n\n```cpp\n184:         (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n200:             IVaultRegistry(registry).totalSupply(_vault)\n```\n\n*   `buyout` is read twice in the conditionnal `if` block:\n\n```cpp\n208:             IFERC1155(token).setApprovalFor(address(buyout), id, true)\n210:             IBuyout(buyout).start{value: proposal.totalEth}(_vault);\n```\n\nscope: `settleVault()`\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L232>\n\n*   `proposal.modules` is read twice:\n\n```cpp\n232:         bytes32[] memory merkleTree = generateMerkleTree(proposal.modules);\n247:             proposal.modules\n```\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L237>\n\n*   `proposal.plugins` is read twice:\n\n```cpp\n237:             proposal.plugins\n248:             proposal.plugins\n```\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L238>\n\n*   `proposal.selectors` is read twice:\n\n```cpp\n238:             proposal.selectors\n249:             proposal.selectors\n```\n\nscope: `settleFractions()`\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L273>\n\n*   `proposal.newVault` is read twice:\n\n```cpp\n273:             proposal.newVault\n283:             proposal.newVault\n```\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L275>\n\n*   `proposal.newFractionSupply` is read twice:\n\n```cpp\n275:             proposal.newFractionSupply\n285:             proposal.newFractionSupply\n```\n\nscope: `migrateFractions()`\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L435>\n\n*   `registry` is read 3 times:\n\n```cpp\n435:         (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault)\n467:         (address token, uint256 newFractionId) = IVaultRegistry(registry)\n470:         uint256 newTotalSupply = IVaultRegistry(registry).totalSupply(newVault)\n```\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L438>\n\n*   `buyout` is read twice:\n\n```cpp\n438:         (, address proposer, State current, , , ) = IBuyout(buyout).buyoutInfo(_vault)\n447:         (, , , , , uint256 lastTotalSupply) = IBuyout(buyout).buyoutInfo(_vault);\n```\n\n### Recommended Mitigation Steps\n\nCache these storage variables using local variables.\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-07-fractional-v2-contest",
  "Code": [
    {
      "filename": "src/modules/Buyout.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IBuyout, Auction, State} from \"../interfaces/IBuyout.sol\";\nimport {IERC1155} from \"../interfaces/IERC1155.sol\";\nimport {ISupply} from \"../interfaces/ISupply.sol\";\nimport {ITransfer} from \"../interfaces/ITransfer.sol\";\nimport {IVault} from \"../interfaces/IVault.sol\";\nimport {IVaultRegistry, Permission} from \"../interfaces/IVaultRegistry.sol\";\nimport {Multicall} from \"../utils/Multicall.sol\";\nimport {NFTReceiver} from \"../utils/NFTReceiver.sol\";\nimport {SafeSend} from \"../utils/SafeSend.sol\";\nimport {SelfPermit} from \"../utils/SelfPermit.sol\";\n\n/// @title Buyout\n/// @author Fractional Art\n/// @notice Module contract for vaults to hold buyout pools\n/// - A fractional owner starts an auction for a vault by depositing any amount of ether and fractional tokens into a pool.\n/// - During the proposal period (2 days) users can sell their fractional tokens into the pool for ether.\n/// - During the rejection period (4 days) users can buy fractional tokens from the pool with ether.\n/// - If a pool has more than 51% of the total supply after 4 days, the buyout is successful and the proposer\n///   gains access to withdraw the underlying assets (ERC20, ERC721, and ERC1155 tokens) from the vault.\n///   Otherwise the buyout is considered unsuccessful and a new one may then begin.\n/// - NOTE: A vault may only have one active buyout at any given time.\n/// - buyoutPrice = (ethDeposit * 100) / (100 - ((fractionDeposit * 100) / totalSupply))\n/// - buyoutShare = (tokenBalance * ethBalance) / (totalSupply + tokenBalance)\ncontract Buyout is IBuyout, Multicall, NFTReceiver, SafeSend, SelfPermit {\n    /// @notice Address of VaultRegistry contract\n    address public registry;\n    /// @notice Address of Supply target contract\n    address public supply;\n    /// @notice Address of Transfer target contract\n    address public transfer;\n    /// @notice Time length of the proposal period\n    uint256 public constant PROPOSAL_PERIOD = 2 days;\n    /// @notice Time length of the rejection period\n    uint256 public constant REJECTION_PERIOD = 4 days;\n    /// @notice Mapping of vault address to auction struct\n    mapping(address => Auction) public buyoutInfo;\n\n    /// @notice Initializes registry, supply, and transfer contracts\n    constructor(\n        address _registry,\n        address _supply,\n        address _transfer\n    ) {\n        registry = _registry;\n        supply = _supply;\n        transfer = _transfer;\n    }\n\n    /// @dev Callback for receiving ether when the calldata is empty\n    receive() external payable {}\n\n    /// @notice Starts the auction for a buyout pool\n    /// @param _vault Address of the vault\n    function start(address _vault) external payable {\n        // Reverts if ether deposit amount is zero\n        if (msg.value == 0) revert ZeroDeposit();\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not inactive\n        (, , State current, , , ) = this.buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert InvalidState(required, current);\n\n        // Gets total supply of fractional tokens for the vault\n        uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);\n        // Gets total balance of fractional tokens owned by caller\n        uint256 depositAmount = IERC1155(token).balanceOf(msg.sender, id);\n\n        // Transfers fractional tokens into the buyout pool\n        IERC1155(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            id,\n            depositAmount,\n            \"\"\n        );\n\n        // Calculates price of buyout and fractions\n        // @dev Reverts with division error if called with total supply of tokens\n        uint256 buyoutPrice = (msg.value * 100) /\n            (100 - ((depositAmount * 100) / totalSupply));\n        uint256 fractionPrice = buyoutPrice / totalSupply;\n\n        // Sets info mapping of the vault address to auction struct\n        buyoutInfo[_vault] = Auction(\n            block.timestamp,\n            msg.sender,\n            State.LIVE,\n            fractionPrice,\n            msg.value,\n            totalSupply\n        );\n        // Emits event for starting auction\n        emit Start(\n            _vault,\n            msg.sender,\n            block.timestamp,\n            buyoutPrice,\n            fractionPrice\n        );\n    }\n\n    /// @notice Sells fractional tokens in exchange for ether from a pool\n    /// @param _vault Address of the vault\n    /// @param _amount Transfer amount of fractions\n    function sellFractions(address _vault, uint256 _amount) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        (uint256 startTime, , State current, uint256 fractionPrice, , ) = this\n            .buyoutInfo(_vault);\n        // Reverts if auction state is not live\n        State required = State.LIVE;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if current time is greater than end time of proposal period\n        uint256 endTime = startTime + PROPOSAL_PERIOD;\n        if (block.timestamp > endTime)\n            revert TimeExpired(block.timestamp, endTime);\n\n        // Transfers fractional tokens to pool from caller\n        IERC1155(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            id,\n            _amount,\n            \"\"\n        );\n\n        // Updates ether balance of pool\n        uint256 ethAmount = fractionPrice * _amount;\n        buyoutInfo[_vault].ethBalance -= ethAmount;\n        // Transfers ether amount to caller\n        _sendEthOrWeth(msg.sender, ethAmount);\n        // Emits event for selling fractions into pool\n        emit SellFractions(msg.sender, _amount);\n    }\n\n    /// @notice Buys fractional tokens in exchange for ether from a pool\n    /// @param _vault Address of the vault\n    /// @param _amount Transfer amount of fractions\n    function buyFractions(address _vault, uint256 _amount) external payable {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not live\n        (uint256 startTime, , State current, uint256 fractionPrice, , ) = this\n            .buyoutInfo(_vault);\n        State required = State.LIVE;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if current time is greater than end time of rejection period\n        uint256 endTime = startTime + REJECTION_PERIOD;\n        if (block.timestamp > endTime)\n            revert TimeExpired(block.timestamp, endTime);\n        // Reverts if payment amount does not equal price of fractional amount\n        if (msg.value != fractionPrice * _amount) revert InvalidPayment();\n\n        // Transfers fractional tokens to caller\n        IERC1155(token).safeTransferFrom(\n            address(this),\n            msg.sender,\n            id,\n            _amount,\n            \"\"\n        );\n        // Updates ether balance of pool\n        buyoutInfo[_vault].ethBalance += msg.value;\n        // Emits event for buying fractions from pool\n        emit BuyFractions(msg.sender, _amount);\n    }\n\n    /// @notice Ends the auction for a live buyout pool\n    /// @param _vault Address of the vault\n    /// @param _burnProof Merkle proof for burning fractional tokens\n    function end(address _vault, bytes32[] calldata _burnProof) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not live\n        (\n            uint256 startTime,\n            address proposer,\n            State current,\n            ,\n            uint256 ethBalance,\n\n        ) = this.buyoutInfo(_vault);\n        State required = State.LIVE;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if current time is less than or equal to end time of auction\n        uint256 endTime = startTime + REJECTION_PERIOD;\n        if (block.timestamp <= endTime)\n            revert TimeNotElapsed(block.timestamp, endTime);\n\n        uint256 tokenBalance = IERC1155(token).balanceOf(address(this), id);\n        // Checks totalSupply of auction pool to determine if buyout is successful or not\n        if (\n            (tokenBalance * 1000) /\n                IVaultRegistry(registry).totalSupply(_vault) >\n            500\n        ) {\n            // Initializes vault transaction\n            bytes memory data = abi.encodeCall(\n                ISupply.burn,\n                (address(this), tokenBalance)\n            );\n            // Executes burn of fractional tokens from pool\n            IVault(payable(_vault)).execute(supply, data, _burnProof);\n            // Sets buyout state to successful\n            buyoutInfo[_vault].state = State.SUCCESS;\n            // Emits event for ending successful auction\n            emit End(_vault, State.SUCCESS, proposer);\n        } else {\n            // Deletes auction info\n            delete buyoutInfo[_vault];\n            // Transfers fractions and ether back to proposer of the buyout pool\n            IERC1155(token).safeTransferFrom(\n                address(this),\n                proposer,\n                id,\n                tokenBalance,\n                \"\"\n            );\n            _sendEthOrWeth(proposer, ethBalance);\n            // Emits event for ending unsuccessful auction\n            emit End(_vault, State.INACTIVE, proposer);\n        }\n    }\n\n    /// @notice Cashes out proceeds from a successful buyout\n    /// @param _vault Address of the vault\n    /// @param _burnProof Merkle proof for burning fractional tokens\n    function cash(address _vault, bytes32[] calldata _burnProof) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not successful\n        (, , State current, , uint256 ethBalance, ) = this.buyoutInfo(_vault);\n        State required = State.SUCCESS;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if caller has a balance of zero fractional tokens\n        uint256 tokenBalance = IERC1155(token).balanceOf(msg.sender, id);\n        if (tokenBalance == 0) revert NoFractions();\n\n        // Initializes vault transaction\n        bytes memory data = abi.encodeCall(\n            ISupply.burn,\n            (msg.sender, tokenBalance)\n        );\n        // Executes burn of fractional tokens from caller\n        IVault(payable(_vault)).execute(supply, data, _burnProof);\n\n        // Transfers buyout share amount to caller based on total supply\n        uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);\n        uint256 buyoutShare = (tokenBalance * ethBalance) /\n            (totalSupply + tokenBalance);\n        _sendEthOrWeth(msg.sender, buyoutShare);\n        // Emits event for cashing out of buyout pool\n        emit Cash(_vault, msg.sender, buyoutShare);\n    }\n\n    /// @notice Terminates a vault with an inactive buyout\n    /// @param _vault Address of the vault\n    /// @param _burnProof Merkle proof for burning fractional tokens\n    function redeem(address _vault, bytes32[] calldata _burnProof) external {\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not inactive\n        (, , State current, , , ) = this.buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert InvalidState(required, current);\n\n        // Initializes vault transaction\n        uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);\n        bytes memory data = abi.encodeCall(\n            ISupply.burn,\n            (msg.sender, totalSupply)\n        );\n        // Executes burn of fractional tokens from caller\n        IVault(payable(_vault)).execute(supply, data, _burnProof);\n\n        // Sets buyout state to successful and proposer to caller\n        (buyoutInfo[_vault].state, buyoutInfo[_vault].proposer) = (\n            State.SUCCESS,\n            msg.sender\n        );\n        // Emits event for redeem underlying assets from the vault\n        emit Redeem(_vault, msg.sender);\n    }\n\n    /// @notice Withdraws an ERC-20 token from a vault\n    /// @param _vault Address of the vault\n    /// @param _token Address of the token\n    /// @param _to Address of the receiver\n    /// @param _value Transfer amount\n    /// @param _erc20TransferProof Merkle proof for transferring an ERC-20 token\n    function withdrawERC20(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _value,\n        bytes32[] calldata _erc20TransferProof\n    ) external {\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not successful\n        (, address proposer, State current, , , ) = this.buyoutInfo(_vault);\n        State required = State.SUCCESS;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if caller is not the auction winner\n        if (msg.sender != proposer) revert NotWinner();\n\n        // Initializes vault transaction\n        bytes memory data = abi.encodeCall(\n            ITransfer.ERC20Transfer,\n            (_token, _to, _value)\n        );\n        // Executes transfer of ERC721 token to caller\n        IVault(payable(_vault)).execute(transfer, data, _erc20TransferProof);\n    }\n\n    /// @notice Withdraws an ERC-721 token from a vault\n    /// @param _vault Address of the vault\n    /// @param _token Address of the token\n    /// @param _to Address of the receiver\n    /// @param _tokenId ID of the token\n    /// @param _erc721TransferProof Merkle proof for transferring an ERC-721 token\n    function withdrawERC721(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _tokenId,\n        bytes32[] calldata _erc721TransferProof\n    ) external {\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not successful\n        (, address proposer, State current, , , ) = this.buyoutInfo(_vault);\n        State required = State.SUCCESS;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if caller is not the auction winner\n        if (msg.sender != proposer) revert NotWinner();\n\n        // Initializes vault transaction\n        bytes memory data = abi.encodeCall(\n            ITransfer.ERC721TransferFrom,\n            (_token, _vault, _to, _tokenId)\n        );\n        // Executes transfer of ERC721 token to caller\n        IVault(payable(_vault)).execute(transfer, data, _erc721TransferProof);\n    }\n\n    /// @notice Withdraws an ERC-1155 token from a vault\n    /// @param _vault Address of the vault\n    /// @param _token Address of the token\n    /// @param _to Address of the receiver\n    /// @param _id ID of the token type\n    /// @param _value Transfer amount\n    /// @param _erc1155TransferProof Merkle proof for transferring an ERC-1155 token\n    function withdrawERC1155(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _id,\n        uint256 _value,\n        bytes32[] calldata _erc1155TransferProof\n    ) external {\n        // Creates local scope to avoid stack too deep\n        {\n            // Reverts if address is not a registered vault\n            (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n            if (id == 0) revert NotVault(_vault);\n            // Reverts if auction state is not successful\n            (, address proposer, State current, , , ) = this.buyoutInfo(_vault);\n            State required = State.SUCCESS;\n            if (current != required) revert InvalidState(required, current);\n            // Reverts if caller is not the auction winner\n            if (msg.sender != proposer) revert NotWinner();\n        }\n\n        // Initializes vault transaction\n        bytes memory data = abi.encodeCall(\n            ITransfer.ERC1155TransferFrom,\n            (_token, _vault, _to, _id, _value)\n        );\n        // Executes transfer of ERC1155 token to caller\n        IVault(payable(_vault)).execute(transfer, data, _erc1155TransferProof);\n    }\n\n    /// @notice Batch withdraws ERC-1155 tokens from a vault\n    /// @param _vault Address of the vault\n    /// @param _token Address of the token\n    /// @param _to Address of the receiver\n    /// @param _ids IDs of each token type\n    /// @param _values Transfer amounts per token type\n    /// @param _erc1155BatchTransferProof Merkle proof for transferring multiple ERC-1155 tokens\n    function batchWithdrawERC1155(\n        address _vault,\n        address _token,\n        address _to,\n        uint256[] calldata _ids,\n        uint256[] calldata _values,\n        bytes32[] calldata _erc1155BatchTransferProof\n    ) external {\n        // Creates local scope to avoid stack too deep\n        {\n            // Reverts if address is not a registered vault\n            (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n            if (id == 0) revert NotVault(_vault);\n            // Reverts if auction state is not successful\n            (, address proposer, State current, , , ) = this.buyoutInfo(_vault);\n            State required = State.SUCCESS;\n            if (current != required) revert InvalidState(required, current);\n            // Reverts if caller is not the auction winner\n            if (msg.sender != proposer) revert NotWinner();\n        }\n\n        // Initializes vault transaction\n        bytes memory data = abi.encodeCall(\n            ITransfer.ERC1155BatchTransferFrom,\n            (_token, _vault, _to, _ids, _values)\n        );\n        // Executes batch transfer of multiple ERC1155 tokens to caller\n        IVault(payable(_vault)).execute(\n            transfer,\n            data,\n            _erc1155BatchTransferProof\n        );\n    }\n\n    /// @notice Gets the list of leaf nodes used to generate a merkle tree\n    /// @dev Leaf nodes are hashed permissions of the merkle tree\n    /// @return nodes Hashes of leaf nodes\n    function getLeafNodes() external view returns (bytes32[] memory nodes) {\n        nodes = new bytes32[](5);\n        // Gets list of permissions from this module\n        Permission[] memory permissions = getPermissions();\n        for (uint256 i; i < permissions.length; ) {\n            // Hashes permission into leaf node\n            nodes[i] = keccak256(abi.encode(permissions[i]));\n            // Can't overflow since loop is a fixed size\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Gets the list of permissions installed on a vault\n    /// @dev Permissions consist of a module contract, target contract, and function selector\n    /// @return permissions List of vault permissions\n    function getPermissions()\n        public\n        view\n        returns (Permission[] memory permissions)\n    {\n        permissions = new Permission[](5);\n        // Burn function selector from supply contract\n        permissions[0] = Permission(\n            address(this),\n            supply,\n            ISupply(supply).burn.selector\n        );\n        // ERC20Transfer function selector from transfer contract\n        permissions[1] = Permission(\n            address(this),\n            transfer,\n            ITransfer(transfer).ERC20Transfer.selector\n        );\n        // ERC721TransferFrom function selector from transfer contract\n        permissions[2] = Permission(\n            address(this),\n            transfer,\n            ITransfer(transfer).ERC721TransferFrom.selector\n        );\n        // ERC1155TransferFrom function selector from transfer contract\n        permissions[3] = Permission(\n            address(this),\n            transfer,\n            ITransfer(transfer).ERC1155TransferFrom.selector\n        );\n        // ERC1155BatchTransferFrom function selector from transfer contract\n        permissions[4] = Permission(\n            address(this),\n            transfer,\n            ITransfer(transfer).ERC1155BatchTransferFrom.selector\n        );\n    }\n}"
    },
    {
      "filename": "src/modules/Buyout.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IBuyout, Auction, State} from \"../interfaces/IBuyout.sol\";\nimport {IERC1155} from \"../interfaces/IERC1155.sol\";\nimport {ISupply} from \"../interfaces/ISupply.sol\";\nimport {ITransfer} from \"../interfaces/ITransfer.sol\";\nimport {IVault} from \"../interfaces/IVault.sol\";\nimport {IVaultRegistry, Permission} from \"../interfaces/IVaultRegistry.sol\";\nimport {Multicall} from \"../utils/Multicall.sol\";\nimport {NFTReceiver} from \"../utils/NFTReceiver.sol\";\nimport {SafeSend} from \"../utils/SafeSend.sol\";\nimport {SelfPermit} from \"../utils/SelfPermit.sol\";\n\n/// @title Buyout\n/// @author Fractional Art\n/// @notice Module contract for vaults to hold buyout pools\n/// - A fractional owner starts an auction for a vault by depositing any amount of ether and fractional tokens into a pool.\n/// - During the proposal period (2 days) users can sell their fractional tokens into the pool for ether.\n/// - During the rejection period (4 days) users can buy fractional tokens from the pool with ether.\n/// - If a pool has more than 51% of the total supply after 4 days, the buyout is successful and the proposer\n///   gains access to withdraw the underlying assets (ERC20, ERC721, and ERC1155 tokens) from the vault.\n///   Otherwise the buyout is considered unsuccessful and a new one may then begin.\n/// - NOTE: A vault may only have one active buyout at any given time.\n/// - buyoutPrice = (ethDeposit * 100) / (100 - ((fractionDeposit * 100) / totalSupply))\n/// - buyoutShare = (tokenBalance * ethBalance) / (totalSupply + tokenBalance)\ncontract Buyout is IBuyout, Multicall, NFTReceiver, SafeSend, SelfPermit {\n    /// @notice Address of VaultRegistry contract\n    address public registry;\n    /// @notice Address of Supply target contract\n    address public supply;\n    /// @notice Address of Transfer target contract\n    address public transfer;\n    /// @notice Time length of the proposal period\n    uint256 public constant PROPOSAL_PERIOD = 2 days;\n    /// @notice Time length of the rejection period\n    uint256 public constant REJECTION_PERIOD = 4 days;\n    /// @notice Mapping of vault address to auction struct\n    mapping(address => Auction) public buyoutInfo;\n\n    /// @notice Initializes registry, supply, and transfer contracts\n    constructor(\n        address _registry,\n        address _supply,\n        address _transfer\n    ) {\n        registry = _registry;\n        supply = _supply;\n        transfer = _transfer;\n    }\n\n    /// @dev Callback for receiving ether when the calldata is empty\n    receive() external payable {}\n\n    /// @notice Starts the auction for a buyout pool\n    /// @param _vault Address of the vault\n    function start(address _vault) external payable {\n        // Reverts if ether deposit amount is zero\n        if (msg.value == 0) revert ZeroDeposit();\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not inactive\n        (, , State current, , , ) = this.buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert InvalidState(required, current);\n\n        // Gets total supply of fractional tokens for the vault\n        uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);\n        // Gets total balance of fractional tokens owned by caller\n        uint256 depositAmount = IERC1155(token).balanceOf(msg.sender, id);\n\n        // Transfers fractional tokens into the buyout pool\n        IERC1155(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            id,\n            depositAmount,\n            \"\"\n        );\n\n        // Calculates price of buyout and fractions\n        // @dev Reverts with division error if called with total supply of tokens\n        uint256 buyoutPrice = (msg.value * 100) /\n            (100 - ((depositAmount * 100) / totalSupply));\n        uint256 fractionPrice = buyoutPrice / totalSupply;\n\n        // Sets info mapping of the vault address to auction struct\n        buyoutInfo[_vault] = Auction(\n            block.timestamp,\n            msg.sender,\n            State.LIVE,\n            fractionPrice,\n            msg.value,\n            totalSupply\n        );\n        // Emits event for starting auction\n        emit Start(\n            _vault,\n            msg.sender,\n            block.timestamp,\n            buyoutPrice,\n            fractionPrice\n        );\n    }\n\n    /// @notice Sells fractional tokens in exchange for ether from a pool\n    /// @param _vault Address of the vault\n    /// @param _amount Transfer amount of fractions\n    function sellFractions(address _vault, uint256 _amount) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        (uint256 startTime, , State current, uint256 fractionPrice, , ) = this\n            .buyoutInfo(_vault);\n        // Reverts if auction state is not live\n        State required = State.LIVE;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if current time is greater than end time of proposal period\n        uint256 endTime = startTime + PROPOSAL_PERIOD;\n        if (block.timestamp > endTime)\n            revert TimeExpired(block.timestamp, endTime);\n\n        // Transfers fractional tokens to pool from caller\n        IERC1155(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            id,\n            _amount,\n            \"\"\n        );\n\n        // Updates ether balance of pool\n        uint256 ethAmount = fractionPrice * _amount;\n        buyoutInfo[_vault].ethBalance -= ethAmount;\n        // Transfers ether amount to caller\n        _sendEthOrWeth(msg.sender, ethAmount);\n        // Emits event for selling fractions into pool\n        emit SellFractions(msg.sender, _amount);\n    }\n\n    /// @notice Buys fractional tokens in exchange for ether from a pool\n    /// @param _vault Address of the vault\n    /// @param _amount Transfer amount of fractions\n    function buyFractions(address _vault, uint256 _amount) external payable {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not live\n        (uint256 startTime, , State current, uint256 fractionPrice, , ) = this\n            .buyoutInfo(_vault);\n        State required = State.LIVE;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if current time is greater than end time of rejection period\n        uint256 endTime = startTime + REJECTION_PERIOD;\n        if (block.timestamp > endTime)\n            revert TimeExpired(block.timestamp, endTime);\n        // Reverts if payment amount does not equal price of fractional amount\n        if (msg.value != fractionPrice * _amount) revert InvalidPayment();\n\n        // Transfers fractional tokens to caller\n        IERC1155(token).safeTransferFrom(\n            address(this),\n            msg.sender,\n            id,\n            _amount,\n            \"\"\n        );\n        // Updates ether balance of pool\n        buyoutInfo[_vault].ethBalance += msg.value;\n        // Emits event for buying fractions from pool\n        emit BuyFractions(msg.sender, _amount);\n    }\n\n    /// @notice Ends the auction for a live buyout pool\n    /// @param _vault Address of the vault\n    /// @param _burnProof Merkle proof for burning fractional tokens\n    function end(address _vault, bytes32[] calldata _burnProof) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not live\n        (\n            uint256 startTime,\n            address proposer,\n            State current,\n            ,\n            uint256 ethBalance,\n\n        ) = this.buyoutInfo(_vault);\n        State required = State.LIVE;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if current time is less than or equal to end time of auction\n        uint256 endTime = startTime + REJECTION_PERIOD;\n        if (block.timestamp <= endTime)\n            revert TimeNotElapsed(block.timestamp, endTime);\n\n        uint256 tokenBalance = IERC1155(token).balanceOf(address(this), id);\n        // Checks totalSupply of auction pool to determine if buyout is successful or not\n        if (\n            (tokenBalance * 1000) /\n                IVaultRegistry(registry).totalSupply(_vault) >\n            500\n        ) {\n            // Initializes vault transaction\n            bytes memory data = abi.encodeCall(\n                ISupply.burn,\n                (address(this), tokenBalance)\n            );\n            // Executes burn of fractional tokens from pool\n            IVault(payable(_vault)).execute(supply, data, _burnProof);\n            // Sets buyout state to successful\n            buyoutInfo[_vault].state = State.SUCCESS;\n            // Emits event for ending successful auction\n            emit End(_vault, State.SUCCESS, proposer);\n        } else {\n            // Deletes auction info\n            delete buyoutInfo[_vault];\n            // Transfers fractions and ether back to proposer of the buyout pool\n            IERC1155(token).safeTransferFrom(\n                address(this),\n                proposer,\n                id,\n                tokenBalance,\n                \"\"\n            );\n            _sendEthOrWeth(proposer, ethBalance);\n            // Emits event for ending unsuccessful auction\n            emit End(_vault, State.INACTIVE, proposer);\n        }\n    }\n\n    /// @notice Cashes out proceeds from a successful buyout\n    /// @param _vault Address of the vault\n    /// @param _burnProof Merkle proof for burning fractional tokens\n    function cash(address _vault, bytes32[] calldata _burnProof) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not successful\n        (, , State current, , uint256 ethBalance, ) = this.buyoutInfo(_vault);\n        State required = State.SUCCESS;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if caller has a balance of zero fractional tokens\n        uint256 tokenBalance = IERC1155(token).balanceOf(msg.sender, id);\n        if (tokenBalance == 0) revert NoFractions();\n\n        // Initializes vault transaction\n        bytes memory data = abi.encodeCall(\n            ISupply.burn,\n            (msg.sender, tokenBalance)\n        );\n        // Executes burn of fractional tokens from caller\n        IVault(payable(_vault)).execute(supply, data, _burnProof);\n\n        // Transfers buyout share amount to caller based on total supply\n        uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);\n        uint256 buyoutShare = (tokenBalance * ethBalance) /\n            (totalSupply + tokenBalance);\n        _sendEthOrWeth(msg.sender, buyoutShare);\n        // Emits event for cashing out of buyout pool\n        emit Cash(_vault, msg.sender, buyoutShare);\n    }\n\n    /// @notice Terminates a vault with an inactive buyout\n    /// @param _vault Address of the vault"
    }
  ]
}