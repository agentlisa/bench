{
  "Title": "An incorrect interface version definition",
  "Content": "##### Description\n\n- https://github.com/ConicFinance/protocol/blob/7a66d26ef84f93059a811a189655e17c11d95f5c/contracts/CurveHandler.sol#L183\n\nIf `interfaceVersion_ == 0`, `_version_0_remove_liquidity_one_coin` is called in `CurveHandler`.\n\nThe following pools were found in the project with `0`:\n- REN_BTC (https://etherscan.io/address/0x93054188d876f558f4a66B2EF1d97d16eDf0895B)\n- SUSD_DAI_USDT_USDC (https://etherscan.io/address/0xA5407eAE9Ba41422680e2e00537571bcC53efBfD)\n\nAll pools are considered as version `0`, but in `REN_BTC` there is a `remove_liquidity_one_coin` method. So, there is no need to use `_version_0_remove_liquidity_one_coin` for `REN_BTC`.\n\n##### Recommendation\nWe recommend revising the pool versioning process (https://github.com/ConicFinance/protocol/blob/7a66d26ef84f93059a811a189655e17c11d95f5c/contracts/CurveRegistryCache.sol#L235C14-L235C34).\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/CurveHandler.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../interfaces/pools/ILpToken.sol\";\nimport \"../interfaces/ICurveHandler.sol\";\nimport \"../interfaces/ICurveRegistryCache.sol\";\nimport \"../interfaces/vendor/IWETH.sol\";\nimport \"../interfaces/vendor/ICurvePoolV1.sol\";\nimport \"../interfaces/vendor/ICurvePoolV0.sol\";\nimport \"../interfaces/vendor/ICurvePoolV2.sol\";\nimport \"../interfaces/vendor/ICurvePoolV1Eth.sol\";\nimport \"../interfaces/vendor/ICurvePoolV2Eth.sol\";\nimport \"../interfaces/IController.sol\";\n\n/// @notice This contract acts as a wrapper for depositing and removing liquidity to and from Curve pools.\n/// Please be aware of the following:\n/// - This contract accepts WETH and unwraps it for Curve pool deposits\n/// - This contract should only be used through delegate calls for deposits and withdrawals\n/// - Slippage from deposits and withdrawals is handled in the ConicPool (do not use handler elsewhere)\ncontract CurveHandler is ICurveHandler {\n    using SafeERC20 for IERC20;\n\n    address internal constant _ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    IWETH internal constant _WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    // Normal calls to `exchange` functions will read various state variables, resulting in\n    // gas fees that are always in the double-digit thousand gas.\n    // On the other hand, a reentrant call will only read a single warm variable (100 gas)\n    // and call a contract already touched, so it will use vastly less than 5k gas.\n    // In practice, reentrant calls appear to use ~1.5k gas while non-reentrant\n    // calls use ~60k gas.\n    // We are better off setting this value a little too high compared to the ~1.5k estimate\n    // to make sure that we always prevent reentrant calls.\n    uint256 internal constant LOCK_GAS_THRESHOLD = 5_000;\n\n    // Recent factory pools are deployed using a minimal proxy pattern pointing to\n    // 1. `0x847ee1227a9900b73aeeb3a47fac92c52fd54ed9`\n    // 2. `0x94b4dfd9ba5865cc931195c99a2db42f3fc5d45b`\n    // The exact bytecodes are:\n    // 1. `0x363d3d373d3d3d363d73847ee1227a9900b73aeeb3a47fac92c52fd54ed95af43d82803e903d91602b57fd5bf3`\n    // 2. `0x363d3d373d3d3d363d7394b4dfd9ba5865cc931195c99a2db42f3fc5d45b5af43d82803e903d91602b57fd5bf3`\n    // that yield the following hashes, against which we can compare the result of `EXTCODEHASH` to\n    // check whether it is from this factory or not.\n    // This check is very local, so we do not include it in the `CurveRegistryCache`.\n    // Note that other pools may have `price_oracle` that do not check for reentrancy, so we cannot\n    // rely on this check for any pool with the `price_oracle` function.\n    // We only include the hash codes of pools created through factories, because\n    // the bytecode is otherwise slightly different for each pool\n    // Since this is only a optimization for gas purposes, we choose to make this constant,\n    // even if that means that we might miss this optimization for new factories deployed later.\n    bytes32 internal constant ETH_FACTORY_POOL_CODE_HASH_1 =\n        0x9e28a09452d2354fc4e15e3244dde27cbc4d52f12a10b91f2ca755b672bfa9be;\n    bytes32 internal constant ETH_FACTORY_POOL_CODE_HASH_2 =\n        0x3429b8decaf6b79a2721e434f60c3c47b9961fdba16eb6ac6c50d3690ac25276;\n\n    IController internal immutable controller;\n\n    constructor(address controller_) {\n        controller = IController(controller_);\n    }\n\n    /// @notice Deposits single sided liquidity into a Curve pool\n    /// @dev This supports both v1 and v2 (crypto) pools.\n    /// @param _curvePool Curve pool to deposit into\n    /// @param _token Asset to deposit\n    /// @param _amount Amount of asset to deposit\n    function deposit(address _curvePool, address _token, uint256 _amount) public override {\n        ICurveRegistryCache registry_ = controller.curveRegistryCache();\n        bool isETH = _isETH(_curvePool, _token);\n        if (!registry_.hasCoinDirectly(_curvePool, isETH ? _ETH_ADDRESS : _token)) {\n            address intermediate = registry_.basePool(_curvePool);\n            require(intermediate != address(0), \"CurveHandler: intermediate not found\");\n            address lpToken = registry_.lpToken(intermediate);\n            uint256 balanceBefore = ILpToken(lpToken).balanceOf(address(this));\n            _addLiquidity(intermediate, _amount, _token);\n            _token = lpToken;\n            _amount = ILpToken(_token).balanceOf(address(this)) - balanceBefore;\n        }\n        _addLiquidity(_curvePool, _amount, _token);\n    }\n\n    /// @notice Withdraws single sided liquidity from a Curve pool\n    /// @param _curvePool Curve pool to withdraw from\n    /// @param _token Underlying asset to withdraw\n    /// @param _amount Amount of Curve LP tokens to withdraw\n    function withdraw(address _curvePool, address _token, uint256 _amount) external override {\n        ICurveRegistryCache registry_ = controller.curveRegistryCache();\n        bool isETH = _isETH(_curvePool, _token);\n        if (!registry_.hasCoinDirectly(_curvePool, isETH ? _ETH_ADDRESS : _token)) {\n            address intermediate = registry_.basePool(_curvePool);\n            require(intermediate != address(0), \"CurveHandler: intermediate not found\");\n            address lpToken = registry_.lpToken(intermediate);\n            uint256 balanceBefore = ILpToken(lpToken).balanceOf(address(this));\n            _removeLiquidity(_curvePool, _amount, lpToken);\n            _curvePool = intermediate;\n            _amount = ILpToken(lpToken).balanceOf(address(this)) - balanceBefore;\n        }\n\n        _removeLiquidity(_curvePool, _amount, _token);\n    }\n\n    function isReentrantCall(address _curvePool) public override returns (bool) {\n        // In this version, curve pools have a price oracle that has a reentrancy lock\n        // so this call will only succeed if we are not in a reentrant call\n        // This is cheaper than trying to do an exchange\n        bytes32 codeHash = _curvePool.codehash;\n        if (codeHash == ETH_FACTORY_POOL_CODE_HASH_1 || codeHash == ETH_FACTORY_POOL_CODE_HASH_2) {\n            try ICurvePoolV2Eth(_curvePool).price_oracle() {\n                return false;\n            } catch {\n                return true;\n            }\n        }\n\n        uint256 interfaceVersion_ = controller.curveRegistryCache().interfaceVersion(_curvePool);\n        bool ethIndexFirst_ = _isEthIndexFirst(_curvePool);\n\n        // If we don't have any other way to check for reentrancy, we try to do a swap\n        // with 0 amount, which can behave in 3 ways depending on the state and the pool:\n        // 1. If it succeeds, there was definitely no lock in place, so the call is not reentrant\n        // 2. If it fails, it can fail in 2 ways:\n        //   a. It fails because some pools do not allow to swap 0 amount. This also means that the call is non-reentrant\n        //   b. It fails because there is a reentrancy lock in place, which means that the call is reentrant\n        // Checking for case 1 is trivial. For case 2a vs 2b, we check the amount of gas consumed by the call.\n        // Some more details about the values are given in the comments of `LOCK_GAS_THRESHOLD`\n        uint256 gasUsed;\n        uint256 currentGasLeft = gasleft();\n        if (interfaceVersion_ == 2) {\n            try\n                ICurvePoolV2Eth(_curvePool).exchange(\n                    ethIndexFirst_ ? uint256(0) : uint256(1),\n                    ethIndexFirst_ ? uint256(1) : uint256(0),\n                    uint256(0),\n                    uint256(0)\n                )\n            {\n                return false;\n            } catch {\n                gasUsed = currentGasLeft - gasleft();\n            }\n        } else {\n            try\n                ICurvePoolV1Eth(_curvePool).exchange(\n                    ethIndexFirst_ ? int128(0) : int128(1),\n                    ethIndexFirst_ ? int128(1) : int128(0),\n                    uint256(0),\n                    uint256(0)\n                )\n            {\n                return false;\n            } catch {\n                gasUsed = currentGasLeft - gasleft();\n            }\n        }\n\n        return gasUsed < LOCK_GAS_THRESHOLD;\n    }\n\n    /// @notice Validates if a given Curve pool is currently in reentrancy\n    /// @dev Reverts if it is in reentrancy\n    /// @param _curvePool Curve pool to validate\n    function reentrancyCheck(address _curvePool) external override {\n        require(!isReentrantCall(_curvePool), \"CurveHandler: reentrant call\");\n    }\n\n    function _removeLiquidity(\n        address _curvePool,\n        uint256 _amount, // Curve LP token amount\n        address _token // underlying asset to withdraw\n    ) internal {\n        bool isETH = _isETH(_curvePool, _token);\n        int128 index = controller.curveRegistryCache().coinIndex(\n            _curvePool,\n            isETH ? _ETH_ADDRESS : _token\n        );\n\n        uint256 balanceBeforeWithdraw = address(this).balance;\n\n        uint256 interfaceVersion_ = controller.curveRegistryCache().interfaceVersion(_curvePool);\n        if (interfaceVersion_ == 0) {\n            _version_0_remove_liquidity_one_coin(_curvePool, _amount, index);\n        } else if (interfaceVersion_ == 1) {\n            ICurvePoolV1(_curvePool).remove_liquidity_one_coin(_amount, index, 0);\n        } else if (interfaceVersion_ == 2) {\n            ICurvePoolV2(_curvePool).remove_liquidity_one_coin(\n                _amount,\n                uint256(uint128(index)),\n                0,\n                isETH,\n                address(this)\n            );\n        } else {\n            revert(\"CurveHandler: unsupported interface version\");\n        }\n\n        if (isETH) {\n            uint256 balanceIncrease = address(this).balance - balanceBeforeWithdraw;\n            _wrapWETH(balanceIncrease);\n        }\n    }\n\n    /// Version 0 pools don't have a `remove_liquidity_one_coin` function.\n    /// So we work around this by calling `removing_liquidity`\n    /// and then swapping all the coins to the target\n    function _version_0_remove_liquidity_one_coin(\n        address _curvePool,\n        uint256 _amount,\n        int128 _index\n    ) internal {\n        ICurveRegistryCache registry_ = controller.curveRegistryCache();\n        uint256 coins = registry_.nCoins(_curvePool);\n        if (coins == 2) {\n            uint256[2] memory min_amounts;\n            ICurvePoolV0(_curvePool).remove_liquidity(_amount, min_amounts);\n        } else if (coins == 3) {\n            uint256[3] memory min_amounts;\n            ICurvePoolV0(_curvePool).remove_liquidity(_amount, min_amounts);\n        } else if (coins == 4) {\n            uint256[4] memory min_amounts;\n            ICurvePoolV0(_curvePool).remove_liquidity(_amount, min_amounts);\n        } else if (coins == 5) {\n            uint256[5] memory min_amounts;\n            ICurvePoolV0(_curvePool).remove_liquidity(_amount, min_amounts);\n        } else if (coins == 6) {\n            uint256[6] memory min_amounts;\n            ICurvePoolV0(_curvePool).remove_liquidity(_amount, min_amounts);\n        } else if (coins == 7) {\n            uint256[7] memory min_amounts;\n            ICurvePoolV0(_curvePool).remove_liquidity(_amount, min_amounts);\n        } else if (coins == 8) {\n            uint256[8] memory min_amounts;\n            ICurvePoolV0(_curvePool).remove_liquidity(_amount, min_amounts);\n        } else {\n            revert(\"CurveHandler: unsupported coins\");\n        }\n\n        for (uint256 i = 0; i < coins; i++) {\n            if (i == uint256(int256(_index))) continue;\n            address[] memory coins_ = registry_.coins(_curvePool);\n            address coin_ = coins_[i];\n            uint256 balance_ = IERC20(coin_).balanceOf(address(this));\n            if (balance_ == 0) continue;\n            IERC20(coin_).safeApprove(_curvePool, balance_);\n            ICurvePoolV0(_curvePool).exchange(int128(int256(i)), _index, balance_, 0);\n        }\n    }\n\n    function _wrapWETH(uint256 amount) internal {\n        _WETH.deposit{value: amount}();\n    }\n\n    function _unwrapWETH(uint256 amount) internal {\n        _WETH.withdraw(amount);\n    }\n\n    function _addLiquidity(\n        address _curvePool,\n        uint256 _amount, // amount of asset to deposit\n        address _token // asset to deposit\n    ) internal {\n        bool isETH = _isETH(_curvePool, _token);\n        if (!isETH) {\n            IERC20(_token).safeIncreaseAllowance(_curvePool, _amount);\n        }\n\n        ICurveRegistryCache registry_ = controller.curveRegistryCache();\n        uint256 index = uint128(registry_.coinIndex(_curvePool, isETH ? _ETH_ADDRESS : _token));\n        uint256 coins = registry_.nCoins(_curvePool);\n        if (coins == 2) {\n            uint256[2] memory amounts;\n            amounts[index] = _amount;\n            if (isETH) {\n                _unwrapWETH(_amount);\n                ICurvePoolV1Eth(_curvePool).add_liquidity{value: _amount}(amounts, 0);\n            } else {\n                ICurvePoolV1(_curvePool).add_liquidity(amounts, 0);\n            }\n        } else if (coins == 3) {\n            uint256[3] memory amounts;\n            amounts[index] = _amount;\n            if (isETH) {\n                _unwrapWETH(_amount);\n                ICurvePoolV1Eth(_curvePool).add_liquidity{value: _amount}(amounts, 0);\n            } else {\n                ICurvePoolV1(_curvePool).add_liquidity(amounts, 0);\n            }\n        } else if (coins == 4) {\n            uint256[4] memory amounts;\n            amounts[index] = _amount;\n            if (isETH) {\n                _unwrapWETH(_amount);\n                ICurvePoolV1Eth(_curvePool).add_liquidity{value: _amount}(amounts, 0);\n            } else {\n                ICurvePoolV1(_curvePool).add_liquidity(amounts, 0);\n            }\n        } else if (coins == 5) {\n            uint256[5] memory amounts;\n            amounts[index] = _amount;\n            if (isETH) {\n                _unwrapWETH(_amount);\n                ICurvePoolV1Eth(_curvePool).add_liquidity{value: _amount}(amounts, 0);\n            } else {\n                ICurvePoolV1(_curvePool).add_liquidity(amounts, 0);\n            }\n        } else if (coins == 6) {\n            uint256[6] memory amounts;\n            amounts[index] = _amount;\n            if (isETH) {\n                _unwrapWETH(_amount);\n                ICurvePoolV1Eth(_curvePool).add_liquidity{value: _amount}(amounts, 0);\n            } else {\n                ICurvePoolV1(_curvePool).add_liquidity(amounts, 0);\n            }\n        } else if (coins == 7) {\n            uint256[7] memory amounts;\n            amounts[index] = _amount;\n            if (isETH) {\n                _unwrapWETH(_amount);\n                ICurvePoolV1Eth(_curvePool).add_liquidity{value: _amount}(amounts, 0);\n            } else {\n                ICurvePoolV1(_curvePool).add_liquidity(amounts, 0);\n            }\n        } else if (coins == 8) {\n            uint256[8] memory amounts;\n            amounts[index] = _amount;\n            if (isETH) {\n                _unwrapWETH(_amount);\n                ICurvePoolV1Eth(_curvePool).add_liquidity{value: _amount}(amounts, 0);\n            } else {\n                ICurvePoolV1(_curvePool).add_liquidity(amounts, 0);\n            }\n        } else {\n            revert(\"invalid number of coins for curve pool\");\n        }\n    }\n\n    function _isETH(address pool, address token) internal view returns (bool) {\n        return\n            token == address(_WETH) &&\n            controller.curveRegistryCache().hasCoinDirectly(pool, _ETH_ADDRESS);\n    }\n\n    function _isETH(address pool) internal view returns (bool) {\n        return controller.curveRegistryCache().hasCoinDirectly(pool, _ETH_ADDRESS);\n    }\n\n    function _isEthIndexFirst(address pool) internal view returns (bool) {\n        return controller.curveRegistryCache().coinIndex(pool, address(_WETH)) == int128(0);\n    }\n}"
    },
    {
      "filename": "contracts/CurveRegistryCache.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"../libraries/CurvePoolUtils.sol\";\n\nimport \"../interfaces/ICurveRegistryCache.sol\";\nimport \"../interfaces/vendor/ICurveMetaRegistry.sol\";\nimport \"../interfaces/vendor/ICurvePoolV1.sol\";\n\ncontract CurveRegistryCache is ICurveRegistryCache {\n    address internal constant _ETH = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n    address internal constant _WETH = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    ICurveMetaRegistry internal constant _CURVE_REGISTRY =\n        ICurveMetaRegistry(0xF98B45FA17DE75FB1aD0e7aFD971b0ca00e379fC);\n\n    IBooster public constant BOOSTER = IBooster(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);\n\n    modifier onlyInitialized(address pool) {\n        require(_isRegistered[pool], \"CurveRegistryCache: pool not initialized\");\n        _;\n    }\n\n    mapping(address => bool) internal _isRegistered;\n    mapping(address => address) internal _lpToken;\n    mapping(address => mapping(address => bool)) internal _hasCoinDirectly;\n    mapping(address => mapping(address => bool)) internal _hasCoinAnywhere;\n    mapping(address => address) internal _basePool;\n    mapping(address => mapping(address => int128)) internal _coinIndex;\n    mapping(address => uint256) internal _nCoins;\n    mapping(address => address[]) internal _coins;\n    mapping(address => uint256[]) internal _decimals;\n    mapping(address => address) internal _poolFromLpToken;\n    mapping(address => CurvePoolUtils.AssetType) internal _assetType;\n    mapping(address => uint256) internal _interfaceVersion;\n\n    /// Information needed for staking Curve LP tokens on Convex\n    mapping(address => uint256) internal _convexPid;\n    mapping(address => address) internal _convexRewardPool; // curve pool => CRV rewards pool (convex)\n\n    function initPool(address pool_) external override {\n        _initPool(pool_, false, 0);\n    }\n\n    function initPool(address pool_, uint256 pid_) external override {\n        _initPool(pool_, true, pid_);\n    }\n\n    function _initPool(address pool_, bool setPid_, uint256 pid_) internal {\n        if (_isRegistered[pool_]) return;\n        require(_isCurvePool(pool_), \"CurveRegistryCache: invalid curve pool\");\n\n        _isRegistered[pool_] = true;\n        address curveLpToken_ = _CURVE_REGISTRY.get_lp_token(pool_);\n        _lpToken[pool_] = curveLpToken_;\n        if (setPid_) {\n            _setConvexPid(pool_, curveLpToken_, pid_);\n        } else {\n            pid_ = _setConvexPid(pool_, curveLpToken_);\n        }\n        _poolFromLpToken[curveLpToken_] = pool_;\n        address basePool_ = _CURVE_REGISTRY.get_base_pool(pool_);\n        _basePool[pool_] = basePool_;\n        if (basePool_ != address(0)) {\n            _initPool(basePool_, false, 0);\n            address[] memory basePoolCoins_ = _coins[basePool_];\n            for (uint256 i; i < basePoolCoins_.length; i++) {\n                address coin_ = basePoolCoins_[i];\n                _hasCoinAnywhere[pool_][coin_] = true;\n            }\n        }\n        _assetType[pool_] = CurvePoolUtils.AssetType(_CURVE_REGISTRY.get_pool_asset_type(pool_));\n        uint256 nCoins_ = _CURVE_REGISTRY.get_n_coins(pool_);\n        address[8] memory staticCoins_ = _CURVE_REGISTRY.get_coins(pool_);\n        uint256[8] memory staticDecimals_ = _CURVE_REGISTRY.get_decimals(pool_);\n        address[] memory coins_ = new address[](nCoins_);\n        for (uint256 i; i < nCoins_; i++) {\n            address coin_ = staticCoins_[i];\n            require(coin_ != address(0), \"CurveRegistryCache: invalid coin\");\n            coins_[i] = coin_;\n            _hasCoinDirectly[pool_][coin_] = true;\n            _hasCoinAnywhere[pool_][coin_] = true;\n            _coinIndex[pool_][coin_] = int128(uint128(i));\n            _decimals[pool_].push(staticDecimals_[i]);\n\n            if (coin_ == _ETH) {\n                coin_ = _WETH;\n                coins_[i] = coin_;\n                _hasCoinDirectly[pool_][coin_] = true;\n                _hasCoinAnywhere[pool_][coin_] = true;\n                _coinIndex[pool_][coin_] = int128(uint128(i));\n            }\n        }\n        _nCoins[pool_] = nCoins_;\n        _coins[pool_] = coins_;\n        _interfaceVersion[pool_] = _getInterfaceVersion(pool_);\n\n        emit PoolInitialized(pool_, pid_);\n    }\n\n    function _setConvexPid(address pool_, address lpToken_) internal returns (uint256 pid_) {\n        uint256 length = BOOSTER.poolLength();\n        address rewardPool;\n        for (uint256 i; i < length; i++) {\n            (address curveToken, , , address rewardPool_, , bool _isShutdown) = BOOSTER.poolInfo(i);\n            if (lpToken_ != curveToken || _isShutdown) continue;\n            rewardPool = rewardPool_;\n            pid_ = i;\n            _convexPid[pool_] = i;\n            break;\n        }\n        /// Only Curve pools that have a valid Convex PID can be added to the cache\n        require(rewardPool != address(0), \"no convex pid found\");\n        _convexRewardPool[pool_] = rewardPool;\n    }\n\n    function _setConvexPid(address pool_, address lpToken_, uint256 pid_) internal {\n        (address curveToken, , , address rewardPool_, , bool _isShutdown) = BOOSTER.poolInfo(pid_);\n        require(lpToken_ == curveToken, \"invalid lp token for curve pool\");\n        require(!_isShutdown, \"convex pool is shutdown\");\n        require(rewardPool_ != address(0), \"no convex pid found\");\n        _convexRewardPool[pool_] = rewardPool_;\n        _convexPid[pool_] = pid_;\n    }\n\n    function isRegistered(address pool_) external view override returns (bool) {\n        return _isRegistered[pool_];\n    }\n\n    function lpToken(\n        address pool_\n    ) external view override onlyInitialized(pool_) returns (address) {\n        return _lpToken[pool_];\n    }\n\n    function assetType(\n        address pool_\n    ) external view override onlyInitialized(pool_) returns (CurvePoolUtils.AssetType) {\n        return _assetType[pool_];\n    }\n\n    function hasCoinDirectly(\n        address pool_,\n        address coin_\n    ) external view override onlyInitialized(pool_) returns (bool) {\n        return _hasCoinDirectly[pool_][coin_];\n    }\n\n    function hasCoinAnywhere(\n        address pool_,\n        address coin_\n    ) external view override onlyInitialized(pool_) returns (bool) {\n        return _hasCoinAnywhere[pool_][coin_];\n    }\n\n    function basePool(\n        address pool_\n    ) external view override onlyInitialized(pool_) returns (address) {\n        return _basePool[pool_];\n    }\n\n    function coinIndex(\n        address pool_,\n        address coin_\n    ) external view override onlyInitialized(pool_) returns (int128) {\n        return _coinIndex[pool_][coin_];\n    }\n\n    function nCoins(address pool_) external view override onlyInitialized(pool_) returns (uint256) {\n        return _nCoins[pool_];\n    }\n\n    function coinIndices(\n        address pool_,\n        address from_,\n        address to_\n    ) external view override onlyInitialized(pool_) returns (int128, int128, bool) {\n        return (\n            _coinIndex[pool_][from_],\n            _coinIndex[pool_][to_],\n            _hasCoinDirectly[pool_][from_] && _hasCoinDirectly[pool_][to_]\n        );\n    }\n\n    function decimals(\n        address pool_\n    ) external view override onlyInitialized(pool_) returns (uint256[] memory) {\n        return _decimals[pool_];\n    }\n\n    /// @notice Returns the Curve interface version for a given pool\n    /// @dev Version 0 uses `int128` for `coins` and `balances`, and `int128` for `get_dy`\n    /// Version 1 uses `uint256` for `coins` and `balances`, and `int128` for `get_dy`\n    /// Version 2 uses `uint256` for `coins` and `balances`, and `uint256` for `get_dy`\n    /// They correspond with which interface the pool implements: ICurvePoolV0, ICurvePoolV1, ICurvePoolV2\n    function interfaceVersion(\n        address pool_\n    ) external view override onlyInitialized(pool_) returns (uint256) {\n        return _interfaceVersion[pool_];\n    }\n\n    function poolFromLpToken(address lpToken_) external view override returns (address) {\n        return _poolFromLpToken[lpToken_];\n    }\n\n    function coins(\n        address pool_\n    ) external view override onlyInitialized(pool_) returns (address[] memory) {\n        return _coins[pool_];\n    }\n\n    function getPid(address pool_) external view override onlyInitialized(pool_) returns (uint256) {\n        require(_convexRewardPool[pool_] != address(0), \"pid not found\");\n        return _convexPid[pool_];\n    }\n\n    function getRewardPool(\n        address pool_\n    ) external view override onlyInitialized(pool_) returns (address) {\n        return _convexRewardPool[pool_];\n    }\n\n    function isShutdownPid(uint256 pid_) external view override returns (bool) {\n        (, , , , , bool _isShutdown) = BOOSTER.poolInfo(pid_);\n        return _isShutdown;\n    }\n\n    function _isCurvePool(address pool_) internal view returns (bool) {\n        try _CURVE_REGISTRY.is_registered(pool_) returns (bool registered_) {\n            return registered_;\n        } catch {\n            return false;\n        }\n    }\n\n    function _getInterfaceVersion(address pool_) internal view returns (uint256) {\n        if (_assetType[pool_] == CurvePoolUtils.AssetType.CRYPTO) return 2;\n        try ICurvePoolV1(pool_).balances(uint256(0)) returns (uint256) {\n            return 1;\n        } catch {\n            return 0;\n        }\n    }\n}"
    }
  ]
}