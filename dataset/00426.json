{
  "Title": "M-7: Penrose::_depositFeesToTwTap can unexpectedly revert due to amount rounded down",
  "Content": "# Issue M-7: Penrose::_depositFeesToTwTap can unexpectedly revert due to amount rounded down \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/43 \n\n## Found by \ncergyk, ctf\\_sec\n## Summary\n_depositFeesToTwTap computes the amount of fees withdrawn after having it withdrawn. There may be a difference with actual fees withdrawn which could cause the function to revert unexpectedly\n\n## Vulnerability Detail\nWe can see the fees being withdrawn [here](https://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/Penrose.sol#L573), but instead of using the amount withdrawn, the amount is recomputed from shares [here](https://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/Penrose.sol#L576)\n\nThis can be problematic if during first call the fee amount is rounded down, but after being withdrawn, it is not being rounded down\n\n### Example\n\n- before withdrawal:\n\nbase: 7\nelastic: 13\nshare: 2\n\namount withdrawn: 13*2/7 = 3\nshares deducted = 2\n\n- after withdrawal:\n\nbase: 5\nelastic: 10\nshare: 2\n\namount computed: 10*2/5 = 4\n\nThe transfer reverts because only 3 has been withdrawn\n\n## Impact\nThe call will withdraw unexpectedly in some cases, dosing fees withdrawal\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\nCompute the amount of fees which will be withdrawn before making the actual withdrawal in `_depositFeesToTwTap`\n\n\n\n## Discussion\n\n**nevillehuang**\n\nrequest poc\n\nSeems valid, however, is there a workaround to prevent this DoS? Also the example is not representative of scaled actual values.\n\n\n\n**sherlock-admin3**\n\nPoC requested from @CergyK\n\nRequests remaining: **6**\n\n**cryptotechmaker**\n\nFixed in https://github.com/Tapioca-DAO/Tapioca-bar/pull/353\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Tapioca-DAO/Tapioca-bar/pull/353.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "Tapioca-bar/contracts/Penrose.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {IERC20} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport {BoringFactory} from \"@boringcrypto/boring-solidity/contracts/BoringFactory.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n// Tapioca\nimport {\n    ERC20WithoutStrategy, IStrategy, IYieldBox as IBoringYieldBox\n} from \"yieldbox/strategies/ERC20WithoutStrategy.sol\";\nimport {PearlmitHandler, IPearlmit} from \"tapioca-periph/pearlmit/PearlmitHandler.sol\";\nimport {ICluster} from \"tapioca-periph/interfaces/periph/ICluster.sol\";\nimport {IMarket} from \"tapioca-periph/interfaces/bar/ISingularity.sol\";\nimport {ITwTap} from \"tapioca-periph/interfaces/tap-token/ITwTap.sol\";\nimport {IPenrose} from \"tapioca-periph/interfaces/bar/IPenrose.sol\";\nimport {IBigBang} from \"tapioca-periph/interfaces/bar/IBigBang.sol\";\nimport {TokenType} from \"yieldbox/enums/YieldBoxTokenType.sol\";\nimport {IUsdo} from \"tapioca-periph/interfaces/oft/IUsdo.sol\";\nimport {IYieldBox} from \"yieldbox/interfaces/IYieldBox.sol\";\nimport {SafeApprove} from \"./libraries/SafeApprove.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/// @title Global market registry\n/// @notice Singularity management\ncontract Penrose is Ownable, PearlmitHandler, BoringFactory {\n    using SafeApprove for address;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    /// @notice returns the Conservator address\n    address public conservator;\n    /// @notice returns the pause state of the contract\n    bool public paused;\n    /// @notice returns the Cluster contract\n    ICluster public cluster;\n\n    /// @notice returns the YieldBox contract\n    IYieldBox public immutable yieldBox;\n    /// @notice returns the TAP contract\n    IERC20 public immutable tapToken;\n    /// @notice returns TAP asset id registered in the YieldBox contract\n    uint256 public immutable tapAssetId;\n    /// @notice returns USDO contract\n    IERC20 public usdoToken;\n    /// @notice returns USDO asset id registered in the YieldBox contract\n    uint256 public usdoAssetId;\n    /// @notice returns the WETH/main contract\n    IERC20 public immutable mainToken;\n    /// @notice returns WETH/main asset id registered in the YieldBox contract\n    uint256 public immutable mainAssetId;\n\n    /// @notice Singularity master contracts\n    IPenrose.MasterContract[] public singularityMasterContracts;\n    /// @notice BigBang master contracts\n    IPenrose.MasterContract[] public bigbangMasterContracts;\n\n    /// @notice Used to check if a Singularity master contract is registered\n    mapping(address => bool) public isSingularityMasterContractRegistered;\n    /// @notice Used to check if a BigBang master contract is registered\n    mapping(address => bool) public isBigBangMasterContractRegistered;\n    /// @notice Used to check if a SGL/BB is a real market\n    mapping(address => bool) public isMarketRegistered;\n    /// @notice default LZ Chain id\n    uint32 public immutable hostLzChainId;\n\n    /// @notice BigBang ETH market addressf\n    address public bigBangEthMarket;\n    /// @notice BigBang ETH market debt rate\n    uint256 public bigBangEthDebtRate;\n\n    /// @notice registered empty strategies\n    mapping(address => IStrategy) public emptyStrategies;\n\n    address[] public allBigBangMarkets;\n\n    mapping(address => bool) public isOriginRegistered;\n    address[] public allOriginsMarkets;\n\n    /// @notice creates a Penrose contract\n    /// @param _yieldBox YieldBox contract address\n    /// @param _cluster Cluster contract address\n    /// @param tapToken_ TapOFT contract address\n    /// @param mainToken_ WETH contract address\n    /// @param _owner owner address\n    constructor(\n        IYieldBox _yieldBox,\n        ICluster _cluster,\n        IERC20 tapToken_,\n        IERC20 mainToken_,\n        IPearlmit _pearlmit,\n        address _owner\n    ) PearlmitHandler(_pearlmit) {\n        yieldBox = _yieldBox;\n        cluster = _cluster;\n        tapToken = tapToken_;\n\n        emptyStrategies[address(tapToken_)] =\n            IStrategy(address(new ERC20WithoutStrategy(IBoringYieldBox(address(_yieldBox)), tapToken_)));\n        tapAssetId = uint96(\n            _yieldBox.registerAsset(\n                TokenType.ERC20, address(tapToken_), address(emptyStrategies[address(tapToken_)]), 0\n            )\n        );\n\n        mainToken = mainToken_;\n        emptyStrategies[address(mainToken_)] =\n            IStrategy(address(new ERC20WithoutStrategy(IBoringYieldBox(address(_yieldBox)), mainToken_)));\n        mainAssetId = uint96(\n            _yieldBox.registerAsset(\n                TokenType.ERC20, address(mainToken_), address(emptyStrategies[address(mainToken_)]), 0\n            )\n        );\n\n        bigBangEthDebtRate = 5e15;\n\n        _transferOwnership(_owner);\n    }\n\n    // **************//\n    // *** EVENTS *** //\n    // ************** //\n    /// @notice event emitted when fees are extracted\n    event ProtocolWithdrawal(IMarket[] indexed markets, uint256 indexed timestamp);\n    /// @notice event emitted when Singularity master contract is registered\n    event RegisterSingularityMasterContract(address indexed location, IPenrose.ContractType indexed risk);\n    /// @notice event emitted when BigBang master contract is registered\n    event RegisterBigBangMasterContract(address indexed location, IPenrose.ContractType indexed risk);\n    /// @notice event emitted when Singularity is registered\n    event RegisterSingularity(address indexed location, address indexed masterContract);\n    /// @notice event emitted when BigBang is registered\n    event RegisterBigBang(address indexed location, address indexed masterContract);\n    /// @notice event emitted when Origins is registered\n    event RegisterOrigins(address indexed location);\n    /// @notice event emitted when USDO address is updated\n    event UsdoTokenUpdated(address indexed usdoToken, uint256 indexed assetId);\n    /// @notice event emitted when conservator is updated\n    event ConservatorUpdated(address indexed old, address indexed _new);\n    /// @notice event emitted when pause state is updated\n    event PausedUpdated(bool indexed oldState, bool indexed newState);\n    /// @notice event emitted when BigBang ETH market address is updated\n    event BigBangEthMarketUpdated(address indexed _oldAddress, address indexed _newAddress);\n    /// @notice event emitted when BigBang ETH market debt rate is updated\n    event BigBangEthMarketDebtRateUpdated(uint256 indexed _oldRate, uint256 indexed _newRate);\n    /// @notice event emitted when fees are deposited to twTap\n    event LogTwTapFeesDeposit(uint256 indexed amount);\n    /// @notice event emitted when Cluster is set\n    event ClusterSet(address indexed old, address indexed _new);\n    /// @notice event emitted when total BB markets debt is computed\n    event TotalUsdoDebt(uint256 indexed amount);\n    /// @notice event emitted when markets are re-accrued\n    event ReaccruedMarkets(bool indexed mainMarketIncluded);\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error NotRegistered();\n    error NotValid();\n    error Paused();\n    error NotAuthorized();\n    error Registered();\n    error ZeroAddress();\n    error Failed();\n    error AlreadyAdded();\n    error LengthMismatch();\n\n    // ******************//\n    // *** MODIFIERS *** //\n    // ***************** //\n    modifier registeredSingularityMasterContract(address mc) {\n        if (!isSingularityMasterContractRegistered[mc]) revert NotRegistered();\n        _;\n    }\n\n    modifier registeredBigBangMasterContract(address mc) {\n        if (!isBigBangMasterContractRegistered[mc]) revert NotRegistered();\n        _;\n    }\n\n    modifier notPaused() {\n        if (paused) revert Paused();\n        _;\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice Get all the Singularity contract addresses\n    /// @return markets list of available markets\n    function singularityMarkets() external view returns (address[] memory markets) {\n        markets = getAllMasterContractClones(singularityMasterContracts);\n    }\n\n    /// @notice Get all the BigBang contract addresses\n    /// @return markets list of available markets\n    function bigBangMarkets() external view returns (address[] memory markets) {\n        markets = getAllMasterContractClones(bigbangMasterContracts);\n    }\n\n    /// @notice Get the length of `singularityMasterContracts`\n    function singularityMasterContractLength() external view returns (uint256) {\n        return singularityMasterContracts.length;\n    }\n\n    /// @notice Get the length of `bigbangMasterContracts`\n    function bigBangMasterContractLength() external view returns (uint256) {\n        return bigbangMasterContracts.length;\n    }\n\n    /// @notice Returns total markets debt\n    /// @dev does not include Origins markets\n    function viewTotalDebt() public view returns (uint256) {\n        uint256 _totalUsdoDebt = 0;\n        uint256 len = allBigBangMarkets.length;\n        for (uint256 i; i < len; i++) {\n            IMarket market = IMarket(allBigBangMarkets[i]);\n            if (isMarketRegistered[address(market)]) {\n                (uint256 elastic,) = market.totalBorrow();\n                _totalUsdoDebt += elastic;\n            }\n        }\n\n        return _totalUsdoDebt;\n    }\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n    /// @notice Loop through the master contracts and call `_depositFeesToTwTap()` to each one of their clones.\n    /// @param markets_ Singularity &/ BigBang markets array\n    /// @param twTap the TwTap contract\n    function withdrawAllMarketFees(IMarket[] calldata markets_, ITwTap twTap) external onlyOwner notPaused {\n        if (address(twTap) == address(0)) revert ZeroAddress();\n\n        uint256 length = markets_.length;\n        unchecked {\n            for (uint256 i; i < length;) {\n                _depositFeesToTwTap(markets_[i], twTap);\n                ++i;\n            }\n        }\n\n        emit ProtocolWithdrawal(markets_, block.timestamp);\n    }\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n    /// @notice mints USDO based on current open interest\n    /// @dev Penrose should be an allowed minter for USDO\n    /// @param twTap the twTap contract address\n    function mintOpenInterestDebt(address twTap) external onlyOwner {\n        uint256 usdoSupply = usdoToken.totalSupply();\n\n        // nothing to mint when there's no activity\n        if (usdoSupply > 0) {\n            // re-compute latest debt\n            uint256 totalUsdoDebt = computeTotalDebt();\n\n            //add Origins debt\n            //Origins market doesn't accrue in time but increases totalSupply\n            //and needs to be taken into account here\n            uint256 len = allOriginsMarkets.length;\n            for (uint256 i; i < len; i++) {\n                IMarket market = IMarket(allOriginsMarkets[i]);\n                if (isOriginRegistered[address(market)]) {\n                    (uint256 elastic,) = market.totalBorrow();\n                    totalUsdoDebt += elastic;\n                }\n            }\n\n            //debt should always be > USDO supply\n            if (totalUsdoDebt > usdoSupply) {\n                uint256 _amount = totalUsdoDebt - usdoSupply;\n\n                //mint against the open interest; supply should be fully minted now\n                IUsdo(address(usdoToken)).mint(address(this), _amount);\n\n                //send it to twTap\n                uint256 rewardTokenId = ITwTap(twTap).rewardTokenIndex(address(usdoToken));\n                _distributeOnTwTap(_amount, rewardTokenId, address(usdoToken), ITwTap(twTap));\n            }\n        }\n    }\n\n    /// @notice sets the Cluster address\n    /// @dev can only be called by the owner\n    /// @param _newCluster the new address\n    function setCluster(address _newCluster) external onlyOwner {\n        if (_newCluster == address(0)) revert ZeroAddress();\n        emit ClusterSet(address(cluster), _newCluster);\n        cluster = ICluster(_newCluster);\n    }\n\n    /// @notice sets the main BigBang market debt rate\n    /// @dev can only be called by the owner\n    /// @param _rate the new rate\n    function setBigBangEthMarketDebtRate(uint256 _rate) external onlyOwner {\n        if (bigBangEthMarket != address(0)) {\n            IBigBang(bigBangEthMarket).accrue();\n        }\n        bigBangEthDebtRate = _rate;\n        emit BigBangEthMarketDebtRateUpdated(bigBangEthDebtRate, _rate);\n    }\n\n    /// @notice sets the main BigBang market\n    /// @dev needed for the variable debt computation\n    /// @param _market the new market address\n    function setBigBangEthMarket(address _market) external onlyOwner {\n        if (_market == address(0)) revert ZeroAddress();\n\n        if (bigBangEthMarket != address(0)) {\n            uint256 len = allBigBangMarkets.length;\n            address[] memory markets = allBigBangMarkets;\n            for (uint256 i = 0; i < len; i++) {\n                address market = markets[i];\n                if (market != bigBangEthMarket && isMarketRegistered[market]) {\n                    IBigBang(market).accrue();\n                }\n            }\n        }\n\n        emit BigBangEthMarketUpdated(bigBangEthMarket, _market);\n        bigBangEthMarket = _market;\n    }\n\n    /// @notice updates the pause state of the contract\n    /// @dev can only be called by the conservator\n    /// @param val the new value\n    function updatePause(bool val) external {\n        if (msg.sender != conservator) revert NotAuthorized();\n        if (val == paused) revert NotValid();\n        emit PausedUpdated(paused, val);\n        paused = val;\n    }\n\n    /// @notice Set the Conservator address\n    /// @dev Conservator can pause the contract\n    /// @param _conservator The new address\n    function setConservator(address _conservator) external onlyOwner {\n        if (_conservator == address(0)) revert ZeroAddress();\n        emit ConservatorUpdated(conservator, _conservator);\n        conservator = _conservator;\n    }\n\n    /// @notice Set the USDO token\n    /// @dev sets usdoToken and usdoAssetId\n    ///      can only by called by the owner\n    /// @param _usdoToken the USDO token address\n    function setUsdoToken(address _usdoToken) external onlyOwner {\n        if (address(usdoToken) != address(0)) revert NotAuthorized();\n        usdoToken = IERC20(_usdoToken);\n\n        emptyStrategies[_usdoToken] =\n            IStrategy(address(new ERC20WithoutStrategy(IBoringYieldBox(address(yieldBox)), IERC20(_usdoToken))));\n        usdoAssetId =\n            uint96(yieldBox.registerAsset(TokenType.ERC20, _usdoToken, address(emptyStrategies[_usdoToken]), 0));\n        emit UsdoTokenUpdated(_usdoToken, usdoAssetId);\n    }\n\n    /// @notice Register a Singularity master contract\n    /// @dev can only be called by the owner\n    /// @param mcAddress The address of the contract\n    /// @param contractType_ The risk type of the contract\n    function registerSingularityMasterContract(address mcAddress, IPenrose.ContractType contractType_)\n        external\n        onlyOwner\n    {\n        if (isSingularityMasterContractRegistered[mcAddress]) {\n            revert Registered();\n        }\n\n        IPenrose.MasterContract memory mc;\n        mc.location = mcAddress;\n        mc.risk = contractType_;\n        singularityMasterContracts.push(mc);\n        isSingularityMasterContractRegistered[mcAddress] = true;\n\n        emit RegisterSingularityMasterContract(mcAddress, contractType_);\n    }\n\n    /// @notice Register a BigBang master contract\n    /// @dev can only be called by the owner\n    /// @param mcAddress The address of the contract\n    /// @param contractType_ The risk type of the contract\n    function registerBigBangMasterContract(address mcAddress, IPenrose.ContractType contractType_) external onlyOwner {\n        if (isBigBangMasterContractRegistered[mcAddress]) revert Registered();\n\n        IPenrose.MasterContract memory mc;\n        mc.location = mcAddress;\n        mc.risk = contractType_;\n        bigbangMasterContracts.push(mc);\n        isBigBangMasterContractRegistered[mcAddress] = true;\n\n        emit RegisterBigBangMasterContract(mcAddress, contractType_);\n    }\n\n    /// @notice Registers a Singularity market\n    /// @dev can only be called by the owner\n    /// @param mc The address of the master contract which must be already registered\n    /// @param data The init data of the Singularity\n    /// @param useCreate2 Whether to use create2 or not\n    /// @return _contract the created contract\n    function registerSingularity(address mc, bytes calldata data, bool useCreate2)\n        external\n        payable\n        onlyOwner\n        registeredSingularityMasterContract(mc)\n        returns (address _contract)\n    {\n        _contract = deploy(mc, data, useCreate2);\n        if (_contract == address(0)) revert ZeroAddress();\n        if (_contract.code.length == 0) revert Failed();\n        isMarketRegistered[_contract] = true;\n        emit RegisterSingularity(_contract, mc);\n    }\n\n    /// @notice Registers an existing Singularity market (without deployment)\n    /// @dev can only be called by the owner\n    /// @param mc The address of the master contract which must be already registered\n    /// @param _contract The address of SGL\n    function addSingularity(address mc, address _contract) external onlyOwner registeredSingularityMasterContract(mc) {\n        if (isMarketRegistered[_contract]) revert AlreadyAdded();\n        isMarketRegistered[_contract] = true;\n        clonesOf[mc].push(_contract);\n        masterContractOf[_contract] = mc;\n        emit RegisterSingularity(_contract, mc);\n    }\n\n    /// @notice Registers a BigBang market\n    /// @dev can only be called by the owner\n    /// @param mc The address of the master contract which must be already registered\n    /// @param data The init data of the BigBang contract\n    /// @param useCreate2 Whether to use create2 or not\n    /// @return _contract the created contract\n    function registerBigBang(address mc, bytes calldata data, bool useCreate2)\n        external\n        payable\n        onlyOwner\n        registeredBigBangMasterContract(mc)\n        returns (address _contract)\n    {\n        _contract = deploy(mc, data, useCreate2);\n        if (_contract == address(0)) revert ZeroAddress();\n        if (_contract.code.length == 0) revert Failed();\n        isMarketRegistered[_contract] = true;\n        allBigBangMarkets.push(_contract);\n        emit RegisterBigBang(_contract, mc);\n    }\n\n    /// @notice Registers an existing BigBang market (without deployment)\n    /// @dev can only be called by the owner\n    /// @param mc The address of the master contract which must be already registered\n    /// @param _contract The address of BB\n    function addBigBang(address mc, address _contract) external onlyOwner registeredBigBangMasterContract(mc) {\n        if (isMarketRegistered[_contract]) revert AlreadyAdded();\n        isMarketRegistered[_contract] = true;\n        clonesOf[mc].push(_contract);\n        masterContractOf[_contract] = mc;\n        allBigBangMarkets.push(_contract);\n        emit RegisterBigBang(_contract, mc);\n    }\n\n    function addOriginsMarket(address _contract) external onlyOwner {\n        if (isOriginRegistered[_contract]) revert AlreadyAdded();\n        isOriginRegistered[_contract] = true;\n        allOriginsMarkets.push(_contract);\n        emit RegisterOrigins(_contract);\n    }\n\n    /// @notice Execute an only owner function inside of a Singularity or a BigBang market\n    /// @param mc Master contracts array\n    /// @param data array\n    /// @param forceSuccess if true, method reverts in case of an unsuccessful execution\n    function executeMarketFn(address[] calldata mc, bytes[] memory data, bool forceSuccess)\n        external\n        onlyOwner\n        returns (bool[] memory success, bytes[] memory result)\n    {\n        uint256 len = mc.length;\n        if (len != data.length) revert LengthMismatch();\n        success = new bool[](len);\n        result = new bytes[](len);\n        for (uint256 i; i < len;) {\n            if (\n                !isSingularityMasterContractRegistered[masterContractOf[mc[i]]]\n                    && !isBigBangMasterContractRegistered[masterContractOf[mc[i]]]\n            ) revert NotAuthorized();\n            if (address(mc[i]).code.length == 0) revert NotValid();\n            (success[i], result[i]) = mc[i].call(data[i]);\n            if (forceSuccess) {\n                require(success[i], _getRevertMsg(result[i]));\n            }\n            ++i;\n        }\n    }\n\n    /// @notice Calls `accrue()` on all BigBang registered markets\n    /// @dev callable by BigBang ETH market only\n    function reAccrueBigBangMarkets() external notPaused {\n        if (msg.sender == bigBangEthMarket) {\n            _reAccrueMarkets(false);\n        }\n    }\n\n    /// @notice computes total USDO debt of all BB markets\n    /// @dev this works because all BB markets have USDO as the asset\n    function computeTotalDebt() public notPaused returns (uint256 totalUsdoDebt) {\n        // allow other registered Markets, owner or Penrose to call it\n        if (!isMarketRegistered[msg.sender] && msg.sender != owner() && msg.sender != address(this)) {\n            revert NotAuthorized();\n        }\n\n        //accrue to the latest point in time\n        _reAccrueMarkets(true);\n\n        // compute debt\n        totalUsdoDebt = viewTotalDebt();\n\n        emit TotalUsdoDebt(totalUsdoDebt);\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _getRevertMsg(bytes memory _returnData) private pure returns (string memory) {\n        if (_returnData.length > 1000) return \"SGL: reason too long\";\n\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return \"SGL: no return data\";\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n\n    function _reAccrueMarkets(bool includeMainMarket) private {\n        uint256 len = allBigBangMarkets.length;\n        address[] memory markets = allBigBangMarkets;\n        for (uint256 i; i < len; i++) {\n            address market = markets[i];\n            if (isMarketRegistered[market]) {\n                if (includeMainMarket || market != bigBangEthMarket) {\n                    IBigBang(market).accrue();\n                }\n            }\n        }\n\n        emit ReaccruedMarkets(includeMainMarket);\n    }\n\n    function _depositFeesToTwTap(IMarket market, ITwTap twTap) private {\n        if (!isMarketRegistered[address(market)]) revert NotValid();\n\n        uint256 feeShares = market.refreshPenroseFees();\n        if (feeShares == 0) return;\n\n        address _asset = market.asset();\n        uint256 _assetId = market.assetId();\n        yieldBox.withdraw(_assetId, address(this), address(this), 0, feeShares);\n\n        uint256 rewardTokenId = twTap.rewardTokenIndex(_asset);\n        uint256 feeAmount = yieldBox.toAmount(_assetId, feeShares, false);\n        _distributeOnTwTap(feeAmount, rewardTokenId, _asset, twTap);\n    }\n\n    function _distributeOnTwTap(uint256 amount, uint256 rewardTokenId, address _asset, ITwTap twTap) private {\n        _asset.safeApprove(address(twTap), amount);\n        twTap.distributeReward(rewardTokenId, amount);\n        emit LogTwTapFeesDeposit(amount);\n    }\n\n    function getAllMasterContractClones(IPenrose.MasterContract[] memory array)\n        public\n        view\n        returns (address[] memory markets)\n    {\n        uint256 _masterContractLength = array.length;\n        uint256 marketsLength = 0;\n\n        unchecked {\n            // We first compute the length of the markets array\n            for (uint256 i; i < _masterContractLength;) {\n                marketsLength += clonesOfCount(array[i].location);\n\n                ++i;\n            }\n        }\n\n        markets = new address[](marketsLength);\n\n        uint256 marketIndex;\n        uint256 clonesOfLength;\n\n        unchecked {\n            // We populate the array\n            for (uint256 i; i < _masterContractLength;) {\n                address mcLocation = array[i].location;\n                clonesOfLength = clonesOfCount(mcLocation);\n\n                // Loop through clones of the current MC.\n                for (uint256 j = 0; j < clonesOfLength;) {\n                    markets[marketIndex] = clonesOf[mcLocation][j];\n                    ++marketIndex;\n                    ++j;\n                }\n                ++i;\n            }\n        }\n    }\n}"
    }
  ]
}