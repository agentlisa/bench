{
  "Title": "H-4: Malicious user can DOS pool and avoid liquidation by creating secondary liquidity pool for Velodrome token pair",
  "Content": "# Issue H-4: Malicious user can DOS pool and avoid liquidation by creating secondary liquidity pool for Velodrome token pair \n\nSource: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/72 \n\n## Found by \n0x52\n\n## Summary\n\nFor every Vault_Velo interaction the vault attempts to price the liquidity of the user. This calls priceLiquidity in the corresponding DepsoitReciept. The prices the underlying assets by swapping them through the Velodrome router. Velodrome can have both a stable and volatile pool for each asset pair. When calling the router directly it routes through the pool that gives the best price. In priceLiquidity the transaction will revert if the router routes through the wrong pool (i.e. trading the volatile pool instead of the stable pool). A malicious user can use this to their advantage to avoid being liquidated.  They could manipulate the price of the opposite pool so that any call to liquidate them would route through the wrong pool and revert.\n\n## Vulnerability Detail\n\n        uint256 amountOut; //amount received by trade\n        bool stablePool; //if the traded pool is stable or volatile.\n        (amountOut, stablePool) = router.getAmountOut(HUNDRED_TOKENS, token1, USDC);\n        require(stablePool == stable, \"pricing occuring through wrong pool\" );\n\nDepositReceipt uses the getAmountOut call the estimate the amountOut. The router will return the best rate between the volatile and stable pool. If the wrong pool give the better rate then the transaction will revert. Since pricing is called during liquidation, a malicious user could manipulate the price of the wrong pool so that it returns the better rate and always reverts the liquidation call.\n\n## Impact\n\nMalicious user can avoid liquidation\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_USDC.sol#L75-L130\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nInstead of quoting from the router, query the correct pool directly:\n\n            uint256 amountOut; //amount received by trade\n    -       bool stablePool; //if the traded pool is stable or volatile.\n\n    -       (amountOut, stablePool) = router.getAmountOut(HUNDRED_TOKENS, token1, USDC);\n    -       require(stablePool == stable, \"pricing occuring through wrong pool\" );\n    +       address pair;\n\n    +       pair = router.pairFor(token1, USDC, stable)\n    +       amountOut = IPair(pair).getAmountOut(HUNDRED_TOKENS, token1)\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor confirmed, will fix.\n\n**kree-dotcom**\n\nFixed https://github.com/kree-dotcom/Velo-Deposit-Tokens/commit/58b8f3e14b416630971b7b17b500bbe22d2016aa\n\nNote there are two fixes in this commit relating to the priceLiquidity function. The other fix is for issue #145 , the code for these changes doesn't overlap so should be clear, please ask me if it is not.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/22",
  "Code": [
    {
      "filename": "contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_USDC.sol",
      "content": "pragma solidity =0.8.9;\n\nimport \"./DepositReceipt_Base.sol\";\n\ncontract DepositReceipt_USDC is  DepositReceipt_Base {\n\n    uint256 private constant SCALE_SHIFT = 1e12; //brings USDC 6.d.p up to 18d.p. standard\n    uint256 private constant USDC_BASE = 1e6; //used for division in USDC 6.d.p scale\n    uint256 private constant ALLOWED_DEVIATION = 5e16; //5% in 1e18 / ETH scale\n    address private constant USDC = 0x7F5c764cBc14f9669B88837ca1490cCa17c31607; \n\n    //Chainlink oracle source\n    IAggregatorV3 public priceFeed;\n    // ten to the power of the number of decimals given by the price feed\n    uint256 private immutable oracleBase;\n\n    /**\n    *    @notice Zero address checks done in Templater that generates DepositReceipt and so not needed here.\n    **/\n    constructor(string memory _name, \n                string memory _symbol, \n                address _router, \n                address _token0,\n                address _token1,\n                bool _stable,\n                address _priceFeed) \n                ERC721(_name, _symbol){\n\n        //we dont want the `DEFAULT_ADMIN_ROLE` to exist as this doesn't require a \n        // time delay to add/remove any role and so is dangerous. \n        //So we ignore it and set our weaker admin role.\n        _setupRole(ADMIN_ROLE, msg.sender);\n        currentLastId = 1; //avoid id 0\n        //set up details for underlying tokens\n        router = IRouter(_router);\n\n        //here we check one token is USDC and that the other token has 18d.p.\n        //this prevents pricing mistakes and is defensive design against dev oversight.\n        //Obvious this is not a full check, a malicious ERC20 can set it's own symbol as USDC too \n        //but in practice as only the multi-sig should be deploying via Templater this is not a concern \n        \n        bytes memory USDCSymbol = abi.encodePacked(\"USDC\");\n        bytes memory token0Symbol = abi.encodePacked(IERC20Metadata(_token0).symbol());\n        //equality cannot be checked for strings so we hash them first.\n        if (keccak256(token0Symbol) == keccak256(USDCSymbol)){\n            require( IERC20Metadata(_token1).decimals() == 18, \"Token does not have 18dp\");\n        }\n        else\n        {   \n            bytes memory token1Symbol = abi.encodePacked(IERC20Metadata(_token1).symbol());\n            \n            require( keccak256(token1Symbol) == keccak256(USDCSymbol), \"One token must be USDC\");\n            require( IERC20Metadata(_token0).decimals() == 18, \"Token does not have 18dp\");\n            \n        }\n\n        token0 = _token0;\n        token1 = _token1;\n        stable = _stable;\n        priceFeed = IAggregatorV3(_priceFeed);\n        IAccessControlledOffchainAggregator  aggregator = IAccessControlledOffchainAggregator(priceFeed.aggregator());\n        //fetch the pricefeeds hard limits so we can be aware if these have been reached.\n        tokenMinPrice = aggregator.minAnswer();\n        tokenMaxPrice = aggregator.maxAnswer();\n        oracleBase = 10 ** priceFeed.decimals();  //Chainlink USD oracles have 8d.p.\n    }\n\n   /**\n    *  @notice this is used to price pooled Tokens by determining their underlying assets and then pricing these\n    *  @notice the two ways to do this are to price to USDC as  a dollar equivalent or to ETH then use Chainlink price feeds\n    *  @dev each DepositReceipt has a bespoke valuation method, make sure it fits the tokens\n    *  @dev each DepositReceipt's valuation method is sensitive to available liquidity keep this in mind as liquidating a pooled token by using the same pool will reduce overall liquidity\n\n    */\n    function priceLiquidity(uint256 _liquidity) external override view returns(uint256){\n        uint256 token0Amount;\n        uint256 token1Amount;\n        (token0Amount, token1Amount) = viewQuoteRemoveLiquidity(_liquidity);\n        //USDC route \n        uint256 value0;\n        uint256 value1;\n        if (token0 == USDC){\n            //hardcode value of USDC at $1\n            //check swap value of 100tokens to USDC to protect against flash loan attacks\n            uint256 amountOut; //amount received by trade\n            bool stablePool; //if the traded pool is stable or volatile.\n            (amountOut, stablePool) = router.getAmountOut(HUNDRED_TOKENS, token1, USDC);\n            require(stablePool == stable, \"pricing occuring through wrong pool\" );\n\n            uint256 oraclePrice = getOraclePrice(priceFeed, tokenMaxPrice, tokenMinPrice);\n            amountOut = (amountOut * oracleBase) / USDC_BASE / HUNDRED; //shift USDC amount to same scale as oracle\n\n            //calculate acceptable deviations from oracle price\n            uint256 lowerBound = (oraclePrice * (BASE - ALLOWED_DEVIATION)) / BASE;\n            uint256 upperBound = (oraclePrice * (BASE + ALLOWED_DEVIATION)) / BASE;\n            //because 1 USDC = $1 we can compare its amount directly to bounds\n            require(lowerBound < amountOut, \"Price shift low detected\");\n            require(upperBound > amountOut, \"Price shift high detected\");\n\n            value0 = token0Amount * SCALE_SHIFT;\n            \n            value1 = (token1Amount * oraclePrice) / oracleBase;\n        }\n        //token1 must be USDC \n        else {\n            //hardcode value of USDC at $1\n            //check swap value of 100tokens to USDC to protect against flash loan attacks\n            uint256 amountOut; //amount received by trade\n            bool stablePool; //if the traded pool is stable or volatile.\n            (amountOut, stablePool) = router.getAmountOut(HUNDRED_TOKENS, token0, USDC);\n            require(stablePool == stable, \"pricing occuring through wrong pool\" );\n\n            uint256 oraclePrice = getOraclePrice(priceFeed, tokenMaxPrice, tokenMinPrice);\n            amountOut = (amountOut * oracleBase) / USDC_BASE / HUNDRED; //shift USDC amount to same scale as oracle\n\n            //calculate acceptable deviations from oracle price\n            uint256 lowerBound = (oraclePrice * (BASE - ALLOWED_DEVIATION)) / BASE;\n            uint256 upperBound = (oraclePrice * (BASE + ALLOWED_DEVIATION)) / BASE;\n            //because 1 USDC = $1 we can compare its amount directly to bounds\n            require(lowerBound < amountOut, \"Price shift low detected\");\n            require(upperBound > amountOut, \"Price shift high detected\");\n\n            value1 = token1Amount * SCALE_SHIFT;\n           \n            value0 = (token0Amount * oraclePrice) / oracleBase;\n        }\n        //Invariant: both value0 and value1 are in ETH scale 18.d.p now\n        //USDC has only 6 decimals so we bring it up to the same scale as other 18d.p ERC20s\n        return(value0 + value1);\n    }\n}"
    }
  ]
}