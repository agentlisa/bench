{
  "Title": "[07] Use safeTransfer/safeTransferFrom consistently instead of transfer/transferFrom",
  "Content": "\nIt is good to add a require() statement that checks the return value of token transfers or to use something like OpenZeppelinâ€™s safeTransfer/safeTransferFrom unless one is sure the given token reverts in case of a failure. Failure to do so will cause silent failures of transfers and affect token accounting in contract.\n\nReference: This similar medium-severity finding from Consensys Diligence Audit of Fei Protocol: https://consensys.net/diligence/audits/2021/01/fei-protocol/#unchecked-return-value-for-iweth-transfer-call\n\n### Proof of Concept\n\n1. Navigate to the following contract.\n\n2. transfer/transferFrom functions are used instead of safe transfer/transferFrom on the following contracts.\n\n[ForgottenRunesWarriorsGuild.sol#L175](https://github.com/code-423n4/2022-05-runes/blob/main/contracts/ForgottenRunesWarriorsGuild.sol#L175)<br>\n\n### Recommended Mitigation Steps\n\nConsider using safeTransfer/safeTransferFrom or require() consistently.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-05-runes",
  "Code": [
    {
      "filename": "contracts/ForgottenRunesWarriorsGuild.sol",
      "content": "pragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport './interfaces/IForgottenRunesWarriorsGuild.sol';\n\n/**\n * @dev This implements the tokens of the Forgotten Runes Warriors Guild. They are {ERC721} tokens.\n */\ncontract ForgottenRunesWarriorsGuild is\n    IForgottenRunesWarriorsGuild,\n    Ownable,\n    ReentrancyGuard,\n    ERC721\n{\n    using Strings for uint256;\n\n    /// @notice The maximum number of Warriors\n    uint256 public constant MAX_WARRIORS = 16000;\n\n    /// @notice Counter to track the number minted so far\n    uint256 public numMinted = 0;\n\n    /// @notice Address of the minter\n    address public minter;\n\n    /// @notice The base URI for the metadata of the tokens\n    string public baseTokenURI;\n\n    string public constant R =\n        \"Old men forget: yet all shall be forgot, But he'll remember with advantages What feats he did that day: then shall our names Familiar in his mouth as household words. This story shall the good man teach his son From this day to the ending of the world\";\n\n    /// @notice The provenance hash\n    string public METADATA_PROVENANCE_HASH = '';\n\n    /**\n     * @dev Create the contract and set the initial baseURI\n     * @param baseURI string the initial base URI for the token metadata URL\n     */\n    constructor(string memory baseURI)\n        ERC721('ForgottenRunesWarriorsGuild', 'WARRIORS')\n    {\n        setBaseURI(baseURI);\n    }\n\n    /**\n     * @dev Convenient way to initialize the contract\n     * @param newMinter address of the minter contract\n     */\n    function initialize(address newMinter) public onlyOwner {\n        setMinter(newMinter);\n    }\n\n    /**\n     * @dev Returns the URL of a given tokenId\n     * @param tokenId uint256 ID of the token to be minted\n     * @return string the URL of a given tokenId\n     */\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (string memory)\n    {\n        require(\n            _exists(tokenId),\n            'ERC721Metadata: URI query for nonexistent token'\n        );\n\n        return string(abi.encodePacked(baseTokenURI, tokenId.toString()));\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return baseTokenURI;\n    }\n\n    /**\n     * @dev Returns if the token exists\n     * @param tokenId uint256 the id of the token\n     * @return exists bool if it exists\n     */\n    function exists(uint256 tokenId) public view returns (bool) {\n        return _exists(tokenId);\n    }\n\n    /**\n     * @dev Mint the next token\n     * @param recipient address representing the owner of the new tokenId\n     * @return tokenId uint256 the new tokenId\n     */\n    function mint(address recipient)\n        public\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        require(numMinted < MAX_WARRIORS, 'All warriors have been summoned');\n        require(_msgSender() == minter, 'Not a minter');\n        uint256 tokenId = numMinted;\n        _safeMint(recipient, tokenId);\n        numMinted += 1;\n        return tokenId;\n    }\n\n    /**\n     * @notice I wouldn't if I were you\n     * @dev Burns the token\n     * @param tokenId uint256 representing the tokenId\n     */\n    function burn(uint256 tokenId) public virtual {\n        require(\n            _isApprovedOrOwner(_msgSender(), tokenId),\n            'ERC721Burnable: caller is not owner nor approved'\n        );\n        _burn(tokenId);\n    }\n\n    /**\n     * Only the owner can do these things\n     */\n\n    /**\n     * @dev Sets a new base URI\n     * @param newBaseURI string the new token base URI\n     */\n    function setBaseURI(string memory newBaseURI) public onlyOwner {\n        baseTokenURI = newBaseURI;\n    }\n\n    /**\n     * @dev Sets a new primary minter address\n     * @param newMinter address of the new minter\n     */\n    function setMinter(address newMinter) public onlyOwner {\n        minter = newMinter;\n    }\n\n    /**\n     * @dev Sets provenance hash\n     * @param newHash string of the new minter\n     */\n    function setProvenanceHash(string memory newHash) public onlyOwner {\n        METADATA_PROVENANCE_HASH = newHash;\n    }\n\n    /**\n     * @dev Adds calldata on chain for the images. See: https://www.forgottenrunes.com/posts/on-chain\n     */\n    function uploadImage(bytes calldata s) external onlyOwner {}\n\n    /**\n     * @dev Adds calldata on chain for the attributes. See: https://www.forgottenrunes.com/posts/on-chain\n     */\n    function uploadAttributes(bytes calldata s) external onlyOwner {}\n\n    /**\n     * @dev ETH should not be sent to this contract, but in the case that it is\n     * sent by accident, this function allows the owner to withdraw it.\n     */\n    function withdrawAll() public payable onlyOwner {\n        require(payable(msg.sender).send(address(this).balance));\n    }\n\n    /**\n     * @dev Again, ERC20s should not be sent to this contract, but if someone\n     * does, it's nice to be able to recover them\n     * @param token IERC20 the token address\n     * @param amount uint256 the amount to send\n     */\n    function forwardERC20s(IERC20 token, uint256 amount) public onlyOwner {\n        require(address(msg.sender) != address(0));\n        token.transfer(msg.sender, amount);\n    }\n}"
    }
  ]
}