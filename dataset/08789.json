{
  "Title": "[H-01] `PortcalFacet.repayAavePortal()` can trigger an underflow of `routerBalances`",
  "Content": "_Submitted by Ruhum, also found by 0x1f8b and WatchPug_\n\n[PortalFacet.sol#L80-L113](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L80-L113)<br>\n\nThe caller of `repayAavePortal()` can trigger an underflow to arbitrarily increase the caller's balance through an underflow.\n\n### Proof of Concept\n\n```sol\n// Relevant code sections:\n\n// PortalFacet.sol\n  function repayAavePortal(\n    address _local,\n    uint256 _backingAmount,\n    uint256 _feeAmount,\n    uint256 _maxIn,\n    bytes32 _transferId\n  ) external {\n    uint256 totalAmount = _backingAmount + _feeAmount; // in adopted\n    uint256 routerBalance = s.routerBalances[msg.sender][_local]; // in local\n\n    // Sanity check: has that much to spend\n    if (routerBalance < _maxIn) revert PortalFacet__repayAavePortal_insufficientFunds();\n\n    // Need to swap into adopted asset or asset that was backing the loan\n    // The router will always be holding collateral in the local asset while the loaned asset\n    // is the adopted asset\n\n    // Swap for exact `totalRepayAmount` of adopted asset to repay aave\n    (bool success, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(\n      _local,\n      totalAmount,\n      _maxIn\n    );\n\n    if (!success) revert PortalFacet__repayAavePortal_swapFailed();\n\n    // decrement router balances\n    unchecked {\n      s.routerBalances[msg.sender][_local] -= amountIn;\n    }\n\n    // back loan\n    _backLoan(_local, _backingAmount, _feeAmount, _transferId);\n  }\n\n// AssetLogic.sol\n  function swapFromLocalAssetIfNeededForExactOut(\n    address _asset,\n    uint256 _amount,\n    uint256 _maxIn\n  )\n    internal\n    returns (\n      bool,\n      uint256,\n      address\n    )\n  {\n    AppStorage storage s = LibConnextStorage.connextStorage();\n\n    // Get the token id\n    (, bytes32 id) = s.tokenRegistry.getTokenId(_asset);\n\n    // If the adopted asset is the local asset, no need to swap\n    address adopted = s.canonicalToAdopted[id];\n    if (adopted == _asset) {\n      return (true, _amount, _asset);\n    }\n\n    return _swapAssetOut(id, _asset, adopted, _amount, _maxIn);\n  }\n```\n\nFirst, call `repayAavePortal()` where `_backingAmount + _feeAmount > s.routerBalances[msg.sender][_local] && _maxIn > s.routerBalances[msg.sender][_local]`. That will trigger the call to the AssetLogic contract:\n\n```sol\n    (bool success, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(\n      _local,\n      totalAmount,\n      _maxIn\n    );\n```\n\nBy setting `_local` to the same value as the adopted asset, you trigger the following edge case:\n\n```sol\n    address adopted = s.canonicalToAdopted[id];\n    if (adopted == _asset) {\n      return (true, _amount, _asset);\n    }\n```\n\nSo the `amountIn` value returned by `swapFromLocalAssetIfNeededForExactOut()` is the `totalAmount` value that was passed to it. And `totalAmount == _backingAmount + _feeAmount`.\n\nMeaning the `amountIn` value is user-specified for this edge case. Finally, we reach the following line:\n\n```sol\n    unchecked {\n      s.routerBalances[msg.sender][_local] -= amountIn;\n    }\n```\n\n`amountIn` (user-specified) is subtracted from the `routerBalances` in an `unchecked` block. Thus, the attacker is able to trigger an underflow and increase their balance arbitrarily high. The `repayAavePortal()` function only verifies that `routerBalance < _maxIn`.\n\nHere's a test as PoC:\n\n```sol\n// PortalFacet.t.sol\n\n  function test_PortalFacet_underflow() public {\n    s.routerPermissionInfo.approvedForPortalRouters[router] = true;\n\n    uint backing = 2 ether;\n    uint fee = 10000;\n    uint init = 1 ether;\n\n    s.routerBalances[router][_local] = init;\n    s.portalDebt[_id] = backing;\n    s.portalFeeDebt[_id] = fee;\n\n    vm.mockCall(s.aavePool, abi.encodeWithSelector(IAavePool.backUnbacked.selector), abi.encode(true));\n    vm.prank(router);\n    this.repayAavePortal(_local, backing, fee, init - 0.5 ether, _id);\n\n    // balance > init => underflow\n    require(s.routerBalances[router][_local] > init);\n  }\n```\n\n### Recommended Mitigation Steps\n\nAfter the call to `swapFromLocalAssetIfNeededForExactOut()` you should add the following check:\n\n```sol\nif (_local == adopted) {\n  require(routerBalance >= amountIn);\n}\n```\n\n**[LayneHaber (Connext) confirmed and resolved](https://github.com/code-423n4/2022-06-connext-findings/issues/68#issuecomment-1167501711):**\n > [connext/nxtp@ac95c1b](https://github.com/connext/nxtp/pull/1450/commits/ac95c1b987c34862e106fc7d643fb8bb7ebb053e)\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-06-connext-findings/issues/68#issuecomment-1202020574):**\n > This is entirely valid and a really severe issue. If the local asset is the adopted asset, `AssetLogic.swapFromLocalAssetIfNeededForExactOut()` will return `amountIn == totalAmount`. So in order to overflow `routerBalances`, the router just needs to provide `_backingAmount + _feeAmount` inputs that sum to exceed the router's current balance.\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2022-06-connext",
  "Code": [
    {
      "filename": "contracts/contracts/core/connext/facets/PortalFacet.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {SafeERC20Upgradeable, IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\n\nimport {IAavePool} from \"../interfaces/IAavePool.sol\";\n\nimport {AssetLogic} from \"../libraries/AssetLogic.sol\";\nimport {ConnextMessage} from \"../libraries/ConnextMessage.sol\";\n\ncontract PortalFacet is BaseConnextFacet {\n  // ========== Custom Errors ===========\n  error PortalFacet__setAavePortalFee_invalidFee();\n  error PortalFacet__repayAavePortal_insufficientFunds();\n  error PortalFacet__repayAavePortal_swapFailed();\n  error PortalFacet__repayAavePortalFor_notSupportedAsset();\n  error PortalFacet__repayAavePortalFor_zeroAmount();\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when a router executed a manual repayment to Aave Portal\n   * @param router - The router that execute the repayment\n   * @param asset - The asset that was repaid\n   * @param amount - The amount that was repaid\n   * @param fee - The fee amount that was repaid\n   */\n  event AavePortalRouterRepayment(address indexed router, address asset, uint256 amount, uint256 fee);\n\n  // ============ Getters methods ==============\n\n  function getAavePortalDebt(bytes32 _transferId) external view returns (uint256) {\n    return s.portalDebt[_transferId];\n  }\n\n  function getAavePortalFeeDebt(bytes32 _transferId) external view returns (uint256) {\n    return s.portalDebt[_transferId];\n  }\n\n  function aavePool() external view returns (address) {\n    return s.aavePool;\n  }\n\n  function aavePortalFee() external view returns (uint256) {\n    return s.aavePortalFeeNumerator;\n  }\n\n  // ============ External functions ============\n\n  /**\n   * @notice Sets the Aave Pool contract address.\n   * @dev Allows to set the aavePool to address zero to disable Aave Portal if needed\n   * @param _aavePool The address of the Aave Pool contract\n   */\n  function setAavePool(address _aavePool) external onlyOwner {\n    s.aavePool = _aavePool;\n  }\n\n  /**\n   * @notice Sets the Aave Portal fee numerator\n   * @param _aavePortalFeeNumerator The new value for the Aave Portal fee numerator\n   */\n  function setAavePortalFee(uint256 _aavePortalFeeNumerator) external onlyOwner {\n    if (_aavePortalFeeNumerator > s.LIQUIDITY_FEE_DENOMINATOR) revert PortalFacet__setAavePortalFee_invalidFee();\n\n    s.aavePortalFeeNumerator = _aavePortalFeeNumerator;\n  }\n\n  /**\n   * @notice Used by routers to perform a manual repayment to Aave Portals to cover any outstanding debt\n   * @dev The router must be approved for portal and with enough liquidity, and must be the caller of this\n   * function\n   * @param _local The local asset (what router stores liquidity in)\n   * @param _backingAmount The principle to be paid (in adopted asset)\n   * @param _feeAmount The fee to be paid (in adopted asset)\n   * @param _maxIn The max value of the local asset to swap for the _backingAmount of adopted asset\n   */\n  function repayAavePortal(\n    address _local,\n    uint256 _backingAmount,\n    uint256 _feeAmount,\n    uint256 _maxIn,\n    bytes32 _transferId\n  ) external {\n    uint256 totalAmount = _backingAmount + _feeAmount; // in adopted\n    uint256 routerBalance = s.routerBalances[msg.sender][_local]; // in local\n\n    // Sanity check: has that much to spend\n    if (routerBalance < _maxIn) revert PortalFacet__repayAavePortal_insufficientFunds();\n\n    // Need to swap into adopted asset or asset that was backing the loan\n    // The router will always be holding collateral in the local asset while the loaned asset\n    // is the adopted asset\n\n    // Swap for exact `totalRepayAmount` of adopted asset to repay aave\n    (bool success, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(\n      _local,\n      totalAmount,\n      _maxIn\n    );\n\n    if (!success) revert PortalFacet__repayAavePortal_swapFailed();\n\n    // decrement router balances\n    unchecked {\n      s.routerBalances[msg.sender][_local] -= amountIn;\n    }\n\n    // back loan\n    _backLoan(_local, _backingAmount, _feeAmount, _transferId);\n  }\n\n  /**\n   * @notice This allows anyone to repay the portal in the adopted asset for a given router\n   * and transfer\n   * @dev Should always be paying in the backing asset for the aave loan\n   * @param _router Router who took out the credit\n   * @param _adopted Address of the adopted asset (asset backing the loan)\n   * @param _backingAmount Amount of principle to repay\n   * @param _feeAmount Amount of fees to repay\n   * @param _transferId Corresponding transfer id for the fees\n   */\n  function repayAavePortalFor(\n    address _router,\n    address _adopted,\n    uint256 _backingAmount,\n    uint256 _feeAmount,\n    bytes32 _transferId\n  ) external payable {\n    address adopted = _adopted == address(0) ? address(s.wrapper) : _adopted;\n    // Ensure the asset is whitelisted\n    ConnextMessage.TokenId memory canonical = s.adoptedToCanonical[adopted];\n    if (canonical.id == bytes32(0)) {\n      revert PortalFacet__repayAavePortalFor_notSupportedAsset();\n    }\n\n    // Transfer funds to the contract\n    uint256 total = _backingAmount + _feeAmount;\n    if (total == 0) revert PortalFacet__repayAavePortalFor_zeroAmount();\n\n    (, uint256 amount) = AssetLogic.handleIncomingAsset(_adopted, total, 0);\n\n    // If this was a fee on transfer token, reduce the total\n    if (amount < total) {\n      uint256 missing = total - amount;\n      if (missing < _feeAmount) {\n        // Debit fee amount\n        _feeAmount -= missing;\n      } else {\n        // Debit backing amount\n        missing -= _feeAmount;\n        _feeAmount = 0;\n        _backingAmount -= missing;\n      }\n    }\n\n    // No need to swap because this is the adopted asset. Simply\n    // repay the loan\n    _backLoan(adopted, _backingAmount, _feeAmount, _transferId);\n  }\n\n  // ============ Internal functions ============\n\n  /**\n   * @notice Calls backUnbacked on the aave contracts\n   * @dev Assumes funds in adopted asset are already on contract\n   * @param _asset Address of the adopted asset (asset backing the loan)\n   * @param _backing Amount of principle to repay\n   * @param _fee Amount of fees to repay\n   * @param _transferId Corresponding transfer id for the fees\n   */\n  function _backLoan(\n    address _asset,\n    uint256 _backing,\n    uint256 _fee,\n    bytes32 _transferId\n  ) internal {\n    // reduce debt\n    s.portalDebt[_transferId] -= _backing;\n    s.portalFeeDebt[_transferId] -= _fee;\n\n    // increase allowance\n    SafeERC20Upgradeable.safeIncreaseAllowance(IERC20Upgradeable(_asset), s.aavePool, _backing + _fee);\n\n    // back loan\n    IAavePool(s.aavePool).backUnbacked(_asset, _backing, _fee);\n\n    // emit event\n    emit AavePortalRouterRepayment(msg.sender, _asset, _backing, _fee);\n  }\n}"
    }
  ]
}