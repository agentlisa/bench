{
  "Title": "[M-03] Dynamic modification of `maxPrizeCount` affects prize claims",
  "Content": "\nThe `ThrusterTreasure` contract is designed to manage rounds of a lottery game, where participants can enter tickets and claim prizes based on random draws. The contract includes a variable `maxPrizeCount` which dictates the maximum number of prizes that can be set for any given round. This variable can be modified by the contract owner at any time through the `setMaxPrizeCount(uint256 _maxPrizeCount)` function:\n\n[ThrusterTreasure.sol#L139-L142](https://github.com/code-423n4/2024-02-thruster/blob/3896779349f90a44b46f2646094cb34fffd7f66e/thruster-protocol/thruster-treasure/contracts/ThrusterTreasure.sol#L139-L142)\n\n```solidity\n    function setMaxPrizeCount(uint256 _maxPrizeCount) external onlyOwner {\n        maxPrizeCount = _maxPrizeCount;\n        emit SetMaxPrizeCount(_maxPrizeCount);\n    }\n```\n\nThe issue arises when `maxPrizeCount` is decreased after prizes for a round have been set but before they have been claimed. Since the `claimPrizesForRound(uint256 roundToClaim)` function iterates over prize indices up to `maxPrizeCount`, reducing this count means that winners of prizes with indices higher than the new `maxPrizeCount` will be unable to claim their winnings:\n\n[ThrusterTreasure.sol#L102-L120](https://github.com/code-423n4/2024-02-thruster/blob/3896779349f90a44b46f2646094cb34fffd7f66e/thruster-protocol/thruster-treasure/contracts/ThrusterTreasure.sol#L102-L120)\n\n```solidity\n    function claimPrizesForRound(uint256 roundToClaim) external {\n        ...\n        \n        uint256 maxPrizeCount_ = maxPrizeCount;\n        for (uint256 i = 0; i < maxPrizeCount_; i++) {\n            [claim prize]\n        }\n        entered[msg.sender][roundToClaim] = Round(0, 0, roundToClaim); // Clear user's tickets for the round\n        emit CheckedPrizesForRound(msg.sender, roundToClaim);\n    }\n```\n\nThis could lead to a scenario where legitimate winners are denied their prizes due to a change in contract state that is unrelated to the rules of the game or their actions. Moreover, since calling `claimPrizesForRound()` clears the user's entries for the round, reverting `maxPrizeCount` to its previous state does not allow them to claim the remaining tickets. This means they will effectively never be able to claim their prize.\n\n### Proof of Concept\n\n1.  The contract owner sets `maxPrizeCount` to 5 and configures five prizes for a given round.\n2.  Users participate in the round, and the round concludes with winners determined for all five prizes.\n3.  The contract owner reduces `maxPrizeCount` to 3 for the next round.\n4.  Winners of prizes 4 and 5 attempt to claim their prizes but are unable to do so because the `claimPrizesForRound(uint256 roundToClaim)` function now iterates only up to the new `maxPrizeCount` of 3.\n\n### Recommended Mitigation Steps\n\nTo address this issue, implementing a checkpoint pattern for the `maxPrizeCount` variable is suggested. This method involves tracking changes to `maxPrizeCount` with checkpoints that record the value and the round number when the change occurs.\n\nA possible implementation could look like this:\n\n```solidity\n// Add a struct to store checkpoints for maxPrizeCount changes\nstruct MaxPrizeCountCheckpoint {\n    uint256 round;\n    uint256 maxPrizeCount;\n}\n\n// Use an array to keep track of all checkpoints\nMaxPrizeCountCheckpoint[] public maxPrizeCountCheckpoints;\n\nconstructor(\n\t...\n) Ownable(msg.sender) {\n\tmaxPrizeCountCheckpoints.push(\n\t\tMaxPrizeCountCheckpoint(0, _maxPrizeCount)\n\t);\n    ...\n}\n\n// Modify setMaxPrizeCount to push a new checkpoint to the array\nfunction setMaxPrizeCount(uint256 _maxPrizeCount) external onlyOwner {\n\trequire(_maxPrizeCount != getMaxPrizeCountForRound(currentRound), \"same value\")\n    maxPrizeCountCheckpoints.push(\n\t\tMaxPrizeCountCheckpoint(currentRound, _maxPrizeCount)\n    );\n    emit SetMaxPrizeCount(_maxPrizeCount);\n}\n\n// Helper function to get the maxPrizeCount for a given round\n// Assumes more recent rounds will be queried more often\nfunction getMaxPrizeCountForRound(uint256 _round) public view returns (uint256) {\n    uint256 length = maxPrizeCountCheckpoints.length;\n    for (uint256 i = length; i > 0; i--) {\n        MaxPrizeCountCheckpoint storage checkpoint = maxPrizeCountCheckpoints[i - 1];\n        if (checkpoint.round <= _round) {\n            return checkpoint.maxPrizeCount;\n        }\n    }\n    return 0;\n}\n\n// Disallow setting prizes for future rounds since the maxPrizeCount could change\nfunction setPrize(uint64 _prizeIndex, uint256 _amountWETH, uint256 _amountUSDB, uint64 _numWinners) external onlyOwner {\n    uint256 maxPrizeCount = getMaxPrizeCountForRound(currentRound);\n    require(_prizeIndex < maxPrizeCount, \"IPC\");\n    ...\n}\n\nfunction claimPrizesForRound(uint256 roundToClaim) external {\n    uint256 maxPrizeCount = getMaxPrizeCountForRound(roundToClaim);\n    ...\n}\n```\n\nThis change ensures that each round's prize structure is fixed upon the round's creation, preventing post-hoc alterations that could negatively impact participants. Note that this implementation still requires attention is paid to not calling `setMaxPrizeCount()` for a given round if prizes have already been set for higher indices.\n\n**[jooleseth (Thruster) commented](https://github.com/code-423n4/2024-02-thruster-findings/issues/25#issuecomment-1963634534):**\n > I would consider this QA to ensure to add a require check that `maxPrizeCount` cannot be decreased as that is the intention.\n\n**[EV\\_om (warden) commented](https://github.com/code-423n4/2024-02-thruster-findings/issues/25#issuecomment-1964892925):**\n > That's indeed a much simpler fix! \n> \n> I would still say Medium severity is appropriate seeing as that could not have been inferred from the audit scope and given the potential impact, but either way I'll accept the judge's decision.\n\n**[jooleseth (Thruster) confirmed](https://github.com/code-423n4/2024-02-thruster-findings/issues/25#issuecomment-1984513989)**\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-thruster",
  "Code": [
    {
      "filename": "thruster-protocol/thruster-treasure/contracts/ThrusterTreasure.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.23;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"@pythnetwork/entropy-sdk-solidity/IEntropy.sol\";\n\nimport \"interfaces/IERC20Rebasing.sol\";\nimport \"interfaces/IThrusterTreasure.sol\";\nimport \"interfaces/IBlast.sol\";\n\n/**\n * @title ThrusterTreasure\n * @notice Contract for Thruster Treasure, a lottery game that uses entropy to determine winners\n */\ncontract ThrusterTreasure is Ownable, IThrusterTreasure {\n    struct Round {\n        uint256 ticketStart; // Inclusive\n        uint256 ticketEnd; // Not inclusive\n        uint256 round;\n    }\n\n    struct Prize {\n        uint256 amountWETH;\n        uint256 amountUSDB;\n        uint64 numWinners;\n        uint64 prizeIndex;\n        uint64 round;\n    }\n\n    uint256 public constant MAX_ROUND_TIME = 30 days; // Time at most 30 days from when round is first initiated, not when winning tickets are drawn\n\n    IBlast public immutable BLAST;\n    IERC20Rebasing public immutable WETH;\n    IERC20Rebasing public immutable USDB;\n\n    IEntropy private entropy;\n    address private entropyProvider;\n\n    bytes32 public root;\n    uint256 public currentRound; // Increments by 1 every time the root is updated\n    uint256 public currentTickets; // Resets to 0 every time the root is updated\n    uint256 public maxPrizeCount;\n    mapping(uint256 => uint256) public roundStart;\n    mapping(address => uint256) public cumulativeTickets;\n    mapping(address => mapping(uint256 => Round)) public entered; // Address => RoundIndex => Round\n    mapping(uint256 => mapping(uint256 => Prize)) public prizes; // Need to keep track of prizes for each round. RoundIndex => PrizeIndex => Prize\n    mapping(uint256 => mapping(uint256 => uint256[])) public winningTickets; // Need to keep track of winning tickets for each round. RoundIndex => PrizeIndex => WinningTickets\n    mapping(uint64 => address) private requestedRandomNumber;\n\n    /**\n     *\n     * @param _entropy - The address of the Entropy contract\n     * @param _entropyProvider - The address of the entropy provider\n     * @param _weth - The address of the WETH contract\n     * @param _usdb - The address of the USDB contract\n     */\n    constructor(\n        address _entropy,\n        address _entropyProvider,\n        address _blast,\n        address _weth,\n        address _usdb,\n        uint256 _maxPrizeCount\n    ) Ownable(msg.sender) {\n        entropy = IEntropy(_entropy);\n        entropyProvider = _entropyProvider;\n        maxPrizeCount = _maxPrizeCount;\n        BLAST = IBlast(_blast);\n        WETH = IERC20Rebasing(_weth);\n        USDB = IERC20Rebasing(_usdb);\n        BLAST.configureAutomaticYield();\n        BLAST.configureClaimableGas();\n        WETH.configure(YieldMode.CLAIMABLE);\n        USDB.configure(YieldMode.CLAIMABLE);\n    }\n\n    /**\n     * Enter tickets into the current active round of Thruster Treasure.\n     * @param _amount The amount of cumulative tickets the user has earned over time, based on merkle proof\n     * @param _proof The Merkle proof to verify the user's tickets\n     */\n    function enterTickets(uint256 _amount, bytes32[] calldata _proof) external {\n        uint256 currentRound_ = currentRound;\n        require(winningTickets[currentRound_][0].length == 0, \"ET\");\n        bytes32 node = keccak256(abi.encodePacked(msg.sender, _amount));\n        require(MerkleProof.verify(_proof, root, node), \"IP\");\n        uint256 ticketsToEnter = _amount - cumulativeTickets[msg.sender];\n        require(ticketsToEnter > 0, \"NTE\");\n        uint256 currentTickets_ = currentTickets;\n        Round memory round = Round(currentTickets_, currentTickets_ + ticketsToEnter, currentRound_);\n        entered[msg.sender][currentRound_] = round;\n        cumulativeTickets[msg.sender] = _amount; // Ensure user can only enter tickets once, no partials\n        currentTickets += ticketsToEnter;\n        emit EnteredTickets(msg.sender, currentTickets_, currentTickets_ + ticketsToEnter, currentRound_);\n    }\n\n    /**\n     * Claim prizes for a round\n     * @param roundToClaim - The round to claim prizes for\n     */\n    function claimPrizesForRound(uint256 roundToClaim) external {\n        require(roundStart[roundToClaim] + MAX_ROUND_TIME >= block.timestamp, \"ICT\");\n        require(winningTickets[roundToClaim][0].length > 0, \"NWT\");\n        Round memory round = entered[msg.sender][roundToClaim];\n        require(round.ticketEnd > round.ticketStart, \"NTE\");\n        uint256 maxPrizeCount_ = maxPrizeCount;\n        for (uint256 i = 0; i < maxPrizeCount_; i++) {\n            Prize memory prize = prizes[roundToClaim][i];\n            uint256[] memory winningTicketsRoundPrize = winningTickets[roundToClaim][i];\n            for (uint256 j = 0; j < winningTicketsRoundPrize.length; j++) {\n                uint256 winningTicket = winningTicketsRoundPrize[j];\n                if (round.ticketStart <= winningTicket && round.ticketEnd > winningTicket) {\n                    _claimPrize(prize, msg.sender, winningTicket);\n                }\n            }\n        }\n        entered[msg.sender][roundToClaim] = Round(0, 0, roundToClaim); // Clear user's tickets for the round\n        emit CheckedPrizesForRound(msg.sender, roundToClaim);\n    }\n\n    /**\n     * Claims the prize for a user\n     * @param _prize - The prize to claim\n     * @param _winningTicket - The winning ticket number\n     */\n    function _claimPrize(Prize memory _prize, address _receiver, uint256 _winningTicket) internal {\n        uint256 amountETH = _prize.amountWETH;\n        uint256 amountUSDB = _prize.amountUSDB;\n        WETH.transfer(_receiver, amountETH);\n        USDB.transfer(_receiver, amountUSDB);\n        emit ClaimedPrize(_receiver, _prize.round, _prize.prizeIndex, amountETH, amountUSDB, _winningTicket);\n    }\n\n    /**\n     * Sets the maximum prize count\n     * @param _maxPrizeCount - The new max prize count\n     */\n    function setMaxPrizeCount(uint256 _maxPrizeCount) external onlyOwner {\n        maxPrizeCount = _maxPrizeCount;\n        emit SetMaxPrizeCount(_maxPrizeCount);\n    }\n\n    /**\n     * Claims the Blast native yield\n     * @param _recipient - The address to claim the yield to\n     * @param _amountWETH - The amount of WETH to claim\n     * @param _amountUSDB - The amount of USDB to claim\n     */\n    function claimYield(address _recipient, uint256 _amountWETH, uint256 _amountUSDB) external onlyOwner {\n        WETH.claim(_recipient, _amountWETH);\n        USDB.claim(_recipient, _amountUSDB);\n    }\n\n    /**\n     * Sets the prize for a round\n     * @param _round - The round to set the prize for\n     * @param _prizeIndex - The index of the prize to set\n     * @param _amountWETH - The amount of WETH to set\n     * @param _amountUSDB - The amount of USDB to set\n     * @param _numWinners - The number of winners for the prize\n     */\n    function setPrize(uint256 _round, uint64 _prizeIndex, uint256 _amountWETH, uint256 _amountUSDB, uint64 _numWinners)\n        external\n        onlyOwner\n    {\n        require(_round >= currentRound, \"ICR\");\n        require(_prizeIndex < maxPrizeCount, \"IPC\");\n        depositPrize(msg.sender, _amountWETH, _amountUSDB);\n        prizes[_round][_prizeIndex] = Prize(_amountWETH, _amountUSDB, _numWinners, _prizeIndex, uint64(_round));\n    }\n\n    /**\n     * Deposits the prize amounts determined in setPrize\n     *\n     * @param _from - The address who should deposit the prize\n     * @param _amountWETH - The amount of WETH\n     * @param _amountUSDB - The amount of USDB\n     */\n    function depositPrize(address _from, uint256 _amountWETH, uint256 _amountUSDB) internal {\n        WETH.transferFrom(_from, address(this), _amountWETH);\n        USDB.transferFrom(_from, address(this), _amountUSDB);\n        emit DepositedPrizes(_amountWETH, _amountUSDB);\n    }\n\n    /**\n     * Retrieve tokens from the contract\n     * @param _recipient - The address to retrieve the tokens to\n     * @param _token - The address of the token to retrieve\n     * @param _amount - The amount of tokens to retrieve\n     */\n    function retrieveTokens(address _recipient, address _token, uint256 _amount) external onlyOwner {\n        IERC20Rebasing token = IERC20Rebasing(_token);\n        if (_amount == 0) {\n            _amount = token.balanceOf(address(this));\n        }\n        token.transfer(_recipient, _amount);\n        emit WithdrawPrizes(_recipient, _token, _amount);\n    }\n\n    /**\n     * Retrieve ETH from the contract\n     * @param _recipient - The address to retrieve the ETH to\n     * @param _amount - The amount of ETH to retrieve\n     */\n    function retrieveETH(address payable _recipient, uint256 _amount) external onlyOwner {\n        if (_amount == 0) {\n            _amount = address(this).balance;\n        }\n        _recipient.transfer(_amount);\n        emit WithdrawPrizes(_recipient, address(0), _amount);\n    }\n\n    /**\n     * Request many random numbers using Pyth Entropy\n     * @param userCommitments - The user's commitments\n     */\n    function requestRandomNumberMany(bytes32[] calldata userCommitments)\n        external\n        payable\n        onlyOwner\n        returns (uint64[] memory seqNums)\n    {\n        uint256 fee = entropy.getFee(entropyProvider);\n        require(address(this).balance >= fee * userCommitments.length, \"IF\");\n        for (uint256 i = 0; i < userCommitments.length; i++) {\n            uint64 sequenceNumber = entropy.request{value: fee}(entropyProvider, userCommitments[i], true);\n            seqNums[i] = sequenceNumber;\n            requestedRandomNumber[sequenceNumber] = msg.sender;\n            emit RandomNumberRequest(sequenceNumber, userCommitments[i]);\n        }\n    }\n\n    /**\n     * Request a random number using Pyth Entropy\n     * @param userCommitment - The user's commitment\n     */\n    function requestRandomNumber(bytes32 userCommitment) external payable onlyOwner returns (uint64) {\n        uint256 fee = entropy.getFee(entropyProvider);\n        require(address(this).balance > fee, \"IF\");\n\n        uint64 sequenceNumber = entropy.request{value: fee}(entropyProvider, userCommitment, true);\n        requestedRandomNumber[sequenceNumber] = msg.sender;\n\n        emit RandomNumberRequest(sequenceNumber, userCommitment);\n        return sequenceNumber;\n    }\n\n    /**\n     * Sets the merkle root for the current round of Thruster Treasure\n     * @param _root - The new root to set\n     */\n    function setRoot(bytes32 _root) external onlyOwner {\n        root = _root;\n        currentRound += 1;\n        roundStart[currentRound] = block.timestamp;\n        currentTickets = 0;\n        emit NewRound(_root, currentRound);\n    }\n\n    /**\n     *\n     * @param _round - The round to claim the prize for\n     * @param _prizeIndex - The index of the prize to claim\n     * @param sequenceNumbers - The sequence numbers of the random number requests\n     * @param userRandoms - The user random numbers\n     * @param providerRandoms - The provider random numbers\n     */\n    function setWinningTickets(\n        uint256 _round,\n        uint256 _prizeIndex,\n        uint64[] calldata sequenceNumbers,\n        bytes32[] calldata userRandoms,\n        bytes32[] calldata providerRandoms\n    ) external onlyOwner {\n        require(roundStart[_round] + MAX_ROUND_TIME >= block.timestamp, \"ICT\");\n        require(winningTickets[_round][_prizeIndex].length == 0, \"WTS\");\n        Prize memory prize_ = prizes[_round][_prizeIndex];\n        uint256 numWinners = prize_.numWinners;\n        require(\n            sequenceNumbers.length == numWinners && userRandoms.length == numWinners\n                && providerRandoms.length == numWinners,\n            \"WL\"\n        );\n        uint256[] memory _winningTickets = new uint256[](numWinners);\n        for (uint256 i = 0; i < numWinners; i++) {\n            _winningTickets[i] = revealRandomNumber(sequenceNumbers[i], userRandoms[i], providerRandoms[i]);\n            emit SetWinningTicket(_round, _prizeIndex, _winningTickets[i], i);\n        }\n        winningTickets[_round][_prizeIndex] = _winningTickets;\n        require(_winningTickets.length == numWinners, \"WTL\");\n    }\n\n    /**\n     * Reveals the random number using Pyth Entropy.\n     *\n     * @param sequenceNumber - The sequence number of the random number request\n     * @param userRandom - The user's random number\n     * @param providerRandom - The provider's random number\n     */\n    function revealRandomNumber(uint64 sequenceNumber, bytes32 userRandom, bytes32 providerRandom)\n        public\n        onlyOwner\n        returns (uint256)\n    {\n        require(currentTickets > 0, \"NCT\");\n        // Reveal the random number. This call reverts if the provided values fail to match the commitments\n        // from the request phase. If the call returns, randomNumber is a uniformly distributed bytes32.\n        bytes32 randomNumber = entropy.reveal(entropyProvider, sequenceNumber, userRandom, providerRandom);\n        uint256 randomTicket_ = uint256(randomNumber) % currentTickets;\n\n        emit RandomNumberResult(randomTicket_, sequenceNumber);\n        return randomTicket_;\n    }\n\n    /**\n     * Claims the gas from the BLAST contract\n     * @param _recipient - The address to claim the yield to\n     * @param _minClaimRateBips - The minimum claim rate in bips\n     */\n    function claimGas(address _recipient, uint256 _minClaimRateBips) external onlyOwner returns (uint256 amount) {\n        if (_minClaimRateBips == 0) {\n            amount = BLAST.claimMaxGas(address(this), _recipient);\n        } else {\n            amount = BLAST.claimGasAtMinClaimRate(address(this), _recipient, _minClaimRateBips);\n        }\n        emit ClaimGas(_recipient, amount);\n    }\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "thruster-protocol/thruster-treasure/contracts/ThrusterTreasure.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.23;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"@pythnetwork/entropy-sdk-solidity/IEntropy.sol\";\n\nimport \"interfaces/IERC20Rebasing.sol\";\nimport \"interfaces/IThrusterTreasure.sol\";\nimport \"interfaces/IBlast.sol\";\n\n/**\n * @title ThrusterTreasure\n * @notice Contract for Thruster Treasure, a lottery game that uses entropy to determine winners\n */\ncontract ThrusterTreasure is Ownable, IThrusterTreasure {\n    struct Round {\n        uint256 ticketStart; // Inclusive\n        uint256 ticketEnd; // Not inclusive\n        uint256 round;\n    }\n\n    struct Prize {\n        uint256 amountWETH;\n        uint256 amountUSDB;\n        uint64 numWinners;\n        uint64 prizeIndex;\n        uint64 round;\n    }\n\n    uint256 public constant MAX_ROUND_TIME = 30 days; // Time at most 30 days from when round is first initiated, not when winning tickets are drawn\n\n    IBlast public immutable BLAST;\n    IERC20Rebasing public immutable WETH;\n    IERC20Rebasing public immutable USDB;\n\n    IEntropy private entropy;\n    address private entropyProvider;\n\n    bytes32 public root;\n    uint256 public currentRound; // Increments by 1 every time the root is updated\n    uint256 public currentTickets; // Resets to 0 every time the root is updated\n    uint256 public maxPrizeCount;\n    mapping(uint256 => uint256) public roundStart;\n    mapping(address => uint256) public cumulativeTickets;\n    mapping(address => mapping(uint256 => Round)) public entered; // Address => RoundIndex => Round\n    mapping(uint256 => mapping(uint256 => Prize)) public prizes; // Need to keep track of prizes for each round. RoundIndex => PrizeIndex => Prize\n    mapping(uint256 => mapping(uint256 => uint256[])) public winningTickets; // Need to keep track of winning tickets for each round. RoundIndex => PrizeIndex => WinningTickets\n    mapping(uint64 => address) private requestedRandomNumber;\n\n    /**\n     *\n     * @param _entropy - The address of the Entropy contract\n     * @param _entropyProvider - The address of the entropy provider\n     * @param _weth - The address of the WETH contract\n     * @param _usdb - The address of the USDB contract\n     */\n    constructor(\n        address _entropy,\n        address _entropyProvider,\n        address _blast,\n        address _weth,\n        address _usdb,\n        uint256 _maxPrizeCount\n    ) Ownable(msg.sender) {\n        entropy = IEntropy(_entropy);\n        entropyProvider = _entropyProvider;\n        maxPrizeCount = _maxPrizeCount;\n        BLAST = IBlast(_blast);\n        WETH = IERC20Rebasing(_weth);\n        USDB = IERC20Rebasing(_usdb);\n        BLAST.configureAutomaticYield();\n        BLAST.configureClaimableGas();\n        WETH.configure(YieldMode.CLAIMABLE);\n        USDB.configure(YieldMode.CLAIMABLE);\n    }\n\n    /**\n     * Enter tickets into the current active round of Thruster Treasure.\n     * @param _amount The amount of cumulative tickets the user has earned over time, based on merkle proof\n     * @param _proof The Merkle proof to verify the user's tickets\n     */\n    function enterTickets(uint256 _amount, bytes32[] calldata _proof) external {\n        uint256 currentRound_ = currentRound;\n        require(winningTickets[currentRound_][0].length == 0, \"ET\");\n        bytes32 node = keccak256(abi.encodePacked(msg.sender, _amount));\n        require(MerkleProof.verify(_proof, root, node), \"IP\");\n        uint256 ticketsToEnter = _amount - cumulativeTickets[msg.sender];\n        require(ticketsToEnter > 0, \"NTE\");\n        uint256 currentTickets_ = currentTickets;\n        Round memory round = Round(currentTickets_, currentTickets_ + ticketsToEnter, currentRound_);\n        entered[msg.sender][currentRound_] = round;\n        cumulativeTickets[msg.sender] = _amount; // Ensure user can only enter tickets once, no partials\n        currentTickets += ticketsToEnter;\n        emit EnteredTickets(msg.sender, currentTickets_, currentTickets_ + ticketsToEnter, currentRound_);\n    }\n\n    /**\n     * Claim prizes for a round\n     * @param roundToClaim - The round to claim prizes for\n     */\n    function claimPrizesForRound(uint256 roundToClaim) external {\n        require(roundStart[roundToClaim] + MAX_ROUND_TIME >= block.timestamp, \"ICT\");\n        require(winningTickets[roundToClaim][0].length > 0, \"NWT\");\n        Round memory round = entered[msg.sender][roundToClaim];\n        require(round.ticketEnd > round.ticketStart, \"NTE\");\n        uint256 maxPrizeCount_ = maxPrizeCount;\n        for (uint256 i = 0; i < maxPrizeCount_; i++) {\n            Prize memory prize = prizes[roundToClaim][i];\n            uint256[] memory winningTicketsRoundPrize = winningTickets[roundToClaim][i];\n            for (uint256 j = 0; j < winningTicketsRoundPrize.length; j++) {\n                uint256 winningTicket = winningTicketsRoundPrize[j];\n                if (round.ticketStart <= winningTicket && round.ticketEnd > winningTicket) {\n                    _claimPrize(prize, msg.sender, winningTicket);\n                }\n            }\n        }\n        entered[msg.sender][roundToClaim] = Round(0, 0, roundToClaim); // Clear user's tickets for the round\n        emit CheckedPrizesForRound(msg.sender, roundToClaim);\n    }\n\n    /**\n     * Claims the prize for a user\n     * @param _prize - The prize to claim\n     * @param _winningTicket - The winning ticket number\n     */\n    function _claimPrize(Prize memory _prize, address _receiver, uint256 _winningTicket) internal {\n        uint256 amountETH = _prize.amountWETH;\n        uint256 amountUSDB = _prize.amountUSDB;\n        WETH.transfer(_receiver, amountETH);\n        USDB.transfer(_receiver, amountUSDB);\n        emit ClaimedPrize(_receiver, _prize.round, _prize.prizeIndex, amountETH, amountUSDB, _winningTicket);\n    }\n\n    /**\n     * Sets the maximum prize count\n     * @param _maxPrizeCount - The new max prize count\n     */\n    function setMaxPrizeCount(uint256 _maxPrizeCount) external onlyOwner {\n        maxPrizeCount = _maxPrizeCount;\n        emit SetMaxPrizeCount(_maxPrizeCount);\n    }\n\n    /**\n     * Claims the Blast native yield\n     * @param _recipient - The address to claim the yield to\n     * @param _amountWETH - The amount of WETH to claim\n     * @param _amountUSDB - The amount of USDB to claim\n     */\n    function claimYield(address _recipient, uint256 _amountWETH, uint256 _amountUSDB) external onlyOwner {\n        WETH.claim(_recipient, _amountWETH);\n        USDB.claim(_recipient, _amountUSDB);\n    }\n\n    /**\n     * Sets the prize for a round\n     * @param _round - The round to set the prize for\n     * @param _prizeIndex - The index of the prize to set\n     * @param _amountWETH - The amount of WETH to set\n     * @param _amountUSDB - The amount of USDB to set\n     * @param _numWinners - The number of winners for the prize\n     */\n    function setPrize(uint256 _round, uint64 _prizeIndex, uint256 _amountWETH, uint256 _amountUSDB, uint64 _numWinners)\n        external\n        onlyOwner\n    {\n        require(_round >= currentRound, \"ICR\");\n        require(_prizeIndex < maxPrizeCount, \"IPC\");\n        depositPrize(msg.sender, _amountWETH, _amountUSDB);\n        prizes[_round][_prizeIndex] = Prize(_amountWETH, _amountUSDB, _numWinners, _prizeIndex, uint64(_round));\n    }\n\n    /**\n     * Deposits the prize amounts determined in setPrize\n     *\n     * @param _from - The address who should deposit the prize\n     * @param _amountWETH - The amount of WETH\n     * @param _amountUSDB - The amount of USDB\n     */\n    function depositPrize(address _from, uint256 _amountWETH, uint256 _amountUSDB) internal {\n        WETH.transferFrom(_from, address(this), _amountWETH);\n        USDB.transferFrom(_from, address(this), _amountUSDB);\n        emit DepositedPrizes(_amountWETH, _amountUSDB);\n    }\n\n    /**\n     * Retrieve tokens from the contract\n     * @param _recipient - The address to retrieve the tokens to\n     * @param _token - The address of the token to retrieve\n     * @param _amount - The amount of tokens to retrieve\n     */\n    function retrieveTokens(address _recipient, address _token, uint256 _amount) external onlyOwner {\n        IERC20Rebasing token = IERC20Rebasing(_token);\n        if (_amount == 0) {\n            _amount = token.balanceOf(address(this));\n        }\n        token.transfer(_recipient, _amount);\n        emit WithdrawPrizes(_recipient, _token, _amount);\n    }\n\n    /**\n     * Retrieve ETH from the contract\n     * @param _recipient - The address to retrieve the ETH to\n     * @param _amount - The amount of ETH to retrieve\n     */\n    function retrieveETH(address payable _recipient, uint256 _amount) external onlyOwner {\n        if (_amount == 0) {\n            _amount = address(this).balance;\n        }\n        _recipient.transfer(_amount);\n        emit WithdrawPrizes(_recipient, address(0), _amount);\n    }\n\n    /**\n     * Request many random numbers using Pyth Entropy\n     * @param userCommitments - The user's commitments\n     */\n    function requestRandomNumberMany(bytes32[] calldata userCommitments)\n        external\n        payable\n        onlyOwner\n        returns (uint64[] memory seqNums)\n    {\n        uint256 fee = entropy.getFee(entropyProvider);\n        require(address(this).balance >= fee * userCommitments.length, \"IF\");\n        for (uint256 i = 0; i < userCommitments.length; i++) {\n            uint64 sequenceNumber = entropy.request{value: fee}(entropyProvider, userCommitments[i], true);\n            seqNums[i] = sequenceNumber;\n            requestedRandomNumber[sequenceNumber] = msg.sender;\n            emit RandomNumberRequest(sequenceNumber, userCommitments[i]);\n        }\n    }\n\n    /**\n     * Request a random number using Pyth Entropy\n     * @param userCommitment - The user's commitment\n     */\n    function requestRandomNumber(bytes32 userCommitment) external payable onlyOwner returns (uint64) {\n        uint256 fee = entropy.getFee(entropyProvider);\n        require(address(this).balance > fee, \"IF\");\n\n        uint64 sequenceNumber = entropy.request{value: fee}(entropyProvider, userCommitment, true);\n        requestedRandomNumber[sequenceNumber] = msg.sender;\n\n        emit RandomNumberRequest(sequenceNumber, userCommitment);\n        return sequenceNumber;\n    }\n\n    /**\n     * Sets the merkle root for the current round of Thruster Treasure\n     * @param _root - The new root to set\n     */\n    function setRoot(bytes32 _root) external onlyOwner {\n        root = _root;\n        currentRound += 1;\n        roundStart[currentRound] = block.timestamp;\n        currentTickets = 0;\n        emit NewRound(_root, currentRound);\n    }\n\n    /**\n     *\n     * @param _round - The round to claim the prize for\n     * @param _prizeIndex - The index of the prize to claim\n     * @param sequenceNumbers - The sequence numbers of the random number requests\n     * @param userRandoms - The user random numbers\n     * @param providerRandoms - The provider random numbers\n     */\n    function setWinningTickets(\n        uint256 _round,\n        uint256 _prizeIndex,\n        uint64[] calldata sequenceNumbers,\n        bytes32[] calldata userRandoms,\n        bytes32[] calldata providerRandoms\n    ) external onlyOwner {\n        require(roundStart[_round] + MAX_ROUND_TIME >= block.timestamp, \"ICT\");\n        require(winningTickets[_round][_prizeIndex].length == 0, \"WTS\");\n        Prize memory prize_ = prizes[_round][_prizeIndex];\n        uint256 numWinners = prize_.numWinners;\n        require(\n            sequenceNumbers.length == numWinners && userRandoms.length == numWinners\n                && providerRandoms.length == numWinners,\n            \"WL\"\n        );\n        uint256[] memory _winningTickets = new uint256[](numWinners);\n        for (uint256 i = 0; i < numWinners; i++) {\n            _winningTickets[i] = revealRandomNumber(sequenceNumbers[i], userRandoms[i], providerRandoms[i]);\n            emit SetWinningTicket(_round, _prizeIndex, _winningTickets[i], i);\n        }\n        winningTickets[_round][_prizeIndex] = _winningTickets;\n        require(_winningTickets.length == numWinners, \"WTL\");\n    }\n\n    /**\n     * Reveals the random number using Pyth Entropy.\n     *\n     * @param sequenceNumber - The sequence number of the random number request\n     * @param userRandom - The user's random number\n     * @param providerRandom - The provider's random number\n     */\n    function revealRandomNumber(uint64 sequenceNumber, bytes32 userRandom, bytes32 providerRandom)\n        public\n        onlyOwner\n        returns (uint256)\n    {\n        require(currentTickets > 0, \"NCT\");\n        // Reveal the random number. This call reverts if the provided values fail to match the commitments\n        // from the request phase. If the call returns, randomNumber is a uniformly distributed bytes32.\n        bytes32 randomNumber = entropy.reveal(entropyProvider, sequenceNumber, userRandom, providerRandom);\n        uint256 randomTicket_ = uint256(randomNumber) % currentTickets;\n\n        emit RandomNumberResult(randomTicket_, sequenceNumber);\n        return randomTicket_;\n    }\n\n    /**\n     * Claims the gas from the BLAST contract\n     * @param _recipient - The address to claim the yield to\n     * @param _minClaimRateBips - The minimum claim rate in bips\n     */\n    function claimGas(address _recipient, uint256 _minClaimRateBips) external onlyOwner returns (uint256 amount) {\n        if (_minClaimRateBips == 0) {\n            amount = BLAST.claimMaxGas(address(this), _recipient);\n        } else {\n            amount = BLAST.claimGasAtMinClaimRate(address(this), _recipient, _minClaimRateBips);\n        }\n        emit ClaimGas(_recipient, amount);\n    }\n\n    receive() external payable {}\n}"
    }
  ]
}