{
  "Title": "H-2: Incorrect function call leads to stale borrowing fees",
  "Content": "# Issue H-2: Incorrect function call leads to stale borrowing fees \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/197 \n\n## Found by \n0xAmanda\n\n## Summary\nDue to an incorrect function call while getting the total borrow fees, the returned fees will be an inaccurate and stale amount. Which will have an impact on liquidity providers\n\n\n## Vulnerability Detail\n\nAs said the function  `getTotalBorrowingFees`:\n\n    function getTotalBorrowingFees(DataStore dataStore, address market, address longToken, address shortToken, bool isLong) internal view returns (uint256) {\n        uint256 openInterest = getOpenInterest(dataStore, market, longToken, shortToken, isLong);\n        uint256 cumulativeBorrowingFactor = getCumulativeBorrowingFactor(dataStore, market, isLong);\n        uint256 totalBorrowing = getTotalBorrowing(dataStore, market, isLong);\n        return openInterest * cumulativeBorrowingFactor - totalBorrowing;\n    }\n\ncalculates the fess by calling  `getCumulativeBorrowingFactor(...)`:\n\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/market/MarketUtils.sol#L1890\n\nwhich is the wrong function to call because it returns a stale borrowing factor. To get the actual borrowing factor and calculate correctly the borrowing fees, GMX should call the `getNextCumulativeBorrowingFactor` function:\n\n\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/market/MarketUtils.sol#L1826\n\n\nWhich makes the right calculation, taking into account the stale fees also:\n\n        uint256 durationInSeconds = getSecondsSinceCumulativeBorrowingFactorUpdated(dataStore, market.marketToken, isLong);\n        uint256 borrowingFactorPerSecond = getBorrowingFactorPerSecond(\n            dataStore,\n            market,\n            prices,\n            isLong\n        );\n\n        uint256 cumulativeBorrowingFactor = getCumulativeBorrowingFactor(dataStore, market.marketToken, isLong);\n\n        uint256 delta = durationInSeconds * borrowingFactorPerSecond;\n        uint256 nextCumulativeBorrowingFactor = cumulativeBorrowingFactor + delta;\n        return (nextCumulativeBorrowingFactor, delta);\n\n## Impact\nAss fee calculation will not be accurate, liquidity providers will be have a less-worth token  because pending fees are not accounted in the pool's value\n\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/market/MarketUtils.sol#L1888\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIn order to mitigate the issue, call the function `getNextCumulativeBorrowingFactor` instead of the function `getCumulativeBorrowingFactor()` for a correct accounting and not getting stale fees \n\n\n\n## Discussion\n\n**IllIllI000**\n\n@xvi10 can you confirm that this is invalid?\n\n**xvi10**\n\nsorry thought i marked this, it is a valid issue\n\n**IllIllI000**\n\n@xvi10 can you elaborate on the conditions where this is a valid issue? Don’t most code paths call updateFundingAndBorrowingState() prior to fetching fees, so doesn’t that mean the value won’t be stale? I flagged the case where it’s missing in https://github.com/sherlock-audit/2023-02-gmx-judging/issues/158 . Are you saying that this is a separate issue, or that these should be combined, or something else?\n\n**xvi10**\n\nit affects the valuation of the market tokens for deposits / withdrawals\n\n**IllIllI000**\n\n@hrishibhat agree with sponsor – valid High\n\n**0xffff11**\n\nEscalate for 10 USDC\n\nIt is a valid solo high. Sponsor confirmed the issue and severity.\n\nRe-explanation for better understanding:\n\nThe function:\n\n     function getTotalBorrowingFees(DataStore dataStore, address market, address longToken, address shortToken, bool isLong) \n    internal view returns (uint256) {\n     uint256 openInterest = getOpenInterest(dataStore, market, longToken, shortToken, isLong);\n      uint256 cumulativeBorrowingFactor = getCumulativeBorrowingFactor(dataStore, market, isLong);\n     uint256 totalBorrowing = getTotalBorrowing(dataStore, market, isLong);\n      return openInterest * cumulativeBorrowingFactor - totalBorrowing;\n     }\n\nis made to return the borrowingFees that are pending at that moment. The issue is that inside the `getTotalBorrowingFees` function, they are calling the wrong function to get the `cumulativeBorrowingFactor`.\n\nThey are calling the function `cumulativeBorrowingFactor` instead of `getNextCumulativeBorrowingFactor.` , that is the one that should be called to get the updated borrowing fees. Calling the `cumulativeBorrowingFactor` returns the outdated fees.\n\nThese `outdate` in fees can cause a missmatch in pricing specially while withdrawing, as sponsor confirmed.\n\n\nTo sum up: Issue is completely valid, sponsor confirmed and enough issue has been given. Please make it a valid solo high, thanks IIIIIII!\n\n\n\n\n\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> It is a valid solo high. Sponsor confirmed the issue and severity.\n> \n> Re-explanation for better understanding:\n> \n> The function:\n> \n>      function getTotalBorrowingFees(DataStore dataStore, address market, address longToken, address shortToken, bool isLong) \n>     internal view returns (uint256) {\n>      uint256 openInterest = getOpenInterest(dataStore, market, longToken, shortToken, isLong);\n>       uint256 cumulativeBorrowingFactor = getCumulativeBorrowingFactor(dataStore, market, isLong);\n>      uint256 totalBorrowing = getTotalBorrowing(dataStore, market, isLong);\n>       return openInterest * cumulativeBorrowingFactor - totalBorrowing;\n>      }\n> \n> is made to return the borrowingFees that are pending at that moment. The issue is that inside the `getTotalBorrowingFees` function, they are calling the wrong function to get the `cumulativeBorrowingFactor`.\n> \n> They are calling the function `cumulativeBorrowingFactor` instead of `getNextCumulativeBorrowingFactor.` , that is the one that should be called to get the updated borrowing fees. Calling the `cumulativeBorrowingFactor` returns the outdated fees.\n> \n> These `outdate` in fees can cause a missmatch in pricing specially while withdrawing, as sponsor confirmed.\n> \n> \n> To sum up: Issue is completely valid, sponsor confirmed and enough issue has been given. Please make it a valid solo high, thanks IIIIIII!\n> \n> \n> \n> \n> \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**IllIllI000**\n\nI messed up the tagging - Valid solo High\n\n**hrishibhat**\n\nEscalation accepted\n\nConsidering this issue a valid high\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Considering this issue a valid high\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n**xvi10**\n\nFix in https://github.com/gmx-io/gmx-synthetics/pull/89/files#diff-f764a51a3af5d3117eeeff219951425f3ecc8cd15b742bb044afc7c73b03f4aa\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/market/MarketUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"../data/DataStore.sol\";\nimport \"../event/EventEmitter.sol\";\nimport \"../bank/StrictBank.sol\";\n\nimport \"./Market.sol\";\nimport \"./MarketToken.sol\";\nimport \"./MarketEventUtils.sol\";\nimport \"./MarketStoreUtils.sol\";\n\nimport \"../position/Position.sol\";\nimport \"../order/Order.sol\";\n\nimport \"../oracle/Oracle.sol\";\nimport \"../price/Price.sol\";\n\nimport \"../utils/Calc.sol\";\nimport \"../utils/Precision.sol\";\n\n// @title MarketUtils\n// @dev Library for market functions\nlibrary MarketUtils {\n    using SafeCast for int256;\n    using SafeCast for uint256;\n\n    using Market for Market.Props;\n    using Position for Position.Props;\n    using Order for Order.Props;\n    using Price for Price.Props;\n\n    // @dev struct to store the prices of tokens of a market\n    // @param indexTokenPrice price of the market's index token\n    // @param longTokenPrice price of the market's long token\n    // @param shortTokenPrice price of the market's short token\n    struct MarketPrices {\n        Price.Props indexTokenPrice;\n        Price.Props longTokenPrice;\n        Price.Props shortTokenPrice;\n    }\n\n    // @dev struct for the result of the getNextFundingAmountPerSize call\n    // @param longsPayShorts whether longs pay shorts or shorts pay longs\n    // @param fundingAmountPerSize_LongCollateral_LongPosition funding amount per\n    // size for users with a long position using long collateral\n    // @param fundingAmountPerSize_LongCollateral_ShortPosition funding amount per\n    // size for users with a short position using long collateral\n    // @param fundingAmountPerSize_ShortCollateral_LongPosition funding amount per\n    // size for users with a long position using short collateral\n    // @param fundingAmountPerSize_ShortCollateral_ShortPosition funding amount per\n    // size for users with a short position using short collateral\n    struct GetNextFundingAmountPerSizeResult {\n        bool longsPayShorts;\n        int256 fundingAmountPerSize_LongCollateral_LongPosition;\n        int256 fundingAmountPerSize_LongCollateral_ShortPosition;\n        int256 fundingAmountPerSize_ShortCollateral_LongPosition;\n        int256 fundingAmountPerSize_ShortCollateral_ShortPosition;\n    }\n\n    // @dev struct to avoid stack too deep errors for the getPoolValue call\n    // @param value the pool value\n    // @param longTokenAmount the amount of long token in the pool\n    // @param shortTokenAmount the amount of short token in the pool\n    // @param longTokenUsd the USD value of the long tokens in the pool\n    // @param shortTokenUsd the USD value of the short tokens in the pool\n    // @param totalBorrowingFees the total pending borrowing fees for the market\n    // @param borrowingFeeReceiverFactor the fee receiver factor for borrowing fees\n    // @param impactPoolAmount the amount of tokens in the impact pool\n    // @param longPnl the pending pnl of long positions\n    // @param shortPnl the pending pnl of short positions\n    // @param netPnl the net pnl of long and short positions\n    struct GetPoolValueCache {\n        uint256 value;\n\n        uint256 longTokenAmount;\n        uint256 shortTokenAmount;\n        uint256 longTokenUsd;\n        uint256 shortTokenUsd;\n\n        uint256 totalBorrowingFees;\n        uint256 borrowingFeeReceiverFactor;\n\n        uint256 impactPoolAmount;\n        int256 longPnl;\n        int256 shortPnl;\n        int256 netPnl;\n    }\n\n    // @dev GetNextFundingAmountPerSizeCache struct used in getNextFundingAmountPerSize\n    // to avoid stack too deep errors\n    //\n    // @param durationInSeconds duration in seconds since the last funding update\n    //\n    // @param diffUsd the absolute difference in long and short open interest for the market\n    // @param totalOpenInterest the total long and short open interest for the market\n    // @param fundingUsd the funding amount in USD\n    //\n    // @param fundingUsdForLongCollateral the funding amount in USD for positions using the long token as collateral\n    // @param fundingUsdForShortCollateral the funding amount in USD for positions using the short token as collateral\n    struct GetNextFundingAmountPerSizeCache {\n        GetNextFundingAmountPerSizeOpenInterestCache oi;\n        GetNextFundingAmountPerSizeFundingPerSizeCache fps;\n\n        uint256 durationInSeconds;\n\n        uint256 diffUsd;\n        uint256 totalOpenInterest;\n        uint256 sizeOfLargerSide;\n        uint256 fundingFactorPerSecond;\n        uint256 fundingUsd;\n\n        uint256 fundingUsdForLongCollateral;\n        uint256 fundingUsdForShortCollateral;\n    }\n\n    // @param longOpenInterestWithLongCollateral amount of long open interest using the long token as collateral\n    // @param longOpenInterestWithShortCollateral amount of long open interest using the short token as collateral\n    // @param shortOpenInterestWithLongCollateral amount of short open interest using the long token as collateral\n    // @param shortOpenInterestWithShortCollateral amount of short open interest using the short token as collateral\n    //\n    // @param longOpenInterest total long open interest for the market\n    // @param shortOpenInterest total short open interest for the market\n    struct GetNextFundingAmountPerSizeOpenInterestCache {\n        uint256 longOpenInterestWithLongCollateral;\n        uint256 longOpenInterestWithShortCollateral;\n        uint256 shortOpenInterestWithLongCollateral;\n        uint256 shortOpenInterestWithShortCollateral;\n\n        uint256 longOpenInterest;\n        uint256 shortOpenInterest;\n    }\n\n    // @param fundingAmountPerSize_LongCollateral_LongPosition funding per size for longs using the long token as collateral\n    // @param fundingAmountPerSize_LongCollateral_ShortPosition funding per size for shorts using the long token as collateral\n    // @param fundingAmountPerSize_ShortCollateral_LongPosition funding per size for longs using the short token as collateral\n    // @param fundingAmountPerSize_ShortCollateral_ShortPosition funding per size for shorts using the short token as collateral\n    //\n    // @param fundingAmountPerSizePortion_LongCollateral_LongPosition the next funding amount per size for longs using the long token as collateral\n    // @param fundingAmountPerSizePortion_LongCollateral_ShortPosition the next funding amount per size for longs using the short token as collateral\n    // @param fundingAmountPerSizePortion_ShortCollateral_LongPosition the next funding amount per size for shorts using the long token as collateral\n    // @param fundingAmountPerSizePortion_ShortCollateral_ShortPosition the next funding amount per size for shorts using the short token as collateral\n    struct GetNextFundingAmountPerSizeFundingPerSizeCache {\n        int256 fundingAmountPerSize_LongCollateral_LongPosition;\n        int256 fundingAmountPerSize_LongCollateral_ShortPosition;\n        int256 fundingAmountPerSize_ShortCollateral_LongPosition;\n        int256 fundingAmountPerSize_ShortCollateral_ShortPosition;\n\n        uint256 fundingAmountPerSizePortion_LongCollateral_LongPosition;\n        uint256 fundingAmountPerSizePortion_ShortCollateral_LongPosition;\n        uint256 fundingAmountPerSizePortion_LongCollateral_ShortPosition;\n        uint256 fundingAmountPerSizePortion_ShortCollateral_ShortPosition;\n    }\n\n    error EmptyMarket();\n    error DisabledMarket(address market);\n    error InsufficientPoolAmount(uint256 poolAmount, uint256 amount);\n    error InsufficientReserve(uint256 reservedUsd, uint256 maxReservedUsd);\n    error UnexpectedPoolValueForTokenPriceCalculation(int256 poolValue);\n    error UnexpectedSupplyForTokenPriceCalculation();\n    error UnableToGetOppositeToken(address inputToken, address market);\n    error UnableToGetCachedTokenPrice(address token, address market);\n    error CollateralAlreadyClaimed(uint256 adjustedClaimableAmount, uint256 claimedAmount);\n    error OpenInterestCannotBeUpdatedForSwapOnlyMarket(address market);\n    error MaxOpenInterestExceeded(uint256 openInterest, uint256 maxOpenInterest);\n    error MaxPoolAmountExceeded(uint256 poolAmount, uint256 maxPoolAmount);\n    error UnexpectedBorrowingFactor(uint256 positionBorrowingFactor, uint256 cumulativeBorrowingFactor);\n    error UnableToGetBorrowingFactorEmptyPoolUsd();\n    error UnableToGetFundingFactorEmptyOpenInterest();\n    error InvalidPositionMarket(address market);\n    error InvalidCollateralTokenForMarket(address market, address token);\n    error PnlFactorExceededForLongs(int256 pnlToPoolFactor, uint256 maxPnlFactor);\n    error PnlFactorExceededForShorts(int256 pnlToPoolFactor, uint256 maxPnlFactor);\n\n    // @dev get the market token's price\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @param longTokenPrice the price of the long token\n    // @param shortTokenPrice the price of the short token\n    // @param indexTokenPrice the price of the index token\n    // @param maximize whether to maximize or minimize the market token price\n    // @return returns the market token's price\n    function getMarketTokenPrice(\n        DataStore dataStore,\n        Market.Props memory market,\n        Price.Props memory longTokenPrice,\n        Price.Props memory shortTokenPrice,\n        Price.Props memory indexTokenPrice,\n        bytes32 pnlFactorType,\n        bool maximize\n    ) internal view returns (int256) {\n        int256 poolValue = getPoolValue(\n            dataStore,\n            market,\n            longTokenPrice,\n            shortTokenPrice,\n            indexTokenPrice,\n            pnlFactorType,\n            maximize\n        );\n\n        if (poolValue == 0) { return 0; }\n\n        if (poolValue < 0) {\n            revert UnexpectedPoolValueForTokenPriceCalculation(poolValue);\n        }\n\n        uint256 supply = getMarketTokenSupply(MarketToken(payable(market.marketToken)));\n\n        if (supply == 0) {\n            revert UnexpectedSupplyForTokenPriceCalculation();\n        }\n\n        return poolValue * Precision.WEI_PRECISION.toInt256() / supply.toInt256();\n    }\n\n    // @dev get the total supply of the marketToken\n    // @param marketToken the marketToken\n    // @return the total supply of the marketToken\n    function getMarketTokenSupply(MarketToken marketToken) internal view returns (uint256) {\n        return marketToken.totalSupply();\n    }\n\n    // @dev get the opposite token of the market\n    // if the inputToken is the longToken return the shortToken and vice versa\n    // @param inputToken the input token\n    // @param market the market values\n    // @return the opposite token\n    function getOppositeToken(address inputToken, Market.Props memory market) internal pure returns (address) {\n        if (inputToken == market.longToken) {\n            return market.shortToken;\n        }\n\n        if (inputToken == market.shortToken) {\n            return market.longToken;\n        }\n\n        revert UnableToGetOppositeToken(inputToken, market.marketToken);\n    }\n\n    // @dev get the token price from the stored MarketPrices\n    // @param token the token to get the price for\n    // @param the market values\n    // @param the market token prices\n    // @return the token price from the stored MarketPrices\n    function getCachedTokenPrice(address token, Market.Props memory market, MarketPrices memory prices) internal pure returns (Price.Props memory) {\n        if (token == market.longToken) {\n            return prices.longTokenPrice;\n        }\n        if (token == market.shortToken) {\n            return prices.shortTokenPrice;\n        }\n        if (token == market.indexToken) {\n            return prices.indexTokenPrice;\n        }\n\n        revert UnableToGetCachedTokenPrice(token, market.marketToken);\n    }\n\n    // @dev return the latest prices for the market tokens\n    // the secondary price for market.indexToken is overwritten for certain order\n    // types, use this value instead of the primary price for positions\n    // @param oracle Oracle\n    // @param market the market values\n    function getMarketPricesForPosition(Oracle oracle, Market.Props memory market) internal view returns (MarketPrices memory) {\n        return MarketPrices(\n            oracle.getLatestPrice(market.indexToken),\n            oracle.getLatestPrice(market.longToken),\n            oracle.getLatestPrice(market.shortToken)\n        );\n    }\n\n    // @dev return the primary prices for the market tokens\n    // @param oracle Oracle\n    // @param market the market values\n    function getMarketPrices(Oracle oracle, Market.Props memory market) internal view returns (MarketPrices memory) {\n        return MarketPrices(\n            oracle.getPrimaryPrice(market.indexToken),\n            oracle.getPrimaryPrice(market.longToken),\n            oracle.getPrimaryPrice(market.shortToken)\n        );\n    }\n\n    // @dev get the usd value of either the long or short tokens in the pool\n    // without accounting for the pnl of open positions\n    // @param dataStore DataStore\n    // @param market the market values\n    // @param prices the prices of the market tokens\n    // @param whether to return the value for the long or short token\n    // @return the usd value of either the long or short tokens in the pool\n    function getPoolUsdWithoutPnl(\n        DataStore dataStore,\n        Market.Props memory market,\n        MarketPrices memory prices,\n        bool isLong\n    ) internal view returns (uint256) {\n        address token = isLong ? market.longToken : market.shortToken;\n        uint256 poolAmount = getPoolAmount(dataStore, market.marketToken, token);\n        uint256 tokenPrice = isLong ? prices.longTokenPrice.min : prices.shortTokenPrice.min;\n        return poolAmount * tokenPrice;\n    }\n\n    // @dev get the USD value of a pool\n    // the value of a pool is the worth of the liquidity provider tokens in the pool - pending trader pnl\n    // we use the token index prices to calculate this and ignore price impact since if all positions were closed the\n    // net price impact should be zero\n    // @param dataStore DataStore\n    // @param market the market values\n    // @param longTokenPrice price of the long token\n    // @param shortTokenPrice price of the short token\n    // @param indexTokenPrice price of the index token\n    // @param maximize whether to maximize or minimize the pool value\n    // @return the USD value of a pool\n    function getPoolValue(\n        DataStore dataStore,\n        Market.Props memory market,\n        Price.Props memory longTokenPrice,\n        Price.Props memory shortTokenPrice,\n        Price.Props memory indexTokenPrice,\n        bytes32 pnlFactorType,\n        bool maximize\n    ) internal view returns (int256) {\n        GetPoolValueCache memory cache;\n\n        cache.longTokenAmount = getPoolAmount(dataStore, market.marketToken, market.longToken);\n        cache.shortTokenAmount = getPoolAmount(dataStore, market.marketToken, market.shortToken);\n\n        cache.longTokenUsd = cache.longTokenAmount * longTokenPrice.pickPrice(maximize);\n        cache.shortTokenUsd = cache.shortTokenAmount * shortTokenPrice.pickPrice(maximize);\n\n        cache.value = cache.longTokenUsd + cache.shortTokenUsd;\n\n        cache.totalBorrowingFees = getTotalBorrowingFees(dataStore, market.marketToken, market.longToken, market.shortToken, true);\n        cache.totalBorrowingFees += getTotalBorrowingFees(dataStore, market.marketToken, market.longToken, market.shortToken, false);\n\n        cache.borrowingFeeReceiverFactor = dataStore.getUint(Keys.BORROWING_FEE_RECEIVER_FACTOR);\n        cache.value += Precision.applyFactor(cache.totalBorrowingFees, cache.borrowingFeeReceiverFactor);\n\n        cache.impactPoolAmount = getPositionImpactPoolAmount(dataStore, market.marketToken);\n        cache.value += cache.impactPoolAmount * indexTokenPrice.pickPrice(maximize);\n\n        // !maximize should be used for net pnl as a larger pnl leads to a smaller pool value\n        // and a smaller pnl leads to a larger pool value\n\n        cache.longPnl = getPnl(\n            dataStore,\n            market.marketToken,\n            market.longToken,\n            market.shortToken,\n            indexTokenPrice,\n            true,\n            !maximize\n        );\n\n        cache.longPnl = getCappedPnl(\n            dataStore,\n            market.marketToken,\n            true,\n            cache.longPnl,\n            cache.longTokenUsd,\n            pnlFactorType\n        );\n\n        cache.shortPnl = getPnl(\n            dataStore,\n            market.marketToken,\n            market.longToken,\n            market.shortToken,\n            indexTokenPrice,\n            false,\n            !maximize\n        );\n\n        cache.shortPnl = getCappedPnl(\n            dataStore,\n            market.marketToken,\n            false,\n            cache.shortPnl,\n            cache.shortTokenUsd,\n            pnlFactorType\n        );\n\n        cache.netPnl = cache.longPnl + cache.shortPnl;\n\n        return Calc.sumReturnInt256(cache.value, -cache.netPnl);\n    }\n\n    // @dev get the net pending pnl for a market\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @param longToken the long token of the market\n    // @param shortToken the short token of the market\n    // @param indexTokenPrice the price of the index token\n    // @param maximize whether to maximize or minimize the net pnl\n    // @return the net pending pnl for a market\n    function getNetPnl(\n        DataStore dataStore,\n        address market,\n        address longToken,\n        address shortToken,\n        Price.Props memory indexTokenPrice,\n        bool maximize\n    ) internal view returns (int256) {\n        int256 longPnl = getPnl(dataStore, market, longToken, shortToken, indexTokenPrice, true, maximize);\n        int256 shortPnl = getPnl(dataStore, market, longToken, shortToken, indexTokenPrice, false, maximize);\n\n        return longPnl + shortPnl;\n    }\n\n    // @dev get the capped pending pnl for a market\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @param isLong whether to check for the long or short side\n    // @param pnl the uncapped pnl of the market\n    // @param poolUsd the USD value of the pool\n    // @param pnlFactorType the pnl factor type to use\n    function getCappedPnl(\n        DataStore dataStore,\n        address market,\n        bool isLong,\n        int256 pnl,\n        uint256 poolUsd,\n        bytes32 pnlFactorType\n    ) internal view returns (int256) {\n        if (pnl < 0) { return pnl; }\n\n        uint256 maxPnlFactor = getMaxPnlFactor(dataStore, pnlFactorType, market, isLong);\n        int256 maxPnl = Precision.applyFactor(poolUsd, maxPnlFactor).toInt256();\n\n        return pnl > maxPnl ? maxPnl : pnl;\n    }\n\n    // @dev get the pending pnl for a market\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @param longToken the long token of the market\n    // @param shortToken the short token of the market\n    // @param indexTokenPrice the price of the index token\n    // @param isLong whether to check for the long or short side\n    // @param maximize whether to maximize or minimize the pnl\n    function getPnl(\n        DataStore dataStore,\n        address market,\n        address longToken,\n        address shortToken,\n        uint256 indexTokenPrice,\n        bool isLong,\n        bool maximize\n    ) internal view returns (int256) {\n        Price.Props memory _indexTokenPrice = Price.Props(indexTokenPrice, indexTokenPrice);\n\n        return getPnl(\n            dataStore,\n            market,\n            longToken,\n            shortToken,\n            _indexTokenPrice,\n            isLong,\n            maximize\n        );\n    }\n\n    // @dev get the pending pnl for a market for either longs or shorts\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @param longToken the long token of the market\n    // @param shortToken the short token of the market\n    // @param indexTokenPrice the price of the index token\n    // @param isLong whether to get the pnl for longs or shorts\n    // @param maximize whether to maximize or minimize the net pnl\n    // @return the pending pnl for a market for either longs or shorts\n    function getPnl(\n        DataStore dataStore,\n        address market,\n        address longToken,\n        address shortToken,\n        Price.Props memory indexTokenPrice,\n        bool isLong,\n        bool maximize\n    ) internal view returns (int256) {\n        int256 openInterest = getOpenInterest(dataStore, market, longToken, shortToken, isLong).toInt256();\n        uint256 openInterestInTokens = getOpenInterestInTokens(dataStore, market, longToken, shortToken, isLong);\n        if (openInterest == 0 || openInterestInTokens == 0) {\n            return 0;\n        }\n\n        uint256 price = indexTokenPrice.pickPriceForPnl(isLong, maximize);\n\n        // openInterest is the cost of all positions, openInterestValue is the current worth of all positions\n        int256 openInterestValue = (openInterestInTokens * price).toInt256();\n        int256 pnl = isLong ? openInterestValue - openInterest : openInterest - openInterestValue;\n\n        return pnl;\n    }\n\n    // @dev get the amount of tokens in the pool\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @param token the token to check\n    // @return the amount of tokens in the pool\n    function getPoolAmount(DataStore dataStore, address market, address token) internal view returns (uint256) {\n        return dataStore.getUint(Keys.poolAmountKey(market, token));\n    }\n\n    // @dev get the max amount of tokens allowed to be in the pool\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @param token the token to check\n    // @return the max amount of tokens that are allowed in the pool\n    function getMaxPoolAmount(DataStore dataStore, address market, address token) internal view returns (uint256) {\n        return dataStore.getUint(Keys.maxPoolAmountKey(market, token));\n    }\n\n    // @dev get the max open interest allowed for the market\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @param isLong whether this is for the long or short side\n    // @return the max open interest allowed for the market\n    function getMaxOpenInterest(DataStore dataStore, address market, bool isLong) internal view returns (uint256) {\n        return dataStore.getUint(Keys.maxOpenInterestKey(market, isLong));\n    }\n\n    // @dev increment the claimable collateral amount\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param market the market to increment the claimable collateral for\n    // @param token the claimable token\n    // @param account the account to increment the claimable collateral for\n    // @param delta the amount to increment\n    function incrementClaimableCollateralAmount(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        address market,\n        address token,\n        address account,\n        uint256 delta\n    ) internal {\n        uint256 divisor = dataStore.getUint(Keys.CLAIMABLE_COLLATERAL_TIME_DIVISOR);\n        uint256 timeKey = block.timestamp / divisor;\n\n        uint256 nextValue = dataStore.incrementUint(\n            Keys.claimableCollateralAmountKey(market, token, timeKey, account),\n            delta\n        );\n\n        MarketEventUtils.emitClaimableCollateralUpdated(eventEmitter, market, token, timeKey, account, delta, nextValue);\n    }\n\n    // @dev increment the claimable funding amount\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param market the trading market\n    // @param token the claimable token\n    // @param account the account to increment for\n    // @param delta the amount to increment\n    function incrementClaimableFundingAmount(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        address market,\n        address token,\n        address account,\n        uint256 delta\n    ) internal {\n        uint256 nextValue = dataStore.incrementUint(\n            Keys.claimableFundingAmountKey(market, token, account),\n            delta\n        );\n\n        MarketEventUtils.emitClaimableFundingUpdated(eventEmitter, market, token, account, delta, nextValue);\n    }\n\n    // @dev claim funding fees\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param market the market to claim for\n    // @param token the token to claim\n    // @param account the account to claim for\n    // @param receiver the receiver to send the amount to\n    function claimFundingFees(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        address market,\n        address token,\n        address account,\n        address receiver\n    ) internal {\n        bytes32 key = Keys.claimableFundingAmountKey(market, token, account);\n\n        uint256 claimableAmount = dataStore.getUint(key);\n        dataStore.setUint(key, 0);\n\n        MarketToken(payable(market)).transferOut(\n            token,\n            receiver,\n            claimableAmount\n        );\n\n        MarketEventUtils.emitFundingFeesClaimed(\n            eventEmitter,\n            market,\n            token,\n            account,\n            receiver,\n            claimableAmount\n        );\n    }\n\n    // @dev claim collateral\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param market the market to claim for\n    // @param token the token to claim\n    // @param account the account to claim for\n    // @param receiver the receiver to send the amount to\n    function claimCollateral(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        address market,\n        address token,\n        uint256 timeKey,\n        address account,\n        address receiver\n    ) internal {\n        uint256 claimableAmount = dataStore.getUint(Keys.claimableCollateralAmountKey(market, token, timeKey, account));\n        uint256 claimableFactor = dataStore.getUint(Keys.claimableCollateralFactorKey(market, token, timeKey, account));\n        uint256 claimedAmount = dataStore.getUint(Keys.claimedCollateralAmountKey(market, token, timeKey, account));\n\n        uint256 adjustedClaimableAmount = Precision.applyFactor(claimableAmount, claimableFactor);\n        if (adjustedClaimableAmount >= claimedAmount) {\n            revert CollateralAlreadyClaimed(adjustedClaimableAmount, claimedAmount);\n        }\n\n        uint256 remainingClaimableAmount = adjustedClaimableAmount - claimedAmount;\n\n        dataStore.setUint(\n            Keys.claimedCollateralAmountKey(market, token, timeKey, account),\n            adjustedClaimableAmount\n        );\n\n        MarketToken(payable(market)).transferOut(\n            token,\n            receiver,\n            remainingClaimableAmount\n        );\n\n        MarketEventUtils.emitCollateralClaimed(\n            eventEmitter,\n            market,\n            token,\n            timeKey,\n            account,\n            receiver,\n            remainingClaimableAmount\n        );\n    }\n\n    // @dev apply a delta to the pool amount\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param market the market to apply to\n    // @param token the token to apply to\n    // @param delta the delta amount\n    function applyDeltaToPoolAmount(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        address market,\n        address token,\n        int256 delta\n    ) internal returns (uint256) {\n        uint256 nextValue = dataStore.applyDeltaToUint(\n            Keys.poolAmountKey(market, token),\n            delta,\n            \"Invalid state, negative poolAmount\"\n        );\n\n        applyDeltaToVirtualInventoryForSwaps(\n            dataStore,\n            market,\n            token,\n            delta\n        );\n\n        MarketEventUtils.emitPoolAmountUpdated(eventEmitter, market, token, delta, nextValue);\n\n        return nextValue;\n    }\n\n    // @dev cap the input priceImpactUsd by the available amount in the position impact pool\n    // @param dataStore DataStore\n    // @param market the trading market\n    // @param tokenPrice the price of the token\n    // @param priceImpactUsd the calculated USD price impact\n    // @return the capped priceImpactUsd\n    function getCappedPositionImpactUsd(\n        DataStore dataStore,\n        address market,\n        Price.Props memory tokenPrice,\n        int256 priceImpactUsd,\n        uint256 sizeDeltaUsd\n    ) internal view returns (int256) {\n        if (priceImpactUsd < 0) {\n            return priceImpactUsd;\n        }\n\n        uint256 impactPoolAmount = getPositionImpactPoolAmount(dataStore, market);\n        int256 maxPriceImpactUsdBasedOnImpactPool = (impactPoolAmount * tokenPrice.min).toInt256();\n\n        if (priceImpactUsd > maxPriceImpactUsdBasedOnImpactPool) {\n            priceImpactUsd = maxPriceImpactUsdBasedOnImpactPool;\n        }\n\n        uint256 maxPriceImpactFactor = getMaxPositionImpactFactor(dataStore, market, true);\n        int256 maxPriceImpactUsdBasedOnMaxPriceImpactFactor = Precision.applyFactor(sizeDeltaUsd, maxPriceImpactFactor).toInt256();\n\n        if (priceImpactUsd > maxPriceImpactUsdBasedOnMaxPriceImpactFactor) {\n            priceImpactUsd = maxPriceImpactUsdBasedOnMaxPriceImpactFactor;\n        }\n\n        return priceImpactUsd;\n    }\n\n    // @dev get the position impact pool amount\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @return the position impact pool amount\n    function getPositionImpactPoolAmount(DataStore dataStore, address market) internal view returns (uint256) {\n        return dataStore.getUint(Keys.positionImpactPoolAmountKey(market));\n    }\n\n    // @dev get the swap impact pool amount\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @param token the token to check\n    // @return the swap impact pool amount\n    function getSwapImpactPoolAmount(DataStore dataStore, address market, address token) internal view returns (uint256) {\n        return dataStore.getUint(Keys.swapImpactPoolAmountKey(market, token));\n    }\n\n    // @dev apply a delta to the swap impact pool\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param market the market to apply to\n    // @param token the token to apply to\n    // @param delta the delta amount\n    function applyDeltaToSwapImpactPool(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        address market,\n        address token,\n        int256 delta\n    ) internal returns (uint256) {\n        uint256 nextValue = dataStore.applyBoundedDeltaToUint(\n            Keys.swapImpactPoolAmountKey(market, token),\n            delta\n        );\n\n        MarketEventUtils.emitSwapImpactPoolAmountUpdated(eventEmitter, market, token, delta, nextValue);\n\n        return nextValue;\n    }\n\n    // @dev apply a delta to the position impact pool\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param market the market to apply to\n    // @param delta the delta amount\n    function applyDeltaToPositionImpactPool(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        address market,\n        int256 delta\n    ) internal returns (uint256) {\n        uint256 nextValue = dataStore.applyBoundedDeltaToUint(\n            Keys.positionImpactPoolAmountKey(market),\n            delta\n        );\n\n        MarketEventUtils.emitPositionImpactPoolAmountUpdated(eventEmitter, market, delta, nextValue);\n\n        return nextValue;\n    }\n\n    // @dev apply a delta to the open interest\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param market the market to apply to\n    // @param collateralToken the collateralToken to apply to\n    // @param isLong whether to apply to the long or short side\n    // @param delta the delta amount\n    function applyDeltaToOpenInterest(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        address market,\n        address indexToken,\n        address collateralToken,\n        bool isLong,\n        int256 delta\n    ) internal returns (uint256) {\n        if (indexToken == address(0)) {\n            revert OpenInterestCannotBeUpdatedForSwapOnlyMarket(market);\n        }\n\n        uint256 nextValue = dataStore.applyDeltaToUint(\n            Keys.openInterestKey(market, collateralToken, isLong),\n            delta,\n            \"Invalid state: negative open interest\"\n        );\n\n        // if the open interest for longs is increased then tokens were virtually bought from the pool\n        // so the virtual inventory should be decreased\n        // if the open interest for longs is decreased then tokens were virtually sold to the pool\n        // so the virtual inventory should be increased\n        // if the open interest"
    }
  ]
}