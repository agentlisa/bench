{
  "Title": "Flawed Stable Debt Calculation Due to Timestamp Mismatch",
  "Content": "##### Description\nhttps://github.com/aave/protocol-v2/blob/f435b2fa0ac589852ca3dd6ae2b0fbfbc7079d54/contracts/libraries/logic/ReserveLogic.sol#L341-L347 \n\nValue `vars.previousStableDebt` calculated this way is actually the current stable debt and always equals to `vars.currentStableDebt`.\n\n```solidity\n//calculate the stable debt until the last timestamp update\nvars.cumulatedStableInterest = MathUtils.calculateCompoundedInterest(\n  vars.avgStableRate,\n  vars.stableSupplyUpdatedTimestamp\n);\n\nvars.previousStableDebt = vars.principalStableDebt.rayMul(vars.cumulatedStableInterest);\n```\n\nAs a result, the stable debt difference is not taken into account. Moreover, the processed stable debt increment is not recorded in any way.\n##### Recommendation\nOne possible solution is to treat `vars.principalStableDebt` as the previous stable debt and update `StableDebtToken`'s `_totalSupply` and `_totalSupplyTimestamp` after the operation.\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/libraries/logic/ReserveLogic.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.6.8;\n\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {MathUtils} from '../math/MathUtils.sol';\nimport {IPriceOracleGetter} from '../../interfaces/IPriceOracleGetter.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {IAToken} from '../../tokenization/interfaces/IAToken.sol';\nimport {IStableDebtToken} from '../../tokenization/interfaces/IStableDebtToken.sol';\nimport {IVariableDebtToken} from '../../tokenization/interfaces/IVariableDebtToken.sol';\nimport {ReserveConfiguration} from '../configuration/ReserveConfiguration.sol';\nimport {IReserveInterestRateStrategy} from '../../interfaces/IReserveInterestRateStrategy.sol';\nimport {WadRayMath} from '../math/WadRayMath.sol';\nimport {PercentageMath} from '../math/PercentageMath.sol';\nimport {Errors} from '../helpers/Errors.sol';\n\n/**\n * @title ReserveLogic library\n * @author Aave\n * @notice Implements the logic to update the state of the reserves\n */\nlibrary ReserveLogic {\n  using SafeMath for uint256;\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n  using SafeERC20 for IERC20;\n\n  /**\n   * @dev Emitted when the state of a reserve is updated\n   * @param reserve the address of the reserve\n   * @param liquidityRate the new liquidity rate\n   * @param stableBorrowRate the new stable borrow rate\n   * @param variableBorrowRate the new variable borrow rate\n   * @param liquidityIndex the new liquidity index\n   * @param variableBorrowIndex the new variable borrow index\n   **/\n  event ReserveDataUpdated(\n    address indexed reserve,\n    uint256 liquidityRate,\n    uint256 stableBorrowRate,\n    uint256 variableBorrowRate,\n    uint256 liquidityIndex,\n    uint256 variableBorrowIndex\n  );\n\n  using ReserveLogic for ReserveLogic.ReserveData;\n  using ReserveConfiguration for ReserveConfiguration.Map;\n\n  enum InterestRateMode {NONE, STABLE, VARIABLE}\n\n  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfiguration.Map configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    uint40 lastUpdateTimestamp;\n    //tokens addresses\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint8 id;\n  }\n\n  /**\n   * @dev returns the ongoing normalized income for the reserve.\n   * a value of 1e27 means there is no income. As time passes, the income is accrued.\n   * A value of 2*1e27 means for each unit of assset two units of income have been accrued.\n   * @param reserve the reserve object\n   * @return the normalized income. expressed in ray\n   **/\n  function getNormalizedIncome(ReserveData storage reserve) internal view returns (uint256) {\n    uint40 timestamp = reserve.lastUpdateTimestamp;\n\n    //solium-disable-next-line\n    if (timestamp == uint40(block.timestamp)) {\n      //if the index was updated in the same block, no need to perform any calculation\n      return reserve.liquidityIndex;\n    }\n\n    uint256 cumulated = MathUtils\n      .calculateLinearInterest(reserve.currentLiquidityRate, timestamp)\n      .rayMul(reserve.liquidityIndex);\n\n    return cumulated;\n  }\n\n  /**\n   * @dev returns the ongoing normalized variable debt for the reserve.\n   * a value of 1e27 means there is no debt. As time passes, the income is accrued.\n   * A value of 2*1e27 means that the debt of the reserve is double the initial amount.\n   * @param reserve the reserve object\n   * @return the normalized variable debt. expressed in ray\n   **/\n  function getNormalizedDebt(ReserveData storage reserve) internal view returns (uint256) {\n    uint40 timestamp = reserve.lastUpdateTimestamp;\n\n    //solium-disable-next-line\n    if (timestamp == uint40(block.timestamp)) {\n      //if the index was updated in the same block, no need to perform any calculation\n      return reserve.variableBorrowIndex;\n    }\n\n    uint256 cumulated = MathUtils\n      .calculateCompoundedInterest(reserve.currentVariableBorrowRate, timestamp)\n      .rayMul(reserve.variableBorrowIndex);\n\n    return cumulated;\n  }\n\n  /**\n   * @dev returns an address of the debt token used for particular interest rate mode on asset.\n   * @param reserve the reserve object\n   * @param interestRateMode - STABLE or VARIABLE from ReserveLogic.InterestRateMode enum\n   * @return an address of the corresponding debt token from reserve configuration\n   **/\n  function getDebtTokenAddress(ReserveLogic.ReserveData storage reserve, uint256 interestRateMode)\n    external\n    view\n    returns (address)\n  {\n    require(\n      ReserveLogic.InterestRateMode.STABLE == ReserveLogic.InterestRateMode(interestRateMode) ||\n        ReserveLogic.InterestRateMode.VARIABLE == ReserveLogic.InterestRateMode(interestRateMode),\n      Errors.INVALID_INTEREST_RATE_MODE_SELECTED\n    );\n    return\n      ReserveLogic.InterestRateMode.STABLE == ReserveLogic.InterestRateMode(interestRateMode)\n        ? reserve.stableDebtTokenAddress\n        : reserve.variableDebtTokenAddress;\n  }\n\n  /**\n   * @dev Updates the liquidity cumulative index Ci and variable borrow cumulative index Bvc. Refer to the whitepaper for\n   * a formal specification.\n   * @param reserve the reserve object\n   **/\n  function updateState(ReserveData storage reserve) external {\n    address variableDebtToken = reserve.variableDebtTokenAddress;\n    uint256 previousVariableBorrowIndex = reserve.variableBorrowIndex;\n    uint256 previousLiquidityIndex = reserve.liquidityIndex;\n\n    (uint256 newLiquidityIndex, uint256 newVariableBorrowIndex) = _updateIndexes(\n      reserve,\n      variableDebtToken,\n      previousLiquidityIndex,\n      previousVariableBorrowIndex\n    );\n\n    _mintToTreasury(\n      reserve,\n      variableDebtToken,\n      previousVariableBorrowIndex,\n      newLiquidityIndex,\n      newVariableBorrowIndex\n    );\n  }\n\n  /**\n   * @dev accumulates a predefined amount of asset to the reserve as a fixed, one time income. Used for example to accumulate\n   * the flashloan fee to the reserve, and spread it through the depositors.\n   * @param reserve the reserve object\n   * @param totalLiquidity the total liquidity available in the reserve\n   * @param amount the amount to accomulate\n   **/\n  function cumulateToLiquidityIndex(\n    ReserveData storage reserve,\n    uint256 totalLiquidity,\n    uint256 amount\n  ) external {\n    uint256 amountToLiquidityRatio = amount.wadToRay().rayDiv(totalLiquidity.wadToRay());\n\n    uint256 result = amountToLiquidityRatio.add(WadRayMath.ray());\n\n    result = result.rayMul(reserve.liquidityIndex);\n    require(result < (1 << 128), Errors.LIQUIDITY_INDEX_OVERFLOW);\n\n    reserve.liquidityIndex = uint128(result);\n  }\n\n  /**\n   * @dev initializes a reserve\n   * @param reserve the reserve object\n   * @param aTokenAddress the address of the overlying atoken contract\n   * @param interestRateStrategyAddress the address of the interest rate strategy contract\n   **/\n  function init(\n    ReserveData storage reserve,\n    address aTokenAddress,\n    address stableDebtTokenAddress,\n    address variableDebtTokenAddress,\n    address interestRateStrategyAddress\n  ) external {\n    require(reserve.aTokenAddress == address(0), Errors.RESERVE_ALREADY_INITIALIZED);\n    if (reserve.liquidityIndex == 0) {\n      //if the reserve has not been initialized yet\n      reserve.liquidityIndex = uint128(WadRayMath.ray());\n    }\n\n    if (reserve.variableBorrowIndex == 0) {\n      reserve.variableBorrowIndex = uint128(WadRayMath.ray());\n    }\n\n    reserve.aTokenAddress = aTokenAddress;\n    reserve.stableDebtTokenAddress = stableDebtTokenAddress;\n    reserve.variableDebtTokenAddress = variableDebtTokenAddress;\n    reserve.interestRateStrategyAddress = interestRateStrategyAddress;\n  }\n\n  struct UpdateInterestRatesLocalVars {\n    address stableDebtTokenAddress;\n    uint256 availableLiquidity;\n    uint256 totalStableDebt;\n    uint256 newLiquidityRate;\n    uint256 newStableRate;\n    uint256 newVariableRate;\n    uint256 avgStableRate;\n  }\n\n  /**\n   * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl.\n   * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information.\n   * @param reserve the address of the reserve to be updated\n   * @param liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action\n   * @param liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow)\n   **/\n  function updateInterestRates(\n    ReserveData storage reserve,\n    address reserveAddress,\n    address aTokenAddress,\n    uint256 liquidityAdded,\n    uint256 liquidityTaken\n  ) external {\n    UpdateInterestRatesLocalVars memory vars;\n\n    vars.stableDebtTokenAddress = reserve.stableDebtTokenAddress;\n\n    (vars.totalStableDebt, vars.avgStableRate) = IStableDebtToken(vars.stableDebtTokenAddress)\n      .getTotalSupplyAndAvgRate();\n\n    vars.availableLiquidity = IERC20(reserveAddress).balanceOf(aTokenAddress);\n\n    (\n      vars.newLiquidityRate,\n      vars.newStableRate,\n      vars.newVariableRate\n    ) = IReserveInterestRateStrategy(reserve.interestRateStrategyAddress).calculateInterestRates(\n      reserveAddress,\n      vars.availableLiquidity.add(liquidityAdded).sub(liquidityTaken),\n      vars.totalStableDebt,\n      IERC20(reserve.variableDebtTokenAddress).totalSupply(),\n      vars.avgStableRate,\n      reserve.configuration.getReserveFactor()\n    );\n    require(vars.newLiquidityRate < (1 << 128), 'ReserveLogic: Liquidity rate overflow');\n    require(vars.newStableRate < (1 << 128), 'ReserveLogic: Stable borrow rate overflow');\n    require(vars.newVariableRate < (1 << 128), 'ReserveLogic: Variable borrow rate overflow');\n\n    reserve.currentLiquidityRate = uint128(vars.newLiquidityRate);\n    reserve.currentStableBorrowRate = uint128(vars.newStableRate);\n    reserve.currentVariableBorrowRate = uint128(vars.newVariableRate);\n\n    emit ReserveDataUpdated(\n      reserveAddress,\n      vars.newLiquidityRate,\n      vars.newStableRate,\n      vars.newVariableRate,\n      reserve.liquidityIndex,\n      reserve.variableBorrowIndex\n    );\n  }\n\n  struct MintToTreasuryLocalVars {\n    uint256 currentStableDebt;\n    uint256 principalStableDebt;\n    uint256 previousStableDebt;\n    uint256 currentVariableDebt;\n    uint256 scaledVariableDebt;\n    uint256 previousVariableDebt;\n    uint256 avgStableRate;\n    uint256 cumulatedStableInterest;\n    uint256 totalDebtAccrued;\n    uint256 amountToMint;\n    uint256 reserveFactor;\n    uint40 stableSupplyUpdatedTimestamp;\n  }\n\n  /**\n   * @dev mints part of the repaid interest to the reserve treasury, depending on the reserveFactor for the\n   * specific asset.\n   * @param reserve the reserve reserve to be updated\n   * @param variableDebtToken the debt token address\n   * @param previousVariableBorrowIndex the variable borrow index before the last accumulation of the interest\n   * @param newLiquidityIndex the new liquidity index\n   * @param newVariableBorrowIndex the variable borrow index after the last accumulation of the interest\n   **/\n  function _mintToTreasury(\n    ReserveData storage reserve,\n    address variableDebtToken,\n    uint256 previousVariableBorrowIndex,\n    uint256 newLiquidityIndex,\n    uint256 newVariableBorrowIndex\n  ) internal {\n    MintToTreasuryLocalVars memory vars;\n\n    vars.reserveFactor = reserve.configuration.getReserveFactor();\n\n    if (vars.reserveFactor == 0) {\n      return;\n    }\n\n    //fetching the last scaled total variable debt\n    vars.scaledVariableDebt = IVariableDebtToken(variableDebtToken).scaledTotalSupply();\n\n    //fetching the principal, total stable debt and the avg stable rate\n    (\n      vars.principalStableDebt,\n      vars.currentStableDebt,\n      vars.avgStableRate,\n      vars.stableSupplyUpdatedTimestamp\n    ) = IStableDebtToken(reserve.stableDebtTokenAddress).getSupplyData();\n\n    //calculate the last principal variable debt\n    vars.previousVariableDebt = vars.scaledVariableDebt.rayMul(previousVariableBorrowIndex);\n\n    //calculate the new total supply after accumulation of the index\n    vars.currentVariableDebt = vars.scaledVariableDebt.rayMul(newVariableBorrowIndex);\n\n    //calculate the stable debt until the last timestamp update\n    vars.cumulatedStableInterest = MathUtils.calculateCompoundedInterest(\n      vars.avgStableRate,\n      vars.stableSupplyUpdatedTimestamp\n    );\n\n    vars.previousStableDebt = vars.principalStableDebt.rayMul(vars.cumulatedStableInterest);\n\n    //debt accrued is the sum of the current debt minus the sum of the debt at the last update\n    vars.totalDebtAccrued = vars\n      .currentVariableDebt\n      .add(vars.currentStableDebt)\n      .sub(vars.previousVariableDebt)\n      .sub(vars.previousStableDebt);\n\n    vars.amountToMint = vars.totalDebtAccrued.percentMul(vars.reserveFactor);\n\n    IAToken(reserve.aTokenAddress).mintToTreasury(vars.amountToMint, newLiquidityIndex);\n  }\n\n  /**\n   * @dev updates the reserve indexes and the timestamp of the update\n   * @param reserve the reserve reserve to be updated\n   * @param variableDebtToken the debt token address\n   * @param liquidityIndex the last stored liquidity index\n   * @param variableBorrowIndex the last stored variable borrow index\n   **/\n  function _updateIndexes(\n    ReserveData storage reserve,\n    address variableDebtToken,\n    uint256 liquidityIndex,\n    uint256 variableBorrowIndex\n  ) internal returns (uint256, uint256) {\n    uint40 timestamp = reserve.lastUpdateTimestamp;\n\n    uint256 currentLiquidityRate = reserve.currentLiquidityRate;\n\n    uint256 newLiquidityIndex = liquidityIndex;\n    uint256 newVariableBorrowIndex = variableBorrowIndex;\n\n    //only cumulating if there is any income being produced\n    if (currentLiquidityRate > 0) {\n      uint256 cumulatedLiquidityInterest = MathUtils.calculateLinearInterest(\n        currentLiquidityRate,\n        timestamp\n      );\n      newLiquidityIndex = cumulatedLiquidityInterest.rayMul(liquidityIndex);\n      require(newLiquidityIndex < (1 << 128), Errors.LIQUIDITY_INDEX_OVERFLOW);\n\n      reserve.liquidityIndex = uint128(newLiquidityIndex);\n\n      //as the liquidity rate might come only from stable rate loans, we need to ensure\n      //that there is actual variable debt before accumulating\n      if (IERC20(variableDebtToken).totalSupply() > 0) {\n        uint256 cumulatedVariableBorrowInterest = MathUtils.calculateCompoundedInterest(\n          reserve.currentVariableBorrowRate,\n          timestamp\n        );\n        newVariableBorrowIndex = cumulatedVariableBorrowInterest.rayMul(variableBorrowIndex);\n        require(newVariableBorrowIndex < (1 << 128), Errors.VARIABLE_BORROW_INDEX_OVERFLOW);\n        reserve.variableBorrowIndex = uint128(newVariableBorrowIndex);\n      }\n    }\n\n    //solium-disable-next-line\n    reserve.lastUpdateTimestamp = uint40(block.timestamp);\n    return (newLiquidityIndex, newVariableBorrowIndex);\n  }\n}"
    }
  ]
}