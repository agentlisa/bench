{
  "Title": "[M-05] cBridge integration fails to send native tokens",
  "Content": "_Submitted by hickuphh3, also found by hyh, rayn, shw, WatchPug, and wuwe1_\n\n[CBridgeFacet.sol#L150-L156](https://github.com/code-423n4/2022-03-lifinance/blob/main/src/Facets/CBridgeFacet.sol#L150-L156)<br>\n\nThe external `sendNative()` call fails to include sending the native tokens together with it.\n\n### Proof of Concept\n\nAdd the following test case to the [`CBridgeFacet` test file](https://github.com/code-423n4/2022-03-lifinance/blob/main/test/facets/CBridgeFacet.test.ts).\n\n```jsx\n// TODO: update bridge address to 0x5427FEFA711Eff984124bFBB1AB6fbf5E3DA1820\nit.only('reverts because ETH not sent to bridge', async () => {\n  CBridgeData.token = constants.AddressZero\n  CBridgeData.amount = constants.One\n  await expect(lifi.connect(alice).startBridgeTokensViaCBridge(lifiData, CBridgeData, {\n    value: constants.One,\n    gasLimit: 500000\n  })).to.be.revertedWith('Amount mismatch');\n})\n```\n\n### Recommended Mitigation Steps\n\n```jsx\nICBridge(bridge).sendNative{ value: _cBridgeData.amount }(\n  _cBridgeData.receiver,\n  _cBridgeData.amount,\n  _cBridgeData.dstChainId,\n  _cBridgeData.nonce,\n  _cBridgeData.maxSlippage\n);\n```\n\nIn addition, add the `payable` keyword to the [CBridge interface](https://github.com/code-423n4/2022-03-lifinance/blob/main/src/Interfaces/ICBridge.sol#L14-L20).\n\n**[H3xept (Li.Fi) resolved and commented](https://github.com/code-423n4/2022-03-lifinance-findings/issues/35#issuecomment-1094907923):**\n > Fixed in lifinance/lifi-contracts@b684627b57c4891bee13fcfcfcf2595965843cc6\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-03-lifinance-findings/issues/35#issuecomment-1100700833):**\n > Valid POC. Sponsor confirmed with fix.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-03-lifinance",
  "Code": [
    {
      "filename": "src/Facets/CBridgeFacet.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ICBridge } from \"../Interfaces/ICBridge.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport \"./Swapper.sol\";\n\n/**\n * @title CBridge Facet\n * @author Li.Finance (https://li.finance)\n * @notice Provides functionality for bridging through CBridge\n */\ncontract CBridgeFacet is ILiFi, Swapper {\n    /* ========== Storage ========== */\n\n    bytes32 internal constant NAMESPACE = keccak256(\"com.lifi.facets.cbridge2\");\n    struct Storage {\n        address cBridge;\n        uint64 cBridgeChainId;\n    }\n\n    /* ========== Types ========== */\n\n    struct CBridgeData {\n        address receiver;\n        address token;\n        uint256 amount;\n        uint64 dstChainId;\n        uint64 nonce;\n        uint32 maxSlippage;\n    }\n\n    /* ========== Init ========== */\n\n    /**\n     * @notice Initializes local variables for the CBridge facet\n     * @param _cBridge address of the canonical CBridge router contract\n     * @param _chainId chainId of this deployed contract\n     */\n    function initCbridge(address _cBridge, uint64 _chainId) external {\n        Storage storage s = getStorage();\n        LibDiamond.enforceIsContractOwner();\n        s.cBridge = _cBridge;\n        s.cBridgeChainId = _chainId;\n        emit Inited(s.cBridge, s.cBridgeChainId);\n    }\n\n    /* ========== Public Bridge Functions ========== */\n\n    /**\n     * @notice Bridges tokens via CBridge\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _cBridgeData data specific to CBridge\n     */\n    function startBridgeTokensViaCBridge(LiFiData memory _lifiData, CBridgeData calldata _cBridgeData) public payable {\n        if (_cBridgeData.token != address(0)) {\n            uint256 _fromTokenBalance = LibAsset.getOwnBalance(_cBridgeData.token);\n\n            LibAsset.transferFromERC20(_cBridgeData.token, msg.sender, address(this), _cBridgeData.amount);\n\n            require(\n                LibAsset.getOwnBalance(_cBridgeData.token) - _fromTokenBalance == _cBridgeData.amount,\n                \"ERR_INVALID_AMOUNT\"\n            );\n        } else {\n            require(msg.value >= _cBridgeData.amount, \"ERR_INVALID_AMOUNT\");\n        }\n\n        _startBridge(_cBridgeData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice Performs a swap before bridging via CBridge\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _swapData an array of swap related data for performing swaps before bridging\n     * @param _cBridgeData data specific to CBridge\n     */\n    function swapAndStartBridgeTokensViaCBridge(\n        LiFiData memory _lifiData,\n        LibSwap.SwapData[] calldata _swapData,\n        CBridgeData memory _cBridgeData\n    ) public payable {\n        if (_cBridgeData.token != address(0)) {\n            uint256 _fromTokenBalance = LibAsset.getOwnBalance(_cBridgeData.token);\n\n            // Swap\n            _executeSwaps(_lifiData, _swapData);\n\n            uint256 _postSwapBalance = LibAsset.getOwnBalance(_cBridgeData.token) - _fromTokenBalance;\n\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n            _cBridgeData.amount = _postSwapBalance;\n        } else {\n            uint256 _fromBalance = address(this).balance;\n\n            // Swap\n            _executeSwaps(_lifiData, _swapData);\n\n            uint256 _postSwapBalance = address(this).balance - _fromBalance;\n\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n            _cBridgeData.amount = _postSwapBalance;\n        }\n\n        _startBridge(_cBridgeData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /* ========== Internal Functions ========== */\n\n    /*\n     * @dev Conatains the business logic for the bridge via CBridge\n     * @param _cBridgeData data specific to CBridge\n     */\n    function _startBridge(CBridgeData memory _cBridgeData) internal {\n        Storage storage s = getStorage();\n        address bridge = _bridge();\n\n        // Do CBridge stuff\n        require(s.cBridgeChainId != _cBridgeData.dstChainId, \"Cannot bridge to the same network.\");\n\n        if (LibAsset.isNativeAsset(_cBridgeData.token)) {\n            ICBridge(bridge).sendNative(\n                _cBridgeData.receiver,\n                _cBridgeData.amount,\n                _cBridgeData.dstChainId,\n                _cBridgeData.nonce,\n                _cBridgeData.maxSlippage\n            );\n        } else {\n            // Give CBridge approval to bridge tokens\n            LibAsset.approveERC20(IERC20(_cBridgeData.token), bridge, _cBridgeData.amount);\n            // solhint-disable check-send-result\n            ICBridge(bridge).send(\n                _cBridgeData.receiver,\n                _cBridgeData.token,\n                _cBridgeData.amount,\n                _cBridgeData.dstChainId,\n                _cBridgeData.nonce,\n                _cBridgeData.maxSlippage\n            );\n        }\n    }\n\n    /*\n     * @dev Public view function for the CBridge router address\n     * @returns the router address\n     */\n    function _bridge() internal view returns (address) {\n        Storage storage s = getStorage();\n        return s.cBridge;\n    }\n\n    /**\n     * @dev fetch local storage\n     */\n    function getStorage() internal pure returns (Storage storage s) {\n        bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }\n}"
    },
    {
      "filename": "src/Interfaces/ICBridge.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\ninterface ICBridge {\n    function send(\n        address _receiver,\n        address _token,\n        uint256 _amount,\n        uint64 _dstChinId,\n        uint64 _nonce,\n        uint32 _maxSlippage\n    ) external;\n\n    function sendNative(\n        address _receiver,\n        uint256 _amount,\n        uint64 _dstChinId,\n        uint64 _nonce,\n        uint32 _maxSlippage\n    ) external;\n\n    function relay(\n        bytes calldata _relayRequest,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external;\n}"
    }
  ]
}