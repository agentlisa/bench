{
  "Title": "[M-11] Griefing Attack By Extending The Reward Duration",
  "Content": "_Submitted by xiaoming90_\n\nThe `Gauge.notifyRewardAmount` notifies the contract of a newly received rewards. This updates the local accounting and streams the reward over a preset period (Five days).\n\nIt was observed that this function is callable by anyone regardless of whether the previous reward period has already expired or not. Thus, it would be possible to exploit the system by repeatedly calling it with dust reward amount to extend an active reward period, and thus dragging out the duration over which the rewards are released.\n\nSince Velodrome is to be deployed on Layer 2 blockchain where the gas fee tends to be cheap, the effort required to carry out this attack would be minimal.\n\nThis issue was also highlighted in Curve documentation under the [`ChildChainStreamer.notify_reward_amount(token: address):`](https://curve.readthedocs.io/dao-gauges-sidechain.html) section.\n\n[Gauge.sol#L590](https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Gauge.sol#L590)<br>\n\n```solidity\nfunction notifyRewardAmount(address token, uint amount) external lock {\n    require(token != stake);\n    require(amount > 0);\n    if (!isReward[token]) {\n        require(rewards.length < MAX_REWARD_TOKENS, \"too many rewards tokens\");\n    }\n    // rewards accrue only during the bribe period\n    uint bribeStart = block.timestamp - (block.timestamp % (7 days)) + BRIBE_LAG;\n    uint adjustedTstamp = block.timestamp < bribeStart ? bribeStart : bribeStart + 7 days;\n    if (rewardRate[token] == 0) _writeRewardPerTokenCheckpoint(token, 0, adjustedTstamp);\n    (rewardPerTokenStored[token], lastUpdateTime[token]) = _updateRewardPerToken(token);\n    _claimFees();\n\n    if (block.timestamp >= periodFinish[token]) {\n        _safeTransferFrom(token, msg.sender, address(this), amount);\n        rewardRate[token] = amount / DURATION;\n    } else {\n        uint _remaining = periodFinish[token] - block.timestamp;\n        uint _left = _remaining * rewardRate[token];\n        require(amount > _left);\n        _safeTransferFrom(token, msg.sender, address(this), amount);\n        rewardRate[token] = (amount + _left) / DURATION;\n    }\n    require(rewardRate[token] > 0);\n    uint balance = IERC20(token).balanceOf(address(this));\n    require(rewardRate[token] <= balance / DURATION, \"Provided reward too high\");\n    periodFinish[token] = adjustedTstamp + DURATION;\n    if (!isReward[token]) {\n        isReward[token] = true;\n        rewards.push(token);\n        IBribe(bribe).addRewardToken(token);\n    }\n\n    emit NotifyReward(msg.sender, token, amount);\n}\n```\n\n### Recommended Mitigation Steps\n\nConsider implementing validation to ensure that this function is callable by anyone only if the previous reward period has already expired. Otherwise, when there is an active reward period, it may only be called by the designated reward distributor account.\n\nFor sample implementation, see [here](https://github.com/curvefi/curve-dao-contracts/blob/3bee979b7b6293c9e7654ee7dfbf5cc9ff40ca58/contracts/streamers/ChildChainStreamer.vy#L166).\n\n**[pooltypes (Velodrome) acknowledged](https://github.com/code-423n4/2022-05-velodrome-findings/issues/172)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-05-velodrome-findings/issues/172#issuecomment-1170461137):**\n > The warden has shown how a reward period could be extended, causing a dilution of reward rate. Because this impact can cause a loss of Yield, I believe Medium Severity to be appropriate.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-05-velodrome",
  "Code": [
    {
      "filename": "contracts/contracts/Gauge.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport './libraries/Math.sol';\nimport './interfaces/IBribe.sol';\nimport './interfaces/IGaugeFactory.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IPair.sol';\nimport './interfaces/IVoter.sol';\nimport './interfaces/IVotingEscrow.sol';\n\n// Gauges are used to incentivize pools, they emit reward tokens every 7 days for staked LP tokens\ncontract Gauge {\n\n    address public immutable stake; // the LP token that needs to be staked for rewards\n    address public immutable _ve; // the ve token used for gauges\n    address public immutable bribe;\n    address public immutable voter;\n    address immutable factory;\n    bool public isForPair;\n\n    uint public derivedSupply;\n    mapping(address => uint) public derivedBalances;\n\n    uint internal constant DURATION = 5 days; // rewards are released over the voting period\n    uint internal constant BRIBE_LAG = 1 days;\n    uint internal constant MAX_REWARD_TOKENS = 16;\n\n    enum VotingStage\n    {\n        BribesPhase,\n        VotesPhase,\n        RewardsPhase\n    }\n\n    uint internal constant PRECISION = 10 ** 18;\n\n    // default snx staking contract implementation\n    mapping(address => uint) public rewardRate;\n    mapping(address => uint) public periodFinish;\n    mapping(address => uint) public lastUpdateTime;\n    mapping(address => uint) public rewardPerTokenStored;\n\n    mapping(address => mapping(address => uint)) public lastEarn;\n    mapping(address => mapping(address => uint)) public userRewardPerTokenStored;\n\n    mapping(address => uint) public tokenIds;\n\n    uint public totalSupply;\n    mapping(address => uint) public balanceOf;\n\n    address[] public rewards;\n    mapping(address => bool) public isReward;\n\n    /// @notice A checkpoint for marking balance\n    struct Checkpoint {\n        uint timestamp;\n        uint balanceOf;\n        bool voted;\n    }\n\n    /// @notice A checkpoint for marking reward rate\n    struct RewardPerTokenCheckpoint {\n        uint timestamp;\n        uint rewardPerToken;\n    }\n\n    /// @notice A checkpoint for marking supply\n    struct SupplyCheckpoint {\n        uint timestamp;\n        uint supply;\n    }\n\n    /// @notice A record of balance checkpoints for each account, by index\n    mapping (address => mapping (uint => Checkpoint)) public checkpoints;\n    /// @notice The number of checkpoints for each account\n    mapping (address => uint) public numCheckpoints;\n    /// @notice A record of balance checkpoints for each token, by index\n    mapping (uint => SupplyCheckpoint) public supplyCheckpoints;\n    /// @notice The number of checkpoints\n    uint public supplyNumCheckpoints;\n    /// @notice A record of balance checkpoints for each token, by index\n    mapping (address => mapping (uint => RewardPerTokenCheckpoint)) public rewardPerTokenCheckpoints;\n    /// @notice The number of checkpoints for each token\n    mapping (address => uint) public rewardPerTokenNumCheckpoints;\n\n    uint public fees0;\n    uint public fees1;\n\n    event Deposit(address indexed from, uint tokenId, uint amount);\n    event Withdraw(address indexed from, uint tokenId, uint amount);\n    event NotifyReward(address indexed from, address indexed reward, uint amount);\n    event ClaimFees(address indexed from, uint claimed0, uint claimed1);\n    event ClaimRewards(address indexed from, address indexed reward, uint amount);\n\n    constructor(address _stake, address _bribe, address  __ve, address _voter, bool _isForPair) {\n        stake = _stake;\n        bribe = _bribe;\n        _ve = __ve;\n        voter = _voter;\n\n        factory = msg.sender;\n\n        IBribe(bribe).setGauge(address(this));\n        address _token = IVotingEscrow(_ve).token();\n        IBribe(bribe).addRewardToken(_token);\n        isReward[_token] = true;\n        rewards.push(_token);\n\n        isForPair = _isForPair;\n        if (isForPair) {\n            (address _token0, address _token1) = IPair(stake).tokens();\n            IBribe(bribe).addRewardToken(_token0);\n            isReward[_token0] = true;\n            rewards.push(_token0);\n            IBribe(bribe).addRewardToken(_token1);\n            isReward[_token1] = true;\n            rewards.push(_token1);\n        }\n    }\n\n    // simple re-entrancy check\n    uint internal _unlocked = 1;\n    modifier lock() {\n        require(_unlocked == 1);\n        _unlocked = 2;\n        _;\n        _unlocked = 1;\n    }\n\n    function claimFees() external lock returns (uint claimed0, uint claimed1) {\n        return _claimFees();\n    }\n\n    function _claimFees() internal returns (uint claimed0, uint claimed1) {\n        if (!isForPair) {\n            return (0, 0);\n        }\n        (claimed0, claimed1) = IPair(stake).claimFees();\n        if (claimed0 > 0 || claimed1 > 0) {\n            uint _fees0 = fees0 + claimed0;\n            uint _fees1 = fees1 + claimed1;\n            (address _token0, address _token1) = IPair(stake).tokens();\n            if (_fees0 / DURATION > 0) {\n                fees0 = 0;\n                _safeApprove(_token0, bribe, _fees0);\n                IBribe(bribe).notifyRewardAmount(_token0, _fees0);\n            } else {\n                fees0 = _fees0;\n            }\n            if (_fees1 / DURATION > 0) {\n                fees1 = 0;\n                _safeApprove(_token1, bribe, _fees1);\n                IBribe(bribe).notifyRewardAmount(_token1, _fees1);\n            } else {\n                fees1 = _fees1;\n            }\n\n            emit ClaimFees(msg.sender, claimed0, claimed1);\n        }\n    }\n\n    function getVotingStage(uint timestamp) public pure returns (VotingStage) {\n        uint modTime = timestamp % (7 days);\n        if (modTime < BRIBE_LAG) {\n            return VotingStage.BribesPhase;\n        } else if (modTime > (BRIBE_LAG + DURATION)) {\n            return VotingStage.RewardsPhase;\n        }\n        return VotingStage.VotesPhase;\n    }\n\n    function deliverBribes() external lock {\n        require(msg.sender == voter);\n        IBribe sb = IBribe(bribe);\n        uint bribeStart = block.timestamp - (block.timestamp % (7 days)) + BRIBE_LAG;\n        uint numRewards = sb.rewardsListLength();\n\n        for (uint i = 0; i < numRewards; i++) {\n            address token = sb.rewards(i);\n            uint epochRewards = sb.deliverReward(token, bribeStart);\n            if (epochRewards > 0) {\n                _notifyBribeAmount(token, epochRewards, bribeStart);\n            }\n        }\n    }\n\n    function setVoteStatus(address account, bool voted) external {\n        require(msg.sender == voter);\n        uint nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            checkpoints[account][0] = Checkpoint(block.timestamp, 0, voted);\n            numCheckpoints[account] = 1;\n        } else {\n            checkpoints[account][nCheckpoints - 1].voted = voted;\n        }\n    }\n\n    /**\n    * @notice Determine the prior balance for an account as of a block number\n    * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n    * @param account The address of the account to check\n    * @param timestamp The timestamp to get the balance at\n    * @return The balance the account had as of the given block\n    */\n    function getPriorBalanceIndex(address account, uint timestamp) public view returns (uint) {\n        uint nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].timestamp <= timestamp) {\n            return (nCheckpoints - 1);\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].timestamp > timestamp) {\n            return 0;\n        }\n\n        uint lower = 0;\n        uint upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.timestamp == timestamp) {\n                return center;\n            } else if (cp.timestamp < timestamp) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return lower;\n    }\n\n    function getPriorSupplyIndex(uint timestamp) public view returns (uint) {\n        uint nCheckpoints = supplyNumCheckpoints;\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (supplyCheckpoints[nCheckpoints - 1].timestamp <= timestamp) {\n            return (nCheckpoints - 1);\n        }\n\n        // Next check implicit zero balance\n        if (supplyCheckpoints[0].timestamp > timestamp) {\n            return 0;\n        }\n\n        uint lower = 0;\n        uint upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            SupplyCheckpoint memory cp = supplyCheckpoints[center];\n            if (cp.timestamp == timestamp) {\n                return center;\n            } else if (cp.timestamp < timestamp) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return lower;\n    }\n\n    function getPriorRewardPerToken(address token, uint timestamp) public view returns (uint, uint) {\n        uint nCheckpoints = rewardPerTokenNumCheckpoints[token];\n        if (nCheckpoints == 0) {\n            return (0,0);\n        }\n\n        // First check most recent balance\n        if (rewardPerTokenCheckpoints[token][nCheckpoints - 1].timestamp <= timestamp) {\n            return (rewardPerTokenCheckpoints[token][nCheckpoints - 1].rewardPerToken, rewardPerTokenCheckpoints[token][nCheckpoints - 1].timestamp);\n        }\n\n        // Next check implicit zero balance\n        if (rewardPerTokenCheckpoints[token][0].timestamp > timestamp) {\n            return (0,0);\n        }\n\n        uint lower = 0;\n        uint upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            RewardPerTokenCheckpoint memory cp = rewardPerTokenCheckpoints[token][center];\n            if (cp.timestamp == timestamp) {\n                return (cp.rewardPerToken, cp.timestamp);\n            } else if (cp.timestamp < timestamp) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return (rewardPerTokenCheckpoints[token][lower].rewardPerToken, rewardPerTokenCheckpoints[token][lower].timestamp);\n    }\n\n    function _writeCheckpoint(address account, uint balance) internal {\n        uint _timestamp = block.timestamp;\n        uint _nCheckPoints = numCheckpoints[account];\n\n        if (_nCheckPoints > 0 && checkpoints[account][_nCheckPoints - 1].timestamp == _timestamp) {\n            checkpoints[account][_nCheckPoints - 1].balanceOf = balance;\n        } else {\n            bool prevVoteStatus = (_nCheckPoints > 0) ? checkpoints[account][_nCheckPoints].voted : false;\n            checkpoints[account][_nCheckPoints] = Checkpoint(_timestamp, balance, prevVoteStatus);\n            numCheckpoints[account] = _nCheckPoints + 1;\n        }\n    }\n\n    function _writeRewardPerTokenCheckpoint(address token, uint reward, uint timestamp) internal {\n        uint _nCheckPoints = rewardPerTokenNumCheckpoints[token];\n\n        if (_nCheckPoints > 0 && rewardPerTokenCheckpoints[token][_nCheckPoints - 1].timestamp == timestamp) {\n            rewardPerTokenCheckpoints[token][_nCheckPoints - 1].rewardPerToken = reward;\n        } else {\n            rewardPerTokenCheckpoints[token][_nCheckPoints] = RewardPerTokenCheckpoint(timestamp, reward);\n            rewardPerTokenNumCheckpoints[token] = _nCheckPoints + 1;\n        }\n    }\n\n    function _writeSupplyCheckpoint() internal {\n        uint _nCheckPoints = supplyNumCheckpoints;\n        uint _timestamp = block.timestamp;\n\n        if (_nCheckPoints > 0 && supplyCheckpoints[_nCheckPoints - 1].timestamp == _timestamp) {\n            supplyCheckpoints[_nCheckPoints - 1].supply = derivedSupply;\n        } else {\n            supplyCheckpoints[_nCheckPoints] = SupplyCheckpoint(_timestamp, derivedSupply);\n            supplyNumCheckpoints = _nCheckPoints + 1;\n        }\n    }\n\n    function rewardsListLength() external view returns (uint) {\n        return rewards.length;\n    }\n\n    // returns the last time the reward was modified or periodFinish if the reward has ended\n    function lastTimeRewardApplicable(address token) public view returns (uint) {\n        return Math.min(block.timestamp, periodFinish[token]);\n    }\n\n    function getReward(address account, address[] memory tokens) external lock {\n        require(msg.sender == account || msg.sender == voter);\n        _unlocked = 1;\n        IVoter(voter).distribute(address(this));\n        _unlocked = 2;\n\n        for (uint i = 0; i < tokens.length; i++) {\n            (rewardPerTokenStored[tokens[i]], lastUpdateTime[tokens[i]]) = _updateRewardPerToken(tokens[i]);\n\n            uint _reward = earned(tokens[i], account);\n            lastEarn[tokens[i]][account] = block.timestamp;\n            userRewardPerTokenStored[tokens[i]][account] = rewardPerTokenStored[tokens[i]];\n            if (_reward > 0) _safeTransfer(tokens[i], account, _reward);\n\n            emit ClaimRewards(msg.sender, tokens[i], _reward);\n        }\n\n        uint _derivedBalance = derivedBalances[account];\n        derivedSupply -= _derivedBalance;\n        _derivedBalance = derivedBalance(account);\n        derivedBalances[account] = _derivedBalance;\n        derivedSupply += _derivedBalance;\n\n        _writeCheckpoint(account, derivedBalances[account]);\n        _writeSupplyCheckpoint();\n    }\n\n\n    function rewardPerToken(address token) public view returns (uint) {\n        if (derivedSupply == 0) {\n            return rewardPerTokenStored[token];\n        }\n        return rewardPerTokenStored[token] + ((lastTimeRewardApplicable(token) - Math.min(lastUpdateTime[token], periodFinish[token])) * rewardRate[token] * PRECISION / derivedSupply);\n    }\n\n    function derivedBalance(address account) public view returns (uint) {\n        return balanceOf[account];\n    }\n\n    function batchRewardPerToken(address token, uint maxRuns) external {\n        (rewardPerTokenStored[token], lastUpdateTime[token])  = _batchRewardPerToken(token, maxRuns);\n    }\n\n    function _batchRewardPerToken(address token, uint maxRuns) internal returns (uint, uint) {\n        uint _startTimestamp = lastUpdateTime[token];\n        uint reward = rewardPerTokenStored[token];\n\n        if (supplyNumCheckpoints == 0) {\n            return (reward, _startTimestamp);\n        }\n\n        if (rewardRate[token] == 0) {\n            return (reward, block.timestamp);\n        }\n\n        uint _startIndex = getPriorSupplyIndex(_startTimestamp);\n        uint _endIndex = Math.min(supplyNumCheckpoints-1, maxRuns);\n\n        for (uint i = _startIndex; i < _endIndex; i++) {\n            SupplyCheckpoint memory sp0 = supplyCheckpoints[i];\n            if (sp0.supply > 0) {\n                SupplyCheckpoint memory sp1 = supplyCheckpoints[i+1];\n                (uint _reward, uint _endTime) = _calcRewardPerToken(token, sp1.timestamp, sp0.timestamp, sp0.supply, _startTimestamp);\n                reward += _reward;\n                _writeRewardPerTokenCheckpoint(token, reward, _endTime);\n                _startTimestamp = _endTime;\n            }\n        }\n\n        return (reward, _startTimestamp);\n    }\n\n    function _calcRewardPerToken(address token, uint timestamp1, uint timestamp0, uint supply, uint startTimestamp) internal view returns (uint, uint) {\n        uint endTime = Math.max(timestamp1, startTimestamp);\n        return (((Math.min(endTime, periodFinish[token]) - Math.min(Math.max(timestamp0, startTimestamp), periodFinish[token])) * rewardRate[token] * PRECISION / supply), endTime);\n    }\n\n    function _updateRewardForAllTokens() internal {\n        uint length = rewards.length;\n        for (uint i; i < length; i++) {\n            address token = rewards[i];\n            (rewardPerTokenStored[token], lastUpdateTime[token]) = _updateRewardPerToken(token);\n        }\n    }\n\n    function _updateRewardPerToken(address token) internal returns (uint, uint) {\n        uint _startTimestamp = lastUpdateTime[token];\n        uint reward = rewardPerTokenStored[token];\n\n        if (supplyNumCheckpoints == 0) {\n            return (reward, _startTimestamp);\n        }\n\n        if (rewardRate[token] == 0) {\n            return (reward, block.timestamp);\n        }\n\n        uint _startIndex = getPriorSupplyIndex(_startTimestamp);\n        uint _endIndex = supplyNumCheckpoints-1;\n\n        if (_endIndex > 0) {\n            for (uint i = _startIndex; i < _endIndex; i++) {\n                SupplyCheckpoint memory sp0 = supplyCheckpoints[i];\n                if (sp0.supply > 0) {\n                    SupplyCheckpoint memory sp1 = supplyCheckpoints[i+1];\n                    (uint _reward, uint _endTime) = _calcRewardPerToken(token, sp1.timestamp, sp0.timestamp, sp0.supply, _startTimestamp);\n                    reward += _reward;\n                    _writeRewardPerTokenCheckpoint(token, reward, _endTime);\n                    _startTimestamp = _endTime;\n                }\n            }\n        }\n\n        SupplyCheckpoint memory sp = supplyCheckpoints[_endIndex];\n        if (sp.supply > 0) {\n            (uint _reward,) = _calcRewardPerToken(token, lastTimeRewardApplicable(token), Math.max(sp.timestamp, _startTimestamp), sp.supply, _startTimestamp);\n            reward += _reward;\n            _writeRewardPerTokenCheckpoint(token, reward, block.timestamp);\n            _startTimestamp = block.timestamp;\n        }\n\n        return (reward, _startTimestamp);\n    }\n\n    // earned is an estimation, it won't be exact till the supply > rewardPerToken calculations have run\n    function earned(address token, address account) public view returns (uint) {\n        uint _startTimestamp = Math.max(lastEarn[token][account], rewardPerTokenCheckpoints[token][0].timestamp);\n        if (numCheckpoints[account] == 0) {\n            return 0;\n        }\n\n        uint _startIndex = getPriorBalanceIndex(account, _startTimestamp);\n        uint _endIndex = numCheckpoints[account]-1;\n\n        uint reward = 0;\n\n        if (_endIndex > 0) {\n            for (uint i = _startIndex; i < _endIndex; i++) {\n                Checkpoint memory cp0 = checkpoints[account][i];\n                Checkpoint memory cp1 = checkpoints[account][i+1];\n                (uint _rewardPerTokenStored0,) = getPriorRewardPerToken(token, cp0.timestamp);\n                (uint _rewardPerTokenStored1,) = getPriorRewardPerToken(token, cp1.timestamp);\n                if (cp0.voted) {\n                    reward += cp0.balanceOf * (_rewardPerTokenStored1 - _rewardPerTokenStored0) / PRECISION;\n                }\n            }\n        }\n\n        Checkpoint memory cp = checkpoints[account][_endIndex];\n        uint lastCpWeeksVoteEnd = cp.timestamp - (cp.timestamp % (7 days)) + BRIBE_LAG + DURATION;\n        if (block.timestamp > lastCpWeeksVoteEnd) {\n            (uint _rewardPerTokenStored,) = getPriorRewardPerToken(token, cp.timestamp);\n            if (cp.voted) {\n                reward += cp.balanceOf * (rewardPerToken(token) - Math.max(_rewardPerTokenStored, userRewardPerTokenStored[token][account])) / PRECISION;\n            }\n        }\n\n        return reward;\n    }\n\n    function depositAll(uint tokenId) external {\n        deposit(IERC20(stake).balanceOf(msg.sender), tokenId);\n    }\n\n    function deposit(uint amount, uint tokenId) public lock {\n        require(amount > 0);\n\n        _updateRewardForAllTokens();\n\n        _safeTransferFrom(stake, msg.sender, address(this), amount);\n        totalSupply += amount;\n        balanceOf[msg.sender] += amount;\n\n        if (tokenId > 0) {\n            require(IVotingEscrow(_ve).ownerOf(tokenId) == msg.sender);\n            if (tokenIds[msg.sender] == 0) {\n                tokenIds[msg.sender] = tokenId;\n                IVoter(voter).attachTokenToGauge(tokenId, msg.sender);\n            }\n            require(tokenIds[msg.sender] == tokenId);\n        } else {\n            tokenId = tokenIds[msg.sender];\n        }\n\n        uint _derivedBalance = derivedBalances[msg.sender];\n        derivedSupply -= _derivedBalance;\n        _derivedBalance = derivedBalance(msg.sender);\n        derivedBalances[msg.sender] = _derivedBalance;\n        derivedSupply += _derivedBalance;\n\n        _writeCheckpoint(msg.sender, _derivedBalance);\n        _writeSupplyCheckpoint();\n\n        IVoter(voter).emitDeposit(tokenId, msg.sender, amount);\n        emit Deposit(msg.sender, tokenId, amount);\n    }\n\n    function withdrawAll() external {\n        withdraw(balanceOf[msg.sender]);\n    }\n\n    function withdraw(uint amount) public {\n        _updateRewardForAllTokens();\n\n        uint tokenId = 0;\n        if (amount == balanceOf[msg.sender]) {\n            tokenId = tokenIds[msg.sender];\n        }\n        withdrawToken(amount, tokenId);\n    }\n\n    function withdrawToken(uint amount, uint tokenId) public lock {\n        totalSupply -= amount;\n        balanceOf[msg.sender] -= amount;\n        _safeTransfer(stake, msg.sender, amount);\n\n        if (tokenId > 0) {\n            require(tokenId == tokenIds[msg.sender]);\n            tokenIds[msg.sender] = 0;\n            IVoter(voter).detachTokenFromGauge(tokenId, msg.sender);\n        } else {\n            tokenId = tokenIds[msg.sender];\n        }\n\n        uint _derivedBalance = derivedBalances[msg.sender];\n        derivedSupply -= _derivedBalance;\n        _derivedBalance = derivedBalance(msg.sender);\n        derivedBalances[msg.sender] = _derivedBalance;\n        derivedSupply += _derivedBalance;\n\n        _writeCheckpoint(msg.sender, derivedBalances[msg.sender]);\n        _writeSupplyCheckpoint();\n\n        IVoter(voter).emitWithdraw(tokenId, msg.sender, amount);\n        emit Withdraw(msg.sender, tokenId, amount);\n    }\n\n    function left(address token) external view returns (uint) {\n        if (block.timestamp >= periodFinish[token]) return 0;\n        uint _remaining = periodFinish[token] - block.timestamp;\n        return _remaining * rewardRate[token];\n    }\n\n    function notifyRewardAmount(address token, uint amount) external lock {\n        require(token != stake);\n        require(amount > 0);\n        if (!isReward[token]) {\n            require(rewards.length < MAX_REWARD_TOKENS, \"too many rewards tokens\");\n        }\n        // rewards accrue only during the bribe period\n        uint bribeStart = block.timestamp - (block.timestamp % (7 days)) + BRIBE_LAG;\n        uint adjustedTstamp = block.timestamp < bribeStart ? bribeStart : bribeStart + 7 days;\n        if (rewardRate[token] == 0) _writeRewardPerTokenCheckpoint(token, 0, adjustedTstamp);\n        (rewardPerTokenStored[token], lastUpdateTime[token]) = _updateRewardPerToken(token);\n        _claimFees();\n\n        if (block.timestamp >= periodFinish[token]) {\n            _safeTransferFrom(token, msg.sender, address(this), amount);\n            rewardRate[token] = amount / DURATION;\n        } else {\n            uint _remaining = periodFinish[token] - block.timestamp;\n            uint _left = _remaining * rewardRate[token];\n            require(amount > _left);\n            _safeTransferFrom(token, msg.sender, address(this), amount);\n            rewardRate[token] = (amount + _left) / DURATION;\n        }\n        require(rewardRate[token] > 0);\n        uint balance = IERC20(token).balanceOf(address(this));\n        require(rewardRate[token] <= balance / DURATION, \"Provided reward too high\");\n        periodFinish[token] = adjustedTstamp + DURATION;\n        if (!isReward[token]) {\n            isReward[token] = true;\n            rewards.push(token);\n            IBribe(bribe).addRewardToken(token);\n        }\n\n        emit NotifyReward(msg.sender, token, amount);\n    }\n\n    function swapOutRewardToken(uint i, address oldToken, address newToken) external {\n        require(msg.sender == IGaugeFactory(factory).team(), 'only team');\n        require(rewards[i] == oldToken);\n        isReward[oldToken] = false;\n        isReward[newToken] = true;\n        rewards[i] = newToken;\n    }\n\n    function swapOutBribeRewardToken(uint i, address oldToken, address newToken) external {\n        require(msg.sender == IGaugeFactory(factory).team(), 'only team');\n        IBribe(bribe).swapOutRewardToken(i, oldToken, newToken);\n    }\n\n    function addBribeRewardToken(address token) external {\n        require(msg.sender == bribe);\n        if (!isReward[token]) {\n            require(rewards.length < MAX_REWARD_TOKENS, \"too many rewards tokens\");\n            isReward[token] = true;\n            rewards.push(token);\n        }\n    }\n\n    function _notifyBribeAmount(address token, uint amount, uint epochStart) internal {\n        if (block.timestamp >= periodFinish[token]) {\n            rewardRate[token] = amount / DURATION;\n        } else {\n            uint _remaining = periodFinish[token] - block.timestamp;\n            uint _left = _remaining * rewardRate[token];\n            require(amount > _left);\n            rewardRate[token] = (amount + _left) / DURATION;\n        }\n\n        lastUpdateTime[token] = epochStart;\n        periodFinish[token] = epochStart + DURATION;\n\n        emit NotifyReward(msg.sender, token, amount);\n    }\n\n    function _safeTransfer(address token, address to, uint256 value) internal {\n        require(token.code.length > 0);\n        (bool success, bytes memory data) =\n        token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n\n    function _safeTransferFrom(address token, address from, address to, uint256 value) internal {\n        require(token.code.length > 0);\n        (bool success, bytes memory data) =\n        token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n\n    function _safeApprove(address token, address spender, uint256 value) internal {\n        require(token.code.length > 0);\n        (bool success, bytes memory data) =\n        token.call(abi.encodeWithSelector(IERC20.approve.selector, spender, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n}"
    },
    {
      "filename": "contracts/streamers/ChildChainStreamer.vy",
      "content": "# @version 0.2.12\n\"\"\"\n@title Child-Chain Streamer\n@author Curve.Fi\n@license MIT\n@notice Evenly streams one or more reward tokens to a single recipient\n\"\"\"\n\nfrom vyper.interfaces import ERC20\n\nstruct RewardToken:\n    distributor: address\n    period_finish: uint256\n    rate: uint256\n    duration: uint256\n    received: uint256\n    paid: uint256\n\n\nowner: public(address)\nfuture_owner: public(address)\n\nreward_receiver: public(address)\nreward_tokens: public(address[8])\nreward_count: public(uint256)\nreward_data: public(HashMap[address, RewardToken])\nlast_update_time: public(uint256)\n\n\n@external\ndef __init__(_owner: address, _receiver: address, _reward: address):\n    self.owner = _owner\n    self.reward_receiver = _receiver\n\n    self.reward_tokens[0] = _reward\n    self.reward_count = 1\n    self.reward_data[_reward].distributor = _owner\n    self.reward_data[_reward].duration = 86400 * 7\n\n\n@external\ndef add_reward(_token: address, _distributor: address, _duration: uint256):\n    \"\"\"\n    @notice Add a reward token\n    @param _token Address of the reward token\n    @param _distributor Address permitted to call `notify_reward_amount` for this token\n    @param _duration Number of seconds that rewards of this token are streamed over\n    \"\"\"\n    assert msg.sender == self.owner  # dev: owner only\n    assert self.reward_data[_token].distributor == ZERO_ADDRESS, \"Reward token already added\"\n\n    idx: uint256 = self.reward_count\n    self.reward_tokens[idx] = _token\n    self.reward_count = idx + 1\n    self.reward_data[_token].distributor = _distributor\n    self.reward_data[_token].duration = _duration\n\n\n@external\ndef remove_reward(_token: address):\n    \"\"\"\n    @notice Remove a reward token\n    @dev Any remaining balance of the reward token is transferred to the owner\n    @param _token Address of the reward token\n    \"\"\"\n    assert msg.sender == self.owner  # dev: only owner\n    assert self.reward_data[_token].distributor != ZERO_ADDRESS, \"Reward token not added\"\n\n    self.reward_data[_token] = empty(RewardToken)\n    amount: uint256 = ERC20(_token).balanceOf(self)\n    response: Bytes[32] = raw_call(\n        _token,\n        concat(\n            method_id(\"transfer(address,uint256)\"),\n            convert(msg.sender, bytes32),\n            convert(amount, bytes32),\n        ),\n        max_outsize=32,\n    )\n    if len(response) != 0:\n        assert convert(response, bool)\n\n    idx: uint256 = self.reward_count - 1\n    for i in range(8):\n        if self.reward_tokens[i] == _token:\n            self.reward_tokens[i] = self.reward_tokens[idx]\n            self.reward_tokens[idx] = ZERO_ADDRESS\n            self.reward_count = idx\n            return\n    raise  # this should never be reached\n\n\n@internal\ndef _update_reward(_token: address, _last_update: uint256):\n    # update data about a reward and distribute any pending tokens to the receiver\n    last_time: uint256 = min(block.timestamp, self.reward_data[_token].period_finish)\n    if last_time > _last_update:\n        amount: uint256 = (last_time - _last_update) * self.reward_data[_token].rate\n        if amount > 0:\n            self.reward_data[_token].paid += amount\n            response: Bytes[32] = raw_call(\n                _token,\n                concat(\n                    method_id(\"transfer(address,uint256)\"),\n                    convert(self.reward_receiver, bytes32),\n                    convert(amount, bytes32),\n                ),\n                max_outsize=32,\n            )\n            if len(response) != 0:\n                assert convert(response, bool)\n\n\n@external\ndef set_receiver(_receiver: address):\n    \"\"\"\n    @notice Set the reward receiver\n    @dev When the receiver is a smart contract, it must be capable of recognizing\n         rewards that are directly pushed to it (without a call to `get_reward`)\n    @param _receiver Address of the reward receiver\n    \"\"\"\n    assert msg.sender == self.owner  # dev: only owner\n    self.reward_receiver = _receiver\n\n\n@external\ndef get_reward():\n    \"\"\"\n    @notice Claim pending rewards for `reward_receiver`\n    \"\"\"\n    last_update: uint256 = self.last_update_time\n    for token in self.reward_tokens:\n        if token == ZERO_ADDRESS:\n            break\n        self._update_reward(token, last_update)\n    self.last_update_time = block.timestamp\n\n\n@external\ndef notify_reward_amount(_token: address):\n    \"\"\"\n    @notice Notify the contract of a newly received reward\n    @dev Only callable by the distributor if there is an active reward period.\n         The reward tokens must be transferred into the contract prior to calling\n         this function. Rewards are distributed over `reward_duration` seconds.\n         Updating the reward amount while an existing reward period is still active\n         causes the remaining rewards to be evenly distributed over the new period.\n    @param _token Address of the reward token\n    \"\"\"\n    last_update: uint256 = self.last_update_time\n    is_updated: bool = False\n    for token in self.reward_tokens:\n        if token == ZERO_ADDRESS:\n            break\n\n        self._update_reward(token, last_update)\n        if token == _token:\n            received: uint256 = self.reward_data[token].received\n            expected_balance: uint256 = received - self.reward_data[token].paid\n            actual_balance: uint256 = ERC20(token).balanceOf(self)\n\n            if actual_balance > expected_balance:\n                new_amount: uint256 = actual_balance - expected_balance\n                duration: uint256 = self.reward_data[token].duration\n\n                if block.timestamp >= self.reward_data[token].period_finish:\n                    self.reward_data[token].rate = new_amount / duration\n                else:\n                    assert msg.sender == self.reward_data[_token].distributor, \"Reward period still active\"\n                    remaining: uint256 = self.reward_data[token].period_finish - block.timestamp\n                    leftover: uint256 = remaining * self.reward_data[token].rate\n                    self.reward_data[token].rate = (new_amount + leftover) / duration\n\n                self.reward_data[token].period_finish = block.timestamp + duration\n                self.reward_data[token].received = received + new_amount\n                is_updated = True\n\n    assert is_updated, \"Invalid token or no"
    }
  ]
}