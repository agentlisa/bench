{
  "Title": "[M-03] Updating `SafeManager` address in the `Vault721` will disable NFV minting",
  "Content": "\n*   `Vault721` contract is the ERC721 \"Non-fungible Vault\" (NFV) that manages all SAFEs ownership, transfers, and approvals via the ERC721 standard, the minter of the NFV is the `ODSafeManager` contract.\n\n*   `ODSafeManager` contract acts as interface to the SAFEEngine to facilitate the management of SAFEs; such as opening safes,modifying SAFE collateral, moving SAFE collateral, etc.\n\n*   When a user opens a SAFE via `ODSafeManager.openSAFE` function; a NFV will be minted to the user where it will have the same id as the SAFE id so that the ids of any of them can be used interchangeably in the system, and the `_safeId` is the state variable that tracks the number of the opened safes/and minted NFV by the `ODSafeManager` contract.\n\n*   The initial value of the `_safeId` is zero; and it will be incremented with each opened SAFE.\n\n*   But a problem will be caused if the governance change the `ODSafeManager` address via `Vault721.setSafeManager`; as this will result in adding a new deployed safe manager where it will have the `_safeId` set to zero, which will result in breaking the synchronization between the `_safeId` and the last minted NFV id (breaking an invariant).\n\n*   But how could this be a problem?\n    Well, this will result in **disabling SAFE opening and NFV minting:**\n\n    1.  The old safe manager contract has a `_safeId` of 1000, and this matches the id of the last minted NFV, so the next NFV id supposed to be 1001, and that should match the value of `_safeId`.\n    2.  The governance decided to change the safe manager address (with a new deployed one) with extra/updated features; so the `_safeId` of the new `ODSafeManager` will be zero.\n    3.  Now a user tries to open a SAFE; so the `_safeId` will be incremeted by 1 (and will equal one) and when the `Vault721.mint` is called to mint a NFV; the function will revert as it's requested to mint a NFV with id=`_safeId`=1, and this NFV has been already deployed by the old safe manager contract.\n\n### Proof of Concept\n\n[Vault721.setSafeManager function](https://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/proxies/Vault721.sol#L126-L128)\n\n```solidity\n  function setSafeManager(address _safeManager) external onlyGovernor {\n    _setSafeManager(_safeManager);\n  }\n```\n\n[Vault721.\\_setSafeManager function](https://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/proxies/Vault721.sol#L172-L174)\n\n```solidity\n  function _setSafeManager(address _safeManager) internal nonZero(_safeManager) {\n    safeManager = IODSafeManager(_safeManager);\n  }\n```\n\n[ODSafeManager.openSAFE function](https://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/proxies/ODSafeManager.sol#L118-L133)\n\n```solidity\n  function openSAFE(bytes32 _cType, address _usr) external returns (uint256 _id) {\n   //some code...\n\n    ++_safeId;\n\n   //some code...\n\n    vault721.mint(_usr, _safeId);\n\n    //some code...\n  }\n```\n\n[Vault721.mint function](https://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/proxies/Vault721.sol#L94-L99)\n\n```solidity\nfunction mint(address _proxy, uint256 _safeId) external {\n    require(msg.sender == address(safeManager), 'V721: only safeManager');\n    require(_proxyRegistry[_proxy] != address(0), 'V721: non-native proxy');\n    address _user = _proxyRegistry[_proxy];\n    _safeMint(_user, _safeId);\n  }\n```\n\n### Recommended Mitigation Steps\n\nAdd a mechanism in the `ODSafeManger` to initialize the `_safeId` based on the total number of previously minted NFV + 1 (another variable to be added to the `Vault721` to track the total number of minted NFVs).\n\n**[MiloTruck (Judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-10-opendollar-findings/issues/381#issuecomment-1800655999):**\n > Since the current implementation of `ODSafeManager` doesn't have the ability to migrate information to a newer version, it will break the `Vault721` contract if the newer version is not modified.\n> \n> Note that the issue of a new `ODSafeManager` not having the state of the previous contract can be addressed in the new contract itself (eg. add functions in the new `ODSafeManager` implementation to set `_safeId`, `_safeData`, etc... to the same values as the current one).\n> \n> However, given that the sponsor was not aware of the bug beforehand (see #326), I believe that this report and its duplicates has provided value to the sponsor and therefore medium severity is appropriate. \n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-opendollar",
  "Code": [
    {
      "filename": "src/contracts/proxies/Vault721.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport {ERC721} from '@openzeppelin/token/ERC721/ERC721.sol';\nimport {ERC721Enumerable} from '@openzeppelin/token/ERC721/extensions/ERC721Enumerable.sol';\nimport {IODSafeManager} from '@interfaces/proxies/IODSafeManager.sol';\nimport {ODProxy} from '@contracts/proxies/ODProxy.sol';\nimport {NFTRenderer} from '@contracts/proxies/NFTRenderer.sol';\n\n// Open Dollar\n// Version 1.5.5\n\ncontract Vault721 is ERC721Enumerable {\n  error NotGovernor();\n  error ProxyAlreadyExist();\n  error ZeroAddress();\n\n  address public governor;\n  IODSafeManager public safeManager;\n  NFTRenderer public nftRenderer;\n\n  string public contractMetaData =\n    '{\"name\": \"Open Dollar Vaults\",\"description\": \"Tradable Vaults for the Open Dollar stablecoin protocol. Caution! Trading this NFT means trading the ownership of your Vault in the Open Dollar protocol and all of the assets/collateral inside each Vault.\",\"image\": \"https://app.opendollar.com/collectionImage.png\",\"external_link\": \"https://opendollar.com\"}';\n\n  mapping(address proxy => address user) internal _proxyRegistry;\n  mapping(address user => address proxy) internal _userRegistry;\n\n  event CreateProxy(address indexed _user, address _proxy);\n\n  /**\n   * @dev initializes DAO governor contract\n   */\n  constructor(address _governor) ERC721('OpenDollar Vault', 'ODV') {\n    governor = _governor;\n  }\n\n  /**\n   * @dev control access for DAO governor\n   */\n  modifier onlyGovernor() {\n    if (msg.sender != governor) revert NotGovernor();\n    _;\n  }\n\n  /**\n   * @dev enforce non-zero address params\n   */\n  modifier nonZero(address _addr) {\n    if (_addr == address(0)) revert ZeroAddress();\n    _;\n  }\n\n  /**\n   * @dev initializes SafeManager contract\n   */\n  function initializeManager() external {\n    if (address(safeManager) == address(0)) _setSafeManager(msg.sender);\n  }\n\n  /**\n   * @dev initializes NFTRenderer contract\n   */\n  function initializeRenderer() external {\n    if (address(nftRenderer) == address(0)) _setNftRenderer(msg.sender);\n  }\n\n  /**\n   * @dev get proxy by user address\n   */\n  function getProxy(address _user) external view returns (address _proxy) {\n    _proxy = _userRegistry[_user];\n  }\n\n  /**\n   * @dev allows msg.sender without an ODProxy to deploy a new ODProxy\n   */\n  function build() external returns (address payable _proxy) {\n    if (!_isNotProxy(msg.sender)) revert ProxyAlreadyExist();\n    _proxy = _build(msg.sender);\n  }\n\n  /**\n   * @dev allows user without an ODProxy to deploy a new ODProxy\n   */\n  function build(address _user) external returns (address payable _proxy) {\n    if (!_isNotProxy(_user)) revert ProxyAlreadyExist();\n    _proxy = _build(_user);\n  }\n\n  /**\n   * @dev mint can only be called by the SafeManager\n   * enforces that only ODProxies call `openSafe` function by checking _proxyRegistry\n   */\n  function mint(address _proxy, uint256 _safeId) external {\n    require(msg.sender == address(safeManager), 'V721: only safeManager');\n    require(_proxyRegistry[_proxy] != address(0), 'V721: non-native proxy');\n    address _user = _proxyRegistry[_proxy];\n    _safeMint(_user, _safeId);\n  }\n\n  /**\n   * @dev allows DAO to update protocol implementation on NFTRenderer\n   */\n  function updateNftRenderer(\n    address _nftRenderer,\n    address _oracleRelayer,\n    address _taxCollector,\n    address _collateralJoinFactory\n  ) external onlyGovernor nonZero(_oracleRelayer) nonZero(_taxCollector) nonZero(_collateralJoinFactory) {\n    address _safeManager = address(safeManager);\n    require(_safeManager != address(0));\n    _setNftRenderer(_nftRenderer);\n    nftRenderer.setImplementation(_safeManager, _oracleRelayer, _taxCollector, _collateralJoinFactory);\n  }\n\n  /**\n   * @dev update meta data\n   */\n  function updateContractURI(string memory _metaData) external onlyGovernor {\n    contractMetaData = _metaData;\n  }\n\n  /**\n   * @dev allows DAO to update protocol implementation of SafeManager\n   */\n  function setSafeManager(address _safeManager) external onlyGovernor {\n    _setSafeManager(_safeManager);\n  }\n\n  /**\n   * @dev allows DAO to update protocol implementation of NFTRenderer\n   */\n  function setNftRenderer(address _nftRenderer) external onlyGovernor {\n    _setNftRenderer(_nftRenderer);\n  }\n\n  /**\n   * @dev generate URI with updated vault information\n   */\n  function tokenURI(uint256 _safeId) public view override returns (string memory uri) {\n    uri = nftRenderer.render(_safeId);\n  }\n\n  /**\n   * @dev contract level meta data\n   */\n  function contractURI() public view returns (string memory uri) {\n    uri = string.concat('data:application/json;utf8,', contractMetaData);\n  }\n\n  /**\n   * @dev check that proxy does not exist OR that the user does not own proxy\n   */\n  function _isNotProxy(address _user) internal view returns (bool) {\n    return _userRegistry[_user] == address(0) || ODProxy(_userRegistry[_user]).OWNER() != _user;\n  }\n\n  /**\n   * @dev deploys ODProxy for user to interact with protocol\n   * updates _proxyRegistry and _userRegistry mappings for new ODProxy\n   */\n  function _build(address _user) internal returns (address payable _proxy) {\n    _proxy = payable(address(new ODProxy(_user)));\n    _proxyRegistry[_proxy] = _user;\n    _userRegistry[_user] = _proxy;\n    emit CreateProxy(_user, address(_proxy));\n  }\n\n  /**\n   * @dev allows DAO to update protocol implementation of SafeManager\n   */\n  function _setSafeManager(address _safeManager) internal nonZero(_safeManager) {\n    safeManager = IODSafeManager(_safeManager);\n  }\n\n  /**\n   * @dev allows DAO to update protocol implementation of NFTRenderer\n   */\n  function _setNftRenderer(address _nftRenderer) internal nonZero(_nftRenderer) {\n    nftRenderer = NFTRenderer(_nftRenderer);\n  }\n\n  /**\n   * @dev _transfer calls `transferSAFEOwnership` on SafeManager\n   * enforces that ODProxy exists for transfer or it deploys a new ODProxy for receiver of vault/nft\n   */\n  function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal override {\n    require(to != address(0), 'V721: no burn');\n    if (from != address(0)) {\n      address payable proxy;\n\n      if (_isNotProxy(to)) {\n        proxy = _build(to);\n      } else {\n        proxy = payable(_userRegistry[to]);\n      }\n      IODSafeManager(safeManager).transferSAFEOwnership(firstTokenId, address(proxy));\n    }\n  }\n}"
    },
    {
      "filename": "src/contracts/proxies/Vault721.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport {ERC721} from '@openzeppelin/token/ERC721/ERC721.sol';\nimport {ERC721Enumerable} from '@openzeppelin/token/ERC721/extensions/ERC721Enumerable.sol';\nimport {IODSafeManager} from '@interfaces/proxies/IODSafeManager.sol';\nimport {ODProxy} from '@contracts/proxies/ODProxy.sol';\nimport {NFTRenderer} from '@contracts/proxies/NFTRenderer.sol';\n\n// Open Dollar\n// Version 1.5.5\n\ncontract Vault721 is ERC721Enumerable {\n  error NotGovernor();\n  error ProxyAlreadyExist();\n  error ZeroAddress();\n\n  address public governor;\n  IODSafeManager public safeManager;\n  NFTRenderer public nftRenderer;\n\n  string public contractMetaData =\n    '{\"name\": \"Open Dollar Vaults\",\"description\": \"Tradable Vaults for the Open Dollar stablecoin protocol. Caution! Trading this NFT means trading the ownership of your Vault in the Open Dollar protocol and all of the assets/collateral inside each Vault.\",\"image\": \"https://app.opendollar.com/collectionImage.png\",\"external_link\": \"https://opendollar.com\"}';\n\n  mapping(address proxy => address user) internal _proxyRegistry;\n  mapping(address user => address proxy) internal _userRegistry;\n\n  event CreateProxy(address indexed _user, address _proxy);\n\n  /**\n   * @dev initializes DAO governor contract\n   */\n  constructor(address _governor) ERC721('OpenDollar Vault', 'ODV') {\n    governor = _governor;\n  }\n\n  /**\n   * @dev control access for DAO governor\n   */\n  modifier onlyGovernor() {\n    if (msg.sender != governor) revert NotGovernor();\n    _;\n  }\n\n  /**\n   * @dev enforce non-zero address params\n   */\n  modifier nonZero(address _addr) {\n    if (_addr == address(0)) revert ZeroAddress();\n    _;\n  }\n\n  /**\n   * @dev initializes SafeManager contract\n   */\n  function initializeManager() external {\n    if (address(safeManager) == address(0)) _setSafeManager(msg.sender);\n  }\n\n  /**\n   * @dev initializes NFTRenderer contract\n   */\n  function initializeRenderer() external {\n    if (address(nftRenderer) == address(0)) _setNftRenderer(msg.sender);\n  }\n\n  /**\n   * @dev get proxy by user address\n   */\n  function getProxy(address _user) external view returns (address _proxy) {\n    _proxy = _userRegistry[_user];\n  }\n\n  /**\n   * @dev allows msg.sender without an ODProxy to deploy a new ODProxy\n   */\n  function build() external returns (address payable _proxy) {\n    if (!_isNotProxy(msg.sender)) revert ProxyAlreadyExist();\n    _proxy = _build(msg.sender);\n  }\n\n  /**\n   * @dev allows user without an ODProxy to deploy a new ODProxy\n   */\n  function build(address _user) external returns (address payable _proxy) {\n    if (!_isNotProxy(_user)) revert ProxyAlreadyExist();\n    _proxy = _build(_user);\n  }\n\n  /**\n   * @dev mint can only be called by the SafeManager\n   * enforces that only ODProxies call `openSafe` function by checking _proxyRegistry\n   */\n  function mint(address _proxy, uint256 _safeId) external {\n    require(msg.sender == address(safeManager), 'V721: only safeManager');\n    require(_proxyRegistry[_proxy] != address(0), 'V721: non-native proxy');\n    address _user = _proxyRegistry[_proxy];\n    _safeMint(_user, _safeId);\n  }\n\n  /**\n   * @dev allows DAO to update protocol implementation on NFTRenderer\n   */\n  function updateNftRenderer(\n    address _nftRenderer,\n    address _oracleRelayer,\n    address _taxCollector,\n    address _collateralJoinFactory\n  ) external onlyGovernor nonZero(_oracleRelayer) nonZero(_taxCollector) nonZero(_collateralJoinFactory) {\n    address _safeManager = address(safeManager);\n    require(_safeManager != address(0));\n    _setNftRenderer(_nftRenderer);\n    nftRenderer.setImplementation(_safeManager, _oracleRelayer, _taxCollector, _collateralJoinFactory);\n  }\n\n  /**\n   * @dev update meta data\n   */\n  function updateContractURI(string memory _metaData) external onlyGovernor {\n    contractMetaData = _metaData;\n  }\n\n  /**\n   * @dev allows DAO to update protocol implementation of SafeManager\n   */\n  function setSafeManager(address _safeManager) external onlyGovernor {\n    _setSafeManager(_safeManager);\n  }\n\n  /**\n   * @dev allows DAO to update protocol implementation of NFTRenderer\n   */\n  function setNftRenderer(address _nftRenderer) external onlyGovernor {\n    _setNftRenderer(_nftRenderer);\n  }\n\n  /**\n   * @dev generate URI with updated vault information\n   */\n  function tokenURI(uint256 _safeId) public view override returns (string memory uri) {\n    uri = nftRenderer.render(_safeId);\n  }\n\n  /**\n   * @dev contract level meta data\n   */\n  function contractURI() public view returns (string memory uri) {\n    uri = string.concat('data:application/json;utf8,', contractMetaData);\n  }\n\n  /**\n   * @dev check that proxy does not exist OR that the user does not own proxy\n   */\n  function _isNotProxy(address _user) internal view returns (bool) {\n    return _userRegistry[_user] == address(0) || ODProxy(_userRegistry[_user]).OWNER() != _user;\n  }\n\n  /**\n   * @dev deploys ODProxy for user to interact with protocol\n   * updates _proxyRegistry and _userRegistry mappings for new ODProxy\n   */\n  function _build(address _user) internal returns (address payable _proxy) {\n    _proxy = payable(address(new ODProxy(_user)));\n    _proxyRegistry[_proxy] = _user;\n    _userRegistry[_user] = _proxy;\n    emit CreateProxy(_user, address(_proxy));\n  }\n\n  /**\n   * @dev allows DAO to update protocol implementation of SafeManager\n   */\n  function _setSafeManager(address _safeManager) internal nonZero(_safeManager) {\n    safeManager = IODSafeManager(_safeManager);\n  }\n\n  /**\n   * @dev allows DAO to update protocol implementation of NFTRenderer\n   */\n  function _setNftRenderer(address _nftRenderer) internal nonZero(_nftRenderer) {\n    nftRenderer = NFTRenderer(_nftRenderer);\n  }\n\n  /**\n   * @dev _transfer calls `transferSAFEOwnership` on SafeManager\n   * enforces that ODProxy exists for transfer or it deploys a new ODProxy for receiver of vault/nft\n   */\n  function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal override {\n    require(to != address(0), 'V721: no burn');\n    if (from != address(0)) {\n      address payable proxy;\n\n      if (_isNotProxy(to)) {\n        proxy = _build(to);\n      } else {\n        proxy = payable(_userRegistry[to]);\n      }\n      IODSafeManager(safeManager).transferSAFEOwnership(firstTokenId, address(proxy));\n    }\n  }\n}"
    },
    {
      "filename": "src/contracts/proxies/ODSafeManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport {SAFEHandler} from '@contracts/proxies/SAFEHandler.sol';\nimport {ISAFEEngine} from '@interfaces/ISAFEEngine.sol';\nimport {ILiquidationEngine} from '@interfaces/ILiquidationEngine.sol';\nimport {IVault721} from '@interfaces/proxies/IVault721.sol';\n\nimport {Math} from '@libraries/Math.sol';\nimport {EnumerableSet} from '@openzeppelin/utils/structs/EnumerableSet.sol';\nimport {Assertions} from '@libraries/Assertions.sol';\n\nimport {IODSafeManager} from '@interfaces/proxies/IODSafeManager.sol';\n\n/**\n * @title  ODSafeManager\n * @notice This contract acts as interface to the SAFEEngine, facilitating the management of SAFEs\n * @dev    This contract is meant to be used by users that interact with the protocol through a proxy contract\n */\ncontract ODSafeManager is IODSafeManager {\n  using Math for uint256;\n  using EnumerableSet for EnumerableSet.UintSet;\n  using Assertions for address;\n\n  /// @inheritdoc IODSafeManager\n  address public safeEngine;\n\n  // --- ERC721 ---\n  IVault721 public vault721;\n\n  uint256 internal _safeId; // Auto incremental\n  mapping(address _safeOwner => EnumerableSet.UintSet) private _usrSafes;\n  /// @notice Mapping of user addresses to their enumerable set of safes per collateral type\n  mapping(address _safeOwner => mapping(bytes32 _cType => EnumerableSet.UintSet)) private _usrSafesPerCollat;\n  /// @notice Mapping of safe ids to their data\n  mapping(uint256 _safeId => SAFEData) internal _safeData;\n\n  /// @inheritdoc IODSafeManager\n  mapping(address _owner => mapping(uint256 _safeId => mapping(address _caller => uint256 _ok))) public safeCan;\n  /// @inheritdoc IODSafeManager\n  mapping(address _safeHandler => mapping(address _caller => uint256 _ok)) public handlerCan;\n\n  // --- Modifiers ---\n\n  /**\n   * @notice Checks if the sender is the owner of the safe or the safe has permissions to call the function\n   * @param  _safe Id of the safe to check if msg.sender has permissions for\n   */\n  modifier safeAllowed(uint256 _safe) {\n    address _owner = _safeData[_safe].owner;\n    if (msg.sender != _owner && safeCan[_owner][_safe][msg.sender] == 0) revert SafeNotAllowed();\n    _;\n  }\n\n  /**\n   * @notice Checks if the sender is the safe handler has permissions to call the function\n   * @param  _handler Address of the handler to check if msg.sender has permissions for\n   */\n  modifier handlerAllowed(address _handler) {\n    if (msg.sender != _handler && handlerCan[_handler][msg.sender] == 0) revert HandlerNotAllowed();\n    _;\n  }\n\n  constructor(address _safeEngine, address _vault721) {\n    safeEngine = _safeEngine.assertNonNull();\n    vault721 = IVault721(_vault721);\n    vault721.initializeManager();\n  }\n\n  // --- Getters ---\n\n  /// @inheritdoc IODSafeManager\n  function getSafes(address _usr) external view returns (uint256[] memory _safes) {\n    _safes = _usrSafes[_usr].values();\n  }\n\n  /// @inheritdoc IODSafeManager\n  function getSafes(address _usr, bytes32 _cType) external view returns (uint256[] memory _safes) {\n    _safes = _usrSafesPerCollat[_usr][_cType].values();\n  }\n\n  /// @inheritdoc IODSafeManager\n  function getSafesData(address _usr)\n    external\n    view\n    returns (uint256[] memory _safes, address[] memory _safeHandlers, bytes32[] memory _cTypes)\n  {\n    _safes = _usrSafes[_usr].values();\n    _safeHandlers = new address[](_safes.length);\n    _cTypes = new bytes32[](_safes.length);\n    for (uint256 _i; _i < _safes.length; _i++) {\n      _safeHandlers[_i] = _safeData[_safes[_i]].safeHandler;\n      _cTypes[_i] = _safeData[_safes[_i]].collateralType;\n    }\n  }\n\n  /// @inheritdoc IODSafeManager\n  function safeData(uint256 _safe) external view returns (SAFEData memory _sData) {\n    _sData = _safeData[_safe];\n  }\n\n  // --- Methods ---\n\n  /// @inheritdoc IODSafeManager\n  function allowSAFE(uint256 _safe, address _usr, uint256 _ok) external safeAllowed(_safe) {\n    address _owner = _safeData[_safe].owner;\n    safeCan[_owner][_safe][_usr] = _ok;\n    emit AllowSAFE(msg.sender, _safe, _usr, _ok);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function allowHandler(address _usr, uint256 _ok) external {\n    handlerCan[msg.sender][_usr] = _ok;\n    emit AllowHandler(msg.sender, _usr, _ok);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function openSAFE(bytes32 _cType, address _usr) external returns (uint256 _id) {\n    if (_usr == address(0)) revert ZeroAddress();\n\n    ++_safeId;\n    address _safeHandler = address(new SAFEHandler(safeEngine));\n\n    _safeData[_safeId] = SAFEData({owner: _usr, safeHandler: _safeHandler, collateralType: _cType});\n\n    _usrSafes[_usr].add(_safeId);\n    _usrSafesPerCollat[_usr][_cType].add(_safeId);\n\n    vault721.mint(_usr, _safeId);\n\n    emit OpenSAFE(msg.sender, _usr, _safeId);\n    return _safeId;\n  }\n\n  // Give the safe ownership to a dst address.\n  function transferSAFEOwnership(uint256 _safe, address _dst) external {\n    require(msg.sender == address(vault721), 'SafeMngr: Only Vault721');\n\n    if (_dst == address(0)) revert ZeroAddress();\n    SAFEData memory _sData = _safeData[_safe];\n    if (_dst == _sData.owner) revert AlreadySafeOwner();\n\n    _usrSafes[_sData.owner].remove(_safe);\n    _usrSafesPerCollat[_sData.owner][_sData.collateralType].remove(_safe);\n\n    _usrSafes[_dst].add(_safe);\n    _usrSafesPerCollat[_dst][_sData.collateralType].add(_safe);\n\n    _safeData[_safe].owner = _dst;\n\n    emit TransferSAFEOwnership(msg.sender, _safe, _dst);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function modifySAFECollateralization(\n    uint256 _safe,\n    int256 _deltaCollateral,\n    int256 _deltaDebt\n  ) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine(safeEngine).modifySAFECollateralization(\n      _sData.collateralType, _sData.safeHandler, _sData.safeHandler, _sData.safeHandler, _deltaCollateral, _deltaDebt\n    );\n    emit ModifySAFECollateralization(msg.sender, _safe, _deltaCollateral, _deltaDebt);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function transferCollateral(uint256 _safe, address _dst, uint256 _wad) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine(safeEngine).transferCollateral(_sData.collateralType, _sData.safeHandler, _dst, _wad);\n    emit TransferCollateral(msg.sender, _safe, _dst, _wad);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function transferCollateral(bytes32 _cType, uint256 _safe, address _dst, uint256 _wad) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine(safeEngine).transferCollateral(_cType, _sData.safeHandler, _dst, _wad);\n    emit TransferCollateral(msg.sender, _cType, _safe, _dst, _wad);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function transferInternalCoins(uint256 _safe, address _dst, uint256 _rad) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine(safeEngine).transferInternalCoins(_sData.safeHandler, _dst, _rad);\n    emit TransferInternalCoins(msg.sender, _safe, _dst, _rad);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function quitSystem(uint256 _safe, address _dst) external safeAllowed(_safe) handlerAllowed(_dst) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine.SAFE memory _safeInfo = ISAFEEngine(safeEngine).safes(_sData.collateralType, _sData.safeHandler);\n    int256 _deltaCollateral = _safeInfo.lockedCollateral.toInt();\n    int256 _deltaDebt = _safeInfo.generatedDebt.toInt();\n    ISAFEEngine(safeEngine).transferSAFECollateralAndDebt(\n      _sData.collateralType, _sData.safeHandler, _dst, _deltaCollateral, _deltaDebt\n    );\n\n    // Remove safe from owner's list (notice it doesn't erase safe ownership)\n    _usrSafes[_sData.owner].remove(_safe);\n    _usrSafesPerCollat[_sData.owner][_sData.collateralType].remove(_safe);\n    emit QuitSystem(msg.sender, _safe, _dst);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function enterSystem(address _src, uint256 _safe) external handlerAllowed(_src) safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine.SAFE memory _safeInfo = ISAFEEngine(safeEngine).safes(_sData.collateralType, _sData.safeHandler);\n    int256 _deltaCollateral = _safeInfo.lockedCollateral.toInt();\n    int256 _deltaDebt = _safeInfo.generatedDebt.toInt();\n    ISAFEEngine(safeEngine).transferSAFECollateralAndDebt(\n      _sData.collateralType, _src, _sData.safeHandler, _deltaCollateral, _deltaDebt\n    );\n    emit EnterSystem(msg.sender, _src, _safe);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function moveSAFE(uint256 _safeSrc, uint256 _safeDst) external safeAllowed(_safeSrc) safeAllowed(_safeDst) {\n    SAFEData memory _srcData = _safeData[_safeSrc];\n    SAFEData memory _dstData = _safeData[_safeDst];\n    if (_srcData.collateralType != _dstData.collateralType) revert CollateralTypesMismatch();\n    ISAFEEngine.SAFE memory _safeInfo = ISAFEEngine(safeEngine).safes(_srcData.collateralType, _srcData.safeHandler);\n    int256 _deltaCollateral = _safeInfo.lockedCollateral.toInt();\n    int256 _deltaDebt = _safeInfo.generatedDebt.toInt();\n    ISAFEEngine(safeEngine).transferSAFECollateralAndDebt(\n      _srcData.collateralType, _srcData.safeHandler, _dstData.safeHandler, _deltaCollateral, _deltaDebt\n    );\n\n    // Remove safe from owner's list (notice it doesn't erase safe ownership)\n    _usrSafes[_srcData.owner].remove(_safeSrc);\n    _usrSafesPerCollat[_srcData.owner][_srcData.collateralType].remove(_safeSrc);\n    emit MoveSAFE(msg.sender, _safeSrc, _safeDst);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function addSAFE(uint256 _safe) external {\n    SAFEData memory _sData = _safeData[_safe];\n    _usrSafes[msg.sender].add(_safe);\n    _usrSafesPerCollat[msg.sender][_sData.collateralType].add(_safe);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function removeSAFE(uint256 _safe) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    _usrSafes[_sData.owner].remove(_safe);\n    _usrSafesPerCollat[_sData.owner][_sData.collateralType].remove(_safe);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function protectSAFE(uint256 _safe, address _liquidationEngine, address _saviour) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ILiquidationEngine(_liquidationEngine).protectSAFE(_sData.collateralType, _sData.safeHandler, _saviour);\n    emit ProtectSAFE(msg.sender, _safe, _liquidationEngine, _saviour);\n  }\n}"
    },
    {
      "filename": "src/contracts/proxies/Vault721.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport {ERC721} from '@openzeppelin/token/ERC721/ERC721.sol';\nimport {ERC721Enumerable} from '@openzeppelin/token/ERC721/extensions/ERC721Enumerable.sol';\nimport {IODSafeManager} from '@interfaces/proxies/IODSafeManager.sol';\nimport {ODProxy} from '@contracts/proxies/ODProxy.sol';\nimport {NFTRenderer} from '@contracts/proxies/NFTRenderer.sol';\n\n// Open Dollar\n// Version 1.5.5\n\ncontract Vault721 is ERC721Enumerable {\n  error NotGovernor();\n  error ProxyAlreadyExist();\n  error ZeroAddress();\n\n  address public governor;\n  IODSafeManager public safeManager;\n  NFTRenderer public nftRenderer;\n\n  string public contractMetaData =\n    '{\"name\": \"Open Dollar Vaults\",\"description\": \"Tradable Vaults for the Open Dollar stablecoin protocol. Caution! Trading this NFT means trading the ownership of your Vault in the Open Dollar protocol and all of the assets/collateral inside each Vault.\",\"image\": \"https://app.opendollar.com/collectionImage.png\",\"external_link\": \"https://opendollar.com\"}';\n\n  mapping(address proxy => address user) internal _proxyRegistry;\n  mapping(address user => address proxy) internal _userRegistry;\n\n  event CreateProxy(address indexed _user, address _proxy);\n\n  /**\n   * @dev initializes DAO governor contract\n   */\n  constructor(address _governor) ERC721('OpenDollar Vault', 'ODV') {\n    governor = _governor;\n  }\n\n  /**\n   * @dev control access for DAO governor\n   */\n  modifier onlyGovernor() {\n    if (msg.sender != governor) revert NotGovernor();\n    _;\n  }\n\n  /**\n   * @dev enforce non-zero address params\n   */\n  modifier nonZero(address _addr) {\n    if (_addr == address(0)) revert ZeroAddress();\n    _;\n  }\n\n  /**\n   * @dev initializes SafeManager contract\n   */\n  function initializeManager() external {\n    if (address(safeManager) == address(0)) _setSafeManager(msg.sender);\n  }\n\n  /**\n   * @dev initializes NFTRenderer contract\n   */\n  function initializeRenderer() external {\n    if (address(nftRenderer) == address(0)) _setNftRenderer(msg.sender);\n  }\n\n  /**\n   * @dev get proxy by user address\n   */\n  function getProxy(address _user) external view returns (address _proxy) {\n    _proxy = _userRegistry[_user];\n  }\n\n  /**\n   * @dev allows msg.sender without an ODProxy to deploy a new ODProxy\n   */\n  function build() external returns (address payable _proxy) {\n    if (!_isNotProxy(msg.sender)) revert ProxyAlreadyExist();\n    _proxy = _build(msg.sender);\n  }\n\n  /**\n   * @dev allows user without an ODProxy to deploy a new ODProxy\n   */\n  function build(address _user) external returns (address payable _proxy) {\n    if (!_isNotProxy(_user)) revert ProxyAlreadyExist();\n    _proxy = _build(_user);\n  }\n\n  /**\n   * @dev mint can only be called by the SafeManager\n   * enforces that only ODProxies call `openSafe` function by checking _proxyRegistry\n   */\n  function mint(address _proxy, uint256 _safeId) external {\n    require(msg.sender == address(safeManager), 'V721: only safeManager');\n    require(_proxyRegistry[_proxy] != address(0), 'V721: non-native proxy');\n    address _user = _proxyRegistry[_proxy];\n    _safeMint(_user, _safeId);\n  }\n\n  /**\n   * @dev allows DAO to update protocol implementation on NFTRenderer\n   */\n  function updateNftRenderer(\n    address _nftRenderer,\n    address _oracleRelayer,\n    address _taxCollector,\n    address _collateralJoinFactory\n  ) external onlyGovernor nonZero(_oracleRelayer) nonZero(_taxCollector) nonZero(_collateralJoinFactory) {\n    address _safeManager = address(safeManager);\n    require(_safeManager != address(0));\n    _setNftRenderer(_nftRenderer);\n    nftRenderer.setImplementation(_safeManager, _oracleRelayer, _taxCollector, _collateralJoinFactory);\n  }\n\n  /**\n   * @dev update meta data\n   */\n  function updateContractURI(string memory _metaData) external onlyGovernor {\n    contractMetaData = _metaData;\n  }\n\n  /**\n   * @dev allows DAO to update protocol implementation of SafeManager\n   */\n  function setSafeManager(address _safeManager) external onlyGovernor {\n    _setSafeManager(_safeManager);\n  }\n\n  /**\n   * @dev allows DAO to update protocol implementation of NFTRenderer\n   */\n  function setNftRenderer(address _nftRenderer) external onlyGovernor {\n    _setNftRenderer(_nftRenderer);\n  }\n\n  /**\n   * @dev generate URI with updated vault information\n   */\n  function tokenURI(uint256 _safeId) public view override returns (string memory uri) {\n    uri = nftRenderer.render(_safeId);\n  }\n\n  /**\n   * @dev contract level meta data\n   */\n  function contractURI() public view returns (string memory uri) {\n    uri = string.concat('data:application/json;utf8,', contractMetaData);\n  }\n\n  /**\n   * @dev check that proxy does not exist OR that the user does not own proxy\n   */\n  function _isNotProxy(address _user) internal view returns (bool) {\n    return _userRegistry[_user] == address(0) || ODProxy(_userRegistry[_user]).OWNER() != _user;\n  }\n\n  /**\n   * @dev deploys ODProxy for user to interact with protocol\n   * updates _proxyRegistry and _userRegistry mappings for new ODProxy\n   */\n  function _build(address _user) internal returns (address payable _proxy) {\n    _proxy = payable(address(new ODProxy(_user)));\n    _proxyRegistry[_proxy] = _user;\n    _userRegistry[_user] = _proxy;\n    emit CreateProxy(_user, address(_proxy));\n  }\n\n  /**\n   * @dev allows DAO to update protocol implementation of SafeManager\n   */\n  function _setSafeManager(address _safeManager) internal nonZero(_safeManager) {\n    safeManager = IODSafeManager(_safeManager);\n  }\n\n  /**\n   * @dev allows DAO to update protocol implementation of NFTRenderer\n   */\n  function _setNftRenderer(address _nftRenderer) internal nonZero(_nftRenderer) {\n    nftRenderer = NFTRenderer(_nftRenderer);\n  }\n\n  /**\n   * @dev _transfer calls `transferSAFEOwnership` on SafeManager\n   * enforces that ODProxy exists for transfer or it deploys a new ODProxy for receiver of vault/nft\n   */\n  function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal override {\n    require(to != address(0), 'V721: no burn');\n    if (from != address(0)) {\n      address payable proxy;\n\n      if (_isNotProxy(to)) {\n        proxy = _build(to);\n      } else {\n        proxy = payable(_userRegistry[to]);\n      }\n      IODSafeManager(safeManager).transferSAFEOwnership(firstTokenId, address(proxy));\n    }\n  }\n}"
    }
  ]
}