{
  "Title": "[L16] Unclear overwrite of commission update queue",
  "Content": "In the [`queueCommissionUpdate` function of the `Validators` contract](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/governance/Validators.sol#L843) the `nextCommission` and `nextCommissionBlock` for a group are updated.  \n\nWhen the `nextCommissionBlock` has passed, the [`updateCommission` function](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/governance/Validators.sol#L857) can be called to update the group commission.\n\n\nIt is not clear what should happen when `queueCommissionUpdate` is called twice before `updateCommission` succeeds. Currently, the `nextCommission` and `nextCommissionBlock` are just overwritten. However, by calling it a queue it gives the impression that the values of the second call will be qeued to be applied after the values of the first call.\n\n\nConsider documenting this case, explaining that the pending commission values will be overwritten. Since this is a queue of one element, consider renaming the function to something like `setNextCommission`.\n\n\n***Update:** Fixed in [pull request #3278](https://github.com/celo-org/celo-monorepo/pull/3278).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/governance/Validators.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/Math.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\nimport \"./interfaces/IValidators.sol\";\n\nimport \"../identity/interfaces/IRandom.sol\";\n\nimport \"../common/CalledByVm.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/FixidityLib.sol\";\nimport \"../common/linkedlists/AddressLinkedList.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/UsingPrecompiles.sol\";\nimport \"../common/libraries/ReentrancyGuard.sol\";\n\n/**\n * @title A contract for registering and electing Validator Groups and Validators.\n */\ncontract Validators is\n  IValidators,\n  Ownable,\n  ReentrancyGuard,\n  Initializable,\n  UsingRegistry,\n  UsingPrecompiles,\n  CalledByVm\n{\n  using FixidityLib for FixidityLib.Fraction;\n  using AddressLinkedList for LinkedList.List;\n  using SafeMath for uint256;\n  using BytesLib for bytes;\n\n  // For Validators, these requirements must be met in order to:\n  //   1. Register a validator\n  //   2. Affiliate with and be added to a group\n  //   3. Receive epoch payments (note that the group must meet the group requirements as well)\n  // Accounts may de-register their Validator `duration` seconds after they were last a member of a\n  // group, after which no restrictions on Locked Gold will apply to the account.\n  //\n  // For Validator Groups, these requirements must be met in order to:\n  //   1. Register a group\n  //   2. Add a member to a group\n  //   3. Receive epoch payments\n  // Note that for groups, the requirement value is multiplied by the number of members, and is\n  // enforced for `duration` seconds after the group last had that number of members.\n  // Accounts may de-register their Group `duration` seconds after they were last non-empty, after\n  // which no restrictions on Locked Gold will apply to the account.\n  struct LockedGoldRequirements {\n    uint256 value;\n    // In seconds.\n    uint256 duration;\n  }\n\n  struct ValidatorGroup {\n    bool exists;\n    LinkedList.List members;\n    FixidityLib.Fraction commission;\n    FixidityLib.Fraction nextCommission;\n    uint256 nextCommissionBlock;\n    // sizeHistory[i] contains the last time the group contained i members.\n    uint256[] sizeHistory;\n    SlashingInfo slashInfo;\n  }\n\n  // Stores the epoch number at which a validator joined a particular group.\n  struct MembershipHistoryEntry {\n    uint256 epochNumber;\n    address group;\n  }\n\n  // Stores the per-epoch membership history of a validator, used to determine which group\n  // commission should be paid to at the end of an epoch.\n  // Stores a timestamp of the last time the validator was removed from a group, used to determine\n  // whether or not a group can de-register.\n  struct MembershipHistory {\n    // The key to the most recent entry in the entries mapping.\n    uint256 tail;\n    // The number of entries in this validators membership history.\n    uint256 numEntries;\n    mapping(uint256 => MembershipHistoryEntry) entries;\n    uint256 lastRemovedFromGroupTimestamp;\n  }\n\n  struct SlashingInfo {\n    FixidityLib.Fraction multiplier;\n    uint256 lastSlashed;\n  }\n\n  struct PublicKeys {\n    bytes ecdsa;\n    bytes bls;\n  }\n\n  struct Validator {\n    PublicKeys publicKeys;\n    address affiliation;\n    FixidityLib.Fraction score;\n    MembershipHistory membershipHistory;\n  }\n\n  // Parameters that govern the calculation of validator's score.\n  struct ValidatorScoreParameters {\n    uint256 exponent;\n    FixidityLib.Fraction adjustmentSpeed;\n  }\n\n  mapping(address => ValidatorGroup) private groups;\n  mapping(address => Validator) private validators;\n  address[] private registeredGroups;\n  address[] private registeredValidators;\n  LockedGoldRequirements public validatorLockedGoldRequirements;\n  LockedGoldRequirements public groupLockedGoldRequirements;\n  ValidatorScoreParameters private validatorScoreParameters;\n  uint256 public membershipHistoryLength;\n  uint256 public maxGroupSize;\n  // The number of blocks to delay a ValidatorGroup's commission update\n  uint256 public commissionUpdateDelay;\n  uint256 public slashingMultiplierResetPeriod;\n\n  event MaxGroupSizeSet(uint256 size);\n  event CommissionUpdateDelaySet(uint256 delay);\n  event ValidatorScoreParametersSet(uint256 exponent, uint256 adjustmentSpeed);\n  event GroupLockedGoldRequirementsSet(uint256 value, uint256 duration);\n  event ValidatorLockedGoldRequirementsSet(uint256 value, uint256 duration);\n  event MembershipHistoryLengthSet(uint256 length);\n  event ValidatorRegistered(address indexed validator, bytes ecdsaPublicKey, bytes blsPublicKey);\n  event ValidatorDeregistered(address indexed validator);\n  event ValidatorAffiliated(address indexed validator, address indexed group);\n  event ValidatorDeaffiliated(address indexed validator, address indexed group);\n  event ValidatorEcdsaPublicKeyUpdated(address indexed validator, bytes ecdsaPublicKey);\n  event ValidatorBlsPublicKeyUpdated(address indexed validator, bytes blsPublicKey);\n  event ValidatorScoreUpdated(address indexed validator, uint256 score, uint256 epochScore);\n  event ValidatorGroupRegistered(address indexed group, uint256 commission);\n  event ValidatorGroupDeregistered(address indexed group);\n  event ValidatorGroupMemberAdded(address indexed group, address indexed validator);\n  event ValidatorGroupMemberRemoved(address indexed group, address indexed validator);\n  event ValidatorGroupMemberReordered(address indexed group, address indexed validator);\n  event ValidatorGroupCommissionUpdateQueued(\n    address indexed group,\n    uint256 commission,\n    uint256 activationBlock\n  );\n  event ValidatorGroupCommissionUpdated(address indexed group, uint256 commission);\n  event ValidatorEpochPaymentDistributed(\n    address indexed validator,\n    uint256 validatorPayment,\n    address indexed group,\n    uint256 groupPayment\n  );\n\n  modifier onlySlasher() {\n    require(getLockedGold().isSlasher(msg.sender), \"Only registered slasher can call\");\n    _;\n  }\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param registryAddress The address of the registry core smart contract.\n   * @param groupRequirementValue The Locked Gold requirement amount for groups.\n   * @param groupRequirementDuration The Locked Gold requirement duration for groups.\n   * @param validatorRequirementValue The Locked Gold requirement amount for validators.\n   * @param validatorRequirementDuration The Locked Gold requirement duration for validators.\n   * @param validatorScoreExponent The exponent used in calculating validator scores.\n   * @param validatorScoreAdjustmentSpeed The speed at which validator scores are adjusted.\n   * @param _membershipHistoryLength The max number of entries for validator membership history.\n   * @param _maxGroupSize The maximum group size.\n   * @param _commissionUpdateDelay The number of blocks to delay a ValidatorGroup's commission\n   * update.\n   * @dev Should be called only once.\n   */\n  function initialize(\n    address registryAddress,\n    uint256 groupRequirementValue,\n    uint256 groupRequirementDuration,\n    uint256 validatorRequirementValue,\n    uint256 validatorRequirementDuration,\n    uint256 validatorScoreExponent,\n    uint256 validatorScoreAdjustmentSpeed,\n    uint256 _membershipHistoryLength,\n    uint256 _slashingMultiplierResetPeriod,\n    uint256 _maxGroupSize,\n    uint256 _commissionUpdateDelay\n  ) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setGroupLockedGoldRequirements(groupRequirementValue, groupRequirementDuration);\n    setValidatorLockedGoldRequirements(validatorRequirementValue, validatorRequirementDuration);\n    setValidatorScoreParameters(validatorScoreExponent, validatorScoreAdjustmentSpeed);\n    setMaxGroupSize(_maxGroupSize);\n    setCommissionUpdateDelay(_commissionUpdateDelay);\n    setMembershipHistoryLength(_membershipHistoryLength);\n    setSlashingMultiplierResetPeriod(_slashingMultiplierResetPeriod);\n  }\n\n  /**\n   * @notice Updates the block delay for a ValidatorGroup's commission udpdate\n   * @param delay Number of block to delay the update\n   */\n  function setCommissionUpdateDelay(uint256 delay) public onlyOwner {\n    require(delay != commissionUpdateDelay, \"commission update delay not changed\");\n    commissionUpdateDelay = delay;\n    emit CommissionUpdateDelaySet(delay);\n  }\n\n  /**\n   * @notice Updates the maximum number of members a group can have.\n   * @param size The maximum group size.\n   * @return True upon success.\n   */\n  function setMaxGroupSize(uint256 size) public onlyOwner returns (bool) {\n    require(0 < size, \"Max group size cannot be zero\");\n    require(size != maxGroupSize, \"Max group size not changed\");\n    maxGroupSize = size;\n    emit MaxGroupSizeSet(size);\n    return true;\n  }\n\n  /**\n   * @notice Updates the number of validator group membership entries to store.\n   * @param length The number of validator group membership entries to store.\n   * @return True upon success.\n   */\n  function setMembershipHistoryLength(uint256 length) public onlyOwner returns (bool) {\n    require(0 < length, \"Membership history length cannot be zero\");\n    require(length != membershipHistoryLength, \"Membership history length not changed\");\n    membershipHistoryLength = length;\n    emit MembershipHistoryLengthSet(length);\n    return true;\n  }\n\n  /**\n   * @notice Updates the validator score parameters.\n   * @param exponent The exponent used in calculating the score.\n   * @param adjustmentSpeed The speed at which the score is adjusted.\n   * @return True upon success.\n   */\n  function setValidatorScoreParameters(uint256 exponent, uint256 adjustmentSpeed)\n    public\n    onlyOwner\n    returns (bool)\n  {\n    require(\n      adjustmentSpeed <= FixidityLib.fixed1().unwrap(),\n      \"Adjustment speed cannot be larger than 1\"\n    );\n    require(\n      exponent != validatorScoreParameters.exponent ||\n        !FixidityLib.wrap(adjustmentSpeed).equals(validatorScoreParameters.adjustmentSpeed),\n      \"Adjustment speed and exponent not changed\"\n    );\n    validatorScoreParameters = ValidatorScoreParameters(\n      exponent,\n      FixidityLib.wrap(adjustmentSpeed)\n    );\n    emit ValidatorScoreParametersSet(exponent, adjustmentSpeed);\n    return true;\n  }\n\n  /**\n   * @notice Returns the maximum number of members a group can add.\n   * @return The maximum number of members a group can add.\n   */\n  function getMaxGroupSize() external view returns (uint256) {\n    return maxGroupSize;\n  }\n\n  /**\n   * @notice Returns the block delay for a ValidatorGroup's commission udpdate.\n   * @return The block delay for a ValidatorGroup's commission udpdate.\n   */\n  function getCommissionUpdateDelay() external view returns (uint256) {\n    return commissionUpdateDelay;\n  }\n\n  /**\n   * @notice Updates the Locked Gold requirements for Validator Groups.\n   * @param value The per-member amount of Locked Gold required.\n   * @param duration The time (in seconds) that these requirements persist for.\n   * @return True upon success.\n   */\n  function setGroupLockedGoldRequirements(uint256 value, uint256 duration)\n    public\n    onlyOwner\n    returns (bool)\n  {\n    LockedGoldRequirements storage requirements = groupLockedGoldRequirements;\n    require(\n      value != requirements.value || duration != requirements.duration,\n      \"Group requirements not changed\"\n    );\n    groupLockedGoldRequirements = LockedGoldRequirements(value, duration);\n    emit GroupLockedGoldRequirementsSet(value, duration);\n    return true;\n  }\n\n  /**\n   * @notice Updates the Locked Gold requirements for Validators.\n   * @param value The amount of Locked Gold required.\n   * @param duration The time (in seconds) that these requirements persist for.\n   * @return True upon success.\n   */\n  function setValidatorLockedGoldRequirements(uint256 value, uint256 duration)\n    public\n    onlyOwner\n    returns (bool)\n  {\n    LockedGoldRequirements storage requirements = validatorLockedGoldRequirements;\n    require(\n      value != requirements.value || duration != requirements.duration,\n      \"Validator requirements not changed\"\n    );\n    validatorLockedGoldRequirements = LockedGoldRequirements(value, duration);\n    emit ValidatorLockedGoldRequirementsSet(value, duration);\n    return true;\n  }\n\n  /**\n   * @notice Registers a validator unaffiliated with any validator group.\n   * @param ecdsaPublicKey The ECDSA public key that the validator is using for consensus, should\n   *   match the validator signer. 64 bytes.\n   * @param blsPublicKey The BLS public key that the validator is using for consensus, should pass\n   *   proof of possession. 96 bytes.\n   * @param blsPop The BLS public key proof-of-possession, which consists of a signature on the\n   *   account address. 48 bytes.\n   * @return True upon success.\n   * @dev Fails if the account is already a validator or validator group.\n   * @dev Fails if the account does not have sufficient Locked Gold.\n   */\n  function registerValidator(\n    bytes calldata ecdsaPublicKey,\n    bytes calldata blsPublicKey,\n    bytes calldata blsPop\n  ) external nonReentrant returns (bool) {\n    address account = getAccounts().validatorSignerToAccount(msg.sender);\n    require(!isValidator(account) && !isValidatorGroup(account), \"Already registered\");\n    uint256 lockedGoldBalance = getLockedGold().getAccountTotalLockedGold(account);\n    require(lockedGoldBalance >= validatorLockedGoldRequirements.value, \"Deposit too small\");\n    Validator storage validator = validators[account];\n    address signer = getAccounts().getValidatorSigner(account);\n    _updateEcdsaPublicKey(validator, signer, ecdsaPublicKey);\n    _updateBlsPublicKey(validator, account, blsPublicKey, blsPop);\n    registeredValidators.push(account);\n    updateMembershipHistory(account, address(0));\n    emit ValidatorRegistered(account, ecdsaPublicKey, blsPublicKey);\n    return true;\n  }\n\n  /**\n   * @notice Returns the parameters that govern how a validator's score is calculated.\n   * @return The parameters that goven how a validator's score is calculated.\n   */\n  function getValidatorScoreParameters() external view returns (uint256, uint256) {\n    return (validatorScoreParameters.exponent, validatorScoreParameters.adjustmentSpeed.unwrap());\n  }\n\n  /**\n   * @notice Returns the group membership history of a validator.\n   * @param account The validator whose membership history to return.\n   * @return The group membership history of a validator.\n   */\n  function getMembershipHistory(address account)\n    external\n    view\n    returns (uint256[] memory, address[] memory, uint256, uint256)\n  {\n    MembershipHistory storage history = validators[account].membershipHistory;\n    uint256[] memory epochs = new uint256[](history.numEntries);\n    address[] memory membershipGroups = new address[](history.numEntries);\n    for (uint256 i = 0; i < history.numEntries; i = i.add(1)) {\n      uint256 index = history.tail.add(i);\n      epochs[i] = history.entries[index].epochNumber;\n      membershipGroups[i] = history.entries[index].group;\n    }\n    return (epochs, membershipGroups, history.lastRemovedFromGroupTimestamp, history.tail);\n  }\n\n  /**\n   * @notice Calculates the validator score for an epoch from the uptime value for the epoch.\n   * @param uptime The Fixidity representation of the validator's uptime, between 0 and 1.\n   * @dev epoch_score = uptime ** exponent\n   * @return Fixidity representation of the epoch score between 0 and 1.\n   */\n  function calculateEpochScore(uint256 uptime) public view returns (uint256) {\n    require(uptime <= FixidityLib.fixed1().unwrap(), \"Uptime cannot be larger than one\");\n    uint256 numerator;\n    uint256 denominator;\n    (numerator, denominator) = fractionMulExp(\n      FixidityLib.fixed1().unwrap(),\n      FixidityLib.fixed1().unwrap(),\n      uptime,\n      FixidityLib.fixed1().unwrap(),\n      validatorScoreParameters.exponent,\n      18\n    );\n    return FixidityLib.newFixedFraction(numerator, denominator).unwrap();\n  }\n\n  /**\n   * @notice Calculates the aggregate score of a group for an epoch from individual uptimes.\n   * @param uptimes Array of Fixidity representations of the validators' uptimes, between 0 and 1.\n   * @dev group_score = average(uptimes ** exponent)\n   * @return Fixidity representation of the group epoch score between 0 and 1.\n   */\n  function calculateGroupEpochScore(uint256[] calldata uptimes) external view returns (uint256) {\n    require(uptimes.length > 0, \"Uptime array empty\");\n    require(uptimes.length <= maxGroupSize, \"Uptime array larger than maximum group size\");\n    FixidityLib.Fraction memory sum;\n    for (uint256 i = 0; i < uptimes.length; i = i.add(1)) {\n      sum = sum.add(FixidityLib.wrap(calculateEpochScore(uptimes[i])));\n    }\n    return sum.divide(FixidityLib.newFixed(uptimes.length)).unwrap();\n  }\n\n  /**\n   * @notice Updates a validator's score based on its uptime for the epoch.\n   * @param signer The validator signer of the validator account whose score needs updating.\n   * @param uptime The Fixidity representation of the validator's uptime, between 0 and 1.\n   * @return True upon success.\n   */\n  function updateValidatorScoreFromSigner(address signer, uint256 uptime) external onlyVm() {\n    _updateValidatorScoreFromSigner(signer, uptime);\n  }\n\n  /**\n   * @notice Updates a validator's score based on its uptime for the epoch.\n   * @param signer The validator signer of the validator whose score needs updating.\n   * @param uptime The Fixidity representation of the validator's uptime, between 0 and 1.\n   * @dev new_score = uptime ** exponent * adjustmentSpeed + old_score * (1 - adjustmentSpeed)\n   * @return True upon success.\n   */\n  function _updateValidatorScoreFromSigner(address signer, uint256 uptime) internal {\n    address account = getAccounts().signerToAccount(signer);\n    require(isValidator(account), \"Not a validator\");\n\n    FixidityLib.Fraction memory epochScore = FixidityLib.wrap(calculateEpochScore(uptime));\n    FixidityLib.Fraction memory newComponent = validatorScoreParameters.adjustmentSpeed.multiply(\n      epochScore\n    );\n\n    FixidityLib.Fraction memory currentComponent = FixidityLib.fixed1().subtract(\n      validatorScoreParameters.adjustmentSpeed\n    );\n    currentComponent = currentComponent.multiply(validators[account].score);\n    validators[account].score = FixidityLib.wrap(\n      Math.min(epochScore.unwrap(), newComponent.add(currentComponent).unwrap())\n    );\n    emit ValidatorScoreUpdated(account, validators[account].score.unwrap(), epochScore.unwrap());\n  }\n\n  /**\n   * @notice Distributes epoch payments to the account associated with `signer` and its group.\n   * @param signer The validator signer of the account to distribute the epoch payment to.\n   * @param maxPayment The maximum payment to the validator. Actual payment is based on score and\n   *   group commission.\n   * @return The total payment paid to the validator and their group.\n   */\n  function distributeEpochPaymentsFromSigner(address signer, uint256 maxPayment)\n    external\n    onlyVm()\n    returns (uint256)\n  {\n    return _distributeEpochPaymentsFromSigner(signer, maxPayment);\n  }\n\n  /**\n   * @notice Distributes epoch payments to the account associated with `signer` and its group.\n   * @param signer The validator signer of the validator to distribute the epoch payment to.\n   * @param maxPayment The maximum payment to the validator. Actual payment is based on score and\n   *   group commission.\n   * @return The total payment paid to the validator and their group.\n   */\n  function _distributeEpochPaymentsFromSigner(address signer, uint256 maxPayment)\n    internal\n    returns (uint256)\n  {\n    address account = getAccounts().signerToAccount(signer);\n    require(isValidator(account), \"Not a validator\");\n    // The group that should be paid is the group that the validator was a member of at the\n    // time it was elected.\n    address group = getMembershipInLastEpoch(account);\n    require(group != address(0), \"Validator not registered with a group\");\n    // Both the validator and the group must maintain the minimum locked gold balance in order to\n    // receive epoch payments.\n    if (meetsAccountLockedGoldRequirements(account) && meetsAccountLockedGoldRequirements(group)) {\n      FixidityLib.Fraction memory totalPayment = FixidityLib.newFixed(maxPayment).multiply(\n        validators[account].score\n      );\n      uint256 groupPayment = totalPayment.multiply(groups[group].commission).fromFixed();\n      uint256 validatorPayment = totalPayment.fromFixed().sub(groupPayment);\n      getStableToken().mint(group, groupPayment);\n      getStableToken().mint(account, validatorPayment);\n      emit ValidatorEpochPaymentDistributed(account, validatorPayment, group, groupPayment);\n      return totalPayment.fromFixed();\n    } else {\n      return 0;\n    }\n  }\n\n  /**\n   * @notice De-registers a validator.\n   * @param index The index of this validator in the list of all registered validators.\n   * @return True upon success.\n   * @dev Fails if the account is not a validator.\n   * @dev Fails if the validator has been a member of a group too recently.\n   */\n  function deregisterValidator(uint256 index) external nonReentrant returns (bool) {\n    address account = getAccounts().validatorSignerToAccount(msg.sender);\n    require(isValidator(account), \"Not a validator\");\n\n    // Require that the validator has not been a member of a validator group for\n    // `validatorLockedGoldRequirements.duration` seconds.\n    Validator storage validator = validators[account];\n    if (validator.affiliation != address(0)) {\n      require(\n        !groups[validator.affiliation].members.contains(account),\n        \"Has been group member recently\"\n      );\n    }\n    uint256 requirementEndTime = validator.membershipHistory.lastRemovedFromGroupTimestamp.add(\n      validatorLockedGoldRequirements.duration\n    );\n    require(requirementEndTime < now, \"Not yet requirement end time\");\n\n    // Remove the validator.\n    deleteElement(registeredValidators, account, index);\n    delete validators[account];\n    emit ValidatorDeregistered(account);\n    return true;\n  }\n\n  /**\n   * @notice Affiliates a validator with a group, allowing it to be added as a member.\n   * @param group The validator group with which to affiliate.\n   * @return True upon success.\n   * @dev De-affiliates with the previously affiliated group if present.\n   */\n  function affiliate(address group) external nonReentrant returns (bool) {\n    address account = getAccounts().validatorSignerToAccount(msg.sender);\n    require(isValidator(account), \"Not a validator\");\n    require(isValidatorGroup(group), \"Not a validator group\");\n    require(meetsAccountLockedGoldRequirements(account), \"Validator doesn't meet requirements\");\n    require(meetsAccountLockedGoldRequirements(group), \"Group doesn't meet requirements\");\n    Validator storage validator = validators[account];\n    if (validator.affiliation != address(0)) {\n      _deaffiliate(validator, account);\n    }\n    validator.affiliation = group;\n    emit ValidatorAffiliated(account, group);\n    return true;\n  }\n\n  /**\n   * @notice De-affiliates a validator, removing it from the group for which it is a member.\n   * @return True upon success.\n   * @dev Fails if the account is not a validator with non-zero affiliation.\n   */\n  function deaffiliate() external nonReentrant returns (bool) {\n    address account = getAccounts().validatorSignerToAccount(msg.sender);\n    require(isValidator(account), \"Not a validator\");\n    Validator storage validator = validators[account];\n    require(validator.affiliation != address(0), \"deaffiliate: not affiliated\");\n    _deaffiliate(validator, account);\n    return true;\n  }\n\n  /**\n   * @notice Updates a validator's BLS key.\n   * @param blsPublicKey The BLS public key that the validator is using for consensus, should pass\n   *   proof of possession. 48 bytes.\n   * @param blsPop The BLS public key proof-of-possession, which consists of a signature on the\n   *   account address. 48 bytes.\n   * @return True upon success.\n   */\n  function updateBlsPublicKey(bytes calldata blsPublicKey, bytes calldata blsPop)\n    external\n    returns (bool)\n  {\n    address account = getAccounts().validatorSignerToAccount(msg.sender);\n    require(isValidator(account), \"Not a validator\");\n    Validator storage validator = validators[account];\n    _updateBlsPublicKey(validator, account, blsPublicKey, blsPop);\n    emit ValidatorBlsPublicKeyUpdated(account, blsPublicKey);\n    return true;\n  }\n\n  /**\n   * @notice Updates a validator's BLS key.\n   * @param validator The validator whose BLS public key should be updated.\n   * @param account The address under which the validator is registered.\n   * @param blsPublicKey The BLS public key that the validator is using for consensus, should pass\n   *   proof of possession. 96 bytes.\n   * @param blsPop The BLS public key proof-of-possession, which consists of a signature on the\n   *   account address. 48 bytes.\n   * @return True upon success.\n   */\n  function _updateBlsPublicKey(\n    Validator storage validator,\n    address account,\n    bytes memory blsPublicKey,\n    bytes memory blsPop\n  ) private returns (bool) {\n    require(blsPublicKey.length == 96, \"Wrong BLS public key length\");\n    require(blsPop.length == 48, \"Wrong BLS PoP length\");\n    require(checkProofOfPossession(account, blsPublicKey, blsPop), \"Invalid BLS PoP\");\n    validator.publicKeys.bls = blsPublicKey;\n    return true;\n  }\n\n  /**\n   * @notice Updates a validator's ECDSA key.\n   * @param account The address under which the validator is registered.\n   * @param signer The address which the validator is using to sign consensus messages.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @return True upon success.\n   */\n  function updateEcdsaPublicKey(address account, address signer, bytes calldata ecdsaPublicKey)\n    external\n    onlyRegisteredContract(ACCOUNTS_REGISTRY_ID)\n    returns (bool)\n  {\n    require(isValidator(account), \"Not a validator\");\n    Validator storage validator = validators[account];\n    require(\n      _updateEcdsaPublicKey(validator, signer, ecdsaPublicKey),\n      \"Error updating ECDSA public key\"\n    );\n    emit ValidatorEcdsaPublicKeyUpdated(account, ecdsaPublicKey);\n    return true;\n  }\n\n  /**\n   * @notice Updates a validator's ECDSA and BLS keys.\n   * @param account The address under which the validator is registered.\n   * @param signer The address which the validator is using to sign consensus messages.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @param blsPublicKey The BLS public key that the validator is using for consensus, should pass\n   *   proof of possession. 96 bytes.\n   * @param blsPop The BLS public key proof-of-possession, which consists of a signature on the\n   *   account address. 48 bytes.\n   * @return True upon success.\n   */\n  function updatePublicKeys(\n    address account,\n    address signer,\n    bytes calldata ecdsaPublicKey,\n    bytes calldata blsPublicKey,\n    bytes calldata blsPop\n  ) external onlyRegisteredContract(ACCOUNTS_REGISTRY_ID) returns (bool) {\n    require(isValidator(account), \"Not a validator\");\n    Validator storage validator = validators[account];\n    require(\n      _updateEcdsaPublicKey(validator, signer, ecdsaPublicKey),\n      \"Error updating ECDSA public key\"\n    );\n    emit ValidatorEcdsaPublicKeyUpdated(account, ecdsaPublicKey);\n    _updateBlsPublicKey(validator, account, blsPublicKey, blsPop);\n    emit ValidatorBlsPublicKeyUpdated(account, blsPublicKey);\n    return true;\n  }\n\n  /**\n   * @notice Updates a validator's ECDSA key.\n   * @param validator The validator whose ECDSA public key should be updated.\n   * @param signer The address with which the validator is signing consensus messages.\n   * @param ecdsaPublicKey The ECDSA public key that the validator is using for consensus. Should\n   *   match `signer`. 64 bytes.\n   * @return True upon success.\n   */\n  function _updateEcdsaPublicKey(\n    Validator storage validator,\n    address signer,\n    bytes memory ecdsaPublicKey\n  ) private returns (bool) {\n    require(ecdsaPublicKey.length == 64, \"Wrong ECDSA public key length\");\n    require(\n      address(uint160(uint256(keccak256(ecdsaPublicKey)))) == signer,\n      \"ECDSA key does not match signer\"\n    );\n    validator.publicKeys.ecdsa = ecdsaPublicKey;\n    return true;\n  }\n\n  /**\n   * @notice Registers a validator group with no member validators.\n   * @param commission Fixidity representation of the commission this group receives on epoch\n   *   payments made to its members.\n   * @return True upon success.\n   * @dev Fails if the account is already a validator or validator group.\n   * @dev Fails if the account does not have sufficient weight.\n   */\n  function registerValidatorGroup(uint256 commission) external nonReentrant returns (bool) {\n    require(commission <= FixidityLib.fixed1().unwrap(), \"Commission can't be greater than 100%\");\n    address account = getAccounts().validatorSignerToAccount(msg.sender);\n    require(!isValidator(account), \"Already registered as validator\");\n    require(!isValidatorGroup(account), \"Already registered as group\");\n    uint256 lockedGoldBalance = getLockedGold().getAccountTotalLockedGold(account);\n    require(lockedGoldBalance >= groupLockedGoldRequirements.value, \"Not enough locked gold\");\n    ValidatorGroup storage group = groups[account];\n    group.exists = true;\n    group.commission = FixidityLib.wrap(commission);\n    group.slashInfo = SlashingInfo(FixidityLib.fixed1(), 0);\n    registeredGroups.push(account);\n    emit ValidatorGroupRegistered(account, commission);\n    return true;\n  }\n\n  /**\n   * @notice De-registers a validator group.\n   * @param index The index of this validator group in the list of all validator groups.\n   * @return True upon success.\n   * @dev Fails if the account is not a validator group with no members.\n   * @dev Fails if the group has had members too recently.\n   */\n  function deregisterValidatorGroup(uint256 index) external nonReentrant returns (bool) {\n    address account = getAccounts().validatorSignerToAccount(msg.sender);\n    // Only Validator Groups that have never had members or have been empty for at least\n    // `groupLockedGoldRequirements.duration` seconds can be deregistered.\n    require(isValidatorGroup(account), \"Not a validator group\");\n    require(groups[account].members.numElements == 0, \"Validator group not empty\");\n    uint256[] storage sizeHistory = groups[account].sizeHistory;\n    if (sizeHistory.length > 1) {\n      require(\n        sizeHistory[1].add(groupLockedGoldRequirements.duration) < now,\n        \"Hasn't been empty for long enough\"\n      );\n    }\n    delete groups[account];\n    deleteElement(registeredGroups, account, index);\n    emit ValidatorGroupDeregistered(account);\n    return true;\n  }\n\n  /**\n   * @notice Adds a member to the end of a validator group's list of members.\n   * @param validator The validator to add to the group\n   * @return True upon success.\n   * @dev Fails if `validator` has not set their affiliation to this account.\n   * @dev Fails if the group has zero members.\n   */\n  function addMember(address validator) external nonReentrant returns (bool) {\n    address account = getAccounts().validatorSignerToAccount(msg.sender);\n    require(groups[account].members.numElements > 0, \"Validator group empty\");\n    return _addMember(account, validator, address(0), address(0));\n  }\n\n  /**\n   * @notice Adds the first member to a group's list of members and marks it eligible for election.\n   * @param validator The validator to add to the group\n   * @param lesser The address of the group that has received fewer votes than this group.\n   * @param greater The address of the group that has received more votes than this group.\n   * @return True upon success.\n   * @dev Fails if `validator` has not set their affiliation to this account.\n   * @dev Fails if the group has > 0 members.\n   */\n  function addFirstMember(address validator, address lesser, address greater)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    address account = getAccounts().validatorSignerToAccount(msg.sender);\n    require(groups[account].members.numElements == 0, \"Validator group not empty\");\n    return _addMember(account, validator, lesser, greater);\n  }\n\n  /**\n   * @notice Adds a member to the end of a validator group's list of members.\n   * @param group The address of the validator group.\n   * @param validator The validator to add to the group.\n   * @param lesser The address of the group that has received fewer votes than this group.\n   * @param greater The ad"
    }
  ]
}