{
  "Title": "Zero Address Management Inconsistencies",
  "Content": "In the Substrate ecosystem, public addresses adopt the SS58 encoding. The Base-58 alphabet omits characters prone to confusion when printed, such as the number 0.\n\n\nGiven this, referring to the \"zero address\" from EVM blockchains can be confusing. In this context, what could potentially use zeros is the public key, which is seldom referenced by regular users. The very idea of a \"zero address\" does not seamlessly translate from EVM chains to Substrate chains.\n\n\nAdditionally, the address derived from a hex public key composed entirely of zeros varies across different Substrate chains.\n\n\nThroughout the codebase, the term \"zero address\" appears numerous times. However, in many instances, it actually refers to Options without an associated `AccountId` (\"None\") which can lead to potentially harmful misunderstandings.\n\n\nWhen using `AccountId` without an associated address, it might be preferable to use \"None\". It is also recommended to rename or refactor any \"zero address\" references throughout the codebase for clarity. For instance, consider changing [`PSP22TokenTimelockError::BeneficiaryZeroAddress`](https://github.com/Brushfam/openbrush-contracts/blob/553347354de6d0ead6a335ba4c197bdd01fb2d12/contracts/src/token/psp22/utils/token_timelock.rs#L123) to `PSP22TokenTimelockError::BeneficiaryIsNotSet`.\n\n\n***Update:** Resolved in [pull request #136](https://github.com/Brushfam/openbrush-contracts/pull/136) at commit [36e2a49](https://github.com/Brushfam/openbrush-contracts/pull/136/commits/36e2a490c5b4ede526fe90f57b7efbd556c3f967).*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/token/psp22/utils/token_timelock.rs",
      "content": "// Copyright (c) 2012-2022 Supercolony\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\"Software\"),\n// to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/// Extension of [`PSP22`] which allows the beneficiary to extract tokens after given time\npub use crate::{\n    psp22,\n    psp22::utils::token_timelock,\n    traits::psp22::{\n        utils::token_timelock::*,\n        *,\n    },\n};\nuse ink::{\n    env::CallFlags,\n    prelude::vec::Vec,\n};\nuse openbrush::traits::{\n    AccountId,\n    Balance,\n    Storage,\n    Timestamp,\n};\npub use psp22::{\n    Internal as _,\n    InternalImpl as _,\n    PSP22Impl,\n};\npub use token_timelock::{\n    Internal as _,\n    InternalImpl as _,\n    PSP22TokenTimelockImpl as _,\n};\n\n#[derive(Default, Debug)]\n#[openbrush::storage_item]\npub struct Data {\n    #[lazy]\n    token: Option<AccountId>,\n    #[lazy]\n    beneficiary: Option<AccountId>,\n    #[lazy]\n    release_time: Timestamp,\n}\n\npub trait PSP22TokenTimelockImpl: Storage<Data> + Internal {\n    /// Returns the token address\n    fn token(&self) -> Option<AccountId> {\n        self._token()\n    }\n\n    /// Returns the beneficiary of the tokens\n    fn beneficiary(&self) -> Option<AccountId> {\n        self._beneficiary()\n    }\n\n    /// Returns the timestamp when the tokens are released\n    fn release_time(&self) -> Timestamp {\n        self.data().release_time.get_or_default()\n    }\n\n    /// Transfers the tokens held by timelock to the beneficairy\n    fn release(&mut self) -> Result<(), PSP22TokenTimelockError> {\n        if Self::env().block_timestamp() < self.data().release_time.get_or_default() {\n            return Err(PSP22TokenTimelockError::CurrentTimeIsBeforeReleaseTime)\n        }\n        let amount = self._contract_balance();\n        if amount == 0 {\n            return Err(PSP22TokenTimelockError::NoTokensToRelease)\n        }\n        self._withdraw(amount)\n    }\n}\n\npub trait Internal {\n    /// Helper function to withdraw tokens\n    fn _withdraw(&mut self, amount: Balance) -> Result<(), PSP22TokenTimelockError>;\n\n    /// Helper function to return balance of the contract\n    fn _contract_balance(&mut self) -> Balance;\n\n    /// Initializes the contract\n    fn _init(\n        &mut self,\n        token: AccountId,\n        beneficiary: AccountId,\n        release_time: Timestamp,\n    ) -> Result<(), PSP22TokenTimelockError>;\n\n    fn _token(&self) -> Option<AccountId>;\n\n    fn _beneficiary(&self) -> Option<AccountId>;\n}\n\npub trait InternalImpl: Storage<Data> + Internal {\n    fn _withdraw(&mut self, amount: Balance) -> Result<(), PSP22TokenTimelockError> {\n        if let Some(beneficiary) = Internal::_beneficiary(self) {\n            if let Some(token) = Internal::_token(self) {\n                PSP22Ref::transfer_builder(&token, beneficiary, amount, Vec::<u8>::new())\n                    .call_flags(CallFlags::default().set_allow_reentry(true))\n                    .try_invoke()\n                    .unwrap()\n                    .unwrap()?;\n                Ok(())\n            } else {\n                Err(PSP22TokenTimelockError::TokenZeroAddress)\n            }\n        } else {\n            Err(PSP22TokenTimelockError::BeneficiaryZeroAddress)\n        }\n    }\n\n    fn _contract_balance(&mut self) -> Balance {\n        if let Some(token) = Internal::_token(self) {\n            PSP22Ref::balance_of(&token, Self::env().account_id())\n        } else {\n            0\n        }\n    }\n\n    fn _init(\n        &mut self,\n        token: AccountId,\n        beneficiary: AccountId,\n        release_time: Timestamp,\n    ) -> Result<(), PSP22TokenTimelockError> {\n        if release_time <= Self::env().block_timestamp() {\n            return Err(PSP22TokenTimelockError::ReleaseTimeIsBeforeCurrentTime)\n        }\n        self.data().token.set(&Some(token));\n        self.data().beneficiary.set(&Some(beneficiary));\n        self.data().release_time.set(&release_time);\n        Ok(())\n    }\n\n    fn _token(&self) -> Option<AccountId> {\n        self.data().token.get_or_default()\n    }\n\n    fn _beneficiary(&self) -> Option<AccountId> {\n        self.data().beneficiary.get_or_default()\n    }\n}"
    }
  ]
}