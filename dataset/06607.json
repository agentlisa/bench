{
  "Title": "[12] Uncommented fields in a struct",
  "Content": "\nConsider adding comments for all the fields in a struct to improve the readability of the codebase.\n\nExample with comments:\n\nhttps://github.com/code-423n4/2023-05-venus/blob/main/contracts/ComptrollerStorage.sol#L29-L42\n\nExample without comments:\n\nhttps://github.com/code-423n4/2023-05-venus/blob/main/contracts/ComptrollerStorage.sol#L8-L27\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-05-venus",
  "Code": [
    {
      "filename": "contracts/ComptrollerStorage.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport \"@venusprotocol/oracle/contracts/PriceOracle.sol\";\nimport \"./VToken.sol\";\n\ncontract ComptrollerStorage {\n    struct LiquidationOrder {\n        VToken vTokenCollateral;\n        VToken vTokenBorrowed;\n        uint256 repayAmount;\n    }\n\n    struct AccountLiquiditySnapshot {\n        uint256 totalCollateral;\n        uint256 weightedCollateral;\n        uint256 borrows;\n        uint256 effects;\n        uint256 liquidity;\n        uint256 shortfall;\n    }\n\n    struct RewardSpeeds {\n        address rewardToken;\n        uint256 supplySpeed;\n        uint256 borrowSpeed;\n    }\n\n    struct Market {\n        // Whether or not this market is listed\n        bool isListed;\n        //  Multiplier representing the most one can borrow against their collateral in this market.\n        //  For instance, 0.9 to allow borrowing 90% of collateral value.\n        //  Must be between 0 and 1, and stored as a mantissa.\n        uint256 collateralFactorMantissa;\n        //  Multiplier representing the collateralization after which the borrow is eligible\n        //  for liquidation. For instance, 0.8 liquidate when the borrow is 80% of collateral\n        //  value. Must be between 0 and collateral factor, stored as a mantissa.\n        uint256 liquidationThresholdMantissa;\n        // Per-market mapping of \"accounts in this asset\"\n        mapping(address => bool) accountMembership;\n    }\n\n    enum Action {\n        MINT,\n        REDEEM,\n        BORROW,\n        REPAY,\n        SEIZE,\n        LIQUIDATE,\n        TRANSFER,\n        ENTER_MARKET,\n        EXIT_MARKET\n    }\n\n    /**\n     * @notice Oracle which gives the price of any given asset\n     */\n    PriceOracle public oracle;\n\n    /**\n     * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\n     */\n    uint256 public closeFactorMantissa;\n\n    /**\n     * @notice Multiplier representing the discount on collateral that a liquidator receives\n     */\n    uint256 public liquidationIncentiveMantissa;\n\n    /**\n     * @notice Per-account mapping of \"assets you are in\"\n     */\n    mapping(address => VToken[]) public accountAssets;\n\n    /**\n     * @notice Official mapping of vTokens -> Market metadata\n     * @dev Used e.g. to determine if a market is supported\n     */\n    mapping(address => Market) public markets;\n\n    /// @notice A list of all markets\n    VToken[] public allMarkets;\n\n    /// @notice Borrow caps enforced by borrowAllowed for each vToken address. Defaults to zero which restricts borrowing.\n    mapping(address => uint256) public borrowCaps;\n\n    /// @notice Minimal collateral required for regular (non-batch) liquidations\n    uint256 public minLiquidatableCollateral;\n\n    /// @notice Supply caps enforced by mintAllowed for each vToken address. Defaults to zero which corresponds to minting notAllowed\n    mapping(address => uint256) public supplyCaps;\n\n    /// @notice True if a certain action is paused on a certain market\n    mapping(address => mapping(Action => bool)) internal _actionPaused;\n\n    // List of Reward Distributors added\n    RewardsDistributor[] internal rewardsDistributors;\n\n    // Used to check if rewards distributor is added\n    mapping(address => bool) internal rewardsDistributorExists;\n\n    uint256 internal constant NO_ERROR = 0;\n\n    // closeFactorMantissa must be strictly greater than this value\n    uint256 internal constant closeFactorMinMantissa = 0.05e18; // 0.05\n\n    // closeFactorMantissa must not exceed this value\n    uint256 internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\n\n    // No collateralFactorMantissa may exceed this value\n    uint256 internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\n\n    /// @notice Indicator that this is a Comptroller contract (for inspection)\n    bool internal constant _isComptroller = true;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}"
    },
    {
      "filename": "contracts/ComptrollerStorage.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport \"@venusprotocol/oracle/contracts/PriceOracle.sol\";\nimport \"./VToken.sol\";\n\ncontract ComptrollerStorage {\n    struct LiquidationOrder {\n        VToken vTokenCollateral;\n        VToken vTokenBorrowed;\n        uint256 repayAmount;\n    }\n\n    struct AccountLiquiditySnapshot {\n        uint256 totalCollateral;\n        uint256 weightedCollateral;\n        uint256 borrows;\n        uint256 effects;\n        uint256 liquidity;\n        uint256 shortfall;\n    }\n\n    struct RewardSpeeds {\n        address rewardToken;\n        uint256 supplySpeed;\n        uint256 borrowSpeed;\n    }\n\n    struct Market {\n        // Whether or not this market is listed\n        bool isListed;\n        //  Multiplier representing the most one can borrow against their collateral in this market.\n        //  For instance, 0.9 to allow borrowing 90% of collateral value.\n        //  Must be between 0 and 1, and stored as a mantissa.\n        uint256 collateralFactorMantissa;\n        //  Multiplier representing the collateralization after which the borrow is eligible\n        //  for liquidation. For instance, 0.8 liquidate when the borrow is 80% of collateral\n        //  value. Must be between 0 and collateral factor, stored as a mantissa.\n        uint256 liquidationThresholdMantissa;\n        // Per-market mapping of \"accounts in this asset\"\n        mapping(address => bool) accountMembership;\n    }\n\n    enum Action {\n        MINT,\n        REDEEM,\n        BORROW,\n        REPAY,\n        SEIZE,\n        LIQUIDATE,\n        TRANSFER,\n        ENTER_MARKET,\n        EXIT_MARKET\n    }\n\n    /**\n     * @notice Oracle which gives the price of any given asset\n     */\n    PriceOracle public oracle;\n\n    /**\n     * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\n     */\n    uint256 public closeFactorMantissa;\n\n    /**\n     * @notice Multiplier representing the discount on collateral that a liquidator receives\n     */\n    uint256 public liquidationIncentiveMantissa;\n\n    /**\n     * @notice Per-account mapping of \"assets you are in\"\n     */\n    mapping(address => VToken[]) public accountAssets;\n\n    /**\n     * @notice Official mapping of vTokens -> Market metadata\n     * @dev Used e.g. to determine if a market is supported\n     */\n    mapping(address => Market) public markets;\n\n    /// @notice A list of all markets\n    VToken[] public allMarkets;\n\n    /// @notice Borrow caps enforced by borrowAllowed for each vToken address. Defaults to zero which restricts borrowing.\n    mapping(address => uint256) public borrowCaps;\n\n    /// @notice Minimal collateral required for regular (non-batch) liquidations\n    uint256 public minLiquidatableCollateral;\n\n    /// @notice Supply caps enforced by mintAllowed for each vToken address. Defaults to zero which corresponds to minting notAllowed\n    mapping(address => uint256) public supplyCaps;\n\n    /// @notice True if a certain action is paused on a certain market\n    mapping(address => mapping(Action => bool)) internal _actionPaused;\n\n    // List of Reward Distributors added\n    RewardsDistributor[] internal rewardsDistributors;\n\n    // Used to check if rewards distributor is added\n    mapping(address => bool) internal rewardsDistributorExists;\n\n    uint256 internal constant NO_ERROR = 0;\n\n    // closeFactorMantissa must be strictly greater than this value\n    uint256 internal constant closeFactorMinMantissa = 0.05e18; // 0.05\n\n    // closeFactorMantissa must not exceed this value\n    uint256 internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\n\n    // No collateralFactorMantissa may exceed this value\n    uint256 internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\n\n    /// @notice Indicator that this is a Comptroller contract (for inspection)\n    bool internal constant _isComptroller = true;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}"
    }
  ]
}