{
  "Title": "[L-03] Dust amounts not compensated, even if not using price oracle",
  "Content": "<h2 id=\"l-03-dust-amounts-not-compensated-even-if-not-using-price-oracle\" style=\"position:relative;\"><a href=\"#l-03-dust-amounts-not-compensated-even-if-not-using-price-oracle\" aria-label=\"l 03 dust amounts not compensated even if not using price oracle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-03] Dust amounts not compensated, even if not using price oracle</h2>\n<p>If thereâ€™s a fixed weighting between what the user provides, and what is minted for them, there should be code that tracks partial token amounts, so that later payments are compensated for their prior partial amounts.</p>\n<p><em>There is 1 instance of this issue:</em></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"23\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">File: </span><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">JBSingleTokenPaymentTerminalStore</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">   #</span><span class=\"mtk7\">1</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">385</span><span class=\"mtk1\">      </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_weightRatio</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_amount</span><span class=\"mtk1\">.</span><span class=\"mtk12\">currency</span><span class=\"mtk1\"> == </span><span class=\"mtk12\">_baseWeightCurrency</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">386</span><span class=\"mtk1\">        ? </span><span class=\"mtk7\">10</span><span class=\"mtk1\">**</span><span class=\"mtk12\">_decimals</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">387</span><span class=\"mtk1\">        : </span><span class=\"mtk12\">prices</span><span class=\"mtk1\">.</span><span class=\"mtk11\">priceFor</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_amount</span><span class=\"mtk1\">.</span><span class=\"mtk12\">currency</span><span class=\"mtk1\">, </span><span class=\"mtk12\">_baseWeightCurrency</span><span class=\"mtk1\">, </span><span class=\"mtk12\">_decimals</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">388</span><span class=\"mtk1\">  </span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">389</span><span class=\"mtk1\">      </span><span class=\"mtk3\">// Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has.</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">390</span><span class=\"mtk1\">:     </span><span class=\"mtk12\">tokenCount</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">PRBMath</span><span class=\"mtk1\">.</span><span class=\"mtk11\">mulDiv</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_amount</span><span class=\"mtk1\">.</span><span class=\"mtk12\">value</span><span class=\"mtk1\">, </span><span class=\"mtk12\">_weight</span><span class=\"mtk1\">, </span><span class=\"mtk12\">_weightRatio</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p><a href=\"https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L385-L390\">https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L385-L390</a></p>\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-07-juicebox-v2-contest",
  "Code": [
    {
      "filename": "contracts/JBSingleTokenPaymentTerminalStore.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport '@paulrberg/contracts/math/PRBMath.sol';\nimport './interfaces/IJBController.sol';\nimport './interfaces/IJBSingleTokenPaymentTerminalStore.sol';\nimport './libraries/JBConstants.sol';\nimport './libraries/JBCurrencies.sol';\nimport './libraries/JBFixedPointNumber.sol';\nimport './libraries/JBFundingCycleMetadataResolver.sol';\n\n/**\n  @notice\n  Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal.\n\n  @dev\n  Adheres to:\n  IJBSingleTokenPaymentTerminalStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.\n\n  @dev\n  Inherits from -\n  ReentrancyGuard: Contract module that helps prevent reentrant calls to a function.\n*/\ncontract JBSingleTokenPaymentTerminalStore is IJBSingleTokenPaymentTerminalStore, ReentrancyGuard {\n  // A library that parses the packed funding cycle metadata into a friendlier format.\n  using JBFundingCycleMetadataResolver for JBFundingCycle;\n\n  //*********************************************************************//\n  // --------------------------- custom errors ------------------------- //\n  //*********************************************************************//\n  error CURRENCY_MISMATCH();\n  error DISTRIBUTION_AMOUNT_LIMIT_REACHED();\n  error FUNDING_CYCLE_PAYMENT_PAUSED();\n  error FUNDING_CYCLE_DISTRIBUTION_PAUSED();\n  error FUNDING_CYCLE_REDEEM_PAUSED();\n  error INADEQUATE_CONTROLLER_ALLOWANCE();\n  error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();\n  error INSUFFICIENT_TOKENS();\n  error INVALID_FUNDING_CYCLE();\n  error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();\n\n  //*********************************************************************//\n  // -------------------------- private constants ---------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers. \n  */\n  uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18;\n\n  //*********************************************************************//\n  // ---------------- public immutable stored properties --------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    The directory of terminals and controllers for projects.\n  */\n  IJBDirectory public immutable override directory;\n\n  /**\n    @notice\n    The contract storing all funding cycle configurations.\n  */\n  IJBFundingCycleStore public immutable override fundingCycleStore;\n\n  /**\n    @notice\n    The contract that exposes price feeds.\n  */\n  IJBPrices public immutable override prices;\n\n  //*********************************************************************//\n  // --------------------- public stored properties -------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    The amount of tokens that each project has for each terminal, in terms of the terminal's token.\n\n    @dev\n    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.\n\n    _terminal The terminal to which the balance applies.\n    _projectId The ID of the project to get the balance of.\n  */\n  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => uint256)) public override balanceOf;\n\n  /**\n    @notice\n    The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.\n\n    @dev\n    Increases as projects use their preconfigured distribution limits.\n\n    @dev\n    The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.\n\n    _terminal The terminal to which the used distribution limit applies.\n    _projectId The ID of the project to get the used distribution limit of.\n    _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.\n  */\n  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))\n    public\n    override usedDistributionLimitOf;\n\n  /**\n    @notice\n    The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.\n\n    @dev\n    Increases as projects use their allowance.\n\n    @dev\n    The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.\n\n    _terminal The terminal to which the overflow allowance applies.\n    _projectId The ID of the project to get the used overflow allowance of.\n    _configuration The configuration of the during which the allowance was used.\n  */\n  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))\n    public\n    override usedOverflowAllowanceOf;\n\n  //*********************************************************************//\n  // ------------------------- external views -------------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    Gets the current overflowed amount in a terminal for a specified project.\n\n    @dev\n    The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.\n\n    @param _terminal The terminal for which the overflow is being calculated.\n    @param _projectId The ID of the project to get overflow for.\n\n    @return The current amount of overflow that project has in the specified terminal.\n  */\n  function currentOverflowOf(IJBSingleTokenPaymentTerminal _terminal, uint256 _projectId)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    // Return the overflow during the project's current funding cycle.\n    return\n      _overflowDuring(\n        _terminal,\n        _projectId,\n        fundingCycleStore.currentOf(_projectId),\n        _terminal.currency()\n      );\n  }\n\n  /**\n    @notice\n    Gets the current overflowed amount for a specified project across all terminals.\n\n    @param _projectId The ID of the project to get total overflow for.\n    @param _decimals The number of decimals that the fixed point overflow should include.\n    @param _currency The currency that the total overflow should be in terms of.\n\n    @return The current total amount of overflow that project has across all terminals.\n  */\n  function currentTotalOverflowOf(\n    uint256 _projectId,\n    uint256 _decimals,\n    uint256 _currency\n  ) external view override returns (uint256) {\n    return _currentTotalOverflowOf(_projectId, _decimals, _currency);\n  }\n\n  /**\n    @notice\n    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.\n\n    @dev \n    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.\n\n    @dev\n    The current reclaimable overflow is returned in terms of the specified terminal's currency.\n\n    @dev\n    The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.\n\n    @param _terminal The terminal from which the reclaimable amount would come.\n    @param _projectId The ID of the project to get the reclaimable overflow amount for.\n    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.\n\n    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.\n  */\n  function currentReclaimableOverflowOf(\n    IJBSingleTokenPaymentTerminal _terminal,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    bool _useTotalOverflow\n  ) external view override returns (uint256) {\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Get the amount of current overflow.\n    // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal.\n    uint256 _currentOverflow = _useTotalOverflow\n      ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())\n      : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());\n\n    // If there's no overflow, there's no reclaimable overflow.\n    if (_currentOverflow == 0) return 0;\n\n    // Get the number of outstanding tokens the project has.\n    uint256 _totalSupply = IJBController(directory.controllerOf(_projectId))\n      .totalOutstandingTokensOf(_projectId, _fundingCycle.reservedRate());\n\n    // Can't redeem more tokens that is in the supply.\n    if (_tokenCount > _totalSupply) return 0;\n\n    // Return the reclaimable overflow amount.\n    return\n      _reclaimableOverflowDuring(\n        _projectId,\n        _fundingCycle,\n        _tokenCount,\n        _totalSupply,\n        _currentOverflow\n      );\n  }\n\n  /**\n    @notice\n    The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.\n\n    @dev \n    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.\n\n    @param _projectId The ID of the project to get the reclaimable overflow amount for.\n    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _overflow The amount of overflow to make the calculation with, as a fixed point number.\n\n    @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.\n  */\n  function currentReclaimableOverflowOf(\n    uint256 _projectId,\n    uint256 _tokenCount,\n    uint256 _totalSupply,\n    uint256 _overflow\n  ) external view override returns (uint256) {\n    // If there's no overflow, there's no reclaimable overflow.\n    if (_overflow == 0) return 0;\n\n    // Can't redeem more tokens that is in the supply.\n    if (_tokenCount > _totalSupply) return 0;\n\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Return the reclaimable overflow amount.\n    return\n      _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);\n  }\n\n  //*********************************************************************//\n  // -------------------------- constructor ---------------------------- //\n  //*********************************************************************//\n\n  /**\n    @param _directory A contract storing directories of terminals and controllers for each project.\n    @param _fundingCycleStore A contract storing all funding cycle configurations.\n    @param _prices A contract that exposes price feeds.\n  */\n  constructor(\n    IJBDirectory _directory,\n    IJBFundingCycleStore _fundingCycleStore,\n    IJBPrices _prices\n  ) {\n    directory = _directory;\n    fundingCycleStore = _fundingCycleStore;\n    prices = _prices;\n  }\n\n  //*********************************************************************//\n  // ---------------------- external transactions ---------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    Records newly contributed tokens to a project.\n\n    @dev\n    Mint's the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.\n\n    @param _payer The original address that sent the payment to the terminal.\n    @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount.\n    @param _projectId The ID of the project being paid.\n    @param _baseWeightCurrency The currency to base token issuance on.\n    @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment.\n    @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source.\n    @param _metadata Bytes to send along to the data source, if one is provided.\n\n    @return fundingCycle The project's funding cycle during which payment was made.\n    @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.\n    @return delegate A delegate contract to use for subsequent calls.\n    @return memo A memo that should be passed along to the emitted event.\n  */\n  function recordPaymentFrom(\n    address _payer,\n    JBTokenAmount calldata _amount,\n    uint256 _projectId,\n    uint256 _baseWeightCurrency,\n    address _beneficiary,\n    string calldata _memo,\n    bytes memory _metadata\n  )\n    external\n    override\n    nonReentrant\n    returns (\n      JBFundingCycle memory fundingCycle,\n      uint256 tokenCount,\n      IJBPayDelegate delegate,\n      string memory memo\n    )\n  {\n    // Get a reference to the current funding cycle for the project.\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // The project must have a funding cycle configured.\n    if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();\n\n    // Must not be paused.\n    if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();\n\n    // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.\n    uint256 _weight;\n\n    // If the funding cycle has configured a data source, use it to derive a weight and memo.\n    if (fundingCycle.useDataSourceForPay()) {\n      // Create the params that'll be sent to the data source.\n      JBPayParamsData memory _data = JBPayParamsData(\n        IJBSingleTokenPaymentTerminal(msg.sender),\n        _payer,\n        _amount,\n        _projectId,\n        fundingCycle.configuration,\n        _beneficiary,\n        fundingCycle.weight,\n        fundingCycle.reservedRate(),\n        _memo,\n        _metadata\n      );\n      (_weight, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource()).payParams(\n        _data\n      );\n    }\n    // Otherwise use the funding cycle's weight\n    else {\n      _weight = fundingCycle.weight;\n      memo = _memo;\n    }\n\n    // If there's no amount being recorded, there's nothing left to do.\n    if (_amount.value == 0) return (fundingCycle, 0, delegate, memo);\n\n    // Add the amount to the token balance of the project.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +\n      _amount.value;\n\n    // If there's no weight, token count must be 0 so there's nothing left to do.\n    if (_weight == 0) return (fundingCycle, 0, delegate, memo);\n\n    // Get a reference to the number of decimals in the amount. (prevents stack too deep).\n    uint256 _decimals = _amount.decimals;\n\n    // If the terminal should base its weight on a different currency from the terminal's currency, determine the factor.\n    // The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the same number of decimals as the `_amount`.\n    uint256 _weightRatio = _amount.currency == _baseWeightCurrency\n      ? 10**_decimals\n      : prices.priceFor(_amount.currency, _baseWeightCurrency, _decimals);\n\n    // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has.\n    tokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);\n  }\n\n  /**\n    @notice\n    Records newly redeemed tokens of a project.\n\n    @dev\n    Redeems the project's tokens according to values provided by a configured data source. If no data source is configured, redeems tokens along a redemption bonding curve that is a function of the number of tokens being burned.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.senders tokens.\n\n    @param _holder The account that is having its tokens redeemed.\n    @param _projectId The ID of the project to which the tokens being redeemed belong.\n    @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.\n    @param _memo A memo to pass along to the emitted event.\n    @param _metadata Bytes to send along to the data source, if one is provided.\n\n    @return fundingCycle The funding cycle during which the redemption was made.\n    @return reclaimAmount The amount of terminal tokens reclaimed, as a fixed point number with 18 decimals.\n    @return delegate A delegate contract to use for subsequent calls.\n    @return memo A memo that should be passed along to the emitted event.\n  */\n  function recordRedemptionFor(\n    address _holder,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    string memory _memo,\n    bytes memory _metadata\n  )\n    external\n    override\n    nonReentrant\n    returns (\n      JBFundingCycle memory fundingCycle,\n      uint256 reclaimAmount,\n      IJBRedemptionDelegate delegate,\n      string memory memo\n    )\n  {\n    // Get a reference to the project's current funding cycle.\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // The current funding cycle must not be paused.\n    if (fundingCycle.redeemPaused()) revert FUNDING_CYCLE_REDEEM_PAUSED();\n\n    // Scoped section prevents stack too deep. `_reclaimedTokenAmount`, `_currentOverflow`, and `_totalSupply` only used within scope.\n    {\n      // Get a reference to the reclaimed token amount struct, the current overflow, and the total token supply.\n      JBTokenAmount memory _reclaimedTokenAmount;\n      uint256 _currentOverflow;\n      uint256 _totalSupply;\n\n      // Another scoped section prevents stack too deep. `_token`, `_decimals`, and `_currency` only used within scope.\n      {\n        // Get a reference to the terminal's tokens.\n        address _token = IJBSingleTokenPaymentTerminal(msg.sender).token();\n\n        // Get a reference to the terminal's decimals.\n        uint256 _decimals = IJBSingleTokenPaymentTerminal(msg.sender).decimals();\n\n        // Get areference to the terminal's currency.\n        uint256 _currency = IJBSingleTokenPaymentTerminal(msg.sender).currency();\n\n        // Get the amount of current overflow.\n        // Use the local overflow if the funding cycle specifies that it should be used. Otherwise, use the project's total overflow across all of its terminals.\n        _currentOverflow = fundingCycle.useTotalOverflowForRedemptions()\n          ? _currentTotalOverflowOf(_projectId, _decimals, _currency)\n          : _overflowDuring(\n            IJBSingleTokenPaymentTerminal(msg.sender),\n            _projectId,\n            fundingCycle,\n            _currency\n          );\n\n        // Get the number of outstanding tokens the project has.\n        _totalSupply = IJBController(directory.controllerOf(_projectId)).totalOutstandingTokensOf(\n          _projectId,\n          fundingCycle.reservedRate()\n        );\n\n        // Can't redeem more tokens that is in the supply.\n        if (_tokenCount > _totalSupply) revert INSUFFICIENT_TOKENS();\n\n        if (_currentOverflow > 0)\n          // Calculate reclaim amount using the current overflow amount.\n          reclaimAmount = _reclaimableOverflowDuring(\n            _projectId,\n            fundingCycle,\n            _tokenCount,\n            _totalSupply,\n            _currentOverflow\n          );\n\n        _reclaimedTokenAmount = JBTokenAmount(_token, reclaimAmount, _decimals, _currency);\n      }\n\n      // If the funding cycle has configured a data source, use it to derive a claim amount and memo.\n      if (fundingCycle.useDataSourceForRedeem()) {\n        // Create the params that'll be sent to the data source.\n        JBRedeemParamsData memory _data = JBRedeemParamsData(\n          IJBSingleTokenPaymentTerminal(msg.sender),\n          _holder,\n          _projectId,\n          fundingCycle.configuration,\n          _tokenCount,\n          _totalSupply,\n          _currentOverflow,\n          _reclaimedTokenAmount,\n          fundingCycle.useTotalOverflowForRedemptions(),\n          fundingCycle.redemptionRate(),\n          fundingCycle.ballotRedemptionRate(),\n          _memo,\n          _metadata\n        );\n        (reclaimAmount, memo, delegate) = IJBFundingCycleDataSource(fundingCycle.dataSource())\n          .redeemParams(_data);\n      } else {\n        memo = _memo;\n      }\n    }\n\n    // The amount being reclaimed must be within the project's balance.\n    if (reclaimAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])\n      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();\n\n    // Remove the reclaimed funds from the project's balance.\n    if (reclaimAmount > 0)\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n        balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -\n        reclaimAmount;\n  }\n\n  /**\n    @notice\n    Records newly distributed funds for a project.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. \n\n    @param _projectId The ID of the project that is having funds distributed.\n    @param _amount The amount to use from the distribution limit, as a fixed point number.\n    @param _currency The currency of the `_amount`. This must match the project's current funding cycle's currency.\n\n    @return fundingCycle The funding cycle during which the distribution was made.\n    @return distributedAmount The amount of terminal tokens distributed, as a fixed point number with the same amount of decimals as its relative terminal.\n  */\n  function recordDistributionFor(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency\n  )\n    external\n    override\n    nonReentrant\n    returns (JBFundingCycle memory fundingCycle, uint256 distributedAmount)\n  {\n    // Get a reference to the project's current funding cycle.\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // The funding cycle must not be configured to have distributions paused.\n    if (fundingCycle.distributionsPaused()) revert FUNDING_CYCLE_DISTRIBUTION_PAUSED();\n\n    // The new total amount that has been distributed during this funding cycle.\n    uint256 _newUsedDistributionLimitOf = usedDistributionLimitOf[\n      IJBSingleTokenPaymentTerminal(msg.sender)\n    ][_projectId][fundingCycle.number] + _amount;\n\n    // Amount must be within what is still distributable.\n    (uint256 _distributionLimitOf, uint256 _distributionLimitCurrencyOf) = IJBController(\n      directory.controllerOf(_projectId)\n    ).distributionLimitOf(\n        _projectId,\n        fundingCycle.configuration,\n        IJBSingleTokenPaymentTerminal(msg.sender),\n        IJBSingleTokenPaymentTerminal(msg.sender).token()\n      );\n\n    // Make sure the new used amount is within the distribution limit.\n    if (_newUsedDistributionLimitOf > _distributionLimitOf || _distributionLimitOf == 0)\n      revert DISTRIBUTION_AMOUNT_LIMIT_REACHED();\n\n    // Make sure the currencies match.\n    if (_currency != _distributionLimitCurrencyOf) revert CURRENCY_MISMATCH();\n\n    // Get a reference to the terminal's currency.\n    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();\n\n    // Convert the amount to the balance's currency.\n    distributedAmount = (_currency == _balanceCurrency)\n      ? _amount\n      : PRBMath.mulDiv(\n        _amount,\n        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.\n        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)\n      );\n\n    // The amount being distributed must be available.\n    if (distributedAmount > balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId])\n      revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();\n\n    // Store the new amount.\n    usedDistributionLimitOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][\n      fundingCycle.number\n    ] = _newUsedDistributionLimitOf;\n\n    // Removed the distributed funds from the project's token balance.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -\n      distributedAmount;\n  }\n\n  /**\n    @notice\n    Records newly used allowance funds of a project.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. \n\n    @param _projectId The ID of the project to use the allowance of.\n    @param _amount The amount to use from the allowance, as a fixed point number. \n    @param _currency The currency of the `_amount`. Must match the currency of the overflow allowance.\n\n    @return fundingCycle The funding cycle during which the overflow allowance is being used.\n    @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals as its relative terminal.\n  */\n  function recordUsedAllowanceOf(\n    uint256 _projectId,\n    uint256 _amount,\n    uint256 _currency\n  )\n    external\n    override\n    nonReentrant\n    returns (JBFundingCycle memory fundingCycle, uint256 usedAmount)\n  {\n    // Get a reference to the project's current funding cycle.\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Get a reference to the new used overflow allowance for this funding cycle configuration.\n    uint256 _newUsedOverflowAllowanceOf = usedOverflowAllowanceOf[\n      IJBSingleTokenPaymentTerminal(msg.sender)\n    ][_projectId][fundingCycle.configuration] + _amount;\n\n    // There must be sufficient allowance available.\n    (uint256 _overflowAllowanceOf, uint256 _overflowAllowanceCurrency) = IJBController(\n      directory.controllerOf(_projectId)\n    ).overflowAllowanceOf(\n        _projectId,\n        fundingCycle.configuration,\n        IJBSingleTokenPaymentTerminal(msg.sender),\n        IJBSingleTokenPaymentTerminal(msg.sender).token()\n      );\n\n    // Make sure the new used amount is within the allowance.\n    if (_newUsedOverflowAllowanceOf > _overflowAllowanceOf || _overflowAllowanceOf == 0)\n      revert INADEQUATE_CONTROLLER_ALLOWANCE();\n\n    // Make sure the currencies match.\n    if (_currency != _overflowAllowanceCurrency) revert CURRENCY_MISMATCH();\n\n    // Get a reference to the terminal's currency.\n    uint256 _balanceCurrency = IJBSingleTokenPaymentTerminal(msg.sender).currency();\n\n    // Convert the amount to this store's terminal's token.\n    usedAmount = (_currency == _balanceCurrency)\n      ? _amount\n      : PRBMath.mulDiv(\n        _amount,\n        10**_MAX_FIXED_POINT_FIDELITY, // Use _MAX_FIXED_POINT_FIDELITY to keep as much of the `_amount.value`'s fidelity as possible when converting.\n        prices.priceFor(_currency, _balanceCurrency, _MAX_FIXED_POINT_FIDELITY)\n      );\n\n    // The amount being distributed must be available in the overflow.\n    if (\n      usedAmount >\n      _overflowDuring(\n        IJBSingleTokenPaymentTerminal(msg.sender),\n        _projectId,\n        fundingCycle,\n        _balanceCurrency\n      )\n    ) revert INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();\n\n    // Store the incremented value.\n    usedOverflowAllowanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId][\n      fundingCycle.configuration\n    ] = _newUsedOverflowAllowanceOf;\n\n    // Update the project's balance.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] -\n      usedAmount;\n  }\n\n  /**\n    @notice\n    Records newly added funds for the project.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. \n\n    @param _projectId The ID of the project to which the funds being added belong.\n    @param _amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as its relative terminal.\n  */\n  function recordAddedBalanceFor(uint256 _projectId, uint256 _amount) external override {\n    // Increment the balance.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] =\n      balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] +\n      _amount;\n  }\n\n  /**\n    @notice\n    Records the migration of funds from this store.\n\n    @dev\n    The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount returned is in terms of the msg.senders tokens.\n\n    @param _projectId The ID of the project being migrated.\n\n    @return balance The project's migrated balance, as a fixed point number with the same amount of decimals as its relative terminal.\n  */\n  function recordMigration(uint256 _projectId)\n    external\n    override\n    nonReentrant\n    returns (uint256 balance)\n  {\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Migration must be allowed.\n    if (!_fundingCycle.terminalMigrationAllowed()) revert PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();\n\n    // Return the current balance.\n    balance = balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId];\n\n    // Set the balance to 0.\n    balanceOf[IJBSingleTokenPaymentTerminal(msg.sender)][_projectId] = 0;\n  }\n\n  //*********************************************************************//\n  // --------------------- private helper functions -------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    The amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens when measured from the specified.\n\n    @dev \n    If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.\n\n    @param _projectId The ID of the project to get the reclaimable overflow amount for.\n    @param _fundingCycle The funding cycle during which reclaimable overflow is being calculated.\n    @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    @param _overflow The amount of overflow to make the calculation with.\n\n    @return The amount of overflowed tokens that can be reclaimed.\n  */\n  function _reclaimableOverflowDuring(\n    uint256 _projectId,\n    JBFundingCycle memory _fundingCycle,\n    uint256 _tokenCount,\n    uint256 _totalSupply,\n    uint256 _overflow\n  ) private view returns (uint256) {\n    // If the amount being redeemed is the total supply, return the rest of the overflow.\n    if (_tokenCount == _totalSupply) return _overflow;\n\n    // Use the ballot redemption rate if the queued cycle is pending approval according to the previous funding cycle's ballot.\n    uint256 _redemptionRate = fundingCycleStore.currentBallotStateOf(_projectId) ==\n      JBBallotState.Active\n      ? _fundingCycle.ballotRedemptionRate()\n      : _fundingCycle.redemptionRate();\n\n    // If the redemption rate is 0, nothing is claimable.\n    if (_redemptionRate == 0) return 0;\n\n    // Get a reference to the linear proportion.\n    uint256 _base = PRBMath.mulDiv(_overflow, _tokenCount, _totalSupply);\n\n    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.\n    if (_redemptionRate == JBConstants.MAX_REDEMPTION_RATE) return _base;\n\n    return\n      PRBMath.mulDiv(\n        _base,\n        _redemptionRate +\n          PRBMath.mulDiv(\n            _tokenCount,\n            JBConstants.MAX_REDEMPTION_RATE - _redemptionRate,\n            _totalSupply\n          ),\n        JBConstants.MAX_REDEMPTION_RATE\n      );\n  }\n\n  /**\n    @notice\n    Gets the amount that is overflowing when measured from the specified funding cycle.\n\n    @dev\n    This amount changes as the value of the balance changes in relation to the currency being used to measure the distribu"
    }
  ]
}