{
  "Title": "[G-03] Avoiding the overhead of `bool` storage",
  "Content": "\nSaves `120600 GAS` in 6 instances.\n\n```\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n```\n\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27\n\nUse `uint256(1)` and `uint256(2)` for true/false to avoid a `Gwarmaccess` `(100 gas)` for the extra `SLOAD`, and to avoid `Gsset` `(20000 gas)` when changing from false to true, after having been true in the past.\n\n```solidity\nFILE: 2023-07-axelar/contracts/cgp/auth/MultisigBase.sol\n\n15: mapping(address => bool) hasVoted;\n21: mapping(address => bool) isSigner;\n```\n\nhttps://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/cgp/auth/MultisigBase.sol#L15\n\n```solidity\nFILE: 2023-07-axelar/contracts/cgp/governance/AxelarServiceGovernance.sol\n\n22: mapping(bytes32 => bool) public multisigApprovals;\n```\n\nhttps://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/cgp/governance/AxelarServiceGovernance.sol#L22\n\n```solidity\nFILE: 2023-07-axelar/contracts/interchain-governance-executor/InterchainProposalExecutor.sol\n\n24: mapping(string => mapping(address => bool)) public whitelistedCallers;\n27: mapping(string => mapping(address => bool)) public whitelistedSenders;\n```\n\nhttps://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/interchain-governance-executor/InterchainProposalExecutor.sol#L24\n\n```solidity\nFILE: 2023-07-axelar/contracts/its/remote-address-validator/RemoteAddressValidator.sol\n\n19: mapping(string => bool) public supportedByGateway;\n```\n\nhttps://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/its/remote-address-validator/RemoteAddressValidator.sol#L19\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-07-axelar",
  "Code": [
    {
      "filename": "contracts/security/ReentrancyGuard.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}"
    },
    {
      "filename": "contracts/cgp/auth/MultisigBase.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IMultisigBase } from '../interfaces/IMultisigBase.sol';\n\n/**\n * @title MultisigBase Contract\n * @notice This contract implements a custom multisignature wallet where transactions must be confirmed by a\n * threshold of signers. The signers and threshold may be updated every `epoch`.\n */\ncontract MultisigBase is IMultisigBase {\n    struct Voting {\n        uint256 voteCount;\n        mapping(address => bool) hasVoted;\n    }\n\n    struct Signers {\n        address[] accounts;\n        uint256 threshold;\n        mapping(address => bool) isSigner;\n    }\n\n    Signers public signers;\n    uint256 public signerEpoch;\n    // uint256 is for epoch, bytes32 for vote topic hash\n    mapping(uint256 => mapping(bytes32 => Voting)) public votingPerTopic;\n\n    /**\n     * @notice Contract constructor\n     * @dev Sets the initial list of signers and corresponding threshold.\n     * @param accounts Address array of the signers\n     * @param threshold Signature threshold required to validate a transaction\n     */\n    constructor(address[] memory accounts, uint256 threshold) {\n        _rotateSigners(accounts, threshold);\n    }\n\n    /**\n     * @notice Modifier to ensure the caller is a signer\n     * @dev Keeps track of votes for each operation and resets the vote count if the operation is executed.\n     * @dev Given the early void return, this modifier should be used with care on functions that return data.\n     */\n    modifier onlySigners() {\n        if (!signers.isSigner[msg.sender]) revert NotSigner();\n\n        bytes32 topic = keccak256(msg.data);\n        Voting storage voting = votingPerTopic[signerEpoch][topic];\n\n        // Check that signer has not voted, then record that they have voted.\n        if (voting.hasVoted[msg.sender]) revert AlreadyVoted();\n\n        voting.hasVoted[msg.sender] = true;\n\n        // Determine the new vote count.\n        uint256 voteCount = voting.voteCount + 1;\n\n        // Do not proceed with operation execution if insufficient votes.\n        if (voteCount < signers.threshold) {\n            // Save updated vote count.\n            voting.voteCount = voteCount;\n            return;\n        }\n\n        // Clear vote count and voted booleans.\n        voting.voteCount = 0;\n\n        uint256 count = signers.accounts.length;\n\n        for (uint256 i; i < count; ++i) {\n            voting.hasVoted[signers.accounts[i]] = false;\n        }\n\n        emit MultisigOperationExecuted(topic);\n\n        _;\n    }\n\n    /******************\\\n    |* Public Getters *|\n    \\******************/\n\n    /**\n     * @notice Returns the current signer threshold\n     * @return uint The signer threshold\n     */\n    function signerThreshold() external view override returns (uint256) {\n        return signers.threshold;\n    }\n\n    /**\n     * @notice Returns an array of current signers\n     * @return array of signer addresses\n     */\n    function signerAccounts() external view override returns (address[] memory) {\n        return signers.accounts;\n    }\n\n    /**\n     * @notice Getter to determine if an account is a signer\n     * @return boolean indicating if the account is a signer\n     */\n    function isSigner(address account) external view override returns (bool) {\n        return signers.isSigner[account];\n    }\n\n    /**\n     * @notice Getter to determine if an account has voted on a topic\n     * @return boolean indicating if the account has voted\n     */\n    function hasSignerVoted(address account, bytes32 topic) external view override returns (bool) {\n        return votingPerTopic[signerEpoch][topic].hasVoted[account];\n    }\n\n    /**\n     * @notice Get the number of votes for a topic\n     * @return uint256 indicating the number of votes for a topic\n     */\n    function getSignerVotesCount(bytes32 topic) external view override returns (uint256) {\n        uint256 length = signers.accounts.length;\n        uint256 voteCount;\n        for (uint256 i; i < length; ++i) {\n            if (votingPerTopic[signerEpoch][topic].hasVoted[signers.accounts[i]]) {\n                voteCount++;\n            }\n        }\n\n        return voteCount;\n    }\n\n    /***********\\\n    |* Setters *|\n    \\***********/\n\n    /**\n     * @notice Rotate the signers for the multisig\n     * @dev Updates the current set of signers and threshold and increments the `epoch`\n     * @dev This function is protected by the onlySigners modifier\n     * @param newAccounts Address array of the new signers\n     * @param newThreshold The new signature threshold for executing operations\n     */\n    function rotateSigners(address[] memory newAccounts, uint256 newThreshold) external virtual onlySigners {\n        _rotateSigners(newAccounts, newThreshold);\n    }\n\n    /**\n     * @dev Internal function that implements signer rotation logic\n     */\n    function _rotateSigners(address[] memory newAccounts, uint256 newThreshold) internal {\n        uint256 length = signers.accounts.length;\n\n        // Clean up old signers.\n        for (uint256 i; i < length; ++i) {\n            signers.isSigner[signers.accounts[i]] = false;\n        }\n\n        length = newAccounts.length;\n\n        if (newThreshold > length) revert InvalidSigners();\n\n        if (newThreshold == 0) revert InvalidSignerThreshold();\n\n        ++signerEpoch;\n\n        signers.accounts = newAccounts;\n        signers.threshold = newThreshold;\n\n        for (uint256 i; i < length; ++i) {\n            address account = newAccounts[i];\n\n            // Check that the account wasn't already set as a signer for this epoch.\n            if (signers.isSigner[account]) revert DuplicateSigner(account);\n            if (account == address(0)) revert InvalidSigners();\n\n            signers.isSigner[account] = true;\n        }\n\n        emit SignersRotated(newAccounts, newThreshold);\n    }\n}"
    },
    {
      "filename": "contracts/cgp/governance/AxelarServiceGovernance.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IAxelarServiceGovernance } from '../interfaces/IAxelarServiceGovernance.sol';\nimport { InterchainGovernance } from './InterchainGovernance.sol';\nimport { MultisigBase } from '../auth/MultisigBase.sol';\n\n/**\n * @title AxelarServiceGovernance Contract\n * @dev This contract is part of the Axelar Governance system, it inherits the Interchain Governance contract\n * with added functionality to approve and execute multisig proposals.\n */\ncontract AxelarServiceGovernance is InterchainGovernance, MultisigBase, IAxelarServiceGovernance {\n    enum ServiceGovernanceCommand {\n        ScheduleTimeLockProposal,\n        CancelTimeLockProposal,\n        ApproveMultisigProposal,\n        CancelMultisigApproval\n    }\n\n    mapping(bytes32 => bool) public multisigApprovals;\n\n    /**\n     * @notice Initializes the contract.\n     * @param gateway The address of the Axelar gateway contract\n     * @param governanceChain The name of the governance chain\n     * @param governanceAddress The address of the governance contract\n     * @param minimumTimeDelay The minimum time delay for timelock operations\n     * @param cosigners The list of initial signers\n     * @param threshold The number of required signers to validate a transaction\n     */\n    constructor(\n        address gateway,\n        string memory governanceChain,\n        string memory governanceAddress,\n        uint256 minimumTimeDelay,\n        address[] memory cosigners,\n        uint256 threshold\n    ) InterchainGovernance(gateway, governanceChain, governanceAddress, minimumTimeDelay) MultisigBase(cosigners, threshold) {}\n\n    /**\n     * @notice Executes a multisig proposal.\n     * @param target The target address the proposal will call\n     * @param callData The data that encodes the function and arguments to call on the target contract\n     * @param nativeValue The value of native token to be sent to the target contract\n     */\n    function executeMultisigProposal(\n        address target,\n        bytes calldata callData,\n        uint256 nativeValue\n    ) external payable onlySigners {\n        bytes32 proposalHash = keccak256(abi.encodePacked(target, callData, nativeValue));\n\n        if (!multisigApprovals[proposalHash]) revert NotApproved();\n\n        multisigApprovals[proposalHash] = false;\n\n        _call(target, callData, nativeValue);\n\n        emit MultisigExecuted(proposalHash, target, callData, nativeValue);\n    }\n\n    /**\n     * @notice Internal function to process a governance command\n     * @param commandId The id of the command\n     * @param target The target address the proposal will call\n     * @param callData The data the encodes the function and arguments to call on the target contract\n     * @param nativeValue The value of native token to be sent to the target contract\n     * @param eta The time after which the proposal can be executed\n     */\n    function _processCommand(\n        uint256 commandId,\n        address target,\n        bytes memory callData,\n        uint256 nativeValue,\n        uint256 eta\n    ) internal override {\n        if (commandId > uint256(type(ServiceGovernanceCommand).max)) {\n            revert InvalidCommand();\n        }\n\n        ServiceGovernanceCommand command = ServiceGovernanceCommand(commandId);\n        bytes32 proposalHash = keccak256(abi.encodePacked(target, callData, nativeValue));\n\n        if (command == ServiceGovernanceCommand.ScheduleTimeLockProposal) {\n            eta = _scheduleTimeLock(proposalHash, eta);\n\n            emit ProposalScheduled(proposalHash, target, callData, nativeValue, eta);\n            return;\n        } else if (command == ServiceGovernanceCommand.CancelTimeLockProposal) {\n            _cancelTimeLock(proposalHash);\n\n            emit ProposalCancelled(proposalHash, target, callData, nativeValue, eta);\n            return;\n        } else if (command == ServiceGovernanceCommand.ApproveMultisigProposal) {\n            multisigApprovals[proposalHash] = true;\n\n            emit MultisigApproved(proposalHash, target, callData, nativeValue);\n            return;\n        } else if (command == ServiceGovernanceCommand.CancelMultisigApproval) {\n            multisigApprovals[proposalHash] = false;\n\n            emit MultisigCancelled(proposalHash, target, callData, nativeValue);\n            return;\n        }\n    }\n}"
    },
    {
      "filename": "contracts/interchain-governance-executor/InterchainProposalExecutor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Ownable } from '@openzeppelin/contracts/access/Ownable.sol';\nimport { StringToAddress } from '../gmp-sdk/util/AddressString.sol';\nimport { AxelarExecutable } from '../gmp-sdk/executable/AxelarExecutable.sol';\nimport { IInterchainProposalExecutor } from './interfaces/IInterchainProposalExecutor.sol';\nimport { InterchainCalls } from './lib/InterchainCalls.sol';\n\n/**\n * @title InterchainProposalExecutor\n * @dev This contract is intended to be the destination contract for `InterchainProposalSender` contract.\n * The proposal will be finally executed from this contract on the destination chain.\n *\n * The contract maintains whitelists for proposal senders and proposal callers. Proposal senders\n * are InterchainProposalSender contracts at the source chain and proposal callers are contracts\n * that call the InterchainProposalSender at the source chain.\n * For most governance system, the proposal caller should be the Timelock contract.\n *\n * This contract is abstract and some of its functions need to be implemented in a derived contract.\n */\ncontract InterchainProposalExecutor is IInterchainProposalExecutor, AxelarExecutable, Ownable {\n    // Whitelisted proposal callers. The proposal caller is the contract that calls the `InterchainProposalSender` at the source chain.\n    mapping(string => mapping(address => bool)) public whitelistedCallers;\n\n    // Whitelisted proposal senders. The proposal sender is the `InterchainProposalSender` contract address at the source chain.\n    mapping(string => mapping(address => bool)) public whitelistedSenders;\n\n    constructor(address _gateway, address _owner) AxelarExecutable(_gateway) {\n        _transferOwnership(_owner);\n    }\n\n    /**\n     * @dev Executes the proposal. The source address must be a whitelisted sender.\n     * @param sourceAddress The source address\n     * @param payload The payload. It is ABI encoded of the caller and calls.\n     * Where:\n     * - `caller` is the address that calls the `InterchainProposalSender` at the source chain.\n     * - `calls` is the array of `InterchainCalls.Call` to execute. Each call contains the target, value, signature and data.\n     */\n    function _execute(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) internal override {\n        _beforeProposalExecuted(sourceChain, sourceAddress, payload);\n\n        // Check that the source address is whitelisted\n        if (!whitelistedSenders[sourceChain][StringToAddress.toAddress(sourceAddress)]) {\n            revert NotWhitelistedSourceAddress();\n        }\n\n        // Decode the payload\n        (address interchainProposalCaller, InterchainCalls.Call[] memory calls) = abi.decode(payload, (address, InterchainCalls.Call[]));\n\n        // Check that the caller is whitelisted\n        if (!whitelistedCallers[sourceChain][interchainProposalCaller]) {\n            revert NotWhitelistedCaller();\n        }\n\n        // Execute the proposal with the given arguments\n        _executeProposal(calls);\n\n        _onProposalExecuted(sourceChain, sourceAddress, interchainProposalCaller, payload);\n\n        emit ProposalExecuted(keccak256(abi.encode(sourceChain, sourceAddress, interchainProposalCaller, payload)));\n    }\n\n    /**\n     * @dev Executes the proposal. Calls each target with the respective value, signature, and data.\n     * @param calls The calls to execute.\n     */\n    function _executeProposal(InterchainCalls.Call[] memory calls) internal {\n        for (uint256 i = 0; i < calls.length; i++) {\n            InterchainCalls.Call memory call = calls[i];\n            (bool success, bytes memory result) = call.target.call{ value: call.value }(call.callData);\n\n            if (!success) {\n                _onTargetExecutionFailed(call, result);\n            } else {\n                _onTargetExecuted(call, result);\n            }\n        }\n    }\n\n    /**\n     * @dev Set the proposal caller whitelist status\n     * @param sourceChain The source chain\n     * @param sourceCaller The source caller\n     * @param whitelisted The whitelist status\n     */\n    function setWhitelistedProposalCaller(\n        string calldata sourceChain,\n        address sourceCaller,\n        bool whitelisted\n    ) external override onlyOwner {\n        whitelistedCallers[sourceChain][sourceCaller] = whitelisted;\n        emit WhitelistedProposalCallerSet(sourceChain, sourceCaller, whitelisted);\n    }\n\n    /**\n     * @dev Set the proposal sender whitelist status\n     * @param sourceChain The source chain\n     * @param sourceSender The source sender\n     * @param whitelisted The whitelist status\n     */\n    function setWhitelistedProposalSender(\n        string calldata sourceChain,\n        address sourceSender,\n        bool whitelisted\n    ) external override onlyOwner {\n        whitelistedSenders[sourceChain][sourceSender] = whitelisted;\n        emit WhitelistedProposalSenderSet(sourceChain, sourceSender, whitelisted);\n    }\n\n    /**\n     * @dev A callback function that is called before the proposal is executed.\n     * This function can be used to handle the payload before the proposal is executed.\n     * @param sourceChain The source chain from where the proposal was sent.\n     * @param sourceAddress The source address that sent the proposal. The source address should be the `InterchainProposalSender` contract address at the source chain.\n     * @param payload The payload. It is ABI encoded of the caller and calls.\n     * Where:\n     * - `caller` is the address that calls the `InterchainProposalSender` at the source chain.\n     * - `calls` is the array of `InterchainCalls.Call` to execute. Each call contains the target, value, calldata.\n     */\n    function _beforeProposalExecuted(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) internal virtual {\n        // You can add your own logic here to handle the payload before the proposal is executed.\n    }\n\n    /**\n     * @dev A callback function that is called after the proposal is executed.\n     * This function emits an event containing the hash of the payload to signify successful execution.\n     * @param payload The payload. It is ABI encoded of the caller and calls.\n     * Where:\n     * - `caller` is the address that calls the `InterchainProposalSender` at the source chain.\n     * - `calls` is the array of `InterchainCalls.Call` to execute. Each call contains the target, value, signature and data.\n     */\n    function _onProposalExecuted(\n        string calldata, /* sourceChain */\n        string calldata, /* sourceAddress */\n        address, /* caller */\n        bytes calldata payload\n    ) internal virtual {\n        // You can add your own logic here to handle the payload after the proposal is executed.\n    }\n\n    /**\n     * @dev A callback function that is called when the execution of a target contract within a proposal fails.\n     * This function will revert the transaction providing the failure reason if present in the failure data.\n     * @param result The return data from the failed call to the target contract.\n     */\n    function _onTargetExecutionFailed(\n        InterchainCalls.Call memory, /* call */\n        bytes memory result\n    ) internal virtual {\n        // You can add your own logic here to handle the failure of the target contract execution. The code below is just an example.\n        if (result.length > 0) {\n            // The failure data is a revert reason string.\n            assembly {\n                revert(add(32, result), mload(result))\n            }\n        } else {\n            // There is no failure data, just revert with no reason.\n            revert ProposalExecuteFailed();\n        }\n    }\n\n    /**\n     * @dev Called after a target is successfully executed. The derived contract should implement this function.\n     * This function should do some post-execution work, such as emitting events.\n     * @param call The call that has been executed.\n     * @param result The result of the call.\n     */\n    function _onTargetExecuted(InterchainCalls.Call memory call, bytes memory result) internal virtual {\n        // You can add your own logic here to handle the success of each target contract execution.\n    }\n}"
    },
    {
      "filename": "contracts/its/remote-address-validator/RemoteAddressValidator.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport { IRemoteAddressValidator } from '../interfaces/IRemoteAddressValidator.sol';\nimport { AddressToString } from '../../gmp-sdk/util/AddressString.sol';\nimport { Upgradable } from '../../gmp-sdk/upgradable/Upgradable.sol';\n\n/**\n * @title RemoteAddressValidator\n * @dev Manages and validates remote addresses, keeps track of addresses supported by the Axelar gateway contract\n */\ncontract RemoteAddressValidator is IRemoteAddressValidator, Upgradable {\n    using AddressToString for address;\n\n    mapping(string => bytes32) public remoteAddressHashes;\n    mapping(string => string) public remoteAddresses;\n    address public immutable interchainTokenServiceAddress;\n    bytes32 public immutable interchainTokenServiceAddressHash;\n    mapping(string => bool) public supportedByGateway;\n\n    bytes32 private constant CONTRACT_ID = keccak256('remote-address-validator');\n\n    /**\n     * @dev Constructs the RemoteAddressValidator contract, both array parameters must be equal in length\n     * @param _interchainTokenServiceAddress Address of the interchain token service\n     */\n    constructor(address _interchainTokenServiceAddress) {\n        if (_interchainTokenServiceAddress == address(0)) revert ZeroAddress();\n        interchainTokenServiceAddress = _interchainTokenServiceAddress;\n        interchainTokenServiceAddressHash = keccak256(bytes(_lowerCase(interchainTokenServiceAddress.toString())));\n    }\n\n    /**\n     * @notice Getter for the contract id.\n     */\n    function contractId() external pure returns (bytes32) {\n        return CONTRACT_ID;\n    }\n\n    function _setup(bytes calldata params) internal override {\n        (string[] memory trustedChainNames, string[] memory trustedAddresses) = abi.decode(params, (string[], string[]));\n        uint256 length = trustedChainNames.length;\n        if (length != trustedAddresses.length) revert LengthMismatch();\n        for (uint256 i; i < length; ++i) {\n            addTrustedAddress(trustedChainNames[i], trustedAddresses[i]);\n        }\n    }\n\n    /**\n     * @dev Converts a string to lower case\n     * @param s Input string to be converted\n     * @return string lowercase version of the input string\n     */\n    function _lowerCase(string memory s) internal pure returns (string memory) {\n        uint256 length = bytes(s).length;\n        for (uint256 i; i < length; i++) {\n            uint8 b = uint8(bytes(s)[i]);\n            if ((b >= 65) && (b <= 70)) bytes(s)[i] = bytes1(b + uint8(32));\n        }\n        return s;\n    }\n\n    /**\n     * @dev Validates that the sender is a valid interchain token service address\n     * @param sourceChain Source chain of the transaction\n     * @param sourceAddress Source address of the transaction\n     * @return bool true if the sender is validated, false otherwise\n     */\n    function validateSender(string calldata sourceChain, string calldata sourceAddress) external view returns (bool) {\n        string memory sourceAddressLC = _lowerCase(sourceAddress);\n        bytes32 sourceAddressHash = keccak256(bytes(sourceAddressLC));\n        if (sourceAddressHash == interchainTokenServiceAddressHash) {\n            return true;\n        }\n        return sourceAddressHash == remoteAddressHashes[sourceChain];\n    }\n\n    /**\n     * @dev Adds a trusted interchain token service address for the specified chain\n     * @param chain Chain name of the interchain token service\n     * @param addr Interchain token service address to be added\n     */\n    function addTrustedAddress(string memory chain, string memory addr) public onlyOwner {\n        if (bytes(chain).length == 0) revert ZeroStringLength();\n        if (bytes(addr).length == 0) revert ZeroStringLength();\n        remoteAddressHashes[chain] = keccak256(bytes(_lowerCase(addr)));\n        remoteAddresses[chain] = addr;\n        emit TrustedAddressAdded(chain, addr);\n    }\n\n    /**\n     * @dev Removes a trusted interchain token service address\n     * @param chain Chain name of the interchain token service to be removed\n     */\n    function removeTrustedAddress(string calldata chain) external onlyOwner {\n        if (bytes(chain).length == 0) revert ZeroStringLength();\n        remoteAddressHashes[chain] = bytes32(0);\n        remoteAddresses[chain] = '';\n        emit TrustedAddressRemoved(chain);\n    }\n\n    /**\n     * @dev Adds chains that are supported by the Axelar gateway\n     * @param chainNames List of chain names to be added as supported\n     */\n    function addGatewaySupportedChains(string[] calldata chainNames) external onlyOwner {\n        uint256 length = chainNames.length;\n        for (uint256 i; i < length; ++i) {\n            string calldata chainName = chainNames[i];\n            supportedByGateway[chainName] = true;\n            emit GatewaySupportedChainAdded(chainName);\n        }\n    }\n\n    /**\n     * @dev Removes chains that are no longer supported by the Axelar gateway\n     * @param chainNames List of chain names to be removed as supported\n     */\n    function removeGatewaySupportedChains(string[] calldata chainNames) external onlyOwner {\n        uint256 length = chainNames.length;\n        for (uint256 i; i < length; ++i) {\n            string calldata chainName = chainNames[i];\n            supportedByGateway[chainName] = false;\n            emit GatewaySupportedChainRemoved(chainName);\n        }\n    }\n\n    /**\n     * @dev Fetches the interchain token service address for the specified chain\n     * @param chainName Name of the chain\n     * @return remoteAddress Interchain token service address for the specified chain\n     */\n    function getRemoteAddress(string calldata chainName) external view returns (string memory remoteAddress) {\n        remoteAddress = remoteAddresses[chainName];\n        if (bytes(remoteAddress).length == 0) {\n            remoteAddress = interchainTokenServiceAddress.toString();\n        }\n    }\n}"
    }
  ]
}