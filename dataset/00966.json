{
  "Title": "`Compound()` will not work if there is only TokenA/TokenB in the trove.",
  "Content": "# `Compound()` will not work if there is only TokenA/TokenB in the trove.\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXCompound.sol#L58\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXCompound.sol#L58</a>\n\n\n## Summary\n\nThe compound() function is designed to deposit Long tokens, Short tokens, or airdropped ARB tokens to the GMX for compounding. However, it will only work if there is ARB token in the trove. If there are only Long/Short tokens in the trove without any ARB, the function will not work.\n\n## Vulnerability Details\n\nThe `compound()` function is intended to be called by the keeper once a day to deposit all the Long/Short or ARB tokens to the GMX for further compounding. However, the logic for depositing to the GMX is restricted by the condition that the trove must always hold an airdropped ARB token.\n\nHere is the relevant code snippet from the GitHub repository:\n```js\n//@audit compound if only ARB is there, what about tokenA and tokenB?\nif (_tokenInAmt > 0) {\n      self.refundee = payable(msg.sender);\n\n      self.compoundCache.compoundParams = cp;\n\n      ISwap.SwapParams memory _sp;\n\n      _sp.tokenIn = cp.tokenIn;\n      _sp.tokenOut = cp.tokenOut;\n      _sp.amountIn = _tokenInAmt;\n      _sp.amountOut = 0; // amount out minimum calculated in Swap\n      _sp.slippage = self.minSlippage;\n      _sp.deadline = cp.deadline;\n\n      GMXManager.swapExactTokensForTokens(self, _sp);\n\n      GMXTypes.AddLiquidityParams memory _alp;\n\n      _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n      _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n\n      self.compoundCache.depositValue = GMXReader.convertToUsdValue(\n        self,\n        address(self.tokenA),\n        self.tokenA.balanceOf(address(this))\n      )\n      + GMXReader.convertToUsdValue(\n        self,\n        address(self.tokenB),\n        self.tokenB.balanceOf(address(this))\n      );\n\n      GMXChecks.beforeCompoundChecks(self);\n\n      self.status = GMXTypes.Status.Compound;\n\n      _alp.minMarketTokenAmt = GMXManager.calcMinMarketSlippageAmt(\n        self,\n        self.compoundCache.depositValue,\n        cp.slippage\n      );\n\n      _alp.executionFee = cp.executionFee;\n\n      self.compoundCache.depositKey = GMXManager.addLiquidity(\n        self,\n        _alp\n      );\n    }\n\n```\n\nThe code checks if there is a positive `_tokenInAmt` (representing ARB tokens) and proceeds with the depositing and compounding logic. However, if there is no ARB token but only tokenA and tokenB in the trove, the compounding will not occur and the tokens will remain in the compoundGMX contract indefinitely.\n\nIt is important to note that the airdrop of ARB tokens is a rare event, making it less likely for this condition to be met. Therefore, if there are no ARB tokens but a significant amount of tokenA and tokenB in the trove, the compounding will not take place.\n\n## Impact\nIf the compounding doesnâ€™t happen this could lead to the indirect loss of funds to the user and loss of gas for the keeper who always calls this function just to transfer tokens and check the balance of ARB.\n\n## Tools Used\nmanual review\n\n## Recommendations\n\nTo mitigate this issue, it is important to always check if either tokenA/tokenB or ARB is present in the trove. If either of these is present, then proceed with the compound action. Otherwise, return.\n\n```js\nif (_tokenInAmt > 0 || self.tokenA.balanceOf(address(this) > 0 || self.tokenB.balanceOf(address(this))  ) {\n      self.refundee = payable(msg.sender);\n\n      self.compoundCache.compoundParams = cp;\n\n      ISwap.SwapParams memory _sp;\n\n      _sp.tokenIn = cp.tokenIn;\n      _sp.tokenOut = cp.tokenOut;\n      _sp.amountIn = _tokenInAmt;\n      _sp.amountOut = 0; // amount out minimum calculated in Swap\n      _sp.slippage = self.minSlippage;\n      _sp.deadline = cp.deadline;\n\n      GMXManager.swapExactTokensForTokens(self, _sp);\n\n      GMXTypes.AddLiquidityParams memory _alp;\n\n      _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n      _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n\n      self.compoundCache.depositValue = GMXReader.convertToUsdValue(\n        self,\n        address(self.tokenA),\n        self.tokenA.balanceOf(address(this))\n      )\n      + GMXReader.convertToUsdValue(\n        self,\n        address(self.tokenB),\n        self.tokenB.balanceOf(address(this))\n      );\n\n      GMXChecks.beforeCompoundChecks(self);\n\n      self.status = GMXTypes.Status.Compound;\n\n      _alp.minMarketTokenAmt = GMXManager.calcMinMarketSlippageAmt(\n        self,\n        self.compoundCache.depositValue,\n        cp.slippage\n      );\n\n      _alp.executionFee = cp.executionFee;\n\n      self.compoundCache.depositKey = GMXManager.addLiquidity(\n        self,\n        _alp\n      );\n    }\n```\n",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clo38mm260001la08daw5cbuf",
  "Code": [
    {
      "filename": "contracts/strategy/gmx/GMXCompound.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\n\n/**\n  * @title GMXCompound\n  * @author Steadefi\n  * @notice Re-usable library functions for compound operations for Steadefi leveraged vaults\n*/\nlibrary GMXCompound {\n  using SafeERC20 for IERC20;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ======================== EVENTS ========================= */\n\n  event CompoundCompleted();\n  event CompoundCancelled();\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function compound(\n    GMXTypes.Store storage self,\n    GMXTypes.CompoundParams memory cp\n  ) external {\n    // Transfer any tokenA/B from trove to vault\n    if (self.tokenA.balanceOf(address(self.trove)) > 0) {\n      self.tokenA.safeTransferFrom(\n        address(self.trove),\n        address(this),\n        self.tokenA.balanceOf(address(self.trove))\n      );\n    }\n    if (self.tokenB.balanceOf(address(self.trove)) > 0) {\n      self.tokenB.safeTransferFrom(\n        address(self.trove),\n        address(this),\n        self.tokenB.balanceOf(address(self.trove))\n      );\n    }\n\n    uint256 _tokenInAmt = IERC20(cp.tokenIn).balanceOf(address(this));\n\n    // Only compound if tokenIn amount is more than 0\n    if (_tokenInAmt > 0) {\n      self.refundee = payable(msg.sender);\n\n      self.compoundCache.compoundParams = cp;\n\n      ISwap.SwapParams memory _sp;\n\n      _sp.tokenIn = cp.tokenIn;\n      _sp.tokenOut = cp.tokenOut;\n      _sp.amountIn = _tokenInAmt;\n      _sp.amountOut = 0; // amount out minimum calculated in Swap\n      _sp.slippage = self.minSlippage;\n      _sp.deadline = cp.deadline;\n\n      GMXManager.swapExactTokensForTokens(self, _sp);\n\n      GMXTypes.AddLiquidityParams memory _alp;\n\n      _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n      _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n\n      self.compoundCache.depositValue = GMXReader.convertToUsdValue(\n        self,\n        address(self.tokenA),\n        self.tokenA.balanceOf(address(this))\n      )\n      + GMXReader.convertToUsdValue(\n        self,\n        address(self.tokenB),\n        self.tokenB.balanceOf(address(this))\n      );\n\n      GMXChecks.beforeCompoundChecks(self);\n\n      self.status = GMXTypes.Status.Compound;\n\n      _alp.minMarketTokenAmt = GMXManager.calcMinMarketSlippageAmt(\n        self,\n        self.compoundCache.depositValue,\n        cp.slippage\n      );\n\n      _alp.executionFee = cp.executionFee;\n\n      self.compoundCache.depositKey = GMXManager.addLiquidity(\n        self,\n        _alp\n      );\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processCompound(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessCompoundChecks(self);\n\n    self.status = GMXTypes.Status.Open;\n\n    emit CompoundCompleted();\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processCompoundCancellation(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessCompoundCancellationChecks(self);\n\n    self.status = GMXTypes.Status.Compound_Failed;\n\n    emit CompoundCancelled();\n  }\n}"
    }
  ]
}