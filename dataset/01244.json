{
  "Title": "`Errors.InvalidTwapPrice()` is never invoked when `if (twapPriceInEther == 0)` is true",
  "Content": "# `Errors.InvalidTwapPrice()` is never invoked when `if (twapPriceInEther == 0)` is true\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/libraries/LibOracle.sol#L87-L89\">https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/libraries/LibOracle.sol#L87-L89</a>\n\n\n## Summary & Vulnerability Details\nThe protocol expects to `revert` with `Errors.InvalidTwapPrice()` when `twapPriceInEther == 0`:\n```js\nFile: contracts/libraries/LibOracle.sol\n\n85            uint256 twapPriceInEther = (twapPrice / Constants.DECIMAL_USDC) * 1 ether;\n86            uint256 twapPriceInv = twapPriceInEther.inv();\n87            if (twapPriceInEther == 0) {\n88                revert Errors.InvalidTwapPrice(); // @audit : unreachable code\n89            }\n```\nHowever, the control never reaches Line 88 when `twapPriceInEther` is zero. It rather reverts before that with error `Division or modulo by 0`. <br>\n***NOTE:*** Due to this bug, `Errors.InvalidTwapPrice()` is **never** invoked/thrown by the protocol even under satisfactory conditions, even though it has been defined. \n\n## PoC\nSince I could not find any helper function inside `contracts/` or `test/` which lets one set the `twapPrice` returned by `uint256 twapPrice = IDiamond(payable(address(this))).estimateWETHInUSDC(Constants.UNISWAP_WETH_BASE_AMT, 30 minutes);` to zero for testing purposes, I have created a simplified PoC which targets the problem area:<br>\nSave the following as a file named `test/InvalidTwapPriceErrorCheck.t.sol` and run the test via `forge test --mt testInvalidTwapPriceErrNeverInvoked -vv`. You will find that the test reverts with error `Division or modulo by 0`, but not with `Errors.InvalidTwapPrice()`. The PoC uses the same underlying math libraries and logic path as the protocol does in `contracts/libraries/LibOracle.sol::baseOracleCircuitBreaker()`.\n```js\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {Constants} from \"contracts/libraries/Constants.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {U256} from \"contracts/libraries/PRBMathHelper.sol\";\nimport {OBFixture} from \"test/utils/OBFixture.sol\";\n\ncontract InvalidTwapPriceErrorCheck is OBFixture {\n    using U256 for uint256;\n\n    function getZeroTwapPriceInEther_IncorrectStyle_As_In_Existing_DittoProtocol()\n        internal\n        pure\n        returns (uint256 twapPriceInEther, uint256 twapPriceInv)\n    {\n        // fake the twapPrice to 0\n        uint256 twapPrice = 0; // IDiamond(payable(address(this))).estimateWETHInUSDC(Constants.UNISWAP_WETH_BASE_AMT, 30 minutes);\n        // Following code is copied as-is from\n        // `contracts/libraries/LibOracle.sol::baseOracleCircuitBreaker()#L85-L89`\n        twapPriceInEther = (twapPrice / Constants.DECIMAL_USDC) * 1 ether;\n        twapPriceInv = twapPriceInEther.inv();\n        if (twapPriceInEther == 0) {\n            revert Errors.InvalidTwapPrice(); // @audit : unreachable code\n        }\n    }\n\n    function getZeroTwapPriceInEther_CorrectStyle()\n        internal\n        pure\n        returns (uint256 twapPriceInEther, uint256 twapPriceInv)\n    {\n        // fake the twapPrice to 0\n        uint256 twapPrice = 0; // IDiamond(payable(address(this))).estimateWETHInUSDC(Constants.UNISWAP_WETH_BASE_AMT, 30 minutes);\n        twapPriceInEther = (twapPrice / Constants.DECIMAL_USDC) * 1 ether;\n        if (twapPriceInEther == 0) { \n            revert Errors.InvalidTwapPrice();\n        }\n        twapPriceInv = twapPriceInEther.inv();\n    }\n\n    function testInvalidTwapPriceErrNeverInvoked() public pure {\n        getZeroTwapPriceInEther_IncorrectStyle_As_In_Existing_DittoProtocol();\n    }\n\n    function testInvalidTwapPriceErrInvokedCorrectly() public {\n        vm.expectRevert(Errors.InvalidTwapPrice.selector);\n        getZeroTwapPriceInEther_CorrectStyle();\n    }\n}\n```\n\n<br>\n\nIn the above test file, you can also run the test which invokes the \"fixed\" or \"correct\" code style via `forge test --mt testInvalidTwapPriceErrInvokedCorrectly -vv`. This will invoke the `Errors.InvalidTwapPrice` error, as expected.\n\n## Recommendations & Root Cause\nThe check on Line 87 (`if` condition) needs to be performed immediately after Line 85.\n```diff\n    85            uint256 twapPriceInEther = (twapPrice / Constants.DECIMAL_USDC) * 1 ether;\n+   86            if (twapPriceInEther == 0) {\n+   87                revert Errors.InvalidTwapPrice();\n+   88            }\n+   89            uint256 twapPriceInv = twapPriceInEther.inv();\n-   86            uint256 twapPriceInv = twapPriceInEther.inv();\n-   87            if (twapPriceInEther == 0) {\n-   88                revert Errors.InvalidTwapPrice();\n-   89            }\n```\nThe above fix needed to be done because the `inv()` call caused a revert even before control used to reach the `if` condition.\n\n## Impact\nProtocol owner or developer monitoring for a revert due to `Errors.InvalidTwapPrice()` in the logs will never see it and will make debugging & issue resolution harder. \n\n## Tools Used\nManual audit & foundry.",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clm871gl00001mp081mzjdlwc",
  "Code": [
    {
      "filename": "contracts/libraries/LibOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {AggregatorV3Interface} from\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IDiamond} from \"interfaces/IDiamond.sol\";\nimport {AppStorage, appStorage} from \"contracts/libraries/AppStorage.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\nlibrary LibOracle {\n    using U256 for uint256;\n\n    function getOraclePrice(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        AggregatorV3Interface baseOracle = AggregatorV3Interface(s.baseOracle);\n        uint256 protocolPrice = getPrice(asset);\n        // prettier-ignore\n        (\n            uint80 baseRoundID,\n            int256 basePrice,\n            /*uint256 baseStartedAt*/\n            ,\n            uint256 baseTimeStamp,\n            /*uint80 baseAnsweredInRound*/\n        ) = baseOracle.latestRoundData();\n\n        AggregatorV3Interface oracle = AggregatorV3Interface(s.asset[asset].oracle);\n        if (address(oracle) == address(0)) revert Errors.InvalidAsset();\n\n        if (oracle == baseOracle) {\n            //@dev multiply base oracle by 10**10 to give it 18 decimals of precision\n            uint256 basePriceInEth = basePrice > 0\n                ? uint256(basePrice * Constants.BASE_ORACLE_DECIMALS).inv()\n                : 0;\n            basePriceInEth = baseOracleCircuitBreaker(\n                protocolPrice, baseRoundID, basePrice, baseTimeStamp, basePriceInEth\n            );\n            return basePriceInEth;\n        } else {\n            // prettier-ignore\n            (\n                uint80 roundID,\n                int256 price,\n                /*uint256 startedAt*/\n                ,\n                uint256 timeStamp,\n                /*uint80 answeredInRound*/\n            ) = oracle.latestRoundData();\n            uint256 priceInEth = uint256(price).div(uint256(basePrice));\n            oracleCircuitBreaker(\n                roundID, baseRoundID, price, basePrice, timeStamp, baseTimeStamp\n            );\n            return priceInEth;\n        }\n    }\n\n    function baseOracleCircuitBreaker(\n        uint256 protocolPrice,\n        uint80 roundId,\n        int256 chainlinkPrice,\n        uint256 timeStamp,\n        uint256 chainlinkPriceInEth\n    ) private view returns (uint256 _protocolPrice) {\n        bool invalidFetchData = roundId == 0 || timeStamp == 0\n            || timeStamp > block.timestamp || chainlinkPrice <= 0\n            || block.timestamp > 2 hours + timeStamp;\n        uint256 chainlinkDiff = chainlinkPriceInEth > protocolPrice\n            ? chainlinkPriceInEth - protocolPrice\n            : protocolPrice - chainlinkPriceInEth;\n        bool priceDeviation =\n            protocolPrice > 0 && chainlinkDiff.div(protocolPrice) > 0.5 ether;\n\n        //@dev if there is issue with chainlink, get twap price. Compare twap and chainlink\n        if (invalidFetchData || priceDeviation) {\n            uint256 twapPrice = IDiamond(payable(address(this))).estimateWETHInUSDC(\n                Constants.UNISWAP_WETH_BASE_AMT, 30 minutes\n            );\n            uint256 twapPriceInEther = (twapPrice / Constants.DECIMAL_USDC) * 1 ether;\n            uint256 twapPriceInv = twapPriceInEther.inv();\n            if (twapPriceInEther == 0) {\n                revert Errors.InvalidTwapPrice();\n            }\n\n            if (invalidFetchData) {\n                return twapPriceInv;\n            } else {\n                uint256 twapDiff = twapPriceInv > protocolPrice\n                    ? twapPriceInv - protocolPrice\n                    : protocolPrice - twapPriceInv;\n                //@dev save the price that is closest to saved oracle price\n                if (chainlinkDiff <= twapDiff) {\n                    return chainlinkPriceInEth;\n                }\n                //@dev In case USDC_WETH suddenly has no liquidity\n                IERC20 weth = IERC20(Constants.WETH);\n                uint256 wethBal = weth.balanceOf(Constants.USDC_WETH);\n                if (wethBal < 100 ether) revert Errors.InsufficientEthInLiquidityPool();\n                return twapPriceInv;\n            }\n        } else {\n            return chainlinkPriceInEth;\n        }\n    }\n\n    function oracleCircuitBreaker(\n        uint80 roundId,\n        uint80 baseRoundId,\n        int256 chainlinkPrice,\n        int256 baseChainlinkPrice,\n        uint256 timeStamp,\n        uint256 baseTimeStamp\n    ) private view {\n        bool invalidFetchData = roundId == 0 || timeStamp == 0\n            || timeStamp > block.timestamp || chainlinkPrice <= 0 || baseRoundId == 0\n            || baseTimeStamp == 0 || baseTimeStamp > block.timestamp\n            || baseChainlinkPrice <= 0;\n\n        if (invalidFetchData) revert Errors.InvalidPrice();\n    }\n\n    /* \n    @dev Constants.HEAD to marks the start/end of the linked list, so the only properties needed are id/nextId/prevId.\n    Helper methods are used to set the values of oraclePrice and oracleTime since they are set to different properties\n    */\n    function setPriceAndTime(address asset, uint256 oraclePrice, uint32 oracleTime)\n        internal\n    {\n        AppStorage storage s = appStorage();\n        s.bids[asset][Constants.HEAD].ercAmount = uint80(oraclePrice);\n        s.bids[asset][Constants.HEAD].creationTime = oracleTime;\n    }\n\n    //@dev Intentionally using creationTime for oracleTime.\n    function getTime(address asset) internal view returns (uint256 creationTime) {\n        AppStorage storage s = appStorage();\n        return s.bids[asset][Constants.HEAD].creationTime;\n    }\n\n    //@dev Intentionally using ercAmount for oraclePrice. Storing as price may lead to bugs in the match algos.\n    function getPrice(address asset) internal view returns (uint80 oraclePrice) {\n        AppStorage storage s = appStorage();\n        return uint80(s.bids[asset][Constants.HEAD].ercAmount);\n    }\n\n    //@dev allows caller to save gas since reading spot price costs ~16K\n    function getSavedOrSpotOraclePrice(address asset) internal view returns (uint256) {\n        if (LibOrders.getOffsetTime() - getTime(asset) < 15 minutes) {\n            return getPrice(asset);\n        } else {\n            return getOraclePrice(asset);\n        }\n    }\n}"
    }
  ]
}