{
  "Title": "Unchecked decrement results in integer underflow in `LibStrings::toString`",
  "Content": "**Description:** The implementation of [`LibStrings::toString`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/LibStrings.sol#L16-L37) is intended to convert an unsigned integer to its string representation. If the value provided is non-zero, the function determines the number of digits in the number, creates a byte buffer of the appropriate size, and then populates that buffer with the ASCII representation of each digit. However, given Beanstalk uses a Solidity compiler version lower than `0.8.0` in which safe, checked math was introduced as default, this library is susceptible to over/underflow of unchecked math operations. One such issue arises when [post-decrementing the `index`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/LibStrings.sol#L33), initialized as [`digits - 1`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/LibStrings.sol#L30), which underflows on the final loop iteration.\n\n\n**Impact:** Evidence of underflow is visible in the use of this function on-chain in both `MetadataFacet::uri`:\n\n![URI](img/uri.png)\n\nand `MetadataImage::imageURI`:\n\n![Image](img/overlap.png)\n\nThe \"Deposit stem\" [attribute](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/metadata/MetadataFacet.sol#L37) is incredibly large due to wrap-around of the maximum `uint256` value, and the same issue applies to [`MetadataImage::blackBars`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/metadata/MetadataImage.sol#L528) called within [`MetadataImage::generateImage](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/metadata/MetadataImage.sol#L35-L49) which causes the stem string representation to overlap with the [\"Bean Deposit\" text](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/metadata/MetadataImage.sol#L538-L539).\n\nThis issue should be resolved to display accurate metadata, given the following disclaimer in `MetadataFacet::uri`:\n> DISCLAIMER: Due diligence is imperative when assessing this NFT. Opensea and other NFT marketplaces cache the svg output and thus, may require the user to refresh the metadata to properly show the correct values.\"\n\n**Recommended Mitigation:** Initialize `index` to `digits` and pre-decrement instead to avoid underflow on the final loop iteration.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/libraries/LibStrings.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary LibStrings {\n\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        uint256 index = digits - 1;\n        temp = value;\n        while (temp != 0) {\n            buffer[index--] = bytes1(uint8(48 + temp % 10));\n            temp /= 10;\n        }\n        return string(buffer);\n    }\n\n     function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}"
    },
    {
      "filename": "protocol/contracts/beanstalk/metadata/MetadataFacet.sol",
      "content": "/*\n * SPDX-License-Identifier: MIT\n */\n\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {LibLegacyTokenSilo} from \"contracts/libraries/Silo/LibLegacyTokenSilo.sol\";\nimport \"./MetadataImage.sol\";\n\n\n/**\n * @title MetadataFacet\n * @author Brean\n * @notice MetadataFacet is a contract that provides metadata for beanstalk ERC1155 deposits, \n * as well as other auxiliary functions related to ERC1155 deposits.\n * \n * @dev Deposits are represented by a uint256, which is the concatination of the token address and the stem.\n */\ncontract MetadataFacet is MetadataImage {\n    using LibStrings for uint256;\n\n    /**\n     * @notice Returns the URI for a given depositId.\n     * @param depositId - the id of the deposit\n     * @dev the URI is a base64 encoded JSON object that contains the metadata and base64 encoded svg.\n     * Deposits are stored as a mapping of a uint256 to a Deposit struct.\n     * ERC20 deposits are represented by the concatination of the token address and the stem. (20 + 12 bytes).\n     */\n    function uri(uint256 depositId) external view returns (string memory) {\n        (address token, int96 stem) = LibBytes.unpackAddressAndStem(depositId);\n        require(token != address(0), \"Silo: metadata does not exist\");\n        bytes memory attributes = abi.encodePacked(\n            '\\n\\nToken Symbol: ', getTokenName(token),\n            '\\nToken Address: ', LibStrings.toHexString(uint256(token), 20),\n            '\\nId: ', depositId.toHexString(32),\n            '\\nDeposit stem: ', uint256(stem).toString(),\n            '\\nDeposit inital stalk per BDV: ', uint256(LibTokenSilo.stalkIssuedPerBdv(token)).toString(),\n            '\\nDeposit grown stalk per BDV\": ', uint256(LibTokenSilo.stemTipForToken(token) - stem).toString(),\n            '\\nDeposit seeds per BDV\": ', uint256(LibLegacyTokenSilo.getSeedsPerToken(token)).toString(),\n            '\\n\\nDISCLAIMER: Due diligence is imperative when assessing this NFT. Opensea and other NFT marketplaces cache the svg output and thus, may require the user to refresh the metadata to properly show the correct values.\"'\n        );\n        return string(abi.encodePacked(\"data:application/json;base64,\",LibBytes64.encode(abi.encodePacked(\n                '{',\n                    '\"name\": \"Beanstalk Deposit\", \"description\": \"A Beanstalk Deposit.',\n                    attributes,\n                    string(abi.encodePacked(', \"image\": \"', imageURI(depositId), '\"')),\n                '}'\n            ))\n        ));\n    }\n}"
    }
  ]
}