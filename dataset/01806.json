{
  "Title": "Indefinite allowances",
  "Content": "The [`Generalized4626Strategy`](https://github.com/OriginProtocol/origin-dollar/blob/508921bd39f988fa61b60cea372b910725ff7bd0/contracts/contracts/strategies/Generalized4626Strategy.sol#L82) and [`ConvexEthMetaStrategy`](https://github.com/OriginProtocol/origin-dollar/blob/757ad13fa07ecdff058e55d9beff3c98d5d186a2/contracts/contracts/strategies/ConvexEthMetaStrategy.sol#L348-L365) contracts both approve token allowances for their respective platform contracts. They also include [a mechanism](https://github.com/OriginProtocol/origin-dollar/blob/757ad13fa07ecdff058e55d9beff3c98d5d186a2/contracts/contracts/utils/InitializableAbstractStrategy.sol#L288) for the governor to refresh those allowances. However, there is no mechanism to revoke the allowances if the platform becomes untrustworthy.\n\n\nConsider allowing the governor to revoke all token allowances.\n\n\n***Update:** Acknowledged, not resolved. The Origin team stated:*\n\n\n\n> *Funds that are moved to strategies by the vault are immediately deposited to the backing strategy. Because of this, having long-running approvals for the backing strategy is not a concern, since those backing strategies either already have the strategy's funds, or the strategy is empty except for dust.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/contracts/strategies/Generalized4626Strategy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title OETH Generalized 4626 Strategy\n * @notice Investment strategy for vaults supporting ERC4626\n * @author Origin Protocol Inc\n */\nimport { IERC4626 } from \"../../lib/openzeppelin/interfaces/IERC4626.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"../utils/InitializableAbstractStrategy.sol\";\n\ncontract Generalized4626Strategy is InitializableAbstractStrategy {\n    using SafeERC20 for IERC20;\n\n    IERC20 shareToken;\n    IERC20 assetToken;\n\n    /**\n     * @dev Deposit assets by converting them to shares\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_asset, _amount);\n    }\n\n    /**\n     * @dev Deposit assets by converting them to shares\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function _deposit(address _asset, uint256 _amount) internal {\n        require(_amount > 0, \"Must deposit something\");\n        require(_asset == address(assetToken), \"Unexpected asset address\");\n\n        // slither-disable-next-line unused-return\n        IERC4626(platformAddress).deposit(_amount, address(this));\n        emit Deposit(_asset, address(shareToken), _amount);\n    }\n\n    /**\n     * @dev Deposit the entire balance of assetToken to gain shareToken\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        uint256 balance = assetToken.balanceOf(address(this));\n        if (balance > 0) {\n            _deposit(address(assetToken), balance);\n        }\n    }\n\n    /**\n     * @dev Withdraw asset by burning shares\n     * @param _recipient Address to receive withdrawn asset\n     * @param _asset Address of asset to withdraw\n     * @param _amount Amount of asset to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        require(_amount > 0, \"Must withdraw something\");\n        require(_recipient != address(0), \"Must specify recipient\");\n        require(_asset == address(assetToken), \"Unexpected asset address\");\n\n        // slither-disable-next-line unused-return\n        IERC4626(platformAddress).withdraw(_amount, _recipient, address(this));\n        emit Withdrawal(_asset, address(shareToken), _amount);\n    }\n\n    /**\n     * @dev Internal method to respond to the addition of new asset / share tokens\n     * @param _asset Address of the asset to approve\n     * @param _pToken The pToken for the approval\n     */\n    function _abstractSetPToken(address _asset, address _pToken)\n        internal\n        override\n    {\n        shareToken = IERC20(_pToken);\n        assetToken = IERC20(_asset);\n\n        // Safe approval\n        shareToken.safeApprove(platformAddress, type(uint256).max);\n        assetToken.safeApprove(platformAddress, type(uint256).max);\n    }\n\n    /**\n     * @dev Remove all assets from platform and send them to Vault contract.\n     */\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        uint256 shareBalance = shareToken.balanceOf(address(this));\n        uint256 assetAmount = IERC4626(platformAddress).redeem(\n            shareBalance,\n            vaultAddress,\n            address(this)\n        );\n        emit Withdrawal(address(assetToken), address(shareToken), assetAmount);\n    }\n\n    /**\n     * @dev Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        require(_asset == address(assetToken), \"Unexpected asset address\");\n        /* We are intentionally not counting the amount of assetToken parked on the\n         * contract toward the checkBalance. The deposit and withdraw functions\n         * should not result in assetToken being unused and owned by this strategy\n         * contract.\n         */\n        return\n            IERC4626(platformAddress).convertToAssets(\n                shareToken.balanceOf(address(this))\n            );\n    }\n\n    /**\n     * @dev Approve the spending of all assets by their corresponding cToken,\n     *      if for some reason is it necessary.\n     */\n    function safeApproveAllTokens() external override {\n        assetToken.safeApprove(platformAddress, type(uint256).max);\n        shareToken.safeApprove(platformAddress, type(uint256).max);\n    }\n\n    /**\n     * @dev Retuns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _asset == address(assetToken);\n    }\n}"
    }
  ]
}