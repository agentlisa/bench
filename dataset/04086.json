{
  "Title": "Invalid setter function",
  "Content": "##### Description\n* In the `setDefaultController()` function defined at line https://github.com/pie-dao/ExperiPie/blob/facf3c246d9c43f5b1e0bad7dc2b0a9a2a2393c5/contracts/factories/PieFactoryContract.sol#L34, the new value is assigned to the `defaultController` variable. But it is not taken into account that earlier using the `bakePie()` function, the pool owner could be changed to address of `defaultController`. Thus, as a result of the work of the `setDefaultController()` function, the pool owner will remain the same, while it is expected that the pool will be managed from a different address.\n* In the `setFeeBeneficiary()` function defined at line https://github.com/pie-dao/ExperiPie/blob/facf3c246d9c43f5b1e0bad7dc2b0a9a2a2393c5/contracts/facets/Basket/BasketFacet.sol#L87 , the `LibBasketStorage.basketStorage().FeeBeneficiary` variable is assigned a new value. But it is not taken into account that earlier tokens could be issued to this address in the following places: https://github.com/pie-dao/ExperiPie/blob/facf3c246d9c43f5b1e0bad7dc2b0a9a2a2393c5/contracts/facets/Basket/BasketFacet.sol#L141, https://github.com/pie-dao/ExperiPie/blob/facf3c246d9c43f5b1e0bad7dc2b0a9a2a2393c5/contracts/facets/Basket/BasketFacet.sol#L175, https://github.com/pie-dao/ExperiPie/blob/facf3c246d9c43f5b1e0bad7dc2b0a9a2a2393c5/contracts/facets/Basket/BasketFacet.sol#L216.\n\n\n##### Recommendation\nIt is necessary to carefully check the logic of these functions and make corrections if necessary.\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/factories/PieFactoryContract.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nimport \"diamond-2/contracts/Diamond.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../interfaces/IExperiPie.sol\";\n\ncontract PieFactoryContract is Ownable {\n    using SafeERC20 for IERC20;\n\n    address[] public pies;\n    mapping(address => bool) public isPie;\n    address public defaultController;\n\n    IDiamondCut.FacetCut[] public defaultCut;\n\n    event PieCreated(\n        address indexed pieAddress,\n        address indexed deployer,\n        uint256 indexed index\n    );\n\n    event DefaultControllerSet(address indexed controller);\n    event FacetAdded(IDiamondCut.FacetCut);\n    event FacetRemoved(IDiamondCut.FacetCut);\n\n    constructor() {\n        defaultController = msg.sender;\n    }\n\n    function setDefaultController(address _controller) external onlyOwner {\n        defaultController = _controller;\n        emit DefaultControllerSet(_controller);\n    }\n\n    function removeFacet(uint256 _index) external onlyOwner {\n        emit FacetRemoved(defaultCut[_index]);\n        defaultCut[_index] = defaultCut[defaultCut.length - 1];\n        defaultCut.pop();\n    }\n\n    function addFacet(IDiamondCut.FacetCut memory _facet) external onlyOwner {\n        defaultCut.push(_facet);\n        emit FacetAdded(_facet);\n    }\n\n    function bakePie(\n        address[] memory _tokens,\n        uint256[] memory _amounts,\n        uint256 _initialSupply,\n        string memory _symbol,\n        string memory _name\n    ) external {\n        Diamond d = new Diamond(defaultCut, address(this));\n\n        pies.push(address(d));\n        isPie[address(d)] = true;\n\n        // emit DiamondCreated(address(d));\n        require(_tokens.length != 0, \"CANNOT_CREATE_ZERO_TOKEN_LENGTH_PIE\");\n        require(_tokens.length == _amounts.length, \"ARRAY_LENGTH_MISMATCH\");\n\n        IExperiPie pie = IExperiPie(address(d));\n\n        // Init erc20 facet\n        pie.initialize(_initialSupply, _name, _symbol);\n\n        // Transfer and add tokens\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC20 token = IERC20(_tokens[i]);\n            token.safeTransferFrom(msg.sender, address(pie), _amounts[i]);\n            pie.addToken(_tokens[i]);\n        }\n\n        // Unlock pool\n        pie.setLock(1);\n\n        // Uncap pool\n        pie.setCap(uint256(-1));\n\n        // Send minted pie to msg.sender\n        pie.transfer(msg.sender, _initialSupply);\n        pie.transferOwnership(defaultController);\n\n        emit PieCreated(address(d), msg.sender, pies.length - 1);\n    }\n\n    function getDefaultCut()\n        external\n        view\n        returns (IDiamondCut.FacetCut[] memory)\n    {\n        return defaultCut;\n    }\n\n    function getDefaultCutCount() external view returns (uint256) {\n        return defaultCut.length;\n    }\n}"
    },
    {
      "filename": "contracts/facets/Basket/BasketFacet.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../../interfaces/IBasketFacet.sol\";\nimport \"../ERC20/LibERC20Storage.sol\";\nimport \"../ERC20/LibERC20.sol\";\nimport \"../shared/Reentry/ReentryProtection.sol\";\nimport \"../shared/Access/CallProtection.sol\";\nimport \"./LibBasketStorage.sol\";\n\ncontract BasketFacet is ReentryProtection, CallProtection, IBasketFacet {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public constant MIN_AMOUNT = 10**6;\n    uint256 public constant MAX_ENTRY_FEE = 10**17; // 10%\n    uint256 public constant MAX_EXIT_FEE = 10**17; // 10%\n    uint256 public constant MAX_ANNUAL_FEE = 10**17; // 10%\n\n    \n\n    function addToken(address _token) external override protectedCall {\n        LibBasketStorage.BasketStorage storage bs = LibBasketStorage.basketStorage();\n        require(!bs.inPool[_token], \"TOKEN_ALREADY_IN_POOL\");\n        // Enforce minimum to avoid rounding errors; (Minimum value is the same as in Balancer)\n        require(balance(_token) >= MIN_AMOUNT, \"BALANCE_TOO_SMALL\");\n\n        bs.inPool[_token] = true;\n        bs.tokens.push(IERC20(_token));\n\n        emit TokenAdded(_token);\n    }\n\n    function removeToken(address _token) external override protectedCall {\n        LibBasketStorage.BasketStorage storage bs = LibBasketStorage.basketStorage();\n\n        require(bs.inPool[_token], \"TOKEN_NOT_IN_POOL\");\n\n        bs.inPool[_token] = false;\n\n        // remove token from array\n        // TODO consider limiting max amount of tokens to mitigate running out of gas.\n        for(uint256 i; i < bs.tokens.length; i ++) {\n            if(address(bs.tokens[i]) == _token) {\n                bs.tokens[i] = bs.tokens[bs.tokens.length - 1];\n                bs.tokens.pop();\n\n                break;\n            }\n        }\n\n        emit TokenRemoved(_token);\n    }\n\n    function setEntryFee(uint256 _fee) external override protectedCall {\n        require(_fee <= MAX_ENTRY_FEE, \"FEE_TOO_BIG\");\n        LibBasketStorage.basketStorage().entryFee = _fee;\n        emit EntryFeeSet(_fee);\n    }\n\n    function getEntryFee() external view override returns(uint256) {\n        return LibBasketStorage.basketStorage().entryFee;\n    }\n\n    function setExitFee(uint256 _fee) external override protectedCall {\n        require(_fee <= MAX_EXIT_FEE, \"FEE_TOO_BIG\");\n        LibBasketStorage.basketStorage().exitFee = _fee;\n        emit ExitFeeSet(_fee);\n    }\n\n    function getExitFee() external view override returns(uint256) {\n        return LibBasketStorage.basketStorage().exitFee;\n    }\n\n    function setAnnualizedFee(uint256 _fee) external override protectedCall {\n        require(_fee <= MAX_ANNUAL_FEE, \"FEE_TOO_BIG\");\n        LibBasketStorage.basketStorage().annualizedFee = _fee;\n        emit AnnualizedFeeSet(_fee);\n    }\n\n    function getAnnualizedFee() external view override returns(uint256) {\n        return LibBasketStorage.basketStorage().annualizedFee;\n    }\n\n    function setFeeBeneficiary(address _beneficiary) external override protectedCall {\n        LibBasketStorage.basketStorage().feeBeneficiary = _beneficiary;\n        emit FeeBeneficiarySet(_beneficiary);\n    }\n\n    function getFeeBeneficiary() external view override returns(address) {\n        return LibBasketStorage.basketStorage().feeBeneficiary;\n    }\n\n    function setEntryFeeBeneficiaryShare(uint256 _share) external override protectedCall {\n        require(_share <= 10**18, \"FEE_SHARE_TOO_BIG\");\n        LibBasketStorage.basketStorage().entryFeeBeneficiaryShare = _share;\n        emit EntryFeeBeneficiaryShareSet(_share);\n    }\n\n    function getEntryFeeBeneficiaryShare() external view override returns(uint256) {\n        return LibBasketStorage.basketStorage().entryFeeBeneficiaryShare;\n    }\n\n    function setExitFeeBeneficiaryShare(uint256 _share) external override protectedCall {\n        require(_share <= 10**18, \"FEE_SHARE_TOO_BIG\");\n        LibBasketStorage.basketStorage().exitFeeBeneficiaryShare = _share;\n        emit ExitFeeBeneficiaryShareSet(_share);\n    }\n\n    function getExitFeeBeneficiaryShare() external view override returns(uint256) {\n        return LibBasketStorage.basketStorage().exitFeeBeneficiaryShare;\n    }\n\n\n    function joinPool(uint256 _amount) external override noReentry {\n        require(!this.getLock(), \"POOL_LOCKED\");\n        chargeOutstandingAnnualizedFee();\n        LibBasketStorage.BasketStorage storage bs = LibBasketStorage.basketStorage();\n        uint256 totalSupply = LibERC20Storage.erc20Storage().totalSupply;\n        require(totalSupply.add(_amount) < this.getCap(), \"MAX_POOL_CAP_REACHED\");\n\n        uint256 feeAmount = _amount.mul(bs.entryFee).div(10**18);\n\n        for(uint256 i; i < bs.tokens.length; i ++) {\n            IERC20 token = bs.tokens[i];\n            uint256 tokenAmount = balance(address(token)).mul(_amount.add(feeAmount)).div(totalSupply);\n            require(tokenAmount != 0, \"AMOUNT_TOO_SMALL\");\n            token.safeTransferFrom(msg.sender, address(this), tokenAmount);\n        }\n\n        // If there is any fee that should go to the beneficiary mint it\n        if(\n            feeAmount != 0 &&\n            bs.entryFeeBeneficiaryShare != 0 &&\n            bs.feeBeneficiary != address(0)\n        ) {\n            uint256 feeBeneficiaryShare = feeAmount.mul(bs.entryFeeBeneficiaryShare).div(10**18);\n            if(feeBeneficiaryShare != 0) {\n                LibERC20.mint(bs.feeBeneficiary, feeBeneficiaryShare);\n            }\n        }\n\n        LibERC20.mint(msg.sender, _amount);\n        emit PoolJoined(msg.sender, _amount);\n    }\n\n    // Must be overwritten to withdraw from strategies\n    function exitPool(uint256 _amount) external override virtual noReentry {\n        require(!this.getLock(), \"POOL_LOCKED\");\n        chargeOutstandingAnnualizedFee();\n        LibBasketStorage.BasketStorage storage bs = LibBasketStorage.basketStorage();\n        uint256 totalSupply = LibERC20Storage.erc20Storage().totalSupply;\n\n        uint256 feeAmount = _amount.mul(bs.exitFee).div(10**18);\n\n        for(uint256 i; i < bs.tokens.length; i ++) {\n            IERC20 token = bs.tokens[i];\n            uint256 tokenBalance = balance(address(token));\n            // redeem less tokens if there is an exit fee\n            uint256 tokenAmount = tokenBalance.mul(_amount.sub(feeAmount)).div(totalSupply);\n            require(tokenBalance.sub(tokenAmount) >= MIN_AMOUNT, \"TOKEN_BALANCE_TOO_LOW\");\n            token.safeTransfer(msg.sender, tokenAmount);\n        }\n\n         // If there is any fee that should go to the beneficiary mint it\n        if(\n            feeAmount != 0 &&\n            bs.exitFeeBeneficiaryShare != 0 &&\n            bs.feeBeneficiary != address(0)\n        ) {\n            uint256 feeBeneficiaryShare = feeAmount.mul(bs.exitFeeBeneficiaryShare).div(10**18);\n            if(feeBeneficiaryShare != 0) {\n                LibERC20.mint(bs.feeBeneficiary, feeBeneficiaryShare);\n            }\n        }\n\n        require(totalSupply.sub(_amount) >= MIN_AMOUNT, \"POOL_TOKEN_BALANCE_TOO_LOW\");\n        LibERC20.burn(msg.sender, _amount);\n        emit PoolExited(msg.sender, _amount);\n    }\n\n\n    function calcOutStandingAnnualizedFee() public view override returns(uint256) {\n        LibBasketStorage.BasketStorage storage bs = LibBasketStorage.basketStorage();\n        uint256 totalSupply = LibERC20Storage.erc20Storage().totalSupply;\n\n        uint256 lastFeeClaimed = bs.lastAnnualizedFeeClaimed;\n        uint256 annualizedFee = bs.annualizedFee;\n\n        if(\n            annualizedFee == 0 ||\n            bs.feeBeneficiary == address(0) ||\n            lastFeeClaimed == 0\n        ) {\n            return 0;\n        }\n\n        uint256 timePassed = block.timestamp.sub(lastFeeClaimed);\n\n        return totalSupply.mul(annualizedFee).div(10**18).mul(timePassed).div(365 days);\n    }\n\n    function chargeOutstandingAnnualizedFee() public override {\n        uint256 outStandingFee = calcOutStandingAnnualizedFee();\n        LibBasketStorage.BasketStorage storage bs = LibBasketStorage.basketStorage();\n\n        bs.lastAnnualizedFeeClaimed = block.timestamp;\n\n        // if there is any fee to mint and the beneficiary is set\n        // note: feeBeneficiary is already checked in calc function\n        if(\n            outStandingFee != 0\n        ) {\n            LibERC20.mint(bs.feeBeneficiary, outStandingFee);\n        }\n\n        emit FeeCharged(outStandingFee);\n    }\n\n    // returns true when locked\n    function getLock() external view override returns(bool) {\n        LibBasketStorage.BasketStorage storage bs = LibBasketStorage.basketStorage();\n        return bs.lockBlock == 0 || bs.lockBlock >= block.number;\n    }\n\n    function getTokenInPool(address _token) external view override returns(bool) {\n        return LibBasketStorage.basketStorage().inPool[_token];\n    }\n\n    function getLockBlock() external view override returns(uint256) {\n        return LibBasketStorage.basketStorage().lockBlock;\n    }\n\n    // lock up to and including _lock blocknumber\n    function setLock(uint256 _lock) external override protectedCall {\n        LibBasketStorage.basketStorage().lockBlock = _lock;\n        emit LockSet(_lock);\n    }\n\n    function setCap(uint256 _maxCap) external override protectedCall {\n        LibBasketStorage.basketStorage().maxCap = _maxCap;\n        emit CapSet(_maxCap);\n    }\n\n    // Seperated balance function to allow yearn like strategies to be hooked up by inheriting from this contract and overriding\n    function balance(address _token) public view override returns(uint256) {\n        return IERC20(_token).balanceOf(address(this));\n    }\n\n    function getTokens() external view override returns (address[] memory) {\n        IERC20[] memory tokens = LibBasketStorage.basketStorage().tokens;\n        address[] memory result = new address[](tokens.length);\n\n        for(uint256 i = 0; i < tokens.length; i ++) {\n            result[i] = address(tokens[i]);\n        }\n\n        return(result);\n    }\n\n    function getCap() external view override returns(uint256){\n        return LibBasketStorage.basketStorage().maxCap;\n    }\n\n    function calcTokensForAmount(uint256 _amount) external view override returns (address[] memory tokens, uint256[] memory amounts) {\n        LibBasketStorage.BasketStorage storage bs = LibBasketStorage.basketStorage();\n        uint256 totalSupply = LibERC20Storage.erc20Storage().totalSupply.add(calcOutStandingAnnualizedFee());\n\n        tokens = new address[](bs.tokens.length);\n        amounts = new uint256[](bs.tokens.length);\n\n        for(uint256 i; i < bs.tokens.length; i ++) {\n            IERC20 token = bs.tokens[i];\n            uint256 tokenBalance = balance(address(token));\n            uint256 tokenAmount = tokenBalance.mul(_amount).div(totalSupply);\n            // Add entry fee\n            tokenAmount = tokenAmount.add(tokenAmount.mul(bs.entryFee).div(10**18));\n\n            tokens[i] = address(token);\n            amounts[i] = tokenAmount;\n        }\n\n        return(tokens, amounts);\n    }\n\n    function calcTokensForAmountExit(uint256 _amount) external view override returns (address[] memory tokens, uint256[] memory amounts) {\n        LibBasketStorage.BasketStorage storage bs = LibBasketStorage.basketStorage();\n        uint256 feeAmount = _amount.mul(bs.exitFee).div(10**18);\n        uint256 totalSupply = LibERC20Storage.erc20Storage().totalSupply.add(calcOutStandingAnnualizedFee());\n\n        tokens = new address[](bs.tokens.length);\n        amounts = new uint256[](bs.tokens.length);\n\n        for(uint256 i; i < bs.tokens.length; i ++) {\n            IERC20 token = bs.tokens[i];\n            uint256 tokenBalance = balance(address(token));\n            uint256 tokenAmount = tokenBalance.mul(_amount.sub(feeAmount)).div(totalSupply);\n\n            tokens[i] = address(token);\n            amounts[i] = tokenAmount;\n        }\n\n        return(tokens, amounts);\n    }\n}"
    }
  ]
}