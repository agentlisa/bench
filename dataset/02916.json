{
  "Title": "M-9: Priority withdrawal sequence array will grow infinitely over time",
  "Content": "# Issue M-9: Priority withdrawal sequence array will grow infinitely over time \n\nSource: https://github.com/sherlock-audit/2022-10-union-finance-judging/issues/76 \n\n## Found by \nhyh, hansfriese, yixxas, GimelSec, Lambda\n\n## Summary\n\nWithdraw sequence reduction operation isn't present on adapter removal, while new withdraw sequence is required to have the same length as the old one if set directly. I.e. this withdraw sequence length is kept as current invariant, which only increases on each adapter addition, this way growing indefinitely over time.\n\n## Vulnerability Detail\n\nEach `removeAdapter() -> addAdapter()` operation sequence makes `withdrawSeq` array to be `1` item longer, while `moneyMarkets` array preserves its length. As `withdrawSeq` is just an ordering of `moneyMarkets`, this is not desirable, but cannot be directly fixed as administrative setWithdrawSequence() requires the length to be preserved, while additional addAdapter() operations keep the length difference.\n\nAs an example, suppose the system operates long enough and now there are `5` adapters, while removeAdapter() was run 50 times since the contract deployment. `withdrawSeq` will have length of `55` and it is impossible to reduce it.\n\n## Impact\n\nAll the users end up paying increased gas costs as AssetManager's withdraw() iterates over the full `withdrawSeq` array.\n\nOver time the length of this array will increase to make withdraw() requiring too much gas, making the operation oftentimes economically non-viable. This is temporal funds freeze, i.e. a rational user will have to delay the withdrawal up to the moment when bloated gas cost will become justified, not being able to withdraw funds without an additional loss bigger than an acceptable threshold until then.\n\nWith the further growth of the `withdrawSeq`, the block gas limit can be surpassed, making the operation overall forbidden. This is permanent fund freeze impact conditional on system being in production long enough.\n\n## Code Snippet\n\nsetWithdrawSequence() requires new sequence array to be the same size as the current `withdrawSeq`:\n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/asset/AssetManager.sol#L135-L142\n\n```solidity\n    /**\n     *  @dev Set withdraw sequence\n     *  @param newSeq priority sequence of money market indices to be used while withdrawing\n     */\n    function setWithdrawSequence(uint256[] calldata newSeq) external override onlyAdmin {\n        if (newSeq.length != withdrawSeq.length) revert NotParity();\n        withdrawSeq = newSeq;\n    }\n```\n\nremoveAdapter() reduces the length of the `moneyMarkets` array, but not of the `withdrawSeq` array:\n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/asset/AssetManager.sol#L436-L457\n\n```solidity\n    /**\n     *  @dev Remove a adapter for the underlying lending protocol\n     *  @param adapterAddress adapter address\n     */\n    function removeAdapter(address adapterAddress) external override onlyAdmin {\n        bool isExist = false;\n        uint256 index;\n        uint256 moneyMarketsLength = moneyMarkets.length;\n\n        for (uint256 i = 0; i < moneyMarketsLength; i++) {\n            if (adapterAddress == address(moneyMarkets[i])) {\n                isExist = true;\n                index = i;\n                break;\n            }\n        }\n\n        if (isExist) {\n            moneyMarkets[index] = moneyMarkets[moneyMarketsLength - 1];\n            moneyMarkets.pop();\n        }\n    }\n```\n\nIn the same time addAdapter() increases both `moneyMarkets` and `withdrawSeq` arrays by one when being called with `adapterAddress` that's not already present:\n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/asset/AssetManager.sol#L416-L434\n\n```solidity\n    /**\n     *  @dev Add a new adapter for the underlying lending protocol\n     *  @param adapterAddress adapter address\n     */\n    function addAdapter(address adapterAddress) external override onlyAdmin {\n        bool isExist = false;\n        uint256 moneyMarketsLength = moneyMarkets.length;\n\n        for (uint256 i = 0; i < moneyMarketsLength; i++) {\n            if (adapterAddress == address(moneyMarkets[i])) isExist = true;\n        }\n\n        if (!isExist) {\n            moneyMarkets.push(IMoneyMarketAdapter(adapterAddress));\n            withdrawSeq.push(moneyMarkets.length - 1);\n        }\n\n        approveAllTokensMax(adapterAddress);\n    }\n```\n\nwithdraw() iterates over the full `withdrawSeq` array each time:\n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/asset/AssetManager.sol#L345-L359\n\n```solidity\n        if (isMarketSupported(token)) {\n            uint256 withdrawSeqLength = withdrawSeq.length;\n            // iterate markets according to defined sequence and withdraw\n            for (uint256 i = 0; i < withdrawSeqLength && remaining > 0; i++) {\n                IMoneyMarketAdapter moneyMarket = moneyMarkets[withdrawSeq[i]];\n                if (!moneyMarket.supportsToken(token)) continue;\n\n                uint256 supply = moneyMarket.getSupply(token);\n                if (supply == 0) continue;\n\n                uint256 withdrawAmount = supply < remaining ? supply : remaining;\n                remaining -= withdrawAmount;\n                moneyMarket.withdraw(token, account, withdrawAmount);\n            }\n        }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider updating the setWithdrawSequence() logic to require new sequence array to be the same size as `moneyMarkets` whose ordering it represents:\n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/asset/AssetManager.sol#L135-L142\n\n```solidity\n    /**\n     *  @dev Set withdraw sequence\n     *  @param newSeq priority sequence of money market indices to be used while withdrawing\n     */\n    function setWithdrawSequence(uint256[] calldata newSeq) external override onlyAdmin {\n-       if (newSeq.length != withdrawSeq.length) revert NotParity();\n+       if (newSeq.length != moneyMarkets.length) revert NotParity();\n        withdrawSeq = newSeq;\n    }\n```\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/11",
  "Code": [
    {
      "filename": "union-v2-contracts/contracts/asset/AssetManager.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport {Controller} from \"../Controller.sol\";\nimport {IAssetManager} from \"../interfaces/IAssetManager.sol\";\nimport {IMarketRegistry} from \"../interfaces/IMarketRegistry.sol\";\nimport {IMoneyMarketAdapter} from \"../interfaces/IMoneyMarketAdapter.sol\";\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\n/**\n *  @title AssetManager\n *  @author Union\n *  @dev  Manage the token assets deposited by components and admins, and invest\n *        tokens to the integrated underlying lending protocols.\n */\ncontract AssetManager is Controller, ReentrancyGuardUpgradeable, IAssetManager {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address;\n\n    /* -------------------------------------------------------------------\n      Storage \n    ------------------------------------------------------------------- */\n\n    /**\n     * @dev Address of market registry\n     */\n    address public marketRegistry;\n\n    /**\n     * @dev Withdraw Seuqence\n     * @dev Priority sequence of money market indices for processing withdraws\n     */\n    uint256[] public withdrawSeq;\n\n    /**\n     * @dev Record admin or userManager balance\n     * @dev Maps user to token to balance\n     */\n    mapping(address => mapping(address => uint256)) public balances;\n\n    /**\n     * @dev Total balance of a token\n     * @dev Maps token to balance (deposited)\n     */\n    mapping(address => uint256) public totalPrincipal;\n\n    /**\n     * @dev Supported markets\n     * @dev Mapping of tokens to boolean (isSupported)\n     */\n    mapping(address => bool) public supportedMarkets;\n\n    /**\n     * @dev Money Market Adapters\n     */\n    IMoneyMarketAdapter[] public moneyMarkets;\n\n    /**\n     * @dev Supported tokens\n     */\n    address[] public supportedTokensList;\n\n    /* -------------------------------------------------------------------\n      Events \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Emit when making a deposit\n     *  @param token Depositing token address\n     *  @param account Account address\n     *  @param amount Deposit amount, in wei\n     */\n    event LogDeposit(address indexed token, address indexed account, uint256 amount);\n    /**\n     *  @dev Emit when withdrawing from AssetManager\n     *  @param token Depositing token address\n     *  @param account Account address\n     *  @param amount Withdraw amount, in wei\n     *  @param remaining The amount cannot be withdrawn\n     */\n    event LogWithdraw(address indexed token, address indexed account, uint256 amount, uint256 remaining);\n    /**\n     *  @dev Emit when rebalancing among the integrated money markets\n     *  @param tokenAddress The address of the token to be rebalanced\n     *  @param percentages Array of the percentages of the tokens to deposit to the money markets\n     */\n    event LogRebalance(address tokenAddress, uint256[] percentages);\n\n    /* -------------------------------------------------------------------\n      Errors \n    ------------------------------------------------------------------- */\n\n    error UnsupportedToken();\n    error AuthFailed();\n    error NotParity();\n    error AmountZero();\n    error InsufficientBalance();\n    error TokenExists();\n\n    /* -------------------------------------------------------------------\n      Constructor/Initializer \n    ------------------------------------------------------------------- */\n\n    function __AssetManager_init(address _marketRegistry) external initializer {\n        Controller.__Controller_init(msg.sender);\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        marketRegistry = _marketRegistry;\n    }\n\n    /* -------------------------------------------------------------------\n      Modifiers \n    ------------------------------------------------------------------- */\n\n    modifier checkMarketSupported(address token) {\n        if (!isMarketSupported(token)) revert UnsupportedToken();\n        _;\n    }\n\n    modifier onlyAuth(address token) {\n        if (!(_isUToken(msg.sender, token) || _isUserManager(msg.sender, token))) revert AuthFailed();\n        _;\n    }\n\n    /* -------------------------------------------------------------------\n      Setters \n    ------------------------------------------------------------------- */\n\n    function setMarketRegistry(address _marketRegistry) external onlyAdmin {\n        marketRegistry = _marketRegistry;\n    }\n\n    /**\n     *  @dev Set withdraw sequence\n     *  @param newSeq priority sequence of money market indices to be used while withdrawing\n     */\n    function setWithdrawSequence(uint256[] calldata newSeq) external override onlyAdmin {\n        if (newSeq.length != withdrawSeq.length) revert NotParity();\n        withdrawSeq = newSeq;\n    }\n\n    /* -------------------------------------------------------------------\n      View Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Get the balance of asset manager, plus the total amount of tokens deposited to all the underlying lending protocols\n     *  @param tokenAddress ERC20 token address\n     *  @return Pool balance\n     */\n    function getPoolBalance(address tokenAddress) public view override returns (uint256) {\n        IERC20Upgradeable poolToken = IERC20Upgradeable(tokenAddress);\n        uint256 balance = poolToken.balanceOf(address(this));\n        if (isMarketSupported(tokenAddress)) {\n            return totalSupplyView(tokenAddress) + balance;\n        } else {\n            return balance;\n        }\n    }\n\n    /**\n     *  @dev Returns the amount of the lending pool balance minus the amount of total staked.\n     *  @param tokenAddress ERC20 token address\n     *  @return loanAmount Amount can be borrowed\n     */\n    function getLoanableAmount(address tokenAddress) public view override returns (uint256) {\n        uint256 poolBalance = getPoolBalance(tokenAddress);\n        return poolBalance > totalPrincipal[tokenAddress] ? poolBalance - totalPrincipal[tokenAddress] : 0;\n    }\n\n    /**\n     *  @dev Get the total amount of tokens deposited to all the integrated underlying protocols without side effects.\n     *  @param tokenAddress ERC20 token address\n     *  @return tokenSupply Total market balance\n     */\n    function totalSupply(address tokenAddress) external override returns (uint256) {\n        uint256 tokenSupply = 0;\n        if (isMarketSupported(tokenAddress)) {\n            uint256 moneyMarketsLength = moneyMarkets.length;\n            for (uint256 i = 0; i < moneyMarketsLength; i++) {\n                if (moneyMarkets[i].supportsToken(tokenAddress)) {\n                    tokenSupply += moneyMarkets[i].getSupply(tokenAddress);\n                }\n            }\n        }\n        return tokenSupply;\n    }\n\n    /**\n     *  @dev Get the total amount of tokens deposited to all the integrated underlying protocols, but without side effects. Safe to call anytime, but may not get the most updated number for the current block. Call totalSupply() for that purpose.\n     *  @param tokenAddress ERC20 token address\n     *  @return tokenSupply Total market balance\n     */\n    function totalSupplyView(address tokenAddress) public view override returns (uint256) {\n        uint256 tokenSupply = 0;\n        if (isMarketSupported(tokenAddress)) {\n            uint256 moneyMarketsLength = moneyMarkets.length;\n            for (uint256 i = 0; i < moneyMarketsLength; i++) {\n                if (moneyMarkets[i].supportsToken(tokenAddress)) {\n                    tokenSupply += moneyMarkets[i].getSupplyView(tokenAddress);\n                }\n            }\n        }\n        return tokenSupply;\n    }\n\n    /**\n     *  @dev Check if there is an underlying protocol available for the given ERC20 token.\n     *  @param tokenAddress ERC20 token address\n     *  @return Whether is supported\n     */\n    function isMarketSupported(address tokenAddress) public view override returns (bool) {\n        return supportedMarkets[tokenAddress];\n    }\n\n    /**\n     *  @dev Get the number of supported underlying protocols.\n     *  @return MoneyMarkets length\n     */\n    function moneyMarketsCount() external view override returns (uint256) {\n        return moneyMarkets.length;\n    }\n\n    /**\n     *  @dev Get the count of supported tokens\n     *  @return Number of supported tokens\n     */\n    function supportedTokensCount() external view override returns (uint256) {\n        return supportedTokensList.length;\n    }\n\n    /**\n     *  @dev Get the supported lending protocol\n     *  @param tokenAddress ERC20 token address\n     *  @param marketId MoneyMarkets array index\n     *  @return rate tokenSupply, rate(compound is supplyRatePerBlock 1e18, aave is supplyRatePerYear 1e27)\n     */\n    function getMoneyMarket(address tokenAddress, uint256 marketId)\n        external\n        view\n        override\n        returns (uint256 rate, uint256 tokenSupply)\n    {\n        rate = moneyMarkets[marketId].getRate(tokenAddress);\n        tokenSupply += moneyMarkets[marketId].getSupplyView(tokenAddress);\n    }\n\n    /* -------------------------------------------------------------------\n      Core Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev  Deposit tokens to AssetManager, and those tokens will be passed along to\n     *        adapters to deposit to integrated asset protocols if any is available.\n     *  @param token ERC20 token address\n     *  @param amount ERC20 token address\n     *  @return Deposited amount\n     */\n    function deposit(address token, uint256 amount)\n        external\n        override\n        whenNotPaused\n        onlyAuth(token)\n        nonReentrant\n        returns (bool)\n    {\n        IERC20Upgradeable poolToken = IERC20Upgradeable(token);\n        if (amount == 0) revert AmountZero();\n\n        if (!_isUToken(msg.sender, token)) {\n            balances[msg.sender][token] += amount;\n            totalPrincipal[token] += amount;\n        }\n\n        bool remaining = true;\n        if (isMarketSupported(token)) {\n            uint256 moneyMarketsLength = moneyMarkets.length;\n            // assumption: markets are arranged in order of decreasing liquidity\n            // iterate markets till floors are filled\n            // floors define minimum amount to maintain confidence in liquidity\n            for (uint256 i = 0; i < moneyMarketsLength && remaining; i++) {\n                IMoneyMarketAdapter moneyMarket = moneyMarkets[i];\n\n                if (!moneyMarket.supportsToken(token)) continue;\n                if (moneyMarket.floorMap(token) <= moneyMarket.getSupply(token)) continue;\n\n                poolToken.safeTransferFrom(msg.sender, address(moneyMarket), amount);\n                moneyMarket.deposit(token);\n                remaining = false;\n            }\n\n            // assumption: less liquid markets provide more yield\n            // iterate markets in reverse to optimize for yield\n            // do this only if floors are filled i.e. min liquidity satisfied\n            // deposit in the market where ceiling is not being exceeded\n            for (uint256 j = moneyMarketsLength; j > 0 && remaining; j--) {\n                IMoneyMarketAdapter moneyMarket = moneyMarkets[j - 1];\n                if (!moneyMarket.supportsToken(token)) continue;\n\n                uint256 supply = moneyMarket.getSupply(token);\n                uint256 ceiling = moneyMarket.ceilingMap(token);\n                if (supply + amount > ceiling) continue;\n\n                poolToken.safeTransferFrom(msg.sender, address(moneyMarket), amount);\n                moneyMarket.deposit(token);\n                remaining = false;\n            }\n        }\n\n        if (remaining) {\n            poolToken.safeTransferFrom(msg.sender, address(this), amount);\n        }\n\n        emit LogDeposit(token, msg.sender, amount);\n\n        return true;\n    }\n\n    /**\n     *  @dev Withdraw from AssetManager\n     *  @param token ERC20 token address\n     *  @param account User address\n     *  @param amount ERC20 token address\n     *  @return Withdraw amount\n     */\n    function withdraw(\n        address token,\n        address account,\n        uint256 amount\n    ) external override whenNotPaused nonReentrant onlyAuth(token) returns (bool) {\n        if (!_checkSenderBalance(msg.sender, token, amount)) revert InsufficientBalance();\n\n        uint256 remaining = amount;\n\n        // If there are tokens in Asset Manager then transfer them on priority\n        uint256 selfBalance = IERC20Upgradeable(token).balanceOf(address(this));\n        if (selfBalance > 0) {\n            uint256 withdrawAmount = selfBalance < remaining ? selfBalance : remaining;\n            remaining -= withdrawAmount;\n            IERC20Upgradeable(token).safeTransfer(account, withdrawAmount);\n        }\n\n        if (isMarketSupported(token)) {\n            uint256 withdrawSeqLength = withdrawSeq.length;\n            // iterate markets according to defined sequence and withdraw\n            for (uint256 i = 0; i < withdrawSeqLength && remaining > 0; i++) {\n                IMoneyMarketAdapter moneyMarket = moneyMarkets[withdrawSeq[i]];\n                if (!moneyMarket.supportsToken(token)) continue;\n\n                uint256 supply = moneyMarket.getSupply(token);\n                if (supply == 0) continue;\n\n                uint256 withdrawAmount = supply < remaining ? supply : remaining;\n                remaining -= withdrawAmount;\n                moneyMarket.withdraw(token, account, withdrawAmount);\n            }\n        }\n\n        if (!_isUToken(msg.sender, token)) {\n            balances[msg.sender][token] = balances[msg.sender][token] - amount + remaining;\n            totalPrincipal[token] = totalPrincipal[token] - amount + remaining;\n        }\n\n        emit LogWithdraw(token, account, amount, remaining);\n\n        return true;\n    }\n\n    /**\n     * @dev Write of Debt\n     */\n    function debtWriteOff(address token, uint256 amount) external override {\n        if (balances[msg.sender][token] < amount) revert InsufficientBalance();\n        balances[msg.sender][token] -= amount;\n        totalPrincipal[token] -= amount;\n    }\n\n    /**\n     *  @dev Add a new ERC20 token to support in AssetManager\n     *  @param tokenAddress ERC20 token address\n     */\n    function addToken(address tokenAddress) external override onlyAdmin {\n        if (supportedMarkets[tokenAddress]) revert TokenExists();\n        supportedTokensList.push(tokenAddress);\n        supportedMarkets[tokenAddress] = true;\n\n        approveAllMarketsMax(tokenAddress);\n    }\n\n    /**\n     *  @dev Remove a ERC20 token to support in AssetManager\n     *  @param tokenAddress ERC20 token address\n     */\n    function removeToken(address tokenAddress) external override onlyAdmin {\n        bool isExist = false;\n        uint256 index;\n        uint256 supportedTokensLength = supportedTokensList.length;\n\n        for (uint256 i = 0; i < supportedTokensLength; i++) {\n            if (tokenAddress == address(supportedTokensList[i])) {\n                isExist = true;\n                index = i;\n                break;\n            }\n        }\n\n        if (isExist) {\n            supportedTokensList[index] = supportedTokensList[supportedTokensLength - 1];\n            supportedTokensList.pop();\n            supportedMarkets[tokenAddress] = false;\n        }\n    }\n\n    /**\n     *  @dev Add a new adapter for the underlying lending protocol\n     *  @param adapterAddress adapter address\n     */\n    function addAdapter(address adapterAddress) external override onlyAdmin {\n        bool isExist = false;\n        uint256 moneyMarketsLength = moneyMarkets.length;\n\n        for (uint256 i = 0; i < moneyMarketsLength; i++) {\n            if (adapterAddress == address(moneyMarkets[i])) isExist = true;\n        }\n\n        if (!isExist) {\n            moneyMarkets.push(IMoneyMarketAdapter(adapterAddress));\n            withdrawSeq.push(moneyMarkets.length - 1);\n        }\n\n        approveAllTokensMax(adapterAddress);\n    }\n\n    /**\n     *  @dev Remove a adapter for the underlying lending protocol\n     *  @param adapterAddress adapter address\n     */\n    function removeAdapter(address adapterAddress) external override onlyAdmin {\n        bool isExist = false;\n        uint256 index;\n        uint256 moneyMarketsLength = moneyMarkets.length;\n\n        for (uint256 i = 0; i < moneyMarketsLength; i++) {\n            if (adapterAddress == address(moneyMarkets[i])) {\n                isExist = true;\n                index = i;\n                break;\n            }\n        }\n\n        if (isExist) {\n            moneyMarkets[index] = moneyMarkets[moneyMarketsLength - 1];\n            moneyMarkets.pop();\n        }\n    }\n\n    /**\n     *  @dev For a give token set allowance for all integrated money markets\n     *  @param tokenAddress ERC20 token address\n     */\n    function approveAllMarketsMax(address tokenAddress) public override onlyAdmin {\n        IERC20Upgradeable poolToken = IERC20Upgradeable(tokenAddress);\n        uint256 moneyMarketsLength = moneyMarkets.length;\n        for (uint256 i = 0; i < moneyMarketsLength; i++) {\n            poolToken.safeApprove(address(moneyMarkets[i]), 0);\n            poolToken.safeApprove(address(moneyMarkets[i]), type(uint256).max);\n        }\n    }\n\n    /**\n     *  @dev For a give moeny market set allowance for all underlying tokens\n     *  @param adapterAddress Address of adaptor for money market\n     */\n    function approveAllTokensMax(address adapterAddress) public override onlyAdmin {\n        uint256 supportedTokensLength = supportedTokensList.length;\n        for (uint256 i = 0; i < supportedTokensLength; i++) {\n            IERC20Upgradeable poolToken = IERC20Upgradeable(supportedTokensList[i]);\n            poolToken.safeApprove(adapterAddress, 0);\n            poolToken.safeApprove(adapterAddress, type(uint256).max);\n        }\n    }\n\n    /**\n     * @dev Take all the supply of `tokenAddress` and redistribute it according to `percentages`.\n     *\n     * Rejects if the token is not supported.\n     *\n     * @param tokenAddress Address of the token that is going to be rebalanced\n     * @param percentages A list of percentages, expressed as units in 10000, indicating how to deposit the tokens in\n     * each underlying money market. The length of this array is one less than the amount of money markets: the last\n     * money market will receive the remaining tokens. For example, if there are 3 money markets, and you want to\n     * rebalance so that the first one has 10.5% of the tokens, the second one 55%, and the third one 34.5%, this param\n     * will be [1050, 5500].\n     */\n    function rebalance(address tokenAddress, uint256[] calldata percentages)\n        external\n        override\n        onlyAdmin\n        checkMarketSupported(tokenAddress)\n    {\n        IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n        uint256 moneyMarketsLength = moneyMarkets.length;\n        uint256 percentagesLength = percentages.length;\n\n        IMoneyMarketAdapter[] memory supportedMoneyMarkets = new IMoneyMarketAdapter[](moneyMarketsLength);\n        uint256 supportedMoneyMarketsSize;\n\n        // Loop through each money market and withdraw all the tokens\n        for (uint256 i = 0; i < moneyMarketsLength; i++) {\n            IMoneyMarketAdapter moneyMarket = moneyMarkets[i];\n            if (!moneyMarket.supportsToken(tokenAddress)) continue;\n            moneyMarket.withdrawAll(tokenAddress, address(this));\n\n            supportedMoneyMarkets[supportedMoneyMarketsSize] = moneyMarket;\n            supportedMoneyMarketsSize++;\n        }\n\n        if (percentagesLength + 1 != supportedMoneyMarketsSize) revert NotParity();\n\n        uint256 tokenSupply = token.balanceOf(address(this));\n\n        for (uint256 i = 0; i < percentagesLength; i++) {\n            IMoneyMarketAdapter moneyMarket = supportedMoneyMarkets[i];\n            uint256 amountToDeposit = (tokenSupply * percentages[i]) / 10000;\n            if (amountToDeposit == 0) continue;\n            token.safeTransfer(address(moneyMarket), amountToDeposit);\n            moneyMarket.deposit(tokenAddress);\n        }\n\n        uint256 remainingTokens = token.balanceOf(address(this));\n\n        IMoneyMarketAdapter lastMoneyMarket = supportedMoneyMarkets[supportedMoneyMarketsSize - 1];\n        if (remainingTokens > 0) {\n            token.safeTransfer(address(lastMoneyMarket), remainingTokens);\n            lastMoneyMarket.deposit(tokenAddress);\n        }\n\n        emit LogRebalance(tokenAddress, percentages);\n    }\n\n    /* -------------------------------------------------------------------\n      Internal Functions \n    ------------------------------------------------------------------- */\n\n    function _checkSenderBalance(\n        address sender,\n        address tokenAddress,\n        uint256 amount\n    ) private view returns (bool) {\n        if (_isUToken(sender, tokenAddress)) {\n            // For all the lending markets, which have no deposits, return the tokens from the pool\n            return getLoanableAmount(tokenAddress) >= amount;\n        }\n\n        return balances[sender][tokenAddress] >= amount;\n    }\n\n    function _isUToken(address sender, address token) private view returns (bool) {\n        return IMarketRegistry(marketRegistry).uTokens(token) == sender;\n    }\n\n    function _isUserManager(address sender, address token) private view returns (bool) {\n        return IMarketRegistry(marketRegistry).userManagers(token) == sender;\n    }\n}"
    },
    {
      "filename": "union-v2-contracts/contracts/asset/AssetManager.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport {Controller} from \"../Controller.sol\";\nimport {IAssetManager} from \"../interfaces/IAssetManager.sol\";\nimport {IMarketRegistry} from \"../interfaces/IMarketRegistry.sol\";\nimport {IMoneyMarketAdapter} from \"../interfaces/IMoneyMarketAdapter.sol\";\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\n/**\n *  @title AssetManager\n *  @author Union\n *  @dev  Manage the token assets deposited by components and admins, and invest\n *        tokens to the integrated underlying lending protocols.\n */\ncontract AssetManager is Controller, ReentrancyGuardUpgradeable, IAssetManager {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address;\n\n    /* -------------------------------------------------------------------\n      Storage \n    ------------------------------------------------------------------- */\n\n    /**\n     * @dev Address of market registry\n     */\n    address public marketRegistry;\n\n    /**\n     * @dev Withdraw Seuqence\n     * @dev Priority sequence of money market indices for processing withdraws\n     */\n    uint256[] public withdrawSeq;\n\n    /**\n     * @dev Record admin or userManager balance\n     * @dev Maps user to token to balance\n     */\n    mapping(address => mapping(address => uint256)) public balances;\n\n    /**\n     * @dev Total balance of a token\n     * @dev Maps token to balance (deposited)\n     */\n    mapping(address => uint256) public totalPrincipal;\n\n    /**\n     * @dev Supported markets\n     * @dev Mapping of tokens to boolean (isSupported)\n     */\n    mapping(address => bool) public supportedMarkets;\n\n    /**\n     * @dev Money Market Adapters\n     */\n    IMoneyMarketAdapter[] public moneyMarkets;\n\n    /**\n     * @dev Supported tokens\n     */\n    address[] public supportedTokensList;\n\n    /* -------------------------------------------------------------------\n      Events \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Emit when making a deposit\n     *  @param token Depositing token address\n     *  @param account Account address\n     *  @param amount Deposit amount, in wei\n     */\n    event LogDeposit(address indexed token, address indexed account, uint256 amount);\n    /**\n     *  @dev Emit when withdrawing from AssetManager\n     *  @param token Depositing token address\n     *  @param account Account address\n     *  @param amount Withdraw amount, in wei\n     *  @param remaining The amount cannot be withdrawn\n     */\n    event LogWithdraw(address indexed token, address indexed account, uint256 amount, uint256 remaining);\n    /**\n     *  @dev Emit when rebalancing among the integrated money markets\n     *  @param tokenAddress The address of the token to be rebalanced\n     *  @param percentages Array of the percentages of the tokens to deposit to the money markets\n     */\n    event LogRebalance(address tokenAddress, uint256[] percentages);\n\n    /* -------------------------------------------------------------------\n      Errors \n    ------------------------------------------------------------------- */\n\n    error UnsupportedToken();\n    error AuthFailed();\n    error NotParity();\n    error AmountZero();\n    error InsufficientBalance();\n    error TokenExists();\n\n    /* -------------------------------------------------------------------\n      Constructor/Initializer \n    ------------------------------------------------------------------- */\n\n    function __AssetManager_init(address _marketRegistry) external initializer {\n        Controller.__Controller_init(msg.sender);\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        marketRegistry = _marketRegistry;\n    }\n\n    /* -------------------------------------------------------------------\n      Modifiers \n    ------------------------------------------------------------------- */\n\n    modifier checkMarketSupported(address token) {\n        if (!isMarketSupported(token)) revert UnsupportedToken();\n        _;\n    }\n\n    modifier onlyAuth(address token) {\n        if (!(_isUToken(msg.sender, token) || _isUserManager(msg.sender, token))) revert AuthFailed();\n        _;\n    }\n\n    /* -------------------------------------------------------------------\n      Setters \n    ------------------------------------------------------------------- */\n\n    function setMarketRegistry(address _marketRegistry) external onlyAdmin {\n        marketRegistry = _marketRegistry;\n    }\n\n    /**\n     *  @dev Set withdraw sequence\n     *  @param newSeq priority sequence of money market indices to be used while withdrawing\n     */\n    function setWithdrawSequence(uint256[] calldata newSeq) external override onlyAdmin {\n        if (newSeq.length != withdrawSeq.length) revert NotParity();\n        withdrawSeq = newSeq;\n    }\n\n    /* -------------------------------------------------------------------\n      View Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Get the balance of asset manager, plus the total amount of tokens deposited to all the underlying lending protocols\n     *  @param tokenAddress ERC20 token address\n     *  @return Pool balance\n     */\n    function getPoolBalance(address tokenAddress) public view override returns (uint256) {\n        IERC20Upgradeable poolToken = IERC20Upgradeable(tokenAddress);\n        uint256 balance = poolToken.balanceOf(address(this));\n        if (isMarketSupported(tokenAddress)) {\n            return totalSupplyView(tokenAddress) + balance;\n        } else {\n            return balance;\n        }\n    }\n\n    /**\n     *  @dev Returns the amount of the lending pool balance minus the amount of total staked.\n     *  @param tokenAddress ERC20 token address\n     *  @return loanAmount Amount can be borrowed\n     */\n    function getLoanableAmount(address tokenAddress) public view override returns (uint256) {\n        uint256 poolBalance = getPoolBalance(tokenAddress);\n        return poolBalance > totalPrincipal[tokenAddress] ? poolBalance - totalPrincipal[tokenAddress] : 0;\n    }\n\n    /**\n     *  @dev Get the total amount of tokens deposited to all the integrated underlying protocols without side effects.\n     *  @param tokenAddress ERC20 token address\n     *  @return tokenSupply Total market balance\n     */\n    function totalSupply(address tokenAddress) external override returns (uint256) {\n        uint256 tokenSupply = 0;\n        if (isMarketSupported(tokenAddress)) {\n            uint256 moneyMarketsLength = moneyMarkets.length;\n            for (uint256 i = 0; i < moneyMarketsLength; i++) {\n                if (moneyMarkets[i].supportsToken(tokenAddress)) {\n                    tokenSupply += moneyMarkets[i].getSupply(tokenAddress);\n                }\n            }\n        }\n        return tokenSupply;\n    }\n\n    /**\n     *  @dev Get the total amount of tokens deposited to all the integrated underlying protocols, but without side effects. Safe to call anytime, but may not get the most updated number for the current block. Call totalSupply() for that purpose.\n     *  @param tokenAddress ERC20 token address\n     *  @return tokenSupply Total market balance\n     */\n    function totalSupplyView(address tokenAddress) public view override returns (uint256) {\n        uint256 tokenSupply = 0;\n        if (isMarketSupported(tokenAddress)) {\n            uint256 moneyMarketsLength = moneyMarkets.length;\n            for (uint256 i = 0; i < moneyMarketsLength; i++) {\n                if (moneyMarkets[i].supportsToken(tokenAddress)) {\n                    tokenSupply += moneyMarkets[i].getSupplyView(tokenAddress);\n                }\n            }\n        }\n        return tokenSupply;\n    }\n\n    /**\n     *  @dev Check if there is an underlying protocol available for the given ERC20 token.\n     *  @param tokenAddress ERC20 token address\n     *  @return Whether is supported\n     */\n    function isMarketSupported(address tokenAddress) public view override returns (bool) {\n        return supportedMarkets[tokenAddress];\n    }\n\n    /**\n     *  @dev Get the number of supported underlying protocols.\n     *  @return MoneyMarkets length\n     */\n    function moneyMarketsCount() external view override returns (uint256) {\n        return moneyMarkets.length;\n    }\n\n    /**\n     *  @dev Get the count of supported tokens\n     *  @return Number of supported tokens\n     */\n    function supportedTokensCount() external view override returns (uint256) {\n        return supportedTokensList.length;\n    }\n\n    /**\n     *  @dev Get the supported lending protocol\n     *  @param tokenAddress ERC20 token address\n     *  @param marketId MoneyMarkets array index\n     *  @return rate tokenSupply, rate(compound is supplyRatePerBlock 1e18, aave is supplyRatePerYear 1e27)\n     */\n    function getMoneyMarket(address tokenAddress, uint256 marketId)\n        external\n        view\n        override\n        returns (uint256 rate, uint256 tokenSupply)\n    {\n        rate = moneyMarkets[marketId].getRate(tokenAddress);\n        tokenSupply += moneyMarkets[marketId].getSupplyView(tokenAddress);\n    }\n\n    /* -------------------------------------------------------------------\n      Core Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev  Deposit tokens to AssetManager, and those tokens will be passed along to\n     *        adapters to deposit to integrated asset protocols if any is available.\n     *  @param token ERC20 token address\n     *  @param amount ERC20 token address\n     *  @return Deposited amount\n     */\n    function deposit(address token, uint256 amount)\n        external\n        override\n        whenNotPaused\n        onlyAuth(token)\n        nonReentrant\n        returns (bool)\n    {\n        IERC20Upgradeable poolToken = IERC20Upgradeable(token);\n        if (amount == 0) revert AmountZero();\n\n        if (!_isUToken(msg.sender, token)) {\n            balances[msg.sender][token] += amount;\n            totalPrincipal[token] += amount;\n        }\n\n        bool remaining = true;\n        if (isMarketSupported(token)) {\n            uint256 moneyMarketsLength = moneyMarkets.length;\n            // assumption: markets are arranged in order of decreasing liquidity\n            // iterate markets till floors are filled\n            // floors define minimum amount to maintain confidence in liquidity\n            for (uint256 i = 0; i < moneyMarketsLength && remaining; i++) {"
    }
  ]
}