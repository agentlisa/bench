{
  "Title": "M-17: OOG / unexpected reverts due to incorrect usage of staticcall.",
  "Content": "# Issue M-17: OOG / unexpected reverts due to incorrect usage of staticcall. \n\nSource: https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/822 \n\n## Found by \ncarrotsmuggler, ctf\\_sec\n\nOOG / unexpected reverts due to incorrect usage of staticcall.\n\n## Vulnerability Detail\n\nThe function `checkReentrancy` in `BalancerUtilities.sol` is used to check if the balancer contract has been re-entered or not. It does this by doing a `staticcall` on the pool contract and checking the return value. According to the solidity docs, if a staticcall encounters a state change, it burns up all gas and returns. The `checkReentrancy` tries to call `manageUserBalance` on the vault contract, and returns if it finds a state change.\n\nThe issue is that this burns up all the gas sent with the call. According to EIP150, a call gets allocated 63/64 bits of the gas, and the entire 63/64 parts of the gas is burnt up after the staticcall, since the staticcall will always encounter a storage change. This is also highlighted in the balancer monorepo, which has guidelines on how to check re-entrancy [here](https://github.com/balancer/balancer-v2-monorepo/blob/227683919a7031615c0bc7f144666cdf3883d212/pkg/pool-utils/contracts/lib/VaultReentrancyLib.sol#L43-L55).\n\nThis can also be shown with a simple POC.\n\n```solidity\nunction testAttack() public {\n        mockRootPrice(WSTETH, 1_123_300_000_000_000_000); //wstETH\n        mockRootPrice(CBETH, 1_034_300_000_000_000_000); //cbETH\n\n        IBalancerMetaStablePool pool = IBalancerMetaStablePool(WSTETH_CBETH_POOL);\n\n        address[] memory assets = new address[](2);\n        assets[0] = WSTETH;\n        assets[1] = CBETH;\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = 10_000 ether;\n        amounts[1] = 0;\n\n        IBalancerVault.JoinPoolRequest memory joinRequest = IBalancerVault.JoinPoolRequest({\n            assets: assets,\n            maxAmountsIn: amounts, // maxAmountsIn,\n            userData: abi.encode(\n                IBalancerVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,\n                amounts, //maxAmountsIn,\n                0\n            ),\n            fromInternalBalance: false\n        });\n\n        IBalancerVault.SingleSwap memory swapRequest = IBalancerVault.SingleSwap({\n            poolId: 0x9c6d47ff73e0f5e51be5fd53236e3f595c5793f200020000000000000000042c,\n            kind: IBalancerVault.SwapKind.GIVEN_IN,\n            assetIn: WSTETH,\n            assetOut: CBETH,\n            amount: amounts[0],\n            userData: abi.encode(\n                IBalancerVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,\n                amounts, //maxAmountsIn,\n                0\n            )\n        });\n\n        IBalancerVault.FundManagement memory funds = IBalancerVault.FundManagement({\n            sender: address(this),\n            fromInternalBalance: false,\n            recipient: payable(address(this)),\n            toInternalBalance: false\n        });\n\n        emit log_named_uint(\"Gas before price1\", gasleft());\n        uint256 price1 = oracle.getPriceInEth(WSTETH_CBETH_POOL);\n        emit log_named_uint(\"price1\", price1);\n        emit log_named_uint(\"Gas after price1 \", gasleft());\n    }\n```\n\nThe oracle is called to get a price. This oracle calls the `checkReentrancy` function and burns up the gas. The gas left is checked before and after this call.\n\nThe output shows this:\n\n```bash\n[PASS] testAttack() (gas: 9203730962297323943)\nLogs:\nGas before price1: 9223372036854745204\nprice1: 1006294352158612428\nGas after price1 : 425625349158468958\n```\n\nThis shows that 96% of the gas sent is burnt up in the oracle call.\n\n## Impact\n\nThis causes the contract to burn up 63/64 bits of gas in a single check. If there are lots of operations after this call, the call can revert due to running out of gas. This can lead to a DOS of the contract.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/libs/BalancerUtilities.sol#L19-L28\n\n## Tool used\n\nFoundry\n\n## Recommendation\n\nAccording to the monorepo [here](https://github.com/balancer/balancer-v2-monorepo/blob/227683919a7031615c0bc7f144666cdf3883d212/pkg/pool-utils/contracts/lib/VaultReentrancyLib.sol#L43-L55), the staticall must be allocated a fixed amount of gas. Change the reentrancy check to the following.\n\n```solidity\n(, bytes memory revertData) = address(vault).staticcall{ gas: 10_000 }(\n            abi.encodeWithSelector(vault.manageUserBalance.selector, 0)\n        );\n```\n\nThis ensures gas isn't burnt up without reason.\n\n\n\n## Discussion\n\n**JeffCX**\n\nEscalate\n\npolitely dispute that the severity is high because the transaction that meant to check the reentrancy burn too much gas and can revert and can block withdraw of fund or at least constantly burn all amount of gas and make user lose money\n\nin a single transaction, the cost burnt can by minimal, but suppose the user send 10000 transaction, the gas burnt lose add up \n\n**sherlock-admin2**\n\n > Escalate\n> \n> politely dispute that the severity is high because the transaction that meant to check the reentrancy burn too much gas and can revert and can block withdraw of fund or at least constantly burn all amount of gas and make user lose money\n> \n> in a single transaction, the cost burnt can by minimal, but suppose the user send 10000 transaction, the gas burnt lose add up \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> This issue should be a Low. \n> \n> The reason is that it will only consume all gas if the staticcall reverts, which means a re-entrancy is detected. For normal usage of the application, there will not be any re-entrancy. Thus, the normal users who use the protocol in the intended manner will not be affected by this issue. \n> \n> It will only consume all the gas of attackers trying to carry out a re-entrancy attack against the protocol. In this case, the attacker will not get the gas refund when the re-entrancy detection reverts. \n> \n> The loss of gas refunding for the attacker is not a valid issue in Sherlock since we are protecting the users, not the malicious users attempting to perform a re-entrancy attack or someone using the features in an unintended manner that triggers the re-entrancy revert. In addition, the loss of gas refund is not substantial enough to be considered a Medium since the chance of innocent users triggering a re-entrancy is close to zero in real life.\n> \n> From the perspective of a smart contract, if an innocent external contract accidentally calls the Balancer protocol that passes the control to the contract and then calls Tokemak, which triggers a re-entrancy revert, such a contract is not operating correctly and should be fixed.\n\n    You've deleted an escalation for this issue.\n\n**JeffCX**\n\nWith full respect to senior watson's comment\n\n> The reason is that it will only consume all gas if the staticcall reverts, which means a re-entrancy is detected\n\nI have to dispute the statement above,\n\nPlease review the duplicate issue #837 as well\n\nthe old balancer reentrancy check version does not cap the staticcall gas limit\n\nbut the new version add the 10000 gas cap\n\nhttps://github.com/balancer/balancer-v2-monorepo/blob/227683919a7031615c0bc7f144666cdf3883d212/pkg/pool-utils/contracts/lib/VaultReentrancyLib.sol#L43-L55\n\nand the balancer team already clearly state that the static call always revert even the reentrancy is not detected\n\n```\n// However, use a static call so that it can be a view function (even though the function is non-view).\n// This allows the library to be used more widely, as some functions that need to be protected might be\n// view.\n//\n// This staticcall always reverts, but we need to make sure it doesn't fail due to a re-entrancy attack.\n// Staticcalls consume all gas forwarded to them on a revert caused by storage modification.\n// By default, almost the entire available gas is forwarded to the staticcall,\n// causing the entire call to revert with an 'out of gas' error.\n//\n// We set the gas limit to 10k for the staticcall to\n// avoid wasting gas when it reverts due to storage modification.\n// `manageUserBalance` is a non-reentrant function in the Vault, so calling it invokes `_enterNonReentrant`\n// in the `ReentrancyGuard` contract, reproduced here:\n//\n//    function _enterNonReentrant() private {\n//        // If the Vault is actually being reentered, it will revert in the first line, at the `_require` that\n//        // checks the reentrancy flag, with \"BAL#400\" (corresponding to Errors.REENTRANCY) in the revertData.\n//        // The full revertData will be: `abi.encodeWithSignature(\"Error(string)\", \"BAL#400\")`.\n//        _require(_status != _ENTERED, Errors.REENTRANCY);\n//\n//        // If the Vault is not being reentered, the check above will pass: but it will *still* revert,\n//        // because the next line attempts to modify storage during a staticcall. However, this type of\n//        // failure results in empty revertData.\n//        _status = _ENTERED;\n//    }\n```\n\nuse not capping the gas limit of static call means the user are constantly waste too much gas (let us say for a single call the user waste and lose 0.01 ETH at gas), after 20000 transaction the loss is cumulatively 200 ETH and has no upper limit of loss\n\nbecause the reason above\n\nthe balancer push a PR fix for this issue specifically, can see the PR\n\nhttps://github.com/balancer/balancer-v2-monorepo/pull/2467\n\ngas is either wasted or transaction revert and block withdraw, which is both really bad for user in long term, so the severity should be high instead of medium\n\n```\n//  If the Vault is not being reentered, the check above will pass: but it will *still* revert,\n//  because the next line attempts to modify storage during a staticcall. However, this type of\n//  failure results in empty revertData.\n```\n\n**carrotsmuggler**\n\nThe comment by the LSW is wrong. The POC clearly shows 90% of gas is consumed even when no re-entrancy is detected, i.e. for normal usage of the protocol.\n\nWhen there is reentrancy, the entire transaction reverts. If there is no reentrancy, the static call still reverts due to a state change. There is no reentrancy for the situation given in the POC.\n\nThe `manageUserBalance` call always does a state change. When a state change is encountered during a static call, the entire gas is burnt up and the execution reverts. This happens irrespective of reentrancy conditions.\n\n**xiaoming9090**\n\nThanks @JeffCX and @carrotsmuggler for your explanation. You are correct that the issue will happen irrespective of reentrancy conditions. The `manageUserBalance` function will trigger the `_enterNonReentrant` modifier. If there is no re-entrancy, this [line of code](https://github.com/balancer/balancer-v2-monorepo/pull/2467/files#diff-36f155e03e561d19a594fba949eb1929677863e769bd08861397f4c7396b0c71R66) will result in a state change that consume all the gas pass to it. I have deleted the escalation.\n\n**Trumpero**\n\nHello JeffCX, I believe that the loss of gas might not qualify as a valid high. According to the guidelines in Sherlock's [documentation](https://docs.sherlock.xyz/audits/judging/judging#viii.-list-of-issue-categories-that-are-considered-valid), the OOG matter will be deemed a medium severity issue. It could be considered high only in cases where it results in a complete blockage of all user funds indefinitely.\n\n**JeffCX**\n\nSir, I agree the OOG does not block user withdraw forever\n\nbut because the static call always revert and waste 63/64 gas when withdraw, the remaining 1 / 64 gas has to be enough to complete the transaction.\n\nthis means user are force to overpaying 100x more gas to complete the withdraw from balancer vault\n\n**we can make a analogy:**\n\nthe protocol open a bank, user put 10K fund into the bank, and the user should only pays for 1 USD transaction fee when withdraw the fund, \n\nbut the bank said, sorry because of a bug, everyone has to pay 100 USD to withdraw the fund, and this 100x cost applies every user in every withdrawal transaction, then the result is the withdraw is not really usable and cause consistent loss of fund\n\nthis 100x gas applies to all user in every withdrawal transaction that use the balancer vault and the loss of fund from gas has no upper bound, so I think a high severity is still justified.\n\n\n\n**Trumpero**\n\nHello, @JeffCX,\n\nThe Out Of Gas (OOG) situation renders users unable to call a method of the contracts due to insufficient gas. On the other hand, your issue poses a risk where users:\n\n- Couldn't call a method due to insufficient gas\n- Users can pay more fees to trigger the function\n\nFrom what I observe, the impact of your issue appears to be a subset of the impact caused by an OOG. Therefore, if the OOG is considered medium, your issue should be equal to or less than medium in severity. I would appreciate it if you could share your opinion on this.\n\n**JeffCX**\n\nYeap, it is a subset of impact caused by OOG, \n\nso Users can pay more fees to trigger the function, but as I already shown, every user needs to pay 100x gas more in every withdrawal transaction for balancer vault, so the lose of fund as gas is cumulatively high :)\n\n**Trumpero**\n\nI believe that in the scenario of an OOG/DOS, it represents the worst-case scenario for your issue. \nThis is because when an OOG/DOS happens, users will pay a gas fee without any results, resulting in a loss of their gas. Hence, the impact of an OOG can be rephrased as follows: \"users pay 100x gas fee but can't use the function\". On the other hand, your issue states that \"users pay 100x gas fee but sometime it fails\". Is that correct?\n\n**JeffCX**\n\nuser can pay 100x gas and use the function as long as the remaining 1/64 gas can complete the executions.\n\nin my original report\n\nhttps://github.com/sherlock-audit/2023-06-tokemak-judging/issues/837\n\nthe impact I summarized is:\n\n> the function may waste too much gas and result in an out of gas error and can block function call such as withdraw\n\nemm as for\n\n> users pay 100x gas fee but sometime it fails\n\nas long as user pay a lot of gas (which they should not, transaction can be processed), and if they do not pay that amount of gas, transaction fails\n\nand sir, just a friendly reminder\n\nmy original escalation is the severity should be high instead of medium based on the impact ðŸ‘ \n\n\n\n\n**Trumpero**\n\nCertainly, I comprehend that you are aiming to elevate the severity level of this issue. However, my stance remains that this issue should be classified as medium due to the following rationale:\n\nLet's consider a situation where Alice intends to initiate 2 methods. Method A results in a denial-of-service (DOS) due to an out-of-gas (OOG) scenario, while method B aligns with your described issue.\n\n1. Alice expends 1 ETH as a gas fee but is unable to execute method A. Even when she attempts to allocate 10 ETH for the gas fee, she still cannot trigger method A.\n\n2. Simultaneously, Alice expends 1 ETH as a gas fee but encounters an inability to execute method B. However, when she allocates 10 ETH for the gas fee, she successfully triggers method B.\n\nConsequently, we observe that method A costs Alice 11 ETH as a gas fee without any return, whereas method B costs Alice the same 11 ETH, yet she gains the opportunity to execute it. Hence, we can infer that method A is more susceptible than method B.\n\n**JeffCX**\n\nSir, I don't think the method A and method B example applies in the codebase and in this issue\n\nthere is only one method for user to withdraw share from the vault\n\nI can add more detail to explain how this impact withdraw using top-down approach\n\nUser can withdraw by calling withdraw in LMPVault.sol and triggers [_withdraw](https://github.com/sherlock-audit/2023-06-tokemak/blob/5d8e902ce33981a6506b1b5fb979a084602c6c9a/v2-core-audit-2023-07-14/src/vault/LMPVault.sol#L414)\n\nthe _withdraw calls the method [_calcUserWithdrawSharesToBurn](https://github.com/sherlock-audit/2023-06-tokemak/blob/5d8e902ce33981a6506b1b5fb979a084602c6c9a/v2-core-audit-2023-07-14/src/vault/LMPVault.sol#L472)\n\nthis calls [LMPDebt._calcUserWithdrawSharesToBurn](https://github.com/sherlock-audit/2023-06-tokemak/blob/5d8e902ce33981a6506b1b5fb979a084602c6c9a/v2-core-audit-2023-07-14/src/vault/LMPVault.sol#L442)\n\nwe need to know the [debt value](https://github.com/sherlock-audit/2023-06-tokemak/blob/5d8e902ce33981a6506b1b5fb979a084602c6c9a/v2-core-audit-2023-07-14/src/vault/libs/LMPDebt.sol#L253) by calling destVault.debtValue\n\nthis calls this [line of code](https://github.com/sherlock-audit/2023-06-tokemak/blob/5d8e902ce33981a6506b1b5fb979a084602c6c9a/v2-core-audit-2023-07-14/src/vault/DestinationVault.sol#L150)\n\nthis calls the [oracle code](https://github.com/sherlock-audit/2023-06-tokemak/blob/5d8e902ce33981a6506b1b5fb979a084602c6c9a/v2-core-audit-2023-07-14/src/vault/DestinationVault.sol#L328)\n\n```solidity\nuint256 price = _systemRegistry.rootPriceOracle().getPriceInEth(_underlying);\n```\n\nthen if the dest vault is the balancer vault, balancer reetrancy check is triggered to waste 63 / 64 waste in [oracle code](https://github.com/sherlock-audit/2023-06-tokemak/blob/5d8e902ce33981a6506b1b5fb979a084602c6c9a/v2-core-audit-2023-07-14/src/oracles/providers/BalancerLPComposableStableEthOracle.sol#L36)\n\nso there is no function A and function B call\n\nas long as user can withdraw and wants to withdraw share from balancer vault, 100x gas overpayment is required\n\n\n\n**JeffCX**\n\nI think we can treat this issue same as \"transaction missing slippage protection\"\n\nmissing slippage protection is consider a high severity finding, but user may not lose million in one single transaction, the loss depends on user's trading amount\n\nthe loss amount for individual transaction can be small but there are be a lot of user getting frontrunning and the missing slippage cause consistent leak of value\n\nall the above character applies to this finding as well\n\ncan refer back to my first analogy\n\n> the protocol open a bank, user put 10K fund into the bank, and the user should only pays for 1 USD transaction fee when withdraw the fund,\n\nbut the bank said, sorry because of a bug, everyone has to pay 100 USD to withdraw the fund, and this 100x cost applies every user in every withdrawal transaction, then the result is the withdraw is not really usable and cause consistent loss of fund\n\nthis 100x gas applies to all user in every withdrawal transaction that use the balancer vault and the loss of fund from gas has no upper bound, so I think a high severity is still justified.\n\n**Evert0x**\n\n> I think we can treat this issue same as \"transaction missing slippage protection\"\n\nYou are referring to the gas usage here? Putting a limit on the gas is not a task for the protocol, this is a task for the wallet someone is using. \n\nAs the escalation comment states\n> in a single transaction, the cost burnt can by minimal\n\nImpact is not significant enough for a high severity.\n\nCurrent opinion is to reject escalation and keep issue medium severity. \n\n**JeffCX**\n\n> Putting a limit on the gas is not a task for the protocol\n\nsir, please read the report again, the flawed logic in the code charge user 100x gas in every transaction in every withdrawal\n\n> in a single transaction, the cost burnt can by minimal\n\nthe most relevant comments is https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/822#issuecomment-1765550141\n\nand https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/822#issuecomment-1769126560\n\nidk how do state it more clearly, emm if you put money in the bank, you expect to pay 1 USD for withdrawal transaction fee, but every time you have to pay 100 USD withdrawal fee because of the bug\n\nthis cause loss of fund for every user in every transaction for not only you but every user...\n\n\n\n\n\n**Evert0x**\n\n@JeffCX what are the exact numbers on the withdrawal costs? E.g. if I want to withdraw $10k, how much gas can I expect to pay? If this is a significant amount I can see the argument for\n> How to identify a high issue:\n> Definite loss of funds without limiting external conditions.\n\nBut it's not clear how much this will be assuming current mainnet conditions. \n\n**JeffCX**\n\nI write a simpe POC\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport \"forge-std/Test.sol\";\nimport \"forge-std/console.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n    constructor()ERC20(\"MyToken\", \"MTK\")\n    {}\n\n    function mint(address to, uint256 amount) public {\n        _mint(to, amount);\n    }\n}\n\ninterface ICheckRetrancy {\n    function checkRentrancy() external;\n}\n\ncontract RentrancyCheck {\n\n\n    uint256 state = 10;\n\n    function checkRentrancy() external {\n        address(this).staticcall(abi.encodeWithSignature(\"hihi()\"));\n    }\n\n    function hihi() public {\n        state = 11;\n    }\n\n}\n\ncontract Vault {\n\n    address balancerAddr;\n    bool checkRentrancy;\n\n    constructor(bool _checkRentrancy, address _balancerAddr) {\n        checkRentrancy = _checkRentrancy;\n        balancerAddr = _balancerAddr;\n    }\n\n    function toggleCheck(bool _state) public {\n        checkRentrancy = _state;\n    }\n\n    function withdraw(address token, uint256 amount) public {\n\n        if(checkRentrancy) {\n            ICheckRetrancy(balancerAddr).checkRentrancy();\n        }\n\n        IERC20(token).transfer(msg.sender, amount);\n    \n    }\n\n}\n\n\ncontract CounterTest is Test {\n\n    using stdStorage for StdStorage;\n    StdStorage stdlib;\n\n    MockERC20 token;\n    Vault vault;\n    RentrancyCheck rentrancyCheck;\n\n    address user = vm.addr(5201314);\n\n    function setUp() public {\n    \n        token = new MockERC20();\n        rentrancyCheck = new RentrancyCheck();\n        vault = new Vault(false, address(rentrancyCheck));\n        token.mint(address(vault), 100000000 ether);\n\n        vm.deal(user, 100 ether);\n    \n        // vault.toggleCheck(true);\n\n    }\n\n    function testPOC() public {\n\n        uint256 gas = gasleft();\n        uint256 amount = 100 ether;\n        vault.withdraw(address(token), amount);\n        console.log(gas - gasleft());\n\n    }\n\n}\n\n```\n\nthe call is \n\n```\nif check reentrancy flag is true\n\nuser withdraw -> \ncheck reentrancy staticall revert and consume most of the gas \n-> withdraw completed\n```\n\nor\n\n```\nif check reentrancy flag is false\n\nuser withdraw ->\n-> withdraw completed\n```\n\nnote first we do not check the reentrancy\n\n```solidity\n// vault.toggleCheck(true);\n```\n\nwe run\n\n```solidity\nforge test -vvv --match-test \"testPOC\" --fork-url \"https://eth.llamarpc.com\" --gas-limit 10000000\n```\n\nthe gas cost is 42335\n\n```\nRunning 1 test for test/Counter.t.sol:CounterTest\n[PASS] testPOC() (gas: 45438)\nLogs:\n  42335\n```\n\nthen we uncomment the vault.toggleCheck(true) and check the reentrancy that revert in staticcall\n\n```solidity\nvault.toggleCheck(true);\n```\n\nwe run the same test again, this is the output, as we can see the gas cost surge\n\n```\nRunning 1 test for test/Counter.t.sol:CounterTest\n[PASS] testPOC() (gas: 9554791)\nLogs:\n  9551688\n```\n\nthen we can use this  python scirpt to estimate how much gas is overpaid as lost of fund\n\n```python\nregular =  42313\n\noverpaid = 9551666\n\n\ncost = 0.000000045 * (overpaid - regular);\n\nprint(cost)\n```\n\nthe cost is \n\n```solidity\n0.427920885 ETH\n```\n\nin a single withdraw, assume user lost 0.427 ETH,\n\nif 500 user withdraw 20 times each and the total number of transaction is 10000\n\nthe lose on gas is 10000 * 0.427 ETH\n\n**JeffCX**\n\nnote that the more gas limit user set, the more fund user lose in gas\n\nbut we are interested in what the lowest amount of gas limit user that user can set the pay for withdrawal transaction\n\nI did some fuzzing\n\nthat number is 1800000 unit of gas\n\nthe command to run the test is\n\n```solidity\nforge test -vvv --match-test \"testPOC\" --fork-url \"https://eth.llamarpc.com\" --gas-limit 1800000\n```\n\nsetting gas limit lower than 1800000 unit of gas is likely to revert in out of gas\n\nunder this setting, the overpaid transaction cost is 1730089\n\n```solidity\nRunning 1 test for test/Counter.t.sol:CounterTest\n[PASS] testPOC() (gas: 1733192)\nLogs:\n  1730089\n```\n\nin other words,\n\nin each withdrawal for every user, user can lose 0.073 ETH, (1730089 uint of gas * 45 gwei -> 0.000000045 ETH)\n\nassume there are 1000 user, each withdraw 10 times, they make 1000 * 10 = 100_00 transaction\n\nso the total lost is 100_00 * 0.07 = 700 ETH \n\nin reality the gas is more than that because user may use more than 1800000 unit of gas to finalize the withdrawal transaction\n\n**Evert0x**\n\n@JeffCX thanks for putting in the effort to make this estimation.\n\nBut as far as I can see, your estimation doesn't use the actual contracts in scope. But maybe that's irrelevant to make your point. \n\nThis seems like the key sentence \n> in each withdrawal for every user, user can lose 0.073 ETH, \n\nThis is an extra $100-$150 dollars per withdrawal action. \n\nThis is not a very significant amount in my opinion. I assume an optimized withdrawal transaction will cost between  $20-$50. So the difference is not as big. \n\n**JeffCX**\n\n> Sir, I don't think the method A and method B example applies in the codebase and in this issue\n> \n> there is only one method for user to withdraw share from the vault\n> \n> I can add more detail to explain how this impact withdraw using top-down approach\n> \n> User can withdraw by calling withdraw in LMPVault.sol and triggers [_withdraw](https://github.com/sherlock-audit/2023-06-tokemak/blob/5d8e902ce33981a6506b1b5fb979a084602c6c9a/v2-core-audit-2023-07-14/src/vault/LMPVault.sol#L414)\n> \n> the _withdraw calls the method [_calcUserWithdrawSharesToBurn](https://github.com/sherlock-audit/2023-06-tokemak/blob/5d8e902ce33981a6506b1b5fb979a084602c6c9a/v2-core-audit-2023-07-14/src/vault/LMPVault.sol#L472)\n> \n> this calls [LMPDebt._calcUserWithdrawSharesToBurn](https://github.com/sherlock-audit/2023-06-tokemak/blob/5d8e902ce33981a6506b1b5fb979a084602c6c9a/v2-core-audit-2023-07-14/src/vault/LMPVault.sol#L442)\n> \n> we need to know the [debt value](https://github.com/sherlock-audit/2023-06-tokemak/blob/5d8e902ce33981a6506b1b5fb979a084602c6c9a/v2-core-audit-2023-07-14/src/vault/libs/LMPDebt.sol#L253) by calling destVault.debtValue\n> \n> this calls this [line of code](https://github.com/sherlock-audit/2023-06-tokemak/blob/5d8e902ce33981a6506b1b5fb979a084602c6c9a/v2-core-audit-2023-07-14/src/vault/DestinationVault.sol#L150)\n> \n> this calls the [oracle code](https://github.com/sherlock-audit/2023-06-tokemak/blob/5d8e902ce33981a6506b1b5fb979a084602c6c9a/v2-core-audit-2023-07-14/src/vault/DestinationVault.sol#L328)\n> \n> ```solidity\n> uint256 price = _systemRegistry.rootPriceOracle().getPriceInEth(_underlying);\n> ```\n> \n> then if the dest vault is the balancer vault, balancer reetrancy check is triggered to waste 63 / 64 waste in [oracle code](https://github.com/sherlock-audit/2023-06-tokemak/blob/5d8e902ce33981a6506b1b5fb979a084602c6c9a/v2-core-audit-2023-07-14/src/oracles/providers/BalancerLPComposableStableEthOracle.sol#L36)\n> \n> so there is no function A and function B call\n> \n> as long as user can withdraw and wants to withdraw share from balancer vault, 100x gas overpayment is required\n\nthe POC is a simplified flow of this \n\nit is ok to disagree sir:)\n\n**Evert0x**\n\nResult:\nMedium\nHas Duplicates\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [JEFFCX](https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/822/#issuecomment-1745242587): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/101",
  "Code": [
    {
      "filename": "pkg/pool-utils/contracts/lib/VaultReentrancyLib.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol\";\nimport \"@balancer-labs/v2-interfaces/contracts/vault/IVault.sol\";\n\nlibrary VaultReentrancyLib {\n    /**\n     * @dev Ensure we are not in a Vault context when this function is called, by attempting a no-op internal\n     * balance operation. If we are already in a Vault transaction (e.g., a swap, join, or exit), the Vault's\n     * reentrancy protection will cause this function to revert.\n     *\n     * The exact function call doesn't really matter: we're just trying to trigger the Vault reentrancy check\n     * (and not hurt anything in case it works). An empty operation array with no specific operation at all works\n     * for that purpose, and is also the least expensive in terms of gas and bytecode size.\n     *\n     * Call this at the top of any function that can cause a state change in a pool and is either public itself,\n     * or called by a public function *outside* a Vault operation (e.g., join, exit, or swap).\n     *\n     * If this is *not* called in functions that are vulnerable to the read-only reentrancy issue described\n     * here (https://forum.balancer.fi/t/reentrancy-vulnerability-scope-expanded/4345), those functions are unsafe,\n     * and subject to manipulation that may result in loss of funds.\n     */\n    function ensureNotInVaultContext(IVault vault) internal view {\n        // Perform the following operation to trigger the Vault's reentrancy guard:\n        //\n        // IVault.UserBalanceOp[] memory noop = new IVault.UserBalanceOp[](0);\n        // _vault.manageUserBalance(noop);\n        //\n        // However, use a static call so that it can be a view function (even though the function is non-view).\n        // This allows the library to be used more widely, as some functions that need to be protected might be\n        // view.\n        //\n        // This staticcall always reverts, but we need to make sure it doesn't fail due to a re-entrancy attack.\n        // Staticcalls consume all gas forwarded to them on a revert caused by storage modification.\n        // By default, almost the entire available gas is forwarded to the staticcall,\n        // causing the entire call to revert with an 'out of gas' error.\n        //\n        // We set the gas limit to 10k for the staticcall to\n        // avoid wasting gas when it reverts due to storage modification.\n        // `manageUserBalance` is a non-reentrant function in the Vault, so calling it invokes `_enterNonReentrant`\n        // in the `ReentrancyGuard` contract, reproduced here:\n        //\n        //    function _enterNonReentrant() private {\n        //        // If the Vault is actually being reentered, it will revert in the first line, at the `_require` that\n        //        // checks the reentrancy flag, with \"BAL#400\" (corresponding to Errors.REENTRANCY) in the revertData.\n        //        // The full revertData will be: `abi.encodeWithSignature(\"Error(string)\", \"BAL#400\")`.\n        //        _require(_status != _ENTERED, Errors.REENTRANCY);\n        //\n        //        // If the Vault is not being reentered, the check above will pass: but it will *still* revert,\n        //        // because the next line attempts to modify storage during a staticcall. However, this type of\n        //        // failure results in empty revertData.\n        //        _status = _ENTERED;\n        //    }\n        //\n        // So based on this analysis, there are only two possible revertData values: empty, or abi.encoded BAL#400.\n        //\n        // It is of course much more bytecode and gas efficient to check for zero-length revertData than to compare it\n        // to the encoded REENTRANCY revertData.\n        //\n        // While it should be impossible for the call to fail in any other way (especially since it reverts before\n        // `manageUserBalance` even gets called), any other error would generate non-zero revertData, so checking for\n        // empty data guards against this case too.\n\n        (, bytes memory revertData) = address(vault).staticcall{ gas: 10_000 }(\n            abi.encodeWithSelector(vault.manageUserBalance.selector, 0)\n        );\n\n        _require(revertData.length == 0, Errors.REENTRANCY);\n    }\n}"
    },
    {
      "filename": "v2-core-audit-2023-07-14/src/libs/BalancerUtilities.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\n\npragma solidity 0.8.17;\n\nimport { IVault } from \"src/interfaces/external/balancer/IVault.sol\";\nimport { IERC20 } from \"openzeppelin-contracts/token/ERC20/IERC20.sol\";\n\nlibrary BalancerUtilities {\n    error BalancerVaultReentrancy();\n\n    // 400 is Balancers Vault REENTRANCY error code\n    bytes32 internal constant REENTRANCY_ERROR_HASH = keccak256(abi.encodeWithSignature(\"Error(string)\", \"BAL#400\"));\n\n    /**\n     * @notice Verifies reentrancy to the Balancer Vault\n     * @dev Reverts if gets BAL#400 error\n     */\n    function checkReentrancy(address balancerVault) external view {\n        // solhint-disable max-line-length\n        // https://github.com/balancer/balancer-v2-monorepo/blob/90f77293fef4b8782feae68643c745c754bac45c/pkg/pool-utils/contracts/lib/VaultReentrancyLib.sol\n        (, bytes memory returnData) = balancerVault.staticcall(\n            abi.encodeWithSelector(IVault.manageUserBalance.selector, new IVault.UserBalanceOp[](0))\n        );\n        if (keccak256(returnData) == REENTRANCY_ERROR_HASH) {\n            revert BalancerVaultReentrancy();\n        }\n    }\n\n    /**\n     * @notice Checks if a given address is Balancer Composable pool\n     * @dev Using the presence of a getBptIndex() fn as an indicator of pool type\n     */\n    function isComposablePool(address pool) public view returns (bool) {\n        // slither-disable-start low-level-calls\n        // solhint-disable-next-line no-unused-vars\n        (bool success, bytes memory data) = pool.staticcall(abi.encodeWithSignature(\"getBptIndex()\"));\n        if (success) {\n            return data.length > 0;\n        }\n        // slither-disable-end low-level-calls\n        return success;\n    }\n\n    /**\n     * @dev This helper function is a fast and cheap way to convert between IERC20[] and IAsset[] types\n     */\n    function _convertERC20sToAddresses(IERC20[] memory tokens) internal pure returns (address[] memory assets) {\n        //slither-disable-start assembly\n        //solhint-disable-next-line no-inline-assembly\n        assembly {\n            assets := tokens\n        }\n        //slither-disable-end assembly\n    }\n}"
    },
    {
      "filename": "pkg/pool-utils/contracts/lib/VaultReentrancyLib.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol\";\nimport \"@balancer-labs/v2-interfaces/contracts/vault/IVault.sol\";\n\nlibrary VaultReentrancyLib {\n    /**\n     * @dev Ensure we are not in a Vault context when this function is called, by attempting a no-op internal\n     * balance operation. If we are already in a Vault transaction (e.g., a swap, join, or exit), the Vault's\n     * reentrancy protection will cause this function to revert.\n     *\n     * The exact function call doesn't really matter: we're just trying to trigger the Vault reentrancy check\n     * (and not hurt anything in case it works). An empty operation array with no specific operation at all works\n     * for that purpose, and is also the least expensive in terms of gas and bytecode size.\n     *\n     * Call this at the top of any function that can cause a state change in a pool and is either public itself,\n     * or called by a public function *outside* a Vault operation (e.g., join, exit, or swap).\n     *\n     * If this is *not* called in functions that are vulnerable to the read-only reentrancy issue described\n     * here (https://forum.balancer.fi/t/reentrancy-vulnerability-scope-expanded/4345), those functions are unsafe,\n     * and subject to manipulation that may result in loss of funds.\n     */\n    function ensureNotInVaultContext(IVault vault) internal view {\n        // Perform the following operation to trigger the Vault's reentrancy guard:\n        //\n        // IVault.UserBalanceOp[] memory noop = new IVault.UserBalanceOp[](0);\n        // _vault.manageUserBalance(noop);\n        //\n        // However, use a static call so that it can be a view function (even though the function is non-view).\n        // This allows the library to be used more widely, as some functions that need to be protected might be\n        // view.\n        //\n        // This staticcall always reverts, but we need to make sure it doesn't fail due to a re-entrancy attack.\n        // Staticcalls consume all gas forwarded to them on a revert caused by storage modification.\n        // By default, almost the entire available gas is forwarded to the staticcall,\n        // causing the entire call to revert with an 'out of gas' error.\n        //\n        // We set the gas limit to 10k for the staticcall to\n        // avoid wasting gas when it reverts due to storage modification.\n        // `manageUserBalance` is a non-reentrant function in the Vault, so calling it invokes `_enterNonReentrant`\n        // in the `ReentrancyGuard` contract, reproduced here:\n        //\n        //    function _enterNonReentrant() private {\n        //        // If the Vault is actually being reentered, it will revert in the first line, at the `_require` that\n        //        // checks the reentrancy flag, with \"BAL#400\" (corresponding to Errors.REENTRANCY) in the revertData.\n        //        // The full revertData will be: `abi.encodeWithSignature(\"Error(string)\", \"BAL#400\")`.\n        //        _require(_status != _ENTERED, Errors.REENTRANCY);\n        //\n        //        // If the Vault is not being reentered, the check above will pass: but it will *still* revert,\n        //        // because the next line attempts to modify storage during a staticcall. However, this type of\n        //        // failure results in empty revertData.\n        //        _status = _ENTERED;\n        //    }\n        //\n        // So based on this analysis, there are only two possible revertData values: empty, or abi.encoded BAL#400.\n        //\n        // It is of course much more bytecode and gas efficient to check for zero-length revertData than to compare it\n        // to the encoded REENTRANCY revertData.\n        //\n        // While it should be impossible for the call to fail in any other way (especially since it reverts before\n        // `manageUserBalance` even gets called), any other error would generate non-zero revertData, so checking for\n        // empty data guards against this case too.\n\n        (, bytes memory revertData) = address(vault).staticcall{ gas: 10_000 }(\n            abi.encodeWithSelector(vault.manageUserBalance.selector, 0)\n        );\n\n        _require(revertData.length == 0, Errors.REENTRANCY);\n    }\n}"
    },
    {
      "filename": "pkg/pool-utils/contracts/lib/VaultReentrancyLib.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"@balancer-labs/v2-interfaces/contracts/solidity-utils/helpers/BalancerErrors.sol\";\nimport \"@balancer-labs/v2-interfaces/contracts/vault/IVault.sol\";\n\nlibrary VaultReentrancyLib {\n    /**\n     * @dev Ensure we are not in a Vault context when this function is called, by attempting a no-op internal\n     * balance operation. If we are already in a Vault transaction (e.g., a swap, join, or exit), the Vault's\n     * reentrancy protection will cause this function to revert.\n     *\n     * The exact function call doesn't really matter: we're just trying to trigger the Vault reentrancy check\n     * (and not hurt anything in case it works). An empty operation array with no specific operation at all works\n     * for that purpose, and is also the least expensive in terms of gas and bytecode size.\n     *\n     * Call this at the top of any function that can cause a state change in a pool and is either public itself,\n     * or called by a public function *outside* a Vault operation (e.g., join, exit, or swap).\n     *\n     * If this is *not* called in functions that are vulnerable to the read-only reentrancy issue described\n     * here (https://forum.balancer.fi/t/reentrancy-vulnerability-scope-expanded/4345), those functions are unsafe,\n     * and subject to manipulation that may result in loss of funds.\n     */\n    function ensureNotInVaultContext(IVault vault) internal view {\n        // Perform the following operation to trigger the Vault's reentrancy guard:\n        //\n        // IVault.UserBalanceOp[] memory noop = new IVault.UserBalanceOp[](0);\n        // _vault.manageUserBalance(noop);\n        //\n        // However, use a static call so that it can be a view function (even though the function is non-view).\n        // This allows the library to be used more widely, as some functions that need to be protected might be\n        // view.\n        //\n        // This staticcall always reverts, but we need to make sure it doesn't fail due to a re-entrancy attack.\n        // Staticcalls consume all gas forwarded to them on a revert caused by storage modification.\n        // By default, almost the entire available gas is forwarded to the staticcall,\n        // causing the entire call to revert with an 'out of gas' error.\n        //\n        // We set the gas limit to 10k for the staticcall to\n        // avoid wasting gas when it reverts due to storage modification.\n        // `manageUserBalance` is a non-reentrant function in the Vault, so calling it invokes `_enterNonReentrant`\n        // in the `ReentrancyGuard` contract, reproduced here:\n        //\n        //    function _enterNonReentrant() private {\n        //        // If the Vault is actually being reentered, it will revert in the first line, at the `_require` that\n        //        // checks the reentrancy flag, with \"BAL#400\" (corresponding to Errors.REENTRANCY) in the revertData.\n        //        // The full revertData will be: `abi.encodeWithSignature(\"Error(string)\", \"BAL#400\")`.\n        //        _require(_status != _ENTERED, Errors.REENTRANCY);\n        //\n        //        // If the Vault is not being reentered, the check above will pass: but it will *still* revert,\n        //        // because the next line attempts to modify storage during a staticcall. However, this type of\n        //        // failure results in empty revertData.\n        //        _status = _ENTERED;\n        //    }\n        //\n        // So based on this analysis, there are only two possible revertData values: empty, or abi.encoded BAL#400.\n        //\n        // It is of course much more bytecode and gas efficient to check for zero-length revertData than to compare it\n        // to the encoded REENTRANCY revertData.\n        //\n        // While it should be impossible for the call to fail in any other way (especially since it reverts before\n        // `manageUserBalance` even gets called), any other error would generate non-zero revertData, so checking for\n        // empty data guards against this case too.\n\n        (, bytes memory revertData) = address(vault).staticcall{ gas: 10_000 }(\n            abi.encodeWithSelector(vault.manageUserBalance.selector, 0)\n        );\n\n        _require(revertData.length == 0, Errors.REENTRANCY);\n    }\n}"
    },
    {
      "filename": "v2-core-audit-2023-07-14/src/vault/LMPVault.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\npragma solidity 0.8.17;\n\n// solhint-disable max-states-count\n\nimport { Roles } from \"src/libs/Roles.sol\";\nimport { Errors } from \"src/utils/Errors.sol\";\nimport { LMPDebt } from \"src/vault/libs/LMPDebt.sol\";\nimport { Pausable } from \"src/security/Pausable.sol\";\nimport { VaultTypes } from \"src/vault/VaultTypes.sol\";\nimport { NonReentrant } from \"src/utils/NonReentrant.sol\";\nimport { SystemComponent } from \"src/SystemComponent.sol\";\nimport { LMPStrategy } from \"src/strategy/LMPStrategy.sol\";\nimport { SecurityBase } from \"src/security/SecurityBase.sol\";\nimport { ILMPVault } from \"src/interfaces/vault/ILMPVault.sol\";\nimport { IStrategy } from \"src/interfaces/strategy/IStrategy.sol\";\nimport { Math } from \"openzeppelin-contracts/utils/math/Math.sol\";\nimport { LMPDestinations } from \"src/vault/libs/LMPDestinations.sol\";\nimport { ERC20 } from \"openzeppelin-contracts/token/ERC20/ERC20.sol\";\nimport { IERC4626 } from \"openzeppelin-contracts/interfaces/IERC4626.sol\";\nimport { IMainRewarder } from \"src/interfaces/rewarders/IMainRewarder.sol\";\nimport { IDestinationVault } from \"src/interfaces/vault/IDestinationVault.sol\";\nimport { SafeERC20 } from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Initializable } from \"openzeppelin-contracts/proxy/utils/Initializable.sol\";\nimport { EnumerableSet } from \"openzeppelin-contracts/utils/structs/EnumerableSet.sol\";\nimport { ISystemRegistry, IDestinationVaultRegistry } from \"src/interfaces/ISystemRegistry.sol\";\nimport { ERC20Permit } from \"openzeppelin-contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport { IERC3156FlashBorrower } from \"openzeppelin-contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport { IERC20Metadata as IERC20 } from \"openzeppelin-contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n// Cross functional reentrancy was identified between updateDebtReporting and the\n// destinationInfo. Have nonReentrant and read-only nonReentrant modifier on them both\n// but slither was still complaining\n//slither-disable-start reentrancy-no-eth,reentrancy-benign\n\ncontract LMPVault is\n    SystemComponent,\n    Initializable,\n    ILMPVault,\n    IStrategy,\n    ERC20Permit,\n    SecurityBase,\n    Pausable,\n    NonReentrant\n{\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using Math for uint256;\n    using SafeERC20 for ERC20;\n    using SafeERC20 for IERC20;\n\n    /// @dev In memory struct only for managing vars in _withdraw\n    struct WithdrawInfo {\n        uint256 currentIdle;\n        uint256 assetsFromIdle;\n        uint256 totalAssetsToPull;\n        uint256 totalAssetsPulled;\n        uint256 idleIncrease;\n        uint256 debtDecrease;\n    }\n\n    /// @notice Max fee. 100% == 10000\n    uint256 public constant MAX_FEE_BPS = 10_000;\n\n    uint256 public constant NAV_CHANGE_ROUNDING_BUFFER = 100;\n\n    /// @notice Factory contract that created this vault\n    address public factory;\n\n    /// @notice Overarching baseAsset type\n    bytes32 public immutable vaultType = VaultTypes.LST;\n\n    /// @dev The asset that is deposited into the vault\n    IERC20 internal immutable _baseAsset;\n\n    /// @notice Decimals of the base asset. Used as the decimals for the vault itself\n    uint8 internal immutable _baseAssetDecimals;\n\n    /// @dev Full list of possible destinations that could be deployed to\n    EnumerableSet.AddressSet internal destinations;\n\n    /// @dev Destinations that queued for removal\n    EnumerableSet.AddressSet internal removalQueue;\n\n    /// @dev destinationVaultAddress -> Info .. Debt reporting snapshot info\n    mapping(address => LMPDebt.DestinationInfo) internal destinationInfo;\n\n    /// @dev whether or not the vault has been shutdown\n    bool internal _shutdown;\n\n    /// @notice The amount of baseAsset deposited into the contract pending deployment\n    uint256 public totalIdle = 0;\n\n    /// @notice The current (though cached) value of assets we've deployed\n    uint256 public totalDebt = 0;\n\n    /// @notice The destinations, in order, in which withdrawals will be attempted from\n    IDestinationVault[] public withdrawalQueue;\n\n    /// @notice Main rewarder for this contract\n    IMainRewarder public rewarder;\n\n    /// @notice Current performance fee taken on profit. 100% == 10000\n    uint256 public performanceFeeBps;\n\n    /// @notice Where claimed fees are sent\n    address public feeSink;\n\n    /// @notice The last nav/share height we took fees at\n    uint256 public navPerShareHighMark = MAX_FEE_BPS;\n\n    /// @notice The last timestamp we took fees at\n    uint256 public navPerShareHighMarkTimestamp;\n\n    /// @notice The max total supply of shares we'll allow to be minted\n    uint256 public totalSupplyLimit;\n\n    /// @notice The max shares a single wallet is allowed to hold\n    uint256 public perWalletLimit;\n\n    string private _desc;\n    string private _symbol;\n\n    error TooFewAssets(uint256 requested, uint256 actual);\n    error WithdrawShareCalcInvalid(uint256 currentShares, uint256 cachedShares);\n    error InvalidFee(uint256 newFee);\n    error RewarderAlreadySet();\n    error RebalanceDestinationsMatch(address destinationVault);\n    error InvalidDestination(address destination);\n    error NavChanged(uint256 oldNav, uint256 newNav);\n    error NavOpsInProgress();\n    error OverWalletLimit(address to);\n    error VaultShutdown();\n\n    event PerformanceFeeSet(uint256 newFee);\n    event FeeSinkSet(address newFeeSink);\n    event NewNavHighWatermark(uint256 navPerShare, uint256 timestamp);\n    event TotalSupplyLimitSet(uint256 limit);\n    event PerWalletLimitSet(uint256 limit);\n\n    modifier noNavChange() {\n        (uint256 oldNav, uint256 startingTotalSupply) = _snapStartNav();\n        _;\n        _ensureNoNavChange(oldNav, startingTotalSupply);\n    }\n\n    modifier noNavDecrease() {\n        (uint256 oldNav, uint256 startingTotalSupply) = _snapStartNav();\n        _;\n        _ensureNoNavDecrease(oldNav, startingTotalSupply);\n    }\n\n    modifier ensureNoNavOps() {\n        if (systemRegistry.systemSecurity().navOpsInProgress() > 0) {\n            revert NavOpsInProgress();\n        }\n        _;\n    }\n\n    modifier trackNavOps() {\n        systemRegistry.systemSecurity().enterNavOperation();\n        _;\n        systemRegistry.systemSecurity().exitNavOperation();\n    }\n\n    constructor(\n        ISystemRegistry _systemRegistry,\n        address _vaultAsset\n    )\n        SystemComponent(_systemRegistry)\n        ERC20(\n            string(abi.encodePacked(ERC20(_vaultAsset).name(), \" Pool Token\")),\n            string(abi.encodePacked(\"lmp\", ERC20(_vaultAsset).symbol()))\n        )\n        ERC20Permit(string(abi.encodePacked(\"lmp\", ERC20(_vaultAsset).symbol())))\n        SecurityBase(address(_systemRegistry.accessController()))\n        Pausable(_systemRegistry)\n    {\n        _baseAsset = IERC20(_vaultAsset);\n        _baseAssetDecimals = IERC20(_vaultAsset).decimals();\n\n        _symbol = ERC20(_vaultAsset).symbol();\n        _desc = ERC20(_vaultAsset).name();\n\n        _disableInitializers();\n    }\n\n    function initialize(\n        uint256 supplyLimit,\n        uint256 walletLimit,\n        string memory symbolSuffix,\n        string memory descPrefix,\n        bytes memory\n    ) public virtual initializer {\n        Errors.verifyNotEmpty(symbolSuffix, \"symbolSuffix\");\n        Errors.verifyNotEmpty(descPrefix, \"descPrefix\");\n\n        // init withdrawal queue to empty (slither issue)\n        withdrawalQueue = new IDestinationVault[](0);\n\n        navPerShareHighMarkTimestamp = block.timestamp;\n\n        _setTotalSupplyLimit(supplyLimit);\n        _setPerWalletLimit(walletLimit);\n\n        factory = msg.sender;\n\n        _symbol = symbolSuffix;\n        _desc = descPrefix;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override(ERC20, IERC20) returns (string memory) {\n        return string(abi.encodePacked(_desc, \" Pool Token\"));\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override(ERC20, IERC20) returns (string memory) {\n        return string(abi.encodePacked(\"lmp\", _symbol));\n    }\n\n    /// @inheritdoc IERC20\n    function decimals() public view virtual override(ERC20, IERC20) returns (uint8) {\n        return _baseAssetDecimals;\n    }\n\n    /// @notice Set the global share limit\n    /// @dev Zero is allowed here and used as a way to stop deposits but allow withdrawals\n    /// @param newSupplyLimit new total amount of shares allowed to be minted\n    function setTotalSupplyLimit(uint256 newSupplyLimit) external onlyOwner {\n        _setTotalSupplyLimit(newSupplyLimit);\n    }\n\n    /// @notice Set the per-wallet share limit\n    /// @param newWalletLimit new total shares a wallet is allowed to hold\n    function setPerWalletLimit(uint256 newWalletLimit) external onlyOwner {\n        _setPerWalletLimit(newWalletLimit);\n    }\n\n    /// @notice Set the fee that will be taken when profit is realized\n    /// @dev Resets the high water to current value\n    /// @param fee Percent. 100% == 10000\n    function setPerformanceFeeBps(uint256 fee) external nonReentrant hasRole(Roles.LMP_FEE_SETTER_ROLE) {\n        if (fee >= MAX_FEE_BPS) {\n            revert InvalidFee(fee);\n        }\n\n        performanceFeeBps = fee;\n\n        // Set the high mark when we change the fee so we aren't able to go farther back in\n        // time than one debt reporting and claim fee's against past profits\n        uint256 supply = totalSupply();\n        if (supply > 0) {\n            navPerShareHighMark = (totalAssets() * MAX_FEE_BPS) / supply;\n        } else {\n            // The default high mark is 1:1. We don't want to be able to take\n            // fee's before the first debt reporting\n            // Before a rebalance, everything will be in idle and we don't want to take\n            // fee's on pure idle\n            navPerShareHighMark = MAX_FEE_BPS;\n        }\n\n        emit PerformanceFeeSet(fee);\n    }\n\n    /// @notice Set the address that will receive fees\n    /// @param newFeeSink Address that will receive fees\n    function setFeeSink(address newFeeSink) external onlyOwner {\n        emit FeeSinkSet(newFeeSink);\n\n        // Zero is valid. One way to disable taking fees\n        // slither-disable-next-line missing-zero-check\n        feeSink = newFeeSink;\n    }\n\n    /// @notice Set the rewarder contract used by the vault\n    /// @dev Must be set immediately on initialization/creation and only once\n    function setRewarder(address _rewarder) external {\n        if (msg.sender != factory) {\n            revert Errors.AccessDenied();\n        }\n\n        Errors.verifyNotZero(_rewarder, \"rewarder\");\n\n        if (address(rewarder) != address(0)) {\n            revert RewarderAlreadySet();\n        }\n\n        rewarder = IMainRewarder(_rewarder);\n\n        emit RewarderSet(_rewarder);\n    }\n\n    /// @dev See {IERC4626-asset}.\n    function asset() public view virtual override returns (address) {\n        return address(_baseAsset);\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        return totalIdle + totalDebt;\n    }\n\n    /// @dev See {IERC4626-convertToShares}.\n    function convertToShares(uint256 assets) public view virtual returns (uint256 shares) {\n        shares = _convertToShares(assets, Math.Rounding.Down);\n    }\n\n    /// @dev See {IERC4626-convertToAssets}.\n    function convertToAssets(uint256 shares) public view virtual returns (uint256 assets) {\n        assets = _convertToAssets(shares, Math.Rounding.Down);\n    }\n\n    //////////////////////////////////////////////////////////////////////\n    //\t\t\t\t\t\t\t\tDeposit\t\t\t\t\t\t\t\t//\n    //////////////////////////////////////////////////////////////////////\n\n    /// @dev See {IERC4626-maxDeposit}.\n    function maxDeposit(address wallet) public view virtual override returns (uint256 maxAssets) {\n        maxAssets = convertToAssets(_maxMint(wallet));\n    }\n\n    /// @dev See {IERC4626-previewDeposit}.\n    function previewDeposit(uint256 assets) public view virtual returns (uint256 shares) {\n        shares = _convertToShares(assets, Math.Rounding.Down);\n    }\n\n    function deposit(\n        uint256 assets,\n        address receiver\n    ) public virtual override nonReentrant noNavChange ensureNoNavOps returns (uint256 shares) {\n        Errors.verifyNotZero(assets, \"assets\");\n        if (assets > maxDeposit(receiver)) {\n            revert ERC4626DepositExceedsMax(assets, maxDeposit(receiver));\n        }\n\n        shares = previewDeposit(assets);\n\n        _transferAndMint(assets, shares, receiver);\n    }\n\n    /// @dev See {IERC4626-maxMint}.\n    function maxMint(address wallet) public view virtual override returns (uint256 maxShares) {\n        maxShares = _maxMint(wallet);\n    }\n\n    /// @dev See {IERC4626-maxWithdraw}.\n    function maxWithdraw(address owner) public view virtual returns (uint256 maxAssets) {\n        maxAssets = paused() ? 0 : previewRedeem(balanceOf(owner));\n    }\n\n    /// @dev See {IERC4626-maxRedeem}.\n    function maxRedeem(address owner) public view virtual returns (uint256 maxShares) {\n        maxShares = _maxRedeem(owner);\n    }\n\n    /// @dev See {IERC4626-previewMint}.\n    function previewMint(uint256 shares) public view virtual returns (uint256 assets) {\n        assets = _convertToAssets(shares, Math.Rounding.Up);\n    }\n\n    /// @dev See {IERC4626-previewWithdraw}.\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256 shares) {\n        shares = _convertToShares(assets, Math.Rounding.Up);\n    }\n\n    /// @dev See {IERC4626-previewRedeem}.\n    function previewRedeem(uint256 shares) public view virtual override returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Down);\n    }\n\n    /**\n     * @dev See {IERC4626-mint}.\n     *\n     * As opposed to {deposit}, minting is allowed even if the vault is in a state where the price of a share is zero.\n     * In this case, the shares will be minted without requiring any assets to be deposited.\n     */\n    function mint(\n        uint256 shares,\n        address receiver\n    ) public virtual override nonReentrant noNavChange ensureNoNavOps returns (uint256 assets) {\n        if (shares > maxMint(receiver)) {\n            revert ERC4626MintExceedsMax(shares, maxMint(receiver));\n        }\n\n        assets = previewMint(shares);\n\n        _transferAndMint(assets, shares, receiver);\n    }\n\n    //////////////////////////////////////////////////////////////////////\n    //\t\t\t\t\t\t\t\tWithdraw\t\t\t\t\t\t\t//\n    //////////////////////////////////////////////////////////////////////\n\n    /// @dev See {IERC4626-withdraw}.\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual override nonReentrant noNavDecrease ensureNoNavOps returns (uint256 shares) {\n        Errors.verifyNotZero(assets, \"assets\");\n        uint256 maxAssets = maxWithdraw(owner);\n        if (assets > maxAssets) {\n            revert ERC4626ExceededMaxWithdraw(owner, assets, maxAssets);\n        }\n\n        // query number of shares these assets match\n        shares = previewWithdraw(assets);\n\n        uint256 actualAssets = _withdraw(assets, shares, receiver, owner);\n\n        if (actualAssets < assets) {\n            revert TooFewAssets(assets, actualAssets);\n        }\n    }\n\n    //"
    }
  ]
}