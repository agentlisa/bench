{
  "Title": "[G-21] `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too)",
  "Content": "Saves **5 gas per loop**.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/p1/mixins/Trading.sol\n\n72:           tradesOpen--;\n\n```\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/Trading.sol#L72\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-01-reserve",
  "Code": [
    {
      "filename": "contracts/p1/mixins/Trading.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Multicall.sol\";\nimport \"../../interfaces/ITrade.sol\";\nimport \"../../interfaces/ITrading.sol\";\nimport \"../../libraries/Fixed.sol\";\nimport \"./Component.sol\";\nimport \"./RewardableLib.sol\";\n\n/// Abstract trading mixin for all Traders, to be paired with TradingLib\n/// @dev See docs/security for discussion of Multicall safety\nabstract contract TradingP1 is Multicall, ComponentP1, ReentrancyGuardUpgradeable, ITrading {\n    using FixLib for uint192;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    uint192 public constant MIN_TRADE_VOLUME = 1e29; // {UoA}\n    uint192 public constant MAX_TRADE_SLIPPAGE = 1e18; // {%}\n\n    // Peer contracts, immutable after init()\n    IBroker private broker;\n\n    // All open trades\n    mapping(IERC20 => ITrade) public trades;\n    uint48 public tradesOpen;\n\n    // === Governance param ===\n    uint192 public maxTradeSlippage; // {%}\n\n    uint192 public minTradeVolume; // {UoA}\n\n    // ==== Invariants ====\n    // tradesOpen = len(values(trades))\n    // trades[sell] != 0 iff trade[sell] has been opened and not yet settled\n\n    // untestable:\n    //      `else` branch of `onlyInitializing` (ie. revert) is currently untestable.\n    //      This function is only called inside other `init` functions, each of which is wrapped\n    //      in an `initializer` modifier, which would fail first.\n    // solhint-disable-next-line func-name-mixedcase\n    function __Trading_init(\n        IMain main_,\n        uint192 maxTradeSlippage_,\n        uint192 minTradeVolume_\n    ) internal onlyInitializing {\n        broker = main_.broker();\n        setMaxTradeSlippage(maxTradeSlippage_);\n        setMinTradeVolume(minTradeVolume_);\n    }\n\n    /// Settle a single trade, expected to be used with multicall for efficient mass settlement\n    /// @custom:interaction (only reads or writes trades, and is marked `nonReentrant`)\n    // checks:\n    //   !paused, !frozen\n    //   trade[sell].canSettle()\n    // actions:\n    //   trade[sell].settle()\n    // effects:\n    //   trades.set(sell, 0)\n    //   tradesOpen' = tradesOpen - 1\n    // untested:\n    //      OZ nonReentrant line is assumed to be working. cost/benefit of direct testing is high\n    function settleTrade(IERC20 sell) external notPausedOrFrozen nonReentrant {\n        ITrade trade = trades[sell];\n        if (address(trade) == address(0)) return;\n        require(trade.canSettle(), \"cannot settle yet\");\n\n        delete trades[sell];\n        tradesOpen--;\n\n        // == Interactions ==\n        (uint256 soldAmt, uint256 boughtAmt) = trade.settle();\n        emit TradeSettled(trade, trade.sell(), trade.buy(), soldAmt, boughtAmt);\n    }\n\n    /// Claim all rewards\n    /// Collective Action\n    /// @custom:interaction CEI\n    function claimRewards() external notPausedOrFrozen {\n        RewardableLibP1.claimRewards(main.assetRegistry());\n    }\n\n    /// Claim rewards for a single asset\n    /// Collective Action\n    /// @param erc20 The ERC20 to claimRewards on\n    /// @custom:interaction CEI\n    function claimRewardsSingle(IERC20 erc20) external notPausedOrFrozen {\n        RewardableLibP1.claimRewardsSingle(main.assetRegistry().toAsset(erc20));\n    }\n\n    /// Try to initiate a trade with a trading partner provided by the broker\n    /// @custom:interaction (only reads or writes `trades`, and is marked `nonReentrant`)\n    // checks:\n    //   (not external, so we don't need auth or pause checks)\n    //   trades[req.sell] == 0\n    // actions:\n    //   req.sell.increaseAllowance(broker, req.sellAmount) - two safeApprove calls to support USDT\n    //   tradeID = broker.openTrade(req)\n    // effects:\n    //   trades' = trades.set(req.sell, tradeID)\n    //   tradesOpen' = tradesOpen + 1\n    //\n    // untested:\n    //      OZ nonReentrant line is assumed to be working. cost/benefit of direct testing is high\n    // This is reentrancy-safe because we're using the `nonReentrant` modifier on every method of\n    // this contract that changes state this function refers to.\n    // slither-disable-next-line reentrancy-vulnerabilities-1\n    function tryTrade(TradeRequest memory req) internal nonReentrant {\n        /*  */\n        IERC20 sell = req.sell.erc20();\n        assert(address(trades[sell]) == address(0));\n\n        IERC20Upgradeable(address(sell)).safeApprove(address(broker), 0);\n        IERC20Upgradeable(address(sell)).safeApprove(address(broker), req.sellAmount);\n        ITrade trade = broker.openTrade(req);\n\n        trades[sell] = trade;\n        tradesOpen++;\n        emit TradeStarted(trade, sell, req.buy.erc20(), req.sellAmount, req.minBuyAmount);\n    }\n\n    // === Setters ===\n\n    /// @custom:governance\n    function setMaxTradeSlippage(uint192 val) public governance {\n        require(val < MAX_TRADE_SLIPPAGE, \"invalid maxTradeSlippage\");\n        emit MaxTradeSlippageSet(maxTradeSlippage, val);\n        maxTradeSlippage = val;\n    }\n\n    /// @custom:governance\n    function setMinTradeVolume(uint192 val) public governance {\n        require(val <= MIN_TRADE_VOLUME, \"invalid minTradeVolume\");\n        emit MinTradeVolumeSet(minTradeVolume, val);\n        minTradeVolume = val;\n    }\n\n    // === FixLib Helper ===\n\n    /// Light wrapper around FixLib.mulDiv to support try-catch\n    function mulDivCeil(\n        uint192 x,\n        uint192 y,\n        uint192 z\n    ) external pure returns (uint192) {\n        return x.mulDiv(y, z, CEIL);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[46] private __gap;\n}"
    }
  ]
}