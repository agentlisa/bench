{
  "Title": "M-3: Read-only reentrancy in BondFixedTermTeller",
  "Content": "# Issue M-3: Read-only reentrancy in BondFixedTermTeller \n\nSource: https://github.com/sherlock-audit/2022-11-bond-judging/issues/23 \n\n## Found by \nZarf\n\n## Summary\n\nWhen minting new ERC1155 bonds in the `BondFixedTermTeller` contract, the total supply of this specific bond is updated after the new bonds are sent to the recipient, which introduces a reentrancy attack.\n\n## Vulnerability Detail\n\nWhenever a new ERC1155 bond is minted in the `BondFixedTermTeller` contract, either through `_handlePayout()` or `create()`, the total supply is updated after the bond has been minted. \n\nERC1155 tokens will perform a callback to the recipient in case the recipient implements the `ERC1155TokenReceiver` interface. Therefore, the recipient (`msg.sender` in `create()` or `recipient_` in `_handlePayout()` ) is able to perform a call to an arbitrary contract before the total supply of the bonds is updated.\n\nWhile the recipient could enter the current `BondFixedTermTeller` contract to call any function, there is no interesting function which might result in financial loss in case it gets called in the callback. Alternatively, the recipient could enter a smart contract which uses the the public mapping `tokenMetadata` in `BondFixedTermTeller` to calculate the current bond price based on the supply. As the supply is not yet updated, but the tokens are minted, this might result in a miscalculation of the price.\n\n## Impact\n\nWhile the `BondFixedTermTeller` contract itself is not at risk, any protocols integrating with `BondFixedTermTeller` and using the total supply of the ERC1155 bond token to calculate the price, might come at risk.\n\n## Code Snippet\n\n[https://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedTermTeller.sol#L218-L225](https://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedTermTeller.sol#L218-L225)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUpdate the total supply and mint the tokens afterwards:\n\n```solidity\nfunction _mintToken(\n    address to_,\n    uint256 tokenId_,\n    uint256 amount_\n) internal {\n    tokenMetadata[tokenId_].supply += amount_;\n    _mint(to_, tokenId_, amount_, bytes(\"\"));\n}\n```\n\n## Discussion\n\n**Evert0x**\n\nMessage from sponsor\n\n----\n\nAgree with this issue. We updated the `_mintToken()` and `_burnToken()` functions to update supply prior to minting/burning tokens to avoid the reentrancy issue.\n\n**xiaoming9090**\n\nFixed in https://github.com/Bond-Protocol/bonds/commit/fafd81d04d685d15612cc56af635513e11ddc626\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/20",
  "Code": [
    {
      "filename": "src/BondFixedTermTeller.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {BondBaseTeller, IBondAggregator, Authority} from \"./bases/BondBaseTeller.sol\";\nimport {IBondFixedTermTeller} from \"./interfaces/IBondFixedTermTeller.sol\";\n\nimport {TransferHelper} from \"./lib/TransferHelper.sol\";\nimport {FullMath} from \"./lib/FullMath.sol\";\nimport {ERC1155} from \"./lib/ERC1155.sol\";\n\n/// @title Bond Fixed Term Teller\n/// @notice Bond Fixed Term Teller Contract\n/// @dev Bond Protocol is a permissionless system to create Olympus-style bond markets\n///      for any token pair. The markets do not require maintenance and will manage\n///      bond prices based on activity. Bond issuers create BondMarkets that pay out\n///      a Payout Token in exchange for deposited Quote Tokens. Users can purchase\n///      future-dated Payout Tokens with Quote Tokens at the current market price and\n///      receive Bond Tokens to represent their position while their bond vests.\n///      Once the Bond Tokens vest, they can redeem it for the Quote Tokens.\n///\n/// @dev The Bond Fixed Term Teller is an implementation of the\n///      Bond Base Teller contract specific to handling user bond transactions\n///      and tokenizing bond markets where purchases vest in a fixed amount of time\n///      (rounded to the day) as ERC1155 tokens.\n///\n/// @author Oighty, Zeus, Potted Meat, indigo\ncontract BondFixedTermTeller is BondBaseTeller, IBondFixedTermTeller, ERC1155 {\n    using TransferHelper for ERC20;\n    using FullMath for uint256;\n\n    /* ========== EVENTS ========== */\n    event ERC1155BondTokenCreated(uint256 tokenId, ERC20 indexed underlying, uint48 indexed expiry);\n\n    /* ========== STATE VARIABLES ========== */\n\n    mapping(uint256 => TokenMetadata) public tokenMetadata; // metadata for bond tokens\n\n    /* ========== CONSTRUCTOR ========== */\n    constructor(\n        address protocol_,\n        IBondAggregator aggregator_,\n        address guardian_,\n        Authority authority_\n    ) BondBaseTeller(protocol_, aggregator_, guardian_, authority_) {}\n\n    /* ========== PURCHASE ========== */\n\n    /// @notice             Handle payout to recipient\n    /// @param recipient_   Address to receive payout\n    /// @param payout_      Amount of payoutToken to be paid\n    /// @param payoutToken_   Token to be paid out\n    /// @param vesting_     Amount of time to vest from current timestamp\n    /// @return expiry      Timestamp when the payout will vest\n    function _handlePayout(\n        address recipient_,\n        uint256 payout_,\n        ERC20 payoutToken_,\n        uint48 vesting_\n    ) internal override returns (uint48 expiry) {\n        // If there is no vesting time, the deposit is treated as an instant swap.\n        // otherwise, deposit info is stored and payout is available at a future timestamp.\n        // instant swap is denoted by expiry == 0.\n        //\n        // bonds mature with a cliff at a set timestamp\n        // prior to the expiry timestamp, no payout tokens are accessible to the user\n        // after the expiry timestamp, the entire payout can be redeemed\n        //\n        // fixed-term bonds mature in a set amount of time from deposit\n        // i.e. term = 1 week. when alice deposits on day 1, her bond\n        // expires on day 8. when bob deposits on day 2, his bond expires day 9.\n        if (vesting_ != 0) {\n            // Normalizing fixed term vesting timestamps to the same time each day\n            expiry = ((vesting_ + uint48(block.timestamp)) / uint48(1 days)) * uint48(1 days);\n\n            // Fixed-term user payout information is handled in BondTeller.\n            // Teller mints ERC-1155 bond tokens for user.\n            uint256 tokenId = getTokenId(payoutToken_, expiry);\n\n            // Create new bond token if it doesn't exist yet\n            if (!tokenMetadata[tokenId].active) {\n                _deploy(tokenId, payoutToken_, expiry);\n            }\n\n            // Mint bond token to recipient\n            _mintToken(recipient_, tokenId, payout_);\n        } else {\n            // If no expiry, then transfer payout directly to user\n            payoutToken_.safeTransfer(recipient_, payout_);\n        }\n    }\n\n    /* ========== DEPOSIT/MINT ========== */\n\n    /// @inheritdoc IBondFixedTermTeller\n    function create(\n        ERC20 underlying_,\n        uint48 expiry_,\n        uint256 amount_\n    ) external override nonReentrant returns (uint256, uint256) {\n        // Revert if expiry is in the past\n        if (expiry_ < block.timestamp) revert Teller_InvalidParams();\n\n        uint256 tokenId = getTokenId(underlying_, expiry_);\n\n        // Revert if no token exists, must call deploy first\n        if (!tokenMetadata[tokenId].active) revert Teller_TokenDoesNotExist(underlying_, expiry_);\n\n        // Transfer in underlying\n        // Check that amount received is not less than amount expected\n        // Handles edge cases like fee-on-transfer tokens (which are not supported)\n        uint256 oldBalance = underlying_.balanceOf(address(this));\n        underlying_.safeTransferFrom(msg.sender, address(this), amount_);\n        if (underlying_.balanceOf(address(this)) < oldBalance + amount_)\n            revert Teller_UnsupportedToken();\n\n        // If fee is greater than the create discount, then calculate the fee and store it\n        // Otherwise, fee is zero.\n        if (protocolFee > createFeeDiscount) {\n            // Calculate fee amount\n            uint256 feeAmount = amount_.mulDiv(protocolFee - createFeeDiscount, FEE_DECIMALS);\n            rewards[_protocol][underlying_] += feeAmount;\n\n            // Mint new bond tokens\n            _mintToken(msg.sender, tokenId, amount_ - feeAmount);\n\n            return (tokenId, amount_ - feeAmount);\n        } else {\n            // Mint new bond tokens\n            _mintToken(msg.sender, tokenId, amount_);\n\n            return (tokenId, amount_);\n        }\n    }\n\n    /* ========== REDEEM ========== */\n\n    function _redeem(uint256 tokenId_, uint256 amount_) internal {\n        // Check that the tokenId is active\n        if (!tokenMetadata[tokenId_].active) revert Teller_InvalidParams();\n\n        // Cache token metadata\n        TokenMetadata memory meta = tokenMetadata[tokenId_];\n\n        // Check that the token has matured\n        if (block.timestamp < meta.expiry) revert Teller_TokenNotMatured(meta.expiry);\n\n        // Burn bond token and transfer underlying to sender\n        _burnToken(msg.sender, tokenId_, amount_);\n        meta.underlying.safeTransfer(msg.sender, amount_);\n    }\n\n    /// @inheritdoc IBondFixedTermTeller\n    function redeem(uint256 tokenId_, uint256 amount_) public override nonReentrant {\n        _redeem(tokenId_, amount_);\n    }\n\n    /// @inheritdoc IBondFixedTermTeller\n    function batchRedeem(uint256[] calldata tokenIds_, uint256[] calldata amounts_)\n        external\n        override\n        nonReentrant\n    {\n        uint256 len = tokenIds_.length;\n        if (len != amounts_.length) revert Teller_InvalidParams();\n        for (uint256 i; i < len; ++i) {\n            _redeem(tokenIds_[i], amounts_[i]);\n        }\n    }\n\n    /* ========== TOKENIZATION ========== */\n\n    /// @inheritdoc IBondFixedTermTeller\n    function deploy(ERC20 underlying_, uint48 expiry_)\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        uint256 tokenId = getTokenId(underlying_, expiry_);\n        // Only creates token if it does not exist\n        if (!tokenMetadata[tokenId].active) {\n            _deploy(tokenId, underlying_, expiry_);\n        }\n        return tokenId;\n    }\n\n    /// @notice             \"Deploy\" a new ERC1155 bond token and stores its ID\n    /// @dev                ERC1155 tokens used for fixed term bonds\n    /// @param tokenId_     Calculated ID of new bond token (from getTokenId)\n    /// @param underlying_  Underlying token to be paid out when the bond token vests\n    /// @param expiry_      Timestamp that the token will vest at\n    function _deploy(\n        uint256 tokenId_,\n        ERC20 underlying_,\n        uint48 expiry_\n    ) internal {\n        // Revert if expiry is in the past\n        if (uint256(expiry_) < block.timestamp) revert Teller_InvalidParams();\n\n        // Store token metadata\n        tokenMetadata[tokenId_] = TokenMetadata(\n            true,\n            underlying_,\n            uint8(underlying_.decimals()),\n            expiry_,\n            0\n        );\n\n        emit ERC1155BondTokenCreated(tokenId_, underlying_, expiry_);\n    }\n\n    /// @notice             Mint bond token and update supply\n    /// @param to_          Address to mint tokens to\n    /// @param tokenId_     ID of bond token to mint\n    /// @param amount_      Amount of bond tokens to mint\n    function _mintToken(\n        address to_,\n        uint256 tokenId_,\n        uint256 amount_\n    ) internal {\n        _mint(to_, tokenId_, amount_, bytes(\"\"));\n        tokenMetadata[tokenId_].supply += amount_;\n    }\n\n    /// @notice             Burn bond token and update supply\n    /// @param from_        Address to burn tokens from\n    /// @param tokenId_     ID of bond token to burn\n    /// @param amount_      Amount of bond token to burn\n    function _burnToken(\n        address from_,\n        uint256 tokenId_,\n        uint256 amount_\n    ) internal {\n        _burn(from_, tokenId_, amount_);\n        tokenMetadata[tokenId_].supply -= amount_;\n    }\n\n    /* ========== TOKEN NAMING ========== */\n\n    /// @inheritdoc IBondFixedTermTeller\n    function getTokenId(ERC20 underlying_, uint48 expiry_) public pure override returns (uint256) {\n        // Vesting is divided by 1 day (in seconds) since bond tokens are only unique\n        // to a day, not a specific timestamp.\n        uint256 tokenId = uint256(\n            keccak256(abi.encodePacked(underlying_, expiry_ / uint48(1 days)))\n        );\n        return tokenId;\n    }\n\n    /// @inheritdoc IBondFixedTermTeller\n    function getTokenNameAndSymbol(uint256 tokenId_)\n        external\n        view\n        override\n        returns (string memory, string memory)\n    {\n        TokenMetadata memory meta = tokenMetadata[tokenId_];\n        (string memory name, string memory symbol) = _getNameAndSymbol(\n            meta.underlying,\n            meta.expiry\n        );\n        return (name, symbol);\n    }\n}"
    }
  ]
}