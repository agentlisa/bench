{
  "Title": "3S-LENFT-N04 libraries/logic /LiquidationLogic.sol: entire loan struct is being needlessly loaded",
  "Content": "#### Description\nIn function `bidLiquidationAuction()` of the [LiquidationLogic](https://github.com/leNFT/contracts/blob/master/contracts/libraries/logic/LiquidationLogic.sol#L71), the entire loan struct is being loaded from storage just to access `loanData.state` and `loanData.pool`. Since the loanCenter already has getters for these two variables, it is cheaper to use these two getters instead of calling function `loanCenter.getLoan(params.loanId)`.\n\n#### Recommendation\nUse getters `getLoanLendingPool()` and `getLoanState()` instead of `getLoan()` to save gas on storage loads.",
  "Impact": "GAS",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/libraries/logic/LiquidationLogic.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.19;\n\nimport {DataTypes} from \"../types/DataTypes.sol\";\nimport {PercentageMath} from \"../utils/PercentageMath.sol\";\nimport {IAddressProvider} from \"../../interfaces/IAddressProvider.sol\";\nimport {IFeeDistributor} from \"../../interfaces/IFeeDistributor.sol\";\nimport {ILoanCenter} from \"../../interfaces/ILoanCenter.sol\";\nimport {ILendingPool} from \"../../interfaces/ILendingPool.sol\";\nimport {ITokenOracle} from \"../../interfaces/ITokenOracle.sol\";\nimport {IGenesisNFT} from \"../../interfaces/IGenesisNFT.sol\";\nimport {INFTOracle} from \"../../interfaces/INFTOracle.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC4626} from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\n/// @title LiquidationLogic\n/// @author leNFT\n/// @notice Contains the logic for the liquidate function\n/// @dev Library dealing with the logic for the function responsible for liquidating a loan\nlibrary LiquidationLogic {\n    uint256 private constant LIQUIDATION_AUCTION_PERIOD = 3600 * 24;\n\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @notice Liquidates a loan\n    /// @param addressProvider The address of the addresses provider\n    /// @param params A struct with the parameters of the liquidate function\n    function createLiquidationAuction(\n        IAddressProvider addressProvider,\n        DataTypes.CreateAuctionParams memory params\n    ) external {\n        // Get loan center\n        ILoanCenter loanCenter = ILoanCenter(addressProvider.getLoanCenter());\n        // Get the loan\n        DataTypes.LoanData memory loanData = loanCenter.getLoan(params.loanId);\n\n        // Validate the auction creation\n        _validateCreateLiquidationAuction(\n            addressProvider,\n            address(loanCenter),\n            params,\n            loanData.state,\n            loanData.pool,\n            loanData.nftAsset,\n            loanData.nftTokenIds\n        );\n\n        // Add auction to the loan\n        loanCenter.auctionLoan(params.loanId, params.onBehalfOf, params.bid);\n\n        // Get the payment from the caller\n        IERC20Upgradeable(IERC4626(loanData.pool).asset()).safeTransferFrom(\n            params.caller,\n            address(this),\n            params.bid\n        );\n    }\n\n    /// @notice Bid on a liquidation auction\n    /// @param addressProvider The address of the addresses provider\n    /// @param params A struct with the parameters of the bid function\n    function bidLiquidationAuction(\n        IAddressProvider addressProvider,\n        DataTypes.BidAuctionParams memory params\n    ) external {\n        // Get the loan center\n        ILoanCenter loanCenter = ILoanCenter(addressProvider.getLoanCenter());\n        // Get the loan\n        DataTypes.LoanState loanState = loanCenter.getLoanState(params.loanId);\n        address loanLendingPool = loanCenter.getLoanLendingPool(params.loanId);\n        // Get the loan liquidation data\n        DataTypes.LoanLiquidationData memory loanLiquidationData = loanCenter\n            .getLoanLiquidationData(params.loanId);\n\n        // validate the auction bid\n        _validateBidLiquidationAuction(\n            params.bid,\n            loanState,\n            loanLiquidationData\n        );\n\n        // Get the address of this asset's lending pool\n        address poolAsset = IERC4626(loanLendingPool).asset();\n\n        // Send the old liquidator their funds back\n        IERC20Upgradeable(poolAsset).safeTransfer(\n            loanLiquidationData.liquidator,\n            loanLiquidationData.auctionMaxBid\n        );\n\n        // Update the auction bid\n        loanCenter.updateLoanAuctionBid(\n            params.loanId,\n            params.onBehalfOf,\n            params.bid\n        );\n\n        // Get the payment from the caller\n        IERC20Upgradeable(poolAsset).safeTransferFrom(\n            params.caller,\n            address(this),\n            params.bid\n        );\n    }\n\n    /// @notice Claim a liquidation auction\n    /// @param addressProvider The address of the addresses provider\n    /// @param params A struct with the parameters of the claim function\n    function claimLiquidation(\n        IAddressProvider addressProvider,\n        DataTypes.ClaimLiquidationParams memory params\n    ) external {\n        // Get the loan center\n        ILoanCenter loanCenter = ILoanCenter(addressProvider.getLoanCenter());\n        // Get the loan\n        DataTypes.LoanData memory loanData = loanCenter.getLoan(params.loanId);\n        // Get the loan liquidation data\n        DataTypes.LoanLiquidationData memory loanLiquidationData = loanCenter\n            .getLoanLiquidationData(params.loanId);\n\n        // Validate the auction claim\n        _validateClaimLiquidation(\n            loanData.state,\n            loanLiquidationData.auctionStartTimestamp\n        );\n\n        // Get the address of this asset's pool\n        address poolAsset = IERC4626(loanData.pool).asset();\n        // Repay loan...\n        uint256 fundsLeft = loanLiquidationData.auctionMaxBid;\n        uint256 loanInterest = loanCenter.getLoanInterest(params.loanId);\n        uint256 loanDebt = loanData.amount + loanInterest;\n        // If we only have funds to pay back part of the loan\n        if (fundsLeft < loanDebt) {\n            ILendingPool(loanData.pool).receiveUnderlyingDefaulted(\n                address(this),\n                fundsLeft,\n                uint256(loanData.borrowRate),\n                loanData.amount\n            );\n\n            fundsLeft = 0;\n        }\n        // If we have funds to cover the whole debt associated with the loan\n        else {\n            ILendingPool(loanData.pool).receiveUnderlying(\n                address(this),\n                loanData.amount,\n                uint256(loanData.borrowRate),\n                loanInterest\n            );\n\n            fundsLeft -= loanDebt;\n        }\n\n        // ... then get the protocol liquidation fee (if there are still funds available) ...\n        if (fundsLeft > 0) {\n            // Get the protocol fee\n            uint256 protocolFee = PercentageMath.percentMul(\n                loanLiquidationData.auctionMaxBid,\n                ILendingPool(loanData.pool).getPoolConfig().liquidationFeeRate\n            );\n            // If the protocol fee is higher than the amount we have left, set the protocol fee to the amount we have left\n            if (protocolFee > fundsLeft) {\n                protocolFee = fundsLeft;\n            }\n            // Send the protocol fee to the fee distributor contract\n            IERC20Upgradeable(poolAsset).safeTransfer(\n                addressProvider.getFeeDistributor(),\n                protocolFee\n            );\n            // Checkpoint the fee distribution\n            IFeeDistributor(addressProvider.getFeeDistributor()).checkpoint(\n                poolAsset\n            );\n            // Subtract the protocol fee from the funds left\n            fundsLeft -= protocolFee;\n        }\n\n        // ... and the rest to the borrower.\n        if (fundsLeft > 0) {\n            IERC20Upgradeable(poolAsset).safeTransfer(\n                loanData.owner,\n                fundsLeft\n            );\n        }\n\n        // Update the state of the loan\n        loanCenter.liquidateLoan(params.loanId);\n\n        // Send collateral to liquidator\n        for (uint i = 0; i < loanData.nftTokenIds.length; i++) {\n            IERC721Upgradeable(loanData.nftAsset).safeTransferFrom(\n                address(this),\n                loanLiquidationData.liquidator,\n                loanData.nftTokenIds[i]\n            );\n        }\n\n        // Unlock Genesis NFT if it was used with this loan\n        if (loanData.genesisNFTId != 0) {\n            // Unlock Genesis NFT\n            IGenesisNFT(addressProvider.getGenesisNFT()).unlockGenesisNFT(\n                uint256(loanData.genesisNFTId)\n            );\n        }\n    }\n\n    /// @notice Validate the parameters of the create liquidation auction function\n    /// @param addressProvider The address of the addresses provider\n    /// @param loanCenter The loan center\n    /// @param params A struct with the parameters of the create liquidation auction function\n    /// @param loanState The state of the loan\n    /// @param lendingPool The address of the lending pool\n    /// @param loanNFTAsset The address of the loan NFT asset\n    /// @param loanNFTTokenIds The token ids of the loan NFT\n    function _validateCreateLiquidationAuction(\n        IAddressProvider addressProvider,\n        address loanCenter,\n        DataTypes.CreateAuctionParams memory params,\n        DataTypes.LoanState loanState,\n        address lendingPool,\n        address loanNFTAsset,\n        uint256[] memory loanNFTTokenIds\n    ) internal view {\n        // Verify if liquidation conditions are met\n        //Require the loan exists\n        require(\n            loanState == DataTypes.LoanState.Active,\n            \"VL:VCLA:LOAN_NOT_FOUND\"\n        );\n\n        // Check if collateral / debt relation allows for liquidation\n        (uint256 ethPrice, uint256 precision) = ITokenOracle(\n            addressProvider.getTokenOracle()\n        ).getTokenETHPrice(IERC4626(lendingPool).asset());\n\n        uint256 collateralETHPrice = INFTOracle(addressProvider.getNFTOracle())\n            .getTokensETHPrice(\n                loanNFTAsset,\n                loanNFTTokenIds,\n                params.request,\n                params.packet\n            );\n\n        require(\n            (ILoanCenter(loanCenter).getLoanMaxDebt(\n                params.loanId,\n                collateralETHPrice\n            ) * precision) /\n                ethPrice <\n                ILoanCenter(loanCenter).getLoanDebt(params.loanId),\n            \"VL:VCLA:MAX_DEBT_NOT_EXCEEDED\"\n        );\n\n        // Check if bid is large enough\n        require(\n            (ethPrice * params.bid) / precision >=\n                PercentageMath.percentMul(\n                    collateralETHPrice,\n                    (PercentageMath.PERCENTAGE_FACTOR -\n                        ILendingPool(lendingPool)\n                            .getPoolConfig()\n                            .maxLiquidatorDiscount)\n                ),\n            \"VL:VCLA:BID_TOO_LOW\"\n        );\n    }\n\n    /// @notice Validate the parameters of the bid liquidation auction function\n    /// @param currentBid The current bid of the auction\n    /// @param loanState The state of the loan\n    /// @param loanLiquidationData The liquidation data of the loan\n    function _validateBidLiquidationAuction(\n        uint256 currentBid,\n        DataTypes.LoanState loanState,\n        DataTypes.LoanLiquidationData memory loanLiquidationData\n    ) internal view {\n        // Check if the auction exists\n        require(\n            loanState == DataTypes.LoanState.Auctioned,\n            \"VL:VBLA:AUCTION_NOT_FOUND\"\n        );\n\n        // Check if the auction is still active\n        require(\n            block.timestamp <\n                loanLiquidationData.auctionStartTimestamp +\n                    LIQUIDATION_AUCTION_PERIOD,\n            \"VL:VBLA:AUCTION_NOT_ACTIVE\"\n        );\n\n        // Check if bid is higher than current bid\n        require(\n            currentBid > loanLiquidationData.auctionMaxBid,\n            \"VL:VBLA:BID_TOO_LOW\"\n        );\n    }\n\n    function _validateClaimLiquidation(\n        DataTypes.LoanState loanState,\n        uint256 loanAuctionStartTimestamp\n    ) internal view {\n        // Check if the loan is being auctioned\n        require(\n            loanState == DataTypes.LoanState.Auctioned,\n            \"VL:VCLA:AUCTION_NOT_FOUND\"\n        );\n\n        // Check if the auction is still active\n        require(\n            block.timestamp >\n                loanAuctionStartTimestamp + LIQUIDATION_AUCTION_PERIOD,\n            \"VL:VCLA:AUCTION_NOT_FINISHED\"\n        );\n    }\n}"
    }
  ]
}