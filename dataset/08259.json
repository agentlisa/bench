{
  "Title": "[M-05] MIMOManagedRebalance.sol#rebalance calculates managerFee incorrectly",
  "Content": "_Submitted by 0x52_\n\nInconsistent manager fees could lead to lack of incentivization to rebalance and unexpected liquidation.\n\n### Proof of Concept\n\n    uint256 managerFee = managedVault.fixedFee + flData.amount.wadMul(managedVault.varFee);\n\n    IERC20(a.stablex()).safeTransfer(managedVault.manager, managerFee);\n\nThe variable portion of the fee is calculated using the amount of the flashloan but pays out in PAR. This is problematic because the value of the flashloan asset is constantly fluctuating in value against PAR. This results in an unpredictable fee for both the user and the manager. If the asset drops in price then the user will pay more than they intended. If the asset increases in price then the fee may not be enough to incentivize the manager to call them. The purpose of the managed rebalance is to limit user interaction. If the manager isn't incentivized to call the vault then the user may be unexpectedly liquidated, resulting in loss of user funds.\n\n### Recommended Mitigation Steps\n\nvarFee should be calculated against the PAR of the rebalance like it is in MIMOAutoRebalance.sol:\n\n    IPriceFeed priceFeed = a.priceFeed();\n    address fromCollateral = vaultsData.vaultCollateralType(rbData.vaultId);\n\n    uint256 rebalanceValue = priceFeed.convertFrom(fromCollateral, flData.amount);\n    uint256 managerFee = managedVault.fixedFee + rebalanceValue.wadMul(managedVault.varFee);\n\n**[RayXpub (Mimo) confirmed and commented](https://github.com/code-423n4/2022-08-mimo-findings/issues/34#issuecomment-1210609570):**\n > We acknowledge this issue and intend to fix it.\n\n**horsefacts (warden) reviewed mitigation:**\n> **Status:** âœ… Resolved\n\n> **Finding:** A warden identified that the variable portion of manager fees in `MIMOManagedRebalance` was calculated incorrectly, based on the amount of the rebalance flash loan denominated in the collateral asset rather than the amount of the rebalance denominated in PAR.\n\n> **What changed:** The Mimo team updated the [fee calculation](https://github.com/mimo-capital/2022-08-mimo/blob/5186ef4be23f9dda81c8474096edb1f0594d70c3/contracts/actions/managed/MIMOManagedRebalance.sol#L61) to calculate the rebalance amount in PAR using a price feed.\n\n> **Why it works:** Since the rebalance amount is now denominated in PAR, it no longer fluctuates in terms of the collateral asset.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-08-mimo-august-2022-contest",
  "Code": [
    {
      "filename": "contracts/actions/managed/MIMOManagedRebalance.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@aave/core-v3/contracts/protocol/libraries/math/WadRayMath.sol\";\n\nimport \"./MIMOManagedAction.sol\";\nimport \"./interfaces/IMIMOManagedRebalance.sol\";\nimport \"../MIMOPausable.sol\";\nimport \"../MIMOFlashLoan.sol\";\n\ncontract MIMOManagedRebalance is\n  MIMOPausable,\n  MIMOManagedAction,\n  MIMOFlashLoan,\n  ReentrancyGuard,\n  IMIMOManagedRebalance\n{\n  using SafeERC20 for IERC20;\n  using WadRayMath for uint256;\n\n  address public immutable mimoRebalance;\n\n  constructor(\n    IAddressProvider _a,\n    IPool _lendingPool,\n    IMIMOProxyFactory _proxyFactory,\n    address _mimoRebalance\n  ) MIMOManagedAction(_a, _proxyFactory) MIMOFlashLoan(_lendingPool) {\n    if (_mimoRebalance == address(0)) {\n      revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n\n    mimoRebalance = _mimoRebalance;\n  }\n\n  /**\n    @notice Perform a rebalance on a vault by an appointed whitelisted manager on behalf of vault owner\n    @notice Vault must have been created though a MIMOProxy\n    @dev Can only be called once a day by the manager selected by the MIMOProxy owner\n    @dev Reverts if operation results in vault value change above allowed variation or in vault ratio lower \n    than min ratio\n    @dev NonReentrant to avoid exploits on what happens between before and after rebalance checks\n    @param flData Flashloan data struct containing flashloan parameters\n    @param rbData RebalanceData struct containing rebalance operation parameters\n    @param swapData SwapData struct containing aggegator swap parameters\n   */\n  function rebalance(\n    FlashLoanData calldata flData,\n    IMIMORebalance.RebalanceData calldata rbData,\n    IMIMOSwap.SwapData calldata swapData\n  ) external override whenNotPaused nonReentrant {\n    ManagedVault memory managedVault = _managedVaults[rbData.vaultId];\n    IVaultsDataProvider vaultsData = a.vaultsData();\n\n    _preRebalanceChecks(managedVault, rbData, vaultsData, flData.amount);\n\n    // Value of the flashloaned collateral is the same as the value of the rebalanced collateral\n    address fromCollateral = vaultsData.vaultCollateralType(rbData.vaultId);\n    uint256 rebalanceValue = a.priceFeed().convertFrom(fromCollateral, flData.amount);\n    uint256 managerFee = managedVault.fixedFee + rebalanceValue.wadMul(managedVault.varFee);\n    address vaultOwner = vaultsData.vaultOwner(rbData.vaultId);\n    uint256 vaultBId = vaultsData.vaultId(address(rbData.toCollateral), vaultOwner);\n    uint256 vaultBBalanceBefore = vaultsData.vaultCollateralBalance(vaultBId);\n\n    _takeFlashLoan(flData, abi.encode(vaultsData.vaultOwner(rbData.vaultId), managerFee, rbData, swapData));\n\n    _postRebalanceChecks(\n      managedVault,\n      rebalanceValue,\n      vaultBBalanceBefore,\n      rbData.vaultId,\n      vaultOwner,\n      address(rbData.toCollateral),\n      vaultsData\n    );\n\n    _operationTracker[rbData.vaultId] = block.timestamp;\n\n    IERC20(a.stablex()).safeTransfer(managedVault.manager, managerFee);\n  }\n\n  /**\n    @notice Routes a call from a flashloan pool to a leverage or rebalance operation\n    @dev Integrates with AAVE V3 flashLoans\n    @param assets Address array with one element corresponding to the address of the reblanced asset\n    @param amounts Uint array with one element corresponding to the amount of the rebalanced asset\n    @param premiums Uint array with one element corresponding to the flashLoan fees\n    @param initiator Initiator of the flashloan; can only be MIMOProxy owner\n    @param params Bytes sent by this contract containing MIMOProxy owner, RebalanceData struct and SwapData struct\n    @return True if success and False if not\n   */\n  function executeOperation(\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address initiator,\n    bytes calldata params\n  ) external override returns (bool) {\n    (\n      address mimoProxy,\n      uint256 managerFee,\n      IMIMORebalance.RebalanceData memory rbData,\n      IMIMOSwap.SwapData memory swapData\n    ) = abi.decode(params, (address, uint256, IMIMORebalance.RebalanceData, IMIMOSwap.SwapData));\n\n    if (initiator != address(this)) {\n      revert Errors.INITIATOR_NOT_AUTHORIZED(initiator, address(this));\n    }\n    if (msg.sender != address(lendingPool)) {\n      revert Errors.CALLER_NOT_LENDING_POOL(msg.sender, address(lendingPool));\n    }\n\n    IERC20 fromCollateral = IERC20(assets[0]);\n    uint256 amount = amounts[0];\n    fromCollateral.safeTransfer(address(mimoProxy), amounts[0]);\n    uint256 flashloanRepayAmount = amounts[0] + premiums[0];\n\n    IMIMOProxy(mimoProxy).execute(\n      mimoRebalance,\n      abi.encodeWithSignature(\n        \"rebalanceOperation(address,uint256,uint256,uint256,(address,uint256,uint256),(uint256,bytes))\",\n        fromCollateral,\n        amount,\n        flashloanRepayAmount,\n        managerFee,\n        rbData,\n        swapData\n      )\n    );\n\n    fromCollateral.safeIncreaseAllowance(address(lendingPool), flashloanRepayAmount);\n\n    return true;\n  }\n\n  /**\n    @notice Helper function performing pre rebalance operation sanity checks\n    @dev Checks that :\n      - Manager is whitelisted\n      - Vault is under management\n      - Caller is the vault selected manager\n      - Rebalance amount is greater than zero\n      - Maximum daily operations has not been exceeded\n      - Mint amount is not greater than vault debt\n    @param managedVault ManagedVault struct of the vault to rebalance\n    @param rbData RebalanceData struct of the vault to rebalance\n    @param vaultsData Cached VaultsDataProvider interface for gas saving\n   */\n  function _preRebalanceChecks(\n    ManagedVault memory managedVault,\n    IMIMORebalance.RebalanceData calldata rbData,\n    IVaultsDataProvider vaultsData,\n    uint256 rebalanceAmount\n  ) internal view {\n    if (!_managers[msg.sender]) {\n      revert Errors.MANAGER_NOT_LISTED();\n    }\n    if (!managedVault.isManaged) {\n      revert Errors.VAULT_NOT_UNDER_MANAGEMENT();\n    }\n    if (msg.sender != managedVault.manager) {\n      revert Errors.CALLER_NOT_SELECTED_MANAGER();\n    }\n    if (rebalanceAmount == 0) {\n      revert Errors.REBALANCE_AMOUNT_CANNOT_BE_ZERO();\n    }\n    if (_operationTracker[rbData.vaultId] > block.timestamp - 1 days) {\n      revert Errors.MAX_OPERATIONS_REACHED();\n    }\n    if (vaultsData.vaultDebt(rbData.vaultId) < rbData.mintAmount) {\n      revert Errors.MINT_AMOUNT_GREATER_THAN_VAULT_DEBT();\n    }\n  }\n\n  /**\n    @notice Helper function performing post rebalance operation sanity checks\n    @dev Checks that :\n      - Rebalance swap slippage is below allowedVaration\n      - Vault A ratio is equal or above minRatio\n      - Vault B ratio is equal or above MCR + mcrBuffer\n    @param managedVault ManagedVault struct of the vault to rebalance\n    @param rebalanceValue Value in PAR of the amount of rebalanced collateral \n    @param vaultBBalanceBefore Collateral balance of the vault to be rebalanced to before the rebalance operation\n    @param vaultId Vault id of the vault to rebalance\n    @param vaultOwner Rebalanced vault owner\n    @param toCollateral Collateral to rebalance to\n    @param vaultsData Cached VaultsDataProvider interface for gas saving\n   */\n  function _postRebalanceChecks(\n    ManagedVault memory managedVault,\n    uint256 rebalanceValue,\n    uint256 vaultBBalanceBefore,\n    uint256 vaultId,\n    address vaultOwner,\n    address toCollateral,\n    IVaultsDataProvider vaultsData\n  ) internal view {\n    IPriceFeed priceFeed = a.priceFeed();\n    uint256 vaultBId = vaultsData.vaultId(toCollateral, vaultOwner);\n    uint256 vaultBBalanceAfter = vaultsData.vaultCollateralBalance(vaultBId);\n    uint256 swapResultValue = priceFeed.convertFrom(toCollateral, vaultBBalanceAfter - vaultBBalanceBefore);\n\n    if (!_isVaultVariationAllowed(managedVault, rebalanceValue, swapResultValue)) {\n      revert Errors.VAULT_VALUE_CHANGE_TOO_HIGH();\n    }\n\n    uint256 vaultARatioAfter = _getVaultRatio(vaultId);\n\n    if (vaultARatioAfter < managedVault.minRatio) {\n      revert Errors.FINAL_VAULT_RATIO_TOO_LOW(managedVault.minRatio, vaultARatioAfter);\n    }\n\n    uint256 vaultBRatioAfter = _getVaultRatio(vaultBId);\n    uint256 minVaultBRatio = a.config().collateralMinCollateralRatio(toCollateral) + managedVault.mcrBuffer;\n\n    if (vaultBRatioAfter < minVaultBRatio) {\n      revert Errors.FINAL_VAULT_RATIO_TOO_LOW(minVaultBRatio, vaultBRatioAfter);\n    }\n  }\n}"
    }
  ]
}