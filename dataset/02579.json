{
  "Title": "M-3: Possible division by zero depending on `TradingModule.getOraclePrice` return values",
  "Content": "# Issue M-3: Possible division by zero depending on `TradingModule.getOraclePrice` return values \n\nSource: https://github.com/sherlock-audit/2022-12-notional-judging/issues/2 \n\n## Found by \nMalfurionWhitehat, ak1, Deivitto\n\n## Summary\n\nSome functions depending on `TradingModule.getOraclePrice` accept non-negative `(int256 answer, int256 decimals)` return values. In case any of those are equal to zero, division depending on `answer` or `decimals` will revert. In the worst case scenario, this will prevent the protocol from continuing operating.\n\n## Vulnerability Detail\n\nThe function `TradingModule.getOraclePrice` properly validates that return values from Chainlink price feeds [are](https://github.com/notional-finance/leveraged-vaults/blob/dd797156651580737ba54506db075b9fdb3d35e9/contracts/trading/TradingModule.sol#L244) [positive](https://github.com/notional-finance/leveraged-vaults/blob/dd797156651580737ba54506db075b9fdb3d35e9/contracts/trading/TradingModule.sol#L248). \n\nNevertheless, `answer` may _currently_ return zero, as [it is calculated as](https://github.com/notional-finance/leveraged-vaults/blob/dd797156651580737ba54506db075b9fdb3d35e9/contracts/trading/TradingModule.sol#L250-L252) `(basePrice * quoteDecimals * RATE_DECIMALS) / (quotePrice * baseDecimals);`, which can be truncated down to zero, depending on base/quote prices [1]. Additionally, `decimals` may _in the future_ return zero, depending on changes to the protocol code, as [the NatSpec states that](https://github.com/notional-finance/leveraged-vaults/blob/dd797156651580737ba54506db075b9fdb3d35e9/contracts/trading/TradingModule.sol#L229) this is a `number of decimals in the rate, currently hardcoded to 1e18` [2].\n\nIf any of these return values are zero, calculations that use division depending on `TradingModule.getOraclePrice` will revert.\n\nMore specifically:\n\n**[1]**\n\n**1.1** [`TradingModule.getLimitAmount`](https://github.com/notional-finance/leveraged-vaults/blob/dd797156651580737ba54506db075b9fdb3d35e9/contracts/trading/TradingModule.sol#L282)\n\n```solidity\n        require(oraclePrice >= 0); /// @dev Chainlink rate error\n```\n\nthat calls `TradingUtils._getLimitAmount`, which reverts if [`oraclePrice` is `0`](https://github.com/notional-finance/leveraged-vaults/blob/dd797156651580737ba54506db075b9fdb3d35e9/contracts/trading/TradingUtils.sol#L207)\n\n```solidity\n            oraclePrice = (oracleDecimals * oracleDecimals) / oraclePrice;\n```\n\n**[2]**\n**2.1** [`TwoTokenPoolUtils._getOraclePairPrice`](https://github.com/notional-finance/leveraged-vaults/blob/dd797156651580737ba54506db075b9fdb3d35e9/contracts/vaults/balancer/internal/pool/TwoTokenPoolUtils.sol#L101-L105)\n\n```solidity\n            require(decimals >= 0);\n\n            if (uint256(decimals) != BalancerConstants.BALANCER_PRECISION) {\n                rate = (rate * int256(BalancerConstants.BALANCER_PRECISION)) / decimals;\n            }\n```\n\n**2.2** [`TradingModule.getLimitAmount`](https://github.com/notional-finance/leveraged-vaults/blob/dd797156651580737ba54506db075b9fdb3d35e9/contracts/trading/TradingModule.sol#L283)\n\n```solidity\n        require(oracleDecimals >= 0); /// @dev Chainlink decimals error\n```\n\nthat calls `TradingUtils._getLimitAmount`, which reverts if [`oracleDecimals` is `0`](https://github.com/notional-finance/leveraged-vaults/blob/dd797156651580737ba54506db075b9fdb3d35e9/contracts/trading/TradingUtils.sol#L210-L214)\n\n```solidity\n            limitAmount =\n                ((oraclePrice + \n                    ((oraclePrice * uint256(slippageLimit)) /\n                        Constants.SLIPPAGE_LIMIT_PRECISION)) * amount) / \n                oracleDecimals;\n```\n\n**2.3** [`CrossCurrencyfCashVault.convertStrategyToUnderlying`](https://github.com/notional-finance/leveraged-vaults/blob/b7f75fd6946dad9661d2476b7b9c7fe3eb78bcd2/contracts/vaults/CrossCurrencyfCashVault.sol#L174-L182)\n\n```solidity\n        return (pvInternal * borrowTokenDecimals * rate) /\n            (rateDecimals * int256(Constants.INTERNAL_TOKEN_PRECISION));\n```\n\n## Impact\n\nIn the worst case, the protocol might stop operating. \n\nAlbeit unlikely that `decimals` is ever zero, since currently this is a hardcoded value, it is possible that `answer` might be zero due to round-down performed by the division in `TradingModule.getOraclePrice`. This can happen if the quote token is much more expensive than the base token. In this case, `TradingModule.getLimitAmount` and depending calls, such as `TradingModule.executeTradeWithDynamicSlippage` might revert.\n\n## Code Snippet\n\n```solidity\n        answer =\n            (basePrice * quoteDecimals * RATE_DECIMALS) /\n            (quotePrice * baseDecimals);\n        decimals = RATE_DECIMALS;\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nValidate that the return values are strictly positive (instead of non-negative) in case depending function calculations may result in division by zero. This can be either done on `TradingModule.getOraclePrice` directly or on the depending functions.\n\n```diff\ndiff --git a/contracts/trading/TradingModule.sol b/contracts/trading/TradingModule.sol\nindex bfc8505..70b40f2 100644\n--- a/contracts/trading/TradingModule.sol\n+++ b/contracts/trading/TradingModule.sol\n@@ -251,6 +251,9 @@ contract TradingModule is Initializable, UUPSUpgradeable, ITradingModule {\n             (basePrice * quoteDecimals * RATE_DECIMALS) /\n             (quotePrice * baseDecimals);\n         decimals = RATE_DECIMALS;\n+\n+        require(answer > 0); /// @dev Chainlink rate error\n+        require(decimals > 0); /// @dev Chainlink decimals error\n     }\n \n     function _hasPermission(uint32 flags, uint32 flagID) private pure returns (bool) {\n@@ -279,9 +282,6 @@ contract TradingModule is Initializable, UUPSUpgradeable, ITradingModule {\n         // prettier-ignore\n         (int256 oraclePrice, int256 oracleDecimals) = getOraclePrice(sellToken, buyToken);\n \n-        require(oraclePrice >= 0); /// @dev Chainlink rate error\n-        require(oracleDecimals >= 0); /// @dev Chainlink decimals error\n-\n         limitAmount = TradingUtils._getLimitAmount({\n             tradeType: tradeType,\n             sellToken: sellToken,\ndiff --git a/contracts/vaults/balancer/internal/pool/TwoTokenPoolUtils.sol b/contracts/vaults/balancer/internal/pool/TwoTokenPoolUtils.sol\nindex 4954c59..6315c0a 100644\n--- a/contracts/vaults/balancer/internal/pool/TwoTokenPoolUtils.sol\n+++ b/contracts/vaults/balancer/internal/pool/TwoTokenPoolUtils.sol\n@@ -76,10 +76,7 @@ library TwoTokenPoolUtils {\n         (int256 rate, int256 decimals) = tradingModule.getOraclePrice(\n             poolContext.primaryToken, poolContext.secondaryToken\n         );\n-        require(rate > 0);\n-        require(decimals >= 0);\n \n         if (uint256(decimals) != BalancerConstants.BALANCER_PRECISION) {\n             rate = (rate * int256(BalancerConstants.BALANCER_PRECISION)) / decimals;\n         }\n\n```\n\n\n\n\n## Discussion\n\n**weitianjie2000**\n\nvalid, will fix\n\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/31",
  "Code": [
    {
      "filename": "contracts/trading/TradingModule.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport {Deployments} from \"../global/Deployments.sol\";\nimport {Constants} from \"../global/Constants.sol\";\nimport {BalancerV2Adapter} from \"./adapters/BalancerV2Adapter.sol\";\nimport {CurveAdapter} from \"./adapters/CurveAdapter.sol\";\nimport {UniV2Adapter} from \"./adapters/UniV2Adapter.sol\";\nimport {UniV3Adapter} from \"./adapters/UniV3Adapter.sol\";\nimport {ZeroExAdapter} from \"./adapters/ZeroExAdapter.sol\";\nimport {TradingUtils} from \"./TradingUtils.sol\";\n\nimport {IERC20} from \"../utils/TokenUtils.sol\";\nimport {NotionalProxy} from \"../../interfaces/notional/NotionalProxy.sol\";\nimport {ITradingModule} from \"../../interfaces/trading/ITradingModule.sol\";\nimport \"../../interfaces/trading/IVaultExchange.sol\";\nimport \"../../interfaces/chainlink/AggregatorV2V3Interface.sol\";\n\n/// @notice TradingModule is meant to be an upgradeable contract deployed to help Strategy Vaults\n/// exchange tokens via multiple DEXes as well as receive price oracle information\ncontract TradingModule is Initializable, UUPSUpgradeable, ITradingModule {\n    NotionalProxy public immutable NOTIONAL;\n    // Used to get the proxy address inside delegate call contexts\n    ITradingModule internal immutable PROXY;\n\n    error SellTokenEqualsBuyToken();\n    error UnknownDEX();\n    error InsufficientPermissions();\n\n    struct PriceOracle {\n        AggregatorV2V3Interface oracle;\n        uint8 rateDecimals;\n    }\n\n    int256 internal constant RATE_DECIMALS = 1e18;\n    mapping(address => PriceOracle) public priceOracles;\n    uint32 public maxOracleFreshnessInSeconds;\n    mapping(address => mapping(address => TokenPermissions)) public tokenWhitelist;\n\n    constructor(NotionalProxy notional_, ITradingModule proxy_) initializer { \n        NOTIONAL = notional_;\n        PROXY = proxy_;\n    }\n\n    modifier onlyNotionalOwner() {\n        require(msg.sender == NOTIONAL.owner());\n        _;\n    }\n\n    function _authorizeUpgrade(\n        address /* newImplementation */\n    ) internal override onlyNotionalOwner {}\n\n    function initialize(uint32 maxOracleFreshnessInSeconds_) external initializer onlyNotionalOwner {\n        maxOracleFreshnessInSeconds = maxOracleFreshnessInSeconds_;\n    }\n\n    function setMaxOracleFreshness(uint32 newMaxOracleFreshnessInSeconds) external onlyNotionalOwner {\n        emit MaxOracleFreshnessUpdated(maxOracleFreshnessInSeconds, newMaxOracleFreshnessInSeconds);\n        maxOracleFreshnessInSeconds = newMaxOracleFreshnessInSeconds;\n    }\n\n    function setPriceOracle(address token, AggregatorV2V3Interface oracle) external override onlyNotionalOwner {\n        PriceOracle storage oracleStorage = priceOracles[token];\n        oracleStorage.oracle = oracle;\n        oracleStorage.rateDecimals = oracle.decimals();\n\n        emit PriceOracleUpdated(token, address(oracle));\n    }\n\n    function setTokenPermissions(\n        address sender, \n        address token, \n        TokenPermissions calldata permissions\n    ) external override onlyNotionalOwner {\n        /// @dev update these if we are adding new DEXes or types\n        for (uint32 i = uint32(DexId.NOTIONAL_VAULT) + 1; i < 32; i++) {\n            require(!_hasPermission(permissions.dexFlags, uint32(1 << i)));\n        }\n        for (uint32 i = uint32(TradeType.EXACT_OUT_BATCH) + 1; i < 32; i++) {\n            require(!_hasPermission(permissions.tradeTypeFlags, uint32(1 << i)));\n        }\n        tokenWhitelist[sender][token] = permissions;\n        emit TokenPermissionsUpdated(sender, token, permissions);\n    }\n\n    /// @notice Called to receive execution data for vaults that will execute trades without\n    /// delegating calls to this contract\n    /// @param dexId enum representing the id of the dex\n    /// @param from address for the contract executing the trade\n    /// @param trade trade object\n    /// @return spender the address to approve for the soldToken, will be address(0) if the\n    /// send token is ETH and therefore does not require approval\n    /// @return target contract to execute the call against\n    /// @return msgValue amount of ETH to transfer to the target, if any\n    /// @return executionCallData encoded call data for the trade\n    function getExecutionData(\n        uint16 dexId,\n        address from,\n        Trade calldata trade\n    )\n        external\n        view\n        override\n        returns (\n            address spender,\n            address target,\n            uint256 msgValue,\n            bytes memory executionCallData\n        )\n    {\n        return _getExecutionData(dexId, from, trade);\n    }\n\n    /// @notice Executes a trade with a dynamic slippage limit based on chainlink oracles.\n    /// @dev Expected to be called via delegatecall on the implementation directly. This means that\n    /// the contract's calling context does not have access to storage (accessible via the proxy\n    /// address).\n    /// @param dexId the dex to execute the trade on\n    /// @param trade trade object\n    /// @param dynamicSlippageLimit the slippage limit in 1e8 precision\n    /// @return amountSold amount of tokens sold\n    /// @return amountBought amount of tokens purchased\n    function executeTradeWithDynamicSlippage(\n        uint16 dexId,\n        Trade memory trade,\n        uint32 dynamicSlippageLimit\n    ) external override returns (uint256 amountSold, uint256 amountBought) {\n        if (!PROXY.canExecuteTrade(address(this), dexId, trade)) revert InsufficientPermissions();\n        if (trade.amount == 0) return (0, 0);\n\n        // This method calls back into the implementation via the proxy so that it has proper\n        // access to storage.\n        trade.limit = PROXY.getLimitAmount(\n            trade.tradeType,\n            trade.sellToken,\n            trade.buyToken,\n            trade.amount,\n            dynamicSlippageLimit\n        );\n\n        (\n            address spender,\n            address target,\n            uint256 msgValue,\n            bytes memory executionData\n        ) = PROXY.getExecutionData(dexId, address(this), trade);\n\n        return\n            TradingUtils._executeInternal(\n                trade,\n                dexId,\n                spender,\n                target,\n                msgValue,\n                executionData\n            );\n    }\n\n    /// @notice Should be called via delegate call to execute a trade on behalf of the caller.\n    /// @param dexId enum representing the id of the dex\n    /// @param trade trade object\n    /// @return amountSold amount of tokens sold\n    /// @return amountBought amount of tokens purchased\n    function executeTrade(uint16 dexId, Trade calldata trade)\n        external\n        override\n        returns (uint256 amountSold, uint256 amountBought)\n    {\n        if (!PROXY.canExecuteTrade(address(this), dexId, trade)) revert InsufficientPermissions();\n        if (trade.amount == 0) return (0, 0);\n\n        (\n            address spender,\n            address target,\n            uint256 msgValue,\n            bytes memory executionData\n        ) = _getExecutionData(dexId, address(this), trade);\n\n        return\n            TradingUtils._executeInternal(\n                trade,\n                dexId,\n                spender,\n                target,\n                msgValue,\n                executionData\n            );\n    }\n\n    function _getExecutionData(\n        uint16 dexId,\n        address from,\n        Trade calldata trade\n    )\n        internal\n        view\n        returns (\n            address spender,\n            address target,\n            uint256 msgValue,\n            bytes memory executionCallData\n        )\n    {\n        if (trade.buyToken == trade.sellToken) revert SellTokenEqualsBuyToken();\n\n        if (DexId(dexId) == DexId.UNISWAP_V2) {\n            return UniV2Adapter.getExecutionData(from, trade);\n        } else if (DexId(dexId) == DexId.UNISWAP_V3) {\n            return UniV3Adapter.getExecutionData(from, trade);\n        } else if (DexId(dexId) == DexId.BALANCER_V2) {\n            return BalancerV2Adapter.getExecutionData(from, trade);\n        } else if (DexId(dexId) == DexId.CURVE) {\n            return CurveAdapter.getExecutionData(from, trade);\n        }\n\n        revert UnknownDEX();\n    }\n\n    /// @notice Returns the Chainlink oracle price between the baseToken and the quoteToken, the\n    /// Chainlink oracles. The quote currency between the oracles must match or the conversion\n    /// in this method does not work. Most Chainlink oracles are baseToken/USD pairs.\n    /// @param baseToken address of the first token in the pair, i.e. USDC in USDC/DAI\n    /// @param quoteToken address of the second token in the pair, i.e. DAI in USDC/DAI\n    /// @return answer exchange rate in rate decimals\n    /// @return decimals number of decimals in the rate, currently hardcoded to 1e18\n    function getOraclePrice(address baseToken, address quoteToken)\n        public\n        view\n        override\n        returns (int256 answer, int256 decimals)\n    {\n        PriceOracle memory baseOracle = priceOracles[baseToken];\n        PriceOracle memory quoteOracle = priceOracles[quoteToken];\n\n        int256 baseDecimals = int256(10**baseOracle.rateDecimals);\n        int256 quoteDecimals = int256(10**quoteOracle.rateDecimals);\n\n        (/* */, int256 basePrice, /* */, uint256 bpUpdatedAt, /* */) = baseOracle.oracle.latestRoundData();\n        require(block.timestamp - bpUpdatedAt <= maxOracleFreshnessInSeconds);\n        require(basePrice > 0); /// @dev: Chainlink Rate Error\n\n        (/* */, int256 quotePrice, /* */, uint256 qpUpdatedAt, /* */) = quoteOracle.oracle.latestRoundData();\n        require(block.timestamp - qpUpdatedAt <= maxOracleFreshnessInSeconds);\n        require(quotePrice > 0); /// @dev: Chainlink Rate Error\n\n        answer =\n            (basePrice * quoteDecimals * RATE_DECIMALS) /\n            (quotePrice * baseDecimals);\n        decimals = RATE_DECIMALS;\n    }\n\n    function _hasPermission(uint32 flags, uint32 flagID) private pure returns (bool) {\n        return (flags & flagID) == flagID;\n    }\n\n    /// @notice Check if the caller is allowed to execute the provided trade object\n    function canExecuteTrade(address from, uint16 dexId, Trade calldata trade) external view override returns (bool) {\n        TokenPermissions memory permissions = tokenWhitelist[from][trade.sellToken];\n        if (!_hasPermission(permissions.dexFlags, uint32(1 << dexId))) {\n            return false;\n        }\n        if (!_hasPermission(permissions.tradeTypeFlags, uint32(1 << uint32(trade.tradeType)))) {\n            return false;\n        }\n        return permissions.allowSell;\n    }\n\n    function getLimitAmount(\n        TradeType tradeType,\n        address sellToken,\n        address buyToken,\n        uint256 amount,\n        uint32 slippageLimit\n    ) external view override returns (uint256 limitAmount) {\n        // prettier-ignore\n        (int256 oraclePrice, int256 oracleDecimals) = getOraclePrice(sellToken, buyToken);\n\n        require(oraclePrice >= 0); /// @dev Chainlink rate error\n        require(oracleDecimals >= 0); /// @dev Chainlink decimals error\n\n        limitAmount = TradingUtils._getLimitAmount({\n            tradeType: tradeType,\n            sellToken: sellToken,\n            buyToken: buyToken,\n            amount: amount,\n            slippageLimit: slippageLimit,\n            oraclePrice: uint256(oraclePrice),\n            oracleDecimals: uint256(oracleDecimals)\n        });\n    }\n}"
    },
    {
      "filename": "contracts/trading/TradingModule.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport {Deployments} from \"../global/Deployments.sol\";\nimport {Constants} from \"../global/Constants.sol\";\nimport {BalancerV2Adapter} from \"./adapters/BalancerV2Adapter.sol\";\nimport {CurveAdapter} from \"./adapters/CurveAdapter.sol\";\nimport {UniV2Adapter} from \"./adapters/UniV2Adapter.sol\";\nimport {UniV3Adapter} from \"./adapters/UniV3Adapter.sol\";\nimport {ZeroExAdapter} from \"./adapters/ZeroExAdapter.sol\";\nimport {TradingUtils} from \"./TradingUtils.sol\";\n\nimport {IERC20} from \"../utils/TokenUtils.sol\";\nimport {NotionalProxy} from \"../../interfaces/notional/NotionalProxy.sol\";\nimport {ITradingModule} from \"../../interfaces/trading/ITradingModule.sol\";\nimport \"../../interfaces/trading/IVaultExchange.sol\";\nimport \"../../interfaces/chainlink/AggregatorV2V3Interface.sol\";\n\n/// @notice TradingModule is meant to be an upgradeable contract deployed to help Strategy Vaults\n/// exchange tokens via multiple DEXes as well as receive price oracle information\ncontract TradingModule is Initializable, UUPSUpgradeable, ITradingModule {\n    NotionalProxy public immutable NOTIONAL;\n    // Used to get the proxy address inside delegate call contexts\n    ITradingModule internal immutable PROXY;\n\n    error SellTokenEqualsBuyToken();\n    error UnknownDEX();\n    error InsufficientPermissions();\n\n    struct PriceOracle {\n        AggregatorV2V3Interface oracle;\n        uint8 rateDecimals;\n    }\n\n    int256 internal constant RATE_DECIMALS = 1e18;\n    mapping(address => PriceOracle) public priceOracles;\n    uint32 public maxOracleFreshnessInSeconds;\n    mapping(address => mapping(address => TokenPermissions)) public tokenWhitelist;\n\n    constructor(NotionalProxy notional_, ITradingModule proxy_) initializer { \n        NOTIONAL = notional_;\n        PROXY = proxy_;\n    }\n\n    modifier onlyNotionalOwner() {\n        require(msg.sender == NOTIONAL.owner());\n        _;\n    }\n\n    function _authorizeUpgrade(\n        address /* newImplementation */\n    ) internal override onlyNotionalOwner {}\n\n    function initialize(uint32 maxOracleFreshnessInSeconds_) external initializer onlyNotionalOwner {\n        maxOracleFreshnessInSeconds = maxOracleFreshnessInSeconds_;\n    }\n\n    function setMaxOracleFreshness(uint32 newMaxOracleFreshnessInSeconds) external onlyNotionalOwner {\n        emit MaxOracleFreshnessUpdated(maxOracleFreshnessInSeconds, newMaxOracleFreshnessInSeconds);\n        maxOracleFreshnessInSeconds = newMaxOracleFreshnessInSeconds;\n    }\n\n    function setPriceOracle(address token, AggregatorV2V3Interface oracle) external override onlyNotionalOwner {\n        PriceOracle storage oracleStorage = priceOracles[token];\n        oracleStorage.oracle = oracle;\n        oracleStorage.rateDecimals = oracle.decimals();\n\n        emit PriceOracleUpdated(token, address(oracle));\n    }\n\n    function setTokenPermissions(\n        address sender, \n        address token, \n        TokenPermissions calldata permissions\n    ) external override onlyNotionalOwner {\n        /// @dev update these if we are adding new DEXes or types\n        for (uint32 i = uint32(DexId.NOTIONAL_VAULT) + 1; i < 32; i++) {\n            require(!_hasPermission(permissions.dexFlags, uint32(1 << i)));\n        }\n        for (uint32 i = uint32(TradeType.EXACT_OUT_BATCH) + 1; i < 32; i++) {\n            require(!_hasPermission(permissions.tradeTypeFlags, uint32(1 << i)));\n        }\n        tokenWhitelist[sender][token] = permissions;\n        emit TokenPermissionsUpdated(sender, token, permissions);\n    }\n\n    /// @notice Called to receive execution data for vaults that will execute trades without\n    /// delegating calls to this contract\n    /// @param dexId enum representing the id of the dex\n    /// @param from address for the contract executing the trade\n    /// @param trade trade object\n    /// @return spender the address to approve for the soldToken, will be address(0) if the\n    /// send token is ETH and therefore does not require approval\n    /// @return target contract to execute the call against\n    /// @return msgValue amount of ETH to transfer to the target, if any\n    /// @return executionCallData encoded call data for the trade\n    function getExecutionData(\n        uint16 dexId,\n        address from,\n        Trade calldata trade\n    )\n        external\n        view\n        override\n        returns (\n            address spender,\n            address target,\n            uint256 msgValue,\n            bytes memory executionCallData\n        )\n    {\n        return _getExecutionData(dexId, from, trade);\n    }\n\n    /// @notice Executes a trade with a dynamic slippage limit based on chainlink oracles.\n    /// @dev Expected to be called via delegatecall on the implementation directly. This means that\n    /// the contract's calling context does not have access to storage (accessible via the proxy\n    /// address).\n    /// @param dexId the dex to execute the trade on\n    /// @param trade trade object\n    /// @param dynamicSlippageLimit the slippage limit in 1e8 precision\n    /// @return amountSold amount of tokens sold\n    /// @return amountBought amount of tokens purchased\n    function executeTradeWithDynamicSlippage(\n        uint16 dexId,\n        Trade memory trade,\n        uint32 dynamicSlippageLimit\n    ) external override returns (uint256 amountSold, uint256 amountBought) {\n        if (!PROXY.canExecuteTrade(address(this), dexId, trade)) revert InsufficientPermissions();\n        if (trade.amount == 0) return (0, 0);\n\n        // This method calls back into the implementation via the proxy so that it has proper\n        // access to storage.\n        trade.limit = PROXY.getLimitAmount(\n            trade.tradeType,\n            trade.sellToken,\n            trade.buyToken,\n            trade.amount,\n            dynamicSlippageLimit\n        );\n\n        (\n            address spender,\n            address target,\n            uint256 msgValue,\n            bytes memory executionData\n        ) = PROXY.getExecutionData(dexId, address(this), trade);\n\n        return\n            TradingUtils._executeInternal(\n                trade,\n                dexId,\n                spender,\n                target,\n                msgValue,\n                executionData\n            );\n    }\n\n    /// @notice Should be called via delegate call to execute a trade on behalf of the caller.\n    /// @param dexId enum representing the id of the dex\n    /// @param trade trade object\n    /// @return amountSold amount of tokens sold\n    /// @return amountBought amount of tokens purchased\n    function executeTrade(uint16 dexId, Trade calldata trade)\n        external\n        override\n        returns (uint256 amountSold, uint256 amountBought)\n    {\n        if (!PROXY.canExecuteTrade(address(this), dexId, trade)) revert InsufficientPermissions();\n        if (trade.amount == 0) return (0, 0);\n\n        (\n            address spender,\n            address target,\n            uint256 msgValue,\n            bytes memory executionData\n        ) = _getExecutionData(dexId, address(this), trade);\n\n        return\n            TradingUtils._executeInternal(\n                trade,\n                dexId,\n                spender,\n                target,\n                msgValue,\n                executionData\n            );\n    }\n\n    function _getExecutionData(\n        uint16 dexId,\n        address from,\n        Trade calldata trade\n    )\n        internal\n        view\n        returns (\n            address spender,\n            address target,\n            uint256 msgValue,\n            bytes memory executionCallData\n        )\n    {\n        if (trade.buyToken == trade.sellToken) revert SellTokenEqualsBuyToken();\n\n        if (DexId(dexId) == DexId.UNISWAP_V2) {\n            return UniV2Adapter.getExecutionData(from, trade);\n        } else if (DexId(dexId) == DexId.UNISWAP_V3) {\n            return UniV3Adapter.getExecutionData(from, trade);\n        } else if (DexId(dexId) == DexId.BALANCER_V2) {\n            return BalancerV2Adapter.getExecutionData(from, trade);\n        } else if (DexId(dexId) == DexId.CURVE) {\n            return CurveAdapter.getExecutionData(from, trade);\n        }\n\n        revert UnknownDEX();\n    }\n\n    /// @notice Returns the Chainlink oracle price between the baseToken and the quoteToken, the\n    /// Chainlink oracles. The quote currency between the oracles must match or the conversion\n    /// in this method does not work. Most Chainlink oracles are baseToken/USD pairs.\n    /// @param baseToken address of the first token in the pair, i.e. USDC in USDC/DAI\n    /// @param quoteToken address of the second token in the pair, i.e. DAI in USDC/DAI\n    /// @return answer exchange rate in rate decimals\n    /// @return decimals number of decimals in the rate, currently hardcoded to 1e18\n    function getOraclePrice(address baseToken, address quoteToken)\n        public\n        view\n        override\n        returns (int256 answer, int256 decimals)\n    {\n        PriceOracle memory baseOracle = priceOracles[baseToken];\n        PriceOracle memory quoteOracle = priceOracles[quoteToken];\n\n        int256 baseDecimals = int256(10**baseOracle.rateDecimals);\n        int256 quoteDecimals = int256(10**quoteOracle.rateDecimals);\n\n        (/* */, int256 basePrice, /* */, uint256 bpUpdatedAt, /* */) = baseOracle.oracle.latestRoundData();\n        require(block.timestamp - bpUpdatedAt <= maxOracleFreshnessInSeconds);\n        require(basePrice > 0); /// @dev: Chainlink Rate Error\n\n        (/* */, int256 quotePrice, /* */, uint256 qpUpdatedAt, /* */) = quoteOracle.oracle.latestRoundData();\n        require(block.timestamp - qpUpdatedAt <= maxOracleFreshnessInSeconds);\n        require(quotePrice > 0); /// @dev: Chainlink Rate Error\n\n        answer =\n            (basePrice * quoteDecimals * RATE_DECIMALS) /\n            (quotePrice * baseDecimals);\n        decimals = RATE_DECIMALS;\n    }\n\n    function _hasPermission(uint32 flags, uint32 flagID) private pure returns (bool) {\n        return (flags & flagID) == flagID;\n    }\n\n    /// @notice Check if the caller is allowed to execute the provided trade object\n    function canExecuteTrade(address from, uint16 dexId, Trade calldata trade) external view override returns (bool) {\n        TokenPermissions memory permissions = tokenWhitelist[from][trade.sellToken];\n        if (!_hasPermission(permissions.dexFlags, uint32(1 << dexId))) {\n            return false;\n        }\n        if (!_hasPermission(permissions.tradeTypeFlags, uint32(1 << uint32(trade.tradeType)))) {\n            return false;\n        }\n        return permissions.allowSell;\n    }\n\n    function getLimitAmount(\n        TradeType tradeType,\n        address sellToken,\n        address buyToken,\n        uint256 amount,\n        uint32 slippageLimit\n    ) external view override returns (uint256 limitAmount) {\n        // prettier-ignore\n        (int256 oraclePrice, int256 oracleDecimals) = getOraclePrice(sellToken, buyToken);\n\n        require(oraclePrice >= 0); /// @dev Chainlink rate error\n        require(oracleDecimals >= 0); /// @dev Chainlink decimals error\n\n        limitAmount = TradingUtils._getLimitAmount({\n            tradeType: tradeType,\n            sellToken: sellToken,\n            buyToken: buyToken,\n            amount: amount,\n            slippageLimit: slippageLimit,\n            oraclePrice: uint256(oraclePrice),\n            oracleDecimals: uint256(oracleDecimals)\n        });\n    }\n}"
    },
    {
      "filename": "contracts/trading/TradingModule.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport {Deployments} from \"../global/Deployments.sol\";\nimport {Constants} from \"../global/Constants.sol\";\nimport {BalancerV2Adapter} from \"./adapters/BalancerV2Adapter.sol\";\nimport {CurveAdapter} from \"./adapters/CurveAdapter.sol\";\nimport {UniV2Adapter} from \"./adapters/UniV2Adapter.sol\";\nimport {UniV3Adapter} from \"./adapters/UniV3Adapter.sol\";\nimport {ZeroExAdapter} from \"./adapters/ZeroExAdapter.sol\";\nimport {TradingUtils} from \"./TradingUtils.sol\";\n\nimport {IERC20} from \"../utils/TokenUtils.sol\";\nimport {NotionalProxy} from \"../../interfaces/notional/NotionalProxy.sol\";\nimport {ITradingModule} from \"../../interfaces/trading/ITradingModule.sol\";\nimport \"../../interfaces/trading/IVaultExchange.sol\";\nimport \"../../interfaces/chainlink/AggregatorV2V3Interface.sol\";\n\n/// @notice TradingModule is meant to be an upgradeable contract deployed to help Strategy Vaults\n/// exchange tokens via multiple DEXes as well as receive price oracle information\ncontract TradingModule is Initializable, UUPSUpgradeable, ITradingModule {\n    NotionalProxy public immutable NOTIONAL;\n    // Used to get the proxy address inside delegate call contexts\n    ITradingModule internal immutable PROXY;\n\n    error SellTokenEqualsBuyToken();\n    error UnknownDEX();\n    error InsufficientPermissions();\n\n    struct PriceOracle {\n        AggregatorV2V3Interface oracle;\n        uint8 rateDecimals;\n    }\n\n    int256 internal constant RATE_DECIMALS = 1e18;\n    mapping(address => PriceOracle) public priceOracles;\n    uint32 public maxOracleFreshnessInSeconds;\n    mapping(address => mapping(address => TokenPermissions)) public tokenWhitelist;\n\n    constructor(NotionalProxy notional_, ITradingModule proxy_) initializer { \n        NOTIONAL = notional_;\n        PROXY = proxy_;\n    }\n\n    modifier onlyNotionalOwner() {\n        require(msg.sender == NOTIONAL.owner());\n        _;\n    }\n\n    function _authorizeUpgrade(\n        address /* newImplementation */\n    ) internal override onlyNotionalOwner {}\n\n    function initialize(uint32 maxOracleFreshnessInSeconds_) external initializer onlyNotionalOwner {\n        maxOracleFreshnessInSeconds = maxOracleFreshnessInSeconds_;\n    }\n\n    function setMaxOracleFreshness(uint32 newMaxOracleFreshnessInSeconds) external onlyNotionalOwner {\n        emit MaxOracleFreshnessUpdated(maxOracleFreshnessInSeconds, newMaxOracleFreshnessInSeconds);\n        maxOracleFreshnessInSeconds = newMaxOracleFreshnessInSeconds;\n    }\n\n    function setPriceOracle(address token, AggregatorV2V3Interface oracle) external override onlyNotionalOwner {\n        PriceOracle storage oracleStorage = priceOracles[token];\n        oracleStorage.oracle = oracle;\n        oracleStorage.rateDecimals = oracle.decimals();\n\n        emit PriceOracleUpdated(token, address(oracle));\n    }\n\n    function setTokenPermissions(\n        address sender, \n        address token, \n        TokenPermissions calldata permissions\n    ) external override onlyNotionalOwner {\n        /// @dev update these if we are adding new DEXes or types\n        for (uint32 i = uint32(DexId.NOTIONAL_VAULT) + 1; i < 32; i++) {\n            require(!_hasPermission(permissions.dexFlags, uint32(1 << i)));\n        }\n        for (uint32 i = uint32(TradeType.EXACT_OUT_BATCH) + 1; i < 32; i++) {\n            require(!_hasPermission(permissions.tradeTypeFlags, uint32(1 << i)));\n        }\n        tokenWhitelist[sender][token] = permissions;\n        emit TokenPermissionsUpdated(sender, token, permissions);\n    }\n\n    /// @notice Called to receive execution data for vaults that will execute trades without\n    /// delegating calls to this contract\n    /// @param dexId enum representing the id of the dex\n    /// @param from address for the contract executing the trade\n    /// @param trade trade object\n    /// @return spender the address to approve for the soldToken, will be address(0) if the\n    /// send token is ETH and therefore does not require approval\n    /// @return target contract to execute the call against\n    /// @return msgValue amount of ETH to transfer to the target, if any\n    /// @return executionCallData encoded call data for the trade\n    function getExecutionData(\n        uint16 dexId,\n        address from,\n        Trade calldata trade\n    )\n        external\n        view\n        override\n        returns (\n            address spender,\n            address target,\n            uint256 msgValue,\n            bytes memory executionCallData\n        )\n    {\n        return _getExecutionData(dexId, from, trade);\n    }\n\n    /// @notice Executes a trade with a dynamic slippage limit based on chainlink oracles.\n    /// @dev Expected to be called via delegatecall on the implementation directly. This means that\n    /// the contract's calling context does not have access to storage (accessible via the proxy\n    /// address).\n    /// @param dexId the dex to execute the trade on\n    /// @param trade trade object\n    /// @param dynamicSlippageLimit the slippage limit in 1e8 precision\n    /// @return amountSold amount of tokens sold\n    /// @return amountBought amount of tokens purchased\n    function executeTradeWithDynamicSlippage(\n        uint16 dexId,\n        Trade memory trade,\n        uint32 dynamicSlippageLimit\n    ) external override returns (uint256 amountSold, uint256 amountBought) {\n        if (!PROXY.canExecuteTrade(address(this), dexId, trade)) revert InsufficientPermissions();\n        if (trade.amount == 0) return (0, 0);\n\n        // This method calls back into the implementation via the proxy so that it has proper\n        // access to storage.\n        trade.limit = PROXY.getLimitAmount(\n            trade.tradeType,\n            trade.sellToken,\n            trade.buyToken,\n            trade.amount,\n            dynamicSlippageLimit\n        );\n\n        (\n            address spender,\n            address target,\n            uint256 msgValue,\n            bytes memory executionData\n        ) = PROXY.getExecutionData(dexId, address(this), trade);\n\n        return\n            TradingUtils._executeInternal(\n                trade,\n                dexId,\n                spender,\n                target,\n                msgValue,\n                executionData\n            );\n    }\n\n    /// @notice Should be called via delegate call to execute a trade on behalf of the caller.\n    /// @param dexId enum representing the id of the dex\n    /// @param trade trade object\n    /// @return amountSold amount of tokens sold\n    /// @return amountBought amount of tokens purchased\n    function executeTrade(uint16 dexId, Trade calldata trade)\n        external\n        override\n        returns (uint256 amountSold, uint256 amountBought)\n    {\n        if (!PROXY.canExecuteTrade(address(this), dexId, trade)) revert InsufficientPermissions();\n        if (trade.amount == 0) return (0, 0);\n\n        (\n            address spender,\n            address target,\n            uint256 msgValue,\n            bytes memory executionData\n        ) = _getExecutionData(dexId, address(this), trade);\n\n        return\n            TradingUtils._executeInternal(\n                trade,\n                dexId,\n                spender,\n                target,\n                msgValue,\n                executionData\n            );\n    }\n\n    function _getExecutionData(\n        uint16 dexId,\n        address from,\n        Trade calldata trade\n    )\n        internal\n        view\n        returns (\n            address spender,\n            address target,\n            uint256 msgValue,\n            bytes memory executionCallData\n        )\n    {\n        if (trade.buyToken == trade.sellToken) revert SellTokenEqualsBuyToken();\n\n        if (DexId(dexId) == DexId.UNISWAP_V2) {\n            return UniV2Adapter.getExecutionData(from, trade);\n        } else if (DexId(dexId) == DexId.UNISWAP_V3) {\n            return UniV3Adapter.getExecutionData(from, trade);\n        } else if (DexId(dexId) == DexId.BALANCER_V2) {\n            return BalancerV2Adapter.getExecutionData(from, trade);\n        } else if (DexId(dexId) == DexId.CURVE) {\n            return CurveAdapter.getExecutionData(from, trade);\n        }\n\n        revert UnknownDEX();\n    }\n\n    /// @notice Returns the Chainlink oracle price between the baseToken and the quoteToken, the\n    /// Chainlink oracles. The quote currency between the oracles must match or the conversion\n    /// in this method does not work. Most Chainlink oracles are baseToken/USD pairs.\n    /// @param baseToken address of the first token in the pair, i.e. USDC in USDC/DAI\n    /// @param quoteToken address of the second token in the pair, i.e. DAI in USDC/DAI\n    /// @return answer exchange rate in rate decimals\n    /// @return decimals number of decimals in the rate, currently hardcoded to 1e18\n    function getOraclePrice(address baseToken, address quoteToken)\n        public\n        view\n        override\n        returns (int256 answer, int256 decimals)\n    {\n        PriceOracle memory baseOracle = priceOracles[baseToken];\n        PriceOracle memory quoteOracle = priceOracles[quoteToken];\n\n        int256 baseDecimals = int256(10**baseOracle.rateDecimals);\n        int256 quoteDecimals = int256(10**quoteOracle.rateDecimals);\n\n        (/* */, int256 basePrice, /* */, uint256 bpUpdatedAt, /* */) = baseOracle.oracle.latestRoundData();\n        require(block.timestamp - bpUpdatedAt <= maxOracleF"
    }
  ]
}