{
  "Title": "M-6: No Validation Check Against Decimal Of Secondary Token",
  "Content": "# Issue M-6: No Validation Check Against Decimal Of Secondary Token \n\nSource: https://github.com/sherlock-audit/2022-09-notional-judging/issues/88 \n\n## Found by \nak1, xiaoming90, 0x52, Jeiwan\n\n## Summary\n\nThere is no validation check against the decimal of the secondary token due to a typo. Thus, this will cause the vault to be broken entirely or the value of the shares to be stuck if a secondary token with more than 18 decimals is added.\n\n## Vulnerability Detail\n\nThere is a typo in Line 65 within the `TwoTokenPoolMixin` contract. The validation at Line 65 should perform a check against the `secondaryDecimals` instead of the `primaryDecimals`. As such, no validation was performed against the secondary token.\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/mixins/TwoTokenPoolMixin.sol#L65\n\n```solidity\nFile: TwoTokenPoolMixin.sol\n23:     constructor(\n24:         NotionalProxy notional_, \n25:         AuraVaultDeploymentParams memory params\n26:     ) PoolMixin(notional_, params) {\n..SNIP..\n55:         // If the underlying is ETH, primaryBorrowToken will be rewritten as WETH\n56:         uint256 primaryDecimals = IERC20(primaryAddress).decimals();\n57:         // Do not allow decimal places greater than 18\n58:         require(primaryDecimals <= 18);\n59:         PRIMARY_DECIMALS = uint8(primaryDecimals);\n60: \n61:         uint256 secondaryDecimals = address(SECONDARY_TOKEN) ==\n62:             Deployments.ETH_ADDRESS\n63:             ? 18\n64:             : SECONDARY_TOKEN.decimals();\n65:         require(primaryDecimals <= 18);\n66:         SECONDARY_DECIMALS = uint8(secondaryDecimals);\n67:     }\n```\n\nIf the decimal of the secondary tokens is more than 18, the `Stable2TokenOracleMath._getSpotPrice` will stop working as the code will revert in Line 24 below because the decimal of secondary tokens is more than 18.\n\nWhen the `Stable2TokenOracleMath._getSpotPrice` function stop working, the vaults will be broken entirely because the settle vault and reinvest rewards functions will stop working too. This is because the settle vault and reinvest rewards functions will call the `Stable2TokenOracleMath._getSpotPrice` function internally, resulting in a revert.\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/math/Stable2TokenOracleMath.sol#L16\n\n```solidity\nFile: Stable2TokenOracleMath.sol\n16:     function _getSpotPrice(\n17:         StableOracleContext memory oracleContext, \n18:         TwoTokenPoolContext memory poolContext, \n19:         uint256 tokenIndex\n20:     ) internal view returns (uint256 spotPrice) {\n21:         // Prevents overflows, we don't expect tokens to be greater than 18 decimals, don't use\n22:         // equal sign for minor gas optimization\n23:         require(poolContext.primaryDecimals < 19); /// @dev primaryDecimals overflow\n24:         require(poolContext.secondaryDecimals < 19); /// @dev secondaryDecimals overflow\n25:         require(tokenIndex < 2); /// @dev invalid token index\n```\n\n## Impact\n\nThe `Stable2TokenOracleMath._getSpotPrice` will stop working, which will in turn cause the settle vault and reinvest rewards functions to stop working too. Since a vault cannot be settled, the vault is considered broken. If the reinvest rewards function cannot work, the value of users' shares will be stuck as the vault relies on reinvesting rewards to buy more BPT tokens from the market.\n\nIn addition, there might be some issues when calculating the price of the tokens since the vault assumes that both primary and secondary tokens have a decimal equal to or less than 18 OR some overflow might occur when processing the token value.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/mixins/TwoTokenPoolMixin.sol#L65\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/math/Stable2TokenOracleMath.sol#L16\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUpdate the code to perform the validation against the `secondaryDecimals` state variable.\n\n```diff\nconstructor(\n    NotionalProxy notional_, \n    AuraVaultDeploymentParams memory params\n) PoolMixin(notional_, params) {\n    ..SNIP..\n    // If the underlying is ETH, primaryBorrowToken will be rewritten as WETH\n    uint256 primaryDecimals = IERC20(primaryAddress).decimals();\n    // Do not allow decimal places greater than 18\n    require(primaryDecimals <= 18);\n    PRIMARY_DECIMALS = uint8(primaryDecimals);\n\n    uint256 secondaryDecimals = address(SECONDARY_TOKEN) ==\n        Deployments.ETH_ADDRESS\n        ? 18\n        : SECONDARY_TOKEN.decimals();\n-   require(primaryDecimals <= 18);\n+   require(secondaryDecimals <= 18);\n    SECONDARY_DECIMALS = uint8(secondaryDecimals);\n}\n```\n\n## Discussion\n\n**jeffywu**\n\n@weitianjie2000\n\nValid issue, although I'm struggling to think of a token with more than 18 decimals.\n\n**jeffywu**\n\nConfirmed, although I would disagree with the severity here to Low. While in theory this would be an issue there are no TwoTokenPools we would really consider with 18+ decimals and these vaults get white listed on a case by case basis.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/2",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/mixins/TwoTokenPoolMixin.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {IERC20} from \"../../../../interfaces/IERC20.sol\";\nimport {Deployments} from \"../../../global/Deployments.sol\";\nimport {TwoTokenPoolContext, AuraVaultDeploymentParams} from \"../BalancerVaultTypes.sol\";\nimport {BalancerConstants} from \"../internal/BalancerConstants.sol\";\nimport {BalancerUtils} from \"../internal/pool/BalancerUtils.sol\";\nimport {PoolMixin} from \"./PoolMixin.sol\";\nimport {NotionalProxy} from \"../../../../interfaces/notional/NotionalProxy.sol\";\n\nabstract contract TwoTokenPoolMixin is PoolMixin {\n    error InvalidPrimaryToken(address token);\n    error InvalidSecondaryToken(address token);\n\n    IERC20 internal immutable PRIMARY_TOKEN;\n    IERC20 internal immutable SECONDARY_TOKEN;\n    uint8 internal immutable PRIMARY_INDEX;\n    uint8 internal immutable SECONDARY_INDEX;\n    uint8 internal immutable PRIMARY_DECIMALS;\n    uint8 internal immutable SECONDARY_DECIMALS;\n\n    constructor(\n        NotionalProxy notional_, \n        AuraVaultDeploymentParams memory params\n    ) PoolMixin(notional_, params) {\n        PRIMARY_TOKEN = IERC20(_getNotionalUnderlyingToken(params.baseParams.primaryBorrowCurrencyId));\n        address primaryAddress = BalancerUtils.getTokenAddress(address(PRIMARY_TOKEN));\n\n        // prettier-ignore\n        (\n            address[] memory tokens,\n            /* uint256[] memory balances */,\n            /* uint256 lastChangeBlock */\n        ) = Deployments.BALANCER_VAULT.getPoolTokens(params.baseParams.balancerPoolId);\n\n        // Balancer tokens are sorted by address, so we need to figure out\n        // the correct index for the primary token\n        PRIMARY_INDEX = tokens[0] == primaryAddress ? 0 : 1;\n        unchecked {\n            SECONDARY_INDEX = 1 - PRIMARY_INDEX;\n        }\n\n        SECONDARY_TOKEN = IERC20(tokens[SECONDARY_INDEX]);\n\n        // Make sure the deployment parameters are correct\n        if (tokens[PRIMARY_INDEX] != primaryAddress) {\n            revert InvalidPrimaryToken(tokens[PRIMARY_INDEX]);\n        }\n\n        if (tokens[SECONDARY_INDEX] !=\n            BalancerUtils.getTokenAddress(address(SECONDARY_TOKEN))\n        ) revert InvalidSecondaryToken(tokens[SECONDARY_INDEX]);\n\n        // If the underlying is ETH, primaryBorrowToken will be rewritten as WETH\n        uint256 primaryDecimals = IERC20(primaryAddress).decimals();\n        // Do not allow decimal places greater than 18\n        require(primaryDecimals <= 18);\n        PRIMARY_DECIMALS = uint8(primaryDecimals);\n\n        uint256 secondaryDecimals = address(SECONDARY_TOKEN) ==\n            Deployments.ETH_ADDRESS\n            ? 18\n            : SECONDARY_TOKEN.decimals();\n        require(primaryDecimals <= 18);\n        SECONDARY_DECIMALS = uint8(secondaryDecimals);\n    }\n\n    function _twoTokenPoolContext() internal view returns (TwoTokenPoolContext memory) {\n        (\n            /* address[] memory tokens */,\n            uint256[] memory balances,\n            /* uint256 lastChangeBlock */\n        ) = Deployments.BALANCER_VAULT.getPoolTokens(BALANCER_POOL_ID);\n\n        return TwoTokenPoolContext({\n            primaryToken: address(PRIMARY_TOKEN),\n            secondaryToken: address(SECONDARY_TOKEN),\n            primaryIndex: PRIMARY_INDEX,\n            secondaryIndex: SECONDARY_INDEX,\n            primaryDecimals: PRIMARY_DECIMALS,\n            secondaryDecimals: SECONDARY_DECIMALS,\n            primaryBalance: balances[PRIMARY_INDEX],\n            secondaryBalance: balances[SECONDARY_INDEX],\n            basePool: _poolContext()\n        });\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/internal/math/Stable2TokenOracleMath.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {StableOracleContext, TwoTokenPoolContext, StrategyContext} from \"../../BalancerVaultTypes.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {IPriceOracle} from \"../../../../../interfaces/balancer/IPriceOracle.sol\";\nimport {StableMath} from \"./StableMath.sol\";\nimport {ITradingModule} from \"../../../../../interfaces/trading/ITradingModule.sol\";\n\nlibrary Stable2TokenOracleMath {\n    using TypeConvert for int256;\n    using Stable2TokenOracleMath for StableOracleContext;\n\n    function _getSpotPrice(\n        StableOracleContext memory oracleContext, \n        TwoTokenPoolContext memory poolContext, \n        uint256 tokenIndex\n    ) internal view returns (uint256 spotPrice) {\n        // Prevents overflows, we don't expect tokens to be greater than 18 decimals, don't use\n        // equal sign for minor gas optimization\n        require(poolContext.primaryDecimals < 19); /// @dev primaryDecimals overflow\n        require(poolContext.secondaryDecimals < 19); /// @dev secondaryDecimals overflow\n        require(tokenIndex < 2); /// @dev invalid token index\n\n        (uint256 balanceX, uint256 balanceY) = tokenIndex == 0 ?\n            (poolContext.primaryBalance, poolContext.secondaryBalance) :\n            (poolContext.secondaryBalance, poolContext.primaryBalance);\n\n        uint256 invariant = StableMath._calculateInvariant(\n            oracleContext.ampParam, StableMath._balances(balanceX, balanceY), true // round up\n        );\n\n        spotPrice = StableMath._calcSpotPrice({\n            amplificationParameter: oracleContext.ampParam,\n            invariant: invariant,\n            balanceX: balanceX,\n            balanceY: balanceY\n        });\n    }\n\n    function _checkPriceLimit(\n        StrategyContext calldata strategyContext,\n        TwoTokenPoolContext memory poolContext,\n        uint256 poolPrice\n    ) private view returns (bool) {\n        (\n            int256 answer, int256 decimals\n        ) = strategyContext.tradingModule.getOraclePrice(poolContext.secondaryToken, poolContext.primaryToken);\n\n        require(decimals == int256(BalancerConstants.BALANCER_PRECISION));\n\n        uint256 oraclePairPrice = answer.toUint();\n        uint256 lowerLimit = (oraclePairPrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS - strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n        uint256 upperLimit = (oraclePairPrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS + strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n\n        if (poolPrice < lowerLimit || upperLimit < poolPrice) {\n            revert Errors.InvalidPrice(oraclePairPrice, poolPrice);\n        }\n    }\n\n    /// @notice calculates the expected min exit amounts for a given BPT amount\n    function _getMinExitAmounts(\n        StableOracleContext calldata oracleContext,\n        TwoTokenPoolContext calldata poolContext,\n        StrategyContext calldata strategyContext,\n        uint256 bptAmount\n    ) internal view returns (uint256 minPrimary, uint256 minSecondary) {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        // Validate the spot price to make sure the pool is not being manipulated\n        uint256 spotPrice = _getSpotPrice(oracleContext, poolContext, 0);\n        _checkPriceLimit(strategyContext, poolContext, spotPrice);\n\n        // min amounts are calculated based on the share of the Balancer pool with a small discount applied\n        uint256 totalBPTSupply = poolContext.basePool.pool.totalSupply();\n        minPrimary = (poolContext.primaryBalance * bptAmount * \n            strategyContext.vaultSettings.balancerPoolSlippageLimitPercent) / \n            (totalBPTSupply * uint256(BalancerConstants.VAULT_PERCENT_BASIS));\n        minSecondary = (poolContext.secondaryBalance * bptAmount * \n            strategyContext.vaultSettings.balancerPoolSlippageLimitPercent) / \n            (totalBPTSupply * uint256(BalancerConstants.VAULT_PERCENT_BASIS));\n    }\n\n    function _validateSpotPriceAndPairPrice(\n        StableOracleContext calldata oracleContext,\n        TwoTokenPoolContext calldata poolContext,\n        StrategyContext calldata strategyContext,\n        uint256 primaryAmount, \n        uint256 secondaryAmount\n    ) internal view {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        uint256 spotPrice = _getSpotPrice(oracleContext, poolContext, 0);\n        _checkPriceLimit(strategyContext, poolContext, spotPrice);\n\n        // We always validate in terms of the primary here so it is the first value in the _balances array\n        uint256 invariant = StableMath._calculateInvariant(\n            oracleContext.ampParam, StableMath._balances(primaryAmount, secondaryAmount), true // round up\n        );\n\n        /// @notice Balancer math functions expect all amounts to be in BALANCER_PRECISION\n        uint256 primaryPrecision = 10 ** poolContext.primaryDecimals;\n        uint256 secondaryPrecision = 10 ** poolContext.secondaryDecimals;\n        primaryAmount = primaryAmount * BalancerConstants.BALANCER_PRECISION / primaryPrecision;\n        secondaryAmount = secondaryAmount * BalancerConstants.BALANCER_PRECISION / secondaryPrecision;\n\n        uint256 calculatedPairPrice = StableMath._calcSpotPrice({\n            amplificationParameter: oracleContext.ampParam,\n            invariant: invariant,\n            balanceX: primaryAmount,\n            balanceY: secondaryAmount\n        });\n\n        _checkPriceLimit(strategyContext, poolContext, calculatedPairPrice);\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/mixins/TwoTokenPoolMixin.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {IERC20} from \"../../../../interfaces/IERC20.sol\";\nimport {Deployments} from \"../../../global/Deployments.sol\";\nimport {TwoTokenPoolContext, AuraVaultDeploymentParams} from \"../BalancerVaultTypes.sol\";\nimport {BalancerConstants} from \"../internal/BalancerConstants.sol\";\nimport {BalancerUtils} from \"../internal/pool/BalancerUtils.sol\";\nimport {PoolMixin} from \"./PoolMixin.sol\";\nimport {NotionalProxy} from \"../../../../interfaces/notional/NotionalProxy.sol\";\n\nabstract contract TwoTokenPoolMixin is PoolMixin {\n    error InvalidPrimaryToken(address token);\n    error InvalidSecondaryToken(address token);\n\n    IERC20 internal immutable PRIMARY_TOKEN;\n    IERC20 internal immutable SECONDARY_TOKEN;\n    uint8 internal immutable PRIMARY_INDEX;\n    uint8 internal immutable SECONDARY_INDEX;\n    uint8 internal immutable PRIMARY_DECIMALS;\n    uint8 internal immutable SECONDARY_DECIMALS;\n\n    constructor(\n        NotionalProxy notional_, \n        AuraVaultDeploymentParams memory params\n    ) PoolMixin(notional_, params) {\n        PRIMARY_TOKEN = IERC20(_getNotionalUnderlyingToken(params.baseParams.primaryBorrowCurrencyId));\n        address primaryAddress = BalancerUtils.getTokenAddress(address(PRIMARY_TOKEN));\n\n        // prettier-ignore\n        (\n            address[] memory tokens,\n            /* uint256[] memory balances */,\n            /* uint256 lastChangeBlock */\n        ) = Deployments.BALANCER_VAULT.getPoolTokens(params.baseParams.balancerPoolId);\n\n        // Balancer tokens are sorted by address, so we need to figure out\n        // the correct index for the primary token\n        PRIMARY_INDEX = tokens[0] == primaryAddress ? 0 : 1;\n        unchecked {\n            SECONDARY_INDEX = 1 - PRIMARY_INDEX;\n        }\n\n        SECONDARY_TOKEN = IERC20(tokens[SECONDARY_INDEX]);\n\n        // Make sure the deployment parameters are correct\n        if (tokens[PRIMARY_INDEX] != primaryAddress) {\n            revert InvalidPrimaryToken(tokens[PRIMARY_INDEX]);\n        }\n\n        if (tokens[SECONDARY_INDEX] !=\n            BalancerUtils.getTokenAddress(address(SECONDARY_TOKEN))\n        ) revert InvalidSecondaryToken(tokens[SECONDARY_INDEX]);\n\n        // If the underlying is ETH, primaryBorrowToken will be rewritten as WETH\n        uint256 primaryDecimals = IERC20(primaryAddress).decimals();\n        // Do not allow decimal places greater than 18\n        require(primaryDecimals <= 18);\n        PRIMARY_DECIMALS = uint8(primaryDecimals);\n\n        uint256 secondaryDecimals = address(SECONDARY_TOKEN) ==\n            Deployments.ETH_ADDRESS\n            ? 18\n            : SECONDARY_TOKEN.decimals();\n        require(primaryDecimals <= 18);\n        SECONDARY_DECIMALS = uint8(secondaryDecimals);\n    }\n\n    function _twoTokenPoolContext() internal view returns (TwoTokenPoolContext memory) {\n        (\n            /* address[] memory tokens */,\n            uint256[] memory balances,\n            /* uint256 lastChangeBlock */\n        ) = Deployments.BALANCER_VAULT.getPoolTokens(BALANCER_POOL_ID);\n\n        return TwoTokenPoolContext({\n            primaryToken: address(PRIMARY_TOKEN),\n            secondaryToken: address(SECONDARY_TOKEN),\n            primaryIndex: PRIMARY_INDEX,\n            secondaryIndex: SECONDARY_INDEX,\n            primaryDecimals: PRIMARY_DECIMALS,\n            secondaryDecimals: SECONDARY_DECIMALS,\n            primaryBalance: balances[PRIMARY_INDEX],\n            secondaryBalance: balances[SECONDARY_INDEX],\n            basePool: _poolContext()\n        });\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/internal/math/Stable2TokenOracleMath.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {StableOracleContext, TwoTokenPoolContext, StrategyContext} from \"../../BalancerVaultTypes.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {IPriceOracle} from \"../../../../../interfaces/balancer/IPriceOracle.sol\";\nimport {StableMath} from \"./StableMath.sol\";\nimport {ITradingModule} from \"../../../../../interfaces/trading/ITradingModule.sol\";\n\nlibrary Stable2TokenOracleMath {\n    using TypeConvert for int256;\n    using Stable2TokenOracleMath for StableOracleContext;\n\n    function _getSpotPrice(\n        StableOracleContext memory oracleContext, \n        TwoTokenPoolContext memory poolContext, \n        uint256 tokenIndex\n    ) internal view returns (uint256 spotPrice) {\n        // Prevents overflows, we don't expect tokens to be greater than 18 decimals, don't use\n        // equal sign for minor gas optimization\n        require(poolContext.primaryDecimals < 19); /// @dev primaryDecimals overflow\n        require(poolContext.secondaryDecimals < 19); /// @dev secondaryDecimals overflow\n        require(tokenIndex < 2); /// @dev invalid token index\n\n        (uint256 balanceX, uint256 balanceY) = tokenIndex == 0 ?\n            (poolContext.primaryBalance, poolContext.secondaryBalance) :\n            (poolContext.secondaryBalance, poolContext.primaryBalance);\n\n        uint256 invariant = StableMath._calculateInvariant(\n            oracleContext.ampParam, StableMath._balances(balanceX, balanceY), true // round up\n        );\n\n        spotPrice = StableMath._calcSpotPrice({\n            amplificationParameter: oracleContext.ampParam,\n            invariant: invariant,\n            balanceX: balanceX,\n            balanceY: balanceY\n        });\n    }\n\n    function _checkPriceLimit(\n        StrategyContext calldata strategyContext,\n        TwoTokenPoolContext memory poolContext,\n        uint256 poolPrice\n    ) private view returns (bool) {\n        (\n            int256 answer, int256 decimals\n        ) = strategyContext.tradingModule.getOraclePrice(poolContext.secondaryToken, poolContext.primaryToken);\n\n        require(decimals == int256(BalancerConstants.BALANCER_PRECISION));\n\n        uint256 oraclePairPrice = answer.toUint();\n        uint256 lowerLimit = (oraclePairPrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS - strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n        uint256 upperLimit = (oraclePairPrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS + strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n\n        if (poolPrice < lowerLimit || upperLimit < poolPrice) {\n            revert Errors.InvalidPrice(oraclePairPrice, poolPrice);\n        }\n    }\n\n    /// @notice calculates the expected min exit amounts for a given BPT amount\n    function _getMinExitAmounts(\n        StableOracleContext calldata oracleContext,\n        TwoTokenPoolContext calldata poolContext,\n        StrategyContext calldata strategyContext,\n        uint256 bptAmount\n    ) internal view returns (uint256 minPrimary, uint256 minSecondary) {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        // Validate the spot price to make sure the pool is not being manipulated\n        uint256 spotPrice = _getSpotPrice(oracleContext, poolContext, 0);\n        _checkPriceLimit(strategyContext, poolContext, spotPrice);\n\n        // min amounts are calculated based on the share of the Balancer pool with a small discount applied\n        uint256 totalBPTSupply = poolContext.basePool.pool.totalSupply();\n        minPrimary = (poolContext.primaryBalance * bptAmount * \n            strategyContext.vaultSettings.balancerPoolSlippageLimitPercent) / \n            (totalBPTSupply * uint256(BalancerConstants.VAULT_PERCENT_BASIS));\n        minSecondary = (poolContext.secondaryBalance * bptAmount * \n            strategyContext.vaultSettings.balancerPoolSlippageLimitPercent) / \n            (totalBPTSupply * uint256(BalancerConstants.VAULT_PERCENT_BASIS));\n    }\n\n    function _validateSpotPriceAndPairPrice(\n        StableOracleContext calldata oracleContext,\n        TwoTokenPoolContext calldata poolContext,\n        StrategyContext calldata strategyContext,\n        uint256 primaryAmount, \n        uint256 secondaryAmount\n    ) internal view {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        uint256 spotPrice = _getSpotPrice(oracleContext, poolContext, 0);\n        _checkPriceLimit(strategyContext, poolContext, spotPrice);\n\n        // We always validate in terms of the primary here so it is the first value in the _balances array\n        uint256 invariant = StableMath._calculateInvariant(\n            oracleContext.ampParam, StableMath._balances(primaryAmount, secondaryAmount), true // round up\n        );\n\n        /// @notice Balancer math functions expect all amounts to be in BALANCER_PRECISION\n        uint256 primaryPrecision = 10 ** poolContext.primaryDecimals;\n        uint256 secondaryPrecision = 10 ** poolContext.secondaryDecimals;\n        primaryAmount = primaryAmount * BalancerConstants.BALANCER_PRECISION / primaryPrecision;\n        secondaryAmount = secondaryAmount * BalancerConstants.BALANCER_PRECISION / secondaryPrecision;\n\n        uint256 calculatedPairPrice = StableMath._calcSpotPrice({\n            amplificationParameter: oracleContext.ampParam,\n            invariant: invariant,\n            balanceX: primaryAmount,\n            balanceY: secondaryAmount\n        });\n\n        _checkPriceLimit(strategyContext, poolContext, calculatedPairPrice);\n    }\n}"
    }
  ]
}