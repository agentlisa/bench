{
  "Title": "[M07] Unsafe division in rdivide and wdivide functions",
  "Content": "The function [`rdivide` on line 227](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L227) and the function [`wdivide` on line 230](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L230) of the `GlobalSettlement` contract, accept the divisor `y` as an input parameter. However, these functions do not check if the value of `y` is `0`. If that is the case, the call will revert due to the division by zero error.\n\n\nOther occurrences of unsafe division functions are:\n\n\n* [`rdivide`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L150), [`rdivide`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L482) and [`wdivide`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L485) in the `CollateralAuctionHouse` contract.\n* [`rdivide`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/OracleRelayer.sol#L132) in the `OracleRelayer` contract.\n\n\nTo prevent such unsafe calculations, consider adding a require statement in the functions to ensure `y &gt; 0`, or consider using the `div` functions provided in OpenZeppelinâ€™s [`SafeMath`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/ae69ecaf014beac078b4c21da8a83cf005713469/contracts/math/SafeMath.sol#L103) libraries.\n\n\n***Update:** Fixed in [pull request #77.](https://github.com/reflexer-labs/geb/pull/77/files)*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/GlobalSettlement.sol",
      "content": "/// GlobalSettlement.sol\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n// Copyright (C) 2018 Lev Livnev <lev@liv.nev.org.uk>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.7;\n\nabstract contract SAFEEngineLike {\n    function coinBalance(address) virtual public view returns (uint256);\n    function collateralTypes(bytes32) virtual public view returns (\n        uint256 debtAmount,        // [wad]\n        uint256 accumulatedRate,   // [ray]\n        uint256 safetyPrice,       // [ray]\n        uint256 debtCeiling,       // [rad]\n        uint256 debtFloor,         // [rad]\n        uint256 liquidationPrice   // [ray]\n    );\n    function safes(bytes32,address) virtual public view returns (\n        uint256 lockedCollateral, // [wad]\n        uint256 generatedDebt     // [wad]\n    );\n    function globalDebt() virtual public returns (uint256);\n    function transferInternalCoins(address src, address dst, uint256 rad) virtual external;\n    function approveSAFEModification(address) virtual external;\n    function transferCollateral(bytes32 collateralType, address src, address dst, uint256 wad) virtual external;\n    function confiscateSAFECollateralAndDebt(bytes32 collateralType, address safe, address collateralSource, address debtDestination, int256 deltaCollateral, int256 deltaDebt) virtual external;\n    function createUnbackedDebt(address debtDestination, address coinDestination, uint256 rad) virtual external;\n    function disableContract() virtual external;\n}\nabstract contract LiquidationEngineLike {\n    function collateralTypes(bytes32) virtual public view returns (\n        address collateralAuctionHouse,\n        uint256 liquidationPenalty,     // [wad]\n        uint256 liquidationQuantity     // [rad]\n    );\n    function disableContract() virtual external;\n}\nabstract contract StabilityFeeTreasuryLike {\n    function disableContract() virtual external;\n}\nabstract contract AccountingEngineLike {\n    function disableContract() virtual external;\n}\nabstract contract CoinSavingsAccountLike {\n    function disableContract() virtual external;\n}\nabstract contract CollateralAuctionHouseLike {\n    function bidAmount(uint id) virtual public view returns (uint256);\n    function remainingAmountToSell(uint id) virtual public view returns (uint256);\n    function forgoneCollateralReceiver(uint id) virtual public view returns (address);\n    function amountToRaise(uint id) virtual public view returns (uint256);\n    function terminateAuctionPrematurely(uint auctionId) virtual external;\n}\nabstract contract OracleLike {\n    function read() virtual public view returns (uint256);\n}\nabstract contract OracleRelayerLike {\n    function redemptionPrice() virtual public returns (uint256);\n    function collateralTypes(bytes32) virtual public view returns (\n        OracleLike orcl,\n        uint256 safetyCRatio,\n        uint256 liquidationCRatio\n    );\n    function disableContract() virtual external;\n}\n\n/*\n    This is the Global Settlement module. It is an\n    involved, stateful process that takes place over nine steps.\n    First we freeze the system and lock the prices for each collateral type.\n    1. `shutdownSystem()`:\n        - freezes user entrypoints\n        - cancels collateral/surplus auctions\n        - starts cooldown period\n    2. `freezeCollateralType(collateralType)`:\n       - set the final price for each collateralType, reading off the price feed\n    We must process some system state before it is possible to calculate\n    the final coin / collateral price. In particular, we need to determine:\n      a. `collateralShortfall` (considers under-collateralised SAFEs)\n      b. `outstandingCoinSupply` (after including system surplus / deficit)\n    We determine (a) by processing all under-collateralised SAFEs with\n    `processSAFE`\n    3. `processSAFE(collateralType, safe)`:\n       - cancels SAFE debt\n       - any excess collateral remains\n       - backing collateral taken\n    We determine (b) by processing ongoing coin generating processes,\n    i.e. auctions. We need to ensure that auctions will not generate any\n    further coin income. In the two-way auction model this occurs when\n    all auctions are in the reverse (`decreaseSoldAmount`) phase. There are two ways\n    of ensuring this:\n    4.  i) `shutdownCooldown`: set the cooldown period to be at least as long as the\n           longest auction duration, which needs to be determined by the\n           shutdown administrator.\n           This takes a fairly predictable time to occur but with altered\n           auction dynamics due to the now varying price of the system coin.\n       ii) `fastTrackAuction`: cancel all ongoing auctions and seize the collateral.\n           This allows for faster processing at the expense of more\n           processing calls. This option allows coin holders to retrieve\n           their collateral faster.\n           `fastTrackAuction(collateralType, auctionId)`:\n            - cancel individual collateral auctions in the `increaseBidSize` (forward) phase\n            - retrieves collateral and returns coins to bidder\n            - `decreaseSoldAmount` (reverse) phase auctions can continue normally\n    Option (i), `shutdownCooldown`, is sufficient for processing the system\n    settlement but option (ii), `fastTrackAuction`, will speed it up. Both options\n    are available in this implementation, with `fastTrackAuction` being enabled on a\n    per-auction basis.\n    When a SAFE has been processed and has no debt remaining, the\n    remaining collateral can be removed.\n    5. `freeCollateral(collateralType)`:\n        - remove collateral from the caller's SAFE\n        - owner can call as needed\n    After the processing period has elapsed, we enable calculation of\n    the final price for each collateral type.\n    6. `setOutstandingCoinSupply()`:\n       - only callable after processing time period elapsed\n       - assumption that all under-collateralised SAFEs are processed\n       - fixes the total outstanding supply of coin\n       - may also require extra SAFE processing to cover system surplus\n    7. `calculateCashPrice(collateralType)`:\n        - calculate `collateralCashPrice`\n        - adjusts `collateralCashPrice` in the case of deficit / surplus\n    At this point we have computed the final price for each collateral\n    type and coin holders can now turn their coin into collateral. Each\n    unit coin can claim a fixed basket of collateral.\n    Coin holders must first `prepareCoinsForRedeeming` into a `coinBag`. Once prepared,\n    coins cannot be transferred out of the bag. More coin can be added to a bag later.\n    8. `prepareCoinsForRedeeming(coinAmount)`:\n        - put some coins into a bag in order to 'redeemCollateral'. The bigger the bag, the more collateral the user can claim.\n    9. `redeemCollateral(collateralType, collateralAmount)`:\n        - exchange some coin from your bag for tokens from a specific collateral type\n        - the amount of collateral available to redeem is limited by how big your bag is\n*/\n\ncontract GlobalSettlement {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    function addAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"GlobalSettlement/account-not-authorized\");\n        _;\n    }\n\n    // --- Data ---\n    SAFEEngineLike            public safeEngine;\n    LiquidationEngineLike    public liquidationEngine;\n    AccountingEngineLike     public accountingEngine;\n    OracleRelayerLike        public oracleRelayer;\n    CoinSavingsAccountLike   public coinSavingsAccount;\n    StabilityFeeTreasuryLike public stabilityFeeTreasury;\n\n    uint256  public contractEnabled;\n    uint256  public shutdownTime;\n    uint256  public shutdownCooldown;\n    uint256  public outstandingCoinSupply;                                      // [rad]\n\n    mapping (bytes32 => uint256) public finalCoinPerCollateralPrice;            // [ray]\n    mapping (bytes32 => uint256) public collateralShortfall;                    // [wad]\n    mapping (bytes32 => uint256) public collateralTotalDebt;                    // [wad]\n    mapping (bytes32 => uint256) public collateralCashPrice;                    // [ray]\n\n    mapping (address => uint256)                      public coinBag;           // [wad]\n    mapping (bytes32 => mapping (address => uint256)) public coinsUsedToRedeem; // [wad]\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event ModifyParameters(bytes32 parameter, uint data);\n    event ModifyParameters(bytes32 parameter, address data);\n    event ShutdownSystem();\n    event FreezeCollateralType(bytes32 collateralType, uint finalCoinPerCollateralPrice);\n    event FastTrackAuction(bytes32 collateralType, uint256 auctionId, uint256 collateralTotalDebt);\n    event ProcessSAFE(bytes32 collateralType, address safe, uint256 collateralShortfall);\n    event FreeCollateral(bytes32 collateralType, address sender, int collateralAmount);\n    event SetOutstandingCoinSupply(uint256 outstandingCoinSupply);\n    event CalculateCashPrice(bytes32 collateralType, uint collateralCashPrice);\n    event PrepareCoinsForRedeeming(address sender, uint coinBag);\n    event RedeemCollateral(bytes32 collateralType, address sender, uint coinsAmount, uint collateralAmount);\n\n    // --- Init ---\n    constructor() public {\n        authorizedAccounts[msg.sender] = 1;\n        contractEnabled = 1;\n        emit AddAuthorization(msg.sender);\n    }\n\n    // --- Math ---\n    function addition(uint x, uint y) internal pure returns (uint z) {\n        z = x + y;\n        require(z >= x);\n    }\n    function subtract(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n    function multiply(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n    function minimum(uint x, uint y) internal pure returns (uint z) {\n        return x <= y ? x : y;\n    }\n    uint constant WAD = 10 ** 18;\n    uint constant RAY = 10 ** 27;\n    function rmultiply(uint x, uint y) internal pure returns (uint z) {\n        z = multiply(x, y) / RAY;\n    }\n    function rdivide(uint x, uint y) internal pure returns (uint z) {\n        z = multiply(x, RAY) / y;\n    }\n    function wdivide(uint x, uint y) internal pure returns (uint z) {\n        z = multiply(x, WAD) / y;\n    }\n\n    // --- Administration ---\n    function modifyParameters(bytes32 parameter, address data) external isAuthorized {\n        require(contractEnabled == 1, \"GlobalSettlement/contract-not-enabled\");\n        if (parameter == \"safeEngine\") safeEngine = SAFEEngineLike(data);\n        else if (parameter == \"liquidationEngine\") liquidationEngine = LiquidationEngineLike(data);\n        else if (parameter == \"accountingEngine\") accountingEngine = AccountingEngineLike(data);\n        else if (parameter == \"oracleRelayer\") oracleRelayer = OracleRelayerLike(data);\n        else if (parameter == \"coinSavingsAccount\") coinSavingsAccount = CoinSavingsAccountLike(data);\n        else if (parameter == \"stabilityFeeTreasury\") stabilityFeeTreasury = StabilityFeeTreasuryLike(data);\n        else revert(\"GlobalSettlement/modify-unrecognized-parameter\");\n        emit ModifyParameters(parameter, data);\n    }\n    function modifyParameters(bytes32 parameter, uint256 data) external isAuthorized {\n        require(contractEnabled == 1, \"GlobalSettlement/contract-not-enabled\");\n        if (parameter == \"shutdownCooldown\") shutdownCooldown = data;\n        else revert(\"GlobalSettlement/modify-unrecognized-parameter\");\n        emit ModifyParameters(parameter, data);\n    }\n\n    // --- Settlement ---\n    function shutdownSystem() external isAuthorized {\n        require(contractEnabled == 1, \"GlobalSettlement/contract-not-enabled\");\n        contractEnabled = 0;\n        shutdownTime = now;\n        safeEngine.disableContract();\n        liquidationEngine.disableContract();\n        // treasury must be disabled before AccountingEngine so that all surplus is gathered in one place\n        if (address(stabilityFeeTreasury) != address(0)) {\n          stabilityFeeTreasury.disableContract();\n        }\n        accountingEngine.disableContract();\n        oracleRelayer.disableContract();\n        if (address(coinSavingsAccount) != address(0)) {\n          coinSavingsAccount.disableContract();\n        }\n        emit ShutdownSystem();\n    }\n\n    function freezeCollateralType(bytes32 collateralType) external {\n        require(contractEnabled == 0, \"GlobalSettlement/contract-still-enabled\");\n        require(finalCoinPerCollateralPrice[collateralType] == 0, \"GlobalSettlement/final-collateral-price-already-defined\");\n        (collateralTotalDebt[collateralType],,,,,) = safeEngine.collateralTypes(collateralType);\n        (OracleLike orcl,,) = oracleRelayer.collateralTypes(collateralType);\n        // redemptionPrice is a ray, orcl returns a wad\n        finalCoinPerCollateralPrice[collateralType] = wdivide(oracleRelayer.redemptionPrice(), uint(orcl.read()));\n        emit FreezeCollateralType(collateralType, finalCoinPerCollateralPrice[collateralType]);\n    }\n    function fastTrackAuction(bytes32 collateralType, uint256 auctionId) external {\n        require(finalCoinPerCollateralPrice[collateralType] != 0, \"GlobalSettlement/final-collateral-price-not-defined\");\n\n        (address auctionHouse_,,)    = liquidationEngine.collateralTypes(collateralType);\n        CollateralAuctionHouseLike collateralAuctionHouse = CollateralAuctionHouseLike(auctionHouse_);\n        (, uint accumulatedRate,,,,) = safeEngine.collateralTypes(collateralType);\n\n        uint bidAmount                    = collateralAuctionHouse.bidAmount(auctionId);\n        uint collateralToSell             = collateralAuctionHouse.remainingAmountToSell(auctionId);\n        address forgoneCollateralReceiver = collateralAuctionHouse.forgoneCollateralReceiver(auctionId);\n        uint amountToRaise                = collateralAuctionHouse.amountToRaise(auctionId);\n\n        safeEngine.createUnbackedDebt(address(accountingEngine), address(accountingEngine), amountToRaise);\n        safeEngine.createUnbackedDebt(address(accountingEngine), address(this), bidAmount);\n        safeEngine.approveSAFEModification(address(collateralAuctionHouse));\n        collateralAuctionHouse.terminateAuctionPrematurely(auctionId);\n\n        uint debt_ = amountToRaise / accumulatedRate;\n        collateralTotalDebt[collateralType] = addition(collateralTotalDebt[collateralType], debt_);\n        require(int(collateralToSell) >= 0 && int(debt_) >= 0, \"GlobalSettlement/overflow\");\n        safeEngine.confiscateSAFECollateralAndDebt(collateralType, forgoneCollateralReceiver, address(this), address(accountingEngine), int(collateralToSell), int(debt_));\n        emit FastTrackAuction(collateralType, auctionId, collateralTotalDebt[collateralType]);\n    }\n    function processSAFE(bytes32 collateralType, address safe) external {\n        require(finalCoinPerCollateralPrice[collateralType] != 0, \"GlobalSettlement/final-collateral-price-not-defined\");\n        (, uint accumulatedRate,,,,) = safeEngine.collateralTypes(collateralType);\n        (uint safeCollateral, uint safeDebt) = safeEngine.safes(collateralType, safe);\n\n        uint amountOwed = rmultiply(rmultiply(safeDebt, accumulatedRate), finalCoinPerCollateralPrice[collateralType]);\n        uint minCollateral = minimum(safeCollateral, amountOwed);\n        collateralShortfall[collateralType] = addition(\n            collateralShortfall[collateralType],\n            subtract(amountOwed, minCollateral)\n        );\n\n        require(minCollateral <= 2**255 && safeDebt <= 2**255, \"GlobalSettlement/overflow\");\n        safeEngine.confiscateSAFECollateralAndDebt(\n            collateralType,\n            safe,\n            address(this),\n            address(accountingEngine),\n            -int(minCollateral),\n            -int(safeDebt)\n        );\n\n        emit ProcessSAFE(collateralType, safe, collateralShortfall[collateralType]);\n    }\n    function freeCollateral(bytes32 collateralType) external {\n        require(contractEnabled == 0, \"GlobalSettlement/contract-still-enabled\");\n        (uint safeCollateral, uint safeDebt) = safeEngine.safes(collateralType, msg.sender);\n        require(safeDebt == 0, \"GlobalSettlement/art-not-zero\");\n        require(safeCollateral <= 2**255, \"GlobalSettlement/overflow\");\n        safeEngine.confiscateSAFECollateralAndDebt(\n          collateralType,\n          msg.sender,\n          msg.sender,\n          address(accountingEngine),\n          -int(safeCollateral),\n          0\n        );\n        emit FreeCollateral(collateralType, msg.sender, -int(safeCollateral));\n    }\n    function setOutstandingCoinSupply() external {\n        require(contractEnabled == 0, \"GlobalSettlement/contract-still-enabled\");\n        require(outstandingCoinSupply == 0, \"GlobalSettlement/outstanding-coin-supply-not-zero\");\n        require(safeEngine.coinBalance(address(accountingEngine)) == 0, \"GlobalSettlement/surplus-not-zero\");\n        require(now >= addition(shutdownTime, shutdownCooldown), \"GlobalSettlement/shutdown-cooldown-not-finished\");\n        outstandingCoinSupply = safeEngine.globalDebt();\n        emit SetOutstandingCoinSupply(outstandingCoinSupply);\n    }\n    function calculateCashPrice(bytes32 collateralType) external {\n        require(outstandingCoinSupply != 0, \"GlobalSettlement/outstanding-coin-supply-zero\");\n        require(collateralCashPrice[collateralType] == 0, \"GlobalSettlement/collateral-cash-price-already-defined\");\n\n        (, uint accumulatedRate,,,,) = safeEngine.collateralTypes(collateralType);\n        uint256 redemptionAdjustedDebt = rmultiply(\n          rmultiply(collateralTotalDebt[collateralType], accumulatedRate), finalCoinPerCollateralPrice[collateralType]\n        );\n        collateralCashPrice[collateralType] = rdivide(\n          multiply(subtract(redemptionAdjustedDebt, collateralShortfall[collateralType]), RAY), outstandingCoinSupply\n        );\n        emit CalculateCashPrice(collateralType, collateralCashPrice[collateralType]);\n    }\n    function prepareCoinsForRedeeming(uint256 coinAmount) external {\n        require(outstandingCoinSupply != 0, \"GlobalSettlement/outstanding-coin-supply-zero\");\n        safeEngine.transferInternalCoins(msg.sender, address(accountingEngine), multiply(coinAmount, RAY));\n        coinBag[msg.sender] = addition(coinBag[msg.sender], coinAmount);\n        emit PrepareCoinsForRedeeming(msg.sender, coinBag[msg.sender]);\n    }\n    function redeemCollateral(bytes32 collateralType, uint coinsAmount) external {\n        require(collateralCashPrice[collateralType] != 0, \"GlobalSettlement/collateral-cash-price-not-defined\");\n        uint collateralAmount = rmultiply(coinsAmount, collateralCashPrice[collateralType]);\n        safeEngine.transferCollateral(\n          collateralType,\n          address(this),\n          msg.sender,\n          collateralAmount\n        );\n        coinsUsedToRedeem[collateralType][msg.sender] = addition(coinsUsedToRedeem[collateralType][msg.sender], coinsAmount);\n        require(coinsUsedToRedeem[collateralType][msg.sender] <= coinBag[msg.sender], \"GlobalSettlement/insufficient-bag-balance\");\n        emit RedeemCollateral(collateralType, msg.sender, coinsAmount, collateralAmount);\n    }\n}"
    },
    {
      "filename": "src/CollateralAuctionHouse.sol",
      "content": "/// EnglishCollateralAuctionHouse.sol\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.7;\n\nabstract contract SAFEEngineLike {\n    function transferInternalCoins(address,address,uint) virtual external;\n    function transferCollateral(bytes32,address,address,uint) virtual external;\n}\nabstract contract OracleRelayerLike {\n    function redemptionPrice() virtual public returns (uint256);\n}\nabstract contract OracleLike {\n    function getResultWithValidity() virtual public view returns (uint256, bool);\n}\nabstract contract LiquidationEngineLike {\n    function removeCoinsFromAuction(uint) virtual public;\n}\n\n/*\n   This thing lets you (English) auction some collateral for a given amount of system coins\n*/\n\ncontract EnglishCollateralAuctionHouse {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"EnglishCollateralAuctionHouse/account-not-authorized\");\n        _;\n    }\n\n    // --- Data ---\n    struct Bid {\n        // Bid size (how many coins are offered per collateral sold)\n        uint256 bidAmount;                                                                                            // [rad]\n        // How much collateral is sold in an auction\n        uint256 amountToSell;                                                                                         // [wad]\n        // Who the high bidder is\n        address highBidder;\n        // When the latest bid expires and the auction can be settled\n        uint48  bidExpiry;                                                                                            // [unix epoch time]\n        // Hard deadline for the auction after which no more bids can be placed\n        uint48  auctionDeadline;                                                                                      // [unix epoch time]\n        // Who (which SAFE) receives leftover collateral that is not sold in the auction; usually the liquidated SAFE\n        address forgoneCollateralReceiver;\n        // Who receives the coins raised from the auction; usually the accounting engine\n        address auctionIncomeRecipient;\n        // Total/max amount of coins to raise\n        uint256 amountToRaise;                                                                                        // [rad]\n    }\n\n    // Bid data for each separate auction\n    mapping (uint => Bid) public bids;\n\n    // SAFE database\n    SAFEEngineLike public safeEngine;\n    // Collateral type name\n    bytes32       public collateralType;\n\n    uint256  constant ONE = 1.00E18;                                                                                  // [wad]\n    // Minimum bid increase compared to the last bid in order to take the new one in consideration\n    uint256  public   bidIncrease = 1.05E18;                                                                          // [wad]\n    // How long the auction lasts after a new bid is submitted\n    uint48   public   bidDuration = 3 hours;                                                                          // [seconds]\n    // Total length of the auction\n    uint48   public   totalAuctionLength = 2 days;                                                                    // [seconds]\n    // Number of auctions started up until now\n    uint256  public   auctionsStarted = 0;\n\n    LiquidationEngineLike public liquidationEngine;\n\n    bytes32 public constant AUCTION_HOUSE_TYPE = bytes32(\"COLLATERAL\");\n    bytes32 public constant AUCTION_TYPE       = bytes32(\"ENGLISH\");\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event StartAuction(\n        uint256 id,\n        uint256 auctionsStarted,\n        uint256 amountToSell,\n        uint256 initialBid,\n        uint256 amountToRaise,\n        address indexed forgoneCollateralReceiver,\n        address indexed auctionIncomeRecipient,\n        uint256 auctionDeadline\n    );\n    event ModifyParameters(bytes32 parameter, uint data);\n    event ModifyParameters(bytes32 parameter, address data);\n    event RestartAuction(uint id, uint256 auctionDeadline);\n    event IncreaseBidSize(uint id, address highBidder, uint amountToBuy, uint rad, uint bidExpiry);\n    event DecreaseSoldAmount(uint id, address highBidder, uint amountToBuy, uint rad, uint bidExpiry);\n    event SettleAuction(uint id);\n    event TerminateAuctionPrematurely(uint id, address sender, uint bidAmount, uint collateralAmount);\n\n    // --- Init ---\n    constructor(address safeEngine_, address liquidationEngine_, bytes32 collateralType_) public {\n        safeEngine = SAFEEngineLike(safeEngine_);\n        liquidationEngine = LiquidationEngineLike(liquidationEngine_);\n        collateralType = collateralType_;\n        authorizedAccounts[msg.sender] = 1;\n        emit AddAuthorization(msg.sender);\n    }\n\n    // --- Math ---\n    function addUint48(uint48 x, uint48 y) internal pure returns (uint48 z) {\n        require((z = x + y) >= x);\n    }\n    function multiply(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n    uint256 constant WAD = 10 ** 18;\n    function wmultiply(uint x, uint y) internal pure returns (uint z) {\n        z = multiply(x, y) / WAD;\n    }\n    uint256 constant RAY = 10 ** 27;\n    function rdivide(uint x, uint y) internal pure returns (uint z) {\n      z = multiply(x, RAY) / y;\n    }\n\n    // --- Admin ---\n    /**\n     * @notice Modify auction parameters\n     * @param parameter The name of the parameter modified\n     * @param data New value for the parameter\n     */\n    function modifyParameters(bytes32 parameter, uint data) external isAuthorized {\n        if (parameter == \"bidIncrease\") bidIncrease = data;\n        else if (parameter == \"bidDuration\") bidDuration = uint48(data);\n        else if (parameter == \"totalAuctionLength\") totalAuctionLength = uint48(data);\n        else revert(\"EnglishCollateralAuctionHouse/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, data);\n    }\n    /**\n     * @notice Modify the address of an integrated contract\n     * @param parameter The name of the contract whose address we modify\n     * @param data New contract address\n     */\n    function modifyParameters(bytes32 parameter, address data) external isAuthorized {\n        if (parameter == \"liquidationEngine\") liquidationEngine = LiquidationEngineLike(data);\n        else revert(\"EnglishCollateralAuctionHouse/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, data);\n    }\n\n    // --- Auction ---\n    /**\n     * @notice Start a new collateral auction\n     * @param forgoneCollateralReceiver Who receives leftover collateral that is not auctioned\n     * @param auctionIncomeRecipient Who receives the amount raised in the auction\n     * @param amountToRaise Total amount of coins to raise (rad)\n     * @param amountToSell Total amount of collateral available to sell (wad)\n     * @param initialBid Initial bid size (usually zero in this implementation) (rad)\n     */\n    function startAuction(\n        address forgoneCollateralReceiver,\n        address auctionIncomeRecipient,\n        uint amountToRaise,\n        uint amountToSell,\n        uint initialBid\n    ) public isAuthorized returns (uint id)\n    {\n        require(auctionsStarted < uint(-1), \"EnglishCollateralAuctionHouse/overflow\");\n        require(amountToSell > 0, \"EnglishCollateralAuctionHouse/null-amount-sold\");\n        id = ++auctionsStarted;\n\n        bids[id].bidAmount = initialBid;\n        bids[id].amountToSell = amountToSell;\n        bids[id].highBidder = msg.sender;\n        bids[id].auctionDeadline = addUint48(uint48(now), totalAuctionLength);\n        bids[id].forgoneCollateralReceiver = forgoneCollateralReceiver;\n        bids[id].auctionIncomeRecipient = auctionIncomeRecipient;\n        bids[id].amountToRaise = amountToRaise;\n\n        safeEngine.transferCollateral(collateralType, msg.sender, address(this), amountToSell);\n\n        emit StartAuction(\n          id,\n          auctionsStarted,\n          amountToSell,\n          initialBid,\n          amountToRaise,\n          forgoneCollateralReceiver,\n          auctionIncomeRecipient,\n          bids[id].auctionDeadline\n        );\n    }\n    /**\n     * @notice Restart an auction if no bids were submitted for it\n     * @param id ID of the auction to restart\n     */\n    function restartAuction(uint id) external {\n        require(bids[id].auctionDeadline < now, \"EnglishCollateralAuctionHouse/not-finished\");\n        require(bids[id].bidExpiry == 0, \"EnglishCollateralAuctionHouse/bid-already-placed\");\n        bids[id].auctionDeadline = addUint48(uint48(now), totalAuctionLength);\n        emit RestartAuction(id, bids[id].auctionDeadline);\n    }\n    /**\n     * @notice First auction phase: submit a higher bid for the same amount of collateral\n     * @param id ID of the auction you want to submit the bid for\n     * @param amountToBuy Amount of collateral to buy (wad)\n     * @param rad New bid submitted (rad)\n     */\n    function increaseBidSize(uint id, uint amountToBuy, uint rad) external {\n        require(bids[id].highBidder != address(0), \"EnglishCollateralAuctionHouse/high-bidder-not-set\");\n        require(bids[id].bidExpiry > now || bids[id].bidExpiry == 0, \"EnglishCollateralAuctionHouse/bid-already-expired\");\n        require(bids[id].auctionDeadline > now, \"EnglishCollateralAuctionHouse/auction-already-expired\");\n\n        require(amountToBuy == bids[id].amountToSell, \"EnglishCollateralAuctionHouse/amounts-not-matching\");\n        require(rad <= bids[id].amountToRaise, \"EnglishCollateralAuctionHouse/higher-than-amount-to-raise\");\n        require(rad >  bids[id].bidAmount, \"EnglishCollateralAuctionHouse/new-bid-not-higher\");\n        require(multiply(rad, ONE) >= multiply(bidIncrease, bids[id].bidAmount) || rad == bids[id].amountToRaise, \"EnglishCollateralAuctionHouse/insufficient-increase\");\n\n        if (msg.sender != bids[id].highBidder) {\n            safeEngine.transferInternalCoins(msg.sender, bids[id].highBidder, bids[id].bidAmount);\n            bids[id].highBidder = msg.sender;\n        }\n        safeEngine.transferInternalCoins(msg.sender, bids[id].auctionIncomeRecipient, rad - bids[id].bidAmount);\n\n        bids[id].bidAmount = rad;\n        bids[id].bidExpiry = addUint48(uint48(now), bidDuration);\n\n        emit IncreaseBidSize(id, msg.sender, amountToBuy, rad, bids[id].bidExpiry);\n    }\n    /**\n     * @notice Second auction phase: decrease the collateral amount you're willing to receive in\n     *         exchange for providing the same amount of coins as the winning bid\n     * @param id ID of the auction for which you want to submit a new amount of collateral to buy\n     * @param amountToBuy Amount of collateral to buy (must be smaller than the previous proposed amount) (wad)\n     * @param rad New bid submitted; must be equal to the winning bid from the increaseBidSize phase (rad)\n     */\n    function decreaseSoldAmount(uint id, uint amountToBuy, uint rad) external {\n        require(bids[id].highBidder != address(0), \"EnglishCollateralAuctionHouse/high-bidder-not-set\");\n        require(bids[id].bidExpiry > n"
    }
  ]
}