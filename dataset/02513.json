{
  "Title": "M-10: Adversary can grief kicker by frontrunning kickAuction call with a large amount of loan",
  "Content": "# Issue M-10: Adversary can grief kicker by frontrunning kickAuction call with a large amount of loan \n\nSource: https://github.com/sherlock-audit/2023-01-ajna-judging/issues/111 \n\n## Found by \nkoxuan\n\n## Summary\nAverage debt size of the pool is used to calculated MOMP  (Most optimistic matching price), which is used to derive NP (neutral price). Higher average debt size will result in lower MOMP and hence lower NP which will make it harder for kicker to earn a reward and more likely that the kicker is penalized. An adversary can manipulate the average debt size of the pool by frontrunning kicker's `kickAuction` call with a large amount of loan. \n\n\n## Vulnerability Detail\n\nNP (neutral price) is a price that will be used to decide whether to reward a kicker with a bonus or punish the kicker with a penalty. In the event the auction ends with a price higher than NP, kicker will be given a penalty and if the auction ends with a price lower than NP, kicker will be rewarded with a bonus. \n\nNP is derived from MOMP  (Most optimistic matching price). BI refers to borrower inflator. Quoted from the whitepaper page 17, When a loan is initiated (the first debt or additional debt is drawn, or collateral is removed from the loan), the neutral price is set to\nthe current MOMP times the ratio of the loanâ€™s threshold price to the LUP, plus one yearâ€™s interest. As time passes, the neutral price increases at the same rate as interest. This can be expressed as the following formula for the neutral price as a function\nof time ð‘¡, where ð‘  is the time the loan is initiated.\n\n```math\n NP_t = (1 + rate_s) * MOMP_s * TP_s * \\frac{TP_s}{LUP_s} *  \\frac{BI_s}{BI_t}\n```\n\nTherefore the lower the MOMP, the lower the NP. Lower NP will mean that kicker will be rewarded less and punished more compared to a higher NP. Quoted from the white paper, The MOMP, or â€œmost optimistic matching price,â€ is the price at which a loan of average size would match with the most favorable lenders on the book. Technically, it is the highest price for which\nthe amount of deposit above it exceeds the average loan debt of the pool. In `_kick` function, MOMP is calculated as this. Notice how total pool debt is divided by number of loans to find the average loan debt size.\n\n```solidity\n        uint256 momp = _priceAt(\n            Deposits.findIndexOfSum(\n                deposits_,\n                Maths.wdiv(poolState_.debt, noOfLoans * 1e18)\n            )\n        );\n```\n\nAn adversary can frontrun `kickAuction` by taking a huge loan, causing the price for which the amount of deposit above the undercollaterized loan bucket to have a lower probability of surpassing the average loan debt. The adversary can use the deposits for the buckets above and the total pool debt to figure out how much loan is necessary to grief the kicker significantly by lowering the MOMP and NP.\n\n\n\n\n\n## Impact\nKickers can be grieved which can disincentivize user from kicking loans that deserve to be liquidated, causing the protocol to not work as desired as undercollaterized loans will not be liquidated.\n\n## Code Snippet\n[Auctions.sol#L796-L801](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/external/Auctions.sol#L796-L801)\n## Tool used\n\nManual Review\n\n## Recommendation\nRecommend taking the snapshot average loan size of the pool to prevent frontrunning attacks.\n\n## Discussion\n\n**dmitriia**\n\nEscalate for 50 USDC\nThat's valid, but griefing attacks are usually Medium as an attacker obtains no direct profit, so the overall probability of this happening is rather low/medium.\nThis surface is somewhat closer to low as it is highly costly for an attacker, who will pay origination fee on a huge loan:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/external/BorrowerActions.sol#L161-L168\n\n```solidity\n        // borrow against pledged collateral\n        ...\n        if (amountToBorrow_ != 0 || limitIndex_ != 0) {\n            ...\n\n            // add origination fee to the amount to borrow and add to borrower's debt\n            vars.debtChange = Maths.wmul(amountToBorrow_, _feeRate(poolState_.rate) + Maths.WAD);\n```\n\nI.e. it is not shown that attacker has good cost to target user loss ratio, which they don't in the most cases as pool liquidity serves as a natural buffer for the attack (the more liquidity the higher loan needs to be to move MOMP, the higher the origination fee). So it's more a corner case, and Medium severity looks more appropriate.\n\n**sherlock-admin**\n\n > Escalate for 50 USDC\n> That's valid, but griefing attacks are usually Medium as an attacker obtains no direct profit, so the overall probability of this happening is rather low/medium.\n> This surface is somewhat closer to low as it is highly costly for an attacker, who will pay origination fee on a huge loan:\n> \n> https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/external/BorrowerActions.sol#L161-L168\n> \n> ```solidity\n>         // borrow against pledged collateral\n>         ...\n>         if (amountToBorrow_ != 0 || limitIndex_ != 0) {\n>             ...\n> \n>             // add origination fee to the amount to borrow and add to borrower's debt\n>             vars.debtChange = Maths.wmul(amountToBorrow_, _feeRate(poolState_.rate) + Maths.WAD);\n> ```\n> \n> I.e. it is not shown that attacker has good cost to target user loss ratio, which they don't in the most cases as pool liquidity serves as a natural buffer for the attack (the more liquidity the higher loan needs to be to move MOMP, the higher the origination fee). So it's more a corner case, and Medium severity looks more appropriate.\n\nYou've created a valid escalation for 50 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**vkabc**\n\nEscalate for 50 USDC\n\nI will address the first point, `the attacker obtains no direct profit`. The MOMP affects NP which is used by every loan in the pool (including the attackers and others) to determine the incentives to kickers to kick the loan, and hence everyone who has a loan is incentivized to push down the MOMP and NP by taking more loans. Incentives to the borrowers to take more loans, spiralling more and more, leading to adverse effects to protocol.\n\nSecond point brought up, ` it is highly costly for an attacker`.  The origination fee is calculated as the greater of the current annualized borrower interest rate divided by 52 (one week of interest) or 5 bps multiplied by the loanâ€™s debt, taking the maximum between the two.\n\nThis is the example given by the whitepaper.\n\nSuppose that the interest rate is 10%. Then Bobâ€™s origination fee would be 18, 000 Â· 10%/52 = 34. 61 ð·ð´ð¼. When he\nwithdraws his 18,000 DAI, his debt is recorded including this origination fee, for a total of 18,034.61.\n\n\nThe costs is meagre compared to the incentives to borrowers, especially when being kicked will cause the loan to increase by 90 days of interest.\n\nBorrowers are all the more incentivized to take out more and bigger size loans, causing insolvency to the protocol as it is left with bad debt that nobody will liquidate.\n\n\n**sherlock-admin**\n\n > Escalate for 50 USDC\n> \n> I will address the first point, `the attacker obtains no direct profit`. The MOMP affects NP which is used by every loan in the pool (including the attackers and others) to determine the incentives to kickers to kick the loan, and hence everyone who has a loan is incentivized to push down the MOMP and NP by taking more loans. Incentives to the borrowers to take more loans, spiralling more and more, leading to adverse effects to protocol.\n> \n> Second point brought up, ` it is highly costly for an attacker`.  The origination fee is calculated as the greater of the current annualized borrower interest rate divided by 52 (one week of interest) or 5 bps multiplied by the loanâ€™s debt, taking the maximum between the two.\n> \n> This is the example given by the whitepaper.\n> \n> Suppose that the interest rate is 10%. Then Bobâ€™s origination fee would be 18, 000 Â· 10%/52 = 34. 61 ð·ð´ð¼. When he\n> withdraws his 18,000 DAI, his debt is recorded including this origination fee, for a total of 18,034.61.\n> \n> \n> The costs is meagre compared to the incentives to borrowers, especially when being kicked will cause the loan to increase by 90 days of interest.\n> \n> Borrowers are all the more incentivized to take out more and bigger size loans, causing insolvency to the protocol as it is left with bad debt that nobody will liquidate.\n> \n\nYou've created a valid escalation for 50 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**mattcushman**\n\nWe acknowledge the issue and intend to fix it (described below), but feel that Medium would be the appropriate severity.  This is fundamentally a griefing attack that is costly to the borrower to execute, and we don't feel that the spiral of over-borrowing is realistic because it would require adding more and more collateral, incurring greater and great origination fees and interest, to effect such borrows.  Furthermore, it's a function of the average loan size, not just the total debt, so if multiple borrowers participated through different loans it would move the MOMP back up.  \n\nWhile this attack is difficult and pricey to pursue, we do acknowledge it and propose a remedy by allowing the kicker to specify a \"limit neutral price\" LNP on their kick.  This would be a price supplied by the lender at the time of submitting the kick transaction that would only allow the kick to occur (and bond posted) if the actual NP exceeds the specified LNP.   By setting the LNP appropriately, the kicker can be assured that they won't find themselves with their bond tied up in an inappropriately low NP liquidation.  \n\n**hrishibhat**\n\nEscalation accepted\n\nBased on the above comments it is clear that the cost of the attack would be high and the likelihood of the attack is only in certain states of the pool. Considering this issue a valid medium\n\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Based on the above comments it is clear that the cost of the attack would be high and the likelihood of the attack is only in certain states of the pool. Considering this issue a valid medium\n> \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/32",
  "Code": [
    {
      "filename": "contracts/src/libraries/external/Auctions.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport { PRBMathSD59x18 } from \"@prb-math/contracts/PRBMathSD59x18.sol\";\n\nimport { PoolType } from '../../interfaces/pool/IPool.sol';\n\nimport {\n    AuctionsState,\n    Borrower,\n    Bucket,\n    DepositsState,\n    Kicker,\n    Lender,\n    Liquidation,\n    LoansState,\n    PoolState,\n    ReserveAuctionState\n}                                    from '../../interfaces/pool/commons/IPoolState.sol';\nimport {\n    BucketTakeResult,\n    KickResult,\n    SettleParams,\n    TakeResult\n}                                    from '../../interfaces/pool/commons/IPoolInternals.sol';\nimport { StartReserveAuctionParams } from '../../interfaces/pool/commons/IPoolReserveAuctionActions.sol';\n\nimport {\n    _claimableReserves,\n    _indexOf,\n    _isCollateralized,\n    _priceAt,\n    _reserveAuctionPrice,\n    _roundToScale,\n    MAX_FENWICK_INDEX,\n    MAX_PRICE,\n    MIN_PRICE\n}                           from '../helpers/PoolHelper.sol';\nimport { _revertOnMinDebt } from '../helpers/RevertsHelper.sol';\n\nimport { Buckets }  from '../internal/Buckets.sol';\nimport { Deposits } from '../internal/Deposits.sol';\nimport { Loans }    from '../internal/Loans.sol';\nimport { Maths }    from '../internal/Maths.sol';\n\n/**\n    @title  Auctions library\n    @notice External library containing actions involving auctions within pool:\n            - Kickers: kick undercollateralized loans; settle auctions; claim bond rewards\n            - Bidders: take auctioned collateral\n            - Reserve purchasers: start auctions; take reserves\n */\nlibrary Auctions {\n\n    /*******************************/\n    /*** Function Params Structs ***/\n    /*******************************/\n\n    struct BucketTakeParams {\n        address borrower;        // borrower address to take from\n        uint256 collateral;      // [WAD] borrower available collateral to take\n        bool    depositTake;     // deposit or arb take, used by bucket take\n        uint256 index;           // bucket index, used by bucket take\n        uint256 inflator;        // [WAD] current pool inflator\n        uint256 t0Debt;          // [WAD] borrower t0 debt\n        uint256 collateralScale; // precision of collateral token based on decimals\n    }\n    struct TakeParams {\n        address borrower;        // borrower address to take from\n        uint256 collateral;      // [WAD] borrower available collateral to take\n        uint256 t0Debt;          // [WAD] borrower t0 debt\n        uint256 takeCollateral;  // [WAD] desired amount to take\n        uint256 inflator;        // [WAD] current pool inflator\n        uint256 poolType;        // pool type (ERC20 or NFT)\n        uint256 collateralScale; // precision of collateral token based on decimals\n    }\n\n    /*************************/\n    /*** Local Var Structs ***/\n    /*************************/\n\n    struct KickWithDepositLocalVars {\n        uint256 amountToDebitFromDeposit; // [WAD] the amount of quote tokens used to kick and debited from lender deposit\n        uint256 bucketCollateral;         // [WAD] amount of collateral in bucket\n        uint256 bucketDeposit;            // [WAD] amount of quote tokens in bucket\n        uint256 bucketLPs;                // [RAY] LPs of the bucket\n        uint256 bucketPrice;              // [WAD] bucket price\n        uint256 bucketRate;               // [RAY] bucket exchange rate\n        uint256 bucketScale;              // [WAD] bucket scales\n        uint256 bucketUnscaledDeposit;    // [WAD] unscaled amount of quote tokens in bucket\n        uint256 lenderLPs;                // [RAY] LPs of lender in bucket\n        uint256 redeemedLPs;              // [RAY] LPs used by kick action\n    }\n    struct SettleLocalVars {\n        uint256 collateralUsed;    // [WAD] collateral used to settle debt\n        uint256 debt;              // [WAD] debt to settle\n        uint256 depositToRemove;   // [WAD] deposit used by settle auction\n        uint256 index;             // index of settling bucket\n        uint256 maxSettleableDebt; // [WAD] max amount that can be settled with existing collateral\n        uint256 price;             // [WAD] price of settling bucket\n        uint256 scaledDeposit;     // [WAD] scaled amount of quote tokens in bucket\n        uint256 scale;             // [WAD] scale of settling bucket\n        uint256 unscaledDeposit;   // [WAD] unscaled amount of quote tokens in bucket\n    }\n    struct TakeLocalVars {\n        uint256 auctionPrice;             // [WAD] The price of auction.\n        uint256 bondChange;               // [WAD] The change made on the bond size (beeing reward or penalty).\n        uint256 borrowerDebt;             // [WAD] The accrued debt of auctioned borrower.\n        int256  bpf;                      // The bond penalty factor.\n        uint256 bucketPrice;              // [WAD] The bucket price.\n        uint256 bucketScale;              // [WAD] The bucket scale.\n        uint256 collateralAmount;         // [WAD] The amount of collateral taken.\n        uint256 excessQuoteToken;         // [WAD] Difference of quote token that borrower receives after take (for fractional NFT only)\n        uint256 factor;                   // The take factor, calculated based on bond penalty factor.\n        bool    isRewarded;               // True if kicker is rewarded (auction price lower than neutral price), false if penalized (auction price greater than neutral price).\n        address kicker;                   // Address of auction kicker.\n        uint256 scaledQuoteTokenAmount;   // [WAD] Unscaled quantity in Fenwick tree and before 1-bpf factor, paid for collateral\n        uint256 t0RepayAmount;            // [WAD] The amount of debt (quote tokens) that is recovered / repayed by take t0 terms.\n        uint256 t0Debt;                   // [WAD] Borrower's t0 debt.\n        uint256 t0DebtPenalty;            // [WAD] Borrower's t0 penalty - 7% from current debt if intial take, 0 otherwise.\n        uint256 unscaledDeposit;          // [WAD] Unscaled bucket quantity\n        uint256 unscaledQuoteTokenAmount; // [WAD] The unscaled token amount that taker should pay for collateral taken.\n    }\n    struct TakeLoanLocalVars {\n        uint256 repaidDebt;   // [WAD] the amount of debt repaid to th epool by take auction\n        uint256 borrowerDebt; // [WAD] the amount of borrower debt\n        bool    inAuction;    // true if loan in auction\n    }\n    struct TakeFromLoanLocalVars {\n        uint256 borrowerDebt;          // [WAD] borrower's accrued debt\n        bool    inAuction;             // true if loan still in auction after auction is taken, false otherwise\n        uint256 newLup;                // [WAD] LUP after auction is taken\n        uint256 repaidDebt;            // [WAD] debt repaid when auction is taken\n        uint256 t0DebtInAuction;       // [WAD] t0 pool debt in auction\n        uint256 t0DebtInAuctionChange; // [WAD] t0 change amount of debt after auction is taken\n        uint256 t0PoolDebt;            // [WAD] t0 pool debt\n    }\n\n    /**************/\n    /*** Events ***/\n    /**************/\n\n    // See `IPoolEvents` for descriptions\n    event AuctionSettle(address indexed borrower, uint256 collateral);\n    event AuctionNFTSettle(address indexed borrower, uint256 collateral, uint256 lps, uint256 index);\n    event BucketTake(address indexed borrower, uint256 index, uint256 amount, uint256 collateral, uint256 bondChange, bool isReward);\n    event BucketTakeLPAwarded(address indexed taker, address indexed kicker, uint256 lpAwardedTaker, uint256 lpAwardedKicker);\n    event Kick(address indexed borrower, uint256 debt, uint256 collateral, uint256 bond);\n    event Take(address indexed borrower, uint256 amount, uint256 collateral, uint256 bondChange, bool isReward);\n    event RemoveQuoteToken(address indexed lender, uint256 indexed price, uint256 amount, uint256 lpRedeemed, uint256 lup);\n    event ReserveAuction(uint256 claimableReservesRemaining, uint256 auctionPrice);\n    event Settle(address indexed borrower, uint256 settledDebt);\n\n    /**************/\n    /*** Errors ***/\n    /**************/\n\n    // See `IPoolErrors` for descriptions\n    event BucketBankruptcy(uint256 indexed index, uint256 lpForfeited);\n    error AuctionActive();\n    error AuctionNotClearable();\n    error AuctionPriceGtBucketPrice();\n    error BorrowerOk();\n    error InsufficientLiquidity();\n    error InsufficientCollateral();\n    error NoAuction();\n    error NoReserves();\n    error NoReservesAuction();\n    error PriceBelowLUP();\n    error TakeNotPastCooldown();\n\n    /***************************/\n    /***  External Functions ***/\n    /***************************/\n\n    /**\n     *  @notice Settles the debt of the given loan / borrower.\n     *  @dev    write state:\n     *          - Deposits.unscaledRemove() (remove amount in Fenwick tree, from index):\n     *              - update values array state\n     *          - Buckets.addCollateral:\n     *              - increment bucket.collateral and bucket.lps accumulator\n     *              - addLenderLPs:\n     *                  - increment lender.lps accumulator and lender.depositTime state\n     *          - update borrower state\n     *  @dev    reverts on:\n     *              - loan is not in auction NoAuction()\n     *              - 72 hours didn't pass and auction still has collateral AuctionNotClearable()\n     *  @dev    emit events:\n     *              - Settle\n     *              - BucketBankruptcy\n     *  @param  params_ Settle params\n     *  @return collateralRemaining_ The amount of borrower collateral left after settle.\n     *  @return t0DebtRemaining_     The amount of t0 debt left after settle.\n     *  @return collateralSettled_   The amount of collateral settled.\n     *  @return t0DebtSettled_       The amount of t0 debt settled.\n     */\n    function settlePoolDebt(\n        AuctionsState storage auctions_,\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        LoansState storage loans_,\n        SettleParams memory params_\n    ) external returns (\n        uint256 collateralRemaining_,\n        uint256 t0DebtRemaining_,\n        uint256 collateralSettled_,\n        uint256 t0DebtSettled_\n    ) {\n        uint256 kickTime = auctions_.liquidations[params_.borrower].kickTime;\n        if (kickTime == 0) revert NoAuction();\n\n        Borrower memory borrower = loans_.borrowers[params_.borrower];\n        if ((block.timestamp - kickTime < 72 hours) && (borrower.collateral != 0)) revert AuctionNotClearable();\n\n        t0DebtSettled_     = borrower.t0Debt;\n        collateralSettled_ = borrower.collateral;\n\n        // auction has debt to cover with remaining collateral\n        while (params_.bucketDepth != 0 && borrower.t0Debt != 0 && borrower.collateral != 0) {\n            SettleLocalVars memory vars;\n\n            (vars.index, , vars.scale) = Deposits.findIndexAndSumOfSum(deposits_, 1);\n            vars.unscaledDeposit = Deposits.unscaledValueAt(deposits_, vars.index);\n            vars.price           = _priceAt(vars.index);\n\n            if (vars.unscaledDeposit != 0) {\n                vars.debt              = Maths.wmul(borrower.t0Debt, params_.inflator);       // current debt to be settled\n                vars.maxSettleableDebt = Maths.wmul(borrower.collateral, vars.price);         // max debt that can be settled with existing collateral\n                vars.scaledDeposit     = Maths.wmul(vars.scale, vars.unscaledDeposit);\n\n                // enough deposit in bucket and collateral avail to settle entire debt\n                if (vars.scaledDeposit >= vars.debt && vars.maxSettleableDebt >= vars.debt) {\n                    borrower.t0Debt      = 0;                                                 // no remaining debt to settle\n\n                    vars.unscaledDeposit = Maths.wdiv(vars.debt, vars.scale);                 // remove only what's needed to settle the debt\n                    vars.collateralUsed  = Maths.wdiv(vars.debt, vars.price);\n                }\n\n                // enough collateral, therefore not enough deposit to settle entire debt, we settle only deposit amount\n                else if (vars.maxSettleableDebt >= vars.scaledDeposit) {\n                    borrower.t0Debt     -= Maths.wdiv(vars.scaledDeposit, params_.inflator);  // subtract from debt the corresponding t0 amount of deposit\n\n                    vars.collateralUsed = Maths.wdiv(vars.scaledDeposit, vars.price);\n                } \n\n                // settle constrained by collateral available\n                else {\n                    borrower.t0Debt      -= Maths.wdiv(vars.maxSettleableDebt, params_.inflator);\n\n                    vars.unscaledDeposit = Maths.wdiv(vars.maxSettleableDebt, vars.scale);\n                    vars.collateralUsed  = borrower.collateral;\n                }\n\n                borrower.collateral             -= vars.collateralUsed;               // move settled collateral from loan into bucket\n                buckets_[vars.index].collateral += vars.collateralUsed;\n\n                Deposits.unscaledRemove(deposits_, vars.index, vars.unscaledDeposit); // remove amount to settle debt from bucket (could be entire deposit or only the settled debt)\n            }\n\n            else {\n                // Deposits in the tree is zero, insert entire collateral into lowest bucket 7388\n                Buckets.addCollateral(\n                    buckets_[vars.index],\n                    params_.borrower,\n                    0,  // zero deposit in bucket\n                    borrower.collateral,\n                    vars.price\n                );\n                borrower.collateral = 0; // entire collateral added into bucket\n            }\n\n            --params_.bucketDepth;\n        }\n\n        // if there's still debt and no collateral\n        if (borrower.t0Debt != 0 && borrower.collateral == 0) {\n            // settle debt from reserves -- round reserves down however\n            borrower.t0Debt -= Maths.min(borrower.t0Debt, (params_.reserves / params_.inflator) * 1e18);\n\n            // if there's still debt after settling from reserves then start to forgive amount from next HPB\n            // loop through remaining buckets if there's still debt to settle\n            while (params_.bucketDepth != 0 && borrower.t0Debt != 0) {\n                SettleLocalVars memory vars;\n\n                (vars.index, , vars.scale) = Deposits.findIndexAndSumOfSum(deposits_, 1);\n                vars.unscaledDeposit = Deposits.unscaledValueAt(deposits_, vars.index);\n                vars.depositToRemove = Maths.wmul(vars.scale, vars.unscaledDeposit);\n                vars.debt            = Maths.wmul(borrower.t0Debt, params_.inflator);\n\n                // enough deposit in bucket to settle entire debt\n                if (vars.depositToRemove >= vars.debt) {\n                    Deposits.unscaledRemove(deposits_, vars.index, Maths.wdiv(vars.debt, vars.scale));\n                    borrower.t0Debt  = 0;                                                              // no remaining debt to settle\n\n                // not enough deposit to settle entire debt, we settle only deposit amount\n                } else {\n                    borrower.t0Debt -= Maths.wdiv(vars.depositToRemove, params_.inflator);             // subtract from remaining debt the corresponding t0 amount of deposit\n\n                    Deposits.unscaledRemove(deposits_, vars.index, vars.unscaledDeposit);              // Remove all deposit from bucket\n                    Bucket storage hpbBucket = buckets_[vars.index];\n                    \n                    if (hpbBucket.collateral == 0) {                                                   // existing LPB and LP tokens for the bucket shall become unclaimable.\n                        emit BucketBankruptcy(vars.index, hpbBucket.lps);\n                        hpbBucket.lps            = 0;\n                        hpbBucket.bankruptcyTime = block.timestamp;\n                    }\n                }\n\n                --params_.bucketDepth;\n            }\n        }\n\n        t0DebtRemaining_ =  borrower.t0Debt;\n        t0DebtSettled_   -= t0DebtRemaining_;\n\n        emit Settle(params_.borrower, t0DebtSettled_);\n\n        if (borrower.t0Debt == 0) {\n            // settle auction\n            borrower.collateral = _settleAuction(\n                auctions_,\n                buckets_,\n                deposits_,\n                params_.borrower,\n                borrower.collateral,\n                params_.poolType\n            );\n        }\n\n        collateralRemaining_ =  borrower.collateral;\n        collateralSettled_   -= collateralRemaining_;\n\n        // update borrower state\n        loans_.borrowers[params_.borrower] = borrower;\n    }\n\n    /**\n     *  @notice Called to start borrower liquidation and to update the auctions queue.\n     *  @param  poolState_       Current state of the pool.\n     *  @param  borrowerAddress_ Address of the borrower to kick.\n     *  @return kickResult_      The result of the kick action.\n     */\n    function kick(\n        AuctionsState storage auctions_,\n        DepositsState storage deposits_,\n        LoansState    storage loans_,\n        PoolState calldata poolState_,\n        address borrowerAddress_\n    ) external returns (\n        KickResult memory\n    ) {\n        return _kick(\n            auctions_,\n            deposits_,\n            loans_,\n            poolState_,\n            borrowerAddress_,\n            0\n        );\n    }\n\n    /**\n     *  @notice Called by lenders to kick loans using their deposits.\n     *  @dev    write state:\n     *              - Deposits.unscaledRemove (remove amount in Fenwick tree, from index):\n     *                  - update values array state\n     *              - decrement lender.lps accumulator\n     *              - decrement bucket.lps accumulator\n     *  @dev    emit events:\n     *              - RemoveQuoteToken\n     *  @param  poolState_           Current state of the pool.\n     *  @param  index_               The deposit index from where lender removes liquidity.\n     *  @return kickResult_ The result of the kick action.\n     */\n    function kickWithDeposit(\n        AuctionsState storage auctions_,\n        DepositsState storage deposits_,\n        mapping(uint256 => Bucket) storage buckets_,\n        LoansState storage loans_,\n        PoolState memory poolState_,\n        uint256 index_\n    ) external returns (\n        KickResult memory kickResult_\n    ) {\n        Bucket storage bucket = buckets_[index_];\n        Lender storage lender = bucket.lenders[msg.sender];\n\n        KickWithDepositLocalVars memory vars;\n\n        if (bucket.bankruptcyTime < lender.depositTime) vars.lenderLPs = lender.lps;\n\n        vars.bucketLPs             = bucket.lps;\n        vars.bucketCollateral      = bucket.collateral;\n        vars.bucketPrice           = _priceAt(index_);\n        vars.bucketUnscaledDeposit = Deposits.unscaledValueAt(deposits_, index_);\n        vars.bucketScale           = Deposits.scale(deposits_, index_);\n        vars.bucketDeposit         = Maths.wmul(vars.bucketUnscaledDeposit, vars.bucketScale);\n\n        // calculate max amount that can be removed (constrained by lender LPs in bucket, bucket deposit and the amount lender wants to remove)\n        vars.bucketRate = Buckets.getExchangeRate(\n            vars.bucketCollateral,\n            vars.bucketLPs,\n            vars.bucketDeposit,\n            vars.bucketPrice\n        );\n\n        vars.amountToDebitFromDeposit = Maths.rayToWad(Maths.rmul(vars.lenderLPs, vars.bucketRate));  // calculate amount to remove based on lender LPs in bucket\n\n        if (vars.amountToDebitFromDeposit > vars.bucketDeposit) vars.amountToDebitFromDeposit = vars.bucketDeposit; // cap the amount to remove at bucket deposit\n\n        // revert if no amount that can be removed\n        if (vars.amountToDebitFromDeposit == 0) revert InsufficientLiquidity();\n\n        // kick top borrower\n        kickResult_ = _kick(\n            auctions_,\n            deposits_,\n            loans_,\n            poolState_,\n            Loans.getMax(loans_).borrower,\n            vars.amountToDebitFromDeposit\n        );\n\n        // amount to remove from deposit covers entire bond amount\n        if (vars.amountToDebitFromDeposit > kickResult_.amountToCoverBond) {\n            vars.amountToDebitFromDeposit = kickResult_.amountToCoverBond;                      // cap amount to remove from deposit at amount to cover bond\n\n            kickResult_.lup = _lup(deposits_, poolState_.debt + vars.amountToDebitFromDeposit); // recalculate the LUP with the amount to cover bond\n            kickResult_.amountToCoverBond = 0;                                                  // entire bond is covered from deposit, no additional amount to be send by lender\n        } else {\n            kickResult_.amountToCoverBond -= vars.amountToDebitFromDeposit;                     // lender should send additional amount to cover bond\n        }\n\n        // revert if the bucket price used to kick and remove is below new LUP\n        if (vars.bucketPrice < kickResult_.lup) revert PriceBelowLUP();\n\n        // remove amount from deposits\n        if (vars.amountToDebitFromDeposit == vars.bucketDeposit && vars.bucketCollateral == 0) {\n            // In this case we are redeeming the entire bucket exactly, and need to ensure bucket LPs are set to 0\n            vars.redeemedLPs = vars.bucketLPs;\n\n            Deposits.unscaledRemove(deposits_, index_, vars.bucketUnscaledDeposit);\n\n        } else {\n            vars.redeemedLPs = Maths.wrdivr(vars.amountToDebitFromDeposit, vars.bucketRate);\n\n            Deposits.unscaledRemove(\n                deposits_,\n                index_,\n                Maths.wdiv(vars.amountToDebitFromDeposit, vars.bucketScale)\n            );\n        }\n\n        // remove bucket LPs coresponding to the amount removed from deposits\n        lender.lps -= vars.redeemedLPs;\n        bucket.lps -= vars.redeemedLPs;\n\n        emit RemoveQuoteToken(msg.sender, index_, vars.amountToDebitFromDeposit, vars.redeemedLPs, kickResult_.lup);\n    }\n\n    /**\n     *  @notice Performs bucket take collateral on an auction, rewards taker and kicker (if case) and updates loan info (settles auction if case).\n     *  @dev    reverts on:\n     *              - insufficient collateral InsufficientCollateral()\n     *  @param  borrowerAddress_ Borrower address to take.\n     *  @param  depositTake_     If true then the take will happen at an auction price equal with bucket price. Auction price is used otherwise.\n     *  @param  index_           Index of a bucket, likely the HPB, in which collateral will be deposited.\n     *  @return result_          BucketTakeResult struct containing details of take.\n    */\n    function bucketTake(\n        AuctionsState storage auctions_,\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        LoansState storage loans_,\n        PoolState memory poolState_,\n        address borrowerAddress_,\n        bool    depositTake_,\n        uint256 index_,\n        uint256 collateralScale_\n    ) external returns (BucketTakeResult memory result_) {\n        Borrower memory borrower = loans_.borrowers[borrowerAddress_];\n\n        if (borrower.collateral == 0) revert InsufficientCollateral(); // revert if borrower's collateral is 0\n\n        (\n            result_.collateralAmount,\n            result_.t0RepayAmount,\n            borrower.t0Debt,\n            result_.t0DebtPenalty \n        ) = _takeBucket(\n            auctions_,\n            buckets_,\n            deposits_,\n            BucketTakeParams({\n                borrower:        borrowerAddress_,\n                collateral:      borrower.collateral,\n                t0Debt:          borrower.t0Debt,\n                inflator:        poolState_.inflator,\n                depositTake:     depositTake_,\n                index:           index_,\n                collateralScale: collateralScale_\n            })\n        );\n\n        borrower.collateral -= result_.collateralAmount;\n\n        if (result_.t0DebtPenalty != 0) {\n            poolState_.debt += Maths.wmul(result_.t0DebtPenalty, poolState_.inflator);\n        }\n\n        (\n            result_.poolDebt,\n            result_.newLup,\n            result_.t0DebtInAuctionChange,\n            result_.settledAuction\n        ) = _takeLoan(\n            auctions_,\n            buckets_,\n            deposits_,\n            loans_,\n            poolState_,\n            borrower,\n            borrowerAddress_,\n            result_.t0RepayAmount\n        );\n    }\n\n    /**\n     *  @notice Performs take collateral on an auction, rewards taker and kicker (if case) and updates loan info (settles auction if case).\n     *  @dev    reverts on:\n     *              - insufficient collateral InsufficientCollateral()\n     *  @param  borrowerAddress_ Borrower address to take.\n     *  @param  collateral_      Max amount of collateral that will be taken from the auction (max number of NFTs in case of ERC721 pool).\n     *  @return result_          TakeResult struct containing details of take.\n    */\n    function take(\n        AuctionsState storage auctions_,\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        LoansState storage loans_,\n        PoolState memory poolState_,\n        address borrowerAddress_,\n        uint256 collateral_,\n        uint256 collateralScale_\n    ) external returns (TakeResult memory result_) {\n        Borrower memory borrower = loans_.borrowers[borrowerAddress_];\n\n        // revert if borrower's collateral is 0 or if maxCollateral to be taken is 0\n        if (borrower.collateral == 0 || collateral_ == 0) revert InsufficientCollateral();\n\n        (\n            result_.collateralAmount,\n            result_.quoteTokenAmount,\n            result_.t0RepayAmount,\n            borrower.t0Debt,\n            result_.t0DebtPenalty,\n            result_.excessQuoteToken\n        ) = _take(\n            auctions_,\n            TakeParams({\n                borrower:        borrowerAddress_,\n                collateral:      borrower.collateral,\n                t0Debt:          borrower.t0Debt,\n                takeCollateral:  collateral_,\n                inflator:        poolState_.inflator,\n                poolType:        poolState_.poolType,\n                collateralScale: collateralScale_\n            })\n        );\n\n        borrower.collateral -= result_.collateralAmount;\n\n        if (result_.t0DebtPenalty != 0) {\n            poolState_.debt += Maths.wmul(result_.t0DebtPenalty, poolState_.inflator);\n        }\n\n        (\n            result_.poolDebt,\n            result_.newLup,\n            result_.t0DebtInAuctionChange,\n            result_.settledAuction\n        ) = _takeLoan(\n            auctions_,\n            buckets_,\n            deposits_,\n            loans_,\n            poolState_,\n            borrower,\n            borrowerAddress_,\n            result_.t0RepayAmount\n        );\n    }\n\n    /**\n     *  @notice See `IPoolReserveAuctionActions` for descriptions.\n     *  @dev    write state:\n     *              - update reserveAuction.unclaimed accumulator\n     *              - update reserveAuction.kicked timestamp state\n     *  @dev    reverts on:\n     *          - no reserves to claim NoReserves()\n     *  @dev    emit events:\n     *              - ReserveAuction\n     */\n    function startClaimableReserveAuction(\n        AuctionsState storage auctions_,\n        ReserveAuctionState storage reserveAuction_,\n        StartReserveAuctionParams calldata params_\n    ) external returns (uint256 kickerAward_) {\n        uint256 curUnclaimedAuctionReserve = reserveAuction_.unclaimed;\n\n        uint256 claimable = _claimableReserves(\n            Maths.wmul(params_.poolDebt, params_.inflator),\n            params_.poolSize,\n            auctions_.totalBondEscrowed,\n            curUnclaimedAuctionReserve,\n            params_.poolBalance\n        );\n\n        kickerAward_ = Maths.wmul(0.01 * 1e18, claimable);\n\n        curUnclaimedAuctionReserve += claimable - kickerAward_;\n\n        if (curUnclaimedAuctionReserve == 0) revert NoReserves();\n\n        reserveAuction_.unclaimed = curUnclaimedAuctionReserve;\n        reserveAuction_.kicked    = block.timestamp;\n\n        emit ReserveAuction(curUnclaimedAuctionReserve, _reserveAuctionPrice(block.timestamp));\n    }\n\n    /**\n     *  @notice See `IPoolReserveAuctionActions` for descriptions.\n     *  @dev    write state:\n     *              - decrement reserveAuction.unclaimed accumulator\n     *  @dev    reverts on:\n     *              - not kicked or 72 hours didn't pass NoReservesAuction()\n     *  @dev    emit events:\n     *              - ReserveAuction\n     */\n    function takeReserves(\n        ReserveAuctionState storage reserveAuction_,\n        uint256 maxAmount_\n    ) external returns (uint256 amount_, uint256 ajnaRequired_) {\n        uint256 kicked = reserveAuction_.kicked;\n\n        if (kicked != 0 && block.timestamp - kicked <= 72 hours) {\n            uint256 unclaimed = reserveAuction_.unclaimed;\n            uint256 price     = _reserveAuctionPrice(kicked);\n\n            amount_       = Maths.min(unclaimed, maxAmount_);\n            ajnaRequired_ = Maths.wmul(amount_, price);\n\n            unclaimed -= amount_;\n\n            reserveAuction_.unclaimed = unclaimed;\n\n            emit ReserveAuction(unclaimed, price);\n        } else {\n            revert NoReservesAuction();\n        }\n    }\n\n    /***************************/\n    /***  Internal Functions ***/\n    /***************************/\n\n    /**\n     *  @notice Performs auction settle based on pool type, emits settle event and removes auction from auctions queue.\n     *  @dev    emit events:\n     *              - AuctionNFTSettle or AuctionSettle\n     *  @param  borrowerAddress_     Address of the borrower that exits auction.\n     *  @param  borrowerCollateral_  Borrower collateral amount before auction exit (in NFT could be fragmented as result of partial takes).\n     *  @param  poolType_            Type of the pool (can be ERC20 or NFT).\n     *  @return remainingCollateral_ Collateral remaining after auction is settled (same amount for ERC20 pool, rounded collateral for NFT pool).\n     */\n    function _settleAuction(\n        AuctionsState storage auctions_,\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        address borrowerAddress_,\n        uint256 borrowerCollateral_,\n        uint256 poolType_\n    ) internal returns (uint256 remainingCollateral_) {\n        if (poolType_ == uint8(PoolType.ERC721)) {\n            uint256 lps;\n            uint256 bucketIndex;\n\n            (remainingCollateral_, lps, bucketIndex) = _settleNFTCollateral(\n                auctions_,\n                buckets_,\n                deposits_,\n                borrowerAddress_,\n                borrowerCollateral_\n            );\n\n            emit AuctionNFTSettle(borrowerAddress_, remainingCollateral_, lps, bucketIndex);\n\n        } else {\n            remainingCollateral_ = borrowerCollateral_;\n\n            emit AuctionSettle(borrowerAddress_, remainingCollateral_);\n        }\n\n        _removeAuction(auctions_, borrowerAddress_);\n    }\n\n    /**\n     *  @notice Performs NFT collateral settlement by rounding down borrower's collateral amount and by moving borrower's token ids to pool claimable array.\n     *  @param borrowerAddress_    Address of the borrower that exits auction.\n     *  @param borrowerCollateral_ Borrower collateral amount before auction exit (could be fragmented as result of partial takes).\n     *  @return floorCollateral_   Rounded down collateral, the number of NFT tokens borrower can pull after auction exit.\n     *  @return lps_               LPs given to the borrower to compensate fractional collateral (if any).\n     *  @return bucketIndex_       Index of the bucket with LPs to compensate.\n     */\n    function _settleNFTCollateral(\n        AuctionsState storage auctions_,\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        address borrowerAddress_,\n        uint256 borrowerCollateral_\n    ) internal returns (uint256 floorCollateral_, uint256 lps_, uint256 bucketIndex_) {\n        floorCollateral_ = (borrowerCollateral_ / Maths.WAD) * Maths.WAD; // floor collateral of borrower\n\n        // if there's fraction of NFTs remaining then reward difference to borrower as LPs in auction price bucket\n        if (floorCollateral_ != borrowerCollateral_) {\n            // cover borrower's fractional amount with LPs in auction price bucket\n            uint256 fractionalCollateral = borrowerCollateral_ - floorCollateral_;\n\n            uint256 auctionPrice = _auctionPrice(\n                auctions_.liquidati"
    }
  ]
}