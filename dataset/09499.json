{
  "Title": "[N-17] Non-library/interface files should use fixed compiler versions, not floating ones",
  "Content": "\n1.  File: src/CitadelToken.sol (line [2](https://github.com/code-423n4/2022-04-badger-citadel/blob/dab143a990a9c355578fbb15cd3c884614e33f42/src/CitadelToken.sol#L2))\n\n```solidity\npragma solidity ^0.8.0;\n```\n\n2.  File: src/GlobalAccessControl.sol (line [3](https://github.com/code-423n4/2022-04-badger-citadel/blob/dab143a990a9c355578fbb15cd3c884614e33f42/src/GlobalAccessControl.sol#L3))\n\n```solidity\npragma solidity ^0.8.0;\n```\n\n3.  File: src/lib/GlobalAccessControlManaged.sol (line [3](https://github.com/code-423n4/2022-04-badger-citadel/blob/dab143a990a9c355578fbb15cd3c884614e33f42/src/lib/GlobalAccessControlManaged.sol#L3))\n\n```solidity\npragma solidity ^0.8.12;\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-04-badger-citadel",
  "Code": [
    {
      "filename": "src/CitadelToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"./lib/GlobalAccessControlManaged.sol\";\n\ncontract CitadelToken is GlobalAccessControlManaged, ERC20Upgradeable {\n    bytes32 public constant CITADEL_MINTER_ROLE =\n        keccak256(\"CITADEL_MINTER_ROLE\");\n\n    /// =======================\n    /// ===== Initializer =====\n    /// =======================\n\n    /**\n     * @notice Initializer\n     * @param _name Token name\n     * @param _symbol Token symbol\n     * @param _gac Global access control to allow permissioned calls by role\n     */\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        address _gac\n    ) public initializer {\n        __ERC20_init(_name, _symbol);\n        __GlobalAccessControlManaged_init(_gac);\n    }\n\n    /// ==========================\n    /// ===== Minter actions =====\n    /// ==========================\n\n    /**\n     * @dev Mints new tokens.\n     * @param dest The address to mint the new tokens to.\n     * @param amount The quantity of tokens to mint.\n     */\n    function mint(address dest, uint256 amount)\n        external\n        onlyRole(CITADEL_MINTER_ROLE)\n        gacPausable\n    {\n        _mint(dest, amount);\n    }\n}"
    },
    {
      "filename": "src/GlobalAccessControl.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport {IERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\"; \nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {PausableUpgradeable} from \"openzeppelin-contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {AccessControlEnumerableUpgradeable} from \"openzeppelin-contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {EnumerableSetUpgradeable} from \"openzeppelin-contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\n\n/**\n * @title Badger Geyser\n @dev Tracks stakes and pledged tokens to be distributed, for use with \n @dev BadgerTree merkle distribution system. An arbitrary number of tokens to \n distribute can be specified.\n */\n\ncontract GlobalAccessControl is\n    AccessControlEnumerableUpgradeable,\n    PausableUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    bytes32 public constant CONTRACT_GOVERNANCE_ROLE =\n        keccak256(\"CONTRACT_GOVERNANCE_ROLE\");\n    bytes32 public constant TREASURY_GOVERNANCE_ROLE =\n        keccak256(\"TREASURY_GOVERNANCE_ROLE\");\n\n    bytes32 public constant TECH_OPERATIONS_ROLE =\n        keccak256(\"TECH_OPERATIONS_ROLE\");\n    bytes32 public constant POLICY_OPERATIONS_ROLE =\n        keccak256(\"POLICY_OPERATIONS_ROLE\");\n    bytes32 public constant TREASURY_OPERATIONS_ROLE =\n        keccak256(\"TREASURY_OPERATIONS_ROLE\");\n\n    bytes32 public constant KEEPER_ROLE = keccak256(\"KEEPER_ROLE\");\n\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n    bytes32 public constant UNPAUSER_ROLE = keccak256(\"UNPAUSER_ROLE\");\n\n    bytes32 public constant BLOCKLIST_MANAGER_ROLE =\n        keccak256(\"BLOCKLIST_MANAGER_ROLE\");\n    bytes32 public constant BLOCKLISTED_ROLE = keccak256(\"BLOCKLISTED_ROLE\");\n\n    bytes32 public constant CITADEL_MINTER_ROLE =\n        keccak256(\"CITADEL_MINTER_ROLE\");\n\n    // Should the function transferFrom be disabled\n    // NOTE: This is enforced at the contract level, the contract just allows the toggling of the bool\n    bool public transferFromDisabled; // Set to true in initialize\n\n    /// =======================\n    /// ===== Initializer =====\n    /// =======================\n\n    /**\n     * @notice Initializer\n     * @param _initialContractGovernance Global access control\n     */\n    function initialize(address _initialContractGovernance)\n        external\n        initializer\n    {\n        __AccessControlEnumerable_init();\n        __Pausable_init();\n\n        // Set this for assumptions and clarity\n        _setupRole(DEFAULT_ADMIN_ROLE, _initialContractGovernance);\n        \n        _setupRole(CONTRACT_GOVERNANCE_ROLE, _initialContractGovernance);\n\n        // All roles are managed by CONTRACT_GOVERNANCE_ROLE\n        _setRoleAdmin(CONTRACT_GOVERNANCE_ROLE, CONTRACT_GOVERNANCE_ROLE);\n        _setRoleAdmin(POLICY_OPERATIONS_ROLE, CONTRACT_GOVERNANCE_ROLE);\n        _setRoleAdmin(TREASURY_GOVERNANCE_ROLE, CONTRACT_GOVERNANCE_ROLE);\n        _setRoleAdmin(PAUSER_ROLE, CONTRACT_GOVERNANCE_ROLE);\n        _setRoleAdmin(UNPAUSER_ROLE, CONTRACT_GOVERNANCE_ROLE);\n        _setRoleAdmin(BLOCKLIST_MANAGER_ROLE, CONTRACT_GOVERNANCE_ROLE);\n        _setRoleAdmin(CITADEL_MINTER_ROLE, CONTRACT_GOVERNANCE_ROLE);\n        _setRoleAdmin(KEEPER_ROLE, CONTRACT_GOVERNANCE_ROLE);\n\n        // Add default admin role here to avoid governance mistakes\n        _setRoleAdmin(DEFAULT_ADMIN_ROLE, CONTRACT_GOVERNANCE_ROLE);\n\n        // BLOCKLIST is managed by BLOCKLIST_MANAGER\n        _setRoleAdmin(BLOCKLISTED_ROLE, BLOCKLIST_MANAGER_ROLE);\n    }\n\n    /// ================================================\n    /// ===== Permissioned Actions (various roles) =====\n    /// ================================================\n\n    function pause() external {\n        require(hasRole(PAUSER_ROLE, msg.sender), \"PAUSER_ROLE\");\n        _pause();\n    }\n\n    function unpause() external {\n        require(hasRole(UNPAUSER_ROLE, msg.sender), \"UNPAUSER_ROLE\");\n        _unpause();\n    }\n\n    /// @dev setup a new role via contract governance, without upgrade\n    /// @dev note that no constant will be available on the contract here to search role, but we can delegate viewing to another contract\n    /// TODO: Add string -> hash EnumerableSet to a new RoleRegistry contract for easy on-chain viewing.\n    function initializeNewRole(\n        bytes32 role,\n        string memory roleString,\n        bytes32 adminRole\n    ) external {\n        require(\n            hasRole(CONTRACT_GOVERNANCE_ROLE, msg.sender),\n            \"CONTRACT_GOVERNANCE_ROLE\"\n        );\n        require(\n            keccak256(bytes(roleString)) == role,\n            \"Role string and role do not match\"\n        );\n        _setRoleAdmin(role, adminRole);\n    }\n}"
    },
    {
      "filename": "src/lib/GlobalAccessControlManaged.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.12;\n\nimport {PausableUpgradeable} from \"openzeppelin-contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"../interfaces/citadel/IGac.sol\";\n\n/**\n * @title Global Access Control Managed - Base Class\n * @notice allows inheriting contracts to leverage global access control permissions conveniently, as well as granting contract-specific pausing functionality\n */\ncontract GlobalAccessControlManaged is PausableUpgradeable {\n    IGac public gac;\n\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n    bytes32 public constant UNPAUSER_ROLE = keccak256(\"UNPAUSER_ROLE\");\n\n    /// =======================\n    /// ===== Initializer =====\n    /// =======================\n\n    /**\n     * @notice Initializer\n     * @dev this is assumed to be used in the initializer of the inhereiting contract\n     * @param _globalAccessControl global access control which is pinged to allow / deny access to permissioned calls by role\n     */\n    function __GlobalAccessControlManaged_init(address _globalAccessControl)\n        public\n        onlyInitializing\n    {\n        __Pausable_init_unchained();\n        gac = IGac(_globalAccessControl);\n    }\n\n    /// =====================\n    /// ===== Modifiers =====\n    /// =====================\n\n    // @dev only holders of the given role on the GAC can call\n    modifier onlyRole(bytes32 role) {\n        require(gac.hasRole(role, msg.sender), \"GAC: invalid-caller-role\");\n        _;\n    }\n\n    // @dev only holders of any of the given set of roles on the GAC can call\n    modifier onlyRoles(bytes32[] memory roles) {\n        bool validRoleFound = false;\n        for (uint256 i = 0; i < roles.length; i++) {\n            bytes32 role = roles[i];\n            if (gac.hasRole(role, msg.sender)) {\n                validRoleFound = true;\n                break;\n            }\n        }\n        require(validRoleFound, \"GAC: invalid-caller-role\");\n        _;\n    }\n\n    // @dev only holders of the given role on the GAC can call, or a specified address\n    // @dev used to faciliate extra contract-specific permissioned accounts\n    modifier onlyRoleOrAddress(bytes32 role, address account) {\n        require(\n            gac.hasRole(role, msg.sender) || msg.sender == account,\n            \"GAC: invalid-caller-role-or-address\"\n        );\n        _;\n    }\n\n    /// @dev can be pausable by GAC or local flag\n    modifier gacPausable() {\n        require(!gac.paused(), \"global-paused\");\n        require(!paused(), \"local-paused\");\n        _;\n    }\n\n    /// ================================\n    /// ===== Permissioned actions =====\n    /// ================================\n\n    function pause() external {\n        require(gac.hasRole(PAUSER_ROLE, msg.sender));\n        _pause();\n    }\n\n    function unpause() external {\n        require(gac.hasRole(UNPAUSER_ROLE, msg.sender));\n        _unpause();\n    }\n}"
    }
  ]
}