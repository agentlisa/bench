{
  "Title": "M-14: Marketplace.setPrincipal do not approve needed allowance for Element vault and APWine router",
  "Content": "# Issue M-14: Marketplace.setPrincipal do not approve needed allowance for Element vault and APWine router \n\nSource: https://github.com/sherlock-audit/2022-10-illuminate-judging/issues/40 \n\n## Found by \npashov, rvierdiiev\n\n## Summary\n`Marketplace.setPrincipal` do not approve needed allowance for `Element vault` and `APWine router`\n## Vulnerability Detail\n`Marketplace.setPrincipal` is used to provide principal token for the base token and maturity when it was not set yet. To set PT you also provide protocol that this token belongs to.\n\nIn case of `APWine` protocol there is special block of code to handle all needed allowance. But it is not enough.\n\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Marketplace.sol#L231-L236\n```solidity\n        } else if (p == uint8(Principals.Apwine)) {\n            address futureVault = IAPWineToken(a).futureVault();\n            address interestBearingToken = IAPWineFutureVault(futureVault)\n                .getIBTAddress();\n            IRedeemer(redeemer).approve(interestBearingToken);\n        } else if (p == uint8(Principals.Notional)) {\n```\n\nIn `Marketplace.createMarket` function 2 more params are used to provide allowance of Lender for Element vault and APWine router.\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Marketplace.sol#L182\n`ILender(lender).approve(u, e, a, t[7]);`\n\nBut in `setPrincipal` we don't have such params and allowance is not set. So `Lender` will not be able to work with that tokens correctly.\n## Impact\nLender will not provide needed allowance and protocol integration will fail.\n## Code Snippet\nProvided above.\n## Tool used\n\nManual Review\n\n## Recommendation\nAdd 2 more params as in `createMarket` and call `ILender(lender).approve(u, e, a, address(0));`\n\n## Discussion\n\n**sourabhmarathe**\n\nSuggested severity is Low on the grounds that we have an `admin` method that would allow us to handle these particular approvals. That being said, we will be implementing a fix based on this report.\n\n**Evert0x**\n\nIssue will stay medium severity, although Illuminate is able to fix it using admin powers.. it's still a broken codebase that can potentially impact user funds.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/12",
  "Code": [
    {
      "filename": "src/Marketplace.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.16;\n\nimport 'src/tokens/ERC5095.sol';\nimport 'src/lib/Safe.sol';\nimport 'src/lib/RevertMsgExtractor.sol';\n\nimport 'src/interfaces/ILender.sol';\nimport 'src/interfaces/IPool.sol';\nimport 'src/interfaces/IPendleToken.sol';\nimport 'src/interfaces/IAPWineToken.sol';\nimport 'src/interfaces/IAPWineFutureVault.sol';\n\nimport 'src/errors/Exception.sol';\n\n/// @title MarketPlace\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice This contract is in charge of managing the available principals for each loan market.\n/// @notice In addition, this contract routes swap orders between Illuminate PTs and their respective underlying to YieldSpace pools.\ncontract MarketPlace {\n    /// @notice the available principals\n    /// @dev the order of this enum is used to select principals from the markets\n    /// mapping (e.g. Illuminate => 0, Swivel => 1, and so on)\n    enum Principals {\n        Illuminate, // 0\n        Swivel, // 1\n        Yield, // 2\n        Element, // 3\n        Pendle, // 4\n        Tempus, // 5\n        Sense, // 6\n        Apwine, // 7\n        Notional // 8\n    }\n\n    /// @notice markets are defined by a tuple that points to a fixed length array of principal token addresses.\n    mapping(address => mapping(uint256 => address[9])) public markets;\n\n    /// @notice pools map markets to their respective YieldSpace pools for the MetaPrincipal token\n    mapping(address => mapping(uint256 => address)) public pools;\n\n    /// @notice address that is allowed to create markets, set pools, etc. It is commonly used in the authorized modifier.\n    address public admin;\n    /// @notice address of the deployed redeemer contract\n    address public immutable redeemer;\n    /// @notice address of the deployed lender contract\n    address public immutable lender;\n\n    /// @notice emitted upon the creation of a new market\n    event CreateMarket(\n        address indexed underlying,\n        uint256 indexed maturity,\n        address[9] tokens,\n        address element,\n        address apwine\n    );\n    /// @notice emitted upon setting a principal token\n    event SetPrincipal(\n        address indexed underlying,\n        uint256 indexed maturity,\n        address indexed principal,\n        uint8 protocol\n    );\n    /// @notice emitted upon swapping with the pool\n    event Swap(\n        address indexed underlying,\n        uint256 indexed maturity,\n        address sold,\n        address bought,\n        uint256 received,\n        uint256 spent,\n        address spender\n    );\n    /// @notice emitted upon minting tokens with the pool\n    event Mint(\n        address indexed underlying,\n        uint256 indexed maturity,\n        uint256 underlyingIn,\n        uint256 principalTokensIn,\n        uint256 minted,\n        address minter\n    );\n    /// @notice emitted upon burning tokens with the pool\n    event Burn(\n        address indexed underlying,\n        uint256 indexed maturity,\n        uint256 tokensBurned,\n        uint256 underlyingReceived,\n        uint256 principalTokensReceived,\n        address burner\n    );\n    /// @notice emitted upon changing the admin\n    event SetAdmin(address indexed admin);\n    /// @notice emitted upon setting a pool\n    event SetPool(\n        address indexed underlying,\n        uint256 indexed maturity,\n        address indexed pool\n    );\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Exception(0, 0, 0, msg.sender, a);\n        }\n        _;\n    }\n\n    /// @notice initializes the MarketPlace contract\n    /// @param r address of the deployed redeemer contract\n    /// @param l address of the deployed lender contract\n    constructor(address r, address l) {\n        admin = msg.sender;\n        redeemer = r;\n        lender = l;\n    }\n\n    /// @notice creates a new market for the given underlying token and maturity\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param t principal token addresses for this market\n    /// @param n name for the Illuminate token\n    /// @param s symbol for the Illuminate token\n    /// @param e address of the Element vault that corresponds to this market\n    /// @param a address of the APWine router that corresponds to this market\n    /// @return bool true if successful\n    function createMarket(\n        address u,\n        uint256 m,\n        address[8] calldata t,\n        string calldata n,\n        string calldata s,\n        address e,\n        address a\n    ) external authorized(admin) returns (bool) {\n        {\n            // Get the Illuminate principal token for this market (if one exists)\n            address illuminate = markets[u][m][\n                (uint256(Principals.Illuminate))\n            ];\n\n            // If illuminate PT already exists, a new market cannot be created\n            if (illuminate != address(0)) {\n                revert Exception(9, 0, 0, illuminate, address(0));\n            }\n        }\n\n        // Create an Illuminate principal token for the new market\n        address illuminateToken = address(\n            new ERC5095(\n                u,\n                m,\n                redeemer,\n                lender,\n                address(this),\n                n,\n                s,\n                IERC20(u).decimals()\n            )\n        );\n\n        {\n            // create the principal tokens array\n            address[9] memory market = [\n                illuminateToken, // Illuminate\n                t[0], // Swivel\n                t[1], // Yield\n                t[2], // Element\n                t[3], // Pendle\n                t[4], // Tempus\n                t[5], // Sense\n                t[6], // APWine\n                t[7] // Notional\n            ];\n\n            // Set the market\n            markets[u][m] = market;\n\n            // Have the lender contract approve the several contracts\n            ILender(lender).approve(u, e, a, t[7]);\n\n            // Have the redeemer contract approve the Pendle principal token\n            if (t[3] != address(0)) {\n                address underlyingYieldToken = IPendleToken(t[3])\n                    .underlyingYieldToken();\n                IRedeemer(redeemer).approve(underlyingYieldToken);\n            }\n\n            if (t[6] != address(0)) {\n                address futureVault = IAPWineToken(t[6]).futureVault();\n                address interestBearingToken = IAPWineFutureVault(futureVault)\n                    .getIBTAddress();\n                IRedeemer(redeemer).approve(interestBearingToken);\n            }\n\n            emit CreateMarket(u, m, market, e, a);\n        }\n        return true;\n    }\n\n    /// @notice allows the admin to set an individual market\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a address of the new principal token\n    /// @return bool true if the principal set, false otherwise\n    function setPrincipal(\n        uint8 p,\n        address u,\n        uint256 m,\n        address a\n    ) external authorized(admin) returns (bool) {\n        // Get the current principal token for the principal token being set\n        address market = markets[u][m][p];\n\n        // Verify that it has not already been set\n        if (market != address(0)) {\n            revert Exception(9, 0, 0, market, address(0));\n        }\n\n        // Set the principal token in the markets mapping\n        markets[u][m][p] = a;\n\n        if (p == uint8(Principals.Pendle)) {\n            // Principal token must be approved for Pendle's redeem\n            address underlyingYieldToken = IPendleToken(a)\n                .underlyingYieldToken();\n            IRedeemer(redeemer).approve(underlyingYieldToken);\n        } else if (p == uint8(Principals.Apwine)) {\n            address futureVault = IAPWineToken(a).futureVault();\n            address interestBearingToken = IAPWineFutureVault(futureVault)\n                .getIBTAddress();\n            IRedeemer(redeemer).approve(interestBearingToken);\n        } else if (p == uint8(Principals.Notional)) {\n            // Principal token must be approved for Notional's lend\n            ILender(lender).approve(address(0), address(0), address(0), a);\n        }\n\n        emit SetPrincipal(u, m, a, p);\n        return true;\n    }\n\n    /// @notice sets the admin address\n    /// @param a Address of a new admin\n    /// @return bool true if the admin set, false otherwise\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        emit SetAdmin(a);\n        return true;\n    }\n\n    /// @notice sets the address for a pool\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a address of the pool\n    /// @return bool true if the pool set, false otherwise\n    function setPool(\n        address u,\n        uint256 m,\n        address a\n    ) external authorized(admin) returns (bool) {\n        // Verify that the pool has not already been set\n        address pool = pools[u][m];\n\n        // Revert if the pool already exists\n        if (pool != address(0)) {\n            revert Exception(10, 0, 0, pool, address(0));\n        }\n\n        // Set the pool\n        pools[u][m] = a;\n\n        emit SetPool(u, m, a);\n        return true;\n    }\n\n    /// @notice sells the PT for the underlying via the pool\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of PTs to sell\n    /// @param s slippage cap, minimum amount of underlying that must be received\n    /// @return uint128 amount of underlying bought\n    function sellPrincipalToken(\n        address u,\n        uint256 m,\n        uint128 a,\n        uint128 s\n    ) external returns (uint128) {\n        // Get the pool for the market\n        IPool pool = IPool(pools[u][m]);\n\n        // Preview amount of underlying received by selling `a` PTs\n        uint256 expected = pool.sellFYTokenPreview(a);\n\n        if (expected < s) {\n            revert Exception(16, expected, s, address(0), address(0));\n        }\n\n        // Transfer the principal tokens to the pool\n        Safe.transferFrom(\n            IERC20(address(pool.fyToken())),\n            msg.sender,\n            address(pool),\n            a\n        );\n\n        // Execute the swap\n        uint128 received = pool.sellFYToken(msg.sender, uint128(expected));\n        emit Swap(u, m, address(pool.fyToken()), u, received, a, msg.sender);\n\n        return received;\n    }\n\n    /// @notice buys the PT for the underlying via the pool\n    /// @notice determines how many underlying to sell by using the preview\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of PTs to be purchased\n    /// @param s slippage cap, maximum number of underlying that can be sold\n    /// @return uint128 amount of underlying sold\n    function buyPrincipalToken(\n        address u,\n        uint256 m,\n        uint128 a,\n        uint128 s\n    ) external returns (uint128) {\n        // Get the pool for the market\n        IPool pool = IPool(pools[u][m]);\n\n        // Get the amount of base hypothetically required to purchase `a` PTs\n        uint128 expected = pool.buyFYTokenPreview(a);\n\n        // Verify that the amount needed does not exceed the slippage parameter\n        if (expected > s) {\n            revert Exception(16, expected, 0, address(0), address(0));\n        }\n\n        // Transfer the underlying tokens to the pool\n        Safe.transferFrom(\n            IERC20(pool.base()),\n            msg.sender,\n            address(pool),\n            expected\n        );\n\n        // Execute the swap to purchase `a` base tokens\n        uint128 spent = pool.buyFYToken(msg.sender, a, 0);\n        emit Swap(u, m, u, address(pool.fyToken()), a, spent, msg.sender);\n\n        return spent;\n    }\n\n    /// @notice sells the underlying for the PT via the pool\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying to sell\n    /// @param s slippage cap, minimum number of PTs that must be received\n    /// @return uint128 amount of PT purchased\n    function sellUnderlying(\n        address u,\n        uint256 m,\n        uint128 a,\n        uint128 s\n    ) external returns (uint128) {\n        // Get the pool for the market\n        IPool pool = IPool(pools[u][m]);\n\n        // Get the number of PTs received for selling `a` underlying tokens\n        uint128 expected = pool.sellBasePreview(a);\n\n        // Verify slippage does not exceed the one set by the user\n        if (expected < s) {\n            revert Exception(16, expected, 0, address(0), address(0));\n        }\n\n        // Transfer the underlying tokens to the pool\n        Safe.transferFrom(IERC20(pool.base()), msg.sender, address(pool), a);\n\n        // Execute the swap\n        uint128 received = pool.sellBase(msg.sender, expected);\n\n        emit Swap(u, m, u, address(pool.fyToken()), received, a, msg.sender);\n        return received;\n    }\n\n    /// @notice buys the underlying for the PT via the pool\n    /// @notice determines how many PTs to sell by using the preview\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying to be purchased\n    /// @param s slippage cap, maximum number of PTs that can be sold\n    /// @return uint128 amount of PTs sold\n    function buyUnderlying(\n        address u,\n        uint256 m,\n        uint128 a,\n        uint128 s\n    ) external returns (uint128) {\n        // Get the pool for the market\n        IPool pool = IPool(pools[u][m]);\n\n        // Get the amount of PTs hypothetically required to purchase `a` underlying\n        uint256 expected = pool.buyBasePreview(a);\n\n        // Verify that the amount needed does not exceed the slippage parameter\n        if (expected > s) {\n            revert Exception(16, expected, 0, address(0), address(0));\n        }\n\n        // Transfer the principal tokens to the pool\n        Safe.transferFrom(\n            IERC20(address(pool.fyToken())),\n            msg.sender,\n            address(pool),\n            expected\n        );\n\n        // Execute the swap to purchase `a` underlying tokens\n        uint128 spent = pool.buyBase(msg.sender, a, 0);\n\n        emit Swap(u, m, address(pool.fyToken()), u, a, spent, msg.sender);\n        return spent;\n    }\n\n    /// @notice mint liquidity tokens in exchange for adding underlying and PT\n    /// @dev amount of liquidity tokens to mint is calculated from the amount of unaccounted for PT in this contract.\n    /// @dev A proportional amount of underlying tokens need to be present in this contract, also unaccounted for.\n    /// @param u the address of the underlying token\n    /// @param m the maturity of the principal token\n    /// @param b number of base tokens\n    /// @param p the principal token amount being sent\n    /// @param minRatio minimum ratio of underlying to PT in the pool.\n    /// @param maxRatio maximum ratio of underlying to PT in the pool.\n    /// @return uint256 number of base tokens passed to the method\n    /// @return uint256 number of yield tokens passed to the method\n    /// @return uint256 the amount of tokens minted.\n    function mint(\n        address u,\n        uint256 m,\n        uint256 b,\n        uint256 p,\n        uint256 minRatio,\n        uint256 maxRatio\n    )\n        external\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        // Get the pool for the market\n        IPool pool = IPool(pools[u][m]);\n\n        // Transfer the underlying tokens to the pool\n        Safe.transferFrom(IERC20(pool.base()), msg.sender, address(pool), b);\n\n        // Transfer the principal tokens to the pool\n        Safe.transferFrom(\n            IERC20(address(pool.fyToken())),\n            msg.sender,\n            address(pool),\n            p\n        );\n\n        // Mint the tokens and return the leftover assets to the caller\n        (uint256 underlyingIn, uint256 principalTokensIn, uint256 minted) = pool\n            .mint(msg.sender, msg.sender, minRatio, maxRatio);\n\n        emit Mint(u, m, underlyingIn, principalTokensIn, minted, msg.sender);\n        return (underlyingIn, principalTokensIn, minted);\n    }\n\n    /// @notice Mint liquidity tokens in exchange for adding only underlying\n    /// @dev amount of liquidity tokens is calculated from the amount of PT to buy from the pool,\n    /// plus the amount of unaccounted for PT in this contract.\n    /// @param u the address of the underlying token\n    /// @param m the maturity of the principal token\n    /// @param a the underlying amount being sent\n    /// @param p amount of `PT` being bought in the Pool, from this we calculate how much underlying it will be taken in.\n    /// @param minRatio minimum ratio of underlying to PT in the pool.\n    /// @param maxRatio maximum ratio of underlying to PT in the pool.\n    /// @return uint256 number of base tokens passed to the method\n    /// @return uint256 number of yield tokens passed to the method\n    /// @return uint256 the amount of tokens minted.\n    function mintWithUnderlying(\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 p,\n        uint256 minRatio,\n        uint256 maxRatio\n    )\n        external\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        // Get the pool for the market\n        IPool pool = IPool(pools[u][m]);\n\n        // Transfer the underlying tokens to the pool\n        Safe.transferFrom(IERC20(pool.base()), msg.sender, address(pool), a);\n\n        // Mint the tokens to the user\n        (uint256 underlyingIn, , uint256 minted) = pool.mintWithBase(\n            msg.sender,\n            msg.sender,\n            p,\n            minRatio,\n            maxRatio\n        );\n\n        emit Mint(u, m, underlyingIn, 0, minted, msg.sender);\n        return (underlyingIn, 0, minted);\n    }\n\n    /// @notice burn liquidity tokens in exchange for underlying and PT.\n    /// @param u the address of the underlying token\n    /// @param m the maturity of the principal token\n    /// @param a the amount of liquidity tokens to burn\n    /// @param minRatio minimum ratio of underlying to PT in the pool\n    /// @param maxRatio maximum ratio of underlying to PT in the pool\n    /// @return uint256 amount of LP tokens burned\n    /// @return uint256 amount of base tokens received\n    /// @return uint256 amount of fyTokens received\n    function burn(\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 minRatio,\n        uint256 maxRatio\n    )\n        external\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        // Get the pool for the market\n        IPool pool = IPool(pools[u][m]);\n\n        // Transfer the underlying tokens to the pool\n        Safe.transferFrom(IERC20(address(pool)), msg.sender, address(pool), a);\n\n        // Burn the tokens\n        (\n            uint256 tokensBurned,\n            uint256 underlyingReceived,\n            uint256 principalTokensReceived\n        ) = pool.burn(msg.sender, msg.sender, minRatio, maxRatio);\n\n        emit Burn(\n            u,\n            m,\n            tokensBurned,\n            underlyingReceived,\n            principalTokensReceived,\n            msg.sender\n        );\n        return (tokensBurned, underlyingReceived, principalTokensReceived);\n    }\n\n    /// @notice burn liquidity tokens in exchange for underlying.\n    /// @param u the address of the underlying token\n    /// @param m the maturity of the principal token\n    /// @param a the amount of liquidity tokens to burn\n    /// @param minRatio minimum ratio of underlying to PT in the pool.\n    /// @param maxRatio minimum ratio of underlying to PT in the pool.\n    /// @return uint256 amount of PT tokens sent to the pool\n    /// @return uint256 amount of underlying tokens returned\n    function burnForUnderlying(\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 minRatio,\n        uint256 maxRatio\n    ) external returns (uint256, uint256) {\n        // get the pool for the market\n        IPool pool = IPool(pools[u][m]);\n\n        // transfer the underlying tokens to the pool\n        Safe.transferFrom(IERC20(address(pool)), msg.sender, address(pool), a);\n\n        // burn the tokens in exchange for underlying tokens\n        (uint256 tokensBurned, uint256 underlyingReceived) = pool.burnForBase(\n            msg.sender,\n            minRatio,\n            maxRatio\n        );\n\n        emit Burn(u, m, tokensBurned, underlyingReceived, 0, msg.sender);\n        return (tokensBurned, underlyingReceived);\n    }\n\n    /// @notice provides an interface to receive principal token addresses from markets\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    function token(\n        address u,\n        uint256 m,\n        uint256 p\n    ) external view returns (address) {\n        return markets[u][m][p];\n    }\n\n    /// @notice Allows batched call to self (this contract).\n    /// @param c An array of inputs for each call.\n    function batch(bytes[] calldata c)\n        external\n        payable\n        returns (bytes[] memory results)\n    {\n        results = new bytes[](c.length);\n        for (uint256 i; i < c.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(\n                c[i]\n            );\n            if (!success) revert(RevertMsgExtractor.getRevertMsg(result));\n            results[i] = result;\n        }\n    }\n}"
    },
    {
      "filename": "src/Marketplace.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.16;\n\nimport 'src/tokens/ERC5095.sol';\nimport 'src/lib/Safe.sol';\nimport 'src/lib/RevertMsgExtractor.sol';\n\nimport 'src/interfaces/ILender.sol';\nimport 'src/interfaces/IPool.sol';\nimport 'src/interfaces/IPendleToken.sol';\nimport 'src/interfaces/IAPWineToken.sol';\nimport 'src/interfaces/IAPWineFutureVault.sol';\n\nimport 'src/errors/Exception.sol';\n\n/// @title MarketPlace\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice This contract is in charge of managing the available principals for each loan market.\n/// @notice In addition, this contract routes swap orders between Illuminate PTs and their respective underlying to YieldSpace pools.\ncontract MarketPlace {\n    /// @notice the available principals\n    /// @dev the order of this enum is used to select principals from the markets\n    /// mapping (e.g. Illuminate => 0, Swivel => 1, and so on)\n    enum Principals {\n        Illuminate, // 0\n        Swivel, // 1\n        Yield, // 2\n        Element, // 3\n        Pendle, // 4\n        Tempus, // 5\n        Sense, // 6\n        Apwine, // 7\n        Notional // 8\n    }\n\n    /// @notice markets are defined by a tuple that points to a fixed length array of principal token addresses.\n    mapping(address => mapping(uint256 => address[9])) public markets;\n\n    /// @notice pools map markets to their respective YieldSpace pools for the MetaPrincipal token\n    mapping(address => mapping(uint256 => address)) public pools;\n\n    /// @notice address that is allowed to create markets, set pools, etc. It is commonly used in the authorized modifier.\n    address public admin;\n    /// @notice address of the deployed redeemer contract\n    address public immutable redeemer;\n    /// @notice address of the deployed lender contract\n    address public immutable lender;\n\n    /// @notice emitted upon the creation of a new market\n    event CreateMarket(\n        address indexed underlying,\n        uint256 indexed maturity,\n        address[9] tokens,\n        address element,\n        address apwine\n    );\n    /// @notice emitted upon setting a principal token\n    event SetPrincipal(\n        address indexed underlying,\n        uint256 indexed maturity,\n        address indexed principal,\n        uint8 protocol\n    );\n    /// @notice emitted upon swapping with the pool\n    event Swap(\n        address indexed underlying,\n        uint256 indexed maturity,\n        address sold,\n        address bought,\n        uint256 received,\n        uint256 spent,\n        address spender\n    );\n    /// @notice emitted upon minting tokens with the pool\n    event Mint(\n        address indexed underlying,\n        uint256 indexed maturity,\n        uint256 underlyingIn,\n        uint256 principalTokensIn,\n        uint256 minted,\n        address minter\n    );\n    /// @notice emitted upon burning tokens with the pool\n    event Burn(\n        address indexed underlying,\n        uint256 indexed maturity,\n        uint256 tokensBurned,\n        uint256 underlyingReceived,\n        uint256 principalTokensReceived,\n        address burner\n    );\n    /// @notice emitted upon changing the admin\n    event SetAdmin(address indexed admin);\n    /// @notice emitted upon setting a pool\n    event SetPool(\n        address indexed underlying,\n        uint256 indexed maturity,\n        address indexed pool\n    );\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Exception(0, 0, 0, msg.sender, a);\n        }\n        _;\n    }\n\n    /// @notice initializes the MarketPlace contract\n    /// @param r address of the deployed redeemer contract\n    /// @param l address of the deployed lender contract\n    constructor(address r, address l) {\n        admin = msg.sender;\n        redeemer = r;\n        lender = l;\n    }\n\n    /// @notice creates a new market for the given underlying token and maturity\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param t principal token addresses for this market\n    /// @param n name for the Illuminate token\n    /// @param s symbol for the Illuminate token\n    /// @param e address of the Element vault that corresponds to this market\n    /// @param a address of the APWine router that corresponds to this market\n    /// @return bool true if successful\n    function createMarket(\n        address u,\n        uint256 m,\n        address[8] calldata t,\n        string calldata n,\n        string calldata s,\n        address e,\n        address a\n    ) external authorized(admin) returns (bool) {\n        {\n            // Get the Illuminate principal token for this market (if one exists)\n            address illuminate = markets[u][m][\n                (uint256(Principals.Illuminate))\n            ];\n\n            // If illuminate PT already exists, a new market cannot be created\n            if (illuminate != address(0)) {\n                revert Exception(9, 0, 0, illuminate, address(0));\n            }\n        }\n\n        // Create an Illuminate principal token for the new market\n        address illuminateToken = address(\n            new ERC5095(\n                u,\n                m,\n                redeemer,\n                lender,\n                address(this),\n                n,\n                s,\n                IERC20(u).decimals()\n            )\n        );\n\n        {\n            // create the principal tokens array\n            address[9] memory market = [\n                illuminateToken, // Illuminate\n                t[0], // Swivel\n                t[1], // Yield\n                t[2], // Element\n                t[3], // Pendle\n                t[4], // Tempus\n                t[5], // Sense\n                t[6], // APWine\n                t[7] // Notional\n            ];\n\n            // Set the market\n            markets[u][m] = market;\n\n            // Have the lender contract approve the several contracts\n            ILender(lender).approve(u, e, a, t[7]);\n\n            // Have the redeemer contract approve the Pendle principal token\n            if (t[3] != address(0)) {\n                address underlyingYieldToken = IPendleToken(t[3])\n                    .underlyingYieldToken();\n                IRedeemer(redeemer).approve(underlyingYieldToken);\n            }\n\n            if (t[6] != address(0)) {\n                address futureVault = IAPWineToken(t[6]).futureVault();\n                address interestBearingToken = IAPWineFutureVault(futureVault)\n                    .getIBTAddress();\n                IRedeemer(redeemer).approve(interestBearingToken);\n            }\n\n            emit CreateMarket(u, m, market, e, a);\n        }\n        return true;\n    }\n\n    /// @notice allows the admin to set an individual market\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a address of the new principal token\n    /// @return bool true if the principal set, false otherwise\n    function setPrincipal(\n        uint8 p,\n        address u,\n        uint256 m,\n        address a\n    ) external authorized(admin) returns (bool) {\n        // Get the current principal token for the principal token being set\n        address market = markets[u][m][p];\n\n        // Verify that it has not already been set\n        if (market != address(0)) {\n            revert Exception(9, 0, 0, market, address(0));\n        }\n\n        // Set the principal token in the markets mapping\n        markets[u][m][p] = a;\n\n        if (p == uint8(Principals.Pendle)) {\n            // Principal token must be approved for Pendle's redeem\n            address underlyingYieldToken = IPendleToken(a)\n                .underlyingYieldToken();\n            IRedeemer(redeemer).approve(underlyingYieldToken);\n        } else if (p == uint8(Principals.Apwine)) {\n            address futureVault = IAPWineToken(a).futureVault();\n            address interestBearingToken = IAPWineFutureVault(futureVault)\n                .getIBTAddress();\n            IRedeemer(redeemer).approve(interestBearingToken);\n        } else if (p == uint8(Principals.Notional)) {\n            // Principal token must be approved for Notional's lend\n            ILender(lender).approve(address(0), address(0), address(0), a);\n        }\n\n        emit SetPrincipal(u, m, a, p);\n        return true;\n    }\n\n    /// @notice sets the admin address\n    /// @param a Address of a new admin\n    /// @return bool true if the admin set, false otherwise\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        emit SetAdmin(a);\n        return true;\n    }\n\n    /// @notice sets the address for a pool\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a address of the pool\n    /// @return bool true if the pool set, false otherwise\n    function setPool(\n        address u,\n        uint256 m,\n        address a\n    ) external authorized(admin) returns (bool) {\n        // Verify that the pool has not already been set\n        address pool = pools[u][m];\n\n        // Revert if the pool already exists\n        if (pool != address(0)) {\n            revert Exception(10, 0, 0, pool, address(0));\n        }\n\n        // Set the pool\n        pools[u][m] = a;\n\n        emit SetPool(u, m, a);\n        return true;\n    }\n\n    /// @notice sells the PT for the underlying via the pool\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of PTs to sell\n    /// @param s slippage cap, minimum amount of underlying that must be received\n    /// @return uint128 amount of underlying bought\n    function sellPrincipalToken(\n        address u,\n        uint256 m,\n        uint128 a,\n        uint128 s\n    ) external returns (uint128) {\n        // Get the pool for the market\n        IPool pool = IPool(pools[u][m]);\n\n        // Preview amount of underlying received by selling `a` PTs\n        uint256 expected = pool.sellFYTokenPreview(a);\n\n        if (expected < s) {\n            revert Exception(16, expected, s, address(0), address(0));\n        }\n\n        // Transfer the principal tokens to the pool\n        Safe.transferFrom(\n            IERC20(address(pool.fyToken())),\n            msg.sender,\n            address(pool),\n            a\n        );\n\n        // Execute the swap\n        uint128 received = pool.sellFYToken(msg.sender, uint128(expected));\n        emit Swap(u, m, address(pool.fyToken()), u, received, a, msg.sender);\n\n        return received;\n    }\n\n    /// @notice buys the PT for the underlying via the"
    }
  ]
}