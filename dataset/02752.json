{
  "Title": "M-1: [Tomo-M3] Use safeMint instead of mint for ERC721",
  "Content": "# Issue M-1: [Tomo-M3] Use safeMint instead of mint for ERC721 \n\nSource: https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/65 \n\n## Found by \nTomo\n\n## Summary\n\nUse safeMint instead of mint for ERC721\n\n## Vulnerability Detail\n\nThe `msg.sender` will be minted as a proof of staking NFT when `_stakeToken()` is called. \n\nHowever, if `msg.sender` is a contract address that does not support ERC721, the NFT can be frozen in the contract.\n\nAs per the documentation of EIP-721:\n\n> A wallet/broker/auction application MUST implement the wallet interface if it will accept safe transfers.\n> \n\nRef: [https://eips.ethereum.org/EIPS/eip-721](https://eips.ethereum.org/EIPS/eip-721)\n\nAs per the documentation of ERC721.sol by Openzeppelin\n\nRef: [https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L274-L285](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L274-L285)\n\n```solidity\n/**\n * @dev Mints `tokenId` and transfers it to `to`.\n *\n * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n *\n * Requirements:\n *\n * - `tokenId` must not exist.\n * - `to` cannot be the zero address.\n *\n * Emits a {Transfer} event.\n */\nfunction _mint(address to, uint256 tokenId) internal virtual {\n```\n\n## Impact\n\nUsers possibly lose their NFTs\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-11-frankendao/blob/main/src/Staking.sol#L411\n``` solidity\n  _mint(msg.sender, _tokenId);\n```\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse `safeMint` instead of `mint` to check received address support for ERC721 implementation.\n\n[https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L262](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L262)\n\n## Discussion\n\n**zobront**\n\nI might consider this a duplicate of #55 but not sure how this is usually judged. We will be changing this function based on other issues to not allow \"approved\" spenders, so msg.sender will be the owner of the FrankenPunk, which ensures they are able to hold NFTs.\n\n**zobront**\n\nFixed: https://github.com/Solidity-Guild/FrankenDAO/pull/14\n\nI didn't need to add safeMint, as I made a change for another issue that removed the ability to non holder to unstake, which means they have the ability to hold NFTs.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/18",
  "Code": [
    {
      "filename": "contracts/token/ERC721/ERC721.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"./IERC721.sol\";\nimport {IERC721Metadata} from \"./extensions/IERC721Metadata.sol\";\nimport {ERC721Utils} from \"./utils/ERC721Utils.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {Strings} from \"../../utils/Strings.sol\";\nimport {IERC165, ERC165} from \"../../utils/introspection/ERC165.sol\";\nimport {IERC721Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC-721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\nabstract contract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Errors {\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    mapping(uint256 tokenId => address) private _owners;\n\n    mapping(address owner => uint256) private _balances;\n\n    mapping(uint256 tokenId => address) private _tokenApprovals;\n\n    mapping(address owner => mapping(address operator => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n\n        return _getApproved(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        // Setting an \"auth\" arguments enables the `_isAuthorized` check which verifies that the token exists\n        // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        ERC721Utils.checkOnERC721Received(_msgSender(), from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     *\n     * IMPORTANT: Any overrides to this function that add ownership of tokens not tracked by the\n     * core ERC-721 logic MUST be matched with the use of {_increaseBalance} to keep balances\n     * consistent with ownership. The invariant to preserve is that for any address `a` the value returned by\n     * `balanceOf(a)` must be equal to the number of tokens such that `_ownerOf(tokenId)` is `a`.\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns the approved address for `tokenId`. Returns 0 if `tokenId` is not minted.\n     */\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `owner`'s tokens, or `tokenId` in\n     * particular (ignoring whether it is owned by `owner`).\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Checks if `spender` can operate on `tokenId`, assuming the provided `owner` is the actual owner.\n     * Reverts if:\n     * - `spender` does not have approval from `owner` for `tokenId`.\n     * - `spender` does not have approval to manage all of `owner`'s assets.\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * NOTE: the value is limited to type(uint128).max. This protect against _balance overflow. It is unrealistic that\n     * a uint256 would ever overflow from increments when these increments are bounded to uint128 values.\n     *\n     * WARNING: Increasing an account's balance using this function tends to be paired with an override of the\n     * {_ownerOf} function to resolve the ownership of the corresponding tokens so that balances and ownership\n     * remain consistent with one another.\n     */\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        unchecked {\n            _balances[account] += value;\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from its current owner to `to`, or alternatively mints (or burns) if the current owner\n     * (or `to`) is the zero address. Returns the owner of the `tokenId` before the update.\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that\n     * `auth` is either the owner of the token, or approved to operate on the token (by the owner).\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: If overriding this function in a way that tracks balances, see also {_increaseBalance}.\n     */\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n\n    /**\n     * @dev Mints `tokenId`, transfers it to `to` and checks for `to` acceptance.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        ERC721Utils.checkOnERC721Received(_msgSender(), address(0), to, tokenId, data);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking that contract recipients\n     * are aware of the ERC-721 standard to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is like {safeTransferFrom} in the sense that it invokes\n     * {IERC721Receiver-onERC721Received} on the receiver, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `tokenId` token must exist and be owned by `from`.\n     * - `to` cannot be the zero address.\n     * - `from` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeTransfer-address-address-uint256-}[`_safeTransfer`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        ERC721Utils.checkOnERC721Received(_msgSender(), from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that `auth` is\n     * either the owner of the token, or approved to operate on all tokens held by this owner.\n     *\n     * Emits an {Approval} event.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n\n    /**\n     * @dev Variant of `_approve` with an optional flag to enable or disable the {Approval} event. The event is not\n     * emitted in the context of transfers.\n     */\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Requirements:\n     * - operator can't be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` doesn't have a current owner (it hasn't been minted, or it has been burned).\n     * Returns the owner.\n     *\n     * Overrides to ownership logic should be done to {_ownerOf}.\n     */\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n}"
    },
    {
      "filename": "src/Staking.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/**\n _______  _______  _______  _        _        _______  _          _______           _        _        _______\n(  ____ \\(  ____ )(  ___  )( (    /|| \\    /\\(  ____ \\( (    /|  (  ____ )|\\     /|( (    /|| \\    /\\(  ____ \\\n| (    \\/| (    )|| (   ) ||  \\  ( ||  \\  / /| (    \\/|  \\  ( |  | (    )|| )   ( ||  \\  ( ||  \\  / /| (    \\/\n| (__    | (____)|| (___) ||   \\ | ||  (_/ / | (__    |   \\ | |  | (____)|| |   | ||   \\ | ||  (_/ / | (_____\n|  __)   |     __)|  ___  || (\\ \\) ||   _ (  |  __)   | (\\ \\) |  |  _____)| |   | || (\\ \\) ||   _ (  (_____  )\n| (      | (\\ (   | (   ) || | \\   ||  ( \\ \\ | (      | | \\   |  | (      | |   | || | \\   ||  ( \\ \\       ) |\n| )      | ) \\ \\__| )   ( || )  \\  ||  /  \\ \\| (____/\\| )  \\  |  | )      | (___) || )  \\  ||  /  \\ \\/\\____) |\n|/       |/   \\__/|/     \\||/    )_)|_/    \\/(_______/|/    )_)  |/       (_______)|/    )_)|_/    \\/\\_______)\n\n*/\n\nimport \"solmate/tokens/ERC721.sol\";\nimport \"solmate/utils/LibString.sol\";\nimport \"./utils/SafeCast.sol\";\nimport \"./utils/Refundable.sol\";\nimport \"./utils/Admin.sol\";\n\nimport \"./interfaces/IERC721.sol\";\nimport \"./interfaces/IStaking.sol\";\nimport \"./interfaces/IGovernance.sol\";\nimport \"./interfaces/IExecutor.sol\";\n\n/// @title FrankenDAO Staking\n/// @author Zach Obront & Zakk Fleischmann\n/// @notice Users stake FrankenPunks & FrankenMonsters and get ERC721s in return\n/// @notice These ERC721s are used for voting power for FrankenDAO governance\ncontract Staking is IStaking, ERC721, Admin, Refundable {\n  using LibString for uint256;\n\n  /// @notice The original ERC721 FrankenPunks contract\n  IERC721 frankenpunks;\n  \n  /// @notice The original ERC721 FrankenMonsters contract\n  IERC721 frankenmonsters;\n\n  /// @notice The DAO governance contract (where voting occurs)\n  IGovernance governance;\n\n  /// @return maxStakeBonusTime The maxmimum time you will earn bonus votes for staking for\n  /// @return maxStakeBonusAmount The amount of bonus votes you'll get if you stake for the max time\n  StakingSettings public stakingSettings;\n\n  /// @notice Multipliers (expressed as percentage) for calculating community voting power from user stats\n  /// @return votes The multiplier for extra voting power earned per DAO vote cast\n  /// @return proposalsCreated The multiplier for extra voting power earned per proposal created\n  /// @return proposalsPassed The multiplier for extra voting power earned per proposal passed\n  CommunityPowerMultipliers public communityPowerMultipliers;\n\n  /// @notice Constant to calculate voting power based on multipliers above\n  uint constant PERCENT = 100;\n\n  /// @notice Are refunds turned on for staking?\n  bool public stakingRefund;\n\n  /// @notice The last timestamp at which a user used their staking refund\n  mapping(address => uint256) public lastStakingRefund;\n\n  /// @notice Are refunds turned on for delegating?\n  bool public delegatingRefund;\n\n  /// @notice The last timestamp at which a user used their delegating refund\n  mapping(address => uint256) public lastDelegatingRefund;\n\n  /// @notice How often can a user use their refund?\n  uint256 public refundCooldown;\n\n  /// @notice Is staking currently paused or open?\n  bool public paused;\n\n  /// @notice Base votes for holding a Frankenpunk token\n  uint public baseVotes;\n\n  /// @notice The staked time bonus for each staked token (tokenId => bonus votes)\n  /// @dev This needs to be tracked because users will select how much time to lock for, so bonus is variable\n  mapping(uint => uint) stakedTimeBonus; \n  \n  /// @notice The allowed unlock time for each staked token (tokenId => timestamp)\n  /// @dev This remains at 0 if tokens are staked without locking\n  mapping(uint => uint) public unlockTime;\n\n  /// @notice Multiplier for votes that Frankenmonsters earn, relative to Frankenpunks\n  /// @dev Expressed as a percentage (ie punk votes * monsterMultiplier / 100 = monster votes)\n  uint public monsterMultiplier;\n\n  /// @notice Addresses that each user delegates votes to\n  /// @dev This should only be accessed via getDelegate() function, which overrides address(0) with self\n  mapping(address => address) private _delegates;\n\n  /// @notice The total voting power earned by each user's staked tokens\n  /// @dev In other words, this is the amount of voting power that would move if they redelegated\n  /// @dev They don't necessarily have this many votes, because they may have delegated them\n  mapping(address => uint) public votesFromOwnedTokens;\n\n  /// @notice The total voting power each user has, after adjusting for delegation\n  /// @dev This represents the actual token voting power of each user\n  mapping(address => uint) public tokenVotingPower;\n\n  /// @notice The total token voting power of the system\n  uint totalTokenVotingPower;\n\n  /// @notice Base token URI for the ERC721s representing the staked position\n  string public baseTokenURI;\n\n  /// @notice The total supply of staked frankenpunks\n  uint128 public stakedFrankenPunks;\n\n  /// @notice The total supply of staked frankenmonsters\n  uint128 public stakedFrankenMonsters;\n\n  /// @notice Bitmaps representing whether each FrankenPunk has a sufficient \"evil score\" for a bonus.\n  /// @dev 40 words * 256 bits = 10,240 bits, which is sufficient to hold values for 10k FrankenPunks\n  uint[40] EVIL_BITMAPS = [\n    883425322698150530263834307704826599123904599330160270537777278655401984, // 0\n    14488147225470816109160058996749687396265978336526515174837584423109802852352, // 1\n    38566513062215815139428642218823858442255833421860837338906624, // 2\n    105312291668557186697918027683670432324476705909712387428719788032, // 3\n    14474011154664524427946373126085988481660077311200856629730921422678596263936, // 4\n    3618502788692465607655909614339766499850336868450542774889103259212619972609, // 5\n    441711772776714745308416192199486840791445460561420424832198410539892736, // 6\n    6901746759773641161995257390185172072446268286034776944761674561224712, // 7\n    883423532414903565819785182543377466397133986207912949084155019599544320, // 8\n    14474011155086185177904289442148664541270784730116237084843513087002589265920, // 9\n    107839786668798718607898896909541540930351713584408019687362806153216, // 10\n    904625700641838402593673198335004289144275540958779302917589231213362556944, // 11\n    220859253090631447287862539909960206022391538433640386622889848771706880, // 12\n    1393839110204029063653915313866451565150208, // 13\n    784637716923340670665773318162647287385528792673206407169, // 14\n    107839786668602559178668060353525740564723109496935832847049186869248, // 15\n    51422802054004612152481822571560984362335820545231474237898784, // 16\n    6582018229284824169333500576582381960460086447259084614308728832, // 17\n    365732221255902219560809532335122355265736818688, // 18\n    445162639419413381705829464770174011933371831432841644599383048677490688, // 19\n    6935446280124502090171244984389489167294584349705235353545399909482504, // 20\n    452312848583266388373372050675839373643513806386188657447441353755011973120, // 21\n    51422023594160337932957247212003666383914706547133656225284128, // 22\n    2923003274661805998666646494941077336069228208128, // 23\n    215679573337205118357336126271343355406346657833909405071980653182976, // 24\n    26959946667150639794667015087041235820865508444839585222888876146720, // 25\n    3731581108651760187459529718884681603688140590625042088037390915407571845120, // 26\n    33372889303170710042455474178259135664197736114694375141005066752, // 27\n    28948022309329151699928351061631107912622119818910282538292189430411643863044, // 28\n    55214023430470347690952963241066788995217469738067023806554216123598848, // 29\n    55213971185700649632772712790212230970723509677757939395778641765335297, // 30\n    50216813883139118038214077107913983031541181002059654103040, // 31\n    45671926166601100787582220677640905906662146176, // 32\n    431359146674410260659915067596052074490887103277477952745659311325184, // 33\n    6741683593362397442763285474207733540211166501858783908538903166976, // 34\n    421249166674235107246797774824181756792478284093098635821743865856, // 35\n    53919893334350319447007114026840783409769671338355940037889148190720, // 36\n    401740641047276407850947922339698016834483256774579142524928, // 37\n    220855883097304318299647574273628650268020954052697685772267193358090240, // 38\n    0 // 39\n  ];\n\n  /////////////////////////////////\n  /////////// MODIFIERS ///////////\n  /////////////////////////////////\n\n  /// @dev To avoid needing to checkpoint voting power, tokens are locked while users have active votes cast or proposals open\n  /// @dev If a user creates a proposal or casts a vote, this modifier prevents them from unstaking or delegating\n  /// @dev Once the proposal is completed, it is removed from getActiveProposals and their tokens are unlocked\n  modifier lockedWhileVotesCast() {\n    uint[] memory activeProposals = governance.getActiveProposals();\n    for (uint i = 0; i < activeProposals.length; i++) {\n      if (governance.getReceipt(activeProposals[i], getDelegate(msg.sender)).hasVoted) revert TokenLocked();\n      (, address proposer,) = governance.getProposalData(activeProposals[i]);\n      if (proposer == getDelegate(msg.sender)) revert TokenLocked();\n    }\n    _;\n  }\n\n  /////////////////////////////////\n  ////////// CONSTRUCTOR //////////\n  /////////////////////////////////\n\n  /// @param _frankenpunks The address of the original ERC721 FrankenPunks contract\n  /// @param _frankenmonsters The address of the original ERC721 FrankenMonsters contract\n  /// @param _governance The address of the DAO governance contract\n  /// @param _executor The address of the DAO executor contract\n  /// @param _founders The address of the founder multisig for restricted functions\n  /// @param _council The address of the council multisig for restricted functions\n  constructor(\n    address _frankenpunks, \n    address _frankenmonsters,\n    address _governance, \n    address _executor, \n    address _founders,\n    address _council,\n    string memory _baseTokenURI\n  ) ERC721(\"Staked FrankenPunks\", \"sFP\") {\n    frankenpunks = IERC721(_frankenpunks);\n    frankenmonsters = IERC721(_frankenmonsters);\n    governance = IGovernance( _governance );\n\n    executor = IExecutor(_executor);\n    founders = _founders;\n    council = _council;\n\n    baseVotes = 20; // Base votes for a staked token\n    monsterMultiplier = 50; // Monsters are worth 50% of Punks\n\n    // Staking bonus increases linearly from 0 to 20 votes over 4 weeks\n    stakingSettings = StakingSettings({\n      maxStakeBonusTime: uint128(4 weeks), \n      maxStakeBonusAmount: uint128(20)\n    });\n\n    // Users get a bonus 1 vote per vote, 2 votes per proposal created, and 2 votes per proposal passed\n    communityPowerMultipliers = CommunityPowerMultipliers({\n      votes: uint64(100), \n      proposalsCreated: uint64(200),\n      proposalsPassed: uint64(200)\n    });\n\n    // Refunds are initially turned on with 1 day cooldown.\n    delegatingRefund = true;\n    stakingRefund = true;\n    refundCooldown = 1 days;\n\n    // Set the base token URI.\n    baseTokenURI = _baseTokenURI;\n  }\n\n  /////////////////////////////////\n  // OVERRIDE & REVERT TRANSFERS //\n  /////////////////////////////////  \n\n  /// @notice Transferring of staked tokens is prohibited, so all transfers will revert\n  /// @dev This will also block safeTransferFrom, because of solmate's implementation\n  function transferFrom(address, address, uint256) public pure override(ERC721) {\n    revert StakedTokensCannotBeTransferred();\n  }\n\n  /////////////////////////////////\n  /////// TOKEN URI FUNCTIONS /////\n  /////////////////////////////////\n\n  /// @notice Token URI to find metadata for each tokenId\n  /// @dev The metadata will be a variation on the metadata of the underlying token\n  function tokenURI(uint256 _tokenId) public view virtual override(ERC721) returns (string memory) {\n    if (ownerOf(_tokenId) == address(0)) revert NonExistentToken();\n\n    string memory baseURI = baseTokenURI;\n    return bytes(baseURI).length > 0\n      ? string(abi.encodePacked(baseURI, _tokenId.toString(), \".json\"))\n      : \"\";\n  }\n  \n  /////////////////////////////////\n  /////// DELEGATION LOGIC ////////\n  /////////////////////////////////\n\n  /// @notice Return the address that a given address delegates to\n  /// @param _delegator The address to check \n  /// @return The address that the delegator has delegated to\n  /// @dev If the delegator has not delegated, this function will return their own address\n  function getDelegate(address _delegator) public view returns (address) {\n    address current = _delegates[_delegator];\n    return current == address(0) ? _delegator : current;\n  }\n\n  /// @notice Delegate votes to another address\n  /// @param _delegatee The address you wish to delegate to\n  /// @dev Refunds gas if delegatingRefund is true and hasn't been used by this user in the past 24 hours\n  function delegate(address _delegatee) public {\n    if (_delegatee == address(0)) _delegatee = msg.sender;\n    \n    // Refunds gas if delegatingRefund is true and hasn't been used by this user in the past 24 hours\n    if (delegatingRefund && lastDelegatingRefund[msg.sender] + refundCooldown <= block.timestamp) {\n      uint256 startGas = gasleft();\n      _delegate(msg.sender, _delegatee);\n      lastDelegatingRefund[msg.sender] = block.timestamp;\n      _refundGas(startGas);\n    } else {\n      _delegate(msg.sender, _delegatee);\n    }\n  }\n\n  /// @notice Delegates votes from the sender to the delegatee\n  /// @param _delegator The address of the user who called the function and owns the votes being delegated\n  /// @param _delegatee The address of the user who will receive the votes\n  function _delegate(address _delegator, address _delegatee) internal lockedWhileVotesCast {\n    address currentDelegate = getDelegate(_delegator);\n    // If currentDelegate == _delegatee, then this function will not do anything\n    if (currentDelegate == _delegatee) revert InvalidDelegation();\n\n    // Set the _delegates mapping to the correct address, subbing in address(0) if they are delegating to themselves\n    _delegates[_delegator] = _delegatee == _delegator ? address(0) : _delegatee;\n    uint amount = votesFromOwnedTokens[_delegator];\n\n    // If the delegator has no votes, then this function will not do anything\n    // This is explicitly blocked to ensure that users without votes cannot abuse the refund mechanism\n    if (amount == 0) revert InvalidDelegation();\n    \n    // Move the votes from the currentDelegate to the new delegatee\n    // Neither of these addresses can be address(0) because: \n    // - currentDelegate calls getDelegate(), which replaces address(0) with the delegator's address\n    // - delegatee is changed to msg.sender in the external functions if address(0) is passed\n    tokenVotingPower[currentDelegate] -= amount;\n    tokenVotingPower[_delegatee] += amount; \n\n    // If a user is delegating back to themselves, they regain their community voting power, so adjust totals up\n    if (_delegator == _delegatee) {\n      _updateTotalCommunityVotingPower(_delegator, true);\n\n    // If a user delegates away their votes, they forfeit their community voting power, so adjust totals down\n    } else if (currentDelegate == _delegator) {\n      _updateTotalCommunityVotingPower(_delegator, false);\n    }\n\n    emit DelegateChanged(_delegator, currentDelegate, _delegatee);\n  }\n\n  /// @notice Updates the total community voting power totals\n  /// @param _delegator The address of the user who called the function and owns the votes being delegated\n  /// @param _increase Should we be increasing or decreasing the totals?\n  /// @dev This function is called by _delegate, _stake, and _unstake\n  function _updateTotalCommunityVotingPower(address _delegator, bool _increase) internal {\n    (uint64 votes, uint64 proposalsCreated, uint64 proposalsPassed) = governance.userCommunityScoreData(_delegator);\n    (uint64 totalVotes, uint64 totalProposalsCreated, uint64 totalProposalsPassed) = governance.totalCommunityScoreData();\n\n    if (_increase) {\n      governance.updateTotalCommunityScoreData(totalVotes + votes, totalProposalsCreated + proposalsCreated, totalProposalsPassed + pr"
    }
  ]
}