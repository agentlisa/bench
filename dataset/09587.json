{
  "Title": "[L-05] `tokenURI()` reverts for tokens that don't implement `IERC20Metadata`",
  "Content": "\nWhile the ticket descriptors are not in scope, the code calling them is. `NFTLoanTicket.tokenURI()`, which is in scope, ends up calling descriptor code which casts the asset to `IERC20Metadata`. This interface is separate from `IERC20` because EIP-20 does not require those functions to exist. If a valid ERC20 token does not implement this interface, casting it and attempting to call non-existant functions will cause the code to revert, which will cause `tokenURI()` to revert.\n\n[PopulateSVGParams.sol#L65](https://github.com/code-423n4/2022-04-backed/blob/d34ddbdaf8d1bc1bf17446df830db629ee551308/contracts/descriptors/libraries/PopulateSVGParams.sol#L65)<br>\n[PopulateSVGParams.sol#L69](https://github.com/code-423n4/2022-04-backed/blob/d34ddbdaf8d1bc1bf17446df830db629ee551308/contracts/descriptors/libraries/PopulateSVGParams.sol#L69)<br>\n[PopulateSVGParams.sol#L83](https://github.com/code-423n4/2022-04-backed/blob/d34ddbdaf8d1bc1bf17446df830db629ee551308/contracts/descriptors/libraries/PopulateSVGParams.sol#L83)<br>\n\nUse [`safeDecimals()`](https://github.com/boringcrypto/BoringSolidity/blob/ccb743d4c3363ca37491b87c6c9b24b1f5fa25dc/contracts/libraries/BoringERC20.sol#L33-L55) etc\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-04-backed-protocol-contest",
  "Code": [
    {
      "filename": "contracts/descriptors/libraries/PopulateSVGParams.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\nimport './BokkyPooBahsDateTimeLibrary.sol';\nimport './UintStrings.sol';\nimport '../../NFTLoanFacilitator.sol';\nimport '../../interfaces/IERC20Metadata.sol';\nimport './HexStrings.sol';\nimport './NFTLoanTicketSVG.sol';\n\n\nlibrary PopulateSVGParams{\n    /**\n     * @notice Populates and returns the passed `svgParams` with loan info retrieved from\n     * `nftLoanFacilitator` for `id`, the loan id\n     * @param svgParams The svg params to populate, which already has `nftType` populated from NFTLoansTicketDescriptor\n     * @param nftLoanFacilitator The loan facilitator contract to get loan info from for loan `id`\n     * @param id The id of the loan\n     * @return `svgParams`, with all values now populated\n     */\n    function populate(NFTLoanTicketSVG.SVGParams memory svgParams, NFTLoanFacilitator nftLoanFacilitator, uint256 id)\n        internal\n        view\n        returns (NFTLoanTicketSVG.SVGParams memory)\n    {\n        (bool closed, uint256 perAnumInterestRate,\n        uint256 durationSeconds, uint256 lastAccumulatedTimestamp,\n        address collateralAddress, address loanAsset, ,\n        uint256 loanAmount, uint256 collateralID) = nftLoanFacilitator.loanInfo(id);\n\n        svgParams.id = Strings.toString(id);\n        svgParams.status = loanStatus(lastAccumulatedTimestamp, durationSeconds, closed);\n        svgParams.interestRate = interestRateString(nftLoanFacilitator, perAnumInterestRate); \n        svgParams.loanAssetContract = HexStrings.toHexString(uint160(loanAsset), 20);\n        svgParams.loanAssetSymbol = loanAssetSymbol(loanAsset);\n        svgParams.collateralContract = HexStrings.toHexString(uint160(collateralAddress), 20);\n        svgParams.collateralContractPartial = HexStrings.partialHexString(uint160(collateralAddress), 10, 40);\n        svgParams.collateralAssetSymbol = collateralAssetSymbol(collateralAddress);\n        svgParams.collateralId = Strings.toString(collateralID);\n        svgParams.loanAmount = loanAmountString(loanAmount, loanAsset);\n        svgParams.interestAccrued = accruedInterest(nftLoanFacilitator, id, loanAsset);\n        svgParams.durationDays = Strings.toString(durationSeconds / (24 * 60 * 60));\n        svgParams.endDateTime = lastAccumulatedTimestamp == 0 ? \"n/a\" \n        : endDateTime(lastAccumulatedTimestamp + durationSeconds);\n        \n        return svgParams;\n    }\n\n    function interestRateString(NFTLoanFacilitator nftLoanFacilitator, uint256 perAnumInterestRate) \n        private \n        view \n        returns (string memory)\n    {\n        return UintStrings.decimalString(\n            perAnumInterestRate,\n            nftLoanFacilitator.INTEREST_RATE_DECIMALS() - 2,\n            true\n            );\n    }\n\n    function loanAmountString(uint256 amount, address asset) private view returns (string memory) {\n        return UintStrings.decimalString(amount, IERC20Metadata(asset).decimals(), false);\n    }\n\n    function loanAssetSymbol(address asset) private view returns (string memory) {\n        return IERC20Metadata(asset).symbol();\n    }\n\n    function collateralAssetSymbol(address asset) private view returns (string memory) {\n        return ERC721(asset).symbol();\n    }\n\n    function accruedInterest(NFTLoanFacilitator nftLoanFacilitator, uint256 loanId, address loanAsset) \n        private \n        view \n        returns (string memory)\n    {\n        return UintStrings.decimalString(\n            nftLoanFacilitator.interestOwed(loanId),\n            IERC20Metadata(loanAsset).decimals(),\n            false);\n    }\n\n    function loanStatus(uint256 lastAccumulatedTimestamp, uint256 durationSeconds, bool closed) \n        view \n        private \n        returns (string memory)\n    {\n        if (lastAccumulatedTimestamp == 0) return \"awaiting lender\";\n\n        if (closed) return \"closed\";\n\n        if (block.timestamp > (lastAccumulatedTimestamp + durationSeconds)) return \"past due\";\n\n        return \"accruing interest\";\n    }\n\n    /** \n     * @param endDateSeconds The unix seconds timestamp of the loan end date\n     * @return a string representation of the UTC end date and time of the loan,\n     * in format YYYY-MM-DD HH:MM:SS\n     */\n    function endDateTime(uint256 endDateSeconds) private pure returns (string memory) {\n        (uint year, uint month, \n        uint day, uint hour, \n        uint minute, uint second) = BokkyPooBahsDateTimeLibrary.timestampToDateTime(endDateSeconds);\n        return string.concat(\n                Strings.toString(year),\n                '-',\n                Strings.toString(month),\n                '-',\n                Strings.toString(day),\n                ' ',\n                Strings.toString(hour),\n                ':',\n                Strings.toString(minute),\n                ':',\n                Strings.toString(second),\n                ' UTC'\n        );\n    } \n}"
    },
    {
      "filename": "contracts/descriptors/libraries/PopulateSVGParams.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\nimport './BokkyPooBahsDateTimeLibrary.sol';\nimport './UintStrings.sol';\nimport '../../NFTLoanFacilitator.sol';\nimport '../../interfaces/IERC20Metadata.sol';\nimport './HexStrings.sol';\nimport './NFTLoanTicketSVG.sol';\n\n\nlibrary PopulateSVGParams{\n    /**\n     * @notice Populates and returns the passed `svgParams` with loan info retrieved from\n     * `nftLoanFacilitator` for `id`, the loan id\n     * @param svgParams The svg params to populate, which already has `nftType` populated from NFTLoansTicketDescriptor\n     * @param nftLoanFacilitator The loan facilitator contract to get loan info from for loan `id`\n     * @param id The id of the loan\n     * @return `svgParams`, with all values now populated\n     */\n    function populate(NFTLoanTicketSVG.SVGParams memory svgParams, NFTLoanFacilitator nftLoanFacilitator, uint256 id)\n        internal\n        view\n        returns (NFTLoanTicketSVG.SVGParams memory)\n    {\n        (bool closed, uint256 perAnumInterestRate,\n        uint256 durationSeconds, uint256 lastAccumulatedTimestamp,\n        address collateralAddress, address loanAsset, ,\n        uint256 loanAmount, uint256 collateralID) = nftLoanFacilitator.loanInfo(id);\n\n        svgParams.id = Strings.toString(id);\n        svgParams.status = loanStatus(lastAccumulatedTimestamp, durationSeconds, closed);\n        svgParams.interestRate = interestRateString(nftLoanFacilitator, perAnumInterestRate); \n        svgParams.loanAssetContract = HexStrings.toHexString(uint160(loanAsset), 20);\n        svgParams.loanAssetSymbol = loanAssetSymbol(loanAsset);\n        svgParams.collateralContract = HexStrings.toHexString(uint160(collateralAddress), 20);\n        svgParams.collateralContractPartial = HexStrings.partialHexString(uint160(collateralAddress), 10, 40);\n        svgParams.collateralAssetSymbol = collateralAssetSymbol(collateralAddress);\n        svgParams.collateralId = Strings.toString(collateralID);\n        svgParams.loanAmount = loanAmountString(loanAmount, loanAsset);\n        svgParams.interestAccrued = accruedInterest(nftLoanFacilitator, id, loanAsset);\n        svgParams.durationDays = Strings.toString(durationSeconds / (24 * 60 * 60));\n        svgParams.endDateTime = lastAccumulatedTimestamp == 0 ? \"n/a\" \n        : endDateTime(lastAccumulatedTimestamp + durationSeconds);\n        \n        return svgParams;\n    }\n\n    function interestRateString(NFTLoanFacilitator nftLoanFacilitator, uint256 perAnumInterestRate) \n        private \n        view \n        returns (string memory)\n    {\n        return UintStrings.decimalString(\n            perAnumInterestRate,\n            nftLoanFacilitator.INTEREST_RATE_DECIMALS() - 2,\n            true\n            );\n    }\n\n    function loanAmountString(uint256 amount, address asset) private view returns (string memory) {\n        return UintStrings.decimalString(amount, IERC20Metadata(asset).decimals(), false);\n    }\n\n    function loanAssetSymbol(address asset) private view returns (string memory) {\n        return IERC20Metadata(asset).symbol();\n    }\n\n    function collateralAssetSymbol(address asset) private view returns (string memory) {\n        return ERC721(asset).symbol();\n    }\n\n    function accruedInterest(NFTLoanFacilitator nftLoanFacilitator, uint256 loanId, address loanAsset) \n        private \n        view \n        returns (string memory)\n    {\n        return UintStrings.decimalString(\n            nftLoanFacilitator.interestOwed(loanId),\n            IERC20Metadata(loanAsset).decimals(),\n            false);\n    }\n\n    function loanStatus(uint256 lastAccumulatedTimestamp, uint256 durationSeconds, bool closed) \n        view \n        private \n        returns (string memory)\n    {\n        if (lastAccumulatedTimestamp == 0) return \"awaiting lender\";\n\n        if (closed) return \"closed\";\n\n        if (block.timestamp > (lastAccumulatedTimestamp + durationSeconds)) return \"past due\";\n\n        return \"accruing interest\";\n    }\n\n    /** \n     * @param endDateSeconds The unix seconds timestamp of the loan end date\n     * @return a string representation of the UTC end date and time of the loan,\n     * in format YYYY-MM-DD HH:MM:SS\n     */\n    function endDateTime(uint256 endDateSeconds) private pure returns (string memory) {\n        (uint year, uint month, \n        uint day, uint hour, \n        uint minute, uint second) = BokkyPooBahsDateTimeLibrary.timestampToDateTime(endDateSeconds);\n        return string.concat(\n                Strings.toString(year),\n                '-',\n                Strings.toString(month),\n                '-',\n                Strings.toString(day),\n                ' ',\n                Strings.toString(hour),\n                ':',\n                Strings.toString(minute),\n                ':',\n                Strings.toString(second),\n                ' UTC'\n        );\n    } \n}"
    },
    {
      "filename": "contracts/descriptors/libraries/PopulateSVGParams.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\nimport './BokkyPooBahsDateTimeLibrary.sol';\nimport './UintStrings.sol';\nimport '../../NFTLoanFacilitator.sol';\nimport '../../interfaces/IERC20Metadata.sol';\nimport './HexStrings.sol';\nimport './NFTLoanTicketSVG.sol';\n\n\nlibrary PopulateSVGParams{\n    /**\n     * @notice Populates and returns the passed `svgParams` with loan info retrieved from\n     * `nftLoanFacilitator` for `id`, the loan id\n     * @param svgParams The svg params to populate, which already has `nftType` populated from NFTLoansTicketDescriptor\n     * @param nftLoanFacilitator The loan facilitator contract to get loan info from for loan `id`\n     * @param id The id of the loan\n     * @return `svgParams`, with all values now populated\n     */\n    function populate(NFTLoanTicketSVG.SVGParams memory svgParams, NFTLoanFacilitator nftLoanFacilitator, uint256 id)\n        internal\n        view\n        returns (NFTLoanTicketSVG.SVGParams memory)\n    {\n        (bool closed, uint256 perAnumInterestRate,\n        uint256 durationSeconds, uint256 lastAccumulatedTimestamp,\n        address collateralAddress, address loanAsset, ,\n        uint256 loanAmount, uint256 collateralID) = nftLoanFacilitator.loanInfo(id);\n\n        svgParams.id = Strings.toString(id);\n        svgParams.status = loanStatus(lastAccumulatedTimestamp, durationSeconds, closed);\n        svgParams.interestRate = interestRateString(nftLoanFacilitator, perAnumInterestRate); \n        svgParams.loanAssetContract = HexStrings.toHexString(uint160(loanAsset), 20);\n        svgParams.loanAssetSymbol = loanAssetSymbol(loanAsset);\n        svgParams.collateralContract = HexStrings.toHexString(uint160(collateralAddress), 20);\n        svgParams.collateralContractPartial = HexStrings.partialHexString(uint160(collateralAddress), 10, 40);\n        svgParams.collateralAssetSymbol = collateralAssetSymbol(collateralAddress);\n        svgParams.collateralId = Strings.toString(collateralID);\n        svgParams.loanAmount = loanAmountString(loanAmount, loanAsset);\n        svgParams.interestAccrued = accruedInterest(nftLoanFacilitator, id, loanAsset);\n        svgParams.durationDays = Strings.toString(durationSeconds / (24 * 60 * 60));\n        svgParams.endDateTime = lastAccumulatedTimestamp == 0 ? \"n/a\" \n        : endDateTime(lastAccumulatedTimestamp + durationSeconds);\n        \n        return svgParams;\n    }\n\n    function interestRateString(NFTLoanFacilitator nftLoanFacilitator, uint256 perAnumInterestRate) \n        private \n        view \n        returns (string memory)\n    {\n        return UintStrings.decimalString(\n            perAnumInterestRate,\n            nftLoanFacilitator.INTEREST_RATE_DECIMALS() - 2,\n            true\n            );\n    }\n\n    function loanAmountString(uint256 amount, address asset) private view returns (string memory) {\n        return UintStrings.decimalString(amount, IERC20Metadata(asset).decimals(), false);\n    }\n\n    function loanAssetSymbol(address asset) private view returns (string memory) {\n        return IERC20Metadata(asset).symbol();\n    }\n\n    function collateralAssetSymbol(address asset) private view returns (string memory) {\n        return ERC721(asset).symbol();\n    }\n\n    function accruedInterest(NFTLoanFacilitator nftLoanFacilitator, uint256 loanId, address loanAsset) \n        private \n        view \n        returns (string memory)\n    {\n        return UintStrings.decimalString(\n            nftLoanFacilitator.interestOwed(loanId),\n            IERC20Metadata(loanAsset).decimals(),\n            false);\n    }\n\n    function loanStatus(uint256 lastAccumulatedTimestamp, uint256 durationSeconds, bool closed) \n        view \n        private \n        returns (string memory)\n    {\n        if (lastAccumulatedTimestamp == 0) return \"awaiting lender\";\n\n        if (closed) return \"closed\";\n\n        if (block.timestamp > (lastAccumulatedTimestamp + durationSeconds)) return \"past due\";\n\n        return \"accruing interest\";\n    }\n\n    /** \n     * @param endDateSeconds The unix seconds timestamp of the loan end date\n     * @return a string representation of the UTC end date and time of the loan,\n     * in format YYYY-MM-DD HH:MM:SS\n     */\n    function endDateTime(uint256 endDateSeconds) private pure returns (string memory) {\n        (uint year, uint month, \n        uint day, uint hour, \n        uint minute, uint second) = BokkyPooBahsDateTimeLibrary.timestampToDateTime(endDateSeconds);\n        return string.concat(\n                Strings.toString(year),\n                '-',\n                Strings.toString(month),\n                '-',\n                Strings.toString(day),\n                ' ',\n                Strings.toString(hour),\n                ':',\n                Strings.toString(minute),\n                ':',\n                Strings.toString(second),\n                ' UTC'\n        );\n    } \n}"
    },
    {
      "filename": "contracts/libraries/BoringERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"../interfaces/IERC20.sol\";\n\n// solhint-disable avoid-low-level-calls\n\nlibrary BoringERC20 {\n    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()\n    bytes4 private constant SIG_NAME = 0x06fdde03; // name()\n    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()\n    bytes4 private constant SIG_BALANCE_OF = 0x70a08231; // balanceOf(address)\n    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\n    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)\n\n    function returnDataToString(bytes memory data) internal pure returns (string memory) {\n        if (data.length >= 64) {\n            return abi.decode(data, (string));\n        } else if (data.length == 32) {\n            uint8 i = 0;\n            while (i < 32 && data[i] != 0) {\n                i++;\n            }\n            bytes memory bytesArray = new bytes(i);\n            for (i = 0; i < 32 && data[i] != 0; i++) {\n                bytesArray[i] = data[i];\n            }\n            return string(bytesArray);\n        } else {\n            return \"???\";\n        }\n    }\n\n    /// @notice Provides a safe ERC20.symbol version which returns '???' as fallback string.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (string) Token symbol.\n    function safeSymbol(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_SYMBOL));\n        return success ? returnDataToString(data) : \"???\";\n    }\n\n    /// @notice Provides a safe ERC20.name version which returns '???' as fallback string.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (string) Token name.\n    function safeName(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_NAME));\n        return success ? returnDataToString(data) : \"???\";\n    }\n\n    /// @notice Provides a safe ERC20.decimals version which returns '18' as fallback value.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (uint8) Token decimals.\n    function safeDecimals(IERC20 token) internal view returns (uint8) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_DECIMALS));\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n    }\n\n    /// @notice Provides a gas-optimized balance check to avoid a redundant extcodesize check in addition to the returndatasize check.\n    /// @param token The address of the ERC-20 token.\n    /// @param to The address of the user to check.\n    /// @return amount The token amount.\n    function safeBalanceOf(IERC20 token, address to) internal view returns (uint256 amount) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_BALANCE_OF, to));\n        require(success && data.length >= 32, \"BoringERC20: BalanceOf failed\");\n        amount = abi.decode(data, (uint256));\n    }\n\n    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.\n    /// Reverts on a failed transfer.\n    /// @param token The address of the ERC-20 token.\n    /// @param to Transfer tokens to.\n    /// @param amount The token amount.\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: Transfer failed\");\n    }\n\n    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.\n    /// Reverts on a failed transfer.\n    /// @param token The address of the ERC-20 token.\n    /// @param from Transfer tokens from.\n    /// @param to Transfer tokens to.\n    /// @param amount The token amount.\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: TransferFrom failed\");\n    }\n}"
    }
  ]
}