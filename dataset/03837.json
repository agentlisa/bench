{
  "Title": "Self-explainable naming",
  "Content": "##### Description\n\nIt's good if the name of the variable is absolutely self-explainable.\nFor primitive types (integers) it's good to know what exactly the variable is.\nFor mappings it's better to add key to the name (e.g. userDeposits not just deposits)\n\n- key and value of struct is unclear\nhttps://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCFactory.sol#L38 - mappingOfMarkets\nhttps://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCMarket.sol#L49 - price\n\n- add Percent postfix\nhttps://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCFactory.sol#L46 - minimumPriceIncrease\nhttps://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCMarket.sol#L62 - minimumPriceIncrease\n\n- add DayDivisor postfix\nhttps://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCMarket.sol#L64 - minRentalDivisor\n\n- add weekDivisor postfix\nhttps://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCMarket.sol#L66 - hotPotatoDivisor\n\n- rentCollected postfix\nhttps://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCMarket.sol#L51\nhttps://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCMarket.sol#L53\nhttps://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCMarket.sol#L55\n\n- deposit - https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCTreasury.sol#L23 what is the key?\n\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyXdai.sol#L37 what is the key?\n\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyXdai.sol#L38 what is the key?\n\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyXdai.sol#L39 - must be upper-cased\n\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyXdai.sol#L47 - what is the key?\n\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyXdai.sol#L48 - what is the key?\n\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyXdai.sol#L118 - change amicable to some common word\n\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyXdai.sol#L50 - the purpose of the value is not clear from the name\n\n##### Recommendation\nIt is recommended to rename variables.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/RCFactory.sol",
      "content": "pragma solidity 0.5.13;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"hardhat/console.sol\";\nimport './lib/CloneFactory.sol';\nimport \"./interfaces/ITreasury.sol\";\nimport './interfaces/IRCMarket.sol';\nimport './interfaces/IRCProxyXdai.sol';\nimport './interfaces/IRCNftHubXdai.sol';\nimport './lib/NativeMetaTransaction.sol';\n\n/// @title Reality Cards Factory\n/// @author Andrew Stanger\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCFactory is Ownable, CloneFactory, NativeMetaTransaction {\n\n    using SafeMath for uint256;\n    using SafeMath for uint32;\n\n    ////////////////////////////////////\n    //////// VARIABLES /////////////////\n    ////////////////////////////////////\n\n    ///// CONTRACT VARIABLES /////\n    ITreasury public treasury;\n    IRCProxyXdai public proxy;\n    IRCNftHubXdai public nfthub;\n\n    ///// CONTRACT ADDRESSES /////\n    /// @dev reference contract\n    address public referenceContractAddress; \n    /// @dev increments each time a new reference contract is added\n    uint256 public referenceContractVersion;\n    /// @dev market addresses, mode // address\n    /// @dev these are not used for anything, just an easy way to get markets\n    mapping(uint256 => address[]) public marketAddresses;\n    mapping(address => bool) public mappingOfMarkets; \n\n    ///// GOVERNANCE VARIABLES- OWNER /////\n    /// @dev artist / winner / market creator / affiliate / card affiliate\n    uint256[5] public potDistribution;\n    /// @dev minimum xDai that must be sent when creating market which forms iniital pot\n    uint256 public sponsorshipRequired;\n    /// @dev adjust required price increase (in %)\n    uint256 public minimumPriceIncrease;\n    /// @dev market opening time must be at least this many seconds in the future\n    uint32 public advancedWarning;\n    /// @dev market closing time must be no more than this many seconds in the future\n    uint32 public maximumDuration;\n    /// @dev if hot potato mode, how much rent new owner must pay current owner (1 week divisor: i.e. 7 = 1 day's rent, 14 = 12 hours's rent)\n    uint256 public hotPotatoDivisor;\n    /// @dev list of governors\n    mapping(address => bool) public governors;\n    /// @dev if false, anyone can create markets\n    bool public marketCreationGovernorsOnly = true;\n    /// @dev if true, cards are burnt at the end of events for hidden markets to enforce scarcity\n    bool public trapIfUnapproved = true;\n    /// @dev high level owner who can change the factory address\n    address public uberOwner;\n\n    ///// GOVERNANCE VARIABLES- GOVERNORS /////\n    /// @dev unapproved markets hidden from the interface\n    mapping(address => bool) public isMarketApproved;\n    /// @dev allows artist to receive cut of total rent\n    mapping(address => bool) public isArtistApproved;\n    /// @dev allows affiliate to receive cut of total rent\n    mapping(address => bool) public isAffiliateApproved;\n    /// @dev allows card affiliate to receive cut of total rent\n    mapping(address => bool) public isCardAffiliateApproved;\n    \n    ///// OTHER /////\n    /// @dev counts the total NFTs minted across all events\n    /// @dev ... so the appropriate token id is used when upgrading to mainnet\n    uint256 public totalNftMintCount;\n\n    ////////////////////////////////////\n    //////// EVENTS ////////////////////\n    ////////////////////////////////////\n\n    event LogMarketCreated1(address contractAddress, address treasuryAddress, address nftHubAddress, uint256 referenceContractVersion);\n    event LogMarketCreated2(address contractAddress, uint32 mode, string[] tokenURIs, string ipfsHash, uint32[] timestamps, uint256 totalNftMintCount);\n    event LogMarketApproved(address market, bool hidden);\n    event LogAdvancedWarning(uint256 _newAdvancedWarning);\n    event LogMaximumDuration(uint256 _newMaximumDuration);\n\n    ////////////////////////////////////\n    //////// CONSTRUCTOR ///////////////\n    ////////////////////////////////////\n\n    /// @dev Treasury must be deployed before Factory\n    constructor(ITreasury _treasuryAddress) public\n    {\n        // initialise MetaTransactions\n        _initializeEIP712(\"RealityCardsFactory\",\"1\");\n\n        // at initiation, uberOwner and owner will be the same\n        uberOwner = msg.sender;\n\n        // initialise contract variable\n        treasury = _treasuryAddress;\n\n        // initialise adjustable parameters\n        // artist // winner // creator // affiliate // card affiliates\n        setPotDistribution(20,0,0,20,100); // 2% artist, 2% affiliate, 10% card affiliate\n        setMinimumPriceIncrease(10); // 10% \n        setHotPotatoPayment(7); // one day's rent\n    }\n\n    ////////////////////////////////////\n    ///////// VIEW FUNCTIONS ///////////\n    ////////////////////////////////////\n\n    function getMostRecentMarket(uint256 _mode) public view returns (address) {\n        return marketAddresses[_mode][marketAddresses[_mode].length-1];\n    }\n\n    function getAllMarkets(uint256 _mode) public view returns (address[] memory) {\n        return marketAddresses[_mode];\n    }\n\n    function getPotDistribution() public view returns (uint256[5] memory) {\n        return potDistribution;\n    }\n\n    ////////////////////////////////////\n    //////////// MODIFERS //////////////\n    ////////////////////////////////////\n\n    modifier onlyGovernors() {\n        require(governors[msgSender()] || owner() == msgSender(), \"Not approved\");\n        _;\n    }\n\n    ////////////////////////////////////\n    ///// GOVERNANCE- OWNER (SETUP) ////\n    ////////////////////////////////////\n    /// @dev all functions should have onlyOwner modifier\n\n    /// @notice address of the xDai Proxy contract\n    function setProxyXdaiAddress(IRCProxyXdai _newAddress) external onlyOwner {\n        proxy = _newAddress;\n    }\n\n    /// @notice where the NFTs live\n    /// @dev nftMintCount will probably need to be reset to zero if new nft contract, but \n    /// @dev ... keeping flexible in case returning to previous contract\n    function setNftHubAddress(IRCNftHubXdai _newAddress, uint256 _newNftMintCount) external onlyOwner {\n        nfthub = _newAddress;\n        totalNftMintCount = _newNftMintCount;\n    }\n\n    ////////////////////////////////////\n    /////// GOVERNANCE- OWNER //////////\n    ////////////////////////////////////\n    /// @dev all functions should have onlyOwner modifier\n    // Min price increase, pot distribution & hot potato events emitted by Market. \n    // Advanced Warning and Maximum Duration events emitted here. Nothing else need be emitted.\n\n    /// CALLED WITHIN CONSTRUCTOR (public)\n\n    /// @notice update stakeholder payouts \n    /// @dev in 10s of basis points (so 1000 = 100%)\n    function setPotDistribution(uint256 _artistCut, uint256 _winnerCut, uint256 _creatorCut, uint256 _affiliateCut, uint256 _cardAffiliateCut) public onlyOwner {\n        require(_artistCut.add(_affiliateCut).add(_creatorCut).add(_winnerCut).add(_affiliateCut).add(_cardAffiliateCut) <= 1000, \"Cuts too big\");\n        potDistribution[0] = _artistCut;\n        potDistribution[1] = _winnerCut;\n        potDistribution[2] = _creatorCut;\n        potDistribution[3] = _affiliateCut;\n        potDistribution[4] = _cardAffiliateCut;\n    }\n\n    /// @notice how much above the current price a user must bid, in %\n    function setMinimumPriceIncrease(uint256 _percentIncrease) public onlyOwner {\n        minimumPriceIncrease = _percentIncrease;\n    }\n\n     /// @dev if hot potato mode, how much rent new owner must pay current owner (1 week divisor: i.e. 7 = 1 day, 14 = 12 hours)\n    function setHotPotatoPayment(uint256 _newDivisor) public onlyOwner {\n        hotPotatoDivisor = _newDivisor;\n    }\n\n    /// NOT CALLED WITHIN CONSTRUCTOR (external)\n\n    /// @notice whether or not only governors can create the market\n    function setMarketCreationGovernorsOnly() external onlyOwner {\n        marketCreationGovernorsOnly = marketCreationGovernorsOnly ? false : true;\n    }\n\n    /// @notice how much xdai must be sent in the createMarket tx which forms the initial pot\n    function setSponsorshipRequired(uint256 _dai) external onlyOwner {\n        sponsorshipRequired = _dai;\n    }\n\n    /// @notice if true, Cards in unapproved markets can't be upgraded\n    function setTrapCardsIfUnapproved() onlyOwner external {\n        trapIfUnapproved = trapIfUnapproved ? false : true;\n    }\n\n    /// @notice market opening time must be at least this many seconds in the future\n    function setAdvancedWarning(uint32 _newAdvancedWarning) onlyOwner external {\n        advancedWarning = _newAdvancedWarning;\n        emit LogAdvancedWarning(_newAdvancedWarning);\n    }\n\n    /// @notice market closing time must be no more than this many seconds in the future\n    function setMaximumDuration(uint32 _newMaximumDuration) onlyOwner external {\n        maximumDuration = _newMaximumDuration;\n        emit LogMaximumDuration(_newMaximumDuration);\n    }\n\n    // EDIT GOVERNORS\n\n    /// @notice add or remove an address from market creator whitelist\n    function addOrRemoveGovernor(address _governor) external onlyOwner {\n        governors[_governor] = governors[_governor] ? false : true;\n    }\n\n    ////////////////////////////////////\n    ///// GOVERNANCE- GOVERNORS ////////\n    ////////////////////////////////////\n    /// @dev all functions should have onlyGovernors modifier\n\n    /// @notice markets are default hidden from the interface, this reveals them\n    function approveOrUnapproveMarket(address _market) external onlyGovernors {\n        isMarketApproved[_market] = isMarketApproved[_market] ? false : true;\n        emit LogMarketApproved(_market, isMarketApproved[_market]);\n    }\n\n    /// @notice artistAddress, passed in createMarket, must be approved\n    function addOrRemoveArtist(address _artist) external onlyGovernors {\n        isArtistApproved[_artist] = isArtistApproved[_artist] ? false : true;\n    }\n\n    /// @notice affiliateAddress, passed in createMarket, must be approved\n    function addOrRemoveAffiliate(address _affiliate) external onlyGovernors {\n        isAffiliateApproved[_affiliate] = isAffiliateApproved[_affiliate] ? false : true;\n    }\n\n    /// @notice cardAffiliateAddress, passed in createMarket, must be approved\n    function addOrRemoveCardAffiliate(address _affiliate) external onlyGovernors {\n        isCardAffiliateApproved[_affiliate] = isCardAffiliateApproved[_affiliate] ? false : true;\n    }\n\n    ////////////////////////////////////\n    ////// GOVERNANCE- UBER OWNER //////\n    ////////////////////////////////////\n    //// ******** DANGER ZONE ******** ////\n    /// @dev uber owner required for upgrades\n    /// @dev this is seperated so owner so can be set to multisig, or burn address to relinquish upgrade ability\n    /// @dev ... while maintaining governance over other governanace functions\n\n    /// @notice change the reference contract for the contract logic\n    function setReferenceContractAddress(address _newAddress) external {\n        require(msg.sender == uberOwner, \"Extremely Verboten\");\n        // check it's an RC contract\n        IRCMarket newContractVariable = IRCMarket(_newAddress);\n        assert(newContractVariable.isMarket());\n        // set \n        referenceContractAddress = _newAddress;\n        // increment version\n        referenceContractVersion = referenceContractVersion.add(1);\n    }\n\n    function changeUberOwner(address _newUberOwner) external {\n        require(msg.sender == uberOwner, \"Extremely Verboten\");\n        uberOwner = _newUberOwner;\n    }\n\n    ////////////////////////////////////\n    //////// MARKET CREATION ///////////\n    ////////////////////////////////////\n\n    /// @param _mode 0 = normal, 1 = winner takes all, 2 = hot potato\n    /// @param _timestamps for market opening, locking, and oracle resolution\n    /// @param _tokenURIs location of NFT metadata\n    /// @param _artistAddress where to send artist's cut, if any\n    /// @param _affiliateAddress where to send affiliate's cut, if any\n    /// @param _cardAffiliateAddresses where to send card specific affiliate's cut, if any\n    /// @param _realitioQuestion the details of the event to send to the oracle\n    function createMarket(\n        uint32 _mode,\n        string memory _ipfsHash,\n        uint32[] memory _timestamps, \n        string[] memory _tokenURIs,\n        address _artistAddress,\n        address _affiliateAddress,\n        address[] memory _cardAffiliateAddresses,\n        string memory _realitioQuestion\n    ) public payable returns (address)  {\n        // check sponsorship\n        require(msg.value >= sponsorshipRequired, \"Insufficient sponsorship\");\n\n        // check stakeholder addresses\n        // artist\n        require(isArtistApproved[_artistAddress] || _artistAddress == address(0), \"Artist not approved\");\n        // affiliate\n        require(isAffiliateApproved[_affiliateAddress] || _affiliateAddress == address(0), \"Affiliate not approved\");\n        // card affiliates\n        for (uint i = 0; i < _cardAffiliateAddresses.length; i++) { \n            require(isCardAffiliateApproved[_cardAffiliateAddresses[i]] || _cardAffiliateAddresses[i] == address(0), \"Card affiliate not approved\");\n        }\n\n        // check market creator is approved\n        if (marketCreationGovernorsOnly) {\n            require(governors[msgSender()] || owner() == msgSender(), \"Not approved\");\n        }\n\n        // check timestamps\n        // check market opening time\n        if (advancedWarning != 0) {\n            require(_timestamps[0] >= now, \"Market opening time not set\"); \n            require(_timestamps[0].sub(advancedWarning) > now, \"Market opens too soon\" );\n        }\n        // check market locking time\n        if (maximumDuration != 0) {\n            require(_timestamps[1] < now.add(maximumDuration), \"Market locks too late\");\n        }\n        // check oracle resolution time (no more than 1 week after market locking to get result)\n        require(_timestamps[1].add(1 weeks) > _timestamps[2] && _timestamps[1] <= _timestamps[2], \"Oracle resolution time error\" );\n\n        uint256 _numberOfTokens = _tokenURIs.length;\n\n        // create the market and emit the appropriate events\n        // two events to avoid stack too deep error\n        address _newAddress = createClone(referenceContractAddress);\n        emit LogMarketCreated1(_newAddress, address(treasury), address(nfthub), referenceContractVersion);\n        emit LogMarketCreated2(_newAddress, _mode, _tokenURIs, _ipfsHash, _timestamps, totalNftMintCount);\n        IRCMarket(_newAddress).initialize({\n            _mode: _mode,\n            _timestamps: _timestamps,\n            _numberOfTokens: _numberOfTokens,\n            _totalNftMintCount: totalNftMintCount,\n            _artistAddress: _artistAddress,\n            _affiliateAddress: _affiliateAddress,\n            _cardAffiliateAddresses: _cardAffiliateAddresses,\n            _marketCreatorAddress: msgSender()\n        });\n\n        // create the NFTs\n        require(address(nfthub) != address(0), \"Nfthub not set\");\n        for (uint i = 0; i < _numberOfTokens; i++) { \n            uint256 _tokenId = i.add(totalNftMintCount);\n            assert(nfthub.mintNft(_newAddress, _tokenId, _tokenURIs[i]));\n        }\n\n        // increment totalNftMintCount\n        totalNftMintCount = totalNftMintCount.add(_numberOfTokens);\n\n        // post question to Oracle\n        require(address(proxy) != address(0), \"xDai proxy not set\");\n        proxy.saveQuestion(_newAddress, _realitioQuestion, _timestamps[2]);\n\n        // tell Treasury, Proxy, and NFT hub about new market\n        assert(treasury.addMarket(_newAddress));\n        assert(proxy.addMarket(_newAddress));\n        assert(nfthub.addMarket(_newAddress));\n\n        // update internals\n        marketAddresses[_mode].push(_newAddress);\n        mappingOfMarkets[_newAddress] = true;\n\n        // pay sponsorship, if applicable\n        if (msg.value > 0) {\n            IRCMarket(_newAddress).sponsor.value(msg.value)();\n        }\n\n        return _newAddress;\n    }\n\n}"
    },
    {
      "filename": "contracts/RCMarket.sol",
      "content": "pragma solidity 0.5.13;\n\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"hardhat/console.sol\";\nimport \"./interfaces/IRealitio.sol\";\nimport \"./interfaces/IFactory.sol\";\nimport \"./interfaces/ITreasury.sol\";\nimport './interfaces/IRCProxyXdai.sol';\nimport './interfaces/IRCNftHubXdai.sol';\nimport './lib/NativeMetaTransaction.sol';\n\n/// @title Reality Cards Market\n/// @author Andrew Stanger\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCMarket is Initializable, NativeMetaTransaction {\n\n    using SafeMath for uint256;\n\n    ////////////////////////////////////\n    //////// VARIABLES /////////////////\n    ////////////////////////////////////\n\n    ///// CONTRACT SETUP /////\n    /// @dev = how many outcomes/teams/NFTs etc \n    uint256 public numberOfTokens;\n    /// @dev only for _revertToUnderbidder to prevent gas limits\n    uint256 public constant MAX_ITERATIONS = 10;\n    uint256 public constant MAX_UINT256 = 2**256 - 1;\n    uint256 public constant MAX_UINT128 = 2**128 - 1;\n    enum States {CLOSED, OPEN, LOCKED, WITHDRAW}\n    States public state; \n    /// @dev type of event. 0 = classic, 1 = winner takes all, 2 = hot potato \n    uint256 public mode;\n    /// @dev so the Factory can check its a market\n    bool public constant isMarket = true;\n    /// @dev counts the total NFTs minted across all events at the time market created\n    /// @dev nft tokenId = card Id + totalNftMintCount\n    uint256 public totalNftMintCount;\n\n    ///// CONTRACT VARIABLES /////\n    ITreasury public treasury;\n    IFactory public factory;\n    IRCProxyXdai public proxy;\n    IRCNftHubXdai public nfthub;\n\n    ///// PRICE, DEPOSITS, RENT /////\n    /// @dev in attodai (so 100xdai = 100000000000000000000)\n    mapping (uint256 => uint256) public price; \n    /// @dev keeps track of all the rent paid by each user. So that it can be returned in case of an invalid market outcome.\n    mapping (address => uint256) public collectedPerUser;\n    /// @dev keeps track of all the rent paid for each token, for card specific affiliate payout\n    mapping (uint256 => uint256) public collectedPerToken;\n    /// @dev an easy way to track the above across all tokens\n    uint256 public totalCollected; \n    /// @dev prevents user from exiting and re-renting in the same block (prevents troll attacks)\n    mapping (address => uint256) public exitedTimestamp;\n\n    ///// PARAMETERS /////\n    /// @dev read from the Factory upon market creation, can not be changed for existing market\n    /// @dev the minimum required price increase in %\n    uint256 public minimumPriceIncrease;\n    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)\n    uint256 public minRentalDivisor;\n    /// @dev if hot potato mode, how much rent new owner must pay current owner (1 week divisor: i.e. 7 = 1 day, 14 = 12 hours)\n    uint256 public hotPotatoDivisor;\n\n    ///// ORDERBOOK /////\n    /// @dev stores the orderbook. Doubly linked list. \n    mapping (uint256 => mapping(address => Bid)) public orderbook; // tokenID // user address // Bid\n    /// @dev orderbook uses uint128 to save gas, because Struct. Using uint256 everywhere else because best for maths. \n    struct Bid{\n  \t\tuint128 price;\n        uint128 timeHeldLimit; // users can optionally set a maximum time to hold it for\n        address next; // who it will return to when current owner exits (i.e, next = going down the list)\n        address prev; // who it returned from (i.e., prev = going up the list)\n    }\n \n    ///// TIME /////\n    /// @dev how many seconds each user has held each token for, for determining winnings  \n    mapping (uint256 => mapping (address => uint256) ) public timeHeld;\n    /// @dev sums all the timeHelds for each. Used when paying out. Should always increment at the same time as timeHeld\n    mapping (uint256 => uint256) public totalTimeHeld; \n    /// @dev used to determine the rent due. Rent is due for the period (now - timeLastCollected), at which point timeLastCollected is set to now.\n    mapping (uint256 => uint256) public timeLastCollected; \n    /// @dev to track the max timeheld of each token (for giving NFT to winner)\n    mapping (uint256 => uint256) public longestTimeHeld;\n    /// @dev to track who has owned it the most (for giving NFT to winner)\n    mapping (uint256 => address) public longestOwner;\n    /// @dev tells the contract to exit position after min rental duration (or immediately, if already rented for this long)\n    /// @dev if not current owner, prevents ownership reverting back to you\n\n    ///// TIMESTAMPS ///// \n    /// @dev when the market opens \n    uint32 public marketOpeningTime; \n    /// @dev when the market locks \n    uint32 public marketLockingTime; \n    /// @dev when the question can be answered on realitio\n    /// @dev only needed for circuit breaker\n    uint32 public oracleResolutionTime;\n\n    ///// PAYOUT VARIABLES /////\n    uint256 public winningOutcome;\n    /// @dev prevent users withdrawing twice\n    mapping (address => bool) public userAlreadyWithdrawn;\n    /// @dev prevent users claiming twice\n    mapping (uint256 => mapping (address => bool) ) public userAlreadyClaimed; // token ID // user // bool\n    /// @dev the artist\n    address public artistAddress;\n    uint256 public artistCut;\n    bool public artistPaid;\n    /// @dev the affiliate\n    address public affiliateAddress;\n    uint256 public affiliateCut;\n    bool public affiliatePaid;\n    /// @dev the winner\n    uint256 public winnerCut;\n    /// @dev the market creator\n    address public marketCreatorAddress;\n    uint256 public creatorCut;\n    bool public creatorPaid;\n    /// @dev card specific recipients\n    address[] public cardAffiliateAddresses;\n    uint256 public cardAffiliateCut;\n    mapping (uint256 => bool) public cardAffiliatePaid;\n\n    ////////////////////////////////////\n    //////// EVENTS ////////////////////\n    ////////////////////////////////////\n\n    event LogAddToOrderbook(address indexed newOwner, uint256 indexed newPrice, uint256 timeHeldLimit, address insertedBelow, uint256 indexed tokenId);\n    event LogNewOwner(uint256 indexed tokenId, address indexed newOwner);\n    event LogRentCollection(uint256 indexed rentCollected, uint256 indexed tokenId, address indexed owner);\n    event LogRemoveFromOrderbook(address indexed owner, uint256 indexed tokenId);\n    event LogContractLocked(bool indexed didTheEventFinish);\n    event LogWinnerKnown(uint256 indexed winningOutcome);\n    event LogWinningsPaid(address indexed paidTo, uint256 indexed amountPaid);\n    event LogStakeholderPaid(address indexed paidTo, uint256 indexed amountPaid);\n    event LogRentReturned(address indexed returnedTo, uint256 indexed amountReturned);\n    event LogTimeHeldUpdated(uint256 indexed newTimeHeld, address indexed owner, uint256 indexed tokenId);\n    event LogStateChange(uint256 indexed newState);\n    event LogUpdateTimeHeldLimit(address indexed owner, uint256 newLimit, uint256 tokenId);\n    event LogExit(address indexed owner, uint256 tokenId);\n    event LogSponsor(address indexed sponsor, uint256 indexed amount);\n    event LogNftUpgraded(uint256 indexed currentTokenId, uint256 indexed newTokenId);\n    event LogPayoutDetails(address indexed artistAddress, address marketCreatorAddress, address affiliateAddress, address[] cardAffiliateAddresses, uint256 indexed artistCut, uint256 winnerCut, uint256 creatorCut, uint256 affiliateCut, uint256 cardAffiliateCut);\n    event LogTransferCardToLongestOwner(uint256 tokenId, address longestOwner);\n    event LogSettings(uint256 indexed minRentalDivisor, uint256 indexed minimumPriceIncrease, uint256 hotPotatoDivisor);\n\n    ////////////////////////////////////\n    //////// CONSTRUCTOR ///////////////\n    ////////////////////////////////////\n    \n    /// @param _mode 0 = normal, 1 = winner takes all, 2 = hot potato\n    /// @param _timestamps for market opening, locking, and oracle resolution\n    /// @param _numberOfTokens how many Cards in this market\n    /// @param _totalNftMintCount total existing Cards across all markets excl this event's Cards\n    /// @param _artistAddress where to send artist's cut, if any\n    /// @param _affiliateAddress where to send affiliate's cut, if any\n    /// @param _cardAffiliateAddresses where to send card specific affiliate's cut, if any\n    /// @param _marketCreatorAddress where to send market creator's cut, if any\n    function initialize(\n        uint256 _mode,\n        uint32[] memory _timestamps,\n        uint256 _numberOfTokens,\n        uint256 _totalNftMintCount,\n        address _artistAddress,\n        address _affiliateAddress,\n        address[] memory _cardAffiliateAddresses,\n        address _marketCreatorAddress\n    ) public initializer {\n        assert(_mode <= 2);\n\n        // initialise MetaTransactions\n        _initializeEIP712(\"RealityCardsMarket\",\"1\");\n\n        // external contract variables:\n        factory = IFactory(msg.sender);\n        treasury = factory.treasury();\n        proxy = factory.proxy();\n        nfthub = factory.nfthub();\n\n        // get adjustable parameters from the factory/treasury\n        uint256[5] memory _potDistribution = factory.getPotDistribution();\n        minRentalDivisor = treasury.minRentalDivisor();\n        minimumPriceIncrease = factory.minimumPriceIncrease();\n        hotPotatoDivisor = factory.hotPotatoDivisor();\n        \n        // initialiiize!\n        winningOutcome = MAX_UINT256; // default invalid\n\n        // assign arguments to public variables\n        mode = _mode;\n        numberOfTokens = _numberOfTokens;\n        totalNftMintCount = _totalNftMintCount;\n        marketOpeningTime = _timestamps[0];\n        marketLockingTime = _timestamps[1];\n        oracleResolutionTime = _timestamps[2];\n        artistAddress = _artistAddress;\n        marketCreatorAddress = _marketCreatorAddress;\n        affiliateAddress = _affiliateAddress;\n        cardAffiliateAddresses = _cardAffiliateAddresses;\n        artistCut = _potDistribution[0];\n        winnerCut = _potDistribution[1];\n        creatorCut = _potDistribution[2];\n        affiliateCut = _potDistribution[3];\n        cardAffiliateCut = _potDistribution[4];\n\n        // reduce artist cut to zero if zero adddress set\n        if (_artistAddress == address(0)) {\n            artistCut = 0;\n        }\n\n        // reduce affiliate cut to zero if zero adddress set\n        if (_affiliateAddress == address(0)) {\n            affiliateCut = 0;\n        }\n\n        // check the validity of card affiliate array. \n        // if not valid, reduce payout to zero\n        if (_cardAffiliateAddresses.length == _numberOfTokens) {\n            for (uint i = 0; i < _numberOfTokens; i++) { \n                if (_cardAffiliateAddresses[i] == address(0)) {\n                    cardAffiliateCut = 0;\n                }\n            }\n        } else {\n            cardAffiliateCut = 0;\n        }\n\n        // if winner takes all mode, set winnerCut to max\n        if (_mode == 1) {\n            winnerCut = (((uint256(1000).sub(artistCut)).sub(creatorCut)).sub(affiliateCut)).sub(cardAffiliateCut);\n        } \n\n        // move to OPEN immediately if market opening time in the past\n        if (marketOpeningTime <= now) {\n            _incrementState();\n        }\n\n        emit LogPayoutDetails(_artistAddress, _marketCreatorAddress, _affiliateAddress, cardAffiliateAddresses, artistCut, winnerCut, creatorCut, affiliateCut, cardAffiliateCut);\n        emit LogSettings(minRentalDivisor, minimumPriceIncrease, hotPotatoDivisor);\n    } \n\n    ////////////////////////////////////\n    /////////// MODIFIERS //////////////\n    ////////////////////////////////////\n\n    /// @dev automatically opens market if appropriate\n    modifier autoUnlock() {\n        if (marketOpeningTime <= now && state == States.CLOSED) {\n            _incrementState();\n        }\n        _;\n    }\n\n    /// @dev automatically locks market if appropriate\n    modifier autoLock() {\n        _;\n        if (marketLockingTime <= now) {\n            lockMarket();\n        }\n    }\n\n    /// @notice what it says on the tin\n    modifier onlyTokenOwner(uint256 _tokenId) {\n        require(msgSender() == ownerOf(_tokenId), \"Not owner\");\n       _;\n    }\n\n    ////////////////////////////////////\n    //// ORACLE PROXY CONTRACT CALLS ///\n    ////////////////////////////////////\n\n    /// @notice send NFT to mainnet\n    /// @dev upgrades not possible if market not approved\n    function upgradeCard(uint256 _tokenId) external onlyTokenOwner(_tokenId) {\n        _checkState(States.WITHDRAW);\n        require(!factory.trapIfUnapproved() || factory.isMarketApproved(address(this)), \"Upgrade blocked\");\n        string memory _tokenUri = tokenURI(_tokenId);\n        address _owner = ownerOf(_tokenId);\n        uint256 _actualTokenId = _tokenId.add(totalNftMintCount);\n        proxy.saveCardToUpgrade(_actualTokenId, _tokenUri, _owner);\n        _transferCard(ownerOf(_tokenId), address(this), _tokenId); // contract becomes final resting place\n        emit LogNftUpgraded(_tokenId, _actualTokenId);\n    }\n\n    ////////////////////////////////////\n    /////// NFT HUB CONTRACT CALLS /////\n    ////////////////////////////////////\n\n    /// @notice gets the owner of the NFT via their Card Id\n    function ownerOf(uint256 _tokenId) public view returns(address) {\n        uint256 _actualTokenId = _tokenId.add(totalNftMintCount);\n        return nfthub.ownerOf(_actualTokenId);\n    }\n\n    /// @notice gets tokenURI via their Card Id\n    function tokenURI(uint256 _tokenId) public view returns(string memory) {\n        uint256 _actualTokenId = _tokenId.add(totalNftMintCount);\n        return nfthub.tokenURI(_actualTokenId);\n    }\n\n    /// @notice transfer ERC 721 between users\n    function _transferCard(address _from, address _to, uint256 _tokenId) internal {\n        require(_from != address(0) && _to != address(0) , \"Cannot send to/from zero address\");\n        uint256 _actualTokenId = _tokenId.add(totalNftMintCount);\n        assert(nfthub.transferNft(_from, _to, _actualTokenId));\n        emit LogNewOwner(_tokenId, _to);\n    }\n\n    ////////////////////////////////////\n    //// MARKET RESOLUTION FUNCTIONS ///\n    ////////////////////////////////////\n\n    /// @notice checks whether the competition has ended, if so moves to LOCKED state\n    /// @dev can be called by anyone \n    /// @dev public because called within autoLock modifier & setWinner\n    function lockMarket() public {\n        _checkState(States.OPEN);\n        require(marketLockingTime < now, \"Market has not finished\");\n        // do a final rent collection before the contract is locked down\n        collectRentAllCards();\n        _incrementState();\n        emit LogContractLocked(true);\n    }\n\n    /// @notice called by proxy, sets the winner\n    function setWinner(uint256 _winningOutcome) external {\n        if (state == States.OPEN) { lockMarket(); }\n        _checkState(States.LOCKED);\n        require(msg.sender == address(proxy), \"Not proxy\");\n        // get the winner. This will revert if answer is not resolved.\n        winningOutcome = _winningOutcome;\n        _incrementState();\n        emit LogWinnerKnown(winningOutcome);\n    }\n\n    /// @notice pays out winnings, or returns funds\n    /// @dev public because called by withdrawWinningsAndDeposit\n    function withdraw() external {\n        _checkState(States.WITHDRAW);\n        require(!userAlreadyWithdrawn[msgSender()], \"Already withdrawn\");\n        userAlreadyWithdrawn[msgSender()] = true;\n        if (totalTimeHeld[winningOutcome] > 0) {\n            _payoutWinnings();\n        } else {\n             _returnRent();\n        }\n    }\n\n    /// @notice the longest owner of each NFT gets to keep it\n    /// @dev LOCKED or WITHDRAW states are fine- does not need to wait for winner to be known\n    function claimCard(uint256 _tokenId) external  {\n        _checkNotState(States.CLOSED);\n        _checkNotState(States.OPEN);\n        require(!userAlreadyClaimed[_tokenId][msgSender()], \"Already claimed\");\n        userAlreadyClaimed[_tokenId][msgSender()] = true;\n        require(longestOwner[_tokenId] == msgSender(), \"Not longest owner\");\n        _transferCard(ownerOf(_tokenId), longestOwner[_tokenId], _tokenId);\n    }\n\n    /// @notice pays winnings\n    function _payoutWinnings() internal {\n        uint256 _winningsToTransfer;\n        uint256 _remainingCut = ((((uint256(1000).sub(artistCut)).sub(affiliateCut))).sub(cardAffiliateCut).sub(winnerCut)).sub(creatorCut); \n        // calculate longest owner's extra winnings, if relevant\n        if (longestOwner[winningOutcome] == msgSender() && winnerCut > 0){\n            _winningsToTransfer = (totalCollected.mul(winnerCut)).d"
    }
  ]
}