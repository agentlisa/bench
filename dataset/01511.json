{
  "Title": "Lack of event emission after sensitive actions",
  "Content": "The following functions do not emit relevant events after executing sensitive actions.\n\n\nEthereum LAND:\n\n\n* When the [`_admin` variable is set](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/Land/erc721/ERC721BaseTokenV2.sol#L36) in the `initialize` function of the `ERC721BaseTokenV2` contract\n* When the [filter registry is set](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/LandV3.sol#L79) in the `LandV3` contract\n* When the [LAND contract is registered](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/LandV3.sol#L72) on the Operator Filterer Registry in the `LandV3` contract\n\n\nPolygon LAND:\n\n\n* When the [`_admin` variable is set](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/polygon/child/land/PolygonLandV2.sol#L15) in the `initialize` function of the `PolygonLandV2` contract\n* When the [`_trustedForwarder` is set](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/common/BaseWithStorage/ERC2771Handler.sol#L13) in the initializer of the `ERC2771Handler` contract\n* When the [`_trustedForwarder` is set](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/polygon/child/land/PolygonLandV2.sol#L22) using the `setTrustedForwarder` method in the `PolygonLandV2` contract\n* When the [filter registry is set](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/polygon/child/land/PolygonLandV2.sol#L172) in the `PolygonLandV2` contract\n* When the [LAND contract is registered](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/polygon/child/land/PolygonLandV2.sol#L164) on the Operator Filterer Registry in the `PolygonLandV2` contract\n* When the [`_trustedForwarder` is set](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/polygon/root/land/LandTunnelV2.sol#L93) using the `setTrustedForwarder` method in the `LandTunnelV2` contract\n* When the [`_trustedForwarder` is set](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/polygon/child/land/PolygonLandTunnelV2.sol#L129) using the `setTrustedForwarder` method in the `PolygonLandTunnelV2` contract\n* When the [`maxGasLimitOnL1` and `maxAllowedQuads` state variables are set](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/polygon/child/land/PolygonLandTunnelV2.sol#L82-L83) in the `initialize` function in the `PolygonLandTunnelV2` contract\n* When the [`admin` is set](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/polygon/child/land/PolygonLandTunnelMigration.sol#L58) in the `constructor` of the `PolygonLandTunnelMigration` contract\n* When the [`admin` is set](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/polygon/root/land/LandTunnelMigration.sol#L48) in the `constructor` of the `LandTunnelMigration` contract\n\n\nConsider emitting events after sensitive changes occur to facilitate tracking and notify any off-chain clients who may be following the contracts' activity.\n\n\n***Update:** Resolved in [pull request #919](https://github.com/thesandboxgame/sandbox-smart-contracts/pull/919) at commit [c5bb59b](https://github.com/thesandboxgame/sandbox-smart-contracts/pull/919/commits/c5bb59b1f61c4553b7cbab48b190be381a65fdb6).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/solc_0.5/Land/erc721/ERC721BaseTokenV2.sol",
      "content": "/* solhint-disable func-order, code-complexity */\npragma solidity 0.5.9;\n\nimport \"../../contracts_common/Libraries/AddressUtils.sol\";\nimport \"../../contracts_common/Interfaces/ERC721TokenReceiver.sol\";\nimport \"../../contracts_common/Interfaces/ERC721Events.sol\";\nimport \"../../contracts_common/BaseWithStorage/SuperOperatorsV2.sol\";\nimport \"../../contracts_common/BaseWithStorage/MetaTransactionReceiverV2.sol\";\nimport \"../../contracts_common/Interfaces/ERC721MandatoryTokenReceiver.sol\";\n\ncontract ERC721BaseTokenV2 is ERC721Events, SuperOperatorsV2, MetaTransactionReceiverV2 {\n    using AddressUtils for address;\n\n    bytes4 internal constant _ERC721_RECEIVED = 0x150b7a02;\n    bytes4 internal constant _ERC721_BATCH_RECEIVED = 0x4b808c46;\n\n    bytes4 internal constant ERC165ID = 0x01ffc9a7;\n    bytes4 internal constant ERC721_MANDATORY_RECEIVER = 0x5e8bf644;\n\n    mapping (address => uint256) public _numNFTPerAddress;\n    mapping (uint256 => uint256) public _owners;\n    mapping (address => mapping(address => bool)) public _operatorsForAll;\n    mapping (uint256 => address) public _operators;\n\n    bool internal _initialized;\n\n    modifier initializer() {\n        require(!_initialized, \"ERC721BaseToken: Contract already initialized\");\n        _;\n    }\n\n    function initialize (\n        address metaTransactionContract,\n        address admin\n    ) public initializer {\n        _admin = admin;\n        _setMetaTransactionProcessor(metaTransactionContract, true);\n        _initialized = true;\n    }\n\n    function _transferFrom(address from, address to, uint256 id) internal {\n        _numNFTPerAddress[from]--;\n        _numNFTPerAddress[to]++;\n        _owners[id] = uint256(to);\n        emit Transfer(from, to, id);\n    }\n\n    /**\n     * @notice Return the number of Land owned by an address\n     * @param owner The address to look for\n     * @return The number of Land token owned by the address\n     */\n    function balanceOf(address owner) external view returns (uint256) {\n        require(owner != address(0), \"owner is zero address\");\n        return _numNFTPerAddress[owner];\n    }\n\n\n    function _ownerOf(uint256 id) internal view returns (address) {\n        return address(_owners[id]);\n    }\n\n    function _ownerAndOperatorEnabledOf(uint256 id) internal view returns (address owner, bool operatorEnabled) {\n        uint256 data = _owners[id];\n        owner = address(data);\n        operatorEnabled = (data / 2**255) == 1;\n    }\n\n    /**\n     * @notice Return the owner of a Land\n     * @param id The id of the Land\n     * @return The address of the owner\n     */\n    function ownerOf(uint256 id) external view returns (address owner) {\n        owner = _ownerOf(id);\n        require(owner != address(0), \"token does not exist\");\n    }\n\n    function _approveFor(address owner, address operator, uint256 id) internal {\n        if(operator == address(0)) {\n            _owners[id] = uint256(owner); // no need to resset the operator, it will be overriden next time\n        } else {\n            _owners[id] = uint256(owner) + 2**255;\n            _operators[id] = operator;\n        }\n        emit Approval(owner, operator, id);\n    }\n\n    /**\n     * @notice Approve an operator to spend tokens on the sender behalf\n     * @param sender The address giving the approval\n     * @param operator The address receiving the approval\n     * @param id The id of the token\n     */\n    function approveFor(\n        address sender,\n        address operator,\n        uint256 id\n    ) external {\n        address owner = _ownerOf(id);\n        require(sender != address(0), \"sender is zero address\");\n        require(\n            msg.sender == sender ||\n            _metaTransactionContracts[msg.sender] ||\n            _operatorsForAll[sender][msg.sender] ||\n            _superOperators[msg.sender],\n            \"not authorized to approve\"\n        );\n        require(owner == sender, \"owner != sender\");\n        _approveFor(owner, operator, id);\n    }\n\n    /**\n     * @notice Approve an operator to spend tokens on the sender behalf\n     * @param operator The address receiving the approval\n     * @param id The id of the token\n     */\n    function approve(address operator, uint256 id) external {\n        address owner = _ownerOf(id);\n        require(owner != address(0), \"token does not exist\");\n        require(\n            owner == msg.sender ||\n            _operatorsForAll[owner][msg.sender] ||\n            _superOperators[msg.sender],\n            \"not authorized to approve\"\n        );\n        _approveFor(owner, operator, id);\n    }\n\n    /**\n     * @notice Get the approved operator for a specific token\n     * @param id The id of the token\n     * @return The address of the operator\n     */\n    function getApproved(uint256 id) external view returns (address) {\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n        require(owner != address(0), \"token does not exist\");\n        if (operatorEnabled) {\n            return _operators[id];\n        } else {\n            return address(0);\n        }\n    }\n\n    function _checkTransfer(address from, address to, uint256 id) internal view returns (bool isMetaTx) {\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n        require(owner != address(0), \"token does not exist\");\n        require(owner == from, \"not owner in _checkTransfer\");\n        require(to != address(0), \"can't send to zero address\");\n        isMetaTx = msg.sender != from && _metaTransactionContracts[msg.sender];\n        if (msg.sender != from && !isMetaTx) {\n            require(\n                _operatorsForAll[from][msg.sender] ||\n                (operatorEnabled && _operators[id] == msg.sender) ||\n                _superOperators[msg.sender],\n                \"not approved to transfer\"\n            );\n        }\n    }\n\n    function _checkInterfaceWith10000Gas(address _contract, bytes4 interfaceId)\n        internal\n        view\n        returns (bool)\n    {\n        bool success;\n        bool result;\n        bytes memory call_data = abi.encodeWithSelector(\n            ERC165ID,\n            interfaceId\n        );\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let call_ptr := add(0x20, call_data)\n            let call_size := mload(call_data)\n            let output := mload(0x40) // Find empty storage location using \"free memory pointer\"\n            mstore(output, 0x0)\n            success := staticcall(\n                10000,\n                _contract,\n                call_ptr,\n                call_size,\n                output,\n                0x20\n            ) // 32 bytes\n            result := mload(output)\n        }\n        // (10000 / 63) \"not enough for supportsInterface(...)\" // consume all gas, so caller can potentially know that there was not enough gas\n        assert(gasleft() > 158);\n        return success && result;\n    }\n\n    /**\n     * @notice Transfer a token between 2 addresses\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param id The id of the token\n    */\n    function transferFrom(address from, address to, uint256 id) external {\n        bool metaTx = _checkTransfer(from, to, id);\n        _transferFrom(from, to, id);\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n            require(\n                _checkOnERC721Received(metaTx ? from : msg.sender, from, to, id, \"\"),\n                \"erc721 transfer rejected by to\"\n            );\n        }\n    }\n\n    /**\n     * @notice Transfer a token between 2 addresses letting the receiver knows of the transfer\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param id The id of the token\n     * @param data Additional data\n     */\n    function safeTransferFrom(address from, address to, uint256 id, bytes memory data) public {\n        bool metaTx = _checkTransfer(from, to, id);\n        _transferFrom(from, to, id);\n        if (to.isContract()) {\n            require(\n                _checkOnERC721Received(metaTx ? from : msg.sender, from, to, id, data),\n                \"ERC721: transfer rejected by to\"\n            );\n        }\n    }\n\n    /**\n     * @notice Transfer a token between 2 addresses letting the receiver knows of the transfer\n     * @param from The send of the token\n     * @param to The recipient of the token\n     * @param id The id of the token\n     */\n    function safeTransferFrom(address from, address to, uint256 id) external {\n        safeTransferFrom(from, to, id, \"\");\n    }\n\n    /**\n     * @notice Transfer many tokens between 2 addresses\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param ids The ids of the tokens\n     * @param data additional data\n    */\n    function batchTransferFrom(address from, address to, uint256[] calldata ids, bytes calldata data) external {\n        _batchTransferFrom(from, to, ids, data, false);\n    }\n\n    function _batchTransferFrom(address from, address to, uint256[] memory ids, bytes memory data, bool safe) internal {\n        bool metaTx = msg.sender != from && _metaTransactionContracts[msg.sender];\n        bool authorized = msg.sender == from ||\n            metaTx ||\n            _operatorsForAll[from][msg.sender] ||\n            _superOperators[msg.sender];\n\n        require(from != address(0), \"from is zero address\");\n        require(to != address(0), \"can't send to zero address\");\n\n        uint256 numTokens = ids.length;\n        for(uint256 i = 0; i < numTokens; i ++) {\n            uint256 id = ids[i];\n            (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n            require(owner == from, \"not owner in batchTransferFrom\");\n            require(authorized || (operatorEnabled && _operators[id] == msg.sender), \"not authorized\");\n            _owners[id] = uint256(to);\n            emit Transfer(from, to, id);\n        }\n        if (from != to) {\n            _numNFTPerAddress[from] -= numTokens;\n            _numNFTPerAddress[to] += numTokens;\n        }\n\n        if (to.isContract()) {\n            if (_checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n                require(\n                    _checkOnERC721BatchReceived(metaTx ? from : msg.sender, from, to, ids, data),\n                    \"erc721 batch transfer rejected by to\"\n                );\n            } else if (safe) {\n                for (uint256 i = 0; i < numTokens; i ++) {\n                    require(\n                        _checkOnERC721Received(metaTx ? from : msg.sender, from, to, ids[i], \"\"),\n                        \"erc721 transfer rejected by to\"\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Transfer many tokens between 2 addresses ensuring the receiving contract has a receiver method\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param ids The ids of the tokens\n     * @param data additional data\n    */\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, bytes calldata data) external {\n        _batchTransferFrom(from, to, ids, data, true);\n    }\n\n    /**\n     * @notice Check if the contract supports an interface\n     * 0x01ffc9a7 is ERC-165\n     * 0x80ac58cd is ERC-721\n     * @param id The id of the interface\n     * @return True if the interface is supported\n     */\n    function supportsInterface(bytes4 id) external pure returns (bool) {\n        return id == 0x01ffc9a7 || id == 0x80ac58cd;\n    }\n\n    /**\n     * @notice Set the approval for an operator to manage all the tokens of the sender\n     * @param sender The address giving the approval\n     * @param operator The address receiving the approval\n     * @param approved The determination of the approval\n     */\n    function setApprovalForAllFor(\n        address sender,\n        address operator,\n        bool approved\n    ) external {\n        require(sender != address(0), \"Invalid sender address\");\n        require(\n            msg.sender == sender ||\n            _metaTransactionContracts[msg.sender] ||\n            _superOperators[msg.sender],\n            \"not authorized to approve for all\"\n        );\n\n        _setApprovalForAll(sender, operator, approved);\n    }\n\n    /**\n     * @notice Set the approval for an operator to manage all the tokens of the sender\n     * @param operator The address receiving the approval\n     * @param approved The determination of the approval\n     */\n    function setApprovalForAll(address operator, bool approved) external {\n        _setApprovalForAll(msg.sender, operator, approved);\n    }\n\n\n    function _setApprovalForAll(\n        address sender,\n        address operator,\n        bool approved\n    ) internal {\n        require(\n            !_superOperators[operator],\n            \"super operator can't have their approvalForAll changed\"\n        );\n        _operatorsForAll[sender][operator] = approved;\n\n        emit ApprovalForAll(sender, operator, approved);\n    }\n\n    /**\n     * @notice Check if the sender approved the operator\n     * @param owner The address of the owner\n     * @param operator The address of the operator\n     * @return The status of the approval\n     */\n    function isApprovedForAll(address owner, address operator)\n        external\n        view\n        returns (bool isOperator)\n    {\n        return _operatorsForAll[owner][operator] || _superOperators[operator];\n    }\n\n    function _burn(address from, address owner, uint256 id) internal {\n        require(from == owner, \"not owner\");\n        _owners[id] = 2**160; // cannot mint it again\n        _numNFTPerAddress[from]--;\n        emit Transfer(from, address(0), id);\n    }\n\n    /// @notice Burns token `id`.\n    /// @param id token which will be burnt.\n    function burn(uint256 id) external {\n        _burn(msg.sender, _ownerOf(id), id);\n    }\n\n    /// @notice Burn token`id` from `from`.\n    /// @param from address whose token is to be burnt.\n    /// @param id token which will be burnt.\n    function burnFrom(address from, uint256 id) external {\n        require(from != address(0), \"Invalid sender address\");\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n        require(\n            msg.sender == from ||\n            _metaTransactionContracts[msg.sender] ||\n            (operatorEnabled && _operators[id] == msg.sender) ||\n            _operatorsForAll[from][msg.sender] ||\n            _superOperators[msg.sender],\n            \"not authorized to burn\"\n        );\n        _burn(from, owner, id);\n    }\n\n    function _checkOnERC721Received(address operator, address from, address to, uint256 tokenId, bytes memory _data)\n        internal returns (bool)\n    {\n        bytes4 retval = ERC721TokenReceiver(to).onERC721Received(operator, from, tokenId, _data);\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    function _checkOnERC721BatchReceived(address operator, address from, address to, uint256[] memory ids, bytes memory _data)\n        internal returns (bool)\n    {\n        bytes4 retval = ERC721MandatoryTokenReceiver(to).onERC721BatchReceived(operator, from, ids, _data);\n        return (retval == _ERC721_BATCH_RECEIVED);\n    }\n\n    // Empty storage space in contracts for future enhancements\n    // ref: https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/issues/13)\n    uint256[49] private __gap;\n}"
    },
    {
      "filename": "src/solc_0.5/LandV3.sol",
      "content": "/* solhint-disable no-empty-blocks */\n\npragma solidity 0.5.9;\n\nimport \"./Land/erc721/LandBaseTokenV3.sol\";\nimport \"./Land/erc721/ERC721BaseTokenV2.sol\";\nimport \"./OperatorFilterer/contracts/upgradeable/OperatorFiltererUpgradeable.sol\";\n\ncontract LandV3 is LandBaseTokenV3, OperatorFiltererUpgradeable {\n    /**\n     * @notice Return the name of the token contract\n     * @return The name of the token contract\n     */\n    function name() external pure returns (string memory) {\n        return \"Sandbox's LANDs\";\n    }\n\n    /**\n     * @notice Return the symbol of the token contract\n     * @return The symbol of the token contract\n     */\n    function symbol() external pure returns (string memory) {\n        return \"LAND\";\n    }\n\n    // solium-disable-next-line security/no-assign-params\n    function uint2str(uint256 _i) internal pure returns (string memory) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint256 j = _i;\n        uint256 len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint256 k = len - 1;\n        while (_i != 0) {\n            bstr[k--] = byte(uint8(48 + (_i % 10)));\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n\n    /**\n     * @notice Return the URI of a specific token\n     * @param id The id of the token\n     * @return The URI of the token\n     */\n    function tokenURI(uint256 id) public view returns (string memory) {\n        require(_ownerOf(id) != address(0), \"LandV3: Id does not exist\");\n        return string(abi.encodePacked(\"https://api.sandbox.game/lands/\", uint2str(id), \"/metadata.json\"));\n    }\n\n    /**\n     * @notice Check if the contract supports an interface\n     * 0x01ffc9a7 is ERC-165\n     * 0x80ac58cd is ERC-721\n     * 0x5b5e139f is ERC-721 metadata\n     * @param id The id of the interface\n     * @return True if the interface is supported\n     */\n    function supportsInterface(bytes4 id) external pure returns (bool) {\n        return id == 0x01ffc9a7 || id == 0x80ac58cd || id == 0x5b5e139f;\n    }\n\n    /// @notice This function is used to register Land contract on the Operator Filterer Registry of Opensea.can only be called by admin.\n    /// @dev used to register contract and subscribe to the subscriptionOrRegistrantToCopy's black list.\n    /// @param subscriptionOrRegistrantToCopy registration address of the list to subscribe.\n    /// @param subscribe bool to signify subscription \"true\"\" or to copy the list \"false\".\n    function register(address subscriptionOrRegistrantToCopy, bool subscribe) external onlyAdmin {\n        require(subscriptionOrRegistrantToCopy != address(0),\"LandV3: subscription can't be zero address\");\n        _register(subscriptionOrRegistrantToCopy, subscribe);\n    }\n\n    /// @notice sets filter registry address deployed in test\n    /// @param registry the address of the registry\n    function setOperatorRegistry(address registry) external onlyAdmin {\n        operatorFilterRegistry = IOperatorFilterRegistry(registry);\n    }\n\n    /**\n     * @notice Approve an operator to spend tokens on the sender behalf\n     * @param sender The address giving the approval\n     * @param operator The address receiving the approval\n     * @param id The id of the token\n     */\n    function approveFor(\n        address sender,\n        address operator,\n        uint256 id\n    ) external onlyAllowedOperatorApproval(operator) {\n        address owner = _ownerOf(id);\n        require(sender != address(0), \"LandV3: sender is zero address\");\n        require(\n            msg.sender == sender ||\n                _metaTransactionContracts[msg.sender] ||\n                _operatorsForAll[sender][msg.sender] ||\n                _superOperators[msg.sender],\n            \"LandV3: not authorized to approve\"\n        );\n        require(owner == sender, \"LandV3: owner != sender\");\n        _approveFor(owner, operator, id);\n    }\n\n    /**\n     * @notice Set the approval for an operator to manage all the tokens of the sender\n     * @param operator The address receiving the approval\n     * @param approved The determination of the approval\n     */\n    function setApprovalForAll(address operator, bool approved) external onlyAllowedOperatorApproval(operator) {\n        _setApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /**\n     * @notice Set the approval for an operator to manage all the tokens of the sender\n     * @param sender The address giving the approval\n     * @param operator The address receiving the approval\n     * @param approved The determination of the approval\n     */\n    function setApprovalForAllFor(\n        address sender,\n        address operator,\n        bool approved\n    ) external onlyAllowedOperatorApproval(operator) {\n        require(sender != address(0), \"LandV3: Invalid sender address\");\n        require(\n            msg.sender == sender || _metaTransactionContracts[msg.sender] || _superOperators[msg.sender],\n            \"LandV3: not authorized to approve for all\"\n        );\n\n        _setApprovalForAll(sender, operator, approved);\n    }\n\n    /**\n     * @notice Approve an operator to spend tokens on the sender behalf\n     * @param operator The address receiving the approval\n     * @param id The id of the token\n     */\n    function approve(address operator, uint256 id) external onlyAllowedOperatorApproval(operator) {\n        address owner = _ownerOf(id);\n        require(owner != address(0), \"LandV3: token does not exist\");\n        require(\n            owner == msg.sender || _operatorsForAll[owner][msg.sender] || _superOperators[msg.sender],\n            \"LandV3: not authorized to approve\"\n        );\n        _approveFor(owner, operator, id);\n    }\n\n    /**\n     * @notice Transfer a token between 2 addresses\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param id The id of the token\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) external onlyAllowedOperator(from) {\n        bool metaTx = _checkTransfer(from, to, id);\n        _transferFrom(from, to, id);\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n            require(\n                _checkOnERC721Received(metaTx ? from : msg.sender, from, to, id, \"\"),\n                \"LandV3: erc721 transfer rejected by to\"\n            );\n        }\n    }\n\n    /**\n     * @notice Transfer a token between 2 addresses letting the receiver knows of the transfer\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param id The id of the token\n     * @param data Additional data\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes memory data\n    ) public onlyAllowedOperator(from) {\n        super.safeTransferFrom(from, to, id, data);\n    }\n\n    /**\n     * @notice Transfer a token between 2 addresses letting the receiver knows of the transfer\n     * @param from The send of the token\n     * @param to The recipient of the token\n     * @param id The id of the token\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) external onlyAllowedOperator(from) {\n        super.safeTransferFrom(from, to, id, \"\");\n    }\n}"
    },
    {
      "filename": "src/solc_0.5/LandV3.sol",
      "content": "/* solhint-disable no-empty-blocks */\n\npragma solidity 0.5.9;\n\nimport \"./Land/erc721/LandBaseTokenV3.sol\";\nimport \"./Land/erc721/ERC721BaseTokenV2.sol\";\nimport \"./OperatorFilterer/contracts/upgradeable/OperatorFiltererUpgradeable.sol\";\n\ncontract LandV3 is LandBaseTokenV3, OperatorFiltererUpgradeable {\n    /**\n     * @notice Return the name of the token contract\n     * @return The name of the token contract\n     */\n    function name() external pure returns (string memory) {\n        return \"Sandbox's LANDs\";\n    }\n\n    /**\n     * @notice Return the symbol of the token contract\n     * @return The symbol of the token contract\n     */\n    function symbol() external pure returns (string memory) {\n        return \"LAND\";\n    }\n\n    // solium-disable-next-line security/no-assign-params\n    function uint2str(uint256 _i) internal pure returns (string memory) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint256 j = _i;\n        uint256 len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint256 k = len - 1;\n        while (_i != 0) {\n            bstr[k--] = byte(uint8(48 + (_i % 10)));\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n\n    /**\n     * @notice Return the URI of a specific token\n     * @param id The id of the token\n     * @return The URI of the token\n     */\n    function tokenURI(uint256 id) public view returns (string memory) {\n        require(_ownerOf(id) != address(0), \"LandV3: Id does not exist\");\n        return string(abi.encodePacked(\"https://api.sandbox.game/lands/\", uint2str(id), \"/metadata.json\"));\n    }\n\n    /**\n     * @notice Check if the contract supports an interface\n     * 0x01ffc9a7 is ERC-165\n     * 0x80ac58cd is ERC-721\n     * 0x5b5e139f is ERC-721 metadata\n     * @param id The id of the interface\n     * @return True if the interface is supported\n     */\n    function supportsInterface(bytes4 id) external pure returns (bool) {\n        return id == 0x01ffc9a7 || id == 0x80ac58cd || id == 0x5b5e139f;\n    }\n\n    /// @notice This function is used to register Land contract on the Operator Filterer Registry of Opensea.can only be called by admin.\n    /// @dev used to register contract and subscribe to the subscriptionOrRegistrantToCopy's black list.\n    /// @param subscriptionOrRegistrantToCopy registration address of the list to subscribe.\n    /// @param subscribe bool to signify subscription \"true\"\" or to copy the list \"false\".\n    function register(address subscriptionOrRegistrantToCopy, bool subscribe) external onlyAdmin {\n        require(subscriptionOrRegistrantToCopy != address(0),\"LandV3: subscription can't be zero address\");\n        _register(subscriptionOrRegistrantToCopy, subscribe);\n    }\n\n    /// @notice sets filter registry address deployed in test\n    /// @param registry the address of the registry\n    function setOperatorRegistry(address registry) external onlyAdmin {\n        operatorFilterRegistry = IOperatorFilterRegistry(registry);\n    }\n\n    /**\n     * @notice Approve an operator to spend tokens on the sender behalf\n     * @param sender The address giving the approval\n     * @param operator The address receiving the approval\n     * @param id The id of the token\n     */\n    function approveFor(\n        address sender,\n        address operator,\n        uint256 id\n    ) external onlyAllowedOperatorApproval(operator) {\n        address owner = _ownerOf(id);\n        require(sender != address(0), \"LandV3: sender is zero address\");\n        require(\n            msg.sender == sender ||\n                _metaTransactionContracts[msg.sender] ||\n                _operatorsForAll[sender][msg.sender] ||\n                _superOperators[msg.sender],\n            \"LandV3: not authorized to approve\"\n        );\n        require(owner == sender, \"LandV3: owner != sender\");\n        _approveFor(owner, operator, id);\n    }\n\n    /**\n     * @notice Set the approval for an operator to manage all the tokens of the sender\n     * @param operator The address receiving the approval\n     * @param approved The determination of the approval\n     */\n    function setApprovalForAll(address operator, bool approved) external onlyAllowedOperatorApproval(operator) {\n        _setApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /**\n     * @notice Set the approval for an operator to manage all the tokens of the sender\n     * @param sender The address giving the approval\n     * @param operator The address receiving the approval\n     * @param approved The determination of the approval\n     */\n    function setApprovalForAllFor(\n        address sender,\n        address operator,\n        bool approved\n    ) external onlyAllowedOperatorApproval(operator) {\n        require(sender != address(0), \"LandV3: Invalid sender address\");\n        require(\n            msg.sender == sender || _metaTransactionContracts[msg.sender] || _superOperators[msg.sender],\n            \"LandV3: not authorized to approve for all\"\n        );\n\n        _setApprovalForAll(sender, operator, approved);\n    }\n\n    /**\n     * @notice Approve an operator to spend tokens on the sender behalf\n     * @param operator The address receiving the approval\n     * @param id The id of the token\n     */\n    function approve(address operator, uint256 id) external onlyAllowedOperatorApproval(operator) {\n        address owner = _ownerOf(id);\n        require(owner != address(0), \"LandV3: token does not exist\");\n        require(\n            owner == msg.sender || _operatorsForAll[owner][msg.sender] || _superOperators[msg.sender],\n            \"LandV3: not authorized to approve\"\n        );\n        _approveFor(owner, operator, id);\n    }\n\n    /**\n     * @notice Transfer a token between 2 addresses\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param id The id of the token\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) external onlyAllowedOperator(from) {\n        bool metaTx = _checkTransfer(from, to, id);\n        _transferFrom(from, to, id);\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n            require(\n                _checkOnERC721Received(metaTx ? from : msg.sender, from, to, id, \"\"),\n                \"LandV3: erc721 transfer rejected by to\"\n            );\n        }\n    }\n\n    /**\n     * @notice Transfer a token between 2 addresses letting the receiver knows of the transfer\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param id The id of the token\n     * @param data Additional data\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes memory data\n    ) public onlyAllowedOperator(from) {\n        super.safeTransferFrom(from, to, id, data);\n    }\n\n    /**\n     * @notice Transfer a token between 2 addresses letting the receiver knows of the transfer\n     * @param from The send of the token\n     * @param to The recipient of the token\n     * @param id The id of the token\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) external onlyAllowedOperator(from) {\n        super.safeTransferFrom(from, to, id, \"\");\n    }\n}"
    },
    {
      "filename": "src/solc_0.8/polygon/child/land/PolygonLandV2.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.2;\n\nimport \"./PolygonLandBaseTokenV2.sol\";\nimport \"../../../common/BaseWithStorage/ERC2771Handler.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"../../../OperatorFilterer/contracts/upgradeable/OperatorFiltererUpgradeable.sol\";\n\n/// @title LAND token on L2\ncontract PolygonLandV2 is PolygonLandBaseTokenV2, ERC2771Handler, OperatorFiltererUpgradeable {\n    using AddressUpgradeable for address;\n\n    function initialize(address trustedForwarder) external initializer {\n        _admin = _msgSender();\n        __ERC2771Handler_initialize(trustedForwarder);\n    }\n\n    /// @dev Change the address of the trusted forwarder for meta-TX\n    /// @param trustedForwarder The new trustedForwarder\n    function setTrustedForwarder(address trustedForwarder) external onlyAdmin {\n        _trustedForwarder = trustedForwarder;\n    }\n\n    function _msgSender() internal view override(ContextUpgradeable, ERC2771Handler) returns (address sender) {\n        return ERC2771Handler._msgSender();\n    }\n\n    function _msgData() internal view override(ContextUpgradeable, ERC2771Handler) returns (bytes calldata) {\n        return ERC2771Handler._msgData();\n    }\n\n    /**\n     * @notice Approve an operator to spend tokens on the sender behalf\n     * @param sender The address giving the approval\n     * @param operator The address receiving the approval\n     * @param id The id of the token\n     */\n    function approveFor(\n        address sender,\n        address operator,\n        uint256 id\n    ) external override onlyAllowedOperatorApproval(operator) {\n        uint256 ownerData = _owners[_storageId(id)];\n        address owner = _ownerOf(id);\n        address msgSender = _msgSender();\n        require(sender != address(0), \"PolygonLandV2: ZERO_ADDRESS_SENDER\");\n        require(owner != address(0), \"PolygonLandV2: NONEXISTENT_TOKEN\");\n        require(\n            msgSender == sender || _operatorsForAll[sender][msgSender] || _superOperators[msgSender],\n            \"PolygonLandV2: UNAUTHORIZED_APPROVAL\"\n        );\n        require(address(uint160(ownerData)) == sender, \"PolygonLandV2: OWNER_NOT_SENDER\");\n        _approveFor(ownerData, operator, id);\n    }\n\n    /**\n     * @notice Approve an operator to spend tokens on the sender behalf\n     * @param operator The address receiving the approval\n     * @param id The id of the token\n     */\n    function approve(address operator, uint256 id) external override onlyAllowedOperatorApproval(operator) {\n        uint256 ownerData = _owners[_storageId(id)]"
    }
  ]
}