{
  "Title": "[G-39] Use AND operators instead of modulo (%) to check if number is odd/even",
  "Content": "\n**Files:** `L2ContractHelper.sol`, `Utils.sol`, `Merkle.sol`, `KnownCodesStorage.sol`\n\n[File: code/contracts/ethereum/contracts/common/libraries/L2ContractHelper.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/common/libraries/L2ContractHelper.sol#L43)\n```solidity\n43:         require(bytecodeLen(_bytecodeHash) % 2 == 1, \"uy\"); // Code length in words must be odd\n```\n\n[File: code/contracts/ethereum/contracts/common/libraries/L2ContractHelper.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/common/libraries/L2ContractHelper.sol#L27)\n```solidity\n27:         require(bytecodeLenInWords % 2 == 1, \"ps\"); // bytecode length in words must be odd\n```\n\n[File: code/contracts/ethereum/contracts/state-transition/libraries/Merkle.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/libraries/Merkle.sol#L30)\n```solidity\n30:             currentHash = (_index % 2 == 0)\n```\n\n[File: code/system-contracts/contracts/KnownCodesStorage.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/KnownCodesStorage.sol#L78)\n```solidity\n78:         require(Utils.bytecodeLenInWords(_bytecodeHash) % 2 == 1, \"Code length in words must be odd\");\n```\n\n[File: code/system-contracts/contracts/libraries/Utils.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/libraries/Utils.sol#L88)\n```solidity\n88:         require(lengthInWords % 2 == 1, \"pr\"); // bytecode length in words must be odd\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-03-zksync",
  "Code": [
    {
      "filename": "code/contracts/ethereum/contracts/common/libraries/L2ContractHelper.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice Helper library for working with L2 contracts on L1.\n */\nlibrary L2ContractHelper {\n    /// @dev The prefix used to create CREATE2 addresses.\n    bytes32 private constant CREATE2_PREFIX = keccak256(\"zksyncCreate2\");\n\n    /// @notice Validate the bytecode format and calculate its hash.\n    /// @param _bytecode The bytecode to hash.\n    /// @return hashedBytecode The 32-byte hash of the bytecode.\n    /// Note: The function reverts the execution if the bytecode has non expected format:\n    /// - Bytecode bytes length is not a multiple of 32\n    /// - Bytecode bytes length is not less than 2^21 bytes (2^16 words)\n    /// - Bytecode words length is not odd\n    function hashL2Bytecode(bytes memory _bytecode) internal pure returns (bytes32 hashedBytecode) {\n        // Note that the length of the bytecode must be provided in 32-byte words.\n        require(_bytecode.length % 32 == 0, \"pq\");\n\n        uint256 bytecodeLenInWords = _bytecode.length / 32;\n        require(bytecodeLenInWords < 2 ** 16, \"pp\"); // bytecode length must be less than 2^16 words\n        require(bytecodeLenInWords % 2 == 1, \"ps\"); // bytecode length in words must be odd\n        hashedBytecode = sha256(_bytecode) & 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        // Setting the version of the hash\n        hashedBytecode = (hashedBytecode | bytes32(uint256(1 << 248)));\n        // Setting the length\n        hashedBytecode = hashedBytecode | bytes32(bytecodeLenInWords << 224);\n    }\n\n    /// @notice Validates the format of the given bytecode hash.\n    /// @dev Due to the specification of the L2 bytecode hash, not every 32 bytes could be a legit bytecode hash.\n    /// @dev The function reverts on invalid bytecode hash formam.\n    /// @param _bytecodeHash The hash of the bytecode to validate.\n    function validateBytecodeHash(bytes32 _bytecodeHash) internal pure {\n        uint8 version = uint8(_bytecodeHash[0]);\n        require(version == 1 && _bytecodeHash[1] == bytes1(0), \"zf\"); // Incorrectly formatted bytecodeHash\n\n        require(bytecodeLen(_bytecodeHash) % 2 == 1, \"uy\"); // Code length in words must be odd\n    }\n\n    /// @notice Returns the length of the bytecode associated with the given hash.\n    /// @param _bytecodeHash The hash of the bytecode.\n    /// @return codeLengthInWords The length of the bytecode in words.\n    function bytecodeLen(bytes32 _bytecodeHash) internal pure returns (uint256 codeLengthInWords) {\n        codeLengthInWords = uint256(uint8(_bytecodeHash[2])) * 256 + uint256(uint8(_bytecodeHash[3]));\n    }\n\n    /// @notice Computes the create2 address for a Layer 2 contract.\n    /// @param _sender The address of the sender.\n    /// @param _salt The salt value to use in the create2 address computation.\n    /// @param _bytecodeHash The contract bytecode hash.\n    /// @param _constructorInputHash The hash of the constructor input data.\n    /// @return The create2 address of the contract.\n    /// NOTE: L2 create2 derivation is different from L1 derivation!\n    function computeCreate2Address(\n        address _sender,\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes32 _constructorInputHash\n    ) internal pure returns (address) {\n        bytes32 senderBytes = bytes32(uint256(uint160(_sender)));\n        bytes32 data = keccak256(\n            bytes.concat(CREATE2_PREFIX, senderBytes, _salt, _bytecodeHash, _constructorInputHash)\n        );\n\n        return address(uint160(uint256(data)));\n    }\n}"
    },
    {
      "filename": "code/contracts/ethereum/contracts/common/libraries/L2ContractHelper.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice Helper library for working with L2 contracts on L1.\n */\nlibrary L2ContractHelper {\n    /// @dev The prefix used to create CREATE2 addresses.\n    bytes32 private constant CREATE2_PREFIX = keccak256(\"zksyncCreate2\");\n\n    /// @notice Validate the bytecode format and calculate its hash.\n    /// @param _bytecode The bytecode to hash.\n    /// @return hashedBytecode The 32-byte hash of the bytecode.\n    /// Note: The function reverts the execution if the bytecode has non expected format:\n    /// - Bytecode bytes length is not a multiple of 32\n    /// - Bytecode bytes length is not less than 2^21 bytes (2^16 words)\n    /// - Bytecode words length is not odd\n    function hashL2Bytecode(bytes memory _bytecode) internal pure returns (bytes32 hashedBytecode) {\n        // Note that the length of the bytecode must be provided in 32-byte words.\n        require(_bytecode.length % 32 == 0, \"pq\");\n\n        uint256 bytecodeLenInWords = _bytecode.length / 32;\n        require(bytecodeLenInWords < 2 ** 16, \"pp\"); // bytecode length must be less than 2^16 words\n        require(bytecodeLenInWords % 2 == 1, \"ps\"); // bytecode length in words must be odd\n        hashedBytecode = sha256(_bytecode) & 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        // Setting the version of the hash\n        hashedBytecode = (hashedBytecode | bytes32(uint256(1 << 248)));\n        // Setting the length\n        hashedBytecode = hashedBytecode | bytes32(bytecodeLenInWords << 224);\n    }\n\n    /// @notice Validates the format of the given bytecode hash.\n    /// @dev Due to the specification of the L2 bytecode hash, not every 32 bytes could be a legit bytecode hash.\n    /// @dev The function reverts on invalid bytecode hash formam.\n    /// @param _bytecodeHash The hash of the bytecode to validate.\n    function validateBytecodeHash(bytes32 _bytecodeHash) internal pure {\n        uint8 version = uint8(_bytecodeHash[0]);\n        require(version == 1 && _bytecodeHash[1] == bytes1(0), \"zf\"); // Incorrectly formatted bytecodeHash\n\n        require(bytecodeLen(_bytecodeHash) % 2 == 1, \"uy\"); // Code length in words must be odd\n    }\n\n    /// @notice Returns the length of the bytecode associated with the given hash.\n    /// @param _bytecodeHash The hash of the bytecode.\n    /// @return codeLengthInWords The length of the bytecode in words.\n    function bytecodeLen(bytes32 _bytecodeHash) internal pure returns (uint256 codeLengthInWords) {\n        codeLengthInWords = uint256(uint8(_bytecodeHash[2])) * 256 + uint256(uint8(_bytecodeHash[3]));\n    }\n\n    /// @notice Computes the create2 address for a Layer 2 contract.\n    /// @param _sender The address of the sender.\n    /// @param _salt The salt value to use in the create2 address computation.\n    /// @param _bytecodeHash The contract bytecode hash.\n    /// @param _constructorInputHash The hash of the constructor input data.\n    /// @return The create2 address of the contract.\n    /// NOTE: L2 create2 derivation is different from L1 derivation!\n    function computeCreate2Address(\n        address _sender,\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes32 _constructorInputHash\n    ) internal pure returns (address) {\n        bytes32 senderBytes = bytes32(uint256(uint160(_sender)));\n        bytes32 data = keccak256(\n            bytes.concat(CREATE2_PREFIX, senderBytes, _salt, _bytecodeHash, _constructorInputHash)\n        );\n\n        return address(uint160(uint256(data)));\n    }\n}"
    },
    {
      "filename": "code/contracts/ethereum/contracts/state-transition/libraries/Merkle.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {UncheckedMath} from \"../../common/libraries/UncheckedMath.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\nlibrary Merkle {\n    using UncheckedMath for uint256;\n\n    /// @dev Calculate Merkle root by the provided Merkle proof.\n    /// NOTE: When using this function, check that the _path length is equal to the tree height to prevent shorter/longer paths attack\n    /// @param _path Merkle path from the leaf to the root\n    /// @param _index Leaf index in the tree\n    /// @param _itemHash Hash of leaf content\n    /// @return The Merkle root\n    function calculateRoot(\n        bytes32[] calldata _path,\n        uint256 _index,\n        bytes32 _itemHash\n    ) internal pure returns (bytes32) {\n        uint256 pathLength = _path.length;\n        require(pathLength > 0, \"xc\");\n        require(pathLength < 256, \"bt\");\n        require(_index < (1 << pathLength), \"px\");\n\n        bytes32 currentHash = _itemHash;\n        for (uint256 i; i < pathLength; i = i.uncheckedInc()) {\n            currentHash = (_index % 2 == 0)\n                ? _efficientHash(currentHash, _path[i])\n                : _efficientHash(_path[i], currentHash);\n            _index /= 2;\n        }\n\n        return currentHash;\n    }\n\n    /// @dev Keccak hash of the concatenation of two 32-byte words\n    function _efficientHash(bytes32 _lhs, bytes32 _rhs) private pure returns (bytes32 result) {\n        assembly {\n            mstore(0x00, _lhs)\n            mstore(0x20, _rhs)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n}"
    },
    {
      "filename": "code/system-contracts/contracts/KnownCodesStorage.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {IKnownCodesStorage} from \"./interfaces/IKnownCodesStorage.sol\";\nimport {ISystemContract} from \"./interfaces/ISystemContract.sol\";\nimport {Utils} from \"./libraries/Utils.sol\";\nimport {COMPRESSOR_CONTRACT, L1_MESSENGER_CONTRACT} from \"./Constants.sol\";\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice The storage of this contract will basically serve as a mapping for the known code hashes.\n * @dev Code hash is not strictly a hash, it's a structure where the first byte denotes the version of the hash,\n * the second byte denotes whether the contract is constructed, and the next two bytes denote the length in 32-byte words.\n * And then the next 28 bytes is the truncated hash.\n */\ncontract KnownCodesStorage is IKnownCodesStorage, ISystemContract {\n    modifier onlyCompressor() {\n        require(msg.sender == address(COMPRESSOR_CONTRACT), \"Callable only by the compressor\");\n        _;\n    }\n\n    /// @notice The method that is used by the bootloader to mark several bytecode hashes as known.\n    /// @param _shouldSendToL1 Whether the bytecode should be sent on L1.\n    /// @param _hashes Hashes of the bytecodes to be marked as known.\n    function markFactoryDeps(bool _shouldSendToL1, bytes32[] calldata _hashes) external onlyCallFromBootloader {\n        unchecked {\n            uint256 hashesLen = _hashes.length;\n            for (uint256 i = 0; i < hashesLen; ++i) {\n                _markBytecodeAsPublished(_hashes[i], _shouldSendToL1);\n            }\n        }\n    }\n\n    /// @notice The method used to mark a single bytecode hash as known.\n    /// @dev Only trusted contacts can call this method, currently only the bytecode compressor.\n    /// @param _bytecodeHash The hash of the bytecode that is marked as known.\n    function markBytecodeAsPublished(bytes32 _bytecodeHash) external onlyCompressor {\n        _markBytecodeAsPublished(_bytecodeHash, false);\n    }\n\n    /// @notice The method used to mark a single bytecode hash as known\n    /// @param _bytecodeHash The hash of the bytecode that is marked as known\n    /// @param _shouldSendToL1 Whether the bytecode should be sent on L1\n    function _markBytecodeAsPublished(bytes32 _bytecodeHash, bool _shouldSendToL1) internal {\n        if (getMarker(_bytecodeHash) == 0) {\n            _validateBytecode(_bytecodeHash);\n\n            if (_shouldSendToL1) {\n                L1_MESSENGER_CONTRACT.requestBytecodeL1Publication(_bytecodeHash);\n            }\n\n            // Save as known, to not resend the log to L1\n            assembly {\n                sstore(_bytecodeHash, 1)\n            }\n\n            emit MarkedAsKnown(_bytecodeHash, _shouldSendToL1);\n        }\n    }\n\n    /// @notice Returns the marker stored for a bytecode hash. 1 means that the bytecode hash is known\n    /// and can be used for deploying contracts. 0 otherwise.\n    function getMarker(bytes32 _hash) public view override returns (uint256 marker) {\n        assembly {\n            marker := sload(_hash)\n        }\n    }\n\n    /// @notice Validates the format of bytecodehash\n    /// @dev zk-circuit accepts & handles only valid format of bytecode hash, other input has undefined behavior\n    /// That's why we need to validate it\n    function _validateBytecode(bytes32 _bytecodeHash) internal pure {\n        uint8 version = uint8(_bytecodeHash[0]);\n        require(version == 1 && _bytecodeHash[1] == bytes1(0), \"Incorrectly formatted bytecodeHash\");\n\n        require(Utils.bytecodeLenInWords(_bytecodeHash) % 2 == 1, \"Code length in words must be odd\");\n    }\n}"
    },
    {
      "filename": "code/system-contracts/contracts/libraries/Utils.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport \"./EfficientCall.sol\";\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @dev Common utilities used in zkSync system contracts\n */\nlibrary Utils {\n    /// @dev Bit mask of bytecode hash \"isConstructor\" marker\n    bytes32 constant IS_CONSTRUCTOR_BYTECODE_HASH_BIT_MASK =\n        0x00ff000000000000000000000000000000000000000000000000000000000000;\n\n    /// @dev Bit mask to set the \"isConstructor\" marker in the bytecode hash\n    bytes32 constant SET_IS_CONSTRUCTOR_MARKER_BIT_MASK =\n        0x0001000000000000000000000000000000000000000000000000000000000000;\n\n    function safeCastToU128(uint256 _x) internal pure returns (uint128) {\n        require(_x <= type(uint128).max, \"Overflow\");\n\n        return uint128(_x);\n    }\n\n    function safeCastToU32(uint256 _x) internal pure returns (uint32) {\n        require(_x <= type(uint32).max, \"Overflow\");\n\n        return uint32(_x);\n    }\n\n    function safeCastToU24(uint256 _x) internal pure returns (uint24) {\n        require(_x <= type(uint24).max, \"Overflow\");\n\n        return uint24(_x);\n    }\n\n    /// @return codeLength The bytecode length in bytes\n    function bytecodeLenInBytes(bytes32 _bytecodeHash) internal pure returns (uint256 codeLength) {\n        codeLength = bytecodeLenInWords(_bytecodeHash) << 5; // _bytecodeHash * 32\n    }\n\n    /// @return codeLengthInWords The bytecode length in machine words\n    function bytecodeLenInWords(bytes32 _bytecodeHash) internal pure returns (uint256 codeLengthInWords) {\n        unchecked {\n            codeLengthInWords = uint256(uint8(_bytecodeHash[2])) * 256 + uint256(uint8(_bytecodeHash[3]));\n        }\n    }\n\n    /// @notice Denotes whether bytecode hash corresponds to a contract that already constructed\n    function isContractConstructed(bytes32 _bytecodeHash) internal pure returns (bool) {\n        return _bytecodeHash[1] == 0x00;\n    }\n\n    /// @notice Denotes whether bytecode hash corresponds to a contract that is on constructor or has already been constructed\n    function isContractConstructing(bytes32 _bytecodeHash) internal pure returns (bool) {\n        return _bytecodeHash[1] == 0x01;\n    }\n\n    /// @notice Sets \"isConstructor\" flag to TRUE for the bytecode hash\n    /// @param _bytecodeHash The bytecode hash for which it is needed to set the constructing flag\n    /// @return The bytecode hash with \"isConstructor\" flag set to TRUE\n    function constructingBytecodeHash(bytes32 _bytecodeHash) internal pure returns (bytes32) {\n        // Clear the \"isConstructor\" marker and set it to 0x01.\n        return constructedBytecodeHash(_bytecodeHash) | SET_IS_CONSTRUCTOR_MARKER_BIT_MASK;\n    }\n\n    /// @notice Sets \"isConstructor\" flag to FALSE for the bytecode hash\n    /// @param _bytecodeHash The bytecode hash for which it is needed to set the constructing flag\n    /// @return The bytecode hash with \"isConstructor\" flag set to FALSE\n    function constructedBytecodeHash(bytes32 _bytecodeHash) internal pure returns (bytes32) {\n        return _bytecodeHash & ~IS_CONSTRUCTOR_BYTECODE_HASH_BIT_MASK;\n    }\n\n    /// @notice Validate the bytecode format and calculate its hash.\n    /// @param _bytecode The bytecode to hash.\n    /// @return hashedBytecode The 32-byte hash of the bytecode.\n    /// Note: The function reverts the execution if the bytecode has non expected format:\n    /// - Bytecode bytes length is not a multiple of 32\n    /// - Bytecode bytes length is not less than 2^21 bytes (2^16 words)\n    /// - Bytecode words length is not odd\n    function hashL2Bytecode(bytes calldata _bytecode) internal view returns (bytes32 hashedBytecode) {\n        // Note that the length of the bytecode must be provided in 32-byte words.\n        require(_bytecode.length % 32 == 0, \"po\");\n\n        uint256 lengthInWords = _bytecode.length / 32;\n        require(lengthInWords < 2 ** 16, \"pp\"); // bytecode length must be less than 2^16 words\n        require(lengthInWords % 2 == 1, \"pr\"); // bytecode length in words must be odd\n        hashedBytecode =\n            EfficientCall.sha(_bytecode) &\n            0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        // Setting the version of the hash\n        hashedBytecode = (hashedBytecode | bytes32(uint256(1 << 248)));\n        // Setting the length\n        hashedBytecode = hashedBytecode | bytes32(lengthInWords << 224);\n    }\n}"
    }
  ]
}