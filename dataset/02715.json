{
  "Title": "H-1: Fixed Term Teller tokens can be created with an expiry in the past",
  "Content": "# Issue H-1: Fixed Term Teller tokens can be created with an expiry in the past \n\nSource: https://github.com/sherlock-audit/2022-11-bond-judging/issues/34 \n\n## Found by \nobront\n\n## Summary\n\nThe Fixed Term Teller does not allow tokens to be created with a timestamp in the past. This is a fact that protocols using this feature will expect to hold and build their systems around. However, users can submit expiry timestamps slightly in the future, which correlate to tokenIds in the past, which allows them to bypass this check.\n\n## Vulnerability Detail\n\nIn `BondFixedTermTeller.sol`, the `create()` function allows protocols to trade their payout tokens directly for bond tokens. The expectation is that protocols will build their own mechanisms around this. It is explicitly required that they cannot do this for bond tokens that expire in the past, only those that have yet to expire:\n\n```solidity\nif (expiry_ < block.timestamp) revert Teller_InvalidParams();\n```\n\nHowever, because tokenIds round timestamps down to the latest day, protocols are able to get around this check.\n\nHere's an example:\n- The most recently expired token has an expiration time of 1668524400 (correlates to 9am this morning)\n- It is currently 1668546000 (3pm this afternoon)\n- A protocol calls create() with an expiry of 1668546000 + 1\n- This passes the check that `expiry_ >= block.timestamp`\n- When the expiry is passed to `getTokenId()` it rounds the time down to the latest day, which is the day corresponding with 9am this morning\n- This expiry associated with this tokenId is 9am this morning, so they are able to redeem their tokens instantly\n\n## Impact\n\nProtocols can bypass the check that all created tokens must have an expiry in the future, and mint tokens with a past expiry that can be redeemed immediately. \n\nThis may not cause a major problem for Bond Protocol itself, but protocols will be building on top of this feature without expecting this behavior. \n\nLet's consider, for example, a protocol that builds a mechanism where users can stake some asset, and the protocol will trade payout tokens to create bond tokens for them at a discount, with the assumption that they will expire in the future. This issue could create an opening for a savvy user to stake, mint bond tokens, redeem and dump them immediately, buy more assets to stake, and continue this cycle to earn arbitrage returns and tank the protocol's token.\n\nBecause there are a number of situations like the one above where this issue could lead to a major loss of funds for a protocol building on top of Bond, I consider this a high severity.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedTermTeller.sol#L97-L105\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nBefore checking whether `expiry_ < block.timestamp`, expiry should be rounded to the nearest day:\n\n```solidity\nexpiry = ((vesting_ + uint48(block.timestamp)) / uint48(1 days)) * uint48(1 days);\n```\n\n## Discussion\n\n**Evert0x**\n\nMessage from sponsor\n\n----\n\nAgree with this finding. We implemented rounding of the expiry before checking whether it is in the past to both the Fixed Term and Fixed Expiry Tellers (fixed expiry added since we made a change to round these to the nearest day as well).\n\n\n**xiaoming9090**\n\nFixed in https://github.com/Bond-Protocol/bonds/commit/54b6833a46b5ae4c3a3ca183b9a55ca8c1266827\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/20",
  "Code": [
    {
      "filename": "src/BondFixedTermTeller.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {BondBaseTeller, IBondAggregator, Authority} from \"./bases/BondBaseTeller.sol\";\nimport {IBondFixedTermTeller} from \"./interfaces/IBondFixedTermTeller.sol\";\n\nimport {TransferHelper} from \"./lib/TransferHelper.sol\";\nimport {FullMath} from \"./lib/FullMath.sol\";\nimport {ERC1155} from \"./lib/ERC1155.sol\";\n\n/// @title Bond Fixed Term Teller\n/// @notice Bond Fixed Term Teller Contract\n/// @dev Bond Protocol is a permissionless system to create Olympus-style bond markets\n///      for any token pair. The markets do not require maintenance and will manage\n///      bond prices based on activity. Bond issuers create BondMarkets that pay out\n///      a Payout Token in exchange for deposited Quote Tokens. Users can purchase\n///      future-dated Payout Tokens with Quote Tokens at the current market price and\n///      receive Bond Tokens to represent their position while their bond vests.\n///      Once the Bond Tokens vest, they can redeem it for the Quote Tokens.\n///\n/// @dev The Bond Fixed Term Teller is an implementation of the\n///      Bond Base Teller contract specific to handling user bond transactions\n///      and tokenizing bond markets where purchases vest in a fixed amount of time\n///      (rounded to the day) as ERC1155 tokens.\n///\n/// @author Oighty, Zeus, Potted Meat, indigo\ncontract BondFixedTermTeller is BondBaseTeller, IBondFixedTermTeller, ERC1155 {\n    using TransferHelper for ERC20;\n    using FullMath for uint256;\n\n    /* ========== EVENTS ========== */\n    event ERC1155BondTokenCreated(uint256 tokenId, ERC20 indexed underlying, uint48 indexed expiry);\n\n    /* ========== STATE VARIABLES ========== */\n\n    mapping(uint256 => TokenMetadata) public tokenMetadata; // metadata for bond tokens\n\n    /* ========== CONSTRUCTOR ========== */\n    constructor(\n        address protocol_,\n        IBondAggregator aggregator_,\n        address guardian_,\n        Authority authority_\n    ) BondBaseTeller(protocol_, aggregator_, guardian_, authority_) {}\n\n    /* ========== PURCHASE ========== */\n\n    /// @notice             Handle payout to recipient\n    /// @param recipient_   Address to receive payout\n    /// @param payout_      Amount of payoutToken to be paid\n    /// @param payoutToken_   Token to be paid out\n    /// @param vesting_     Amount of time to vest from current timestamp\n    /// @return expiry      Timestamp when the payout will vest\n    function _handlePayout(\n        address recipient_,\n        uint256 payout_,\n        ERC20 payoutToken_,\n        uint48 vesting_\n    ) internal override returns (uint48 expiry) {\n        // If there is no vesting time, the deposit is treated as an instant swap.\n        // otherwise, deposit info is stored and payout is available at a future timestamp.\n        // instant swap is denoted by expiry == 0.\n        //\n        // bonds mature with a cliff at a set timestamp\n        // prior to the expiry timestamp, no payout tokens are accessible to the user\n        // after the expiry timestamp, the entire payout can be redeemed\n        //\n        // fixed-term bonds mature in a set amount of time from deposit\n        // i.e. term = 1 week. when alice deposits on day 1, her bond\n        // expires on day 8. when bob deposits on day 2, his bond expires day 9.\n        if (vesting_ != 0) {\n            // Normalizing fixed term vesting timestamps to the same time each day\n            expiry = ((vesting_ + uint48(block.timestamp)) / uint48(1 days)) * uint48(1 days);\n\n            // Fixed-term user payout information is handled in BondTeller.\n            // Teller mints ERC-1155 bond tokens for user.\n            uint256 tokenId = getTokenId(payoutToken_, expiry);\n\n            // Create new bond token if it doesn't exist yet\n            if (!tokenMetadata[tokenId].active) {\n                _deploy(tokenId, payoutToken_, expiry);\n            }\n\n            // Mint bond token to recipient\n            _mintToken(recipient_, tokenId, payout_);\n        } else {\n            // If no expiry, then transfer payout directly to user\n            payoutToken_.safeTransfer(recipient_, payout_);\n        }\n    }\n\n    /* ========== DEPOSIT/MINT ========== */\n\n    /// @inheritdoc IBondFixedTermTeller\n    function create(\n        ERC20 underlying_,\n        uint48 expiry_,\n        uint256 amount_\n    ) external override nonReentrant returns (uint256, uint256) {\n        // Revert if expiry is in the past\n        if (expiry_ < block.timestamp) revert Teller_InvalidParams();\n\n        uint256 tokenId = getTokenId(underlying_, expiry_);\n\n        // Revert if no token exists, must call deploy first\n        if (!tokenMetadata[tokenId].active) revert Teller_TokenDoesNotExist(underlying_, expiry_);\n\n        // Transfer in underlying\n        // Check that amount received is not less than amount expected\n        // Handles edge cases like fee-on-transfer tokens (which are not supported)\n        uint256 oldBalance = underlying_.balanceOf(address(this));\n        underlying_.safeTransferFrom(msg.sender, address(this), amount_);\n        if (underlying_.balanceOf(address(this)) < oldBalance + amount_)\n            revert Teller_UnsupportedToken();\n\n        // If fee is greater than the create discount, then calculate the fee and store it\n        // Otherwise, fee is zero.\n        if (protocolFee > createFeeDiscount) {\n            // Calculate fee amount\n            uint256 feeAmount = amount_.mulDiv(protocolFee - createFeeDiscount, FEE_DECIMALS);\n            rewards[_protocol][underlying_] += feeAmount;\n\n            // Mint new bond tokens\n            _mintToken(msg.sender, tokenId, amount_ - feeAmount);\n\n            return (tokenId, amount_ - feeAmount);\n        } else {\n            // Mint new bond tokens\n            _mintToken(msg.sender, tokenId, amount_);\n\n            return (tokenId, amount_);\n        }\n    }\n\n    /* ========== REDEEM ========== */\n\n    function _redeem(uint256 tokenId_, uint256 amount_) internal {\n        // Check that the tokenId is active\n        if (!tokenMetadata[tokenId_].active) revert Teller_InvalidParams();\n\n        // Cache token metadata\n        TokenMetadata memory meta = tokenMetadata[tokenId_];\n\n        // Check that the token has matured\n        if (block.timestamp < meta.expiry) revert Teller_TokenNotMatured(meta.expiry);\n\n        // Burn bond token and transfer underlying to sender\n        _burnToken(msg.sender, tokenId_, amount_);\n        meta.underlying.safeTransfer(msg.sender, amount_);\n    }\n\n    /// @inheritdoc IBondFixedTermTeller\n    function redeem(uint256 tokenId_, uint256 amount_) public override nonReentrant {\n        _redeem(tokenId_, amount_);\n    }\n\n    /// @inheritdoc IBondFixedTermTeller\n    function batchRedeem(uint256[] calldata tokenIds_, uint256[] calldata amounts_)\n        external\n        override\n        nonReentrant\n    {\n        uint256 len = tokenIds_.length;\n        if (len != amounts_.length) revert Teller_InvalidParams();\n        for (uint256 i; i < len; ++i) {\n            _redeem(tokenIds_[i], amounts_[i]);\n        }\n    }\n\n    /* ========== TOKENIZATION ========== */\n\n    /// @inheritdoc IBondFixedTermTeller\n    function deploy(ERC20 underlying_, uint48 expiry_)\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        uint256 tokenId = getTokenId(underlying_, expiry_);\n        // Only creates token if it does not exist\n        if (!tokenMetadata[tokenId].active) {\n            _deploy(tokenId, underlying_, expiry_);\n        }\n        return tokenId;\n    }\n\n    /// @notice             \"Deploy\" a new ERC1155 bond token and stores its ID\n    /// @dev                ERC1155 tokens used for fixed term bonds\n    /// @param tokenId_     Calculated ID of new bond token (from getTokenId)\n    /// @param underlying_  Underlying token to be paid out when the bond token vests\n    /// @param expiry_      Timestamp that the token will vest at\n    function _deploy(\n        uint256 tokenId_,\n        ERC20 underlying_,\n        uint48 expiry_\n    ) internal {\n        // Revert if expiry is in the past\n        if (uint256(expiry_) < block.timestamp) revert Teller_InvalidParams();\n\n        // Store token metadata\n        tokenMetadata[tokenId_] = TokenMetadata(\n            true,\n            underlying_,\n            uint8(underlying_.decimals()),\n            expiry_,\n            0\n        );\n\n        emit ERC1155BondTokenCreated(tokenId_, underlying_, expiry_);\n    }\n\n    /// @notice             Mint bond token and update supply\n    /// @param to_          Address to mint tokens to\n    /// @param tokenId_     ID of bond token to mint\n    /// @param amount_      Amount of bond tokens to mint\n    function _mintToken(\n        address to_,\n        uint256 tokenId_,\n        uint256 amount_\n    ) internal {\n        _mint(to_, tokenId_, amount_, bytes(\"\"));\n        tokenMetadata[tokenId_].supply += amount_;\n    }\n\n    /// @notice             Burn bond token and update supply\n    /// @param from_        Address to burn tokens from\n    /// @param tokenId_     ID of bond token to burn\n    /// @param amount_      Amount of bond token to burn\n    function _burnToken(\n        address from_,\n        uint256 tokenId_,\n        uint256 amount_\n    ) internal {\n        _burn(from_, tokenId_, amount_);\n        tokenMetadata[tokenId_].supply -= amount_;\n    }\n\n    /* ========== TOKEN NAMING ========== */\n\n    /// @inheritdoc IBondFixedTermTeller\n    function getTokenId(ERC20 underlying_, uint48 expiry_) public pure override returns (uint256) {\n        // Vesting is divided by 1 day (in seconds) since bond tokens are only unique\n        // to a day, not a specific timestamp.\n        uint256 tokenId = uint256(\n            keccak256(abi.encodePacked(underlying_, expiry_ / uint48(1 days)))\n        );\n        return tokenId;\n    }\n\n    /// @inheritdoc IBondFixedTermTeller\n    function getTokenNameAndSymbol(uint256 tokenId_)\n        external\n        view\n        override\n        returns (string memory, string memory)\n    {\n        TokenMetadata memory meta = tokenMetadata[tokenId_];\n        (string memory name, string memory symbol) = _getNameAndSymbol(\n            meta.underlying,\n            meta.expiry\n        );\n        return (name, symbol);\n    }\n}"
    }
  ]
}