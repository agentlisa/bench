{
  "Title": "Excessive minting `aETH` permissions for strategies",
  "Content": "##### Description\nThe issue is identified in the `CorePrimary.strategyMinting` function.\nCurrently, the function, which can only be invoked by a `strategy`, permits the minting of an unrestricted amounts of `AETH` to the arbitrary address. It presents a significant risk of overinflating the circulating supply of `AETH`, potentially leading to a scenario where `AETH` is no longer backed on a one-to-one basis with the `ETH` locked in the project.\n\nThe issue is classified as `high` due to the excessive authority granted to the `strategy` in regulating the circulating supply of `AETH`.\n\nRelated code - strategyMinting: https://github.com/aspidanet/aspida-contract/blob/a94928e27a72baabb8c73b42634350ca934b3353/contracts/CorePrimary.sol#L257\n\n##### Recommendation\nWe recommend removing this function or adding the constraints to ensure that the minted `AETH` amounts are backed by an equivalent `ETH` collateral on a one-to-one basis.\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/CorePrimary.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./library/PauseGuardian.sol\";\nimport \"./library/Manable.sol\";\nimport \"./core/ActionControl.sol\";\nimport \"./core/CoreTreasury.sol\";\nimport \"./core/CoreStrategy.sol\";\nimport \"./core/StakingModel.sol\";\nimport \"./core/Submit.sol\";\nimport \"./core/WithdrawalQueue.sol\";\n\nimport \"./interface/IRewardOracle.sol\";\n\n/**\n * @title Aspida's ETH 2.0 staking Core(primary)\n * @author Aspida engineer\n * @notice This contract is the primary contract for Aspida's ETH 2.0 staking Core.\n *         It inherits from several other contracts and contains various functions for managing the Core.\n * @dev This contract is implemented using the OpenZeppelin library.\n *      It is used for staking ETH 2.0 and managing the Core's treasury, strategies, and actions.\n *      It also contains functions for submitting and withdrawing ETH, as well as managing the withdrawal queue.\n */\ncontract CorePrimary is\n    Ownable2StepUpgradeable,\n    PauseGuardian,\n    ReentrancyGuardUpgradeable,\n    Manable,\n    ActionControl,\n    CoreTreasury,\n    CoreStrategy,\n    Submit,\n    StakingModel,\n    WithdrawalQueue\n{\n    address internal rewardOracle_;\n\n    uint256 internal received_;\n\n    event SetRewardOracle(address rewardOracle);\n    event Received(uint256 _ethValue);\n\n    /**\n     * @dev Throws if called by any account other than the rewardOracle.\n     */\n    modifier onlyRewardOracle() {\n        require(rewardOracle_ == msg.sender, \"onlyRewardOracle: caller is not the rewardOracle\");\n        _;\n    }\n\n    /**\n     * @notice Only for the implementation contract, as for the proxy pattern,\n     *            should call `initialize()` separately.\n     */\n    constructor(\n        IDepositContract _depositContract,\n        IdETH _dETH,\n        IsdETH _sdETH\n    ) StakingModel(_depositContract) Submit(_dETH, _sdETH) {\n        initialize();\n    }\n\n    /**\n     * @notice Expects to call only once to initialize CorePrimary.\n     */\n    function initialize() public initializer {\n        __Ownable2Step_init();\n        _setTreasuryInternal(owner());\n        _setWithdrawalCredentialsInternal(_addressToWithdrawalCredentials(address(this)));\n    }\n\n    /**\n     * @notice Receives ETH sent to the contract.\n     */\n    receive() external payable {\n        received_ += msg.value;\n        emit Received(msg.value);\n    }\n\n    /**\n     * @dev Unpause when Core is paused.\n     */\n    function _open() external onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @dev Pause Core.\n     */\n    function _close() external onlyPauseGuardian {\n        _pause();\n    }\n\n    /**\n     * @notice Adds a new pause guardian to the Core.\n     * @param _pauseGuardian The address of the new pause guardian.\n     */\n    function _addPauseGuardian(address _pauseGuardian) external onlyOwner {\n        _addPauseGuardianInternal(_pauseGuardian);\n    }\n\n    /**\n     * @notice Removes a pause guardian from the Core.\n     * @param _pauseGuardian The address of the pause guardian to remove.\n     */\n    function _removePauseGuardian(address _pauseGuardian) external onlyOwner {\n        _removePauseGuardianInternal(_pauseGuardian);\n    }\n\n    /**\n     * @notice Adds a new manager to the Core.\n     * @param _manager The address of the new manager.\n     */\n    function _addManager(address _manager) external onlyOwner {\n        _addManagerInternal(_manager);\n    }\n\n    /**\n     * @notice Removes a manager from the Core.\n     * @param _manager The address of the manager to remove.\n     */\n    function _removeManager(address _manager) external onlyOwner {\n        _removeManagerInternal(_manager);\n    }\n\n    /**\n     * @notice Sets the treasury address.\n     * @param _treasury The address of the new treasury.\n     */\n    function _setTreasury(address _treasury) external onlyOwner {\n        _setTreasuryInternal(_treasury);\n    }\n\n    /**\n     * @notice Sets the treasury ratio.\n     * @param _treasuryRatio The new treasury ratio.\n     */\n    function _setTreasuryRatio(uint256 _treasuryRatio) external onlyOwner {\n        _setTreasuryRatioInternal(_treasuryRatio);\n    }\n\n    /**\n     * @notice Sets the action limit.\n     * @param _actionId The action ID.\n     * @param _limit The new limit.\n     */\n    function _setActionLimit(Action _actionId, uint256 _limit) external onlyOwner {\n        _setActionLimitInternal(_actionId, _limit);\n    }\n\n    /**\n     * @notice Sets the action threshold.\n     * @param _actionId The action ID.\n     * @param _threshold The new threshold.\n     */\n    function _setActionThreshold(Action _actionId, uint256 _threshold) external onlyOwner {\n        _setActionThresholdInternal(_actionId, _threshold);\n    }\n\n    /**\n     * @notice Sets the reserve ratio.\n     * @param _reserveRatio The new reserve ratio.\n     */\n    function _setReserveRatio(uint256 _reserveRatio) external onlyOwner {\n        _setReserveRatioInternal(_reserveRatio);\n    }\n\n    /**\n     * @notice Adds a new strategy.\n     * @param _strategy The address of the new strategy.\n     */\n    function _addStrategy(address _strategy) external onlyOwner {\n        _addStrategyInternal(_strategy);\n    }\n\n    /**\n     * @notice Removes a strategy.\n     * @param _strategy The address of the strategy to remove.\n     */\n    function _removeStrategy(address _strategy) external onlyOwner {\n        _removeStrategyInternal(_strategy);\n    }\n\n    /**\n     * @notice Releases the strategy reserve.\n     * @param _releaseAmount The amount to release.\n     */\n    function _releaseStrategyReserve(uint256 _releaseAmount) external onlyOwner {\n        _decreaseStrategyReserve(_releaseAmount);\n    }\n\n    /**\n     * @notice Sets the reward oracle address.\n     * @param _rewardOracle The address of the new reward oracle.\n     */\n    function _setRewardOracle(address _rewardOracle) external onlyOwner {\n        require(\n            _rewardOracle != rewardOracle_ && IRewardOracle(_rewardOracle).core() == address(this),\n            \"_setRewardOracle: Invalid reward oracle address\"\n        );\n        rewardOracle_ = _rewardOracle;\n        emit SetRewardOracle(_rewardOracle);\n    }\n\n    /**\n     * @notice Disables the reward oracle.\n     */\n    function _disableRewardOracle() external onlyOwner {\n        rewardOracle_ = address(0);\n        emit SetRewardOracle(address(0));\n    }\n\n    /**\n     * @notice Deposits ETH into a strategy.\n     * @param _strategy The address of the strategy.\n     * @param _ethAmount The amount of ETH to deposit.\n     */\n    function _depositIntoStrategy(address _strategy, uint256 _ethAmount) external onlyOwner {\n        _depositIntoStrategyInternal(_strategy, _ethAmount);\n    }\n\n    /**\n     * @notice Deposits ETH into the contract for staking.\n     * @param _validators The array of validators to deposit.\n     */\n    function deposit(Validator[] calldata _validators) external whenNotPaused nonReentrant onlyManager {\n        require(\n            (address(this).balance - strategyReserve_ - pendingClaimAmount_) / DEPOSIT_SIZE >= _validators.length,\n            \"deposit: Not enough ETH\"\n        );\n\n        _deposit(_validators);\n    }\n\n    /**\n     * @notice Supplies reward.\n     * @param _amount The amount to supply.\n     */\n    function supplyReward(uint256 _amount) external whenNotPaused onlyRewardOracle {\n        require(_amount != 0, \"supplyReward: Amount cannot be 0\");\n\n        uint256 _treasuryAmount = _getTreasuryAmount(_amount);\n        if (_treasuryAmount > 0) DETH.mint(treasury_, _treasuryAmount);\n\n        uint256 _reward = _amount - _treasuryAmount;\n        if (_reward > 0) DETH.mint(address(SDETH), _reward);\n    }\n\n    /**\n     * @notice Mints DETH to the specified receiver.\n     * @param _receiver The address of the receiver.\n     * @param _amount The amount of DETH to mint.\n     */\n    function strategyMinting(address _receiver, uint256 _amount) external whenNotPaused isStrategy(msg.sender) {\n        DETH.mint(_receiver, _amount);\n    }\n\n    /**\n     * @notice Receives earnings from a strategy.\n     */\n    function receiveStrategyEarning() external payable {\n        _receiveStrategyEarning(msg.sender);\n    }\n\n    /**\n     * @notice Submits a transaction to the CorePrimary contract.\n     * @dev This function is called internally when a user submits a transaction.\n     * @param _receiver The address of the receiver of the transaction.\n     */\n    function _submit(address _receiver) internal override whenNotPaused nonReentrant {\n        uint256 _ethValue = msg.value;\n        _checkActionLimit(Action.submit, block.timestamp / 1 days, _ethValue, submitted_);\n        _increaseReservesByRatio(_ethValue);\n        Submit._submit(_receiver);\n    }\n\n    /**\n     * @dev Internal function to withdraw funds from the contract.\n     * @param _sender The address of the sender.\n     * @param _receiver The address of the receiver.\n     * @param _amount The amount to withdraw.\n     */\n    function _withdraw(\n        address _sender,\n        address _receiver,\n        uint256 _amount\n    ) internal override whenNotPaused nonReentrant {\n        _checkAction(\n            Action.withdraw,\n            block.timestamp / 1 days,\n            _amount,\n            totalWithdrawn_ + pendingClaimAmount_ + totalClaimed_\n        );\n        DETH.burnFrom(_sender, _amount);\n        WithdrawalQueue._withdraw(_sender, _receiver, _amount);\n    }\n\n    /**\n     * @notice Claims the rewards by queue ID.\n     * @param _sender The address of the sender.\n     * @param _receiver The address of the receiver.\n     * @param _queueIds The array of queue IDs.\n     * @param _userQueueIds The set of user queue IDs.\n     */\n    function _claimByQueueId(\n        address _sender,\n        address _receiver,\n        uint256[] memory _queueIds,\n        EnumerableSet.UintSet storage _userQueueIds\n    ) internal override whenNotPaused nonReentrant {\n        WithdrawalQueue._claimByQueueId(_sender, _receiver, _queueIds, _userQueueIds);\n    }\n\n    /**\n     * @dev Returns the amount of ETH that can be withdrawn from the contract.\n     * @return _availableAmount The available amount of ETH that can be withdrawn.\n     */\n    function _withdrawableAmount() internal view override returns (uint256 _availableAmount) {\n        uint256 _balance = address(this).balance;\n        uint256 _locked = pendingClaimAmount_ + strategyReserve_;\n        if (_balance > _locked) {\n            _availableAmount = _balance - _locked;\n        }\n    }\n\n    /**\n     * @dev Returns the amount of ETH that can be claimed from the contract.\n     * @return _claimableAmount The amount of ETH that can be claimed.\n     */\n    function _claimableAmount() internal view override returns (uint256) {\n        return address(this).balance - strategyReserve_ + totalClaimed_;\n    }\n\n    /**\n     * @notice Withdraws a specified amount of tokens with permit functionality.\n     * @param _amount The amount of tokens to withdraw.\n     * @param _receiver The address to receive the tokens.\n     * @param _deadline The deadline for the permit.\n     * @param _approveMax Boolean indicating whether to approve the maximum amount.\n     * @param _v The recovery id of the permit signature.\n     * @param _r The R value of the permit signature.\n     * @param _s The S value of the permit signature.\n     */\n    function withdrawWithPermit(\n        uint256 _amount,\n        address _receiver,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        // Determine the value to be approved\n        uint256 _value = _approveMax ? type(uint256).max : _amount;\n\n        // Call the permit function of the token contract\n        DETH.permit(msg.sender, address(this), _value, _deadline, _v, _r, _s);\n\n        // Withdraw the specified amount of tokens\n        _withdraw(msg.sender, _receiver, _amount);\n    }\n\n    /**\n     * @notice Redeems a specified amount of sdETH and withdraws the underlying ETH.\n     * @param _sdETHAmount The amount of sdETH to redeem.\n     */\n    function redeemAndWithdraw(uint256 _sdETHAmount) external {\n        address _sender = msg.sender;\n        uint256 _amount = SDETH.redeem(_sdETHAmount, address(this), _sender);\n        _withdraw(address(this), _sender, _amount);\n    }\n\n    /**\n     * @notice Withdraws a specified amount of underlying ETH and sdETH.\n     * @param _amount The amount of underlying ETH to withdraw.\n     */\n    function redeemUnderlyingAndWithdraw(uint256 _amount) external {\n        address _sender = msg.sender;\n        SDETH.withdraw(_amount, address(this), _sender);\n        _withdraw(address(this), _sender, _amount);\n    }\n\n    /**\n     * @dev Returns the address of the reward oracle.\n     * @return The address of the reward oracle.\n     */\n    function rewardOracle() external view returns (address) {\n        return rewardOracle_;\n    }\n\n    /**\n     * @dev Returns the amount of ETH received by the contract.\n     * @return The amount of ETH received by the contract.\n     */\n    function received() external view returns (uint256) {\n        return received_;\n    }\n\n    /**\n     * @dev Returns the remaining amount of ETH that can be submitted for the current day.\n     * @return The remaining amount of ETH that can be submitted for the current day.\n     */\n    function submitRemaining() external view returns (uint256) {\n        return actionRemaining(Action.submit, block.timestamp / 1 days, submitted_);\n    }\n\n    /**\n     * @dev Returns the remaining amount of ETH that can be withdrawn for the current day.\n     * @return The remaining amount of ETH that can be withdrawn for the current day.\n     */\n    function withdrawRemaining() external view returns (uint256) {\n        return\n            actionRemaining(\n                Action.withdraw,\n                block.timestamp / 1 days,\n                totalWithdrawn_ + pendingClaimAmount_ + totalClaimed_\n            );\n    }\n\n    /**\n     * @dev Returns the withdraw threshold.\n     * @return The withdraw threshold.\n     */\n    function withdrawThreshold() external view returns (uint256) {\n        return actionDatas_[Action.withdraw].threshold;\n    }\n\n    /**\n     * @dev Returns whether the given address is a pause guardian.\n     * @param _pauseGuardian The address to check.\n     * @return Whether the given address is a pause guardian.\n     */\n    function isPauseGuardian(address _pauseGuardian) public view override returns (bool) {\n        return PauseGuardian.isPauseGuardian(_pauseGuardian) || _pauseGuardian == owner();\n    }\n\n    /**\n     * @dev Returns the staking reward.\n     * @param _deposited The amount deposited.\n     * @param _exited The amount exited.\n     * @return _stakingReward The staking reward.\n     */\n    function stakingReward(uint256 _deposited, uint256 _exited) external view returns (uint256 _stakingReward) {\n        uint256 _minuend = address(this).balance +\n            totalWithdrawn_ +\n            totalClaimed_ +\n            depositStrategy_ +\n            _deposited *\n            DEPOSIT_SIZE;\n        uint256 _subtrahend = submitted_ + received_ + receiveStrategy_ + _exited * DEPOSIT_SIZE;\n        if (_minuend > _subtrahend) _stakingReward = _minuend - _subtrahend;\n    }\n}"
    }
  ]
}