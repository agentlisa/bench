{
  "Title": "M-5: Balances of rebasing tokens aren't properly tracked",
  "Content": "# Issue M-5: Balances of rebasing tokens aren't properly tracked \nSource: https://github.com/sherlock-audit/2022-08-sentiment-judging/tree/main/035-M \n## Found by \nLambda, JohnSmith, PwnPatrol, IllIllI, xiaoming90, ellahi, bytehat\n\n## Summary\nRebasing tokens are tokens where `balanceOf()` returns larger amounts over time, due to the addition of interest to each account, or due to airdrops\n\n## Vulnerability Detail\nSentiment doesn't properly track balance changes while rebasing tokens are in the borrower's account\n\n## Impact\nThe lender will miss out on gains that should have accrued to them while the asset was lent out. While market-based price corrections may be able to handle interest that is accrued to everyone, market approaches won't work when only subsets of token addresses are given rewards, e.g. an airdrop based on a snapshot of activity that happened prior to the token being lent.\n\n## Code Snippet\nLending tracks shares of the LToken:\nhttps://github.com/sherlock-audit/2022-08-sentiment/blob/main/protocol/src/tokens/LToken.sol#L140-L143\n\nBut repayment assumes that shares are equal to the same amount, regardless of which address held them, which is not true for airdrops:\nhttps://github.com/sherlock-audit/2022-08-sentiment/blob/main/protocol/src/tokens/LToken.sol#L160-L163\n\nRebasing tokens are supported, since Aave is a rebasing token:\nhttps://github.com/sherlock-audit/2022-08-sentiment/blob/main/controller/src/aave/AaveEthController.sol#L28\n## Tool used\n\nManual Review\n\n## Recommendation\nAdjust share amounts when the account balance doesn't match the share conversion calculation when taking into account gains made by the borrower\n\n## Sentiment Team\nWe'll make sure to not interact with fee-on-transfer tokens. This can be ensured by the admins.\n\n## Lead Senior Watson\nNote: The admins should not add rebasing/fee-on-transfer tokens to any allowed lists.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/1",
  "Code": [
    {
      "filename": "protocol/src/tokens/LToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {Errors} from \"../utils/Errors.sol\";\nimport {Pausable} from \"../utils/Pausable.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC4626} from \"./utils/ERC4626.sol\";\nimport {IRegistry} from \"../interface/core/IRegistry.sol\";\nimport {IRateModel} from \"../interface/core/IRateModel.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ILToken} from \"../interface/tokens/ILToken.sol\";\n\n/**\n    @title Lending Token\n    @notice Lending token with ERC4626 implementation\n*/\ncontract LToken is Pausable, ERC4626, ILToken {\n    using FixedPointMathLib for uint;\n    using SafeTransferLib for ERC20;\n\n    /* -------------------------------------------------------------------------- */\n    /*                               STATE VARIABLES                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Utility variable to indicate if contract is initialized\n    bool private initialized;\n\n    /// @notice Registry\n    IRegistry public registry;\n\n    /// @notice Rate Model\n    IRateModel public rateModel;\n\n    /// @notice Account Manager\n    address public accountManager;\n\n    /// @notice Protocol treasury\n    address public treasury;\n\n    /// @notice Total amount of borrows\n    uint public borrows;\n\n    /// @notice Timestamp of when the state of the LToken was last updated\n    uint public lastUpdated;\n\n    /// @notice Protocol reserves\n    uint public reserves;\n\n    /// @notice Reserve factor\n    uint public reserveFactor;\n\n    /// @notice Total borrow shares minted\n    uint public totalBorrowShares;\n\n    /// @notice Mapping of account to borrow in terms of shares\n    mapping (address => uint) public borrowsOf;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   EVENTS                                   */\n    /* -------------------------------------------------------------------------- */\n\n    event ReservesRedeemed(address indexed treasury, uint amt);\n\n    /* -------------------------------------------------------------------------- */\n    /*                              CUSTOM MODIFIERS                              */\n    /* -------------------------------------------------------------------------- */\n\n    modifier accountManagerOnly() {\n        if (msg.sender != accountManager) revert Errors.AccountManagerOnly();\n        _;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             EXTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Contract initialization function\n        @dev Can only be invoked once\n        @param _asset Underlying ERC20 token\n        @param _name Name of LToken\n        @param _symbol Symbol of LToken\n        @param _registry Address of Registry\n        @param _reserveFactor Borrow Fee\n        @param _treasury Protocol treasury\n    */\n    function init(\n        ERC20 _asset,\n        string calldata _name,\n        string calldata _symbol,\n        IRegistry _registry,\n        uint _reserveFactor,\n        address _treasury\n    ) external {\n        if (initialized) revert Errors.ContractAlreadyInitialized();\n\n        if (\n            address(_asset) == address(0) ||\n            address(_registry) == address(0) ||\n            _treasury == address(0)\n        ) revert Errors.ZeroAddress();\n\n        initialized = true;\n        initPausable(msg.sender);\n        initERC4626(_asset, _name, _symbol);\n        registry = _registry;\n        reserveFactor = _reserveFactor;\n        treasury = _treasury;\n    }\n\n    /**\n        @notice Initializes external dependencies\n        @param _rateModel Name of rate model contract\n    */\n    function initDep(string calldata _rateModel) external adminOnly {\n        rateModel = IRateModel(registry.getAddress(_rateModel));\n        accountManager = registry.getAddress('ACCOUNT_MANAGER');\n    }\n\n    /**\n        @notice Lends a specified amount of underlying asset to an account\n        @param account Address of account\n        @param amt Amount of token to lend\n        @return isFirstBorrow Returns if the account is borrowing the asset for\n            the first time\n    */\n    function lendTo(address account, uint amt)\n        external\n        whenNotPaused\n        accountManagerOnly\n        returns (bool isFirstBorrow)\n    {\n        updateState();\n        isFirstBorrow = (borrowsOf[account] == 0);\n\n        uint borrowShares;\n        require((borrowShares = convertAssetToBorrowShares(amt)) != 0, \"ZERO_BORROW_SHARES\");\n        totalBorrowShares += borrowShares;\n        borrowsOf[account] += borrowShares;\n\n        borrows += amt;\n        asset.safeTransfer(account, amt);\n        return isFirstBorrow;\n    }\n\n    /**\n        @notice Collects a specified amount of underlying asset from an account\n        @param account Address of account\n        @param amt Amount of token to collect\n        @return bool Returns true if account has no debt\n    */\n    function collectFrom(address account, uint amt)\n        external\n        accountManagerOnly\n        returns (bool)\n    {\n        uint borrowShares;\n        require((borrowShares = convertAssetToBorrowShares(amt)) != 0, \"ZERO_BORROW_SHARES\");\n        borrowsOf[account] -= borrowShares;\n        totalBorrowShares -= borrowShares;\n\n        borrows -= amt;\n        return (borrowsOf[account] == 0);\n    }\n\n    /**\n        @notice Returns Borrow balance of given account\n        @param account Address of account\n        @return borrowBalance Amount of underlying tokens borrowed\n    */\n    function getBorrowBalance(address account) external view returns (uint) {\n        return convertBorrowSharesToAsset(borrowsOf[account]);\n    }\n\n    function getReserves() public view returns (uint) {\n        return reserves + borrows.mulWadUp(getRateFactor())\n        .mulWadUp(reserveFactor);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                              PUBLIC FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Returns total amount of underlying assets\n            totalAssets = underlying balance + totalBorrows + delta\n            delta = totalBorrows * RateFactor\n        @return totalAssets Total amount of underlying assets\n    */\n    function totalAssets() public view override returns (uint) {\n        return asset.balanceOf(address(this)) + getBorrows() - getReserves();\n    }\n\n    function getBorrows() public view returns (uint) {\n        return borrows + borrows.mulWadUp(getRateFactor());\n    }\n\n    /// @notice Updates state of the lending pool\n    function updateState() public {\n        if (lastUpdated == block.timestamp) return;\n        uint rateFactor = getRateFactor();\n        uint interestAccrued = borrows.mulWadUp(rateFactor);\n        borrows += interestAccrued;\n        reserves += interestAccrued.mulWadUp(reserveFactor);\n        lastUpdated = block.timestamp;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             INTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @dev Rate Factor = Timestamp Delta * 1e18 (Scales timestamp delta to 18 decimals) * Interest Rate Per Block\n            Timestamp Delta = Number of seconds since last update\n    */\n    function getRateFactor() internal view returns (uint) {\n        return (block.timestamp == lastUpdated) ?\n            0 :\n            ((block.timestamp - lastUpdated)*1e18)\n            .mulWadUp(\n                rateModel.getBorrowRatePerSecond(\n                    asset.balanceOf(address(this)),\n                    borrows\n                )\n            );\n    }\n\n    function convertAssetToBorrowShares(uint amt) internal view returns (uint) {\n        uint256 supply = totalBorrowShares;\n        return supply == 0 ? amt : amt.mulDivUp(supply, getBorrows());\n    }\n\n    function convertBorrowSharesToAsset(uint debt) internal view returns (uint) {\n        uint256 supply = totalBorrowShares;\n        return supply == 0 ? debt : debt.mulDivDown(getBorrows(), supply);\n    }\n\n    function beforeDeposit(uint, uint) internal override { updateState(); }\n    function beforeWithdraw(uint, uint) internal override { updateState(); }\n\n    /* -------------------------------------------------------------------------- */\n    /*                               ADMIN FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    function redeemReserves(uint amt) external adminOnly {\n        updateState();\n        reserves -= amt;\n        emit ReservesRedeemed(treasury, amt);\n        asset.safeTransfer(treasury, amt);\n    }\n}"
    },
    {
      "filename": "protocol/src/tokens/LToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {Errors} from \"../utils/Errors.sol\";\nimport {Pausable} from \"../utils/Pausable.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC4626} from \"./utils/ERC4626.sol\";\nimport {IRegistry} from \"../interface/core/IRegistry.sol\";\nimport {IRateModel} from \"../interface/core/IRateModel.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ILToken} from \"../interface/tokens/ILToken.sol\";\n\n/**\n    @title Lending Token\n    @notice Lending token with ERC4626 implementation\n*/\ncontract LToken is Pausable, ERC4626, ILToken {\n    using FixedPointMathLib for uint;\n    using SafeTransferLib for ERC20;\n\n    /* -------------------------------------------------------------------------- */\n    /*                               STATE VARIABLES                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Utility variable to indicate if contract is initialized\n    bool private initialized;\n\n    /// @notice Registry\n    IRegistry public registry;\n\n    /// @notice Rate Model\n    IRateModel public rateModel;\n\n    /// @notice Account Manager\n    address public accountManager;\n\n    /// @notice Protocol treasury\n    address public treasury;\n\n    /// @notice Total amount of borrows\n    uint public borrows;\n\n    /// @notice Timestamp of when the state of the LToken was last updated\n    uint public lastUpdated;\n\n    /// @notice Protocol reserves\n    uint public reserves;\n\n    /// @notice Reserve factor\n    uint public reserveFactor;\n\n    /// @notice Total borrow shares minted\n    uint public totalBorrowShares;\n\n    /// @notice Mapping of account to borrow in terms of shares\n    mapping (address => uint) public borrowsOf;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   EVENTS                                   */\n    /* -------------------------------------------------------------------------- */\n\n    event ReservesRedeemed(address indexed treasury, uint amt);\n\n    /* -------------------------------------------------------------------------- */\n    /*                              CUSTOM MODIFIERS                              */\n    /* -------------------------------------------------------------------------- */\n\n    modifier accountManagerOnly() {\n        if (msg.sender != accountManager) revert Errors.AccountManagerOnly();\n        _;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             EXTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Contract initialization function\n        @dev Can only be invoked once\n        @param _asset Underlying ERC20 token\n        @param _name Name of LToken\n        @param _symbol Symbol of LToken\n        @param _registry Address of Registry\n        @param _reserveFactor Borrow Fee\n        @param _treasury Protocol treasury\n    */\n    function init(\n        ERC20 _asset,\n        string calldata _name,\n        string calldata _symbol,\n        IRegistry _registry,\n        uint _reserveFactor,\n        address _treasury\n    ) external {\n        if (initialized) revert Errors.ContractAlreadyInitialized();\n\n        if (\n            address(_asset) == address(0) ||\n            address(_registry) == address(0) ||\n            _treasury == address(0)\n        ) revert Errors.ZeroAddress();\n\n        initialized = true;\n        initPausable(msg.sender);\n        initERC4626(_asset, _name, _symbol);\n        registry = _registry;\n        reserveFactor = _reserveFactor;\n        treasury = _treasury;\n    }\n\n    /**\n        @notice Initializes external dependencies\n        @param _rateModel Name of rate model contract\n    */\n    function initDep(string calldata _rateModel) external adminOnly {\n        rateModel = IRateModel(registry.getAddress(_rateModel));\n        accountManager = registry.getAddress('ACCOUNT_MANAGER');\n    }\n\n    /**\n        @notice Lends a specified amount of underlying asset to an account\n        @param account Address of account\n        @param amt Amount of token to lend\n        @return isFirstBorrow Returns if the account is borrowing the asset for\n            the first time\n    */\n    function lendTo(address account, uint amt)\n        external\n        whenNotPaused\n        accountManagerOnly\n        returns (bool isFirstBorrow)\n    {\n        updateState();\n        isFirstBorrow = (borrowsOf[account] == 0);\n\n        uint borrowShares;\n        require((borrowShares = convertAssetToBorrowShares(amt)) != 0, \"ZERO_BORROW_SHARES\");\n        totalBorrowShares += borrowShares;\n        borrowsOf[account] += borrowShares;\n\n        borrows += amt;\n        asset.safeTransfer(account, amt);\n        return isFirstBorrow;\n    }\n\n    /**\n        @notice Collects a specified amount of underlying asset from an account\n        @param account Address of account\n        @param amt Amount of token to collect\n        @return bool Returns true if account has no debt\n    */\n    function collectFrom(address account, uint amt)\n        external\n        accountManagerOnly\n        returns (bool)\n    {\n        uint borrowShares;\n        require((borrowShares = convertAssetToBorrowShares(amt)) != 0, \"ZERO_BORROW_SHARES\");\n        borrowsOf[account] -= borrowShares;\n        totalBorrowShares -= borrowShares;\n\n        borrows -= amt;\n        return (borrowsOf[account] == 0);\n    }\n\n    /**\n        @notice Returns Borrow balance of given account\n        @param account Address of account\n        @return borrowBalance Amount of underlying tokens borrowed\n    */\n    function getBorrowBalance(address account) external view returns (uint) {\n        return convertBorrowSharesToAsset(borrowsOf[account]);\n    }\n\n    function getReserves() public view returns (uint) {\n        return reserves + borrows.mulWadUp(getRateFactor())\n        .mulWadUp(reserveFactor);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                              PUBLIC FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Returns total amount of underlying assets\n            totalAssets = underlying balance + totalBorrows + delta\n            delta = totalBorrows * RateFactor\n        @return totalAssets Total amount of underlying assets\n    */\n    function totalAssets() public view override returns (uint) {\n        return asset.balanceOf(address(this)) + getBorrows() - getReserves();\n    }\n\n    function getBorrows() public view returns (uint) {\n        return borrows + borrows.mulWadUp(getRateFactor());\n    }\n\n    /// @notice Updates state of the lending pool\n    function updateState() public {\n        if (lastUpdated == block.timestamp) return;\n        uint rateFactor = getRateFactor();\n        uint interestAccrued = borrows.mulWadUp(rateFactor);\n        borrows += interestAccrued;\n        reserves += interestAccrued.mulWadUp(reserveFactor);\n        lastUpdated = block.timestamp;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             INTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @dev Rate Factor = Timestamp Delta * 1e18 (Scales timestamp delta to 18 decimals) * Interest Rate Per Block\n            Timestamp Delta = Number of seconds since last update\n    */\n    function getRateFactor() internal view returns (uint) {\n        return (block.timestamp == lastUpdated) ?\n            0 :\n            ((block.timestamp - lastUpdated)*1e18)\n            .mulWadUp(\n                rateModel.getBorrowRatePerSecond(\n                    asset.balanceOf(address(this)),\n                    borrows\n                )\n            );\n    }\n\n    function convertAssetToBorrowShares(uint amt) internal view returns (uint) {\n        uint256 supply = totalBorrowShares;\n        return supply == 0 ? amt : amt.mulDivUp(supply, getBorrows());\n    }\n\n    function convertBorrowSharesToAsset(uint debt) internal view returns (uint) {\n        uint256 supply = totalBorrowShares;\n        return supply == 0 ? debt : debt.mulDivDown(getBorrows(), supply);\n    }\n\n    function beforeDeposit(uint, uint) internal override { updateState(); }\n    function beforeWithdraw(uint, uint) internal override { updateState(); }\n\n    /* -------------------------------------------------------------------------- */\n    /*                               ADMIN FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    function redeemReserves(uint amt) external adminOnly {\n        updateState();\n        reserves -= amt;\n        emit ReservesRedeemed(treasury, amt);\n        asset.safeTransfer(treasury, amt);\n    }\n}"
    },
    {
      "filename": "controller/src/aave/AaveEthController.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {IController} from \"../core/IController.sol\";\n\n/**\n    @title Aave Eth Controller\n    @notice Controller for aave Weth interaction\n    arbi:0xC09e69E79106861dF5d289dA88349f10e2dc6b5C\n*/\ncontract AaveEthController is IController {\n\n    /* -------------------------------------------------------------------------- */\n    /*                             CONSTANT VARIABLES                             */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice depositETH(address,address,uint16) function signature\n    bytes4 public constant DEPOSIT = 0x474cf53d;\n\n    /// @notice withdrawETH(address,uint256,address) function signature\n    bytes4 public constant WITHDRAW = 0x80500d20;\n\n    /* -------------------------------------------------------------------------- */\n    /*                               STATE VARIABLES                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice List of tokens\n    /// @dev Will always have one token aave WETH\n    address[] public tokens;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 CONSTRUCTOR                                */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Contract constructor\n        @param _aWeth address of aave WETH\n    */\n    constructor(address _aWeth) {\n        tokens.push(_aWeth);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                              PUBLIC FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IController\n    function canCall(address, bool, bytes calldata data)\n        external\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        bytes4 sig = bytes4(data);\n        if (sig == DEPOSIT) return (true, tokens, new address[](0));\n        if (sig == WITHDRAW) return (true, new address[](0), tokens);\n        return (false, new address[](0), new address[](0));\n    }\n}"
    }
  ]
}