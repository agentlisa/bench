{
  "Title": "[G-22]Gas savings can be achieved by changing the model for assigning value to the structure",
  "Content": "\nHere's an example to illustrate this:\n\n```\nstruct MyStruct {\n    uint256 a;\n    uint256 b;\n    uint256 c;\n}\n\nfunction assignValuesToStruct(uint256 _a, uint256 _b, uint256 _c) public {\n    MyStruct memory myStruct = MyStruct(_a, _b, _c);\n    // Do something with myStruct\n}\n```\n\nIn this example, we have a simple `MyStruct` data structure with three uint256 fields. The `assignValuesToStruct` function takes three input parameters `_a`, `_b`, and `_c`, and assigns them to the corresponding fields in a new `myStruct` variable. This is done using the struct constructor syntax, which creates a new instance of the `MyStruct` struct with the specified field values.\n\nThis approach can be more efficient than assigning values to the struct fields one by one, like this:\n\n```\nfunction assignValuesToStruct(uint256 _a, uint256 _b, uint256 _c) public {\n    MyStruct memory myStruct;\n    myStruct.a = _a;\n    myStruct.b = _b;\n    myStruct.c = _c;\n    // Do something with myStruct\n}\n```\n\nIn this example, the values of `_a`, `_b`, and `_c` are assigned to the corresponding fields of the `myStruct` variable one by one. This can be less efficient than using the struct constructor syntax, because it requires more memory operations to initialize the struct fields.\n\nBy using the struct constructor syntax to assign values to the struct fields, we can save gas by reducing the number of memory operations required to create the struct.\n\n[Reference](https://code4rena.com/reports/2023-01-timeswap#g-06-gas-savings-can-be-achieved-by-changing-the-model-for-assigning-value-to-the-structure-260-gas)\n\n<details>\n\n```solidity\nFile: src/erc-20/ERC20Boost.sol\n131    getUserGaugeBoost[user][msg.sender] =\n            GaugeState({userGaugeBoost: userGaugeBoost, totalGaugeBoost: totalSupply.toUint128()});\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/erc-20/ERC20Boost.sol#L131\n\n```solidity\nFile: src/erc-20/ERC20MultiVotes.sol\n253   ckpts.push(Checkpoint({fromBlock: block.number.toUint32(), votes: newWeight.toUint224()}));\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/erc-20/ERC20MultiVotes.sol#L253\n\n```solidity\nFile: src/rewards/rewards/FlywheelGaugeRewards.sol\n189   gaugeQueuedRewards[gauge] = QueuedRewards({\n                priorCycleRewards: queuedRewards.priorCycleRewards + completedRewards,\n                cycleRewards: uint112(nextRewards),\n                storedCycle: currentCycle\n            });\n\n228    gaugeQueuedRewards[ERC20(msg.sender)] = QueuedRewards({\n            priorCycleRewards: 0,\n            cycleRewards: cycleRewardsNext,\n            storedCycle: queuedRewards.storedCycle\n        });        \n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/rewards/FlywheelGaugeRewards.sol#L189\n\n```solidity\nFile: src/talos/TalosStrategyStaked.sol\n148   INonfungiblePositionManager.CollectParams({\n                    tokenId: _tokenId,\n                    recipient: address(this),\n                    amount0Max: type(uint128).max,\n                    amount1Max: type(uint128).max\n                })\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/talos/TalosStrategyStaked.sol#L148\n\n```solidity\nFile: src/talos/TalosStrategyVanilla.sol\n108   INonfungiblePositionManager.CollectParams({\n                tokenId: _tokenId,\n                recipient: address(this),\n                amount0Max: type(uint128).max,\n                amount1Max: type(uint128).max\n            })\n\n142    INonfungiblePositionManager.IncreaseLiquidityParams({\n                    tokenId: _tokenId,\n                    amount0Desired: balance0,\n                    amount1Desired: balance1,\n                    amount0Min: 0,\n                    amount1Min: 0,\n                    deadline: block.timestamp\n                })\n\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/talos/TalosStrategyVanilla.sol#L108\n\n```solidity\nFile: src/ulysses-omnichain/RootBridgeAgentExecutor.sol\n416   dParams = DepositMultipleParams({\n            numberOfAssets: numOfAssets,\n            depositNonce: nonce,\n            hTokens: hTokens,\n            tokens: tokens,\n            amounts: amounts,\n            deposits: deposits,\n            toChain: toChain\n        });\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgentExecutor.sol#L416\n\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/erc-20/ERC20Boost.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {EnumerableSet} from \"@lib/EnumerableSet.sol\";\n\nimport {IBaseV2Gauge} from \"@gauges/interfaces/IBaseV2Gauge.sol\";\n\nimport {Errors} from \"./interfaces/Errors.sol\";\nimport {IERC20Boost} from \"./interfaces/IERC20Boost.sol\";\n\n/// @title An ERC20 with an embedded attachment mechanism to keep track of boost\n///        allocations to gauges.\nabstract contract ERC20Boost is ERC20, Ownable, IERC20Boost {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using SafeCastLib for *;\n\n    /*///////////////////////////////////////////////////////////////\n                            GAUGE STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    mapping(address => mapping(address => GaugeState)) public override getUserGaugeBoost;\n\n    /// @inheritdoc IERC20Boost\n    mapping(address => uint256) public override getUserBoost;\n\n    mapping(address => EnumerableSet.AddressSet) internal _userGauges;\n\n    EnumerableSet.AddressSet internal _gauges;\n\n    // Store deprecated gauges in case a user needs to free dead boost\n    EnumerableSet.AddressSet internal _deprecatedGauges;\n\n    /*///////////////////////////////////////////////////////////////\n                            VIEW HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    function gauges() external view returns (address[] memory) {\n        return _gauges.values();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function gauges(uint256 offset, uint256 num) external view returns (address[] memory values) {\n        values = new address[](num);\n        for (uint256 i = 0; i < num;) {\n            unchecked {\n                values[i] = _gauges.at(offset + i); // will revert if out of bounds\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC20Boost\n    function isGauge(address gauge) external view returns (bool) {\n        return _gauges.contains(gauge) && !_deprecatedGauges.contains(gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function numGauges() external view returns (uint256) {\n        return _gauges.length();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function deprecatedGauges() external view returns (address[] memory) {\n        return _deprecatedGauges.values();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function numDeprecatedGauges() external view returns (uint256) {\n        return _deprecatedGauges.length();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function freeGaugeBoost(address user) public view returns (uint256) {\n        return balanceOf[user] - getUserBoost[user];\n    }\n\n    /// @inheritdoc IERC20Boost\n    function userGauges(address user) external view returns (address[] memory) {\n        return _userGauges[user].values();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function isUserGauge(address user, address gauge) external view returns (bool) {\n        return _userGauges[user].contains(gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function userGauges(address user, uint256 offset, uint256 num) external view returns (address[] memory values) {\n        values = new address[](num);\n        for (uint256 i = 0; i < num;) {\n            unchecked {\n                values[i] = _userGauges[user].at(offset + i); // will revert if out of bounds\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC20Boost\n    function numUserGauges(address user) external view returns (uint256) {\n        return _userGauges[user].length();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    function attach(address user) external {\n        if (!_gauges.contains(msg.sender) || _deprecatedGauges.contains(msg.sender)) {\n            revert InvalidGauge();\n        }\n\n        // idempotent add\n        if (!_userGauges[user].add(msg.sender)) revert GaugeAlreadyAttached();\n\n        uint128 userGaugeBoost = balanceOf[user].toUint128();\n\n        if (getUserBoost[user] < userGaugeBoost) {\n            getUserBoost[user] = userGaugeBoost;\n            emit UpdateUserBoost(user, userGaugeBoost);\n        }\n\n        getUserGaugeBoost[user][msg.sender] =\n            GaugeState({userGaugeBoost: userGaugeBoost, totalGaugeBoost: totalSupply.toUint128()});\n\n        emit Attach(user, msg.sender, userGaugeBoost);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function detach(address user) external {\n        require(_userGauges[user].remove(msg.sender));\n        delete getUserGaugeBoost[user][msg.sender];\n\n        emit Detach(user, msg.sender);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        USER GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    function updateUserBoost(address user) external {\n        uint256 userBoost = 0;\n\n        address[] memory gaugeList = _userGauges[user].values();\n\n        uint256 length = gaugeList.length;\n        for (uint256 i = 0; i < length;) {\n            address gauge = gaugeList[i];\n\n            if (!_deprecatedGauges.contains(gauge)) {\n                uint256 gaugeBoost = getUserGaugeBoost[user][gauge].userGaugeBoost;\n\n                if (userBoost < gaugeBoost) userBoost = gaugeBoost;\n            }\n\n            unchecked {\n                i++;\n            }\n        }\n        getUserBoost[user] = userBoost;\n\n        emit UpdateUserBoost(user, userBoost);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementGaugeBoost(address gauge, uint256 boost) public {\n        GaugeState storage gaugeState = getUserGaugeBoost[msg.sender][gauge];\n        if (boost >= gaugeState.userGaugeBoost) {\n            _userGauges[msg.sender].remove(gauge);\n            delete getUserGaugeBoost[msg.sender][gauge];\n\n            emit Detach(msg.sender, gauge);\n        } else {\n            gaugeState.userGaugeBoost -= boost.toUint128();\n\n            emit DecrementUserGaugeBoost(msg.sender, gauge, gaugeState.userGaugeBoost);\n        }\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementGaugeAllBoost(address gauge) external {\n        require(_userGauges[msg.sender].remove(gauge));\n        delete getUserGaugeBoost[msg.sender][gauge];\n\n        emit Detach(msg.sender, gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementAllGaugesBoost(uint256 boost) external {\n        decrementGaugesBoostIndexed(boost, 0, _userGauges[msg.sender].length());\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementGaugesBoostIndexed(uint256 boost, uint256 offset, uint256 num) public {\n        address[] memory gaugeList = _userGauges[msg.sender].values();\n\n        uint256 length = gaugeList.length;\n        for (uint256 i = 0; i < num && i < length;) {\n            address gauge = gaugeList[offset + i];\n\n            GaugeState storage gaugeState = getUserGaugeBoost[msg.sender][gauge];\n\n            if (_deprecatedGauges.contains(gauge) || boost >= gaugeState.userGaugeBoost) {\n                require(_userGauges[msg.sender].remove(gauge)); // Remove from set. Should never fail.\n                delete getUserGaugeBoost[msg.sender][gauge];\n\n                emit Detach(msg.sender, gauge);\n            } else {\n                gaugeState.userGaugeBoost -= boost.toUint128();\n\n                emit DecrementUserGaugeBoost(msg.sender, gauge, gaugeState.userGaugeBoost);\n            }\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementAllGaugesAllBoost() external {\n        // Loop through all user gauges, live and deprecated\n        address[] memory gaugeList = _userGauges[msg.sender].values();\n\n        // Free gauges until through the entire list\n        uint256 size = gaugeList.length;\n        for (uint256 i = 0; i < size;) {\n            address gauge = gaugeList[i];\n\n            require(_userGauges[msg.sender].remove(gauge)); // Remove from set. Should never fail.\n            delete getUserGaugeBoost[msg.sender][gauge];\n\n            emit Detach(msg.sender, gauge);\n\n            unchecked {\n                i++;\n            }\n        }\n\n        getUserBoost[msg.sender] = 0;\n\n        emit UpdateUserBoost(msg.sender, 0);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ADMIN GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    function addGauge(address gauge) external onlyOwner {\n        _addGauge(gauge);\n    }\n\n    function _addGauge(address gauge) internal {\n        bool newAdd = _gauges.add(gauge);\n        bool previouslyDeprecated = _deprecatedGauges.remove(gauge);\n        // add and fail loud if zero address or already present and not deprecated\n        if (gauge == address(0) || !(newAdd || previouslyDeprecated)) revert InvalidGauge();\n\n        emit AddGauge(gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function removeGauge(address gauge) external onlyOwner {\n        _removeGauge(gauge);\n    }\n\n    function _removeGauge(address gauge) internal {\n        // add to deprecated and fail loud if not present\n        if (!_deprecatedGauges.add(gauge)) revert InvalidGauge();\n\n        emit RemoveGauge(gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function replaceGauge(address oldGauge, address newGauge) external onlyOwner {\n        _removeGauge(oldGauge);\n        _addGauge(newGauge);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// NOTE: any \"removal\" of tokens from a user requires notAttached < amount.\n\n    /**\n     * @notice Burns `amount` of tokens from `from` address.\n     * @dev User must have enough free boost.\n     * @param from The address to burn tokens from.\n     * @param amount The amount of tokens to burn.\n     */\n    function _burn(address from, uint256 amount) internal override notAttached(from, amount) {\n        super._burn(from, amount);\n    }\n\n    /**\n     * @notice Transfers `amount` of tokens from `msg.sender` to `to` address.\n     * @dev User must have enough free boost.\n     * @param to the address to transfer to.\n     * @param amount the amount to transfer.\n     */\n    function transfer(address to, uint256 amount) public override notAttached(msg.sender, amount) returns (bool) {\n        return super.transfer(to, amount);\n    }\n\n    /**\n     * @notice Transfers `amount` of tokens from `from` address to `to` address.\n     * @dev User must have enough free boost.\n     * @param from the address to transfer from.\n     * @param to the address to transfer to.\n     * @param amount the amount to transfer.\n     */\n    function transferFrom(address from, address to, uint256 amount)\n        public\n        override\n        notAttached(from, amount)\n        returns (bool)\n    {\n        return super.transferFrom(from, to, amount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Reverts if the user does not have enough free boost.\n     * @param user The user address.\n     * @param amount The amount of boost.\n     */\n    modifier notAttached(address user, uint256 amount) {\n        if (freeGaugeBoost(user) < amount) revert AttachedBoost();\n        _;\n    }\n}"
    },
    {
      "filename": "src/erc-20/ERC20MultiVotes.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Voting logic inspired by OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/ERC20Votes.sol)\n\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {EnumerableSet} from \"@lib/EnumerableSet.sol\";\n\nimport {IBaseV2Gauge} from \"@gauges/interfaces/IBaseV2Gauge.sol\";\n\nimport {Errors} from \"./interfaces/Errors.sol\";\nimport {IERC20MultiVotes} from \"./interfaces/IERC20MultiVotes.sol\";\n\n/// @title ERC20 Multi-Delegation Voting contract\nabstract contract ERC20MultiVotes is ERC20, Ownable, IERC20MultiVotes {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using SafeCastLib for *;\n\n    /*///////////////////////////////////////////////////////////////\n                        VOTE CALCULATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice votes checkpoint list per user.\n    mapping(address => Checkpoint[]) private _checkpoints;\n\n    /// @inheritdoc IERC20MultiVotes\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n    /// @inheritdoc IERC20MultiVotes\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return _checkpoints[account].length.toUint32();\n    }\n\n    /// @inheritdoc IERC20MultiVotes\n    function freeVotes(address account) public view virtual returns (uint256) {\n        return balanceOf[account] - userDelegatedVotes[account];\n    }\n\n    /// @inheritdoc IERC20MultiVotes\n    function getVotes(address account) public view virtual returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n    }\n\n    /// @inheritdoc IERC20MultiVotes\n    function userUnusedVotes(address user) public view virtual returns (uint256) {\n        return getVotes(user);\n    }\n\n    /// @inheritdoc IERC20MultiVotes\n    function getPriorVotes(address account, uint256 blockNumber) public view virtual returns (uint256) {\n        if (blockNumber >= block.number) revert BlockError();\n        return _checkpointsLookup(_checkpoints[account], blockNumber);\n    }\n\n    /// @dev Lookup a value in a list of (sorted) checkpoints.\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {\n        // We run a binary search to look for the earliest checkpoint taken after `blockNumber`.\n        uint256 high = ckpts.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = average(low, high);\n            if (ckpts[mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        return high == 0 ? 0 : ckpts[high - 1].votes;\n    }\n\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ADMIN OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20MultiVotes\n    uint256 public override maxDelegates;\n\n    /// @inheritdoc IERC20MultiVotes\n    mapping(address => bool) public override canContractExceedMaxDelegates;\n\n    /// @inheritdoc IERC20MultiVotes\n    function setMaxDelegates(uint256 newMax) external onlyOwner {\n        uint256 oldMax = maxDelegates;\n        maxDelegates = newMax;\n\n        emit MaxDelegatesUpdate(oldMax, newMax);\n    }\n\n    /// @inheritdoc IERC20MultiVotes\n    function setContractExceedMaxDelegates(address account, bool canExceedMax) external onlyOwner {\n        if (canExceedMax && account.code.length == 0) revert Errors.NonContractError(); // can only approve contracts\n\n        canContractExceedMaxDelegates[account] = canExceedMax;\n\n        emit CanContractExceedMaxDelegatesUpdate(account, canExceedMax);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        DELEGATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice How many votes a user has delegated to a delegatee.\n    mapping(address => mapping(address => uint256)) private _delegatesVotesCount;\n\n    /// @notice How many votes a user has delegated to him.\n    mapping(address => uint256) public userDelegatedVotes;\n\n    /// @notice The delegatees of a user.\n    mapping(address => EnumerableSet.AddressSet) private _delegates;\n\n    /// @inheritdoc IERC20MultiVotes\n    function delegatesVotesCount(address delegator, address delegatee) public view virtual returns (uint256) {\n        return _delegatesVotesCount[delegator][delegatee];\n    }\n\n    /// @inheritdoc IERC20MultiVotes\n    function delegates(address delegator) public view returns (address[] memory) {\n        return _delegates[delegator].values();\n    }\n\n    /// @inheritdoc IERC20MultiVotes\n    function delegateCount(address delegator) public view returns (uint256) {\n        return _delegates[delegator].length();\n    }\n\n    /// @inheritdoc IERC20MultiVotes\n    function incrementDelegation(address delegatee, uint256 amount) public virtual {\n        _incrementDelegation(msg.sender, delegatee, amount);\n    }\n\n    /// @inheritdoc IERC20MultiVotes\n    function undelegate(address delegatee, uint256 amount) public virtual {\n        _undelegate(msg.sender, delegatee, amount);\n    }\n\n    /// @inheritdoc IERC20MultiVotes\n    function delegate(address newDelegatee) external virtual {\n        _delegate(msg.sender, newDelegatee);\n    }\n\n    /**\n     * @notice Delegates all votes from `delegator` to `delegatee`\n     * @dev Reverts if delegateCount > 1\n     * @param delegator The address to delegate votes from\n     * @param newDelegatee The address to delegate votes to\n     */\n    function _delegate(address delegator, address newDelegatee) internal virtual {\n        uint256 count = delegateCount(delegator);\n\n        // undefined behavior for delegateCount > 1\n        if (count > 1) revert DelegationError();\n\n        address oldDelegatee;\n        // if already delegated, undelegate first\n        if (count == 1) {\n            oldDelegatee = _delegates[delegator].at(0);\n            _undelegate(delegator, oldDelegatee, _delegatesVotesCount[delegator][oldDelegatee]);\n        }\n\n        // redelegate only if newDelegatee is not empty\n        if (newDelegatee != address(0)) {\n            _incrementDelegation(delegator, newDelegatee, freeVotes(delegator));\n        }\n        emit DelegateChanged(delegator, oldDelegatee, newDelegatee);\n    }\n\n    /**\n     * @notice Delegates votes from `delegator` to `delegatee`\n     * @dev Reverts if delegator is not approved and exceeds maxDelegates\n     * @param delegator The address to delegate votes from\n     * @param delegatee The address to delegate votes to\n     * @param amount The amount of votes to delegate\n     */\n    function _incrementDelegation(address delegator, address delegatee, uint256 amount) internal virtual {\n        // Require freeVotes exceed the delegation size\n        uint256 free = freeVotes(delegator);\n        if (delegatee == address(0) || free < amount || amount == 0) revert DelegationError();\n\n        bool newDelegate = _delegates[delegator].add(delegatee); // idempotent add\n        if (newDelegate && delegateCount(delegator) > maxDelegates && !canContractExceedMaxDelegates[delegator]) {\n            // if is a new delegate, exceeds max and is not approved to exceed, revert\n            revert DelegationError();\n        }\n\n        _delegatesVotesCount[delegator][delegatee] += amount;\n        userDelegatedVotes[delegator] += amount;\n\n        emit Delegation(delegator, delegatee, amount);\n        _writeCheckpoint(delegatee, _add, amount);\n    }\n\n    /**\n     * @notice Undelegates votes from `delegator` to `delegatee`\n     * @dev Reverts if delegatee does not have enough free votes\n     * @param delegator The address to undelegate votes from\n     * @param delegatee The address to undelegate votes to\n     * @param amount The amount of votes to undelegate\n     */\n    function _undelegate(address delegator, address delegatee, uint256 amount) internal virtual {\n        /**\n         * @dev delegatee needs to have sufficient free votes for delegator to undelegate.\n         *         Delegatee needs to be trusted, can be either a contract or an EOA.\n         *         If delegatee does not have any free votes and doesn't change their vote delegator won't be able to undelegate.\n         *         If it is a contract, a possible safety measure is to have an emergency clear votes.\n         */\n        if (userUnusedVotes(delegatee) < amount) revert UndelegationVoteError();\n\n        uint256 newDelegates = _delegatesVotesCount[delegator][delegatee] - amount;\n\n        if (newDelegates == 0) {\n            require(_delegates[delegator].remove(delegatee));\n        }\n\n        _delegatesVotesCount[delegator][delegatee] = newDelegates;\n        userDelegatedVotes[delegator] -= amount;\n\n        emit Undelegation(delegator, delegatee, amount);\n        _writeCheckpoint(delegatee, _subtract, amount);\n    }\n\n    /**\n     * @notice Writes a checkpoint for `delegatee` with `delta` votes\n     * @param delegatee The address to write a checkpoint for\n     * @param op The operation to perform on the checkpoint\n     * @param delta The difference in votes to write\n     */\n    function _writeCheckpoint(address delegatee, function(uint256, uint256) view returns (uint256) op, uint256 delta)\n        private\n    {\n        Checkpoint[] storage ckpts = _checkpoints[delegatee];\n\n        uint256 pos = ckpts.length;\n        uint256 oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;\n        uint256 newWeight = op(oldWeight, delta);\n\n        if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {\n            ckpts[pos - 1].votes = newWeight.toUint224();\n        } else {\n            ckpts.push(Checkpoint({fromBlock: block.number.toUint32(), votes: newWeight.toUint224()}));\n        }\n        emit DelegateVotesChanged(delegatee, oldWeight, newWeight);\n    }\n\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// NOTE: any \"removal\" of tokens from a user requires freeVotes(user) < amount.\n    /// _decrementVotesUntilFree is called as a greedy algorithm to free up votes.\n    /// It may be more gas efficient to free weight before burning or transferring tokens.\n\n    /**\n     * @notice Burns `amount` of tokens from `from` address.\n     * @dev Frees votes with a greedy algorithm if needed to burn tokens\n     * @param from The address to burn tokens from.\n     * @param amount The amount of tokens to burn.\n     */\n    function _burn(address from, uint256 amount) internal virtual override {\n        _decrementVotesUntilFree(from, amount);\n        super._burn(from, amount);\n    }\n\n    /**\n     * @notice Transfers `amount` of tokens from `msg.sender` to `to` address.\n     * @dev Frees votes with a greedy algorithm if needed to burn tokens\n     * @param to the address to transfer to.\n     * @param amount the amount to transfer.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        _decrementVotesUntilFree(msg.sender, amount);\n        return super.transfer(to, amount);\n    }\n\n    /**\n     * @notice Transfers `amount` of tokens from `from` address to `to` address.\n     * @dev Frees votes with a greedy algorithm if needed to burn tokens\n     * @param from the address to transfer from.\n     * @param to the address to transfer to.\n     * @param amount the amount to transfer.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        _decrementVotesUntilFree(from, amount);\n        return super.transferFrom(from, to, amount);\n    }\n\n    /**\n     * @notice A greedy algorithm for freeing votes before a token burn/transfer\n     * @dev Frees up entire delegates, so likely will free more than `votes`\n     * @param user The address to free votes from.\n     * @param votes The amount of votes to free.\n     */\n    function _decrementVotesUntilFree(address user, uint256 votes) internal {\n        uint256 userFreeVotes = freeVotes(user);\n\n        // early return if already free\n        if (userFreeVotes >= votes) return;\n\n        // cache total for batch updates\n        uint256 totalFreed;\n\n        // Loop through all delegates\n        address[] memory delegateList = _delegates[user].values();\n\n        // Free gauges through the entire list or until underweight\n        uint256 size = delegateList.length;\n        for (uint256 i = 0; i < size && (userFreeVotes + totalFreed) < votes; i++) {\n            address delegatee = delegateList[i];\n            uint256 delegateVotes = _delegatesVotesCount[user][delegatee];\n            // Minimum of votes delegated to delegatee and unused votes of delegatee\n            uint256 votesToFree = FixedPointMathLib.min(delegateVotes, userUnusedVotes(delegatee));\n            // Skip if votesToFree is zero\n            if (votesToFree != 0) {\n                totalFreed += votesToFree;\n\n                if (delegateVotes == votesToFree) {\n                    // If all votes are freed, remove delegatee from list\n                    require(_delegates[user].remove(delegatee)); // Remove from set. Should never fail.\n                    _delegatesVotesCount[user][delegatee] = 0;\n                } else {\n                    // If not all votes are freed, update the votes count\n                    _delegatesVotesCount[user][delegatee] -= votesToFree;\n                }\n\n                _writeCheckpoint(delegatee, _subtract, votesToFree);\n                emit Undelegation(user, delegatee, votesToFree);\n            }\n        }\n\n        if ((userFreeVotes + totalFreed) < votes) revert UndelegationVoteError();\n\n        userDelegatedVotes[user] -= totalFreed;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             EIP-712 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    bytes32 public constant DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) public {\n        require(block.timestamp <= expiry, \"ERC20MultiVotes: signature expired\");\n        address signer = ecrecover(\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\", DOMAIN_SEPARATOR(), keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry))\n                )\n            ),\n            v,\n            r,\n            s\n        );\n        require(nonce == nonces[signer]++, \"ERC20MultiVotes: invalid nonce\");\n        require(signer != address(0));\n        _delegate(signer, delegatee);\n    }\n}"
    },
    {
      "filename": "src/rewards/rewards/FlywheelGaugeRewards.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Rewards logic inspired by Tribe DAO Contracts (flywheel-v2/src/rewards/FlywheelGaugeRewards.sol)\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {ERC20Gauges} from \"@ERC20/ERC20Gauges.sol\";\n\nimport {IFlywheelGaugeRewards} from \"../interfaces/IFlywheelGaugeRewards.sol\";\n\nimport {IBaseV2Minter} from \"@hermes/interfaces/IBaseV2Minter.sol\";\n\n/// @title Flywheel Gauge Reward Stream\ncontract FlywheelGaugeRewards is Ownable, IFlywheelGaugeRewards {\n    using SafeTransferLib for address;\n    using SafeCastLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                        REWARDS CONTRACT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    ERC20Gauges public immutable override gaugeToken;\n\n    /// @notice the minter contract, is a rewardsStream to collect rewards from\n    IBaseV2Minter public immutable minter;\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    address public immutable override rewardToken;\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    uint32 public override gaugeCycle;\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    uint32 public immutable override gaugeCycleLength;\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    mapping(ERC20 => QueuedRewards) public override gaugeQueuedRewards;\n\n    /// @notice the start of the next cycle being partially queued\n    uint32 internal nextCycle;\n\n    // rewards that made it into a partial queue but didn't get completed\n    uint112 internal nextCycleQueuedRewards;\n\n    // the offset during pagination of the queue\n    uint32 internal paginationOffset;\n\n    constructor(address _rewardToken, address _owner, ERC20Gauges _gaugeToken, IBaseV2Minter _minter) {\n        _initializeOwner(_owner);\n        rewardToken = _rewardToken;\n\n        gaugeCycleLength = _gaugeToken.gaugeCycleLength();\n\n        // seed initial gaugeCycle\n        gaugeCycle = (block.timestamp.toUint32() / gaugeCycleLength) * gaugeCycleLength;\n\n        gaugeToken = _gaugeToken;\n\n        minter = _minter;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GAUGE REWARDS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    function queueRewardsForCycle() external returns (uint256 totalQueuedForCycle) {\n        /// @dev Update minter cycle and queue rewars if needed.\n        /// This will make this call fail if it is a new epoch, because the minter calls this function, the first call would fail with \"CycleError()\".\n        /// Should be called through Minter to kickoff new epoch.\n        minter.updatePeriod();\n\n        // next cycle is always the next even divisor of the cycle length above current block timestamp.\n        uint32 currentCycle = (block.timestamp.toUint32() / gaugeCycleLength) * gaugeCycleLength;\n        uint32 lastCycle = gaugeCycle;\n\n        // ensure new cycle has begun\n        if (currentCycle <= lastCycle) revert CycleError();\n\n        gaugeCycle = currentCycle;\n\n        // queue the rewards stream and sanity check the tokens were received\n        uint256 balanceBefore = rewardToken.balanceOf(address(this));\n        totalQueuedForCycle = minter.getRewards();\n        require(rewardToken.balanceOf(address(this)) - balanceBefore >= totalQueuedForCycle);\n\n        // include uncompleted cycle\n        totalQueuedForCycle += nextCycleQueuedRewards;\n\n        // iterate over all gauges and update the rewards allocations\n        address[] memory gauges = gaugeToken.gauges();\n\n        _queueRewards(gauges, currentCycle, lastCycle, totalQueuedForCycle);\n\n        nextCycleQueuedRewards = 0;\n        paginationOffset = 0;\n\n        emit CycleStart(currentCycle, totalQueuedForCycle);\n    }\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    function queueRewardsForCyclePaginated(uint256 numRewards) external {\n        /// @dev Update minter cycle and queue rewars if needed.\n        /// This will make this call fail if it is a new epoch, because the minter calls this function, the first call would fail with \"CycleError()\".\n        /// Should be called through Minter to kickoff new epoch.\n        minter.updatePeriod();\n\n        // next cycle is always the next even divisor of the cycle length above current block timestamp.\n        uint32 currentCycle = (block.timestamp.toUint32() / gaugeCycleLength) * gaugeCycleLength;\n        uint32 lastCycle = gaugeCycle;\n\n        // ensure new cycle has begun\n        if (currentCycle <= lastCycle) revert CycleError();\n\n        if (currentCycle > nextCycle) {\n            nextCycle = currentCycle;\n            paginationOffset = 0;\n        }\n\n        uint32 offset = paginationOffset;\n\n        // important to only calculate the reward amount once to prevent each page from having a different reward amount\n        if (offset == 0) {\n            // queue the rewards stream and sanity check the tokens were received\n            uint256 balanceBefore = rewardToken.balanceOf(address(this));\n            uint256 newRewards = minter.getRewards();\n            require(rewardToken.balanceOf(address(this)) - balanceBefore >= newRewards);\n            require(newRewards <= type(uint112).max); // safe cas"
    }
  ]
}