{
  "Title": "[L03] Missing revert messages in require statements",
  "Content": "There are several `require` statements in the project without revert messages. This behavior results in an increased difficulty of debugging the system.\n\n\nThe list of affected `require` statements is:\n\n\n* In the [`Freezable` contract](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/baklava/Freezable.sol): [L9](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/baklava/Freezable.sol#L9), [L16](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/baklava/Freezable.sol#L16)\n* In the [`FixidityLib` library](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/FixidityLib.sol#L17): [L122](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/FixidityLib.sol#L122), [L151-L153](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/FixidityLib.sol#L151-L153), [L192](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/FixidityLib.sol#L192), [L202](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/FixidityLib.sol#L202), [L231](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/FixidityLib.sol#L231), [L236](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/FixidityLib.sol#L236), [L240](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/FixidityLib.sol#L240), [L243](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/FixidityLib.sol#L243), [L248](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/FixidityLib.sol#L248), [L267](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/FixidityLib.sol#L267), [L280](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/FixidityLib.sol#L280), [L282](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/FixidityLib.sol#L282)\n* In the [`FractionUtil` library](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/FractionUtil.sol#L6): [L67](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/FractionUtil.sol#L67), [L102](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/FractionUtil.sol#L102), [L113](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/FractionUtil.sol#L113)\n* In the [`Initializable` contract](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/Initializable.sol#L3): [L7](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/Initializable.sol#L7)\n* In the [`UsingPrecompiles` contract](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/UsingPrecompiles.sol#L5): [L62](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/UsingPrecompiles.sol#L62), [L93](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/UsingPrecompiles.sol#L93), [L111](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/UsingPrecompiles.sol#L111), [L123](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/UsingPrecompiles.sol#L123), [L136](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/UsingPrecompiles.sol#L136), [L168](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/UsingPrecompiles.sol#L168), [L181](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/UsingPrecompiles.sol#L181), [L194](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/UsingPrecompiles.sol#L194), [L209](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/UsingPrecompiles.sol#L209)\n\n\nConsider including specific and informative revert messages in all require statements.\n\n\n****Update:*** Fixed in pull requests [#2809](https://github.com/celo-org/celo-monorepo/pull/2809) and [#3272](https://github.com/celo-org/celo-monorepo/pull/3272). The cLabs team has addressed all identified cases in [`Freezable.sol`](https://github.com/celo-org/celo-monorepo/pull/2809/files#diff-7a91f1df1f95fbd07d97183a7e9db1fd), [`Initializable.sol`](https://github.com/celo-org/celo-monorepo/pull/2809/files#diff-458b28f73b1452746c7ae6e8b97c4f56), [`UsingPrecompiles.sol`](https://github.com/celo-org/celo-monorepo/pull/2809/files#diff-0cffec14a25e6876b387a826c4b4946d), and [`FixidityLib.sol`](https://github.com/celo-org/celo-monorepo/pull/2809/files#diff-7801c12f54d927cac93ca457047e3425). `FractionUtil.sol` has been deleted from the repository.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/common/FixidityLib.sol",
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title FixidityLib\n * @author Gadi Guy, Alberto Cuesta Canada\n * @notice This library provides fixed point arithmetic with protection against\n * overflow.\n * All operations are done with uint256 and the operands must have been created\n * with any of the newFrom* functions, which shift the comma digits() to the\n * right and check for limits, or with wrap() which expects a number already\n * in the internal representation of a fraction.\n * When using this library be sure to use maxNewFixed() as the upper limit for\n * creation of fixed point numbers. Use maxFixedMul(), maxFixedDividend() and\n * maxFixedAdd() if you want to be certain that those operations don't\n * overflow.\n */\nlibrary FixidityLib {\n  struct Fraction {\n    uint256 value;\n  }\n\n  /**\n   * @notice Number of positions that the comma is shifted to the right.\n   */\n  function digits() internal pure returns (uint8) {\n    return 24;\n  }\n\n  uint256 private constant FIXED1_UINT = 1000000000000000000000000;\n\n  /**\n   * @notice This is 1 in the fixed point units used in this library.\n   * @dev Test fixed1() equals 10^digits()\n   * Hardcoded to 24 digits.\n   */\n  function fixed1() internal pure returns (Fraction memory) {\n    return Fraction(FIXED1_UINT);\n  }\n\n  /**\n   * @notice Wrap a uint256 that represents a 24-decimal fraction in a Fraction\n   * struct.\n   * @param x Number that already represents a 24-decimal fraction.\n   * @return A Fraction struct with contents x.\n   */\n  function wrap(uint256 x) internal pure returns (Fraction memory) {\n    return Fraction(x);\n  }\n\n  /**\n   * @notice Unwraps the uint256 inside of a Fraction struct.\n   */\n  function unwrap(Fraction memory x) internal pure returns (uint256) {\n    return x.value;\n  }\n\n  /**\n   * @notice The amount of decimals lost on each multiplication operand.\n   * @dev Test mulPrecision() equals sqrt(fixed1)\n   */\n  function mulPrecision() internal pure returns (uint256) {\n    return 1000000000000;\n  }\n\n  /**\n   * @notice Maximum value that can be represented in a uint256\n   * @dev Test maxUint256() equals 2^256 -1\n   */\n  function maxUint256() internal pure returns (uint256) {\n    return 115792089237316195423570985008687907853269984665640564039457584007913129639935;\n  }\n\n  /**\n   * @notice Maximum value that can be converted to fixed point. Optimize for\n   * deployment.\n   * @dev\n   * Test maxNewFixed() equals maxUint256() / fixed1()\n   */\n  function maxNewFixed() internal pure returns (uint256) {\n    return 115792089237316195423570985008687907853269984665640564;\n  }\n\n  /**\n   * @notice Maximum value that can be safely used as an addition operator.\n   * @dev Test maxFixedAdd() equals maxUint256()-1 / 2\n   * Test add(maxFixedAdd(),maxFixedAdd()) equals maxFixedAdd() + maxFixedAdd()\n   * Test add(maxFixedAdd()+1,maxFixedAdd()+1) throws\n   */\n  function maxFixedAdd() internal pure returns (uint256) {\n    return 57896044618658097711785492504343953926634992332820282019728792003956564819967;\n  }\n\n  /**\n   * @notice Maximum value that can be safely used as a multiplication operator.\n   * @dev Calculated as sqrt(maxUint256()*fixed1()).\n   * Test multiply(maxFixedMul(),maxFixedMul()) is around maxFixedMul() * maxFixedMul()\n   * Test multiply(maxFixedMul(),maxFixedMul()+1) throws\n   */\n  function maxFixedMul() internal pure returns (uint256) {\n    return 340282366920938463463374607431768211455999999999999;\n  }\n\n  /**\n   * @notice Maximum value that can be safely used as a dividend.\n   * @dev divide(maxFixedDividend,newFixedFraction(1,fixed1())) is around maxUint256().\n   * Test maxFixedDividend() equals maxUint256()/fixed1()\n   * Test divide(maxFixedDividend(),1) equals maxFixedDividend()*(fixed1)\n   * Test divide(maxFixedDividend()+1,multiply(mulPrecision(),mulPrecision())) throws\n   */\n  function maxFixedDividend() internal pure returns (uint256) {\n    return 115792089237316195423570985008687907853269984665640564;\n  }\n\n  /**\n   * @notice Converts a uint256 to fixed point Fraction\n   * @dev Test newFixed(0) returns 0\n   * Test newFixed(1) returns fixed1()\n   * Test newFixed(maxNewFixed()) returns maxNewFixed() * fixed1()\n   * Test newFixed(maxNewFixed()+1) fails\n   */\n  function newFixed(uint256 x) internal pure returns (Fraction memory) {\n    require(x <= maxNewFixed());\n    return Fraction(x * FIXED1_UINT);\n  }\n\n  /**\n   * @notice Converts a uint256 in the fixed point representation of this\n   * library to a non decimal. All decimal digits will be truncated.\n   */\n  function fromFixed(Fraction memory x) internal pure returns (uint256) {\n    return x.value / FIXED1_UINT;\n  }\n\n  /**\n   * @notice Converts two uint256 representing a fraction to fixed point units,\n   * equivalent to multiplying dividend and divisor by 10^digits().\n   * @dev\n   * Test newFixedFraction(maxFixedDividend()+1,1) fails\n   * Test newFixedFraction(1,maxFixedDividend()+1) fails\n   * Test newFixedFraction(1,0) fails\n   * Test newFixedFraction(0,1) returns 0\n   * Test newFixedFraction(1,1) returns fixed1()\n   * Test newFixedFraction(maxFixedDividend(),1) returns maxFixedDividend()*fixed1()\n   * Test newFixedFraction(1,fixed1()) returns 1\n   */\n  function newFixedFraction(uint256 numerator, uint256 denominator)\n    internal\n    pure\n    returns (Fraction memory)\n  {\n    require(numerator <= maxNewFixed());\n    require(denominator <= maxNewFixed());\n    require(denominator != 0);\n    Fraction memory convertedNumerator = newFixed(numerator);\n    Fraction memory convertedDenominator = newFixed(denominator);\n    return divide(convertedNumerator, convertedDenominator);\n  }\n\n  /**\n   * @notice Returns the integer part of a fixed point number.\n   * @dev\n   * Test integer(0) returns 0\n   * Test integer(fixed1()) returns fixed1()\n   * Test integer(newFixed(maxNewFixed())) returns maxNewFixed()*fixed1()\n   */\n  function integer(Fraction memory x) internal pure returns (Fraction memory) {\n    return Fraction((x.value / FIXED1_UINT) * FIXED1_UINT); // Can't overflow\n  }\n\n  /**\n   * @notice Returns the fractional part of a fixed point number.\n   * In the case of a negative number the fractional is also negative.\n   * @dev\n   * Test fractional(0) returns 0\n   * Test fractional(fixed1()) returns 0\n   * Test fractional(fixed1()-1) returns 10^24-1\n   */\n  function fractional(Fraction memory x) internal pure returns (Fraction memory) {\n    return Fraction(x.value - (x.value / FIXED1_UINT) * FIXED1_UINT); // Can't overflow\n  }\n\n  /**\n   * @notice x+y. If any operator is higher than maxFixedAdd() it\n   * might overflow.\n   * @dev\n   * Test add(maxFixedAdd(),maxFixedAdd()) returns maxUint256()-1\n   * Test add(maxFixedAdd()+1,maxFixedAdd()+1) fails\n   * Test add(maxUint256(),maxUint256()) fails\n   */\n  function add(Fraction memory x, Fraction memory y) internal pure returns (Fraction memory) {\n    uint256 z = x.value + y.value;\n    require(z >= x.value);\n    return Fraction(z);\n  }\n\n  /**\n   * @notice x-y.\n   * @dev\n   * Test subtract(6, 10) fails\n   */\n  function subtract(Fraction memory x, Fraction memory y) internal pure returns (Fraction memory) {\n    require(x.value >= y.value);\n    return Fraction(x.value - y.value);\n  }\n\n  /**\n   * @notice x*y. If any of the operators is higher than maxFixedMul() it\n   * might overflow.\n   * @dev\n   * Test multiply(0,0) returns 0\n   * Test multiply(maxFixedMul(),0) returns 0\n   * Test multiply(0,maxFixedMul()) returns 0\n   * Test multiply(fixed1()/mulPrecision(),fixed1()*mulPrecision())\n   * Test multiply(maxFixedMul(),maxFixedMul()) is around maxUint256()\n   * Test multiply(maxFixedMul()+1,maxFixedMul()+1) fails\n   */\n  function multiply(Fraction memory x, Fraction memory y) internal pure returns (Fraction memory) {\n    if (x.value == 0 || y.value == 0) return Fraction(0);\n    if (y.value == FIXED1_UINT) return x;\n    if (x.value == FIXED1_UINT) return y;\n\n    // Separate into integer and fractional parts\n    // x = x1 + x2, y = y1 + y2\n    uint256 x1 = integer(x).value / FIXED1_UINT;\n    uint256 x2 = fractional(x).value;\n    uint256 y1 = integer(y).value / FIXED1_UINT;\n    uint256 y2 = fractional(y).value;\n\n    // (x1 + x2) * (y1 + y2) = (x1 * y1) + (x1 * y2) + (x2 * y1) + (x2 * y2)\n    uint256 x1y1 = x1 * y1;\n    if (x1 != 0) require(x1y1 / x1 == y1); // Overflow x1y1\n\n    // x1y1 needs to be multiplied back by fixed1\n    // solium-disable-next-line mixedcase\n    uint256 fixed_x1y1 = x1y1 * FIXED1_UINT;\n    if (x1y1 != 0) require(fixed_x1y1 / x1y1 == FIXED1_UINT); // Overflow x1y1 * fixed1\n    x1y1 = fixed_x1y1;\n\n    uint256 x2y1 = x2 * y1;\n    if (x2 != 0) require(x2y1 / x2 == y1); // Overflow x2y1\n\n    uint256 x1y2 = x1 * y2;\n    if (x1 != 0) require(x1y2 / x1 == y2); // Overflow x1y2\n\n    x2 = x2 / mulPrecision();\n    y2 = y2 / mulPrecision();\n    uint256 x2y2 = x2 * y2;\n    if (x2 != 0) require(x2y2 / x2 == y2); // Overflow x2y2\n\n    // result = fixed1() * x1 * y1 + x1 * y2 + x2 * y1 + x2 * y2 / fixed1();\n    Fraction memory result = Fraction(x1y1);\n    result = add(result, Fraction(x2y1)); // Add checks for overflow\n    result = add(result, Fraction(x1y2)); // Add checks for overflow\n    result = add(result, Fraction(x2y2)); // Add checks for overflow\n    return result;\n  }\n\n  /**\n   * @notice 1/x\n   * @dev\n   * Test reciprocal(0) fails\n   * Test reciprocal(fixed1()) returns fixed1()\n   * Test reciprocal(fixed1()*fixed1()) returns 1 // Testing how the fractional is truncated\n   * Test reciprocal(1+fixed1()*fixed1()) returns 0 // Testing how the fractional is truncated\n   */\n  function reciprocal(Fraction memory x) internal pure returns (Fraction memory) {\n    require(x.value != 0);\n    return Fraction((FIXED1_UINT * FIXED1_UINT) / x.value); // Can't overflow\n  }\n\n  /**\n   * @notice x/y. If the dividend is higher than maxFixedDividend() it\n   * might overflow. You can use multiply(x,reciprocal(y)) instead.\n   * @dev\n   * Test divide(fixed1(),0) fails\n   * Test divide(maxFixedDividend(),1) = maxFixedDividend()*(10^digits())\n   * Test divide(maxFixedDividend()+1,1) throws\n   */\n  function divide(Fraction memory x, Fraction memory y) internal pure returns (Fraction memory) {\n    require(y.value != 0);\n    uint256 X = x.value * FIXED1_UINT;\n    require(X / FIXED1_UINT == x.value);\n    return Fraction(X / y.value);\n  }\n\n  /**\n   * @notice x > y\n   */\n  function gt(Fraction memory x, Fraction memory y) internal pure returns (bool) {\n    return x.value > y.value;\n  }\n\n  /**\n   * @notice x >= y\n   */\n  function gte(Fraction memory x, Fraction memory y) internal pure returns (bool) {\n    return x.value >= y.value;\n  }\n\n  /**\n   * @notice x < y\n   */\n  function lt(Fraction memory x, Fraction memory y) internal pure returns (bool) {\n    return x.value < y.value;\n  }\n\n  /**\n   * @notice x <= y\n   */\n  function lte(Fraction memory x, Fraction memory y) internal pure returns (bool) {\n    return x.value <= y.value;\n  }\n\n  /**\n   * @notice x == y\n   */\n  function equals(Fraction memory x, Fraction memory y) internal pure returns (bool) {\n    return x.value == y.value;\n  }\n\n  /**\n   * @notice x <= 1\n   */\n  function isProperFraction(Fraction memory x) internal pure returns (bool) {\n    return lte(x, fixed1());\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/common/FractionUtil.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n// TODO(asa): Move to uint128 if gas savings are significant enough.\nlibrary FractionUtil {\n  using SafeMath for uint256;\n  using FractionUtil for Fraction;\n\n  struct Fraction {\n    uint256 numerator;\n    uint256 denominator;\n  }\n\n  function reduce(Fraction memory x) internal pure returns (Fraction memory) {\n    uint256 gcd = x.denominator;\n    uint256 y = x.numerator;\n    while (y != 0) {\n      uint256 y_ = gcd % y;\n      gcd = y;\n      y = y_;\n    }\n    Fraction memory fraction = Fraction(x.numerator.div(gcd), x.denominator.div(gcd));\n    return fraction;\n  }\n\n  /**\n   * @dev Returns whether or not at least one of numerator and denominator are non-zero.\n   * @return Whether or not at least one of numerator and denominator are non-zero.\n   */\n  function exists(Fraction memory x) internal pure returns (bool) {\n    return x.numerator > 0 || x.denominator > 0;\n  }\n\n  /**\n   * @dev Returns whether fraction \"x\" is equal to fraction \"y\".\n   * @param x A Fraction struct.\n   * @param y A Fraction struct.\n   * @return x == y\n   */\n  function equals(Fraction memory x, Fraction memory y) internal pure returns (bool) {\n    return x.numerator.mul(y.denominator) == y.numerator.mul(x.denominator);\n  }\n\n  /**\n   * @dev Returns a new fraction that is the sum of two rates.\n   * @param x A Fraction struct.\n   * @param y A Fraction struct.\n   * @return x + y\n   */\n  function add(Fraction memory x, Fraction memory y) internal pure returns (Fraction memory) {\n    return\n      Fraction(\n        x.numerator.mul(y.denominator).add(y.numerator.mul(x.denominator)),\n        x.denominator.mul(y.denominator)\n      )\n        .reduce();\n  }\n\n  /**\n   * @dev Returns a new fraction that is the two rates subtracted from each other.\n   * @param x A Fraction struct.\n   * @param y A Fraction struct.\n   * @return x - y\n   */\n  function sub(Fraction memory x, Fraction memory y) internal pure returns (Fraction memory) {\n    require(isGreaterThanOrEqualTo(x, y));\n    return\n      Fraction(\n        x.numerator.mul(y.denominator).sub(y.numerator.mul(x.denominator)),\n        x.denominator.mul(y.denominator)\n      )\n        .reduce();\n  }\n\n  /**\n   * @dev Returns a fraction that is the fraction times a fraction.\n   * @param x A Fraction struct.\n   * @param y A Fraction struct.\n   * @return x * y\n   */\n  function mul(Fraction memory x, Fraction memory y) internal pure returns (Fraction memory) {\n    return Fraction(x.numerator.mul(y.numerator), x.denominator.mul(y.denominator)).reduce();\n  }\n\n  /**\n   * @dev Returns an integer that is the fraction time an integer.\n   * @param x A Fraction struct.\n   * @param y An integer.\n   * @return x * y\n   */\n  function mul(Fraction memory x, uint256 y) internal pure returns (uint256) {\n    return x.numerator.mul(y).div(x.denominator);\n  }\n\n  /**\n   * @dev Returns the inverse of the fraction.\n   * @param x A Fraction struct.\n   * @return 1 / x\n   */\n  function inverse(Fraction memory x) internal pure returns (Fraction memory) {\n    require(x.numerator != 0);\n    return Fraction(x.denominator, x.numerator);\n  }\n\n  /**\n   * @dev Returns a fraction that is the fraction divided by a fraction.\n   * @param x A Fraction struct.\n   * @param y A Fraction struct.\n   * @return x / y\n   */\n  function div(Fraction memory x, Fraction memory y) internal pure returns (Fraction memory) {\n    require(y.numerator != 0);\n    return Fraction(x.numerator.mul(y.denominator), x.denominator.mul(y.numerator));\n  }\n\n  /**\n   * @dev Returns whether fraction \"x\" is greater than fraction \"y\".\n   * @param x A Fraction struct.\n   * @param y A Fraction struct.\n   * @return x > y\n   */\n  function isGreaterThan(Fraction memory x, Fraction memory y) internal pure returns (bool) {\n    return x.numerator.mul(y.denominator) > y.numerator.mul(x.denominator);\n  }\n\n  /**\n   * @dev Returns whether fraction \"x\" is greater than or equal to fraction \"y\".\n   * @param x A Fraction struct.\n   * @param y A Fraction struct.\n   * @return x >= y\n   */\n  function isGreaterThanOrEqualTo(Fraction memory x, Fraction memory y)\n    internal\n    pure\n    returns (bool)\n  {\n    return x.numerator.mul(y.denominator) >= y.numerator.mul(x.denominator);\n  }\n\n  /**\n   * @dev Returns whether fraction \"x\" is less than fraction \"y\".\n   * @param x A Fraction struct.\n   * @param y A Fraction struct.\n   * @return x < y\n   */\n  function isLessThan(Fraction memory x, Fraction memory y) internal pure returns (bool) {\n    return x.numerator.mul(y.denominator) < y.numerator.mul(x.denominator);\n  }\n\n  /**\n   * @dev Returns whether fraction \"x\" is less than or equal to fraction \"y\".\n   * @param x A Fraction struct.\n   * @param y A Fraction struct.\n   * @return x <= y\n   */\n  function isLessThanOrEqualTo(Fraction memory x, Fraction memory y) internal pure returns (bool) {\n    return x.numerator.mul(y.denominator) <= y.numerator.mul(x.denominator);\n  }\n\n  /**\n   * @dev Returns whether fraction \"z\" is between fractions \"x\" and \"y\".\n   * @param z A Fraction struct.\n   * @param x A Fraction struct representing a rate lower than \"y\".\n   * @param y A Fraction struct representing a rate higher than \"x\".\n   * @return x <= z <= y\n   */\n  function isBetween(Fraction memory z, Fraction memory x, Fraction memory y)\n    internal\n    pure\n    returns (bool)\n  {\n    return isLessThanOrEqualTo(x, z) && isLessThanOrEqualTo(z, y);\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/common/Initializable.sol",
      "content": "pragma solidity ^0.5.3;\n\ncontract Initializable {\n  bool public initialized;\n\n  modifier initializer() {\n    require(!initialized);\n    initialized = true;\n    _;\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/common/UsingPrecompiles.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\ncontract UsingPrecompiles {\n  using SafeMath for uint256;\n\n  address constant TRANSFER = address(0xff - 2);\n  address constant FRACTION_MUL = address(0xff - 3);\n  address constant PROOF_OF_POSSESSION = address(0xff - 4);\n  address constant GET_VALIDATOR = address(0xff - 5);\n  address constant NUMBER_VALIDATORS = address(0xff - 6);\n  address constant EPOCH_SIZE = address(0xff - 7);\n  address constant BLOCK_NUMBER_FROM_HEADER = address(0xff - 8);\n  address constant HASH_HEADER = address(0xff - 9);\n  address constant GET_PARENT_SEAL_BITMAP = address(0xff - 10);\n  address constant GET_VERIFIED_SEAL_BITMAP = address(0xff - 11);\n\n  /**\n   * @notice calculate a * b^x for fractions a, b to `decimals` precision\n   * @param aNumerator Numerator of first fraction\n   * @param aDenominator Denominator of first fraction\n   * @param bNumerator Numerator of exponentiated fraction\n   * @param bDenominator Denominator of exponentiated fraction\n   * @param exponent exponent to raise b to\n   * @param _decimals precision\n   * @return numerator/denominator of the computed quantity (not reduced).\n   */\n  function fractionMulExp(\n    uint256 aNumerator,\n    uint256 aDenominator,\n    uint256 bNumerator,\n    uint256 bDenominator,\n    uint256 exponent,\n    uint256 _decimals\n  ) public view returns (uint256, uint256) {\n    require(aDenominator != 0 && bDenominator != 0);\n    uint256 returnNumerator;\n    uint256 returnDenominator;\n    bool success;\n    bytes memory out;\n    (success, out) = FRACTION_MUL.staticcall(\n      abi.encodePacked(aNumerator, aDenominator, bNumerator, bDenominator, exponent, _decimals)\n    );\n    require(\n      success,\n      \"UsingPrecompiles :: fractionMulExp Unsuccessful invocation of fraction exponent\"\n    );\n    returnNumerator = getUint256FromBytes(out, 0);\n    returnDenominator = getUint256FromBytes(out, 32);\n    return (returnNumerator, returnDenominator);\n  }\n\n  /**\n   * @notice Returns the current epoch size in blocks.\n   * @return The current epoch size in blocks.\n   */\n  function getEpochSize() public view returns (uint256) {\n    bytes memory out;\n    bool success;\n    (success, out) = EPOCH_SIZE.staticcall(abi.encodePacked());\n    require(success);\n    return getUint256FromBytes(out, 0);\n  }\n\n  /**\n   * @notice Returns the epoch number at a block.\n   * @param blockNumber Block number where epoch number is calculated.\n   * @return Epoch number.\n   */\n  function getEpochNumberOfBlock(uint256 blockNumber) public view returns (uint256) {\n    uint256 sz = getEpochSize();\n    return blockNumber.sub(1) / sz;\n  }\n\n  /**\n   * @notice Returns the epoch number at a block.\n   * @return Current epoch number.\n   */\n  function getEpochNumber() public view returns (uint256) {\n    return getEpochNumberOfBlock(block.number);\n  }\n\n  /**\n   * @notice Gets a validator address from the current validator set.\n   * @param index Index of requested validator in the validator set.\n   * @return Address of validator at the requested index.\n   */\n  function validatorSignerAddressFromCurrentSet(uint256 index) public view returns (address) {\n    bytes memory out;\n    bool success;\n    (success, out) = GET_VALIDATOR.staticcall(abi.encodePacked(index, uint256(block.number)));\n    require(success);\n    return address(getUint256FromBytes(out, 0));\n  }\n\n  /**\n   * @notice Gets a validator address from the validator set at the given block number.\n   * @param index Index of requested validator in the validator set.\n   * @param blockNumber Block number to retrieve the validator set from.\n   * @return Address of validator at the requested index.\n   */\n  function validatorSignerAddressFromSet(uint256 index, uint256 blockNumber)\n    public\n    view\n    returns (address)\n  {\n    bytes memory out;\n    bool success;\n    (success, out) = GET_VALIDATOR.staticcall(abi.encodePacked(index, blockNumber));\n    require(success);\n    return address(getUint256FromBytes(out, 0));\n  }\n\n  /**\n   * @notice Gets the size of the current elected validator set.\n   * @return Size of the current elected validator set.\n   */\n  function numberValidatorsInCurrentSet() public view returns (uint256) {\n    bytes memory out;\n    bool success;\n    (success, out) = NUMBER_VALIDATORS.staticcall(abi.encodePacked(uint256(block.number)));\n    require(success);\n    return getUint256FromBytes(out, 0);\n  }\n\n  /**\n   * @notice Gets the size of the validator set that must sign the given block number.\n   * @param blockNumber Block number to retrieve the validator set from.\n   * @return Size of the validator set.\n   */\n  function numberValidatorsInSet(uint256 blockNumber) public view returns (uint256) {\n    bytes memory out;\n    bool success;\n    (success, out) = NUMBER_VALIDATORS.staticcall(abi.encodePacked(blockNumber));\n    require(success);\n    return getUint256FromBytes(out, 0);\n  }\n\n  /**\n   * @notice Checks a BLS proof of possession.\n   * @param sender The address signed by the BLS key to generate the proof of possession.\n   * @param blsKey The BLS public key that the validator is using for consensus, should pass proof\n   *   of possession. 48 bytes.\n   * @param blsPop The BLS public key proof-of-possession, which consists of a signature on the\n   *   account address. 96 bytes.\n   * @return True upon success.\n   */\n  function checkProofOfPossession(address sender, bytes memory blsKey, bytes memory blsPop)\n    public\n    view\n    returns (bool)\n  {\n    bool success;\n    (success, ) = PROOF_OF_POSSESSION.staticcall(abi.encodePacked(sender, blsKey, blsPop));\n    return success;\n  }\n\n  /**\n   * @notice Parses block number out of header.\n   * @param header RLP encoded header\n   * @return Block number.\n   */\n  function getBlockNumberFromHeader(bytes memory header) public view returns (uint256) {\n    bytes memory out;\n    bool success;\n    (success, out) = BLOCK_NUMBER_FROM_HEADER.staticcall(abi.encodePacked(header));\n    require(success);\n    return getUint256FromBytes(out, 0);\n  }\n\n  /**\n   * @notice Computes hash of header.\n   * @param header RLP encoded header\n   * @return Header hash.\n   */\n  function hashHeader(bytes memory header) public view returns (bytes32) {\n    bytes memory out;\n    bool success;\n    (success, out) = HASH_HEADER.staticcall(abi.encodePacked(header));\n    require(success);\n    return getBytes32FromBytes(out, 0);\n  }\n\n  /**\n   * @notice Gets the parent seal bitmap from the header at the given block number.\n   * @param blockNumber Block number to retrieve. Must be within 4 epochs of the current number.\n   * @return Bitmap parent seal with set bits at indices correspoinding to signing validators.\n   */\n  function getParentSealBitmap(uint256 blockNumber) public view returns (bytes32) {\n    bytes memory out;\n    bool success;\n    (success, out) = GET_PARENT_SEAL_BITMAP.staticcall(abi.encodePacked(blockNumber));\n    require(success);\n    return getBytes32FromBytes(out, 0);\n  }\n\n  /**\n   * @notice Verifies the BLS signature on the header and returns the seal bitmap.\n   * The validator set used for verification is retrieved based on the parent hash field of the\n   * header.  If the parent hash is not in the blockchain, verification fails.\n   * @param header RLP encoded header\n   * @return Bitmap parent seal with set bits at indices correspoinding to signing validators.\n   */\n  function getVerifiedSealBitmapFromHeader(bytes memory header) public view returns (bytes32) {\n    bytes memory out;\n    bool success;\n    (success, out) = GET_VERIFIED_SEAL_BITMAP.staticcall(abi.encodePacked(header));\n    require(success);\n    return getBytes32FromBytes(out, 0);\n  }\n\n  /**\n   * @notice Converts bytes to uint256.\n   * @param bs byte[] data\n   * @param start offset into byte data to convert\n   * @return uint256 data\n   */\n  function getUint256FromBytes(bytes memory bs, uint256 start) internal pure returns (uint256) {\n    return uint256(getBytes32FromBytes(bs, start));\n  }\n\n  /**\n   * @notice Converts bytes to bytes32.\n   * @param bs byte[] data\n   * @param start offset into byte data to convert\n   * @return bytes32 data\n   */\n  function getBytes32FromBytes(bytes memory bs, uint256 start) internal pure returns (bytes32) {\n    require(bs.length >= start + 32, \"slicing out of range\");\n    bytes32 x;\n    assembly {\n      x := mload(add(bs, add(start, 32)))\n    }\n    return x;\n  }\n}"
    }
  ]
}