{
  "Title": "[H-02] `money-market-contracts/oracle#feed_prices()` delayed transaction may disrupt price feeds",
  "Content": "\n<https://github.com/code-423n4/2022-02-anchor/blob/7af353e3234837979a19ddc8093dc9ad3c63ab6b/contracts/money-market-contracts/contracts/oracle/src/contract.rs#L106-L113>\n\nThe implementation only takes two attributes: `asset` and `price`. And the `last_updated_time` of the record will always be set to the current `block.time`.\n\nThis makes it possible for the price feeds to be disrupted when the network is congested, or the endpoint is down for a while, or the `feeder` bot handled the message queue inappropriately, as a result, the transactions with stale prices get accepted as fresh prices.\n\nSince the price feeds are essential to the protocol, that can result in users' positions being liquidated wrongfully and case fund loss to users.\n\n### Proof of Concept\n\nGiven:\n\n*   `feeder` i connected to an endpoint currently experiencing degraded performance;\n*   ETH price is `$10,000`;\n*   The `max_ltv` ratio of ETH is `60%`.\n\n1.  Alice borrowed `5,000 USDC` with `1 ETH` as collateral;\n2.  ETH price dropped to `$9,000`, to avoid liquidation, Alice repaid `1,000 USD`;\n3.  The price of ETH dropped to `$8,000`; `feeder` tries to `updateMainFeedData()` with the latest price: `$8,000`, however, since the network is congested, the transactions were not get packed timely;\n4.  ETH price rebound to `$10,000`; Alice borrowed another `1,000 USDC`;\n5.  The txs send by `feeder` at step 3 finally got packed, the protocol now believes the price of ETH has suddenly dropped to `$8,000`, as a result, Alice's position got liquidated.\n\n### Recommended Mitigation Steps\n\nChange to:\n\n```solidity\npub fn feed_prices(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    prices: Vec<(String, Decimal256, u64)>,\n) -> Result<Response, ContractError> {\n    let mut attributes = vec![attr(\"action\", \"feed_prices\")];\n    let sender_raw = deps.api.addr_canonicalize(info.sender.as_str())?;\n    for price in prices {\n        let asset: String = price.0;\n        let mut updated_time: u64 = price.2;\n        let price: Decimal256 = price.1;\n\n        // Check feeder permission\n        let feeder = read_feeder(deps.storage, &asset)?;\n        if feeder != sender_raw {\n            return Err(ContractError::Unauthorized {});\n        }\n\n        let config: Config = read_config(deps.storage)?;\n        if env.block.time.seconds() > updated_time {\n            // reject stale price\n            if env.block.time.seconds() - updated_time > config.valid_period {\n                return Err(ContractError::InvalidInputs {});\n            }\n        } else {\n            // reject future timestamp, graceFuturePeriod can be set to 3, which means < 3s is allowed\n            if updated_time - env.block.time.seconds() > config.grace_future_period {\n                return Err(ContractError::InvalidInputs {});\n            }\n            updated_time = env.block.time.seconds();\n        }\n\n        attributes.push(attr(\"asset\", asset.to_string()));\n        attributes.push(attr(\"price\", price.to_string()));\n\n        store_price(\n            deps.storage,\n            &asset,\n            &PriceInfo {\n                last_updated_time: updated_time,\n                price,\n            },\n        )?;\n    }\n\n    Ok(Response::new().add_attributes(attributes))\n}\n```\n\n**[bitn8 (Anchor) disputed and commented](https://github.com/code-423n4/2022-02-anchor-findings/issues/47#issuecomment-1102992100):**\n > We currently have a mean shorting function that pulls multiple price feeds so that if one is stale it gets rejected. \n\n**[Alex the Entreprenerd (triage) commented](https://github.com/code-423n4/2022-02-anchor-findings/issues/47#issuecomment-1205898865):**\n > Seems like the warden has shown a specific scenario, contingent on external conditions.\n> \n> However, from the code, there seems to be no \"mean shorting function\", at least in the code in scope.\n\n**[Albert Chon (judge) commented](https://github.com/code-423n4/2022-02-anchor-findings/issues/47#issuecomment-1251670569):**\n > Agreed with @Alex the Entreprenerd, oracle staleness is still an issue in this version of the code. \n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-02-anchor-contest",
  "Code": [
    {
      "filename": "contracts/money-market-contracts/contracts/oracle/src/contract.rs",
      "content": "use crate::error::ContractError;\nuse crate::state::{\n    read_config, read_feeder, read_price, read_prices, store_config, store_feeder, store_price,\n    Config, PriceInfo,\n};\nuse cosmwasm_bignumber::Decimal256;\n#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\nuse cosmwasm_std::{attr, to_binary, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult};\nuse moneymarket::oracle::{\n    ConfigResponse, ExecuteMsg, FeederResponse, InstantiateMsg, PriceResponse, PricesResponse,\n    PricesResponseElem, QueryMsg,\n};\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    msg: InstantiateMsg,\n) -> StdResult<Response> {\n    store_config(\n        deps.storage,\n        &Config {\n            owner: deps.api.addr_canonicalize(&msg.owner)?,\n            base_asset: msg.base_asset,\n        },\n    )?;\n\n    Ok(Response::default())\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -> Result<Response, ContractError> {\n    match msg {\n        ExecuteMsg::UpdateConfig { owner } => update_config(deps, info, owner),\n        ExecuteMsg::RegisterFeeder { asset, feeder } => register_feeder(deps, info, asset, feeder),\n        ExecuteMsg::FeedPrice { prices } => feed_prices(deps, env, info, prices),\n    }\n}\n\npub fn update_config(\n    deps: DepsMut,\n    info: MessageInfo,\n    owner: Option<String>,\n) -> Result<Response, ContractError> {\n    let mut config: Config = read_config(deps.storage)?;\n    if deps.api.addr_canonicalize(info.sender.as_str())? != config.owner {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    if let Some(owner) = owner {\n        config.owner = deps.api.addr_canonicalize(&owner)?;\n    }\n\n    store_config(deps.storage, &config)?;\n    Ok(Response::default())\n}\n\npub fn register_feeder(\n    deps: DepsMut,\n    info: MessageInfo,\n    asset: String,\n    feeder: String,\n) -> Result<Response, ContractError> {\n    let config: Config = read_config(deps.storage)?;\n    if deps.api.addr_canonicalize(info.sender.as_str())? != config.owner {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    store_feeder(deps.storage, &asset, &deps.api.addr_canonicalize(&feeder)?)?;\n\n    Ok(Response::new().add_attributes(vec![\n        attr(\"action\", \"register_feeder\"),\n        attr(\"asset\", asset),\n        attr(\"feeder\", feeder),\n    ]))\n}\n\npub fn feed_prices(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    prices: Vec<(String, Decimal256)>,\n) -> Result<Response, ContractError> {\n    let mut attributes = vec![attr(\"action\", \"feed_prices\")];\n    let sender_raw = deps.api.addr_canonicalize(info.sender.as_str())?;\n    for price in prices {\n        let asset: String = price.0;\n        let price: Decimal256 = price.1;\n\n        // Check feeder permission\n        let feeder = read_feeder(deps.storage, &asset)?;\n        if feeder != sender_raw {\n            return Err(ContractError::Unauthorized {});\n        }\n\n        attributes.push(attr(\"asset\", asset.to_string()));\n        attributes.push(attr(\"price\", price.to_string()));\n\n        store_price(\n            deps.storage,\n            &asset,\n            &PriceInfo {\n                last_updated_time: env.block.time.seconds(),\n                price,\n            },\n        )?;\n    }\n\n    Ok(Response::new().add_attributes(attributes))\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -> StdResult<Binary> {\n    match msg {\n        QueryMsg::Config {} => to_binary(&query_config(deps)?),\n        QueryMsg::Feeder { asset } => to_binary(&query_feeder(deps, asset)?),\n        QueryMsg::Price { base, quote } => to_binary(&query_price(deps, base, quote)?),\n        QueryMsg::Prices { start_after, limit } => {\n            to_binary(&query_prices(deps, start_after, limit)?)\n        }\n    }\n}\n\nfn query_config(deps: Deps) -> StdResult<ConfigResponse> {\n    let state = read_config(deps.storage)?;\n    let resp = ConfigResponse {\n        owner: deps.api.addr_humanize(&state.owner)?.to_string(),\n        base_asset: state.base_asset,\n    };\n\n    Ok(resp)\n}\n\nfn query_feeder(deps: Deps, asset: String) -> StdResult<FeederResponse> {\n    let feeder = read_feeder(deps.storage, &asset)?;\n    let resp = FeederResponse {\n        asset,\n        feeder: deps.api.addr_humanize(&feeder)?.to_string(),\n    };\n\n    Ok(resp)\n}\n\nfn query_price(deps: Deps, base: String, quote: String) -> StdResult<PriceResponse> {\n    let config: Config = read_config(deps.storage)?;\n    let quote_price = if config.base_asset == quote {\n        PriceInfo {\n            price: Decimal256::one(),\n            last_updated_time: 9999999999,\n        }\n    } else {\n        read_price(deps.storage, &quote)?\n    };\n\n    let base_price = if config.base_asset == base {\n        PriceInfo {\n            price: Decimal256::one(),\n            last_updated_time: 9999999999,\n        }\n    } else {\n        read_price(deps.storage, &base)?\n    };\n\n    Ok(PriceResponse {\n        rate: base_price.price / quote_price.price,\n        last_updated_base: base_price.last_updated_time,\n        last_updated_quote: quote_price.last_updated_time,\n    })\n}\n\nfn query_prices(\n    deps: Deps,\n    start_after: Option<String>,\n    limit: Option<u32>,\n) -> StdResult<PricesResponse> {\n    let prices: Vec<PricesResponseElem> = read_prices(deps.storage, start_after, limit)?;\n    Ok(PricesResponse { prices })\n}"
    }
  ]
}