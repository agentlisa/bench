{
  "Title": "M-5: SwapHandler.sol: Check that collateral token cannot be swapped is insufficient for tokens with multiple addresses",
  "Content": "# Issue M-5: SwapHandler.sol: Check that collateral token cannot be swapped is insufficient for tokens with multiple addresses \n\nSource: https://github.com/sherlock-audit/2023-03-taurus-judging/issues/31 \n\n## Found by \nroguereddwarf\n\n## Summary\nAccording to the contest page `any non-rebasing` ERC20 token is supposed to be supported.\n\nThe `SwapHandler.swapForTau` function checks that the `collateralToken` cannot be sent to the `SwapAdapter` for trading:\n\nhttps://github.com/sherlock-audit/2023-03-taurus/blob/main/taurus-contracts/contracts/Vault/SwapHandler.sol#L54-L56\n## Vulnerability Detail\nThere exist however ERC20 tokens that have more than one address. In case of such a token, the above check is not sufficient. The token could be swapped anyway by using a different address.\n\n## Impact\nThe check that collateral cannot be swapped can be bypassed for tokens with multiple addresses.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-03-taurus/blob/main/taurus-contracts/contracts/Vault/SwapHandler.sol#L45-L101\n\n## Tool used\nManual Review\n\n## Recommendation\nCompare the balance of the collateral before and after sending tokens to the SwapAdapter and make sure it hasn't changed. Or implement a whitelist for tokens that can be swapped.\n\n## Discussion\n\n**Sierraescape**\n\nTokens with multiple addresses are pretty rare, so we're just going to note that the vault doesn't allow such tokens as collateral, and create wrappers for them if necessary.\n\nhttps://github.com/protokol/taurus-contracts/pull/120\n\n**spyrosonic10**\n\nEscalate for 10 USDC\n\nToken with different addresses is very very rare.  Almost every protocols in Defi operating on assumption of token with single address.\nThis issue does not qualify as High/Medium.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> Token with different addresses is very very rare.  Almost every protocols in Defi operating on assumption of token with single address.\n> This issue does not qualify as High/Medium.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**roguereddwarf**\n\nEscalate for 10 USDC\n\nDisagree with previous escalation.\nWhile these tokens are rare they do exist and as pointed out in my report `any non-rebasing` ERC20 is supposed to be supported which clearly includes tokens with multiple addresses.\nSo I think this is a valid medium.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> Disagree with previous escalation.\n> While these tokens are rare they do exist and as pointed out in my report `any non-rebasing` ERC20 is supposed to be supported which clearly includes tokens with multiple addresses.\n> So I think this is a valid medium.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted\n\nConsidering this a valid medium.\nAs pointed out in the second escalation, even though these tokens are rare the issue can still be considered valid medium. \n\nNote: Going forward, Sherlock team will add additional clarity on such rare token cases in the README. \n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Considering this a valid medium.\n> As pointed out in the second escalation, even though these tokens are rare the issue can still be considered valid medium. \n> \n> Note: Going forward, Sherlock team will add additional clarity on such rare token cases in the README. \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/45",
  "Code": [
    {
      "filename": "taurus-contracts/contracts/Vault/SwapHandler.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { Controller } from \"../Controller/Controller.sol\";\nimport { BaseSwapAdapter } from \"../SwapAdapters/BaseSwapAdapter.sol\";\nimport { FeeMapping } from \"./FeeMapping.sol\";\nimport { PriceOracleManager } from \"../Oracle/PriceOracleManager.sol\";\nimport { SwapAdapterRegistry } from \"../Controller/SwapAdapterRegistry.sol\";\nimport { TauDripFeed } from \"./TauDripFeed.sol\";\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ERC20Burnable } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// Libraries\nimport { Constants } from \"../Libs/Constants.sol\";\n\nabstract contract SwapHandler is FeeMapping, TauDripFeed {\n    using SafeERC20 for IERC20;\n\n    // Errors\n    error notContract();\n    error oracleCorrupt();\n    error tokenCannotBeSwapped();\n    error tooMuchSlippage(uint256 actualTauReturned, uint256 _minTauReturned);\n    error unregisteredSwapAdapter();\n    error zeroAmount();\n\n    event Swap(address indexed fromToken, uint256 feesToProtocol, uint256 fromAmount, uint256 tauReturned);\n\n    /**\n     * @dev function called as part of the yield pull process. This will fetch swap modules from the Controller, use them \n        to handle a swap from vault yield to tau, then validate that the swap did not encounter too much slippage.\n     * @param _yieldTokenAddress is the address of the token to be swapped. Must be a yield token, so cannot be the vault's collateral token or tau.\n     * @param _yieldTokenAmount is the amount of yield token. Some will be transferred to the FeeSplitter for use by the protocol. The rest will be swapped for tau.\n     * note that slippage parameters must be built based on the amount to be swapped, not based on _yieldTokenAmount above (some of which will not be swapped).\n     * @param _swapAdapterHash is the hash of the swap adapter to be used, i.e. keccak256(\"UniswapSwapAdapter\") for the UniswapSwapAdapter.\n     * @param _rewardProportion refers to the proportion of received tau which will be rewarded (i.e. pay back user loans). The remainder will simply be burned without\n     * being distributed to users. This undistributed tau cancels out bad debt in the vault. All vaults retain a growing reserve of yield to ensure bad debt\n     * will always be covered.\n     * _rewardProportion has a precision of 1e18. If _rewardProportion = 1e18, all tau will be disbursed to users. If _rewardProportion = 0, none of the burned tau will be disbursed.\n     * @param _swapParams is the params to be passed to the SwapAdapter.\n     * note that this function may only be called by a registered keeper.\n     */\n    function swapForTau(\n        address _yieldTokenAddress,\n        uint256 _yieldTokenAmount,\n        uint256 _minTauReturned,\n        bytes32 _swapAdapterHash,\n        uint256 _rewardProportion,\n        bytes calldata _swapParams\n    ) external onlyKeeper whenNotPaused {\n        // Ensure keeper is allowed to swap this token\n        if (_yieldTokenAddress == collateralToken) {\n            revert tokenCannotBeSwapped();\n        }\n\n        if (_yieldTokenAmount == 0) {\n            revert zeroAmount();\n        }\n\n        // Get and validate swap adapter address\n        address swapAdapterAddress = SwapAdapterRegistry(controller).swapAdapters(_swapAdapterHash);\n        if (swapAdapterAddress == address(0)) {\n            // The given hash has not yet been approved as a swap adapter.\n            revert unregisteredSwapAdapter();\n        }\n\n        // Calculate portion of tokens which will be swapped for TAU and disbursed to the vault, and portion which will be sent to the protocol.\n        uint256 protocolFees = (feeMapping[Constants.GLP_VAULT_PROTOCOL_FEE] * _yieldTokenAmount) /\n            Constants.PERCENT_PRECISION;\n        uint256 swapAmount = _yieldTokenAmount - protocolFees;\n\n        // Transfer tokens to swap adapter\n        IERC20(_yieldTokenAddress).safeTransfer(swapAdapterAddress, swapAmount);\n\n        // Call swap function, which will transfer resulting tau back to this contract and return the amount transferred.\n        // Note that this contract does not check that the swap adapter has transferred the correct amount of tau. This check\n        // is handled by the swap adapter, and for this reason any registered swap adapter must be a completely trusted contract.\n        uint256 tauReturned = BaseSwapAdapter(swapAdapterAddress).swap(tau, _swapParams);\n\n        if (tauReturned < _minTauReturned) {\n            revert tooMuchSlippage(tauReturned, _minTauReturned);\n        }\n\n        // Burn received Tau\n        ERC20Burnable(tau).burn(tauReturned);\n\n        // Add Tau rewards to withheldTAU to avert sandwich attacks\n        _disburseTau();\n        _withholdTau((tauReturned * _rewardProportion) / Constants.PERCENT_PRECISION);\n\n        // Send protocol fees to FeeSplitter\n        IERC20(_yieldTokenAddress).safeTransfer(\n            Controller(controller).addressMapper(Constants.FEE_SPLITTER),\n            protocolFees\n        );\n\n        // Emit event\n        emit Swap(_yieldTokenAddress, protocolFees, swapAmount, tauReturned);\n    }\n\n    uint256[50] private __gap;\n}"
    },
    {
      "filename": "taurus-contracts/contracts/Vault/SwapHandler.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { Controller } from \"../Controller/Controller.sol\";\nimport { BaseSwapAdapter } from \"../SwapAdapters/BaseSwapAdapter.sol\";\nimport { FeeMapping } from \"./FeeMapping.sol\";\nimport { PriceOracleManager } from \"../Oracle/PriceOracleManager.sol\";\nimport { SwapAdapterRegistry } from \"../Controller/SwapAdapterRegistry.sol\";\nimport { TauDripFeed } from \"./TauDripFeed.sol\";\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ERC20Burnable } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// Libraries\nimport { Constants } from \"../Libs/Constants.sol\";\n\nabstract contract SwapHandler is FeeMapping, TauDripFeed {\n    using SafeERC20 for IERC20;\n\n    // Errors\n    error notContract();\n    error oracleCorrupt();\n    error tokenCannotBeSwapped();\n    error tooMuchSlippage(uint256 actualTauReturned, uint256 _minTauReturned);\n    error unregisteredSwapAdapter();\n    error zeroAmount();\n\n    event Swap(address indexed fromToken, uint256 feesToProtocol, uint256 fromAmount, uint256 tauReturned);\n\n    /**\n     * @dev function called as part of the yield pull process. This will fetch swap modules from the Controller, use them \n        to handle a swap from vault yield to tau, then validate that the swap did not encounter too much slippage.\n     * @param _yieldTokenAddress is the address of the token to be swapped. Must be a yield token, so cannot be the vault's collateral token or tau.\n     * @param _yieldTokenAmount is the amount of yield token. Some will be transferred to the FeeSplitter for use by the protocol. The rest will be swapped for tau.\n     * note that slippage parameters must be built based on the amount to be swapped, not based on _yieldTokenAmount above (some of which will not be swapped).\n     * @param _swapAdapterHash is the hash of the swap adapter to be used, i.e. keccak256(\"UniswapSwapAdapter\") for the UniswapSwapAdapter.\n     * @param _rewardProportion refers to the proportion of received tau which will be rewarded (i.e. pay back user loans). The remainder will simply be burned without\n     * being distributed to users. This undistributed tau cancels out bad debt in the vault. All vaults retain a growing reserve of yield to ensure bad debt\n     * will always be covered.\n     * _rewardProportion has a precision of 1e18. If _rewardProportion = 1e18, all tau will be disbursed to users. If _rewardProportion = 0, none of the burned tau will be disbursed.\n     * @param _swapParams is the params to be passed to the SwapAdapter.\n     * note that this function may only be called by a registered keeper.\n     */\n    function swapForTau(\n        address _yieldTokenAddress,\n        uint256 _yieldTokenAmount,\n        uint256 _minTauReturned,\n        bytes32 _swapAdapterHash,\n        uint256 _rewardProportion,\n        bytes calldata _swapParams\n    ) external onlyKeeper whenNotPaused {\n        // Ensure keeper is allowed to swap this token\n        if (_yieldTokenAddress == collateralToken) {\n            revert tokenCannotBeSwapped();\n        }\n\n        if (_yieldTokenAmount == 0) {\n            revert zeroAmount();\n        }\n\n        // Get and validate swap adapter address\n        address swapAdapterAddress = SwapAdapterRegistry(controller).swapAdapters(_swapAdapterHash);\n        if (swapAdapterAddress == address(0)) {\n            // The given hash has not yet been approved as a swap adapter.\n            revert unregisteredSwapAdapter();\n        }\n\n        // Calculate portion of tokens which will be swapped for TAU and disbursed to the vault, and portion which will be sent to the protocol.\n        uint256 protocolFees = (feeMapping[Constants.GLP_VAULT_PROTOCOL_FEE] * _yieldTokenAmount) /\n            Constants.PERCENT_PRECISION;\n        uint256 swapAmount = _yieldTokenAmount - protocolFees;\n\n        // Transfer tokens to swap adapter\n        IERC20(_yieldTokenAddress).safeTransfer(swapAdapterAddress, swapAmount);\n\n        // Call swap function, which will transfer resulting tau back to this contract and return the amount transferred.\n        // Note that this contract does not check that the swap adapter has transferred the correct amount of tau. This check\n        // is handled by the swap adapter, and for this reason any registered swap adapter must be a completely trusted contract.\n        uint256 tauReturned = BaseSwapAdapter(swapAdapterAddress).swap(tau, _swapParams);\n\n        if (tauReturned < _minTauReturned) {\n            revert tooMuchSlippage(tauReturned, _minTauReturned);\n        }\n\n        // Burn received Tau\n        ERC20Burnable(tau).burn(tauReturned);\n\n        // Add Tau rewards to withheldTAU to avert sandwich attacks\n        _disburseTau();\n        _withholdTau((tauReturned * _rewardProportion) / Constants.PERCENT_PRECISION);\n\n        // Send protocol fees to FeeSplitter\n        IERC20(_yieldTokenAddress).safeTransfer(\n            Controller(controller).addressMapper(Constants.FEE_SPLITTER),\n            protocolFees\n        );\n\n        // Emit event\n        emit Swap(_yieldTokenAddress, protocolFees, swapAmount, tauReturned);\n    }\n\n    uint256[50] private __gap;\n}"
    }
  ]
}