{
  "Title": "[L15] Failure of ecrecover function does not revert",
  "Content": "The [`ecrecover` function](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/Signatures.sol#L34) is called within the [`getSignerOfMessageHash` function](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/Signatures.sol#L27), which is in turn called by the [`getSignerOfAddress` function](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/Signatures.sol#L11). The `ecrecover` function returns the signer of a message, given the correct parameters `v`, `r`, and `s`. In the event of an invalid combination of parameters, the `ecrecover` function will return `address(0)`. If misapplied, the results of `getSignerOfAddress` and `getSignerOfMessageHash` could make it appear that a valid signature of the `address(0)` was produced.\n\n\nCurrently, if a user calls the [`transfer` function of the `Escrow` contract](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Escrow.sol#L84) to lock some payment with `paymentId` set to `address(0)`, any user can then call [`withdraw`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Escrow.sol#L127) with `paymentId` set to `address(0)` and an invalid signature, and they will receive that escrowed payment.\n\n\nIf not used carefully, `ecrecover` could potentially give users some appearance of controlling `address(0)`. Considering that the VM is assigned to `address(0)`, a signature that appears to come from this address could have significant consequences. On the other hand, we should be able to safely assume that the private key for `address(0)` is never knowable, and therefore a valid signature from it is never producible.\n\n\nConsider adding a `require` statement that ensures that the result of `ecrecover != 0`, so that in the future, any uses of it do not mistakenly give the impression that a valid signature of `address(0)` was produced. \n\n\n***Update:** Fixed in [pull request #2892](https://github.com/celo-org/celo-monorepo/pull/2892). `ecrecover` now reverts if the signer address is 0.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/common/Signatures.sol",
      "content": "pragma solidity ^0.5.3;\n\nlibrary Signatures {\n  /**\n  * @notice Given a signed address, returns the signer of the address.\n  * @param message The address that was signed.\n  * @param v The recovery id of the incoming ECDSA signature.\n  * @param r Output value r of the ECDSA signature.\n  * @param s Output value s of the ECDSA signature.\n  */\n  function getSignerOfAddress(address message, uint8 v, bytes32 r, bytes32 s)\n    public\n    pure\n    returns (address)\n  {\n    bytes32 hash = keccak256(abi.encodePacked(message));\n    return getSignerOfMessageHash(hash, v, r, s);\n  }\n\n  /**\n  * @notice Given a signed address, returns the signer of the address.\n  * @param messageHash The hash of a message.\n  * @param v The recovery id of the incoming ECDSA signature.\n  * @param r Output value r of the ECDSA signature.\n  * @param s Output value s of the ECDSA signature.\n  */\n  function getSignerOfMessageHash(bytes32 messageHash, uint8 v, bytes32 r, bytes32 s)\n    public\n    pure\n    returns (address)\n  {\n    bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n    bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, messageHash));\n    return ecrecover(prefixedHash, v, r, s);\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/identity/Escrow.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\n\nimport \"./interfaces/IAttestations.sol\";\nimport \"./interfaces/IEscrow.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/Signatures.sol\";\n\ncontract Escrow is IEscrow, ReentrancyGuard, Ownable, Initializable, UsingRegistry {\n  using SafeMath for uint256;\n\n  event Transfer(\n    address indexed from,\n    bytes32 indexed identifier,\n    address indexed token,\n    uint256 value,\n    address paymentId,\n    uint256 minAttestations\n  );\n\n  event Withdrawal(\n    bytes32 indexed identifier,\n    address indexed to,\n    address indexed token,\n    uint256 value,\n    address paymentId\n  );\n\n  event Revocation(\n    bytes32 indexed identifier,\n    address indexed by,\n    address indexed token,\n    uint256 value,\n    address paymentId\n  );\n\n  struct EscrowedPayment {\n    bytes32 recipientIdentifier;\n    address sender;\n    address token;\n    uint256 value;\n    uint256 sentIndex; // Location of this payment in sender's list of sent payments.\n    uint256 receivedIndex; // Location of this payment in receivers's list of received payments.\n    uint256 timestamp;\n    uint256 expirySeconds;\n    uint256 minAttestations;\n  }\n\n  // Maps unique payment IDs to escrowed payments.\n  // These payment IDs are the temporary wallet addresses created with the escrowed payments.\n  mapping(address => EscrowedPayment) public escrowedPayments;\n\n  // Maps receivers' identifiers to a list of received escrowed payment IDs.\n  mapping(bytes32 => address[]) public receivedPaymentIds;\n\n  // Maps senders' addresses to a list of sent escrowed payment IDs.\n  mapping(address => address[]) public sentPaymentIds;\n\n  function initialize(address registryAddress) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n  }\n\n  /**\n  * @notice Transfer tokens to a specific user. Supports both identity with privacy (an empty\n  *         identifier and 0 minAttestations) and without (with identifier and minAttestations).\n  * @param identifier The hashed identifier of a user to transfer to.\n  * @param token The token to be transferred.\n  * @param value The amount to be transferred.\n  * @param expirySeconds The number of seconds before the sender can revoke the payment.\n  * @param paymentId The address of the temporary wallet associated with this payment. Users must\n  *        prove ownership of the corresponding private key to withdraw from escrow.\n  * @param minAttestations The min number of attestations required to withdraw the payment.\n  * @dev Throws if 'token' or 'value' is 0.\n  * @dev msg.sender needs to have already approved this contract to transfer\n  * @dev If no identifier is given, then minAttestations must be 0.\n  */\n  // solhint-disable-next-line no-simple-event-func-name\n  function transfer(\n    bytes32 identifier,\n    address token,\n    uint256 value,\n    uint256 expirySeconds,\n    address paymentId,\n    uint256 minAttestations\n  ) external nonReentrant returns (bool) {\n    require(token != address(0) && value > 0 && expirySeconds > 0, \"Invalid transfer inputs.\");\n    require(\n      !(identifier.length <= 0 && !(minAttestations == 0)),\n      \"Invalid privacy inputs: Can't require attestations if no identifier\"\n    );\n\n    uint256 sentIndex = sentPaymentIds[msg.sender].push(paymentId).sub(1);\n    uint256 receivedIndex = receivedPaymentIds[identifier].push(paymentId).sub(1);\n\n    EscrowedPayment storage newPayment = escrowedPayments[paymentId];\n    newPayment.recipientIdentifier = identifier;\n    newPayment.sender = msg.sender;\n    newPayment.token = token;\n    newPayment.value = value;\n    newPayment.sentIndex = sentIndex;\n    newPayment.receivedIndex = receivedIndex;\n    // solhint-disable-next-line not-rely-on-time\n    newPayment.timestamp = now;\n    newPayment.expirySeconds = expirySeconds;\n    newPayment.minAttestations = minAttestations;\n\n    require(ERC20(token).transferFrom(msg.sender, address(this), value), \"Transfer unsuccessful.\");\n    emit Transfer(msg.sender, identifier, token, value, paymentId, minAttestations);\n    return true;\n  }\n\n  /**\n  * @notice Withdraws tokens for a verified user.\n  * @param paymentId The ID for the EscrowedPayment struct that contains all relevant information.\n  * @param v The recovery id of the incoming ECDSA signature.\n  * @param r Output value r of the ECDSA signature.\n  * @param s Output value s of the ECDSA signature.\n  * @dev Throws if 'token' or 'value' is 0.\n  * @dev Throws if msg.sender does not prove ownership of the withdraw key.\n  */\n  function withdraw(address paymentId, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    address signer = Signatures.getSignerOfAddress(msg.sender, v, r, s);\n    require(signer == paymentId, \"Failed to prove ownership of the withdraw key\");\n    EscrowedPayment memory payment = escrowedPayments[paymentId];\n    require(payment.token != address(0) && payment.value > 0, \"Invalid withdraw value.\");\n\n    if (payment.recipientIdentifier.length > 0) {\n      IAttestations attestations = IAttestations(registry.getAddressFor(ATTESTATIONS_REGISTRY_ID));\n      (uint64 completedAttestations, ) = attestations.getAttestationStats(\n        payment.recipientIdentifier,\n        msg.sender\n      );\n      require(\n        uint256(completedAttestations) >= payment.minAttestations,\n        \"This account does not have enough attestations to withdraw this payment.\"\n      );\n    }\n\n    deletePayment(paymentId);\n\n    require(ERC20(payment.token).transfer(msg.sender, payment.value), \"Transfer not successful.\");\n\n    emit Withdrawal(\n      payment.recipientIdentifier,\n      payment.sender,\n      payment.token,\n      payment.value,\n      paymentId\n    );\n\n    return true;\n  }\n\n  /**\n  * @notice Revokes tokens for a sender who is redeeming a payment after it has expired.\n  * @param paymentId The ID for the EscrowedPayment struct that contains all relevant information.\n  * @dev Throws if 'token' or 'value' is 0.\n  * @dev Throws if msg.sender is not the sender of payment.\n  * @dev Throws if redeem time hasn't been reached yet.\n  */\n  function revoke(address paymentId) external nonReentrant returns (bool) {\n    EscrowedPayment memory payment = escrowedPayments[paymentId];\n    require(payment.sender == msg.sender, \"Only sender of payment can attempt to revoke payment.\");\n    require(\n      // solhint-disable-next-line not-rely-on-time\n      now >= (payment.timestamp.add(payment.expirySeconds)),\n      \"Transaction not redeemable for sender yet.\"\n    );\n\n    deletePayment(paymentId);\n\n    require(ERC20(payment.token).transfer(msg.sender, payment.value), \"Transfer not successful.\");\n\n    emit Revocation(\n      payment.recipientIdentifier,\n      payment.sender,\n      payment.token,\n      payment.value,\n      paymentId\n    );\n\n    return true;\n\n  }\n\n  /**\n  * @notice Gets array of all Escrowed Payments received by identifier.\n  * @param identifier The hash of an identifier of the receiver of the escrowed payment.\n  * @return An array containing all the IDs of the Escrowed Payments that were received\n  * by the specified receiver.\n  */\n  function getReceivedPaymentIds(bytes32 identifier) external view returns (address[] memory) {\n    return receivedPaymentIds[identifier];\n  }\n\n  /**\n  * @notice Gets array of all Escrowed Payment IDs sent by sender.\n  * @param sender The address of the sender of the escrowed payments.\n  * @return An array containing all the IDs of the Escrowed Payments that were sent by the\n  * specified sender.\n  */\n  function getSentPaymentIds(address sender) external view returns (address[] memory) {\n    return sentPaymentIds[sender];\n  }\n\n  /**\n  * @notice Deletes the payment from its receiver's and sender's lists of payments,\n  * and zeroes out all the data in the struct.\n  * @param paymentId The ID of the payment to be deleted.\n  */\n  function deletePayment(address paymentId) private {\n    EscrowedPayment storage payment = escrowedPayments[paymentId];\n    address[] storage received = receivedPaymentIds[payment.recipientIdentifier];\n    address[] storage sent = sentPaymentIds[payment.sender];\n\n    escrowedPayments[received[received.length - 1]].receivedIndex = payment.receivedIndex;\n    received[payment.receivedIndex] = received[received.length - 1];\n    received.length = received.length.sub(1);\n\n    escrowedPayments[sent[sent.length - 1]].sentIndex = payment.sentIndex;\n    sent[payment.sentIndex] = sent[sent.length - 1];\n    sent.length = sent.length.sub(1);\n\n    delete escrowedPayments[paymentId];\n  }\n}"
    }
  ]
}